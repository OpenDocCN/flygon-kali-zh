- en: '*Chapter 11*: Reflection and Dynamic Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：反射和动态编程'
- en: In the previous chapter, we looked at functional programming, lambda expressions,
    and the features they enable, such as **Language Integrated Query (LINQ)**. This
    chapter is focused on reflection services and dynamic programming. You will learn
    what reflection is and how you can get information about types at runtime, as
    well as how code and resources are stored in assemblies and how these can be loaded
    dynamically at runtime both for reflection and code execution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了函数式编程、lambda表达式以及它们所支持的功能，比如**语言集成查询（LINQ）**。本章侧重于反射服务和动态编程。您将学习什么是反射，以及如何在运行时获取有关类型的信息，以及代码和资源如何存储在程序集中，以及如何在运行时动态加载它们，无论是用于反射还是代码执行。
- en: This is key for building applications that support extension in the form of
    add-ons or plugins. We will see what attributes are and what role they play in
    reflection. Another important topic that we will address in this chapter is dynamic
    programming and the **Dynamic Language Runtime** that enables dynamic languages
    to run on the **Common Language Runtime (CLR**) and to add dynamic features to
    statically typed languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于构建支持插件或附加组件形式的扩展的应用程序至关重要。我们将看到属性是什么，以及它们在反射中扮演的角色。本章中我们将讨论的另一个重要主题是动态编程和**动态语言运行时**，它使动态语言能够在**公共语言运行时（CLR）**上运行，并为静态类型语言添加动态特性。
- en: 'The topics we will address in this chapter are the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Understanding reflection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解反射
- en: Dynamically loading assemblies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载程序集
- en: Understanding late binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解后期绑定
- en: Using the `dynamic` type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dynamic`类型
- en: Attributes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: By the end of this chapter, you will have a good understanding of reflection,
    attributes, and their use in reflection, as well as assembly loading and code
    execution. On the other hand, you will also learn about the `dynamic` type and
    be able to interoperate with dynamic languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对反射、属性及其在反射中的使用，以及程序集加载和代码执行有很好的理解。另一方面，您还将学习关于`dynamic`类型，并能够与动态语言进行交互。
- en: Understanding reflection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解反射
- en: 'The unit of deployment in .NET is the assembly. An assembly is a file (either
    an executable or a dynamic-linked library) that contains `ildasm.exe` (`ilspy.exe`
    (an open-source project); or others allow you to view the content of the assembly.
    The following is a screenshot of `ildasm.exe` that shows the `chapter_11_01.dll`
    assembly, available with the source code of this book:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的部署单元是程序集。程序集是一个文件（可以是可执行文件或动态链接库），其中包含`ildasm.exe`（`ilspy.exe`（一个开源项目）；或其他允许您查看程序集内容的工具。以下是`ildasm.exe`的屏幕截图，显示了本书源代码中提供的`chapter_11_01.dll`程序集：
- en: '![Figure 11.1 - Disassembled source code for chapter 11 assembly.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - chapter 11程序集的反汇编源代码。'
- en: '](img/Figure_11.1_B12346.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B12346.jpg)'
- en: Figure 11.1 – Disassembled source code for chapter_11_01 assembly
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - chapter_11_01程序集的反汇编源代码
- en: '**Reflection** is the process of runtime type discovery and the ability to
    make changes to them. This means that we can retrieve information about types,
    their members, and attributes at runtime. This brings several important benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**是在运行时发现类型并对其进行更改的过程。这意味着我们可以在运行时检索有关类型、其成员和属性的信息。这带来了一些重要的好处：'
- en: The ability to load assemblies dynamically during runtime (late binding), inspect
    types, and execute code makes it easy to build extensible applications. An application
    can define functionalities through interfaces and base classes, which would then
    be implemented or extended in separate modules (plugins or add-ons) that could
    be loaded and executed at runtime based on various conditions.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时动态加载程序集（后期绑定）、检查类型和执行代码的能力使得构建可扩展应用程序变得容易。应用程序可以通过接口和基类定义功能，然后在单独的模块（插件或附加组件）中实现或扩展这些功能，并根据各种条件在运行时加载和执行它们。
- en: Attributes, which we will later see in this chapter, make it possible to provide
    meta-information about types, methods, properties, and others in a declarative
    way. By being able to read these attributes at runtime, a system can change their
    behavior. Tools, for instance, could warn that a method is used differently than
    intended (such as in the case of obsolete methods) or execute them in a particular
    way. Testing frameworks (we will look at some in the final chapter) use this functionality
    extensively.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性，我们稍后将在本章中看到，使得以声明方式提供有关类型、方法、属性和其他内容的元信息成为可能。通过能够在运行时读取这些属性，系统可以改变它们的行为。例如，工具可以警告某个方法的使用方式与预期不同（比如过时方法的情况），或以特定方式执行它们。测试框架（我们将在最后一章中看到一些）广泛使用了这种功能。
- en: It provides the ability to execute types and members that are private or have
    other access levels that make them inaccessible otherwise. This is, again, very
    handy for testing frameworks.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了执行私有或其他访问级别的类型和成员的能力，否则这些类型和成员将无法访问。这对于测试框架来说非常方便。
- en: It allows modifying existing types or creating entirely new types at runtime
    and executing code using them.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在运行时修改现有类型或创建全新类型，并使用它们执行代码。
- en: 'Reflection also has some drawbacks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 反射也有一些缺点：
- en: It incurs an overhead that can degrade performance. Loading, discovering, and
    executing code at runtime is slower and may prevent optimizations.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会产生一个可能降低性能的开销。在运行时加载、发现和执行代码会更慢，可能会阻止优化。
- en: It exposes the internals of types because it allows introspection on all types
    and members regardless of their access level.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它暴露了类型的内部，因为它允许对所有类型和成员进行内省，而不考虑它们的访问级别。
- en: 'The .NET reflection services allow you to discover, using APIs from the `System.Reflection`
    namespace, the same information that you can see with the tools mentioned earlier.
    The key to this process is the type called `System.Type`, which contains members
    that expose all of a type''s metadata. This is done with the help of other types
    from the `System.Reflection` namespace, some of which are listed in the following
    table:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: .NET反射服务允许您使用`System.Reflection`命名空间中的API发现与前面提到的工具中看到的相同的信息。这个过程的关键是名为`System.Type`的类型，其中包含公开所有类型元数据的成员。这是通过`System.Reflection`命名空间中的其他类型的帮助完成的，其中一些列在以下表中：
- en: '![](img/Chapter_11_Table_1_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_11_Table_1_01.jpg)'
- en: 'Some of the most important members of the `System.Type` class are listed in
    the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Type`类的一些最重要的成员列在以下表中：'
- en: '![](img/Chapter_11_Table_2_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_11_Table_2_01.jpg)'
- en: 'There are several ways to retrieve an instance of `System.Type` to access type
    metadata at runtime; here are a few:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以在运行时检索`System.Type`的实例以访问类型元数据；以下是其中的一些：
- en: 'Using the `GetType()` method of the `System.Object` type. Since this is the
    base class for all value and reference types, you can call with an instance of
    any type:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`System.Object`类型的`GetType()`方法。由于这是所有值类型和引用类型的基类，您可以使用任何类型的实例调用：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the `GetType()` static method from `System.Type`. There are many overloads
    that allow you to specify the name and various parameters:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`System.Type`的`GetType()`静态方法。有许多重载，允许您指定名称和各种参数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the C# `typeof` operator:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#的`typeof`运算符：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see how we can use reflection by looking at an actual example. We will
    consider the following `Engine` type, which has several properties, a constructor,
    and a couple of methods that change the status of the engine (started or stopped):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过查看一个实际的例子来使用反射。我们将考虑以下`Engine`类型，它具有几个属性、一个构造函数和一对改变引擎状态（启动或停止）的方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will build a small program that will read metadata about the `Engine` type
    at runtime and print the following to the console:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个小程序，它将在运行时读取有关`Engine`类型的元数据，并将以下内容打印到控制台：
- en: The name of the *type*
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型*的名称'
- en: The name of all *properties* as well as the name of their type
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有*属性*的名称以及它们的类型的名称
- en: The name of all *declared methods* (excluding the inherited methods)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有*声明的方法*的名称（不包括继承的方法）
- en: The name of their *return type*
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的*返回类型*的名称
- en: The name and type of *each parameter*
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数的名称和类型
- en: 'Here is the program to read and print metadata about the `Engine` type at runtime:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于在运行时读取和打印有关`Engine`类型的元数据的程序：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we used the `typeof` operator to retrieve an instance of the
    `System.Type` type to discover the metadata for the `Engine` type. To retrieve
    properties, we used the overload of `GetProperties()` with no parameters, which
    returns all of the public properties of the current type. For methods, however,
    we used an overload of the `GetMethod()` method, which takes as argument a bitmask
    comprised of one or more `BindingFlags` values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`typeof`运算符检索`System.Type`类型的实例，以发现`Engine`类型的元数据。为了检索属性，我们使用了没有参数的`GetProperties()`重载，它返回当前类型的所有公共属性。然而，对于方法，我们使用了`GetMethod()`方法的重载，它以一个由一个或多个`BindingFlags`值组成的位掩码作为参数。
- en: 'The `BindingFlags` type is an enum with flags that control the binding and
    the way searching for types and methods is performed during reflection. In our
    example, we used `Public`, `Instance`, and `DeclareOnly` to specify public, non-static
    methods declared in this type only, and exclude inherited ones. The output of
    this program is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingFlags`类型是一个枚举，其中的标志控制绑定和在反射期间执行类型和方法搜索的方式。在我们的例子中，我们使用`Public`、`Instance`和`DeclareOnly`来指定仅在此类型中声明的公共非静态方法，并排除继承的方法。这个程序的输出如下：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Engine` type is located in the assembly where the reflection code was executed.
    However, you can also reflect on types from other assemblies too, whether they
    are referred from the executing assembly or loaded at runtime, which is what we
    will look at in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine`类型位于执行反射代码的程序集中。但是，您也可以反射来自其他程序集的类型，无论它们是从执行程序集引用还是在运行时加载的，这是我们将在下一节中看到的。'
- en: Dynamically loading assemblies
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载程序集
- en: The reflection services allow you to load an assembly at runtime. This is done
    using the `System.Reflection.Assembly` type, which provides various methods for
    loading assemblies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 反射服务允许您在运行时加载程序集。这是使用`System.Reflection.Assembly`类型完成的，它提供了各种加载程序集的方法。
- en: Assemblies can be either *public* (also called *shared*) or *private*. A shared
    assembly is intended to be used by several applications and is usually located
    under the **Global Assembly Cache (GAC)**, a system repository for assemblies.
    A private assembly is intended to be used by a single application and is stored
    in the application directory or one of its sub-directories. Shared assemblies
    must be strongly named and enforce version constraints; these requirements are
    not necessary for private assemblies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集可以是*公共*（也称为*共享*）或*私有*。共享程序集旨在供多个应用程序使用，并且通常位于**全局程序集缓存（GAC）**下，这是程序集的系统存储库。私有程序集旨在供单个应用程序使用，并存储在应用程序目录或其子目录中。共享程序集必须具有强名称并强制执行版本约束；对于私有程序集，这些要求是不必要的。
- en: 'An assembly can be loaded in one of three contexts or without any:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集可以在三个上下文中之一加载，也可以不加载：
- en: The *load context*, which contains assemblies loaded from the GAC, the application
    directory (`ApplicationBase` of the app domain), or its sub-directories of private
    assemblies (`PrivateBinPath` of the app domain)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载上下文*，其中包含从GAC、应用程序目录（应用程序域的`ApplicationBase`）或其私有程序集的子目录（应用程序域的`PrivateBinPath`）加载的程序集'
- en: The *load-from context*, which contains assemblies loaded from paths other than
    the aforementioned ones that are probed by the assembly loader
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载上下文*，其中包含从除了程序集加载程序探测的路径加载的程序集'
- en: The *reflection-only context*, which contains assemblies loaded for reflection
    purposes only and which cannot be used to execute code
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅反射上下文*，其中包含仅用于反射目的加载的程序集，不能用于执行代码'
- en: '*No context*, which is used in some particular cases such as assemblies loaded
    from an array of bytes'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无上下文*，在某些特殊情况下使用，例如从字节数组加载的程序集'
- en: 'The most important methods used to load assemblies are listed in the following
    table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加载程序集的最重要的方法列在下表中：
- en: '![](img/Chapter_11_Table_3_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_11_Table_3_01.jpg)'
- en: We will look at several examples of loading assemblies dynamically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看几个动态加载程序集的例子。
- en: 'In the first example, we use `Assembly.Load()` to load an assembly called `EngineLib`
    from the applications directory:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用`Assembly.Load()`从应用程序目录加载名为`EngineLib`的程序集：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we only specified the name of the assembly, but we could alternatively
    specify the display name, which is comprised not only of the name but also the
    version, culture, and the public key token used to sign the assembly. For assemblies
    that do not have a strong name, this is `null`. The following line, where we use
    the display name, is equivalent to the one used previously:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只指定了程序集的名称，但我们也可以指定显示名称，该名称不仅由名称组成，还包括版本、文化和用于签名程序集的公钥标记。对于没有强名称的程序集，这是`null`。在下面的行中，我们使用显示名称，与先前使用的行等效：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is possible to create the display name in a type-safe way by using the `AssemblyName`
    class. This class has various properties and methods that allow you to build the
    display name. This can be done as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`AssemblyName`类以类型安全的方式创建显示名称。该类具有各种属性和方法，允许您构建显示名称。可以按照以下方式完成：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Public (or shared) assemblies must have a strong name. This helps to uniquely
    identify the assembly and therefore avoid possible conflicts. Signing is done
    using a public-private key; the private key is used for signing and the public
    key is distributed with the assembly and used to verify the signature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 公共（或共享）程序集必须具有强名称。这有助于唯一标识程序集，从而避免可能的冲突。签名是使用公共-私钥完成的；私钥用于签名，公钥与程序集一起分发并用于验证签名。
- en: 'Such a cryptographic pair can be generated with the `sn.exe` tool, distributed
    with Visual Studio; this tool can also be used for verifying a signature. For
    strong-name assemblies, `PublicKeyToken` must be specified or loading would fail.
    The following example shows how to load `WindowsBase.dll` from the GAC:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用与Visual Studio一起分发的`sn.exe`工具生成这样的加密对；此工具也可用于验证签名。对于强名称程序集，必须指定`PublicKeyToken`，否则加载将失败。以下示例显示了如何从GAC加载`WindowsBase.dll`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The alternative to using the assembly name for loading an assembly is to use
    its actual path. However, in this case, you must use one of the `LoadFrom()` overloads.
    This is useful for cases where you must load an assembly that is neither in the
    GAC nor under the application''s folder. An example can be an extensible system
    that can load plugins that may be installed in some custom directory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序集名称加载程序集的替代方法是使用其实际路径。但是，在这种情况下，您必须使用`LoadFrom()`的一个重载之一。这对于必须加载既不在GAC中也不在应用程序文件夹下的程序集的情况非常有用。一个例子可以是一个可扩展的系统，可以加载可能安装在某个自定义目录中的插件：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Assembly` class has members that provide information about the assembly
    itself, as well as members that provide information about the types it contains.
    Some of the most important members are listed here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly`类具有提供有关程序集本身信息的成员，以及提供有关其包含的类型信息的成员。以下是一些最重要的成员：'
- en: '![](img/Chapter_11_Table_4_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_11_Table_4_01.jpg)'
- en: 'In the following example, after loading an assembly using one of the methods
    shown previously, we list the assembly name and the files in the assembly manifest,
    as well as the names of the referenced assemblies. After that, we search for the
    `EngineLib.Engine` type and print the name and the type of all of its properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，使用先前显示的方法之一加载程序集后，我们列出程序集名称和程序集清单中的文件，以及引用程序集的名称。之后，我们搜索`EngineLib.Engine`类型并打印其所有属性的名称和类型：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Apart from querying for information about an assembly and its content, it is
    also possible to execute code from it at runtime. This is what we will look at
    in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询有关程序集及其内容的信息之外，还可以在运行时从中执行代码。这是我们将在下一节中讨论的内容。
- en: Understanding late binding
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解后期绑定
- en: When you reference an assembly at compile time, the compiler has full access
    to the types available in that assembly. This is called **early binding**. However,
    if an assembly is only loaded at runtime, the compiler has no access to the content
    of that assembly. This is called **late binding** and is key to building extensible
    applications. Using late binding, you can not only load and query assemblies but
    also execute code. We will see that in the following examples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时引用程序集时，编译器可以完全访问该程序集中可用的类型。这称为**早期绑定**。但是，如果程序集仅在运行时加载，编译器将无法访问该程序集的内容。这称为**后期绑定**，是构建可扩展应用程序的关键。使用后期绑定，您不仅可以加载和查询程序集，还可以执行代码。我们将在下面的例子中看到。
- en: 'Let''s imagine the `Engine` class, shown earlier, is available in an assembly
    called `EngineLib`. This can be loaded with either `Assembly.Load()` or `Assembly.LoadFrom()`.
    Once loaded, we can get information about the `Engine` type using `Assembly.GetType()`
    and the class methods of `Type`. However, using `Assembly.CreateInstance()`, we
    can instantiate an object of the class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设先前显示的`Engine`类在名为`EngineLib`的程序集中可用。可以使用`Assembly.Load()`或`Assembly.LoadFrom()`加载该程序集。加载后，我们可以使用`Assembly.GetType()`和`Type`的类方法获取有关`Engine`类型的信息。但是，使用`Assembly.CreateInstance()`，我们可以实例化该类的对象：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Assembly.CreateInstance()` method has many parameters, but three of them
    are of the most importance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly.CreateInstance()`方法有许多参数，但其中三个最重要：'
- en: The first parameter, `string typeName`, representing the name of the assembly.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数`string typeName`，表示程序集的名称。
- en: The third parameter, `BindingFlags bindingAttr`, representing binding flags.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数，`BindingFlags bindingAttr`，表示绑定标志。
- en: The fifth parameter, `object[]` `args`, representing an array with the parameters
    used to invoke the constructor; for a default constructor, this object can be
    `null.`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数，`object[]` `args`，表示用于调用构造函数的参数数组；对于默认构造函数，这个对象可以是`null`。
- en: After creating an instance of a type, we can invoke its members using instances
    of `PropertyInfo`, `MethodInfo`, and so on. For instance, in the previous example,
    we first retrieve an instance of `PropertyInfo` for the property called `Status`
    and then the value of the property by calling `GetValue()` and passing the engine
    object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类型的实例之后，我们可以使用`PropertyInfo`、`MethodInfo`等的实例来调用其成员。例如，在前面的示例中，我们首先检索了名为`Status`的属性的`PropertyInfo`实例，然后通过调用`GetValue()`并传递引擎对象来获取属性的值。
- en: Similarly, we use `GetMethod()` to retrieve an instance of `MethodInfo` with
    information about the method called `Start()` and then invoke it by calling `Invoke()`.
    This method takes a reference to the object and an array of objects representing
    the arguments; since the `Start()` method has no parameters, `null` is used here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们使用`GetMethod()`来检索一个名为`Start()`的方法的`MethodInfo`实例，然后通过调用`Invoke()`来调用它。这个方法接受一个对象的引用和一个表示参数的对象数组；由于`Start()`方法没有参数，在这里使用了`null`。
- en: 'The `Assembly.CreateInstance()` method has a lot of parameters and can be cumbersome
    to use. Alternatively, a simpler way to create instances of types at runtime is
    provided by the `System.Activator` class. It has an overloaded `CreateInstance()`
    method. This is actually used under the hood by `Assembly.CreateInstance()`. In
    its simplest form, it only takes `Type` and an array of objects representing constructor
    arguments and instantiates an object of that type. An example is shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assembly.CreateInstance()`方法有很多参数，使用起来可能很麻烦。作为替代，`System.Activator`类提供了在运行时创建类型实例的更简单的方法。它有一个重载的`CreateInstance()`方法。实际上，`Assembly.CreateInstance()`在内部实际上就是使用了它。在最简单的形式中，它只需要`Type`和一个表示构造函数参数的对象数组，并实例化该类型的对象。示例如下：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Activator.CreateInstance()` is not only simpler to use but can provide benefits
    in some scenarios. For instance, it can create objects in other app domains or
    on another server using Remoting. On the other hand, `Assembly.CreateIntance()`
    will not attempt to load the assembly if it is not already loaded, while `System.Activator`
    will load the assembly into the current app domain.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activator.CreateInstance()`不仅更简单易用，而且在某些情况下可以提供一些好处。例如，它可以在其他应用程序域或另一台服务器上使用远程调用来创建对象。另一方面，`Assembly.CreateIntance()`如果尚未加载程序集，则不会尝试加载程序集，而`System.Activator`会将程序集加载到当前应用程序域中。'
- en: Using late binding and invoking code in the manner shown earlier is not necessarily
    practical. In practice, when building an extensible system, you will probably
    have one or more assemblies with interfaces and common types that add-ons (or
    plugins, depending on how you want to call them) rely upon. You will early-bind
    to these base assemblies and then use late binding with the plugins.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用晚期绑定和以前展示的方式调用代码并不一定实用。在实践中，当构建一个可扩展的系统时，您可能会有一个或多个包含接口和公共类型的程序集，这些插件（或插件，取决于您希望如何称呼它们）依赖于这些基本程序集。您将对这些基本程序集进行早期绑定，然后使用插件进行晚期绑定。
- en: 'To better understand this, we will demonstrate it with the following example.
    `EngineLibBase` is an assembly that defines an interface called `IEngine` and
    the `EngineStatus` enumeration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们将通过以下示例进行演示。`EngineLibBase`是一个定义了名为`IEngine`和`EngineStatus`枚举的接口的程序集：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This assembly is directly referenced in the `EngineLib` assembly, which provides
    the `Engine` class that implements the `IEngine` interface. This is shown in the
    example here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序集直接被`EngineLib`程序集引用，它提供了实现`IEngine`接口的`Engine`类。示例如下：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our application, where we instantiated the `Engine` class, we again reference
    the `EngineLibBase` assembly so that we can use the `IEngine` interface. After
    loading the `EngineLib` assembly at runtime, we instantiate an object of the `Engine`
    class and cast it to the `IEngine` interface, which makes it possible to access
    the members of the interface at compile time, even though the actual instance
    is not known until at runtime. This is shown in the code here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们再次引用了`EngineLibBase`程序集，以便我们可以使用`IEngine`接口。在运行时加载`EngineLib`程序集后，我们实例化了`Engine`类的对象，并将其转换为`IEngine`接口，这样即使在编译时实际实例未知的情况下，也可以访问接口的成员。代码如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we will see further on in this chapter, this is not the only way to use late
    binding and execute code dynamically at runtime. The other possibility is using
    the DLR and the `dynamic` type. We will look at this in the following section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，这并不是使用晚期绑定和在运行时动态执行代码的唯一方法。另一种可能性是使用DLR和`dynamic`类型。我们将在下一节中看到这一点。
- en: Using the dynamic type
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态类型
- en: Throughout this book, we have talked about the **CLR**. .NET Framework, however,
    contains another component called the **Dynamic Language Runtime (DLR)**. This
    is another runtime environment that adds a set of services on top of the CLR to
    enable dynamic languages to run on the CLR and to add dynamic features to statically-typed
    languages. C# and Visual Basic are statically-typed languages. By contrast, languages
    such as JavaScript, Python, Ruby, PHP, Smalltalk, Lua, and others are dynamic
    languages. The key characteristic of these languages is that they identify the
    type of an object at runtime and not at compile time as in the case of the statically-typed
    languages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经谈到了**CLR**。.NET Framework，然而，还包含了另一个组件，称为**动态语言运行时（DLR）**。这是另一个运行时环境，它在CLR之上添加了一组服务，使动态语言能够在CLR上运行，并为静态类型语言添加动态特性。C#和Visual
    Basic是静态类型语言。相比之下，诸如JavaScript、Python、Ruby、PHP、Smalltalk、Lua等语言是动态语言。这些语言的关键特征是它们在运行时识别对象的类型，而不是在编译时像静态类型语言那样。
- en: 'The DLR provides C# (and Visual Basic) with dynamic features that enable them
    to interoperate with dynamic languages in a simple manner. As mentioned before,
    the DLR adds a set of services to the CLR. These services are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: DLR为C#（和Visual Basic）提供了动态特性，使它们能够以简单的方式与动态语言进行互操作。如前所述，DLR为CLR添加了一组服务。这些服务如下：
- en: '**Expression trees** are used to present language semantics. These are the
    same expression trees used with LINQ but extended to include control-flow, assignments,
    and others.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式树用于表示语言语义。这些是与LINQ一起使用的相同表达式树，但扩展到包括控制流、赋值和其他内容。
- en: '**Call site caching** is a service that caches information about operations
    and objects (such as the type of an object) so that when the same operation is
    performed again, it can be quickly dispatched.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用站点缓存是一个缓存有关操作和对象（如对象的类型）的信息的服务，这样当再次执行相同的操作时，它可以被快速分派。
- en: '`IDynamicMetaObjectProvider`, `DynamicMetaObject`, `DynamicObject`, and `ExpandoObject`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDynamicMetaObjectProvider`、`DynamicMetaObject`、`DynamicObject`和`ExpandoObject`。'
- en: The DLR provides the infrastructure for the `dynamic` type, introduced in C#
    4\. This is a static type, meaning variables of this type are assigned the `dynamic`
    type at compile time. However, they bypass static type checking. This means that
    the actual type of the object is only known at runtime and the compiler cannot
    know and cannot enforce any checks on operations performed on objects of this
    type. You can actually invoke any methods with any parameters and the compiler
    will not check and complain; however, if the operation is not valid, an exception
    will be thrown at runtime.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DLR为C# 4引入的`dynamic`类型提供了基础设施。这是一个静态类型，这意味着在编译时为该类型的变量分配了`dynamic`类型。但是，它们绕过了静态类型检查。这意味着对象的实际类型只在运行时知道，编译器无法知道并且无法强制执行对该类型对象执行的任何检查。您实际上可以调用任何带有任何参数的方法，编译器不会检查和抱怨；但是，如果操作无效，运行时将抛出异常。
- en: 'The following code shows several examples of variables of the `dynamic` type.
    Notice that `s` is a string and `l` is `List<int>`. Calling `l.Add()` is a valid
    operation because `List<T>` contains such a method. However, calling `s.Add()`
    is invalid because the `string` type does not have such a method. Therefore, an
    exception of the `RuntimeBinderException` type is thrown at runtime for this call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`dynamic`类型的几个变量的示例。请注意，`s`是一个字符串，`l`是`List<int>`。调用`l.Add()`是有效的操作，因为`List<T>`包含这样的方法。但是，调用`s.Add()`是无效的，因为`string`类型没有这样的方法。因此，对于此调用，在运行时会抛出`RuntimeBinderException`类型的异常：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `dynamic` type makes it easy to consume objects whose type you do not know
    anything about at compile time. Consider the first example from the previous paragraph,
    where we loaded an assembly using reflection, instantiated an object of the `Engine`
    type and called its methods and properties. That example can be rewritten in a
    simpler way, as follows, using the `dynamic` type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型使得在编译时不知道对象类型的情况下轻松消耗对象变得容易。考虑前一段中的第一个例子，在那里我们使用反射加载了一个程序集，实例化了一个`Engine`类型的对象并调用了它的方法和属性。可以用`dynamic`类型以更简单的方式重写该示例，如下所示：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An object of the `dynamic` type behaves in many cases as if it had the `object`
    type (except there is no compile-time checking). However, the actual source of
    the object's value is irrelevant. It could be a .NET object, a COM object, an
    HTML DOM object, an object created through reflection, such as in the previous
    example, and so on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型的对象在许多情况下的行为就像它具有`object`类型一样（除了没有编译时检查）。但是，对象值的实际来源是无关紧要的。它可以是.NET对象、COM对象、HTML
    DOM对象、通过反射创建的对象，例如前面的示例等。'
- en: 'The type of the result of a dynamic operation is also `dynamic` with the exception
    of conversions from `dynamic` to another type and constructor calls that include
    arguments of the `dynamic` type. Implicit conversions from a static type to `dynamic`
    and the other way around are performed. This is shown in the code block here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 动态操作的结果类型也是`dynamic`，除了从`dynamic`到另一种类型的转换和包括`dynamic`类型参数的构造函数调用。从静态类型到`dynamic`的隐式转换以及相反的转换都会执行。代码块中显示了这一点：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For static types, the compiler performs overload resolution to figure out what
    is the best match for a function call. Because there is no information about the
    `dynamic` type at compile time, the same cannot be done for methods that have
    at least one argument of the `dynamic` type. Instead, the overload resolution
    is performed at runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态类型，编译器执行重载解析以找出对函数调用的最佳匹配。因为在编译时没有关于`dynamic`类型的信息，所以对于至少有一个参数是`dynamic`类型的方法，同样的操作在运行时执行。
- en: 'The `dynamic` type is often used to simplify the consumption of COM objects
    when an interop assembly is not available. The following is an example that creates
    an Excel document with some dummy data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic`类型通常用于简化在互操作程序集不可用时消耗COM对象。以下是一个创建带有一些虚拟数据的Excel文档的示例：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What this code does is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: It retrieves `System.Type` for the COM object identified by the programmatic
    identifier, `Excel.Application.16`, and creates an instance of it.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检索由程序标识符`Excel.Application.16`标识的COM对象的`System.Type`，并创建其实例。
- en: It sets the `Visible` property of the Excel application to `true` so that you
    can see the window.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将Excel应用程序的`Visible`属性设置为`true`，这样您就可以看到窗口。
- en: It creates a workbook and adds some data to its active worksheet.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建一个工作簿并向其活动工作表添加一些数据。
- en: It saves the document on a file called `demo.xls`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将文档保存在名为`demo.xls`的文件中。
- en: It closes the workbook and quits the Excel application.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它关闭工作簿并退出Excel应用程序。
- en: In the last section of this chapter, we will look at how to use attributes with
    reflection services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将看看如何在反射服务中使用属性。
- en: Attributes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Attributes provide meta-information about assemblies, types, and members. This
    meta-information is consumed by the compiler, the CLR, or tools that use reflection
    services to read them. Attributes are actually types that derive from the `System.Attribute`
    abstract class. The .NET frameworks provide a large number of attributes, but
    users can define their own.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 属性提供有关程序集、类型和成员的元信息。编译器、CLR或使用反射服务读取它们的工具会消耗这些元信息。属性实际上是从`System.Attribute`抽象类派生的类型。.NET框架提供了大量的属性，但用户也可以定义自己的属性。
- en: Attributes are specified in square brackets, such as in `[SerializableAttribute]`.
    The naming convention for attributes is that the type names are always suffixed
    with the word `Attribute`. The C# language provides a syntactic shortcut that
    allows specifying the name of the attribute without the suffix, `Attribute`, such
    as in `[Serializable]`. However, this is only possible as long as the type name
    is properly suffixed according to this convention.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在方括号中指定，例如`[SerializableAttribute]`。属性的命名约定是类型名称总是以`Attribute`一词结尾。C#语言提供了一种语法快捷方式，允许在不带后缀`Attribute`的情况下指定属性的名称，例如`[Serializable]`。但是，只有在类型名称根据此约定正确后缀时才可能。
- en: We will first look at some widely used system attributes in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节首先介绍一些广泛使用的系统属性。
- en: System attributes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统属性
- en: '.NET Framework provides hundreds of attributes in different assemblies and
    namespaces. Enumerating them would be not only practically impossible but would
    also make little sense. However, the following table lists several attributes
    that you will often work with; some of them we have already seen in this book:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework在不同的程序集和命名空间中提供了数百个属性。枚举它们不仅几乎不可能，而且也没有多大意义。然而，以下表格列出了一些经常使用的属性；其中一些我们在本书中已经见过：
- en: '![](img/Chapter_11_Table_5_01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_11_Table_5_01.jpg)'
- en: On the other hand, it is often necessary or useful to create your own attribute
    classes. In the next section, we will look at user-defined attributes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通常需要或有用的是创建自己的属性类。在下一节中，我们将看看用户定义的属性。
- en: User-defined attributes
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的属性
- en: 'You can create your attributes to mark program elements. What you have to do
    is derive from `System.Attribute` and follow the naming convention of suffixing
    the type with the word `Attribute`. The following is an attribute called `Description`
    that contains a single property, called `Text`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的属性来标记程序元素。您需要从`System.Attribute`派生，并遵循将类型后缀命名为`Attribute`的命名约定。以下是一个名为`Description`的属性，其中包含一个名为`Text`的属性：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This attribute can be used to decorate any program element. In the following
    example, we can see this attribute used on a class, properties, and method parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可用于装饰任何程序元素。在下面的示例中，我们可以看到这个属性用在了一个类、属性和方法参数上：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Attributes can have *positional* and *named* parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以有*位置*和*命名*参数：
- en: Positional parameters are defined by the arguments of public instance constructors.
    The arguments of each such constructor define a set of named parameters.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数由公共实例构造函数的参数定义。每个这样的构造函数的参数定义了一组命名参数。
- en: On the other hand, every non-static public field and property that is read-write
    defines a named parameter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，每个非静态公共字段和可读写属性定义了一个命名参数。
- en: 'The following sample shows the `Description` attribute introduced earlier,
    modified so that a public property called `Required` is available:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了早期介绍的`Description`属性，修改后可以使用一个名为`Required`的公共属性：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This property can be used as a named parameter in the declaration of an attribute
    on a program element. This is shown in the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可以在程序元素上的属性声明中用作命名参数。如下例所示：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's learn how to use attributes in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中学习如何使用属性。
- en: How to use attributes?
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用属性？
- en: 'A program element can be marked with multiple attributes. This can be done
    in two equivalent ways:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序元素可以标记多个属性。有两种等效的方法可以实现这一点：
- en: 'The first method (which is the most widely used because it is the most descriptive
    and clear) is to declare each attribute separately, inside a pair of square brackets.
    The following example shows how this is done:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法（因为它最具描述性和清晰，所以被广泛使用）是在一对方括号内分别声明每个属性。以下示例显示了如何完成此操作：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The alternative method is to declare multiple attributes inside the same pair
    of square brackets, separated by a comma. The following code is equivalent to
    the earlier one:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是在同一对方括号内声明多个属性，用逗号分隔。以下代码等同于之前的代码：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see how to specify an attribute's target in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看如何指定属性的目标。
- en: Attribute targets
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性目标
- en: By default, an attribute is applied to any program element that it precedes.
    However, it is possible to specify the target, such as a type, a method, and so
    on. This is done by marking the attribute type with another attribute called `AttributeUsage`.
    Apart from specifying the target, this attribute allows specifying whether the
    newly defined attribute can be applied multiple times and whether it can be inherited.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，属性应用于它前面的任何程序元素。但是，可以指定目标，比如类型、方法等。这是通过使用另一个名为`AttributeUsage`的属性标记属性类型来完成的。除了指定目标外，此属性还允许指定新定义的属性是否可以多次应用以及是否可以继承。
- en: 'The following modified version of `DescriptionAttribute` indicates that it
    can only be used on classes, structs, methods, properties, and fields. In addition,
    it specifies that the attribute is inherited by derived classes and that it can
    be used multiple times on the same element:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下修改后的`DescriptionAttribute`版本指示它只能用于类、结构、方法、属性和字段。此外，它指定了该属性被派生类继承，并且可以在同一元素上多次使用：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As a result of these changes, this attribute can no longer be used for method
    parameters, as shown in an earlier example. That would result in a compiler error.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些变化，这个属性不能再用于方法参数，就像之前的例子中所示的那样。那将导致编译器错误。
- en: The attributes we've used so far target program elements, such as types and
    methods. But assembly-level attributes are also possible. We look at these in
    the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的属性针对程序元素，如类型和方法。但是也可以使用程序集级属性。我们将在下一节中看到这些。
- en: Assembly attributes
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集属性
- en: 'There are attributes that can target an assembly and specify information about
    the assembly. This information can be the identity (that is, the name, version,
    and culture) of the assembly, manifest information, the strong name, or others.
    These attributes are specified using the syntax `[assembly : attribute]`. These
    attributes are usually found in the `AssemblyInfo.cs` file generated for every
    .NET Framework project. The following is an example of such attributes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '有一些属性可以针对程序集并指定有关程序集的信息。这些信息可以是程序集的标识（即名称、版本和文化）、清单信息、强名称或其他信息。这些属性使用语法`[assembly:
    attribute]`指定。这些属性通常可以在为每个.NET Framework项目生成的`AssemblyInfo.cs`文件中找到。以下是这些属性的一个示例：'
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Attributes are intended for reflection services. Now that we've seen how to
    create and use attributes, let's see how to use them in reflection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 属性用于反射服务。既然我们已经看到了如何创建和使用属性，让我们看看如何在反射中使用它们。
- en: Attributes in reflection
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射中的属性
- en: Attributes have little value by themselves until somebody reflects on them and
    performs specific actions based on the meaning of the attributes and their values.
    The `System.Type` type as well as other types from the `System.Reflection` namespace
    have an overloaded method called `GetCustomAttributes()` that retrieves the attributes
    a particular program element is marked with. One overload takes the type of the
    attribute so that it only returns instances of that type; the other does not and
    returns all the attributes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 属性本身没有太大的价值，直到有人反映它们并根据属性的含义和值执行特定的操作。`System.Type`类型以及`System.Reflection`命名空间中的其他类型都有一个名为`GetCustomAttributes()`的重载方法，用于检索特定程序元素标记的属性。其中一个重载采用属性的类型，因此它只返回该类型的实例；另一个不是，返回所有属性。
- en: 'The following example retrieves all of the instances of the `Description` attribute,
    first from the `Engine` type and then from all of the properties of the type,
    and displays the description text in the console:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例从`Engine`类型中首先检索所有`Description`属性的实例，然后从类型的所有属性中检索并在控制台中显示描述文本：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of this program is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at reflection services, how to load assemblies at
    runtime, and querying meta-information about types. We also learned how to execute
    code dynamically using both system reflection on one hand and the DLR and the
    `dynamic` type on the other hand. The DLR provides dynamic features to C# and
    enables interoperability with dynamic languages in a simple manner. The last topic
    we covered in this chapter was attributes. We learned what the common system attributes
    are and how to create your own types as well as how to use them in reflection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了反射服务，如何在运行时加载程序集，并查询关于类型的元信息。我们还学习了如何使用系统反射和DLR以及动态类型来动态执行代码。DLR为C#提供了动态特性，并以简单的方式实现了与动态语言的互操作性。本章最后涵盖的主题是属性。我们学习了常见的系统属性是什么，以及如何创建自己的类型以及如何在反射中使用它们。
- en: In the next chapter, we will focus on concurrency and parallelism.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于并发和并行性。
- en: Test what you learned
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到的东西
- en: What is the unit of deployment in .NET and what does it contain?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中的部署单位是什么，它包含什么？
- en: What is reflection? What benefits does it provide?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反射？它提供了什么好处？
- en: What .NET type exposes metadata about types? How can you create an instance
    of this type?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET类型暴露了关于类型的元数据？你如何创建这种类型的实例？
- en: What is the difference between public and private assemblies?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共程序集和私有程序集之间有什么区别？
- en: In .NET Framework, in what context can an assembly be loaded?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Framework中，程序集可以在什么上下文中被加载？
- en: What is early binding? What about late binding? What benefits does the latter
    provide?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是早期绑定？晚期绑定呢？后者提供了什么好处？
- en: What is the Dynamic Language Runtime?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是动态语言运行时？
- en: What is the dynamic type and what are the typical scenarios where it is used?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态类型是什么，它通常在哪些场景中使用？
- en: What are attributes and how do you specify them in code?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性是什么，你如何在代码中指定它们？
- en: How do you create user-defined attributes?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建用户定义的属性？
