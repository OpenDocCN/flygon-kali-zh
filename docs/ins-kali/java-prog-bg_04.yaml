- en: Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: In this chapter, we are going to learn some of the most important data structures
    in Java. We'll look at what arrays are and how they are useful when we need to
    work with sequences of variables. We'll write a program in NetBeans using arrays
    to understand how they work. This chapter will also walk us through the concept
    of multidimensional arrays. We'll write a program to create a chessboard using
    a two-dimensional array.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java中一些最重要的数据结构。我们将研究数组是什么，以及当我们需要处理变量序列时它们如何有用。我们将在NetBeans中使用数组编写一个程序来理解它们的工作原理。本章还将介绍多维数组的概念。我们将编写一个程序，使用二维数组创建一个棋盘。
- en: Next, this chapter will illustrate what ArrayLists are and how they provide
    increased functionality when compared to arrays. Finally, we'll look at the `Map`
    data structure and implement it in NetBeans.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本章将说明ArrayList是什么，以及与数组相比，它们如何提供增强功能。最后，我们将看看`Map`数据结构，并在NetBeans中实现它。
- en: 'More specifically, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，我们将涵盖以下主题：
- en: Arrays and their syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组及其语法
- en: An array example to print the English alphabet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个打印英文字母表的数组示例
- en: Multidimensional arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组
- en: A program to create a chessboard using a 2D array
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2D数组创建棋盘的程序
- en: ArrayList and its example
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ArrayList及其示例
- en: Maps and their implementation in NetBeans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NetBeans中的地图及其实现
- en: Working with arrays
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组
- en: In this section we're going to learn about Java arrays. Arrays are Java's most
    basic and commonly used data structure. Data structures are tools that allow us
    to store and access sequences of information rather than using individual variables.
    Variables are great when we have one specific piece of information that we need
    in our local programming space, but data structures are used when we want to store
    large or complicated sets or series of information. We're going to start this
    section with some visual learning modes, and then we'll jump into our NetBeans
    IDE to write some actual Java code and make use of arrays.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Java数组。数组是Java最基本和常用的数据结构。数据结构是一种工具，允许我们存储和访问信息序列，而不是使用单个变量。当我们在本地编程空间中需要一个特定的信息片段时，变量非常有用，但是当我们想要存储大量或复杂的信息集或系列时，就会使用数据结构。我们将从一些视觉学习模式开始本节，然后我们将进入NetBeans
    IDE编写一些实际的Java代码并使用数组。
- en: Declaring and initializing an array
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化数组
- en: 'Let''s begin by taking a look at the syntax behind declaring and initializing
    an array in Java. The following line of code will cause an array to come into
    being with enough space to hold seven characters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下在Java中声明和初始化数组的语法。以下代码行将使一个数组产生，有足够的空间来容纳七个字符：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To the left of our assignment operator (`=`), the syntax looks pretty familiar,
    not unlike the syntax we would use when declaring any other primitive or object.
    We begin by telling Java what type of element we're going to declare here. In
    this case, we're declaring a character array. The empty square brackets lets Java
    know that rather than creating a single character variable, we'd like to declare
    an array type variable because our array is a variable just like any other. We'll
    access the elements of the array through the array's variable name itself, not
    through the individual variable names of the elements, which we don't need to
    assign as they are being stored in an array. Once we've told Java what type of
    array we're going to create, we give our array variable a name. I've called this
    one `arrayVar`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的赋值运算符（`=`）的左侧，语法看起来非常熟悉，与声明任何其他原始或对象时使用的语法非常相似。我们首先告诉Java我们要在这里声明什么类型的元素。在这种情况下，我们声明了一个字符数组。空方括号让Java知道，我们不是要创建一个单个字符变量，而是要声明一个数组类型变量，因为我们的数组就像任何其他变量一样。我们将通过数组的变量名本身访问数组的元素，而不是通过元素的单独变量名，因为它们被存储在数组中，我们不需要分配它们。告诉Java我们要创建什么类型的数组后，我们给我们的数组变量一个名称。我把这个叫做`arrayVar`。
- en: To the right of our equality operator, things look a little different. You may
    have seen the `new` keyword used in the past when we needed to create a new instance
    of an object, not a primitive element. When we create a primitive element in Java,
    Java knows exactly how much memory space is needed to store the primitive element,
    no matter what its value is. However, objects and arrays can have many different
    size requirements. Because a single array variable can be assigned to arrays of
    different lengths, we're going to need to tell Java how much memory to put aside
    for each of these different length arrays when we create them. When creating an
    object or an array, therefore, we use the `new` keyword to tell Java that it should
    set aside memory space to place what we're about to cause to come into being,
    and that thing is a character array of length seven.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的等号运算符右侧，情况看起来有些不同。您可能已经在过去看到`new`关键字的使用，当我们需要创建一个对象的新实例时，而不是原始元素。在Java中创建原始元素时，Java知道需要多少内存空间来存储原始元素，无论其值如何。然而，对象和数组可能具有许多不同的大小要求。因为单个数组变量可以分配给不同长度的数组，所以当我们创建它们时，我们需要告诉Java为这些不同长度的数组中的每一个分配多少内存。因此，在创建对象或数组时，我们使用`new`关键字告诉Java应该设置多少内存空间来放置我们即将产生的东西，而那个东西是一个长度为七的字符数组。
- en: 'After declaring and initializing our seven character array, what exists in
    our program''s local memory is something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明和初始化我们的七个字符数组之后，我们程序的本地内存中存在以下内容：
- en: '![](img/8d309c8b-43d4-4a06-8e54-171a1043da0e.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d309c8b-43d4-4a06-8e54-171a1043da0e.png)'
- en: Our array is basically a block of memory large enough to store seven individual
    characters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组基本上是一个足够大的内存块，可以存储七个单独的字符。
- en: Assigning values to an array
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为数组分配值
- en: 'The location of our array is accessed by our program when we call the `arrayVar`
    variable. This allows us to run lines of code such as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`arrayVar`变量时，我们的程序访问数组的位置。这使我们能够运行以下代码行：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `arrayVar` variable gives us access, essentially, to seven different character
    variables. When we don''t want to assign a new array to our `arrayVar` variable,
    we''re probably going to be accessing these character variables as individuals.
    We do this simply using the variable name of `arrayVar`, following it with square
    brackets, which include the index of the individual character we''d like to access.
    Remember, when our computers count indexes, they almost always begin with **0**.
    So, in Java, our seven-character array has these indexes: **0**, **1**, **2**,
    **3**, **4**, **5**, and **6**. If we execute the preceding line of code while
    setting the value of index `2` in our `arrayVar` to `c`, we will take the third
    block of memory and assign its value to the character `c`, as shown in the following
    diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`arrayVar`变量基本上让我们可以访问七个不同的字符变量。当我们不想给我们的`arrayVar`变量分配一个新的数组时，我们可能会单独访问这些字符变量。我们只需使用`arrayVar`的变量名，后面跟着方括号，其中包括我们想要访问的单个字符的索引。请记住，当我们的计算机计算索引时，它们几乎总是从**0**开始。因此，在Java中，我们的七个字符数组具有这些索引：**0**，**1**，**2**，**3**，**4**，**5**和**6**。如果我们执行上面的代码行，同时将我们的`arrayVar`中索引`2`的值设置为`c`，我们将取出内存的第三个块，并将其值分配给字符`c`，如下图所示：
- en: '![](img/23e6c8b8-c4a9-4b21-8862-53c6b33889f4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e6c8b8-c4a9-4b21-8862-53c6b33889f4.png)'
- en: 'Sometimes when we declare an array, we just want to go ahead and assign values
    to all of its memory blocks right there in the code explicitly. When we want to
    do this, rather than using the `new` keyword and having our computer space out
    the new memory space by telling it how long the array is, we can explicitly declare
    an array, like we explicitly declare a primitive type. For example, we would do
    this for our `arrayVar` variable with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们声明一个数组时，我们只想继续在代码中明确地为所有的内存块分配值。当我们想要这样做时，我们可以像明确声明原始类型一样，而不是使用`new`关键字并让计算机告诉它数组的长度，我们可以明确声明一个数组。例如，我们可以使用以下代码为我们的`arrayVar`变量做到这一点：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding statement will create an array of length seven simply because
    seven elements are declared, and of course, it will map the values accordingly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将创建一个长度为七的数组，因为声明了七个元素，并且当然，它将相应地映射值：
- en: '![](img/f96737c2-efd9-4c2f-bdb4-9c62057f3c8f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f96737c2-efd9-4c2f-bdb4-9c62057f3c8f.png)'
- en: Now, let's jump into some Java code and put arrays to work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳入一些Java代码，并让数组开始工作。
- en: Array example in NetBeans
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans中的数组示例
- en: Alright, I think it's time to employ our newfound knowledge and write a computer
    program. Arrays allow us to manipulate amounts of information that would be unwieldy
    to deal with at the individual element level. So, we're going to jump right into
    hard-hitting stuff and create a cool computer program. Arrays are a big logic
    step, and if you haven't worked with something like them before, it can take a
    little time to wrap your head around them. The good news is if you make it through
    arrays in Java, you're probably going to be just fine with anything else the language
    can throw at you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我想现在是时候运用我们的新知识并编写一个计算机程序了。数组允许我们处理在单个元素级别处理起来会很麻烦的信息量。因此，我们将直接进入重要的内容，并创建一个很酷的计算机程序。数组是一个很大的逻辑步骤，如果你以前没有使用过类似的东西，可能需要一点时间来理解它们。好消息是，如果你通过了Java中的数组，你可能会很好地处理语言可以给你带来的其他任何东西。
- en: 'The program I would like to write will print the English alphabet to our screen.
    We could, of course, do all of this by ourselves by just doing something along
    the lines of the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要编写的程序将把英语字母表打印到屏幕上。当然，我们可以自己做所有这些，只需按照以下代码的方式进行：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, employing this is pretty mind-numbing and it's not going to teach us
    much. Instead, the program that we're going to write is going to learn, store,
    and print out the English alphabet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这个方法相当令人昏昏欲睡，而且不会教会我们太多东西。相反，我们要编写的程序将学习、存储并打印出英语字母表。
- en: To do this, we're going to need to employ our newfound knowledge of arrays,
    our existing knowledge of how characters work and mapping integer values on an
    ASCII table, and a single `for` loop.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要运用我们对数组的新知识，我们对字符如何工作和在ASCII表上映射整数值的现有知识，以及一个`for`循环。
- en: Creating an array
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个数组
- en: 'Let''s begin our programming by declaring and initializing a character array
    in which to store the characters of the English language. So, we tell Java that
    we''re going to need a variable to point to an array of characters. I''ll call
    this variable `alpha`. Then we''re going to ask Java to set aside memory space
    by using the `new` keyword for `26` characters, because the English language has
    26 letters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的编程，声明并初始化一个字符数组，用来存储英语语言的字符。因此，我们告诉Java我们需要一个变量来指向一个字符数组。我会把这个变量称为`alpha`。然后我们要求Java使用`new`关键字为`26`个字符分配内存空间，因为英语语言有26个字母：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if you remember, character values can also map to integer values. To find
    these, we will look for an ASCII table. (You can access the ASCII table at [www.asciitable.com](http://www.asciitable.com/).)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你记得，字符值也可以映射到整数值。要找到这些值，我们将查找ASCII表。（您可以在[www.asciitable.com](http://www.asciitable.com/)上访问ASCII表。）
- en: '![](img/d9f6be8e-6290-44ce-97ce-b9bb46a323d6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9f6be8e-6290-44ce-97ce-b9bb46a323d6.jpg)'
- en: 'The value we''re looking for is **97**, the integer value of a lowercase **a**,
    which is the first character in the English language. So let''s create a little
    comment in our program and store the value `97` for later use:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的值是**97**，小写字母**a**的整数值，这是英语语言中的第一个字符。因此，让我们在我们的程序中创建一个小注释，并将值`97`存储起来以备后用：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating a for loop
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个for循环
- en: 'Now let''s begin creating our `for` loop. Our `for` loop is going to run 26
    times; each time it runs, it will take the next character in the English alphabet
    and place it in our character array: `alpha`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始创建我们的`for`循环。我们的`for`循环将运行26次；每次运行时，它将取出英语字母表中的下一个字符，并将其放入我们的字符数组`alpha`中。
- en: 'To make sure our `for` loop runs exactly 26 times, we should declare a counting
    variable, say `i`, and set it to `0`, that is, (`i=0`). Next, let''s say that
    our `for` loop should continue to run as long as the value of our counting variable
    is less than `26`, that is, it should take values between `0` and `25` (`i<26`).
    Lastly, every time our `for` loop runs, we need to increase the value of our counting
    variable by one so that it goes up each time, and after 26 iterations, the `i<26`
    statement will no longer be true and our loop will stop at (`i++`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保我们的`for`循环运行26次，我们应该声明一个计数变量，比如`i`，并将其设置为`0`，即（`i=0`）。接下来，让我们说我们的`for`循环应该继续运行，只要我们的计数变量的值小于`26`，也就是说，它应该在`0`和`25`之间取值（`i<26`）。最后，每次我们的`for`循环运行时，我们需要增加我们的计数变量的值，以便它每次都增加，经过26次迭代后，`i<26`语句将不再为真，我们的循环将在（`i++`）处停止： '
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, inside our `for` loop, we're going to assign values to the spaces in our
    character array one by one. To access one of these spaces, we will use the name
    of the variable assigned to our array, that is, `alpha`, followed by a number
    (or index) within square brackets to tell Java which character in our array we
    would like to assign a value to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`for`循环内部，我们将逐个为字符数组中的空格赋值。要访问其中一个空格，我们将使用分配给数组的变量的名称，即`alpha`，后跟方括号内的数字（或索引），以告诉Java我们想要为数组中的哪个字符赋值。
- en: The index of our array should be different each time we run through the loop.
    This is the beauty of `for` loops. By starting our counting variable `i` at `0`,
    we can use it to map to the index of our array. That is, we can use `alpha[i]`
    to access elements of the array one by one. Our counting variable's value, as
    our loop runs, will range from 0 to 25\. The index values of our array (because
    computers start counting at zero) also ranges from 0 to 25.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数组的索引应该在每次循环中都不同。这就是`for`循环的美妙之处。通过将我们的计数变量`i`从`0`开始，我们可以使用它来映射到数组的索引。也就是说，我们可以使用`alpha[i]`逐个访问数组的元素。随着循环运行，我们的计数变量的值将从0到25变化。数组的索引值（因为计算机从零开始计数）也从0到25变化。
- en: 'So, what value do we assign to each character so that our computer will learn
    the alphabet? Well, I like to think of it this way: when we run through the loop
    for the first time, the value of the first element of our array, when `i` is `0`,
    should be `97`, which is the integer value of the character **a**. Now, when we
    should assign `97+i` as the value of each character in our array. When we run
    through our loop the second time, `i` is incremented by one, and we''ll be assigning
    the value 97 + 1, or **98**, which is the integer value of the character **b**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为每个字符分配什么值，以便我们的计算机学会字母表呢？嗯，我喜欢这样想：当我们第一次运行循环时，当`i`为`0`时，我们数组的第一个元素的值应该是`97`，这是字符**a**的整数值。现在，当我们应该将`97+i`作为数组中每个字符的值。当我们第二次运行循环时，`i`增加了一，我们将分配值97
    + 1，或**98**，这是字符**b**的整数值：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this instance, Java is asking us to explicitly let it know that we would
    like to cast this integer value to a character and then store it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Java要求我们明确告诉它，我们希望将这个整数值转换为字符，然后存储它。
- en: Printing the alphabet
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印字母表
- en: 'Now, to finish off our program, all we need to do is print out our `alpha`
    array. To do this, let''s make use of a nifty function in an always accessible
    object called `Arrays`. The `Arrays.toString()` function will convert a single
    dimension array, which is the kind of array that we''ve created, that is capable
    of being converted into a string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要完成我们的程序，我们需要做的就是打印出我们的`alpha`数组。为此，让我们利用一个始终可访问的对象中的一个巧妙的函数，称为`Arrays`。`Arrays.toString()`函数将转换为字符串的单维数组（这是我们创建的数组的类型），可以转换为字符串：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we run our program, we''ll see Java''s representation of the English
    alphabet in array form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的程序，我们将看到Java以数组形式表示的英文字母：
- en: '![](img/f64fbff0-7f63-4e4b-bc9b-42930ad80643.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f64fbff0-7f63-4e4b-bc9b-42930ad80643.jpg)
- en: If you have followed along with this, you should give yourself a solid pat on
    the back. That's some heavy lifting we just did.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直跟着做，那么您应该给自己一个坚实的鼓励。我们刚刚做了一些重活。
- en: Default initialization of arrays in Java
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中数组的默认初始化
- en: 'Now, let''s jump back into theory for the rest of this section. I misled you
    earlier when I led you to believe that our newly created arrays were filled with
    empty memory space. In fact, when we declare a new array of a primitive type,
    that is, characters, integers, Booleans, floats, and so on, Java fills it with
    default values. For example, our new array of seven characters was filled by seven
    space characters, that is, what you''d get if you pressed the spacebar on your
    keyboard:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到理论中的其余部分。我之前误导了你，让你相信我们新创建的数组是用空内存空间填充的。实际上，当我们声明一个新的原始类型数组，即字符、整数、布尔值、浮点数等时，Java会用默认值填充它。例如，我们的七个字符的新数组被七个空格字符填充，也就是如果您在键盘上按空格键会得到的结果：
- en: '![](img/83398f87-f920-4c84-9b7d-3a7227bb310a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/83398f87-f920-4c84-9b7d-3a7227bb310a.png)
- en: 'Similarly, an array of integers would be filled with seven zeros:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，整数数组将填充七个零：
- en: '![](img/c2e6f3b3-fef4-445f-9385-8a0f2eb177a9.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c2e6f3b3-fef4-445f-9385-8a0f2eb177a9.png)
- en: I recommend that you boot up a Java IDE and create some empty primitive arrays
    and print them out using `println` to see what the default values are.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您启动Java IDE并创建一些空的原始数组，并使用`println`将它们打印出来，以查看默认值是什么。
- en: Now we can create arrays of any object available to us. However, objects, unlike
    primitives, do not have default values that they set themselves to when they are
    initialized as part of an array. This is an important thing to realize.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建任何可用对象的数组。但是，与原始类型不同，对象在初始化为数组的一部分时不会设置默认值。这是一个重要的事实。
- en: Anything that we would need to use the `new` keyword to create will not default-initialize
    in an array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`new`关键字创建的任何内容都不会在数组中进行默认初始化。
- en: 'Let''s say for some reason we decided that we must have seven `Scanner` objects
    in an array. The following statement does not create seven `Scanner` objects for
    us; it simply sets aside memory space:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出于某种原因，我们决定必须在数组中有七个`Scanner`对象。以下语句并不会为我们创建七个`Scanner`对象；它只是简单地设置了内存空间：
- en: '![](img/cc6f82a1-e7e7-4e04-a449-682ff95ee803.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc6f82a1-e7e7-4e04-a449-682ff95ee803.png)'
- en: We can create `Scanner` objects and assign them to these memory spaces, but
    if we try and call one of these memory spaces and use a Scanner-specific function
    from it before we've assigned a `Scanner` object to the memory location, our program
    will crash. We'll get what's called `NullReferenceException`, which means that
    Java asked nothingness to behave like a `Scanner` object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`Scanner`对象并将它们分配到这些内存空间，但如果在我们分配`Scanner`对象给内存位置之前尝试调用其中一个内存空间并使用Scanner特定的函数，我们的程序将崩溃。我们将得到所谓的`NullReferenceException`，这意味着Java要求虚无行为像一个`Scanner`对象。
- en: Multidimensional arrays
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: In Java, our most basic data structure is the array, which allows us to store
    sequences of light-typed information and access this through a single location
    in memory. Sometimes, however, arrays are unwieldy, and we want to use more strongly
    organized data structures so that they can be easier for humans to understand
    and write programs around. Oftentimes, what's appropriate here is a multi-dimensional
    array.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们最基本的数据结构是数组，它允许我们存储轻类型信息的序列，并通过内存中的单个位置访问这些信息。然而，有时数组不灵活，我们希望使用更强有力的组织数据结构，以便人类更容易理解和编写程序。在这种情况下，通常适合使用多维数组。
- en: '"Multidimensional array" is a pretty scary-sounding name, but in fact the concept
    behind it is very basic. The question is what happens if we create an array of
    arrays? The following line of code shows the syntax to do just that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “多维数组”听起来是一个相当可怕的名字，但实际上它背后的概念非常基本。问题是如果我们创建一个数组的数组会发生什么？以下代码显示了如何做到这一点的语法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This line of code will create a two-dimensional multidimensional array. You''ll
    see it''s very much like the syntax for simply creating an array of characters
    under normal circumstances, but in every instance where we reference the array
    variable now, Java is going to need two pieces of information (or two indexes).
    The preceding line of code will tell Java to create three arrays, each of which
    has enough space to store seven characters or three arrays of length seven:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将创建一个二维多维数组。你会看到它非常类似于在正常情况下简单创建字符数组的语法，但在我们现在引用数组变量的每个实例中，Java将需要两个信息（或两个索引）。前面的代码将告诉Java创建三个数组，每个数组都有足够的空间来存储七个字符或长度为七的三个数组：
- en: '![](img/fb6fae9f-b50e-4a72-bd5a-41c9a46a2c66.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb6fae9f-b50e-4a72-bd5a-41c9a46a2c66.png)'
- en: To cement our understanding of this concept, let's write a Java program that
    utilizes two-dimensional arrays.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们对这个概念的理解，让我们编写一个利用二维数组的Java程序。
- en: A multidimensional array example in NetBeans
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在NetBeans中的多维数组示例
- en: While we can use multidimensional arrays to store information in abstract manners,
    it will probably be easiest for us to learn them by representing an actual two-dimensional
    object with our two-dimensional array, in this case, a chessboard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多维数组以抽象的方式存储信息，但最容易的学习方法可能是通过用二维数组表示实际的二维对象，比如国际象棋棋盘。
- en: The classic chessboard is divided into black and white squares; it's eight squares
    in width and eight squares in height. The program we're about to write will store
    a virtual board in Java with the squares correctly labeled black and white. Then,
    at the end, we'll have it print this board out to us so that we can check whether
    we had written to our program correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的国际象棋棋盘被分成黑色和白色方块；宽度为八个方块，高度为八个方块。我们即将编写的程序将在Java中存储一个虚拟棋盘，并正确标记黑色和白色方块。然后，在最后，我们将打印出这个棋盘，以便我们可以检查我们是否正确地编写了程序。
- en: Creating a multidimensional array
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多维数组
- en: 'Let''s begin by simply declaring and initializing the array we''re going to
    be using. We''ll use an array of characters for this task, giving the white squares
    the character value of `W` and the black squares the character value of `B`. Since
    a chessboard is an eight by eight grid, we''re going to want to declare a two-dimensional
    array of eight arrays, each of which should contain eight characters:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先声明并初始化我们将要使用的数组。我们将使用字符数组来完成这个任务，给白色方块赋予字符值`W`，给黑色方块赋予字符值`B`。由于国际象棋棋盘是一个八乘八的网格，我们将声明一个包含八个数组的二维数组，每个数组应包含八个字符：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s make things even more difficult for someone to inadvertently break in
    by storing the dimensions of our board in a separate location. To do this, simply
    create a variable called `boardDim`, for board dimensions, assign it the value
    `8`, and then reference it when we create our arrays. Arrays will be perfectly
    happy to use an integer in a variable to initialize themselves, letting us create
    dynamically linked arrays if our program calls for it. Now, if someone wants to
    go to this program and scale up our chessboard, they need to only change the value
    of `boardDim`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将我们棋盘的尺寸存储在一个单独的位置来使某人更难无意中破坏。为此，只需创建一个名为`boardDim`的变量，为棋盘尺寸，将其赋值为`8`，然后在创建数组时引用它。数组将很乐意使用变量中的整数来初始化自己，让我们可以根据需要创建动态链接的数组。现在，如果有人想要扩大我们的国际象棋棋盘，他们只需要改变`boardDim`的值：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to assign our squares their proper values, we're going to need to loop
    through this array to get to each individual node and give it the value we want
    it to have.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的方块分配适当的值，我们需要循环遍历这个数组，以便到达每个单独的节点并给它赋予我们想要的值。
- en: Using nested loops for multidimensional arrays
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌套循环进行多维数组
- en: Loops and arrays get along great because arrays always know how long they are,
    but a single `for` loop doesn't allow us to meaningfully loop through a two-dimensional
    array. A `for` loop really just goes in one direction, and our two-dimensional
    arrays have two directions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和数组非常合适，因为数组总是知道它们的长度，但单个`for`循环不能让我们有意义地循环遍历二维数组。`for`循环实际上只是沿着一个方向进行，而我们的二维数组有两个方向。
- en: To solve this, we're going to make use of nested `for` loops, or a `for` loop
    within a `for` loop. Our outer `for` loop will loop through each array in turn,
    while the job of our inner `for` loop will be to loop through the nodes that those
    arrays contain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将利用嵌套的`for`循环，或者`for`循环中的`for`循环。我们的外部`for`循环将依次循环每个数组，而内部`for`循环的工作将是循环遍历这些数组包含的节点。
- en: A common practice when creating `for` loops is to use the integer variable `i`
    for your initial `for` loop, and then `j`, `k`, and so on for subsequent `for`
    loops. However, because we're creating a chessboard, which is an actual object,
    I'm going to choose the value `y` as our outer loop's counting variable. This
    is because what our loop is doing is iterating down the *y*-axis of our chessboard.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`for`循环时的常见做法是使用整数变量`i`作为初始`for`循环，然后使用`j`、`k`等变量作为后续`for`循环。然而，因为我们正在创建一个实际对象的棋盘，我将选择值`y`作为我们外部循环的计数变量。这是因为我们的循环正在沿着棋盘的*y*轴进行迭代。
- en: As mentioned earlier, `for` loops and arrays get along great because arrays
    know how long they are. We could simply state that we would like this loop to
    run eight times (`y<8`), but that's not good dynamic programming because if someone
    were to go along and change the size of our chessboard, our program would now
    break. We can write this loop such that it will work for a chessboard of any size.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`for`循环和数组非常合适，因为数组知道它们的长度。我们可以简单地声明我们希望这个循环运行八次（`y<8`），但这不是良好的动态编程，因为如果有人改变了棋盘的大小，我们的程序现在就会出错。我们可以编写这个循环，使其适用于任何大小的棋盘。
- en: 'To do this, rather than explicitly saying our loop should run eight times,
    we should have it start by asking our array how long it is. To ask an array its
    length, we just need to write `array.length` and this will returns an integer
    value. This is a two-dimensional array, so simply calling the name of the array
    to use the `length` variable will get us the length of the array''s outermost
    segment. In this case, we''re asking our two-dimensional array, "How many arrays
    do you have?" To finish off this `for` loop, we simply need to increment `y` after
    it runs each time. Thus, our outer `for` loop will loop through each array that
    our 2D array `board` contains:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们不应该明确地说我们的循环应该运行八次，而是应该让它开始询问我们的数组有多长。要询问数组的长度，我们只需要写`array.length`，这将返回一个整数值。这是一个二维数组，所以简单地调用数组的名称来使用`length`变量将得到数组最外层段的长度。在这种情况下，我们正在询问我们的二维数组，“你有多少个数组？”为了完成这个`for`循环，我们只需要在每次运行后递增`y`。因此，我们的外部`for`循环将循环遍历我们的2D数组`board`包含的每个数组：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s do something similar for our inner loop. Because this loop will
    be iterating through the individual elements of our rows, `x` for the *x*-axis
    seems an appropriate variable name to use. Because our array is currently the
    same length in both its segments, an eight by eight array, simply using the `board.length`
    statement, would work for now. But once again, it''s not good dynamic programming.
    If someone was to go through and change the size of our board to be eight by ten,
    this program would no longer execute properly. Instead, at the beginning of this
    inner `for` loop''s execution, let''s ask the array that we''ve currently accessed
    through the outer loop how long it individually is. This once again makes our
    program robust and allows us to accommodate multiple sizes for our board:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对内部循环做类似的事情。因为这个循环将遍历我们行的单个元素，所以对于*x*轴来说，`x`似乎是一个合适的变量名。因为我们的数组目前在两个部分中的长度相同，即一个八乘八的数组，简单地使用`board.length`语句，现在可以工作。但再一次，这不是良好的动态编程。如果有人通过更改我们的棋盘大小为八乘十，这个程序将不再正确执行。相反，在这个内部`for`循环执行的开始，让我们询问我们当前通过外部循环访问的数组有多长。这再次使我们的程序健壮，并允许我们适应棋盘的多种尺寸：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'OK, the next step in our program is to assign character values to each node
    in our array: `B` for black squares and `W` for white squares. Let''s start off
    by writing the code to make all the squares white. Our double `for` loop will
    pass through each node in our two-dimensional array when it executes. So, each
    time we execute the code in our inner `for` loop, we''re executing it in terms
    of one of the single two-dimensional array nodes. To get this node, we''re going
    to need to ask our `board` array what is located at row `y` and column `x`, and
    then we''ll change the value of that node:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们程序的下一步是为数组中的每个节点分配字符值：黑色方块为`B`，白色方块为`W`。让我们首先编写代码使所有方块都是白色的。当我们执行双重`for`循环时，它将通过我们的二维数组中的每个节点。因此，每次我们执行内部`for`循环中的代码时，我们都是根据单个二维数组节点来执行的。为了获得这个节点，我们需要询问我们的`board`数组在第`y`行和第`x`列的位置是什么，然后我们将改变该节点的值：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Assigning different colors to our chessboard
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的棋盘分配不同的颜色
- en: The thing is, each time this inner loop executes, we're going to want a different
    value for the nodes so that we get a chessboard that is alternating white and
    black squares. To help us do this, let's add another variable to our program.
    It'll be a Boolean variable, and we'll just call it `isWhite`. If `isWhite` is
    `true`, then the next square we add will be white; if `isWhite` is false, the
    square will be black.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，每次这个内部循环执行时，我们都希望节点的值不同，这样我们就得到了交替的白色和黑色方块的棋盘。为了帮助我们做到这一点，让我们在程序中添加另一个变量。它将是一个布尔变量，我们将其称为`isWhite`。如果`isWhite`为`true`，那么我们添加的下一个方块将是白色；如果`isWhite`为false，方块将是黑色。
- en: To code this out, let's use some `if` statements. Firstly, the `if(isWhite)`
    code term checks whether `isWhite` is `true`. If it is, then we put a `W` in our
    square. If `isWhite` is `false`, we put a `B` in the square for black. To check
    whether something is not true, we can invert any Boolean value with an exclamation
    point beforehand. This will work for Boolean or even conditional statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写代码，让我们使用一些`if`语句。首先，`if(isWhite)`代码术语检查`isWhite`是否为`true`。如果是，我们就在方块中放一个`W`。如果`isWhite`是`false`，我们就在方块中放一个`B`代表黑色。要检查某事是否不是真的，我们可以在条件语句之前用感叹号来翻转任何布尔值。这对布尔值甚至条件语句都适用。
- en: 'Next, we simply need to flip the value of `isWhite`. Well, using our knowledge
    of the exclamation point operator, which flips the value of Boolean, we can flip
    the value of `isWhite` from `true` to `false` or `false` to `true` by simply setting
    its value to the knotted version of itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要翻转`isWhite`的值。好吧，利用我们对感叹号运算符的知识，它可以翻转布尔值的值，我们可以通过简单地将其值设置为其自身的倒数版本，将`isWhite`的值从`true`翻转为`false`或从`false`翻转为`true`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unfortunately, this program is not quite perfect. It turns out that if we do
    this, our chessboard is going to have every single row starting off with a white
    square, while a real chessboard alternates with every other row with a different
    colored square.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个程序还不够完美。事实证明，如果我们这样做，我们的棋盘将每一行都以白色方块开头，而真正的棋盘是每隔一行用不同颜色的方块交替的。
- en: 'Fortunately, the outer loop runs once for each row of the chessboard. So if
    we were to simply add an extra flip to our `isWhite` Boolean value at the start
    of every row, we would get alternating row starts as well. If we do it like this,
    we need to start `isWhite` off as `false` because it''s going to be immediately
    changed to `true` when the outer loop executes for the first time:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，外部循环对棋盘的每一行运行一次。因此，如果我们在每一行的开头简单地给我们的`isWhite`布尔值添加一个额外的翻转，我们也会得到交替的行开头。如果我们这样做，我们需要将`isWhite`的初始值设为`false`，因为当外部循环第一次执行时，它将立即更改为`true`：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Printing the chessboard
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印棋盘
- en: If you've followed along thus far, let's go ahead and write the final bit of
    our program, a line of code to print out our chessboard to the screen. Actually,
    we're going to need a bit more than a line of code. We can use the `println()`
    function along with `arrays.toString()` to print the contents of a single array
    to the screen, but this technique won't work well with a two-dimensional or higher
    array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您迄今为止一直在跟进，请继续编写我们程序的最后一部分，一行代码来将我们的棋盘打印到屏幕上。实际上，我们需要的不仅仅是一行代码。我们可以使用`println()`函数以及`arrays.toString()`来将单个数组的内容打印到屏幕上，但是这种技术在二维或更高维数组中效果不佳。
- en: 'So, we''re going to need to use a `for` loop again to grab each array in turn,
    and then print them to the screen. This works pretty well because `println` will
    automatically carriage return, or give us a new line between each row we print.
    Here, let''s use the conventional syntax variable `i` to iterate through our `for`
    loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要再次使用`for`循环来依次抓取每个数组，然后将它们打印到屏幕上。这很有效，因为`println`将自动换行，或者在我们打印每一行之间给我们一个新行。在这里，让我们使用传统的语法变量`i`来迭代我们的`for`循环：
- en: '![](img/e9febda2-dfd7-4516-9fde-4248e4d90dcb.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9febda2-dfd7-4516-9fde-4248e4d90dcb.png)'
- en: 'You''ll notice that Java does not yet understand the `Arrays` keyword as shown
    in the preceding screenshot; that''s because `Arrays` lives in the `java.lang`
    package. It can be kind of annoying when we call a function or a class and Java
    doesn''t immediately know where to find it, and we have to go online and locate
    it on Google. If we''re working in an IDE, such as NetBeans, sometimes there''s
    a shortcut to find common packages. In this case, if we right-click on the problem
    statement and go to Fix Imports, NetBeans will go through the common packages
    and check whether it can figure out what we''re doing:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，Java还不理解前面截图中显示的`Arrays`关键字；这是因为`Arrays`位于`java.lang`包中。当我们调用函数或类时，Java不知道立即在哪里找到它，我们必须上网在Google上找到它时，这可能有点烦人。如果我们在IDE中工作，比如NetBeans，有时会有一个查找常用包的快捷方式。在这种情况下，如果我们右键单击问题语句并转到“修复导入”，NetBeans将浏览常用包并检查是否可以弄清楚我们在做什么：
- en: '![](img/ad6ff3b4-9a65-4431-b208-6bca9a0bfe94.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad6ff3b4-9a65-4431-b208-6bca9a0bfe94.png)'
- en: 'In this case, NetBeans has located the `Arrays` class and added the import
    statement for us:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，NetBeans已经找到了`Arrays`类并为我们添加了导入语句：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, because we don''t want to attempt to print out the contents of the two-dimensional
    array each time our `for` loop executes (which wouldn''t work very well anyway),
    we''re going to tell our `println` statement to print out the contents of `board[i]`,
    or the individual array, within the two-dimensional array that we''ve accessed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们不想在每次`for`循环执行时尝试打印二维数组的内容（这样也不会很好），我们将告诉我们的`println`语句打印`board[i]`的内容，或者我们已经访问的二维数组中的单个数组：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s see whether we got everything right the first time through and
    run our program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们第一次是否做得对，并运行我们的程序：
- en: '![](img/8e6cded2-3f5b-4752-8e51-5bd514db59e9.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e6cded2-3f5b-4752-8e51-5bd514db59e9.png)'
- en: Wow! It looks like we did. There's an alternating white and black representation
    of a chessboard that begins with a white square and has rows starting in the proper
    manner. This might not look like much now, but its significance is pretty big.
    We've essentially taught our program how a chessboard looks. This is our first
    step toward creating something much bigger, such as a program that plays chess.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！看起来我们做到了。有一个交替的白色和黑色的棋盘表示，以白色方块开始，并且行以正确的方式开始。现在可能看起来不起眼，但它的意义很大。我们基本上教会了我们的程序棋盘是什么样子。这是我们朝着创建更大的东西迈出的第一步，比如一个下棋的程序。
- en: 'Were we to create a program that plays chess (which is a little out of the
    scope of this section here, but we can talk about it conceptually), we would probably
    want our individual squares to be able to store more information than just what
    color they were. For example, we would probably want them to know what piece was
    on them. To make this happen, we could utilize a three-dimensional array. We could
    create an array that looks like the following so that each square could store
    an array that holds two pieces of information, one character for its color and
    another character to represent what piece it''s on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个下棋程序（这有点超出了本节的范围，但我们可以在概念上讨论一下），我们可能希望我们的每个方块能够存储更多信息，而不仅仅是它们的颜色。例如，我们可能希望它们知道上面有什么棋子。为了实现这一点，我们可以利用三维数组。我们可以创建一个看起来像下面这样的数组，以便每个方块可以存储一个包含两个信息的数组，一个字符表示它的颜色，另一个字符表示它上面有什么棋子：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So that's the basics of multidimensional arrays in Java.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java中多维数组的基础。
- en: ArrayLists
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayLists
- en: When we need a Java data structure, we should start by asking ourselves whether
    a simple array is sufficient. If we can write our program easily and neatly using
    just an array, that might be our best option to keep our programs simple by extension.
    If you're writing code that must run as fast as possible and use memory as efficiently
    as possible, arrays will also have very little overhead. But, in today's development
    world, where memory efficiency and speed really aren't concerns for your average
    program, sometimes we need to employ data structures with more built-in functionality,
    or maybe which are designed for a specific purpose.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个Java数据结构时，我们应该首先问自己是否简单的数组就足够了。如果我们可以使用一个简单的数组轻松整洁地编写我们的程序，那可能是保持程序简单的最佳选择。如果你正在编写必须尽可能快地运行并尽可能高效地使用内存的代码，数组也将几乎没有额外开销。但是，在今天的开发世界中，内存效率和速度对于普通程序来说真的不是问题，有时我们需要使用具有更多内置功能的数据结构，或者可能是为特定目的而设计的数据结构。
- en: A data structure with additional functionality is called an ArrayList. One of
    the weaknesses of traditional arrays is that when we instantiate them, we have
    to give them a specific length, so we have to know how large we want our array
    to be. An ArrayList is basically an array wrapped in some additional code that
    causes the array to increase or decrease in size to always be the size of the
    number of elements it contains.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 具有附加功能的数据结构称为ArrayList。传统数组的一个弱点是，当我们实例化它们时，我们必须给它们一个特定的长度，因此我们必须知道我们希望数组有多大。ArrayList基本上是一个包装在一些附加代码中的数组，这些代码导致数组的大小增加或减小，以始终保持与其包含的元素数量相同的大小。
- en: An ArrayList example in NetBeans
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans中的一个ArrayList示例
- en: To see this in action, let's write a program that would actually be a little
    more difficult to write if we just used a standard array instead of an ArrayList.
    I'd like to write a program that will take an input string from the user. It will
    store this input string with every other input string the user has ever given
    it, and then print them all out each time the user inputs a new string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个实例，让我们编写一个程序，如果我们只使用标准数组而不是ArrayList，那么编写起来可能会更困难一些。我想编写一个程序，它将从用户那里获取一个输入字符串。它将存储这个输入字符串以及用户以前给它的每个其他输入字符串，然后每次用户输入一个新字符串时都打印它们出来。
- en: This would be really difficult to do with an array because if the user ever
    inputs one more string than the array was designed to hold, our array would, in
    the best-case scenario, not accept the string; in the worst-case scenario, our
    program might crash. But, our ArrayList object will simply resize to fit the number
    of strings that it's currently holding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是非常困难的，因为如果用户输入的字符串比数组设计的容量多一个，数组将在最好的情况下不接受字符串；在最坏的情况下，程序可能会崩溃。但是，我们的ArrayList对象将简单地调整大小以适应它当前持有的字符串数量。
- en: Creating an ArrayList
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个ArrayList
- en: 'We need to begin by importing `java.util`, because `java.util` is where the
    `Scanner` class, which we''ll need to get user input, and the `ArrayList` class
    itself, live. Once we''ve declared a `Scanner`, which we''ll utilize a bit more
    later, it''s time for us to declare our `ArrayList`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从导入`java.util`开始，因为`java.util`是`Scanner`类（我们需要获取用户输入）和`ArrayList`类本身所在的地方。一旦我们声明了一个`Scanner`，我们稍后会更多地利用它，现在是时候声明我们的`ArrayList`了：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Simply declaring `ArrayList` looks a lot like declaring any other object. We
    say what type of object we'd like to create. We give it a name. We use the `new`
    keyword because Java is going to have to set aside some memory to create this
    object since it's not a primitive. Then, we tell Java to actually create the object.
    Even though we're not going to provide any arguments for our `ArrayList` creation,
    we still need to follow it with the double parentheses. This is actually valid
    code we've just written, but generally when we create an `ArrayList`, we're going
    to do a little bit more.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地声明`ArrayList`看起来很像声明任何其他对象。我们说出我们想创建的对象的类型。我们给它一个名字。我们使用`new`关键字，因为Java将不得不设置一些内存来创建这个对象，因为它不是原始的。然后，我们告诉Java实际创建对象。即使我们不会为我们的`ArrayList`创建提供任何参数，我们仍然需要在其后跟上双括号。这实际上是我们刚刚编写的有效代码，但通常当我们创建一个`ArrayList`时，我们会做更多的事情。
- en: The `ArrayList` memory that we've created will actually store any type of single
    entity we place within it. This might sound really, really great at first, but
    honestly, it's not a good thing to have in our program. It's really easy to get
    confused if we have ArrayLists, or any data structure, really, that's storing
    just about anything, and if we feel the need to do this, we're either doing something
    really complicated, or more likely we're not writing our code as cleanly as we
    should. More importantly, once we store anything in our ArrayList, it's possible
    for us to sneak by our compiler and create code that compiles OK. However, the
    other possibility is that it would break at runtime, causing the kind of bugs
    that are really bad to have in commercial software because they can break when
    people are actually using it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`ArrayList`内存实际上将存储我们放入其中的任何类型的单个实体。这一开始听起来可能非常好，但老实说，在我们的程序中这不是一件好事。如果我们有ArrayLists，或者任何数据结构，实际上存储了几乎任何东西，很容易感到困惑，如果我们觉得有必要这样做，要么我们正在做一些非常复杂的事情，要么更可能的是我们没有编写我们的代码如我们应该那样清晰。更重要的是，一旦我们在ArrayList中存储任何东西，我们就有可能绕过编译器并创建编译正常的代码。然而，另一种可能性是它会在运行时出错，导致那种在商业软件中非常糟糕的bug，因为它们在人们实际使用时可能会出现问题。
- en: 'To solve this problem, we can tell our ArrayList to only accept information
    of a certain type. We do this by following our `ArrayList` declaration and instantiation
    with double character brackets and placing a type within them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以告诉我们的ArrayList只接受特定类型的信息。我们通过在`ArrayList`声明和实例化后跟随双字符括号，并在其中放置一个类型来实现这一点：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've declared and then caused to come into being an `ArrayList` data structure
    that will only allow strings to be stored within it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并使`ArrayList`数据结构成为可能，它只允许存储字符串。
- en: Getting user input
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: 'We''re going to need a loop so that our user can input more than one string
    to the program. For now, let''s just use an infinite loop. It will run forever,
    but while we''re building our program and debugging it, we can always just stop
    it manually:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个循环，这样我们的用户可以向程序输入多个字符串。现在，让我们只使用一个无限循环。它将永远运行，但在构建程序和调试程序时，我们总是可以手动停止它：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each time our loop runs, we're going to want to use the `nextLine()` function
    on our Scanner variable, that is, `reader`, to grab a new line of input from the
    user that we're going to store in our ArrayList.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环运行时，我们都要使用Scanner变量`reader`上的`nextLine()`函数，从用户那里获取一个新的输入行，并将其存储在我们的ArrayList中。
- en: When we're working with object data structures, that is, data structures that
    have code wrapped around them, and functions and methods of their own, we're generally
    not going to have to deal with the individual indices of memory, which can be
    pretty nice. Instead, we use their provided functions to add, remove, and manipulate
    the information within them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用对象数据结构时，也就是说，具有自己的代码包装、函数和方法的数据结构时，通常不需要处理内存的各个索引，这可能非常好。相反，我们使用它们提供的函数来添加、删除和操作其中的信息。
- en: 'In this case, adding something to an ArrayList is pretty easy. The `add()`
    function in ArrayList will add whatever input we give it, in our case, as long
    as it''s a string, to the end of the array that the ArrayList contains. So, let''s
    add the following line of code that will request a new input string from the user
    and then put it at the end of our ArrayList inside our infinite `while` loop:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，向ArrayList添加内容非常容易。ArrayList中的`add()`函数将添加我们提供的任何输入，也就是说，只要它是一个字符串，就会将其添加到ArrayList包含的数组的末尾。因此，让我们添加以下代码行，它将请求用户输入一个新的字符串，然后将其放在我们的无限`while`循环内的ArrayList末尾：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Printing the ArrayList of user input
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印用户输入的ArrayList
- en: 'Now, we can simply use `println` to print our ArrayList out to the user. Note
    that the `println` code line doesn''t know how to take an ArrayList as input.
    Actually, it might, but we should explicitly use the `toString()` function, which
    almost every object in Java implements:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地使用`println`将我们的ArrayList打印给用户。请注意，`println`代码行不知道如何将ArrayList作为输入。实际上，它可能知道，但我们应该明确使用`toString()`函数，几乎每个Java对象都实现了它：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we run our program, we''ll be prompted for some user input, and we''ll
    see the input echoed back out at us. If we give Java some more input, we''ll see
    our more input, and the old input will be stored in our `ArrayList`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的程序时，我们将被提示输入一些用户输入，并且我们将看到输入被回显。如果我们给Java一些更多的输入，我们将看到更多的输入，并且旧的输入将被存储在我们的`ArrayList`中：
- en: '![](img/e01f0a61-f15e-4542-b690-6f8bdfa5e77e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e01f0a61-f15e-4542-b690-6f8bdfa5e77e.png)'
- en: So that's pretty cool! We've built a really basic program that would be more
    difficult to write with a simple array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很酷！我们已经构建了一个非常基本的程序，使用简单的数组写起来会更困难。
- en: Giving control to the user
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将控制权交给用户
- en: ArrayLists have a lot of power contained within them. We can turn them into
    arrays, create them from arrays, and all sorts of things. If we go to the Java
    documentation and check under `java.util` for ArrayList, we can find all of their
    methodologies. Let's add few more features to our ArrayList program so that I
    can walk you through some common ArrayList methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayLists内含有很多强大的功能。我们可以将它们转换为数组，从数组创建它们，以及各种其他操作。如果我们去Java文档并在`java.util`下查找ArrayList，我们可以找到它们的所有方法。让我们给我们的ArrayList程序添加一些功能，这样我就可以向您介绍一些常见的ArrayList方法。
- en: 'ArrayLists have a function that takes no input, called `clear()`, which will
    erase our ArrayList. We can utilize this function to give our users some control
    over our program. Let''s say that if the user inputs the string `CLEAR`, we would
    like to erase all of the information in our ArrayList. Well, that''s a conditional
    statement I just made, so we use an `if` statement. We''d utilize the following
    `if` statement code inside our `while` loop to implement this functionality:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayLists有一个不需要输入的函数，称为`clear()`，它将擦除我们的ArrayList。我们可以利用这个函数来让我们的用户对我们的程序有一些控制。假设如果用户输入字符串`CLEAR`，我们想要擦除ArrayList中的所有信息。好吧，这是一个条件语句，所以我们使用`if`语句。我们将在我们的`while`循环内部使用以下`if`语句代码来实现这个功能：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, we need to check the item just added to our ArrayList against the string
    `CLEAR`. This item will be at the very end, that is, it will be the last item
    with the highest index value. Unfortunately, there''s no `lastItem()` function
    implemented for ArrayList, but we can essentially create one ourselves by mashing
    together two ArrayList functions: `get()` and `size()`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查刚刚添加到我们的ArrayList中的项目是否与字符串`CLEAR`相匹配。这个项目将位于最后，也就是说，它将是具有最高索引值的最后一个项目。不幸的是，ArrayList没有实现`lastItem()`函数，但我们可以通过将两个ArrayList函数`get()`和`size()`组合在一起来创建一个自己的函数。
- en: First, in order to get an item from an ArrayList, we utilize the `get()` function.
    Note that `get()` is very similar to the square brackets we would utilize if we
    were accessing an item from a traditional array. Also, the `get()` function is
    going to take an integer value and it's going to map that integer to the index
    of the array contained within our ArrayList.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了从ArrayList中获取一个项目，我们利用`get()`函数。请注意，`get()`与我们访问传统数组中的项目时会使用的方括号非常相似。此外，`get()`函数将接受一个整数值，并将该整数映射到包含在我们的ArrayList中的数组的索引。
- en: So, to get the last item in our ArrayList, we need to know how many items are
    there in the ArrayList. Then, we want to subtract one from that value, because
    the last index of an array with the length of, let's say seven, would be six,
    since the array starts counting at zero. To get how many items are there in our
    ArrayList, we use the `size()` function, which takes no arguments and simply gives
    us an integer that is the size of the array, that is, how many items it contains.
    We subtract `1` from that value so that we can properly access the last index
    and not the index behind it, which could contain anything. Then, we wrap the whole
    `memory.get(memory.size()-1)` block, which accesses the last item of our `ArrayList`
    in parentheses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要获取我们的ArrayList中的最后一个项目，我们需要知道ArrayList中有多少个项目。然后，我们想从该值中减去一个，因为长度为7的数组的最后一个索引将是6，因为数组从零开始计数。要获取我们的ArrayList中有多少个项目，我们使用`size()`函数，它不需要参数，只是给我们一个整数，即数组的大小，即它包含多少个项目。我们从该值中减去`1`，以便我们可以正确访问最后一个索引，而不是其后面的索引，它可能包含任何内容。然后，我们将整个`memory.get(memory.size()-1)`块，它访问我们的`ArrayList`的最后一个项目，用括号括起来。
- en: 'This block of our `if` statement we just parenthesized gets for us a string
    object. We know that we can compare strings by using the `equals()` method. We
    can actually call that method from the string object that this block of code returns,
    even though we haven''t assigned it a specific variable name yet. Objects exist
    even if we don''t have a name for them, and we can call their methods and do just
    about anything we like with them if we''ve just returned them from something else:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚括起来的`if`语句块为我们获取了一个字符串对象。我们知道可以使用`equals()`方法来比较字符串。实际上，我们可以从这个代码块返回的字符串对象中调用该方法，即使我们还没有为它分配一个特定的变量名。对象存在，即使我们没有它们的名称，如果我们刚刚从其他地方返回它们，我们可以调用它们的方法，并且可以做任何我们喜欢的事情。
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, that's a pretty crazy statement we've just written, but as long as we've
    written it right, when our user enters `CLEAR` in the program, we will erase the
    ArrayList.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个我们刚刚写的非常疯狂的语句，但只要我们写得正确，当我们的用户在程序中输入`CLEAR`时，我们将擦除ArrayList。
- en: 'Once we''ve written this code, we can write very similar code to give our user
    different functionality options. Let''s also allow our user to type in `END`.
    Currently, we''re in a program that will loop infinitely until we manually turn
    it off. But by using the `break` Java keyword, which will jump us out of whatever
    loop we''re in, or function if we''re in a function, we can make this an escapable
    loop. This way, we let the user essentially turn off our program because once
    we leave this loop, there''s no more code to execute and our program will end:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 写完这段代码后，我们可以编写非常类似的代码，为我们的用户提供不同的功能选项。让我们也允许用户输入`END`。目前，我们处于一个将无限循环直到我们手动关闭它的程序中。但是通过使用`break`
    Java关键字，它将使我们跳出我们所在的任何循环，或者如果我们在一个函数中，它将使我们跳出该函数，我们可以使这个循环可以被打破。这样，我们可以让用户基本上关闭我们的程序，因为一旦我们离开这个循环，就没有更多的代码可以执行，我们的程序将结束：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be careful when you're using `break` statements. Make sure it makes sense to
    do so, because they can be a little confusing if you're going through someone's
    code. They break and jump the control flow all over the place.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`break`语句时要小心。确保这样做是有意义的，因为如果你在阅读别人的代码时，它们可能会让人有点困惑。它们会打破并跳转控制流到各个地方。
- en: 'So let''s run this program and see what happens. We''ll start by giving our
    program some input and build the ArrayList:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们运行这个程序，看看会发生什么。我们将从给我们的程序一些输入开始，并构建ArrayList：
- en: '![](img/ae823de0-08af-458a-a9c0-062b10bb890b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae823de0-08af-458a-a9c0-062b10bb890b.png)'
- en: 'Now let''s try inputting `CLEAR` and check whether it empties our ArrayList.
    Oh no! I broke it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试输入`CLEAR`并检查它是否清空了我们的ArrayList。哦，不！我把它弄坏了：
- en: '![](img/daa354cd-4dd8-4f52-ab30-374efe042f27.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daa354cd-4dd8-4f52-ab30-374efe042f27.png)'
- en: This is actually a pretty interesting error that we made. I actually made this
    error; it wasn't preplanned. I'm going to leave it in because this is a great
    learning experience for us. It also shows you that even if you're an experienced
    programmer, you're going to make mistakes. One of the reasons why we should use
    typed ArrayLists whenever we can, for example, is so that we can easily figure
    out and fix our mistakes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个非常有趣的错误。我实际上犯了这个错误；这不是预先计划的。我会留下它，因为这对我们来说是一个很好的学习经验。它还表明，即使你是一名经验丰富的程序员，你也会犯错误。例如，我们应该尽可能使用带类型的ArrayList，这样我们就可以轻松地找出并纠正我们的错误。
- en: Analyzing ArrayIndexOutOfBoundsException
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析ArrayIndexOutOfBoundsException
- en: Our program has thrown an `ArrayIndexOutOfBoundsException`. This means that
    we tried to access memory that our `memory` array did not have access to. Specifically,
    we tried to look at what was at the index `-1` of the array. Since arrays start
    at index `0`, they don't have anything at index `-1`. Any piece of our computer's
    memory could be there, and for security reasons, programs aren't allowed to just
    go looking through a computer's memory because they want to. So, why did this
    happen? Why did we ask for index `-1` of an array, which is never going to be
    a valid array index?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序抛出了`ArrayIndexOutOfBoundsException`。这意味着我们试图访问我们的`memory`数组没有访问权限的内存。具体来说，我们试图查看数组索引-1处的内容。由于数组从索引0开始，它们没有任何内容在索引-1处。计算机内存的任何部分都可能在那里，出于安全原因，程序不允许随意查看计算机的内存。那么，为什么会发生这种情况？为什么我们要求查看数组的索引-1，这永远不会是有效的数组索引？
- en: Well, our first `if` statement that implemented the functionality to clear our
    ArrayList executed just fine. Our program saw our `CLEAR` command, understood
    our first look at our array index, and cleared the array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们第一个实现清除ArrayList功能的`if`语句执行得很好。我们的程序看到了我们的`CLEAR`命令，理解了我们对数组索引的第一次查看，并清空了数组。
- en: Immediately following this, we asked our program to again check the last item
    added to our array, using the second `if` statement. When we did this, we executed
    `memory.size()-1`. First, we asked Java about the size of our ArrayList. Because
    we just cleared our ArrayList, Java told us that the size of the ArrayList was
    zero, that there was nothing in it. Then we subtracted one from that value to
    get -1\. Post this, we ran `memory.get()` on that `-1` value. Thus, we asked Java
    to take a look at what was at index `-1` of our array, at which point Java said,
    "Whoa! What are you doing? It's not cool, I'm going to crash!"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们要求程序再次检查添加到数组中的最后一项，使用第二个`if`语句。当我们这样做时，我们执行了`memory.size()-1`。首先，我们询问Java关于我们的ArrayList的大小。因为我们刚刚清空了ArrayList，Java告诉我们ArrayList的大小为零，里面什么也没有。然后我们从这个值中减去1，得到-1。然后，我们在这个-1值上运行`memory.get()`。因此，我们要求Java查看数组索引-1处的内容，此时Java说：“哇！你在干什么？这不好，我要崩溃了！”
- en: So, how do we solve this? Well, there's a couple of things we could do. We should
    probably just check and make sure that our arrays are not empty before we run
    the functions in the second `if` statement. That option looks like a few more
    lines of code than I want to put. It's not undoable in any sense of the word,
    and I encourage you to try and implement a better solution than this yourself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？嗯，我们可以做一些事情。我们应该在运行第二个`if`语句中的函数之前检查并确保我们的数组不为空。这个选项看起来比我想要的代码行数多一些。这并不是不可逆转的，我鼓励你尝试并实现比这更好的解决方案。
- en: 'For now, just to get our program quickly up and running without crashing, let''s
    change the pair of `if` blocks to an `if...else` statement as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，为了让我们的程序快速启动并且不崩溃，让我们将一对`if`块改为`if...else`语句如下：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've embedded the second `if` statement in the `else` block. This will prevent
    us from ever running both of the `if` blocks back to back. If our first `if` statement
    evaluates to be true and our clear statement gets executed, then we will not check
    for the second `if` statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第二个`if`语句嵌入了`else`块中。这将阻止我们连续运行两个`if`块。如果我们的第一个`if`语句评估为真并且我们的清除语句被执行，那么我们将不会检查第二个`if`语句。
- en: 'Now, if we run our program and give some gibberish input to build up our ArrayList,
    and then type in `CLEAR`, we''re going to properly get the response of an empty
    ArrayList:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行程序并输入一些胡言乱语来构建我们的ArrayList，然后输入`CLEAR`，我们将正确地得到一个空的ArrayList的响应：
- en: '![](img/7adf9ca8-08b9-4c14-9d90-873227e545ea.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7adf9ca8-08b9-4c14-9d90-873227e545ea.png)'
- en: We'll never hit the second `if` statement with an array of size `0` because
    we're always going to add a line to our array beforehand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会在大小为0的数组上触发第二个`if`语句，因为我们总是会在之前向数组中添加一行。
- en: 'Now, let''s cross our fingers and check that the `END` input works:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们祈祷并检查`END`输入是否有效：
- en: '![](img/4da83cb8-0be7-42ee-998b-1fb11670670b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4da83cb8-0be7-42ee-998b-1fb11670670b.png)'
- en: It does! The break command breaks specifically out of loops and functions, so
    even though we've nested it within an if and else statement, it's still going
    to break us out of the `while` loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实会！`break`命令专门用于跳出循环和函数，所以即使我们将其嵌套在if和else语句中，它仍然会将我们从`while`循环中跳出来。
- en: I think that little trip up we had was a great learning experience. That's actually
    a pretty interesting error we ran into. Nonetheless, I hope you've seen how different
    data structures have different purposes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们遇到的小问题是一个很好的学习经验。我们遇到的错误实际上是一个非常有趣的错误。尽管如此，我希望你已经看到不同的数据结构有不同的用途。
- en: Maps
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'In this section, we''re going to take a look at Java''s `Map` data structure.
    I wanted to start with a bunch of already formatted information, so I have created
    a little program on my own. You will find the following program in the companion
    files for the book. Take a look through it and make sure you understand how it
    works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究Java的`Map`数据结构。我想从一堆已经格式化的信息开始，所以我自己创建了一个小程序。你可以在本书的附属文件中找到以下程序。仔细查看它，确保你理解它的工作原理：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I'm operating on the assumption that we're not yet familiar with file input
    and output, so I dropped all of the data that we'd normally want to store in a
    file, or somewhere more manageable, right in the code of our program. I have created
    a `String` array that I've called `allNames`, and what it is a list of names of
    famous people. Their individual first and last names are also divided. So `Jane`,
    `Addams` comprises the first two elements of the array. Her first name `Jane`
    is part of `allNames[0]`, and then `Addams`, her last name, is at `allNames[1]`,
    and so on, with every two elements in the array being a single person's first
    and last name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设我们还不熟悉文件输入和输出，所以我把我们通常想要存储在文件中或其他更可管理的地方的所有数据都放在了我们程序的代码中。我创建了一个名为`allNames`的字符串数组，它是一组名人的名字。他们各自的名和姓也被分开。所以`简`，`亚当斯`是数组的前两个元素。她的名`简`是`allNames[0]`的一部分，然后`亚当斯`，她的姓，是在`allNames[1]`，以此类推，数组中的每两个元素是一个人的名和姓。
- en: 'This is also a good chance for me to show you a nifty little NetBeans feature
    that''s available in most IDEs. We can talk to our IDEs often if they support
    features such as these by putting instructions for them in the comments of our
    code. Because these instructions are commented out, they won''t in any way affect
    the way our Java code compiles and runs, but we can talk to the IDE. The following
    instruction in the program, paired with its ending instruction, tells NetBeans
    that we''d like it to section off the code included between them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我向你展示一个很棒的小功能的好机会，这个功能在大多数IDE中都可以使用。如果我们的IDE经常支持这样的功能，我们可以通过在代码的注释中放置对它们的指令来与它们交流。因为这些指令被注释掉了，它们不会以任何方式影响我们的Java代码的编译和运行，但我们可以与IDE交流。程序中的以下指令和它的结束指令告诉NetBeans我们想要它将它们之间包含的代码分隔开：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can use the little box on the left-hand side of our opening instruction
    to expand and contract the block of code as shown in the following screenshots:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用左侧的小框来展开和收缩代码块，就像下面的截图所示：
- en: '![](img/abf0f56c-f800-4b58-ac72-23308b838434.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abf0f56c-f800-4b58-ac72-23308b838434.png)'
- en: 'It doesn''t make the code go away; it just hides it from us so that we can
    develop it without cluttering up our screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有使代码消失；它只是把它从我们面前隐藏起来，这样我们就可以在不弄乱屏幕的情况下开发它：
- en: '![](img/7535308f-d7b1-46cf-8b1a-43623e9b0262.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7535308f-d7b1-46cf-8b1a-43623e9b0262.png)'
- en: 'Now, let''s look at a very quick explanation of the program I''ve written to
    start this section off. We have an array of strings called `allNames` that contains
    the first and last names of a bunch of famous people. The program I''ve written
    simply loops through this array and determines whether it''s looking at the first
    or last name. Then it places those names in separate arrays of their own. At the
    end, when we print out these arrays, we have two separate arrays: one of first
    names and one of last names. The relationship of these arrays, because we''ve
    placed them into the two separate arrays (`firstNames` and `lastNames`) in order,
    is that the indexes of the arrays match up. So, at `firstNames[0]` and `lastNames[0]`,
    we have the first and last names of Jane Addams.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我写的程序的一个非常快速的解释，以开始这一部分。我们有一个名为`allNames`的字符串数组，其中包含许多名人的名和姓。我写的程序简单地循环遍历这个数组，并确定它是在查看名字还是姓。然后它将这些名字放在它们自己的单独的数组中。最后，当我们打印出这些数组时，我们有两个单独的数组：一个是名字的数组，一个是姓的数组。这些数组的关系是，因为我们将它们按顺序放入了两个单独的数组（`firstNames`和`lastNames`）中，所以数组的索引是匹配的。因此，在`firstNames[0]`和`lastNames[0]`，我们有简·亚当斯的名字和姓。
- en: 'What I''d like to do now is expand this program and place all of this information
    in a single data structure: a Java `Map`. While creating such a Map, we let it
    know the relationship between one set, which we call the keys, and the other set,
    which we call the values, so that each key maps to the value. This will allow
    us to ask our program questions, such as, "Given a famous person''s last name,
    what is the first name that is associated with it?"'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想扩展这个程序，并将所有这些信息放在一个单一的数据结构中：一个Java`Map`。在创建这样一个Map时，我们让它知道一个集合之间的关系，我们称之为键，另一个集合，我们称之为值，这样每个键都映射到值。这将允许我们向我们的程序提问，比如，“给定一个名人的姓，与之相关联的名字是什么？”
- en: Creating a Map
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Map
- en: 'To begin, I''ve gone ahead and imported `java.util` where the `Map` interface
    lives. Next, I''ll get rid of the last two `println` statements that prints the
    `firstNames` and `lastNames` arrays. Instead, at this point in our code, when
    our `firstNames` and `lastNames` arrays have been set up, let''s start constructing
    our `Map`. For this, add the following line of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我已经导入了`java.util`，那里有`Map`接口。接下来，我将删除打印`firstNames`和`lastNames`数组的最后两个`println`语句。相反，在我们的代码中的这一点上，当我们的`firstNames`和`lastNames`数组已经设置好时，让我们开始构建我们的`Map`。为此，添加以下代码行：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We begin by using the `Map` keyword and then, as with most data structures,
    we tell Java what type of information our `Map` is going to take. Maps take two
    sets of information, so we'll have to give it two information types that are comma-separated.
    The first information type is the information type for the Map's keys, and the
    second information type is the type for the Map's values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`Map`关键字，然后，与大多数数据结构一样，我们告诉Java我们的`Map`将要接受什么类型的信息。Map接受两组信息，所以我们必须给它两个以逗号分隔的信息类型。第一个信息类型是Map的键的信息类型，第二个信息类型是Map的值的类型。
- en: We're going to use `lastNames` as our keys because we don't want our `Map` to
    store multiple values in one key, and it's much less likely that we're going to
    have multiple identical last names. Additionally, it's a lot more valuable for
    us to ask for the first name of the famous person named Addams, rather than the
    last name of the famous person named Jane, of which there are probably more. Anyway,
    the data type of `lastNames` is `String`, and the data type of `firstNames` is
    `String`, as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lastNames`作为我们的键，因为我们不希望我们的`Map`在一个键中存储多个值，而且我们很少会有多个相同的姓氏。此外，对我们来说，询问名为Addams的名人的名字比询问名为Jane的名人的姓氏更有价值，后者可能更多。无论如何，`lastNames`的数据类型是`String`，`firstNames`的数据类型也是`String`。
- en: 'Next, we give our new `Map` variable a name: `famousPeople`. Then, we cause
    our `Map` to come into being by instantiating it. To do this, we use the `new`
    keyword. `Map` is not an object, actually, it''s what we call an interface. For
    the most part, we interact with interfaces and objects the same way, but we cannot
    simply declare an instance of an interface. Rather, interfaces are additional
    wrappings of functionality that we place on top of objects, in the way that ArrayLists
    add additional functionality to arrays.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给我们的新`Map`变量取一个名字：`famousPeople`。然后，我们通过实例化来使我们的`Map`存在。为了做到这一点，我们使用`new`关键字。`Map`实际上不是一个对象，它是我们称之为接口。在大多数情况下，我们以相同的方式与接口和对象交互，但我们不能简单地声明一个接口的实例。相反，接口是我们放在对象之上的功能的额外包装，就像ArrayLists为数组添加了额外的功能一样。
- en: So, to create a new `Map`, we need a simpler type of object that we can wrap
    the `Map` interface around. A great candidate for this is the `HashMap`. Therefore,
    we create our `HashMap` and assign our Map variable `famousPeople` to it. We'll
    now interact with this `famousPeople` variable just as if it were an object with
    all of the `Map` functionality. Additionally, if we would like, we could call
    only the `HashMap` functionality on this object as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一个新的`Map`，我们需要一个更简单的对象类型，我们可以在其周围包装`Map`接口。这方面的一个很好的候选者是`HashMap`。因此，我们创建我们的`HashMap`并将我们的Map变量`famousPeople`分配给它。现在，我们将与这个`famousPeople`变量交互，就像它是一个具有所有`Map`功能的对象一样。此外，如果我们愿意，我们也可以在这个对象上调用`HashMap`功能。
- en: 'While it''s a little out of the scope of this particular section, the power
    of interfaces is that we can assign them to objects of different types, giving
    common functionalities to otherwise distinct object types. But, for now, we''re
    mostly just interested in the power and function of Java Maps. You''ll notice
    that we didn''t have to explicitly tell Java what type our `HashMap` was going
    to take. This is a stylistic choice really; if we wanted to, we could explicitly
    declare the types that the `HashMap` would take:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这有点超出了本节的范围，但接口的强大之处在于我们可以将它们分配给不同类型的对象，从而为否则不同的对象类型提供共同的功能。但是，目前，我们主要只对Java
    Maps的功能和功能感兴趣。您会注意到，我们不必明确告诉Java我们的`HashMap`将采用什么类型。这实际上是一种风格选择；如果我们愿意，我们可以明确声明`HashMap`将采用的类型：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, since we're only going to interact with our `HashMap` in terms of its
    functionality as a `Map`, simply protecting us from adding anything but strings
    when we interact with our `HashMap` through the variable `famousPeople`, which
    is currently our only way to access it, should be just fine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们只会根据其作为`Map`的功能与我们的`HashMap`进行交互，通过变量`famousPeople`与我们的`HashMap`进行交互时，我们只需要保护自己免受添加除字符串以外的任何东西的影响，这样就可以了。
- en: Assigning values to our Map
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的Map分配值
- en: 'Once we set up our `Map`, it''s time for us to go through and fill it with
    information. For this, I think a `for` loop will be appropriate:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了我们的`Map`，就该是时候填充它的信息了。对此，我认为使用`for`循环是合适的：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We're going to need to add a number of pairs of information to our Map, that
    is, one key and one value, equal to the number of items in either of these arrays.
    This is because they both have the same length. So let's set up a `for` loop that
    iterates through every index from `i` to the length of (`lastNames-1`). The `i`
    values will map to the indexes of the `lastNames` array, and because the `firstNames`
    array has the same length as the `lastNames` array, they will map to the indexes
    of the `firstNames` array as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的Map添加许多信息对，即一个键和一个值，等于这些数组中的任何一个的项目数。这是因为它们的长度相同。因此，让我们设置一个`for`循环，遍历从`i`到（`lastNames-1`）的每个索引。`i`值将映射到`lastNames`数组的索引，因为`firstNames`数组的长度与`lastNames`数组的长度相同，它们也将映射到`firstNames`数组的索引。
- en: Now, for each `i`, we're going to execute our Map's `put()` function. The `put()`
    function is similar to the `add()` function. It inserts information into our map.
    However, this function expects two pieces of information. First, it expects our
    key, which is the value we're currently looking at in `lastNames`, and then it
    expects the associated value, which is the value we're looking at in `firstNames`.
    Each time we execute the `famousPeople.put(lastNames[i], firstNames[i]);` line
    of code in our `for` loop, we'll be adding a new key value pair to our `Map`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个`i`，我们将执行我们的Map的`put()`函数。`put()`函数类似于`add()`函数。它将信息插入到我们的Map中。但是，这个函数期望两个信息。首先，它期望我们的键，即我们当前在`lastNames`中查看的值，然后它期望相关的值，即我们在`firstNames`中查看的值。每次我们在我们的`for`循环中执行`famousPeople.put(lastNames[i],
    firstNames[i]);`这行代码时，我们将向我们的`Map`添加一个新的键值对。
- en: Fetching information from our Map
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的Map中获取信息
- en: 'Once we''ve set up the `Map`, with all our information already in our program,
    all we need to do is ask it some questions and make sure we get the right responses:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了`Map`，程序中已经包含了所有信息，我们只需要问一些问题，确保我们得到正确的回答：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We use the `get()` function to ask our `Map` the basic question that it''s
    designed to answer, "What is the value paired with a given key?" So, let''s ask
    our `Map`, "What is the value paired with `Addams`?", or in more understandable
    English terms, "What is the first name of the person in our Map whose last name
    is `Addams`?" When we run this program, we get the expected result, that is, `Jane`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get()`函数来询问我们的`Map`它设计来回答的基本问题，“与给定键配对的值是什么？”因此，让我们问我们的`Map`，“与`Addams`配对的值是什么？”，或者更容易理解的英语术语，“在我们的Map中，姓氏是`Addams`的人的名字是什么？”当我们运行这个程序时，我们得到了预期的结果，即`Jane`。
- en: '![](img/0df094d6-336d-4e4a-8b59-fef66961165b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0df094d6-336d-4e4a-8b59-fef66961165b.png)'
- en: 'Let''s just run it one more time to make sure we haven''t made any silly mistakes.
    Let''s see whether our program answers `Frank` when we input `Sinatra`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再运行一次，以确保我们没有犯任何愚蠢的错误。让我们看看当我们输入`Sinatra`时，我们的程序是否会回答`Frank`：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Indeed it does!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此！
- en: '![](img/8e045ad4-f16e-4761-865b-25557362080d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e045ad4-f16e-4761-865b-25557362080d.png)'
- en: While it's possible for us to write a program like this by simply looping through
    our arrays when we get user input (finding `lastName`, storing that index, and
    getting it from `firstNames`), our Map interface essentially does that for us.
    Perhaps, more importantly than this, when we're working with other programmers
    or looking at code that we didn't write just yesterday, and we see a `Map`, we
    understand immediately its intended purpose and what functionality it implements.
    In almost all cases, just writing code that works is equally important because
    it makes sense and will be understood by others who might come across the code
    in the future.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过简单地循环遍历数组来编写这样的程序（当我们获得用户输入时找到`lastName`，存储该索引，并从`firstNames`获取它），但我们的Map接口基本上为我们做到了这一点。也许更重要的是，当我们与其他程序员合作或查看我们昨天没有编写的代码时，当我们看到`Map`时，我们立即理解它的预期目的以及它实现的功能。在几乎所有情况下，编写能够正常工作的代码同样重要，因为它是合理的，并且将被未来可能遇到代码的其他人理解。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at arrays and an example that printed the English
    alphabet by using an array. Next, we looked at multidimensional arrays and wrote
    a program that created a two-dimensional chessboard.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了数组，并举了一个使用数组打印英文字母表的例子。接下来，我们看了多维数组，并编写了一个创建二维棋盘的程序。
- en: We walked through what an ArrayList is and how it enhances the functionality
    of arrays. We also wrote a program using an ArrayList with functionality, which
    would have been quite difficult to implement using an array. Finally, we looked
    at Maps and implemented an example to understand this better.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了ArrayList是什么，以及它如何增强数组的功能。我们还编写了一个使用具有功能的ArrayList的程序，这在使用数组实现将会相当困难。最后，我们看了Maps并实现了一个例子以更好地理解它。
- en: In the next chapter, we'll look at Java functions in detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细讨论Java函数。
