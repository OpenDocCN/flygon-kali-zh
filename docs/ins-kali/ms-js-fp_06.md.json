["```js\nfunction someFunction(param1, param2, param3) {\n // *do something*\n // *do something else*\n // *and a bit more,*\n // *and finally*\n return *some expression*;\n}\n```", "```js\nfunction someFunction(param1, param2, param3) {\n console.log(\"entering someFunction: \", param1, param2, param3);\n // *do something*\n // *do something else*\n // *and a bit more,*\n // *and finally*\n let auxValue = *some expression*;\n console.log(\"exiting someFunction: \", auxValue);\n return auxValue;\n}\n```", "```js\nconst addLogging = fn => (...args) => {\n    console.log(`entering ${fn.name}: ${args})`);\n const valueToReturn = fn(...args);\n    console.log(`exiting ${fn.name}: ${valueToReturn}`);\n return valueToReturn;\n};\n```", "```js\nfunction subtract(a, b) {\n b = changeSign(b);\n return a + b;\n}\n\nfunction changeSign(a) {\n return -a;\n}\n\nsubtract = addLogging(subtract);\nchangeSign = addLogging(changeSign);\nlet x = subtract(7, 5);\n```", "```js\nentering subtract: 7 5\nentering changeSign: 5\nexiting changeSign: -5\nexiting subtract: 2\n```", "```js\nconst addLogging2 = fn => (...args) => {\n console.log(`entering ${fn.name}: ${args}`);\n try {\n const valueToReturn = fn(...args);\n console.log(`exiting ${fn.name}: ${valueToReturn}`);\n return valueToReturn;\n } catch (thrownError) {\n        console.log(`exiting ${fn.name}: threw ${thrownError}`);\n throw thrownError;\n }\n};\n```", "```js\ndescribe(\"a logging function\", function() {\n it(\"should log twice with well behaved functions\", () => {\n let something = (a, b) => `result=${a}:${b}`;\n something = addLogging(something);\n\n spyOn(window.console, \"log\");\n something(22, 9);\n expect(window.console.log).toHaveBeenCalledTimes(2);\n expect(window.console.log).toHaveBeenCalledWith(\n \"entering something: 22,9\"\n );\n expect(window.console.log).toHaveBeenCalledWith(\n \"exiting something: result=22:9\"\n );\n });\n\n it(\"should report a thrown exception\", () => {\n let thrower = (a, b, c) => {\n throw \"CRASH!\";\n };\n spyOn(window.console, \"log\");\n expect(thrower).toThrow();\n\n thrower = addLogging(thrower);\n try {\n thrower(1, 2, 3);\n } catch (e) {\n expect(window.console.log).toHaveBeenCalledTimes(2);\n expect(window.console.log).toHaveBeenCalledWith(\n \"entering thrower: 1,2,3\"\n );\n expect(window.console.log).toHaveBeenCalledWith(\n \"exiting thrower: threw CRASH!\"\n );\n }\n });\n});\n```", "```js\nconst addLogging3 = (fn, logger = console.log) => (...args) => {\n    logger(`entering ${fn.name}: ${args}`);\n try {\n const valueToReturn = fn(...args);\n        logger(`exiting ${fn.name}: ${valueToReturn}`);\n return valueToReturn;\n } catch (thrownError) {\n        logger(`exiting ${fn.name}: threw ${thrownError}`);\n throw thrownError;\n }\n};\n```", "```js\nconst winston = require(\"winston\");\nconst myLogger = **t => winston.log(\"debug\", \"Logging by winston: %s\", t)**;\nwinston.level = \"debug\";\n\nsubtract = addLogging3(subtract, myLogger);\nchangeSign = addLogging3(changeSign, myLogger);\nlet x = subtract(7, 5);\n\n// *debug: Logging by winston: entering subtract: 7,5*\n// *debug: Logging by winston: entering changeSign: 5*\n// *debug: Logging by winston: exiting changeSign: -5*\n// *debug: Logging by winston: exiting subtract: 2*\n```", "```js\ndescribe(\"after addLogging2()\", function() {\n let dummy;\n\n beforeEach(() => {\n dummy = {logger() {}};\n spyOn(dummy, \"logger\");\n });\n\n it(\"should call the provided logger\", () => {\n let something = (a, b) => `result=${a}:${b}`;\n something = addLogging2(something, dummy.logger);\n\n something(22, 9);\n expect(dummy.logger).toHaveBeenCalledTimes(2);\n expect(dummy.logger).toHaveBeenCalledWith(\n \"entering something: 22,9\"\n );\n expect(dummy.logger).toHaveBeenCalledWith(\n \"exiting something: result=22:9\"\n );\n });\n\n it(\"a throwing function should be reported\", () => {\n let thrower = (a, b, c) => {\n throw \"CRASH!\";\n };\n thrower = addLogging2(thrower, dummy.logger);\n\n try {\n thrower(1, 2, 3);\n } catch (e) {\n expect(dummy.logger).toHaveBeenCalledTimes(2);\n expect(dummy.logger).toHaveBeenCalledWith(\n \"entering thrower: 1,2,3\"\n );\n expect(dummy.logger).toHaveBeenCalledWith(\n \"exiting thrower: threw CRASH!\"\n );\n }\n });\n});\n```", "```js\nconst myPut = (text, name, tStart, tEnd) =>\n console.log(`${name} - ${text} ${tEnd - tStart} ms`);\n\nconst myGet = () => performance.now();\n\nconst addTiming = (fn, getTime = myGet, output = myPut) => (...args) => {\n let tStart = getTime();\n try {\n const valueToReturn = fn(...args);\n        output(\"normal exit\", fn.name, tStart, getTime());\n return valueToReturn;\n } catch (thrownError) {\n        output(\"exception thrown\", fn.name, tStart, getTime());\n throw thrownError;\n }\n};\n```", "```js\nsubtract = **addTiming(subtract)**;\n\nlet x = subtract(7, 5);\n// subtract - normal exit 0.10500000000001819 ms\n\nlet y = subtract(4, 0);\n// subtract - exception thrown 0.0949999999999136 ms\n```", "```js\nfunction fib(n) {\n if (n == 0) {\n return 0;\n } else if (n == 1) {\n return 1;\n } else {\n return fib(n - 2) + fib(n - 1);\n }\n}\n```", "```js\nconst memoize = fn => {\n let cache = {};\n return x => (x in cache ? cache[x] : (cache[x] = fn(x)));\n};\n```", "```js\nconst testFib = n => fib(n);\naddTiming(testFib)(45); // 15,382.255 ms\naddTiming(testFib)(40); //  1,600.600 ms\naddTiming(testFib)(35); //    146.900 ms\n```", "```js\nconst testMemoFib = memoize(n => fib(n));\naddTiming(testMemoFib)(45); // 15,537.575 ms\naddTiming(testMemoFib)(45); //      0.005 ms... *good!*\naddTiming(testMemoFib)(40); //  1,368.880 ms... *recalculating?*\naddTiming(testMemoFib)(35); //    123.970 ms... *here too?*\n```", "```js\nfib = memoize(fib);\naddTiming(testFib)(45); // 0.080 ms\naddTiming(testFib)(40); // 0.025 ms\naddTiming(testFib)(35); // 0.009 ms\n```", "```js\nconst memoize2 = fn => {\n if (fn.length === 1) {\n let cache = {};\n return x => (x in cache ? cache[x] : (cache[x] = fn(x)));\n } else {\n        return fn;\n }\n};\n```", "```js\nvar a = [1, 5, 3, 8, 7, 4, 6];\nString(a); // \"1,5,3,8,7,4,6\"\n\nvar b = [[1, 5], [3, 8, 7, 4, 6]];\nString(b); // \"1,5,3,8,7,4,6\"\n\nvar c = [[1, 5, 3], [8, 7, 4, 6]];\nString(c); // \"1,5,3,8,7,4,6\"\n```", "```js\nvar d = {a: \"fk\"};\nString(d); // \"[object Object]\"\n\nvar e = [{p: 1, q: 3}, {p: 2, q: 6}];\nString(e); // \"[object Object],[object Object]\"\n```", "```js\nvar a = [1, 5, 3, 8, 7, 4, 6];\nJSON.stringify(a); // \"[1,5,3,8,7,4,6]\"\n\nvar b = [[1, 5], [3, 8, 7, 4, 6]];\nJSON.stringify(b); // \"[[1,5],[3,8,7,4,6]]\"\n\nvar c = [[1, 5, 3], [8, 7, 4, 6]];\nJSON.stringify(c); // \"[[1,5,3],[8,7,4,6]]\"\n\nvar d = {a: \"fk\"};\nJSON.stringify(d); // \"{\"a\":\"fk\"}\"\n\nvar e = [{p: 1, q: 3}, {p: 2, q: 6}];\nJSON.stringify(e); // \"[{\"p\":1,\"q\":3},{\"p\":2,\"q\":6}]\"\n```", "```js\nconst memoize3 = fn => {\n let cache = {};\n const PRIMITIVES = [\"number\", \"string\", \"boolean\"];\n return (...args) => {\n let strX =\n args.length === 1 && PRIMITIVES.includes(typeof args[0])\n ? args[0]\n : JSON.stringify(args);\n return strX in cache ? cache[strX] : (cache[strX] = fn(...args));\n };\n};\n```", "```js\nconst memoize4 = fn => {\n let cache = {};\n return (...args) => {\n let strX = JSON.stringify(args);\n return strX in cache ? cache[strX] : (cache[strX] = fn(...args));\n };\n};\n```", "```js\nvar fib = null;\n\nbeforeEach(() => {\n fib = n => {\n if (n == 0) {\n return 0;\n } else if (n == 1) {\n return 1;\n } else {\n return fib(n - 2) + fib(n - 1);\n }\n };\n});\n\ndescribe(\"the original fib\", function() {\n it(\"should produce correct results\", () => {\n expect(fib(0)).toBe(0);\n expect(fib(1)).toBe(1);\n expect(fib(5)).toBe(5);\n expect(fib(8)).toBe(21);\n expect(fib(10)).toBe(55);\n });\n\n it(\"should repeat calculations\", () => {\n spyOn(window, \"fib\").and.callThrough();\n expect(fib(6)).toBe(8);\n expect(fib).toHaveBeenCalledTimes(25);\n });\n});\n```", "```js\ndescribe(\"the memoized fib\", function() {\n beforeEach(() => {\n fib = memoize(fib);\n });\n\n it(\"should produce same results\", () => {\n expect(fib(0)).toBe(0);\n expect(fib(1)).toBe(1);\n expect(fib(5)).toBe(5);\n expect(fib(8)).toBe(21);\n expect(fib(10)).toBe(55);\n });\n\n it(\"shouldn't repeat calculations\", () => {\n spyOn(window, \"fib\").and.callThrough();\n\n expect(fib(6)).toBe(8); // 11 calls\n expect(fib).toHaveBeenCalledTimes(11);\n\n expect(fib(5)).toBe(5); // 1 call\n expect(fib(4)).toBe(3); // 1 call\n expect(fib(3)).toBe(2); // 1 call\n expect(fib).toHaveBeenCalledTimes(14);\n });\n});\n```", "```js\nconst once = func => {\n let done = false;\n return (...args) => {\n if (!done) {\n done = true;\n func(...args);\n }\n };\n};\n```", "```js\nconst once2 = func => {\n let done = false;\n    let result;\n return (...args) => {\n if (!done) {\n done = true;\n            result = func(...args);\n }\n        return result;\n };\n};\n```", "```js\nconst onceAndAfter = (f, g) => {\n let done = false;\n return (...args) => {\n if (!done) {\n done = true;\n return f(...args);\n } else {\n return g(...args);\n }\n };\n};\n```", "```js\nconst onceAndAfter2 = (f, g) => {\n    let toCall = f;\n return (...args) => {\n let result = toCall(...args);\n        toCall = g;\n return result;\n };\n};\n```", "```js\nconst squeak = (x) => console.log(x, \"squeak!!\");\nconst creak = (x) => console.log(x, \"creak!!\");\nconst makeSound = onceAndAfter2(squeak, creak);\n\nmakeSound(\"door\"); // *\"door squeak!!\"*\nmakeSound(\"door\"); // *\"door creak!!\"*\nmakeSound(\"door\"); // *\"door creak!!\"*\nmakeSound(\"door\"); // *\"door creak!!\"*\n```", "```js\nconst delinquent = serviceResult.accountsData.filter(v => v.balance < 0);\n```", "```js\nconst notDelinquent = serviceResult.accountsData.filter(\n    v => v.balance >= 0\n);\n\nconst notDelinquent2 = serviceResult.accountsData.filter(\n    v => !(v.balance < 0)\n);\n```", "```js\nconst isNegativeBalance = v => v.balance < 0;\n\n// ...*many lines later..*.\n\nconst delinquent2 = serviceResult.accountsData.filter(isNegativeBalance);\n```", "```js\nconst not = fn => (...args) => !fn(...args);\n```", "```js\nconst isNegativeBalance = v => v.balance < 0;\n\n// ...*many lines later...* \nconst notDelinquent3 = serviceResult.accountsData.filter(\n    not(isNegativeBalance)\n);\n```", "```js\nconst filterNot = arr => fn => arr.filter(not(fn));\n```", "```js\nconst spanishComparison = (a, b) => a.localeCompare(b, \"es\");\n\npalabras.sort(spanishComparison); // *sorts the* palabras *array according to Spanish rules*\n```", "```js\nconst invert = fn => (...args) => -fn(...args);\n```", "```js\nconst spanishComparison = (a, b) => a.localeCompare(b, \"es\");\n\nvar palabras = [\"\u00f1and\u00fa\", \"oasis\", \"mano\", \"natural\", \"m\u00edtico\", \"musical\"];\n\npalabras.sort(spanishComparison);\n// [\"mano\", \"m\u00edtico\", \"musical\", \"natural\", \"\u00f1and\u00fa\", \"oasis\"]\n\npalabras.sort(**invert(spanishComparison)**);\n// [\"oasis\", \"\u00f1and\u00fa\", \"natural\", \"musical\", \"m\u00edtico\", \"mano\"]\n```", "```js\n[\"123.45\", \"-67.8\", \"90\"].map(parseInt); // *problem: parseInt isn't monadic!*\n// [123, NaN, NaN]\n```", "```js\nconst unary = fn => (...args) => fn(args[0]);\n```", "```js\n[\"123.45\", \"-67.8\", \"90\"].map(unary(parseInt));\n// *[123, -67, 90]*\n```", "```js\nconst mySum = myArray.reduce((x, y) => x + y, 0);\n```", "```js\nconst factorialByRange = n => range(1, n + 1).reduce((x, y) => x * y, 1);\n```", "```js\nconst mySum = myArray.reduce(binaryOp(\"+\"), 0);\nconst factorialByRange = n => range(1, n + 1).reduce(binaryOp(\"*\"), 1);\n```", "```js\nconst binaryOp1 = op => {\n switch (op) {\n case \"+\":\n return (x, y) => x + y;\n case \"-\":\n return (x, y) => x - y;\n case \"*\":\n return (x, y) => x * y;\n //\n // etc.\n //\n }\n};\n```", "```js\nconst binaryOp2 = op => new Function(\"x\", \"y\", `return x ${op} y;`);\n```", "```js\nconst isNegative = curry(binaryOp2(\">\"))(0);\n```", "```js\nconst binaryLeftOp = (x, op) => \n (y) => binaryOp2(op)(x,y);\n\nconst binaryOpRight = (op, y) => \n (x) => binaryOp2(op)(x,y);\n```", "```js\nconst binaryLeftOp2 = (x, op) => y => binaryOp2(op)(x, y);\n\nconst binaryOpRight2 = (op, y) => x => binaryOp2(op)(x, y);\n```", "```js\nconst isNegative1 = binaryLeftOp(0, \">\");\n\nconst isNegative2 = binaryOpRight(\"<\", 0);\n```", "```js\nconst isNegative3 = x => x < 0;\n```", "```js\nconst promisify = fn => (...args) =>\n new Promise((resolve, reject) =>\n fn(...args, (err, data) => (err ? reject(err) : resolve(data)))\n );\n```", "```js\nconst fs = require(\"fs\");\n\nconst cb = (err, data) =>\n err ? console.log(\"ERROR\", err) : console.log(\"SUCCESS\", data);\n\nfs.readFile(\"./exists.txt\", cb); // *success, list the data*\nfs.readFile(\"./doesnt_exist.txt\", cb); // *failure, show exception*\n```", "```js\nconst fspromise = promisify(fs.readFile.bind(fs));\n\nconst goodRead = data => console.log(\"SUCCESSFUL PROMISE\", data);\nconst badRead = err => console.log(\"UNSUCCESSFUL PROMISE\", err);\n\nfspromise(\"./readme.txt\") *// success*\n .then(goodRead)\n .catch(badRead);\n\nfspromise(\"./readmenot.txt\") // *failure*\n .then(goodRead)\n .catch(badRead);\n```", "```js\nmarkers = [\n {name: \"UY\", lat: -34.9, lon: -56.2},\n {name: \"AR\", lat: -34.6, lon: -58.4},\n {name: \"BR\", lat: -15.8, lon: -47.9},\n ...\n {name: \"BO\", lat: -16.5, lon: -68.1}\n];\n\nlet averageLat = average(markers.map(x => x.lat));\nlet averageLon = average(markers.map(x => x.lon));\n```", "```js\nconst delinquent = serviceResult.accountsData.filter(v => v.balance < 0);\nconst delinquentIds = delinquent.map(v => v.id);\n```", "```js\nconst getField = attr => obj => obj[attr];\n```", "```js\nlet averageLat = average(markers.map(getField(\"lat\")));\nlet averageLon = average(markers.map(getField(\"lon\")));\n```", "```js\nconst getId = getField(\"id\");\nconst delinquent = serviceResult.accountsData.filter(v => v.balance < 0);\nconst delinquentIds = delinquent.map(getId);\n```", "```js\nconst demethodize1 = fn => (arg0, ...args) => fn.apply(arg0, args);\n\nconst demethodize2 = fn => (arg0, ...args) => fn.call(arg0, ...args);\n\nconst demethodize3 = fn => (...args) => fn.bind(...args)();\n```", "```js\nconst name = \"FUNCTIONAL\";\nconst result = name.split(\"\").map(x => x.toUpperCase());\n// *[\"F\", \"U\", \"N\", \"C\", \"T\", \"I\", \"O\", \"N\", \"A\", \"L\"]*\n```", "```js\nconst map = demethodize3(Array.prototype.map);\nconst toUpperCase = demethodize3(String.prototype.toUpperCase);\n\nconst result2 = map(name, toUpperCase);\n// *[\"F\", \"U\", \"N\", \"C\", \"T\", \"I\", \"O\", \"N\", \"A\", \"L\"]*\n```", "```js\nconst toLocaleString = demethodize3(Number.prototype.toLocaleString);\n\nconst numbers = [2209.6, 124.56, 1048576];\nconst strings = numbers.map(toLocaleString);\n// *[\"2,209.6\", \"124.56\", \"1,048,576\"]*\n```", "```js\nconst strings2 = map(numbers, toLocaleString);\n```", "```js\nconst findOptimum = arr => Math.max(...arr);\n\nconst myArray = [22, 9, 60, 12, 4, 56];\nfindOptimum(myArray); // 60\n```", "```js\nconst findOptimum2 = fn => arr => arr.reduce(fn);\n```", "```js\nconst findMaximum = findOptimum2((x, y) => (x > y ? x : y));\nconst findMinimum = findOptimum2((x, y) => (x < y ? x : y));\n\nfindMaximum(myArray); // 60\nfindMinimum(myArray); // 4\n```", "```js\nconst compareHeroes = (card1, card2) => {\n const oneIfBigger = (x, y) => (x > y ? 1 : 0);\n\n const wins1 =\n oneIfBigger(card1.strength, card2.strength) +\n oneIfBigger(card1.powers, card2.powers) +\n oneIfBigger(card1.tech, card2.tech);\n\n const wins2 =\n oneIfBigger(card2.strength, card1.strength) +\n oneIfBigger(card2.powers, card1.powers) +\n oneIfBigger(card2.tech, card1.tech);\n\n return wins1 > wins2 ? card1 : card2;\n};\n```", "```js\nfunction Hero(n, s, p, t) {\n this.name = n;\n this.strength = s;\n this.powers = p;\n this.tech = t;\n}\n\nconst codingLeagueOfAmerica = [\n new Hero(\"Forceful\", 20, 15, 2),\n new Hero(\"Electrico\", 12, 21, 8),\n new Hero(\"Speediest\", 8, 11, 4),\n new Hero(\"TechWiz\", 6, 16, 30)\n];\n\nconst findBestHero = findOptimum2(compareHeroes);\nfindBestHero(codingLeagueOfAmerica); // Electrico is the top hero!\n```"]