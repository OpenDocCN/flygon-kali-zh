- en: Securing APIs with API Keys and Azure Key Vault
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API密钥和Azure Key Vault保护API
- en: In this chapter, we are going to see how we can keep secrets in Azure Key Vault.
    We will also be looking at how we can use API keys to secure our own keys with
    authentication and role-based authorization. To gain first-hand experience with
    API security, we will build a fully functional FinTech API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何在Azure Key Vault中保存秘密。我们还将研究如何使用API密钥来通过身份验证和基于角色的授权保护我们自己的密钥。为了获得API安全性的第一手经验，我们将构建一个完全功能的FinTech
    API。
- en: Our API will extract third-party API data using a private key (kept safe in
    Azure Key Vault). We will then secure our API with two API keys; one key will
    be used internally and a second key will be used by external users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API将使用私钥（在Azure Key Vault中安全保存）提取第三方API数据。然后，我们将使用两个API密钥保护我们的API；一个密钥将在内部使用，第二个密钥将由外部用户使用。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Accessing the Morningstar API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Morningstar API
- en: Storing the Morningstar API in Azure Key Vault
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Morningstar API存储在Azure Key Vault中
- en: Creating the dividend calendar ASP.NET Core web application in Azure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Azure中创建股息日历ASP.NET Core Web应用程序
- en: Publishing our web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布我们的Web应用程序
- en: Using an API key to secure our dividend calendar API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API密钥保护我们的股息日历API
- en: Testing our API key's security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的API密钥安全性
- en: Adding the dividend calendar code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加股息日历代码
- en: Throttling our API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制我们的API
- en: 'You will understand the basics of good API design and you will be armed with
    the knowledge needed to push your API abilities forward. This chapter will assist
    you in gaining the following skills:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解良好API设计的基础知识，并掌握推动API能力所需的知识。本章将帮助您获得以下技能：
- en: Securing an API with a client API key
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端API密钥保护API
- en: Storing and retrieving secrets using Azure Key Vault
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure Key Vault存储和检索秘密
- en: Using Postman to execute API commands that post and get data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman执行发布和获取数据的API命令
- en: Applying for and using third-party APIs on RapidAPI.com
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RapidAPI.com上申请并使用第三方API
- en: Throttling API usage
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制API使用
- en: Writing FinTech APIs that leverage online financial data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写利用在线财务数据的FinTech API
- en: Before we continue, make sure you implement the following technical requirements
    to get the most out of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您实施以下技术要求，以充分利用本章。
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using the following technologies in this chapter to write an API:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术编写API：
- en: Visual Studio 2019 Community edition or higher
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019社区版或更高版本
- en: Your own personal Morningstar API key from [https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您自己的个人Morningstar API密钥来自[https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1)
- en: RestSharp ([http://restsharp.org/](http://restsharp.org/))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RestSharp ([http://restsharp.org/](http://restsharp.org/))
- en: Swashbuckle.AspNetCore 5 or higher
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore 5或更高版本
- en: Postman ([https://www.postman.com/](https://www.postman.com/))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman ([https://www.postman.com/](https://www.postman.com/))
- en: Swagger ([https://swagger.io](https://swagger.io))
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger ([https://swagger.io](https://swagger.io))
- en: Undertaking the API project – dividend calendar
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行API项目-股息日历
- en: 'The best way to learn is by doing. So, we will build a working API and secure
    it. The API won''t be perfect and there will be room for improvement. However,
    you are free to implement these improvements yourself and expand on the project
    as you wish. The main goal here is to have a fully functioning API that does one
    thing: return financial data that lists all the company dividends that will be
    paid in the current year.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 学习的最佳方式是通过实践。因此，我们将构建一个可用的API并对其进行安全保护。API不会完美无缺，还有改进的空间。但是，您可以自由地实施这些改进，并根据需要扩展项目。这里的主要目标是拥有一个完全运作的API，只做一件事：返回列出当前年度将支付的所有公司股息的财务数据。
- en: Our dividend calendar API, which we will be building in this chapter, is an
    API that is authenticated with an **API key**. Depending on what key is used,
    authorization will determine whether the user is internal or external. The controller
    will then execute the appropriate method, depending on the type of user. Only
    the internal user method will be implemented, but you are free to implement the
    external user method yourself as a training exercise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的股息日历API是一个使用API密钥进行身份验证的API。根据使用的密钥，授权将确定用户是内部用户还是外部用户。然后，控制器将根据用户类型执行适当的方法。只有内部用户方法将被实现，但您可以自由地实施外部用户方法，作为训练练习。
- en: The internal method extracts an API key from Azure Key Vault and executes various
    API calls to a third-party API. The data is returned in **JavaScript Object Notation** (**JSON**)
    format, deserialized into objects and then processed to extract future dividend
    payments, which are added to a list of dividends. This list is then returned to
    the caller in JSON format. The end result is a JSON file that has all the scheduled
    dividend payments for the current year. The end user can then take this data and
    convert it into a list of dividends that can be queried using LINQ.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法从Azure Key Vault中提取API密钥，并执行对第三方API的各种API调用。数据以**JavaScript对象表示法**（**JSON**）格式返回，反序列化为对象，然后处理以提取未来的股息支付，并将其添加到股息列表中。然后将此列表以JSON格式返回给调用者。最终结果是一个JSON文件，其中包含当前年度的所有计划股息支付。然后，最终用户可以将这些数据转换为可以使用LINQ查询的股息列表。
- en: The project we will be building in this chapter is a web API that returns processed
    JSON from third-party financial APIs. Our project will obtain a list of companies
    from a given stock exchange. We will then loop through these companies to obtain
    their dividend data. The dividend data will then be processed for the current
    year. So, what we will end up returning to the API caller is JSON data. This JSON
    data will contain a list of companies and their dividend payment forecast for
    the current year. The JSON data can then be converted by the end user into C#
    objects, and LINQ queries can be performed on these objects. Queries can be carried
    out to get x-dividend payments for the next month or payments due this month,
    for example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的项目是一个Web API，它从第三方金融API返回处理过的JSON。我们的项目将从给定的股票交易所获取公司列表。然后，我们将循环遍历这些公司以获取它们的股息数据。然后将处理股息数据以获取当前年份的数据。因此，我们最终将返回给API调用者的是JSON数据。这些JSON数据将包含公司列表及其当前年份的股息支付预测。然后，最终用户可以将JSON数据转换为C#对象，并对这些对象执行LINQ查询。例如，可以执行查询以获取下个月的除权支付或本月到期的支付。
- en: The APIs that we will be using will be part of the Morningstar API, which is
    available via RapidAPI.com. You can sign up for a free Morningstar API key. We
    will secure our API with a login system, where users log in using an email address
    and password. You will also need Postman, as we will be using it to fire the API's `POST`
    and `GET` requests to the dividend calendar API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的API将是Morningstar API的一部分，该API可通过RapidAPI.com获得。您可以注册一个免费的Morningstar API密钥。我们将使用登录系统来保护我们的API，用户将使用电子邮件地址和密码登录。您还需要Postman，因为我们将使用它来发出API的`POST`和`GET`请求到股息日历API。
- en: Our solution will contain a single project, which will be an ASP.NET Core application
    that targets .NET Framework Core 3.1 or higher. We will now discuss how to access
    the Morningstar API.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案将包含一个项目，这将是一个ASP.NET Core应用程序，目标是.NET Framework Core 3.1或更高版本。现在我们将讨论如何访问Morningstar
    API。
- en: Accessing the Morningstar API
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Morningstar API
- en: Go to [https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1) and
    request an API access key. The API is a Freemium API. This means you are allowed
    a certain number of calls for free for a limited period, after which you need
    to pay for its usage. Take some time to look at the API and its documentation.
    Pay attention to the pricing plans and keep your key a secret when you receive
    it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1)并请求API访问密钥。该API是Freemium
    API。这意味着您可以在有限的时间内免费使用一定数量的调用，之后需要支付使用费用。花些时间查看API及其文档。当您收到密钥时，注意定价计划并保持密钥的机密性。
- en: 'The APIs that we are interested in are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的API如下：
- en: '`GET /companies/list-by-exchange`: This API returns a list of countries for
    the specified exchange.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /companies/list-by-exchange`：此API返回指定交易所的国家列表。'
- en: '`GET /dividends`: This API gets all the historical and current dividend payment
    information for the specified company.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /dividends`：此API获取指定公司的所有历史和当前股息支付信息。'
- en: The first part of the API request is the `GET` HTTP verb, which is used to retrieve
    a resource. The second part of the API request is the resource to `GET`, which
    in this case is `/companies/list-by-exchange`. As we can see in the second bullet
    point of the preceding list, we are getting the `/dividends` resource.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: API请求的第一部分是`GET` HTTP动词，用于检索资源。API请求的第二部分是要`GET`的资源，在这种情况下是`/companies/list-by-exchange`。正如我们在前面列表的第二个项目符号中所看到的，我们正在获取`/dividends`资源。
- en: You can test each API in the browser and see the data that is returned. I recommend
    you do this before you continue. This will help you get a feel for what we will
    be working on. The basic flow we will be using is getting the list of companies
    that belong to a specified exchange, then looping through them to obtain the dividend
    data. If the dividend data has a future payment date, then the dividend data will
    be added to the calendar; otherwise, it will be discarded. No matter how much
    dividend data exists for a company, we are only interested in the first record,
    which is the most current one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中测试每个API，并查看返回的数据。我建议您在继续之前先这样做。这将帮助您对我们将要处理的内容有所了解。我们将使用的基本流程是获取属于指定交易所的公司列表，然后循环遍历它们以获取股息数据。如果股息数据有未来的支付日期，那么股息数据将被添加到日历中；否则，它将被丢弃。无论公司有多少股息数据，我们只对第一条记录感兴趣，这是最新的记录。
- en: Now that you have your API key (assuming you are following along with these
    steps), we will start to build our API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有API密钥（假设您正在按照这些步骤进行），我们将开始构建我们的API。
- en: Storing the Morningstar API key in Azure Key Vault
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Azure Key Vault中存储Morningstar API密钥
- en: We will be using Azure Key Vault and **Managed Service Identity** (**MSI**)
    with an ASP.NET Core web application. So, before you continue, you will need an
    Azure subscription. For new customers, there is a free 12-month offer available
    at [http://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Azure Key Vault和**托管服务标识**（MSI）与ASP.NET Core Web应用程序。因此，在继续之前，您将需要Azure订阅。对于新客户，可在[http://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free/)上获得免费12个月的优惠。
- en: As web developers, it is important not to store secrets in code because code
    can be *reverse-engineered*. If code is open source, then there is the danger
    of uploading personal or enterprise keys to a public version control system. A
    way around this is to store secrets securely, but this gives rise to a dilemma.
    To access secret keys, we need to be authenticated. So, how do we overcome this
    dilemma?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Web开发人员，不将机密存储在代码中非常重要，因为代码可以被*反向工程*。如果代码是开源的，那么上传个人或企业密钥到公共版本控制系统存在危险。解决这个问题的方法是安全地存储机密，但这会引发一个困境。要访问机密密钥，我们需要进行身份验证。那么，我们如何克服这个困境呢？
- en: We can overcome this dilemma by enabling MSI for our Azure service. As a result,
    a service principal is produced by Azure. This service principal is used by applications
    developed by the user to access resources on Microsoft Azure. For the service
    principal, you can use a certificate or a username and password, along with any
    role you choose that has the required set of permissions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为我们的Azure服务启用MSI来克服这一困境。因此，Azure会生成一个服务主体。用户开发的应用程序将使用此服务主体来访问Microsoft
    Azure上的资源。对于服务主体，您可以使用证书或用户名和密码，以及任何您选择的具有所需权限集的角色。
- en: 'The person who controls the Azure account is in control of what specific tasks
    each service can perform. It is often best to start with full restrictions and
    only add capabilities as and when they are needed. The following diagram shows
    the relationships between our ASP.NET Core web applications, MSI, and our Azure
    service:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 控制Azure帐户的人控制每项服务可以执行的具体任务。通常最好从完全限制开始，只有在需要时才添加功能。以下图表显示了我们的ASP.NET Core Web应用程序、MSI和Azure服务之间的关系：
- en: '![](img/98b01f77-0e13-4266-9d5e-de1621a12700.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98b01f77-0e13-4266-9d5e-de1621a12700.png)'
- en: '**Azure Active Directory **(**Azure AD**) is employed by MSI to inject the
    service principal for the service instance. An Azure resource known as a **local
    metadata service** is used to obtain an access token and will be used to authenticate
    service access to the Azure key vault.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Active Directory**（**Azure AD**）被MSI用于注入服务实例的服务主体。一个名为**本地元数据服务**的Azure资源用于获取访问仁牌，并将用于验证服务访问Azure密钥保管库。'
- en: The code then calls a local metadata service that is available on the Azure
    resource to get the access token. The access token extracted from the local MSI
    endpoint is then used by our code to authenticate to an Azure Key Vault service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用可用于获取访问令牌的Azure资源上的本地元数据服务。然后，我们的代码使用从本地MSI端点提取的访问令牌来对Azure密钥保管库服务进行身份验证。
- en: 'Open the Azure CLI and type `az login` to log in to Azure. Once we are logged
    in, we can create a resource group. Azure resource groups are logical containers
    into which Azure resources are deployed and managed. The following command creates
    a resource group in the `East US` location:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Azure CLI并输入`az login`以登录到Azure。一旦登录，我们就可以创建一个资源组。Azure资源组是逻辑容器，用于部署和管理Azure资源。以下命令在`East
    US`位置创建一个资源组：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use this resource group throughout the rest of the chapter. We will now move
    on to creating our key vault. The creation of a key vault requires the following
    information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分中都使用此资源组。现在我们将继续创建我们的密钥保管库。创建密钥保管库需要以下信息：
- en: The name of the key vault, which is a string that is between 3 to 24 characters
    long and can only contain the `0-9`, `a-z`, `A-Z`, and `-` (hyphen) characters
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥保管库的名称，这是一个3到24个字符长的字符串，只能包含`0-9`、`a-z`、`A-Z`和`-`（连字符）字符
- en: The name of the resource group
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组的名称
- en: The location—for example, `East US` or `West US`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置——例如，`East US`或`West US`
- en: 'In the Azure CLI, enter the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure CLI中，输入以下命令：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Only your Azure account is authorized to perform operations on your new vault
    at this stage. You can add other accounts if necessary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有您的Azure帐户被授权在新的保管库上执行操作。如有必要，您可以添加其他帐户。
- en: 'The main key that we need to add to our project is `MorningstarApiKey`. To
    add the Morningstar API key to your key vault, type the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到项目中的主要密钥是`MorningstarApiKey`。要将Morningstar API密钥添加到您的密钥保管库中，请输入以下命令：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your key vault now stores your Morningstar API key. To check that the value
    is stored correctly, type the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您的密钥保管库现在存储了您的Morningstar API密钥。要检查该值是否正确存储，请输入以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should now see your secret displayed in the console window, which shows
    the key and value for the stored secret.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在控制台窗口中看到您的密钥显示，显示存储的密钥和值。
- en: Creating the dividend calendar ASP.NET Core web application in Azure
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure中创建股息日历ASP.NET Core Web应用程序
- en: 'To complete this stage of the project, you will need Visual Studio 2019 with
    the ASP.NET and web development workload installed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成项目的这一阶段，您需要安装了ASP.NET和Web开发工作负载的Visual Studio 2019：
- en: 'Create a new ASP.NET Core web application:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的ASP.NET Core Web应用程序：
- en: '![](img/83a0ae31-6cad-493c-8818-9b2c23ebe9c1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83a0ae31-6cad-493c-8818-9b2c23ebe9c1.png)'
- en: 'Make sure API is selected with No Authentication set:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保API选择了`No Authentication`：
- en: '![](img/f1d634c9-d3d2-44d9-9003-6b2a961c0d8a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1d634c9-d3d2-44d9-9003-6b2a961c0d8a.png)'
- en: 'Click on Create to scaffold your new project. Then, run your project. By default,
    an example weather forecast API is defined, and it outputs the following JSON
    code in the browser window:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建”以创建您的新项目。然后运行您的项目。默认情况下，定义了一个示例天气预报API，并在浏览器窗口中输出以下JSON代码：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we will publish our application to Azure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将发布我们的应用程序到Azure。
- en: Publishing our web application
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布我们的Web应用程序
- en: 'Before we can publish our web applications, we will first create a new Azure
    app service to publish our application to. We will need a resource group to contain
    our Azure app service, as well as a new hosting plan that specifies the location,
    size, and features of the web server farm that hosts our application. So, let''s
    take care of these requirements, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以发布我们的Web应用程序之前，我们将首先创建一个新的Azure应用服务来发布我们的应用程序。我们将需要一个资源组来包含我们的Azure应用服务，以及一个指定托管位置、大小和特性的新托管计划，用于托管我们的应用程序的Web服务器群。因此，让我们按照以下要求进行处理：
- en: 'Make sure you are signed in to your Azure account from Visual Studio. To create
    the app service, right-click on the project that you just created and select Publish from
    the menu. This will display the Pick a publish target dialog, as shown:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您从Visual Studio登录到Azure帐户。要创建应用服务，请右键单击刚创建的项目，然后从菜单中选择“发布”。这将显示“选择发布目标”对话框，如下所示：
- en: '![](img/bb8f7ab3-0071-4ef9-972a-6499efb8f6e4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb8f7ab3-0071-4ef9-972a-6499efb8f6e4.png)'
- en: 'Select App Service | Create New and click on Create Profile. Create a new hosting
    plan, as in the following example:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择App Service | 创建新的，并点击创建配置文件。创建一个新的托管计划，如下例所示：
- en: '![](img/73abd32c-f8df-4d10-82d4-73fc691a21d3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73abd32c-f8df-4d10-82d4-73fc691a21d3.png)'
- en: 'Then, make sure you provide a name, select a subscription, and select your
    resource group. It is recommended that you also set the Application Insights setting:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，确保您提供一个名称，选择一个订阅，并选择您的资源组。建议您还设置“应用程序洞察”设置：
- en: '![](img/35f10e70-0b39-4035-973a-6ea031b28dc8.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f10e70-0b39-4035-973a-6ea031b28dc8.png)'
- en: 'Click on Create to create your app service. Once it''s created, your Publish screen
    should look like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建”以创建您的应用服务。创建完成后，您的“发布”屏幕应如下所示：
- en: '![](img/82f95f6e-c959-43fd-89ba-b2bd2ac7e14f.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82f95f6e-c959-43fd-89ba-b2bd2ac7e14f.png)'
- en: 'At this stage, you can click on the site URL. This will load your site URL
    in the browser. If your service is successfully configured and running, your browser
    should display the following page:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，您可以点击站点URL。这将在浏览器中加载您的站点URL。如果您的服务成功配置并运行，您的浏览器应该显示以下页面：
- en: '![](img/e45fb271-cba1-45ba-9150-e5fdf60cf2a5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e45fb271-cba1-45ba-9150-e5fdf60cf2a5.png)'
- en: 'Let''s publish our API. Click on the Publish button. When the web page runs,
    it will display an error page. Modify the URL to `https://dividend-calendar.azurewebsites.net/weatherforecast`.
    The web page should now display the weather forecast API JSON code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们发布我们的API。点击“发布”按钮。当网页运行时，它将显示一个错误页面。修改URL为`https://dividend-calendar.azurewebsites.net/weatherforecast`。网页现在应该显示天气预报API的JSON代码：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our service is now live. If you log in to your Azure portal and visit the resource
    group for your hosting plan, you will see four resources. These resources are
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务现在已经上线。如果您登录到Azure门户并访问您的托管计划的资源组，您将看到四个资源。这些资源如下：
- en: '**App Service**: `dividend-calendar`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**：`dividend-calendar`'
- en: '**Application Insights**: `dividend-calendar`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序洞察**：`dividend-calendar`'
- en: '**App Service plan**: ``DividendCalendarHostingPlan``'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务计划**：``DividendCalendarHostingPlan``'
- en: '**Key vault**: Whatever your key vault is called. In my case, it''s `Keys-APIs`,
    as shown here:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥保管库**：无论你的密钥保管库叫什么。在我的案例中，它叫`Keys-APIs`，如下所示：'
- en: '![](img/4ece03d9-20f5-4014-b1bf-1d03e363bb20.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ece03d9-20f5-4014-b1bf-1d03e363bb20.png)'
- en: 'If you click on your app service from the Azure portal home page ([https://portal.azure.com/#home](https://portal.azure.com/#home)),
    you will see that you can browse to your service, as well as stop, restart, and
    delete your app service:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Azure门户主页([https://portal.azure.com/#home](https://portal.azure.com/#home))点击您的应用服务，您将看到您可以浏览到您的服务，以及停止、重新启动和删除您的应用服务：
- en: '![](img/8ba4b623-0f35-4f20-bd5b-526ef3b17ef3.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ba4b623-0f35-4f20-bd5b-526ef3b17ef3.png)'
- en: Now that we have our project in place with Application Insights and our Morningstar
    API key is stored securely, we can start building our dividend calendar.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在应用程序中使用了应用程序洞察，并且我们的Morningstar API密钥已经安全存储，我们可以开始构建我们的股息日历。
- en: Using an API key to secure our dividend calendar API
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API密钥保护我们的股息日历API
- en: To secure access to our dividend calendar API, we are going to use a client
    API key. There are many ways to share client keys with your clients, but we will
    not be discussing them here. You can come up with your own strategies. What we
    will be focusing on is how to enable authenticated and authorized client access
    to our API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的股息日历API的访问，我们将使用客户端API密钥。有许多方法可以与客户共享客户端密钥，但我们将不在这里讨论它们。你可以想出自己的策略。我们将专注于如何使客户能够经过身份验证和授权访问我们的API。
- en: To keep things simple, we will be using the **repository pattern**. The repository
    pattern helps to decouple our program from the underlying data store. This pattern
    improves maintainability and allows you to change the underlying data store without
    affecting the program. For our repository, our keys will be defined in a class,
    but in a commercial project, you would store the keys in a data store, such as
    Cosmos DB, SQL Server, or Azure Key Vault. You decide the strategy that best suits
    your needs, which is the main reason why we use the repository pattern as you
    are in control of the underlying data source for your own needs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将使用**存储库模式**。存储库模式有助于将我们的程序与底层数据存储解耦。这种模式提高了可维护性，并允许您更改底层数据存储而不影响程序。对于我们的存储库，我们的密钥将在一个类中定义，但在商业项目中，您可以将密钥存储在数据存储中，如Cosmos
    DB、SQL Server或Azure密钥保管库。您可以决定最适合您需求的策略，这也是我们使用存储库模式的主要原因，因为您可以控制自己需求的底层数据源。
- en: Setting up the repository
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置存储库
- en: 'We are going to start by setting up our repository:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置我们的存储库开始：
- en: 'Add a new folder to your project called `Repository`. Then, add a new interface
    called `IRepository` and a class that will implement `IRepository`, called `InMemoryRepository`.
    Modify your interface, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中添加一个名为`Repository`的新文件夹。然后，添加一个名为`IRepository`的新接口和一个将实现`IRepository`的类，名为`InMemoryRepository`。修改您的接口，如下所示：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This interface defines one method for retrieving the API key. We have not yet
    defined the `ApiKey` class and we will do that later. Now, let''s implement `InMemoryRepository`.
    Add the following `using` statements:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个接口定义了一个用于检索API密钥的方法。我们还没有定义`ApiKey`类，我们将在稍后进行。现在，让我们实现`InMemoryRepository`。添加以下`using`语句：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `security` namespaces will be created when we start adding the authentication
    and authorization classes. Modify the `Repository` class to implement the `IRepository` interface.
    Add the member variable that will hold our API keys, and then add the `GetApiKey()` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始添加身份验证和授权类时，将创建`security`命名空间。修改`Repository`类以实现`IRepository`接口。添加将保存我们的API密钥的成员变量，然后添加`GetApiKey()`方法：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `InMemoryRepository` class implements the `GetApiKey()` method of `IRepository`.
    This returns a dictionary of API keys. These keys will be stored in our `_apiKeys` dictionary
    member variable. Now, we''ll add our constructor:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InMemoryRepository`类实现了`IRepository`的`GetApiKey()`方法。这将返回一个API密钥的字典。这些密钥将存储在我们的`_apiKeys`字典成员变量中。现在，我们将添加我们的构造函数：'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our constructor creates a new list of API keys. It creates an internal API key
    for internal use only and an external API key for external use only. It then converts
    the list into a dictionary and stores the dictionary in `_apiKeys`. So, we now
    have our repository in place.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的构造函数创建了一个新的API密钥列表。它为内部使用创建了一个内部API密钥，为外部使用创建了一个外部API密钥。然后将列表转换为字典，并将字典存储在`_apiKeys`中。因此，我们现在已经有了我们的存储库。
- en: 'We will be using an HTTP header called `X-Api-Key`. This will store the client''s
    API key, which will be passed into our API for authentication and authorization.
    Add a new folder to the project called `Shared`, and then add a new file called `ApiKeyConstants`.
    Update the file with the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`X-Api-Key`的HTTP标头。这将存储客户端的API密钥，该密钥将传递到我们的API进行身份验证和授权。在项目中添加一个名为`Shared`的新文件夹，然后添加一个名为`ApiKeyConstants`的新文件。使用以下代码更新文件：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file contains two constants—the header name, which will be used when establishing
    the user's identity, and the URL for the Morningstar API key, which is stored
    in the Azure key vault that we created earlier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含两个常量——标头名称，用于建立用户身份的时候使用，以及Morningstar API密钥的URL，它存储在我们之前创建的Azure密钥保管库中。
- en: 'Since we will be handling JSON data, we need to set our JSON naming policy.
    Add a folder to your project called `Json`. Then, add a class called `DefaultJsonSerializerOptions`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将处理JSON数据，我们需要设置我们的JSON命名策略。在项目中添加一个名为`Json`的文件夹。然后，添加一个名为`DefaultJsonSerializerOptions`的类：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `DefaultJsonSerializerOptions` class sets our JSON naming policy to ignore
    null values and to use camel case names.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultJsonSerializerOptions`类将我们的JSON命名策略设置为忽略空值并使用驼峰命名法。'
- en: We will now start adding authentication and authorization to our API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始为我们的API添加身份验证和授权。
- en: Setting up authentication and authorization
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置身份验证和授权
- en: We will now start work on the security classes for authentication and authorization.
    It is good to clarify what we mean by authentication and authorization first.
    Authentication is establishing whether the user is authorized to access our API.
    Authorization is establishing what permissions the user has once they gain access
    to our API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始为身份验证和授权的安全类工作。首先澄清一下我们所说的身份验证和授权的含义是很好的。身份验证是确定用户是否被授权访问我们的API。授权是确定用户一旦获得对我们的API的访问权限后拥有什么权限。
- en: Adding authentication
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: 'Before we continue, add a `Security` folder to your project and then under
    that folder, add the `Authentication` and `Authorisation` folders. We will start
    by adding our `Authentication` classes; the first class that we will add to our
    `Authentication` folder is `ApiKey`. Add the following properties to `ApiKey`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，将一个`Security`文件夹添加到项目中，然后在该文件夹下添加`Authentication`和`Authorisation`文件夹。我们将首先添加我们的`Authentication`类；我们将添加到`Authentication`文件夹的第一个类是`ApiKey`。向`ApiKey`添加以下属性：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These properties store information that pertains to the specified API key and
    its owner. The properties are set via the constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性存储与指定API密钥及其所有者相关的信息。这些属性是通过构造函数设置的：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The constructor sets the API key properties. If a person fails authentication,
    then they will be notified with an `Error 403 Unauthorized` message. So, let''s
    now define our `UnauthorizedProblemDetails` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数设置API密钥属性。如果一个人身份验证失败，他们将收到一个`Error 403 Unauthorized`的消息。因此，现在让我们定义我们的`UnauthorizedProblemDetails`类：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This class inherits the `Microsoft.AspNetCore.Mvc.ProblemDetails` class. The
    constructor takes a single parameter of the `string` type, which defaults to `null`.
    You can pass details into this constructor to provide more information if required.
    Next, we add `AuthenticationBuilderExtensions`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自`Microsoft.AspNetCore.Mvc.ProblemDetails`类。构造函数接受一个`string`类型的单个参数，默认为`null`。如果需要，您可以将详细信息传递给这个构造函数以提供更多信息。接下来，我们添加`AuthenticationBuilderExtensions`：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This extension method adds API key support to the authentication service, which
    will be set in the `ConfigureServices` method of the `Startup` class. Now, add
    the `ApiKeyAuthenticationOptions` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展方法将API密钥支持添加到身份验证服务中，在`Startup`类的`ConfigureServices`方法中设置。现在，添加`ApiKeyAuthenticationOptions`类：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ApiKeyAuthenticationOptions` class inherits the `AuthenticationSchemeOptions`
    class. We set the default scheme to use API key authentication. The final part
    of our authorization is to build up our `ApiKeyAuthenticationHandler` class. As
    the name suggests, this is the main class for validating the API key, ensuring
    the client is authorized to access and use our API:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiKeyAuthenticationOptions`类继承自`AuthenticationSchemeOptions`类。我们将默认方案设置为使用API密钥身份验证。我们授权的最后一部分是构建我们的`ApiKeyAuthenticationHandler`类。顾名思义，这是用于验证API密钥，确保客户端被授权访问和使用我们的API的主要类：'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `ApiKeyAuthenticationHandler` class inherits from `AuthenticationHandler`
    and uses `ApiKeyAuthenticationOptions`. We define the content type for the problem
    details (exception information) as `application/problem+json`. We also provide
    a placeholder for our API key repository using the `_repository` member variable.
    The next step is to declare our constructor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ApiKeyAuthenticationHandler`类继承自`AuthenticationHandler`并使用`ApiKeyAuthenticationOptions`。我们将问题详细信息（异常信息）的内容类型定义为`application/problem+json`。我们还使用`_repository`成员变量提供了API密钥存储库的占位符。下一步是声明我们的构造函数：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our constructor passes the `ApiKeyAuthenticationOptions`, `ILoggerFactory`,
    `UrlEncoder`, and `ISystemClock` parameters to the base class. Explicitly, we
    set the repository. If the repository is null, we throw a null argument exception
    with the name of the repository. Let''s add our `HandleChallengeAsync()` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数将`ApiKeyAuthenticationOptions`、`ILoggerFactory`、`UrlEncoder`和`ISystemClock`参数传递给基类。明确地，我们设置了存储库。如果存储库为空，我们将抛出一个带有存储库名称的空参数异常。让我们添加我们的`HandleChallengeAsync()`方法：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `HandleChallengeAsync()` method returns an `Error 401 Unauthorized` response
    when the user challenge fails. Now, let''s add our `HandleForbiddenAsync()` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户挑战失败时，`HandleChallengeAsync()`方法返回一个`Error 401 Unauthorized`的响应。现在，让我们添加我们的`HandleForbiddenAsync()`方法：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `HandleForbiddenAsync()` method returns an `Error 403 Forbidden` response
    when the user permission check fails. Now, we need to add a final method that
    returns `AuthenticationResult`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户权限检查失败时，`HandleForbiddenAsync()`方法返回`Error 403 Forbidden`响应。现在，我们需要添加一个最终的方法，返回`AuthenticationResult`：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code we've just written checks whether our header exists. If the header
    is not present, then `AuthenticateResult()` returns a Boolean value of `true`
    for the `None` property, indicating that there was no information provided for
    this request. We then check whether the header has a value. If no value is provided,
    the `return` value indicates that no information was provided for this request.
    We then obtain our server-side key from our repository using the client-side key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的代码检查我们的标头是否存在。如果标头不存在，则`AuthenticateResult()`返回`None`属性的布尔值`true`，表示此请求未提供任何信息。然后我们检查标头是否有值。如果没有提供值，则`return`值表示此请求未提供任何信息。然后我们使用客户端密钥从我们的存储库中获取我们的服务器端密钥。
- en: If the server-side key is null, then a failed `AuthenticationResult()` instance
    is returned, indicating that the provided API key is invalid, as identified in
    the `Failure` property of the `Exception` type. Otherwise, the user is deemed
    authentic and is allowed to access our API. For valid users, we set the claims
    for their identities and then pass back a successful `AuthenticateResult()` instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器端的密钥为空，则返回一个失败的`AuthenticationResult()`实例，表示提供的API密钥无效，如`Exception`类型的`Failure`属性中所标识的那样。否则，用户被视为真实，并被允许访问我们的API。对于有效的用户，我们为他们的身份设置声明，然后返回一个成功的`AuthenticateResult()`实例。
- en: So, we have our authentication sorted. Now, we need to work on our authorization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经解决了我们的身份验证问题。现在，我们需要处理我们的授权。
- en: Adding authorization
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加授权
- en: 'Our authorization classes will be added to the `Authorisation` folder. Add
    the `Roles` struct with the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的授权类将被添加到`Authorisation`文件夹中。使用以下代码添加`Roles`结构：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We expect our API to be used internally and externally. However, for our minimum
    viable product, only the code for internal users will be implemented. Now, add
    the `Policies` struct:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望我们的API在内部和外部都可以使用。但是，对于我们的最小可行产品，只实现了内部用户的代码。现在，添加`Policies`结构：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our `Policies` structure, we have added two policies that will be used for
    internal and external clients. Now, we''ll add the `ForbiddenProblemDetails` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Policies`结构中，我们添加了两个将用于内部和外部客户端的策略。现在，我们将添加`ForbiddenProblemDetails`类：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This class provides the forbidden problem details if one or more permissions
    are not available to the authenticated user. You can pass a string into this class's
    constructor to provide relevant information if required.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个权限对经过身份验证的用户不可用，这个类提供了禁止的问题详细信息。如果需要，您可以将一个字符串传递到这个类的构造函数中，提供相关信息。
- en: 'For our authorization, we will need to add authorization requirements and handlers
    for both internal and external clients. We''ll add the `ExternalAuthorisationHandler` class
    first:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的授权，我们需要为内部和外部客户端添加授权要求和处理程序。首先，我们将添加`ExternalAuthorisationHandler`类：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ExternalRequirement` class is an empty class that implements the `IAuthorizationRequirement` interface.
    Now, add the `InternalAuthorisationHandler` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalRequirement`类是一个空类，实现了`IAuthorizationRequirement`接口。现在，添加`InternalAuthorisationHandler`类：'
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `InternalAuthorisationHandler` class handles the authorization of the internal
    requirement. If the context user is assigned to the internal role, then permission
    is granted. Otherwise, permission is denied. Let''s add the required  `InternalRequirement`
    class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalAuthorisationHandler`类处理内部要求的授权。如果上下文用户被分配到内部角色，则授予权限。否则，将拒绝权限。让我们添加所需的`InternalRequirement`类：'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the `InternalRequirement` class is an empty class that implements the `IAuthorizationRequirement` interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`InternalRequirement`类是一个空类，实现了`IAuthorizationRequirement`接口。
- en: 'We now have our authentication and authorization classes in place. So, it is
    now time to update our `Startup` class to wire up the `security` classes. Start
    by modifying the `Configure()` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的身份验证和授权类放在了适当的位置。所以，现在是时候更新我们的`Startup`类，将`security`类连接起来。首先修改`Configure()`方法：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Configure()` method sets the exception page to the developer page if we
    are in development. It then requests the app to use *routing* to match URIs with
    the actions in our controllers. The app is then informed that it should use our
    authentication and authorization methods. Finally, the application endpoints are
    mapped from the controllers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure()`方法将异常页面设置为开发人员页面（如果我们处于开发中）。然后请求应用程序使用*routing*将URI与我们的控制器中的操作匹配。然后通知应用程序应该使用我们的身份验证和授权方法。最后，从控制器映射应用程序端点。'
- en: 'The final method we need to update to complete our API key authentication and
    authorization is the `ConfigureServices()` method. The first thing we need to
    do is add our authentication service with API key support:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的最后一个方法来完成我们的API密钥身份验证和授权是`ConfigureServices()`方法。我们需要做的第一件事是添加我们的具有API密钥支持的身份验证服务：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we are setting the default authentication scheme. We add `AddApiKeySupport()`
    using our extension key, as defined in our `AuthenticationBuilderExtensions` class,
    which returns; `Microsoft.AspNetCore.Authentication.AuthenticationBuilder`. Our
    default scheme is set to the API key, as configured in our `ApiKeyAuthenticationOptions`
    class. The API key is a constant value that informs the authentication service
    that we will be using API key authentication. Now, we need to add our authorization
    service:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了默认的身份验证方案。我们使用我们的扩展密钥`AddApiKeySupport()`，如在我们的`AuthenticationBuilderExtensions`类中定义的那样，返回`Microsoft.AspNetCore.Authentication.AuthenticationBuilder`。我们的默认方案设置为API密钥，如在我们的`ApiKeyAuthenticationOptions`类中配置的那样。API密钥是一个常量值，通知身份验证服务我们将使用API密钥身份验证。现在，我们需要添加我们的授权服务：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are setting our internal and external policies and requirements. These
    are defined in our `Policies`, `InternalRequirement`, and `ExternalRequirement`
    classes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置我们的内部和外部策略和要求。这些定义在我们的`Policies`、`InternalRequirement`和`ExternalRequirement`类中。
- en: Well, we've added all of our API key security classes. So, we can now test whether
    our API key authentication and authorization is working using Postman.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经添加了所有的API密钥安全类。因此，我们现在可以使用Postman测试我们的API密钥身份验证和授权是否有效。
- en: Testing our API key security
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的API密钥安全性
- en: 'In this section, we are going to test our API key authentication and authorization
    using Postman. Add a class to your `Controllers` folder called `DividendCalendar`.
    Update the class as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Postman测试我们的API密钥身份验证和授权。在您的`Controllers`文件夹中添加一个名为`DividendCalendar`的类。更新类如下：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class will contain all of our dividend calendar API code functionality.
    Even though external code will not be used in this initial release of our minimum
    viable product, we will be able to test our internal and external authentication
    and authorization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将包含我们的股息日历API代码功能。尽管在我们的最小可行产品的初始版本中不会使用外部代码，但我们将能够测试我们的内部和外部身份验证和授权。
- en: 'Open Postman and create a new `GET` request. For the URL, use `https://localhost:44325/api/dividendcalendar/internal`.
    Click Send:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Postman并创建一个新的`GET`请求。对于URL，请使用`https://localhost:44325/api/dividendcalendar/internal`。点击发送：
- en: '![](img/cb86a829-e085-40e4-a8e8-222ddf94a65a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb86a829-e085-40e4-a8e8-222ddf94a65a.png)'
- en: 'As you can see, without the API key present in the API request, we get the
    expected `401 Unauthorized` status with our forbidden JSON, as defined in the `ForbiddenProblemDetails` class.
    Now, add the `x-api-key` header with the `C5BFF7F0-B4DF-475E-A331-F737424F013C` value.
    Then, click Send:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，在API请求中没有API密钥，我们得到了预期的`401未经授权`状态，以及我们在`ForbiddenProblemDetails`类中定义的禁止JSON。现在，添加`x-api-key`头，并使用`C5BFF7F0-B4DF-475E-A331-F737424F013C`值。然后，点击发送：
- en: '![](img/d2968005-7ae2-4e3f-8c33-cdae1e1fcc44.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2968005-7ae2-4e3f-8c33-cdae1e1fcc44.png)'
- en: 'You will now have a status of `200 OK`. This means that the API request has
    been successful. You can see the result of the request in the body. Internal users
    will see `Hello from GetDividendCalendar`. Run the request again, but change the
    URL so that the route is external instead of internal. So, the URL should be `https://localhost:44325/api/dividendcalendar/external`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将获得一个`200 OK`的状态。这意味着API请求已成功。您可以在正文中看到请求的结果。内部用户将看到`Hello from GetDividendCalendar`。再次运行请求，但更改URL，使路由为外部而不是内部。因此，URL应为`https://localhost:44325/api/dividendcalendar/external`：
- en: '![](img/70e85d72-8e5f-4e57-b678-fb074a597962.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70e85d72-8e5f-4e57-b678-fb074a597962.png)'
- en: 'You should receive a status of `403 Forbidden` with the forbidden JSON. This
    is because the API key is a valid API key, but the route is for an external client
    and the external client does not have access to the internal API. Change the `x-api-key` header
    value to `9218FACE-3EAC-6574-C3F0-08357FEDABE9`. Then, click Send:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该收到一个`403禁止`的状态和禁止的JSON。这是因为API密钥是有效的API密钥，但路由是为外部客户端而设，外部客户端无法访问内部API。将`x-api-key`头值更改为`9218FACE-3EAC-6574-C3F0-08357FEDABE9`。然后，点击发送：
- en: '![](img/222f0de1-53d5-4a1a-bd17-86c1dc9b7158.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/222f0de1-53d5-4a1a-bd17-86c1dc9b7158.png)'
- en: You will see that you have a status of `200 OK` and that the body has the `External
    access is currently unavailable` text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到您的状态是`200 OK`，并且正文中有`当前无法访问外部`的文本。
- en: Good news! Our role-based security system using API key authentication and authorization
    is tested and working. So, before we have even added our actual FinTech API, we
    have implemented and tested our API key, which is used to secure our FinTech API.
    So, we have put the security of our API first before writing a single line of
    our actual API. Now, we can start in earnest to build our dividend calendar API
    functionality, knowing that it is secure.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！我们使用API密钥身份验证和授权的基于角色的安全系统已经经过测试并且有效。因此，在我们实际添加我们的FinTech API之前，我们已经实施并测试了我们的API密钥，用于保护我们的FinTech
    API。因此，在编写我们实际API的一行代码之前，我们已经将API的安全性放在首位。现在，我们可以认真开始构建我们的股息日历API功能，知道它是安全的。
- en: Adding the dividend calendar code
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加股息日历代码
- en: Our internal API only has one purpose, which is to build up an array of dividends
    that are to be paid out this year. You, however, can build on this project to
    save the JSON to a file or database of some type. So, you would only make an internal
    call once a month to save money on API calls. However, the external role could
    access the data from your file or database as often as needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内部API只有一个目的，那就是建立今年要支付的股息数组。然而，您可以在此项目的基础上构建，将JSON保存到文件或某种类型的数据库中。因此，您只需要每月进行一次内部调用，以节省API调用的费用。然而，外部角色可以根据需要从您的文件或数据库中访问数据。
- en: We already have our controller in place for our dividend calendar API. This
    security is in place to prevent unauthenticated and unauthorized users from accessing
    our internal `GetDividendCalendar()` API endpoint. So, all we have to do now is
    generate the dividend calendar JSON, which our method will return.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的股息日历API准备好了控制器。这个安全性是为了防止未经身份验证和未经授权的用户访问我们的内部`GetDividendCalendar()`API端点。因此，现在我们所要做的就是生成股息日历JSON，我们的方法将返回。
- en: 'So that you can see what we will be working toward, have a look at the following
    truncated JSON response:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您看到我们将要努力实现的目标，请查看以下截断的JSON响应：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This JSON response is an array of dividends. A dividend consists of the `Mic`,
    `Ticker`, `CompanyName`, `DividendYield`, `Amount`, `ExDividendDate`, `DeclarationDate`,
    `RecordDate`, `PaymentDate`, `DividendType`, and `CurrencyCode` fields. Add a
    new folder to your project called `Models`, and then add the `Dividend` class
    with the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON响应是一个股息数组。股息由`Mic`、`Ticker`、`CompanyName`、`DividendYield`、`Amount`、`ExDividendDate`、`DeclarationDate`、`RecordDate`、`PaymentDate`、`DividendType`和`CurrencyCode`字段组成。在您的项目中添加一个名为`Models`的新文件夹，然后添加以下代码的`Dividend`类：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see what each of these fields represents:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个字段代表什么：
- en: '`Mic`: **ISO 10383 Market Identification Code** (**MIC**), which is where the
    stock is listed. See [https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes) for
    more information.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mic`: **ISO 10383市场识别代码**（**MIC**），这是股票上市的地方。有关更多信息，请参阅[https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes)。'
- en: '`Ticker`: The stock market ticker for the common stock.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ticker`: 普通股的股票市场代码。'
- en: '`CompanyName`: The name of the company that owns the stock.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompanyName`: 拥有该股票的公司的名称。'
- en: '`DividendYield`: The ratio of the company''s annual dividend compared to its
    share price. The dividend yield is calculated in terms of percentage and is calculated
    with the *Dividend Yield = Annual Dividend / Share Price* formula.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DividendYield`: 公司年度股利与股价的比率。股利收益率以百分比计算，并使用*股利收益率=年度股利/股价*公式计算。'
- en: '`Amount`: The amount that will be paid out to the shareholder per share.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Amount`: 每股支付给股东的金额。'
- en: '`ExDividendDate`: The date before which you must purchase the share in order
    to receive the next dividend payment.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExDividendDate`: 在此日期之前，您必须购买股票才能收到下一个股利支付。'
- en: '`DeclarationDate`: The date that the company declares they are paying a dividend.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeclarationDate`: 公司宣布支付股利的日期。'
- en: '`RecordDate`: The date that the company looks at its records to determine who
    will receive the dividend.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordDate`: 公司查看其记录以确定谁将收到股利的日期。'
- en: '`PaymentDate`: The date that the shareholders receives the dividend payment.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PaymentDate`: 股东收到股利支付的日期。'
- en: '`DividendType`: This can be, for example, `Cash Dividend`, `Property Dividend`,
    `Stock Dividend`, `Scrip Dividend`, or `Liquidating Dividend`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DividendType`: 这可以是，例如，`现金股利`，`财产股利`，`股票股利`，`分红股`或`清算股利`。'
- en: '`CurrencyCode`: The currency that the amount will be paid in.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyCode`: 金额将支付的货币。'
- en: 'The next class we need in our `Models` folder is the `Company` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Models`文件夹中需要的下一个类是`Company`类：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Mic` and `Ticker` fields are the same as for our `Dividend` class. Between
    the different API calls, the APIs use different names for the currency identifier.
    That is why we have `CurrencyCode` in `Dividend` and `Currency` in `Company`.
    This helps the JSON with the object-mapping process so that we don't experience
    formatting exceptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mic`和`Ticker`字段与我们的`Dividend`类相同。在不同的API调用之间，API使用不同的货币标识符名称。这就是为什么我们在`Dividend`中有`CurrencyCode`，在`Company`中有`Currency`。这有助于JSON对象映射过程，以便我们不会遇到格式化异常。'
- en: 'Each of these fields represents the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段分别代表以下内容：
- en: '`Currency`: The currency used to price the stock'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Currency`: 用于定价股票的货币'
- en: '`SecurityId`: The stock market security identifier for the common stock'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityId`: 普通股的股票市场安全标识符'
- en: '`CompanyName`: The name of the company that owns the stock'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompanyName`: 拥有该股票的公司的名称'
- en: 'Our next `Models` class is called `Companies`. This class is required to store
    the companies that are returned in the initial Morningstar API call. We will be
    looping through the list of companies to make further API calls to get each company''s
    record so that we can then make our API call to get the company''s dividend:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的`Models`类称为`Companies`。这个类用于存储在初始Morningstar API调用中返回的公司。我们将循环遍历公司列表，以进行进一步的API调用，以获取每家公司的记录，以便我们随后进行API调用以获取公司的股利：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Each of these properties defines the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性分别定义以下内容：
- en: '`Total`: The total number of records returned from the API query'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Total`: 从API查询返回的记录总数'
- en: '`Offset`: The record offset'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Offset`: 记录偏移量'
- en: '`Results`: The list of companies returned'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Results`: 返回的公司列表'
- en: '`ResponseStatus`: Provides detailed response information, especially if errors
    are returned'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseStatus`: 提供详细的响应信息，特别是如果返回错误的话'
- en: 'Now, we will add the `Dividends` class. This class holds the list of dividends
    returned by the dividends'' Morningstar API response:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加`Dividends`类。这个类保存了股利的列表，这些股利是通过股利的Morningstar API响应返回的：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each of these properties is the same as those defined previously, except for
    the `Results` property, which defines a list of dividend payments returned for
    the specified company.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性与之前定义的相同，除了`Results`属性，它定义了返回指定公司的股利支付列表。
- en: 'The final class we need to add to our `Models` folder is the `ResponseStatus` class.
    This is mainly used to store error information:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到我们的`Models`文件夹中的最后一个类是`ResponseStatus`类。这主要用于存储错误信息：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The properties of this class are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的属性如下：
- en: '`ErrorCode`: The number of the error'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorCode`: 错误的编号'
- en: '`Message`: The error message'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`: 错误消息'
- en: '`StackTrace`: The error diagnostics'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackTrace`: 错误诊断'
- en: '`Errors`: A list of errors'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Errors`: 错误列表'
- en: '`Meta`: A list of the error metadata'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Meta`: 错误元数据列表'
- en: 'We now have all the models we need in place. So now, we can start to make our
    API calls to build up our dividend payment calendar. In the controller, add a
    new method called `FormatStringDate()`, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了所有需要的模型。现在，我们可以开始进行API调用，以建立我们的股利支付日历。在控制器中，添加一个名为`FormatStringDate()`的新方法，如下所示：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method takes a string date. If the string is null or empty, then `null`
    is returned. Otherwise, the string is parsed and a nullable `DateTime` value is
    passed back. We''ll also need a method that extracts our Morningstar API key from
    our Azure key vault:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个字符串日期。如果字符串为null或空，则返回null。否则，解析字符串并传回一个可空的`DateTime`值。我们还需要一个方法，从Azure密钥保管库中提取我们的Morningstar
    API密钥：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `GetMorningstarApiKey()` method instantiates `AzureServiceTokenProvider`.
    It then creates a new `KeyVaultClient` object type, which performs cryptographic
    key operations. Then, the method awaits the response to get the Morningstar API
    key from the Azure key vault. It then passes back the response value. If an error
    occurs processing a request, `KeyVaultErrorException.Message` is returned.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMorningstarApiKey()`方法实例化`AzureServiceTokenProvider`。然后，它创建一个新的`KeyVaultClient`对象类型，执行加密密钥操作。然后，该方法等待从Azure密钥保管库获取Morningstar
    API密钥的响应。然后，它传回响应值。如果在处理请求时发生错误，则返回`KeyVaultErrorException.Message`。'
- en: 'When processing the dividends, we first obtain a list of companies from a stock
    exchange. We then loop through these companies and make another call to get the
    dividends for each company in that stock exchange. So, we''ll start with our method
    to obtain a list of companies by MIC. Remember, we are using the `RestSharp` library.
    So, if you have not already installed it, then now is a good time to do so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理股息时，我们首先从证券交易所获取公司列表。然后，我们循环遍历这些公司，并对该证券交易所中的每家公司进行另一个调用以获取每家公司的股息。因此，我们将从通过MIC获取公司列表的方法开始。请记住，我们使用`RestSharp`库。因此，如果您还没有安装它，现在是一个很好的时机。
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our `GetCompanies()` method creates a new REST client that points to the API
    URL that retrieves a list of companies that are listed on the specified stock
    exchange. The type of the request is a `GET` request. We add three headers to
    our `GET` request for `x-rapidapi-host`, `x-rapidapi-key`, and `accept`. Then,
    we execute the request and return the deserialized JSON data via the `Companies` model.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GetCompanies()`方法创建一个新的REST客户端，指向检索上市公司列表的API URL。请求的类型是`GET`请求。我们为`GET`请求添加了三个头部，分别是`x-rapidapi-host`，`x-rapidapi-key`和`accept`。然后，我们执行请求并通过`Companies`模型返回反序列化的JSON数据。
- en: 'Now, we will write the methods that return the dividends for the specified
    exchange and company. Let''s start by adding the `GetDividends()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写返回指定交易所和公司的股息的方法。让我们从添加`GetDividends()`方法开始：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `GetDividends()` method is the same as the `GetCompanies()` method, except
    the request returns the dividends for the specified stock exchange and company.
    The JSON is deserialized into an instance of the `Dividends` object and is returned.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDividends()`方法与`GetCompanies()`方法相同，只是请求返回指定股票交易所和公司的股息。 JSON反序列化为`Dividends`对象的实例并返回。'
- en: 'For our final method, we need our minimum viable product to be built into the `BuildDividendCalendar()` method.
    This method is the method that will build up the dividend calendar JSON that will
    be returned to the client:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终方法，我们需要将我们的最小可行产品构建到`BuildDividendCalendar()`方法中。这个方法是构建股息日历JSON的方法，将返回给客户端：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this version of the API, we hardcode the MIC to `"XLON"`—the **London Stock
    Exchange**. However, in future releases, this method and the public endpoint could
    be updated to accept a MIC as a `request` parameter. We then add a `list` variable
    to hold this year's dividend payments. Then, we perform our Morningstar API call
    to extract the list of companies that are currently listed on the specified MIC.
    Once the list is returned, we loop through results. For each company, we then
    make a further API call to get the complete dividend record for the MIC and the
    ticker. If the company has no dividends listed, then we continue with the next
    iteration and select the next company.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个API的版本中，我们将MIC硬编码为`"XLON"`——**伦敦证券交易所**。然而，在未来的版本中，这个方法和公共端点可以更新为接受`request`参数的MIC。然后，我们添加一个`list`变量来保存今年的股息支付。然后，我们执行我们的Morningstar
    API调用，以提取当前在指定MIC上市的公司列表。一旦列表返回，我们循环遍历结果。对于每家公司，我们然后进行进一步的API调用，以获取指定MIC和股票的完整股息记录。如果公司没有列出股息，那么我们继续下一个迭代并选择下一个公司。
- en: If the company has dividend records, we get the first record, which will be
    the latest dividend payment. We check whether the payable date is `null`. If the
    payable date is `null`, then we continue on to the next iteration with the next
    customer. If the payable date is not `null`, we check whether the payable date
    is greater than December 31^(st) from the previous year. If the date difference
    is greater than 1, then we add a new dividend object to this year's dividends
    list. Once we have iterated through all the companies and built up a list of this
    year's dividends, we then pass the list back to the calling method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司有股息记录，我们获取第一条记录，这将是最新的股息支付。我们检查可支付日期是否为`null`。如果可支付日期为`null`，那么我们继续下一个迭代，选择下一个客户。如果可支付日期不为`null`，我们检查可支付日期是否大于上一年的12月31日。如果日期差大于1，那么我们将向今年的股息列表添加一个新的股息对象。一旦我们遍历了所有公司并建立了今年的股息列表，我们将列表传回给调用方法。
- en: 'The final step before we run our project is to update the `GetDividendCalendar()` method
    to call the `BuildDividendCalendar()` method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前的最后一步是更新`GetDividendCalendar()`方法以调用`BuildDividendCalendar()`方法：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `GetDividendCalendar()` method, we return a JSON string from the serialized
    list of this year''s dividends. So, if you run the project in Postman using the
    internal `x-api-key` variable, then you should find that after around 20 minutes,
    the following JSON is returned:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetDividendCalendar()`方法中，我们从今年的股息序列化列表返回一个JSON字符串。因此，如果您在Postman中使用内部`x-api-key`变量运行项目，那么大约20分钟后，将返回以下JSON：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This query does take a lot of time to run, roughly around 20 minutes, and the
    results will change over the course of a year. So, a strategy we could use is
    to throttle the API to run once a month and then store the JSON either in a file
    or a database. Then, this file or database record is what you would update the
    external method to call and pass back to external clients. Let's throttle our
    API to only run once a month.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询确实需要很长时间才能运行，大约20分钟左右，结果会在一年的时间内发生变化。因此，我们可以使用的一种策略是限制API每月运行一次，然后将JSON存储在文件或数据库中。然后，这个文件或数据库记录就是您要更新的外部方法调用并传回给外部客户端。让我们将API限制为每月运行一次。
- en: Throttling our API
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制我们的API
- en: When exposing APIs, you need to throttle them. There are many methods available
    to do this, such as limiting the number of simultaneous users or limiting the
    number of calls within a given period of time, for example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在暴露API时，您需要对其进行节流。有许多可用的方法来做到这一点，例如限制同时用户的数量或限制在给定时间内的调用次数。
- en: 'In this section, we are going to throttle our API. The method we will use to
    throttle our API will be to limit our API to run only once a month on the 25^(th)
    of the month. Add the following line to your `appsettings.json` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将对我们的API进行节流。我们将用来节流API的方法是限制我们的API每月只能在当月的25日运行一次。将以下一行添加到您的`appsettings.json`文件中：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This value will contain the date that the next API can be executed. Now, add
    the `AppSettings` class at the root of your project, and then add the following
    property:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值将包含下一个API可以执行的日期。现在，在项目的根目录添加`AppSettings`类，然后添加以下属性：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This property will hold the value of the `MorningstarNextRunDate` key. The
    next thing to do is to add our static method, which will be called to add or update
    an application setting in the `appsetting.json` file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将保存`MorningstarNextRunDate`键的值。接下来要做的是添加我们的静态方法，该方法将被调用以在`appsetting.json`文件中添加或更新应用程序设置：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`AddOrUpdateAppSetting()` tries to get the file path for the `appsettings.json` file.
    It then reads the JSON from the file. The JSON is then deserialized into a `dynamic` object.
    We then call our method to recursively set the required value. Then, we write
    the JSON back to the same file. If an error is encountered, then we output an
    error message to the console. Let''s write our `SetValueRecursively()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOrUpdateAppSetting()`尝试获取`appsettings.json`文件的文件路径。然后从文件中读取JSON。然后将JSON反序列化为`dynamic`对象。然后我们调用我们的方法递归设置所需的值。然后，我们将JSON写回同一文件。如果遇到错误，则将错误消息输出到控制台。让我们编写我们的`SetValueRecursively()`方法：'
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `SetValueRecursively()` method splits the string at the first apostrophe
    character. It then proceeds to recursively process the JSON, moving down the tree.
    When it gets to where it needs to be—that is, it finds the required value—the
    value is then set and the method returns. Add the `ThrottleMonthDay` constant to
    the `ApiKeyConstants` struct:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetValueRecursively()`方法在第一个撇号字符处拆分字符串。然后递归处理JSON，向下移动树。当它到达需要的位置时，也就是找到所需的值时，然后设置该值并返回该方法。将`ThrottleMonthDay`常量添加到`ApiKeyConstants`结构中：'
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This constant is used for our day-of-the-month check when an API request is
    issued. In `DividendCalendarController`, add the `ThrottleMessage()` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当API请求发出时，此常量用于我们的日期检查。在`DividendCalendarController`中，添加`ThrottleMessage()`方法：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `ThrottleMessage()` method simply returns the message, `"This API call
    can only be made once on the 25th of each  month."`. Now, add the following constructor:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrottleMessage()`方法只是返回消息，`"此API调用只能在每月的25日进行一次。"`。现在，添加以下构造函数：'
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This constructor provides us with access to the values in the `appsettings.json` file. 
    Add these two lines to the end of your `Startup.ConfigureServices()` method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数为我们提供了访问`appsettings.json`文件中的值。将以下两行添加到您的`Startup.ConfigureServices()`方法的末尾：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'These two lines enable the `AppSettings` class to be dynamically injected into
    our controller when we need it. Add the `SetMorningstarNextRunDate()` method to
    the `DividendCalendarController` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行使`AppSettings`类能够在需要时动态注入到我们的控制器中。将`SetMorningstarNextRunDate()`方法添加到`DividendCalendarController`类中：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `SetMorningstarNextRunDate()` method checks whether the current month''s
    day is less than `25`. If the current month''s day is less than `25`, then the
    month is set to the current month so that the API can be run on the 25^(th) of
    the current month. Otherwise, for days that are `25` and upward, the month is
    set to the following month. The new date is then assembled and the `MorningstarNextRunDate` key
    of `appsettings.json` is then updated and the nullable `DateTime` value is returned:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMorningstarNextRunDate()`方法检查当前月份的日期是否小于`25`。如果当前月份的日期小于`25`，则将月份设置为当前月份，以便API可以在当月的25日运行。否则，对于大于或等于`25`的日期，月份将设置为下个月。然后组装新日期，然后更新`appsettings.json`的`MorningstarNextRunDate`键，返回可空的`DateTime`值：'
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`CanExecuteApiRequest()` gets the current value of the `MorningstarNextRunDate`
    value from the `AppSettings` class. If `DateTime?` does not have a value, then
    the value is set and assigned to the `nextRunDate` local variable. If the current
    month''s day does not equal `ThrottleMonthDay`, then we return `false`. If the
    current month does not equal the next run date month, then we return `false`.
    Otherwise, we set the next API run date to the 25^(th) of the following month
    and return `true`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanExecuteApiRequest()`从`AppSettings`类中获取`MorningstarNextRunDate`值的当前值。如果`DateTime?`没有值，则将该值设置并分配给`nextRunDate`本地变量。如果当前月份的日期不等于`ThrottleMonthDay`，则返回`false`。如果当前月份不等于下次运行日期的月份，则返回`false`。否则，我们将下一个API运行日期设置为下个月的25日，并返回`true`。'
- en: 'Finally, we update our `GetDividendCalendar()` method, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新我们的`GetDividendCalendar()`方法，如下所示：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When an internal user calls the API now, their request will be validated to
    see whether it can run. If it runs, then the serialized JSON for the dividend
    calendar is returned. Otherwise, we return the `throttle` message.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当内部用户调用API时，他们的请求将被验证，以查看是否可以运行。如果运行，则返回股息日历的序列化JSON。否则，我们返回`throttle`消息。
- en: That concludes our project.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的项目。
- en: Well, we've completed our project. It is not perfect, and there are improvements
    and extensions that we can make. The next step would be to document our API and
    deploy the API and documentation. We should also add logging and monitoring.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们完成了我们的项目。它并不完美，还有我们可以做的改进和扩展。下一步是记录我们的API并部署API和文档。我们还应该添加日志记录和监控。
- en: Logging is useful for storing exception details and for tracking how our API
    is used. Monitoring is a way to keep an eye on the health of our API so that we
    can be alerted if anything goes wrong. This way, we can be proactive in keeping
    our API up and running. I will leave you to extend the API as you desire. It will
    be a good learning exercise for you.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录对于存储异常详细信息以及跟踪我们的API的使用方式非常有用。 监控是一种监视我们的API健康状况的方法，这样我们可以在出现问题时收到警报。 这样，我们可以积极地保持我们的API正常运行。
    我将让您根据需要扩展API。 这对您来说将是一个很好的学习练习。
- en: The next chapter addresses cross-cutting concerns. It will give you an idea
    about how to address logging and monitoring using aspects and attributes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涉及横切关注点。 它将让您了解如何使用方面和属性来处理日志记录和监视。
- en: Let's summarise what we have learned.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you signed up to a third-party API and received your own key.
    The API key is stored in your Azure key vault and kept secure from access by unauthorized
    clients. You then moved on to create an ASP.NET Core web application and published
    it to Azure. Then, you set about securing the web application by using authentication
    and role-based authorization.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您注册了一个第三方API并收到了自己的密钥。 API密钥存储在您的Azure密钥保险库中，并且不被未经授权的客户端访问。 然后，您开始创建了一个ASP.NET
    Core Web应用程序并将其发布到Azure。 然后，您开始使用身份验证和基于角色的授权来保护Web应用程序。
- en: The authorization we set up is performed using an API key. You used two API
    keys in this project—one for internal use and one for external use. The testing
    of our API and API key security was performed using the Postman application. Postman
    is a very good and useful tool for testing HTTP requests and responses for the
    various HTTP verbs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的授权是使用API密钥执行的。 在这个项目中，您使用了两个API密钥——一个用于内部使用，一个用于外部使用。 我们使用Postman应用程序进行了API和API密钥安全性的测试。
    Postman是一个非常好的有用的工具，用于测试各种HTTP谓词的HTTP请求和响应。
- en: You then added the dividend calendar API code and enabled internal and external
    access based on API keys. The project itself performed a number of different API
    calls to build up a list of companies that are expecting to pay dividends to investors.
    The project then serializes the objects into JSON format, which is returned to
    the client. Finally, the project is throttled to run once a month.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您添加了股息日历API代码，并基于API密钥启用了内部和外部访问。 项目本身执行了许多不同的API调用，以建立一份预计向投资者支付股息的公司列表。
    项目然后将对象序列化为JSON格式，返回给客户端。 最后，该项目被限制为每月运行一次。
- en: So, by working through this chapter, you have created a FinTech API that you
    can run once a month. This API will provide dividend payment information for the
    current year. Your clients can deserialize this data and then perform LINQ queries
    on it to extract data that meets their specific requirements.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过完成本章，您已经创建了一个FinTech API，可以每月运行一次。 该API将为当年提供股息支付信息。 您的客户可以对此数据进行反序列化，然后对其执行LINQ查询，以提取满足其特定要求的数据。
- en: In the next chapter, we will be using PostSharp to implement **Aspect-Oriented
    Programming **(**AOP**). With our AOP framework, we will learn how to manage common
    functionalities such as exception handling, logging, security, and transactions
    within our applications. But before that, let's put your brain to work to see
    what you have learned.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用PostSharp来实现**面向方面的编程**（**AOP**）。 通过我们的AOP框架，我们将学习如何在应用程序中管理常见功能，如异常处理，日志记录，安全性和事务。
    但在那之前，让我们让您的大脑思考一下您学到了什么。
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What URL is a good source for hosting your own APIs and accessing third-party
    APIs?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个URL是托管您自己的API并访问第三方API的良好来源？
- en: What are the two required parts for securing an API?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护API所需的两个必要部分是什么？
- en: What are claims and why should you use them?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明是什么，为什么应该使用它们？
- en: What do you use Postman for?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您用Postman做什么？
- en: Why should you use the repository pattern for your data store?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该使用存储库模式来管理数据存储？
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api) is
    Microsoft''s in-depth guide to web API security.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api)
    是微软关于Web API安全的深入指南。'
- en: '[https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb) covers
    creating the ASP.NET membership database.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb)
    讲解了如何创建ASP.NET成员数据库。'
- en: '[https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes)
    is about ISO 10383 MIC.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes)
    是关于ISO 10383 MIC的链接。'
- en: '[https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service](https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service) covers
    adding key vault to your web application by using Visual Studio Connected Services.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service](https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service)
    讲解了如何使用Visual Studio Connected Services将密钥保险库添加到您的Web应用程序。'
- en: '[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows) is
    about the Azure CLI MSI installer.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)
    是关于Azure CLI MSI安装程序的链接。'
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication](https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication) is
    the Azure service-to-service documentation.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication](https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication)
    是Azure服务到服务认证的文档。'
- en: '[https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F](https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F) is
    where you can sign up for your free 12-month subscription to Azure if you are
    a new customer.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F](https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F) 是您可以注册免费12个月Azure订阅的地方，如果您是新客户。'
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts](https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts) looks
    at the Azure Key Vault basic concepts.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts](https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts) 介绍了Azure
    Key Vault的基本概念。'
- en: '[https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet](https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet) covers
    creating a .NET Core app in Azure.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet](https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet) 介绍了在Azure中创建.NET
    Core应用程序。'
- en: '[https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans](https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans) provides
    an Azure App Service plan overview.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans](https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans) 提供了Azure应用服务计划的概述。'
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app](https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app) is
    a tutorial on using Azure Key Vault with an Azure web app in .NET.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app](https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app) 是一个关于在.NET中使用Azure
    Key Vault与Azure Web应用程序的教程。'
