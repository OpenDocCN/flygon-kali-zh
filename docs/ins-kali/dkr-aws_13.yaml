- en: Continuously Delivering ECS Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付ECS应用程序
- en: '**Continuous delivery** is the practice of creating a repeatable and reliable
    process for releasing software, so that you can deploy new features to production
    frequently and on demand, with a lower cost and risk. There are numerous benefits
    to adopting continuous delivery, and today, more and more organizations are adopting
    it, to get features to the market faster, increase customer satisfaction, and
    lower the cost of software delivery.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付**是创建一个可重复和可靠的软件发布过程的实践，以便您可以频繁且按需地将新功能部署到生产环境，成本和风险更低。采用持续交付有许多好处，如今越来越多的组织正在采用它，以更快地将功能推向市场，提高客户满意度，并降低软件交付成本。'
- en: Implementing continuous delivery requires a high degree of automation across
    the end-to-end life cycle of software delivery. So far, in this course, you have
    worked with many technologies that support automation and continuous delivery,
    in general. For example, Docker inherently brings a high degree of automation
    and promotes repeatable and consistent build processes, all of which are critical
    components of continuous delivery. The make workflow in the `todobackend` repository
    takes this a step further, automating a full test, build, and publish workflow
    for your Docker images. We have also been using CloudFormation extensively throughout
    this course, which provides us with the ability to create, update, and destroy
    complete AWS environments in a completely automated fashion, and allows us to
    easily deploy new features (in the form of new Docker images) in a reliable and
    consistent manner. Continuous delivery brings all of these features and capabilities
    together to create an end-to-end process for the delivery of software changes,
    from the time they are developed and committed to source code, to the time they
    are regression-tested and deployed to production. To achieve this level of end-to-end
    orchestration and automation, we need to adopt new tools that are engineered for
    this purpose, and AWS offers a number of services that work together to deliver
    this, including AWS CodePipeline, CodeBuild, and CloudFormation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实施持续交付需要在软件交付的端到端生命周期中实现高度自动化。到目前为止，在这门课程中，您已经使用了许多支持自动化和持续交付的技术。例如，Docker本身带来了高度自动化，并促进了可重复和一致的构建过程，这些都是持续交付的关键组成部分。`todobackend`存储库中的make工作流进一步实现了这一点，自动化了Docker镜像的完整测试、构建和发布工作流程。在整个课程中，我们还广泛使用了CloudFormation，它使我们能够以完全自动化的方式创建、更新和销毁完整的AWS环境，并且可以轻松地以可靠和一致的方式部署新功能（以新的Docker镜像形式）。持续交付将所有这些功能和能力整合在一起，创建了一个端到端的软件变更交付过程，从开发和提交源代码的时间到回归测试和部署到生产的时间。为了实现这种端到端的协调和自动化，我们需要采用专为此目的设计的新工具，AWS提供了一系列服务来实现这一点，包括AWS
    CodePipeline、CodeBuild和CloudFormation。
- en: In this chapter, you will learn how you can implement an end-to-end continuous
    delivery pipeline (using CodePipeline, CodeBuild, and CloudFormation) that will
    continuously test, build, and publish Docker images, and then continuously deploy
    your freshly built Docker images to a non-production environment. The pipeline
    will also support controlled releases into a production environment, by automatically
    creating change sets that must be reviewed and approved before deploying new changes
    into production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何实现一个端到端的持续交付流水线（使用CodePipeline、CodeBuild和CloudFormation），该流水线将持续测试、构建和发布Docker镜像，然后持续将新构建的Docker镜像部署到非生产环境。该流水线还将支持对生产环境进行受控发布，自动创建必须经过审查和批准的变更集，然后才能将新变更部署到生产环境。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing CodePipeline and CodeBuild
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CodePipeline和CodeBuild
- en: Creating a custom CodeBuild container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义CodeBuild容器
- en: Adding CodeBuild support to your application repository
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序存储库添加CodeBuild支持
- en: Creating a continuous integration pipeline using CodePipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建持续集成流水线
- en: Creating a continuous deployment pipeline using CodePipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建持续部署流水线
- en: Continuously delivering your applications to production
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续将您的应用程序交付到生产环境
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists the technical requirements for completing this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: Administrator access to an AWS account.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS账户的管理员访问权限。
- en: A local AWS profile, configured as per the instructions in Chapter 3.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地AWS配置文件，根据第3章的说明进行配置。
- en: The AWS CLI version 1.15.71 or higher
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI版本1.15.71或更高
- en: This chapter continues on from Chapter 12, so it requires that you have successfully
    completed all configuration tasks defined in Chapter 12.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章继续自第12章，因此需要您成功完成第12章中定义的所有配置任务。
- en: This chapter requires you to have both the `todobackend` and `todobackend-aws`
    repositories published to a GitHub account that you have administrative access
    to.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章要求您将`todobackend`和`todobackend-aws`存储库发布到您具有管理访问权限的GitHub账户。
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub URL包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2BVGMYI](http://bit.ly/2BVGMYI)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2BVGMYI](http://bit.ly/2BVGMYI)'
- en: Introducing CodePipeline and CodeBuild
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍CodePipeline和CodeBuild
- en: '**CodePipeline** and **CodeBuild** are two services from the developer tools
    portfolio of AWS that, along with the CloudFormation service that we have been
    working with extensively throughout this book, provide the building blocks for
    creating complete and comprehensive continuous delivery solutions to pave your
    application''s path from development to production.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline和CodeBuild是AWS开发工具组合中的两项服务，与我们在本书中广泛使用的CloudFormation服务一起，为创建完整和全面的持续交付解决方案提供了构建块，为您的应用程序从开发到生产铺平道路。
- en: CodePipeline allows you to create complex pipelines that take your applications'
    source code, build, test, and publish application artifacts, and then deploy your
    applications into non-production and production environments. The top-level building
    blocks of these pipelines are stages, which must always start with a source stage
    that includes one or more source materials for your pipeline, such as the source
    code repository for your application. Each stage can then be comprised of one
    or more actions that produce an artifact that can be used later on in your pipeline,
    or achieve a desired outcome, such as deploying to an environment. You can define
    actions in sequence or in parallel, which allows you to orchestrate almost any
    scenario you want; for example, I have used CodePipeline to orchestrate the deployment
    of complete, complex, multi-application environments in a highly controlled fashion
    that can easily be visualized and managed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline允许您创建复杂的流水线，将应用程序的源代码、构建、测试和发布应用程序工件，然后将应用程序部署到非生产和生产环境中。这些流水线的顶层构建模块是阶段，它们必须始终以包含一个或多个流水线的源材料的源阶段开始，例如应用程序的源代码仓库。然后，每个阶段可以由一个或多个操作组成，这些操作会产生一个工件，可以在流水线的后续阶段中使用，或者实现期望的结果，例如部署到一个环境。您可以按顺序或并行定义操作，这使您能够编排几乎任何您想要的场景；例如，我已经使用CodePipeline以高度受控的方式编排了完整、复杂的多应用程序环境的部署，这样可以轻松地进行可视化和管理。
- en: Every CodePipeline pipeline must define at least two stages, and we will see
    an example of this initially, when we create a continuous integration pipeline
    including a source stage (which collects application source code from a source
    code repository) and a build stage (which tests, builds, and publishes application
    artifacts from the application source collected by the source stage).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CodePipeline流水线必须定义至少两个阶段，我们将在最初看到一个示例，当我们创建一个包括源阶段（从源代码仓库收集应用程序源代码）和构建阶段（从源阶段收集的应用程序源代码测试、构建和发布应用程序工件）的持续集成流水线。
- en: An important concept to understand here is the concept of artifacts. Many actions
    in CodePipeline consume input artifacts and produce output artifacts, and the
    ability for one action to consume the output of an earlier action is the essence
    of how CodePipeline works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这里的一个重要概念是“工件”的概念。CodePipeline中的许多操作都会消耗输入工件并产生输出工件，一个操作消耗早期操作的输出的能力是CodePipeline工作原理的本质。
- en: 'As an example, the following diagram illustrates the initial continuous integration
    pipeline that we will create:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图表说明了我们将创建的初始持续集成流水线：
- en: '![](assets/27880320-80ab-4e17-8106-8fc29ba82459.png)Continuous integration
    pipeline'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/27880320-80ab-4e17-8106-8fc29ba82459.png)持续集成流水线'
- en: In the preceding diagram, the **Source Stage** includes a single **Source Action**
    that is linked to your todobackend GitHub repository. This action will download
    the latest source code whenever changes are committed to your GitHub repository,
    and will produce an output artifact that zips up your source code and makes it
    available for the build stage that immediately follows. The **Build Stage** has
    a single **Build Action** that takes your source action output artifact as an
    input, and then tests, builds, and publishes a Docker image. The **Build Action**
    in the preceding diagram is executed by the AWS CodeBuild service, which is a
    fully managed build service that provides a container-based build agent for running
    build jobs on demand. CodePipeline ensures that the CodeBuild build job is supplied
    with an input artifact that includes your application source code, which allows
    CodeBuild to then run your local test, build, and publish the workflow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，**源阶段**包括一个与您的todobackend GitHub存储库相关联的**源操作**。每当对GitHub存储库进行提交更改时，此操作将下载最新的源代码，并生成一个输出工件，将您的源代码压缩并使其可用于紧随其后的构建阶段。**构建阶段**有一个**构建操作**，它将您的源操作输出工件作为输入，然后测试、构建和发布Docker镜像。上图中的**构建操作**由AWS
    CodeBuild服务执行，该服务是一个完全托管的构建服务，为按需运行构建作业提供基于容器的构建代理。CodePipeline确保CodeBuild构建作业提供了一个包含应用程序源代码的输入工件，这样CodeBuild就可以运行本地测试、构建和发布工作流程。
- en: 'So far, we have discussed the concept of the source and build stages in CodePipeline;
    the other common stage that you will use in your pipelines is a deploy stage,
    where you deploy your application artifacts into a target environment. The following
    diagram illustrates how you can extend the pipeline shown in the preceding diagram
    to continuously deploy your applications:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了CodePipeline中源和构建阶段的概念；您在流水线中将使用的另一个常见阶段是部署阶段，在该阶段中，您将应用程序工件部署到目标环境。以下图示了如何扩展上图中显示的流水线，以持续部署您的应用程序：
- en: '![](assets/a2ac7b82-63b4-4d97-a803-2126e603a611.png)Continuous deployment pipeline'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a2ac7b82-63b4-4d97-a803-2126e603a611.png)持续部署流水线'
- en: In the preceding diagram, a new stage (called **Dev Stage**) has been added;
    it leverages CodePipeline's integration with CloudFormation to deploy your applications
    into a non-production environment, which we refer to as dev (development). Because
    we are using CloudFormation for deployment, we need to provide a CloudFormation
    stack to deploy, and this is provided by adding the todobackend-aws repository
    as another source action in the source stage. The **Deploy Action** also requires
    another input artifact that defines the tag of the Docker image to deploy, and
    this is provided as an output artifact (called `ApplicationVersion`) of the CodeBuild
    build action in the build stage. Don't worry if this doesn't make too much sense
    right now; we will cover all of the details and set up these pipelines in this
    chapter, but it is important to at least understand the concepts of stages, actions,
    and how artifacts can be passed between them to achieved your desired outcomes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，添加了一个新阶段（称为**Dev阶段**）；它利用CodePipeline与CloudFormation的集成将应用程序部署到非生产环境中，我们称之为dev（开发）。因为我们使用CloudFormation进行部署，所以需要提供一个CloudFormation堆栈进行部署，这是通过在源阶段添加todobackend-aws存储库作为另一个源操作来实现的。**部署操作**还需要另一个输入工件，用于定义要部署的Docker镜像的标签，这是通过构建阶段中的CodeBuild构建操作的输出工件（称为`ApplicationVersion`）提供的。如果现在这些都不太明白，不要担心；我们将在本章中涵盖所有细节并设置这些流水线，但至少了解阶段、操作以及如何在它们之间传递工件以实现所需的结果是很重要的。
- en: 'Finally, CodePipeline can support deployments into multiple environments, and
    the final section of this chapter will extend our pipeline to perform a controlled
    release into a production environment, as illustrated in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CodePipeline可以支持部署到多个环境，本章的最后一部分将扩展我们的流水线，以便在生产环境中执行受控发布，如下图所示：
- en: '![](assets/d3186f6c-4547-4471-9e0e-a4d4fa6b7191.png)Continuous delivery pipeline'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d3186f6c-4547-4471-9e0e-a4d4fa6b7191.png)持续交付流水线'
- en: In the preceding diagram, a new stage (called **Production Stage**) is added
    to the pipeline, which can only be executed if your application has been successfully
    deployed in your dev environment. Unlike the continuous deployment approach of
    the dev stage, which immediately deploys into your dev environment, the production
    stage first creates a CloudFormation change set, which identifies all of the changes
    that will be made as part of the deployment, and then triggers a manual approval
    action that requires somebody to review the change set and approve or reject the
    changes. Assuming that the changes are approved, the production stage will then
    deploy the changes to the production environment, and these sets of actions will
    collectively combine to offer support for controlled releases into production
    (or other controlled) environments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，流水线添加了一个新阶段（称为**生产阶段**），只有在您的应用程序成功部署在开发环境中才能执行。与开发阶段的持续部署方法不同，后者立即部署到开发环境中，生产阶段首先创建一个CloudFormation变更集，该变更集标识了部署的所有更改，然后触发一个手动批准操作，需要某人审查变更集并批准或拒绝更改。假设更改得到批准，生产阶段将部署更改到生产环境中，这些操作集合将共同提供对生产（或其他受控）环境的受控发布的支持。
- en: Now that you have had a high-level overview of CodePipeline, let's get started
    by creating the continuous integration pipeline that we discussed in the very
    first diagram. Before, we can build this pipeline, we need to build a custom build
    container to meet the requirements of the Docker workflow defined in the todobackend
    repository, and we also need to add support for CodeBuild, after which we can
    create our pipeline in CodePipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对CodePipeline有了一个高层次的概述，让我们开始创建我们在第一个图表中讨论的持续集成流水线。在构建这个流水线之前，我们需要构建一个自定义的构建容器，以满足todobackend存储库中定义的Docker工作流的要求，并且我们还需要添加对CodeBuild的支持，之后我们可以在CodePipeline中创建我们的流水线。
- en: Creating a custom CodeBuild container
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义CodeBuild容器
- en: AWS CodeBuild provides a build service that uses a container build agent to
    execute your builds.  CodeBuild provides a number of AWS curated images that target
    specific application languages and/or platforms, such as [Python, Java, PHP and
    many more](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html).
    CodeBuild does provide an image that is designed for building Docker images; however,
    this image is somewhat limited, in that it does not include tools like the AWS
    CLI, GNU make, and Docker Compose, all of which we require for building the todobackend
    application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodeBuild提供了一个构建服务，使用容器构建代理来执行您的构建。CodeBuild提供了许多AWS策划的镜像，针对特定的应用程序语言和/或平台，比如[Python，Java，PHP等等](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html)。CodeBuild确实提供了一个专为构建Docker镜像而设计的镜像；然而，这个镜像有一定的限制，它不包括AWS
    CLI、GNU make和Docker Compose等工具，而我们构建todobackend应用程序需要这些工具。
- en: Although you can run pre-build steps that install additional tools in CodeBuild,
    this approach slows down your builds, as the installation of the additional tools
    will happen on each and every build. CodeBuild does support using your own custom
    images, which allows you to pre-package all of the tools required for your application
    builds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在CodeBuild中运行预构建步骤来安装额外的工具，但这种方法会减慢构建速度，因为安装额外工具将在每次构建时都会发生。CodeBuild确实支持使用自定义镜像，这允许您预打包所有应用程序构建所需的工具。
- en: 'For our use case, the CodeBuild build environment must include the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，CodeBuild构建环境必须包括以下内容：
- en: Access to a Docker daemon, given the build stands up a multi-container environment
    to run integration and acceptance tests
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Docker守护程序，鉴于构建建立了一个多容器环境来运行集成和验收测试
- en: Docker Compose
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: GNU Make
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make
- en: AWS CLI
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI
- en: You may be wondering how you can meet the first requirement, given that your
    CodeBuild runtime environment is located within an isolated container that has
    no direct access to the underlying infrastructure it is running on. Docker does
    support the concept of **Docker in Docker** (**DinD**), where the Docker daemon
    runs inside of your Docker container, allowing you to install a Docker client
    that can build Docker images and orchestrate multi-container environments, using
    tools like Docker Compose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何满足第一个要求，因为您的CodeBuild运行时环境位于一个隔离的容器中，无法直接访问其正在运行的基础架构。Docker确实支持**Docker中的Docker**（**DinD**）的概念，其中Docker守护程序在您的Docker容器内运行，允许您安装一个可以构建Docker镜像并使用工具如Docker
    Compose编排多容器环境的Docker客户端。
- en: The practice of Docker in Docker is [somewhat controversial](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/), and
    is an example of using Docker more like a virtual machine than a container. However,
    for the purposes of running a build, this approach is completely acceptable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的Docker实践有些有争议，并且是使用Docker更像虚拟机而不是容器的一个例子。然而，为了运行构建，这种方法是完全可以接受的。
- en: Defining a custom CodeBuild container
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义CodeBuild容器
- en: First, we need to build our custom CodeBuild image, which we will define in
    a Dockerfile called `Dockerfile.codebuild`, located within the todobackend-aws
    repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要构建我们的自定义CodeBuild镜像，我们将在名为`Dockerfile.codebuild`的Dockerfile中定义，该文件位于todobackend-aws存储库中。
- en: 'The following example shows the Dockerfile:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了Dockerfile：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because Docker publishes a Docker in Docker image, we can simply base our customization
    from this image; we have the Docker in Docker functionality for free. The DinD
    image is based on Alpine Linux, and already includes the required Docker daemon
    and Docker client. Next, we will add the specific tools that we require for our
    build. This includes the bash shell, GNU make, and a Python 3 runtime, which is
    required to install Docker Compose and the AWS CLI.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Docker发布了一个Docker中的Docker镜像，我们可以简单地基于这个镜像进行定制；我们免费获得了Docker中的Docker功能。DinD镜像基于Alpine
    Linux，并已经包含所需的Docker守护程序和Docker客户端。接下来，我们将添加我们构建所需的特定工具。这包括bash shell，GNU make和Python
    3运行时，这是安装Docker Compose和AWS CLI所需的。
- en: 'You can now build this image locally by using the `docker build` command, demonstrated
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用`docker build`命令在本地构建此镜像，如下所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command in the preceding example, creates the newly built Docker image with
    a name of `codebuild`. This is OK for now, but we will need to publish this CodeBuild
    to the **Elastic Container Registry** (**ECR**), so that it is available for CodeBuild.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，使用名称为`codebuild`创建新构建的Docker镜像。现在这样做是可以的，但是我们需要将此CodeBuild发布到**弹性容器注册表**（**ECR**），以便CodeBuild可以使用。
- en: Creating a repository for the custom CodeBuild container
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义CodeBuild容器创建存储库
- en: Now, that you have built a custom CodeBuild image, you need to publish the image
    to a location that CodeBuild can pull the image from. If you are using the ECR,
    you will typically publish this image to a repository within ECR, and that is
    the approach we will take.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经构建了一个自定义的CodeBuild图像，您需要将图像发布到CodeBuild可以从中拉取图像的位置。如果您使用ECR，通常会将此图像发布到ECR中的存储库，这就是我们将采取的方法。
- en: 'First, you need to add a new repository to the `ecr.yml` file, in the root
    of the `todobackend-aws` folder, which you created earlier in the chapter::'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在`todobackend-aws`文件夹的根目录中的`ecr.yml`文件中添加一个新的存储库，该文件夹是您在本章中创建的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, you create a new repository with the name `docker-in-aws/codebuild`,
    which will result in a fully qualified repository by the name of `<account-id>.dkr.ecr.<region>.amazonaws.com/docker-in-aws/codebuild` (for
    example, `385605022855.dkr.ecr.us-east-1.amazonaws.com/docker-in-aws/codebuild`).
    Note that you must grant pull access to the CodeBuild service, as CodeBuild needs
    to pull the image to run as its build container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您创建了一个名为`docker-in-aws/codebuild`的新存储库，这将导致一个名为`<account-id>.dkr.ecr.<region>.amazonaws.com/docker-in-aws/codebuild`的完全限定存储库（例如`385605022855.dkr.ecr.us-east-1.amazonaws.com/docker-in-aws/codebuild`）。请注意，您必须授予CodeBuild服务拉取访问权限，因为CodeBuild需要拉取图像以运行作为其构建容器。
- en: 'You can now deploy the changes to the ECR stack by using the `aws cloudformation
    deploy` command, which you may recall from the chapter, Publishing Docker Images
    Using ECR is deployed to a stack called ecr-repositories:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用`aws cloudformation deploy`命令将更改部署到ECR堆栈，您可能还记得来自章节《使用ECR发布Docker镜像》的命令，部署到名为ecr-repositories的堆栈：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the deployment is complete, you need to retag the image that you created
    earlier, with the fully qualified name of your new ECR repository, after which
    you can log in to ECR and publish the image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，您需要使用您之前创建的图像的完全限定名称重新标记图像，然后您可以登录到ECR并发布图像：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding CodeBuild support to your application repository
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的应用程序存储库添加CodeBuild支持
- en: Whenever you create a CodeBuild project, you must define how CodeBuild should
    test and build your application source code, and then publish application artifacts
    and/or Docker images. CodeBuild defines these tasks within a build specification,
    which provides the build instructions the CodeBuild agent should execute when
    running a build.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您创建CodeBuild项目时，必须定义CodeBuild应如何测试和构建应用程序源代码，然后发布应用程序工件和/或Docker镜像。 CodeBuild在构建规范中定义这些任务，构建规范提供了CodeBuild代理在运行构建时应执行的构建说明。
- en: 'CodeBuild allows you to provide a build specification in several ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CodeBuild允许您以多种方式提供构建规范：
- en: '**Self-defined**: CodeBuild looks for a file that is defined within the source
    repository of the project.  By default, this is a file called `buildspec.yml`;
    however, you can also configure a custom file where your build specification is
    located.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：CodeBuild查找项目的源存储库中定义的文件。默认情况下，这是一个名为`buildspec.yml`的文件；但是，您还可以配置一个自定义文件，其中包含您的构建规范。'
- en: '**Preconfigured**: When you create a CodeBuild project, you can define a build
    specification as part of your project setup.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预配置**：当您创建CodeBuild项目时，可以在项目设置的一部分中定义构建规范。'
- en: '**On demand**: If you initiate a CodeBuild build job using the AWS CLI or SDK,
    you can override the preconfigured or self-defined build specification'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需：如果您使用AWS CLI或SDK启动CodeBuild构建作业，您可以覆盖预配置或自定义的构建规范
- en: In general, I recommend using the self-defined method, as it allows the repository
    owner (typically, your developers) to configure and maintain the specification
    independently of CodeBuild; this is the approach we will take.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我建议使用自定义方法，因为它允许存储库所有者（通常是您的开发人员）独立配置和维护规范；这是我们将采取的方法。
- en: 'The following example demonstrates adding a build specification to the todobackend
    repository, in a file called `buildspec.yml`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在名为`buildspec.yml`的文件中向todobackend存储库添加构建规范：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The build specification starts by specifying a version that must be included
    in every build specification, the most current version being `0.2`, as of the
    writing of this book. Next, you define the phases sequence, which is required,
    defining the commands that CodeBuild will run during the various phases of the
    build.  In the previous example, you define three phases:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建规范首先指定了必须包含在每个构建规范中的版本，本书编写时最新版本为`0.2`。接下来，您定义了阶段序列，这是必需的，定义了CodeBuild将在构建的各个阶段运行的命令。在前面的示例中，您定义了三个阶段：
- en: '`pre_build`: Commands that CodeBuild will run before the build. Here, you can
    run commands such as logging into ECR, or any other commands that are required
    for your build to run successfully.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre_build`：CodeBuild在构建之前运行的命令。在这里，您可以运行诸如登录到ECR或构建成功运行所需的任何其他命令。'
- en: '`build`: These commands run your build steps.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：这些命令运行您的构建步骤。'
- en: '`post_build`: Commands that CodeBuild will run after your build. These typically
    involve clean up tasks, such as logging out of ECR and removing temporary files.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_build`：CodeBuild在构建后运行的命令。这些通常涉及清理任务，例如退出ECR并删除临时文件。'
- en: You can find more information about the CodeBuild build specifications at [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html)找到有关CodeBuild构建规范的更多信息。
- en: 'During the `pre_build` stage, you perform the following actions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pre_build`阶段，您执行以下操作：
- en: The first two commands are used to start the Docker daemon in your custom CodeBuild
    image; the `nohup` command starts the Docker daemon as a background task, while
    the `timeout` command is used to ensure the Docker daemon has started successfully,
    before attempting to continue.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个命令用于在自定义CodeBuild镜像中启动Docker守护程序；`nohup`命令将Docker守护程序作为后台任务启动，而`timeout`命令用于确保Docker守护程序已成功启动，然后再继续尝试。
- en: 'Export a `BUILD_ID` environment variable, which is used to add build information
    to the application version that will be generated for your build. This `BUILD_ID`
    value will be added to the application version tag that is attached to the Docker
    image that is built during the build phase, and therefore, it can only include
    characters that are compatible with Docker''s tag format. The CodeBuild job ID
    is exposed to your build agent via the `CODEBUILD_BUILD_ID` environment variable,
    and has the format `<project-name>:<job-id>`, where `<job-id>` is a UUID value.
    The colon in the CodeBuild job ID is not supported in Docker tags; hence, you
    strip the `<project-name>`: portion of the job ID using a `sed` expression, leaving
    just the job ID value that will be included in the Docker tag.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出一个`BUILD_ID`环境变量，用于将构建信息添加到将为您的构建生成的应用程序版本中。此`BUILD_ID`值将被添加到构建阶段期间构建的Docker镜像附加的应用程序版本标记中，因此，它只能包含与Docker标记格式兼容的字符。CodeBuild作业ID通过`CODEBUILD_BUILD_ID`环境变量暴露给您的构建代理，并且格式为`<project-name>:<job-id>`，其中`<job-id>`是UUID值。CodeBuild作业ID中的冒号在Docker标记中不受支持；因此，您可以使用`sed`表达式剥离作业ID的`<project-name>`部分，只留下将包含在Docker标记中的作业ID值。
- en: Export the `APP_VERSION` environment variable, which is used in the Makefile
    to define the application version that is tagged on the built Docker image. When
    you use CodeBuild with CodePipeline, it is important to understand that the source
    artifact presented to CodeBuild is actually a zipped version located in an S3
    bucket that CodePipeline creates after cloning the source code from your source
    repository. CodePipeline does not include any Git metadata; therefore, the `APP_VERSION`
    directive in the todobackend Makefile - `export APP_VERSION ?= $(shell git rev-parse
    --short HEAD` -  will fail, as the Git client will not have any Git metadata available.
    Luckily, the `?=` syntax in GNU Make means to use the value of the aforementioned
    environment variable, if it is already defined in the environment. So, we can
    export `APP_VERSION` in the CodeBuild environment, and Make will just use the
    configured value, rather than run the Git commands. In the previous example, you
    construct the `APP_VERSION` from a variable called `CODEBUILD_RESOLVED_SOURCE_VERSION`,
    which is the full commit hash of the source repository, and is set by CodePipeline.
    You also append the `BUILD_ID` variable calculated in the previous command, which
    allows you to trace a specific Docker image build to a CodeBuild build job.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出`APP_VERSION`环境变量，在Makefile中用于定义构建的Docker镜像上标记的应用程序版本。当您在CodeBuild与CodePipeline一起使用时，重要的是要了解，呈现给CodeBuild的源构件实际上是位于S3存储桶中的一个压缩版本，CodePipeline在从源代码库克隆源代码后创建。CodePipeline不包括任何Git元数据；因此，在todobackend
    Makefile中的`APP_VERSION`指令 - `export APP_VERSION ?= $(shell git rev-parse --short
    HEAD` - 将失败，因为Git客户端将没有任何可用的Git元数据。幸运的是，在GNU Make中的`?=`语法意味着如果环境中已经定义了前述环境变量的值，那么就使用该值。因此，我们可以在CodeBuild环境中导出`APP_VERSION`，并且Make将只使用配置的值，而不是运行Git命令。在前面的示例中，您从一个名为`CODEBUILD_RESOLVED_SOURCE_VERSION`的变量构造了`APP_VERSION`，它是源代码库的完整提交哈希，并由CodePipeline设置。您还附加了在前一个命令中计算的`BUILD_ID`变量，这允许您将特定的Docker镜像构建跟踪到一个CodeBuild构建作业。
- en: Log in to ECR using the `make login` command included in the source repository.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用源代码库中包含的`make login`命令登录到ECR。
- en: Once the `pre_build` stage has completed, the build stage is straightforward,
    and simply executes the various build steps that we have executed manually so
    far in this book. The final `post_build` stage runs the `make clean` task to tear
    down the Docker Compose environment, and then removes any local ECR credentials
    by running the `make logout` command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`pre_build`阶段完成，构建阶段就很简单了，只需执行我们在本书中迄今为止手动执行的各种构建步骤。最终的`post_build`阶段运行`make
    clean`任务来拆除Docker Compose环境，然后通过运行`make logout`命令删除任何本地ECR凭据。
- en: One important point to note is that the `post_build` stage always runs, even
    if the build stage fails. This means you should only reserve `post_build` tasks
    for actions that you would run regardless of whether the build passes or fails.
    For example, you might be tempted to run the `make publish` task as a `post_build`
    step; however, if you do this, and the previous build stage fails, CodeBuild will
    still attempt to run the make publish task, given that it is defined as a `post_build`
    step. Placing the make publish task as the final action in the build stage ensures
    that if make test or make release fails, the build stage will immediately exit
    with an error, bypassing the make publish action and  proceeding to execute the
    cleanup tasks in the `post_build` step.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是`post_build`阶段始终运行，即使构建阶段失败也是如此。这意味着您应该仅将`post_build`任务保留为无论构建是否通过都会运行的操作。例如，您可能会尝试将`make
    publish`任务作为`post_build`步骤运行；但是，如果您这样做，且前一个构建阶段失败，CodeBuild仍将尝试运行make publish任务，因为它被定义为`post_build`步骤。将make
    publish任务放置在构建阶段的最后一个操作确保如果make test或make release失败，构建阶段将立即以错误退出，绕过make publish操作并继续执行`post_build`步骤中的清理任务。
- en: You can find out more about all of the CodeBuild phases, and whether they execute
    on success/failure, at [https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases](https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases](https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases)找到有关所有CodeBuild阶段以及它们在成功/失败时是否执行的更多信息。
- en: 'The final step that you need to perform is to commit and push your changes
    to your Git repository, so that the newly created `buildspec.yml` file will be
    available when you configure CodePipeline and CodeBuild:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行的最后一步是将更改提交并推送到您的Git存储库，以便在配置CodePipeline和CodeBuild时新创建的`buildspec.yml`文件可用：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating a continuous integration pipeline using CodePipeline
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建持续集成管道
- en: Now that you have established the prerequisites for supporting CodeBuild, you
    can create a continuous integration CodePipeline pipeline that will use CodeBuild
    to test, build, and publish your Docker image. Continuous integration focuses
    on continuously merging application source code changes into your master branch
    and validating the changes by creating a build and running automated tests against
    it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经建立了支持CodeBuild的先决条件，您可以创建一个持续集成的CodePipeline管道，该管道将使用CodeBuild来测试、构建和发布您的Docker镜像。持续集成侧重于不断将应用程序源代码更改合并到主分支，并通过创建构建并针对其运行自动化测试来验证更改。
- en: 'As per the first diagram in this chapter, this generally involves two stages
    when you configure a CodePipeline pipeline for continuous integration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章第一个图表，当您为持续集成配置CodePipeline管道时，通常涉及两个阶段：
- en: '**Source Stage**: Downloads the source application repository and makes it
    available for subsequent stages. For our use case, you will connect CodePipeline
    to the master branch of your GitHub repository, and subsequent commits to this
    repository will automatically trigger a new pipeline execution.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源阶段**：下载源应用程序存储库，并使其可用于后续阶段。对于我们的用例，您将把CodePipeline连接到GitHub存储库的主分支，对该存储库的后续提交将自动触发新的管道执行。'
- en: '**Build Stage**: Runs the build, test, and publish workflow defined in the
    source application repository. For our use case, we will use CodeBuild to run
    this stage, which will execute the build tasks defined in the source repository
    `buildspec.yml` file that you created earlier in this chapter.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建阶段**：运行在源应用程序存储库中定义的构建、测试和发布工作流程。对于我们的用例，我们将使用CodeBuild来运行此阶段，它将执行源存储库中定义的构建任务`buildspec.yml`文件，这是在本章前面创建的。'
- en: Creating a CodePipeline pipeline using the AWS console
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建CodePipeline管道
- en: To get started, first, select **Services** from the AWS console and choose **CodePipeline**.
    If this is the first time that you have used CodePipeline, you will be presented
    with an introduction page, and you can click the Get started button to start the
    CodePipeline wizard.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请首先从AWS控制台中选择**服务**，然后选择**CodePipeline**。如果这是您第一次使用CodePipeline，您将看到一个介绍页面，您可以单击“开始”按钮开始CodePipeline向导。
- en: 'You are first asked to enter a name for your pipeline, and after clicking Next
    step, you are prompted to set up a source provider, which defines the provider
    of the source repository or files that will be used in your pipeline:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要求您为管道输入名称，然后单击“下一步”，您将被提示设置源提供程序，该提供程序定义将在您的管道中使用的源存储库或文件的提供程序：
- en: '![](assets/db98d662-8e5f-410b-8afe-1492bf859b6d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db98d662-8e5f-410b-8afe-1492bf859b6d.png)'
- en: 'After selecting GitHub from the drop-down menu, click on the Connect to GitHub button,
    which will redirect you to GitHub, where you will be prompted to log in and grant
    CodePipeline access to your GitHub account:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在从下拉菜单中选择GitHub后，单击“连接到GitHub”按钮，这将重定向您到GitHub，在那里您将被提示登录并授予CodePipeline对您的GitHub帐户的访问权限：
- en: '![](assets/9b6c00bb-874c-48ea-9185-b8f5d82bc591.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9b6c00bb-874c-48ea-9185-b8f5d82bc591.png)'
- en: 'After clicking on the Authorize aws-codesuite button, you will be redirected
    back to the CodePipeline wizard, and you can select the todobackend repository
    and master branch:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 点击授权aws-codesuite按钮后，您将被重定向回CodePipeline向导，您可以选择todobackend存储库和主分支：
- en: '![](assets/44a9298c-0671-4f61-b714-fae334ce3b7c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44a9298c-0671-4f61-b714-fae334ce3b7c.png)'
- en: 'If you click on Next step, you will be asked to select a build provider, which
    defines the provider of the build service that will perform build actions on your
    source repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单击“下一步”，您将被要求选择构建提供程序，该提供程序定义将在您的管道中执行构建操作的构建服务的提供程序：
- en: '![](assets/4ebf9916-9332-4ea5-b7c5-89c361a8123c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ebf9916-9332-4ea5-b7c5-89c361a8123c.png)'
- en: 'After selecting AWS CodeBuild and choosing the Create a new build project option,
    you need to configure the build project, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择AWS CodeBuild并选择“创建新的构建项目”选项后，您需要配置构建项目，如下所示：
- en: 'Environment image: For Environment image, select the Specify a Docker image
    option, and then set the Environment type to Linux, Custom image type to Amazon
    ECR; then, choose the `docker-in-aws/codebuild repository/latest` image you published
    earlier in this chapter.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境镜像：对于环境镜像，请选择“指定Docker镜像”选项，然后将环境类型设置为Linux，自定义镜像类型设置为Amazon ECR；然后选择您在本章前面发布的`docker-in-aws/codebuild
    repository/latest`镜像。
- en: 'Advanced: Ensure that the Privileged flag is set, as shown in the following
    screenshot. This is required whenever you run Docker in Docker images:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级：确保设置特权标志，如下面的屏幕截图所示。每当您在Docker中运行Docker镜像时，这是必需的：
- en: '![](assets/132bf4f5-0a72-458b-ab05-419745b1bae5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/132bf4f5-0a72-458b-ab05-419745b1bae5.png)'
- en: After completing the build project configuration, ensure that you click on Save
    build project before clicking Next step to continue.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成构建项目配置后，请确保在单击“下一步”继续之前，单击“保存构建项目”。
- en: 'In the next stage, you will be asked to define a Deploy stage. At this point,
    we only want to perform the continuous integration tasks of testing, building,
    and publishing our Docker application, so select the No Deployment option and
    click Next step to continue:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一阶段，您将被要求定义一个部署阶段。在这一点上，我们只想执行测试、构建和发布我们的Docker应用程序的持续集成任务，因此选择“无部署”选项，然后单击“下一步”继续：
- en: '![](assets/c5d4b3fa-d8ea-4c84-968d-565b491923cf.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c5d4b3fa-d8ea-4c84-968d-565b491923cf.png)'
- en: 'The final step is to configure an IAM role that CodePipeline can assume to
    perform the various build and deployment tasks in your pipeline. Click on the
    Create role button, which will open a new window that asks you to create a new
    IAM role, with the appropriate permissions, for CodePipeline:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是配置CodePipeline可以假定的IAM角色，以执行管道中的各种构建和部署任务。单击“创建角色”按钮，这将打开一个新窗口，要求您创建一个新的IAM角色，具有适当的权限，供CodePipeline使用：
- en: '![](assets/d924fc71-95b4-41d3-a6e8-29ad258664cf.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d924fc71-95b4-41d3-a6e8-29ad258664cf.png)'
- en: After reviewing the Policy Document, click on Allow, which will select the new
    role in the CodePipeline wizard. Finally, click on Next step, review the pipeline
    configuration, and then click Create pipeline to create your new pipeline.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在审阅政策文件后，单击“允许”，这将在CodePipeline向导中选择新角色。最后，单击“下一步”，审查管道配置，然后单击“创建管道”以创建新管道。
- en: 'At this point, your pipeline will be created, and you will be taken to the
    pipeline configuration view for your pipeline. Whenever you create a pipeline
    for the first time, CodePipeline will automatically trigger the first execution
    of your pipeline, and after a few minutes, you should notice that the build stage
    for your pipeline has failed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您的管道将被创建，并且您将被带到您的管道的管道配置视图。每当您第一次为管道创建管道时，CodePipeline将自动触发管道的第一次执行，几分钟后，您应该注意到管道的构建阶段失败了：
- en: '![](assets/a014138c-d861-4c94-9165-871b35dc3908.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a014138c-d861-4c94-9165-871b35dc3908.png)'
- en: 'To find out more information about why the build failed, click on the Details
    link, which will pop up more details about the failure, and will also include
    a link to the CodeBuild job where the failure occurred. If you click on this link
    and scroll down, you can see that the failure occurred in the `pre_build` stage,
    and in the build logs that the issue is related to an IAM permission issue:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关构建失败的更多信息，请单击“详细信息”链接，这将弹出有关失败的更多详细信息，并且还将包括到构建失败的CodeBuild作业的链接。如果单击此链接并向下滚动，您会看到失败发生在“pre_build”阶段，并且在构建日志中，问题与IAM权限问题有关：
- en: '![](assets/4640dbba-7a70-49ac-8992-d1d43e7b3d1c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4640dbba-7a70-49ac-8992-d1d43e7b3d1c.png)'
- en: The problem is that the IAM role that was automatically created during the CodePipeline
    wizard does not include permissions to log in to ECR.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于CodePipeline向导期间自动创建的IAM角色不包括登录到ECR的权限。
- en: 'To resolve this, open the IAM console, select Roles from the left-hand menu,
    and locate the `code-build-todobackend-service-role` that was created by the wizard.
    In the Permissions tab, click on Attach Policy, locate the `AmazonEC2ContainerRegistryPowerUser` managed
    policy, and click on the Attach Policy button.  The power user role grants login,
    pull, and push permissions, and because we will be publishing to ECR as a part
    of the build workflow, this level of access is required. Once you have completed
    the configuration, the Permissions tab for the role should look the same as what''s
    shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，打开IAM控制台，从左侧菜单中选择角色，找到由向导创建的`code-build-todobackend-service-role`。在权限选项卡中，点击附加策略，找到`AmazonEC2ContainerRegistryPowerUser`托管策略，并点击附加策略按钮。power
    user角色授予登录、拉取和推送权限，因为我们将作为构建工作流的一部分发布到ECR，所以需要这个级别的访问权限。完成配置后，角色的权限选项卡应该与下面的截图一样：
- en: '![](assets/6e394fa4-1f87-4edd-9edd-6b53978de78a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e394fa4-1f87-4edd-9edd-6b53978de78a.png)'
- en: 'Now that you have resolved the permissions issue, navigate back to the CodePipeline
    details view for your pipeline, click on the Retry button in the build stage,
    and confirm retrying the failed build. This time, after a few minutes, the build
    should complete successfully, and you can use the `aws ecr list-images` command
    to verify that a new image has been published to ECR:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经解决了权限问题，请导航回到您的流水线的CodePipeline详细信息视图，点击构建阶段的重试按钮，并确认重试失败的构建。这一次，几分钟后，构建应该成功完成，您可以使用`aws
    ecr list-images`命令来验证已经发布了新的镜像到ECR：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the last image published is in the format `<long commit hash>`.`<uuid>`,
    where `<uuid>` is the CodeBuild job ID, confirming that CodeBuild has successfully
    published a new image to ECR.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后发布的镜像的格式为`<long commit hash>`.`<uuid>`，其中`<uuid>`是CodeBuild作业ID，证实CodeBuild已成功将新镜像发布到ECR。
- en: Creating a continuous delivery pipeline using CodePipeline
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CodePipeline创建持续交付流水线
- en: At this point, you have a continuous integration pipeline that will automatically publish
    new Docker images for your application whenever a commit is pushed on the master
    branch to your source repository. At some point, you will want to deploy your
    Docker images to an environment (perhaps a staging environment, where you may
    run some end-to-end tests to verify that your application works as expected),
    and then to a production environment that services your end users. Although you
    could deploy these changes manually by updating the `ApplicationImageTag` input
    to the todobackend stack, ideally, you want to be able to continuously deploy
    these changes automatically into at least one environment, which provides immediate
    access to developers, testers, and product managers, allowing for fast feedback
    from the key stakeholders involved in the development of your applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经拥有了一个持续集成流水线，每当在主分支上推送提交到您的源代码库时，它将自动发布新的Docker镜像。在某个时候，您将希望将Docker镜像部署到一个环境（也许是一个分段环境，在那里您可以运行一些端到端测试来验证您的应用程序是否按预期工作），然后再部署到为最终用户提供服务的生产环境。虽然您可以通过手动更新`ApplicationImageTag`输入来手动部署这些更改到todobackend堆栈，但理想情况下，您希望能够自动将这些更改持续部署到至少一个环境中，这样可以立即让开发人员、测试人员和产品经理访问，并允许从参与应用程序开发的关键利益相关者那里获得快速反馈。
- en: This concept is referred to as continuous deployment. In other words, whenever
    you are continuously integrating and building tested software artifacts, you then
    continuously deploy those artifacts.  Continuous deployment is very common these
    days, especially if you are deploying into a non-production environment. What
    is far less common is continuous deployment all the way to production. To achieve
    this, you must have a high degree of automated post-deployment testing available,
    and, at least in my experience, this is something that is still difficult to achieve
    for most organizations. A far more common approach is what is referred to as continuous
    delivery, which you can think of as the ability to automatically deploy all the
    way to production once you are sure your release is ready for production.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念被称为持续部署。换句话说，每当您持续集成和构建经过测试的软件构件时，您就会持续部署这些构件。持续部署在当今非常普遍，特别是如果您部署到非生产环境。远不那么普遍的是一直持续部署到生产环境。要实现这一点，您必须具有高度自动化的部署后测试，并且至少根据我的经验，这对大多数组织来说仍然很难实现。更常见的方法是持续交付，您可以将其视为一旦确定您的发布准备好投入生产，就能自动部署到生产的能力。
- en: Continuous delivery allows for the common scenario where you have a requirement
    to perform controlled releases into production,  rather than continuously deploying
    into production as soon as a release is available. This is somewhat more achievable
    than continuous deployment all the way to production, as it allows for the manual
    testing of your non-production environments before you choose to deploy to production.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付允许常见的情况，即您需要对生产环境进行受控发布，而不是一旦发布可用就持续部署到生产环境。这比一直持续部署到生产环境更可行，因为它允许在选择部署到生产环境之前对非生产环境进行手动测试。
- en: Now that you have some context around what continuous delivery is, let's extend
    our pipeline to support continuous delivery.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了持续交付的背景，让我们扩展我们的管道以支持持续交付。
- en: CodePipeline includes support for ECS as a deployment target, where you can
    deploy new images published by your continuous integration pipeline to a target
    ECS cluster and ECS service. In this chapter, I will be using CloudFormation to
    deploy application changes; however, you can read more about the ECS deployment
    mechanism at [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline包括对ECS作为部署目标的支持，您可以将持续集成管道发布的新镜像部署到目标ECS集群和ECS服务。在本章中，我将使用CloudFormation来部署应用程序更改；但是，您可以在[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html)了解更多关于ECS部署机制的信息。
- en: 'The first stage of this is to configure the continuous deployment of your code
    changes into a non-production environment, requiring you to perform the following
    configuration actions, which will be discussed in further detail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一阶段的第一步是配置您的代码更改的持续部署到非生产环境，这需要您执行以下配置操作，这些操作将在后续详细讨论：
- en: Publish version information in your source repository
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的源代码存储库中发布版本信息
- en: Add CodePipeline support to your deployment repository
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的部署存储库添加CodePipeline支持
- en: Add your deployment repository to CodePipeline
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的部署存储库添加到CodePipeline
- en: Add an output artifact for your build actions
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的构建操作添加一个输出构件
- en: Create an IAM role for CloudFormation deployments
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为CloudFormation部署创建一个IAM角色
- en: Add a deployment stage to the pipeline
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道中添加一个部署阶段
- en: Publishing version information in your source repository
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的源代码存储库中发布版本信息
- en: A key requirement of our pipeline is the ability to deploy a newly built Docker
    image into our AWS environments. At the moment, CodePipeline has no real awareness
    of the Docker image tag that is published. We know that the tag is configured
    within the CodeBuild environment, but CodePipeline has no understanding of this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流水线的一个关键要求是能够将新构建的Docker镜像部署到我们的AWS环境中。目前，CodePipeline并不真正了解发布的Docker镜像标记。我们知道该标记在CodeBuild环境中配置，但CodePipeline并不了解这一点。
- en: In order to use the Docker image tag that is generated in the CodeBuild build
    stage, you need to produce an output artifact that is first collected by CodeBuild,
    and then made available to future deployment stages in CodePipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用在CodeBuild构建阶段生成的Docker镜像标记，您需要生成一个输出构件，首先由CodeBuild收集，然后在CodePipeline中的未来部署阶段中提供。
- en: 'To do this, you must first define the artifact(s) that CodeBuild should collect,
    which you can do by adding an `artifacts` parameter to the `buildspec.yml` build
    specification in the todobackend repository:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您必须首先定义CodeBuild应该收集的构件，您可以通过在todobackend存储库中的`buildspec.yml`构建规范中添加`artifacts`参数来实现这一点：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, the `artifacts` parameter configures CodeBuild to
    look for an artifact at the location `version.json`. Notice that you also add
    an additional command to the build phase, which writes the output of the `make
    version` command to the `version.json` file where CodeBuild expects to find an
    artifact.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`artifacts`参数配置CodeBuild在位置`version.json`查找构件。请注意，您还需要向构建阶段添加一个额外的命令，该命令将`make
    version`命令的输出写入`version.json`文件，CodeBuild期望在那里找到构件。
- en: At this point, ensure that you commit and push your changes to the todobackend
    repository , so that the changes will be available for future builds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，请确保您提交并推送更改到todobackend存储库，以便将来的构建可以使用这些更改。
- en: Adding CodePipeline support to the deployment repository
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向部署存储库添加CodePipeline支持
- en: 'When you use CodePipeline to deploy your environments using CloudFormation,
    you need to ensure that you can supply a configuration file that includes input
    stack parameters, stack tags, and stack policy configuration. This file must be
    implemented in a JSON format, as defined at [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15),
    so we need to modify the format of the input parameters file in the `todobackend-aws`
    repository, which is currently in a `<parameter>=<value>` format, located in a
    file called `dev.cfg`. As per the referenced document, all of your input parameters
    need to reside in a JSON file under a key called `Parameters`, which you can define
    in a new file called `dev.json`, located at the root of the `todobackend-aws`
    repository:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用CodePipeline使用CloudFormation部署您的环境时，您需要确保您可以提供一个包含输入堆栈参数、堆栈标记和堆栈策略配置的配置文件。该文件必须以JSON格式实现，如[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15)中定义的那样，因此我们需要修改`todobackend-aws`存储库中输入参数文件的格式，该文件目前以`<parameter>=<value>`格式位于名为`dev.cfg`的文件中。根据所引用的文档，您所有的输入参数都需要位于一个名为`Parameters`的键下的JSON文件中，您可以在`todobackend-aws`存储库的根目录下定义一个名为`dev.json`的新文件。
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, notice that I have updated the `ApplicationImageTag`
    value to `latest`. This is because our pipeline will actually obtain the value
    for the `ApplicationImageTag` input dynamically, from the build stage of our pipeline,
    and the `latest` value is a safer default value, in the event that you want to
    deploy your stack manually, from the command line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，请注意我已将`ApplicationImageTag`的值更新为`latest`。这是因为我们的流水线实际上会动态地从流水线的构建阶段获取`ApplicationImageTag`输入的值，而`latest`值是一个更安全的默认值，以防您希望从命令行手动部署堆栈。
- en: At this point, the `dev.cfg` file is redundant, and can be deleted from your
    repository; however, note that you will need to modify the way you run deployments
    manually, from the command line, given that the `aws cloudformation deploy` command
    expects input parameters to be provided in a `<parameter>=<value>` format.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`dev.cfg`文件是多余的，可以从您的存储库中删除；但是，请注意，鉴于`aws cloudformation deploy`命令期望以`<parameter>=<value>`格式提供输入参数，您需要修改手动从命令行运行部署的方式。
- en: 'One way that you can solve this is to use the `jq` utility to transform your
    new `dev.json` configuration file into the required `<parameter>=<value>` format:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以解决这个问题的一种方法是使用`jq`实用程序将新的`dev.json`配置文件转换为所需的`<parameter>=<value>`格式：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command is now quite a mouthful, so, in order to simplify running this
    command, you could add a simple Makefile to the `todobackend-aws` repository:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令现在相当冗长，为了简化运行这个命令，您可以向`todobackend-aws`存储库添加一个简单的Makefile：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the `%` character in the task name captures a wildcard
    text value whenever you execute the `make deploy` command. For example, if you
    run make `deploy`/`dev`, then the `%` character would capture `dev`, and if you
    run make `deploy`/`prod`, then the captured value would be `prod`. You can then
    refer to the captured value by using the `$*` variable, which you can see that
    we have substituted in the stack name (`todobackend-$*`, which would expand to
    `todobackend-dev` and `todobackend-prod`, using the previous examples), and in
    the command to cat the `dev.json` or `prod.json` file. Note that because we have
    named our stack `todobackend` throughout this book, this command won't quite work
    for us, but if you rename your stack to `todobackend-dev`, this command will make
    it much easier to deploy to a given environment manually.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，任务名称中的`%`字符捕获了一个通配文本值，无论何时执行`make deploy`命令。例如，如果您运行`make deploy`/`dev`，那么`%`字符将捕获`dev`，如果您运行`make
    deploy`/`prod`，那么捕获的值将是`prod`。然后，您可以使用`$*`变量引用捕获的值，您可以看到我们已经在堆栈名称（`todobackend-$*`，在前面的例子中会扩展为`todobackend-dev`和`todobackend-prod`）和用于cat`dev.json`或`prod.json`文件的命令中替换了这个变量。请注意，因为在本书中我们一直将堆栈命名为`todobackend`，所以这个命令对我们来说不太适用，但是如果您将堆栈重命名为`todobackend-dev`，这个命令将使手动部署到特定环境变得更加容易。
- en: Before you continue, you need to add the new `dev.json` file, commit, and push
    your changes to the source Git repository, as we will soon add the `todobackend-aws`
    repository as another source in your CodePipeline pipeline.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要添加新的`dev.json`文件，提交并推送更改到源Git存储库，因为我们将很快将`todobackend-aws`存储库添加为CodePipeline流水线中的另一个源。
- en: Creating an IAM role for CloudFormation deployments
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CloudFormation部署创建IAM角色
- en: When you use CodePipeline to deploy your CloudFormation stacks, CodePipeline
    requires you to specify an IAM role that will be assumed by the CloudFormation
    service to deploy your stack. CloudFormation supports the ability to specify an
    IAM role that the CloudFormation service will assume, which is a powerful capability
    that allows for more advanced configuration scenarios, such as cross-account deployments
    from a central build account. This role must specify the CloudFormation service
    as a trusted entity that can assume the role; hence, you typically can't use administrative
    roles created for human access, such as the admin role that you have been using
    throughout this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用CodePipeline部署CloudFormation堆栈时，CodePipeline要求您指定一个IAM角色，该角色将由CloudFormation服务来部署您的堆栈。CloudFormation支持指定CloudFormation服务将承担的IAM角色，这是一个强大的功能，允许更高级的配置场景，例如从中央构建账户进行跨账户部署。此角色必须指定CloudFormation服务作为可信实体，可以承担该角色；因此，通常不能使用为人员访问创建的管理角色，例如您在本书中一直在使用的管理员角色。
- en: 'To create the required role, navigate to the IAM console, select Roles from
    the left-hand menu, and click on the Create role button. In the Choose the service section,
    select CloudFormation, and then click Next: Permissions to continue. On the Attach
    permissions policies screen, you can create or select an appropriate policy with
    the various permissions required to create the resources in your stack. To keep
    things simple, I will just select the AdministratorAccess policy. However, in
    a real-world scenario, you should create or choose a policy that only grants the
    specific permissions required to create your CloudFormation stacks. After clicking
    the Next: Review button, specify the role name of `cloudformation-deploy`, and
    click on the Create role button to create the new role:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建所需的角色，请转到IAM控制台，从左侧菜单中选择“角色”，然后点击“创建角色”按钮。在“选择服务”部分，选择“CloudFormation”，然后点击“下一步：权限”继续。在“附加权限策略”屏幕上，您可以创建或选择一个适当的策略，其中包含创建堆栈所需的各种权限。为了保持简单，我将只选择“AdministratorAccess”策略。但是，在实际情况下，您应该创建或选择一个仅授予创建CloudFormation堆栈所需的特定权限的策略。点击“下一步：审阅”按钮后，指定角色名称为`cloudformation-deploy`，然后点击“创建角色”按钮创建新角色：
- en: '![](assets/2e5c6f9d-08b7-4abf-9aa4-8ae01e773f32.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2e5c6f9d-08b7-4abf-9aa4-8ae01e773f32.png)'
- en: Adding a deployment repository to CodePipeline
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向CodePipeline添加部署存储库
- en: Now that you have the appropriate stack configuration file and an IAM deployment
    role in place for CodePipeline, you can get started in modifying your pipeline
    to support the continuous delivery of application changes to your target AWS environments.
    The first modification that you need to perform is to add the todobackend-aws
    repository as another source action to the source stage of your pipeline. To do
    this, navigate to the details view for your pipeline, and click on the Edit button.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好了适当的堆栈配置文件和IAM部署角色，可以开始修改管道，以支持将应用程序更改持续交付到目标AWS环境。您需要执行的第一个修改是将todobackend-aws存储库作为另一个源操作添加到管道的源阶段。要执行此操作，请转到管道的详细信息视图，并点击“编辑”按钮。
- en: 'In the Edit screen, you can click on the pencil icon at the top right-hand
    corner of the source stage, which will change the view and allow you to add a
    new source action, either before, after, or at the same level as the current action
    for the todobackend repository:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑屏幕中，您可以点击源阶段右上角的铅笔图标，这将改变视图并允许您添加一个新的源操作，可以在当前操作之前、之后或与当前操作在同一级别：
- en: '![](assets/99536673-029a-4c09-b052-0f5e5314af0f.png)Editing a pipeline'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/99536673-029a-4c09-b052-0f5e5314af0f.png)编辑管道'
- en: 'For our scenario, we can download the deployment repository source in parallel;
    so, add a new action at the same level as the other source repository, which will
    open an Add action dialog. Select Source for the Action category, configure an
    Action name of `DeploymentRepository` or similar, and, after choosing GitHub as
    the Source provider and clicking on the Connect to GitHub button, select the master
    branch on the `docker-in-aws/todobackend-aws` repository:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的场景，我们可以并行下载部署存储库源；因此，在与其他源存储库相同级别添加一个新操作，这将打开一个添加操作对话框。选择“动作类别”为“源”，配置一个名称为`DeploymentRepository`或类似的操作名称，然后选择GitHub作为源提供者，并单击“连接到GitHub”按钮，在`docker-in-aws/todobackend-aws`存储库上选择主分支：
- en: '![](assets/2b70a550-a045-4e69-b305-4a204589bfe5.png)Adding a deployment repository'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2b70a550-a045-4e69-b305-4a204589bfe5.png)添加部署存储库'
- en: 'Next, scroll to the bottom of the page, and configure a name for the output
    artifact of this source action. CodePipeline will make the infrastructure templates
    and configuration in the deployment repository available to other stages in your
    pipeline, which you can reference by the configured output artifact name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，滚动到页面底部，并为此源操作的输出工件配置一个名称。CodePipeline将使部署存储库中的基础架构模板和配置可用于管道中的其他阶段，您可以通过配置的输出工件名称引用它们：
- en: '![](assets/3dfcd5c8-f127-4f80-a986-f2484d9a2254.png)Configuring an output artifact
    name'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3dfcd5c8-f127-4f80-a986-f2484d9a2254.png)配置输出工件名称'
- en: In the preceding screenshot, you also configure the output artifact name as
    `DeploymentRepository` (the same as the source action name), which helps, as the
    pipeline details view only shows stage and action names, and does not show artifact
    names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您还将输出工件名称配置为`DeploymentRepository`（与源操作名称相同），这有助于，因为管道详细信息视图仅显示阶段和操作名称，不显示工件名称。
- en: Adding an output artifact to the build stage
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建阶段添加输出工件
- en: 'After adding the DeploymentRepository action, the Edit pipeline screen should
    look as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 添加部署存储库操作后，编辑管道屏幕应如下截图所示：
- en: '![](assets/f8faf3c3-1c42-456f-8918-12c795137764.png)Edit pipeline screen'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f8faf3c3-1c42-456f-8918-12c795137764.png)编辑管道屏幕'
- en: The next pipeline configuration task that you need to perform is to modify the
    CodeBuild build action within the build stage, which was created for you by the
    CodePipeline wizard, when you created the pipeline.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行的下一个管道配置任务是修改构建阶段中的CodeBuild构建操作，该操作是由CodePipeline向导为您创建的，当您创建管道时。
- en: 'You can do this by clicking on the pencil icon in the right-hand corner of
    the CodeBuild action box as shown in the preceding screenshot, which opens the
    Edit action dialog:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击前面截图中CodeBuild操作框右上角的铅笔图标来执行此操作，这将打开编辑操作对话框：
- en: '![](assets/76a52a53-f5b4-48dd-99ff-14fadd367347.png)Editing build action'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/76a52a53-f5b4-48dd-99ff-14fadd367347.png)编辑构建操作'
- en: 'In the preceding screenshot, notice that the CodePipeline wizard has already
    configured an input and output artifact:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，请注意CodePipeline向导已经配置了输入和输出工件：
- en: 'Input artifacts: The CodePipeline wizard names this `MyApp`, which refers to
    the output artifact associated with the source repository that you referenced
    when you created the pipeline (in this case, this is the GitHub todobackend repository).
    If you want to rename this artifact, you must ensure that you rename the output
    artifact name on the owning action (in this case, the source action in the source
    stage), and then update any action that uses the artifact as an input.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入工件：CodePipeline向导将其命名为`MyApp`，这指的是与您创建管道时引用的源存储库相关联的输出工件（在本例中，这是GitHub todobackend存储库）。如果要重命名此工件，必须确保在拥有操作（在本例中是源阶段中的源操作）上重命名输出工件名称，然后更新任何使用该工件作为输入的操作。
- en: 'Output artifacts: The CodePipeline wizard names this `MyAppBuild` by default,
    which can then be referenced in later stages of your pipeline. The output artifacts
    are determined by the artifacts property in the `buildspec.yml` file, and for
    our use case, this artifact is not the application build; instead, it is just
    a version artifact that captures version metadata (`version.json`), so we rename
    this artifact to `ApplicationVersion`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出工件：CodePipeline向导默认将其命名为`MyAppBuild`，然后可以在流水线的后续阶段中引用。输出工件由`buildspec.yml`文件中的artifacts属性确定，对于我们的用例，这个工件不是应用程序构建，而是捕获版本元数据（`version.json`）的版本工件，因此我们将这个工件重命名为`ApplicationVersion`。
- en: Adding a deployment stage to the pipeline
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向流水线添加部署阶段
- en: 'After clicking on the Update button in the preceding screenshot, you can add
    a new stage by clicking the Add Stage box below the build stage. For the stage
    name, enter the name `Dev`, which will represent a deployment into an environment
    called Dev, and then click on the Add Action box to add a new action:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中单击“更新”按钮后，您可以通过单击构建阶段下方的“添加阶段”框来添加一个新阶段。对于阶段名称，请输入名称“Dev”，这将代表部署到名为Dev的环境，然后单击“添加操作”框以添加新操作：
- en: '![](assets/294d261f-8ecd-4942-8a13-7c8e5773895a.png)Adding a deploy action'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/294d261f-8ecd-4942-8a13-7c8e5773895a.png)添加部署操作'
- en: 'Because this is a deployment stage, select Deploy from the Action category
    drop-down menu, configure an action name of Deploy, and select AWS CloudFormation
    as the Deployment provider:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个部署阶段，所以从操作类别下拉菜单中选择“部署”，配置一个操作名称为“部署”，并选择AWS CloudFormation作为部署提供程序：
- en: '![](assets/6aafc914-9182-4329-881f-2c1faf719f56.png)Configuring a CloudFormation
    deploy action'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6aafc914-9182-4329-881f-2c1faf719f56.png)配置CloudFormation部署操作'
- en: 'This will expose a number of configuration parameters related to CloudFormation
    deployment, as shown in the preceding screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将公开与CloudFormation部署相关的一些配置参数，如前面的截图所示：
- en: 'Action mode: Select the Create or update a stack option, which will create
    a new stack if the stack does not exist, or update an existing stack.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作模式：选择“创建或更新堆栈”选项，如果堆栈不存在，则将创建一个新堆栈，或者更新现有堆栈。
- en: 'Stack name: References the existing todobackend stack that you have already
    deployed in previous chapters.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈名称：引用您在之前章节中已部署的现有todobackend堆栈。
- en: 'Template: Refers to the CloudFormation template file that should be deployed.
    This is expressed in the format `InputArtifactName::TemplateFileName`, which,
    in our case, is `DeploymentRepository::stack.yml`, given that we configured an
    output artifact name of `DeploymentRepository` for the `DeploymentRepository`
    source action, and our stack is located in the file `stack.yml`, at the root of
    the repository.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板：指的是应该部署的CloudFormation模板文件。这是以`InputArtifactName::TemplateFileName`的格式表示的，在我们的情况下是`DeploymentRepository::stack.yml`，因为我们为`DeploymentRepository`源操作配置了一个输出工件名称，并且我们的堆栈位于存储库根目录的`stack.yml`文件中。
- en: 'Template configuration: Refers to the configuration file that is used to provide
    stack parameters, tags, and a stack policy. This needs to reference the new `dev.json`
    file that you created earlier,, within the `todobackend-aws` deployment repository;
    it is configured in the same format as the template parameter, with a value of `DeploymentRepository::dev.json`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板配置：指的是用于提供堆栈参数、标记和堆栈策略的配置文件。这需要引用您之前创建的新`dev.json`文件，在`todobackend-aws`部署存储库中；它与模板参数的格式相同，值为`DeploymentRepository::dev.json`。
- en: 'Once you have configured the properties shown in the preceding screenshot,
    scroll down further and expand the Advanced section, as demonstrated in the following
    screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了前面截图中显示的属性，请继续向下滚动并展开高级部分，如下面的截图所示：
- en: '![](assets/7a23b618-6734-4918-96ab-b21350aecc7c.png)Configuring additional
    CloudFormation deploy action properties'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7a23b618-6734-4918-96ab-b21350aecc7c.png)配置额外的CloudFormation部署操作属性'
- en: 'The following describes each of the additional parameters that you need to
    configure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了您需要配置的每个额外参数：
- en: 'Capabilities: This grants permission to the CloudFormation deployment action
    to create IAM resources on your behalf, and is identical in meaning to the`--capabilities`
    flag that you pass to the `aws cloudformation deploy` command.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：这授予了CloudFormation部署操作的权限，以代表您创建IAM资源，并且与您传递给`aws cloudformation deploy`命令的`--capabilities`标志具有相同的含义。
- en: 'Role name: This specifies the IAM role used by the CloudFormation deployment
    action to deploy your CloudFormation stack. Reference the `cloudformation-deploy`
    role that you created earlier.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色名称：这指定了CloudFormation部署操作使用的IAM角色，用于部署您的CloudFormation堆栈。引用您之前创建的`cloudformation-deploy`角色。
- en: 'Parameter overrides: This parameter allows you to override input parameter
    values that are normally supplied by the template configuration file (`dev.json`),
    or default values within the CloudFormation template. For our use case, we need
    to override the `ApplicationImageTag` parameter, given that this needs to reflect
    the image tag that is created as part of the build stage. CodePipeline supports
    two types of parameter overrides (see [Using Parameter Override Functions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)),
    and, for our use case, we are using the `Fn::GetParam` override, which can be
    used to extract property values from a JSON file in an artifact that is output
    by your pipeline. Recall that we added a `make version` task to the todobackend
    repository earlier in this chapter, which outputs the file `version.json` that
    is collected as an artifact as part of the CodeBuild build specification. We updated
    the build action to refer to this artifact as `ApplicationVersion`. In the preceding
    screenshot, the input list that is supplied to the `Fn::GetParam` call first references
    the artifact (`ApplicationVersion`), the path to the JSON file in the artifact
    (`version.json`), and finally, the key within the JSON file (`Version`) that holds
    the parameter override value.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数覆盖：此参数允许您覆盖通常由模板配置文件（`dev.json`）或CloudFormation模板中的默认值提供的输入参数值。对于我们的用例，我们需要覆盖`ApplicationImageTag`参数，因为这需要反映作为构建阶段的一部分创建的图像标记。CodePipeline支持两种类型的参数覆盖（请参阅[使用参数覆盖函数](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)），对于我们的用例，我们使用`Fn::GetParam`覆盖，它可以用于从由您的流水线输出的工件中提取属性值的JSON文件中。回想一下，在本章的前面，我们向todobackend存储库添加了一个`make
    version`任务，该任务输出了作为CodeBuild构建规范的一部分收集的`version.json`文件。我们更新了构建操作以引用此工件为`ApplicationVersion`。在前面的屏幕截图中，提供给`Fn::GetParam`调用的输入列表首先引用了工件（`ApplicationVersion`），然后是工件中JSON文件的路径（`version.json`），最后是JSON文件中保存参数覆盖值的键（`Version`）。
- en: 'Input artifacts: This must specify any input artifacts that you reference in
    your deployment configuration. Here, we add `DeploymentRepository` (used for both
    the template and template configuration parameters) and `ApplicationVersion` (used
    in the parameter overrides configuration).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入工件：这必须指定您在部署配置中引用的任何输入工件。在这里，我们添加了`DeploymentRepository`（用于模板和模板配置参数）和`ApplicationVersion`（用于参数覆盖配置）。
- en: 'Once complete, click on the Add action button, and then you can click on Save
    pipeline changes to complete the configuration of your pipeline. At this point,
    you can test that your new deployment action is working by clicking on the Release
    change button, which manually triggers a new execution of your pipeline; within
    a few minutes, your pipeline should successfully build, test, and publish a new
    image as part of the build stage, and then successfully deploy your changes to
    your todobackend stack via the dev stage:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，单击“添加操作”按钮，然后您可以单击“保存管道更改”以完成管道的配置。在这一点上，您可以通过单击“发布更改”按钮来测试您的新部署操作是否正常工作，这将手动触发管道的新执行；几分钟内，您的管道应该成功构建、测试和发布一个新的镜像作为构建阶段的一部分，然后成功通过dev阶段将更改部署到您的todobackend堆栈：
- en: '![](assets/9c4d6c8e-0bbc-47b0-85dd-6e7afdb035c0.png)Successful CloudFormation
    deployment via CodePipeline'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9c4d6c8e-0bbc-47b0-85dd-6e7afdb035c0.png)通过CodePipeline成功部署CloudFormation'
- en: 'In the preceding screenshot, you can click on the Details link, either during
    or after deployment, which takes you to the CloudFormation console and shows you
    details about the in-progress or completed deployment. If you expand the Parameters
    tab, you should see that ApplicationImageTag is referencing a tag in the format
    of  `<long commit hash>`.`<codebuild job id>`, confirming that our pipeline has,
    in fact, deployed the Docker image that was built during the build stage:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，您可以在部署期间或之后单击“详细信息”链接，这将带您到CloudFormation控制台，并向您显示有关正在进行中或已完成的部署的详细信息。如果您展开“参数”选项卡，您应该会看到ApplicationImageTag引用的标签格式为`<长提交哈希>`.`<codebuild作业ID>`，这证实我们的流水线实际上已部署了在构建阶段构建的Docker镜像：
- en: '![](assets/28a8570e-e4d2-4ab4-ac45-13e6a2063286.png)Confirming an overridden
    input parameter'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/28a8570e-e4d2-4ab4-ac45-13e6a2063286.png)确认覆盖的输入参数'
- en: Continuously delivering to production using CodePipeline
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CodePipeline持续交付到生产环境
- en: Now that we are continuously deploying into a non-production environment, the
    final step in our continuous delivery journey is to enable the ability to deploy
    application releases into production in a controlled fashion. CodePipeline supports
    this capability by leveraging a useful feature of CloudFormation, called change
    sets. A change set describes the various configuration changes that will be applied
    to a given CloudFormation stack, based on any changes that may have been applied
    to your stack template file and/or input parameters. For new application releases,
    you are typically only changing an input parameter that defines the version of
    your new application artifact(s). For example, the dev stage of our pipeline overrides
    the `ApplicationImageTag` input parameter. In some scenarios, you may make wider
    changes to your CloudFormation stack and input parameters. For example, you might
    need to add new environment variables for your container, or you might add new
    infrastructure components or supporting services to you stack. These changes are
    typically committed to your deployment repository, and, given that our deployment
    repository is a source in our pipeline, any changes to your deployment repository
    will be captured as a change.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在持续部署到非生产环境，我们持续交付旅程的最后一步是启用能够以受控方式将应用程序发布到生产环境的能力。CodePipeline通过利用CloudFormation的一个有用特性来支持这一能力，称为变更集。变更集描述了将应用于给定CloudFormation堆栈的各种配置更改，这些更改基于可能已应用于堆栈模板文件和/或输入参数的任何更改。对于新的应用程序发布，通常只会更改定义新应用程序构件版本的输入参数。例如，我们的流水线的dev阶段覆盖了`ApplicationImageTag`输入参数。在某些情况下，您可能会对CloudFormation堆栈和输入参数进行更广泛的更改。例如，您可能需要为容器添加新的环境变量，或者向堆栈添加新的基础设施组件或支持服务。这些更改通常会提交到您的部署存储库中，并且鉴于我们的部署存储库是我们流水线中的一个源，对部署存储库的任何更改都将被捕获为一个变更。
- en: CloudFormation change sets provide an opportunity for you to review any changes
    that are about to be applied to a target environment, and if the change set is
    deemed safe, you can then initiate a deployment from that change set. CodePipeline
    supports generating CloudFormation change sets as a deployment action, which can
    then be combined with a separate manual approval action, which allows for an appropriate
    person to review the change set and subsequently approve or reject the change.
    If the change is approved, you can then trigger a deployment from the change set,
    providing an effective means to provide controlled releases into your production
    environment, or any type of environment that requires some form of change control.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation变更集为您提供了一个机会，可以审查即将应用于目标环境的任何更改，如果变更集被认为是安全的，那么您可以从该变更集发起部署。CodePipeline支持生成CloudFormation变更集作为部署操作，然后可以与单独的手动批准操作结合使用，允许适当的人员审查变更集，随后批准或拒绝变更。如果变更得到批准，那么您可以从变更集触发部署，从而提供一种有效的方式来对生产环境或任何需要某种形式的变更控制的环境进行受控发布。
- en: 'Let''s now extend our pipeline to support the controlled deployment of application
    releases into a new production environment, which requires you to perform the
    following configuration changes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展我们的流水线，以支持将应用程序发布受控地部署到新的生产环境，这需要您执行以下配置更改：
- en: Add a new environment configuration file to your deployment repository
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向部署存储库添加新的环境配置文件
- en: Add a create change set action to the pipeline
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向流水线添加创建变更集操作
- en: Add a manual approval action to the pipeline
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向流水线添加手动批准操作
- en: Add a deploy change set action to the pipeline
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向流水线添加部署变更集操作
- en: Deploy to production
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到生产环境
- en: Adding a new environment configuration file to your deployment repository
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向部署存储库添加新的环境配置文件
- en: 'Because we are creating a new production environment, we need to add an environment
    configuration file to the deployment repository, which will include input parameters
    specific to your production environment. As shown in the previous example, which
    demonstrates adding a new file called `prod.json` at the root of the `todobackend-aws`
    repository:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在创建一个新的生产环境，我们需要向部署存储库添加一个环境配置文件，其中将包括特定于您的生产环境的输入参数。如前面的示例所示，演示了在`todobackend-aws`存储库的根目录下添加一个名为`prod.json`的新文件：
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that the format of the configuration file is identical to the `dev.json`
    file that we modified earlier. In a real-world scenario, of course, you would
    expect differences in the configuration file. For example, we are using the same
    application subnets and VPC ID; you would typically have a separate VPC, or even
    a separate account, for production, but to keep things simple, we will just deploy
    our production environment into the same VPC and subnets as our dev environment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到配置文件的格式与我们之前修改的`dev.json`文件相同。在现实世界的情况下，您当然会期望配置文件中有所不同。例如，我们正在使用相同的应用子网和VPC
    ID；您通常会为生产环境拥有一个单独的VPC，甚至一个单独的账户，但为了保持简单，我们将生产环境部署到与开发环境相同的VPC和子网中。
- en: 'You will also need to make a few minor changes to our CloudFormation stack file,
    as there are some hardcoded names that will cause conflicts if you attempt to
    create a new stack in the same AWS account:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要对我们的CloudFormation堆栈文件进行一些微小的更改，因为其中有一些硬编码的名称，如果您尝试在同一AWS账户中创建一个新堆栈，将会导致冲突。
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, I have commented the previous configurations, and
    then highlighted the new configuration that is required. In all cases, we replace
    the hardcoded reference to todobackend with a reference to the stack name. Given
    that CloudFormation stack names must be unique within a given AWS account and
    region, this ensures that the modified resources will have unique names that do
    not conflict with other stacks in the same account and region.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我已经注释了以前的配置，然后突出显示了所需的新配置。在所有情况下，我们将硬编码的对todobackend的引用替换为对堆栈名称的引用。鉴于CloudFormation堆栈名称在给定的AWS账户和区域内必须是唯一的，这确保了修改后的资源将具有唯一名称，不会与同一账户和区域内的其他堆栈发生冲突。
- en: To keep things simple, the CloudFormation stack for the production environment
    will use the same secret that we created back in the *Managing Secrets* chapter.
    In a real-world scenario, you would maintain separate secrets per environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，生产环境的CloudFormation堆栈将使用我们在*管理秘密*章节中创建的相同秘密。在现实世界的情况下，您会为每个环境维护单独的秘密。
- en: 'With the new configuration file and template changes in place, make sure that
    you have committed and pushed your changes to GitHub before proceeding to the
    next section:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置新的配置文件和模板更改后，确保在继续下一部分之前已经将更改提交并推送到GitHub：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding a create change set action to the pipeline
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向管道添加创建变更集操作
- en: We are now ready to add a new stage to our pipeline that will deploy our application
    to production. We will create the first action in this stage, which creating a
    CloudFormation change set.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备向我们的管道中添加一个新阶段，用于将我们的应用部署到生产环境。我们将在这个阶段创建第一个操作，即创建一个CloudFormation变更集。
- en: 'In the pipeline details view for your pipeline, click on the Edit button and
    add a new stage called Production after the dev stage, and then add an action
    to the new stage:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的详细信息视图中，单击“编辑”按钮，然后在dev阶段之后添加一个名为Production的新阶段，然后向新阶段添加一个操作：
- en: '![](assets/709983ae-b16b-4beb-8387-94be2f9b2b00.png)Adding a production stage
    to the pipeline'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/709983ae-b16b-4beb-8387-94be2f9b2b00.png)向管道添加一个生产阶段'
- en: 'In the Add action dialog box, you need to create an action that is similar
    to the deploy action that you created for the dev stage, with a few variations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加操作”对话框中，您需要创建一个类似于为dev阶段创建的部署操作的操作，但有一些变化：
- en: '![](assets/1b96f366-2196-493a-af18-a12ece18dcb5.png)Adding a create change
    set action to the pipeline'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1b96f366-2196-493a-af18-a12ece18dcb5.png)向管道添加创建更改集操作'
- en: 'If you compare the deploy action configuration for the dev stage, with the
    new create change set action configuration as shown in the preceding screenshot,
    the configuration is very similar, except for the following key differences:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将dev阶段的部署操作配置与前面截图中显示的新创建更改集操作配置进行比较，您会发现配置非常相似，除了以下关键差异：
- en: 'Action mode: You configure this as `create` or `replace` a change set, which,
    instead of deploying the stack, will just create a new change set.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作模式：您可以将其配置为`create`或`replace`更改集，而不是部署堆栈，只会创建一个新的更改集。
- en: 'Stack name: Because this action relates to our production environment, you
    need to configure a new stack name, which we will call `todobackend-prod`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈名称：由于此操作涉及我们的生产环境，您需要配置一个新的堆栈名称，我们将其称为`todobackend-prod`。
- en: 'Change set name: This defines a name for the change set. I typically just name
    this the same as the stack name, given that the action will create or replace
    the change set on each execution.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改集名称：这定义了更改集的名称。我通常将其命名为与堆栈名称相同，因为该操作将在每次执行时创建或替换更改集。
- en: 'Template configuration: Here, you need to reference the new `prod.json` file
    that you added to the `todobackend-aws` repository in the earlier example, as
    this holds the input parameters specific to your production environment. This
    file is made available via the `DeploymentRepository` artifact that is created
    from the `todobackend-aws` repository.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板配置：在这里，您需要引用之前示例中添加到`todobackend-aws`存储库的新`prod.json`文件，因为这个文件包含特定于生产环境的输入参数。该文件通过从`todobackend-aws`存储库创建的`DeploymentRepository`工件提供。
- en: Next, you need to scroll down, expand the Advanced section, configure the Parameter
    overrides property using the `Fn::GetParam`  syntax, and finally, configure both
    the `ApplicationVersion` and `DeploymentRepository` artifacts as input artifacts.
    This is identical to the configuration that you performed earlier, for the `dev`/`deploy`
    action.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要向下滚动，展开高级部分，使用`Fn::GetParam`语法配置参数覆盖属性，并最终将`ApplicationVersion`和`DeploymentRepository`工件配置为输入工件。这与您之前为`dev`/`deploy`操作执行的配置相同。
- en: Adding a manual approval action to the pipeline
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向管道添加手动批准操作
- en: 'After you have completed the configuration of the ChangeSet action, you will
    need to add a new action that comes after the ChangeSet action:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完成更改集操作的配置后，您需要添加一个在更改集操作之后执行的新操作：
- en: '![](assets/8e665d07-b1fc-496e-aa77-9f0d637f6c89.png)Adding an approval action
    to the pipeline'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8e665d07-b1fc-496e-aa77-9f0d637f6c89.png)向管道添加批准操作'
- en: In the Add action dialog box, select Approval for the Action category, and then
    configure an Action name of ApproveChangeSet. After selecting an Approval type
    of Manual approval, notice that you can add an SNS topic ARN and other information
    to the manual approval request. This could then be used to send an email to the
    approver, or to trigger a lambda function that performs some custom action, such
    as posting a message into a messaging tool like Slack.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加操作”对话框中，选择“批准”作为操作类别，然后配置一个操作名称为ApproveChangeSet。选择手动批准类型后，注意您可以添加SNS主题ARN和其他信息到手动批准请求。然后可以用于向批准者发送电子邮件，或触发执行一些自定义操作的lambda函数，例如将消息发布到Slack等消息工具中。
- en: Adding a deploy change set action to the pipeline
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向管道添加部署更改集操作
- en: 'The final action that you need to create is one that will deploy the change
    set created earlier in the ChangeSet action, once the ApproveChangeSet action
    has been approved:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建的最后一个操作是，在批准ApproveChangeSet操作后，部署先前在ChangeSet操作中创建的更改集：
- en: '![](assets/8e4948db-2942-4902-9e0b-1ef79d3935f1.png)Adding an execute change
    set action to the pipeline'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8e4948db-2942-4902-9e0b-1ef79d3935f1.png)向流水线添加执行更改集操作'
- en: In the preceding screenshot, we have selected an Action mode of Execute a change
    set, and then configured the Stack name and Change set name, which must match
    the same values that you configured earlier, in the ChangeSet action.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们选择了“执行更改集”操作模式，然后配置了堆栈名称和更改集名称，这些名称必须与您在ChangeSet操作中之前配置的相同值匹配。
- en: Deploying to production
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到生产环境
- en: 'After clicking on Add action in the preceding screenshot, your pipeline configuration
    for the new production stage should look as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中单击“添加操作”后，您的新生产阶段的管道配置应如下所示：
- en: '![](assets/04e63fe0-ea86-4462-8481-35d21211f1e4.png)Adding a create change
    set action to the pipeline'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/04e63fe0-ea86-4462-8481-35d21211f1e4.png)向流水线添加创建更改集操作'
- en: 'At this point, you can save your pipeline changes by clicking the Save pipeline
    changes button, and test your new pipeline stage by clicking the Release change
    button, which will force a new pipeline execution. After the pipeline successfully
    executes the build and dev stages, the production stage will be invoked for the
    first time, with a CloudFormation change set created by the ChangeSet action,
    after which the approval action will be triggered:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以通过单击“保存管道更改”按钮保存管道更改，并通过单击“发布更改”按钮测试新的管道阶段，这将强制执行新的管道执行。在管道成功执行构建和开发阶段后，生产阶段将首次被调用，由ChangeSet操作创建一个CloudFormation更改集，之后将触发批准操作。
- en: '![](assets/fe4dfcc1-0aef-4ddd-998c-946d30339bd9.png)Adding a create change
    set action to the pipeline'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fe4dfcc1-0aef-4ddd-998c-946d30339bd9.png)向流水线添加创建更改集操作'
- en: 'The pipeline will now wait for approval, and this is where an approver would
    typically review the previously created change set by clicking on the Details
    link for the ChangeSet action:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在管道将等待批准，这是批准者通常会通过单击ChangeSet操作的“详细信息”链接来审查先前创建的更改集：
- en: '![](assets/ba618105-d503-4550-91a1-8173242461a1.png)CloudFormation change set'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ba618105-d503-4550-91a1-8173242461a1.png)CloudFormation更改集'
- en: As you can see in the preceding screenshot, the change set indicates that all
    resources in the stack will be created, given that the production environment
    does not currently exist. Subsequent deployments should have very little changes,
    given that the stack will be in place, and the typical change is to deploy a new
    Docker image.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上述截图中所看到的，更改集指示将创建堆栈中的所有资源，因为生产环境目前不存在。随后的部署应该有非常少的更改，因为堆栈将就位，典型的更改是部署新的Docker镜像。
- en: 'After reviewing the change set and returning to the CodePipeline details view,
    you can now approve (or reject) the change set by clicking on the Review button. 
    This will present an Approve or reject the revision dialog box, where you can
    add a comment and either Approve or Reject the change:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 审查更改集并返回到CodePipeline详细视图后，您现在可以通过单击“审查”按钮来批准（或拒绝）更改集。这将呈现一个批准或拒绝修订对话框，在这里您可以添加评论并批准或拒绝更改：
- en: '![](assets/2af34076-a505-4017-b38f-120ab29e1f8b.png)Approving or rejecting
    a manual approval action'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2af34076-a505-4017-b38f-120ab29e1f8b.png)批准或拒绝手动批准操作'
- en: If you click on Approve, the pipeline will proceed to the next action, which
    is to deploy the change set associated with the earlier ChangeSet action. For
    this first execution, a new stack called `todobackend-prod` will be deployed,
    and, once complete, you have successfully deployed a brand new production environment
    using CodePipeline!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击“批准”，流水线将继续执行下一个操作，即部署与之前ChangeSet操作相关联的变更集。对于这次执行，将部署一个名为“todobackend-prod”的新堆栈，一旦完成，您就成功地使用CodePipeline部署了一个全新的生产环境！
- en: At this point, you should test and verify that your new stack and application
    are working as expected, following the steps in the *Deploying an Application
    Load Balancer* section of the *Deploying Applications Using ECS* chapter to obtain
    the DNS name of the application load balancer endpoint that your production application
    endpoint will be served from. I also encourage you to trigger the pipeline, either
    manually or by making a test commit to either repository, and then reviewing the
    subsequent change set that is generated for an application deployment to an existing
    environment. Note that you can choose when you want to deploy to production. For
    example, your developers may commit application changes many times, with each
    change automatically deployed to your non-production environment, before you choose
    to deploy your next release to production. When you do choose to deploy to production,
    your production stage will take the most recent release that has been successfully
    deployed to your non-production environment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该测试并验证您的新堆栈和应用程序是否按预期工作，按照“使用ECS部署应用程序”章节中“部署应用程序负载均衡器”部分的步骤获取应用程序负载均衡器端点的DNS名称，您的生产应用程序端点将从中提供服务。我还鼓励您触发流水线，无论是手动触发还是通过对任一存储库进行测试提交，然后审查生成的后续变更集，以进行对现有环境的应用程序部署。请注意，您可以选择何时部署到生产环境。例如，您的开发人员可能多次提交应用程序更改，每次更改都会自动部署到非生产环境，然后再选择部署下一个版本到生产环境。当您选择部署到生产环境时，您的生产阶段将采用最近成功部署到非生产环境的最新版本。
- en: Once you have completed testing your production deployments, if you are using
    a free tier account, bear in mind that you now have multiple EC2 instances and
    RDS instances running, so you should consider tearing down your production environment,
    in order to avoid incurring charges.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了对生产部署的测试，如果您使用的是免费套餐账户，请记住您现在有多个EC2实例和RDS实例在运行，因此您应该考虑拆除您的生产环境，以避免产生费用。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you created an end-to-end continuous delivery pipeline that
    automatically tests, builds, and publishes Docker images for your application,
    continuously deploys new application changes into a non-production environment,
    and allows you to perform controlled releases into production that generate change
    sets and require manual approval before deployment to production can commence.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您创建了一个端到端的持续交付流水线，该流水线自动测试、构建和发布您的应用程序的Docker镜像，持续将新的应用程序更改部署到非生产环境，并允许您在生成变更集并在部署到生产环境之前需要手动批准的情况下执行受控发布。
- en: You learned how to integrate your GitHub repositories with CodePipeline by defining
    them as source actions in a source stage, and then created a build stage that
    used CodeBuild to test, build, and publish Docker images for your application.
    You added a build specification to the todobackend repository, which CodeBuild
    uses to execute your builds, and you created a custom CodeBuild container that
    was able to run Docker in Docker, to allow you to build a Docker image and perform
    integration and acceptance tests in a Docker Compose environment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何将您的GitHub存储库与CodePipeline集成，方法是将它们定义为源阶段中的源操作，然后创建一个构建阶段，该阶段使用CodeBuild来测试、构建和发布应用程序的Docker镜像。您向todobackend存储库添加了构建规范，CodeBuild使用它来执行您的构建，并创建了一个自定义的CodeBuild容器，该容器能够在Docker中运行Docker，以允许您构建Docker镜像并在Docker
    Compose环境中执行集成和验收测试。
- en: Next, you created a deploy stage in CodePipeline, which automatically deploys
    application changes to the existing todobackend stack that we have worked with
    throughout this book. This required you to add a new source action in the source
    stage for the `todobackend-aws` repository, which makes the CloudFormation stack
    file and environment configuration file available as artifacts for later CloudFormation
    deployment actions. You also needed to create an output artifact for the todobackend
    repository, which, in this case, simply captures the Docker image tag built and
    published during the build stage, and makes it available for subsequent stages.
    You then referenced this artifact as a parameter override to your dev stage deployment
    action, overriding the `ApplicationImageTag` parameter with the Docker image tag
    output in the build action version artifact.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您在CodePipeline中创建了一个部署阶段，该阶段会自动将应用程序更改部署到我们在本书中一直使用的todobackend堆栈。这要求您在源阶段为`todobackend-aws`存储库添加一个新的源操作，这使得CloudFormation堆栈文件和环境配置文件可用作以后的CloudFormation部署操作的工件。您还需要为todobackend存储库创建一个输出工件，这种情况下，它只是捕获了在构建阶段构建和发布的Docker镜像标记，并使其可用于后续阶段。然后，您将此工件作为参数覆盖引用到您的dev阶段部署操作中，使用构建操作版本工件中输出的Docker镜像标记覆盖`ApplicationImageTag`参数。
- en: Finally, you extended the pipeline to support controlled releases in a production
    environment, which requires a create change set action that creates a CloudFormation
    change set, a manual approval action that allows somebody to review the change
    set and approve/reject it, and a deployment action that executes the previously
    generated change set.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您扩展了管道以支持在生产环境中进行受控发布，这需要创建一个创建变更集操作，该操作创建一个CloudFormation变更集，一个手动批准操作，允许某人审查变更集并批准/拒绝它，以及一个部署操作，执行先前生成的变更集。
- en: In the next chapter, we will change tracks and introduce the AWS Fargate service,
    which allows you to deploy your Docker applications without a need to deploy and
    manage your own ECS clusters and ECS container instances. We will take this opportunity
    to add support for the AWS X-Ray service by deploying an X-Ray daemon using Fargate,
    and will publish the daemon endpoint by using ECS service discovery.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改变方向，介绍AWS Fargate服务，它允许您部署Docker应用程序，而无需部署和管理自己的ECS集群和ECS容器实例。我们将利用这个机会通过使用Fargate部署X-Ray守护程序来为AWS
    X-Ray服务添加支持，并将通过使用ECS服务发现发布守护程序端点。
- en: Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What file do you typically include at the root of your application repository
    to support AWS CodeBuild?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您通常在应用程序存储库的根目录中包含哪个文件以支持AWS CodeBuild？
- en: 'True/false: AWS CodeBuild is a build service that spins up virtual machines
    and runs build scripts using AWS CodeDeploy.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：AWS CodeBuild是一个构建服务，它会启动虚拟机并使用AWS CodeDeploy运行构建脚本。
- en: What is the Docker configuration that you need to run to support the building
    of Docker images and multi-container build environments?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要运行哪些Docker配置来支持Docker镜像和多容器构建环境的构建？
- en: You wish to review the changes made to your CloudFormation templates before
    they are deployed. What feature of CloudFormation would you use to achieve this?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望在部署CloudFormation模板之前审查所做的更改。您将使用CloudFormation的哪个功能来实现这一点？
- en: When deploying CloudFormation stacks using the CodePipeline CloudFormation deploy
    action, which service must be the trusted for the service role that you specify
    for these actions?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用CodePipeline CloudFormation部署操作部署CloudFormation堆栈时，必须信任哪个服务以用于指定这些操作的服务角色？
- en: You set up a new CodeBuild project that includes a build task that publishes
    to the Elastic Container Registry. Your first build fails when you attempt to
    publish the image. You confirm that the target ECR repository exists, and that
    you can manually publish images to the repository yourself. What is the likely
    cause of this problem?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您设置了一个新的CodeBuild项目，其中包括一个发布到弹性容器注册表的构建任务。当您尝试发布图像时，第一次构建失败。您确认目标ECR存储库存在，并且您可以手动发布图像到存储库。这个问题的可能原因是什么？
- en: You create a custom build container for CodeBuild that is published to ECR,
    and create a repository policy that allows ECR pull access from your AWS account.
    When executing a build, you get failures indicating that CodeBuild was unable
    to retry the custom image. How would you resolve this?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您为CodeBuild创建了一个自定义构建容器，并将其发布到ECR，并创建了一个允许您的AWS账户从ECR拉取访问的存储库策略。在执行构建时，您会收到失败的消息，指示CodeBuild无法重试自定义镜像。您将如何解决这个问题？
- en: You create a custom build container that uses Docker in Docker to support Docker
    image builds. When the build container starts and you attempt to start the Docker
    daemon, a permissions error occurs. How would you resolve this?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个自定义构建容器，该容器使用Docker in Docker来支持Docker镜像构建。当构建容器启动并尝试启动Docker守护程序时，会出现权限错误。您将如何解决这个问题？
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: CodePipeline User Guide: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodePipeline用户指南：[https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)
- en: CodeBuild User Guide: [https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html](https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild用户指南：[https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html](https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html)
- en: Build Specification Reference for CodeBuild: [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild的构建规范参考：[https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html)
- en: Using AWS CodePipeline with CodeBuild: [https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html](https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CodePipeline与CodeBuild：[https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html](https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html)
- en: AWS CodePipeline Pipeline Structure Reference: [https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CodePipeline管道结构参考：[https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html)
- en: Using Parameter Override Functions with AWS CodePipeline Pipelines: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数覆盖函数与AWS CodePipeline管道：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)
