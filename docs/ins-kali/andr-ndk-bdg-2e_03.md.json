["```kt\n        <LinearLayout \n\n          a:layout_width=\"match_parent\" a:layout_height=\"match_parent\"\n          a:orientation=\"vertical\"\n        tools:context=\"com.packtpub.store.StoreActivity$PlaceholderFragment\">\n          <TextView\n            a:layout_width=\"match_parent\" a:layout_height=\"wrap_content\"\n            a:text=\"Save or retrieve a value from the store:\" />\n          <TableLayout\n            a:layout_width=\"match_parent\" a:layout_height=\"wrap_content\"\n            a:stretchColumns=\"1\" >\n            <TableRow>\n              <TextView a:id=\"@+id/uiKeyLabel\" a:text=\"Key : \" />\n              <EditText a:id=\"@+id/uiKeyEdit\" ><requestFocus /></EditText>\n            </TableRow>\n            <TableRow>\n              <TextView a:id=\"@+id/uiValueLabel\" a:text=\"Value : \" />\n              <EditText a:id=\"@+id/uiValueEdit\" />\n            </TableRow>\n            <TableRow>\n              <TextView a:id=\"@+id/uiTypeLabel\" a:layout_height=\"match_parent\"\n                        a:gravity=\"center_vertical\" a:text=\"Type : \" />\n              <Spinner a:id=\"@+id/uiTypeSpinner\" />\n            </TableRow>\n          </TableLayout>\n          <LinearLayout\n            a:layout_width=\"wrap_content\" a:layout_height=\"wrap_content\"\n            a:layout_gravity=\"right\" >\n            <Button a:id=\"@+id/uiGetValueButton\" a:layout_width=\"wrap_content\"\n                    a:layout_height=\"wrap_content\" a:text=\"Get Value\" />\n            <Button a:id=\"@+id/uiSetValueButton\" a:layout_width=\"wrap_content\"\n                    a:layout_height=\"wrap_content\" a:text=\"Set Value\" />\n          </LinearLayout>\n        </LinearLayout>\n        ```", "```kt\n    package com.packtpub.store;\n\n    public enum StoreType {\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            private Store mStore = new Store();\n     private EditText mUIKeyEdit, mUIValueEdit;\n     private Spinner mUITypeSpinner;\n            private Button mUIGetButton, mUISetButton;\n            private Pattern mKeyPattern;\n\n            ...\n\n            @Override\n            public View onCreateView(LayoutInflater inflater,\n                                     ViewGroup container,\n                                     Bundle savedInstanceState)\n            {\n                View rootView = inflater.inflate(R.layout.fragment_store,\n                                                 container, false);\n                updateTitle();\n\n     // Initializes text components.\n     mKeyPattern = Pattern.compile(\"\\\\p{Alnum}+\");\n     mUIKeyEdit = (EditText) rootView.findViewById(\n     R.id.uiKeyEdit);\n     mUIValueEdit = (EditText) rootView.findViewById(\n     R.id.uiValueEdit);\n\n    ```", "```kt\n                ...\n     ArrayAdapter<StoreType> adapter =\n     new ArrayAdapter<StoreType>(getActivity(),\n     android.R.layout.simple_spinner_item,\n     StoreType.values());\n     adapter.setDropDownViewResource(\n     android.R.layout.simple_spinner_dropdown_item);\n     mUITypeSpinner = (Spinner) rootView.findViewById(\n     R.id.uiTypeSpinner);\n     mUITypeSpinner.setAdapter(adapter);\n                    ...\n    ```", "```kt\n                ...\n     mUIGetButton = (Button) rootView.findViewById(\n     R.id.uiGetValueButton);\n     mUIGetButton.setOnClickListener(new OnClickListener() {\n     public void onClick(View pView) {\n     onGetValue();\n     }\n     });\n     mUISetButton = (Button) rootView.findViewById(\n     R.id.uiSetValueButton);\n     mUISetButton.setOnClickListener(new OnClickListener() {\n     public void onClick(View pView) {\n     onSetValue();\n     }\n     });\n                return rootView;\n            }\n            ...\n    ```", "```kt\n            ...\n            private void onGetValue() {\n                // Retrieves key and type entered by the user.\n                String key = mUIKeyEdit.getText().toString();\n                StoreType type = (StoreType) mUITypeSpinner\n                                                       .getSelectedItem();\n                // Checks key is correct.\n                if (!mKeyPattern.matcher(key).matches()) {\n                    displayMessage(\"Incorrect key.\");\n                    return;\n                }\n\n                // Retrieves value from the store and displays it.\n                // Each data type has its own access method.\n                switch (type) {\n                    // Will retrieve entries soon...\n                }\n            }\n            ...\n    ```", "```kt\n            ...\n            private void onSetValue() {\n                // Retrieves key and type entered by the user.\n                String key = mUIKeyEdit.getText().toString();\n                String value = mUIValueEdit.getText().toString();\n                StoreType type = (StoreType) mUITypeSpinner\n                                                       .getSelectedItem();\n                // Checks key is correct.\n                if (!mKeyPattern.matcher(key).matches()) {\n                    displayMessage(\"Incorrect key.\");\n                    return;\n                }\n\n                // Parses user entered value and saves it in the store.\n                // Each data type has its own access method.\n                try {\n                    switch (type) {\n                        // Will put entries soon...\n                    }\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n    ```", "```kt\n            ...\n            private void displayMessage(String pMessage) {\n                Toast.makeText(getActivity(), pMessage, Toast.LENGTH_LONG)\n                     .show();\n            }\n        }\n    }\n    ```", "```kt\n        #ifndef _STORE_H_\n        #define _STORE_H_\n\n        #include <cstdint>\n\n        #define STORE_MAX_CAPACITY 16\n\n        typedef enum {\n        } StoreType;\n\n        typedef union {\n        } StoreValue;\n\n        typedef struct {\n            char* mKey;\n            StoreType mType;\n            StoreValue mValue;\n        } StoreEntry;\n\n        typedef struct {\n            StoreEntry mEntries[STORE_MAX_CAPACITY];\n            int32_t mLength;\n        } Store;\n        #endif\n        ```", "```kt\n    #include \"com_packtpub_store_Store.h\"\n    #include \"Store.h\"\n\n    static Store gStore;\n\n    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n     // Store initialization.\n     gStore.mLength = 0;\n     return JNI_VERSION_1_6;\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jint JNICALL Java_com_packtpub_store_Store_getCount\n      (JNIEnv* pEnv, jobject pObject) {\n     return gStore.mLength;\n    }\n    ```", "```kt\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);\n```", "```kt\nJNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n JNIEnv *env;\n if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {\n abort();\n    }\n    ...\n    return JNI_VERSION_1_6;\n}\n```", "```kt\n    public enum StoreType {\n     String\n    }\n    Open Store.java and define the new functionalities our native key/value store provides (for now, only strings):\n    public class Store {\n        ...\n        public native int getCount();\n\n     public native String getString(String pKey);\n     public native void setString(String pKey, String pString);\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            ...\n            private void onGetValue() {\n                ...\n                switch (type) {\n     case String:\n     mUIValueEdit.setText(mStore.getString(key));\n     break;\n                }\n            }\n            ...\n    ```", "```kt\n            ...\n            private void onSetValue() {\n                ...\n                try {\n                    switch (type) {\n     case String:\n     mStore.setString(key, value);\n     break;\n                    }\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n        }\n    }\n    ```", "```kt\n    #ifndef _STORE_H_\n    #define _STORE_H_\n\n    #include <cstdint>\n    #include \"jni.h\"\n    ...\n    ```", "```kt\n    ...\n    typedef enum {\n     StoreType_String\n    } StoreType;\n\n    typedef union {\n     char*     mString;\n    } StoreValue;\n    ...\n    ```", "```kt\n    ...\n    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType);\n\n    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey);\n\n    StoreEntry* findEntry(JNIEnv* pEnv, Store* pStore, jstring pKey);\n\n    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry);\n    #endif\n    ```", "```kt\n    #include \"Store.h\"\n    #include <cstdlib>\n    #include <cstring>\n\n    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType) {\n        return ((pEntry != NULL) && (pEntry->mType == pType));\n    }\n    ...\n    ```", "```kt\n    ...\n    StoreEntry* findEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {\n        StoreEntry* entry = pStore->mEntries;\n        StoreEntry* entryEnd = entry + pStore->mLength;\n\n        // Compare requested key with every entry key currently stored\n        // until we find a matching one.\n        const char* tmpKey = pEnv->GetStringUTFChars(pKey, NULL);\n        while ((entry < entryEnd) && (strcmp(entry->mKey, tmpKey) != 0)) {\n            ++entry;\n        }\n        pEnv->ReleaseStringUTFChars(pKey, tmpKey);\n\n        return (entry == entryEnd) ? NULL : entry;\n    }\n    ...\n    ```", "```kt\n    ...\n    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {\n        // If entry already exists in the store, releases its content\n        // and keep its key.\n        StoreEntry* entry = findEntry(pEnv, pStore, pKey);\n        if (entry != NULL) {\n            releaseEntryValue(pEnv, entry);\n        }\n        // If entry does not exist, create a new entry\n        // right after the entries already stored.\n        else {\n            entry = pStore->mEntries + pStore->mLength;\n\n            // Copies the new key into its final C string buffer.\n            const char* tmpKey = pEnv->GetStringUTFChars(pKey, NULL);\n            entry->mKey = new char[strlen(tmpKey) + 1];\n            strcpy(entry->mKey, tmpKey);\n            pEnv->ReleaseStringUTFChars(pKey, tmpKey);\n\n            ++pStore->mLength;\n        }\n        return entry;\n    }\n    ...\n    ```", "```kt\n    ...\n    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {\n        switch (pEntry->mType) {\n        case StoreType_String:\n            delete pEntry->mValue.mString;\n            break;\n        }\n    }\n    ```", "```kt\n    #include \"com_packtpub_store_Store.h\"\n    #include <cstdlib>\n    #include \"Store.h\"\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jstring JNICALL Java_com_packtpub_store_Store_getString\n      (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n        if (isEntryValid(pEnv, entry, StoreType_String)) {\n            // Converts a C string into a Java String.\n            return pEnv->NewStringUTF(entry->mValue.mString);\n        } else {\n            return NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setString\n      (JNIEnv* pEnv, jobject pThis, jstring pKey, jstring pString) {\n        // Turns the Java string into a temporary C string.\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            entry->mType = StoreType_String;\n            // Copy the temporary C string into its dynamically allocated\n            // final location. Then releases the temporary string.\n            jsize stringLength = pEnv->GetStringUTFLength(pString);\n            entry->mValue.mString = new char[stringLength + 1];\n            // Directly copies the Java String into our new C buffer.\n            pEnv->GetStringUTFRegion(pString, 0, stringLength,\n                                     entry->mValue.mString);\n            // Append the null character for string termination.\n            entry->mValue.mString[stringLength] = '\\0';    }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LOCAL_MODULE    := com_packtpub_store_Store\n    LOCAL_SRC_FILES := com_packtpub_store_Store.cpp Store.cpp\n\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    jsize GetStringUTFLength(jstring string)\n    jsize GetStringLength(jstring string)\n    ```", "```kt\n    const char* GetStringUTFChars(jstring string, jboolean* isCopy)\n    const jchar* GetStringChars(jstring string, jboolean* isCopy)\n    ```", "```kt\n    void ReleaseStringUTFChars(jstring string, const char* utf)\n    void ReleaseStringChars(jstring string, const jchar* chars)\n    ```", "```kt\n    void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf)\n    void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf)\n    ```", "```kt\n    const jchar* GetStringCritical(jstring string, jboolean* isCopy)\n    void ReleaseStringCritical(jstring string, const jchar* carray)\n    ```", "```kt\n    public enum StoreType {\n        Integer,\n        String\n    }\n    ```", "```kt\n    public class Store {\n        ...\n        public native int getCount();\n\n     public native int getInteger(String pKey);\n     public native void setInteger(String pKey, int pInt);\n\n        public native String getString(String pKey);\n        public native void setString(String pKey, String pString);\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            ...\n            private void onGetValue() {\n                ...\n                switch (type) {\n     case Integer:\n     mUIValueEdit.setText(Integer.toString(mStore\n     .getInteger(key)));\n     break;\n                case String:\n                    mUIValueEdit.setText(mStore.getString(key));\n                    break;\n                }\n            }\n            ...\n    ```", "```kt\n            ...\n            private void onSetValue() {\n                ...\n                try {\n                    switch (type) {\n     case Integer:\n     mStore.setInteger(key, Integer.parseInt(value));\n     break;\n                    case String:\n                        mStore.setString(key, value);\n                        break;\n                    }\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n        }\n    }\n    ```", "```kt\n    ...\n    typedef enum {\n     StoreType_Integer,\n        StoreType_String\n    } StoreType;\n    typedef union {\n     int32_t   mInteger;\n        char*     mString;\n    } StoreValue;\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jint JNICALL Java_com_packtpub_store_Store_getInteger\n      (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n        if (isEntryValid(pEnv, entry, StoreType_Integer)) {\n            return entry->mValue.mInteger;\n        } else {\n            return 0;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setInteger\n      (JNIEnv* pEnv, jobject pThis, jstring pKey, jint pInteger) {\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            entry->mType = StoreType_Integer;\n            entry->mValue.mInteger = pInteger;\n        }\n    }\n    ```", "```kt\n    package com.packtpub.store;\n    import android.text.TextUtils;\n    public class Color {\n        private int mColor;\n        public Color(String pColor) {\n            if (TextUtils.isEmpty(pColor)) {\n                throw new IllegalArgumentException();\n            }\n            mColor = android.graphics.Color.parseColor(pColor);\n        }\n        @Override\n        public String toString() {\n            return String.format(\"#%06X\", mColor);\n        }\n    }\n    ```", "```kt\n    public enum StoreType {\n        Integer,\n        String,\n     Color\n    }\n    ```", "```kt\n    public class Store {\n        ...\n     public native Color getColor(String pKey);\n     public native void setColor(String pKey, Color pColor);\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            ...\n            private void onGetValue() {\n                ...\n                switch (type) {\n                ...\n     case Color:\n     mUIValueEdit.setText(mStore.getColor(key)\n                                    .toString());\n     break;\n                }\n            }\n            private void onSetValue() {\n                ...\n                try {\n                    switch (type) {\n                    ...\n     case Color:\n     mStore.setColor(key, new Color(value));\n     break;\n                    }\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n        }\n    }\n    ```", "```kt\n    ...\n    typedef enum {\n        ...\n        StoreType_String,\n     StoreType_Color\n    } StoreType;\n    typedef union {\n        ...\n        char*     mString;\n     jobject   mColor;\n    } StoreValue;\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jobject JNICALL Java_com_packtpub_store_Store_getColor\n      (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n        if (isEntryValid(pEnv, entry, StoreType_Color)) {\n            return entry->mValue.mColor;\n        } else {\n            return NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColor\n      (JNIEnv* pEnv, jobject pThis, jstring pKey, jobject pColor) {\n        // Save the Color reference in the store.\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            entry->mType = StoreType_Color;\n            // The Java Color is going to be stored on the native side.\n            // Need to keep a global reference to avoid a potential\n            // garbage collection after method returns.\n            entry->mValue.mColor = pEnv->NewGlobalRef(pColor);\n        }\n    }\n    ```", "```kt\n    ...\n    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {\n        switch (pEntry->mType) {\n        case StoreType_String:\n            delete pEntry->mValue.mString;\n            break;\n     case StoreType_Color:\n     // Unreferences the object for garbage collection.\n     pEnv->DeleteGlobalRef(pEntry->mValue.mColor);\n     break;\n        }\n    }\n    ```", "```kt\nstatic jobject gMyReference;\nJNIEXPORT void JNICALL Java_MyClass_myMethod(JNIEnv* pEnv,\n                                     jobject pThis, jobject pRef) {\n    gMyReference = pRef;\n    ...\n}\n\n// Later on...\nenv->CallVoidMethod(gMyReference, ...);\n```", "```kt\n    jobject NewLocalRef(jobject ref)\n    ```", "```kt\n    void DeleteLocalRef(jobject localRef)\n    ```", "```kt\n    jint EnsureLocalCapacity(jint capacity)\n    ```", "```kt\n    jint PushLocalFrame(jint capacity)\n    jobject PopLocalFrame(jobject result)\n    ```", "```kt\n    jobject NewGlobalRef(jobject obj)\n    ```", "```kt\n    void DeleteGlobalRef(jobject globalRef)\n    ```", "```kt\n    jboolean IsSameObject(jobject ref1, jobject ref2)\n    ```", "```kt\njweak NewWeakGlobalRef(JNIEnv *env, jobject obj);\nvoid DeleteWeakGlobalRef(JNIEnv *env, jweak obj);\n```", "```kt\njobject myObject = ...;\n// Keep a reference to that object until it is garbage collected.\njweak weakRef = pEnv->NewWeakGlobalRef(myObject);\n...\n\n// Later on, get a real reference, hoping it is still available.\njobject localRef = pEnv->NewLocalRef(weakRef);\nif (!localRef) {\n// Do some stuff...\npEnv->DeleteLocalRef(localRef);\n} else {\n   // Object has been garbage collected, reference is unusable...\n}\n\n...\n// Later on, when weak reference is no more needed.\npEnv->DeleteWeakGlobalRef(weakRef);\n```", "```kt\njboolean IsSameObject(jobject ref1, jobject ref2)\n```", "```kt\n    public enum StoreType {\n        ...\n        Color,\n        IntegerArray,\n        StringArray,\n        ColorArray\n    }\n    ```", "```kt\n    public class Store {\n        ...\n     public native int[] getIntegerArray(String pKey);\n     public native void setIntegerArray(String pKey, int[] pIntArray);\n     public native String[] getStringArray(String pKey);\n     public native void setStringArray(String pKey,\n     String[] pStringArray);\n     public native Color[] getColorArray(String pKey);\n     public native void setColorArray(String pKey,Color[] pColorArray);\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            ...\n            private void onGetValue() {\n                ...\n                switch (type) {\n                ...\n     case IntegerArray:\n     mUIValueEdit.setText(Ints.join(\";\", mStore\n     .getIntegerArray(key)));\n     break;\n     case StringArray:\n     mUIValueEdit.setText(Joiner.on(\";\").join(\n     mStore.getStringArray(key)));\n     break;\n     case ColorArray:\n     mUIValueEdit.setText(Joiner.on(\";\").join(mStore\n     .getColorArray(key)));\n     break;            case IntegerArray:\n                }\n            }\n            ...\n    ```", "```kt\n            ...\n            private void onSetValue() {\n                ...\n                try {\n                    switch (type) {\n                    ...\n                    case IntegerArray:\n     mStore.setIntegerArray(key, Ints.toArray(\n     stringToList(new Function<String, Integer>() {\n     public Integer apply(String pSubValue) {\n     return Integer.parseInt(pSubValue);\n     }\n     }, value)));\n     break;\n     case StringArray:\n     String[] stringArray = value.split(\";\");\n     mStore.setStringArray(key, stringArray);\n     break;\n     case ColorArray:\n     List<Color> idList = stringToList(\n     new Function<String, Color>() {\n     public Color apply(String pSubValue) {\n     return new Color(pSubValue);\n     }\n     }, value);\n     mStore.setColorArray(key, idList.toArray(\n     new Color[idList.size()]));\n     break;\n                    }\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n    ```", "```kt\n            ...\n            private <TType> List<TType> stringToList(\n                            Function<String, TType> pConversion,\n                            String pValue) {\n                String[] splitArray = pValue.split(\";\");\n                List<String> splitList = Arrays.asList(splitArray);\n                return Lists.transform(splitList, pConversion);\n            }\n        }\n    }\n    ```", "```kt\n    ...\n    typedef enum {\n        ...\n        StoreType_Color,\n     StoreType_IntegerArray,\n     StoreType_StringArray,\n     StoreType_ColorArray\n    } StoreType;\n\n    typedef union {\n        ...\n        jobject   mColor;\n     int32_t*  mIntegerArray;\n     char**    mStringArray;\n     jobject*  mColorArray;\n    } StoreValue;\n    ...\n    ```", "```kt\n    ...\n    typedef struct {\n        char* mKey;\n        StoreType mType;\n        StoreValue mValue;\n     int32_t mLength;\n    } StoreEntry;\n    ...\n    ```", "```kt\n    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {\n        switch (pEntry->mType) {\n        ...\n     case StoreType_IntegerArray:\n     delete[] pEntry->mValue.mIntegerArray;\n     break;\n     case StoreType_StringArray:\n     // Destroys every C string pointed by the String array\n     // before releasing it.\n     for (int32_t i = 0; i < pEntry->mLength; ++i) {\n     delete pEntry->mValue.mStringArray[i];\n     }\n     delete[] pEntry->mValue.mStringArray;\n     break;\n     case StoreType_ColorArray:\n     // Unreferences every Id before releasing the Id array.\n     for (int32_t i = 0; i < pEntry->mLength; ++i) {\n     pEnv->DeleteGlobalRef(pEntry->mValue.mColorArray[i]);\n     }\n     delete[] pEntry->mValue.mColorArray;\n     break;\n        }\n    }\n    ...\n    ```", "```kt\n    #include \"com_packtpub_store_Store.h\"\n    #include <cstdint>\n    #include <cstdlib>\n    #include \"Store.h\"\n    ...\n    ```", "```kt\n    ...\n    static jclass StringClass;\n    static jclass ColorClass;\n\n    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n     JNIEnv *env;\n     if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {\n     abort();\n     }\n     // If returned class is null, an exception is raised by the VM.\n     jclass StringClassTmp = env->FindClass(\"java/lang/String\");\n     if (StringClassTmp == NULL) abort();\n     StringClass = (jclass) env->NewGlobalRef(StringClassTmp);\n     env->DeleteLocalRef(StringClassTmp);\n     jclass ColorClassTmp = env->FindClass(\"com/packtpub/store/Color\");\n     if (ColorClassTmp == NULL) abort();\n     ColorClass = (jclass) env->NewGlobalRef(ColorClassTmp);\n     env->DeleteLocalRef(ColorClassTmp);\n        // Store initialization.\n        gStore.mLength = 0;\n        return JNI_VERSION_1_6;\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jintArray JNICALL\n    Java_com_packtpub_store_Store_getIntegerArray\n      (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n        if (isEntryValid(pEnv, entry, StoreType_IntegerArray)) {\n            jintArray javaArray = pEnv->NewIntArray(entry->mLength);\n            pEnv->SetIntArrayRegion(javaArray, 0, entry->mLength,\n                                    entry->mValue.mIntegerArray);\n            return javaArray;\n        } else {\n            return NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setIntegerArray\n      (JNIEnv* pEnv, jobject pThis, jstring pKey,\n       jintArray pIntegerArray) {\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            jsize length = pEnv->GetArrayLength(pIntegerArray);\n            int32_t* array = new int32_t[length];\n            pEnv->GetIntArrayRegion(pIntegerArray, 0, length, array);\n\n            entry->mType = StoreType_IntegerArray;\n            entry->mLength = length;\n            entry->mValue.mIntegerArray = array;\n        }\n    }\n    ...\n    ```", "```kt\n...\nJNIEXPORT jobjectArray JNICALL\nJava_com_packtpub_store_Store_getStringArray\n  (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n    StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n    if (isEntryValid(pEnv, entry, StoreType_StringArray)) {\n        // An array of String in Java is in fact an array of object.\n        jobjectArray javaArray = pEnv->NewObjectArray(entry->mLength,\n                StringClass, NULL);\n        // Creates a new Java String object for each C string stored.\n        // Reference to the String can be removed right after it is\n        // added to the Java array, as the latter holds a reference\n        // to the String object.\n        for (int32_t i = 0; i < entry->mLength; ++i) {\n            jstring string = pEnv->NewStringUTF(\n                    entry->mValue.mStringArray[i]);\n            // Puts the new string in the array\n            pEnv->SetObjectArrayElement(javaArray, i, string);\n            // Do it here to avoid holding many useless local refs.\n            pEnv->DeleteLocalRef(string);\n        }\n        return javaArray;\n    } else {\n        return NULL;\n    }\n}\n...\n```", "```kt\n...\nJNIEXPORT void JNICALL Java_com_packtpub_store_Store_setStringArray\n  (JNIEnv* pEnv, jobject pThis, jstring pKey,\n   jobjectArray pStringArray) {\n    // Creates a new entry with the new String array.\n    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n    if (entry != NULL) {\n        // Allocates an array of C string.\n        jsize length = pEnv->GetArrayLength(pStringArray);\n        char** array = new char*[length];\n        // Fills the C array with a copy of each input Java string.\n        for (int32_t i = 0; i < length; ++i) {\n            // Gets the current Java String from the input Java array.\n            // Object arrays can be accessed element by element only.\n            jstring string = (jstring)\n                         pEnv->GetObjectArrayElement(pStringArray, i);\n            jsize stringLength = pEnv->GetStringUTFLength(string);\n            array[i] = new char[stringLength + 1];\n            // Directly copies the Java String into our new C buffer.\n            pEnv->GetStringUTFRegion(string,0,stringLength, array[i]);\n            // Append the null character for string termination.\n            array[i][stringLength] = '\\0';\n            // No need to keep a reference to the Java string anymore.\n            pEnv->DeleteLocalRef(string);\n        }\n        entry->mType = StoreType_StringArray;\n        entry->mLength = length;\n        entry->mValue.mStringArray = array;\n    }\n}\n```", "```kt\n...\nJNIEXPORT jobjectArray JNICALL\nJava_com_packtpub_store_Store_getColorArray\n  (JNIEnv* pEnv, jobject pThis, jstring pKey) {\n    StoreEntry* entry = findEntry(pEnv, &gStore, pKey);\n    if (isEntryValid(pEnv, entry, StoreType_ColorArray)) {\n        // Creates a new array with objects of type Id.\n        jobjectArray javaArray = pEnv->NewObjectArray(entry->mLength,\n                ColorClass, NULL);\n        // Fills the array with the Color objects stored on the native\n        // side, which keeps a global reference to them. So no need\n        // to delete or create any reference here.\n        for (int32_t i = 0; i < entry->mLength; ++i) {\n            pEnv->SetObjectArrayElement(javaArray, i,\n                                        entry->mValue.mColorArray[i]);\n        }\n        return javaArray;\n    } else {\n        return NULL;\n    }\n}\n...\n```", "```kt\n...\nJNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColorArray\n  (JNIEnv* pEnv, jobject pThis, jstring pKey,\n   jobjectArray pColorArray) {\n    // Saves the Color array in the store.\n    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n    if (entry != NULL) {\n        // Allocates a C array of Color objects.\n        jsize length = pEnv->GetArrayLength(pColorArray);\n        jobject* array = new jobject[length];\n        // Fills the C array with a copy of each input Java Color.\n        for (int32_t i = 0; i < length; ++i) {\n            // Gets the current Color object from the input Java array.\n            // Object arrays can be accessed element by element only.\n            jobject localColor = pEnv->GetObjectArrayElement(\n                    pColorArray, i);\n            // The Java Color is going to be stored on the native side\n            // Need to keep a global reference to avoid a potential\n            // garbage collection after method returns.\n            array[i] = pEnv->NewGlobalRef(localColor);\n            // We have a global reference to the Color, so we can now\n            // get rid of the local one.\n            pEnv->DeleteLocalRef(localColor);\n        }\n        entry->mType = StoreType_ColorArray;\n        entry->mLength = length;\n        entry->mValue.mColorArray = array;\n    }\n}\n```", "```kt\n    jintArray NewIntArray(jsize length)\n    ```", "```kt\n    jsize GetArrayLength(jarray array)\n    ```", "```kt\n    jint* GetIntArrayElements(jintArray array, jboolean* isCopy)\n    ```", "```kt\n        void ReleaseIntArrayElements(jintArray array, jint* elems, jint mode)\n        ```", "```kt\n    void GetIntArrayRegion(jintArray array, jsize start, jsize len,\n                           jint* buf)\n    ```", "```kt\n    void SetIntArrayRegion(jintArray array, jsize start, jsize len,\n                           const jint* buf)\n    ```", "```kt\n    void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy)\n    void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode)\n    ```", "```kt\n...\nJNIEXPORT void JNICALL Java_com_packtpub_store_Store_setBooleanArray\n  (JNIEnv* pEnv, jobject pThis, jstring pKey,\n   jbooleanArray pBooleanArray) {\n    // Finds/creates an entry in the store and fills its content.\n    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n    if (entry != NULL) {\n        entry->mType = StoreType_BooleanArray;\n        jsize length = pEnv->GetArrayLength(pBooleanArray);\n        uint8_t* array = new uint8_t[length];\n        // Retrieves array content.\n jboolean* arrayTmp = pEnv->GetBooleanArrayElements(\n pBooleanArray, NULL);\n        memcpy(array, arrayTmp, length * sizeof(uint8_t));\n        pEnv->ReleaseBooleanArrayElements(pBooleanArray, arrayTmp, 0);\n        entry->mType = StoreType_BooleanArray;\n        entry->mValue.mBooleanArray = array;\n        entry->mLength = length;\n    }\n}\n...\n```", "```kt\n    jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement);\n    ```", "```kt\n    jsize GetArrayLength(jarray array)\n    ```", "```kt\n    jobject GetObjectArrayElement(jobjectArray array, jsize index)\n    ```", "```kt\n    void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)\n    ```", "```kt\n    package com.packtpub.exception;\n\n    public class InvalidTypeException extends Exception {\n        public InvalidTypeException(String pDetailMessage) {\n            super(pDetailMessage);\n        }\n    }\n    ```", "```kt\n    public class Store {\n        ...\n        public native int getInteger(String pKey)\n     throws NotExistingKeyException, InvalidTypeException;\n        public native void setInteger(String pKey, int pInt);\n        ...\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment {\n            ...\n            private void onGetValue() {\n                ...\n                try {\n                    switch (type) {\n                    ...\n                }\n     // Process any exception raised while retrieving data.\n     catch (NotExistingKeyException eNotExistingKeyException) {\n     displayMessage(eNotExistingKeyException.getMessage());\n     } catch (InvalidTypeException eInvalidTypeException) {\n     displayMessage(eInvalidTypeException.getMessage());\n                }\n            }\n    ```", "```kt\n            private void onSetValue() {\n                ...\n                try {\n                    ...\n                } catch (NumberFormatException eNumberFormatException) {\n                    displayMessage(\"Incorrect value.\");\n     } catch (StoreFullException eStoreFullException) {\n     displayMessage(eStoreFullException.getMessage());\n                } catch (Exception eException) {\n                    displayMessage(\"Incorrect value.\");\n                }\n                updateTitle();\n            }\n            ...\n        }\n    }\n    ```", "```kt\n    ...\n    void throwInvalidTypeException(JNIEnv* pEnv);\n\n    void throwNotExistingKeyException(JNIEnv* pEnv);\n\n    void throwStoreFullException(JNIEnv* pEnv);\n    #endif\n    ```", "```kt\n    ...\n    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType) {\n        if (pEntry == NULL) {\n            throwNotExistingKeyException(pEnv);\n        } else if (pEntry->mType != pType) {\n            throwInvalidTypeException(pEnv);\n        }\n        return !pEnv->ExceptionCheck();\n    }\n    ...\n    ```", "```kt\n    ...\n    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {\n        // If entry already exists in the store, releases its content\n        // and keep its key.\n        StoreEntry* entry = findEntry(pEnv, pStore, pKey);\n        if (entry != NULL) {\n            releaseEntryValue(pEnv, entry);\n        }\n        // If entry does not exist, create a new entry\n        // right after the entries already stored.\n        else {\n            // Checks store can accept a new entry.\n     if (pStore->mLength >= STORE_MAX_CAPACITY) {\n     throwStoreFullException(pEnv);\n     return NULL;\n            }\n            entry = pStore->mEntries + pStore->mLength;\n            // Copies the new key into its final C string buffer.\n            ...\n        }\n        return entry;\n    }\n    ...\n    ```", "```kt\n...\nvoid throwNotExistingKeyException(JNIEnv* pEnv) {\n    jclass clazz = pEnv->FindClass(\n                    \"com/packtpub/exception/NotExistingKeyException\");\n    if (clazz != NULL) {\n        pEnv->ThrowNew(clazz, \"Key does not exist.\");\n    }\n    pEnv->DeleteLocalRef(clazz);\n}\n```", "```kt\n    // Raise an exception\n    jclass clazz = pEnv->FindClass(\"java/lang/RuntimeException\");\n    if (clazz != NULL) {\n      pEnv->ThrowNew(clazz, \"Oups an exception.\");\n    }\n    pEnv->DeleteLocalRef(clazz);\n\n    ...\n\n    // Detect and catch the exception by clearing it.\n    jthrowable exception = pEnv->ExceptionOccurred();\n    if (exception) {\n      // Do something...\n      pEnv->ExceptionDescribe();\n      pEnv->ExceptionClear();\n      pEnv->DeleteLocalRef(exception);\n    }\n    ```", "```kt\n    jint ThrowNew(jclass clazz, const char* message)\n    ```", "```kt\n    jint Throw(jthrowable obj)\n    ```", "```kt\n    jboolean ExceptionCheck()\n    ```", "```kt\n    jthrowable ExceptionOccurred()\n    ```", "```kt\n    void ExceptionDescribe()\n    ```", "```kt\n    void ExceptionClear()\n    ```"]