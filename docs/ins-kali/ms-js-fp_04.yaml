- en: Behaving Properly - Pure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为得当-纯函数
- en: In [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*, we considered functions as the key elements in FP,
    went into detail about arrow functions, and introduced some concepts such as injection,
    callbacks, polyfilling, and stubbing. Now, in this chapter, we'll have the opportunity
    to revisit or apply some of those ideas, while we also...
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)中，*从函数开始-核心概念*，我们将函数视为FP中的关键元素，详细介绍了箭头函数，并介绍了一些概念，如注入、回调、填充和存根。现在，在这一章中，我们将有机会重新审视或应用其中一些想法，同时我们也...
- en: Consider the notion of *purity*, and why we should care about *pure functions*
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑*纯度*的概念，以及为什么我们应该关心*纯函数*
- en: Examine the concept of *Referential Transparency*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查*引用透明性*的概念
- en: Recognize the problems implied by side effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到副作用所暗示的问题
- en: Show some advantages of pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示纯函数的一些优势
- en: Describe the main causes of impure functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不纯函数的主要原因
- en: Find ways to minimize the number of impure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到减少不纯函数数量的方法
- en: Focus on ways of testing both pure and impure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于测试纯函数和不纯函数的方法
- en: Pure functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'Pure functions behave in the same way as mathematical functions and provide
    diverse benefits. A function may be considered to be pure if it satisfies two
    conditions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的行为方式与数学函数相同，并提供各种好处。如果函数满足两个条件，可以认为函数是纯的：
- en: '**Given the same arguments, the function always calculates and returns the
    same result**, no matter how many times it''s invoked, or in which conditions
    you call it. This result value cannot depend on any *outside*information or state,
    which could change during the program execution, and cause it to return a different
    value. Nor can the function result depend on I/O results, random numbers, or some
    other external variable, not directly controllable, value.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定相同的参数，函数总是计算并返回相同的结果**，无论调用多少次，或者在什么条件下调用它。这个结果值不能依赖于任何*外部*信息或状态，这些信息在程序执行期间可能会发生变化，并导致它返回不同的值。函数结果也不能依赖于I/O结果、随机数或其他外部变量，这些变量不是直接可控的值。'
- en: '**When calculating its result, the function doesn''t cause any observable *side
    effect***, including output to I/O devices, mutation of objects, change to program
    state outside of the function, and so on.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在计算其结果时，函数不会引起任何可观察的*副作用***，包括输出到I/O设备，对象的突变，函数外部程序状态的改变等等。'
- en: If you want, you can simply say that pure functions don't depend on, and don't
    modify, anything outside its scope, and do always return the same result for the
    same input arguments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以简单地说纯函数不依赖于，也不修改其范围之外的任何东西，并且总是对相同的输入参数返回相同的结果。
- en: Another word used in this context is *idempotency*, but it's not exactly the
    same. An idempotent function can be called as many times as desired, and will
    always produce the same result. However, this doesn't imply that the function
    is free from side effects. Idempotency is usually mentioned in the context of
    RESTful services, and a simple example showing the difference between purity and
    idempotency follows. A `PUT` call would cause a database record to be updated
    (a side effect) but if you repeat the call, the element will not be further modified,
    so the global state of the database won't change any further.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下还有一个词叫做*幂等性*，但它并不完全相同。一个幂等函数可以被调用任意次，并且总是产生相同的结果。然而，这并不意味着函数没有副作用。幂等性通常在RESTful服务的背景下提到，并且一个简单的例子展示了纯度和幂等性之间的区别。一个`PUT`调用会导致数据库记录被更新（一个副作用），但如果你重复调用，元素将不会被进一步修改，因此数据库的全局状态不会再发生变化。
- en: We might also invoke a software design principle, and remind ourselves that
    a function should *do one thing, only one thing, and nothing but that thing*.
    If a function does anything else, and has some hidden functionality, that dependency
    on the state will mean that we won't be able to predict the function's output
    and make things harder for us as developers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以引用一个软件设计原则，并提醒自己函数应该*只做一件事，只做一件事，而且只做那件事*。如果一个函数做了其他事情，并且有一些隐藏的功能，那么对状态的依赖将意味着我们无法预测函数的输出，并且会让开发人员的工作变得更加困难。
- en: Let's get into these conditions in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这些条件。
- en: Referential Transparency
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: In mathematics, *Referential Transparency* is the property that lets you replace
    an expression with its value, and not change the results of whatever you were
    doing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*引用透明性*是一种属性，它允许您用其值替换表达式，而不改变您正在进行的任何操作的结果。
- en: The counterpart of *Referential Transparency*is, appropriately enough, *Referential
    Opacity*. A referentially opaque function cannot guarantee always producing the
    same result, even when called with the same arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用透明性*的对应物是*引用不透明性*。引用不透明的函数不能保证始终产生相同的结果，即使使用相同的参数调用。'
- en: 'To give a simple example, when an optimizing compiler decides to do *constant
    folding* and replace a sentence like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，当优化编译器决定进行*常量折叠*并替换句子时：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'with:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'or, even better, directly with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的是，直接使用：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: to save execution time, it's taking advantage of the fact that all mathematical
    expressions and functions are (by definition) referentially transparent.  On the
    other hand, if the compiler cannot predict the output of a given expression, it
    won't be able to optimize the code in any fashion, and the calculation will have
    to be done at runtime.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省执行时间，它利用了所有数学表达式和函数（根据定义）都是引用透明的事实。另一方面，如果编译器无法预测给定表达式的输出，它将无法以任何方式优化代码，计算将不得不在运行时进行。
- en: In lambda calculus, if you replace the value of an expression involving a function,
    with the calculated value for the function, that operation is called a β (beta)
    reduction. Note that you can only do this safely with referentially transparent
    functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算中，如果你用函数的计算值替换涉及函数的表达式的值，这个操作被称为β（beta）规约。请注意，你只能安全地对引用透明的函数进行这样的操作。
- en: 'All arithmetic expressions (involving both mathematical operators and functions)
    are referentially transparent: *22*9* can always be replaced by 198\. Expressions
    involving I/O are not transparent, given that their results cannot be known until
    they are executed. For the same reason, expressions involving date- and time-related
    functions, or random numbers, are also not transparent.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有算术表达式（涉及数学运算符和函数）都是引用透明的：*22*9*总是可以被198替换。涉及I/O的表达式不是透明的，因为它们的结果在执行之前无法知道。出于同样的原因，涉及日期和时间相关函数或随机数的表达式也不是透明的。
- en: With regard to JS functions, you may produce yourself, it's quite easy to write
    some that won't fulfill the *referential transparency*condition. In fact, a function
    is not even required to return a value, though the JS interpreter will return
    an undefined value in that situation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JS函数，你可能会自己编写一些不满足*引用透明*条件的函数。事实上，函数甚至不需要返回一个值，尽管JS解释器会在这种情况下返回一个未定义的值。
- en: Some languages distinguish between functions, which are expected to return some
    value, and procedures, which do not return anything, but that's not the case with
    JS. Also, there are some languages that provide means to ensure that functions
    are referentially transparent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言区分函数和过程，预期函数返回某个值，而过程不返回任何东西，但JS不是这种情况。此外，有些语言提供手段来确保函数是引用透明的。
- en: 'If you wanted to, you could classify JS functions as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意的话，你可以将JS函数分类为：
- en: '**pure functions**: that return a value depending only on its arguments, and
    have no side effects whatsoever'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：它们根据其参数返回一个值，并且没有任何副作用'
- en: '**side effects**: that don''t return anything (actually, JS has those functions
    return an `undefined` value, but that''s not relevant here), but do produce some
    kind of side effects'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副作用**：它们不返回任何东西（实际上，JS让这些函数返回一个`undefined`值，但这在这里并不重要），但会产生某种副作用'
- en: '**functions with side effects**: meaning they return some value (which may
    not only depend on the function arguments and also involve side effects)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有副作用的函数**：意味着它们返回一些值（这些值可能不仅取决于函数参数，还涉及副作用）'
- en: In FP, much emphasis is put upon the first group, referentially transparent
    functions. Not only a compiler can reason about the program behavior (and thus
    be enabled to optimize the generated code), but also the programmer can more easily
    reason about the program and the relationship between its components. In turn,
    this can help prove the correctness of an algorithm, or to optimize the code by
    replacing a function with an equivalent one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，非常强调第一组引用透明函数。不仅编译器可以推断程序行为（从而能够优化生成的代码），而且程序员也可以更容易地推断程序和其组件之间的关系。反过来，这可以帮助证明算法的正确性，或者通过用等效函数替换一个函数来优化代码。
- en: Side effects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: What are *side effects*? We can define those as some change in state, or some
    interaction with outside elements (the user, a web service, another computer,
    whatever) that occurs during the execution of some calculations or process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*副作用*？我们可以将其定义为在执行某些计算或过程期间发生的状态变化或与外部元素（用户、网络服务、另一台计算机等）的交互。
- en: There's a possible misunderstanding as to the scope of this meaning. In common
    daily speech, when you speak of *side effects*, it's a bit like talking of *collateral
    damage*--some *unintended* consequences for a given action. However, in computing,
    we include every possible effect or change outside the function. If you write
    a function that is meant to do a `console.log()` call to display some result,
    that would be considered a side effect, even if it's exactly what you intended
    the function to do in the first place!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个意义的范围可能存在一些误解。在日常语言中，当你谈论*副作用*时，这有点像谈论*附带损害*--对于给定行动的一些*意外*后果。然而，在计算中，我们包括函数外的每一个可能的效果或变化。如果你编写一个旨在执行`console.log()`调用以显示一些结果的函数，即使这正是你首先打算让函数执行的，它也会被视为副作用！
- en: Usual side effects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通常的副作用
- en: 'There are (too many!) things that are considered side effects. In JS programming,
    including both front- and back-end coding, the more common ones you may find,
    include:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有（太多！）被认为是副作用的事情。在JS编程中，包括前端和后端编码，你可能会发现更常见的副作用包括：
- en: Changing global variables.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变全局变量。
- en: Mutating objects received as arguments.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变接收的对象。
- en: Doing any kind of I/O, such as showing an alert message or logging some text.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行任何类型的I/O，比如显示警报消息或记录一些文本。
- en: Working with, and changing, the filesystem.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和更改文件系统。
- en: Updating a database.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库。
- en: Calling a web service.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用网络服务。
- en: Querying or modifying the DOM.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询或修改DOM。
- en: Triggering any external process.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发任何外部进程。
- en: 'And, finally, just calling some other function that happens to produce a side
    effect of its own. You could say that impurity is contagious: a function that
    calls an impure function automatically becomes impure on its own!'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，只是调用一些其他函数，这些函数恰好会产生自己的副作用。你可以说不纯度是具有传染性的：调用不纯的函数的函数会自动变得不纯！
- en: With this definition, let's start considering what can cause functional impurity
    (or *referential opaqueness*, as we saw).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，让我们开始考虑什么会导致函数不纯（或者*引用不透明*，正如我们所看到的）。
- en: Global state
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局状态
- en: 'Of all the preceding points, the most common reason is the usage of non-local
    variables, sharing a global state with other parts of the program. Since pure
    functions, by definition, always return the same output value given the same input
    arguments, if a function refers to anything outside its internal state, it automatically
    becomes impure. Furthermore, and this is a hindrance to debugging, to understand
    what a function did, you must understand how the state got its current values,
    and that means understanding all the past history from your program: not easy!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述观点中，最常见的原因是使用非本地变量，与程序的其他部分共享全局状态。由于纯函数根据定义，始终返回相同的输出值，给定相同的输入参数，如果函数引用其内部状态之外的任何东西，它就会自动变得不纯。此外，这对于调试是一个障碍，要理解函数的作用，你必须了解状态如何得到其当前值，这意味着要理解程序的所有过去历史：这并不容易！
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isOldEnough()`function correctly detects if a person is at least 18 years
    old, but it depends on an external variable for that (the variable is good for
    2017 only). You cannot tell what the function does, unless you know about the
    external variable, and how it got its value. Testing would also be hard; you'd
    have to remember creating the global `limitYear` variable, or all your tests would
    fail to run. Even though the function works, the implementation isn't the best
    possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOldEnough()`函数正确检测一个人是否至少18岁，但它依赖于一个外部变量（该变量仅适用于2017年）。除非你知道外部变量及其值是如何得到的，否则你无法知道函数的作用。测试也很困难；你必须记住创建全局`limitYear`变量，否则所有的测试都将无法运行。尽管函数可以工作，但实现并不是最佳的。'
- en: 'There is an exception to this rule. Check out the following case: is the `circleArea` function,
    which calculates the area of a circle given its radius, pure or not?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个例外。看看下面的情况：`circleArea`函数，它根据半径计算圆的面积，是纯的还是不纯的？
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though the function is accessing an external state, the fact that `PI`
    is a constant (and thus cannot be modified) would allow substituting it inside
    `circleArea` with no functional change, and so we should accept that the function
    is pure. The function will always return the same value for the same argument,
    and thus fulfills our purity requirements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数正在访问外部状态，但`PI`是一个常数（因此不能被修改），允许在`circleArea`中替换它而不改变功能，因此我们应该接受函数是纯净的。对于相同的参数，函数将始终返回相同的值，因此满足我们的纯度要求。
- en: Even if you were to use `Math.PI` instead of a constant as we defined (a better
    idea, by the way) the argument would still be the same; the constant cannot be
    changed, so the function remains pure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用`Math.PI`而不是我们定义的常数（顺便说一句，这是一个更好的主意），参数仍然是相同的；常数是不能改变的，所以函数保持纯净。
- en: Inner state
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部状态
- en: 'The notion is also extended to internal variables, in which a local state is
    stored, and then used for future calls. In this case, the external state is unchanged,
    but there are side effects that imply future differences as to the returned values
    from the function. Let''s imagine a `roundFix()` rounding function, that takes
    into account if it has been rounding too much upwards or downwards, so next time
    it will round the other way, to make the accumulated difference closer to zero:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也适用于内部变量，其中存储了本地状态，然后用于将来的调用。在这种情况下，外部状态没有改变，但是有一些副作用意味着未来从函数返回的值会有所不同。让我们想象一个`roundFix()`四舍五入函数，它考虑到是否已经过多地向上或向下四舍五入，所以下次它将以另一种方式四舍五入，使累积差异更接近零：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some comments regarding this function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个函数的一些评论：
- en: 'The `console.log()` line is just for the sake of this example; it wouldn''t
    be included in the real-world function. It lists the accumulated difference up
    to the point, and the result it will return: the given number rounded up or down.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log()`行只是为了这个例子; 它不会包含在真实世界的函数中。它列出了到目前为止的累积差异，以及它将返回的结果：给定数字四舍五入的结果。'
- en: We are using the IIFE pattern that we saw in the `myCounter()` example, in the *Immediate
    Invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, in order to get a hidden internal
    variable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用IIFE模式，这是我们在“myCounter()”示例中看到的，在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*立即调用*部分，*从函数开始-核心概念*，以便获得隐藏的内部变量。
- en: 'The `nRounded` calculation could also be written as`Math[accum > 0 ? "ceil":
    "floor"](n)` -- we test `accum` to see what method to invoke (`"ceil"` or `"floor"`)
    and then use the `Object["method"]` notation to indirectly invoke `Object.method()`.
    The way we used it, I think, is more clear, but I just wanted to give you a heads
    up in case you happen to find this other coding style.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nRounded`的计算也可以写成`Math[accum > 0 ? "ceil": "floor"](n)`--我们测试`accum`来看要调用什么方法（“ceil”或“floor”），然后使用`Object["method"]`表示法间接调用`Object.method()`。我们使用的方式更清晰，但我只是想提醒你，如果你碰巧发现这种其他编码风格。'
- en: 'Running this function with just two values (recognize them?) shows that results
    are not always the same for a given input. The *result* part of the console log
    shows how the value got rounded, up or down:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用两个值（认出它们吗？）运行此函数显示，对于给定的输入，结果并不总是相同。控制台日志的*结果*部分显示了值是如何四舍五入的，向上还是向下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first time around, `accum` is zero, so 3.14159 gets rounded down, and `accum`
    becomes `0.14159` in our favor. The second time, since `accum` is positive (meaning
    we have been rounding in our favor) then 2.71828 gets rounded up to 3, and now
    `accum` becomes negative. The third time, the same 2.71828 value gets rounded
    down to 2, because then the accumulated difference was negative; we got different
    values for the same input! The rest of the example is similar; you can get a same
    value rounded up or down, depending on the accumulated differences, because the
    function's result depends on its inner state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，`accum`是零，所以3.14159被舍入，`accum`变成了`0.14159`，对我们有利。第二次，因为`accum`是正数（意味着我们一直在我们的利益上四舍五入），所以2.71828被舍入为3，现在`accum`变成了负数。第三次，相同的2.71828值被舍入为2，因为累积的差值是负的；我们得到了相同输入的不同值！其余的例子类似；你可以得到相同的值被舍入为上或下，取决于累积的差异，因为函数的结果取决于它的内部状态。
- en: This usage of internal state, is why many FPers consider that using objects
    is potentially bad. In OOP, we developers are used to storing information (attributes)
    and using them for future calculations. However, this usage is considered impure,
    insofar repeated method calls may return different values, despite the same arguments
    being passed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用内部状态的方式，是为什么许多FPers认为使用对象可能是不好的。在OOP中，我们开发人员习惯于存储信息（属性）并将它们用于未来的计算。然而，这种用法被认为是不纯的，因为尽管传递相同的参数，重复的方法调用可能返回不同的值。
- en: Argument mutation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数突变
- en: 'You also need to be aware of the possibility that an impure function will modify
    its arguments. In JS, arguments are passed by value, except in the case of arrays
    and objects, which are passed by reference. This implies that any modification
    to the parameters of the function, will effect an actual modification of the original
    object or array. This can be furthermore obscured by the fact that there are several
    *mutator* methods, that change the underlying objects by definition. For example,
    say you wanted a function that would find the maximum element of an array of strings
    (of course, if it were an array of numbers, you could simply use `Math.max()`
    with no further ado). A short implementation could be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要意识到一个不纯的函数可能会修改它的参数。在JS中，参数是按值传递的，除了数组和对象，它们是按引用传递的。这意味着对函数参数的任何修改都会影响原始对象或数组的实际修改。这可能会更加模糊，因为有几种*mutator*方法，它们根据定义改变了底层对象。例如，假设你想要一个函数，它会找到一个字符串数组的最大元素（当然，如果它是一个数字数组，你可以简单地使用`Math.max()`而无需进一步操作）。一个简短的实现可能如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function does provide the correct result (and if you worry about foreign
    languages, we already saw a way around that in the *Injection: Sorting it out* section of [Chapter
    3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with Functions -
    A Core Concept*), but it has a defect:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数确实提供了正确的结果（如果你担心外语，我们已经在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*注入：解决问题*部分看到了解决方法，*从函数开始-核心概念*），但它有一个缺陷：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Oops, the original array was modified; a side effect by definition! If you were
    to call `maxStrings(countries)` again, instead of returning the same result as
    before, it would produce another value; clearly, not a pure function. In this
    case, a quick solution is to work on a copy of the array (and we can use the spread
    operator to help), but we'll be dealing with more ways of avoiding these sort
    of problems in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability:*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的是，原始数组被修改了；这是根据定义的副作用！如果你再次调用`maxStrings(countries)`，而不是返回与之前相同的结果，它会产生另一个值；显然，这不是一个纯函数。在这种情况下，一个快速的解决方法是对数组的副本进行操作（我们可以使用扩展运算符来帮助），但我们将在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中处理更多避免这类问题的方法，*确保纯度-不可变性*：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Troublesome functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 麻烦的函数
- en: 'Finally, some functions also cause problems. For instance, `Math.random()`
    is impure: it doesn''t always return the same value -- and it would certainly
    beat its purpose if it did! Furthermore, each call to the function modifies a
    global *seed*value, from which the next *random* value will be calculated.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些函数也会引起问题。例如，`Math.random()`是不纯的：它不总是返回相同的值--如果它这样做了，它肯定会打破它的目的！此外，对该函数的每次调用都会修改全局*种子*值，从而计算下一个*随机*值。
- en: The fact that *random*numbers are actually calculated by an internal function,
    and thus not random at all (if you know the formula that's used, and the initial
    value of the seed) implies that *pseudorandom* would be a better denomination
    for them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机*数字实际上是由内部函数计算的，因此根本不是随机的（如果你知道使用的公式和种子的初始值），这意味着*伪随机*可能更合适。'
- en: 'For instance, consider this function that generates random letters (`"A"` to
    `"Z"`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个生成随机字母（`"A"`到`"Z"`）的函数：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The fact that it receives no arguments, but is expected to produce *different*
    results upon each call, clearly points out that this function is impure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不接受任何参数，但是预期每次调用都会产生*不同*的结果，这清楚地表明这个函数是不纯的。
- en: Check [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
    for the explanation for the `getRandomLetter()` function I wrote, and[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
    for the `.charCodeAt()` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我写的`getRandomLetter()`函数的解释，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)，以及[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)的`.charCodeAt()`方法。
- en: 'Impurity can be inherited by calling functions. If a function uses an impure
    function, it immediately becomes impure itself. We might want to use `getRandomLetter()` in
    order to generate random filenames, with an optional given extension:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数会继承不纯性。如果一个函数使用了不纯的函数，它立即变得不纯。我们可能想要使用`getRandomLetter()`来生成随机文件名，还可以选择给定的扩展名：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we will see a more functional way of initializing array `namePart`,
    by using `map()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中，*声明式编程——更好的风格*，我们将看到一种更加函数式的初始化数组`namePart`的方法，使用`map()`。
- en: 'Because of its usage of `getRandomLetter()`, `getRandomFileName()` is also
    impure, though it performs as expected:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它使用了`getRandomLetter()`，`getRandomFileName()`也是不纯的，尽管它的表现如预期：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep this function in mind; we'll see some ways around the unit testing problem
    later in this chapter, and we'll rewrite it a bit to help out with that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个函数；我们稍后会在本章解决单元测试问题的一些方法，并稍作修改以帮助解决这个问题。
- en: 'The consideration about impurity also extends to functions that access the
    current time or date, because their results will depend on an outside condition
    (namely the time of the day) that is part of the *global state*of the application.
    We could rewrite our `isOldEnough()` function to remove the dependency upon a
    global variable, but it wouldn''t help much:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问当前时间或日期的函数，不纯性的考虑也适用，因为它们的结果将取决于外部条件（即一天中的时间），这是应用程序的*全局状态*的一部分。我们可以重写我们的`isOldEnough()`函数，以消除对全局变量的依赖，但这并没有太大帮助：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A problem has been removed --the new `isOldEnough2()`function is now *safer*.
    Also, as long as you don''t use it near midnight just before New Year''s Day,
    it will consistently return the same results, so you could say, paraphrasing the
    Ivory Soap slogan from the XIX century, that it''s *about 99.44% pure*. However,
    an inconvenience remains: how would you test it? If you were to write some tests
    that worked fine today, next year they''d start to fail. We''ll have to work a
    bit to solve this, and we''ll see how later on.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题已经被解决了——新的`isOldEnough2()`函数现在更加*安全*。此外，只要你不在新年前夕的午夜附近使用它，它将始终返回相同的结果，因此你可以说，用19世纪象牙皂的广告语来说，它是*约99.44%纯*。然而，一个不便仍然存在：你该如何测试它？如果你今天写了一些测试，明年它们可能会开始失败。我们将不得不努力解决这个问题，我们稍后会看到如何解决。
- en: 'Several other functions that also are impure are those that cause I/O. If a
    function gets input from some source (a web service, the user himself, a file,
    and so on), obviously the returned result may vary. You should also consider the
    possibility of an I/O error, so the very same function, calling the same service
    or reading the same file, might at some time fail, for reasons outside its control
    (you should assume that your filesystem, database, socket, and so on, could be
    unavailable, and thus a given function call might produce an error instead of
    the expected constant, unvarying, answer). Even a pure output, and generally safe,
    statement such as a `console.log()`, that doesn''t change anything internally
    (at least in a visible way) does cause some effects, because the user does see
    a change: the produced output.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些不纯的函数，比如那些引起I/O的函数。如果一个函数从某个来源获取输入（网络服务、用户本身、文件等），显然返回的结果可能会有所不同。你还应该考虑I/O错误的可能性，因此同一个函数，调用同一个服务或读取同一个文件，可能在某个时候失败，原因是超出了它的控制范围（你应该假设你的文件系统、数据库、套接字等可能不可用，因此给定的函数调用可能产生错误，而不是预期的恒定、不变的答案）。即使是一个纯输出的、通常安全的语句，比如`console.log()`，它在内部并不会改变任何东西（至少在可见的方式上），但它确实会产生一些影响，因为用户看到了变化：产生的输出。
- en: Does this imply that we won't ever be able to write a program that requires
    random numbers, handles dates, or does I/O, and also use pure functions? Not at
    all -- but it does mean that some functions won't be pure, and they will have
    some disadvantages that we will have to consider; we'll return to this in a bit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们永远无法编写需要随机数、处理日期或进行I/O的程序，并且还使用纯函数？一点也不——但这意味着有些函数不会是纯函数，它们会有一些我们需要考虑的缺点；我们稍后会回到这个问题。
- en: Advantages of pure functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数的优势
- en: The main advantage of using pure functions, derives from the fact that they
    don't have any side effects. When you call a pure function, you need not worry
    about anything, outside of which arguments you are passing to it. Also, more to
    the point, you can be sure that you cannot cause any problems or break anything
    else, because the function will only work with whatever you give it, and not with
    outside sources. But this is not their only advantage; let's see more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数的主要优势，源于它们没有任何副作用。当你调用一个纯函数时，你不需要担心任何事情，除了你传递给它的参数。而且更重要的是，你可以确信你不会造成任何问题或破坏其他任何东西，因为函数只会处理你给它的东西，而不会处理外部来源。但这并不是它们唯一的优势；让我们看看更多。
- en: Order of execution
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'Another way of looking at what we have been saying in this chapter, is the
    consideration that pure functions can be called *robust*. You know that their
    execution --in whichever order-- won''t ever have any sort of impact on the system.
    This idea may be extended further: you could evaluate pure functions in parallel,
    resting assured that results wouldn''t vary from what you would get in a single-threaded
    execution.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章中我们所说的另一个角度来看，纯函数可以被称为*健壮*的。你知道它们的执行——无论以哪种顺序——都不会对系统产生任何影响。这个想法可以进一步扩展：你可以并行评估纯函数，放心地得出结果不会与单线程执行中得到的结果有所不同。
- en: Unhappily, JS restricts us very much as to parallel programming. We may make
    do, in very restricted ways, with web workers, but that's about as far as it goes.
    For Node.js developers, the cluster module may help out, though it isn't actually
    an alternative to threads, and only lets you spawn multiple processes letting
    you use all available CPU cores. To sum it up, you don't get facilities such as
    Java's threads, for example, so parallelization isn't really an FP advantage in
    JS terms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JS在并行编程方面限制了我们很多。我们可能会以非常有限的方式使用Web Workers，但这大概就是它的极限了。对于Node.js开发人员，集群模块可能会有所帮助，尽管它并不是线程的替代品，只允许您生成多个进程以利用所有可用的CPU核心。总之，您不会得到诸如Java的线程之类的设施，因此在JS术语中，并行化并不是FP的优势。
- en: 'When you work with pure functions, another consideration to keep in mind is
    that there''s no explicit need to specify the order in which they should be called.
    If you work with mathematics, an expression such as *f(2)+f(5)* is always the
    same as *f(5)+f(2)*; this is called the *commutative property*, by the way. However,
    when you deal with impure functions, that can be not true, as shown in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用纯函数时，需要牢记的另一个考虑因素是，没有明确的需要指定它们应该被调用的顺序。如果您使用数学，例如*f(2)+f(5)*这样的表达式总是与*f(5)+f(2)*相同；顺便说一下，这被称为*交换律*。然而，当您处理不纯函数时，这可能不成立，就像下面的代码所示：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With impure functions such as shown previously, you cannot assume that calculating
    *f(3)+f(3)* would produce the same result as *2*f(3)*, or that *f(4)-f(4)* would
    actually be zero; check it out! More common mathematical properties down the drain...
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前显示的不纯函数，您不能假设计算*f(3)+f(3)*会产生与*2*f(3)*相同的结果，或者*f(4)-f(4)*实际上会是零；检查一下！更常见的数学属性都泡汤了...
- en: Why should you care? When you are writing code, willingly or not, you are always
    keeping in mind those properties you learnt about, such as the commutative property.
    So, while you might think that both expressions should produce the same result,
    and code accordingly, with impure functions you may be in for a surprise, with
    hard-to-find bugs that are difficult to fix.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您应该关心呢？当您编写代码时，无论是否愿意，您总是牢记着您学到的那些属性，比如交换律。因此，虽然您可能认为这两个表达式应该产生相同的结果，并相应地编写代码，但是对于不纯函数，您可能会遇到令人惊讶的难以修复的难以发现的错误。
- en: Memoization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: Since the output of a pure function for a given input is always the same, you
    can cache the function results and avoid a possibly costly re-calculation. This
    process, which implies evaluating an expression only the first time, and caching
    the result for later calls, is called *memoization*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纯函数对于给定的输入始终产生相同的输出，您可以缓存函数的结果，避免可能昂贵的重新计算。这个过程，即仅在第一次评估表达式，并缓存结果以供以后调用，称为*记忆化*。
- en: 'We will come back to this idea in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, but let''s see an example done
    by hand. The Fibonacci sequence is always used for examples, because of its simplicity,
    and its hidden calculation costs. This sequence is defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中回到这个想法，*生成函数 - 高阶函数*，但让我们看一个手工完成的例子。斐波那契序列总是被用来举例，因为它简单，而且隐藏的计算成本。这个序列的定义如下：
- en: for *n*=0, *fib*(*n*)=0
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*n*=0，*fib*(*n*)=0
- en: for *n*=1, *fib*(*n*)=1
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*n*=1，*fib*(*n*)=1
- en: for *n*>1, *fib*(*n*)=*fib*(*n*-2)+*fib*(*n*-1)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*n*>1，*fib*(*n*)=*fib*(*n*-2)+*fib*(*n*-1)
- en: Fibonacci's name actually comes from *filius Bonacci*, or *son of Bonacci*.
    He is best known for having introduced the usage of digits 0-9 as we know them
    today, instead of the cumbersome Roman numbers. He derived the sequence named
    after him as the answer to a puzzle involving rabbits!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契的名字实际上来自*filius Bonacci*，或者*Bonacci的儿子*。他最著名的是引入了我们今天所知的0-9数字的使用，而不是繁琐的罗马数字。他将以他命名的序列作为解答引入了一个涉及兔子的谜题！
- en: 'If you do the numbers, the sequence starts with 0, then 1, and from that point
    onwards, each term is the sum of the two previous ones: 1 again, then 2, 3, 5,
    8, 13, 21, and so on. Programming this series by using recursion is simple --
    though we''ll revisit this example in [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*. The following code, a direct translation of
    the definition, will do:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计算一下，序列从0开始，然后是1，从那一点开始，每个项都是前两个项的和：再次是1，然后是2，3，5，8，13，21，依此类推。通过递归编程这个系列很简单--尽管我们将在[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)中重新讨论这个例子，*设计函数
    - 递归*。下面的代码，是对定义的直接翻译，将会这样做：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you really go for oneliners, you could also write `const fib = (n) => (n<=1)
    ? n : fib(n-2)+fib(n-1)`-- do you see why? But, more important... is it worth
    the loss of clarity?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您真的喜欢一行代码，您也可以写成`const fib = (n) => (n<=1) ? n : fib(n-2)+fib(n-1)`--您明白为什么吗？但更重要的是...值得失去清晰度吗？'
- en: 'If you try out this function for growing values of `n`, you''ll soon realize
    there is a problem, and computation starts taking too much time. For example,
    on my machine, these are some timings I took, measured in milliseconds -- of course,
    your mileage may vary. Since the function is quite speedy, I had to run calculations
    100 times, for values of `n` between 0 and 40. Even then, times for small values
    of `n` were really tiny; only from 25 onwards, I got interesting numbers. The
    chart (see Figure 4.1) shows an exponential growth, which bodes ill:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用这个函数来增加`n`的值，很快就会意识到存在问题，计算开始花费太多时间。例如，在我的机器上，这是我测得的一些时间，以毫秒为单位--当然，您的情况可能有所不同。由于函数速度相当快，我不得不运行100次计算，对`n`的值在0到40之间。即使如此，对于较小的`n`值，时间确实非常短暂；只有从25开始，我得到了有趣的数字。图表（见图4.1）显示了指数增长，这预示着不祥的事情。
- en: '![](assets/e2ac008e-f09e-49d5-9d43-78a74620c31c.png)Figure 4.1: Calculation
    times for the fib() recursive function go up exponentially.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e2ac008e-f09e-49d5-9d43-78a74620c31c.png)图4.1：fib()递归函数的计算时间呈指数增长。'
- en: 'If we draw a diagram of all the calls required to calculate `fib(6)`, you''ll
    notice the problem. Each node represents a call to calculate `fib(n)`: we just
    note the value of `n` in the node. Every call, except those for `n`=0 or 1, requires
    further calls; see Figure 4.2:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制出计算`fib(6)`所需的所有调用的图表，你会注意到问题。每个节点代表计算`fib(n)`的调用：我们只在节点中记录`n`的值。除了`n`=0或1的调用外，每个调用都需要进一步的调用；参见图4.2：
- en: '![](assets/ccd25b95-8da3-4bc6-8d25-3eb16a5e4029.png)Figure 4.2: All the required
    calculations for fib(6) show lots of duplication'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ccd25b95-8da3-4bc6-8d25-3eb16a5e4029.png)图4.2：计算fib(6)所需的所有计算显示出大量重复'
- en: 'The reason for the increasing delays becomes obvious: for example, the calculation
    for `fib(2)` was repeated on four different occasions, and `fib(3)` was itself
    calculated three times. Given that our function is pure, we could have stored
    the calculated values to avoid doing the numbers over and over again. A possible
    version would be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟增加的原因变得很明显：例如，`fib(2)`的计算在四个不同的场合重复进行，而`fib(3)`本身被计算了三次。鉴于我们的函数是纯函数，我们可以存储计算出的值，避免一遍又一遍地进行数字计算。可能的版本如下：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initially, the cache is empty. Whenever we need to calculate a value of `fib2(n)`,
    we check if it was already calculated before. If that''s not true, we do the calculation,
    but with a twist: instead of immediately returning the value, first we store it
    in the cache, and then we return it. This means that no calculation will be done
    twice: after we have calculated `fib2(n)` for a certain `n`, future calls will
    not repeat the procedure, and simply return the value that was already evaluated
    before.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，缓存是空的。每当我们需要计算`fib2(n)`的值时，我们都会检查它是否已经计算过。如果不是，我们进行计算，但有一个小变化：我们不会立即返回值，而是先将其存储在缓存中，然后再返回。这意味着不会重复进行计算：在我们为特定的`n`计算了`fib2(n)`之后，未来的调用将不会重复这个过程，而只是返回之前已经计算过的值。
- en: 'A couple of short notes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简短的注释：
- en: We memoizedthe function by hand, but we can do it with a higher-order function,
    and we'll see that later, in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. It is perfectly possible to memoize a
    function, without having to change to rewrite it.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们手动进行了函数的记忆化，但我们可以使用高阶函数来实现，我们将在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中看到，*生成函数
    - 高阶函数*。完全可以对函数进行记忆化，而无需改写它。
- en: Using an global variable for the cache isn't a very good practice; we could
    have used an IIFE and a closure to hide cache from sight; do you see how? See
    the `myCounter()` example in the *Immediate invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, to review how we'd do that.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局变量作为缓存不是一个很好的做法；我们可以使用IIFE和闭包来隐藏缓存；你看到了吗？在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*立即调用*部分中查看`myCounter()`示例，回顾我们如何做到这一点。
- en: Of course, you need not do this for every pure function in your program. You'd
    do this sort of optimization only for frequently called functions, that take a
    certain important time -- if it were otherwise, the added cache management time
    would end costing more than whatever you expected to save!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要为程序中的每个纯函数都这样做。你只会对频繁调用、需要花费重要时间的函数进行这种优化 - 如果情况不是这样的话，额外的缓存管理时间将会比你期望节省的时间更多！
- en: Self-documentation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我文档化
- en: Pure functions have another advantage. Since all the function needs to work
    with is given to it through its parameters, having no kind of hidden dependency
    whatsoever, when you read its source code, you have all you need to understand
    the function's objective.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数还有另一个优势。由于函数需要处理的一切都通过其参数给出，没有任何隐藏的依赖关系，所以当你阅读其源代码时，你已经拥有了理解函数目标所需的一切。
- en: 'An extra advantage: knowing that a function doesn''t access anything beyond
    its parameters, makes you more confident in using it, since you won''t be accidentally
    producing some side effect, the only thing the function will accomplish, is what
    you already learned through its documentation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的优势：知道一个函数不会访问除了其参数之外的任何东西，会让你更有信心使用它，因为你不会意外地产生一些副作用，函数将会完成的唯一事情，就是你已经通过文档学到的。
- en: Unit tests (which we'll be covering in the next section) also work as documentation,
    for they provide examples of what the function returns, when given certain arguments.
    Most programmers will agree that the best kind of documentation is full with examples,
    and each unit test can be considered such a sample case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试（我们将在下一节中介绍）也可以作为文档，因为它们提供了在给定特定参数时函数返回的示例。大多数程序员都会同意，最好的文档是充满示例的，每个单元测试都可以被视为这样一个示例。
- en: Testing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Yet another advantage of pure functions --and one of the most important ones--
    has to do with unit testing. Pure functions have a single responsibility, producing
    their output in terms of their input. So, when you write tests for pure functions,
    your work is much simplified, because there is no context to consider and no state
    to simulate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的另一个优势 - 也是最重要的之一 - 与单元测试有关。纯函数只负责以其输入产生输出。因此，当你为纯函数编写测试时，你的工作会简化得多，因为不需要考虑上下文，也不需要模拟状态。
- en: You can simply focus on providing inputs and checking outputs, because all function
    calls can be reproduced in isolation, with independence from the *rest of the
    world*. We'll see more about testing pure and impure functions, later in this
    very chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地专注于提供输入和检查输出，因为所有函数调用都可以在与*世界其他部分*独立的情况下重现。我们将在本章后面更多地了解测试纯函数和不纯函数。
- en: Impure functions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不纯函数
- en: If you decided to completely forego all kinds of side effects, your programs
    would only be able to work with hardcoded inputs... and wouldn't be able to show
    you the calculated results! Similarly, most web pages would be useless; you wouldn't
    be able to do any web services calls, or to update the DOM; you'd have static
    pages only. And, for server-side JS, your Node.JS code would be really useless,
    not being able to do any I/O...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定完全放弃所有种类的副作用，你的程序只能使用硬编码的输入...并且无法显示计算结果！同样，大多数网页将变得无用；你将无法进行任何网络服务调用，或者更新DOM；你只能有静态页面。对于服务器端的JS，你的Node.JS代码将变得非常无用，无法进行任何I/O...
- en: Reducing side effects is a good goal in FP, but we cannot go overboard with
    it! So, let's think how to avoid using impure functions, if possible, and how
    to deal with them if not, looking for the best possible way to contain or limit
    their scope.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中减少副作用是一个很好的目标，但我们不能过分追求！所以，让我们想想如何避免使用不纯的函数，如果可能的话，以及如何处理它们，寻找最好的方法来限制或限制它们的范围。
- en: Avoiding impure functions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免不纯的函数
- en: Earlier in this chapter, we saw the more common reasons for impure functions.
    Let's now consider how we can minimize their number, if doing away with all of
    them isn't really feasible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看到了不纯函数更常见的原因。现在让我们考虑如何最小化它们的数量，如果完全摆脱它们并不现实的话。
- en: Avoiding the usage of state
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用状态
- en: 'With regard to the usage of global state --both getting and setting it-- the
    solution is well known. The key to this is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用全局状态--获取和设置--解决方案是众所周知的。关键在于：
- en: Provide whatever is needed of the global state to the function, as arguments
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局状态所需的内容作为参数提供给函数
- en: If the function needs to update the state, it shall not do it directly, but
    rather produce a new version of the state, and return it
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数需要更新状态，它不应该直接这样做，而是应该产生状态的新版本，并返回它
- en: It will be the responsibility of the caller to take the returned state, if any,
    and update the global state
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，将由调用者负责获取返回的状态并更新全局状态
- en: This is the technique that Redux uses for its reducers. The signature for a
    reducer is `(previousState, action) => newState` meaning that it takes a state
    and an action as parameters, and returns a new state as the result. Most specifically,
    the reducer is not supposed to simply change the `previousState`argument, which
    must remain untouched (we'll see more about this in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Redux用于其reducer的技术。reducer的签名是`(previousState, action) => newState`，意味着它以状态和动作作为参数，并返回一个新的状态作为结果。更具体地说，reducer不应该简单地改变`previousState`参数，它必须保持不变（我们将在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中看到更多关于这一点的内容，*确保纯度-不可变性*）。
- en: 'With regard to our first version of the `isOldEnough()`function, that used
    a global `limitYear` variable, the change is simple enough: we just have to provide
    `limitYear` as a parameter for the function. With this change, it will become
    pure, since it will produce its result by only using its parameters. Even better,
    we should provide the current year, and let the function do the math, instead
    of forcing the caller to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们第一个版本的`isOldEnough()`函数，它使用了一个全局的`limitYear`变量，改变很简单：我们只需要将`limitYear`作为函数的参数提供。有了这个改变，函数就会变得纯净，因为它只会使用它的参数来产生结果。更好的是，我们应该提供当前年份，让函数来计算，而不是强制调用者这样做：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll have to change, obviously, all the calls to provide the needed `limitYear`
    argument (we could also use currying, as we will see in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying And Partial Application*). The responsibility
    of initializing the value of `limitYear` still remains outside of the function,
    as before, but we have managed to avoid a defect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们将不得不改变所有调用以提供所需的`limitYear`参数（我们也可以使用柯里化，正如我们将在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中看到的，*转换函数-柯里化和部分应用*）。初始化`limitYear`的值的责任仍然在函数之外，但我们已经成功避免了一个缺陷。
- en: 'We can also apply this solution to our peculiar `roundFix()`function. As you
    recall, the function worked by accumulating the differences caused by rounding,
    and deciding whether to round up or down depending on the sign of that accumulator.
    We cannot avoid using that state, but we can split off the rounding part from
    the accumulating part. So, our original code (less comments and logging) would
    change from:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这个解决方案应用到我们特殊的`roundFix()`函数中。你还记得，这个函数通过累积由四舍五入引起的差异来工作，并根据累加器的符号决定是向上还是向下舍入。我们无法避免使用这个状态，但我们可以将四舍五入部分与累积部分分开。因此，我们的原始代码（减去注释和日志）将从以下内容更改：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 至于：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How would you use this function? Initializing the accumulator, passing it to
    the function, and updating it afterwards, are now the responsibility of the caller
    code. You would have something like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何使用这个函数？初始化累加器，将其传递给函数，并在之后更新，现在都是调用者代码的责任。你会有类似以下的东西：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：
- en: '`accum` is now part of the global state of the application'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accum`现在是应用程序的全局状态的一部分'
- en: Since `roundFix2()` needs it, the current accumulator value is provided in each
    call
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`roundFix2()`需要它，当前的累加器值在每次调用时都会被提供
- en: The caller is responsible for updating the global state, not `roundFix2()`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者负责更新全局状态，而不是`roundFix2()`
- en: Note the usage of the destructuring assignment, in order to allow a function
    to return more than a value, and to easily store each one in a different variable.
    For more on this, check [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用解构赋值，以便允许函数返回多个值，并且可以轻松地将每个值存储在不同的变量中。更多信息，请查看[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。
- en: This new `roundFix2()`function is totally pure, and can be easily tested. If
    you want to hide the accumulator from the rest of the application, you could still
    use a closure as in other examples, but that would again introduce impurity in
    your code; your call!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`roundFix2()`函数是完全纯粹的，可以很容易地进行测试。如果你想要隐藏累加器不被应用程序的其他部分访问，你仍然可以像其他示例中一样使用闭包，但这将再次在你的代码中引入不纯性；你决定！
- en: Injecting impure functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入不纯的函数
- en: If a function becomes impure because it needs to call some other function that
    is itself impure, a way around this problem is to inject the required function
    in the call. This technique actually provides more flexibility in your code and
    allows for easier future changes, as well as less complex unit testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数变得不纯，因为它需要调用一些其他函数，而这些函数本身是不纯的，解决这个问题的方法是在调用中注入所需的函数。这种技术实际上为您的代码提供了更多的灵活性，并允许更容易地进行未来更改，以及更简单的单元测试。
- en: 'Let''s consider the random filename generator function that we saw earlier.
    The problematic part is its usage of `getRandomLetter()` to produce the filename:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们之前看到的随机文件名生成器函数。问题的关键在于它使用`getRandomLetter()`来生成文件名：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A way to solve this is replacing the impure function, with an injected external
    one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是用一个注入的外部函数替换不纯的函数：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have removed the inherent impurity from this function. If we care to
    provide a predefined pseudorandom function that actually returns fixed, known,
    values, we will be able to easily unit test this function; we''ll be seeing that
    in the following examples. The usage of the function will change, and we would
    have to write:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从这个函数中移除了固有的不纯性。如果我们愿意提供一个预定义的伪随机函数，实际上返回固定、已知的值，我们将能够轻松地对这个函数进行单元测试；我们将在接下来的示例中看到。函数的使用将会改变，我们需要编写：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this way bothers you, you may want to provide a  default value for the `randomLetterFunc` parameter,
    as with:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种方式让你困扰，你可能想为`randomLetterFunc`参数提供一个默认值，如下所示：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Or you may also solve this by partial application, as we'll be seeing in [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以通过部分应用来解决这个问题，就像我们将在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中看到的那样，*转换函数
    - 柯里化和部分应用*。
- en: This hasn't actually avoided the usage of impure functions. In normal use, you'll
    call `getRandomFileName()`providing it with the random letter generator we wrote,
    so it will behave as an impure function. However, for testing purposes, if you
    provide a function that returns predefined (that is, not random) letters, you'll
    be able to test it as if it were pure, much more easily.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并没有避免使用不纯的函数。在正常使用中，你将调用`getRandomFileName()`并提供我们编写的随机字母生成器，因此它将表现为一个不纯的函数。然而，为了测试目的，如果你提供一个返回预定义（即非随机）字母的函数，你将能够更轻松地测试它是否纯粹。
- en: 'But what about the original problem function, `getRandomLetter()`? We can apply
    the same trick, and write a new version, like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但是原始问题函数`getRandomLetter()`呢？我们可以应用相同的技巧，编写一个新版本，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For normal usage, `getRandomFileName()`would call `getRandomLetter()`without
    providing any parameters, which would imply that the called function would behave
    in its expected random ways. But if we want to test whether the function does
    what we wanted, we can run it with an injected function that will return whatever
    we decide, letting us test it thoroughly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常使用中，`getRandomFileName()`会调用`getRandomLetter()`而不提供任何参数，这意味着被调用的函数将按照预期的随机方式行事。但是，如果我们想要测试函数是否符合我们的预期，我们可以运行它，使用一个返回我们决定的任何内容的注入函数，让我们彻底测试它。
- en: This idea is actually very important and has a wide specter of application to
    other problems. For example, instead of having a function directly access the
    DOM, we may provide it with injected functions that would do that. For testing
    purposes, it would be simple to verify that the tested function actually does
    what it needs to do, without really interacting with the DOM (of course, we'd
    have to find some other way to test those DOM-related functions). This can also
    apply to functions that need to update the DOM, generate new elements, and do
    all sorts of manipulations, you just use some intermediary functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法实际上非常重要，对其他问题有广泛的应用。例如，我们可以提供一个函数来直接访问DOM，而不是直接访问DOM。对于测试目的，可以简单地验证被测试的函数是否真的做了它需要做的事情，而不是真的与DOM进行交互（当然，我们必须找到其他方法来测试那些与DOM相关的函数）。这也适用于需要更新DOM、生成新元素和进行各种操作的函数，你只需使用一些中间函数。
- en: Is your function pure?
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的函数是纯的吗？
- en: 'Let''s end this section by considering an important question: can you ensure
    a function is actually pure? To show the difficulties of this task, we''ll go
    back to the simple `sum3()`function we saw in earlier chapters. Would you say
    that this function is pure? It certainly looks like it!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个重要的问题来结束这一节：你能确保一个函数实际上是纯的吗？为了展示这个任务的困难，我们将回到我们在前几章中看到的简单的`sum3()`函数。你会说这个函数是纯的吗？它看起来是！
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see, the function doesn't access anything but its parameters, doesn't
    even try to modify them (not that it could... or could it?), doesn't do any I/O
    or work with any of the impure functions or methods that we mentioned earlier...
    what could go wrong?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看，这个函数除了它的参数之外没有访问任何东西，甚至不尝试修改它们（即使它可能...或者可能吗？），不进行任何I/O或使用我们之前提到的任何不纯的函数或方法...会出什么问题呢？
- en: 'The answer has to do with checking your assumptions. For example, who says
    the arguments for this function should be numbers? You might say to yourself *OK,
    they could be strings... but the function would still be pure, wouldn''t it?*,
    but for an (assuredly evil!) answer to that, see the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 答案与检查你的假设有关。例如，谁说这个函数的参数应该是数字？你可能会对自己说“好吧，它们可以是字符串...但是函数仍然是纯的，不是吗？”，但是对于这个（肯定是邪恶的！）答案，看看下面的代码。
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Observe the way we assigned a new function to the `x.valueOf` method, we are
    taking full advantage of the fact that functions are first-class objects. See
    the *An unnecessary mistake* section in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting out with functions - A Core Concept*, to see more on this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何将一个新函数分配给`x.valueOf`方法，我们充分利用了函数是一级对象的事实。在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*一个不必要的错误*部分中，可以了解更多相关信息。
- en: Well, `sum3()`ought to be pure... but it actually depends on whatever parameters
    you pass to it! You might console yourself thinking that surely no one would pass
    such arguments, but edge cases are usually where bugs reside. But you need not
    resign yourself to abandoning the idea of pure functions. Adding some type checking
    (TypeScript might come in handy) you could at least prevent some cases -- though
    JS won't ever let you be totally sure that your code is *always* pure!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`sum3()`应该是纯的...但它实际上取决于你传递给它的参数！你可能会安慰自己，认为肯定没有人会传递这样的参数，但边缘情况通常是错误的根源。但你不必放弃纯函数的想法。添加一些类型检查（TypeScript可能会派上用场），你至少可以防止一些情况--尽管JS永远不会让你完全确定你的代码*总是*是纯的！
- en: Testing - pure versus impure
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试-纯函数与不纯函数
- en: 'We have seen how pure functions are conceptually better than impure ones, but
    we cannot set out on a crusade to vanquish all impurity from our code. First,
    no one can deny that side effects can be useful, or at least unavoidable: you
    will need to interact with the DOM or call a web service, and there are no ways
    to do it in a pure way. So, rather on bemoaning the fact that you have to allow
    for impurity, try to structure your code so you can isolate the impure functions,
    and let the rest of your code be the best possible.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到纯函数在概念上比不纯函数更好，但我们不能开始一场消灭代码中所有不纯性的运动。首先，没有人能否认副作用是有用的，或者至少是不可避免的：你需要与DOM交互或调用Web服务，而没有办法以纯粹的方式做到这一点。因此，与其抱怨你必须允许不纯性，不如尝试构建你的代码，以便隔离不纯函数，并让你的代码尽可能地好。
- en: With this in mind, you'll have to be able to write unit tests for all kinds
    of functions, pure or impure. Writing unit tests for functions is different, as
    to its difficulty and complexity, when you deal with pure or impure functions.
    While coding tests for the former is usually quite simple and follows a basic
    pattern, the latter usually require scaffolding and complex setups. So, let's
    finish this chapter by seeing how to go about testing both types of functions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，你将能够为各种函数编写单元测试，无论是纯函数还是不纯函数。编写纯函数和不纯函数的单元测试是不同的，因为在处理纯函数或不纯函数时，其难度和复杂性也不同。对于前者编写测试通常相当简单，并遵循基本模式，而对于后者通常需要搭建和复杂的设置。因此，让我们通过看看如何测试这两种类型的函数来结束本章。
- en: Testing pure functions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: 'Given the characteristics of pure functions that we have already described,
    most of your unit tests could be simply:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们已经描述的纯函数的特性，你的大部分单元测试可能会很简单：
- en: Call the function with a given set of arguments
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的一组参数调用函数
- en: Verify that the results match what you expected
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证结果是否与预期相匹配
- en: 'Let''s start with a couple of simple examples. Testing the `isOldEnough()`function
    would have been more complex than needed for the version that required access
    to a global variable. On the other hand, the last version, `isOldEnough3()`, which
    didn''t require anything because it received two parameters, is simple to test:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的例子开始。测试`isOldEnough()`函数将比需要访问全局变量的版本更复杂。另一方面，最后一个版本`isOldEnough3()`不需要任何东西，因为它接收了两个参数，所以测试起来很简单：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another of the pure functions we wrote is equally simple, but for a care about
    precision. If we test the `circleArea`function we must use the Jasmine `.toBeCloseTo()`matcher,
    which allows for approximate equality, when dealing with floating point numbers.
    Other than that, tests are just about the same: call the function with known arguments,
    and check the expected results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的另一个纯函数同样简单，但需要注意精度。如果我们测试`circleArea`函数，我们必须使用Jasmine的`.toBeCloseTo()`匹配器，它允许在处理浮点数时进行近似相等。除此之外，测试基本相同：使用已知参数调用函数，并检查预期结果。
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'No difficulty whatsoever! The test run reports success for both suites (see
    Figure 4.3):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无困难！测试运行报告对两个套件都成功（见图4.3）：
- en: '![](assets/aa0a1952-14ab-403c-a802-19ad03979492.png)Figure 4.3: A successful
    test run for a pair of simple pure functions'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aa0a1952-14ab-403c-a802-19ad03979492.png)图4.3：一对简单纯函数的成功测试运行'
- en: So, we don't have to worry about pure functions, so let's move on to the impure
    ones we dealt with by transforming them into pure equivalents.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必担心纯函数，让我们继续处理不纯函数，将它们转换为纯函数的等价物。
- en: Testing purified functions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试纯化函数
- en: 'When we considered the `roundFix` special function, which required using state
    to accumulate the differences due to rounding, we produced a new version by providing
    the current state as an added parameter, and by having the function return two
    values: the rounded one, and the updated state:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑`roundFix`特殊函数时，它需要使用状态来累积由于舍入而产生的差异，我们通过将当前状态作为附加参数提供，并使函数返回两个值：舍入后的值和更新后的状态，从而生成了一个新版本：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function is now pure, but testing it requires validating not only the
    returned values but also the updated states. We can base our tests on the experiments
    we did previously. Once again, we have to use `toBeCloseTo()` for dealing with
    floating point numbers but we can use `toBe()` with integers, which produce no
    rounding errors:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在是纯的，但测试它需要验证不仅返回的值，还有更新的状态。我们可以基于之前的实验来进行测试。再次，我们必须使用`toBeCloseTo()`来处理浮点数，但对于整数，我们可以使用`toBe()`，它不会产生舍入误差：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We took care to include several cases, with positive, zero, or negative accumulated
    differences and checking if it rounded up or down on each occasion. We could certainly
    go further, by rounding negative numbers, but the idea is clear: if your function
    takes the current state as a parameter, and updates it, the only difference with
    the pure functions tests are that you will also have to test whether the returned
    state matches your expectations.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到包括了几种情况，积累的差异为正、零或负，并检查在每种情况下是否四舍五入。我们当然可以进一步进行，对负数进行四舍五入，但思路很清楚：如果你的函数将当前状态作为参数，并更新它，与纯函数测试的唯一区别是你还必须测试返回的状态是否符合你的期望。
- en: Let's now consider the alternative way of testing, for our pure `getRandomLetter()`variant;
    let's call it `getRandomLetter2()`. This is simple; you just have to provide a
    function that will itself produce *random* numbers. (This kind of function, in
    testing parlance, is called a *stub*). There's no limit to the complexity of a
    stub, but you'll want to keep it simple.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑测试的另一种方式，对于我们纯净的`getRandomLetter()`变体；让我们称之为`getRandomLetter2()`。这很简单；你只需要提供一个函数，它本身会产生*随机*数字。（在测试术语中，这种函数被称为*存根*）。存根的复杂性没有限制，但你会希望保持它简单。
- en: Wecan then do some tests, based on our knowledge of the workings of the function,
    to verify that low values produce an `A`, values close to 1 produce a `Z`, so
    we can have a little confidence that no extra values are produced. Also, a middle
    value (around 0.5) should produce a letter around the middle of the alphabet.
    However, keep in mind that this kind of test is not very good; if we substituted
    an equally valid `getRandomLetter()` variant, it might be the case that the new
    function could work perfectly well, but not pass this test, because of a different
    internal implementation!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以根据对函数工作原理的了解进行一些测试，以验证低值产生`A`，接近1的值产生`Z`，因此我们可以有一点信心，不会产生额外的值。此外，中间值（大约0.5）应该产生字母在字母表中间的位置。然而，请记住，这种测试并不是很好；如果我们替换了一个同样有效的`getRandomLetter()`变体，新函数可能完全正常工作，但由于不同的内部实现，可能无法通过这个测试！
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Testing our filename generator can be done in a similar way, by using stubs.
    We can provide a simple stub that will return the letters of `"SORTOFRANDOM"`
    in sequence (this function is quite impure; see why?). So, we can verify that
    the returned filename matches the expected name, and a couple more properties
    of the returned filename, such as its length and its extension:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的文件名生成器可以通过使用存根来以类似的方式进行。我们可以提供一个简单的存根，按顺序返回`"SORTOFRANDOM"`的字母（这个函数是相当不纯的；知道为什么吗？）。因此，我们可以验证返回的文件名是否与预期的名称匹配，以及返回的文件名的一些其他属性，例如其长度和扩展名：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Testing *purified*impure functions is very much the same as testing originally
    pure functions. Now, we'll have to consider some cases of truly impure functions,
    because, as we said, it's quite certain that at some time or another, you'll have
    to use such functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试*纯化*的不纯函数与测试最初纯函数非常相似。现在，我们将不得不考虑一些真正不纯函数的情况，因为正如我们所说的，几乎可以肯定，你迟早会使用这样的函数。
- en: Testing impure functions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试不纯函数
- en: For starters, we'll go back to our `getRandomLetter()`function. With insider
    knowledge about its implementation (this is called *white box testing*, in opposition
    to *black box testing*, in which we know nothing about the function code itself)
    we can *spy*(a Jasmine term) on the `Math.random()`method, and set a *mock* function
    that will return whatever values we desire.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回到我们的`getRandomLetter()`函数。有了对其实现的内部知识（这被称为*白盒测试*，与*黑盒测试*相对，后者我们对函数代码本身一无所知），我们可以*监视*（Jasmine术语）`Math.random()`方法，并设置一个*模拟*函数，它将返回我们想要的任何值。
- en: 'We can revisit some of the test cases we did in the previous section. In the
    first case, we set `Math.random()`to return 0.0001, and we test that it was actually
    called, and also that the final return was `A`. In the second case, just for variety,
    we set things up so `Math.random()`can be called twice, returning two different
    values. We also verify that there were two calls to the function and that both
    results were `Z`. The third case shows yet a different way of checking how many
    times `Math.random()` (or, rather, our mocked function) was called:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新审视我们在上一节中进行的一些测试用例。在第一个案例中，我们将`Math.random()`设置为返回0.0001，并测试它是否实际被调用，以及最终返回是否为`A`。在第二个案例中，为了多样化，我们设置了`Math.random()`可以被调用两次，返回两个不同的值。我们还验证了函数被调用了两次，而且两个结果都是`Z`。第三个案例展示了检查`Math.random()`（或者说，我们的模拟函数）被调用了多少次的另一种方式：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, you wouldn't go around inventing whatever tests came into your head.
    Supposedly, you'll work from the description of the desired `getRandomLetter()`function,
    which was written before you started to code or test it. In our case, I'm making
    do as if that specification did exist, and it pointedly said, for example, that
    values close to 0 should produce an `A`, values close to 1 should return `Z`,
    and the function should return ascending letters for ascending `random` values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会随意发明任何测试。据说，你会从所需的`getRandomLetter()`函数的描述开始工作，这个描述是在你开始编码或测试之前编写的。在我们的情况下，我假装那个规范确实存在，并且明确指出，例如，接近0的值应该产生`A`，接近1的值应该返回`Z`，并且函数应该对升序的`random`值返回升序的字母。
- en: 'Now, how would you test the original `getRandomFileName()` function, the one
    that called the impure `getRandomLetter()`function? That''s a much more complicated
    problem.... what kind of expectations do you have? You cannot know the results
    it will give, so you won''t be able to write any `.toBe()` type of tests. What
    you can do, is to test for some properties of the expected results. And, also,
    if your function implies randomness of some kind, you can repeat the tests as
    many times as you want, to have a bigger chance of catching a bug:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你如何测试原始的`getRandomFileName()`函数，即调用不纯的`getRandomLetter()`函数的函数？这是一个更加复杂的问题....你有什么期望？你无法知道它将会给出什么结果，因此你无法编写任何`.toBe()`类型的测试。你可以测试一些预期结果的属性。而且，如果你的函数涉及某种形式的随机性，你可以重复测试多次，以增加捕获错误的机会：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We are not passing any random letter generator function to `getFileName()`,
    so it will use the original, impure one. We ran some of the tests a hundred times,
    as extra insurance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有向`getFileName()`传递任何随机字母生成函数，因此它将使用原始的、不纯的函数。我们对一些测试运行了一百次，作为额外的保险。
- en: When testing code, always remember that *absence of evidence*isn't *evidence
    of absence*. Even if our repeated tests succeed, there is no guarantee that, with
    some other random input, they won't produce an unexpected, and hitherto undetected,
    error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码时，永远记住*没有证据*不是*证据的缺失*。即使我们的重复测试成功了，也不能保证，使用其他随机输入时，它们不会产生意外的、迄今未被发现的错误。
- en: 'Let''s do another *property*test. Suppose we want to test a shuffling algorithm;
    we may decide to implement the Fisher-Yates version, along the lines of the following.
    As implemented, the algorithm is doubly impure: it doesn''t always produce the
    same result (obviously!) and it modifies its input parameter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行另一个*属性*测试。假设我们想测试一个洗牌算法；我们可以决定实现Fisher-Yates版本，按照以下的方式。按照实现，该算法是双重不纯的：它不总是产生相同的结果（显然！）并且修改了它的输入参数：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For more on this algorithm --including some pitfalls for the unwary programmer--
    see [https://en.wikipedia.org/wiki/Fisher-Yates_shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此算法的更多信息--包括对不慎的程序员造成的一些问题--请参阅[https://en.wikipedia.org/wiki/Fisher-Yates_shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)。
- en: 'How could you test this algorithm? Given that the result won''t be predictable,
    we can check for properties of its output. We can call it with a known array,
    and then test some properties of it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试这个算法？考虑到结果是不可预测的，我们可以检查其输出的属性。我们可以使用已知的数组调用它，然后测试它的一些属性：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We had to write the second part of the unit tests in that way, because, as we
    saw, `shuffle()` modifies the input parameter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不以这种方式编写单元测试的第二部分，因为正如我们所看到的，`shuffle()`会修改输入参数。
- en: Questions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 4.1\. **Minimalistic function**: Functional programmers sometimes tend to write
    code in a minimalistic way. Can you examine this version of the Fibonacci function,
    and explain whether it works, and if so, how?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 4.1\. **极简主义函数**：函数式程序员有时候倾向于以极简主义的方式编写代码。你能检查这个斐波那契函数的版本，并解释它是否有效，如果有效，是如何有效的吗？
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '4.2\. **A cheap way**:The following version of the Fibonacci function is quite
    efficient and doesn''t do any unnecessary or repeated computations. Can you see
    how? Suggestion: try to calculate `fib4(6)` by hand, and compare with the example
    given earlier in the book:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2\. **一个廉价的方法**：下面这个版本的斐波那契函数非常高效，不会进行任何不必要或重复的计算。你能看出来吗？建议：尝试手工计算`fib4(6)`，并与本书前面给出的例子进行比较：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.3 **A shuffle test:**How would you write unit tests for `shuffle()`, to test
    whether it works correctly with arrays with *repeated* values?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 4.3 **洗牌测试**：你如何为`shuffle()`编写单元测试，以测试它在具有*重复*值的数组上是否正确工作？
- en: '4.4\. **Breaking laws:**Using `.toBeCloseTo()` is very practical, but it can
    cause some problems. Some basic mathematics properties are:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4\. **违反规律**：使用`.toBeCloseTo()`非常实用，但可能会引发一些问题。一些基本的数学属性是：
- en: 'a number should equal itself: for any number *a*, *a* should equal *a*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字应该等于它自己：对于任何数字*a*，*a*应该等于*a*
- en: If a number *a* equals number *b*, then *b* should equal *a*
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字*a*等于数字*b*，那么*b*应该等于*a*
- en: If *a* equals *b*, and *b* equals *c*, then *a* should equal *c*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，*b*等于*c*，那么*a*应该等于*c*
- en: If *a* equals *b*, and *c* equals *d*, then *a*+*c* should equal *b*+*d*
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，*c*等于*d*，那么*a*+*c*应该等于*b*+*d*
- en: If *a* equals *b*, and *c* equals *d*, then *a***c* should equal *b***d*
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，*c*等于*d*，那么*a***c*应该等于*b***d*
- en: If *a* equals *b*, and *c* equals *d*, then *a*/*c* should equal *b*/*d*
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*a*等于*b*，*c*等于*d*，那么*a*/*c*应该等于*b*/*d*
- en: Does `.toBeCloseTo()` also satisfy all these properties?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toBeCloseTo()`是否也满足所有这些属性？'
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced the concept of *pure functions* and studied
    why they matter. We have also seen the problems caused by *side effects*, one
    of the causes of impure functions; considered some ways of *purifying* such impure
    functions, and finally, we have seen several ways of doing unit tests, for both
    pure and impure functions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了*纯函数*的概念，并研究了它们为什么重要。我们还看到了*副作用*造成的问题，这是不纯函数的原因之一；考虑了一些*净化*这些不纯函数的方法，最后，我们看到了对纯函数和不纯函数进行单元测试的几种方法。
- en: 'In [Chapter 5](a58c196f-ddb4-4d2a-858e-10ce09e0d02f.xhtml), *Programming Declaratively
    - A Better Style*, we''ll show other advantages of FP: how you can program in
    a declarative fashion, at a higher level, for simpler, more powerful code.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](a58c196f-ddb4-4d2a-858e-10ce09e0d02f.xhtml)中，*声明式编程 - 更好的风格*，我们将展示FP的其他优势：如何以声明式的方式进行编程，以更高的层次编写更简单、更强大的代码。
