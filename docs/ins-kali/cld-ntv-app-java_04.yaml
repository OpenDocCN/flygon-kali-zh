- en: Writing Your First Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个云原生应用程序
- en: This chapter looks at the essential elements of building your first cloud-native
    application. We will do the minimal number of steps required to get a microservice
    running in our development environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍构建第一个云原生应用程序的基本要素。我们将采取最少的步骤，在我们的开发环境中运行一个微服务。
- en: If you are an experienced Java developer using IDEs such as Eclipse, you will
    find yourself on familiar turf. Though most of it will be similar to building
    traditional applications, there are a few nuances, which we will discuss in this
    chapter and summarize at the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一名有经验的Java开发人员，使用Eclipse等IDE，您会发现自己置身熟悉的领域。尽管大部分内容与构建传统应用程序相似，但也有一些细微差别，我们将在本章中讨论并在最后进行总结。
- en: 'The setup steps to get development going will vary based on the type of developer:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开始开发的设置步骤将根据开发人员的类型而有所不同：
- en: For hobbyist, self-employed, or working-from-home developers with open access
    to the internet, cloud development is relatively simple.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于业余爱好者、自由职业者或在家工作的开发人员，可以自由访问互联网，云开发相对简单。
- en: for enterprise developers who work on projects for customers or business teams
    in a closed environment and has to access the internet through a proxy, you have
    your enterprise development guidelines to follow. You will be constrained in what
    you can download, run, and configure. Having said that, the benefit of being this
    type of developer is that you are not alone. You have the support of your team
    and colleagues who can help with informal help, or formal documentation in wikis.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在封闭环境中为客户或业务团队开发项目的企业开发人员，并且必须通过代理访问互联网，您需要遵循企业开发指南。您将受到在下载、运行和配置方面的限制。话虽如此，作为这种类型的开发人员的好处是您并不孤单。您有团队和同事的支持，他们可以通过非正式的帮助或维基文档提供正式的帮助。
- en: 'By the end of this chapter, you will have a cloud-native microservice running
    in your machine. To get there, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将在自己的机器上运行一个云原生微服务。为了达到这个目标，我们将涵盖以下主题：
- en: The developer's toolbox and ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者的工具箱和生态系统
- en: Internet connectivity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: The development life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发生命周期
- en: Framework selection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架选择
- en: Writing a cloud-native microservice
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写云原生微服务
- en: Enabling a few cloud native behaviors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用一些云原生行为
- en: Reviewing key aspects of cloud development
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查云开发的关键方面
- en: Setting up your developer toolbox
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发者工具箱
- en: For any profession, the tools are very important, and that applies to coding
    as well. Before writing a line of code, we need to get the right equipment to
    start.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何职业来说，工具都非常重要，编码也是如此。在编写一行代码之前，我们需要准备好正确的设备。
- en: Getting an IDE
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一个IDE
- en: An** integrated development environment** (**IDE**) is more than a code editor;
    it includes the tools for autocompletion, syntax, formatting, and other miscellaneous
    features, such as search and replace. IDEs have advanced features such as refactoring,
    building, testing, and running the programs with the help of runtime containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDE**）不仅仅是一个代码编辑器；它还包括自动完成、语法、格式化等工具，以及搜索和替换等其他杂项功能。IDE具有高级功能，如重构、构建、测试和在运行时容器的帮助下运行程序。'
- en: 'The popular IDEs are Eclipse, IntelliJ IDEA, and NetBeans. Of the three, Eclipse
    is the most popular and open source IDE available for Java. It has a big community
    and is frequently updated. It has a workspace and an extensible plugin system.
    The development potential of applications in a whole range of languages is endless.
    Some other development IDEs based on Eclipse include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的IDE包括Eclipse、IntelliJ IDEA和NetBeans。在这三者中，Eclipse是最受欢迎的开源Java IDE。它拥有庞大的社区，并经常更新。它具有工作区和可扩展的插件系统。在各种语言中应用程序的开发潜力是无限的。基于Eclipse的其他一些开发IDE包括以下内容：
- en: If you are going to do only Spring development, then the derivative of Eclipse
    called **Spring Tool Suite** (**STS**) is a good option.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只打算进行Spring开发，那么称为**Spring Tool Suite**（**STS**）的Eclipse衍生产品是一个不错的选择。
- en: There are also cloud IDEs such as Eclipse Che, touted as the next-generation
    Eclipse. It does not need any installation. You develop in a browser that connects
    to a Che server, which builds a workspace remotely (containing libraries, runtime,
    and dependencies) in a Docker container. As a result, you can develop from any
    machine and anyone can contribute to your project, with just a URL. If you think
    that is cool and have a need for a location- and machine-independent development,
    give it a spin.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些云IDE，比如被誉为下一代Eclipse的Eclipse Che。它不需要任何安装。您可以在连接到Che服务器的浏览器中进行开发，该服务器在Docker容器中远程构建工作区（包含库、运行时和依赖项）。因此，您可以从任何机器进行开发，任何人都可以通过一个URL为您的项目做出贡献。如果您认为这很酷，并且需要一个与位置和机器无关的开发环境，请试一试。
- en: For the purposes of this book, let's stick to the basic and hugely popular Eclipse.
    The current edition, at the time of writing this book, is Neon. A large community
    and configurable plugin support makes it the IDE of choice for cloud-based Java
    development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，让我们坚持使用基本且非常受欢迎的Eclipse。在撰写本书时，当前版本是Neon。庞大的社区和可配置的插件支持使其成为云基Java开发的首选IDE。
- en: Download the latest version from: [https://www.eclipse.org/](https://www.eclipse.org/).
    Assuming you have JDK 8 or later installed, Eclipse should start up fine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下网址下载最新版本：[https://www.eclipse.org/](https://www.eclipse.org/)。假设您已安装了JDK
    8或更高版本，Eclipse应该可以正常启动。
- en: 'Configure a workspace that will store your project files and settings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 配置一个将存储项目文件和设置的工作区：
- en: '![](img/d05a49d3-1c19-438f-afdd-9759f8202244.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05a49d3-1c19-438f-afdd-9759f8202244.png)'
- en: 'When you hit OK, the Eclipse IDE should open up. Eclipse Neon will automatically
    get you two important plugins we need for development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击确定时，Eclipse IDE应该会打开。Eclipse Neon将自动为您获取我们开发所需的两个重要插件：
- en: '**Git client**: This will allow us to connect to a Git source control repository.
    This book assumes you use Git due to its popularity and features, but there are
    many older options in use in enterprises, such as Subversion and Perforce. In
    case you use the alternatives, download the respective plugin to your IDE by following
    the developer setup instructions given by your project team or in your team wiki.
    If these instructions do not exist, ask to build one for new team members to use.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git客户端**：这将允许我们连接到Git源代码控制存储库。本书假设您使用Git，因为它很受欢迎并且功能强大，但在企业中还有许多旧的选项，如Subversion和Perforce。如果您使用其他选项，请按照您的项目团队或团队wiki中给出的开发人员设置说明下载相应的插件。如果这些说明不存在，请要求为新团队成员建立一个。'
- en: '**Maven support**: Maven and Gradle are both great project management and configuration
    tools. They help with tasks such as getting dependencies, compiling, building,
    and so on. We chose Maven because of its maturity with the enterprises.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven支持**：Maven和Gradle都是很好的项目管理和配置工具。它们有助于诸如获取依赖项、编译、构建等任务。我们选择Maven是因为它在企业中的成熟度。'
- en: If you are coming across these two for the first time, please get familiar with
    both by reading up on their respective websites.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次接触这两个工具，请通过阅读它们各自的网站来熟悉它们。
- en: Setting up internet connectivity
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立互联网连接
- en: If you are working in an enterprise and have to access internet through a proxy,
    this can be a pain based on what your enterprise policies limits you to do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在企业中工作并且必须通过代理访问互联网，根据您的企业政策限制您的操作，这可能会很麻烦。
- en: 'For our development purposes, we need internet connectivity for the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的开发目的，我们需要以下互联网连接：
- en: Downloading dependency libraries such as Log4j and Spring that are configured
    as part of the Maven repository. This is a one-time activity, as the libraries
    become part of the local Maven repository once downloaded. If your organization
    has a repository, you need to configure that.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载依赖库，如Log4j和Spring，这些库被配置为Maven存储库的一部分。这是一次性活动，因为一旦下载，这些库就成为本地Maven存储库的一部分。如果您的组织有一个存储库，您需要进行配置。
- en: Eclipse plugins from the marketplace as we evolve our sample application.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们样例应用的发展，从市场中获取Eclipse插件。
- en: Your program calls a service or APIs that are in the public cloud.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的程序调用了公共云中的服务或API。
- en: 'For writing our first service, only the first point is important. Please get
    your proxy details and configure them in the Maven settings from the main menu, Windows
    | Preferences, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编写我们的第一个服务，只有第一个点很重要。请获取您的代理详细信息，并在主菜单的Maven设置中进行配置，路径为Windows | Preferences。
- en: '![](img/d9570efd-e76c-4132-9c6e-bbc5d2386b57.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9570efd-e76c-4132-9c6e-bbc5d2386b57.png)'
- en: 'Make changes to the `settings.xml` file in User Settings and add a proxy section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对`settings.xml`文件进行更改，添加代理部分：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file and restart Eclipse. We will know whether it worked when we create
    a project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并重新启动Eclipse。当我们创建一个项目时，我们将知道它是否起作用。
- en: Understanding the development life cycle
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解开发生命周期
- en: Professional software writing goes through various stages. In the following
    sections, we will talk about all the various stages we will follow while developing
    the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 专业软件编写经历各种阶段。在接下来的章节中，我们将讨论在开发应用程序时将遵循的各个阶段。
- en: Requirements/user stories
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求/用户故事
- en: It is important to know the problem statement being solved before starting any
    coding or design. Agile development methodology recommends breaking the overall
    project into modules and services, and then implementing a few features at a time
    as user stories. The idea is to get a **minimally viable product** (**MVP**) and
    then keep adding features.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何编码或设计之前，了解要解决的问题陈述是很重要的。敏捷开发方法建议将整个项目分解为模块和服务，然后逐步实现一些功能作为用户故事。其思想是获得一个**最小可行产品**（MVP），然后不断添加功能。
- en: The problem we have taken to solve is an area of e-commerce. Due to online shopping,
    most of us are familiar with e-commerce as consumers. It is time to look under
    the hood.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的问题是电子商务领域。由于在线购物，我们大多数人都熟悉电子商务作为消费者。现在是时候来看看它的内部运作了。
- en: 'The starting point is a `product` service that does the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 起点是一个`product`服务，它执行以下操作：
- en: Returns details of a product given a product ID
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据产品ID返回产品的详细信息
- en: Gets a list of product IDs for a given product category
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定产品类别的产品ID列表
- en: Architecture
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: We have separate chapters dedicated to this later in the book. In brief, once
    the requirements are known, architecture is about taking key decisions and creating
    a blueprint of how the requirements will be realized, and the design is about
    contracts and mechanisms to implement them. For cloud-native development, we have
    taken a call to implement microservices architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的后面有专门的章节来讨论这个问题。简而言之，一旦需求确定，架构就是关于做出关键决策并创建需求实现蓝图的过程，而设计则是关于合同和机制来实现这些决策。对于云原生开发，我们决定实施微服务架构。
- en: The microservices architecture paradigm recommends smaller deployment units
    that contain a unit of functionality. Hence, our `product` service will run its
    own process and have its own runtime. This makes it easier to bundle the entire
    runtime, and take it from development to test environments and then to production
    with a consistent behavior. Each `product` service will register itself in a service
    registry to be discoverable to other services. We will examine the technology
    choices later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构范式建议使用包含功能单元的较小部署单元。因此，我们的`product`服务将运行自己的进程并拥有自己的运行时。这使得更容易打包整个运行时，并将其从开发环境带到测试环境，然后再到生产环境，并保持一致的行为。每个`product`服务将在服务注册表中注册自己，以便其他服务可以发现它。我们将在后面讨论技术选择。
- en: Design
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: Design takes a deeper dive into the interface and implementation decisions of
    the service. The `product` service will have a simple interface that takes a product
    ID and returns a Java object. If the product is not found in the repository, you
    can decide to return an exception or an empty product. The access is logged and
    metrics on how many times the service was accessed and how long it took are recorded.
    These are the design decisions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设计深入探讨了服务的接口和实现决策。`product`服务将具有一个简单的接口，接受产品ID并返回一个Java对象。如果在存储库中找不到产品，可以决定返回异常或空产品。访问被记录下来，记录了服务被访问的次数和所花费的时间。这些都是设计决策。
- en: We will discuss architecture and design principles specific to cloud development
    in detail in later chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中详细讨论特定于云开发的架构和设计原则。
- en: Testing and development
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和开发
- en: In any modern enterprise software development, testing is not an afterthought
    or an activity post development. It is done with or prior to the development through
    concepts such as **test-driven development** (**TDD**) and **behavior-driven development**
    (**BDD**). The test cases are written first, which fail initially. Then, enough
    code is written to pass the test case. This concept is extremely important for
    regression testing in future iterations of the product and blends nicely with
    the **continuous integration** (**CI**) and **continuous delivery** (**CD**) concepts
    discussed later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何现代企业软件开发中，测试都不是事后或开发后的活动。它是通过诸如**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**）等概念与开发同时进行或在开发之前进行的。首先编写测试用例，最初失败。然后编写足够的代码来通过测试用例。这个概念对于产品未来迭代中的回归测试非常重要，并与后面讨论的**持续集成**（**CI**）和**持续交付**（**CD**）概念完美融合。
- en: Building and deployment
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署
- en: Building and deployment are the steps to create the deployment unit from the
    source code and put it in the target runtime environment. The developer executes
    most of the steps in the IDE. However, with CI principles, an integration server
    does the compilation, automated test case execution, building the deployment unit,
    and deploying it in a target runtime.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署是从源代码创建部署单元并将其放入目标运行时环境的步骤。开发人员在IDE中执行大部分步骤。然而，根据CI原则，集成服务器进行编译、自动化测试用例执行、构建部署单元，并将其部署到目标运行时环境。
- en: In a cloud environment, the deployable unit is deployed on a virtual environment
    such as a **virtual machine** (**VM**) or in a container. As part of the deployment,
    it is important to include the necessary runtimes and dependencies as part of
    the build process itself. This is different from the traditional process of putting
    a `.war` or `.ear` in an application server running in each environment. Including
    all dependencies in the deployable unit makes it complete and consistent as it
    moves across the various environments. This reduces the chances of errors where
    the dependencies on server does not match with those on the local machine of the
    developer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，可部署单元部署在虚拟环境中，如**虚拟机**（**VM**）或容器中。作为部署的一部分，将必要的运行时和依赖项包含在构建过程中非常重要。这与将`.war`或`.ear`放入每个环境中运行的应用服务器的传统过程不同。将所有依赖项包含在可部署单元中使其在不同环境中完整和一致。这减少了出现错误的机会，即服务器上的依赖项与开发人员本地机器上的依赖项不匹配。
- en: Selecting a framework
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择框架
- en: 'Having looked at the basics, let''s write our `product` service. After IDE
    setup, the next step is to select a framework to write the service. The microservice
    architecture puts forward a few interesting design considerations that will help
    us select the frameworks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了基础知识之后，让我们编写我们的`product`服务。在IDE设置之后，下一步是选择一个框架来编写服务。微服务架构提出了一些有趣的设计考虑，这将帮助我们选择框架：
- en: '**Lightweight runtime**: The service should be small in size and fast to deploy'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级运行时**：服务应该体积小，部署快速'
- en: '**High resiliency**: It should have support for patterns such as circuit breaker
    and timeout'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高弹性**：应该支持诸如断路器和超时等模式'
- en: '**Measurable and monitorable**: It should capture metrics and expose hooks
    for monitoring agents to tap into'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测量和可监控**：应该捕获指标并公开钩子供监控代理使用'
- en: '**Efficient**: It should avoid blocking resources and enable high scalability
    and elasticity in the presence of increased load'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：应该避免阻塞资源，在负载增加的情况下实现高可伸缩性和弹性'
- en: 'A good comparison can be found at: [https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html](https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html).
    Three frameworks are gaining popularity in the Java space that meet the preceding
    requirements: Dropwizard, Vert.x, and Spring Boot.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到一个很好的比较：[https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html](https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html)。在Java领域，有三个框架正在变得流行，符合前述要求：Dropwizard，Vert.x和Spring
    Boot。
- en: Dropwizard
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dropwizard
- en: Dropwizard was one of the first frameworks to popularize the fat JAR concept
    by putting container runtime with all dependencies and libraries inside the deployment
    unit, instead of putting the deployment unit inside the container. It mashes up
    libraries such as Jetty for HTTP, Jackson for JSON, Jersey for REST, and Metrics
    to create a perfect blend for building RESTful web services. It was one of the
    early frameworks to be used in microservice development.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Dropwizard是最早推广fat JAR概念的框架之一，通过将容器运行时与所有依赖项和库一起放入部署单元，而不是将部署单元放入容器。它整合了Jetty用于HTTP，Jackson用于JSON，Jersey用于REST和Metrics等库，创建了一个完美的组合来构建RESTful
    web服务。它是早期用于微服务开发的框架之一。
- en: Its choices, such as JDBI, Freemarker, and Moustache, might sound restrictive
    for some organizations that want flexibility in their choice of implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它的选择，如JDBI，Freemarker和Moustache，可能对一些希望在实现选择上灵活的组织来说有所限制。
- en: Vert.x
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vert.x
- en: Vert.x is an excellent framework to build reactive applications that do not
    block resources (threads) and hence are very scalable and elastic, and hence resilient.
    It is a relatively new kid on the block (with major upgrades in version 3.0).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x是一个出色的框架，用于构建不会阻塞资源（线程）的反应式应用程序，因此非常可伸缩和弹性，因此具有弹性。它是一个相对较新的框架（在3.0版本中进行了重大升级）。
- en: However, its Reactive programming model is not very popular in the industry
    yet and hence it is just gaining adoption, especially for use cases that require
    very high resiliency and scalability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它的响应式编程模型在行业中并不十分流行，因此它只是在获得采用，特别是对于需要非常高的弹性和可伸缩性的用例。
- en: Spring Boot
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: 'Spring Boot is rapidly becoming the most popular of the Java frameworks for
    building cloud-native microservices. Here are a few good reasons:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot正在迅速成为构建云原生微服务的Java框架中最受欢迎的。以下是一些很好的理由：
- en: It has a foundation on Spring and Spring MVC, which is already popular in enterprises
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它建立在Spring和Spring MVC的基础上，这在企业中已经很受欢迎
- en: Like Dropwizard, it assembles the most reasonable defaults and takes an opinionated
    approach to assembling the required dependencies for the services, reducing the
    XML required for configuration
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Dropwizard一样，它汇集了最合理的默认值，并采用了一种偏向的方法来组装所需的服务依赖项，减少了配置所需的XML
- en: It integrates Spring Cloud out of the box, which provides useful libraries such
    as Hystrix and Ribbon, for distributed service development that is required for
    cloud deployment
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以直接集成Spring Cloud，提供诸如Hystrix和Ribbon之类的有用库，用于云部署所需的分布式服务开发
- en: It has a lower learning curve; you can get started in minutes (as we shall see
    next)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的学习曲线较低；您可以在几分钟内开始（接下来我们将看到）
- en: It has the concept of 40+ starter Maven **Project Object Models (POMs)** that
    give good flexibility for choosing and developing applications
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有40多个起始Maven **项目对象模型（POMs）**的概念，为选择和开发应用程序提供了很好的灵活性
- en: Spring Boot is suitable for a wide spectrum of the workloads that are suitable
    for cloud-native deployments and hence is a good first choice for most use cases.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot适用于适合云原生部署的各种工作负载，因此对于大多数用例来说是一个很好的首选。
- en: Let's get into writing a service in Spring Boot now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写一个Spring Boot服务。
- en: Writing a product service
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写产品服务
- en: 'For the sake of simplicity, our `product` service has two functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的`product`服务有两个功能：
- en: '`List<int> getProducts(int categoryId)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<int> getProducts(int categoryId)`'
- en: '`Product getProduct(int prodId)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product getProduct(int prodId)`'
- en: The intent of the two methods is quite clear. The first returns a list of product
    IDs given a category ID, and the second returns product details (as an object)
    given a product ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的意图非常明确。第一个返回给定类别ID的产品ID列表，第二个返回给定产品ID的产品详细信息（作为对象）。
- en: Service registration and discovery
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现
- en: Why is service registration and discovery important? So far, we have been calling
    the service through its URL, which includes the IP address—for example, `http://localhost:8080/prod`—thus
    we expect the service to run at that address. Even though we might substitute
    the test and the production URLs, the step of calling the service at a particular
    IP address and port is still static.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册和发现为什么重要？到目前为止，我们一直通过其URL调用服务，其中包括IP地址，例如`http://localhost:8080/prod`，因此我们期望服务在该地址运行。即使我们可能替换测试和生产URL，调用特定IP地址和端口的服务步骤仍然是静态的。
- en: However, in a cloud environment, things are quite dynamic. If the service goes
    down at a given IP, it can come up in a different IP address as it comes up on
    some container. Although we can mitigate that with virtual IPs and reverse proxies,
    it would be better to look up a service dynamically at the time of the service
    call and then call the service at the IP address. The lookup addresses can be
    cached in the client, so that the dynamic lookup need not be performed for each
    service call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在云环境中，事情变化很快。如果服务在给定的IP上停机，它可以在不同的IP地址上启动，因为它在某个容器上启动。虽然我们可以通过虚拟IP和反向代理来缓解这一问题，但最好在服务调用时动态查找服务，然后在IP地址上调用服务。查找地址可以在客户端中缓存，因此不需要为每个服务调用执行动态查找。
- en: A registry (referred to as a service registry) helps in this case. When the
    service boots up, it registers itself in a registry. There is also a heartbeat
    between registry and service to ensure that the registry keeps only live services
    in its registry. If the heartbeat stops, the registry deregisters that instance
    of the service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，注册表（称为服务注册表）很有帮助。当服务启动时，它会在注册表中注册自己。注册表和服务之间也有心跳，以确保注册表中只保留活动的服务。如果心跳停止，注册表将注销该服务实例。
- en: 'For this quick starter, we are going to use Spring Cloud Netflix, which nicely
    integrates with Spring Boot. We need three components now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个快速入门，我们将使用Spring Cloud Netflix，它与Spring Boot很好地集成。现在我们需要三个组件：
- en: '**Product service**: We have already written this'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品服务**：我们已经编写了这个'
- en: '**Service registry**: We are going to use Eureka, which is part of Spring Cloud'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务注册表**：我们将使用Eureka，它是Spring Cloud的一部分'
- en: '**Service client**: Instead of calling our service directly through a browser,
    we will write a simple client to our service'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务客户端**：我们将编写一个简单的客户端来调用我们的服务，而不是直接通过浏览器调用'
- en: Creating a Maven project
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Maven项目
- en: 'Open your IDE (Eclipse Neon or other) and then create a new Maven project as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的IDE（Eclipse Neon或其他），然后按以下步骤创建一个新的Maven项目：
- en: 'Right-click on Package Explorer and select New and Project..., as shown in
    the following screenshot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Package Explorer上右键单击，然后选择New和Project...，如下截图所示：
- en: '![](img/681949d8-038d-4675-9be2-8e5a65d86c5a.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/681949d8-038d-4675-9be2-8e5a65d86c5a.png)'
- en: 'Select Maven Project:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Maven项目：
- en: '![](img/9fe14540-94a8-4cd4-b7fe-156e2d293869.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fe14540-94a8-4cd4-b7fe-156e2d293869.png)'
- en: In the next window of the wizard, choose Create a simple project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的下一个窗口中，选择创建一个简单的项目。
- en: 'The next dialog will ask for many parameters. Of these, the Group Id (what
    your project name is) and the Artifact Id (application or service name) are important.
    Select reasonable names, as shown in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对话框将要求输入许多参数。其中，Group Id（你的项目名称）和Artifact Id（应用程序或服务名称）很重要。选择合理的名称，如下面的截图所示：
- en: '![](img/1c3962d4-41d2-4a1f-9fda-56f35f23a737.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c3962d4-41d2-4a1f-9fda-56f35f23a737.png)'
- en: 'Select Finish. You should see the following structure:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择完成。你应该看到以下结构：
- en: '![](img/f7096253-de5c-4104-ac43-57ab9881fb77.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7096253-de5c-4104-ac43-57ab9881fb77.png)'
- en: If the JRE System Library [JavaSE-1.6] does not exist, or you have a later version,
    go to the project properties and edit it to select the version that your Eclipse
    is configured with. You do this by changing the Properties by right-clicking JRE
    System Library [JavaSE-1.6]. Here's a screenshot after adjusting the JRE System Library
    to 1.8.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JRE System Library [JavaSE-1.6]不存在，或者你有一个更新的版本，去项目属性中编辑它，选择你的Eclipse配置的版本。你可以通过右键单击JRE
    System Library [JavaSE-1.6]来改变属性。这是调整JRE System Library到1.8后的截图。
- en: '![](img/43dfa29c-079f-4a17-b400-375158b121f4.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43dfa29c-079f-4a17-b400-375158b121f4.png)'
- en: 'Now, you have a clean slate. Open the Maven file `pom.xml` and add a dependency
    to the `spring-boot-starter-web`. This will tell Spring Boot to configure this
    project to get libraries for web development:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你有一个干净的板面。打开Maven文件`pom.xml`，并添加一个依赖项`spring-boot-starter-web`。这将告诉Spring
    Boot配置这个项目以获取web开发的库：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you save this POM file, your IDE will build the workspace and download
    the dependent libraries, assuming your internet connection works (directly or
    through a proxy as configured before), and you are all set to develop the service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个POM文件时，你的IDE将构建工作区并下载依赖的库，假设你的互联网连接正常（直接或通过之前配置的代理），你已经准备好开发服务了。
- en: Writing a Spring Boot application class
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个Spring Boot应用程序类
- en: 'This class contains the main method where the execution starts. This main method
    will bootstrap the Spring Boot application, look at the configurations, and start
    the respective bundled containers such as Tomcat if executing web services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了执行开始的主方法。这个主方法将引导Spring Boot应用程序，查看配置，并启动相应的捆绑容器，比如Tomcat，如果执行web服务：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the annotation called `@SpringBootApplication`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意注解`@SpringBootApplication`。
- en: 'The `@SpringBootApplication` annotation is equivalent to using `@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`, which do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication`注解等同于使用`@Configuration`，`@EnableAutoConfiguration`和`@ComponentScan`，它们分别执行以下操作：'
- en: '`@Configuration`: This is a core Spring annotation. It tells Spring that this
    class is a source of the `Bean` definitions.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`：这是一个核心的Spring注解。它告诉Spring这个类是`Bean`定义的来源。'
- en: '`@EnableAutoConfiguration`: This annotation tells Spring Boot to guess how
    you will want to configure Spring, based on the JAR dependencies that you have
    added. We have added the starter web and hence the application will be considered
    to be a Spring MVC web application.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`：这个注解告诉Spring Boot根据你添加的JAR依赖来猜测你想要如何配置Spring。我们添加了starter
    web，因此应用程序将被视为Spring MVC web应用程序。'
- en: '`@ComponentScan`: This annotation tells Spring to scan for any components,
    for example, the `RestController` that we are going to write. Note the scan happens
    in current and child packages. Hence, the class having this component scan should
    be at the top of the package hierarchy.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`：这个注解告诉Spring扫描任何组件，例如我们将要编写的`RestController`。注意扫描发生在当前和子包中。因此，拥有这个组件扫描的类应该在包层次结构的顶部。'
- en: Writing service and domain objects
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写服务和领域对象
- en: The annotations in Spring Boot make it easy to extract parameters and path variables
    and execute the service. For now, let's mock the response instead of getting the
    data from the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot中的注解使得提取参数和路径变量并执行服务变得容易。现在，让我们模拟响应，而不是从数据库中获取数据。
- en: 'Create a simple Java entity called the `Product` class. For now, it is a simple **Plain
    Old Java Object** (**POJO**) class with three fields:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的Java实体，称为`Product`类。目前，它是一个简单的**POJO**类，有三个字段：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the getter and setter methods and a constructor that accepts the product
    ID:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加获取器和设置器方法以及接受产品ID的构造函数：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, add an empty constructor that will be used by the service client, as
    we will see later:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，添加一个空的构造函数，将在后面由服务客户端使用：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, write the `ProductService` class as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写`ProductService`类如下：
- en: '![](img/e48d02a3-1d11-4c87-b0f6-933b6155d8a2.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e48d02a3-1d11-4c87-b0f6-933b6155d8a2.png)'
- en: Running the service
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务
- en: There are many ways to run the service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以运行服务。
- en: 'Right-click on the project and select Run As | Maven build and configure the
    Run Configurations to execute the `spring-boot:run` target as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击项目，选择Run As | Maven build，并配置Run Configurations来执行`spring-boot:run`目标如下：
- en: '![](img/517a372f-2512-46ef-8db3-44f2e63bac93.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/517a372f-2512-46ef-8db3-44f2e63bac93.png)'
- en: 'On clicking Run, if the internet connection and configuration are fine, you
    will see the following console output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行，如果互联网连接和配置正常，你将看到以下控制台输出：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the stages of the Maven execution:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Maven执行的阶段：
- en: First, the Maven task compiles all the Java files. We have three simple Java
    classes as of now.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，Maven任务编译所有的Java文件。目前我们有三个简单的Java类。
- en: The next step runs it as an application, where a Tomcat instance starts.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将其作为一个应用程序运行，其中一个Tomcat实例启动。
- en: Note the mapping of the URLs `/product/` and `/productIds` to the `Bean` methods.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意将URL `/product/`和`/productIds`映射到`Bean`方法。
- en: Tomcat listens on port `8080` for service requests.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tomcat监听端口`8080`以接收服务请求。
- en: You can also run the service by just right-clicking the class that has the main
    method (`ProductSpringApp`) in Package Explorer and then selecting Run As | Java
    Application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在Package Explorer中右键单击具有主方法的类（`ProductSpringApp`）然后选择Run As | Java Application来运行服务。
- en: Testing the service on the browser
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器上测试服务
- en: 'Open a browser and hit the following URL: `http://localhost:8080/product/1`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，访问以下URL：`http://localhost:8080/product/1`。
- en: 'You should get back the following response:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下响应：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, try the other service (URL—`http://localhost:8080/productIds`). What response
    do you get? An error, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试另一个服务（URL—`http://localhost:8080/productIds`）。你得到什么响应？一个错误，如下所示：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Can you guess why? It is because the service definition that you wrote had
    a method expecting a request parameter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到为什么吗？这是因为你写的服务定义有一个期望请求参数的方法：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, the URL is expecting an `id` and as you did not supply it, it gives an error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，URL需要一个`id`，由于你没有提供它，所以会出错。
- en: Give the parameter and try  `http://localhost:8080/productIds?id=5` again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 给出参数，再次尝试  `http://localhost:8080/productIds?id=5`。
- en: 'You will now get back a correct response:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会得到一个正确的响应：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a deployable
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可部署文件
- en: 'We are not going to run our service on Eclipse. We would like to deploy it
    on a server. There are two options for doing this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在Eclipse上运行我们的服务。我们想要在服务器上部署它。有两种选择：
- en: Create a WAR and deploy it in Tomcat or any other web container. This is the
    traditional method.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个WAR文件，并将其部署到Tomcat或任何其他Web容器中。这是传统的方法。
- en: Create a JAR with the runtime (Tomcat) included so that you just need Java to
    execute the service.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含运行时（Tomcat）的JAR，这样你只需要Java来执行服务。
- en: 'In cloud application development, the second option, also called fat JAR or
    uber JAR, is becoming popular for the following reasons:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在云应用程序开发中，第二个选项，也称为fat JAR或uber JAR，因以下原因而变得流行：
- en: The deployable is self-contained with all the dependencies it needs. This reduces
    the chances of environment mismatch as the deployable unit is deployed to Dev,
    Test, UAT, and Production. If it works in development, there is a good chance
    it will work across all the other environments.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可部署文件是自包含的，具有其所需的所有依赖项。这减少了环境不匹配的可能性，因为可部署单元被部署到开发、测试、UAT和生产环境。如果在开发中工作，它很可能会在所有其他环境中工作。
- en: The host, server, or container where the service is deployed need not have a
    preinstalled application server or servlet engine. Just a basic JRE is good enough.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署服务的主机、服务器或容器不需要预安装应用服务器或servlet引擎。只需一个基本的JRE就足够了。
- en: Let's look at the steps to create a JAR file and run it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建JAR文件并运行它的步骤。
- en: 'Include the following dependencies of the POM file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 包括POM文件的以下依赖项：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, run it by right-clicking the project in the explorer and choosing Run As
    | Maven Install.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在资源管理器中右键单击项目并选择Run As | Maven Install来运行它。
- en: You will see `product-0.0.1-SNAPSHOT.jar` in the target directory of the project
    folder structure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在项目文件夹结构的目标目录中看到`product-0.0.1-SNAPSHOT.jar`。
- en: 'Navigate to the `product` folder so that you see the target directory in the
    command line and then run the JAR through a Java command, as shown in the following
    screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`product`文件夹，以便在命令行中看到目标目录，然后通过Java命令运行JAR，如下面的屏幕截图所示：
- en: '![](img/43947a81-a87d-47cb-832f-a0a4ecb0893c.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43947a81-a87d-47cb-832f-a0a4ecb0893c.png)'
- en: You will see Tomcat listening to the port at the end of the startup. Test it
    through the browser again. Milestone achieved.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到Tomcat在启动结束时监听端口。再次通过浏览器测试。里程碑达成。
- en: Enabling cloud-native behaviors
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用云原生行为
- en: 'We have just developed a basic service with two APIs that respond to requests.
    Let''s add a few capabilities that will enable to it to be a good cloud citizen.
    We will discuss the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开发了一个基本的服务，有两个API响应请求。让我们添加一些功能，使其成为一个良好的云服务。我们将讨论以下内容：
- en: Externalizing configuration
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化配置
- en: Instrumentation—health and metrics
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪器化—健康和指标
- en: Service registration and discovery
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册和发现
- en: Externalizing configuration
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化配置
- en: Configuration can be any property that is likely to differ between environments
    or production deployments. Typical examples are queue and topic names, ports,
    URLs, connection and pool properties, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以是在环境或生产部署之间可能不同的任何属性。典型的例子是队列和主题名称、端口、URL、连接和池属性等。
- en: A deployable should not have configuration in it. A configuration should be
    injected from outside. This makes the deployable unit immutable as it goes through
    the various stages of the life cycle, such as Dev, QA, and UAT.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可部署文件不应该包含配置。配置应该从外部注入。这使得可部署单元在生命周期的各个阶段（如开发、QA和UAT）中是不可变的。
- en: 'Let''s assume we have to run our `product` service in different environments,
    where the URL differentiates the environment. Therefore, the small change we make
    in the request mapping is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须在不同的环境中运行我们的`product`服务，其中URL区分环境。因此，我们在请求映射中做的小改变如下：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can inject this variable in various ways. Once injected, the value is not
    expected to change for the life of the deployment. The simplest is to pass it
    in the command-line argument. Bring up the Run Configurations dialog and in the
    Arguments, add the command-line parameter `-env=dev/` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以各种方式注入这个变量。一旦注入，该值在部署的生命周期内不应该改变。最简单的方法是通过命令行参数传递。打开运行配置对话框，在参数中添加命令行参数`-env=dev/`，如下所示：
- en: '![](img/c0613d40-8b94-4e8b-8f03-81ba4ddbd6cc.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0613d40-8b94-4e8b-8f03-81ba4ddbd6cc.png)'
- en: 'Now, Run the configuration. During startup, you will find the value substituted
    in the log statement as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行配置。在启动过程中，你会发现值被替换在日志声明中，如下所示：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The configuration can also be provided through configuration files, database,
    operating system environment properties, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置也可以通过配置文件、数据库、操作系统环境属性等提供。
- en: Spring applications popularly use `application.properties` to store a few properties
    such as port numbers. Recently, YAML, which is a superset of JSON, is becoming
    more popular due to the hierarchical definition of the properties.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序通常使用`application.properties`来存储一些属性，如端口号。最近，YAML，它是JSON的超集，由于属性的分层定义，变得更加流行。
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`/product/src/main/resources`文件夹中创建一个`application.yml`文件，并输入以下内容：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This tells the `product` service to run at port `8081` instead of the default
    `8080`. This concept is further extended to profiles. So, it is possible to load
    different profiles by loading the configuration specific to the profile.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`product`服务在端口`8081`上运行，而不是默认的`8080`。这个概念进一步扩展到配置文件。因此，可以通过加载特定于配置文件的配置来加载不同的配置文件。
- en: Spring Cloud Config as a project handles this well. It uses a `bootstrap.yml`
    file to get the application started up with a name and details of the source to
    further load the configuration. Hence, `bootstrap.yml` contains the application
    name and config server details, and then loads the respective profile configuration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config作为一个项目很好地处理了这个问题。它使用`bootstrap.yml`文件来启动应用程序，并加载配置的名称和详细信息。因此，`bootstrap.yml`包含应用程序名称和配置服务器详细信息，然后加载相应的配置文件。
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`resources`文件夹中创建一个`bootstrap.yml`文件，并输入以下内容：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will come back to these files when we discuss service registration later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论服务注册时，我们将回到这些文件。
- en: Metering your services
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计量您的服务
- en: Instrumentation is important for cloud applications. Your service should expose
    health check and metrics so that it can be monitored better. Spring Boot allows
    for easier instrumentation through the `actuator` module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化对于云应用程序非常重要。您的服务应该公开健康检查和指标，以便更好地进行监控。Spring Boot通过`actuator`模块更容易进行仪器化。
- en: 'Include the following in your POM:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在POM中包含以下内容：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the service. During startup, you will see a number of mappings being created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务。在启动过程中，您将看到创建了许多映射。
- en: 'You can access these URLs (such as `http://localhost:8080/env`) directly and
    see the information displayed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接访问这些URL（例如`http://localhost:8080/env`）并查看显示的信息：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The metrics are especially interesting (`http://localhost:8080/metrics`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 指标尤其有趣（`http://localhost:8080/metrics`）：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The information includes the counters and gauges which store the number of times
    the service was accessed and the response times.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 信息包括计数器和量规，用于存储服务被访问的次数和响应时间。
- en: Running a service registry
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务注册表
- en: Consul and Eureka are two popular dynamic service registries. There are subtle
    conceptual differences between them with respect to the method of heartbeats and
    agent-based operations, but the fundamental concept of registry is similar. The
    selection of the registry will be driven by the needs and the decisions of the
    enterprise. For our example, let's continue with Spring Boot and the Spring Cloud
    ecosystem and use Eureka for this example. Spring Cloud includes Spring Cloud
    Netflix, which has support for the Eureka registry.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Consul和Eureka是两个流行的动态服务注册表。它们在心跳方法和基于代理的操作方面存在微妙的概念差异，但注册表的基本概念是相似的。注册表的选择将受企业的需求和决策的驱动。对于我们的示例，让我们继续使用Spring
    Boot和Spring Cloud生态系统，并为此示例使用Eureka。Spring Cloud包括Spring Cloud Netflix，它支持Eureka注册表。
- en: 'Perform the following steps to get a service registry running:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以运行服务注册表：
- en: Create a new Maven project with `artifactId` as `eureka-server`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Maven项目，`artifactId`为`eureka-server`。
- en: 'Edit the POM file and add the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑POM文件并添加以下内容：
- en: Parent as `spring-boot-starter-parent`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父级为`spring-boot-starter-parent`
- en: The dependency to `eureka-server` as ``spring-cloud-starter-eureka-server``
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于`eureka-server`为`spring-cloud-starter-eureka-server`
- en: 'The `dependencyManagement` to `spring-cloud-netflix`:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencyManagement`为`spring-cloud-netflix`：'
- en: '![](img/432ff7ef-5eb6-4cc5-9810-9280b967d0e7.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/432ff7ef-5eb6-4cc5-9810-9280b967d0e7.png)'
- en: 'Create an application class similar to the one we created for the `product`
    project. Note the annotations. The annotation `@EnableEurekaServer` starts Eureka
    as a service:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于我们为`product`项目创建的应用程序类。注意注解。注解`@EnableEurekaServer`将Eureka作为服务启动：
- en: '![](img/f1c9c5e9-be4a-4332-8242-c5a24e496291.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1c9c5e9-be4a-4332-8242-c5a24e496291.png)'
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`/product/src/main/resources`文件夹中创建一个`application.yml`文件，并输入以下内容：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`resources`文件夹中创建一个`bootstrap.yml`文件，并输入以下内容：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Build the `eureka-server` Maven project (as we did for `product`) and then run
    it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`eureka-server` Maven项目（就像我们为`product`做的那样），然后运行它。
- en: 'Apart from a few connectivity errors (more on this later), you should see a
    Tomcat started message as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了一些连接错误（稍后会详细介绍），您应该看到以下Tomcat启动消息：
- en: '![](img/aa53f30d-18e5-46f3-b83d-342370af2aec.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa53f30d-18e5-46f3-b83d-342370af2aec.png)'
- en: 'Once the startup is completed, access the Eureka server at `localhost:8761`
    and check whether you get the following page:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 启动完成后，访问`localhost:8761`上的Eureka服务器，并检查是否出现以下页面：
- en: '![](img/be32fc66-1a70-47a3-bad5-8d633506d118.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be32fc66-1a70-47a3-bad5-8d633506d118.png)'
- en: Look at the circled section in the preceding screenshot. The instance currently
    registered with Eureka is `EUREKA` itself. We can correct this later. Now, let's
    focus on registering our `product` service with this Eureka service registry.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面截图中的圈定部分。当前注册到Eureka的实例是`EUREKA`本身。我们可以稍后更正这一点。现在，让我们专注于将我们的`product`服务注册到这个Eureka服务注册表。
- en: Registering a product service
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册产品服务
- en: 'The `product` service boots up and listens on port `8081` for `product` service
    requests. We will now add the necessary instructions so that the service instance
    registers itself with the Eureka registry. Thanks to Spring Boot, we only have
    to do a few configurations and annotations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务启动并监听端口`8081`以接收`product`服务请求。现在，我们将添加必要的指示，以便服务实例将自身注册到Eureka注册表中。由于Spring
    Boot，我们只需要进行一些配置和注解：'
- en: 'Add the `dependencyManagement` section with dependency on `spring-cloud-netflix`
    and the dependency in the existing dependencies section to `spring-cloud-starter-eureka`
    to the `product` service POM as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`服务POM中添加`dependencyManagement`部分，依赖于`spring-cloud-netflix`和现有依赖项部分中的`spring-cloud-starter-eureka`如下所示：
- en: '![](img/582a3747-c882-43dd-a428-9c5e34411f9b.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/582a3747-c882-43dd-a428-9c5e34411f9b.png)'
- en: 'The `product` service keeps renewing its lease every specific interval. Reduce
    it to 5 seconds, by defining an entry explicitly in the `application.yml` as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product`服务会在特定间隔内不断更新其租约。通过在`application.yml`中明确定义一个条目，将其减少到5秒：'
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Include the annotation `@EnableDiscoveryClient` in the startup application
    class of the `product` project, in other words, `ProductSpringApp`. The `@EnableDiscoveryClient`
    annotation activates the Netflix Eureka `DiscoveryClient` implementation as that
    is the one we have defined in the POM file. There are other implementations for
    other service registries, such as HashiCorp Consul or Apache Zookeeper:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`项目的启动应用程序类中包含`@EnableDiscoveryClient`注解，换句话说，`ProductSpringApp`。`@EnableDiscoveryClient`注解激活Netflix
    Eureka `DiscoveryClient`实现，因为这是我们在POM文件中定义的。还有其他实现适用于其他服务注册表，如HashiCorp Consul或Apache
    Zookeeper：
- en: '![](img/397e1c42-3d6c-424c-9012-305e71f783ae.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/397e1c42-3d6c-424c-9012-305e71f783ae.png)'
- en: 'Now, start the `product` service as before:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像以前一样启动`product`服务：
- en: '![](img/8e4e43cc-a802-441d-b9ba-0f169af84c0c.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4e43cc-a802-441d-b9ba-0f169af84c0c.png)'
- en: At the end of the initialization of the `product` service, you will see log
    statements that register the service with the Eureka server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product`服务初始化结束时，您将看到注册服务到Eureka服务器的日志声明。
- en: 'To check whether the `product` service has registered, refresh the Eureka server
    page that you just accessed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`product`服务是否已注册，请刷新您刚访问的Eureka服务器页面：
- en: '![](img/2c653d48-c5d6-4702-83bf-e03c58e5131b.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c653d48-c5d6-4702-83bf-e03c58e5131b.png)'
- en: Also keep a tab on the Eureka log. You will find the lease renewal log statements
    of the `product` service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还要留意Eureka日志。您会发现`product`服务的租约续订日志声明。
- en: Creating a product client
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品客户端
- en: We have created a dynamic product registry and even registered our service.
    Now, let's use this lookup to access the `product` service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个动态产品注册表，甚至注册了我们的服务。现在，让我们使用这个查找来访问`product`服务。
- en: We will use the Netflix Ribbon project, which provides a load balancer as well
    as having address lookup from the service registry. Spring Cloud makes it easier
    to configure and use this.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Netflix Ribbon项目，该项目提供了负载均衡器以及从服务注册表中查找地址的功能。Spring Cloud使配置和使用这一切变得更加容易。
- en: 'For now, let''s run the client within the same project as the service itself.
    The client will make an HTTP call to the service after looking up the product
    definition in Eureka. All this will be done by the Ribbon library, and we will
    just be using it as an endpoint:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在与服务本身相同的项目中运行客户端。客户端将在Eureka中查找产品定义后，向服务发出HTTP调用。所有这些都将由Ribbon库完成，我们只需将其用作端点：
- en: 'Add a dependency to the Maven POM of the `product` project as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`项目的Maven POM中添加依赖如下：
- en: '![](img/a120da92-e357-4c87-a464-4497467711cd.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a120da92-e357-4c87-a464-4497467711cd.png)'
- en: 'Create a `ProductClient` class, which simply listens on `/client` and then
    forwards the request after doing a lookup to the actual `product` service:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ProductClient`类，它简单地监听`/client`，然后在进行查找后将请求转发到实际的`product`服务：
- en: '![](img/a9340beb-00a1-47e4-b71f-2fd7ebcb4681.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9340beb-00a1-47e4-b71f-2fd7ebcb4681.png)'
- en: The URL construction `http://PRODUCT/` will be translated at runtime by Ribbon
    after doing a lookup. We are nowhere giving an IP address of the service.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: URL构造`http://PRODUCT/`将在运行时由Ribbon进行翻译。我们没有提供服务的IP地址。
- en: 'The `restTemplate` is injected here through auto-wiring. However, it needs
    to be initialized in the latest Spring versions. Hence, declare it as follows
    in the main application class, which also acts as a configuration class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restTemplate`通过自动装配在这里注入。但是，在最新的Spring版本中需要初始化它。因此，在主应用程序类中声明如下，这也充当配置类：'
- en: '![](img/da08bf22-4652-47b9-bdc4-29a5a359104e.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da08bf22-4652-47b9-bdc4-29a5a359104e.png)'
- en: The `@LoadBalanced` annotation tells Spring to use the Ribbon load balancer
    (as Ribbon is in the classpath due to Maven).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`@LoadBalanced`注解告诉Spring使用Ribbon负载均衡器（因为Ribbon在类路径中由Maven提供）。'
- en: Seeing the lookup in action
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看查找的实际操作
- en: 'Now, we are all set to run the product client. To recap, at this stage, we
    have a Eureka server project and a `product` project with the following structure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行产品客户端了。简而言之，在这个阶段，我们有一个Eureka服务器项目和一个具有以下结构的`product`项目：
- en: '![](img/e6bb7836-fac8-4b95-a37b-c562d0d4fd4c.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6bb7836-fac8-4b95-a37b-c562d0d4fd4c.png)'
- en: 'Let''s take a few minutes to review what we did:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间来回顾一下我们做了什么：
- en: We created a Maven project and defined the starters and dependencies.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个Maven项目并定义了启动器和依赖项。
- en: We created the YML files for bootstrapping and application properties.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为引导和应用程序属性创建了YML文件。
- en: We created the `ProductSpringApp` class containing the main method that is the
    starting point of the applications.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了包含主方法的`ProductSpringApp`类，这是应用程序的起点。
- en: 'For the `product` project, we had the following classes:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`product`项目，我们有以下类：
- en: '`Product`: The domain or entity which we will enhance later'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`：我们稍后将增强的领域或实体'
- en: '`ProductService`: The microservice responsible for implementing the services
    and APIs'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductService`：负责实现服务和API的微服务'
- en: '`ProductClient`: The client to test out the service lookup'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductClient`：用于测试服务查找的客户端'
- en: 'Now, let''s see it in action:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它的实际操作：
- en: 'Run the `EurekaApplication` class (or run a Maven build on the `eureka-server`
    project). Observe the last few lines in the logs:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`EurekaApplication`类（或在`eureka-server`项目上运行Maven构建）。观察日志中的最后几行：
- en: '![](img/9624f0d6-6e69-49df-9d35-0988accb12c2.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9624f0d6-6e69-49df-9d35-0988accb12c2.png)'
- en: 'Run the `ProductSpringApp` class (or run a Maven build on the `product` project).
    Note the last few lines in the the log:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ProductSpringApp`类（或在`product`项目上运行Maven构建）。注意日志中的最后几行：
- en: '![](img/57e4b508-31d3-4563-985e-2fa5b451d62e.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57e4b508-31d3-4563-985e-2fa5b451d62e.png)'
- en: Access the `product` service directly at: `http://localhost:8081/dev/product/4`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接访问`product`服务：`http://localhost:8081/dev/product/4`。
- en: 'You will see the following response:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, access the client URL, `http://localhost:8081/client/4` , which does a
    lookup of the `product` service from the service registry and directs it to the
    respective `product` service.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问客户端URL，`http://localhost:8081/client/4`，它会从服务注册表中查找`product`服务并将其指向相应的`product`服务。
- en: 'You will see the following response:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may see an internal server error (`No instances available for PRODUCT`).
    This can happen while the heartbeat completes and the addresses are re-picked
    by the Ribbon load balancer. Wait a few seconds for the registry to update and then try
    again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到内部服务器错误（`PRODUCT`没有可用实例）。这可能发生在心跳完成并且地址被Ribbon负载均衡器重新选择时。等待几秒钟，直到注册表更新，然后再试一次。
- en: 'A lot has happened under the hood in getting this response:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取此响应的过程中发生了很多事情：
- en: The HTTP request to get `/client/4` was handled by the `getProduct` method in
    the `ProductClient` class.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`/client/4`的HTTP请求是由`ProductClient`类中的`getProduct`方法处理的。
- en: 'It did a lookup of the service from the Eureka registry. This is where we find
    log statements as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从Eureka注册表中查找了该服务。这就是我们找到的日志语句如下：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After it did the lookup, it forwarded the request to the actual `ProductService`
    through the Ribbon load balancer library.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行查找后，它通过Ribbon负载均衡器库将请求转发到实际的`ProductService`。
- en: This was just a simple mechanism of a client invoking services through a dynamic
    lookup. In later chapters, we will add functionality to make it resilient and
    functional in terms of getting data from the database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个客户端通过动态查找调用服务的简单机制。在后面的章节中，我们将添加功能，使其在从数据库获取数据方面具有弹性和功能性。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's review the key concepts of the cloud applications that we have discussed
    so far. We made our application **lightweight** by making it run on a servlet
    engine and start in less than 15 seconds. Our application is **self-contained**,
    as the fat JAR has all libraries to run our service. We just need a JVM to run
    this JAR file. It has **externalized configuration** (to some extent) by injecting
    environment from the command line and properties from `application.yml` and `bootstrap.yml`.
    We take a deeper look at the next stages of externalization in [Chapter 7](23d9bfc6-4a12-4ead-9389-7d11ac4cb2ac.xhtml),
    *Cloud-Native Application Runtime*. The Spring actuator helped capturing all metrics
    and made their URL available for consumption, thus enabling **instrumentation**.
    The **location abstraction** was implemented by Eureka.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们讨论过的云应用程序的关键概念。通过在servlet引擎上运行并在不到15秒内启动，我们使我们的应用程序变得**轻量级**。我们的应用程序是**自包含**的，因为fat
    JAR包含了运行我们的服务所需的所有库。我们只需要一个JVM来运行这个JAR文件。它通过从命令行注入环境和从`application.yml`和`bootstrap.yml`中注入属性，实现了**外部化配置**（在某种程度上）。我们将在[第7章](23d9bfc6-4a12-4ead-9389-7d11ac4cb2ac.xhtml)
    *Cloud-Native Application Runtime*中更深入地研究外部化的下一阶段。Spring执行器帮助捕获所有指标，并使它们的URL可供使用，从而实现了**仪表化**。**位置抽象**是由Eureka实现的。
- en: In the next chapters, we will enhance this service by adding to it a data tier
    and resiliency, and adding cache behavior and other enhancements that we skipped
    in this chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过向其添加数据层和弹性，以及添加缓存行为和其他我们在本章中跳过的增强功能，来增强此服务。
