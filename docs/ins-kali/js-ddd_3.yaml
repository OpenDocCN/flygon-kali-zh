- en: Chapter 3. Setting Up a Project for Domain-driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。为面向领域驱动设计设置项目
- en: 'So far we have been focused on getting the prerequisites for the project ready.
    We focused on creating a mental model for ourselves and confirmed that our understanding
    of the domain matched the understanding of our domain expert. By doing this, we
    started to create a shared language between all the people involved so that all
    parties can communicate about the project while avoiding most misunderstandings.
    With all this in place, we were able to identify a starting point for the project,
    and now that we know where to start and how to name our objects according to the
    domain, we can set up the project to fit this. Robert C. Martin says in his talk
    *Architecture the lost years*: *Architecture is about intent* that architecture
    is not created for the sake of itself but actually to state what the project is
    about and make it clear for the next person what each level covers. As we set
    up our application, we want to express what the application is about at every
    level, and this includes the level of organization of files and folders as much
    as it is about creating classes and modules.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于准备项目的先决条件。我们致力于为自己创建一个心智模型，并确认我们对领域的理解与我们的领域专家的理解相匹配。通过这样做，我们开始在所有参与者之间创建一个共享的语言，以便所有各方可以就项目进行沟通，同时避免大部分误解。有了这一切，我们能够确定项目的起点，现在我们知道从哪里开始，以及如何根据领域命名我们的对象，我们可以设置项目以适应这一点。罗伯特·C·马丁在他的演讲《架构的失落年代》中说：*架构是关于意图的*，架构不是为了自身而创建的，而是为了说明项目的内容，并清楚地表明下一个人需要覆盖的每个层次。在设置应用程序时，我们希望在每个层次上表达应用程序的内容，这包括文件和文件夹的组织层次，以及创建类和模块。
- en: Our main goal, which coincides with the goal of software architecture, in general
    has been to not make decisions prematurely as well as to ensure the decisions
    we make are as self-explanatory as possible. We have not decided on any frameworks
    or actually any technology yet, but as we now push our application forward, it
    is time to resolve some of those deferred decisions, even though we want to keep
    as much as possible open to change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标与软件架构的目标一致，一般来说，我们的目标是不要过早做决定，并确保我们做出的决定尽可能自我解释。我们还没有决定任何框架或实际上任何技术，但随着我们推动应用程序的进展，现在是时候解决一些推迟的决定了，尽管我们希望尽可能保持开放以进行更改。
- en: This chapter is going to be about the challenges that arise when it comes to
    creating a flexible project setup that allows your project to adapt and actually
    embrace a change of structure. This is important to keep in mind throughout the
    whole design as we put it together. We don't want a module structure hindering
    our refactoring, or making our project more rigid because of an overwhelming class
    and file hierarchy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论在创建灵活的项目设置时出现的挑战，这样可以使您的项目适应并实际上拥抱结构的变化。在整个设计过程中牢记这一点非常重要。我们不希望模块结构妨碍我们的重构，或者因为压倒性的类和文件层次结构而使我们的项目更加僵化。
- en: 'As we go about this, we are going to deal with structure on multiple levels:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这项工作时，我们将在多个层次上处理结构：
- en: File and directory structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录结构
- en: Project structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: Object or class structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象或类结构
- en: Application structure as interaction with the outside of the domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序结构与领域外部的交互
- en: Object and class structure, as well as project structure, are closely related
    to how we decide to design our application. As part of this, testing is introduced
    as it has the most immediate impact on how we are going to design both our classes
    and objects. It also has an impact on the way our team works together on the project
    and how they are able to show the results to business experts by letting them
    explore the project as it currently stands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和类结构以及项目结构与我们决定如何设计应用程序密切相关。作为其中的一部分，测试被引入，因为它对我们如何设计我们的类和对象有最直接的影响。它还对我们的团队如何共同开展项目工作以及他们如何能够向业务专家展示结果产生影响，让他们探索当前项目的方式。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As JavaScript leaves the realm of enhancing websites and moves towards being
    a language used for large applications, be it in the browser or on the server,
    the need for more involved architectures has grown and people have tried to carry
    over many of the concepts currently in use for Java or C++ backend applications.
    Often this actually causes more problems than it solves, as JavaScript is a very
    flexible language and has its own concepts of how organization can, and should,
    be done even though parts might still be missing; modules being one of those as
    a core concept. When building a JavaScript application, always keep in mind what
    language you are using and use its features and concepts to work with your project;
    don't fight it every step of the way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript离开增强网站的领域，转向成为用于大型应用程序的语言，无论是在浏览器上还是在服务器上，对更复杂的架构的需求增加了，人们试图将目前用于Java或C++后端应用程序的许多概念移植过来。通常，这实际上会引起更多问题，因为JavaScript是一种非常灵活的语言，有自己的组织方式和概念，尽管可能仍然缺少一些部分；模块是其中一个核心概念。构建JavaScript应用程序时，始终牢记自己使用的语言，并使用其特性和概念来处理项目；不要在每一步都与之对抗。
- en: 'This chapter covers the setup of the project and how to make it a joy to work
    on. You will learn about the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了项目的设置以及如何使其成为一种愉快的工作方式。您将了解以下内容：
- en: The project file structure and what to consider when laying it out
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件结构以及在布局时要考虑的因素
- en: Different forms of testing and why they are important
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同形式的测试及其重要性
- en: Building the application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: An introduction to hexagonal architecture
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构简介
- en: Structuring a project as we see it
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按我们的看法构建项目
- en: As a new developer dives into a project, the first thing they are always going
    to see is the layout of files and folders in the project. This is also the element
    of organization we deal with constantly while editing the project, so it is worth
    investing thought into the organization. Just looking at the files and folders
    should already tell you something about the project; it is the highest level of
    organization and therefore should represent some of the top level concepts of
    our domain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的开发人员投入一个项目时，他们总是会看到项目中文件和文件夹的布局。这也是我们在不断编辑项目时不断处理的组织元素，因此值得投入思考。仅仅看看文件和文件夹应该已经告诉你一些关于项目的信息；这是最高级别的组织，因此应该代表我们领域的一些最高级别的概念。
- en: 'So to start out, we need to make sure we know what we are trying to solve with
    this structure. There are multiple points that we need to address at this level,
    and they will follow us through every part of the organization of the project;
    they are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要确保我们知道我们试图用这个结构解决什么问题。在这个层面上，有多个要点需要我们解决，并且它们将贯穿项目组织的每个部分；它们是：
- en: Approachability
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易接近性
- en: Locality of edits
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑的局部性
- en: Fitness for handling change
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应变化的能力
- en: So let's see what these points are about and how we can optimize for each of
    those points.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这些要点是关于什么，以及我们如何为每个要点进行优化。
- en: Approachability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易接近性
- en: As a new developer joins a project, or even as one comes back to a project that
    they have not been recently working on, there is a learning curve in knowing where
    things are located, and maybe even more importantly in where things should be
    located moving forward. This is always a problem as it slows down development,
    or when talking about an open source project it might actually slow down adoption
    and contributions. So we obviously want to make codebase as approachable as possible,
    but what does this mean? There is a subjective learning curve in relation to unfamiliar
    tools and styles, which is hard to estimate ahead of time for each developer,
    but there is also a more objective one in relation to common practices, naming,
    and well established concepts. So how can we make a codebase approachable just
    from the file and folder level?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的开发人员加入一个项目，甚至当一个回到他们最近没有工作的项目时，都需要花时间了解事物的位置，也许更重要的是，了解事物未来应该放在哪里。这总是一个问题，因为它会减慢开发速度，或者当谈论一个开源项目时，它实际上可能会减慢采用和贡献。因此，我们显然希望尽可能使代码库易接近，但这意味着什么呢？对于不熟悉的工具和风格，存在主观的学习曲线，这很难提前估计每个开发人员的情况，但也存在一个更客观的学习曲线，与常见的做法、命名和已经建立的概念相关。那么我们如何从文件和文件夹级别使代码库易接近呢？
- en: When we start out, we will need to take a look at what is in there, so the ease
    of navigation is one of the first things we have to deal with. Having extensive
    levels of subfolders, with only view files, or sometimes even no files, is an
    example of making a project hard to navigate. Some might say that the editor you
    are working with should solve this, but it is also a problem we create for ourselves,
    so we should refrain from it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始时，我们需要看看里面有什么，因此导航的便利性是我们必须处理的第一件事。具有大量的子文件夹，只有视图文件，或者有时甚至没有文件，都是使项目难以导航的例子。有些人可能会说，你正在使用的编辑器应该解决这个问题，但这也是我们为自己创造的问题，因此我们应该避免这样做。
- en: There are more ways to make a project approachable so, for example, the filenames
    should reflect the contents, as should the directory names, and probably most
    importantly, the project should follow conventions that have been established
    in the community. This means that unless you have a very good reason, you should
    refrain from creating your own conventions. Especially little things such as naming
    files according to a community standard can help a lot. One example is tagging
    on names like model or controller to the end of files. In some programming communities
    this is really common, while in the Node.js community it is frowned upon. Following
    these little things can make it easier for developers as not following them might
    almost drive rage towards a project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的方法可以使项目更易接近，例如，文件名应反映内容，目录名也应如此，而且可能最重要的是，项目应遵循社区已经建立的惯例。这意味着除非你有很好的理由，否则你应该避免创建自己的惯例。特别是一些小事情，比如根据社区标准命名文件，可以帮助很多。一个例子是在文件末尾添加像model或controller这样的名称。在一些编程社区中，这是非常常见的，而在Node.js社区中，这是不被赞同的。遵循这些小事情可以使开发人员更容易，而不遵循它们可能几乎会引起对项目的愤怒。
- en: Keep in mind that files will most likely only ever be touched by developers,
    so they can be optimized to support developers in their task, and so a common
    developer practice is of higher weight than approachability for a domain expert.
    Of course, the extent of this varies between projects and tasks. It holds largely
    true for the organizational nature and for common idioms from frameworks, but
    does not extend to the naming of the inherent part of the language that is developed
    throughout the project. We want the project's structure to be approachable for
    developers already familiar with similar codebases, but we don't want to introduce
    a translation layer between the developers and the domain experts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，文件很可能只会被开发人员触及，因此它们可以被优化以支持开发人员的任务，因此，常见的开发人员实践比领域专家的易接近性更重要。当然，这在项目和任务之间的范围上有所不同。它在组织性质和框架的常见习语方面基本成立，但不适用于在整个项目中开发的语言固有部分的命名。我们希望项目的结构对于已经熟悉类似代码库的开发人员来说是易接近的，但我们不希望在开发人员和领域专家之间引入翻译层。
- en: 'Let''s take a closer look at this in an example of how we could lay out the
    basics for our dungeon-manager. To start out, this will, of course, only contain
    the transferring `prisoners feature`, but nonetheless it will hint towards the
    overall structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子更仔细地看看我们如何为我们的地牢管理器制定基本规则。当然，一开始，这只会包含转移`囚犯功能`，但尽管如此，它将暗示整体结构：
- en: '![Approachability](graphics/B03704_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![易接近性](graphics/B03704_03_01.jpg)'
- en: The important thing to note about this structure is that it uses the basics
    of node modules all the way while already hinting at a possible structure to include
    multiple features outside the prisoner transfer. The `index.js` files are conventional
    named to indicate the entry point to a certain module. A developer jumping into
    the project will know to look in those files first when trying to find out more
    about the module. We can leverage this fact later to include common documentation
    about the feature, as well as having this file load all the others necessary to
    accomplish the module task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种结构的重要事项是，它一直使用节点模块的基础，同时已经暗示了可能包括多个功能在囚犯转移之外的结构。`index.js`文件通常命名为指示特定模块的入口点。跳入项目的开发人员将知道在尝试了解有关模块的更多信息时首先查看这些文件。我们以后可以利用这一事实来包括有关功能的常见文档，以及使该文件加载完成模块任务所需的所有其他文件。
- en: Creating the tests in a test folder is also the established way to locate your
    tests. As the test have certain categories inherent in their design, it makes
    sense to structure the test directory accordingly. The structure of the test folder
    should allow us to, at a glance, figure out what tests there are and how they
    apply to our project as a whole. As the project grows, having a set of tests covering
    the features is not only incredibly valuable from a regression perspective, but
    also gives a quick insight into how a certain feature can be used, so locating
    your tests quickly can mean a certain module gets reused or adapted instead of
    wasting efforts on duplicating what was there already.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件夹中创建测试也是定位测试的已建立方式。由于测试在设计上具有某些固有的类别，因此按照测试目录的结构进行组织是有意义的。测试文件夹的结构应该让我们一眼就能看出有哪些测试，以及它们如何适用于我们的整个项目。随着项目的增长，拥有一组覆盖功能的测试不仅在回归方面非常有价值，而且还可以快速了解某个功能的使用方式，因此快速定位测试可以意味着某个模块被重复使用或调整，而不是浪费精力重复已有的工作。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The structure presented here is not set in stone, some people prefer app to
    lib, spec to test, or other small changes like this. The goal of a structure should
    always be that developers feel at home in it. Tradeoffs in this area can be made
    with specific developers in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的结构并非一成不变，有些人更喜欢将app改为lib，将spec改为test，或者进行其他类似的小改动。结构的目标应始终是让开发人员感到宾至如归。在这个领域可以根据特定的开发人员做出权衡。
- en: Lastly, adding a `package.json` file is the common way to handle project dependency
    and to define aspects about the structure and other parts, so we add this as well,
    ready to put to good use later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`package.json`文件是处理项目依赖关系并定义结构和其他部分的常见方式，因此我们也添加了这个文件，准备以后充分利用。
- en: Locality of edits
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑的局部性
- en: As developers are working on the project, they are most likely working on either
    a feature, or are fixing bugs and refactoring code. As these activities are, at
    least in the case we are aiming for, related to one feature, we want to make sure
    that the developer does not have to jump into many different places to edit. The
    files related to the problem should therefore be in one spot, reducing the overhead
    of opening everything related to a given task or feature, as well as the mental
    overhead of keeping the related parts in one's head to make sure the edits happen
    in the right place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员在项目上工作时，他们很可能正在处理一个功能，或者正在修复错误和重构代码。由于这些活动至少在我们所追求的情况下与一个功能相关，我们希望确保开发人员不必跳转到许多不同的地方进行编辑。因此，与问题相关的文件应该在一个地方，减少打开与给定任务或功能相关的所有内容的开销，以及保持相关部分在头脑中以确保编辑发生在正确的地方的心理开销。
- en: This is one of the reasons we created features such as packages or modules in
    the `lib` folder before. As the developer works on the prisoner transfer, they
    can, just by looking at the directory structure, know what to edit. They can quickly
    open the files in their editor and view them as a unit of work as they are changing
    the code to accomplish a given task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前在`lib`文件夹中创建包或模块的原因之一。当开发人员在处理囚犯转移时，他们可以仅通过查看目录结构就知道要编辑什么。他们可以快速在编辑器中打开文件，并将其视为一个工作单元，因为他们正在更改代码以完成给定的任务。
- en: Using a structure like this not only makes it easier to look at for the developer
    when editing, but also the version control system will be easier to work with.
    As the code is organized like this, we can look at it on a feature-by-feature
    basis and we are also less likely to touch the same files when working on different
    features. This not only reduces the likelihood of conflict, but also makes the
    history of a given module more useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的结构不仅使开发人员在编辑时更容易查看，而且版本控制系统也更容易使用。由于代码是这样组织的，我们可以逐个功能地查看它，而且在处理不同功能时也不太可能触及相同的文件。这不仅减少了冲突的可能性，还使给定模块的历史更有用。
- en: If you look at the preceding structure we have been using so far, you might
    have noticed that the locality of edits breaks down for tests. As we work on the
    prisoner transfer feature in `lib`, we have to edit the feature test in tests
    as well, which is about as far apart as you can get filesystem-wise. As with everything
    in software development, this is a tradeoff and we have chosen approachability
    over locality in this case. The reason being that a higher value is placed on
    the onboarding of people, and the assumed cost of non-locality seems low enough
    to support that. If we think otherwise, we might locate the tests for each feature
    inside the feature, and therefore more easily enable moving the whole feature
    to a different project in the future. This decision is not all or nothing of course,
    and we might create a structure resembling the main structure under the test directory
    to keep a locality for the tests as part of the tests directory for example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看过我们迄今为止一直在使用的前述结构，您可能已经注意到编辑的局部性在测试中会被打破。当我们在`lib`中开发囚犯转移功能时，我们也必须编辑测试中的功能测试，这在文件系统上可能是相隔很远的。与软件开发中的一切一样，这是一个权衡，我们在这种情况下选择了可接近性而不是局部性。原因是更重视人员的入职，并且假定非局部性的成本似乎足够低以支持这一点。如果我们有不同看法，我们可能会将每个功能的测试定位在功能内部，因此更容易在将来将整个功能移动到不同的项目中。当然，这个决定并不是非此即彼的，我们可能会创建一个类似于测试目录下主目录结构的结构，以保持测试的局部性，例如将测试目录作为测试目录的一部分。
- en: Fitness
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健身
- en: '|   | *Fitness, according to Darwin, means the capacity to survive and reproduce.*
    |   |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| | *根据达尔文的说法，健身意味着生存和繁殖的能力。* | |'
- en: '|   | --*Darwinian fitness - Lloyd Demetriusa, Martin Ziehec* |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| | - *达尔文健身-劳埃德·德米特里乌斯，马丁·齐赫克* |'
- en: As our software grows and evolves, it will need to adapt to varying scenarios
    of its usage, and the best software is the kind that grows beyond its intended
    use case. A common example is Unix and the associated philosophy. The idea is
    to create many small pieces that, when recombined, allow for a vast variety of
    uses. Unix has survived in various forms for decades now and there does not seem
    to be an end in sight, but being created in a certain way is only half the story.
    As changes came along and new use cases took form, it did not ossify, but its
    idea and concepts were malleable, but what does that mean for our software. How
    can we achieve similar versatility?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的软件的增长和发展，它将需要适应不同的使用场景，最好的软件是超出其预期用例的软件。一个常见的例子是Unix及其相关的哲学。其理念是创建许多小的部分，当重新组合时，可以实现各种各样的用途。Unix以各种形式存活了几十年，似乎没有尽头，但仅仅以某种方式创建只是故事的一半。随着变化的出现和新的用例形成，它并没有变得僵化，而是其思想和概念是可塑的，但对于我们的软件意味着什么。我们如何实现类似的多功能性？
- en: We have seen already that even on the filesystem level, the software is composed
    of modules. There is an obvious distinction between the different elements as
    features are implemented. From a fitness perspective, this means that we are quickly
    able to locate a certain feature, as well as enhance, remove, or reuse it. A feature
    should also hint at its dependencies, which could be made clear through subfolders,
    or just by looking at the imported dependencies located in the index file located
    right at the root of a feature directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，即使在文件系统级别上，软件也是由模块组成的。随着功能的实现，不同元素之间存在明显的区别。从健身的角度来看，这意味着我们能够快速定位某个特定功能，以及增强、删除或重用它。功能还应提示其依赖关系，可以通过子文件夹明确表示，或者只需查看位于功能目录根目录的索引文件中的导入依赖关系即可。
- en: To give an example, moving forward as the dungeon manager grows, the prisoner
    transfer might start to incorporate more messaging since other dungeons have adopted
    our system, and we can now fully automate transfers between them. At this point,
    the whole kingdom relies on the availability of the transfer service and this
    means that very rigorous testing needs to be present to ensure its reliability
    because downtime means that the kingdom cannot raid at maximum effectiveness.
    We are very happy with the success of this system, but it slows down development
    of the dungeon manager in general, as the prisoner transfer is a part of it and
    we need to comply with its harsh integration rules. But we are in a good position
    after all; if we look at the layout of our application, we can see that we can
    quite easily extract the prisoner transfer into an application by itself and have
    it maintained separately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，随着地牢管理员的发展，囚犯转移可能会开始融入更多的消息传递，因为其他地牢已经采用了我们的系统，现在我们可以完全自动地在它们之间进行转移。在这一点上，整个王国都依赖于转移服务的可用性，这意味着需要非常严格的测试来确保其可靠性，因为停机意味着王国无法以最大效率进行袭击。我们对这个系统的成功非常满意，但它总体上减缓了地牢管理员的发展，因为囚犯转移是其一部分，我们需要遵守其严格的集成规则。但毕竟我们处于一个良好的位置；如果我们看一下我们的应用程序布局，我们可以看到我们可以相当容易地将囚犯转移提取到一个独立的应用程序中，并且可以单独维护它。
- en: After the extraction, we can start moving forward quickly again, and integrate
    the transfer as just another service the dungeon manager speaks with. Splitting
    out common functionality, as well as functionality that has to comply with different
    constraints, is key to having malleable and extendable software that can keep
    moving forward.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 提取后，我们可以再次快速前进，并将转移集成为地牢管理员与之通信的另一个服务。拆分共同功能以及必须遵守不同约束的功能是保持可塑和可扩展软件不断前进的关键。
- en: In reality, this would obviously be the best case, but just structuring an application
    as a set of independent small parts all tested separately on the feature level
    makes us consider APIs in a way that will be very useful down the road as the
    software grows and, of course, the same goes the other way around. We are able
    to rip out unneeded features quickly and thus reduce the maintenance overhead
    and increase our velocity. This is in essence the concept of cooperation of all
    the small Unix programs mentioned at the beginning of this section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这显然是最好的情况，但仅仅将应用程序构建为一组独立的小部分，每个部分都在功能级别上进行了单独测试，使我们考虑API的方式，这在软件增长时将非常有用，当然，反过来也是一样。我们能够快速剔除不需要的功能，从而减少维护开销并提高我们的速度。这本质上就是本节开头提到的所有小型Unix程序的合作概念。
- en: This is not the *be all and end all* of software design of course, as anybody
    who started out using Unix mainly from the shell will know that the initial learning
    curve is rather steep and getting anything done does not feel very fast or expressive
    at the beginning. As we have seen before, reaching all the way for one goal means
    sacrificing another, in this example—the approachability of the project. After
    all, there is no perfect solution, but at least at the beginning of a project
    it is often helpful to enhance approachability and think about other problems
    as they arise. For us, this means that keeping a high level structure of modules
    in mind is probably a good thing, but going overboard and making every piece ready
    for extraction, or even its own application, will probably not help the project
    along.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是软件设计的全部和终结，任何从shell开始使用Unix的人都会知道最初的学习曲线非常陡峭，最初做任何事情都不会感觉很快或者表达得很好。正如我们之前所看到的，为了达到一个目标，就意味着牺牲另一个，比如在这个例子中——项目的可接近性。毕竟，没有完美的解决方案，但至少在项目开始时，增强可接近性并在问题出现时考虑其他问题通常是有帮助的。对我们来说，这意味着牢记模块的高层结构可能是一件好事，但过度做准备并使每个部分都准备好提取，甚至是自己的应用程序，可能不会帮助项目前进。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't overcomplicate things to get the perfect architecture, as it does not
    exist. It is more important to get the software into the hands of the users quickly
    to get feedback on whether it is even useful. A slowdown determining the perfect
    architecture will most likely be more costly down the road due to the delay in
    feedback, than a suboptimal architecture could be.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于复杂化以获得完美的架构，因为完美的架构并不存在。更重要的是迅速将软件交到用户手中，以便获得关于其是否有用的反馈。由于延迟反馈，决定完美架构的减速很可能会在以后造成更大的成本，而次优的架构可能不会。
- en: Dealing with shared functionality
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理共享功能
- en: As we have structured our application right now, we are ready to split apart
    features that might become an independent piece of functionality, but what about
    the other way around? Domains often have a certain set of key concepts that to
    shows up time and time again. This is great as it allows us to not having to write
    it over and over if we can share it across the pieces that need. It also shows
    that we understand the domain well enough to extract core concepts and share them,
    so it is actually something to strive for.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们目前构建的应用程序而言，我们已经准备好拆分可能成为独立功能的功能，但反过来呢？领域通常有一定的一组关键概念，这些概念一次又一次地出现。这很好，因为它允许我们在需要时共享它，而不必一遍又一遍地写。这也表明我们足够了解领域，以提取核心概念并共享它们，因此这实际上是值得努力的事情。
- en: This is great on a level where our features match the shared functionality closely;
    we provide a public interface and each dependent interface can develop against
    that. But what happens if we actually extract a piece of functionality, and our
    prisoner transfer service is for example no longer local to the application but
    actually a service that is reachable via HTTP for example? In this case, we have
    to deal with shared functionality, which is not just another thing we can create
    an API for, but we actually have to implement the same code in every dependent
    to actually call over the API to do the work we were doing locally before. Think
    of the payment gateway abstraction every other shopping system creates—this kind
    of functionality could be developed once and used in multiple places, allowing
    shared testing and shared resources for development.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的功能与共享功能密切匹配时，我们提供一个公共接口，每个依赖接口都可以根据它进行开发。但如果我们实际上提取了一部分功能，例如我们的囚犯转移服务不再局限于应用程序，而实际上是通过HTTP可达的服务，那会发生什么？在这种情况下，我们不仅需要处理共享功能，而且我们实际上必须在每个依赖方中实现相同的代码，以便通过API调用来执行我们以前在本地执行的工作。想想每个其他购物系统都创建的支付网关抽象——这种功能可以开发一次并在多个地方使用，允许共享测试和共享开发资源。
- en: This is, of course, not the only place where shared functionality actually means
    there is code being shared, where it seems like we have to duplicate certain snippets
    all over the place. Other examples might be database access, or configuration
    management. What all of this has in common is that it is actually lower level
    code that does not really have a close relationship with the application domain.
    We are dealing with an artifact of the way we like to communicate, and the patterns
    we applied don't support this communication well. We can think about it also in
    the way that the cohesion at a domain level is low, because we are leaking abstractions
    in a way that would for example make us care about the database accessing code
    when we want to deal with a prisoner.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是唯一一个共享功能实际上意味着有代码被共享的地方，似乎我们不得不在各个地方重复某些片段。其他例子可能是数据库访问或配置管理。所有这些共同点都是实际上与应用程序领域没有密切关系的较低级别代码。我们正在处理我们喜欢交流的方式的产物，我们应用的模式并不很好地支持这种交流。我们也可以这样思考，领域层面的内聚性较低，因为我们正在以一种方式泄露抽象，例如当我们想要处理囚犯时，我们会关心数据库访问代码。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One thing to keep in mind when introducing shared code is that sharing is coupling
    and coupling is not a good thing. There should always be a very good reason for
    sharing code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引入共享代码时要记住的一件事是，共享是耦合，耦合不是一件好事。共享代码应该有非常好的理由。
- en: Multiple solutions are possible at this point, and depending on the project
    as well as the piece of code, different ones might be applicable, so let me introduce
    you to the most common ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此时可能有多种解决方案，根据项目和代码的不同，可能适用不同的解决方案，所以让我向您介绍最常见的解决方案。
- en: A shared toolbox
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享工具箱
- en: 'When the first shared functionality appears that does not really belong anywhere,
    most projects start to create a *utility* library, a toolbox of things that are
    used in places all over the project. Even though many architecture purists frown
    upon it, it might be the best way to start out. It is better to have a shared
    toolbox separated out than dealing with code duplication later on after all. Many
    popular libraries start this way; think about underscore providing its implementation
    of the *each* construct on top of JavaScript, and dealing with all the different
    versions underneath that a browser implementation might have to care about to
    run all over the world. The following is an example from the `underscore.js` file,
    reformatted for easier reading:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现第一个不真正属于任何地方的共享功能时，大多数项目开始创建一个*实用*库，一个在整个项目中使用的工具箱。尽管许多架构纯粹主义者对此不屑一顾，但这可能是开始的最佳方式。最好将共享的工具箱分开，而不是在之后处理代码重复。许多流行的库都是这样开始的；想想underscore在JavaScript的*each*构造上提供了其实现，并处理了浏览器实现可能需要关心的所有不同版本，以在全世界运行。以下是从`underscore.js`文件中提取的一个示例，重新格式化以便更容易阅读：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While a library such as underscore is a perfect example of the usefulness of
    this approach, there are problems as well. Especially when poorly named, this
    folder or file quickly becomes the dumping ground for all kind of things. It is
    quicker to not think about where something really belongs, and instead just dump
    more into the utilities folder. At least it is in one place now where it can be
    moved and refactored from, so stay positive; it could be worse. In the long run,
    the goal should be to move to an approach where we use object orientation and
    let our tests guide a domain-design from the start. When we look at an application
    and we see a library function like the above being part of the application code
    we know that there is an abstraction missing. Again, it is all tradeoffs all the
    time and the problem with abstractions is that you have to consider them at the
    time of writing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然underscore这样的库是这种方法有用性的完美例子，但也存在问题。特别是当命名不当时，这个文件夹或文件很快就会成为各种东西的倾倒地。不去考虑某样东西真正属于哪里，而是将更多东西倾倒到实用程序文件夹中，这更快。至少现在它在一个地方，可以从中移动和重构，所以保持积极；情况可能会更糟。从长远来看，目标应该是转向一种使用面向对象的方法，并让我们的测试从一开始就指导领域设计。当我们查看应用程序并看到类似上述的库函数是应用程序代码的一部分时，我们知道缺少一个抽象。再次强调，这一切都是权衡，抽象的问题是您在编写时必须考虑它们。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Utilities or libraries are a dangerous place, so be sure to keep them on your
    regular review and refactor radar. Always leave the code a little bit tidier than
    you found it and monitor its churn closely.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序或库是一个危险的地方，所以一定要确保将它们放在您的定期审查和重构的视线中。始终保持代码比您找到的代码整洁一点，并密切监视其变化。
- en: Moving up the dependencies
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升依赖关系
- en: As the project moves along and grows, the best way to deal with dependencies
    will probably be to leverage what is there already. Your libraries have grown,
    and many internal projects rely on them, so why not make use of the dependency
    management that is built into the environment already?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的推进和发展，处理依赖关系的最佳方式可能是利用已有的内容。您的库已经成长，许多内部项目依赖于它们，为什么不利用已经内置到环境中的依赖管理呢？
- en: JavaScript used to be notoriously bad at dealing with dependencies, but the
    time of downloading a version of jQuery and putting it in the project is luckily
    over. JavaScript provides an amazing amount of dependency managers for every use
    case. In the browser, we can leverage **bower** ([http://bower.io/](http://bower.io/)),
    **browserify** ([http://browserify.org/](http://browserify.org/)) and **npm**
    ([https://www.npmjs.com/](https://www.npmjs.com/)) and possibly many more, and
    in Node.js, npm is the standard way to deal with any kind of packages we might
    want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript曾经以处理依赖关系而臭名昭著，但是下载jQuery的版本并将其放入项目的时代幸运地结束了。JavaScript为每种用例提供了惊人数量的依赖管理器。在浏览器中，我们可以利用**bower**
    ([http://bower.io/](http://bower.io/))、**browserify** ([http://browserify.org/](http://browserify.org/))和**npm**
    ([https://www.npmjs.com/](https://www.npmjs.com/))，可能还有许多其他的依赖管理器，在Node.js中，npm是处理任何我们可能需要的包的标准方式。
- en: Depending on the kind of library that has been developed as part of the process,
    it might be either a good point to rely on versioning it outside of your project,
    or even maybe set up a private version of the package registry. This will be overkill
    in the beginning, but is something to keep in mind as the need arises. Also, don't
    forget that it might be your time to contribute back to the community and release
    it as open source.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据作为过程一部分开发的库的类型，可能是一个很好的时机依赖于项目之外的版本，甚至可能建立一个私有版本的包注册表。这在开始时可能有些过度，但随着需求的出现，这是需要记住的事情。此外，不要忘记，现在可能是您回馈社区并将其作为开源发布的时候。
- en: Testing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: '|   | *Beware of bugs in the above code; I have only proved it correct, not
    tried it.* |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| | *小心上述代码中的错误；我只证明了它的正确性，而没有尝试它。* | |'
- en: '|   | --*Donald Ervin Knuth* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| | --*Donald Ervin Knuth* |'
- en: Every system that is supposed to go into production needs to be evaluated against
    the real world situation. Reality can be a harsh thing, and it happens more often
    than not that something we expected to work perfectly fine does not work when
    we actually want to use it. So throughout the history of computer programming,
    developers have thought about how they could make sure that the software works,
    and at best, actually work as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个即将投入生产的系统都需要根据实际情况进行评估。现实可能是一件严酷的事情，经常发生的情况是，我们期望完美运行的东西在实际使用时却不起作用。因此，在计算机编程的历史上，开发人员一直在思考如何确保软件能够正常工作，并且最好能够按预期工作。
- en: 'In 1994, Kent Beck wrote the **SUnit** test framework for Smalltalk and kicked
    off the modern age of unit testing. The idea was quite simple: automate the evaluation
    of code and make sure it fulfilled a certain set of specifications. Even though
    there are many new frameworks today to achieve this, the basic idea is still the
    same: write code and check whether it produces the expected result. In reality,
    with or without a testing framework or fixed process, developers are always doing
    this—nobody is just pushing code into production without actually having tried
    it before, at least. We can either do this by hand, or automate it.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，Kent Beck 为 Smalltalk 编写了 **SUnit** 测试框架，开启了现代单元测试的时代。这个想法非常简单：自动化代码评估，并确保它满足一定的规范。即使今天有许多新的框架来实现这一点，基本思想仍然是一样的：编写代码并检查它是否产生了预期的结果。实际上，无论有没有测试框架或固定流程，开发人员总是在做这个事情——没有人会在没有尝试过的情况下将代码推送到生产环境中。我们可以手动执行，也可以自动化执行。
- en: There are multiple points that need to be addressed to make testing useful because
    there are different goals for the tests we write. We need to facilitate easy unit
    testing, expressive feature testing, and performance testing. This of course does
    not mean that all scenarios need to be handled by one framework, but the less
    friction there is, the better the adoption of the core principles will be. It
    is also vital to make sure the tests are executed, and the best way to achieve
    this is through automation, making sure no code can wind up in the end product
    without satisfying its requirements and without breaking others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个要点需要解决，以使测试变得有用，因为我们编写的测试有不同的目标。我们需要促进简单的单元测试、表达性的功能测试和性能测试。当然，这并不意味着所有场景都需要由一个框架处理，但摩擦越小，核心原则的采纳就会越好。确保测试被执行是至关重要的，而实现这一点的最佳方式是通过自动化，确保没有代码可以在最终产品中出现，而不满足其要求并且不破坏其他代码。
- en: Setting up a test environment
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: As we now know, there are a lot of different goals a test environment must satisfy,
    but there also are an incredible number of test frameworks out there and JavaScript
    itself brings some challenges when it comes to testing. One framework that has
    worked for a lot of projects in the past is the Mocha-testing framework. It has
    also gained quite a wide adoption among web developers, so the following sections
    will explain Mocha. There is no secret to it, and Mocha is swappable for the framework
    of your choice that fits the style of your development team best. The only thing
    to make sure is that you actually use what you have, and be aware of what you
    want to get out of your tests. So first, we need to make sure we know what the
    goals are for our different tests before we can chose a technology to achieve
    them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知，测试环境必须满足许多不同的目标，但也有大量的测试框架以及 JavaScript 本身在测试方面带来了一些挑战。过去许多项目中使用的一个框架是
    Mocha 测试框架。它在 Web 开发人员中也得到了广泛的采用，因此接下来的部分将解释 Mocha。没有秘密可言，Mocha 可以与您团队最擅长的框架相互替换。唯一需要确保的是您实际使用了您拥有的工具，并且了解您想从测试中获得什么。因此，首先，我们需要确保在选择技术实现目标之前，了解我们不同测试的目标是什么。
- en: Different types of tests and goals
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同类型的测试和目标
- en: When we start testing code, there are multiple reasons why we should do it.
    For a project that is driven by its domain implementation, one major aspect is
    always testing the features as they are implemented, as we want to provide quick
    feedback to the client and show in an explanatory way that our implementation
    works. But as developers, we also need to dig a little deeper and work on the
    unit level, exploring the specifics of our code as we write it, or as we design
    the algorithm. Finally, a project should not only care about its functionality
    in actually doing what it is supposed to do, but also be usable from a user perspective,
    giving responsive answers and performing well enough overall to not be in the
    way. All of these aspects can be achieved by testing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始测试代码时，有多个原因需要这样做。对于一个由其领域实现驱动的项目来说，一个主要方面始终是测试实现的功能，因为我们希望向客户提供快速反馈，并以一种解释性的方式展示我们的实现是有效的。但作为开发人员，我们还需要深入挖掘并在单元级别上工作，探索我们编写代码时的具体情况，或者在设计算法时。最后，一个项目不仅应关心其功能是否实际执行了它应该执行的任务，还应该从用户的角度来看，提供响应迅速的答复，并在整体上表现得足够好，以免成为障碍。所有这些方面都可以通过测试来实现。
- en: Feature specs
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能规范
- en: 'Making tests not only useful for the developer, but for the client too, has
    been the ultimate goal of test driving and implementation for many years. There
    are tools such as **Ruby''s** **Cucumber** that have a JavaScript implementation
    that makes sure the specification gets somewhat decoupled from the code, making
    it as accessible as possible for the domain expert to read and understand. The
    end result is a specification that mostly looks like plain English but has some
    restrictions applied to it. The code below is using the cucumber syntax to describe
    the prisoner transfer as a feature specification, including one acceptance scenario:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，使测试不仅对开发人员有用，而且对客户也有用，一直是测试驱动和实施的最终目标。有一些工具，比如Ruby的Cucumber，它有一个JavaScript实现，可以确保规范与代码有些解耦，使其尽可能易于领域专家阅读和理解。最终结果是规范看起来大部分像普通英语，但有一些限制。下面的代码使用黄瓜语法来描述囚犯转移作为功能规范，包括一个验收场景：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This kind of specification can now easily be turned into a running specification,
    using the `Given`, `When`, and `Then` blocks as the instructions for our tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规范现在可以很容易地转化为一个运行的规范，使用`Given`、`When`和`Then`块作为我们测试的指令。
- en: Decoupling the specification from the real tests like this somewhat removes
    the programmer from it. So, depending on the technical expertise of the product
    owner, the idea is that even they could write the specification, with some developer
    support of course. In most projects, this is not the case, and the developers
    end up creating the specification code for Cucumber, as well as its implementation
    as test code. In this case, it is useful to stick with more basic tools, as it
    is a better fit for developers to write tests in a way they are accustomed to
    already. This does not mean Cucumber's idea isn't something to keep in mind. Tests
    should read at a really high level, and should be understandable to reflect what
    the product owner originally intended when describing it to developers, so we
    can detect mismatches together as a team. But, as code is most likely to be read
    with a developer at hand, the overhead of having almost two implementations of
    the tests is unnecessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将规范与真正的测试解耦有些程度上将程序员与之分离。因此，根据产品所有者的技术专业知识，即使他们也可以编写规范，当然需要一些开发人员的支持。在大多数项目中，情况并非如此，开发人员最终会为Cucumber创建规范代码，以及其作为测试代码的实现。在这种情况下，坚持使用更基本的工具是有用的，因为这更适合开发人员已经习惯的方式编写测试。这并不意味着黄瓜的想法不值得考虑。测试应该在非常高的层面上阅读，并且应该能够反映产品所有者最初在描述给开发人员时的意图，这样我们作为团队可以一起检测不匹配。但是，由于代码很可能在有开发人员在场的情况下阅读，几乎没有必要几乎有两种测试实现的开销。
- en: 'There is nothing wrong with being inspired by Cucumber and using Mocha to write
    our tests. The tests can look like this for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 受到Cucumber的启发并使用Mocha来编写我们的测试并没有错。例如，测试可以看起来像这样：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though this style is now actual runnable code, using helper methods to
    abstract details and make the naming clear keeps it readable. The goal here is
    not to make it easy for a non-technical person to read this, but to enable a developer
    to sit down with a business expert and talk about the implied rules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种风格现在是实际可运行的代码，使用辅助方法来抽象细节并使命名清晰保持可读性。这里的目标不是让非技术人员轻松阅读，而是让开发人员能够与业务专家坐下来讨论隐含的规则。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Test are an integral part of the code, so they need to have the same rigorous
    coding standards employed, and since there are no tests for the tests, readability
    is key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是代码的一个组成部分，因此它们需要采用相同严格的编码标准，由于测试没有测试，可读性至关重要。
- en: Unit tests
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: After the discussion with the business expert to agree on the feature set, and
    creating a specification of its current state in the feature specs, there is a
    level where we as developers need to try out our code. This is where unit tests
    shine! The idea is to test our code as we develop it and allow it to be immediately
    executed in isolation, where we can reason about it. Unit tests are generally
    quickly changing as the development on a certain part progresses and serves as
    regression protection afterwards.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务专家讨论功能集后，创建功能规范中的当前状态规范，作为开发人员，我们需要尝试我们的代码。这就是单元测试的闪光之处！这个想法是在开发代码的同时测试我们的代码，并允许它在隔离环境中立即执行，这样我们就可以对其进行推理。单元测试通常随着某个部分的开发而迅速变化，并在之后作为回归保护。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't fear throwing away unit tests; they are there to aid development not to
    hinder it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕放弃单元测试；它们是为了帮助开发而不是阻碍开发。
- en: As we already are using Mocha for our features, it is natural to use it to test
    our smaller units as well, but the tests are going to look different. At the level
    of the unit tests, we want to isolate ourselves as far as possible and if we can't
    do that, then we are really going to encounter some pain sooner or later in other
    development areas as well. This pain is really about high coupling; when we are
    coupling a module too close to other pieces of the system the test will show us.
    In this kind of setup, creating a unit test that is isolated is going to require
    an incredible amount of setup to really make sure we only hit the module by itself,
    and don't touch the dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在我们的功能中使用Mocha，自然而然地也要用它来测试我们的更小的单元，但测试看起来会有所不同。在单元测试的级别上，我们希望尽可能地隔离自己，如果我们做不到这一点，那么在其他开发领域中，我们真的会遇到一些痛苦。这种痛苦实际上是关于高耦合的；当我们将一个模块与系统的其他部分耦合得太紧时，测试会告诉我们。在这种设置中，创建一个孤立的单元测试将需要大量的设置，以确保我们只击中模块本身，而不触及依赖关系。
- en: The end result of unit tests of a module should always test the public interface
    and this interface alone, because at this point they serve as regression protection.
    The more external pieces are tested with the unit tests, the more of its private
    interface is exposed, the more likely a breakage is going to occur, but even though
    this is our end goal, don't make the mistake of thinking this should be all the
    unit tests ever do. Often when writing a module of a bigger application, it can
    be immensely useful to explore its logic more deeply, especially when the public
    interface might still be in flux. So write all the tests that reach inside the
    harder parts of the module while developing it, but make sure you remove those
    "little helpers" before declaring a module ready for consumption.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的单元测试的最终结果应始终测试公共接口，因为在这一点上它们起到了回归保护的作用。模块的单元测试测试的外部部分越多，它的私有接口就越多暴露，发生故障的可能性就越大，但即使这是我们的最终目标，也不要犯认为这应该是所有单元测试所做的错误。在编写更大应用程序的模块时，探索其逻辑更深入可能非常有用，特别是当公共接口可能仍在变化时。因此，在开发时编写所有能够深入了解模块较难部分的测试，但确保在声明模块可以使用之前删除这些“小助手”。
- en: Performance tests
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: Any time an application is moving forward and features are implemented, there
    is a point at which we need to think about the performance of this application.
    Even before we get into performance needs, it is important to know which parts
    of the system are most likely to cause trouble in the future.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个应用程序向前发展并实现功能时，我们都需要考虑这个应用程序的性能。甚至在我们涉及性能需求之前，了解系统中哪些部分最有可能在将来引起麻烦是很重要的。
- en: The important thing about performance tests are that they will ascertain the
    focus on metrics in the code at an early stage. Just thinking about how to measure
    the performance across parts of the system will ensure that we think about instrumentation,
    and this can be a vital feature when we actually move closer to heavy usage later
    on or actually when exploring breakages in production.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的重要之处在于它们将在早期阶段确定代码中的指标重点。考虑如何测量系统各部分的性能将确保我们考虑到仪器，这在我们后来实际上更接近重度使用或者在生产中探索故障时可能是一个至关重要的特性。
- en: Testing the performance of an application is, of course, not a one-off thing.
    By itself, a measurement of performance is rather meaningless; it only becomes
    useful if it's monitored as it changes over time. One strategy to accomplish this
    is exercising the outside API on each push to the master branch and recording
    the changes. This will give you an idea of where the project stands in respect
    to monitoring as well as performance over the time the project is developed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试应用程序的性能不是一次性的事情。单独来看，性能的测量是毫无意义的；只有在随着时间的推移监控时才会变得有用。实现这一点的一种策略是在每次推送到主分支时对外部API进行测试，并记录更改。这将让您了解项目在监控方面以及在项目开发期间的性能方面的情况。
- en: Even though it might not be obvious outright, monitoring changes in performance
    is a major point towards implementing a domain. As developers employing domain-driven
    design practices, we must consider the usability of our app. Often, different
    stakeholders have different needs in performance, and having an application that
    does not satisfy its needs might render it useless to some. So many times apps
    stop being used due to bad performance characteristics even if they supply the
    whole feature set otherwise. Overall, just knowing the deficiencies is half the
    battle. When we at least have an understanding of where time is spent, it is a
    point where we can hook in as the need arises and optimize as needed. This need
    is very likely to arise sooner or later so the preparation for it is time very
    well spent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能并不明显，但监控性能的变化是实施域的一个重要点。作为采用领域驱动设计实践的开发人员，我们必须考虑我们应用程序的可用性。通常，不同的利益相关者对性能有不同的需求，而一个无法满足其需求的应用程序可能对某些人毫无用处。因此，很多时候，即使应用程序在其他方面提供了完整的功能集，由于性能特征不佳，应用程序也停止被使用。总的来说，只要知道了缺陷，就已经成功了一半。当我们至少了解时间花在哪里时，这是一个我们可以随时介入并根据需要进行优化的时机。这种需求很可能迟早会出现，因此为此做准备是非常值得的。
- en: With these different goals in mind, we now have to tackle the problem of actually
    running all those different tests as often as possible without having to rely
    on just strict compliance throughout, especially when creating a view over time.
    As a project changes, relying on people running everything needed every time is
    not just a major burden on the team, but unnecessary as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些不同的目标，我们现在必须解决的问题是尽可能经常地运行所有这些不同的测试，而不必仅仅依赖于严格的遵从，特别是在创建一个随着时间推移而变化的视图时。随着项目的变化，依赖于人们每次运行所需的一切不仅对团队是一个重大负担，而且也是不必要的。
- en: Continuous integration
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: In the end, all the tests one could ever want are only useful if they are run,
    and this is where continuous integration comes into play. Of course, all of us
    are great developers who always test their code, but even we might not always
    test the whole chain of integration in our app. Our performance tests are only
    useful if they are run on a comparable platform.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，所有可能需要的测试只有在运行时才有用，这就是持续集成发挥作用的地方。当然，我们都是优秀的开发人员，总是测试他们的代码，但即使我们可能并不总是测试应用程序中整个集成链。我们的性能测试只有在可比较的平台上运行时才有用。
- en: Continuous integration has been around for some time now, and its most prominent
    system is probably Jenkins, but others are around as well. The idea is to run
    the tests and other steps we need to move from development to production on a
    system automatically, and make sure we have a stable build at all times. We can
    even use this system to automate deployment, and of course provide a dashboard
    for developers to check how the app is doing right now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成已经存在一段时间了，它最突出的系统可能是Jenkins，但也有其他系统存在。其想法是在系统上自动运行我们从开发到生产需要的测试和其他步骤，并确保我们始终拥有稳定的构建。我们甚至可以使用这个系统来自动化部署，并且当然为开发人员提供一个仪表板，以检查应用程序当前的运行情况。
- en: A system like this can be a vital part of a project, as it allows you to quickly
    move from development to system, where the business experts can check the impact
    of the work as well. There are many tutorials out there on how to set up a project's
    continuous integration, and in recent times highly refined systems such as **Travis-CI**
    make it very easy to set up, so I won't go into more details here; just keep in
    mind that such a system is worth its cost many times over throughout a project
    that grows to a certain size and complexity, and there is no real reason not to
    use one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统可以成为项目的重要组成部分，因为它允许您快速从开发转移到系统，业务专家可以检查工作的影响。有许多关于如何设置项目持续集成的教程，最近高度精练的系统如**Travis-CI**使得设置变得非常容易，所以我在这里不会详细介绍；只需记住，这样的系统在项目达到一定规模和复杂性时，其价值远远超过成本，没有理由不使用。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A continuous integration system is really about keeping the best practices enforced
    throughout the development, even when a developer has a bad day. It also provides
    a more approachable way to have an outsider discover and evaluate the state of
    the application as a whole.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成系统实际上是在整个开发过程中强制执行最佳实践，即使开发人员有一天状态不佳。它还提供了一个更易接近的方式，让外部人员发现和评估整个应用程序的状态。
- en: Managing the build
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理构建
- en: Writing software for an orc dungeon has a major advantage since the orcs don't
    know much about software so we can introduce any tools we like and they won't
    have an opinion on it. Why have I mentioned this when the title of this section
    is supposed to talk about building the software, you might wonder? There are a
    myriad of build tools out there and they all do things slightly differently, and
    everybody seems to prefer one to the other. Especially in JavaScript, the community
    has not yet standardized a tool so there is **Grunt**, **Jake**, and **Broccoli**,
    just to name a few, and of course your project might leverage one from a different
    language such as Ruby's Rake or the old familiar make.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为兽人地牢编写软件有一个重要的优势，因为兽人对软件了解不多，所以我们可以引入任何我们喜欢的工具，他们不会对此有意见。你可能会想，当这一节的标题应该谈论构建软件时，我为什么要提到这个？市面上有很多构建工具，它们都有些许不同的功能，每个人似乎都更喜欢其中的一个。特别是在JavaScript中，社区尚未统一一种工具，因此有**Grunt**、**Jake**和**Broccoli**等，当然，您的项目也可能利用其他语言的工具，比如Ruby的Rake或老式的make。
- en: Even though there are so many build tools, the only important thing about them
    is to actually use one. Yes they all have differences, but they can all do pretty
    much the same, adjusting for syntax and performance. But why is a build tool so
    important? And why should we use one?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这么多构建工具，但它们唯一重要的是实际使用一个。是的，它们都有差异，但它们几乎都可以做到相同的事情，只是语法和性能有所不同。但为什么构建工具如此重要？为什么我们应该使用一个？
- en: Why every application needs a build system
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么每个应用程序都需要一个构建系统
- en: Creating software at the scale of actually creating a functional, complete system
    to manage a business process is always a difficult task. Such a system involves
    many parts, like in our example of managing prisoner transfers, notifying other
    dungeons, tracking statistics about the dungeon, and so on. When we set it up,
    we need to load multiple files, maybe compile some parts, manage the dependencies,
    and, in the case of frontend JavaScript code, we also want to compress and minimize
    it to optimize for faster page load. Doing all this manually involves multiple
    steps and will most likely fail sooner or later because we forgot one of those
    steps, and this is where the build system comes in. In a way, all software has
    a build system, it just depends on how automated the system is.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际创建一个功能完整的系统来管理业务流程的规模上创建软件总是一项困难的任务。这样的系统涉及许多部分，就像我们管理囚犯转移的例子中，通知其他地牢，跟踪地牢的统计数据等等。当我们设置它时，我们需要加载多个文件，也许编译一些部分，管理依赖关系，并且在前端JavaScript代码的情况下，我们还希望对其进行压缩和最小化，以优化页面加载速度。手动执行所有这些步骤涉及多个步骤，并且很可能会因为我们忘记了其中一个步骤而在早晚失败，这就是构建系统的作用。在某种程度上，所有软件都有一个构建系统，这取决于系统的自动化程度。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A build system optimizes for *boringness*; the more boring a build is, the better.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统优化了“无聊性”；构建越无聊，越好。
- en: 'The goal is to not be able to make mistakes and create a reproducible environment
    every time. We want to run one command and get the expected result, so in our
    case the build system has a couple of responsibilities:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是不犯错误，并且每次都能创建一个可重现的环境。我们希望运行一个命令并获得预期的结果，所以在我们的情况下，构建系统有一些责任：
- en: Running the tests
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Packaging the application
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: Deploying the application
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: All those steps are important to think about, so let's walk through them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都很重要，所以让我们逐步进行。
- en: Running the tests
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'We are writing great tests right now and those tests ensure that our system
    behaves as expected according to the feature set we worked out with the domain
    experts, so those tests should run, and if they fail there is something wrong
    with our system that we need to fix. Since we already have a testing framework
    in place, running the tests is pretty straightforward:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在编写很好的测试，这些测试确保我们的系统按照我们与领域专家确定的功能集的预期行为进行。因此，这些测试应该运行，如果它们失败，那么我们的系统有问题需要修复。由于我们已经有了一个测试框架，运行测试非常简单：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will run all the tests specified inside the test directory, which according
    to our file layout we created earlier, will be all of them. Since we don''t want
    to remember this command, we can wire it into npm by adding it to the `package.json`
    file we already set up:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行在测试目录中指定的所有测试，根据我们之前创建的文件布局，这将是所有测试。由于我们不想记住这个命令，我们可以通过将其添加到我们已经设置的`package.json`文件中，将其连接到npm中：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this in place, running all our tests becomes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，运行所有测试变得很简单：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will make our lives a lot easier, we can now rely on one command to actually
    run our tests, and the failures are certainly development failures and not the
    mistyping of a command, for example, forgetting about the `--recursive` and then
    skipping most of the tests. Depending on the preference of the developers involved,
    we can go even further, watching the files for changes and rerunning the tests
    triggered by those changes, the described system here should be considered as
    the minimum requirement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的生活变得更加轻松，现在我们可以依靠一个命令来运行我们的测试，失败肯定是开发失败，而不是命令输错，例如，忘记了`--recursive`然后跳过大部分测试。根据涉及的开发人员的偏好，我们甚至可以进一步观察文件的更改并重新运行由这些更改触发的测试，这里描述的系统应该被视为最低要求。
- en: Packaging the application
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: Moving an application to production is most likely not a one-step process. Web
    applications might involve compiling assets together, downloading dependencies,
    and maybe even configuring certain parts for production instead of development.
    Running these steps by hand is prone to error, and every developer who has used
    such a process before has a story to tell about it failing more or less spectacularly.
    But if we want to keep our software malleable and able to react to changes to
    the domain, as well as get it in the hands of our domain experts quickly, we need
    to deploy early and often, and the first step towards this is packaging the application
    in one step.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序移至生产环境很可能不是一个一步完成的过程。Web应用程序可能涉及将资产编译在一起，下载依赖项，甚至配置某些部分以适应生产环境而不是开发环境。手动运行这些步骤容易出错，之前使用过这种流程的每个开发人员都有一个失败的故事。但是，如果我们希望保持软件的可塑性，并能够对领域的变化做出反应，并且能够迅速将其交给我们的领域专家，我们需要尽早并经常部署，而这的第一步是将应用程序打包成一个步骤。
- en: 'The goal is for every developer to be able to set up the basic environment
    for the application, like in our case installing Node.js, and from then on setting-up
    the application with one command. Continuing with npm for now to manage our task,
    we add the following to our `package.json` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让每个开发人员能够设置应用程序的基本环境，就像我们的情况下安装Node.js一样，然后用一个命令设置应用程序。目前继续使用npm来管理我们的任务，我们将以下内容添加到我们的`package.json`文件中：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since this is a custom command that has no special support in npm running,
    it means running:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个自定义命令，在npm运行中没有特殊支持，这意味着运行：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a little non-intuitive to an outsider, but listing a command like this
    in the readme file will cover that for now, and if we want to, we can also decide
    on a system to wrap all those calls to make them consistent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外部人来说，这有点不直观，但是在readme文件中列出这样的命令目前可以解决这个问题，如果我们愿意，我们也可以决定使用一个系统来包装所有这些调用，使它们保持一致。
- en: Now that we have a place to put any steps involved in packaging the application,
    we are ready to make sure we can deploy it with one command as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个地方来放置打包应用程序所涉及的任何步骤，我们准备确保我们也可以用一个命令部署它。
- en: Deploying
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: Like we said before, we want our deployment to be a boring process; it should
    be one step and never cause a failure that is hard to recover from. This actually
    means we need to be able to roll back deploys as necessary, otherwise the fear
    of making a wrong deploy will be ossifying to any progress.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们希望我们的部署过程是一个无聊的过程；它应该是一个步骤，永远不会导致难以恢复的失败。这实际上意味着我们需要能够根据需要回滚部署，否则错误部署的恐惧将对任何进展产生僵化作用。
- en: 'The actual deployment can be quite simple, and a couple of shell scripts easily
    accomplish it depending on your needs. One system that covers the basics, and
    is easy to use and adaptable to changing needs is `deploy.sh` is available at
    [https://github.com/visionmedia/deploy](https://github.com/visionmedia/deploy).
    When using deploy, all there is to do is create a `deploy.conf` configuration
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实际部署可能非常简单，根据您的需求，几个shell脚本就可以轻松完成。一个涵盖基本知识的系统，易于使用并适应不断变化的需求的系统是`deploy.sh`，可以在[https://github.com/visionmedia/deploy](https://github.com/visionmedia/deploy)上找到。使用deploy时，需要创建一个`deploy.conf`配置文件：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The file can be extended for any application servers, and should be fairly easy
    to read. Any steps that need to be run can be implemented as pre- or post-deploy
    hooks, which makes this system incredibly flexible, especially when combined with
    a powerful build system managing the application parts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件可以扩展为任何应用程序服务器，并且应该非常容易阅读。需要运行的任何步骤都可以实现为预部署或后部署挂钩，这使得该系统非常灵活，特别是当与管理应用程序部分的强大构建系统结合使用时。
- en: Choosing the right system
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的系统
- en: So far we have been using what was available without really installing big tools;
    `deploy.sh` itself is just a shell script containing less than 400 lines of code
    and npm comes with Node.js by default. There are a lot of valid reasons to actually
    use a system outside the ones that come with the environment, for example, when
    you expect that the project will be composed of more than one language in the
    future, choosing a neutral wrapper can greatly increase the consistency across
    projects and ease the on ramp.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用默认安装的工具，而没有真正安装大型工具；`deploy.sh`本身只是一个包含不到400行代码的shell脚本，npm默认包含在Node.js中。实际上有很多有效的理由来使用环境之外的系统，例如，当您预期项目将来会由多种语言组成时，选择一个中立的包装器可以极大地增加项目之间的一致性，并简化入门。
- en: We now know what we want to get out of the system, so choosing one means looking
    at the requirements and picking one the majority of the developers like. One thing
    to bear in mind is that this is something the project will stick with hopefully
    for a long time, so a system that has some usage under its belt is a good idea.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想从系统中得到什么，所以选择一个意味着查看需求并选择大多数开发人员喜欢的系统。要记住的一件事是，这是项目希望长期坚持的东西，所以一个有一些使用经验的系统是个好主意。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I like to wrap most of my projects in a simple **Makefile**, because it is the
    most available and understood system out there, but your mileage may vary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在大多数项目中使用简单的**Makefile**，因为它是最常用和理解的系统，但你的情况可能有所不同。
- en: This brings us to the end of the setting up where we think about files and running
    commands, but one important part is missing, that is, how to actually make the
    domain part of the world, but keep it separate enough to allow reasoning on about
    it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了设置结束的地方，我们考虑文件和运行命令，但缺少一个重要的部分，那就是如何使领域部分真正成为世界的一部分，但又足够分离，以便对其进行推理。
- en: Isolating the domain
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离领域
- en: '|   | *Create your application to work without either a UI or a database so
    you can run automated regression-tests against the application, work when the
    database becomes unavailable, and link applications together without any user
    involvement.* |   |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|   | *创建应用程序，使其可以在没有UI或数据库的情况下运行自动回归测试，当数据库不可用时工作，并且可以在没有用户参与的情况下链接应用程序。*
    |   |'
- en: '|   | --*Alistair Cockburn* |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Alistair Cockburn* |'
- en: When we create an application following the principles of domain-driven design,
    we strive to keep the business logic separate from the parts of the software that
    interact with the "real world". The most-often referenced case is that we don't
    want to build our UI layer in a way that it houses some or all of the business
    logic as well. We want a clear domain-focused API that is consumed by other parts
    of the application to provide their interaction with the domain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个遵循领域驱动设计原则的应用程序时，我们努力将业务逻辑与与“真实世界”交互的软件部分分开。最常引用的情况是，我们不希望以某种方式构建我们的UI层，使其也包含部分或全部业务逻辑。我们希望有一个清晰的面向领域的API，被应用程序的其他部分消耗，以提供它们与领域的交互。
- en: The concept is similar to the UI being provided by some, to the UI specific
    language or API, be it HTML, or for example QT. Both sprang out of the concept
    of providing the developer with all the parts needed to build a UI but keep a
    natural separation. This doesn't make sense, the combination of HTML, CSS, and
    the DOM abstraction of JavaScript are a DSL, domain-specific language, to build
    browser interfaces. They provide an abstraction under which the browser implementers
    are free to change their implementation without impacting every website written.
    They therefore isolate the business domain of the browser vendors, displaying
    structured content, from the job of creating the content, most likely your job.
    Having such an API has many advantages over exposing the internal data structures
    directly, as history has shown.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念类似于一些提供的UI，特定于UI的语言或API，比如HTML，或者例如QT。这两者都源于提供开发人员构建UI所需的所有部分，但保持自然分离的概念。这是没有意义的，HTML、CSS和JavaScript的DOM抽象的组合是DSL，领域特定语言，用于构建浏览器界面。它们提供了一个抽象，浏览器实现者可以在其下更改他们的实现而不影响每个网站的编写。因此，它们隔离了浏览器供应商的业务领域，显示结构化内容，与创建内容的工作，很可能是你的工作。拥有这样的API比直接暴露内部数据结构具有许多优势，正如历史所显示的。
- en: The architecture of modern applications
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代应用程序的架构
- en: The idea to isolate the business domain has followed the software industry for
    a long time, especially with the growth of having a core domain and many consumers.
    In recent years, the idea to make a service an API first has become more and more
    viable due to the increasing importance of mobiles and the web. Many applications
    today have multiple interfaces, for example, in hotel booking, the state of the
    hotel is accessed by the employees, moving customers between rooms, taking bookings
    over the phone, and more. At the same time, customers are online, checking the
    Internet for available options and booking via various web portals.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离业务领域的想法已经在软件行业中存在了很长时间，特别是随着核心领域和许多消费者的增长。近年来，首先将服务作为API变得越来越可行，这是由于移动设备和网络的重要性日益增加。今天，许多应用程序具有多个接口，例如，在酒店预订中，员工可以访问酒店的状态，将客户移动到不同的房间，通过电话进行预订等。与此同时，客户在线上，通过各种网络门户查看可用选项并进行预订。
- en: 'On the days prior to their arrival, users might want to access the data on
    their phone in a mobile app to make sure they have it available wherever they
    are. These are just some of the many access options for a booking system, and
    even now there are a lot of options already:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达之前的几天，用户可能希望通过手机上的移动应用程序访问数据，以确保无论他们身在何处都可以使用。这些只是预订系统的许多访问选项之一，即使现在已经有很多选项：
- en: Internal desktop applications
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部桌面应用程序
- en: Internal web applications
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部Web应用程序
- en: Web applications
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序
- en: Web applications by other providers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他供应商的Web应用程序
- en: Mobile applications
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序
- en: Mobile applications by other providers
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他供应商的移动应用程序
- en: This is already a long list and we can expect it to grow in the future with
    new devices appearing, accompanied by different usage patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个很长的列表，我们可以预期随着新设备的出现以及不同的使用模式，它将在未来不断增长。
- en: Hexagonal architecture
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 六边形架构
- en: So how can we make sure an application is ready to evolve? With the appearance
    and dominance of web applications, developers have realized that there is a split
    between what an application is built to process and the interface and technologies
    it uses. This split is not a bad thing, as it can be used to establish APIs at
    those points and encapsulate the business domain that the core concept domain-driven
    design is all about. One possible technique to accomplish this is known as **Hexagonal
    architecture**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何确保应用程序准备好发展？随着Web应用程序的出现和主导地位，开发人员意识到应用程序构建的处理过程与其使用的界面和技术之间存在分歧。这种分歧并不是一件坏事，因为它可以用来在这些点上建立API，并封装核心概念领域驱动设计所关注的业务领域。实现这一点的一种可能的技术被称为**六边形架构**。
- en: '![Hexagonal architecture](graphics/B03704_03_02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![六边形架构](graphics/B03704_03_02.jpg)'
- en: The application as a whole is seen as a hexagon, with the business domain located
    inside. While the business domain only cares about its own language and concepts,
    it uses ports to talk to whatever it needs. Ports are the interfaces to the outside
    world and establish a clear API for what is needed and how it should be provided.
    On the other hand, there are adapters, that is, elements providing the API. This
    gives a lot of flexibility, and it not only allows you to swap adapters, for example
    during a test, but to also try out different technologies more quickly to find
    the one that fits best, not by guessing but actually trying it with the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序被视为一个六边形，业务领域位于其中。虽然业务领域只关心自己的语言和概念，但它使用端口与所需的任何内容进行通信。端口是与外部世界的接口，并为所需内容和提供方式建立了清晰的API。另一方面，还有适配器，即提供API的元素。这提供了很大的灵活性，不仅允许您交换适配器，例如在测试期间，还可以更快地尝试不同的技术，以找到最合适的技术，而不是猜测，而是实际尝试应用。
- en: Applying the pattern
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用模式
- en: As an avid reader will have realized, our dungeon management application does
    not differ a lot from the booking application just described. Moving forward,
    we also want to integrate it with multiple UIs and other applications. Also, our
    business concepts are complex enough to make us reach for domain-driven design,
    so a Hexagonal architecture suits us well. But how do we get there?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 热心的读者会意识到，我们的地牢管理应用程序与刚刚描述的预订应用程序并没有太大的不同。此外，我们还希望将其与多个UI和其他应用程序集成。此外，我们的业务概念足够复杂，以至于我们需要领域驱动设计，因此六边形架构非常适合我们。但我们如何才能实现这一点呢？
- en: This first thing to realize is that so far we have already been designing for
    it. Our core functionality is understood outside the context of a database or
    a web framework. The idea of hexagonal architecture and domain-driven design integrate
    very well after all. We now move forward to have a clear separation of what the
    business domain contains and what the outside provides. This is also referred
    to as **persistence ignorance**, as we want our domain to ignore the layers dealing
    with saving and loading data. As part of this pattern, we create separate objects
    or modules that encapsulate the actions of our domain, and use those to integrate
    into web frameworks as well as exposing as an API when we need to in the future.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要意识到的是，到目前为止，我们已经在为此进行设计。我们的核心功能在数据库或Web框架的上下文之外被理解。六边形架构和领域驱动设计的理念毕竟非常契合。我们现在继续前进，清晰地分离业务领域包含的内容和外部提供的内容。这也被称为**持久性无知**，因为我们希望我们的领域忽略处理保存和加载数据的层。作为这种模式的一部分，我们创建单独的对象或模块，封装我们领域的操作，并在将来需要时将其集成到Web框架中以及公开为API。
- en: Abstractions are not free; depending on the application, abstracting the data
    layers too much can introduce a performance overhead that might be too much to
    cope with. On the other hand, if your domain interacts with the data layer at
    such a frequency, there is possibly a problem in the domain itself and you might
    want to rethink your aggregates in the domain layer. The way we have to think
    about such patterns is more like a slider than a Boolean; we can increase and
    decrease the abstractions depending on the domain as well as the needs of our
    application's performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象并不是免费的；根据应用程序的不同，过度抽象数据层可能会引入性能开销，这可能是无法应付的。另一方面，如果您的领域与数据层的交互频率如此之高，可能领域本身存在问题，您可能需要重新思考领域层中的聚合。我们必须像滑块一样思考这种模式，而不是布尔值；我们可以根据领域以及应用程序性能的需求增加和减少抽象。
- en: Plugging in a framework
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入一个框架
- en: So how can we go about making this work for our application? The first version
    we are going to build is set out to have a web UI, so we need to have to plug
    in a web framework so we don't have to reinvent the wheel. Node.js provides many
    options there, the most popular being `express.js`, which we've already used,
    so what we want to do is let express do what it does best, serving requests, while
    our core domain processes the logic for those requests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何让这对我们的应用程序起作用呢？我们将要构建的第一个版本旨在具有Web UI，因此我们需要插入一个Web框架，这样我们就不必重新发明轮子。Node.js提供了许多选项，最流行的是`express.js`，我们已经使用过了，所以我们想要的是让express做它最擅长的事情，即处理请求，而我们的核心领域处理这些请求的逻辑。
- en: 'Let''s take a look at an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code to manage the prisoner transfer is nicely encapsulated in its own module
    and only interacts with the domain objects. The other question is where the code
    should live. At this early stage, code like this might still validly reside in
    an `index.js` file, providing the interface, but as our project moves along we
    might move towards a more modular architecture containing the glue code that connects
    the domain to the express framework in its own module. At this stage, we might
    even create a middleware layer to inject dependencies automatically as we need
    them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 管理囚犯转移的代码被很好地封装在自己的模块中，并且只与领域对象进行交互。另一个问题是代码应该放在哪里。在这个早期阶段，这样的代码可能仍然可以放在一个`index.js`文件中，提供接口，但随着项目的进展，我们可能会朝着一个包含将领域与express框架连接的粘合代码的更模块化的架构发展。在这个阶段，我们甚至可以创建一个中间件层，以自动注入我们需要的依赖关系。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got started with the project and are well on our way. We
    have everything in place to make the project progress and make it ready for changes
    that will no doubt follow. Again, the main idea has all been about isolation and
    making sure we think and tackle the domain, while not getting lost in the intricacies
    of language and frameworks and alike along the way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始了项目，并且进展顺利。我们已经做好了一切准备，使项目能够进展，并为随之而来的变化做好准备。再次强调，主要思想始终是关于隔离，并确保我们思考和解决领域的问题，而不会在这一过程中迷失在语言和框架的复杂性中。
- en: As most programmers will agree, integrating systems and modeling data are two
    tasks that really require attention just to themselves, and with this setup, we
    are taking an important step towards this integration. Meanwhile, the architecture
    sets us up to keep modeling the data as we started out previously.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员都会同意，集成系统和建模数据是两项确实需要专注的任务，而通过这种设置，我们正在迈出实现这种集成的重要一步。与此同时，这种架构使我们能够继续对数据进行建模，就像我们之前开始的那样。
- en: In the next chapter, we go into more detail on the domain objects themselves
    and what modeling them means in domain-driven design terms. We will be introducing
    the terminology to classify those models and drive them out using domain-driven
    design in conjunction with object orientation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论领域对象本身以及在领域驱动设计术语中对它们进行建模的含义。我们将介绍术语来对这些模型进行分类，并使用领域驱动设计与面向对象的方法来推动它们。
