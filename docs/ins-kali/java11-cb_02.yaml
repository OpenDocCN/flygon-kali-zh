- en: Fast Track to OOP - Classes and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP的快速通道-类和接口
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Implementing **Object-Oriented Design** (**OOD**)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现**面向对象设计**（**OOD**）
- en: Using inner classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部类
- en: Using inheritance and aggregation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和聚合
- en: Coding to an interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码到一个接口
- en: Creating interfaces with default and static methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: Creating interfaces with private methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: A better way to work with nulls using `Optional`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Optional`更好地处理空值
- en: Using the utility class `Objects`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实用类`Objects`
- en: The recipes in this chapter do not require any prior knowledge of OOD. However,
    some experience of writing code in Java would be beneficial. The code samples
    in this chapter are fully functional and compatible with Java 11\. For better
    understanding, we recommend that you try to run the presented examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例不需要对OOD有任何先前的了解。但是，在Java中编写代码的一些经验将是有益的。本章中的代码示例完全可用，并与Java 11兼容。为了更好地理解，我们建议您尝试运行所呈现的示例。
- en: We also encourage you to adapt the tips and recommendations in this chapter
    to your needs in the context of your team experience. Consider sharing your newfound
    knowledge with your colleagues and discuss how the described principles can be
    applied to your domain and your current project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还鼓励您根据您团队的经验，将本章中的提示和建议调整到您的需求中。考虑与同事分享您新获得的知识，并讨论所描述的原则如何应用到您的领域和当前项目中。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter gives you a quick introduction to the concepts of **o****bject-oriented
    programming** (**OOP**) and covers some enhancements that have been introduced
    since Java 8\. We will also try to cover a few good OOD practices wherever applicable
    and demonstrate them using specific code examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您快速介绍了**面向对象编程**（**OOP**）的概念，并涵盖了自Java 8以来引入的一些增强功能。我们还将尝试在适用的地方涵盖一些良好的OOD实践，并使用具体的代码示例加以演示。
- en: One can spend many hours reading articles and practical advice on OOD in books
    and on the internet. Doing this can be beneficial for some people. But, in our
    experience, the fastest way to get hold of OOD is to try its principles early
    in your own code. That is exactly the goal of this chapter—to give you a chance
    to see and use the OOD principles so that the formal definition makes sense immediately.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可以花费很多时间阅读关于OOD的文章和实用建议，无论是在书籍上还是在互联网上。对一些人来说，这样做可能是有益的。但是根据我们的经验，掌握OOD的最快方法是在自己的代码中尝试其原则。这正是本章的目标——让您有机会看到和使用OOD原则，以便立即理解其正式定义。
- en: One of the main criteria of well-written code is the clarity of the intent.
    A well-motivated and clear design helps achieve this. The code is run by a computer,
    but it is maintained—read and modified—by humans. Keeping this in mind will assure
    the longevity of your code and perhaps even a few thanks and mentions with appreciation
    from those who have to deal with it later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 良好编写代码的主要标准之一是意图的清晰。良好的动机和清晰的设计有助于实现这一点。代码由计算机运行，但由人类维护——阅读和修改。牢记这一点将确保您的代码的长期性，甚至可能会得到一些后来处理它的人的感激和赞赏。
- en: 'In this chapter, you will learn how to use the five basic OOP concepts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用五个基本的OOP概念：
- en: '**Object/class**: Keeping data and methods together'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象/类**：将数据和方法放在一起'
- en: '**Encapsulation**: Hiding data and/or methods'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：隐藏数据和/或方法'
- en: '**Inheritance**: Extending another class data and/or methods'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：扩展另一个类的数据和/或方法'
- en: '**Interface**: Hiding the implementation and coding for a type'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：隐藏实现和为一种类型编码'
- en: '**Polymorphism**: Using the base class type reference that points to a child
    class object'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：使用指向子类对象的基类类型引用'
- en: If you search the internet, you may notice that many other concepts and additions
    to them, as well as all OOD principles, can be derived from the five concepts
    listed previously. This means that a solid understanding of them is a prerequisite
    to a successful design of an object-oriented system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在互联网上搜索，您可能会注意到许多其他概念和对它们的补充，以及所有OOD原则，都可以从前面列出的五个概念中推导出来。这意味着对它们的扎实理解是设计面向对象系统的先决条件。
- en: Implementing object-oriented design (OOD)
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现面向对象设计（OOD）
- en: In this recipe, you will learn the first two OOP concepts—object/class and encapsulation.
    These concepts are at the foundation of OOD.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习前两个OOP概念——对象/类和封装。这些概念是OOD的基础。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The term *object* usually refers to an entity that couples data and procedures
    that can be applied to this data. Neither data nor procedures are required, but
    one of them is—and, typically, both are—always present. The data is called object
    fields (or properties), while procedures are called methods. Field values describe
    the object's *state*. Methods describe the object's *behavior*. Every object has
    a type, which is defined by its class—the template used for the object's creation.
    An object is also said to be an instance of a class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*对象*通常指的是将数据和可以应用于这些数据的过程耦合在一起的实体。数据和过程都不是必需的，但其中一个是——通常情况下，两者都是——总是存在的。数据称为对象字段（或属性），而过程称为方法。字段值描述了对象的*状态*。方法描述了对象的*行为*。每个对象都有一个类型，由其类——用于对象创建的模板——定义。对象也被称为类的实例。
- en: A *class* is a collection of definitions of fields and methods that will be
    present in each of its instances—the objects created based on this class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是字段和方法的定义集合，这些字段和方法将存在于基于该类创建的每个实例中。'
- en: Encapsulation is the hiding of those fields and methods that should not be accessible
    by other objects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是隐藏那些不应该被其他对象访问的字段和方法。
- en: Encapsulation is achieved by using the `public`, `protected`, or `private` Java
    keywords, called *access modifiers, *in the declaration of the fields and methods.
    There is also a default level of encapsulation when no access modifier is specified.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是通过在字段和方法的声明中使用`public`、`protected`或`private` Java关键字，称为*访问修饰符*来实现的。当未指定访问修饰符时，还有一种默认级别的封装。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an `Engine` class with the `horsePower` field. Add the `setHorsePower(int
    horsePower)` method, which sets this field''s value, and the `getSpeedMph(double
    timeSec, int weightPounds)` method, which calculates the speed of a vehicle based
    on the period of time passed since the vehicle began moving, the vehicle weight,
    and the engine power:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`horsePower`字段的`Engine`类。添加`setHorsePower(int horsePower)`方法，用于设置该字段的值，以及`getSpeedMph(double
    timeSec, int weightPounds)`方法，用于根据车辆开始移动以来经过的时间、车辆重量和发动机功率计算车辆的速度：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `Vehicle` class:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Vehicle`类：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the application that will use the preceding classes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将使用前述类的应用程序：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the `engine` object was created by invoking the default constructor
    of the `Engine` class without parameters and with the `new` Java keyword that
    allocates memory for the newly created object on the heap.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`engine`对象是通过调用`Engine`类的默认构造函数而创建的，该构造函数没有参数，并且使用`new` Java关键字在堆上为新创建的对象分配内存。
- en: The second object, `vehicle`, was created with the explicitly defined constructor
    of the `Vehicle` class with two parameters. The second parameter of the constructor
    is the `engine` object, which carries the `horsePower` value set to `246` using
    the `setHorsePower(int horsePower)` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象`vehicle`是使用`Vehicle`类的显式定义的带有两个参数的构造函数创建的。构造函数的第二个参数是`engine`对象，它携带了`horsePower`值，使用`setHorsePower(int
    horsePower)`方法设置为`246`。
- en: The `engine` object contains the `getSpeedMph(double timeSec, int weightPounds)` method,
    which can be called by any object (because it is `public`), as is done in the `getSpeedMph(double timeSec)` method
    of the `Vehicle` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine`对象包含`getSpeedMph(double timeSec, int weightPounds)`方法，可以被任何对象调用（因为它是`public`），就像在`Vehicle`类的`getSpeedMph(double
    timeSec)`方法中所做的那样。'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding application produces the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前述应用程序产生以下输出：
- en: '![](img/5e877a71-e07d-4cdf-a2ba-4d06cf4abe6a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e877a71-e07d-4cdf-a2ba-4d06cf4abe6a.png)'
- en: 'It''s worth noticing that the `getSpeedMph(double timeSec)` method of the `Vehicle` class
    relies on the presence of a value assigned to the `engine` field. This way, the
    object of the `Vehicle` class *delegates* the speed calculation to the object
    of the `Engine` class. If the latter is not set (`null` passed in the `Vehicle()`
    constructor, for example), `NullPointerException` will be thrown at the runtime
    and, if not handled by the application, will be caught by JVM and force it to
    exit. To avoid this, we can place a check for the presence of the `engine` field
    value in the `Vehicle()` constructor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Vehicle`类的`getSpeedMph(double timeSec)`方法依赖于为`engine`字段分配的值的存在。这样，`Vehicle`类的对象*委托*速度计算给`Engine`类的对象。如果后者未设置（例如在`Vehicle()`构造函数中传递了`null`），将在运行时抛出`NullPointerException`，如果应用程序未处理，将被JVM捕获并强制其退出。为了避免这种情况，我们可以在`Vehicle()`构造函数中放置一个检查，检查`engine`字段值的存在：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, we can place a check in the `getSpeedMph(double timeSec)` method
    of the `Vehicle` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`Vehicle`类的`getSpeedMph(double timeSec)`方法中放置一个检查：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way, we avoid the ambiguity of `NullPointerException` and tell the user
    exactly what the source of the problem was.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们避免了`NullPointerException`的歧义，并告诉用户问题的确切来源。
- en: 'As you may have noticed, the `getSpeedMph(double timeSec, int weightPounds)`
    method can be removed from the `Engine` class and can be fully implemented in
    the `Vehicle` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，`getSpeedMph(double timeSec, int weightPounds)`方法可以从`Engine`类中移除，并且可以完全在`Vehicle`类中实现：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To do this, we would need to add the `getHorsePower()` public method to the `Engine`
    class in order to make it available for usage by the `getSpeedMph(double timeSec)`
    method in the `Vehicle` class. For now, we leave the `getSpeedMph(double timeSec,
    int weightPounds)` method in the `Engine` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在`Engine`类中添加`getHorsePower()`公共方法，以便使其可以被`Vehicle`类的`getSpeedMph(double
    timeSec)`方法使用。目前，我们将`getSpeedMph(double timeSec, int weightPounds)`方法留在`Engine`类中。
- en: This is one of the design decisions you need to make. If you think that an object
    of the `Engine` class is going to be passed around and used by the objects of
    different classes (not only `Vehicle`), you would need to keep the `getSpeedMph(double timeSec,
    int weightPounds)` method in the `Engine` class. Otherwise, if you think that
    only the `Vehicle` class is going to be responsible for the speed calculation
    (which makes sense, since it is the speed of a vehicle, not of an engine), you
    should implement this method inside the `Vehicle` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做出的设计决策之一。如果你认为`Engine`类的对象将被传递并被不同类的对象使用（不仅仅是`Vehicle`），那么你需要在`Engine`类中保留`getSpeedMph(double
    timeSec, int weightPounds)`方法。否则，如果你认为只有`Vehicle`类将负责速度计算（这是有道理的，因为这是车辆的速度，而不是发动机的速度），你应该在`Vehicle`类中实现这个方法。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Java provides a capability to extend a class and allows the subclass to access
    all non-private fields and methods of the base class. For example, you can decide
    that every object that could be asked about its speed belongs to a subclass that
    is derived from the `Vehicle` class. In such a case, the `Car` class may look
    like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了扩展类的能力，并允许子类访问基类的所有非私有字段和方法。例如，你可以决定每个可以被询问其速度的对象都属于从`Vehicle`类派生的子类。在这种情况下，`Car`类可能如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can change our test code by replacing the `Vehicle` class object with
    the object of the `Car` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过用`Car`类的对象替换`Vehicle`类对象来更改我们的测试代码：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the preceding code is executed, it produces the same value as with an
    object of the `Vehicle` class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，它产生与`Vehicle`类对象相同的值：
- en: '![](img/2366a79d-188e-42bb-87d8-accfac3a3c97.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2366a79d-188e-42bb-87d8-accfac3a3c97.png)'
- en: Because of polymorphism, a reference to the object of the `Car` class can be
    assigned to the reference of its base class, `Vehicle`. The `Car` class object
    has two types—its own type, `Car`, and the type of the base class, `Vehicle`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态性，对`Car`类对象的引用可以赋给其基类`Vehicle`的引用。`Car`类对象有两种类型——它自己的类型`Car`和基类`Vehicle`的类型。
- en: In Java, a class can also implement multiple interfaces, and the object of such
    a class would have a type of each of the implemented interfaces, too. We will
    talk about this in the subsequent recipes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个类也可以实现多个接口，这样类的对象也会有每个实现接口的类型。我们将在随后的配方中讨论这一点。
- en: Using inner classes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部类
- en: 'In this recipe, you will learn about three types of inner classes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将了解三种内部类的类型：
- en: '**Inner class**: This is a class defined inside another (enclosing) class.
    Its accessibility from outside the enclosing class is regulated by the `public`,
    `protected`, and `private` access modifiers. An inner class can access the private
    members of the enclosing class, and the enclosing class can access the private
    members of its inner class, but a private inner class or private members of a
    non-private inner class cannot be accessed from outside the enclosing class.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部类**：这是一个在另一个（封闭）类内部定义的类。它的可访问性由`public`、`protected`和`private`访问修饰符调节。内部类可以访问封闭类的私有成员，封闭类也可以访问其内部类的私有成员，但是无法从封闭类外部访问私有内部类或非私有内部类的私有成员。'
- en: '**Method-local inner class**: This is a class defined inside a method. Its
    accessibility is restricted to within the method.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法局部内部类**：这是一个在方法内部定义的类。它的可访问性受限于方法内部。'
- en: '**Anonymous inner class**: This is a class without a declared name that''s
    defined during object instantiation based on the interface only or the extended
    class.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名内部类**：这是一个没有声明名称的类，在对象实例化时基于接口或扩展类定义。'
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When a class is used by one, and only one, other class, the designer might decide
    that there is no need to make such a class public. For example, let's assume that
    the `Engine` class is only used by the `Vehicle` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类只被一个其他类使用时，设计者可能会决定不需要将这样的类设为公共类。例如，假设`Engine`类只被`Vehicle`类使用。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the `Engine` class as an inner class of the `Vehicle` class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Engine`类创建为`Vehicle`类的内部类：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the `getSpeedMph(double timeSec)` method of the `Vehicle` class
    can access the `Engine` class, even though it is declared `private`. It can even
    access the `getSpeedMph(double timeSec)` private method of the `Engine` class.
    And the inner class can access all private elements of the enclosing class, too.
    That is why the `getSpeedMph(double timeSec)` method of the `Engine` class can
    access the private `getWeightPounds()` method of the enclosing `Vehicle` class.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`Vehicle`类的`getSpeedMph(double timeSec)`方法可以访问`Engine`类，即使它被声明为`private`。它甚至可以访问`Engine`类的`getSpeedMph(double
    timeSec)`私有方法。内部类也可以访问封闭类的所有私有元素。这就是为什么`Engine`类的`getSpeedMph(double timeSec)`方法可以访问封闭`Vehicle`类的私有`getWeightPounds()`方法。
- en: 'Look closer at the usage of the inner `Engine` class. Only the `getSpeedMph(double timeSec)` method
    of the `Engine` class is used. If the designer believes that it is going to be
    the case in the future too, they could reasonably decide to make the `Engine` class
    a method-local inner class, which is the second type of an inner class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更仔细地看一下内部`Engine`类的用法。只使用了`Engine`类的`getSpeedMph(double timeSec)`方法。如果设计者认为将来也会是这种情况，他们可能会合理地决定将`Engine`类设为方法局部内部类，这是内部类的第二种类型：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code example, it does not make sense to have an `Engine` class
    at all. The speed-calculation formula can be just used directly, without the mediation
    of the `Engine` class. But there are cases when this might be not so easy to do.
    For example, the method-local inner class may need to extend some other class
    in order to inherit its functionality, or the created `Engine` object may need
    to go through some transformation, so creation is required. Other considerations
    may require a method-local inner class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，根本没有必要有一个`Engine`类。速度计算公式可以直接使用，而不需要`Engine`类的介入。但也有一些情况下可能不那么容易做到。例如，方法局部内部类可能需要扩展其他类以继承其功能，或者创建的`Engine`对象可能需要经过一些转换，因此需要创建。其他考虑可能需要方法局部内部类。
- en: In any case, it is a good practice to make all the functionality that is not
    required to be accessed from outside the enclosing class inaccessible. Encapsulation—hiding
    the state and behavior of objects—helps avoid unexpected side effects resulting
    from an accidental change or overriding object behavior. It makes the results
    more predictable. That's why a good design exposes only the functionality that
    must be accessed from the outside. And it is usually the enclosing class functionality
    that motivated the class creation in the first place, not the inner class or other
    implementation details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，将不需要从封闭类外部访问的所有功能设为不可访问是一个好的做法。封装——隐藏对象的状态和行为——有助于避免意外更改或覆盖对象行为导致的意外副作用。这使得结果更加可预测。这就是为什么一个好的设计只暴露必须从外部访问的功能。通常是封闭类的功能首先促使类的创建，而不是内部类或其他实现细节。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Whether the `Engine` class is implemented as an inner class or a method-local
    inner class, the test code looks the same:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Engine`类是作为内部类还是方法局部内部类实现的，测试代码看起来都是一样的：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we run the preceding program, we get the same output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的程序，我们会得到相同的输出：
- en: '![](img/23149b17-7ecf-404f-ae5b-77abdb9deb27.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23149b17-7ecf-404f-ae5b-77abdb9deb27.png)'
- en: 'Now, let''s assume that we need to test a different implementation of the `getSpeedMph()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要测试`getSpeedMph()`方法的不同实现：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If this speed-calculation formula does not make sense to you, you are correct,
    it does not. We did it to make the result predictable and different from the result
    of the previous implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个速度计算公式对你来说没有意义，那么你是正确的，它确实没有意义。我们这样做是为了使结果可预测，并且与先前实现的结果不同。
- en: There are many ways to introduce this new implementation. We can change the code
    of the `getSpeedMph(double timeSec)` method in the `Engine` class, for example.
    Or, we can change the implementation of the same method in the `Vehicle` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以引入这个新的实现。例如，我们可以改变`Engine`类中`getSpeedMph(double timeSec)`方法的代码。或者，我们可以改变`Vehicle`类中相同方法的实现。
- en: 'In this recipe, we will do this by using the third type of inner class, called the
    anonymous inner class. This approach is especially handy when you want to write
    as little new code as possible, or you want to quickly test the new behavior by
    temporarily overriding the old one. The usage of an anonymous class would then
    look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用第三种内部类，称为匿名内部类。当你想尽可能少地编写新代码，或者你想通过临时覆盖旧代码来快速测试新行为时，这种方法特别方便。匿名类的使用将如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run this program, this would be the result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，结果将是这样的：
- en: '![](img/c6f8fa7d-3a9c-416c-a8ff-c78167eaf68e.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f8fa7d-3a9c-416c-a8ff-c78167eaf68e.png)'
- en: As you can see, the anonymous class implementation has overridden the `Vehicle` class
    implementation. The new anonymous class has only one method in it—the `getSpeedMph()` method
    which returns the hardcoded value. But we could override other methods of the `Vehicle` class
    or add new ones too. We just wanted to keep the example simple for demonstration
    purposes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，匿名类实现已经覆盖了`Vehicle`类的实现。新的匿名类中只有一个方法——`getSpeedMph()`方法，它返回了硬编码的值。但我们也可以覆盖`Vehicle`类的其他方法或者添加新的方法。我们只是想为了演示目的保持示例简单。
- en: 'By definition, an anonymous inner class has to be an expression that is part
    of a statement that ends (as any statement) with a semicolon. Such an expression
    is composed of the following parts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，匿名内部类必须是语句的一部分，该语句以分号结束（与任何语句一样）。这样的表达式由以下部分组成：
- en: The `new` operator
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`操作符'
- en: The name of the implemented interface or extended class followed by parentheses, `()`,
    that represents the default constructor or a constructor of the extended class
    (the latter is our case, with the extended class being `Vehicle`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的接口或扩展类的名称后跟括号`()`，表示默认构造函数或扩展类的构造函数（后者是我们的情况，扩展类是`Vehicle`）
- en: The class body with methods
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类体与方法
- en: Like any inner class, an anonymous inner class can access any member of the
    enclosing class with a caveat—to be used by an inner anonymous class, the fields
    of the enclosing class have to be either declared `final` or become `final` implicitly,
    which means that their values cannot be changed. A good modern IDE will warn you
    about the violation of this constraint if you try to change such a value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何内部类一样，匿名内部类可以访问外部类的任何成员，但有一个注意事项——要被内部匿名类使用，外部类的字段必须要么声明为`final`，要么隐式地变为`final`，这意味着它们的值不能被改变。一个好的现代IDE会在你试图改变这样的值时警告你违反了这个约束。
- en: 'Using these features, we can modify our sample code and provide more input
    data for the newly implemented `getSpeedMph(double timeSec)` method without passing
    them as method parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些特性，我们可以修改我们的示例代码，并为新实现的`getSpeedMph(double timeSec)`方法提供更多的输入数据，而无需将它们作为方法参数传递：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the `timeSec`, `engineHorsePower`, and `vehicleWeightPounds` variables
    are accessible by the `getSpeedMph(double timeSec)` method of the inner class
    and cannot be modified. If we run the preceding code, the result will be the same
    as before:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`timeSec`、`engineHorsePower`和`vehicleWeightPounds`变量可以被内部类的`getSpeedMph(double
    timeSec)`方法访问，但不能被修改。如果我们运行上述代码，结果将与之前一样：
- en: '![](img/3b0f5b59-fcd0-4847-8141-cb56a9c81995.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b0f5b59-fcd0-4847-8141-cb56a9c81995.png)'
- en: In the case of an interface with only one abstract method (called the functional
    interface), instead of an anonymous inner class, another construct can be used,
    called a *lambda expression*. It provides a shorter notation. We are going to
    discuss the functional interface and lambda expressions in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml),
    *Going Functional*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个抽象方法的接口（称为函数式接口）的情况下，可以使用另一种构造，称为*lambda表达式*，而不是匿名内部类。它提供了更简洁的表示。我们将在[第4章](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml)
    *进入函数式*中讨论函数式接口和lambda表达式。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An inner class is a non-static nested class. Java also allows us to create
    a static nested class that can be used when an inner class does not require access
    to non-static fields and methods of the enclosing class. Here is an example (the `static` keyword
    is added to the `Engine` class):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类是一个非静态嵌套类。Java还允许我们创建一个静态嵌套类，当内部类不需要访问外部类的非静态字段和方法时可以使用。下面是一个示例（`Engine`类中添加了`static`关键字）：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because a static class couldn't access a non-static member, we were forced to
    pass the weight value to the `Engine` class during its construction, and we removed
    the `getWeightPounds()` method as it's no longer needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态类无法访问非静态成员，我们被迫在构造`Engine`类时传递重量值，并且我们移除了`getWeightPounds()`方法，因为它不再需要了。
- en: Using inheritance and aggregation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承和聚合
- en: In this recipe, you will learn more about two important OOP concepts, inheritance
    and polymorphism, which have been mentioned already and used in the examples of
    the previous recipes. Together with aggregation, these concepts make the design
    more extensible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习更多关于两个重要的面向对象编程概念，继承和多态，这些概念已经在前面的示例中提到并被使用。结合聚合，这些概念使设计更具可扩展性。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Inheritance is the ability of one class to get ownership of the non-private fields
    and methods of another class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一个类获取另一个类的非私有字段和方法的能力。
- en: The extended class is called the base class, superclass, or parent class. The
    new extension of the class is called a subclass or child class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的类称为基类、超类或父类。类的新扩展称为子类或子类。
- en: Polymorphism is the ability to use the base class type for the reference to
    an object of its subclass.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是使用基类类型引用其子类对象的能力。
- en: To demonstrate the power of inheritance and polymorphism, let's create classes
    that represent cars and trucks, each with the weight, engine power, and speed
    it can reach (as a function of time) with the maximum load. In addition, a car,
    in this case, will be characterized by the number of passengers, while a truck's
    important feature will be its payload.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示继承和多态的威力，让我们创建代表汽车和卡车的类，每个类都有它可以达到的重量、发动机功率和速度（作为时间函数）的最大载荷。此外，这种情况下的汽车将以乘客数量为特征，而卡车的重要特征将是其有效载荷。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Look at the `Vehicle` class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看`Vehicle`类：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The functionality implemented in the `Vehicle` class is not specific to a car
    or to a truck, so it makes sense to use this class as a base class for the `Car`
    and `Truck` classes, so each of them gets this functionality as its own.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类中实现的功能不特定于汽车或卡车，因此将这个类用作`Car`和`Truck`类的基类是有意义的，这样每个类都可以将这个功能作为自己的功能。'
- en: 'Create the `Car` class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Car`类：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `Truck` class:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Truck`类：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the `Vehicle` base class has neither an implicit nor explicit constructor
    without parameters (because we have chosen to use an explicit constructor with
    parameters only), we had to call the base class constructor `super()` as the first
    line of the constructor of every subclass of the `Vehicle` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Vehicle`基类既没有隐式构造函数也没有没有参数的显式构造函数（因为我们选择只使用带参数的显式构造函数），所以我们必须在`Vehicle`类的每个子类的构造函数的第一行调用基类构造函数`super()`。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s write a test program:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试程序：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the `vehicle` reference of the `Vehicle` type points to the object
    of the `Car` subclass and later to the object of the `Truck` subclass. This is
    possible thanks to polymorphism, according to which an object has a type of every
    class in its line of inheritance, including all the interfaces.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Vehicle`类型的`vehicle`引用指向`Car`子类的对象，稍后指向`Truck`子类的对象。这是由多态性实现的，根据多态性，对象具有其继承线中每个类的类型，包括所有接口。
- en: If you need to invoke a method that exists only in the subclass, you have to
    cast such a reference to the subclass type, as was done in the previous example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调用仅存在于子类中的方法，必须将这样的引用转换为子类类型，就像在前面的示例中所做的那样。
- en: 'The results of the preceding code are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果如下：
- en: '![](img/d383484b-d020-48a8-b025-444f48b764a4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d383484b-d020-48a8-b025-444f48b764a4.png)'
- en: We should not be surprised to see the same speed calculated for both the car
    and the truck because the same weight and engine power are used to calculate the speed
    of each. But, intuitively, we feel that a heavily loaded truck should not be able
    to reach the same speed as a car in the same period of time. To verify this, we
    need to include the total weight of the car (with the passengers and their luggage)
    and that of the truck (with the payload) in the calculations of the speed. One
    way to do this is to override the `getSpeedMph(double timeSec)` method of the `Vehicle` base
    class in each of the subclasses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该对看到相同的速度计算结果感到惊讶，因为相同的重量和发动机功率用于计算每个车辆的速度。但是，直观上，我们感觉到一个装载重的卡车不应该能够在相同的时间内达到与汽车相同的速度。为了验证这一点，我们需要在速度的计算中包括汽车的总重量（乘客和行李）和卡车的总重量（有效载荷）。一种方法是在每个子类中覆盖`Vehicle`基类的`getSpeedMph(double
    timeSec)`方法。
- en: 'We can add the `getSpeedMph(double timeSec)` method to the `Car` class, which
    will override the method with the same signature in the base class. This method
    will use car-specific weight calculation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Car`类中添加`getSpeedMph(double timeSec)`方法，它将覆盖基类中具有相同签名的方法。这个方法将使用特定于汽车的重量计算：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we have assumed that a passenger with luggage weighs
    `250` pounds total on average.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们假设一个带行李的乘客平均重量为`250`磅。
- en: 'Similarly, we can add the `getSpeedMph(double timeSec)` method to the `Truck` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以在`Truck`类中添加`getSpeedMph(double timeSec)`方法：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The results of these modifications (if we run the same test class) will be
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些修改的结果（如果我们运行相同的测试类）将如下：
- en: '![](img/2063b24d-ad9e-45ad-9fe8-387b077e2c86.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2063b24d-ad9e-45ad-9fe8-387b077e2c86.png)'
- en: The results confirm our intuition—a fully loaded car or truck does not reach
    the same speed as an empty one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证实了我们的直觉——装载完全的汽车或卡车的速度不会达到空车的速度。
- en: 'The new methods in the subclasses override `getSpeedMph(double timeSec)` of
    the `Vehicle` base class, although we access it via the base class reference:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中的新方法覆盖了`Vehicle`基类的`getSpeedMph(double timeSec)`，尽管我们是通过基类引用来访问它的：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The overridden method is dynamically bound, which means that the context of
    the method invocation is determined by the type of the actual object being referred
    to. Since, in our example, the reference `vehicle` points to an object of the `Car` subclass,
    the `vehicle.getSpeedMph(double timeSec)` construct invokes the method of the
    subclass, not the method of the base class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的方法是动态绑定的，这意味着方法调用的上下文是由实际对象的类型决定的。因此，在我们的示例中，引用`vehicle`指向`Car`子类的对象，`vehicle.getSpeedMph(double
    timeSec)`调用子类的方法，而不是基类的方法。
- en: 'There is obvious code redundancy in the two new methods, which we can refactor
    by creating a method in the `Vehicle` base class and then use it in each of the
    subclasses:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个新方法中存在明显的代码冗余，我们可以通过在`Vehicle`基类中创建一个方法，然后在每个子类中使用它来重构。
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since this method is used by subclasses only, it can be `protected` and thus,
    accessible only to the subclasses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个方法只被子类使用，它可以是`protected`，因此只能被子类访问。
- en: 'Now, we can change the `getSpeedMph(double timeSec)` method in the `Car` class,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改`Car`类中的`getSpeedMph(double timeSec)`方法，如下所示：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, there was no need to use the `super` keyword while calling
    the `getSpeedMph(timeSec, weightPounds)` method because a method with such a signature
    exists only in the `Vehicle` base class, and there is no ambiguity about it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，调用`getSpeedMph(timeSec, weightPounds)`方法时不需要使用`super`关键字，因为这样的签名方法只存在于`Vehicle`基类中，对此没有任何歧义。
- en: 'Similar changes can be made in the `getSpeedMph(double timeSec)` method of the `Truck` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Truck`类的`getSpeedMph(double timeSec)`方法中也可以进行类似的更改：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we need to modify the test class by adding casting, otherwise there will
    be a runtime error because the `getSpeedMph(double timeSec)` method does not exist
    in the `Vehicle` base class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过添加转换来修改测试类，否则会出现运行时错误，因为`Vehicle`基类中不存在`getSpeedMph(double timeSec)`方法：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you may have expected, the test class produces the same values:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，测试类产生相同的值：
- en: '![](img/a3b6ad65-2ded-4313-9556-3f48a4060cb4.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3b6ad65-2ded-4313-9556-3f48a4060cb4.png)'
- en: 'To simplify the test code, we can drop casting and write the following instead:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试代码，我们可以放弃转换，改为写以下内容：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The speed values produced by this code remain the same.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生的速度值保持不变。
- en: 'Yet, there is an even simpler way to achieve the same effect. We can add the `getMaxWeightPounds()`
    method to the base class and each of the subclasses. The `Car` class will now
    look as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种更简单的方法可以实现相同的效果。我们可以将`getMaxWeightPounds()`方法添加到基类和每个子类中。现在`Car`类将如下所示：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here''s what the new version of the `Truck` class looks like now:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Truck`类的新版本如下所示：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need to add the `getMaxWeightPounds()` method to the base class so
    that it can be used for the speed calculations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在基类中添加`getMaxWeightPounds()`方法，以便用于速度计算：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Adding an abstract method, `getMaxWeightPounds()`, to the `Vehicle` class makes
    the class abstract. This has a positive side effect—it enforces the implementation
    of the `getMaxWeightPounds()` method in each subclass. Otherwise, a subclass cannot
    be instantiated and has to be declared abstract too.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Vehicle`类添加一个抽象方法`getMaxWeightPounds()`会使该类成为抽象类。这有一个积极的副作用——它强制在每个子类中实现`getMaxWeightPounds()`方法。否则，子类将无法实例化，必须声明为抽象类。
- en: 'The test class remains the same and produces the same results:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类保持不变，产生相同的结果：
- en: '![](img/a5729936-bd5b-478f-80f4-4b0f0737bdb9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5729936-bd5b-478f-80f4-4b0f0737bdb9.png)'
- en: 'But, to be honest, we did it just to demonstrate one possible way of using
    an abstract method and class. In fact, an even simpler solution would be to pass
    the maximum weight as a parameter into the constructor of the `Vehicle` base class.
    The resulting classes will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，说实话，我们这样做只是为了演示使用抽象方法和类的一种可能方式。事实上，一个更简单的解决方案是将最大重量作为参数传递给`Vehicle`基类的构造函数。结果类将如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We added the weight of the passengers to the value we pass to the constructor
    of the superclass; this is the only change in this subclass. Here is a similar
    change in the `Truck` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将乘客的重量添加到我们传递给超类构造函数的值中；这是这个子类中唯一的变化。`Truck`类中也有类似的变化：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Vehicle` base class remains the same as the original one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`基类与原始的一样：'
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test class does not change and produces the same results:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类不会改变，并且产生相同的结果：
- en: '![](img/fda2f8c4-58be-44e1-afd1-02c378f1b7a0.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fda2f8c4-58be-44e1-afd1-02c378f1b7a0.png)'
- en: This last version—passing the maximum weight to the constructor of the base
    class—will now be the starting point for further code demonstrations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的版本——将最大重量传递给基类的构造函数——现在将成为进一步代码演示的起点。
- en: Aggregation makes the design more extensible
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合使设计更具可扩展性
- en: In the preceding example, the speed model was implemented in the `getSpeedMph(double
    timeSec)` method of the `Vehicle` class. If we need to use a different speed model
    (which includes more input parameters and is more tuned to certain driving conditions,
    for example), we would need to change the `Vehicle` class or create a new subclass
    to override the method. In the case where we need to experiment with dozens or
    even hundreds of different models, this approach becomes untenable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，速度模型是在`Vehicle`类的`getSpeedMph(double timeSec)`方法中实现的。如果我们需要使用不同的速度模型（例如包含更多输入参数并且更适合特定驾驶条件），我们需要更改`Vehicle`类或创建一个新的子类来覆盖该方法。在需要尝试几十甚至数百种不同模型的情况下，这种方法变得不可行。
- en: Also, in real life, modeling based on machine learning and other advanced techniques
    become so involved and specialized, that it is quite common that the modeling
    of car acceleration is done by a different team, not the team that assembles the
    vehicle model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在现实生活中，基于机器学习和其他先进技术的建模变得如此复杂和专业化，以至于汽车加速的建模通常是由不同的团队完成的，而不是组装车辆模型的团队。
- en: To avoid the proliferation of subclasses and code-merge conflicts between vehicle
    builders and speed-model developers, we can create a more extensible design using
    aggregation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免子类的激增和车辆构建者与速度模型开发者之间的代码合并冲突，我们可以使用聚合创建一个更具可扩展性的设计。
- en: Aggregation is an OOD principle for implementing the necessary functionality
    using the behavior of classes that are not part of the inheritance hierarchy.
    That behavior can exist independent of the aggregated functionality.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一种面向对象设计原则，用于使用不属于继承层次结构的类的行为来实现必要的功能。该行为可以独立于聚合功能存在。
- en: 'We can encapsulate the speed calculations inside the `SpeedModel` class in
    the `getSpeedMph(double timeSec)` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将速度计算封装在`SpeedModel`类的`getSpeedMph(double timeSec)`方法中：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An object of this class can be created and then set as the value of the `Vehicle` class
    field:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建这个类的对象，然后将其设置为`Vehicle`类字段的值：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test class changes as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类的更改如下：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![](img/97d4f021-cc4a-4235-bae2-4388a0c31ba8.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d4f021-cc4a-4235-bae2-4388a0c31ba8.png)'
- en: We isolated the speed-calculating functionality in a separate class and can
    now modify or extend it without changing any class of the `Vehicle` inheritance
    hierarchy. This is how the aggregation design principle allows you to change the behavior
    without changing the implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将速度计算功能隔离到一个单独的类中，现在可以修改或扩展它，而不需要改变`Vehicle`继承层次结构中的任何类。这就是聚合设计原则允许您在不改变实现的情况下改变行为的方式。
- en: In the next recipe, we will show you how the OOP concept of interface unlocks
    more power of aggregation and polymorphism, making the design simpler and even
    more expressive.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将向您展示接口的面向对象编程概念如何释放出更多聚合和多态的力量，使设计更简单，甚至更具表现力。
- en: Coding to an interface
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码到接口
- en: In this recipe, you will learn the last of the OOP concepts, called interface,
    and further practice the usage of aggregation and polymorphism as well as inner
    classes and inheritance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习面向对象编程概念中的最后一个接口，并进一步练习聚合和多态的使用，以及内部类和继承。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: An interface defines the signatures of the methods one can expect to see in
    the class that implements the interface. It is the public face of the functionality
    that's accessible to a client and is thus often called an **Application Program
    Interface** (**API**). It supports polymorphism and aggregation, and facilitates
    a more flexible and extensible design.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了一个类中可以期望看到的方法的签名。它是对客户端可访问的功能的公共界面，因此通常被称为**应用程序编程接口**（**API**）。它支持多态和聚合，并促进更灵活和可扩展的设计。
- en: An interface is implicitly abstract, which means it cannot be instantiated.
    No object can be created based on an interface only, without implementing it.
    It is used to contain abstract methods (without body) only. But since Java 8,
    it is possible to add default and private methods to an interface, which is the
    capability we are going to discuss in the following recipes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是隐式抽象的，这意味着它不能被实例化。不能仅基于接口创建对象，而不实现它。它仅用于包含抽象方法（无方法体）。但自Java 8以来，可以向接口添加默认和私有方法，这是我们将在以下示例中讨论的功能。
- en: Each interface can extend multiple other interfaces and, similar to class inheritance,
    inherit all default and abstract methods of the extended interfaces. Static members
    cannot be inherited because they belong to a specific interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口可以扩展多个其他接口，并且类继承类似，继承所有扩展接口的默认和抽象方法。静态成员不能被继承，因为它们属于特定接口。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create interfaces that describe the API:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建描述API的接口：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use factories, which are classes that generate objects that implement certain
    interfaces. A factory hides from the client code the details of the implementation,
    so the client deals with an interface only. It is especially helpful when an instance
    creation requires a complex process and/or significant code duplication. In our
    case, it makes sense to have a `FactoryVehicle` class that creates objects of
    classes that implement the `Vehicle`, `Car`, or `Truck` interface. We will also
    create the `FactorySpeedModel` class, which generates objects of a class that
    implements the `SpeedModel` interface. Such an API allows us to write the following
    code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工厂，这些工厂是生成实现特定接口的对象的类。工厂隐藏了实现的细节，因此客户端只处理接口。当实例创建需要复杂的过程和/或大量代码重复时，这是特别有帮助的。在我们的情况下，有一个`FactoryVehicle`类是有意义的，它创建实现`Vehicle`、`Car`或`Truck`接口的类的对象。我们还将创建`FactorySpeedModel`类，它生成实现`SpeedModel`接口的类的对象。这样的API允许我们编写以下代码：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Observe that the code behavior is the same as in the previous examples:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，代码行为与先前示例中的相同：
- en: '![](img/350a455b-060d-47ea-ac7a-b0b904f5f119.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/350a455b-060d-47ea-ac7a-b0b904f5f119.png)'
- en: However, the design is much more extensible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设计更具可扩展性。
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have already seen one possible implementation of the `SpeedModel` interface.
    Here is another way to do it by aggregating the object of the `SpeedModel` type
    inside the `FactorySpeedModel` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`SpeedModel`接口的一个可能的实现。这是另一种通过在`FactorySpeedModel`类内聚`SpeedModel`类型对象来实现的方法：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We put comments as pseudocode, and the `...` symbol instead of the actual code,
    for brevity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注释作为伪代码，并使用`...`符号代替实际代码，以便简洁。
- en: As you can see, the factory class may hide many different private classes, each
    containing a specialized model for particular driving conditions. Each model produces
    a different result.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，工厂类可能隐藏许多不同的私有类，每个类都包含特定驾驶条件的专门模型。每个模型产生不同的结果。
- en: 'An implementation of the `FactoryVehicle` class may look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryVehicle`类的实现可能如下所示：'
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `CarImpl` private nested class may look as follows inside the  `FactoryVehicle` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarImpl`私有嵌套类在`FactoryVehicle`类内部可能如下所示：'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Similarly, the `TruckImpl` class can be a private nested class of the `FactoryImpl` class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`TruckImpl`类可以是`FactoryImpl`类的私有嵌套类：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can place the `VehicleImpl` class as a private inner class of the `FactoryVehicle`
    class too, so the `CarImpl` and `TruckImpl` classes can access it, but not any
    other class outside of `FactoryVehicle`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`VehicleImpl`类作为`FactoryVehicle`类的私有内部类放置，这样`CarImpl`和`TruckImpl`类就可以访问它，但是`FactoryVehicle`之外的任何其他类都不能访问它：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, an interface describes how to invoke object behavior, while
    factories can generate different implementations for different requests without
    changing the code of the client application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，接口描述了如何调用对象行为，而工厂可以为不同的请求生成不同的实现，而不改变客户端应用程序的代码。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's try to model a crew cab—a truck with multiple passenger seats that combines
    the properties of a car and a truck. Java does not allow multiple inheritances.
    This is another case where an interface comes to the rescue.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试建模一个乘员舱——一个具有多个乘客座位的卡车，它结合了汽车和卡车的特性。Java不允许多重继承。这是另一个接口发挥作用的案例。
- en: 'The `CrewCab` class may look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrewCab`类可能如下所示：'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This class implements both interfaces—`Car` and `Truck`—and passes the combined
    weight of the vehicle, payload, and passengers with their luggage to the base
    class constructor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类同时实现了`Car`和`Truck`接口，并将车辆、货物和乘客及其行李的总重量传递给基类构造函数。
- en: 'We can also add the following method to `FactoryVehicle`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向`FactoryVehicle`添加以下方法：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The double nature of the `CrewCab` object can be demonstrated in the following
    test:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrewCab`对象的双重性质可以在以下测试中得到证明：'
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, we can cast the object of the `CrewCub` class to each of the
    interfaces it implements. If we run this program, the results will be as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以将`CrewCub`类的对象转换为它实现的每个接口。如果我们运行这个程序，结果将如下所示：
- en: '![](img/e5b5257c-8012-4426-9d71-ac9820ccbbf1.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5b5257c-8012-4426-9d71-ac9820ccbbf1.png)'
- en: Creating interfaces with default and static methods
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有默认和静态方法的接口
- en: In this recipe, you will learn about two new features that were first introduced
    in Java 8—the default and static methods in an interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将了解到Java 8中首次引入的两个新功能——接口中的默认和静态方法。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A default method in an interface allows us to add a new method signature without
    changing the classes that have implemented this interface before a new method
    signature was added. The method is called *default* because it provides functionality
    in case this method is not implemented by the class. If, however, the class implements
    it, the interface's default implementation is ignored and overridden by the class
    implementation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的默认方法允许我们添加一个新的方法签名，而不需要改变在添加新方法签名之前已经实现了该接口的类。该方法被称为*default*，因为它在该方法未被类实现时提供功能。然而，如果类实现了它，接口的默认实现将被忽略并被类实现覆盖。
- en: A static method in an interface can provide functionality in the same way a
    static method in a class can. Similarly to a class static method, which can be
    called without class instantiation, an interface static method can also be called
    using a dot-operator applied to the interface, `SomeInterface.someStaticMethod()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的静态方法可以提供与类中的静态方法相同的功能。类似于类静态方法可以在不实例化类的情况下调用一样，接口静态方法也可以使用点运算符应用于接口来调用，`SomeInterface.someStaticMethod()`。
- en: A static method of an interface cannot be overridden by the class that implements
    this interface, and it cannot hide any static method of any class, including the
    class that implements this interface.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的静态方法不能被实现该接口的类覆盖，也不能隐藏任何类的静态方法，包括实现该接口的类。
- en: For example, let's add some functionality to the system we have used already
    in our examples. So far, we have created an amazing piece of software that calculates
    the speed of a vehicle. If the system becomes popular (as it should), we would
    like it to be friendlier to the readers who prefer a metric system of units, instead
    of the miles and pounds we have used in our speed calculations. To address such
    a need after our speed-calculating software has become popular, we have decided
    to add more methods to the `Car` and `Truck` interfaces, but we do not want to break
    the existing implementations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们为我们已经在示例中使用的系统添加一些功能。到目前为止，我们已经创建了一个了不起的软件，可以计算车辆的速度。如果系统变得受欢迎（应该是这样），我们希望它对更喜欢使用公制单位的读者更友好，而不是我们在速度计算中使用的英里和磅。在我们的速度计算软件变得受欢迎之后，为了满足这样的需求，我们决定向`Car`和`Truck`接口添加更多方法，但我们不想破坏现有的实现。
- en: The default interface method was introduced exactly for such a situation. Using
    it, we can release a new version of the `Car` and `Truck` interfaces without the
    need to coordinate the release with the corresponding modification of the existing
    implementations, that is, the `CarImpl`, `TruckImpl`, and `FactoryVehicle` classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口方法正是为这种情况而引入的。使用它，我们可以发布`Car`和`Truck`接口的新版本，而无需协调与现有实现的相应修改，即`CarImpl`、`TruckImpl`和`FactoryVehicle`类。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As an example, we will change the `Truck` interface. The `Car` interface can
    be modified in a similar fashion:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将更改`Truck`接口。`Car`接口可以以类似的方式修改：
- en: 'Enhance the `Truck` interface by adding the `getPayloadKg()` method, which
    returns the truck payload in kilograms. You can do this without forcing a change
    in the `TruckImpl` class that implements the `Truck` interface—by adding a new
    default method to the `Truck` interface:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个新的默认方法来增强`Truck`接口，该方法返回卡车的载重量（以千克为单位）。您可以在不强制更改实现`Truck`接口的`TruckImpl`类的情况下完成这一点——通过向`Truck`接口添加一个新的默认方法：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice how the new `getPayloadKg()` method uses the existing `getPayloadPounds()` method
    as if the latter is implemented inside the interface too, although, in fact, it
    is implemented in a class that implements the `Truck` interface. The magic happens
    during runtime when this method becomes dynamically bound to the instance of the
    class that implements this interface.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的`getPayloadKg()`方法如何使用现有的`getPayloadPounds()`方法，就好像后者也是在接口内实现的一样，尽管实际上它是在实现`Truck`接口的类中实现的。魔术发生在运行时，当这个方法动态绑定到实现该接口的类的实例时。
- en: We could not make the `getPayloadKg()` method static because it would not be
    able to access the non-static `getPayloadPounds()` method, and we must use the
    `default` keyword because only the default or static method of an interface can
    have a body.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法将`getPayloadKg()`方法设为静态，因为它无法访问非静态的`getPayloadPounds()`方法，我们必须使用`default`关键字，因为只有接口的默认或静态方法才能有方法体。
- en: 'Write the client code that uses the new method:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用新方法的客户端代码：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the preceding program and check out the output:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述程序并检查输出：
- en: '![](img/b8a5a262-530f-4fda-8c70-f6a7031828ef.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8a5a262-530f-4fda-8c70-f6a7031828ef.png)'
- en: Notice that the new method works even without changing the class that implemented
    it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，即使不改变实现它的类，新方法也可以工作。
- en: 'When you decide to improve the implementation of the `TruckImpl` class, you
    can do it by adding the corresponding method, for example:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您决定改进`TruckImpl`类的实现时，您可以通过添加相应的方法来实现，例如：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have implemented the `getPyloadKg()` method as `return -2` in order to make
    it obvious which implementation is used.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`getPyloadKg()`方法，使其为`return -2`，以便明确使用了哪种实现。
- en: 'Run the same demo program. The results will be as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行相同的演示程序。结果将如下所示：
- en: '![](img/ec934ae1-b1ca-46e6-bd7c-c4ddd443e171.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec934ae1-b1ca-46e6-bd7c-c4ddd443e171.png)'
- en: As you can see, this time, the method implementation in the `TruckImpl` class
    was used. It has overridden the default implementation in the `Truck` interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这次在`TruckImpl`类中使用了方法实现。它已覆盖了`Truck`接口中的默认实现。
- en: 'Enhance the `Truck` interface with the ability to enter the payload in kilograms
    without changing the implementation of `FactoryVehicle` and the `Truck` interface.
    Also, we do not want to add a setter method. With all of these limitations, our
    only recourse is to add `convertKgToPounds(int kgs)` to the `Truck` interface,
    and it has to be `static` since we are going to use it before the object that
    implements the `Truck` interface is constructed:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增强`Truck`接口的功能，使其能够以千克为单位输入有效载荷，而不改变`FactoryVehicle`和`Truck`接口的实现。此外，我们不希望添加一个setter方法。在所有这些限制下，我们唯一的选择是在`Truck`接口中添加`convertKgToPounds(int
    kgs)`方法，并且它必须是静态的，因为我们将在实现`Truck`接口的对象构造之前使用它：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Those who prefer the metric system of units can now take advantage of the new
    method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，喜欢使用公制单位的人可以利用新的方法：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The results will be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/9b6dd7f4-683a-4c17-9fe9-36f269429277.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b6dd7f4-683a-4c17-9fe9-36f269429277.png)'
- en: The value of 1,502 is close to the original 1,500, while 3,308 is close to 3,312\.
    The difference is caused by the error of an approximation during the conversion.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 1,502的值接近原始的1,500，而3,308接近3,312。差异是由转换过程中的近似误差引起的。
- en: Creating interfaces with private methods
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有私有方法的接口
- en: In this recipe, you will learn about a new feature that was introduced in Java
    9, the private interface method, which is of two types—static and non-static.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将了解Java 9中引入的新功能——私有接口方法，它有两种类型：静态和非静态。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A private interface method must have an implementation (a body with a code). A
    private interface method not used by other methods of the same interface does
    not make sense. The purpose of a private method is to contain functionality that
    is common between two or more methods with a body in the same interface or to
    isolate a section of code in a separate method for better structure and readability.
    A private interface method cannot be overridden—not by a method of any other interface,
    nor by a method in a class that implements the interface.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 私有接口方法必须有实现（具有代码的主体）。同一接口的其他方法未使用的私有接口方法是没有意义的。私有方法的目的是包含在同一接口中具有主体的两个或多个方法之间的常见功能，或者将代码部分隔离在单独的方法中，以获得更好的结构和可读性。私有接口方法不能被覆盖，既不能被任何其他接口的方法覆盖，也不能被实现接口的类中的方法覆盖。
- en: A non-static private interface method can only be accessed by non-static methods
    of the same interface. A static private interface method can be accessed by non-static
    and static methods of the same interface.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态私有接口方法只能被同一接口的非静态方法访问。静态私有接口方法可以被同一接口的非静态和静态方法访问。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the `getWeightKg(int pounds)` method implementation:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`getWeightKg(int pounds)`方法的实现：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Remove the redundant code by using the private interface method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用私有接口方法删除冗余代码：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The following code demonstrates the new addition:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了新的添加内容：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The results of the test do not change:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果不会改变：
- en: '![](img/6e275e58-b2e0-4b84-bf31-fd7cba0ce165.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e275e58-b2e0-4b84-bf31-fd7cba0ce165.png)'
- en: There's more...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With the `getWeightKg(int pounds)` method accepting the input parameter, the
    method name can be misleading because it does not capture the weight unit of the
    input parameter. We could try and name it `getWeightKgFromPounds(int pounds)` but
    it does not make the method function clearer. After realizing it, we decided to make
    the `convertPoundsToKg(int pounds)` method public and to remove the `getWeightKg(int pounds)` method
    at all. Since the `convertPoundsToKg(int pounds)` method does not require access
    to the object fields, it can be static, too:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getWeightKg(int pounds)`方法接受输入参数，方法名称可能会误导，因为它没有捕捉输入参数的重量单位。我们可以尝试将其命名为`getWeightKgFromPounds(int
    pounds)`，但这并不会使方法功能更清晰。在意识到这一点后，我们决定将`convertPoundsToKg(int pounds)`方法设为公共方法，并完全删除`getWeightKg(int
    pounds)`方法。由于`convertPoundsToKg(int pounds)`方法不需要访问对象字段，它也可以是静态的：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Fans of the metric system are still able to convert pounds into kilograms and
    back. Besides, since both converting methods are static, we do not need to create
    an instance of the class that implements the `Truck` interface in order to do
    the conversion:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以将英镑转换为千克，而且由于两种转换方法都是静态的，我们不需要创建实现`Truck`接口的类的实例来进行转换：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The results do not change:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不会改变：
- en: '![](img/7e402e41-cd4e-42b6-9ed2-5549b764a5ce.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e402e41-cd4e-42b6-9ed2-5549b764a5ce.png)'
- en: A better way to work with nulls using Optional
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Optional更好地处理空值
- en: In this recipe, you will learn how to use the `java.util.Optional` class for
    representing optional values instead of using `null` references. It was introduced
    in Java 8 and further enhanced in Java 9—where three more methods were added—`or()`,
    `ifPresentOrElse()`, and `stream()`. We will demonstrate all of them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何使用`java.util.Optional`类来表示可选值，而不是使用`null`引用。它是在Java 8中引入的，并在Java
    9中进一步增强，增加了三种方法：`or()`、`ifPresentOrElse()`和`stream()`。我们将演示它们全部。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `Optional` class is a wrapper around a value, which can be `null` or a value
    of any type. It was intended to help to avoid the dreaded `NullPointerException`.
    But, so far, the introduction of `Optional` helped to accomplish it only to a
    degree and mostly in the area of streams and functional programming.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类是一个围绕值的包装器，可以是`null`或任何类型的值。它旨在帮助避免可怕的`NullPointerException`。但是，到目前为止，引入`Optional`只在流和函数式编程领域有所帮助。'
- en: The vision that motivated the creation of the `Optional` class was to call the `isPresent()` method
    on an `Optional` object and then apply the `get()` method (to get the contained
    value) only when the `isPresent()` method returns `true`. Unfortunately, when
    one cannot guarantee that the reference to the `Optional` object itself is not
    `null`, one needs to check it in order to avoid `NullPointerException`. If so,
    then the value of using `Optional` diminishes, because with even less amount of
    code writing we could check for `null` the value itself and avoid wrapping inside
    `Optional` whatsoever? Let's write the code that illustrates what we have been
    talking about.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Optional`类的愿景是在`Optional`对象上调用`isPresent()`方法，然后仅在`isPresent()`方法返回`true`时应用`get()`方法（获取包含的值）。不幸的是，当无法保证`Optional`对象本身的引用不是`null`时，需要检查它以避免`NullPointerException`。如果是这样，那么使用`Optional`的价值就会减少，因为即使写入更少的代码，我们也可以检查值本身是否为`null`并避免包装在`Optional`中？让我们编写代码来说明我们所说的。
- en: 'Let''s assume that we would like to write a method that checks the lottery
    result and, if the ticket you have bought with your friend wins, calculates your 50%
    share. The traditional way to do it would be:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个方法来检查彩票结果，如果你和朋友一起买的彩票中奖了，计算你的50%份额。传统的做法是：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But, to demonstrate how to use `Optional`, we will assume that the result is
    of the `Integer` type. Then, we also need to check for `null`, if we are not sure
    that the passed-in value cannot be `null`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了演示如何使用`Optional`，我们将假设结果是`Integer`类型。然后，我们还需要检查`null`，如果我们不能确定传入的值不可能是`null`：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using the `Optional` class does not help to avoid the check for `null`. It
    even requires an additional check, `isPresent()`, to be added so that we can avoid
    `NullPointerException` while getting the value:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Optional`类并不能帮助避免对`null`的检查。它甚至需要添加额外的检查`isPresent()`，以避免在获取值时出现`NullPointerException`：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Apparently, the preceding usage of `Optional` does not help to improve the code
    or make the coding easier. Using `Optional` in Lambda expressions and stream pipelines
    has more potential because the `Optional` object provides methods that can be
    invoked via the dot-operator and can be plugged into the fluent-style processing
    code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，先前使用`Optional`并没有帮助改进代码或使编码更容易。在Lambda表达式和流管道中使用`Optional`具有更大的潜力，因为`Optional`对象提供了可以通过点运算符调用的方法，并且可以插入到流畅式处理代码中。
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an `Optional` object using any of the methods that have been demonstrated,
    as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已经演示过的任何方法创建一个`Optional`对象，如下所示：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that a `null` value can be wrapped inside an `Optional` object by using
    the `ofNullable()` method.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以使用`ofNullable()`方法将`null`值包装在`Optional`对象中。
- en: 'It is possible to compare two `Optional` objects by using the `equals()` method,
    which compares them by value:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`equals()`方法比较两个`Optional`对象，该方法通过值进行比较：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Please note that an empty `Optional` object is equal to an object that wraps
    the `null` value (the `prize1` and `prize3` objects in the preceding code). The `prize2`
    and `prize4` objects in the preceding code are equal because they wrap the same
    value, although they are different objects and the references do not match (`prize2
    != prize4`). Also, notice that empty objects that wrap different types are equal
    (`prize1.equals(congrats1)`), which means that the `equals()` method of the `Optional` class
    does not compare the value type.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空的`Optional`对象等于包装`null`值的对象（上述代码中的`prize1`和`prize3`对象）。上述代码中的`prize2`和`prize4`对象相等，因为它们包装相同的值，尽管它们是不同的对象，引用不匹配（`prize2
    != prize4`）。还要注意，包装不同类型的空对象是相等的（`prize1.equals(congrats1)`），这意味着`Optional`类的`equals()`方法不比较值类型。
- en: 3\. Use the `or(Suppier<Optional<T>> supplier)` method of the `Optional` class
    to reliably return a non-null value from the `Optional` object. If the object
    is empty and contains `null`, it returns another value contained in the `Optional` object
    that was produced by the provided `Supplier` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 使用`Optional`类的`or(Suppier<Optional<T>> supplier)`方法可靠地从`Optional`对象中返回非空值。如果对象为空并包含`null`，则它将返回由提供的`Supplier`函数生成的`Optional`对象中的另一个值。
- en: 'For example, if the `Optional<Integer> lotteryPrize` object can contain a `null`
    value, the following construct will return zero every time the `null` value is
    encountered:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`Optional<Integer> lotteryPrize`对象可能包含`null`值，则以下结构将在遇到`null`值时每次返回零：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use the `ifPresent(Consumer<T> consumer)` method to ignore the `null` value
    and to process the non-null value using the provided `Consumer<T>` function. For
    example, here is the `processIfPresent(Optional<Integer>)` method, which processes the `Optional<Integer>
    lotteryPrize` object:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ifPresent(Consumer<T> consumer)`方法来忽略`null`值，并使用提供的`Consumer<T>`函数处理非空值。例如，这是`processIfPresent(Optional<Integer>)`方法，它处理`Optional<Integer>
    lotteryPrize`对象：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can simplify the preceding code by creating the `checkResultAndShare(int
    prize)` method:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建`checkResultAndShare(int prize)`方法简化上述代码：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, the `processIfPresent()` method looks much simpler:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`processIfPresent()`方法看起来简单得多：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you do not want to ignore the `null` value and process it as well, you can
    use the `ifPresentOrElse(Consumer<T> consumer, Runnable processEmpty)` method
    to apply the `Consumer<T>` function to a non-null value, and use the `Runnable` functional
    interface to process the `null` value:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不想忽略`null`值并且也要处理它，可以使用`ifPresentOrElse(Consumer<T> consumer, Runnable processEmpty)`方法将`Consumer<T>`函数应用于非空值，并使用`Runnable`函数接口来处理`null`值：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, we have reused the `checkResultAndShare(int prize)` method we
    just created.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们已经重用了刚刚创建的`checkResultAndShare(int prize)`方法。
- en: 'Using the `orElseGet(Supplier<T> supplier)` method allows us to replace an
    empty or `null` value (contained in the  `Optional` object) with the value produced
    by the provided `Supplier<T>` function:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`orElseGet(Supplier<T> supplier)`方法允许我们用由提供的`Supplier<T>`函数产生的值来替换`Optional`对象中的空值或`null`值：
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Use the `orElseThrow()` method if you need to throw an exception in case an `Optional` object
    is empty or contains a `null` value:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要在`Optional`对象为空或包含`null`值的情况下抛出异常，请使用`orElseThrow()`方法：
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'An overloaded version of the `orElseThrow()` method allows us to specify an
    exception and the message you would like to throw when the value contained in
    the `Optional` object is `null`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`orElseThrow()`方法的重载版本允许我们指定异常和当`Optional`对象中包含的值为`null`时要抛出的消息：'
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the `filter()`, `map()`, and `flatMap()` methods to process `Optional` objects
    in a stream:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`、`map()`和`flatMap()`方法来处理流中的`Optional`对象：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding code, the `useFilter()` method processes only those stream
    elements that have non-null values. The `useMap()` method processes all stream
    elements but replaces `Optional` objects without any value or by wrapping the `null`
    value with an `Optional` object that wraps zero. The last method uses `flatMap()`,
    which requires returning a stream from the provided function. Our example is quite
    useless in this respect because the function we pass as a `flatMap()` parameter
    produces a stream of one object, so using `map()` (as in the previous `useMap()` method)
    is a better solution here. We only did this for demonstrating how the `flatMap()`
    method can be plugged into the stream pipeline.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`useFilter()`方法只处理那些非空数值的流元素。`useMap()`方法处理所有流元素，但是用没有值的`Optional`对象或者用包装了`null`值的`Optional`对象替换它们。最后一个方法使用了`flatMap()`，它需要从提供的函数返回一个流。在这方面，我们的示例是相当无用的，因为我们传递给`flatMap()`参数的函数产生了一个对象的流，所以在这里使用`map()`（就像前面的`useMap()`方法中一样）是一个更好的解决方案。我们只是为了演示`flatMap()`方法如何插入到流管道中才这样做的。
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following code demonstrates the functionality of the described `Optional` class.
    The `useFlatMap()` method accepts a list of `Optional` objects, creates a stream,
    and process each emitted element:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了所描述的`Optional`类的功能。`useFlatMap()`方法接受一个`Optional`对象列表，创建一个流，并处理每个发出的元素：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Each element of the original list first enters the `flatMap()` method as an
    input into the `tryUntilWin` function. This function first checks if the value
    of the `Optional` object is present. If yes, the `Optional` object is emitted
    as a single element of a stream and is processed by the `checkResultAndShare()` method.
    But if the `tryUntilWin` function determines that there is no value in the `Optional`
    object or the value is `null`, it generates a random double number in the range
    between `-0.8` and `0.2`. If the value is negative, an `Optional` object is added
    to the resulting list with a value of zero and a new random number is generated.
    But if the generated number is positive, it is used for the prize-value calculation,
    which is added to the resulting list that's wrapped inside an `Optional` object.
    The resulting list of `Optional` objects is then returned as a stream, and each
    element of the stream is processed by the `checkResultAndShare()` method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 原始列表的每个元素首先作为输入进入`flatMap()`方法，然后作为`tryUntilWin`函数的输入。这个函数首先检查`Optional`对象的值是否存在。如果是，`Optional`对象将作为流的单个元素发出，并由`checkResultAndShare()`方法处理。但是如果`tryUntilWin`函数确定`Optional`对象中没有值或者值为`null`，它会在`-0.8`和`0.2`之间生成一个随机双精度数。如果值为负数，就会向结果列表中添加一个值为零的`Optional`对象，并生成一个新的随机数。但如果生成的数是正数，它将用于奖金值的计算，并添加到包装在`Optional`对象中的结果列表中。`Optional`对象的结果列表然后作为流返回，并且流的每个元素都由`checkResultAndShare()`方法处理。
- en: 'Now, let''s run the preceding method for the following list:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对以下列表运行前面的方法：
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The results will be as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/94c3889d-7c68-497b-a360-7604d8c4f8ca.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94c3889d-7c68-497b-a360-7604d8c4f8ca.png)'
- en: As you can see, when the first list element, `Optional.empty()`, was processed,
    the `tryUntilWin` function succeeded in getting a positive `prize` value from
    the third attempt. The second `Optional.ofNullable(null)` object caused two attempts
    until the `tryUntilWin` function succeeded. The last object successfully went
    through and awarded you and your friend 50,000 each.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当第一个列表元素`Optional.empty()`被处理时，`tryUntilWin`函数在第三次尝试中成功获得了一个正的奖金值。第二个`Optional.ofNullable(null)`对象导致了两次尝试，直到`tryUntilWin`函数成功。最后一个对象成功通过，并奖励您和您的朋友各50000。
- en: There's more...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An object of the `Optional` class is not serializable and, thus, cannot be used
    as a field of an object. This is another indication that the designer of the `Optional` class
    intended to be used in a stateless process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类的对象不可序列化，因此不能用作对象的字段。这是`Optional`类的设计者打算在无状态过程中使用的另一个指示。'
- en: It makes the stream processing pipeline more compact and expressive, focusing
    on the actual values instead of checking if there are empty elements in the stream.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它使流处理管道更加简洁和表达，专注于实际值而不是检查流中是否有空元素。
- en: Using the utility class Objects
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实用类Objects
- en: In this recipe, you will learn how the `java.util.Objects` utility class allows
    for the better processing of objects related functionality related to object comparison,
    calculating a hash value, and checking for `null`. It was a long time coming,
    as the programmers wrote the same code for checking an object for `null` again
    and again.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习`java.util.Objects`实用类如何允许更好地处理与对象比较、计算哈希值和检查`null`相关的功能。这是早就该有的功能，因为程序员们一遍又一遍地编写相同的代码来检查对象是否为`null`。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `Objects` class has only 17 methods, all of which are static. For a better
    overview, we have organized them into seven groups:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects`类只有17种方法，全部都是静态的。为了更好地概述，我们将它们组织成了七个组：'
- en: '`compare()`: One method compares two objects using the provided `Comparator`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare()`: 使用提供的`Comparator`比较两个对象的方法'
- en: '`toString()`: Two methods that convert an `Object` to a `String` value'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`: 将`Object`转换为`String`值的两种方法'
- en: '`checkIndex()`: Three methods that allow us to check whether the index and
    the length of a collection or an array are compatible'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkIndex()`: 三种允许我们检查集合或数组的索引和长度是否兼容的方法'
- en: '`requireNonNull()`: Five methods throw an exception if the provided object
    is `null`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requireNonNull()`: 如果提供的对象为`null`，则五种方法抛出异常'
- en: '`hash()`, `hashCode():` Two methods that calculate a hash value for a single
    object or an array of objects'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash()`, `hashCode():` 计算单个对象或对象数组的哈希值的两种方法'
- en: '`isNull()`, `nonNull()`: Two methods that wrap the `obj == null` or  `obj !=
    null` expressions'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNull()`, `nonNull()`: 包装`obj == null`或`obj != null`表达式的两种方法'
- en: '`equals()`, `deepEquals()`: Two methods that compare two objects that can be
    null or arrays'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`, `deepEquals()`: 比较两个可以为null或数组的对象的两种方法'
- en: We are going to write code that uses these methods in the preceding sequence.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照前述顺序编写使用这些方法的代码。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `int compare(T a, T b, Comparator<T> c)` method uses the provided comparator
    for comparing the two objects:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int compare(T a, T b, Comparator<T> c)`方法使用提供的比较器来比较两个对象：'
- en: Returns 0 when the objects are equal
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象相等时返回0
- en: Returns a negative number when the first object is smaller than the second one
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当第一个对象小于第二个对象时返回负数
- en: Returns a positive number otherwise
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则返回正数
- en: 'The non-zero return value of the `int compare(T a, T b, Comparator<T> c)` method
    depends on the implementation. In the case of `String`, smaller and bigger are
    defined according to their ordering position (smaller is placed in front of bigger
    in the ordered list), and the returned value is the difference between the positions
    of the first and the second parameter in the list, ordered according to the provided
    comparator:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`int compare(T a, T b, Comparator<T> c)`方法的非零返回值取决于实现。对于`String`，根据它们的排序位置定义较小和较大（较小的放在有序列表的前面），返回值是第一个和第二个参数在列表中的位置之间的差异，根据提供的比较器排序：'
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `Integer` values, on the other hand, return just `-1` or `1` when the values
    are not equal:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Integer`值在值不相等时返回`-1`或`1`：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Please notice how, in the last line in the preceding code block, the result
    changes when we compare numbers as `String` literals.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面代码块的最后一行中，当我们将数字作为`String`文字进行比较时，结果会发生变化。
- en: 'When both objects are `null`, the `compare()` method considers them equal:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象都为`null`时，`compare()`方法将认为它们相等：
- en: '[PRE74]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'But it throws `NullPointerException` when only one of the objects is null:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当其中一个对象为null时，会抛出`NullPointerException`：
- en: '[PRE75]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If you need to compare an object with null, you are better off using `org.apache.commons.lang3.ObjectUtils.compare(T
    o1, T o2)`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将对象与null进行比较，最好使用`org.apache.commons.lang3.ObjectUtils.compare(T o1, T o2)`。
- en: 'The `toString(Object obj)` method is helpful when an `obj` object reference
    is the `null` value:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`null`时，`toString(Object obj)`方法很有用：
- en: '`String toString(Object obj)`: Returns the result of calling `toString()` on
    the first parameter when it is not `null` and `null` when the first parameter
    value is `null`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String toString(Object obj)`: 当第一个参数不为`null`时，返回调用`toString()`的结果，当第一个参数值为`null`时，返回`null`'
- en: '`String toString(Object obj, String nullDefault)`: Returns the result of calling `toString()` on
    the first parameter when it is not `null` and the second parameter value, `nullDefault`,
    when the first parameter value is `null`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String toString(Object obj, String nullDefault)`: 当第一个参数不为`null`时，返回调用`toString()`的结果，当第一个参数值为`null`时，返回第二个参数值`nullDefault`'
- en: 'The usage of the `toString(Object obj)` method is straightforward:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString(Object obj)`方法的使用很简单：'
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `checkIndex()` overloaded method checks whether the index and the length
    of a collection or an array are compatible:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkIndex()`重载方法检查集合或数组的索引和长度是否兼容：'
- en: '`int checkIndex(int index, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `index` is bigger than `length - 1`, for example:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int checkIndex(int index, int length)`: 如果提供的`index`大于`length - 1`，则抛出`IndexOutOfBoundsException`，例如：'
- en: '[PRE77]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`int checkFromIndexSize(int fromIndex, int size, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `index + size` is bigger than `length - 1`, for example:'
  id: totrans-368
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int checkFromIndexSize(int fromIndex, int size, int length)`: 如果提供的`index
    + size`大于`length - 1`，则抛出`IndexOutOfBoundsException`，例如：'
- en: '[PRE78]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`int checkFromToIndex(int fromIndex, int toIndex, int length)`: Throws `IndexOutOfBoundsException` if
    the provided `fromIndex` is bigger than `toIndex`, or `toIndex` is bigger than `length
    - 1`, for example:'
  id: totrans-370
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int checkFromToIndex(int fromIndex, int toIndex, int length)`: 如果提供的`fromIndex`大于`toIndex`，或者`toIndex`大于`length
    - 1`，则抛出`IndexOutOfBoundsException`，例如：'
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The five methods of the `requireNonNull()` group check the value of the first
    parameter, `obj`. If the value is `null`, they either throw `NullPointerException` or
    return the provided default value:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requireNonNull()`组的五种方法检查第一个参数`obj`的值。如果值为`null`，它们要么抛出`NullPointerException`，要么返回提供的默认值：'
- en: '`T requireNonNull(T obj)`: Throws `NullPointerException` without a message
    if the parameter is `null`, for example:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNull(T obj)`: 如果参数为`null`，则抛出没有消息的`NullPointerException`，例如：'
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`T requireNonNull(T obj, String message)`: Throws `NullPointerException` with
    the provided message if the first parameter is `null`, for example:'
  id: totrans-375
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNull(T obj, String message)`: 如果第一个参数为`null`，则抛出带有提供的消息的`NullPointerException`，例如：'
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`T requireNonNull(T obj, Supplier<String> messageSupplier)`: If the first parameter
    is `null`, returns the message generated the provided function or, if the generated
    message or the function itself is `null`, throws `NullPointerException`, for example:'
  id: totrans-377
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNull(T obj, Supplier<String> messageSupplier)`: 如果第一个参数为`null`，则返回由提供的函数生成的消息，如果生成的消息或函数本身为`null`，则抛出`NullPointerException`，例如：'
- en: '[PRE82]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`T requireNonNullElse(T obj, T defaultObj)`: Returns the first parameter (if
    it is non-null), the second parameter (if it is non-null), throws `NullPointerException` (if
    both parameters is `null`), for example:'
  id: totrans-379
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNullElse(T obj, T defaultObj)`: 返回第一个参数（如果它不是null），第二个参数（如果它不是null），抛出`NullPointerException`（如果两个参数都是`null`），例如：'
- en: '[PRE83]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`T requireNonNullElseGet(T obj, Supplier<T> supplier)`: Returns the first parameter
    (if it is non-null), the object produced by the provided supplier function (if
    it is non-null and `supplier.get()` is non-null), throws `NullPointerException` (if
    both parameters are `null` or the first parameter and supplier.get() are `null`),
    for example:'
  id: totrans-381
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T requireNonNullElseGet(T obj, Supplier<T> supplier)`: 返回第一个参数（如果它不是null），由提供的供应商函数产生的对象（如果它不是null且`supplier.get()`不是null），抛出`NullPointerException`（如果两个参数都是`null`或第一个参数和supplier.get()都是`null`），例如：'
- en: '[PRE84]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `hash()` or `hashCode()` method is typically used to override the default `hashCode()` implementation:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hash()`或`hashCode()`方法通常用于覆盖默认的`hashCode()`实现：'
- en: '`int hashCode(Object value)`: Calculates a hash value for a single object,
    for example:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int hashCode(Object value)`: 为单个对象计算哈希值，例如：'
- en: '[PRE85]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`int hash(Object... values)`: Calculates a hash value for an array of objects,
    for example:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int hash(Object... values)`: 为对象数组计算哈希值，例如：'
- en: '[PRE86]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Please note that the `hashCode(Object value)` method returns a different hash
    value (`96354`) than the `Objects.hash(Object... values)` method (`96385`), even
    though they calculate the hash value for the same single object.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hashCode(Object value)`方法返回一个不同的哈希值(`96354`)，而`Objects.hash(Object... values)`方法返回(`96385`)，尽管它们为相同的单个对象计算哈希值。
- en: 'The `isNull()` and `nonNull()` methods are just wrappers around Boolean expressions:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isNull()`和`nonNull()`方法只是布尔表达式的包装器：'
- en: '`boolean isNull(Object obj)`: Returns the same value as `obj == null`, for
    example:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isNull(Object obj)`: 返回与`obj == null`相同的值，例如：'
- en: '[PRE87]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`boolean nonNull(Object obj)`: Returns the same value as `obj != null`, for
    example:'
  id: totrans-392
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean nonNull(Object obj)`: 返回与`obj != null`相同的值，例如：'
- en: '[PRE88]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `equals()` and `deepEquals()` methods allow us to compare two objects by
    their state:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`equals()`和`deepEquals()`方法允许我们通过它们的状态来比较两个对象：'
- en: '`boolean equals(Object a, Object b)`: Compares two objects using the `equals(Object)` method
    and handles the case when one of them or both are `null`, for example:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean equals(Object a, Object b)`: 使用`equals(Object)`方法比较两个对象，并处理它们中的一个或两个为`null`的情况，例如：'
- en: '[PRE89]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the preceding example, `Objects.equals(ints1, ints2)` returns `false` because
    arrays cannot override the `equals()` method of the `Object` class and are compared
    by references, not by value.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Objects.equals(ints1, ints2)`返回`false`，因为数组不能覆盖`Object`类的`equals()`方法，而是通过引用而不是值进行比较。
- en: '`boolean deepEquals(Object a, Object b)`: Compares two arrays by the value
    of their elements, for example:'
  id: totrans-398
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean deepEquals(Object a, Object b)`: 比较两个数组的元素值，例如：'
- en: '[PRE90]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you can see, the `deepEquals()` method returns `true` when the corresponding
    values of the arrays are equal. But if the arrays have different values or a different
    order of the same values, the method returns `false`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`deepEquals()`方法在数组的相应值相等时返回`true`。但是如果数组有不同的值或相同值的不同顺序，该方法将返回`false`：
- en: '[PRE91]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The  `Arrays.equals(Object a, Object b)` and  `Arrays.deepEquals(Object a, Object
    b)` methods behave the same way as the `Objects.equals(Object a, Object b)` and `Objects.deepEquals(Object a, Object
    b)` methods:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrays.equals(Object a, Object b)`和`Arrays.deepEquals(Object a, Object b)`方法的行为与`Objects.equals(Object
    a, Object b)`和`Objects.deepEquals(Object a, Object b)`方法相同：'
- en: '[PRE92]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In fact, the `Arrays.equals(Object a, Object b)` and  `Arrays.deepEquals(Object a, Object
    b)` methods are used in the implementation of the `Objects.equals(Object a, Object
    b)` and `Objects.deepEquals(Object a, Object b)` methods.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Arrays.equals(Object a, Object b)`和`Arrays.deepEquals(Object a, Object
    b)`方法在`Objects.equals(Object a, Object b)`和`Objects.deepEquals(Object a, Object
    b)`方法的实现中被使用。
- en: 'To summarize, if you would like to compare two objects, `a` and `b`, by the
    values of their fields, then:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果你想要比较两个对象`a`和`b`的字段值，那么：
- en: If they are not arrays and `a` is not `null`, use `a.equals(Object b)`
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不是数组且`a`不是`null`，则使用`a.equals(Object b)`
- en: If they are not arrays and each or both objects can be `null`, use `Objects.equals(Object a, Object
    b)`
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不是数组且每个或两个对象都可以是`null`，则使用`Objects.equals(Object a, Object b)`
- en: If both can be arrays and each or both can be `null`, use `Objects.deepEquals(Object a, Object
    b)`
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都可以是数组且每个或两者都可以是`null`，则使用`Objects.deepEquals(Object a, Object b)`
- en: The `Objects.deepEquals(Object a, Object b)` method seems to be the safest one,
    but it does not mean that you must always use it. Most of the time, you will know
    whether the compared objects can be `null` or can be arrays, so you can safely
    use other methods, too.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects.deepEquals(Object a, Object b)`方法似乎是最安全的，但这并不意味着你必须总是使用它。大多数情况下，你会知道比较的对象是否可以是`null`或者可以是数组，因此你也可以安全地使用其他方法。'
