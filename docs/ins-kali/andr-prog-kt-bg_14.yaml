- en: Chapter 14. Android Dialog Windows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。Android对话框窗口
- en: In this chapter, we will learn how to present the user with a pop-up dialog
    window. We can then put all that we know into the first phase of our first multi-chapter
    app, *Note to self*. We will then learn about more Android and Kotlin features
    in this chapter and the four following chapters (up to [Chapter 18](ch18.html
    "Chapter 18. Localization"), *Localization*), and then use our newly acquired
    knowledge to enhance the Note to self app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何向用户呈现弹出式对话框窗口。然后，我们可以将我们所知道的一切放入我们的第一个多章节应用程序*Note to self*的第一阶段。然后，我们将在本章和接下来的四章（直到[第18章](ch18.html
    "第18章。本地化")，*本地化*）中学习更多关于Android和Kotlin的特性，然后使用我们新获得的知识来增强Note to self应用程序。
- en: 'In each chapter, we will also build a selection of smaller apps that are separate
    from this main app. So, what does [Chapter 14](ch14.html "Chapter 14. Android
    Dialog Windows"), *Android Dialog Windows*, hold in store for you? The following
    topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，我们还将构建一系列与主要应用程序分开的较小的应用程序。那么，[第14章](ch14.html "第14章。Android对话框窗口")*Android对话框窗口*对你有什么期待呢？本章将涵盖以下主题：
- en: Implement a simple app with a pop-up dialog box
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个带有弹出式对话框的简单应用程序
- en: Learn how to use `DialogFragment` to begin the Note to self app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`DialogFragment`来开始Note to self应用程序
- en: Start the Note to self app and learn how to add string resources in our projects
    instead of hardcoding text in our layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Note to self应用程序，并学习如何在项目中添加字符串资源，而不是在布局中硬编码文本
- en: Implement more complex dialog boxes to capture input from the user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现更复杂的对话框以捕获用户输入
- en: So, let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Dialog windows
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框窗口
- en: Often in our apps, we will want to show the user some information, or perhaps
    ask for confirmation of an action in a pop-up window. This is known as a **dialog**
    window. If you quickly scan the palette in Android Studio, you might be surprised
    to see no mention of dialog windows whatsoever.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们经常会想要向用户显示一些信息，或者询问是否确认弹出窗口中的操作。这就是所谓的**对话框**窗口。如果你快速浏览一下Android
    Studio的调色板，你可能会惊讶地发现根本没有提到对话框窗口。
- en: Dialog windows in Android are more advanced than a simple widget or even a whole
    layout. They are classes that can also have layouts and other UI elements of their
    own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的对话框窗口比简单的小部件甚至整个布局更高级。它们是可以拥有自己的布局和其他UI元素的类。
- en: The best way to create a dialog window in Android is to use the `DialogFragment`
    class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中创建对话框窗口的最佳方式是使用`DialogFragment`类。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Fragments are an extensive and vital topic in Android, and we will spend much
    of the second half of this book exploring and using them. Creating a neat pop-up
    dialog (using `DialogFragment`) for our user to interact with is, however, a great
    introduction to fragments and is not complicated at all.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 片段在Android中是一个广泛而重要的主题，我们将在本书的后半部分花费大量时间来探索和使用它们。然而，为我们的用户创建一个整洁的弹出式对话框（使用`DialogFragment`）是对片段的一个很好的介绍，并且一点也不复杂。
- en: Creating the dialog demo project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对话框演示项目
- en: We previously mentioned that the best way to create a dialog window in Android
    is with the `DialogFragment` class. However, there is another way to create dialogs
    in Android that is arguably a little bit simpler. The problem with this simpler
    `Dialog` class is that it is not very well supported in the Activity lifecycle.
    It is even possible that using `Dialog` could accidentally crash the app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，在Android中创建对话框窗口的最佳方式是使用`DialogFragment`类。然而，在Android中创建对话框的另一种方式可能会更简单一些。这种更简单的`Dialog`类的问题在于它在Activity生命周期中的支持不是很好。甚至可能会导致应用程序意外崩溃。
- en: If you were writing an app with one fixed orientation layout that only needed
    one simple pop-up dialog, it could be argued that the simpler `Dialog` class should
    be used. But, as we are aiming to build modern, professional apps with advanced
    features, we will benefit from ignoring this class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个只需要一个简单弹出式对话框的固定方向布局的应用程序，可以说应该使用更简单的`Dialog`类。但是，由于我们的目标是构建具有先进功能的现代专业应用程序，因此忽略这个类将会使我们受益匪浅。
- en: Create a new project in Android Studio using the **Empty Activity** project
    template and call it `Dialog Demo`. The completed code for this project is in
    the `Chapter14/Dialog Demo` folder of the download bundle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中使用**空活动**项目模板创建一个名为`Dialog Demo`的新项目。该项目的完成代码位于下载包的`Chapter14/Dialog
    Demo`文件夹中。
- en: Coding a DialogFragment class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写DialogFragment类
- en: Create a new class in Android Studio by right-clicking on the folder with the
    name of your package (the one that has the `MainActivity.kt` file). Select **New**
    | **Kotlin File/class**, name it `MyDialog`, and choose **Class** in the drop-down
    selector. Left-click on **OK** to create the class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含`MainActivity.kt`文件的包名称的文件夹，在Android Studio中创建一个新的类。选择**新建** | **Kotlin文件/类**，命名为`MyDialog`，并在下拉选择器中选择**类**。单击**确定**以创建类。
- en: 'The first thing you need to do is to change the class declaration to inherit
    from `DialogFragment`. Also, let''s add all the imports we will need in this class.
    When you have done so, your new class will look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是将类声明更改为继承自`DialogFragment`。此外，让我们添加在这个类中需要的所有导入。当你这样做后，你的新类将如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's add code to this class a bit at a time and explain what is happening
    at each step.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一点一点地向这个类添加代码，并解释每一步发生了什么。
- en: As with so many classes in the Android API, `DialogFragment` provides us with
    functions that we can override to interact with the different events that will
    occur with the class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android API中的许多类一样，`DialogFragment`为我们提供了可以重写以与类中发生的不同事件交互的函数。
- en: 'Add the following highlighted code that overrides the `onCreateDialog` function.
    Study it carefully, and then we will examine what is happening:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 添加覆盖`onCreateDialog`函数的以下突出显示的代码。仔细研究它，然后我们将检查发生了什么：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is one error in the code because we are missing the return statement,
    which needs to return an object of type `Dialog`. We will add this when we have
    finished coding the rest of the function shortly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有一个错误，因为我们缺少返回语句，需要返回一个`Dialog`类型的对象。我们将在完成函数的其余部分编码后添加这个返回语句。
- en: In the code that we just added, we first add the overridden `onCreateDialog`
    function, which will be called by Android when we later show the dialog with code
    from the `MainActivity` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中，我们首先添加了重写的`onCreateDialog`函数，当我们稍后使用`MainActivity`类的代码显示对话框时，Android将调用它。
- en: Then, inside the `onCreateDialog` function, we get our hands on an instance
    of a new class. We declare and initialize an object of the `AlertDialog.Builder`
    type that needs a reference to the `MainActivity` class to be passed into its
    constructor. This is why we use `activity!!` as the argument; and we are asserting
    that the instance is not null (!!).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onCreateDialog`函数内部，我们得到了一个新类的实例。我们声明并初始化了一个`AlertDialog.Builder`类型的对象，它需要一个对`MainActivity`类的引用传递给它的构造函数。这就是为什么我们使用`activity!!`作为参数；我们断言该实例不为空（!!）。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Refer to [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to the UI
    and Nullability"), *Connecting Our Kotlin to the UI and Nullability*, for a refresher
    on the not null assertion (`!!`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")，“将我们的Kotlin连接到UI和可空性”，了解非空断言（!!）的用法。
- en: The `activity` property is part of the `Fragment` class (and, therefore, `DialogFragment`
    too) and it is a reference to the `Activity` class instance that will create the
    `DialogFragment` instance. In this case, this is our `MainActivity` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity`属性是`Fragment`类（因此也是`DialogFragment`）的一部分，它是一个对将创建`DialogFragment`实例的`Activity`类实例的引用。在这种情况下，这是我们的`MainActivity`类。'
- en: Let's take a look at what we can do with `builder` now that we have declared
    and initialized it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明并初始化了`builder`，让我们看看我们可以用它做什么。
- en: Using chaining to configure the DialogFragment class
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用链接来配置DialogFragment类
- en: Now we can use our `builder` object to do the rest of the work. There is something
    slightly odd in the next three blocks of code. If you look ahead and quickly scan
    them, you will notice that there are three uses of the dot operator, but only
    one usage is actually placed next to the `builder` object. This shows that these
    three apparent blocks of code are, in fact, just one line to the compiler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的`builder`对象来完成其余的工作。在接下来的三个代码块中有一些略微奇怪的地方。如果你往前看并快速扫描它们，你会注意到有三次使用了点运算符，但只有一次使用是实际放在`builder`对象旁边的。这表明这三个明显的代码块实际上只是编译器的一行代码。
- en: We have seen what is going on here before, but in a less pronounced situation.
    When we create a `Toast` message and add a `.show()` call on to the end of it,
    we are **chaining**. That is, we are calling more than one function, in sequence,
    on the same object. This is equivalent to writing multiple lines of code; it is
    just clearer and shorter this way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过这里发生的事情，但情况没有那么明显。当我们创建一个`Toast`消息并在其末尾添加`.show()`调用时，我们正在**链接**。也就是说，我们在同一个对象上按顺序调用多个函数。这相当于编写多行代码；只是这样更清晰、更简洁。
- en: 'Add this code, which utilizes chaining, right after the previous code that
    we added in `onCreateDialog`, examine it, and then we will discuss it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateDialog`中添加这段代码，它利用了链接，然后我们将讨论它：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each of the three parts of code that we added can be explained as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的代码的三个部分可以解释如下：
- en: In the first of the three blocks that uses chaining, we call `builder.setMessage`,
    which sets the main message that the user will see in the dialog box. Also, note
    that it is fine to have comments in between parts of the chained function calls,
    as these are ignored entirely by the compiler.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用链接的三个代码块中的第一个中，我们调用`builder.setMessage`，它设置用户在对话框中看到的主要消息。另外，需要注意的是，在链接函数调用的不同部分之间添加注释是可以的，因为编译器完全忽略这些注释。
- en: Then, we add a button to our dialog with the `setPositiveButton` function and
    the first argument sets the text on it to `OK`. The second argument is a lambda
    that implements `DialogInterface.OnClickListener` that handles clicks on the button.
    Notice that we are not going to add any code to the `onClick` function, but we
    could, just as we did in the previous chapter. We just want to see this simple
    dialog and we will take things a step further in the next project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`setPositiveButton`函数向对话框添加一个按钮，第一个参数将其文本设置为“OK”。第二个参数是一个实现`DialogInterface.OnClickListener`的lambda，用于处理按钮的点击。请注意，我们不会在`onClick`函数中添加任何代码，但我们可以，就像我们在上一章中所做的那样。我们只是想看到这个简单的对话框，我们将在下一个项目中进一步进行。
- en: Next, we call yet another function on the same `builder` object. This time,
    it's the `setNegativeButton` function. Again, the two arguments set `Cancel` as
    the text for the button and a lambda is used to set up listening for clicks. Again,
    for the purposes of this demo, we are not taking any action in the overridden
    `onClick` function.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在同一个`builder`对象上调用另一个函数。这次是`setNegativeButton`函数。同样，两个参数将“Cancel”设置为按钮的文本，使用lambda来设置监听点击。同样，为了这个演示的目的，我们不会在重写的`onClick`函数中执行任何操作。
- en: 'Next, we will code the `return` statement to complete the function and remove
    the error. Add the `return` statement to the end (but keep it inside the final
    curly brace) of the `onCreateDialog` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`return`语句以完成函数并移除错误。在`onCreateDialog`函数的最后（但保持在最终大括号内部）添加`return`语句：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This last line of code has the effect of returning to `MainActivity` (which
    will call `onCreateDialog` in the first place) our new, fully configured, dialog
    window. We will see and add this calling code quite soon.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码的最后效果是将我们新的、完全配置好的对话框窗口返回给`MainActivity`（它首先会调用`onCreateDialog`）。我们很快将看到并添加这个调用代码。
- en: Now that we have our `MyDialog` class that inherits from `FragmentDialog`, all
    we have to do is to declare an instance of `MyDialog`, instantiate it, and call
    its overridden `onCreateDialog` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了从`FragmentDialog`继承的`MyDialog`类，我们所要做的就是声明`MyDialog`的一个实例，实例化它，并调用它重写的`onCreateDialog`函数。
- en: Using the DialogFragment class
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DialogFragment类
- en: 'Before we turn to the code, let''s add a button to our layout, by observing
    the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向代码之前，让我们通过以下步骤向我们的布局添加一个按钮：
- en: Switch to the `activity_main.xml` tab, and then switch to the **Design** tab.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`activity_main.xml`选项卡，然后切换到**Design**选项卡。
- en: Drag a **Button** widget onto the layout and make sure its `id` attribute is
    set to `button`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Button**小部件拖放到布局中，并确保其`id`属性设置为`button`。
- en: Click the **Infer Constraints** button to constrain the button exactly where
    you place it, but the position isn't important; how we will use it to create an
    instance of our `MyDialog` class is the key lesson.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**推断约束**按钮，将按钮约束到您放置的位置，但位置并不重要；我们将如何使用它来创建我们的`MyDialog`类的实例是关键的教训。
- en: Now switch to the `MainActivity.kt` tab and we will handle a click on this new
    button by using a lambda as we did in [Chapter 13](ch13.html "Chapter 13. Bringing
    Android Widgets to Life"), *Bringing Android Widgets to Life* during the Widget
    exploration app. We do it this way as we only have one button in the layout, and
    it seems sensible and more compact than doing the alternative (that is, implementing
    the `OnClickListener` interface and then overriding `onClick` for the entire `MainActivity`
    class as we did in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to
    the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到`MainActivity.kt`选项卡，我们将使用lambda来处理新按钮的点击，就像我们在[第13章](ch13.html "第13章。将Android小部件带到生活中")中所做的那样，在Widget探索应用程序中。我们这样做是因为布局中只有一个按钮，这种方式似乎比另一种方式更明智和更紧凑（即实现`OnClickListener`接口，然后在整个`MainActivity`类中重写`onClick`，就像我们在[第12章](ch12.html
    "第12章。将我们的Kotlin连接到UI和可空性")中所做的那样，*将我们的Kotlin连接到UI和可空性*）。
- en: 'Add the following code to the `onCreate` function of `MainActivity` after the
    call to `setContentView`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`onCreate`函数中添加以下代码，放在`setContentView`调用之后：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following `import` statement is needed for this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以下`import`语句来支持此代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the only thing that happens in the code is that the `setOnClickListener`
    lambda overrides `onClick`. This means that when the button is pressed, a new
    instance of `MyDialog` is created and calls its `show` function, which will show
    our dialog window just as we configured it in the `MyDialog` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中唯一发生的事情是`setOnClickListener` lambda覆盖了`onClick`。这意味着当按钮被按下时，将创建`MyDialog`的一个新实例并调用其`show`函数，该函数将显示我们在`MyDialog`类中配置的对话框窗口。
- en: The `show` function needs a reference to `FragmentManager`, which we get from
    the `supportFragmentManager` property. This is the class that tracks and controls
    all fragment instances for an `Activity` instance. We also pass in an ID (`"123"`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`函数需要一个对`FragmentManager`的引用，我们从`supportFragmentManager`属性中获取。这是跟踪和控制`Activity`实例的所有片段实例的类。我们还传入一个ID（`"123"`）。'
- en: More details on `FragmentManager` will be revealed when we look more deeply
    at fragments, starting in [Chapter 24,](ch24.html "Chapter 24. Design Patterns,
    Multiple Layouts, and Fragments") *Design Patterns, Multiple Layouts, and Fragments*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`FragmentManager`的细节将在我们更深入地研究片段时揭示，从[第24章](ch24.html "第24章。设计模式、多个布局和片段")开始，*设计模式、多个布局和片段*。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason we use the `supportFragmentManager` property is because we are supporting
    older devices by extending `AppCompatActivity`. If we simply extended `Activity`,
    then we could use the `fragmentManager` property. The downside is that the app
    won't run on many older devices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`supportFragmentManager`属性的原因是因为我们通过扩展`AppCompatActivity`来支持旧设备。如果我们简单地扩展`Activity`，那么我们可以使用`fragmentManager`属性。缺点是该应用程序将无法在许多旧设备上运行。
- en: 'Now we can run the app and admire our new dialog window that appears when we
    click the button in the layout. Notice that clicking either of the buttons in
    the dialog window will close it; this is the default behavior. The following screenshot
    shows our dialog window in action on the tablet emulator:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序，并欣赏我们点击布局中的按钮时出现的新对话框窗口。请注意，单击对话框窗口中的任一按钮都将关闭它；这是默认行为。以下屏幕截图显示了我们的对话框窗口在平板模拟器上的运行情况：
- en: '![Using the DialogFragment class](img/B12806_14_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用DialogFragment类](img/B12806_14_01.jpg)'
- en: Next, we will make two more classes that implement dialogs as the first phase
    of our multi-chapter Note to self app. We will see that a dialog window can have
    almost any layout we choose, and that we don't have to rely on the simple layouts
    that the `Dialog.Builder` class provided us with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将制作另外两个实现对话框的类，作为我们多章节备忘录应用程序的第一阶段。我们将看到对话框窗口几乎可以有我们选择的任何布局，并且我们不必依赖`Dialog.Builder`类提供给我们的简单布局。
- en: The Note to self app
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录应用程序
- en: Welcome to the first of the multi-chapter apps that we will implement in this
    book. When we do these projects, we will do them more professionally than we do
    the smaller apps. In this project, we will use String resources instead of hardcoding
    the text in the layouts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书中我们将实现的多章应用程序中的第一个。在做这些项目时，我们将比做较小的应用程序更专业。在这个项目中，我们将使用字符串资源而不是在布局中硬编码文本。
- en: Sometimes, these things can be overkill when you are trying to learn a new Android
    or Kotlin topic, but they are useful and important to start using as soon as possible
    in real projects. They soon become like second nature and the quality of our apps
    will benefit from it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当您尝试学习新的Android或Kotlin主题时，这些东西可能会过度，但它们对于尽快在真实项目中开始使用是有用且重要的。它们很快就会变得像第二天性一样，我们的应用程序质量将受益于此。
- en: Using String resources
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符串资源
- en: In [Chapter 3,](ch03.html "Chapter 3. Exploring Android Studio and the Project
    Structure") *Exploring Android Studio and the Project Structure*, we discussed
    using String resources instead of hardcoding text in our layout files. There were
    a few benefits of doing things this way, but it was also slightly long-winded.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。探索Android Studio和项目结构")*探索Android Studio和项目结构*中，我们讨论了在布局文件中使用字符串资源而不是硬编码文本。这样做有一些好处，但也稍微冗长。
- en: As this is our first multi-chapter project, it is a good time to do things the
    right way. If you want a quick refresher on the benefits of String resources,
    refer back to [Chapter 3,](ch03.html "Chapter 3. Exploring Android Studio and
    the Project Structure") *Exploring Android Studio and the Project Structure*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们的第一个多章节项目，现在是做正确的时候。如果您想快速了解字符串资源的好处，请参阅[第3章](ch03.html "第3章。探索Android
    Studio和项目结构")*探索Android Studio和项目结构*。
- en: How to get the code files for the Note to self app
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何获取Note to self应用程序的代码文件
- en: 'The fully-completed app, including all the code and resources, can be found
    in the `Chapter18/Note to self` folder within the download bundle. As we are implementing
    this app over the next five chapters, it will be useful to see the part-completed,
    runnable app at the end of every chapter as well. The part-completed, runnable
    apps and all their associated code and resources can be found in their respective
    folders:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完全完成的应用程序，包括所有的代码和资源，可以在下载包的`Chapter18/Note to self`文件夹中找到。由于我们将在接下来的五章中实施这个应用程序，因此在每一章结束时查看部分完成的可运行应用程序也是有用的。部分完成的可运行应用程序及其所有相关的代码和资源可以在各自的文件夹中找到：
- en: '`Chapter14/Note to self`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter14/Note to self`'
- en: '`Chapter16/Note to self`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter16/Note to self`'
- en: '`Chapter17/Note to self`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter17/Note to self`'
- en: '`Chapter18/Note to self`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter18/Note to self`'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no Note to self code in [Chapter 15](ch15.html "Chapter 15. Handling
    Data and Generating Random Numbers"), *Handling Data and Generating Random Numbers*,
    because although we will learn about topics we use in Note to self, we don't make
    the changes to the app until [Chapter 16](ch16.html "Chapter 16. Adapters and
    Recyclers"), *Adapters and Recyclers*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.html "第15章。处理数据和生成随机数")*处理数据和生成随机数*中没有Note to self的代码，因为虽然我们会学习一些在Note
    to self中使用的主题，但直到[第16章](ch16.html "第16章。适配器和回收器")*适配器和回收器*，我们才对应用程序进行更改。
- en: Be aware that each of these folders contains a separate, runnable project, and
    is also contained within its own unique package. This is so that you can easily
    see the app running as it would do after completing a given chapter. When copying
    and pasting the code, be careful not to include the package name because it will
    likely be different from your package name and cause the code not to compile.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个文件夹都包含一个独立的可运行项目，并且也包含在自己独特的包中。这样你就可以很容易地看到应用程序在完成给定章节后的运行情况。在复制和粘贴代码时，要小心不要包括包名称，因为它可能与您的包名称不同，导致代码无法编译。
- en: If you are following along and intend to build Note to self from start to finish,
    we will build a project simply called `Note to self`. There is still nothing stopping
    you, however, from dipping into the code files of the projects from each chapter
    to do a bit of copying and pasting at any time. Just don't copy the package directive
    from the top of a file. Additionally, be aware that at a couple of points in the
    instructions, you will be asked to remove or replace the occasional line of code
    from a previous chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在跟着做，并打算从头到尾构建Note to self，我们将简单地构建一个名为`Note to self`的项目。然而，您仍然可以随时查看每个章节的项目文件中的代码，进行一些复制和粘贴。只是不要复制文件顶部的包指令。另外，请注意，在说明书的几个地方，您将被要求删除或替换前几章的偶尔一行代码。
- en: So, even if you are copying and pasting more than you are typing the code, be
    sure to read the instructions in full and look at the code in the book for extra
    comments that might be useful.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使您复制和粘贴的次数多于输入代码的次数，请务必完整阅读说明，并查看书中的代码，以获取可能有用的额外注释。
- en: In each chapter, the code will be presented as if you have completed the last
    chapter in full, showing code from earlier chapters, where necessary, as context
    for the new code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，代码将被呈现为如果您已经完全完成上一章，将显示来自早期章节的代码，必要时作为新代码的上下文。
- en: Each chapter will not be solely devoted to the Note to self app. We will learn
    about other related things and build some smaller and simpler apps as well. So,
    when we come to the Note to self implementation, we will be technically prepared
    for it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都不会完全致力于Note to self应用程序。我们还将学习其他相关内容，并构建一些更小更简单的应用程序。因此，当我们开始实施Note to self时，我们将在技术上做好准备。
- en: The completed app
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成的应用程序
- en: The following features and screenshots are from the completed app. It will obviously
    look slightly different to this at the various stages of development. Where necessary,
    we will look at more images, either as a reminder, or to see the differences throughout
    the development process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能和屏幕截图来自完成的应用程序。在开发的各个阶段，它显然会略有不同。必要时，我们将查看更多图像，作为提醒，或者查看开发过程中的差异。
- en: 'The completed app will allow the user to tap thefloating button icon in the
    bottom-right corner of the app to open a dialog window to add a new note. The
    following screenshot shows this highlighted feature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的应用程序将允许用户点击应用程序右下角的浮动按钮图标，打开一个对话框窗口以添加新的便签。以下屏幕截图显示了这个突出的功能：
- en: '![The completed app](img/B12806_14_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![完成的应用程序](img/B12806_14_02.jpg)'
- en: The screenshot on the left shows the button to tap, and the screenshot on the
    right shows the dialog window where the user can add a new note.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的屏幕截图显示了要点击的按钮，右侧的屏幕截图显示了用户可以添加新便签的对话框窗口。
- en: 'Eventually, as the user adds more notes, they will have a list of all the notes
    they have added on the main screen of the app, as shown in the following screenshot.
    The user can select whether the note is **Important**, an **Idea**, and/or a **To
    do** note:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，随着用户添加更多的笔记，他们将在应用程序的主屏幕上拥有所有已添加的笔记列表，如下截图所示。用户可以选择笔记是**重要**、**想法**和/或**待办事项**笔记：
- en: '![The completed app](img/B12806_14_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![完成的应用程序](img/B12806_14_04.jpg)'
- en: 'They will be able to scroll the list and tap on a note to see it shown in another
    dialog window dedicated to that note. Here is that dialog window showing a note:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将能够滚动列表并点击一个笔记，以在专门用于该笔记的另一个对话框窗口中查看它。以下是显示笔记的对话框窗口：
- en: '![The completed app](img/B12806_14_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![完成的应用程序](img/B12806_14_05.jpg)'
- en: 'There will also be a simple (very simple) settings screen that is accessible
    from the menu that will allow the user to configure whether the note list is formatted
    with a dividing line. Here is the settings menu option in action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还将有一个非常简单的设置屏幕，可以从菜单中访问，允许用户配置笔记列表是否以分隔线格式化。以下是设置菜单选项的操作：
- en: '![The completed app](img/B12806_14_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![完成的应用程序](img/B12806_14_06.jpg)'
- en: Now we know exactly what we are going to build, we can go ahead and start to
    implement it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确切地知道我们要构建什么，我们可以继续并开始实施它。
- en: Building the project
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: Let's create our new project now. Call the project `Note to Self` and use the
    **Basic Activity** template. Remember from [Chapter 3,](ch03.html "Chapter 3. Exploring
    Android Studio and the Project Structure") *Exploring Android Studio and the Project
    Structure,* that this template will generate a simple menu and a floating action
    button, which are both used in this project. Leave the other settings at their
    default settings.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的新项目。将项目命名为`Note to Self`，并使用**Basic Activity**模板。请记住，从[第3章](ch03.html
    "第3章。探索Android Studio和项目结构")*探索Android Studio和项目结构*中得知，此模板将生成一个简单的菜单和一个浮动操作按钮，这两者都在此项目中使用。将其他设置保留为默认设置。
- en: Preparing the String resources
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备字符串资源
- en: Here, we will create all the String resources that we will refer to from our
    layout files instead of hardcoding the `text` property, as we have been doing
    up until now. Strictly speaking, this is a step that can be avoided. However,
    if you are looking to make in-depth Android apps, you will benefit from learning
    to do things this way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建所有的字符串资源，我们将从布局文件中引用这些资源，而不是硬编码`text`属性，就像我们一直在做的那样。严格来说，这是一个可以避免的步骤。但是，如果您想要制作深入的Android应用程序，学会以这种方式做事情将使您受益匪浅。
- en: 'To get started, open the `strings.xml` file from the `res/values` folder in
    the project explorer. You will see the autogenerated resources. Add the following
    highlighted String resources that we will use in our app throughout the rest of
    the project. Add the code before the closing `</resources>` tag:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在项目资源管理器中的`res/values`文件夹中打开`strings.xml`文件。您将看到自动生成的资源。添加我们将在整个项目的其余部分中使用的以下突出显示的字符串资源。在关闭`</resources>`标签之前添加以下代码：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Observe in the preceding code that each String resource has a `name` attribute
    that is unique and distinguishes it from all the others. The `name` attribute
    also provides a meaningful and, hopefully, memorable clue as to the actual String
    value it represents. It is these name values that we will use to refer to the
    String that we want to use from within our layout files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在上述代码中，每个字符串资源都有一个唯一的`name`属性，用于将其与所有其他字符串资源区分开。`name`属性还提供了一个有意义的，并且希望是记忆深刻的线索，表明它代表的实际字符串值。正是这些名称值，我们将用来从我们的布局文件中引用我们想要使用的字符串。
- en: Coding the Note class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Note类
- en: This is the fundamental data structure of the app. It is a class we will write
    ourselves from scratch and it has all the properties that we need to represent
    a single user note. In [Chapter 15,](ch15.html "Chapter 15. Handling Data and
    Generating Random Numbers") *Handling Data and Generating Random Numbers,* we
    will learn some new Kotlin code to gain an understanding of how we can let the
    user have dozens, hundreds, or even thousands of notes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的基本数据结构。这是一个我们将从头开始编写的类，它具有表示单个用户笔记所需的所有属性。在[第15章](ch15.html "第15章。处理数据和生成随机数")*处理数据和生成随机数*中，我们将学习一些新的Kotlin代码，以了解如何让用户拥有数十、数百甚至数千条笔记。
- en: Create a new class by right-clicking on the folder with the name as your package
    – as usual, the one that contains the `MainActivity.kt` file. Select **New** |
    **Kotlin File/class**, name it `Note`, and select **Class** from the drop-down
    selector. Left-click on **OK** to create the class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含`MainActivity.kt`文件的文件夹来创建一个新类 - 通常是包含`MainActivity.kt`文件的文件夹。选择**New**
    | **Kotlin File/class**，命名为`Note`，并从下拉选择器中选择**Class**。单击**OK**创建类。
- en: 'Add the following code to the new `Note` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到新的`Note`类中：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have a simple class with no functions, called `Note`. The class has five
    `var` properties called `title`, `description`, `idea`, `todo`, and `important`.
    Their uses are to hold the title of the user's note, the description (or contents)
    of the note, and to detail whether the note is an idea, a to-do, or an important
    note, respectively. Let's now design the layout of the two dialog windows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的类，没有函数，叫做`Note`。这个类有五个`var`属性，分别叫做`title`、`description`、`idea`、`todo`和`important`。它们的用途是保存用户笔记的标题、笔记的描述（或内容），以及详细说明笔记是一个想法、一个待办事项，还是一个重要的笔记。现在让我们设计两个对话框窗口的布局。
- en: Implementing the dialog designs
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现对话框设计
- en: Now we will do something that we have done many times before, but this time,
    for a different reason. As you know, we will have two dialog windows – one for
    the user to enter a new note, and one for the user to view a note of their choice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将做一些我们以前做过很多次的事情，但这次是出于不同的原因。正如你所知，我们将有两个对话框窗口 - 一个用于用户输入新的笔记，另一个用于用户查看他们选择的笔记。
- en: We can design the layouts of these two dialog windows in the same way that we
    have designed all our previous layouts. When we come to create the Kotlin code
    for the `FragmentDialog` classes, we will then learn how to incorporate these
    layouts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与之前所有布局相同的方式设计这两个对话框窗口的布局。当我们开始为`FragmentDialog`类创建Kotlin代码时，我们将学习如何将这些布局结合起来。
- en: 'First, let''s add a layout for our "new note" dialog by following these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照以下步骤为我们的“新笔记”对话框添加布局：
- en: Right-click on the `layout` folder in the project explorer and select **New**
    | **Layout resource file**. Enter `dialog_new_note` in the **File name:** field
    and then start typing `Constrai` for the **Root element:** field. Notice that
    there is a drop-down list with multiple options that start with **Constrai…**.
    Now select **androidx.constraintlayout.widget.ConstraintLayout**. Left-click on
    **OK** to generate the new layout file that will have the `ConstraintLayout` type
    as its root element.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中右键单击`layout`文件夹，选择**新建** | **布局资源文件**。在**文件名：**字段中输入`dialog_new_note`，然后开始输入`Constrai`以填写**根元素：**字段。注意到有一个下拉列表，其中有多个以**Constrai…**开头的选项。现在选择**androidx.constraintlayout.widget.ConstraintLayout**。左键单击**确定**生成新的布局文件，其根元素类型为`ConstraintLayout`。
- en: Refer to the target design in the following screenshot while following the rest
    of these instructions. I have photoshopped together the finished layout, including
    the constraints that we will soon autogenerate, next to the layout, with the constraints
    hidden for extra clarity:![Implementing the dialog designs](img/B12806_14_08.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按照以下说明的同时，参考下面的屏幕截图中的目标设计。我已经使用Photoshop将完成的布局和我们即将自动生成的约束条件放在一起，约束条件被隐藏以增加清晰度：![实现对话框设计](img/B12806_14_08.jpg)
- en: Drag and drop a **Plain Text** widget (from the **Text** category) to the very
    top and left of the layout, and then add another **Plain Text** below it. Don't
    worry about any of the attributes for now.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文本**类别中拖放一个**纯文本**小部件到布局的最上方和最左边，然后再添加另一个**纯文本**。现在不用担心任何属性。
- en: Drag and drop three **CheckBox** widgets from the **Button** category, one below
    the other. Look at the previous reference screenshot for guidance. Again, don't
    worry about any attributes for now.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**按钮**类别中拖放三个**复选框**小部件，依次放置。查看之前的参考屏幕截图以获得指导。同样，现在不用担心任何属性。
- en: Drag and drop two **Buttons** onto the layout, the first directly below the
    last **CheckBox** widget from the previous step, and the second horizontally in
    line with the first **Button** widget, but fully over to the right of the layout.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一步中的最后一个**复选框**小部件直接下方拖放两个**按钮**到布局中，然后将第二个**按钮**水平放置，与第一个**按钮**对齐，但完全位于布局的右侧。
- en: Tidy up the layout so that it resembles the reference screenshot as closely
    as possible, and then click on the **Infer Constraints** button to fix the positions
    that you have chosen.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理布局，使其尽可能地与参考屏幕截图相似，然后点击**推断约束条件**按钮来修复您选择的位置。
- en: Now we can set up all our `text`, `id`, and `hint` properties. You can do so
    by using the values from this next table. Remember that we are using our String
    resources for the `text` and `hint` properties.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以设置所有的`text`、`id`和`hint`属性。您可以使用下表中的值来设置。请记住，我们在`text`和`hint`属性中使用了我们的字符串资源。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you edit the first `id` property, you may be shown a pop-up window asking
    for confirmation of your changes. Check the box for **Don''t ask again during
    this session** and click on **Yes** to continue, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编辑第一个`id`属性时，可能会弹出一个窗口询问您是否确认更改。勾选**本次会话期间不再询问**并点击**是**继续，如下屏幕截图所示：
- en: '![Implementing the dialog designs](img/B12806_14_15.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![实现对话框设计](img/B12806_14_15.jpg)'
- en: 'Here are the values to enter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要输入的值：
- en: '| **Widget type** | **Property** | **Value to set to** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **小部件类型** | **属性** | **要设置的值** |'
- en: '| --- | --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Plain Text (top) | id | `editTitle` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本（顶部） | id | `editTitle` |'
- en: '| Plain Text (top) | hint | `@string/title_hint` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本（顶部） | 提示 | `@string/title_hint` |'
- en: '| Plain Text (bottom) | id | `editDescription` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本（底部） | id | `editDescription` |'
- en: '| Plain Text (bottom) | hint | `@string/description_hint` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本（底部） | 提示 | `@string/description_hint` |'
- en: '| Plain Text (bottom) | inputType | textMultiLine (uncheck any other options)
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 纯文本（底部） | 输入类型 | textMultiLine（取消其他选项） |'
- en: '| CheckBox (top) | id | `checkBoxIdea` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（顶部） | id | `checkBoxIdea` |'
- en: '| CheckBox (top) | text | `@string/idea_text` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（顶部） | 文本 | `@string/idea_text` |'
- en: '| CheckBox (middle) | id | `checkBoxTodo` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（中部） | id | `checkBoxTodo` |'
- en: '| CheckBox (middle) | text | `@string/todo_text` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（中部） | 文本 | `@string/todo_text` |'
- en: '| CheckBox (bottom) | id | `checkBoxImportant` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（底部） | id | `checkBoxImportant` |'
- en: '| CheckBox (bottom) | text | `@string/important_text` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 复选框（底部） | 文本 | `@string/important_text` |'
- en: '| Button (left) | id | `btnCancel` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 按钮（左侧） | id | `btnCancel` |'
- en: '| Button (left) | text | `@string/cancel_button` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 按钮（左侧） | 文本 | `@string/cancel_button` |'
- en: '| Button (right) | id | `btnOK` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 按钮（右侧） | id | `btnOK` |'
- en: '| Button (right) | text | `@string/ok_button` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 按钮（右侧） | 文本 | `@string/ok_button` |'
- en: We now have a nice neat layout ready for our Kotlin code to display. Be sure
    to keep in mind the `id` value of the different widgets because we will see them
    in action when we write our code. The important thing is that our layout looks
    nice and has an `id` value for every relevant item, so that we can get a reference
    to it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个整洁的布局，准备好显示我们的Kotlin代码。请记住不同小部件的`id`值，因为当我们编写代码时，我们将看到它们的作用。重要的是，我们的布局看起来漂亮，并且每个相关项目都有一个`id`值，这样我们就可以引用它。
- en: 'Let''s lay out our dialog box to show a note to the user:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们布置对话框，向用户显示一个提示：
- en: Right-click on the **layout** folder in the project explorer and select **New
    | Layout resource file**. Enter `dialog_show_note` for the **File name:** field,
    and then start typing `Constrai` for the **Root element:** field. Notice that
    there is a drop-down list with multiple options that start with **Constrai…**.
    Now select **androidx.constraintlayout.widget.ConstraintLayout**. Left-click on
    **OK** to generate the new layout file that will have the `ConstraintLayout` type
    as its root element.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中右键单击**布局**文件夹，然后选择**新建|布局资源文件**。在**文件名：**字段中输入`dialog_show_note`，然后开始输入`Constrai`以获取**根元素：**字段。注意到有一个下拉列表，其中有多个以**Constrai…**开头的选项。现在选择**androidx.constraintlayout.widget.ConstraintLayout**。单击**确定**生成具有`ConstraintLayout`类型作为其根元素的新布局文件。
- en: Refer to the target design in the next screenshot, while following the rest
    of these instructions. I have photoshopped together the finished layout including
    the constraints we will soon autogenerate, next to the layout, with the constraints
    hidden for extra clarity:![Implementing the dialog designs](img/B12806_14_09.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考下一个截图中的目标设计，同时按照这些说明的其余部分进行操作。我已经使用Photoshop将包括我们即将自动生成的约束的完成布局与布局放在一起，并隐藏了约束以获得额外的清晰度：![实现对话框设计](img/B12806_14_09.jpg)
- en: First, drag and drop three **TextView** widgets, vertically aligned across the
    top of the layout.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在布局的顶部垂直对齐拖放三个**TextView**小部件。
- en: Next, drag and drop another **TextView** widget just below the center of the
    three previous `TextView` widgets.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在前三个`TextView`小部件的中心下方拖放另一个**TextView**小部件。
- en: Add another **TextView** widget just below the previous one, but on the left
    side.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个下方的左侧添加另一个**TextView**小部件。
- en: Now add a **Button** horizontally and centrally, and near the bottom of the
    layout. This is what it should look like so far:![Implementing the dialog designs](img/B12806_14_10.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在布局的底部水平居中位置添加一个**Button**。到目前为止，它应该是这个样子：![实现对话框设计](img/B12806_14_10.jpg)
- en: Tidy up the layout so that it resembles the reference screenshot as closely
    as possible, and then click on the **Infer Constraints** button to fix the positions
    that you have chosen.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整理布局，使其尽可能地与参考截图相似，然后单击**推断约束**按钮以修复您选择的位置。
- en: 'Configure the attributes from the following table:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下表中配置属性：
- en: '| **Widget type** | **Attribute** | **Value to set to** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **小部件类型** | **属性** | **要设置的值** |'
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| TextView (top-left) | `id` | `textViewImportant` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| TextView（左上角） | `id` | `textViewImportant` |'
- en: '| TextView (top-left) | `text` | `@string/important_text` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| TextView（左上角） | `text` | `@string/important_text` |'
- en: '| TextView (top-center) | `id` | `textViewTodo` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部中心） | `id` | `textViewTodo` |'
- en: '| TextView (top-center) | `text` | `@string/todo_text` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部中心） | `text` | `@string/todo_text` |'
- en: '| TextView (top-right) | `id` | `textViewIdea` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| TextView（右上角） | `id` | `textViewIdea` |'
- en: '| TextView (top-right) | `text` | `@string/idea_text` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| TextView（右上角） | `text` | `@string/idea_text` |'
- en: '| TextView (center, second row) | `id` | `txtTitle` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| TextView（中心，第二行） | `id` | `txtTitle` |'
- en: '| TextView (center, second row) | `textSize` | `24sp` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| TextView（中心，第二行） | `textSize` | `24sp` |'
- en: '| TextView (last one added) | `id` | `txtDescription` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| TextView（最后一个添加的） | `id` | `txtDescription` |'
- en: '| Button | `id` | `btnOK` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| Button | `id` | `btnOK` |'
- en: '| Button | `text` | `@string/ok_button` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| Button | `text` | `@string/ok_button` |'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After the preceding changes, you might want to tweak the final positions of
    some of the UI elements by dragging them around the screen since we have adjusted
    their size and contents. First, click on **Clear all Constraints**, then tweak
    the layout to be how you want it, and finally, click on **Infer Constraints**
    to constrain the positions again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行上述更改之后，您可能希望通过拖动它们在屏幕上调整它们的大小和内容来微调一些UI元素的最终位置。首先，单击**清除所有约束**，然后调整布局使其符合您的要求，最后，单击**推断约束**以再次约束位置。
- en: Now we have a layout that we can use for showing a note to the user. Notice
    that we get to reuse some string resources. The bigger our apps get, the more
    beneficial it is to do things this way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个布局，可以用来向用户显示笔记。请注意，我们可以重用一些字符串资源。我们的应用程序越大，这样做就越有益。
- en: Coding the dialog boxes
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写对话框
- en: Now that we have a design for both of our dialog windows ("show note" and "new
    note"), we can use what we know about the `FragmentDialog` class to implement
    a class to represent each of the dialog windows that the user can interact with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的两个对话框窗口（“显示笔记”和“新建笔记”）设计好了，我们可以利用我们对`FragmentDialog`类的了解来实现一个类来代表用户可以交互的每个对话框窗口。
- en: We will start with the "new note" screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从“新建笔记”屏幕开始。
- en: Coding the DialogNewNote class
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DialogNewNote类
- en: Create a new class by right-clicking on the project folder that has the `.kt`
    files and choose **New** | **Kotlin File/Class**. Name the `DialogNewNote` class
    and select **Class** in the drop-down selector. Click on **OK** to generate the
    new class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击具有`.kt`文件的项目文件夹并选择**新建** | **Kotlin文件/类**来创建一个新类。命名`DialogNewNote`类并在下拉选择器中选择**类**。单击**确定**生成新类。
- en: 'First, change the class declaration and inherit from `DialogFragment`. Also,
    override the `onCreateDialog` function, which is where all the rest of the code
    in this class will go. Make your code the same as the following in order to achieve
    this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改类声明并继承自`DialogFragment`。还要重写`onCreateDialog`函数，这是该类中其余代码的位置。使您的代码与以下代码相同以实现这一点：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to add these new imports as well:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要添加以下新的导入：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We temporarily have an error in the new class because we need a `return` statement
    in the `onCreateDialog` function, but we will get to that in just a moment.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时在新类中有一个错误，因为我们需要在`onCreateDialog`函数中有一个`return`语句，但我们马上就会解决这个问题。
- en: In the next block of code, which we will add in a moment, first we declare and
    initialize an `AlertDialog.Builder` object as we have previously done when creating
    dialog windows. This time, however, we will not use this object as much as we
    have before.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们将在一会儿添加的首先声明并初始化一个`AlertDialog.Builder`对象，就像我们以前创建对话框窗口时所做的那样。然而，这一次，我们不会像以前那样经常使用这个对象。
- en: Next, we initialize a `LayoutInflater` object, which we will use to inflate
    our XML layout. "Inflate" simply means to turn our XML layout into a Kotlin object.
    Once this has been done, we can then access all our widgets in the usual way.
    We can think of `inflater.inflate` replacing the `setContentView` function call
    for our dialog. And, in the second line, we do just that with the `inflate` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化一个`LayoutInflater`对象，我们将用它来填充我们的XML布局。 "填充"简单地意味着将我们的XML布局转换为Kotlin对象。一旦完成了这个操作，我们就可以以通常的方式访问所有小部件。我们可以将`inflater.inflate`视为替换对话框的`setContentView`函数调用。在第二行中，我们使用`inflate`函数做到了这一点。
- en: 'Add the three lines of code that we have just discussed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚刚讨论过的三行代码：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To support the new classes in the previous three lines of code, you will need
    to add the following `import` statements:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持前三行代码中的新类，您需要添加以下`import`语句：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have a `View` object called `dialogView` that has all the UI elements
    from our `dialog_new_note.xml` layout file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个名为`dialogView`的`View`对象，它具有来自我们的`dialog_new_note.xml`布局文件的所有UI元素。
- en: Now, underneath the previous block of code, we will add the following code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在上一个代码块下面，我们将添加以下代码。
- en: 'This code will get a reference to each of the UI widgets. Add this following
    code just after the previous block of code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将获取对每个UI小部件的引用。在上一个代码块之后添加以下代码：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Be sure to add the following `import` code to make the code you just added
    error-free:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保添加以下`import`代码，以使您刚刚添加的代码无错误：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is a new Kotlin feature in the preceding code that is known as the `as`
    keyword; for example, `as EditText`, `as CheckBox`, and `as Button`. This feature
    is used because there is no way for the compiler to infer the specific type of
    each of the UI widgets. Try deleting one of the `as…` keywords from the code and
    notice the error that arises. Using the `as` keyword (because we do know the type)
    overcomes this problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中有一个新的Kotlin特性，称为`as`关键字；例如，`as EditText`，`as CheckBox`和`as Button`。由于编译器无法推断出每个UI小部件的具体类型，所以使用了这个特性。尝试从代码中删除一个`as…`关键字并注意产生的错误。使用`as`关键字（因为我们知道类型）可以解决这个问题。
- en: In the next code block, we will set the message of the dialog using the `builder`
    instance. Then, we will write a lambda to handle clicks on `btnCancel`. In the
    overridden `onClick` function, we will simply call `dismiss()`, which is a function
    of `DialogFragment`, to close the dialog window. This is just what we need should
    the user click on **Cancel**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们将使用`builder`实例设置对话框的消息。然后，我们将编写一个lambda来处理`btnCancel`的点击。在重写的`onClick`函数中，我们将简单地调用`dismiss()`，这是`DialogFragment`的一个函数，用于关闭对话框窗口。这正是用户单击**Cancel**时我们需要的。
- en: 'Add this code that we have just discussed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚刚讨论过的代码：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we will add a lambda to handle what happens when the user clicks on the
    **OK** button (`btnOK`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个lambda来处理用户单击**OK**按钮（`btnOK`）时发生的情况。
- en: Inside it, we create a new `Note` called `newNote`. Then, we set each of the
    properties from `newNote` to the appropriate content of the form.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们创建一个名为`newNote`的新`Note`。然后，我们将`newNote`的每个属性设置为表单的适当内容。
- en: After this, we use a reference to `MainActivity` to call the `createNewNote`
    function in `MainActivity`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用对`MainActivity`的引用来调用`MainActivity`中的`createNewNote`函数。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we have not written this `createNewNote` function yet, and the function
    call will show an error until we do so later in this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有编写`createNewNote`函数，直到本章后面我们这样做之前，函数调用将显示错误。
- en: The argument sent in this function is our newly initialized `newNote` object.
    This has the effect of sending the user's new note back to `MainActivity`. We
    will see what we do with this later in the chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中发送的参数是我们新初始化的`newNote`对象。这样做的效果是将用户的新笔记发送回`MainActivity`。我们将在本章后面看到我们如何处理这个。
- en: 'Finally, we call `dismiss` to close the dialog window. Add the code that we
    have been discussing after the previous block of code that we added:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`dismiss`来关闭对话框窗口。在我们添加的上一个代码块之后添加我们讨论过的代码：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's our first dialog window done. We haven't wired it up to appear from `MainActivity`
    yet, and we need to implement the `createNewNote` function too. We will do this
    right after we create the next dialog.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个对话框窗口已经完成。我们还没有将其连接到`MainActivity`中，并且我们还需要实现`createNewNote`函数。我们将在创建下一个对话框之后立即执行此操作。
- en: Coding the DialogShowNote class
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写DialogShowNote类
- en: Create a new class by right-clicking on the project folder that contains all
    the `.kt` files and choose **New** | **Kotlin File/Class**. Name the `DialogShowNote`
    class, then choose **Class** in the drop-down selector, and click on **OK** to
    generate the new class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击包含所有`.kt`文件的项目文件夹，选择**New** | **Kotlin File/Class**来创建一个新类。命名为`DialogShowNote`类，然后在下拉选择器中选择**Class**，然后单击**OK**生成新类。
- en: First, change the class declaration and inherit from `DialogFragment`, and then
    override the `onCreateDialog` function. As most of the code for this class goes
    in the `onCreateDialog` function, implement the signature and empty body as shown
    in the following code and we will revisit it in a minute.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改类声明并继承自`DialogFragment`，然后重写`onCreateDialog`函数。由于这个类的大部分代码都在`onCreateDialog`函数中，所以按照以下代码中显示的签名和空体实现它，我们将在一分钟后回顾它。
- en: Notice that we declare a `var` property, `note`, of the `Note` type. In addition,
    add the `sendNoteSelected` function and its single line of code that initializes
    `note`. This function will be called by `MainActivity` and it will pass in the
    `Note` object that the user has clicked on.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们声明了`Note`类型的`var`属性`note`。另外，添加`sendNoteSelected`函数及其初始化`note`的单行代码。这个函数将被`MainActivity`调用，并传入用户点击的`Note`对象。
- en: 'Add the code that we have just discussed, and then we can look at the details
    of `onCreateDialog`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚讨论过的代码，然后我们可以查看`onCreateDialog`的细节：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'At this point, you will need to import the following classes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您需要导入以下类：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we declare and initialize an instance of `AlertDialog.Builder`. Next,
    as we did for `DialogNewNote`, we declare and initialize `LayoutInflater`, and
    then use it to create a `View` object that has the layout for the dialog. In this
    case, it is the layout from `dialog_show_note.xml`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明并初始化一个`AlertDialog.Builder`的实例。接下来，就像我们为`DialogNewNote`做的那样，我们声明并初始化`LayoutInflater`，然后使用它来创建一个具有对话框布局的`View`对象。在这种情况下，它是来自`dialog_show_note.xml`的布局。
- en: Finally, in the following block of code, we get a reference to each of the UI
    widgets and set the `text` properties on `txtTitle` and `textDescription` using
    the appropriate related properties from `note`, which was initialized in the `sendNoteSelected`
    function call.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面的代码块中，我们获取对每个UI小部件的引用，并使用`note`中的相关属性设置`txtTitle`和`textDescription`的`text`属性，这些属性在`sendNoteSelected`函数调用中初始化。
- en: 'Add the code that we have just discussed within the `onCreateDialog` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们刚刚讨论过的代码到`onCreateDialog`函数中：
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Add the following `import` statements to make all the classes in the previous
    code available:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述`import`语句添加到以前的代码中，以使所有类都可用：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This next code is also in the `onCreateDialog` function. It checks whether the
    note being shown is "important", and then shows or hides the `txtImportant TextView`
    widget accordingly. We then do the same for the `txtTodo` and `txtIdea` widgets.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码也在`onCreateDialog`函数中。它检查正在显示的笔记是否“重要”，然后相应地显示或隐藏`txtImportant TextView`小部件。然后我们对`txtTodo`和`txtIdea`小部件做同样的操作。
- en: 'Add this code after the previous block of code, while still in the `onCreateDialog`
    function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块之后添加此代码，仍然在`onCreateDialog`函数中：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All we need to do now is `dismiss` (that is, close) the dialog window when the
    user clicks on the **OK** button. This is done with a lambda, as we have seen
    several times already. The `onClick` function simply calls the `dismiss` function
    that closes the dialog window.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在用户点击**OK**按钮时`dismiss`（即关闭）对话框窗口。这是通过lambda完成的，因为我们已经看到了好几次。`onClick`函数只是调用`dismiss`函数，关闭对话框窗口。
- en: 'Add this code to the `onCreateDialog` function after the previous block of
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码块之后添加此代码到`onCreateDialog`函数中：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Import the `Button` class with this line of code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这行代码导入`Button`类：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We now have two dialog windows ready to roll. We just must add some code to
    the `MainActivity` class to finish the job.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个准备好的对话框窗口。我们只需要在`MainActivity`类中添加一些代码来完成工作。
- en: Showing and using our new dialogs
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示和使用我们的新对话框
- en: 'Add a new temporary property just after the `MainActivity` declaration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后添加一个新的临时属性：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This code won't be in the final app; it is just so we can test our dialog windows
    right away.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会出现在最终的应用程序中；这只是为了让我们立即测试我们的对话框窗口。
- en: 'Now add this function so that we can receive a new note from the `DialogNewNote`
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加这个函数，以便我们可以从`DialogNewNote`类接收一个新的笔记：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, to send a note to the `DialogShowNote` function, we need to add a button
    with the `button` `id` to the `layout_main.xml` layout file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将一个笔记发送到`DialogShowNote`函数，我们需要在`layout_main.xml`布局文件中添加一个带有`button` `id`的按钮。
- en: 'So that it is clear what this button is for, we will change its `text` attribute
    to `Show Note`, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地说明这个按钮的用途，我们将把它的`text`属性更改为`Show Note`，如下所示：
- en: Drag a `Button` widget onto `layout_main.xml`, and configure its `id` as `button`
    and `text` as `Show Note`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Button`小部件拖放到`layout_main.xml`上，并将其`id`配置为`button`，`text`配置为`Show Note`。
- en: Click on the **Infer Constraints** button so that the button stays where you
    put it. The exact position of this button is not important at this stage.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**Infer Constraints**按钮，使按钮停留在您放置的位置。此按钮的确切位置在这个阶段并不重要。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just to clarify, this is a temporary button for testing purposes and will not
    be used in the final app. At the end of development, we will click on a note's
    title from a list.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了澄清，这是一个临时按钮，用于测试目的，不会在最终的应用程序中使用。在开发结束时，我们将点击列表中的笔记标题。
- en: 'Now, in the `onCreate` function, we will set up a lambda to handle clicks on
    our temporary button. The code in `onClick` will do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`函数中，我们将设置一个lambda来处理对临时按钮的点击。`onClick`中的代码将执行以下操作：
- en: Create a new `DialogShowNote` instance that is simply called `dialog`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`dialog`的新`DialogShowNote`实例。
- en: Call the `sendNoteSelected` function on `dialog` to pass in our `Note` object,
    called `tempNote`, as an argument.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`dialog`上调用`sendNoteSelected`函数，将我们的`Note`对象`tempNote`作为参数传递进去。
- en: Finally, it will call `show`, which breathes life into our new dialog.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将调用`show`，为我们的新对话框注入生命。
- en: 'Add the code described previously to the `onCreate` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将先前描述的代码添加到`onCreate`函数中：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Be sure to import the `Button` class with this line of code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用这行代码导入`Button`类：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now summon our `DialogShowNote` dialog window at the click of a button.
    Run the app and click on the **SHOW NOTE** button to see the `DialogShowNote`
    dialog with the `dialog_show_note.xml` layout, as demonstrated in the following
    screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在点击按钮时召唤我们的`DialogShowNote`对话框窗口。运行应用程序，点击**SHOW NOTE**按钮，查看`DialogShowNote`对话框窗口，其中包含`dialog_show_note.xml`布局，如下截图所示：
- en: '![Showing and using our new dialogs](img/B12806_14_11.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![显示和使用我们的新对话框](img/B12806_14_11.jpg)'
- en: Admittedly, this is not much to look at considering how much coding we have
    done in this chapter, but when we get the `DialogNewNote` class working, we will
    see how `MainActivity` interacts and shares data between the two dialogs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，考虑到我们在本章中所做的大量编码，这并不是什么了不起的，但是当我们让“DialogNewNote”类起作用时，我们将看到“MainActivity”如何在两个对话框之间交互和共享数据。
- en: Let's make the `DialogNewNote` dialog useable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让“DialogNewNote”对话框可用。
- en: Coding the floating action button
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写浮动操作按钮
- en: 'This is going to be easy. The floating action button was provided for us in
    the layout. By way of a reminder, this is the floating action button:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将很容易。浮动操作按钮已经在布局中为我们提供。作为提醒，这是浮动操作按钮：
- en: '![Coding the floating action button](img/B12806_14_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![编写浮动操作按钮](img/B12806_14_12.jpg)'
- en: 'It is in the `activity_main.xml` file. This is the XML code that positions
    and defines its appearance:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 它在“activity_main.xml”文件中。这是定位和定义其外观的XML代码：
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Android Studio has even provided a ready-made lambda to handle clicks on the
    floating action button. All we need to do is add some code to the `onClick` function
    of this already provided code and we can use the `DialogNewNote` class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio甚至提供了一个现成的lambda来处理对浮动操作按钮的点击。我们只需要在已提供的代码的“onClick”函数中添加一些代码，就可以使用“DialogNewNote”类。
- en: The floating action button is usually used for a core action of an app. For
    example, in an email app, it will probably be used to start a new email; or, in
    a note-keeping app, it will probably be used to add a new note. So, let's do that
    now.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动操作按钮通常用于应用程序的核心操作。例如，在电子邮件应用程序中，它可能用于启动新电子邮件；或者在便签应用程序中，它可能用于添加新便签。所以，让我们现在做这个。
- en: 'In `MainActivity.kt`, find the autogenerated code provided by Android Studio
    in the `MainActivity.kt` class in the `onCreate` function; here is the code in
    its entirety:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在“MainActivity.kt”中，在“onCreate”函数中找到Android Studio提供的自动生成的代码；以下是完整的代码：
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the previous code, note the highlighted line and delete it. Now add the
    following code in place of the deleted code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意突出显示的行并删除它。现在在删除的代码的位置添加以下代码：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The new code creates a new dialog window of the `DialogNewNote` variety and
    then shows it to the user.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码创建了“DialogNewNote”类型的新对话框窗口，然后向用户显示它。
- en: 'We can now run the app; tap the floating action button and add a note along
    the lines of the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序；点击浮动操作按钮并添加一条便签，类似于以下截图：
- en: '![Coding the floating action button](img/B12806_14_13.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![编写浮动操作按钮](img/B12806_14_13.jpg)'
- en: 'Click on **OK** to save the note and return to the main layout. Next, we can
    tap the **Show Note** button to see it in a dialog window like the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”保存便签并返回到主布局。接下来，我们可以点击“显示便签”按钮，在对话框窗口中查看它，就像以下截图一样：
- en: '![Coding the floating action button](img/B12806_14_14.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![编写浮动操作按钮](img/B12806_14_14.jpg)'
- en: Be aware that if you add a second note, it will overwrite the first because
    we only have one `Note` instance. Furthermore, if you turn the phone off, or fully
    shut down the app, then the note is lost forever. We need to cover some more Kotlin
    in order to solve these problems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您添加第二个便笺，它将覆盖第一个，因为我们只有一个“Note”实例。此外，如果您关闭手机或完全关闭应用程序，那么便签将永远丢失。我们需要涵盖一些更多的Kotlin来解决这些问题。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen and implemented a common UI design with dialog
    windows using the `DialogFragment` class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到并实现了使用“DialogFragment”类的常见UI设计与对话框窗口。
- en: We went a step further when we started the Note to self app by implementing
    more complicated dialogs that can capture information from the user. We saw that
    `DialogFragment` enables us to have any UI we like in a dialog box.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动“Note to self”应用程序时，我们进一步迈出了一步，通过实现更复杂的对话框，可以从用户那里捕获信息。我们看到，“DialogFragment”使我们能够在对话框中拥有任何我们喜欢的UI。
- en: In the next chapter, we will begin to deal with the obvious problem whereby
    the user can only have one note, by exploring Kotlin's data handling classes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始解决一个明显的问题，即用户只能有一个便签，通过探索Kotlin的数据处理类。
