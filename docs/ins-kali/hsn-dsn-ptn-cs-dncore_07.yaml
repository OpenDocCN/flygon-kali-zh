- en: Implementing Design Patterns - .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计模式-.NET Core
- en: The previous chapter continued the building of the FlixOne inventory management
    application by incorporating additional patterns. More of the Gang of Four patterns
    were used, including the Singleton and Factory patterns. The Singleton pattern
    was used to illustrate the Repository pattern that was used to maintain the FlixOne
    collection of books. The Factory pattern was used to further explore the **dependency
    injection** (**DI**). The .Net Core framework was used to complete the initial
    inventory management console application, in order to facilitate an **inversion
    of control** (**IoC**) container.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章继续构建FlixOne库存管理应用程序，同时还包括其他模式。使用了更多的四人帮模式，包括Singleton和Factory模式。Singleton模式用于说明用于维护FlixOne图书集合的Repository模式。Factory模式用于进一步探索**依赖注入**（**DI**）。使用.NET
    Core框架完成了初始库存管理控制台应用程序，以便实现**控制反转**（**IoC**）容器。
- en: This chapter will continue building upon the inventory management console application,
    while also exploring features of .Net Core. The Singleton pattern, which was covered
    in the previous chapter, will be revisited and created, using the Singleton service
    lifetime built into the .Net Core framework. Using the framework's DI, the Configuration
    pattern will be shown, as well as **constructor injection (CI)** explained, using
    different examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续构建库存管理控制台应用程序，同时还将探索.NET Core的特性。将重新访问并创建上一章中介绍的Singleton模式，使用内置于.NET Core框架中的Singleton服务生命周期。将展示使用框架的DI的配置模式，以及使用不同示例解释**构造函数注入（CI）**。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: .Net Core service lifetimes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .Net Core服务生命周期
- en: Implementation factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现工厂
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples that are used to explain the concepts.
    The code is kept simple, and is just for demonstration purposes. Most of the examples
    involve a .NET Core console application written in C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含用于解释概念的各种代码示例。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    Version 3 or later).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）。
- en: Setting up .NET Core.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置.NET Core。
- en: SQL server (express edition is used in this chapter).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用的是Express版本）。
- en: Installing Visual Studio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio 2010, or later.
    You can use your preferred IDE. To do this, follow these instructions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio 2010或更高版本。您可以使用您喜欢的IDE。要做到这一点，请按照以下说明进行操作：
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明进行操作。Visual Studio有多个版本可供安装。在本章中，我们使用的是Windows版的Visual Studio。
- en: Setting up .NET Core
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装.NET Core，则需要按照以下说明进行操作：
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'The installation instructions and the related library can be found at the following
    link: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装说明和相关库可以在以下链接找到：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in the GitHub repository. The source code
    shown in the chapter might not be complete, so it is advisable to retrieve the
    source in order to run the examples. Please refer to [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5.](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub存储库中找到。本章中显示的源代码可能不完整，因此建议检索源代码以运行示例。请参阅[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5.](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5)
- en: .Net Core service lifetimes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .Net Core服务生命周期
- en: 'A fundamental concept to understand when working with .Net Core''s DI, is service
    lifetimes. A service lifetime defines how a dependency is managed in regards to
    how often it is created. As an illustration of this process, think of DI as managing
    a container of dependencies. Dependency is just a class that the DI knows about,
    because the class was *registered* with it. For .Net Core''s DI, this is done
    with the following three methods of `IServiceCollection`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用.NET Core的DI时，理解服务生命周期是一个基本概念。服务生命周期定义了依赖项的管理方式，以及它被创建的频率。作为这一过程的说明，将DI视为管理依赖项的容器。依赖项只是DI知道的一个类，因为该类已经与它*注册*。对于.NET
    Core的DI，可以使用`IServiceCollection`的以下三种方法来完成这一过程：
- en: '`AddTransient<TService, TImplementation>()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTransient<TService, TImplementation>()`'
- en: '`AddScoped<TService, TImplementation>()`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddScoped<TService, TImplementation>()`'
- en: '`AddSingleton<TService, TImplementation>()`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddSingleton<TService, TImplementation>()`'
- en: The `IServiceCollection` interface is a collection of registered service descriptions,
    basically containing the dependency, and when the DI should supply the dependency.
    For example, when `TService` is requested, `TImplementation` is supplied (that
    is, injected).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection`接口是已注册的服务描述的集合，基本上包含依赖项以及DI应该何时提供依赖项。例如，当请求`TService`时，会提供`TImplementation`（也就是注入）。'
- en: In this section, we will look at the three service lifetimes, and provide an
    illustration of the different lifetimes via unit tests. We will also look at how
    implementation factories can be used to create instances of the dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看三种服务生命周期，并通过单元测试提供不同生命周期的示例。我们还将看看如何使用实现工厂来创建依赖项的实例。
- en: Transient
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瞬态
- en: A `transient` dependency means each time the DI receives a request for a dependency,
    then a new instance of the dependency will be created. In most situations, this
    is the service lifetime that makes the most sense to use, as most classes should
    be designed to be lightweight, stateless services. In situations where the state
    needs to be persisted between references and/or if there is considerable effort
    in instantiating a new instance, then another service lifetime might make more
    sense.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`瞬态`依赖项意味着每次DI接收到对依赖项的请求时，将创建依赖项的新实例。在大多数情况下，这是最合理使用的服务生命周期，因为大多数类应设计为轻量级、无状态的服务。在需要在引用之间保持状态和/或在实例化新实例方面需要大量工作的情况下，可能会更合理地使用另一种服务生命周期。'
- en: Scoped
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: In .Net Core, there is the concept of a scope, which can be thought of as a
    context or boundary for the executing process. In some .Net Core implementations,
    the scope is implicitly defined, so you might not be aware that it is being put
    in place. For example, in ASP.Net Core, a scope is created for each web request
    that is received. This means that, if a dependency has a Scoped lifetime, then
    it will only be constructed once per web request, so, if the same dependency is
    used multiple times for the same web request, it will be shared.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在.Net Core中，有一个作用域的概念，可以将其视为执行过程的上下文或边界。在某些.Net Core实现中，作用域是隐式定义的，因此您可能不知道它已经被放置。例如，在ASP.Net
    Core中，为接收到的每个Web请求创建一个作用域。这意味着，如果一个依赖项具有作用域生命周期，那么它将仅在每个Web请求中构造一次，因此，如果相同的依赖项在同一Web请求中多次使用，它将被共享。
- en: Later in this chapter, we will explicitly create a scope in order to illustrate
    a Scoped lifetime, and the same concept applies in the unit test as it will in
    an ASP.Net Core application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将明确创建一个范围，以说明作用域生命周期，相同的概念也适用于单元测试，就像在ASP.Net Core应用程序中一样。
- en: Singleton
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: In .Net Core, the Singleton pattern is implemented so that dependency is only
    ever instantiated once, just like the Singleton pattern that was implemented in
    the previous chapter. Similar to the Singleton pattern in the previous chapter,
    the `singleton` class needs to be thread safe, and only the factory method that
    is used to create the singleton class is guaranteed to be called only once by
    a single thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在.Net Core中，Singleton模式的实现方式是依赖只被实例化一次，就像在上一章中实现的Singleton模式一样。与上一章中的Singleton模式类似，`singleton`类需要是线程安全的，只有用于创建单例类的工厂方法才能保证只被单个线程调用一次。
- en: Back to FlixOne
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到FlixOne
- en: 'To illustrate .Net Core''s DI, we need to make some modifications to the FlixOne
    inventory management application. The first thing to do will be to update the
    `InventoryContext` class, which was defined earlier, in order to no longer implement
    the Singleton pattern (as we will do this using .Net Core''s DI):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明.Net Core的DI，我们需要对FlixOne库存管理应用程序进行一些修改。首先要做的是更新之前定义的`InventoryContext`类，以便不再实现Singleton模式（因为我们将使用.Net
    Core的DI来实现）：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The detail of the `AddBook` and `UpdateQuantity` methods are shown in the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBook`和`UpdateQuantity`方法的详细信息如下所示：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are a couple of things to note. The constructor has been changed from
    protected to public. This will allow the class to be instantiated by objects outside
    of the class. Also, note that the static `Instance` property and the private static
    `_instance` field have been removed, while the private `_lock` field remains.
    Similar to the Singleton pattern defined in the previous chapter, this only guarantees
    how the class is instantiated; it does not prevent methods from being accessed
    in parallel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情需要注意。构造函数已从受保护更改为公共。这将允许类在类外部被实例化。还要注意，静态`Instance`属性和私有静态`_instance`字段已被删除，而私有`_lock`字段仍然存在。与上一章中定义的Singleton模式类似，这只保证了类的实例化方式；它并不阻止方法被并行访问。
- en: Both the `IInventoryContext` interface and the `InventoryContext` and `Book`
    classes were made public, as our DI is being defined in an external project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInventoryContext`接口和`InventoryContext`和`Book`类都被设为公共，因为我们的DI是在外部项目中定义的。'
- en: 'Subsequently, the `InventoryCommandFactory` class, which is used to return
    commands, has been updated to have an instance of the `InventoryContext` injected
    into its constructor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，用于返回命令的`InventoryCommandFactory`类已更新，以便在其构造函数中注入`InventoryContext`的实例：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `GetCommand` method uses the input provided to determine the specific command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommand`方法使用提供的输入来确定特定的命令：'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As noted, the `IInventoryContext` interface will now be supplied by the DI
    container that is defined in the client project. The console application now has
    an additional line to create a Singleton of the `IInventoryContext` interface
    using the `InventoryContext` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`IInventoryContext`接口现在将由客户端项目中定义的DI容器提供。控制台应用程序现在有一个额外的行来使用`InventoryContext`类创建`IInventoryContext`接口的单例：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The console application can now be run with the same manual test as that performed
    in the previous chapter, but unit tests are a great way to understand what is
    being achieved using .Net Core's DI.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序现在可以使用与上一章中执行的手动测试相同的方式运行，但是单元测试是了解使用.Net Core的DI实现的成果的好方法。
- en: The example code provided for this chapter shows the completed project. The
    following section concentrates on the `InventoryContext` tests. The `InventoryCommandFactory`
    tests were also modified, but, as the changes are trivial, they will not be covered
    here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的示例代码显示了完成的项目。接下来的部分集中在`InventoryContext`测试上。`InventoryCommandFactory`测试也进行了修改，但由于更改是微不足道的，因此不会在此处进行介绍。
- en: Unit tests
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'With the changes to the `InventoryContext` class, we no longer have a convenient
    property for getting the only instance of the class. This means that `InventoryContext.Instance`
    will need to be replaced, and, as a first attempt, let''s create a method to return
    a new instance of `InventoryContext`, and use `GetInventoryContext()` instead
    of `InventoryContext.Instance`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对`InventoryContext`类的更改，我们不再有一个方便的属性来获取该类的唯一实例。这意味着`InventoryContext.Instance`需要被替换，首先，让我们创建一个方法来返回`InventoryContext`的新实例，并使用`GetInventoryContext()`代替`InventoryContext.Instance`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As expected, the unit tests fail with an error message: *The given key was
    not present in the dictionary*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，单元测试失败，并显示错误消息：*给定的键在字典中不存在*：
- en: '![](img/270f856b-e1dc-475a-8a82-22e9288276cb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/270f856b-e1dc-475a-8a82-22e9288276cb.png)'
- en: As we saw in the previous chapter, this is because the `InventoryContext` list
    of books is empty each time the `InventoryContext` class is created. This is why
    we need to create a context using a Singleton.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，这是因为每次创建`InventoryContext`类时，书籍的列表都是空的。这就是为什么我们需要使用Singleton创建一个上下文的原因。
- en: 'Let''s update the `GetInventoryContext()` method to now supply an instance
    of the `IInventoryContext` interface using .Net Core''s DI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`GetInventoryContext()`方法，现在使用.Net Core的DI来提供`IInventoryContext`接口的实例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the updated method, an instance of the `ServiceCollection` class is created,
    which will be used to contain all the registered dependencies. The `InventoryContext`
    class is registered as a Singleton to be supplied when the `IInventoryContext`
    dependency is requested. A `ServiceProvider` instance is then generated, which
    will actually perform the DI based on the registrations in the `IServiceCollection` interface.
    The final step is to supply the `InventoryContext` class when the `IInventoryContext`
    interface is requested.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的方法中，创建了`ServiceCollection`类的一个实例，用于包含所有注册的依赖项。`InventoryContext`类被注册为Singleton，以便在请求`IInventoryContext`依赖项时提供。然后生成了一个`ServiceProvider`实例，它将根据`IServiceCollection`接口中的注册执行DI。最后一步是在请求`IInventoryContext`接口时提供`InventoryContext`类。
- en: The `Microsoft.Extensions.DependencyInjection` library will need to be added
    to the `InventoryManagementTests` project in order to be able to reference the
    .Net Core DI components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.DependencyInjection`库需要添加到`InventoryManagementTests`项目中，以便能够引用.Net
    Core DI组件。'
- en: 'Unfortunately, the unit test still does not pass, and results in the same error: *The
    given key was not present in the dictionary. *This is because we are creating
    a new instance of the DI framework each time `IInventoryContext` is requested.
    This means that even though our dependency is a Singleton, each instance of `ServiceProvider`
    will supply a new instance of the `InventoryContext` class. To get around this,
    we will create `IServiceCollection` when the test first starts up, and then we
    will use the same reference during the test:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，单元测试仍然无法通过，并且导致相同的错误：*给定的键在字典中不存在。*这是因为每次请求`IInventoryContext`时，我们都会创建一个新的DI框架实例。这意味着，即使我们的依赖是一个Singleton，每个`ServiceProvider`实例都会提供一个新的`InventoryContext`类的实例。为了解决这个问题，我们将在测试启动时创建`IServiceCollection`，然后在测试期间使用相同的引用：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the `TestInitialize` attribute is a great way to separate the functionality
    required by multiple `TestMethod` tests within a `TestClass` class. The method
    will be run before every test is run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestInitialize`属性是在`TestClass`类中分离多个`TestMethod`测试所需的功能的好方法。该方法将在每次测试运行之前运行。
- en: 'Now that there is a reference to the same `ServiceProvider` instance, we can
    update to retrieve the dependency. The following illustrates how the `AddBook()`
    method has been updated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了对同一个`ServiceProvider`实例的引用，我们可以更新以检索依赖项。以下说明了`AddBook()`方法的更新方式：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our unit test now passes successfully, as only one instance of the `InventoryContext`
    class is created during the execution of the test:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试现在成功通过，因为在测试执行期间只创建了一个`InventoryContext`类的实例：
- en: '![](img/1c92dd81-8d8c-466a-982e-ab7862dcab15.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c92dd81-8d8c-466a-982e-ab7862dcab15.png)'
- en: The Singleton pattern is relatively easy to implement using the built-in DI,
    as illustrated in this section. Understanding when to use the pattern is an important
    concept. The next section will explore the concept of scope in more detail, in
    order to gain a further understanding of service lifetimes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的DI相对容易实现Singleton模式，就像本节中所示。了解何时使用该模式是一个重要的概念。下一节将更详细地探讨作用域的概念，以便更深入地理解服务的生命周期。
- en: Scope
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: In applications that have multiple processes executing simultaneously, understanding
    service lifetime is very important to both functional and non-functional requirements.
    As illustrated in the previous unit test without the correct service lifetime,
    `InventoryContext` did not function as desired, and led to an invalid situation.
    Likewise, the incorrect use of service lifetimes could lead to applications that
    do not scale well. In general, the use of a lock-and-shared state should be avoided
    in multi-process solutions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在同时执行多个进程的应用程序中，了解服务生命周期对功能和非功能需求都非常重要。正如在上一个单元测试中所示，如果没有正确的服务生命周期，`InventoryContext`就无法按预期工作，并导致了一个无效的情况。同样，错误使用服务生命周期可能导致应用程序无法良好扩展。一般来说，在多进程解决方案中应避免使用锁和共享状态。 '
- en: To illustrate this concept, imagine the FlixOne inventory management application
    was supplied to multiple staff members. The challenge now is how to perform a
    lock across multiple applications, and how to have a single collected state. In
    our terms, this would be a single `InventoryContext` class shared by multiple
    applications. Of course, this is where changing our solution to use a shared repository
    (for example, a database) would make sense, and/or changing our solution to a
    web application. We will cover databases and web application patterns in later
    chapters, but, as we are discussing service lifetimes, it does make sense to describe
    these in terms of a web application in more detail now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，想象一下FlixOne库存管理应用程序被提供给多个员工。现在的挑战是如何在多个应用程序之间执行锁定，以及如何拥有一个单一的收集状态。在我们的术语中，这将是多个应用程序共享的单个`InventoryContext`类。当然，这就是我们改变解决方案以使用共享存储库（例如数据库）或改变解决方案以使用Web应用程序的地方。我们将在后面的章节中涵盖数据库和Web应用程序模式，但是，由于我们正在讨论服务生命周期，现在更详细地描述这些内容是有意义的。
- en: 'The following diagram depicts a web app receiving two requests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了一个Web应用程序接收两个请求：
- en: '![](img/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png)'
- en: In terms of service lifetimes, a Singleton service lifetime will be available
    to both requests, while each request receives its own Scope lifetime. The important
    thing to note is around garbage collection. Dependencies that are created with
    a Transient service lifetime are marked to be released once the object is no longer
    referenced, while dependencies created with a Scope service lifetime are not marked
    to be released until the web request completes. And, dependencies created with
    a Singleton service lifetime are not marked to be released until the application
    ends.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务生命周期方面，单例服务生命周期将对两个请求都可用，而每个请求都会接收到自己的作用域生命周期。需要注意的重要事情是垃圾回收。使用瞬态服务生命周期创建的依赖项在对象不再被引用时标记为释放，而使用作用域服务生命周期创建的依赖项在Web请求完成之前不会被标记为释放。而使用单例服务生命周期创建的依赖项直到应用程序结束才会被标记为释放。
- en: 'Also, as shown in the following diagram, it is important to remember that dependencies
    in .Net Core are not shared between server instances in a web garden or web farm:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如下图所示，重要的是要记住，在.Net Core中，依赖项在Web园或Web农场中的服务器实例之间不共享：
- en: '![](img/13d3bc5b-0273-488b-9db0-f87daf198604.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13d3bc5b-0273-488b-9db0-f87daf198604.png)'
- en: In the following chapters, different approaches to the shared state will be
    shown, including using a shared cache, databases, and other forms of repositories.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将展示共享状态的不同方法，包括使用共享缓存、数据库和其他形式的存储库。
- en: Implementation factory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现工厂
- en: 'The .Net Core DI supports the ability to specify an *implementation factory*
    when registering a dependency. This allows for control over the creation of the
    dependency that is supplied by the service provided. This is done when registering
    by using the following extension of the `IServiceCollection` interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core DI支持在注册依赖项时指定*实现工厂*的能力。这允许对由提供的服务提供的依赖项的创建进行控制。在注册时使用`IServiceCollection`接口的以下扩展来完成：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AddSingleton` extension receives both a class to be registered as well
    as the class to be supplied when the dependency is required. An interesting thing
    to note is the .Net Core DI framework will maintain the registered services and
    either deliver the implementation when requested, or as part of instantiating
    one of the dependencies. This automatic instantiation is called **constructor
    injection** (**CI**). We will see examples of both in the following sections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton`扩展接收要注册的类以及在需要依赖项时要提供的类。值得注意的是，.Net Core DI框架将维护已注册的服务，并在请求时提供实现，或作为依赖项之一的实例化的一部分。这种自动实例化称为**构造函数注入**（**CI**）。我们将在以下章节中看到这两种的例子。'
- en: IInventoryContext
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryContext
- en: 'As an example, let''s revisit the `InventoryContext` class that is used to
    manage the inventory of books, by segregating the read and the write operations
    performed on our collection of books. `IInventoryContext` is split into `IInventoryReadContext`
    and `IInventoryWriteContext`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们重新审视一下用于管理书籍库存的`InventoryContext`类，通过将对书籍集合的读取和写入操作进行分离。`IInventoryContext`被分成了`IInventoryReadContext`和`IInventoryWriteContext`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: IInventoryReadContext
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryReadContext
- en: The `IInventoryReadContext` interface contains the operation to read the books,
    while `IInventoryWriteContext` contains the operations that modify the collection
    of books. The original `IInventoryContext` interface was created for convenience
    for when a class requires both dependency types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInventoryReadContext`接口包含读取书籍的操作，而`IInventoryWriteContext`包含修改书籍集合的操作。最初创建`IInventoryContext`接口是为了方便一个类需要两种依赖类型时。'
- en: In later chapters, we will cover patterns that take advantage of splitting the
    context, including the **Command and** **Query Responsibility Segregation** (**CQRS**)
    pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将涵盖利用分割上下文的模式，包括**命令和** **查询责任分离**（**CQRS**）模式。
- en: 'With this refactor, some changes are required. First classes only requiring
    to read the collection of books have their constructor updated with the `IInventoryReadContext`
    interface, as illustrated in the `GetInventoryCommand` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种重构，需要进行一些更改。首先，只需要读取书籍集合的类将其构造函数更新为`IInventoryReadContext`接口，如`GetInventoryCommand`类所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IInventoryWriteContext
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IInventoryWriteContext
- en: 'Likewise, classes requiring to modify the collection of books are updated to
    the `IInventoryWriteContext` interface, as illustrated with `AddInventoryCommand`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，需要修改书籍集合的类将其更新为`IInventoryWriteContext`接口，如`AddInventoryCommand`所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following shows the detail of the `GetParameters` and `InternalCommand`
    methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了`GetParameters`和`InternalCommand`方法的详细信息：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the `InternalCommand` method, where the book is added to the inventory
    with the given name of the book held in the `InventoryName` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `InternalCommand` 方法，其中将带有 `InventoryName` 参数中保存的书名添加到库存中。
- en: Next, we will look at the factory for the inventory commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看库存命令的工厂。
- en: InventoryCommandFactory
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommandFactory
- en: 'The `InventoryCommandFactory` class is an implementation of the Factory pattern
    using .Net classes, which requires both readings of, and writing to, the collection
    of books:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 类是使用 .Net 类实现工厂模式的一个实现，需要对书籍集合进行读取和写入：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An interesting thing to note, is that the class actually did not require modifying
    from the previous chapter's version, as polymorphism handles the casting from
    `IInventoryContext` to the `IInventoryReadContext` and `IInventoryWriteContext`
    interfaces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个类实际上不需要修改前一章版本的内容，因为多态性处理了从 `IInventoryContext` 到 `IInventoryReadContext`
    和 `IInventoryWriteContext` 接口的转换。
- en: 'With these changes, we need to change the registration of the dependencies
    that are related to `InventoryContext`, in order to use an implementation factory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些变化，我们需要改变与 `InventoryContext` 相关的依赖项的注册，以使用实现工厂：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For all three interfaces, the same instance of `InventoryContext` will be used,
    and this is instantiated once using the implementation factory extension. This
    is supplied when a `IInventoryReadContext`, `IInventoryWriteContext`, or `IInventoryContext`
    dependency is requested.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有三个接口，将使用相同的 `InventoryContext` 实例，并且这是使用实现工厂扩展一次实例化的。当请求 `IInventoryReadContext`、`IInventoryWriteContext`
    或 `IInventoryContext` 依赖项时提供。
- en: InventoryCommand
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand
- en: '`InventoryCommandFactory` was useful to illustrate how the Factory pattern
    could be achieved using .Net, but let''s revisit this now that we are using the
    .Net Core framework. Our requirement is given a string value; we want to return
    a particular implementation of `InventoryCommand`. This can be achieved in several
    ways, and, in this section, three examples will be given:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 在展示如何使用 .Net 实现工厂模式时非常有用，但现在让我们重新审视一下，因为我们现在正在使用
    .Net Core 框架。我们的要求是给定一个字符串值；我们希望返回 `InventoryCommand` 的特定实现。这可以通过几种方式实现，在本节中将给出三个示例：'
- en: Implementation factory using a function
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数的实现工厂
- en: Using services
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务
- en: Using third-party containers
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: Implementation factory using a function
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数的实现工厂
- en: 'The implementation factory of the `GetService()` method can be used to determine
    the type of `InventoryCommand` class to be returned. For this example, a new static
    method is created in the `InventoryCommand` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetService()` 方法的实现工厂可以用于确定要返回的 `InventoryCommand` 类型。对于这个示例，在 `InventoryCommand`
    类中创建了一个新的静态方法：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a little tricky to read if you are not familiar with lambda expression
    bodies, so we will explain the code in a bit of detail. First of all, let''s revisit
    the syntax of the `AddSingleton`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 lambda 表达式体，这可能有点难以阅读，因此我们将详细解释一下代码。首先，让我们重新审视一下 `AddSingleton` 的语法：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This shows that the parameter of the `AddSingleton` extension is a function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `AddSingleton` 扩展的参数是一个函数：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that the following code is equivalent:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下代码是等价的：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `GetInventoryContext` method is defined as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryContext` 方法定义如下：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our particular example, the specific `InventoryCommand` types have been
    marked as internal to the `FlixOne.InventoryManagement` project, so the `FlixOne.InventoryManagementClient`
    project is not able to access them directly. This is why a new static method was
    created in the `FlixOne.InventoryManagement.InventoryCommand` class that returned
    the following type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定示例中，特定的 `InventoryCommand` 类型已被标记为 `FlixOne.InventoryManagement` 项目的内部，因此
    `FlixOne.InventoryManagementClient` 项目无法直接访问它们。这就是为什么在 `FlixOne.InventoryManagement.InventoryCommand`
    类中创建了一个新的静态方法，返回以下类型：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What this means is, when the service is requested, a string will be supplied
    to determine the specific type. Because the dependency changed, this means the
    `CatalogService` constructor requires updating:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当请求服务时，将提供一个字符串来确定具体的类型。由于依赖项发生了变化，这意味着 `CatalogService` 构造函数需要更新：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the service is requested, a string will be supplied to determine the specific.
    Because the dependency changed, the `CatalogueService` constructor requires updating:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求服务时，将提供一个字符串来确定具体的类型。由于依赖项发生了变化，`CatalogueService` 构造函数需要更新：
- en: 'Now when the string the user has entered is supplied to the `CommandFactory`
    dependency, the correct command is supplied:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户输入的字符串被提供给 `CommandFactory` 依赖项时，将提供正确的命令：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The unit tests associated with the command factory were also updated. As a
    comparison, a new `test` class was created from the existing `InventoryCommandFactoryTests` class,
    and named `InventoryCommandFunctionTests`. The initialization step is shown in
    the following code, with the changes highlighted:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令工厂相关的单元测试也进行了更新。作为对比，从现有的 `InventoryCommandFactoryTests` 类创建了一个新的 `test`
    类，并命名为 `InventoryCommandFunctionTests`。初始化步骤如下所示，其中突出显示了更改：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The individual tests were also updated to supply the string as part of the
    get service call, as shown in the following code with `QuitCommand`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还更新了各个测试，以在 `QuitCommand` 中提供字符串作为获取服务调用的一部分，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two tests verify that the services that are returned are of the `QuitCommand`
    type, when the service provider is given `"q"` or `"quit"`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试验证了当服务提供程序提供 `"q"` 或 `"quit"` 时，返回的服务类型是 `QuitCommand`。
- en: Using services
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务
- en: The `ServiceProvider` class provides a `Services` method that can be used to
    determine the appropriate service, when there are multiple dependencies registered
    for the same type. This example will take a different tack with `InventoryCommands`,
    and, because of the extent of the refactor, this will be done with new classes
    that will be created just to illustrate this approach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceProvider`类提供了一个`Services`方法，可以用来确定适当的服务，当同一类型有多个依赖项注册时。这个例子将采用不同的方法处理`InventoryCommands`，由于重构的范围，这将通过新创建的类来完成，以说明这种方法。'
- en: 'In the unit test project, a new folder, `ImplementationFactoryTests`, was created,
    to contain the classes for this section. In the folder, a new base class for `InventoryCommand`
    was created:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试项目中，创建了一个新的文件夹`ImplementationFactoryTests`，用于包含本节的类。在这个文件夹中，创建了一个新的`InventoryCommand`基类：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The concept behind this new class is that child classes will define the strings
    that they respond to. For example, `QuitCommand` will respond to the `"q"` and
    `"quit"` strings:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类背后的概念是，子类将定义它们要响应的字符串。例如，`QuitCommand`将响应`"q"`和`"quit"`字符串：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following shows the `GetInventoryCommand`, `AddInventoryCommand`, `UpdateQuantityCommand`,
    and `HelpCommand` classes, which follow a similar approach:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了`GetInventoryCommand`、`AddInventoryCommand`、`UpdateQuantityCommand`和`HelpCommand`类，它们采用了类似的方法：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `UnknownCommand` class, though, will be used as a default, so it will always
    evaluate to true, by overriding the `IsCommandFor` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`UnknownCommand`类将被用作默认值，因此它将始终通过重写`IsCommandFor`方法来评估为true：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because the `UnknownCommand` class is being treated as a default, the order
    of registration is important, and is shown below in the initialization of the
    unit `test` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`UnknownCommand`类被视为默认值，注册的顺序很重要，在单元测试类的初始化中如下所示：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For convenience, a new method has been created in order to return an instance
    of the `InventoryCommand` class when given a matching input string:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，创建了一个新的方法，以便在给定匹配输入字符串时返回`InventoryCommand`类的实例：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method will traverse the collection of dependencies that are registered
    for the `InventoryCommand` service, until a match is found by using the `IsCommandFor()`
    method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将遍历为`InventoryCommand`服务注册的依赖项集合，直到使用`IsCommandFor()`方法找到匹配项。
- en: 'The unit test then uses the `GetCommand()` method to determine the dependency,
    as shown below for `UpdateQuantityCommand`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，单元测试使用`GetCommand()`方法来确定依赖项，如下所示，用于`UpdateQuantityCommand`：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using third-party containers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方容器
- en: The .Net Core framework provides great flexibility and functionality, but some
    features might not be supported, and a third-party container might be a more appropriate
    choice. Fortunately .Net Core is extensible and allows for the built-in service
    container to be replaced by a third-party container. To provide an example, we
    will use `Autofac` as our IoC container of the .Net Core DI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core框架提供了很大的灵活性和功能，但可能不支持一些功能，第三方容器可能是更合适的选择。幸运的是，.Net Core是可扩展的，允许用第三方容器替换内置的服务容器。为了举例，我们将使用`Autofac`作为.Net
    Core DI的IoC容器。
- en: '`Autofac` has a ton of great features, and is shown here as an example; but
    of course, there are other IoC containers that could have been used. For example,
    Castle Windsor and Unit are great alternatives that should also be considered.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autofac`有很多很棒的功能，在这里作为一个例子展示出来；当然，还有其他IoC容器可以使用。例如，Castle Windsor和Unit都是很好的替代方案，也应该考虑使用。'
- en: 'The first step is to add the required `Autofac` package to the project. Using
    the package manager console, add the package using the following command (only
    required on the test project):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将所需的`Autofac`包添加到项目中。使用包管理器控制台，使用以下命令添加包（仅在测试项目中需要）：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example will again support our `InventoryCommand` factory by using an `Autofac`
    feature of naming registered dependencies. These named dependencies will be used
    to retrieve the correct `InventoryCommand` instance, based on the supplied input.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将再次通过使用`Autofac`的命名注册依赖项的功能来支持我们的`InventoryCommand`工厂。这些命名的依赖项将用于根据提供的输入来检索正确的`InventoryCommand`实例。
- en: 'Similar to the previous example, the registration of dependencies will be done
    in the `TestInitialize` method. The registrations will be named based on the command
    that will be used to determine the command. The following shows the `Startup`
    method structure that creates the `ContainerBuilder` object which will build the
    `Container` instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子类似，依赖项的注册将在`TestInitialize`方法中完成。注册将根据将用于确定命令的命令命名。以下显示了创建`ContainerBuilder`对象的`Startup`方法结构，该对象将构建`Container`实例：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The commands are registered as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的注册如下：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unlike the previous example, the container that is generated is an instance
    of `Autofac.IContainer`. This will be used to retrieve each registered dependency. `QuitCommand`,
    for example, will be named both `"q"` and `"quit"`, which indicates the two commands
    that can be used to execute the command. Also, note the last registered type is
    not named, and belongs to `UnknownCommand`. This will act as a default if no command
    is found by name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子不同，生成的容器是`Autofac.IContainer`的实例。这将用于检索每个注册的依赖项。例如，`QuitCommand`将被命名为`"q"`和`"quit"`，这表示可以用于执行命令的两个命令。另外，注意最后注册的类型没有命名，并属于`UnknownCommand`。如果没有找到命令，则这将充当默认值。
- en: 'To determine a dependency, a new method will be used to retrieve the dependency
    by name:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定一个依赖项，将使用一个新方法来按名称检索依赖项：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Autofac.IContainer` interface has a `ResolveOptionalNamed<*T*>(*string*)`
    method name, which will return the dependency with the given name, or null, if
    no matching registrations are found. If the dependency is not registered with
    the given name, then an instance of the `UnknownCommand` class will be returned.
    This is done by using the null-coalescing operation, `??`, and the `IContainer.Resolve<*T*>`
    method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autofac.IContainer`接口具有`ResolveOptionalNamed<*T*>(*string*)`方法名称，该方法将返回具有给定名称的依赖项，如果找不到匹配的注册，则返回null。如果未使用给定名称注册依赖项，则将返回`UnknownCommand`类的实例。这是通过使用空值合并操作`??`和`IContainer.Resolve<*T*>`方法来实现的。'
- en: '`Autofac.IContainer.ResolveNamed<*T*>(*string*)` will throw a `ComponentNotRegisteredException` exception
    if the dependency resolution fails.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项解析失败，`Autofac.IContainer.ResolveNamed<*T*>(*string*)`将抛出`ComponentNotRegisteredException`异常。
- en: 'A test method is written for each command in order to ensure that the commands
    are resolved correctly. Again, using `QuitCommand` as an example, we can see the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保正确解析命令，为每个命令编写了一个测试方法。再次以`QuitCommand`为例，我们可以看到以下内容：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please view the `InventoryCommandAutofacTests` class in the source for the other
    `InventoryCommand` examples.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看源代码中的`InventoryCommandAutofacTests`类，以获取其他`InventoryCommand`示例。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The goal of this chapter was to explore the .Net Core framework in more detail,
    and, in particular, the .Net Core DI. Three types of service lifetimes are supported:
    Transient, Scoped, and Singleton. A Transient service will create a new instance
    of a registered dependency for each request. A Scoped service will be generated
    once with a defined scope, while a Singleton service will be performed once for
    the lifetime of the DI service collection.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是更详细地探索.Net Core框架，特别是.Net Core DI。支持三种类型的服务生命周期：瞬态（Transient）、作用域（Scoped）和单例（Singleton）。瞬态服务将为每个请求创建一个已注册依赖项的新实例。作用域服务将在定义的范围内生成一次，而单例服务将在DI服务集合的生命周期内执行一次。
- en: As the .Net Core DI is central to confidently building .Net Core applications,
    it is important to understand its capabilities and its limitations. It is important
    to use the DI effectively, as well as to avoid duplicating functionality that
    is already supplied. Just as crucial, it is also wise to know the limits of the
    .Net Core DI framework, as well as the strengths of other DI frameworks, for situations
    where replacing the basic .Net Core DI framework with a third-party DI framework
    could be beneficial for an application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.Net Core DI对于自信地构建.Net Core应用程序至关重要，因此了解其能力和局限性非常重要。重要的是要有效地使用DI，同时避免重复使用已提供的功能。同样重要的是，了解.Net
    Core DI框架的限制，以及其他DI框架的优势，以便在替换基本的.Net Core DI框架为第三方DI框架可能对应用程序有益的情况下，能够明智地做出选择。
- en: The next chapter will build upon the previous chapters and explore, common patterns
    in .Net Core ASP.Net web applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在前几章的基础上构建，并探索.Net Core ASP.Net Web应用程序中的常见模式。
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: If you are not sure what type of service lifetime to use, which type is it best
    to register a class as? Why?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不确定要使用哪种类型的服务生命周期，最好将类注册为哪种类型？为什么？
- en: In .Net Core ASP.Net solutions, is a Scope defined per web request, or per session?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.Net Core ASP.Net解决方案中，作用域是按照每个web请求定义的，还是按照每个会话定义的？
- en: Does registering a class as a Singleton in the .Net Core DI framework make it
    thread-safe?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.Net Core DI框架中将类注册为单例是否会使其线程安全？
- en: Is it true that the .Net Core DI framework can only be replaced with other Microsoft-supplied
    DI frameworks?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .Net Core DI框架只能被其他由微软提供的DI框架替换吗？
