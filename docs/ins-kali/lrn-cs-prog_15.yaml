- en: '*Chapter 15*: New Features of C# 8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：C# 8的新功能'
- en: C# is a mature programming language, but it is still evolving to satisfy new
    requirements coming from emergent software architectures. The main focus of most
    of the four language versions of C# 7 is on providing the tools for impressive
    performance when using value types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种成熟的编程语言，但它仍在不断发展，以满足新兴软件架构带来的新需求。C# 7的四个语言版本的主要重点是提供在使用值类型时令人印象深刻的性能工具。
- en: 'With the latest version, C# 8 introduces many new important features focusing
    on four main areas: making code more compact and easier to read, along with performance,
    robustness, and expressivity. The fundamental change in C# 8 is that it is the
    first release of the language without official support in .NET Framework because
    some of its features require the .NET Core runtime enhancements.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最新版本的推出，C# 8引入了许多重要的新功能，重点放在四个主要领域：使代码更紧凑、更易阅读，以及性能、健壮性和表现力。C# 8的根本变化在于它是该语言的第一个版本，没有在.NET
    Framework中获得官方支持，因为其中一些功能需要.NET Core运行时的增强。
- en: 'In this chapter, we will go through the following new language features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下新的语言特性：
- en: Nullable reference types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: Default implementation of interface members
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口成员的默认实现
- en: Ranges and indices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围和索引
- en: Pattern matching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: The using declaration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明
- en: Asynchronous Dispose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步Dispose
- en: Disposable patterns in structs and ref structs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构和ref结构中的可处置模式
- en: Asynchronous streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步流
- en: Read-only struct members
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读结构成员
- en: Null coalescing assignment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空合并赋值
- en: Static local functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态局部函数
- en: Better interpolated verbatim strings
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的插值原始字符串
- en: Using stackalloc in nested expressions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌套表达式中使用stackalloc
- en: Unmanaged constructed types
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未管理的构造类型
- en: By the end of this chapter, you will understand the use cases for using each
    of these features and be able to progressively adopt them in your listings. As
    always, the more you put these features into practice, the sooner you will master
    them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解使用每个功能的用例，并能够逐步在您的列表中采用它们。一如既往，您越多地将这些功能付诸实践，您就越快掌握它们。
- en: We will now start with a language feature that has the great ambition of reducing
    one of the primary causes of crashes in .NET-based applications—`NullReferenceException`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始介绍一种语言特性，它有着减少.NET应用程序中主要崩溃原因之一`NullReferenceException`的伟大抱负。
- en: Nullable reference types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: In the previous chapter, we learned that the type system in C# is split into
    **reference types** and **value types**. Value types are allocated on the stack
    and subject to memory copies every time they are assigned to a new variable. On
    the other hand, reference types are allocated on the heap, which is managed by
    the garbage collector. Every time we allocate a new reference type, we receive
    a reference acting as a key to identify the allocated memory back from the garbage
    collector.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到C#中的类型系统分为**引用类型**和**值类型**。值类型分配在堆栈上，并且每次分配给新变量时都会进行内存复制。另一方面，引用类型分配在堆上，由垃圾收集器管理。每当我们分配一个新的引用类型时，我们都会收到一个引用，作为标识分配的内存的关键，从垃圾收集器那里。
- en: The reference is essentially a pointer that can assume the special null value,
    which is the simplest, and therefore most popular, way to indicate the absence
    of a value. Remember, instead of using the null value, another solution is to
    adopt the special case architectural pattern, which, in its simplest form, is
    an instance of that object with a Boolean field indicating whether the object
    is valid, which is how `Nullable<T>` works. In many other cases, developers don't
    really need to use null values, the validation of which requires a remarkable
    amount of code that will affect runtime performance as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 引用本质上是一个指针，可以假定特殊的空值，这是指示值的缺失的最简单、因此最流行的方式。请记住，除了使用空值之外，另一个解决方案是采用特殊情况的架构模式，它的最简单形式是该对象的一个实例，其中包含一个布尔字段，指示对象是否有效，这就是`Nullable<T>`的工作原理。在许多其他情况下，开发人员实际上不需要使用空值，对其进行验证需要大量的代码，这将影响运行时性能。
- en: The problem with the null reference is that the compiler can't argue about potential
    problems because it is syntactically correct, but dereferencing it at runtime
    will lead to a `NullReferenceException`, which is the first cause for application
    crashes in the .NET world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用的问题在于编译器无法讨论潜在问题，因为它在语法上是正确的，但在运行时对其进行取消引用将导致`NullReferenceException`，这是.NET世界中应用程序崩溃的首要原因。
- en: 'Let''s consider for a moment a simple class with two constructors, where only
    the second one initializes the `_name` field:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时考虑一个简单的类，它有两个构造函数，只有第二个初始化了`_name`字段：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the first constructor is used, the `NameLength` property will cause a `NullReferenceException`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用第一个构造函数时，`NameLength`属性将导致`NullReferenceException`。
- en: 'In terms of tests, this is the code that highlights the following two cases:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方面，这是突出显示以下两种情况的代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The fundamental problem is that our code behavior depends on the values assumed
    at runtime, and obviously, the compiler cannot know if we will ever initialize
    the `_name` field after calling the default constructor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根本问题在于我们的代码行为取决于运行时的值，显然，编译器无法知道我们是否会在调用默认构造函数后初始化`_name`字段。
- en: Information box
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The null reference is a concept invented by Sir Tony Hoare in 1965\. However,
    in 2009, he regretted his invention, calling it *my billion-dollar mistak*[*e*
    (https://en.wikipedia.org/wiki/Tony_Ho](https://en.wikipedia.org/wiki/Tony_Hoare)are).
    As nulls cannot be easily removed from a framework, nullable reference types aim
    to resolve the problem using a code analysis approach.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用是由Tony Hoare爵士在1965年发明的概念。然而，2009年，他对自己的发明感到遗憾，称其为*我的十亿美元的错误*（https://en.wikipedia.org/wiki/Tony_Hoare）。由于无法轻松地从框架中删除空值，可空引用类型旨在使用代码分析方法解决这个问题。
- en: This concept is widespread in most programming languages, including all the
    ones in the .NET ecosystem. This means that any effort to remove the null concept
    from the framework would be a huge breaking change, potentially destroying current
    applications. What can the compiler do to resolve this problem? The answer is
    to undertake *static code analysis*, a technique used to understand the runtime
    behavior of the source code without running it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在大多数编程语言中都很普遍，包括.NET生态系统中的所有语言。这意味着任何试图从框架中移除空概念的努力都将是一个巨大的破坏性变化，可能会破坏当前的应用程序。编译器可以做什么来解决这个问题？答案是进行*静态代码分析*，这是一种在不运行代码的情况下了解源代码运行时行为的技术。
- en: Information box
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: In 2011, Microsoft started working on a revolutionary project called `Microsoft.CodeAnalysis`)
    is the ability to expose the APIs for all the processing normally done by the
    compilers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，微软开始着手进行一项名为`Microsoft.CodeAnalysis`的革命性项目，即公开为编译器通常完成的所有处理提供API。
- en: Traditionally, compilers are black boxes, but Roslyn makes it possible to programmatically
    parse the source code, get the syntax and semantic trees, use visitors to retrieve
    or rewrite specific nodes, and analyze the semantics of the source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，编译器是黑匣子，但Roslyn使得可以以编程方式解析源代码，获取语法和语义树，使用访问者检索或重写特定节点，并分析源代码的语义。
- en: You may have already seen static code analysis at work in Visual Studio when
    the yellow light bulb or the squiggles underneath some code suggest some refactoring
    or a potential issue in the editor. These abilities can be further extended by
    writing custom analyzers, distributed as Visual Studio extensions or in NuGet
    packages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员在编辑器中看到黄色灯泡或代码下方的波浪线建议进行一些重构或指出潜在问题时，他们可能已经看到了静态代码分析在Visual Studio中的工作。通过编写自定义分析器，这些能力可以进一步扩展，分发为Visual
    Studio扩展或NuGet包。
- en: 'Since static code analysis can''t know the value assumed by a reference at
    runtime, it just examines all the possible usage paths and tries to tell if one
    of those may dereference (using the dot or the square brackets) a null reference.
    But the analysis can suggest two different strategies, depending on whether it
    is desirable or not for the reference to assume the null value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态代码分析无法知道引用在运行时所假定的值，它只检查所有可能的使用路径，并尝试判断其中是否可能会取消引用（使用点或方括号）。但是分析可以提出两种不同的策略，取决于是否希望引用假定空值：
- en: We may want to prevent a reference from ever assuming the null value. In this
    case, the analyzer would suggest initializing at declaration or construction time
    and on any other following assignments.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能希望防止引用假定空值。在这种情况下，分析器将建议在声明或构造时进行初始化，并在任何后续赋值时进行初始化。
- en: We may need the reference to assume the null value. In this other case, the
    analyzer will verify that there is adequate null-checking code (an `if` statement
    or similar) to avoid any possible path that could dereference a null.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能需要引用假定空值。在这种情况下，分析器将验证是否有足够的空检查代码（`if`语句或类似的）来避免任何可能取消引用空值的路径。
- en: The choice between these two strategies is the developer's choice, who is called
    to provide additional information so that the compiler knows which feedback it
    should provide.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种策略之间的选择是开发人员的选择，开发人员需要提供额外的信息，以便编译器知道应该提供哪种反馈。
- en: 'The C# 8 nullable reference types feature ships the advanced static code analysis
    feature supporting both strategies, thanks to the ability to annotate the references
    to inform the compiler about the intended reference usage. For this purpose, the
    C# syntax has been extended to provide the ability to decorate the reference types
    as potentially nullable. Under this new rule, the string field declared in the
    previous sample class assumes that the reference cannot be null and must be initialized
    at construction time:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8可空引用类型功能支持两种策略的高级静态代码分析功能，这得益于能够注释引用以告知编译器有关预期引用使用的能力。为此，C#语法已经扩展，提供了装饰引用类型为可空的能力。根据这个新规则，在前面示例类中声明的字符串字段假定引用不为空，并且必须在构造时初始化：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When developers wants to give a hint to the compiler on the `_name` reference
    to potentially be null, they must declare it with a question mark decoration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员希望给编译器一个提示，使`_name`引用可能为空时，他们必须用问号装饰来声明它：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the question mark character as a decorator is not new; it was introduced
    in C# 2 to shorten the `Nullable<T>` declaration to `T?` and consisted of wrapping
    a *value type* into a structure using a Boolean field to know whether a value
    type is set to null.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用问号字符作为装饰符并不是新的；它在C# 2中引入，将`Nullable<T>`声明缩短为`T?`，并且包括将*值类型*包装到一个结构中，使用布尔字段来知道值类型是否设置为空。
- en: The question mark decoration for reference types is new in C# 8 and its meaning
    is similar, but no wrapper is involved. Instead, this decoration is just a way
    to inform the code analysis about the intended use of the reference.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的问号装饰在C# 8中是新的，其含义类似，但不涉及包装。相反，这种装饰只是一种通知代码分析有关引用预期使用的方式。
- en: By default, the code analysis is turned *off* because the existing applications
    always assumed that any reference could be null, and enabling it by default on
    the existing code would result in a large number of squiggles and compiler messages
    all over the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，代码分析是关闭的，因为现有的应用程序总是假定任何引用都可能为空，并且在现有代码上默认启用它将导致大量的波浪线和编译器消息遍布整个代码。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a reference is decorated with the question mark and the nullable reference
    types feature is not yet enabled, Visual Studio will squiggle the question mark
    in green, advising that the question mark functionality isn't in effect, as the
    feature is not active.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用用问号装饰，并且可空引用类型功能尚未启用时，Visual Studio会用绿色波浪线标记问号，建议问号功能尚未生效，因为该功能尚未激活。
- en: In addition to the question mark, C# adds the **forgiving operator**, represented
    by an *exclamation mark*, which is used to inform the code analysis to *forgive*
    a statement for that specific case. Using the forgiving operator is rare because
    it means the analysis has failed to recognize a case where the developer themselves
    knows the reference cannot be null. A realistic example of its usage is when some
    unsafe/native code changes the memory values pointed by a reference without any
    evidence in the managed code. In other very edge cases, the pure managed code
    can be so complex that the compiler fails to recognize it. I would personally
    opt to simplify the code instead of using the forgiving operator.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了问号外，C#还添加了**宽容运算符**，表示为*感叹号*，用于通知代码分析在特定情况下*宽容*一个语句。使用宽容运算符是很少见的，因为这意味着分析未能识别开发人员自己知道引用不可能为空的情况。其使用的一个现实例子是当一些不安全/本地代码改变了由引用指向的内存值，而托管代码中没有任何证据。在其他非常极端的情况下，纯托管代码可能非常复杂，编译器无法识别它。我个人会选择简化代码而不是使用宽容运算符。
- en: 'Remember that the *question mark* is used while declaring the *reference*,
    while the *exclamation mark* is used when *dereferencing* it. The following example
    shows a statement that will not be analyzed from the static code analysis and
    will not provide any feedback because the developer is making a strong promise
    that the reference will never be null:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在*声明*引用时使用*问号*，在*取消引用*时使用*感叹号*。以下示例显示了一个语句，该语句将不会从静态代码分析中进行分析，并且不会提供任何反馈，因为开发人员在强烈承诺引用永远不会为空：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is worth repeating that it should be used only in extremely rare cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申，它应该只在极其罕见的情况下使用。
- en: Enabling the nullable reference type feature
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用可空引用类型功能
- en: There are multiple options to enable this feature; the reason to do so is to
    be able to progressively adapt the feature on existing code without being blocked
    or receiving a huge amount of messages. Every time you start with a new project,
    you may want to fully enable this feature to avoid excessive annoyance by opening
    the Visual Studio solution explorer, double-clicking the project node, and editing
    the `.csproj` file. Alternatively, you can right-click the project node and select
    **Edit Project File** from the context menu.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种选项可以启用此功能；这样做的原因是能够逐步调整现有代码上的功能，而不会被阻塞或收到大量消息。每次启动新项目时，您可能希望完全启用此功能，以避免通过打开
    Visual Studio 解决方案资源管理器、双击项目节点并编辑`.csproj`文件而受到过多的干扰。或者，您可以右键单击项目节点，然后从上下文菜单中选择**编辑项目文件**。
- en: 'By adding the nullable XML tag, the feature will be enabled for the entire
    project, which is the best option when starting a new project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加可空的 XML 标记，该功能将在整个项目中启用，这是在启动新项目时的最佳选项：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can do the same on an existing project, but the amount of feedback provided
    by the compiler may be excessive, distracting the developer. For this reason,
    the C# compiler provides four new pragma directives, making it possible to enable
    and disable the feature for selected portions of the code. Interestingly, the
    restore pragma restores the previously defined setting to allow nesting of the
    pragma directives:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在现有项目上执行相同的操作，但编译器提供的反馈可能过多，会分散开发人员的注意力。因此，C#编译器提供了四个新的编译指示，可以在选定的代码部分启用和禁用该功能。有趣的是，restore编译指示可以恢复先前定义的设置，以允许编译指示的嵌套：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The range of possible settings for this feature enables some other nuances,
    depending on whether you want to be able to use the decorations (question and
    exclamation marks) and/or get the warnings on code that may potentially cause
    a `NullReferenceException`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的可能设置范围使其能够实现其他细微差别，具体取决于您是否希望能够使用修饰符（问号和感叹号），和/或在可能导致`NullReferenceException`的代码上获得警告：
- en: '**Enabling both the warnings and annotations**: This is done by just enabling
    the feature, as we mentioned previously. Under this rule, the code can be annotated
    with the question mark to hint to the compiler about the intended usage of the
    references. The code editor will show any potential problem and the compiler will
    generate warnings for those issues:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同时启用警告和注释**：这是通过仅启用该功能来完成的，正如我们之前提到的。根据此规则，可以使用问号对代码进行注释，以提示编译器有关引用的预期使用。代码编辑器将显示任何潜在问题，编译器将为这些问题生成警告：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Nullable` feature either on the whole project or on selected portions of the
    code:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable`功能可以在整个项目或选定的代码部分上使用：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Enabling only the annotations but not the compiler warnings**: When you are
    adopting this feature in existing projects, it can be very useful to start annotating
    the code without receiving any warning in the IDE or in the compiler output. It''s
    worth remembering that many companies enforce gated check-ins, rejecting any code
    producing warnings. In this case, it can be useful to enable the annotations project-wide,
    and enable the warnings file by file, to progressively migrate the code:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅启用注释而不启用编译器警告**：在现有项目中采用此功能时，可以非常有用地开始注释代码而不在IDE或编译器输出中收到任何警告。值得记住的是，许多公司强制执行门控检入，拒绝产生警告的任何代码。在这种情况下，可以在整个项目中启用注释，并逐渐逐个文件启用警告，以逐步迁移代码：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`NullReferenceException`:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullReferenceException`：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Restoring the previous settings in the code (only in code files)**: When
    using pragmas, it is always better to mark the end of a given region using a restore
    pragma, instead of an enable/disable, to make nested regions behave correctly:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在代码中恢复先前的设置（仅在代码文件中）**：在使用编译指示时，最好使用恢复编译指示标记给定区域的结束，而不是启用/禁用，以使嵌套区域正确运行：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Selectively disabling the settings (only in code files)**: The final setting
    is the one used to selectively disable either the annotations or the warnings
    in a given region of code. It is useful when you want to apply inverse logic,
    that is, enabling the feature for the whole project and disabling only selected
    portions of code:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性地禁用设置（仅在代码文件中）**：最终设置是用于有选择地在代码的给定区域禁用注释或警告的设置。当您希望应用逆逻辑时，即为整个项目启用该功能并仅禁用代码的选定部分时，这将非常有用：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This fine-grained ability to control the nullable reference types feature is
    very important when adopting this feature in existing projects. Outside that,
    you may find it simpler to just enable it project-wide.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有项目中采用此功能时，这种细粒度控制可空引用类型功能的能力非常重要。除此之外，您可能会发现在整个项目范围内启用它更简单。
- en: Working with nullable reference types
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可空引用类型
- en: 'Once enabled, the code analysis provides feedback in the code editor, which
    differs depending on whether the reference has been decorated with the question
    mark. The developer may choose not to decorate the variable, implying that the
    reference should never assume the null value. In this case, the declaration looks
    very familiar:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用，代码分析将在代码编辑器中提供反馈，具体取决于引用是否已用问号装饰。开发人员可以选择不装饰变量，这意味着引用永远不应假定为空值。在这种情况下，声明看起来非常熟悉：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the code analysis will squiggle the constructor code that is responsible
    for not initializing the string that, in the absence of the question mark, cannot
    be null. The remedies, in this case, are straightforward: you can either initialize
    the `_name` variable to an empty string or remove the default constructor, forcing
    all the callers to provide a non-nullable string at the creation of the object.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码分析将标记负责不初始化字符串的构造函数代码，如果没有问号，则该字符串不能为null。在这种情况下，补救措施很简单：您可以将`_name`变量初始化为一个空字符串，或者删除默认构造函数，强制所有调用者在创建对象时提供非空字符串。
- en: 'The other strategy is to declare the `_name` variable as nullable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是将`_name`变量声明为可空的：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code analysis will show the green squiggle when dereferencing the `Length`
    property. In this case, the solution is to explicitly check for `_name` being
    null and return an appropriate value (or throw an exception). This is a possible
    implementation for the property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当解除引用`Length`属性时，代码分析将显示绿色波浪线。在这种情况下，解决方案是显式检查`_name`是否为null，并返回适当的值（或引发异常）。这是属性的可能实现：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is an alternative and more elegant implementation of the same
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相同代码的另一种替代和更优雅的实现：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Annotating code is simple as it resembles the strategy already used with the
    nullable types, but with the arrays, the decoration is slightly more complex since
    there are two possible reference types in the game: the array itself and the items
    held in the array.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注释代码很简单，因为它类似于已经使用的可空类型的策略，但是对于数组，装饰略微复杂，因为游戏中存在两种可能的引用类型：数组本身和数组中保存的项目。
- en: 'An array of strings can be declared as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数组可以声明如下：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But remember, the more question marks we use, the more checks for null we need
    to do. Let''s consider this simple class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，我们使用的问号越多，我们需要做的空值检查就越多。让我们考虑这个简单的类：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Count` property is short only because we used a modern compact syntax,
    but it still contains a null check. `GetItemLength` returns the length of the
    *n*th item held in the array, and since both the arrays and the items could be
    null, two different null checks are required.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count`属性之所以短，仅因为我们使用了现代紧凑的语法，但它仍然包含了一个空值检查。`GetItemLength`返回数组中第n个项目的长度，由于数组和项目都可能为null，因此需要两个不同的空值检查。'
- en: If you are thinking to just return `string?` as the return type of the `GetItemLength`
    method, this solution will make the implementation code a bit shorter but all
    the callers will be forced to check for nulls, requiring even more code changes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是考虑将`GetItemLength`方法的返回类型设置为`string?`，这种解决方案将使实现代码变得更短，但所有调用者都将被迫检查空值，需要进行更多的代码更改。
- en: Migrating existing code to nullable reference types
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将现有代码迁移到可空引用类型
- en: Every project has its own characteristics, but from my personal experience,
    I've managed to identify a couple of best practices when migrating existing projects
    to this powerful feature.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有其自己的特点，但根据我的个人经验，我已经成功地确定了迁移现有项目到这一强大功能时的一些最佳实践。
- en: The first suggestion is to start enabling this feature from the project at the
    bottom of the dependency tree. In the project context, you may want to enable
    the analysis using pragma directives, starting from the most frequently used code
    files, such as helpers, extension methods, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建议是从依赖树底部的项目开始启用此功能。在项目上下文中，您可能希望使用编译指示开始启用分析，从最常用的代码文件开始，例如助手、扩展方法等。
- en: 'The second suggestion is to try avoiding the question mark: every time you
    decorate the reference with the question mark, the code analysis will require
    you to write some code to provide proof that a null dereferencing cannot occur,
    incrementing the amount of boilerplate code, which can affect the performance
    of the hot paths.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个建议是尝试避免使用问号：每次您用问号装饰引用时，代码分析都会要求您编写一些代码来证明空值解除引用不会发生，增加样板代码的数量，这可能会影响热路径的性能。
- en: Lastly, when you compile a library using this feature, the compiler will apply
    two hidden attributes to leave a track in the metadata about the nullability of
    the references used publicly in your code. Every time some code referencing your
    library is compiled, the compiler will know whether the library methods accept
    nullable references or not, assuming a not-nullable reference parameter only if
    the attribute specifically advertises that. It is therefore a best practice to
    use this feature on public libraries so that others can benefit from this metadata.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您使用这个功能编译一个库时，编译器会应用两个隐藏属性，以在元数据中留下关于代码中公开使用的引用的可空性的记录。每当编译引用您的库的一些代码时，编译器都会知道库方法是否接受可空引用，假设只有在属性明确宣传时才接受不可空引用参数。因此，在公共库中使用这个功能是最佳实践，这样其他人就可以从这些元数据中受益。
- en: The nullable reference types are very useful to decrease the amount of `NullReferenceException`
    exceptions at runtime, which is the primary cause for an application to crash.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型非常有用，可以减少运行时的`NullReferenceException`异常，这是应用程序崩溃的主要原因。
- en: While this feature is optional, it is very convenient to use pragma directives
    to progressively apply the small changes required for the code to be null-proof.
    This is a typical task that any team should add to its technical debts to improve
    code quality. In addition to that, library authors embracing this feature automatically
    provide the nullability metadata in their libraries, making the whole chain of
    references more stable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个功能是可选的，但使用编译指令逐渐应用所需的小改动以使代码具有空值保护是非常方便的。这是任何团队都应该将其技术债务添加到其中以提高代码质量的典型任务。除此之外，采用这一功能的库作者自动在其库中提供了可空性元数据，使整个引用链更加稳定。
- en: Default implementation of interface members
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口成员的默认实现
- en: We have already learned that interfaces are used to define a contract that every
    implementing type must fulfill. Every interface member defines a portion of the
    contract by specifying a name and its signature (input and output parameters).
    The implementation (or body) of the defined members are then provided by the concrete
    types implementing the interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到，接口用于定义每个实现类型必须满足的合同。每个接口成员通过指定名称和其签名（输入和输出参数）来定义合同的一部分。然后，具体类型实现接口提供了定义成员的实现（或主体）。
- en: 'With the *default implementation of interface members*, C# 8 widens the interface
    type syntax to include the following features:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*接口成员的默认实现*，C# 8扩展了接口类型语法，包括以下功能：
- en: Interfaces can now define bodies for *methods*, *properties*, *indexers*, and
    *events*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口现在可以为*方法*、*属性*、*索引器*和*事件*定义主体。
- en: Interfaces may declare *static members*, including *static constructors* and
    *nested types*.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以声明*静态成员*，包括*静态构造函数*和*嵌套类型*。
- en: They may explicitly specify visibility modifiers, such as *private*, *protected*,
    *internal*, and *public* (which continues to be the default).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以明确指定可见性修饰符，比如*private*、*protected*、*internal*和*public*（后者仍然是默认值）。
- en: They may also specify other modifiers, such as *virtual*, *abstract*, *sealed*,
    *extern*, and *partial*.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还可以指定其他修饰符，比如*virtual*、*abstract*、*sealed*、*extern*和*partial*。
- en: 'The syntax for this new feature is straightforward, as it is as simple as adding
    an implementation to a member:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能的语法很简单，就像给成员添加实现一样简单：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At first sight, adding implementations to the member of the interface looks
    contradictory. In fact, the preceding example demonstrates the syntax well, but
    it is certainly not a good design strategy. You may wonder what could be a good
    use case for defining a default implementation on interface members. The first
    reason is *interface versioning*, which has been traditionally very hard to manage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，给接口成员添加实现似乎是矛盾的。事实上，前面的例子很好地演示了语法，但这绝对不是一个好的设计策略。您可能会想知道定义接口成员默认实现的一个好用例是什么。第一个原因是*接口版本控制*，传统上很难管理。
- en: Interface versioning
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口版本控制
- en: 'As an example, let''s start from a classic interface, `IWelcome`, declaring
    two simple properties and a `Person` class to implement it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们从一个经典的接口`IWelcome`开始，声明两个简单的属性和一个`Person`类来实现它：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is now possible to add a new method with a default implementation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以添加一个具有默认实现的新方法：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The implementing class does not need to be updated. It can even reside in a
    different assembly without having any impact on the interface change.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类不需要更新。它甚至可以驻留在不同的程序集中，而不会对接口的更改产生任何影响。
- en: 'Since the implementation is provided by the interface and the class does not
    provide an implementation for the `Greet` method, it is still not accessible from
    a `Person` reference. In other words, the following declaration is not legal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现由接口提供，而类没有为`Greet`方法提供实现，因此仍然无法从`Person`引用中访问。换句话说，以下声明是不合法的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to invoke the default implementation, we need an `IWelcome` reference:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用默认实现，我们需要一个`IWelcome`引用：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The impact of this feature on a long-established interface is extremely important:
    for example, the `List<T>` class exposes the `AddRange` method, which is unfortunately
    not available in the `IList<T>` interface. After almost 20 years of applications
    relying on that interface, any change would be a huge breaking change.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能对于一个历史悠久的接口的影响非常重要：例如，`List<T>`类公开了`AddRange`方法，而在`IList<T>`接口中不可用。在几乎20年的应用程序依赖于该接口之后，任何更改都将是一个巨大的破坏性变化。
- en: What are the changes that could make sense on an interface? Removal of a member
    can be avoided by discouraging its usage via `ObsoleteAttribute` and maybe, a
    few versions later, it will start throwing `NotImplementedException`, without
    ever needing to remove that member from the interface.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接口上可能会发生什么变化？通过不鼓励使用`ObsoleteAttribute`来避免成员的使用，可以避免删除成员。也许几个版本之后，它将开始抛出`NotImplementedException`，而无需从接口中删除该成员。
- en: Changing a member is always a bad practice because interfaces are contracts;
    usually, the need for a change can be modeled by a new member with a different
    name and signature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 改变成员总是一个不好的做法，因为接口是契约；通常，对于变更的需求可以通过使用不同名称和签名的新成员来建模。
- en: Adding a new member is, therefore, the only true challenge because it breaks
    binary compatibility and forces a requirement change to every interface implementer.
    If the interface is very popular, for example, `IList<T>`, it is nearly impossible
    to add new members as it would break everybody's code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加新成员是唯一的真正挑战，因为它会破坏二进制兼容性，并迫使每个接口实现者更改要求。例如，如果接口非常受欢迎，比如`IList<T>`，几乎不可能添加新成员，因为这将破坏所有人的代码。
- en: Traditionally, the interface versioning problem has been solved by creating
    a new interface that extends the previous one, but this solution isn't that practical,
    since the adoption of the new interface requires the implementers to replace the
    old interface with the new one in their object inheritance declaration and, of
    course, implement the new members.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，接口版本问题是通过创建一个扩展先前接口的新接口来解决的，但这种解决方案并不实用，因为采用新接口需要实现者在对象继承声明中用新接口替换旧接口，并且当然要实现新成员。
- en: 'The default implementation in C# 8 does not behave the same way as a normal
    class implementation, as it defines the *baseline* implementation for that hierarchy.
    Let''s suppose you have a hierarchy of interfaces and a class defined as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8中的默认实现与普通类实现的行为不同，因为它为该层次结构定义了*基线*实现。假设您有一组接口层次结构和一个如下所示的类定义：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the current situation, the following assert is true:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，以下断言为真：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, fix the `ILabrador` default implementation and modify the interface, as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修复`ILabrador`的默认实现并修改接口，如下所示：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is worth noting that the `Noise` method must be redefined by specifying
    the full path: `IDog.Noise`. The reason for this is because .NET allows multiple
    inheritances with interfaces; therefore, in a more complex inheritance structure,
    there could be more than a single path leading to the `Noise` method.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，必须通过指定完整路径`IDog.Noise`来重新定义`Noise`方法。原因是因为.NET允许接口进行多重继承；因此，在更复杂的继承结构中，可能会有多条路径导致`Noise`方法。
- en: The syntax, therefore, requires specifying the full path to overcome this potential
    ambiguity. If the compiler finds any ambiguity that cannot be resolved by just
    specifying the full path, it will generate an explicit error.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，语法要求指定完整路径以克服潜在的歧义。如果编译器发现无法通过指定完整路径解决的歧义，它将生成显式错误。
- en: 'The default implementation of `ILabrador` redefines the baseline implementation
    of `Noise` in `IDog`. This means that, even if we are using an `IDog` reference,
    the change in `ILabrador` will affect the result, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILabrador`的默认实现重新定义了`IDog`中`Noise`的基线实现。这意味着，即使我们使用的是`IDog`引用，`ILabrador`中的更改也会影响结果，如下所示：'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Furthermore, you may have noticed in the comments of the preceding sample that
    the interfaces and the class lie in two different assemblies. If the first assembly
    containing `ILabrador` is recompiled with the new member and the second assembly
    is instead untouched, you will still see `Noise` being updated to `woofs`. This
    means that patching the first assembly will cause all the applications to benefit
    from the update, even without recompiling the whole code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能已经注意到在前面示例的注释中，接口和类位于两个不同的程序集中。如果包含`ILabrador`的第一个程序集重新编译并添加了新成员，而第二个程序集保持不变，您仍将看到`Noise`被更新为`woofs`。这意味着修补第一个程序集将使所有应用程序受益于更新，即使不重新编译整个代码。
- en: Interface reabstraction
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口重新抽象
- en: The ability to redefine the default implementation from a derived interface
    is fundamental to understanding reabstraction. The principle is the same, but
    the deriving interface may decide to *erase* the default interface implementation,
    marking the member as abstract.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从派生接口重新定义默认实现的能力对于理解重新抽象是至关重要的。原则是相同的，但派生接口可以决定*擦除*默认接口实现，将成员标记为抽象。
- en: 'Going on with the previous example, we could define the following interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上面的例子，我们可以定义以下接口：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But this time, the implementers of the new interface are required to implement
    the `Noise` method as well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这次，新接口的实现者需要实现`Noise`方法：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This capability is useful because the default implementation was written to
    provide the best possible implementation that can be commonly used by all the
    types in the hierarchy. But there is a possibility that a branch of those types
    does not fit well with that implementation and you want to erase it at the interface
    level to avoid any misbehavior.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力很有用，因为默认实现是为了提供最佳实现，可以被层次结构中所有类型通用使用。但是，这些类型中的某个分支可能与该实现不太匹配，您希望在接口级别上擦除它以避免任何不当行为。
- en: Interfaces as traits
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口作为特质
- en: Treating the concept of trait composition in detail would require an entire
    chapter, but it is worth noting that C# 8 has only just opened the door to traits,
    leaving future versions of the language with the opportunity to fill the gaps,
    as you can read in the design notes of the C# language public repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 详细讨论特质组合的概念需要一个完整的章节，但值得注意的是，C# 8刚刚打开了特质的大门，让语言的未来版本有机会填补空白，您可以在C#语言公共存储库的设计说明中阅读到相关内容。
- en: '**Trait composition** is a concept that''s well known in other languages such
    as C++. It involves the ability to define a set of members for determining a well-known
    behavior. The goal is defining different types (traits) with the goal to give
    any class the ability to compose its own behavior by just inheriting the traits.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**特质组合**是其他语言（如C++）中众所周知的概念。它涉及定义一组成员以确定一个众所周知的行为。目标是定义不同类型（特质），以便任何类都能通过继承特质来组合自己的行为能力。'
- en: Before this release of the language, we used to create static helper classes
    to define a set of reusable behaviors. In C# 8, we can define those members inside
    the interfaces so that they can be reused by just inheriting the interfaces. The
    choice of interfaces is very convenient because .NET supports multiple inheritances
    only on interfaces, allowing multiple traits to be inherited in a new class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语言的发布之前，我们通常会创建静态帮助类来定义一组可重用的行为。在C# 8中，我们可以将这些成员定义在接口内，这样它们可以通过继承接口来重用。接口的选择非常方便，因为.NET只支持接口上的多重继承，允许多个特质被继承到一个新的类中。
- en: If you are going to experiment with traits, try to model them without thinking
    about the classical interface usage; rather, look at them for their intrinsic
    ability to open to multiple inheritances and thus compose a set of methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要尝试使用特质，试着在不考虑经典接口用法的情况下对其进行建模；相反，看看它们固有的能力，能够打开到多重继承，从而组合一组方法。
- en: Traits are usually very useful when the availability of the behaviors you need
    to compose is very dependent on each class that you are going to define. In terms
    of design, this would translate into either a very long list of interfaces, each
    one defining a single behavior, or a single interface with many objects implementing
    part of its methods by throwing `NotImplementedException`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 特质通常在你要定义的每个类的行为的可用性非常依赖于每个类时非常有用。在设计方面，这将转化为一个非常长的接口列表，每个接口定义一个单一的行为，或者一个单一的接口，许多对象通过抛出`NotImplementedException`来实现其部分方法。
- en: 'Let''s try to look at a very simple example where you want to expose an alphabet
    transliteration service to your application. There are multiple ways to achieve
    this: either with the Windows native APIs, a NuGet library, or a cloud service.
    We could be tempted to define a single interface with a long list of methods supporting
    all the possible permutations from one alphabet to another, but it would not be
    very practical because each of those libraries or services supports only a part
    of all the possible transliterations. This would result in many implementations
    throwing `NotImplementedException`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着看一个非常简单的例子，你想要向你的应用程序公开一个字母转换服务。有多种实现方法：使用Windows本机API、一个NuGet库或一个云服务。我们可能会尝试定义一个单一的接口，其中包含支持从一个字母表到另一个字母表的所有可能排列的长列表方法，但这并不是很实用，因为这些库或服务只支持所有可能的转换的一部分。这将导致许多实现抛出`NotImplementedException`。
- en: Another approach would be to define one interface for each possible transliteration,
    but the class implementing these interfaces would need to redirect the member
    implementation to some external helper class that calls the appropriate library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是为每种可能的转换定义一个接口，但实现这些接口的类需要将成员实现重定向到调用适当库的外部帮助类。
- en: 'The traits solution looks a bit simpler because it just models what we can
    do. For example, here, there are two possible transliteration interfaces:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 特质解决方案看起来更简单一些，因为它只是模拟我们可以做什么。例如，在这里，有两种可能的转换接口：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'They are still interfaces, but the class that needs the common implementation
    can add the interface to the inheritance list, without anything else:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仍然是接口，但需要共同实现的类可以将接口添加到继承列表中，而无需其他任何操作：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, in order to make the consumer''s life easier, the class could expose
    a switch expression using pattern matching to invoke the try transliteration to/from
    a given alphabet and return the computed result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了让消费者的生活更加便利，该类可以暴露一个使用模式匹配的开关表达式，以调用尝试转换成/从给定字母表的转换，并返回计算结果：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code tries to transliterate the text with all the available services, and
    if one of them is implemented by the class, a conversion is tried. As soon as
    the phrase can be converted (that is, the conversion result is different from
    the input), it is returned to the caller.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码尝试使用所有可用的服务对文本进行转换，如果其中一个服务由类实现，就尝试进行转换。一旦短语可以转换（即，转换结果与输入不同），就将其返回给调用者。
- en: Default interface implementations in interfaces are a valuable feature for all
    pragmatists. Java and Swift are examples of programming languages that already
    support this feature. If you are a library developer needing to port your code
    across multiple languages, it will make your life easier and avoiding re-architecting
    portions of code to overcome its absence in previous versions of the language.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的默认接口实现对所有实用主义者来说都是一个有价值的功能。Java和Swift是已经支持这一功能的编程语言的例子。如果你是一个需要将你的代码移植到多种语言的库开发人员，它将使你的生活更加轻松，并避免重新设计代码的部分来克服它在语言先前版本中的缺失。
- en: As always, the recommendation is to use the default implementation with wisdom.
    It would not be useful if the use case already fit well with the previous tools
    and patterns.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，建议明智地使用默认实现。如果用例已经很好地适应了以前的工具和模式，那么它就不会有用。
- en: 'A fun edge case of the default implementation is that you can now define the
    entry point of your application with the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现的一个有趣的边缘情况是，现在你可以用以下代码定义你的应用程序的入口点：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The default interface members are a controversial feature leveraging the intrinsic
    capability of the .NET interfaces to support multiple inheritance. The pragmatist
    should appreciate the practical use cases justifying this little revolution, while
    the others can just continue using the interfaces as they always did before.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口成员是一个具有争议性的功能，利用了.NET接口支持多重继承的固有能力。实用主义者应该欣赏这个小革命所证明的实际用例，而其他人可以继续像以前一样使用接口。
- en: We can now move on to the next feature, which should help in avoiding some headaches
    and `IndexOutOfRangeException` exceptions when slicing arrays and lists.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续下一个功能，这应该有助于避免在切片数组和列表时出现一些头痛和`IndexOutOfRangeException`异常。
- en: Ranges and indices
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围和索引
- en: Another convenient functionality introduced in C# 8 is the new syntax to identify
    single elements or ranges inside a sequence. The language already offers the ability
    to get or set elements in an array using the square brackets and a numeric index,
    but this concept has been extended by adding two operators to identify an item
    from the end of a sequence and to extract a range between two indices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8中引入的另一个方便的功能是用于标识序列中单个元素或范围的新语法。语言已经提供了使用方括号和数字索引在数组中获取或设置元素的能力，但通过添加两个运算符来标识从序列末尾获取项目和提取两个索引之间的范围，这个概念已经得到了扩展。
- en: 'In addition to the aforementioned operators, the base class library now offers
    two new system types, `System.Index` and `System.Range`, which we will immediately
    see in action. Let''s consider an array of strings containing six country names:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述运算符之外，基类库现在还提供了两种新的系统类型，`System.Index`和`System.Range`，我们将立即看到它们的作用。让我们考虑一个包含六个国家名称的字符串数组：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We already know how to use the numeric indexer to get a reference to the first
    item:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用数字索引器来获取对第一个项目的引用：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The new `System.Index` type is just a convenient wrapper for the numeric index
    that can be directly used on the arrays:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`System.Index`类型只是一个方便的包装器，可以直接用于数组上：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The interesting part is when we need to address the item starting from the
    end of the sequence:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是当我们需要从序列末尾开始处理项目时：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The new `^` operator provides us with a succinct and effective way to get the
    last item:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`^`运算符为我们提供了一种简洁而有效的方法来获取最后一个项目：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It is very important to note that, while zero is the first index when counting
    from the beginning, it points to one item beyond the total length when counting
    from the end. This means that the `[^0]` expression will always throw `IndexOutOfRangeException`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，从开始计数时零是第一个索引，但从末尾计数时，它指向总长度之外的一个项目。这意味着`[^0]`表达式将始终抛出`IndexOutOfRangeException`：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When it comes to ranges, the value of the new syntax is more evident, since
    it is a brand new concept that never existed before in the language or in the
    base class library. The new`..` operator delimits two indices that are used to
    identify a range. The delimiters on the left and the right of the operator can
    be also omitted whenever the items at the boundaries should be skipped.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及范围时，新语法的价值更加明显，因为它是一种全新的概念，在语言或基类库中以前从未存在过。新的`..`运算符界定了两个用于标识范围的索引。运算符左侧和右侧的界定符也可以省略，无论何时都应该跳过边界处的项目。
- en: 'The following example shows three ways to specify all the items in an array:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了指定数组中所有项目的三种方式：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `expected` variable just gets a clone of the countries array and the convenient
    `SequenceEqual` Linq extension method returns true when the items in the two sequences
    are identical and are ordered the same. The previous example is not very useful,
    but highlights the semantics at the boundaries: the *left* boundary is always
    *inclusive*, while the *right* boundary is always *exclusive*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`expected`变量只是获得了国家数组的克隆，方便的`SequenceEqual` Linq扩展方法在两个序列中的项目相同且排序相同时返回true。前面的示例并不是很有用，但突出了边界的语义：*左*边界始终是*包含*的，而*右*边界始终是*排除*的。'
- en: 'The following example is more realistic and shows three different ways to specify
    a range that just skips the first item of the sequence:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例更加现实，并展示了指定范围的三种不同方式，只跳过序列的第一个项目：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, the following example shows how to skip the last item in the sequence:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下示例展示了如何跳过序列中的最后一个项目：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Putting everything together is straightforward, and the following example shows
    how to skip both the first and the last element of the sequence:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起很简单，以下示例展示了如何跳过序列的第一个和最后一个元素：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The range syntax to specify the starting and the ending indices can start counting
    from the start or the end. In the following example, the sliced array will return
    just the second and the third element, both counted from the beginning:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 指定起始和结束索引的范围语法可以从开始或末尾开始计数。在以下示例中，切片的数组将只返回第二个和第三个元素，都是从开始计数的：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, the same is valid when counting from the end, which is the goal
    of the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当从末尾计数时，同样有效，这是以下示例的目标：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This syntax is very simple, but you may have noticed that we only made use
    of arrays, which, as well as strings, are treated as special by C#. In fact, if
    we try to use this same syntax with a `List<T>`, it won''t work, since there are
    no members that know what `Index` and `Range` are:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法非常简单，但您可能已经注意到，我们只使用了数组，以及字符串，它们在C#中被视为特殊。事实上，如果我们尝试在`List<T>`中使用相同的语法，它将无法工作，因为没有成员知道`Index`和`Range`是什么：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The question now is, how can we make the following test pass? There are three
    different ways to make it compile and work. The first one is straightforward and
    consists of providing an indexer that takes a `System.Range` as a parameter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何使以下测试通过？有三种不同的方法可以使其编译并工作。第一种方法很直接，就是提供一个接受`System.Range`作为参数的索引器：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `List<T>` base class provides the indexer taking an integer, while `MyList<T>`
    adds an overload taking a `Range` type, which is used from C# 8 as an alias of
    the `..` syntax. In the new indexer, we use `Range.GetOffsetAndLength`, a very
    convenient method that returns a tuple with the initial index and the length of
    the sequence to slice. Finally, the `List<T>.GetRange` base method provides the
    sliced sequence used to create the new `MyList<T>` collection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`基类提供了一个接受整数的索引器，而`MyList<T>`添加了一个接受`Range`类型的重载，它在C# 8中作为`..`语法的别名使用。在新的索引器中，我们使用`Range.GetOffsetAndLength`，这是一个非常方便的方法，它返回一个元组，其中包含切片的初始索引和长度。最后，`List<T>.GetRange`基本方法提供了用于创建新的`MyList<T>`集合的切片序列。'
- en: 'Another possible solution to make the previous test pass is to take advantage
    of the special `Slice` method with which the C# 8 compiler searches *by pattern*.
    In the absence of the indexer that we wrote before, if the compiler finds a method
    called `Slice` that takes two integers, it *remaps* the range syntax to a call
    to the `Slice` method. As a result, the following code is neater and simpler to
    read:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使先前的测试通过的可能解决方案是利用特殊的`Slice`方法，C# 8编译器会通过模式搜索。在我们之前编写的索引器不存在的情况下，如果编译器找到一个名为`Slice`的方法，该方法接受两个整数，它会将范围语法重新映射为对`Slice`方法的调用。因此，以下代码更整洁，更易于阅读：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Please note that any call with a range syntax such as `countries[1..^1]` will
    invoke the `Slice` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何使用范围语法的调用，如`countries[1..^1]`，都将调用`Slice`方法。
- en: This solution is nice but can't solve the problem of the popular `List<T>` class,
    a class that can be found almost everywhere in the code, especially because the
    Linq extension method known as `ToList()` returns an `IList<T>`. Writing a `Slice`
    extension method will not work because the compiler looks for `Slice` among the
    instance methods, while extension methods are static.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案很好，但无法解决流行的`List<T>`类的问题，这个类几乎可以在代码的任何地方找到，特别是因为Linq扩展方法`ToList()`返回一个`IList<T>`。编写一个`Slice`扩展方法是行不通的，因为编译器会在实例方法中寻找`Slice`，而扩展方法是静态的。
- en: 'The solution is to write an extension method taking a `Range`, as shown in
    the following example. This time, the countries reference is any collection inheriting
    `ICollection<T>` and supports slicing with the nice syntax of `countries.Slice(1..^1)`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是编写一个接受`Range`的扩展方法，如下例所示。这次，`countries`引用是任何继承`ICollection<T>`并支持使用`countries.Slice(1..^1)`的漂亮语法进行切片的集合：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In all the previous examples, we explicitly created `Index` and `Range` using
    their constructors, but I would recommend taking some time to explore the convenient
    static factories provided by the `Index` and `Range` classes, such as `Range.All()`
    or `Index.FromEnd()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有先前的例子中，我们都是使用它们的构造函数显式创建了`Index`和`Range`，但我建议花一些时间探索`Index`和`Range`类提供的便捷静态工厂，比如`Range.All()`或`Index.FromEnd()`。
- en: Ranges and indices provide powerful and expressive operators and types to simplify
    the selection of single or multiple items in a sequence. The main purpose is to
    make the code more readable and less prone to errors without impacting the performance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 范围和索引提供了强大且表达力强的运算符和类型，以简化序列中单个或多个项目的选择。其主要目的是使代码更易读，减少错误，而不影响性能。
- en: The most important advice on ranges to remember is that boundaries are inclusive
    only on the left side of the range.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于范围的最重要建议是，范围的边界只在范围的左侧是包含的。
- en: Pattern matching
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching was introduced in C# 7, but version 8 of the language specification
    widens its usage by smoothing the syntax and making it more compact and readable.
    This chapter will avoid repeating the features already seen in the previous versions
    and just focus on the new concepts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是在C# 7中引入的，但语言规范的第8版通过平滑语法和更紧凑可读的方式扩大了其使用范围。本章将避免重复之前版本中已经看到的功能，只专注于新概念。
- en: 'The popular `switch` statement has evolved in C# to become an *expression*
    with a very fluent syntax. For example, suppose you are reading the console keys
    in an application using the `Console.ReadKey` method to get the colors matching
    the `R`, `G`, and `B` characters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的`switch`语句在C#中已经发展成为一个具有非常流畅语法的*表达式*。例如，假设您正在使用`Console.ReadKey`方法读取应用程序中的控制台键，以获取与`R`、`G`和`B`字符匹配的颜色：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Or, if you prefer an even more compact version, we could write this as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您更喜欢更紧凑的版本，我们可以这样写：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `switch` expression is not semantically changed from the previous innovations
    of C# 7 pattern matching; rather, it has become simpler and more compact with
    some important things to highlight:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`表达式在语义上与C# 7模式匹配的先前创新没有改变；相反，它变得更简单，更紧凑，有一些重要的事情需要强调：'
- en: As an expression, the `switch` statement must return a value (the `Color` enumeration
    in our sample).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为表达式，`switch`语句必须返回一个值（在我们的示例中是`Color`枚举）。
- en: The discard character `(_)` replaces the `default` keyword in the classical
    `switch` statement.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弃用字符`(_)`取代了经典`switch`语句中的`default`关键字。
- en: The subexpressions mapping the keys to the colors are evaluated in order, where
    the first match wins and exits.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将键映射到颜色的子表达式按顺序进行评估，第一个匹配就会退出。
- en: 'Things can get even more interesting when using the switch expression to match
    types, as shown in the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`switch`表达式匹配类型时，事情可能变得更加有趣，如下例所示：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This method takes an unknown object as input and returns a string that is formatted
    differently depending on its runtime type, which must match with the exact type.
    For example, `GetString((Int16)1)` will not match nor return the string `Fallback:
    1`. Another failed matching is `GetString(10.6m)` because the literal is a decimal
    and the returned string will be `Fallback: 10.6`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '这个方法接受一个未知对象作为输入，并返回一个根据其运行时类型格式化不同的字符串，该类型必须与确切的类型匹配。例如，`GetString((Int16)1)`将不匹配，也不会返回字符串`Fallback:
    1`。另一个失败的匹配是`GetString(10.6m)`，因为字面量是十进制，返回的字符串将是`Fallback: 10.6`。'
- en: Before C# 7, testing the type identity on value or reference types was pretty
    cumbersome because it required a second step to either cast the value type to
    the desired type or a null-check conditional operation for the reference types.
    Thanks to C# 7, we learned to use `is` pattern matching, which is perfect when
    checking a single type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7之前，对值类型或引用类型进行类型识别测试非常麻烦，因为它需要第二步，要么将值类型转换为所需类型，要么对引用类型进行空检查条件操作。多亏了C#
    7，我们学会了使用`is`模式匹配，当检查单个类型时非常完美。
- en: 'With the new C# 8 syntax, the resulting code is more succinct and less error-prone,
    with a number of advantages:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的C# 8语法，生成的代码更加简洁，更不容易出错，具有许多优点：
- en: Not having to care about null references in every case, which has the positive
    effect of being a better candidate for the method to be inlined by the **Just-in-time
    Compiler** (**JIT**), resulting in better performance.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每种情况下都不必担心空引用，这对于方法成为**即时编译器**（**JIT**）内联的更好候选者有积极的影响，从而提高性能。
- en: The evaluation respects the order, which is very useful when testing type hierarchies.
    In our example, it is fundamental to evaluate the `Derived` class before `Base`,
    because otherwise the `switch` expression would always match `Base`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估遵循顺序，这在测试类型层次结构时非常有用。在我们的例子中，评估`Derived`类在`Base`之前是至关重要的，否则`switch`表达式将始终匹配`Base`。
- en: Explicitly capturing the nulls in *null case* captures avoids any conditional
    expression.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式捕获*null case*中的空值避免了任何条件表达式。
- en: The `switch` expression is very powerful, but the improvements to pattern matching
    are not over yet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`表达式非常强大，但模式匹配的改进还没有结束。'
- en: Recursive pattern matching
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归模式匹配
- en: 'Pattern matching has been extended to allow drilling down into object properties
    and tuples. The syntax at the base of this improvement consists of the ability
    to specify an expression between curly braces after a pattern:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配已经扩展，允许深入到对象属性和元组中。这一改进的基础语法包括在模式后的花括号中指定表达式的能力：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The expression inside the curly braces can only specify properties and must
    make use of constant literals. This allows us to match the type and, at the same
    time, evaluate its properties possibly recurring over subexpressions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号内的表达式只能指定属性，并且必须使用常量文字。这使我们能够匹配类型，并同时评估其属性，可能会在子表达式中重复。
- en: 'The true power comes into play when we need to evaluate objects structured
    in a graph, like in the following two `Customer` property of the `Order` class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要评估以图形结构化的对象时，真正的力量就会发挥作用，就像在`Order`类的两个`Customer`属性中一样。
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s suppose we''re working on an e-commerce application where the discount
    depends on the order properties:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在开发一个电子商务应用程序，其中折扣取决于订单属性：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, the first subexpression reassigns the reference to the `o` variable whose
    `Quantity` property, thanks to the `when` clause, is then evaluated. If `o.Quantity
    > 100` is satisfied, a 7.5% discount is returned.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个子表达式重新分配了对`o`变量的引用，然后通过`when`子句评估了`Quantity`属性。如果满足`o.Quantity > 100`，则返回7.5%的折扣。
- en: In the second case, when `Order.IsMadeOnWeb` is true, a good 5% discount is
    returned. The third case evaluates the property obtained by navigating `Order.Customer.Country`,
    returning a 2% discount just because the order originates from Italy. Finally,
    the discard character represents the fallback to zero discount.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当`Order.IsMadeOnWeb`为真时，返回5%的折扣。第三种情况评估了通过导航`Order.Customer.Country`获得的属性，仅因为订单来自意大利，返回2%的折扣。最后，丢弃字符表示回退到零折扣。
- en: The syntax with the properties is great, but things get a bit more complicated
    when it comes to tuples because you may want to match a single tuple item, as
    well as multiple ones, and their position is also fundamental.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的语法很棒，但是当涉及元组时，情况会变得更加复杂，因为您可能希望匹配单个元组项，以及多个元组项，它们的位置也是至关重要的。
- en: 'Let''s consider, for example, a simple `Point` struct with, not surprisingly,
    two integer properties of `X` and `Y`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的`Point`结构，其中有两个整数属性`X`和`Y`：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'How can we write a method that returns whether the point lies on the horizontal
    or vertical axis? The condition is satisfied if either `X` or `Y` is zero; therefore,
    a possible approach is doing the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写一个方法，返回点是否位于水平轴或垂直轴上？如果`X`或`Y`为零，则满足条件；因此，一个可能的方法是这样做：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Traditionally, we would write this method with one `if` using an `or` operator,
    but the more the parameters come into play, the more unreadable the code becomes.
    An interesting point of the previous example is that we built a tuple on the fly
    and evaluated it inside the `switch` expression, matching the parameters by their
    position and discarding (with the `_` character) the ones that were not relevant
    to the evaluation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们会使用一个`if`和一个`or`运算符来编写这个方法，但是参数越多，代码就变得越难读。前面例子的一个有趣的地方是，我们动态构建了一个元组，并在`switch`表达式中对其进行了评估，通过它们的位置匹配参数，并丢弃（使用`_`字符）与评估无关的参数。
- en: 'Things get even more interesting when writing the special `Deconstruct` method
    in the `Point` structure, as it simplifies the tuple''s creation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写`Point`结构中的特殊`Deconstruct`方法时，情况变得更加有趣，因为它简化了元组的创建：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When using tuples in a `switch` expression, there is space for getting more
    power by evaluating its values using the `when` clause.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`表达式中使用元组时，通过使用`when`子句评估其值，可以获得更多的功能。
- en: 'In the following example, we use the `when` clause to identify the diagonal
    positions in addition to the axis. For this purpose, we define the `SpecialPosition`
    enumerator and use the `switch` expression together with the `when` clause to
    match the diagonals:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用`when`子句来识别对角线位置，除了轴。为此，我们定义了`SpecialPosition`枚举器，并使用`switch`表达式以及`when`子句来匹配对角线：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Pattern matching gained a lot of power over the last two versions of the language
    and now allows the developer to focus on the important parts of the code without
    being distracted by the boilerplate code required by the previous language rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配在过去两个语言版本中获得了很大的力量，现在允许开发人员专注于代码的重要部分，而不会被以前语言规则所需的样板代码分散注意力。
- en: The `switch` expression is specifically suited for all those expressions whose
    outcome can be derived from multiple choices, should the evaluation need to dig
    into an object graph or evaluate tuples. The powerful discard character allows
    partial evaluations, avoiding code that is often complex and prone to errors.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`表达式特别适用于那些结果可以从多个选择中得出的表达式，如果评估需要深入到对象图或评估元组。强大的丢弃字符允许部分评估，避免了通常复杂且容易出错的代码。'
- en: The using declaration
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: using声明
- en: 'The `using` declaration is a very convenient syntax equivalent to the `try/finally`
    block and provides a deterministic call to the `Dispose` method. This declaration
    can be used on all the objects implementing the `IDisposable` interface:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`声明是一个非常方便的语法，相当于`try/finally`块，并确定性地调用`Dispose`方法。这个声明可以用于所有实现`IDisposable`接口的对象：'
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We already know that the `using` declaration deterministically invokes the
    `Dispose` method as soon as its closing curly brace is encountered:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，`using`声明在遇到其闭合大括号时会确定性地调用`Dispose`方法：
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Every time multiple disposable objects need to be used in the same scope, the
    nested `using` declarations are nested, causing an annoying triangle-shaped code
    alignment:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要在同一作用域中使用多个可释放对象时，嵌套的`using`声明会导致令人讨厌的三角形代码对齐：
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This annoyance can be finally removed if it is fine for the `Dispose` method
    to be called at the end of the current block (the closed curly brace), no matter
    whether the block is a statement (such as a `for`/`if`/…) or the current method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Dispose`方法在当前块（闭合大括号）的末尾被调用，无论该块是一个语句（如`for`/`if`/…）还是当前方法，这种烦恼最终可以被消除。
- en: 'The new syntax in C# 8 allows us to entirely remove the curly braces from the
    `using` declarations, transforming the previous example into the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8中的新语法允许我们完全删除`using`声明中的大括号，将前面的示例转换为以下形式：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first curly brace closing the current block will automatically trigger the
    three `Dispose` methods in the inverse order of declaration. But there is more
    to cover about `Dispose`; in fact, this compact syntax is also valid for the `async
    using` declaration, which will be covered in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当前块的第一个闭合大括号将自动触发三个`Dispose`方法，按照声明的相反顺序。但关于`Dispose`还有更多内容要讨论；事实上，这种紧凑的语法也适用于`async
    using`声明，这将在下一节中介绍。
- en: Asynchronous Dispose
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步Dispose
- en: After the advent of Tasks in .NET, most of the libraries managing I/O operations
    progressively moved to an asynchronous behavior. For example, the `System.Net.Websocket`
    class members embrace the Task-based programming strategy, providing a better
    developer experience and more efficient behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中引入Tasks之后，大多数管理I/O操作的库逐渐转向异步行为。例如，`System.Net.Websocket`类成员采用基于任务的编程策略，提供更好的开发人员体验和更高效的行为。
- en: Every time a developer needs to write a C# client to access some service based
    on the WebSocket protocol, they typically write a wrapper class exposing specialized
    *send* methods and implementing the dispose pattern to invoke the `Websocket.CloseAsync`
    method. We also know that any asynchronous method should return a `Task`, but
    the Dispose method has been defined as void far before the `Task` era, and therefore
    doesn't fit well in the `Task` chain.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每当开发人员需要编写一个C#客户端来访问基于WebSocket协议的某些服务时，他们通常会编写一个包装类，公开专门的*send*方法，并实现释放模式以调用`Websocket.CloseAsync`方法。我们也知道任何异步方法都应该返回一个`Task`，但是Dispose方法在`Task`时代之前就已经定义为void，因此不太适合`Task`链中。
- en: The Websocket example is very realistic as I had this exact problem some time
    ago, where blocking the current thread to wait for the CloseAsync to finish inside
    the Dispose caused a deadlock.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Websocket示例非常现实，因为我曾经遇到过这个确切的问题，即在Dispose内部阻塞当前线程等待CloseAsync完成会导致死锁。
- en: 'Starting from C# 8 and .NET Core 3.0, we now have two important tools:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 8和.NET Core 3.0开始，我们现在有两个重要的工具：
- en: The `IAsyncDisposable` interface defined in .NET Core 3, returning a lightweight
    `ValueTask` type
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET Core 3中定义的`IAsyncDisposable`接口，返回轻量级的`ValueTask`类型
- en: The `await using` construct leveraging the new `AsyncDisposable` interface
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用新的`AsyncDisposable`接口的`await using`构造
- en: 'Let''s see how to use those in code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在代码中使用它们：
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It is worth remembering that the `await using` declaration benefits from succinct,
    single-line syntax, as we discussed previously:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，`await using`声明受益于简洁的单行语法，正如我们之前讨论的那样：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you are a library author exposing a disposable type, you can implement either
    one of the two, or even both the `IDisposable` and `IAsyncDisposable` interfaces.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个公开可释放类型的库作者，您可以实现这两种接口中的任何一种，甚至同时实现`IDisposable`和`IAsyncDisposable`接口。
- en: Disposable patterns in structs and ref structs
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体和ref结构中的可释放模式
- en: Over time, C# introduced some *pattern-based* constructs to resolve issues deriving
    from rules that could not be applied in every circumstance. This happens, for
    example, with the `foreach` statement not requiring an object to implement the
    `IEnumerable<>` interface, instead just relying on the presence of the `GetEnumerator`
    method, and similarly the object returned by `GetEnumerator` not needing to implement
    `IEnumerator` but just exposing the required members instead.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，C#引入了一些*基于模式*的构造来解决由于规则无法在每种情况下应用而导致的问题。例如，`foreach`语句不需要对象实现`IEnumerable<>`接口，而只需依赖于`GetEnumerator`方法的存在，同样，`GetEnumerator`返回的对象不需要实现`IEnumerator`，而只需公开所需的成员即可。
- en: This change was driven by the recent introduction of the `ref structs`, which
    are important for diminishing the pressure on the garbage collector as they are
    guaranteed to live only on the stack but do not allow the implementation of interfaces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化是由最近引入的`ref结构`驱动的，它对减少垃圾收集器的压力很重要，因为它们保证只在堆栈上存在，但不允许实现接口。
- en: The pattern-based approach has now been extended to the `Dispose` and `DisposeAsync`
    methods under certain conditions that we are going to discuss now.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模式的方法现在已经在特定条件下扩展到了`Dispose`和`DisposeAsync`方法，我们现在将讨论这些条件。
- en: Starting from C# 8, developers can define `Dispose` or `DisposeAsync` without
    implementing `IDisposable` or `IAsyncDisposable`. Implementing the `Dispose` method
    by pattern has been *limited* to `ref struct` types because extending it to any
    other type could eventually cause a breaking change for types already defining
    a `Dispose` method without declaring `IDisposable` in the inheritance list.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 8开始，开发人员可以定义`Dispose`或`DisposeAsync`而无需实现`IDisposable`或`IAsyncDisposable`。通过模式实现`Dispose`方法已经被*限制*为`ref
    struct`类型，因为将其扩展到任何其他类型最终可能会导致已经定义了`Dispose`方法但未在继承列表中声明`IDisposable`的类型发生破坏性变化。
- en: 'The following definition is a valid implementation of the `Dispose` and `DisposeAsync`
    methods:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义是`Dispose`和`DisposeAsync`方法的有效实现：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Dispose` method can be used as usual:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispose`方法可以像往常一样使用：'
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But this other declaration is not allowed because we cannot use `ref` inside
    an asynchronous method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种声明是不允许的，因为我们不能在异步方法中使用`ref`：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The workaround is to expand the `await using` declaration with a full `try`/`finally`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是扩展`await using`声明，使用完整的`try`/`finally`：
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This code is certainly not very nice to read, but we should consider that declaring
    the asynchronous version of `Dispose` (in a type whose life cycle is limited to
    the stack) is probably not a great idea.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码肯定不好阅读，但我们应该考虑，在一个生命周期仅限于堆栈的类型中声明`Dispose`的异步版本可能不是一个好主意。
- en: While the `Dispose` by pattern has been precautionarily limited to `ref structs`,
    the `DisposeAsync` by pattern has no restrictions, so it is perfectly legal to
    declare `DisposeAsync` in an old-fashioned class and use it with the `await using`
    statement.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过模式实现的`Dispose`已经被预防性地限制为`ref structs`，但通过模式实现的`DisposeAsync`没有限制，因此在老式类中声明`DisposeAsync`并在`await
    using`语句中使用它是完全合法的。
- en: Asynchronous streams
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步流
- en: Asynchronous streams are the final missing piece in the task story that began
    several years ago when the `Task` class, `async`, and `await` were first introduced.
    An example of an unresolved use case is the processing of data chunks coming from
    the internet while they are being downloaded. The basic point here is that we
    don't want to await the entire stream of data, but instead take a single chunk
    at a time, processing it and then awaiting the next one. This processing can therefore
    happen while the other pieces of data are still downloading and the unused thread
    time can be spent to serve other users as well, incrementing the total scalability
    of the application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 异步流是任务故事的最后一块缺失的部分，这个故事始于几年前`Task`类、`async`和`await`首次引入。一个未解决的用例示例是在从互联网下载数据时处理数据块。基本点在于我们不想等待整个数据流，而是一次获取一个数据块，处理它，然后等待下一个。这样处理可以在其他数据仍在下载时进行，未使用的线程时间也可以用来为其他用户提供服务，增加应用程序的总可伸缩性。
- en: Before digging into the new C# feature, let's rapidly review how an enumerable
    is made in the synchronous world. The following examples show an enumerable sequence
    that can be used inside a `foreach` statement; you may notice that the enumerated
    type is an integer instead of the hypothetical byte array composing the chunks
    downloaded from the internet, but this is not really relevant.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究新的C#特性之前，让我们快速回顾一下在同步世界中如何创建可枚举对象。以下示例展示了一个可在`foreach`语句中使用的可枚举序列；您可能会注意到，枚举类型是整数，而不是假设的从互联网下载的数据块组成的字节数组，但这并不重要。
- en: 'The simplest possible implementation leverages the C# iterator, which is implemented
    through the `yield` keyword:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的实现利用了C#迭代器，通过`yield`关键字实现：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Its main consumer is, of course, a `foreach` statement:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要使用者当然是`foreach`语句：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Under the hood, the compiler generates the code, exposing an `IEnumerable<T>`
    whose responsibility is to provide the enumerator, a class made of the `Current`,
    `Reset`, and `MoveNext` members unrolling the sequence. The relevant part of this
    code is `Thread.Sleep` inside the `MoveNext` method, which simulates a slow iteration.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，编译器生成代码，暴露一个`IEnumerable<T>`，其职责是提供枚举器，一个由`Current`、`Reset`和`MoveNext`成员组成的类来展开序列。这段代码的相关部分是`MoveNext`方法中的`Thread.Sleep`，模拟了一个缓慢的迭代。
- en: 'The following code is equivalent, but implements the `IEnumerable` and `IEnumerator`
    interfaces manually:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是等效的，但手动实现了`IEnumerable`和`IEnumerator`接口：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once again, the `foreach` statement can easily consume the sequence, sharing
    the problem of the blocked thread caused by `Thread.Sleep`, which in real life
    would be an ongoing I/O operation inside the network stack of the operating system:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，`foreach`语句可以轻松地消耗序列，共享由`Thread.Sleep`引起的阻塞线程的问题，而在现实生活中，这将是操作系统网络堆栈中正在进行的I/O操作：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In order to resolve this problem, C# 8 introduced the very convenient `await
    foreach`, which is used to iterate an asynchronous enumeration, which in turn
    requires two new interfaces: `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>`.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C# 8引入了非常方便的`await foreach`，用于迭代异步枚举，这又需要两个新接口：`IAsyncEnumerable<T>`和`IAsyncEnumerator<T>`。
- en: 'The simplest possible producer and consumer for the new asynchronous streams
    are very similar to the previous ones:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 新的异步流的最简单的生产者和消费者与以前的非常相似：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Should we need to implement those two interfaces (manually), it would not be
    much different than the synchronous implementation where, not surprisingly, we
    have to implement the asynchronous version of `MoveNext` called `MoveNextAsync`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要手动实现这两个接口，那么与同步实现并没有太大不同，不出所料，我们需要实现`MoveNext`的异步版本`MoveNextAsync`：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the same way that `IEnumerator<T>` derives from `IDisposable<T>`, the `IAsyncEnumerator<T>`
    interface derives from `IAsyncDisposable<T>`, which we already discussed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与`IEnumerator<T>`从`IDisposable<T>`派生一样，`IAsyncEnumerator<T>`接口从我们已经讨论过的`IAsyncDisposable<T>`派生。
- en: '`MoveNextAsync` and `Current` are the only other members required by the `IAsyncEnumerator<T>`
    interface, whose methods return the *lightweight* `ValueTask` type already seen
    in `DisposeAsync`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveNextAsync`和`Current`是`IAsyncEnumerator<T>`接口需要的唯一其他成员，其方法返回*轻量级*的`ValueTask`类型，这在`DisposeAsync`中已经见过。'
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the only class in the base class library implementing
    `IAsyncEnumerable<T>` is `System.Threading.Channel`, so in order to fully leverage
    the power of the asynchronous streams, you should adopt an external library or
    implement those two interfaces by yourself, which is pretty straightforward.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，基类库中实现`IAsyncEnumerable<T>`的唯一类是`System.Threading.Channel`，因此为了充分利用异步流的功能，您应该采用外部库或自己实现这两个接口，这非常简单。
- en: 'The code consuming the new asynchronous sequence is structurally the same:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 消费新的异步序列的代码在结构上是相同的：
- en: '[PRE76]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For the sake of completeness, the consuming code is equivalent to the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，消费代码等同于以下内容：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The static `TaskAsyncEnumerableExtensions` class contains some extension methods
    that allow the configuration of `IAsyncEnumerable` objects, as you would expect
    from any other `Task` object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`TaskAsyncEnumerableExtensions`类包含一些扩展方法，允许配置`IAsyncEnumerable`对象，就像您从任何其他`Task`对象中期望的那样。
- en: The first extension method is `ConfigureAwait`, which we already examined in
    [*Chapter 12*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215), *Multithreading
    and Asynchronous Programming*. The other is `WithCancellation`, which takes a
    `CancellationToken` value that can be used to cancel the ongoing task.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个扩展方法是`ConfigureAwait`，我们已经在[*第12章*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215)中进行了讨论，*多线程和异步编程*。另一个是`WithCancellation`，它接受一个`CancellationToken`值，可以用于取消正在进行的任务。
- en: Asynchronous streams are very powerful as they simplify the developer code while
    making it more powerful. On the producer side, implementing the required interfaces
    (`IAsyncEnumerable` and `IAsyncEnumerator`) is very simple, and on the consumer
    side, it is easy to enumerate the sequence asynchronously thanks to the new `async
    foreach`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 异步流非常强大，因为它简化了开发人员的代码，同时使其更加强大。在生产者方面，实现所需的接口（`IAsyncEnumerable`和`IAsyncEnumerator`）非常简单，而在消费者方面，由于新的`async
    foreach`，可以轻松地异步枚举序列。
- en: One drawback is that the current library ecosystem is not compatible with the
    new interfaces. For this reason, the community already wrote a new set of Linq-style
    extension methods providing the same *look and feel* of the ones baked into the
    base class library.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是当前的库生态系统与新接口不兼容。因此，社区已经编写了一组新的Linq风格的扩展方法，提供了与基类库中内置方法相同的*外观和感觉*。
- en: It is also important to use the right tool for every use case. In other words,
    there is no need to transform everything into something asynchronous just because
    the language has been extended. This is just an important tool that every developer
    can use whenever it makes sense.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种用例使用合适的工具也很重要。换句话说，并不是因为语言已经扩展了就需要将一切都转换成异步的。这只是每个开发人员在有意义时可以使用的重要工具。
- en: Readonly struct members
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读结构成员
- en: Following the introduction of the `readonly` struct in C# 7, it is now possible
    to specify the `readonly` modifier singularly on its members. This feature has
    been added for all those cases where the struct type cannot be entirely marked
    as read-only, but when only one or more members can guarantee not to modify the
    state of the instance.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7引入`readonly`结构后，现在可以单独在其成员上指定`readonly`修饰符。这个特性是为了所有那些结构类型不能完全标记为只读的情况而添加的，但是当一个或多个成员可以保证不修改实例状态时。
- en: The main reason why I love this feature is because expressing the intents explicitly
    is a best practice in terms of maintenance and usability.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个功能的主要原因是因为明确表达意图在维护和可用性方面是最佳实践。
- en: It is also important from a performance perspective because the `readonly` struct
    provides a sort of *hint* to the compiler, which can apply better optimizations.
    The modifier can be applied on fields, properties, and methods to guarantee it
    does not mutate the struct instance, but does not give any guarantee on the referenced
    objects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看也很重要，因为`readonly`结构为编译器提供了一种*提示*，可以应用更好的优化。修饰符可以应用于字段、属性和方法，以确保它不会改变结构实例，但不会对引用的对象提供任何保证。
- en: 'When dealing with properties, the modifier can be applied on the property or
    on just one of the accessors:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 处理属性时，修饰符可以应用于属性或者仅应用于其中一个访问器：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For example, let''s define a `Vector struct` exposing two methods returning
    the vector length where only one of the two is marked as `readonly`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义一个`Vector结构`，公开两个返回向量长度的方法，其中只有一个标记为`readonly`：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since value types such as `Vector` are subject to be copied when they are passed
    as parameters, a common solution is to apply the `in` modifier (which means a
    `readonly` `ref`), as in the following example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值类型（如`Vector`）在作为参数传递时会被复制，一个常见的解决方案是应用`in`修饰符（意味着`readonly` `ref`），就像以下示例中一样：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Unfortunately, the `in` modifier cannot give any guarantees about the immutability
    of the other data addressed by the reference. Therefore, as soon as the compiler
    sees the `GetLength` method being invoked, it has to assume a potential change
    to the vector instance, causing a defensive hidden local copy of `Vector`, regardless
    of the fact that it has been passed by the reference.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`in`修饰符不能保证引用地址的其他数据的不可变性。因此，一旦编译器看到调用`GetLength`方法，它就必须假设可能会对向量实例进行潜在更改，导致`Vector`的防御性隐藏本地副本，而不管它是通过引用传递的。
- en: 'If instead we replace the call to `GetLength` with the read-only `GetLengthRo`
    method, the compiler understands there is no risk in modifying the `Vector` content
    and can avoid generating the local copy, providing better performance to the application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用只读的`GetLengthRo`方法替换对`GetLength`的调用，编译器会理解在修改`Vector`内容时没有风险，并且可以避免生成本地副本，从而提供更好的应用性能：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It is worth saying that the compiler is smart enough to provide some automatic
    optimizations. For example, automatically generated property getters are already
    marked as read-only, but remember to apply the `readonly` modifier to all the
    other members not mutating the instance state, providing an important hint to
    the compiler and obtaining the best possible optimizations in change.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，编译器足够聪明，可以提供一些自动优化。例如，自动生成的属性getter已经标记为只读，但请记住对所有其他不改变实例状态的成员应用`readonly`修饰符，为编译器提供重要提示，并获得尽可能好的优化。
- en: Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Version after version, the compiler improves its capability to detect potential
    side effects such as local copies. You can verify the generated IL code by yourself
    using a decompiler such as `ildasm` or the `ILSpy` tools, but be warned that these
    optimizations are subject to changes over time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 版本之后，编译器改进了其检测潜在副作用的能力，例如局部副本。您可以使用`ildasm`或`ILSpy`等反编译器自行验证生成的IL代码，但请注意，这些优化可能随时间而变化。
- en: 'If you mark a method as read-only, even if it is modifying the state of its
    instance, the compiler will generate either an error or a warning, depending on
    the situation:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将方法标记为只读，即使它修改了实例的状态，编译器也会生成错误或警告，具体取决于情况：
- en: The compiler will complain with a `CS1604` error if the `readonly` method tries
    to modify any field of the struct.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`readonly`方法尝试修改结构的任何字段，编译器将报告`CS1604`错误。
- en: The compiler will generate a `CS8656` warning every time the code accesses a
    not read-only property getter to advise about the generation of the code needed
    to create a defensive hidden local copy of the struct, as stated in the message
    description.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当代码访问不是只读属性getter时，编译器都会生成一个`CS8656`警告，以提醒生成所需的代码来创建结构的防御性隐藏本地副本，如消息描述中所述。
- en: 'In the CS8656 warning message, the compiler advises that it is going to generate
    a copy of `''this''` to avoid mutating the current instance:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在CS8656警告消息中，编译器建议生成`'this'`的副本以避免改变当前实例：
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'There is one important side effect regarding the ability of the compiler to
    recognize undesired situations. It cannot detect any attempt to modify the changes
    to a referenced object, as demonstrated by the following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编译器识别不良情况的能力有一个重要的副作用。它无法检测任何试图修改对引用对象的更改，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: While we apparently don't see any drawbacks in not applying the `readonly` modifier
    on struct members that are not modifying the state of the value type, be very
    careful, because it can make a big difference to the performance of hot paths.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们似乎在不对不修改值类型状态的结构成员应用`readonly`修饰符中看不到任何缺点，但一定要小心，因为这可能对热点路径的性能产生很大影响。
- en: Null coalescing assignment
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值合并赋值
- en: 'The null coalescing operator, `??`, has been extended in C# 8 to support assignment.
    A popular usage for the null coalescing operator involves the parameter checks
    at the beginning of a method, like in the following example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，空值合并运算符`??`已扩展以支持赋值。空值合并运算符的一个常见用法涉及方法开头的参数检查，就像以下示例中所示：
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The new assignment allows us to reassign the reference whenever it is null,
    as demonstrated by the following example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 新的赋值允许我们在引用为null时重新分配引用，就像以下示例所示：
- en: '[PRE85]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The parameter list can initially be null and in this case, it will be reassigned
    to a new instance, but the following times, the assignment will not occur anymore:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表最初可以为null，在这种情况下，它将被重新分配给一个新实例，但在接下来的时间里，赋值将不再发生：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The null coalescing assignment doesn't look very important, but its ability
    to execute the rightmost expression is a big value that you should not underestimate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并赋值看起来并不是很重要，但它执行最右边表达式的能力是一个你不应该低估的重要价值。
- en: Static local functions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态本地函数
- en: 'Local functions have been introduced to make the code more readable by constraining
    the visibility of a certain piece of code to a single method:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了本地函数，通过将某个代码片段的可见性限制为单个方法，使代码更易读：
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this example, the `Obfuscated` method can only be used by `PrintName` and
    has the advantage of being able to ignore any parameter check, because the context
    where the `p` captured parameter is used does not allow its value to be null.
    This can deliver performance advantages in complex scenarios, but its ability
    to capture the local variables (including `this`) can be confusing.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Obfuscated`方法只能被`PrintName`使用，并且具有忽略任何参数检查的优势，因为`p`捕获的参数在使用它的上下文中不允许其值为null。这可以在复杂的场景中提供性能优势，但它捕获局部变量（包括`this`）的能力可能会令人困惑。
- en: 'With C# 8, it is now possible to avoid any capturing by marking the local function
    as static:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，现在可以通过将本地函数标记为静态来避免任何捕获：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This new version of the method enforces its ability to self-describe while still
    having the advantage of ignoring any parameter-checking due to the known context.
    It is worth noting that capturing is usually not an issue in terms of performance,
    but can severely impact readability because C# allows automatic capturing by default,
    in contrast to other languages such as C++ lambdas.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的新版本强化了它自我描述的能力，同时仍然具有忽略由于已知上下文而导致的任何参数检查的优势。值得注意的是，捕获通常在性能方面不是问题，但可能严重影响可读性，因为C#默认允许自动捕获，与C++
    lambda等其他语言形成对比。
- en: Better interpolated verbatim strings
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的插值原始字符串
- en: 'We have already learned that string literals supports some *variants* to avoid
    escaping characters:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了字符串文字支持一些*变体*以避免转义字符：
- en: '[PRE89]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'They can also be used to improve formatting, thanks to interpolation:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用于改进格式，感谢插值：
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Since the introduction of interpolated strings, we have always been able to
    mix the two formatting styles:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 自从插值字符串被引入以来，我们一直能够混合两种格式化样式：
- en: '[PRE91]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But inverting the `$` and `@` characters was not possible before C# 8:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 但在C# 8之前，不可能颠倒`$`和`@`字符：
- en: '[PRE92]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: With this small improvement, you don't have to bother about the order of the
    prefixes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个小改进，你就不必再担心前缀的顺序了。
- en: Using stackalloc in nested expressions
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌套表达式中使用stackalloc
- en: 'With C# 7, we started using `Span<T>`, `ReadOnlySpan<T>`, and `Memory<T>` because
    they are `ref struct` instances that are guaranteed to be allocated on the stack,
    and therefore won''t affect the garbage collector. Thanks to `Span`, it was also
    possible to avoid declaring the `stackalloc` statements that are directly assigned
    to `Span` or `ReadOnlySpan` as unsafe:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7中，我们开始使用`Span<T>`、`ReadOnlySpan<T>`和`Memory<T>`，因为它们是保证在堆栈上分配的`ref struct`实例，因此不会影响垃圾收集器。由于`Span`，也可以避免声明直接分配给`Span`或`ReadOnlySpan`的`stackalloc`语句作为不安全的：
- en: '[PRE93]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Starting from C# 8, the compiler widens the use of `stackalloc` to any expression
    expecting `Span` or `ReadOnlySpan`. In the following example, the test trims the
    `input` string from three special characters, obtaining the string specified in
    the `expected` variable:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 8开始，编译器将`stackalloc`的使用扩展到任何期望`Span`或`ReadOnlySpan`的表达式。在下面的例子中，测试从`input`字符串中修剪了三个特殊字符，得到了`expected`变量中指定的字符串：
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The operations performed by the preceding example are as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子中执行的操作如下：
- en: The `AsSpan` extension method converts the string into `ReadOnlySpan<char>`.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsSpan`扩展方法将字符串转换为`ReadOnlySpan<char>`。'
- en: The `Trim` extension method narrows the boundaries of `ReadOnlySpan<char>` to
    the characters specified with the `stackalloc` array. This `Trim` method does
    not require any allocation.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trim`扩展方法将`ReadOnlySpan<char>`的边界缩小到`stackalloc`数组指定的字符。这个`Trim`方法不需要任何分配。'
- en: Finally, the `ToString` method is called to create a new string from `ReadOnlySpan<char>`.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，调用`ToString`方法从`ReadOnlySpan<char>`创建一个新的字符串。
- en: The advantage of this code is that, beyond the new `int[]` expression, which
    is used to verify the test, and the `ToString` method, which is used to create
    the result, no other heap allocations are performed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的优势在于，除了用于验证测试的新的`int[]`表达式和用于创建结果的`ToString`方法之外，不会执行其他堆分配。
- en: Unmanaged constructed types
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未管理构造类型
- en: 'Before digging into this new C# feature, it is necessary to understand the
    subject by analyzing the definitions of **unmanaged** and **constructed types**
    cited by the language specifications:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究这个新的C#特性之前，有必要通过分析语言规范中引用的“未管理”和“构造类型”的定义来理解这个主题：
- en: A type is called `constructed` if it is generic and the type parameter is already
    defined. For example, `List<string>` is a constructed type while `List<T>` is
    not.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型是泛型的，并且类型参数已经定义，则称为“构造”类型。例如，`List<string>`是一个构造类型，而`List<T>`则不是。
- en: 'A type is called `unmanaged` when it can be used in an unsafe context. This
    is true for many built-in basic types. The official documentation includes the
    list of these types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`,
    `ulong`, `char`, `float`, `double`, `decimal`, `bool`, `enums`, `pointers`, and
    `struct`.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它可以在不安全的上下文中使用时，类型被称为“未管理”。这对许多内置的基本类型都是正确的。官方文档包括这些类型的列表：`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、`bool`、`enums`、`pointers`和`struct`。
- en: 'An example of an unmanaged constructed type that it was not possible to declare
    before C# 8 is as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8之前无法声明的未管理构造类型的一个例子如下：
- en: '[PRE95]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The two main advantages of allowing generic structs to be unmanaged are as
    follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 允许泛型结构体为未管理的两个主要优势如下：
- en: They can be allocated on the stack using `stackalloc`.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用`stackalloc`在堆栈上分配。
- en: 'We can use those types with pointers and unsafe code to interoperate with native
    code. This is useful when dealing with native chunks whose fields could, for example,
    be either 32 or 64 bits:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用这些类型与指针和不安全的代码一起与本机代码进行互操作。当处理本机块时，这是有用的，其字段可以是32位或64位：
- en: '[PRE96]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: With this feature, the language specifications are going in the direction of
    easing the native interoperability without incurring the performance hits that,
    in the past, required the use of the C or C++ languages.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个特性，语言规范朝着简化本机互操作性的方向发展，而不会导致以往需要使用C或C++语言的性能损失。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There is no doubt that the new C# 8 features mark an important milestone in
    terms of code robustness and clarity. It is not unusual for a language to become
    (version after version) more complex and difficult to read, but C# introduced
    features such as pattern matching and ranges that allow any developer to express
    their intent with more concise and unambiguous code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，新的C# 8功能标志着代码健壮性和清晰度方面的重要里程碑。语言变得越来越复杂和难以阅读并不罕见，但C#引入了诸如模式匹配和范围等功能，使任何开发人员都能用更简洁和明确的代码表达其意图。
- en: While it is controversial, the default interface members introduced the Traits
    paradigm to the .NET world and addressed problems such as interface versioning,
    which caused developers to struggle for years.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有争议，但默认接口成员将Traits范式引入了.NET世界，并解决了接口版本化等多年来困扰开发人员的问题。
- en: We learned about a key feature, that is, built-in nullable reference static
    code analysis, which allows us to progressively review the code and dramatically
    cut down the number of errors due to dereferencing null references.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了一个关键特性，即内置可空引用静态代码分析，它允许我们逐步审查代码并大大减少由于取消引用空引用而导致的错误数量。
- en: This was not the end of tuning the language for productivity, as we continued
    through the C#7 performance journey with asynchronous streams, read-only struct
    members, and the updates to `stackalloc` and unmanaged constructed types, all
    of which combine to make C# a compelling competitor among the native languages
    while still enforcing code safety.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是为了提高生产力而调整语言的终点，因为我们继续通过C#7性能之旅，引入了异步流、只读结构成员以及对`stackalloc`和未管理构造类型的更新，所有这些都使C#成为本机语言中的一个引人注目的竞争者，同时仍然强制执行代码安全性。
- en: Other smaller features such as the succinct `using` declaration, asynchronous
    `Dispose`, the disposable pattern, static local functions, the fix on the interpolated
    string, and null-coalescing assignment are very simple to remember and deliver
    practical advantages.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 其他较小的特性，如简洁的`using`声明、异步`Dispose`、可处置模式、静态局部函数、插值字符串的修复和空值合并赋值，都非常容易记住并提供实际优势。
- en: New language features are not just additional tools in the developer's Swiss
    Army knife, but a big opportunity to improve the code base. If we go back in time
    and think of generic types introduced in C# 2.0, they boosted the productivity
    and performance by orders of magnitude. Later on, the language introduced LINQ
    queries, lambda expressions, and extension methods, thereby bringing more expressivity
    and opening up new design strategies that were much harder before then. The entire
    history of programming languages, not only C#, is characterized by improvements
    targeting the requirements of modern development. Nowadays, application development
    is clearly oriented toward shorter development life cycles by adopting the **Continuous
    Integration/Continuous Delivery** (**CI/CD**) pipeline, which brings with it strong
    requirements regarding code quality and productivity. By considering this broader
    view, there is no doubt that staying up to date on the latest language features
    is mandatory for any developer.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语言特性不仅仅是开发人员瑞士军刀中的额外工具，而是改进代码库的重大机会。如果我们回到过去，想想C# 2.0引入的泛型类型，它们大大提高了生产力和性能。后来，语言引入了LINQ查询、lambda表达式和扩展方法，从而带来了更多的表现力，并开启了之前更加困难的新设计策略。整个编程语言的历史，不仅仅是C#，都以改进满足现代开发需求为特点。如今，应用程序开发明显倾向于通过采用**持续集成/持续交付**（**CI/CD**）流水线来缩短开发周期，这带来了对代码质量和生产力的强烈要求。考虑到这个更广泛的视角，毫无疑问，跟上最新语言特性的步伐对于任何开发人员来说都是必须的。
- en: In the next chapter, we will learn how .NET Core 3 can transform language formalism
    into running code, both on Windows and on Linux. We will go through creating a
    library that can be consumed from any .NET runtime flavor; consuming packages,
    which is the real richness of this ecosystem; and finally, publishing the application,
    turning all of our work into great value for the end user.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习.NET Core 3如何将语言形式转化为运行代码，无论是在Windows还是Linux上。我们将学习创建一个可以从任何.NET运行时环境中使用的库；使用包，这是这个生态系统的真正丰富之处；最后，发布应用程序，将我们所有的工作转化为最终用户的巨大价值。
- en: Test what you learned
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: How can you minimize the amount of `NullReferenceException` exceptions in your
    code?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何最小化代码中的`NullReferenceException`异常数量？
- en: What is the best syntax to use to read the last item in an array?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用什么语法来读取数组中的最后一个项目？
- en: When using `switch` expressions, what keyword is equivalent to using the discard
    character (_)?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`switch`表达式时，什么关键字等同于使用弃置字符(_)？
- en: How can you await an asynchronous call closing a file in the `Dispose` method?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何等待一个异步调用来关闭`Dispose`方法中的文件？
- en: When assigning the `orders` variable in the following statement, is the method
    call invoked on every execution?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的语句中，当分配`orders`变量时，方法调用是否在每次执行时都被调用？
- en: '[PRE97]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Is defining a sequence as `IAsyncEnumerable` mandatory for it to be iterated
    with the new `async foreach` statement?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个序列为`IAsyncEnumerable`是必须的，才能用新的`async foreach`语句进行迭代吗？
- en: Further reading
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to follow the evolution of C#, you can examin[e the proposals and
    the conversation](https://github.com/dotnet/csharplang)s around the next release
    of the language on GitHub at https://github.com/dotnet/csharplang.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟踪C#的发展，你可以在GitHub上查看关于语言下一个版本的提案和讨论：https://github.com/dotnet/csharplang。
