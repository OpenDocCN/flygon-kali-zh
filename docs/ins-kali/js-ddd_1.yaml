- en: Chapter 1. A Typical JavaScript Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 典型的JavaScript项目
- en: 'Welcome to domain-driven design in JavaScript. In this book, we will explore
    a practical approach to developing software with advanced business logic. There
    are many strategies to keep development flowing and the code and thoughts organized,
    there are frameworks building on conventions, there are different software paradigms
    such as object orientation and functional programming, or methodologies such as
    test-driven development. All these pieces solve problems, and are like tools in
    a toolbox to help manage growing complexity in software, but they also mean that
    today when starting something new, there are loads of decisions to make even before
    we get started at all. Do we want to develop a single-page application, do we
    want to develop following the standards of a framework closely or do we want to
    set our own? These kinds of decisions are important, but they also largely depend
    on the context of the application, and in most cases the best answer to the questions
    is: *it depends*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到JavaScript中的领域驱动设计。在本书中，我们将探索一种开发具有高级业务逻辑的软件的实用方法。有许多策略可以保持开发流畅和代码和思想有组织，有建立在约定上的框架，有不同的软件范式，如面向对象和函数式编程，或者测试驱动开发等方法。所有这些部分都解决了问题，并且就像工具箱中的工具一样，帮助管理软件中不断增长的复杂性，但这也意味着今天在开始新项目时，甚至在我们开始之前就有很多决定要做。我们想要开发单页应用程序吗，我们想要紧密遵循框架的标准吗，还是我们想要自己设置？这些决定很重要，但它们也在很大程度上取决于应用程序的上下文，在大多数情况下，对这些问题的最佳答案是：“这取决于情况”。
- en: So, how do we really start? Do we really even know what our problem is, and,
    if we understand it, does this understanding match that of others? Developers
    are very seldom the domain experts on a given topic. Therefore, the development
    process needs input from outside through experts of the business domain when it
    comes to specifying the behavior a system should have. Of course, this is not
    only true for a completely new project developed from the ground up, but also
    can be applied to any new feature added during development of to an application
    or product. So, even if your project is well on its way already, there will come
    a time when a new feature just seems to bog the whole thing down and, at this
    stage, you may want to think about alternative ways to go about approaching this
    new piece of functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们真的该如何开始呢？我们真的知道我们的问题是什么吗？如果我们理解了，这种理解是否与其他人的理解相匹配？开发人员很少是某个特定主题的领域专家。因此，当涉及指定系统应具有的行为时，开发过程需要来自业务领域专家的外部输入。当然，这不仅适用于从头开始开发的全新项目，也可以应用于在开发过程中添加到应用程序或产品中的任何新功能。因此，即使您的项目已经进展顺利，也会有一个时机，新功能似乎会拖慢整个项目，此时，您可能想考虑以替代方式来处理这个新功能。
- en: Domain-driven design gives us another useful piece to play with, especially
    to solve the need to interact with other developers, business experts, and product
    owners. As in the modern era, JavaScript becomes a more and more persuasive choice
    to build projects in and, in many cases like browser-based web applications, it
    actually is the only viable choice. Today, the need to design software with JavaScript
    is more pressing than ever. In the past, the issues of a more involved software
    design were focused on either backend or client application development, with
    the rise of JavaScript as a language to develop complete systems in, this has
    changed. The development of a JavaScript client in the browser is a complex part
    of developing the application as a whole, and so is the development of server-side
    JavaScript applications with the rise of **Node.js**. In modern development, JavaScript
    plays a major role and therefore needs to receive the same amount of attention
    in development practices and processes as other languages and frameworks have
    in the past. A browser based client-side application often holds the same amount,
    or even more logic, than the backend. With this change, a lot of new problems
    and solutions have arisen, the first being the movement toward better encapsulation
    and modularization of JavaScript projects. New frameworks have arisen and established
    themselves as the bases for many projects. Last but not least, JavaScript made
    the jump from being the language in the browser to move more and more to the server
    side, by means of Node.js or as the query language of choice in some **NoSQL**
    databases. Let me take you on a tour of developing a piece of software, taking
    you through the stages of creating an application from start to finish using the
    concepts domain-driven design introduced and how they can be interpreted and applied.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计为我们提供了另一个有用的工具，特别是为了解决与其他开发人员、业务专家和产品所有者互动的需求。在现代，JavaScript成为构建项目的更加有说服力的选择，特别是在基于浏览器的Web应用程序等许多情况下，它实际上是唯一可行的选择。如今，使用JavaScript设计软件的需求比以往任何时候都更加迫切。过去，更复杂的软件设计问题集中在后端或客户端应用程序开发上，随着JavaScript作为一种开发完整系统的语言的崛起，情况已经发生了变化。在浏览器中开发JavaScript客户端是开发整个应用程序的复杂部分，随着Node.js的崛起，开发服务器端JavaScript应用程序也是如此。在现代开发中，JavaScript发挥着重要作用，因此需要像过去其他语言和框架一样在开发实践和流程中得到同等重视。基于浏览器的客户端应用程序通常包含与后端相同甚至更多的逻辑。随着这种变化，许多新问题和解决方案已经出现，首先是朝着更好地封装和模块化JavaScript项目的方向发展。新的框架已经出现并确立了自己作为许多项目的基础。最后但同样重要的是，JavaScript已经从浏览器中的语言跃升到更多地移动到服务器端，通过Node.js或作为某些NoSQL数据库中的首选查询语言。让我带你走一遍开发软件的过程，带你通过使用领域驱动设计引入的概念以及它们如何被解释和应用来创建一个应用程序的各个阶段。
- en: 'In this chapter, you will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: The core idea of domain-driven design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计的核心理念
- en: Our business scenario—managing an orc dungeon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的业务场景——管理兽人地牢
- en: Tracking the business logic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪业务逻辑
- en: Understanding the core problem and selecting the right solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解核心问题并选择正确的解决方案
- en: Learning what domain-driven design is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习什么是领域驱动设计
- en: The core idea of domain-driven design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计的核心思想
- en: There are many software development methodologies around, all with pros and
    cons but all also have a core idea, which is to be applied and understood to get
    the methodology right. For a domain-driven design, the core lies in the realization
    that since we are not the experts in the domain the software is placed in, we
    need to gather input from other people who are experts. This realization means
    that we need to optimize our development process to gather and incorporate this
    input.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多软件开发方法论，各有优缺点，但都有一个核心思想，就是要应用和理解以正确地使用该方法论。对于领域驱动设计，核心在于意识到，由于我们不是软件所处领域的专家，我们需要从其他专家那里收集意见。这意识意味着我们需要优化我们的开发过程来收集和整合这些意见。
- en: 'So, what does this mean for JavaScript? When thinking about a browser application
    to expose a certain functionality to a consumer, we need to think about many things,
    for example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对JavaScript意味着什么？当考虑在浏览器应用程序中向消费者公开某种功能时，我们需要考虑许多事情，例如：
- en: How does the user expect the application to behave in the browser?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户期望应用程序在浏览器中的行为是什么？
- en: How does the business workflow work?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务工作流程是如何工作的？
- en: What does the user know about the workflow?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户对工作流程了解多少？
- en: 'These three questions already involve three different types of experts: a person
    skilled in user experience can help with the first query, a business domain expert
    can address the second query, and a third person can research the target audience
    and provide input on the last query. Bringing all of this together is the goal
    we are trying to achieve.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个问题已经涉及到三种不同类型的专家：擅长用户体验的人可以帮助解决第一个问题，业务领域专家可以解决第二个问题，第三个人可以研究目标受众并提供最后一个问题的意见。将所有这些整合在一起是我们试图实现的目标。
- en: While the different types of people matter, the core idea is that the process
    of getting them involved is always the same. We provide a common way to talk about
    the process and establish a quick feedback loop for them to review. In JavaScript,
    this can be easier than in most other languages due to the nature of it being
    run in a browser, readily available to be modified and prototyped with; an advantage
    Java Enterprise Applications can only dream of. We can work closely with the user
    experience designer adjusting the expected interface and at the same time change
    the workflow dynamically to suit our business needs, first on the frontend in
    the browser and later moving the knowledge out of the prototype to the backend,
    if necessary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不同类型的人很重要，但核心思想是让他们参与的过程总是相同的。我们提供了一种共同的方式来谈论这个过程，并为他们建立了一个快速的反馈循环进行审查。在JavaScript中，这可能比大多数其他语言更容易，因为它是在浏览器中运行的，可以随时进行修改和原型设计；这是Java企业应用程序所梦寐以求的优势。我们可以与用户体验设计师密切合作，调整预期的界面，同时动态地改变工作流程以适应我们的业务需求，首先在浏览器的前端，然后将知识从原型移至后端，如果有必要的话。
- en: Managing an orc dungeon
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理兽人地牢
- en: When talking about domain-driven design, it is often stated in the context of
    having complex business logic to deal with. In fact, most software development
    practices are not really useful when dealing with a very small, cut-out problem.
    Like with every tool, you need to be clear when it is the right time to use it.
    So, what does really fall in to the realm of complex business logic? It means
    that the software has to describe a real-world scenario, which normally involves
    human thinking and interaction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到领域驱动设计时，通常是在处理复杂的业务逻辑的情境下。事实上，大多数软件开发实践在处理非常小的、简化的问题时并不真正有用。就像使用任何工具一样，你需要清楚什么时候是使用它的正确时机。那么，什么才真正属于复杂的业务逻辑领域？这意味着软件必须描述一个现实世界的场景，通常涉及人类的思考和互动。
- en: Writing software that deals with decisions, which 90 per cent of the time go
    a certain way and ten per cent of the time it's some other way, is notoriously
    hard, especially when explaining it to people not familiar with software. These
    kind of decisions are the core of many business problems, but even though this
    is an interesting problem to solve, following how the next accounting software
    is developed does not make an interesting read. With this in mind, I would like
    to introduce you to the problem we are trying to solve, that is, managing a dungeon.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写处理决策的软件，90%的时间按某种方式进行，10%的时间按其他方式进行，这在向不熟悉软件的人解释时尤其困难。这些决策是许多业务问题的核心，但尽管这是一个有趣的问题要解决，但跟踪下一个会计软件的开发并不是一个有趣的阅读。考虑到这一点，我想向你介绍我们正在尝试解决的问题，即管理地牢。
- en: '![Managing an orc dungeon](graphics/B03704_01_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![管理兽人地牢](graphics/B03704_01_01.jpg)'
- en: An orc
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一位兽人
- en: Inside the dungeon
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地牢内部
- en: Running an orc dungeon seems pretty simple from the outside, but managing it
    without getting killed is actually rather complicated. For this reason, we are
    contacted by an orc master who struggles with keeping his dungeon running smoothly.
    When we arrive at the dungeon, he explains to us how it actually works and what
    factors come into play.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，管理兽人地牢似乎很简单，但实际上管理起来并不容易。因此，我们受到一位兽人大师的联系，他苦于保持地牢的顺利运行。当我们到达地牢时，他向我们解释了实际运作方式和涉及的因素。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even **greenfield** projects often have some status quo that work. This is important
    to keep in mind since it means that we don't have to come up with the feature
    set, but match the feature set of the current reality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是**全新**的项目通常也有一些现状是有效的。这一点很重要，因为这意味着我们不必提出功能集，而是匹配当前现实的功能集。
- en: Many outside factors play a role and the dungeon is not as independent at it
    would like to be. After all, it is part of the orc kingdom, and the king demands
    that his dungeons make him money. However, money is just part of the deal. How
    does it actually make money? The prisoners need to mine gold and to do that there
    needs to be a certain amount of prisoners in the dungeon that need to be kept.
    The way an orc kingdom is run also results in the constant arrival of new prisoners,
    new captures from war, those who couldn't afford their taxes, and so on. There
    always needs to be room for new prisoners. The good thing is that every dungeon
    is interconnected, and to achieve its goals it can rely on others by requesting
    a prisoner transfer to either fill up free cells or get rid of overflowing prisoners
    in its cells. These options allow the dungeon masters to keep a close watch on
    prisoners being kept and the amount of cell space available. Sending off prisoners
    into other dungeons as needed and requesting new ones from other dungeons, in
    case there is too much free cell space available, keeps the mining workforce at
    an optimal level for maximizing the profit, while at the same time being ready
    to accommodate the eventual arrival of a high value inmate sent directly to the
    dungeon. So far, the explanation is sound, but let's dig a little deeper and see
    what is going on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多外部因素起着作用，地牢并不像它希望的那样独立。毕竟，它是兽人王国的一部分，国王要求他的地牢给他赚钱。然而，金钱只是交易的一部分。它实际上如何赚钱呢？囚犯需要采矿金子，为此需要在地牢中保留一定数量的囚犯。兽人王国的运行方式也导致不断有新囚犯到来，来自战争的新俘虏，那些无法支付税款的人等等。总是需要为新囚犯腾出空间。好消息是每个地牢都是相互连接的，为了实现其目标，它可以依靠其他地牢，通过请求囚犯转移来填满空牢房或摆脱自己牢房中的囚犯。这些选择使地牢主能够密切关注囚犯的保留和牢房空间的数量。根据需要将囚犯送往其他地牢，并向其他地牢请求新的囚犯，以防有太多的空牢房空间，可以使采矿劳工保持在最佳水平，以最大化利润，同时准备好接收直接被送到地牢的高价值囚犯。到目前为止，解释是合理的，但让我们深入一点，看看发生了什么。
- en: Managing incoming prisoners
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理进来的囚犯
- en: Prisoners can arrive for a couple of reasons, such as if a dungeon is overflowing
    and decides to transfer some of its inmates to a dungeon with free cells and,
    unless they flee on the way, they will eventually arrive at our dungeon sooner
    or later. Another source of prisoners is the ever expanding orc kingdom itself.
    The orcs will constantly enslave new folk and telling our king, *"Sorry we don't
    have room"*, is not a valid option, it might actually result in us being one of
    the new prisoners. Looking at this, our dungeon will fill up eventually, but we
    need to make sure this doesn't happen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 囚犯可能因为一些原因到达，比如如果一个地牢已经满了，决定将一些囚犯转移到有空牢房的地牢，除非他们在途中逃跑，他们最终会在我们的地牢里到达。另一个囚犯来源是不断扩张的兽人王国本身。兽人将不断奴役新的人民，对我们的国王说“抱歉，我们没有空间”并不是一个有效的选择，这实际上可能导致我们成为新的囚犯之一。看到这一点，我们的地牢最终会填满，但我们需要确保这不会发生。
- en: The way to handle this is by transferring inmates early enough to make room.
    This is obviously going to be the most complicated thing; we need to weigh several
    factors to decide when and how many prisoners to transfer. The reason we can't
    simply solve this via thresholds is that looking at the dungeon structure, this
    is not the only way we can *lose* inmates. After all, people are not always happy
    with being gold mining slaves and may decide the risk of dying in a prison is
    as high as dying while fleeing. Therefore, they decide to do so.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法是提前转移囚犯以腾出空间。这显然是最复杂的事情；我们需要权衡几个因素来决定何时以及转移多少囚犯。我们不能简单地通过阈值来解决这个问题的原因是，从地牢结构来看，这不是我们可以失去囚犯的唯一方式。毕竟，人们并不总是愿意成为采金矿的奴隶，他们可能会决定在逃跑时死亡的风险和在监狱中死亡的风险一样高，因此他们决定逃跑。
- en: The same is true while prisoners are on the move between different dungeons
    as well, and not unlikely. So even though we have a hard limit of physical cells,
    we need to deal with the soft number of incoming and outgoing prisoners. This
    is a classical problem in business software. Matching these numbers against each
    other and optimizing for a certain outcome is basically what computer data analysis
    is all about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 囚犯在不同地牢之间移动时也是如此，而且并不罕见。因此，即使我们在物理牢房上有一个硬性限制，我们仍需要处理进出囚犯的软性数量。这是商业软件中的一个经典问题。将这些数字相互匹配并优化特定结果基本上就是计算机数据分析的全部内容。
- en: The current state of the art
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现状
- en: With all this in mind, it becomes clear that the orc master's current system
    of keeping track via a badly written note on a napkin is not perfect. In fact,
    it almost got him killed multiple times already. To give you an example of what
    can happen, he tells the story of how one time the king captured four clan leaders
    and wanted to make them miners just to humiliate them. However, when arriving
    at the dungeon, he realized that there was no room and had to travel to the next
    dungeon to drop them off, all while having them laugh at him because he obviously
    didn't know how to run a kingdom. This was due to our orc master having forgotten
    about the arrival of eight transfers just the day before. Another time, the orc
    master was not able to deliver any gold when the king's sheriff arrived because
    he didn't know he only had one-third of his required prisoners to actually mine
    anything. This time it was due to having multiple people count the inmates, and
    instead of recoding them cell-by-cell, they actually tried to do it in their head.
    While being orc, this is a setup for failure. All this comes down to bad organization,
    and having your *system* to manage dungeon inmates drawn on the back of a napkin
    certainly qualifies as such.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，很明显兽人大师目前通过一张糟糕的餐巾纸上的笔记来跟踪的系统并不完美。事实上，这几乎已经让他多次险些丧命。举个例子，他讲述了一次国王抓住了四个氏族领袖并想让他们成为矿工，只是为了羞辱他们。然而，当到达地牢时，他意识到没有空间，不得不前往下一个地牢把他们放下，而他们则嘲笑他，因为显然他不知道如何管理王国。这是因为我们的兽人大师忘记了前一天到达的八名转移者。还有一次，兽人大师在国王的治安官到来时无法交付任何黄金，因为他不知道他只有三分之一所需囚犯才能挖掘任何东西。这次是因为有多人统计囚犯，而不是逐个单元格记录，他们实际上试图在脑海中做。虽然是兽人，但这是失败的设置。所有这些都归结为糟糕的组织，而将管理地牢囚犯的*系统*画在餐巾纸的背面当然也符合这样的标准。
- en: Digital dungeon management
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字地牢管理
- en: Guided by the recent failures, the orc master has finally realized it is time
    to move to modern times, and he wants to revolutionize the way to manage his dungeon
    by making everything digital. He strives to have a system that basically takes
    the busywork out of managing by automatically calculating the necessary transfers
    according to the current amount of cells filled. He would like to just sit back,
    relax and let the computer do all the work for him.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的失败案例的指导下，兽人大师终于意识到是时候进入现代化了，他希望通过数字化一切来革新管理地牢的方式。他努力要有一个系统，可以通过自动计算当前填充的单元格数量来简化管理繁琐的工作。他希望只需坐下来，放松，让计算机为他做所有的工作。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A common pattern when talking with a business expert about software is that
    they are not aware of what can be done. Always remember that we, as developers,
    are the software experts and therefore are the only ones who are able to manage
    these expectations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与业务专家讨论软件时的一个常见模式是，他们不知道可以做什么。永远记住，我们作为开发者是软件专家，因此是唯一能够管理这些期望的人。
- en: It is time now for us to think about what we need to know about the details
    and how to deal with the different scenarios. The orc master is not really familiar
    with the concepts of software development, so we need to make sure we talk in
    a language he can follow and understand, while making sure we get all the answers
    we need. We are hired for our expertise in software development, so we need to
    make sure to manage the expectations as well as the feature set and development
    flow. The development itself is of course going to be an iterative process, since
    we can't expect to get a list of everything needed right in one go. It also means
    that we will need to keep possible changes in mind. This is an essential part
    of structuring complex business software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候考虑我们需要了解的细节以及如何处理不同的情况了。兽人大师并不真正熟悉软件开发的概念，所以我们需要确保用他能理解的语言交谈，同时确保我们得到所有需要的答案。我们被聘用是因为我们在软件开发方面的专业知识，所以我们需要确保管理期望以及功能集和开发流程。开发本身当然会是一个迭代的过程，因为我们不能指望一次性就得到所有需要的清单。这也意味着我们需要考虑可能的变化。这是构建复杂商业软件的重要部分。
- en: Developing software containing more complex business logic is prone to changing
    rapidly as the business is adapting itself and the users leverage the functionality
    the software provides. Therefore, it is essential to keep a common language between
    the people who understand the business and the developers who understand the software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开发包含更复杂业务逻辑的软件很容易迅速变化，因为业务正在调整自己，用户正在利用软件提供的功能。因此，保持业务理解者和软件开发者之间的共同语言是至关重要的。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Incorporate the business terms wherever possible, it will ease communication
    between the business domain experts and you as a developer and therefore prevent
    misunderstandings early on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地融入业务术语，这将有助于业务领域专家和开发者之间的沟通，从而在早期防止误解。
- en: Specification
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规格
- en: To create a good understanding of what a piece of software needs to do, at least
    to be useful in the best way, is to get an understanding of what the future users
    were doing before your software existed. Therefore, we sit down with the orc master
    as he is managing his incoming and outgoing prisoners, and let him walk us through
    what he is doing on a day-to-day basis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解软件需要做什么，至少要有用的最好方式是了解在你的软件存在之前未来用户在做什么。因此，我们与兽人大师坐下来，看他是如何管理进出囚犯的，并让他向我们介绍他日常工作。
- en: 'The dungeon is comprised of 100 cells that are either occupied by a prisoner
    or empty at the moment. When managing these cells, we can identify distinct tasks
    by watching the orc do his job. Drawing out what we see, we can roughly sketch
    it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢由100个单元格组成，目前每个单元格要么被囚犯占据，要么为空。在管理这些单元格时，我们可以通过观察兽人的工作来确定不同的任务。根据我们所见，我们可以大致将其勾画如下：
- en: '![Specification](graphics/B03704_01_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![规格](graphics/B03704_01_02.jpg)'
- en: 'There are a couple of organizational important events and states to be tracked,
    they are:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的组织事件和状态需要跟踪，它们是：
- en: Currently available or empty cells
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前可用或空闲单元
- en: Outgoing transfer states
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外传输状态
- en: Incoming transfer states
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传入传输状态
- en: 'Each transfer can be in multiple states that the master has to know about to
    make further decisions on what to do next. Keeping a view of the world like this
    is not easy especially accounting for the amount of concurrent updates happening.
    Tracking the state of everything results in further tasks for our master to do:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次传输都可能处于多种状态，主控必须了解这些状态，以便进一步决定下一步该做什么。保持这样的世界观并不容易，尤其要考虑到同时发生的并发更新的数量。跟踪一切的状态会导致我们的主控有更多的任务要做：
- en: Update the tracking
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新跟踪
- en: Start outgoing transfers when too many cells are occupied
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当太多的单元被占用时开始进行外传输
- en: Respond to incoming transfers by starting to track them
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过开始跟踪来响应传入传输
- en: Ask for incoming transfers if the occupied cells are to low
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果占用单元太少，要求传入传输
- en: So, what does each of them involve?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，每个任务都包括什么呢？
- en: Tracking available cells
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪可用单元
- en: The current state of the dungeon is reflected by the state of its cells, so
    the first task is to get this knowledge. In its basic form, this is easily achievable
    by simply counting every occupied and every empty cell, writing down what the
    values are. Right now, our orc master tours the dungeon in the morning, noting
    each free cell assuming that the other one must be occupied. To make sure he does
    not get into trouble, he no longer trusts his subordinates to do that! The problem
    being that there only is one central sheet to keep track of everything, so his
    keepers may overwrite each other's information accidently if there is more than
    one person counting and writing down cells. Also, this is a good start and is
    sufficient as it is right now, although it misses some information that would
    be interesting to have, for example, the amount of inmates fleeing the dungeon
    and an understanding of the expected free cells based on this rate. For us, this
    means that we need to be able track this information inside the application, since
    ultimately we want to project the expected amount of free cells so that we can
    effectively create recommendations or warnings based on the dungeon state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢的当前状态由其单元的状态反映，因此第一个任务是获得这种知识。在其基本形式中，这很容易实现，只需计算每个占用和每个空闲单元，写下这些值。现在，我们的兽人主控在早上巡视地牢，记录每个空闲单元，假设另一个单元必定被占用。为了确保他不陷入麻烦，他不再相信他的下属能够做到！问题在于只有一个中央表来跟踪一切，所以如果有多人计算和记录单元，他的看守人可能会意外地覆盖彼此的信息。此外，这是一个很好的开始，目前已经足够了，尽管它缺少一些有趣的信息，例如逃离地牢的囚犯数量以及根据这一速率预期的空闲单元数量。对我们来说，这意味着我们需要能够在应用程序内跟踪这些信息，因为最终我们希望根据地牢的状态来预测预期的空闲单元数量，以便我们可以有效地根据地牢的状态创建建议或警告。
- en: Starting outgoing transfers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始外传输
- en: The second part is to actually handle getting rid of prisoners in case the dungeon
    fills up. In this concrete case, this means that if the number of free cells drops
    beneath 10, it is time to move prisoners out, since there may be new prisoners
    coming at any time. This strategy works pretty reliably since, from experience,
    it has been established that there are hardly any larger transports, so the recommendation
    is to stick with it in the beginning. However, we can already see some optimizations
    which currently are too complex.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是实际处理在地牢填满囚犯的情况下如何处理。在这种具体情况下，这意味着如果空闲单元的数量低于10，是时候移出囚犯了，因为随时可能会有新的囚犯到来。这种策略非常可靠，因为根据经验，几乎没有更大的运输，所以建议一开始就坚持这种策略。然而，我们已经看到一些目前过于复杂的优化。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Drawing from the experience of the business is important, as it is possible
    to encode such knowledge and reduces mistakes, but be mindful since encoding detailed
    experience is probably one of the most complex things to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务经验中汲取经验是重要的，因为可以对这种知识进行编码并减少错误，但要注意，因为编码详细的经验可能是最复杂的事情之一。
- en: In the future, we want to optimize this based on the rate of inmates fleeing
    the dungeon, new prisoners arriving due to being captured, as well as the projection
    of new arrivals from transfers. All this is impossible right now, since it will
    just overwhelm the current tracking system, but it actually comes down to capturing
    as much data as possible and analyzing it, which is something modern computer
    systems are good at. After all, it could save the orc master's head!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们希望根据逃离地牢的囚犯数量、因被捕获而到达的新囚犯以及来自传输的新到达的预期来优化这一点。目前这是不可能的，因为它只会压垮当前的跟踪系统，但实际上这归结为尽可能多地捕获数据并进行分析，这是现代计算机系统擅长的事情。毕竟，这可能会挽救兽人主控的脑袋！
- en: Tracking the state of incoming transfers
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪传入传输的状态
- en: On some days, a raven will arrive bringing news that some prisoners have been
    sent on their way to be transferred to our dungeon. There really is nothing we
    can do about it, but the protocol is to send the raven out five days prior to
    the prisoners actually arriving to give the dungeon a chance to prepare. Should
    prisoners flee along the way, another raven will be sent informing the dungeon
    of this embarrassing situation. These messages have to be sifted through every
    day, to make sure there actually is room available for those arriving. This is
    a big part of projecting the amount of filled cells, and also the most variable
    part, we get told. It is important to note that every message should only be processed
    once, but it can arrive at any time during the day. Right now, they are all dealt
    with by one orc, who throws them out immediately after noting what the content
    results in. One problem with the current system is that since other dungeons are
    managed the same way ours is currently, they react with quick and large transfers
    when they get in trouble, which makes this quite unpredictable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有些日子，一只乌鸦会带来消息，说有些囚犯已经被送去转移到我们的地牢。我们实际上无能为力，但协议是在囚犯实际到达之前的五天发送乌鸦，给地牢一个准备的机会。如果囚犯在途中逃跑，将会发送另一只乌鸦通知地牢这尴尬的情况。这些消息每天都要筛选一遍，以确保实际上有足够的空间来容纳到达的囚犯。这是预测填充单元数量的一个重要部分，也是最不稳定的部分，我们被告知。重要的是要注意，每条消息只能处理一次，但它可以在任何时候到达。目前，它们都由一个兽人处理，他在记录内容结果后立即将它们扔掉。当前系统的一个问题是，由于其他地牢的管理方式与我们目前的方式相同，当它们陷入麻烦时，它们会迅速进行大规模的转移，这使得情况变得相当不可预测。
- en: Initiating incoming transfers
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动传入转移
- en: Besides keeping the prisoners where they belong, mining gold is the second major
    goal of the dungeon. To do this, there needs to be a certain amount of prisoners
    available to man the machines, otherwise production will essentially halt. This
    means that whenever too many cells become abandoned it is time to fill them, so
    the orc master sends a raven to request new prisoners in. This again takes five
    days and, unless they flee along the way, works reliably. In the past, it still
    has been a major problem for the dungeon due to the long delay. If the filled
    cells drop below 50, the dungeon will no longer produce any gold and not making
    money is a reason to replace the current dungeon master. If all the orc master
    does is react to the situation, it means that there will probably be about five
    days in which no gold will be mined. This is one of the major pain points in the
    current system because projecting the amount of filled cells five days out seems
    rather impossible, so all the orcs can do right now is react.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让囚犯呆在他们应该呆的地方，挖掘黄金是地牢的第二个主要目标。为了做到这一点，需要有一定数量的囚犯来操作机器，否则生产基本上会停止。这意味着每当太多的单元被放弃时，就是填充它们的时候，因此兽人头目会派一只乌鸦请求新的囚犯。这再次需要五天时间，除非他们在途中逃跑，否则是可靠的。过去，由于长时间的延迟，这仍然是地牢的一个主要问题。如果填充的单元数量低于50，地牢将不再生产任何黄金，而不赚钱是替换当前地牢主的原因。如果兽人头目所做的只是对情况做出反应，这意味着可能会有大约五天时间没有黄金被挖掘。这是当前系统的一个主要痛点，因为预测五天后填充单元数量似乎是不可能的，所以目前所有兽人能做的就是做出反应。
- en: All in all, this gives us a rough idea what the dungeon master is looking for
    and which tasks need to be accomplished to replace the current system. Of course,
    this does not have to happen in one go, but can be done gradually so everybody
    adjusts. Right now, it is time for us to identify where to start.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这给了我们一个大致的想法，地牢主在寻找什么，以及需要完成哪些任务来替换当前系统。当然，这不必一次完成，而可以逐渐进行，以便每个人都能适应。目前，是时候确定从哪里开始了。
- en: From greenfield to application
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始到应用程序
- en: We are JavaScript developers, so it seems obvious for us to build a web application
    to implement this. As the problem is described, it is clear that starting out
    simply and growing the application as we further analyze the situation is clearly
    the way to go. Right now, we don't really have a clear understanding how some
    parts should be handled since the business process has not evolved to this level,
    yet. Also, it is possible that new features will arise or things start being handled
    differently as our software begins to get used. The steps described leave room
    for optimization based on collected data, so we first need the data to see how
    predictions can work. This means that we need to start by tracking as many events
    as possible in the dungeon. Running down the list, the first step is always to
    get a view of which state we are in, this means tracking the available cells and
    providing an interface for this. To start out, this can be done via a counter,
    but this can't be our final solution. So, we then need to grow toward tracking
    events and summing those to be able to make predictions for the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是JavaScript开发者，所以对我们来说构建一个Web应用程序来实现这一点似乎是显而易见的。根据问题的描述，很明显，从简单开始，随着我们进一步分析情况，逐渐扩展应用程序显然是正确的方式。目前，我们并不真正了解一些部分应该如何处理，因为业务流程尚未发展到这个水平。此外，随着我们的软件开始被使用，可能会出现新的功能或处理方式开始有所不同。所描述的步骤留有根据收集到的数据进行优化的空间，因此我们首先需要数据来看预测如何工作。这意味着我们需要从追踪尽可能多的事件开始。按照清单，第一步始终是了解我们所处的状态，这意味着追踪可用单元并为此提供一个接口。起初，可以通过计数器来完成，但这不能是我们的最终解决方案。因此，我们需要朝着追踪事件并对其进行汇总以便能够对未来进行预测。
- en: The first route and model
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一条路线和模型
- en: Of course there are many other ways to get started, but what it boils down to
    in most cases is that it is time now to choose the base to build on. By this I
    mean deciding on a framework or set of libraries to build upon. This happens alongside
    the decision on what database is used to back our application and many other small
    decisions, which are influenced by influenced by those decisions around framework
    and libraries. A clear understanding on how the frontend should be built is important
    as well, since building a single-page application, which implements a large amount
    of logic in the frontend and is backed by an API layer that differs a lot from
    an application, which implements most logic on the server side.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有许多其他开始的方式，但在大多数情况下，最重要的是现在是选择构建的基础的时候了。我的意思是决定构建在哪个框架或一组库上。这与决定使用哪个数据库来支持我们的应用程序以及许多其他小决定同时进行，这些小决定受到框架和库的影响。对前端应该如何构建有清晰的理解也很重要，因为构建单页应用程序，在前端实现大量逻辑，并由与在服务器端实现大部分逻辑有很大不同的API层支持的应用程序，与构建大量逻辑的应用程序有很大不同。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry if you are unfamiliar with express or any other technology used
    in the following. You don't need to understand every single detail, but you will
    get the idea of how developing an application with a framework is achieved.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对express或以下使用的任何其他技术不熟悉，不要担心。您不需要理解每一个细节，但您会了解如何使用框架开发应用程序的想法。
- en: Since we don't have a clear understanding, yet, which way the application will
    ultimately take, we try to push as many decisions as possible out, but decide
    on the stuff we immediately need. As we are developing in JavaScript, the application
    is going to be developed in Node.js and express is going to be our framework of
    choice. To make our life easier, we first decide that we are going to implement
    the frontend in plain HTML using EJS embedded JavaScript templates, since it will
    keep the logic in one place. This seems sensible since spreading the logic of
    a complex application across multiple layers will complicate things even further.
    Also, getting rid of the eventual errors during transport will ease our way toward
    a solid application in the beginning. We can push the decision about the database
    out and work with simple objects stored in RAM for our first prototype; this is,
    of course, no long-term solution, but we can at least validate some structure
    before we need to decide on another major piece of software, which brings along
    a lot of expectations as well. With all this in mind, we setup the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有明确了解应用程序最终会采取的方式，我们试图尽可能推迟尽可能多的决定，但决定我们立即需要的东西。由于我们在JavaScript中开发，应用程序将在Node.js中开发，express将是我们选择的框架。为了使我们的生活更轻松，我们首先决定我们将使用纯HTML来实现前端，使用EJS嵌入式JavaScript模板，因为这将使逻辑集中在一个地方。这似乎是合理的，因为将复杂应用程序的逻辑分散在多个层中将进一步复杂化事情。此外，在传输过程中摆脱最终的错误将使我们更容易朝着一个坚实的应用程序迈进。我们可以推迟关于数据库的决定，并使用存储在RAM中的简单对象来处理我们的第一个原型；当然，这不是长期的解决方案，但至少我们可以在需要决定另一个重要软件之前验证一些结构，这也带来了很多期望。考虑到所有这些，我们设置了应用程序。
- en: 'In the following section and throughout the book, we are using Node.js to build
    a small backend. At the time of the writing, the currently active version was
    Node.js 0.10.33\. Node.js can be obtained from [http://nodejs.org/](http://nodejs.org/)
    and is available for Windows, Mac OS X, and Linux. The foundation for our web
    application is provided by express, available via the **Node Package Manager**
    (**NPM**) at the time of writing in version 3.0.3:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节和整本书中，我们将使用Node.js构建一个小型后端。在撰写本文时，当前活跃的版本是Node.js 0.10.33。Node.js可以从[http://nodejs.org/](http://nodejs.org/)获取，并且适用于Windows、Mac
    OS X和Linux。我们的Web应用程序的基础由express提供，目前版本为3.0.3，可通过**Node Package Manager** (**NPM**)获取：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the sake of brevity, the glue code in the following is omitted, but like
    all other code presented in the book, the code is available on the GitHub repository
    [https://github.com/sideshowcoder/ddd-js-sample-code](https://github.com/sideshowcoder/ddd-js-sample-code).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，以下的粘合代码被省略了，但像书中呈现的所有其他代码一样，该代码可以在GitHub存储库[https://github.com/sideshowcoder/ddd-js-sample-code](https://github.com/sideshowcoder/ddd-js-sample-code)上找到。
- en: Creating the model
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'The most basic parts of the application are set up now. We can move on to creating
    our dungeon model in `models`/`dungeon.js` and add the following code to it to
    keep a model and its loading and saving logic:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序的最基本部分已经设置好了。我们可以继续创建我们的地牢模型在`models`/`dungeon.js`中，并添加以下代码以保持模型及其加载和保存逻辑：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)账户购买的所有Packt图书中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'Keeping in mind that this will eventually be stored in a database, we also
    need to be able to find a dungeon in some way, so the `find` method seems reasonable.
    This method should already adhere to the Node.js callback style to make our lives
    easier when switching to a real database. Even though we pushed this decision
    out, the assumption is clear since, even if we decide against a database, the
    dungeon reference will be stored and requested from outside the process in the
    future. The following shows an example with the `find` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这将最终存储在数据库中，我们还需要以某种方式找到一个地牢，因此`find`方法似乎是合理的。这个方法应该已经遵循了Node.js的回调风格，以便在切换到真正的数据库时更容易。尽管我们推迟了这个决定，但假设是明确的，因为即使我们决定不使用数据库，地牢引用也将在将来存储并从进程外部请求。以下是一个使用`find`方法的示例：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first route and loading the dungeon
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一个路由和加载地牢
- en: Now that we have this in place, we can move on to actually react to requests.
    In express defining, the needed routes do this. Since we need to make sure we
    have our current dungeon available, we also use middleware to load it when a request
    comes in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了这些，我们可以继续实际响应请求。在express中定义所需的路由来做到这一点。由于我们需要确保我们当前的地牢可用，当请求到达时，我们还使用中间件来加载它。
- en: Using the methods we just created, we can add a middleware to the express stack
    to load the dungeon whenever a request comes in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚刚创建的方法，我们可以向express堆栈添加一个中间件，以便在请求到达时加载地牢。
- en: 'A middleware is a piece of code, which gets executed whenever a request reaches
    its level of the stack, for example, the router used to dispatch requests to defined
    functions is implemented as a middleware, as is logging and so on. This is a common
    pattern for many other kinds of interactions as well, such as user login. Our
    dungeon loading middleware looks like this, assuming for now we only manage one
    dungeon we can create it by adding a file in `middleware/load_context.js` with
    the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一段代码，每当请求到达其堆栈级别时就会执行，例如，用于将请求分派到定义的函数的路由器被实现为中间件，日志记录也是如此。这也是许多其他类型的交互的常见模式，比如用户登录。我们的地牢加载中间件看起来像这样，假设现在我们只管理一个地牢，我们可以通过在`middleware/load_context.js`中添加以下代码来创建它：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Displaying the page
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示页面
- en: 'With this, we are now able to simply display information about the dungeon
    and track any changes made to it inside the request. Creating a view to render
    the state, as well as a form to modify it, are the essential parts of our GUI.
    Since we decided to implement the logic server-side, they are rather barebones.
    Creating a view under `views`/`index.ejs` allows us to render everything to the
    browser via express later. The following example is the HTML code for the frontend:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在能够简单地显示有关地牢的信息，并在请求内跟踪对其所做的任何更改。创建一个视图来呈现状态，以及一个用于修改状态的表单，是我们GUI的基本部分。由于我们决定在服务器端实现逻辑，它们相当简单。在`views`/`index.ejs`下创建一个视图可以让我们稍后通过express将所有内容呈现到浏览器。以下示例是前端的HTML代码：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Gluing the application together via express
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过express将应用程序粘合在一起
- en: 'Now that we are almost done, we have a display for the state, a model to track
    what is changing, and a middleware to load this model as needed. Now, to glue
    it all together we will use express to register our routes and call the necessary
    functions. We mainly need two routes: one to display the page and one to accept
    and process the form input. Displaying the page is done when a user hits the index
    page, so we need to bind to the root path. Accepting the form input is already
    declared in the form itself as `/cells/book`. We can just create a route for it.
    In express, we define routes in relation to the main app object and according
    to the HTTP verbs as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎完成了，我们有一个显示状态的页面，一个用于跟踪变化的模型，以及一个根据需要加载此模型的中间件。现在，为了将所有这些粘合在一起，我们将使用express注册我们的路由并调用必要的函数。我们主要需要两个路由：一个用于显示页面，一个用于接受和处理表单输入。当用户访问首页时，显示页面已经完成，所以我们需要绑定到根路径。接受表单输入已经在表单本身中声明为`/cells/book`。我们只需为其创建一个路由。在express中，我们根据主应用程序对象定义路由，并根据HTTP动词定义如下：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding this to the main `app.js` file allows express to wire things up, the
    routes itself are implemented as follows in the routes/`index.js` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到主`app.js`文件中允许express连接各种东西，路由本身实现如下在routes/`index.js`文件中：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this done, we have a working application to track free and used cells.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这些，我们有一个可以跟踪空闲和已使用单元的工作应用程序。
- en: 'The following shows the frontend output for the tracking system:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了跟踪系统的前端输出：
- en: '![Gluing the application together via express](graphics/B03704_01_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![通过express将应用程序粘合在一起](graphics/B03704_01_03.jpg)'
- en: Moving the application forward
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推动应用程序向前发展
- en: This is only the first step toward the application that will hopefully automate
    what is currently done by hand. With the first start in place, it is now time
    to make sure we can move the application along. We have to think about what this
    application is supposed to do and identify the next steps. After presenting the
    current state back to the business the next request is most likely to be to integrate
    some kind of login, since it will not be possible to modify the state of the dungeon
    unless you are authorized to do it. Since this is a web application, most people
    are familiar with them having a login. This moves us into a complicated space
    in which we need to start specifying the roles in the application along with their
    access patterns; so it is not clear if this is the way to go.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是朝着希望自动化目前手工完成的应用程序的第一步。有了第一步，现在是时候确保我们可以推动应用程序了。我们必须考虑这个应用程序应该做什么，并确定下一步。在向业务展示当前状态后，下一个请求很可能是要集成某种登录，因为如果没有授权，将无法修改地牢的状态。由于这是一个Web应用程序，大多数人都熟悉它们有登录功能。这将使我们进入一个复杂的空间，我们需要开始指定应用程序中的角色以及它们的访问模式；因此目前还不清楚这是否是正确的方法。
- en: Another route to take is starting to move the application towards tracking events
    instead of pure numbers of the free cells. From a developer's point of view, this
    is probably the most interesting route but the immediate business value might
    be hard to justify, since without the login it seems unusable. We need to create
    an endpoint to record events such as fleeing prisoner, and then modify the state
    of the dungeon according to those tracked events. This is based on the assumption
    that the highest value for the application will lie in the prediction of the prisoner
    movement. When we want to track free cells in such a way, we will need to modify
    the way our first version of the application works. The logic on what events need
    to be created will have to move somewhere, most logically the frontend, and the
    dungeon will no longer be the single source of truth for the dungeon state. Rather,
    it will be an aggregator for the state, which is modified by the generation of
    events.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是开始将应用程序转向跟踪事件，而不是纯粹的空闲单元格数量。从开发者的角度来看，这可能是最有趣的路线，但立即的业务价值可能很难证明，因为没有登录似乎是不可用的。我们需要创建一个记录事件的端点，比如逃跑的囚犯，然后根据这些跟踪的事件修改地牢的状态。这是基于这样一个假设，即应用程序的最高价值将在于对囚犯移动的预测。当我们想以这种方式跟踪空闲单元格时，我们将需要修改我们的应用程序的第一个版本的工作方式。关于需要创建哪些事件的逻辑将不得不移动到某个地方，最合理的是前端，地牢将不再是地牢状态的唯一真相来源。相反，它将成为状态的聚合器，通过事件的生成进行修改。
- en: Thinking about the application in such a way makes some things clear. We are
    not completely sure what the value proposition of the application ultimately will
    be. This leads us down a dangerous path since the design decisions that we make
    now will impact how we build new features inside the application. This is also
    a problem in case our assumption about the main value proposition turns out to
    be wrong. In this case, we may have built quite a complex event tracking system
    which does not really solve the problem but complicates things. Every state modification
    needs to be transformed into a series of events where a simple state update on
    an object may have been enough. Not only does this design not solve the real problem,
    explaining it to the orc master is also tough. There are certain abstractions
    missing, and the communication is not following a pattern established as the business
    language. We need an alternative approach to keep the business more involved.
    Also, we need to keep development simple using abstraction on the business logic
    and not on the technologies, which are provided by the frameworks that are used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考应用程序使一些事情变得清晰。我们并不完全确定应用程序的最终价值主张是什么。这将使我们走上一条危险的道路，因为我们现在做出的设计决策将影响我们如何在应用程序内构建新功能。如果我们关于主要价值主张的假设最终是错误的，这也是一个问题。在这种情况下，我们可能已经构建了一个相当复杂的事件跟踪系统，它并没有真正解决问题，而是使事情变得复杂。每个状态修改都需要转换为一系列事件，而对对象的简单状态更新可能已经足够了。这种设计不仅不能解决真正的问题，而且向兽人大师解释起来也很困难。某些抽象缺失，沟通也没有遵循作为业务语言建立的模式。我们需要一种替代方法来让业务更加参与。此外，我们需要保持开发简单，使用业务逻辑上的抽象，而不是技术上的抽象，这些技术由所使用的框架提供。
- en: Another look at the problem
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视问题
- en: So far, we have been looking at the application solely from a web developer's
    point of view. This is a classic case of *when all you have is a hammer, everything
    looks like a nail*. Have we really tackled the core problem already? What questions
    haven't we asked yet? These are important things to ask ourselves. Also, we need
    to figure out what we can ask our business experts to get a better idea on how
    to move forward. So what assumptions did we make beforehand and why?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直从网页开发者的角度看待应用程序。这是一个经典的例子，*当你手中只有一把锤子，一切看起来都像钉子*。我们真的已经解决了核心问题吗？我们还没有问过哪些问题？这些是我们需要问自己的重要问题。此外，我们需要弄清楚我们可以向业务专家提出什么问题，以更好地了解如何前进。我们之前做了什么假设，以及为什么？
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the right tool for the job does extend to the abstractions that we make.
    Solving a problem when you already know the *solution* is a web application, which
    is not always helpful.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合适的工具来解决问题也延伸到我们所做的抽象。当你已经知道*解决方案*是一个网页应用程序时，解决问题并不总是有帮助的。
- en: Thinking in an MVC web application
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个思考MVC网页应用程序的角度
- en: So far, we have been thinking about the problem in terms of a **Model-View-Controller**
    (**MVC**), web application. This brings along a certain set of assumptions that
    might not hold true in the case of our business domain. It is true that creating
    a web interface to manage input and output often does handle the presentation
    of an application today, but this does not mean that this part also holds the
    primary set of logic. In the case of our dungeon manager, it might only be one
    way to access and input data. An information system structured in this way has
    models holding the logic along with the data. These models are backed by a database,
    which is responsible for persistence, and is also used to implement some logic
    via constraints on the data. This means that our domain is pressed in the shape
    of the, most likely relational, database model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在以**模型-视图-控制器**（**MVC**）的方式思考问题，这是一个网页应用程序。这带来了一定的假设，可能在我们的业务领域并不成立。创建一个用于管理输入和输出的网页界面确实通常处理应用程序的呈现，但这并不意味着这部分也包含主要的逻辑。在我们的地牢管理器的情况下，这可能只是访问和输入数据的一种方式。以这种方式构建的信息系统具有包含逻辑和数据的模型。这些模型由数据库支持，负责持久性，并且还用于通过对数据的约束来实现一些逻辑。这意味着我们的领域被压缩成了，很可能是关系型的，数据库模型。
- en: 'All this locks us into a certain set of technologies: a webserver for hosting
    our application, a database for persistence, and a web layer for access and input.
    All these elements become the integral parts of our application and make change
    hard. Also, the model layer has no real abstraction besides being composed of
    a bunch of models. When we want to represent more complex interactions, this might
    not be enough. To be clear, there is no real issue with this as long as the developed
    application primarily consists of the interaction between systems, when however,
    the value proposition is mainly the business logic to be represented between parts
    of the system, this design starts to be not enough anymore.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些将我们锁定在一定的技术集合中：用于托管我们的应用程序的Web服务器，用于持久性的数据库，以及用于访问和输入的Web层。所有这些元素都成为我们应用程序的组成部分，并使变更变得困难。此外，模型层除了由一堆模型组成之外，并没有真正的抽象。当我们想要表示更复杂的交互时，这可能不够。要明确的是，只要开发的应用程序主要由系统之间的交互组成，这并没有真正的问题，但是当价值主张主要是要在系统的各个部分之间表示业务逻辑时，这种设计就不再足够了。
- en: Understanding the core problem
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解核心问题
- en: 'In the case of business applications, a lot of problems and their respective
    solutions are often not explicit. This is true for many areas and an example most
    developers might be familiar with is setting up a webserver. When asking a developer
    or administrator what he has to do to achieve this, it is described in only a
    few steps along the lines of: set up the operating system, install **Apache**,
    configure the site, and then start. For another developer of a system administrator,
    this might be enough to know what to do, but this is hardly reproducible for somebody
    from the outside or, even worse, for a computer.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务应用的情况下，许多问题及其解决方案通常并不明确。这对许多领域都是如此，大多数开发人员可能熟悉的一个例子是设置Web服务器。当询问开发人员或管理员要实现这一目标时，描述的步骤通常只有几步，例如：设置操作系统，安装**Apache**，配置站点，然后启动。对于另一个开发人员或系统管理员来说，这可能足够了解要做什么，但对于外部人员，甚至更糟糕的是对于计算机来说，这几乎无法复制。
- en: Making all the steps explicit is essential to get a grasp of what the core business
    domain really consists of. In our case, we need to make sure to follow what the
    orc master currently does to keep his dungeon running. This can be done by either
    following him around, or making him walk us through his normal business process.
    We can't, however, rely on the business expert to explain the process to us in
    the necessary details. Also,we can't rely on our understanding of it to match
    what really needs to be done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 明确所有步骤对于了解核心业务领域的真正构成至关重要。在我们的情况下，我们需要确保跟随兽人大师目前所做的事情来保持他的地牢运行。这可以通过跟随他周围，或者让他向我们展示他的正常业务流程来完成。然而，我们不能依赖业务专家向我们详细解释流程。此外，我们也不能依赖我们对其理解与实际需要做的事情是否匹配。
- en: The main goal of this exercise, therefore, is to establish a baseline of understanding
    for what is going on and provide a shared language to talk about the problems,
    which will inadvertently arise. We are in an uncertain situation to start out
    with. This should not scare us, but we need to see it as the opportunity to increase
    our own understanding, as well as sometimes even the understanding of the currently
    executing person. Often business experts realize new details about their domain
    when questioning all the steps towards a goal, and they might even identify the
    possible problems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这项练习的主要目标是建立对正在发生的事情的理解基线，并提供一个共同的语言来讨论将不可避免地出现的问题。我们开始处于不确定的情况中。这不应该吓倒我们，而是我们需要将其视为增加自己理解的机会，有时甚至是增加当前执行人员的理解。通常，当质疑达到目标的所有步骤时，业务专家会意识到他们领域的新细节，他们甚至可能会识别可能的问题。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Figuring out where the gaps in understanding a business process are is half
    the battle to implementing it correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 找出对业务流程理解存在差距的地方是正确实施的关键。
- en: In the case of implementing a business process, we can assume that the status
    quo is the least we need to replicate to replace the tools the business is currently
    using. So, first of all, we need to either rebuild or incorporate all the tools
    the business is currently using. We can later find the places where optimization
    makes sense and is possible when we get a firm grasp on the problem in general.
    We should also aim for gradual replacement of processes one by one instead of
    one big switch, as this minimizes the risk for the business.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施业务流程的情况下，我们可以假设现状是我们需要复制以替换业务目前正在使用的工具的最低要求。因此，首先，我们需要重建或整合业务目前正在使用的所有工具。当我们对问题有了牢固的把握后，我们可以找到优化有意义且可能的地方。我们还应该逐步替换一个接一个的流程，而不是一次性进行大规模切换，因为这样可以最大程度地减少业务风险。
- en: Communication is key
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沟通是关键
- en: '|   | *There are only two hard things in Computer Science: cache invalidation
    and naming things.* |   |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   | *计算机科学中只有两件难事：缓存失效和命名事物。* |   |'
- en: '|   | --*Phil Karlton* |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|   | --*菲尔·卡尔顿* |'
- en: When working with applications, it often is a problem to create a shared language
    between developers, product owners, as well as the business people in general.
    It is often stated that naming things is one of the hardest problems of computer
    science, and it is true that having a describing name makes many things easier.
    It is also often the case that a clearly named object is easier to extend because
    its scope is already defined by its name. Therefore, it is often discouraged in
    object-oriented design to name things with general words, such as *Manager*, *Creator*
    or *Processor*. When thinking about this problem in the context of our business
    domain, it becomes clear that we can, and should, reuse the established business
    language as often as possible. It all comes down to communication. We, as the
    developers, are new to the field, so the business experts introducing us will
    already have an established language to describe problems in the domain where
    we are missing them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中工作时，往往很难在开发人员、产品所有者以及业务人员之间创建共享语言。通常有人说，命名事物是计算机科学中最困难的问题之一，有一个描述性的名称确实会让很多事情变得更容易。通常情况下，一个明确定义的对象更容易扩展，因为它的范围已经由它的名称定义。因此，在面向对象设计中，通常不鼓励使用一般性词语来命名事物，比如*Manager*、*Creator*或*Processor*。在考虑这个问题时，我们发现在我们的业务领域中，我们可以并且应该尽可能多地重用已建立的业务语言。这一切都归结为沟通。我们作为开发人员是这个领域的新手，所以介绍我们的业务专家将已经有一个建立的语言来描述我们所缺少的领域中的问题。
- en: 'As we follow along the steps of our business expert, we should take the time
    to get accustomed to the specific language that is in use throughout. This becomes
    even more essential as we start writing code. We will constantly need to check
    in with the domain experts to take their understanding into account, so when we
    use the business language to encode the domain, it will be easier for us to talk
    to everybody around us to develop a better understanding of the domain. This is
    quite abstract, so let me give you an example. Consider this naming for the dungeon:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跟随业务专家的步伐时，我们应该花时间熟悉正在使用的特定语言。当我们开始编写代码时，这变得更加重要。我们将不断需要与领域专家核对，以考虑他们的理解，因此当我们使用业务语言来编码领域时，我们将更容易与周围的每个人交流，以更好地理解领域。这相当抽象，所以让我举个例子。考虑一下地牢的命名：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now consider we want to record changes in the amount of prisoners, and write
    the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑我们想要记录囚犯数量的变化，并编写以下代码：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Even though this is natural to a developer, it does not use any business-specific
    language. We need to explain the meaning of things like `+=` to non-developers
    to make them understand the meaning. Consider on the other hand encoding the same
    logic in the following methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对开发人员来说是自然的，但它并没有使用任何特定于业务的语言。我们需要向非开发人员解释像`+=`这样的东西的含义，以使他们理解含义。另一方面，考虑使用以下方法对相同的逻辑进行编码：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using these methods to express the same thing, it looks vastly more domain
    - specific then before. We can now describe the problem in the context of the
    domain and the code looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法来表达相同的事物，看起来比以前更加领域特定。现在我们可以在领域的上下文中描述问题，代码如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will now become quite clear, even to non-developers, what is going on and
    therefore we can focus on talking about if the behavior is correct rather than
    about the details of the code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在即使对非开发人员来说，发生了什么也变得非常清晰，因此我们可以专注于讨论行为是否正确，而不是代码的细节。
- en: The concepts of domain-driven design
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计的概念。
- en: When developing software, it is all too easy to get caught up in the details
    of implementation, without ever getting to the bottom of the problem. As software
    developers, our main goal is always to add value to the business, and for this
    to work, we first need to be clear what the problem we are trying to solve is.
    This has been attacked in several ways throughout the history of computer science.
    Structured programming gave the developers a way to break a problem into pieces,
    object-orientation attached those pieces to named things that allow for further
    structure and better associate meaning with parts of the program.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，很容易陷入实施细节，而从未深入问题的本质。作为软件开发人员，我们的主要目标始终是为业务增加价值，为了实现这一目标，我们首先需要明确我们试图解决的问题是什么。这在计算机科学的历史上已经有过多种尝试。结构化编程为开发人员提供了一种将问题分解为片段的方法，面向对象则将这些片段附加到命名的事物上，从而进一步构建结构并更好地将含义与程序的各个部分关联起来。
- en: 'Domain-driven designs focus on getting structure in the problem solving process
    and also provide the right starting point to begin a conversation every stakeholder
    can be part of. Language is an important part in this, since communication is
    an area where a lot of projects struggle, as there often is a mismatch between
    engineering and business. While engineering terms are often more specific, the
    business language leaves room for interpretation, leaving it up to the person
    and his or her context to resolve what has been talked about. Both forms of languages
    have their place, as they have been established as an effective form of communication
    in their specific scenario, but translating between these two is often where problems
    or bugs are introduced. To help with these problems, domain-driven design allows
    a developer to classify certain types of object in the communication in several
    forms, all of which are going to be introduced in detail throughout this book:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计专注于在解决问题的过程中建立结构，并提供了正确的起点，以便开始每个利益相关者都可以参与的对话。语言在其中是一个重要部分，因为沟通是许多项目挣扎的领域，因为工程术语往往更具体，而业务语言则留下了解释的空间，让人和他或她的上下文来解决所谈论的问题。这两种形式的语言都有它们的位置，因为它们已经被证明是在特定场景中有效的沟通形式，但在这两者之间进行翻译往往是引入问题或错误的地方。为了帮助解决这些问题，领域驱动设计允许开发人员以多种形式对通信中的某些类型的对象进行分类，所有这些都将在本书中详细介绍：
- en: Value objects
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象
- en: Entities
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Aggregates
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Bounded context
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界上下文
- en: These are concepts that have a certain meaning and allow classification objects,
    which are part of a business process. With this, we can attach meanings and patterns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是具有一定意义并允许对业务流程中的对象进行分类的概念。有了这些，我们可以附加意义和模式。
- en: It is all about distractions
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这一切都是关于分心。
- en: Considering the different ways to create a program, the main improvement that
    structured programming added to the way we program today is the idea that while
    working on a project, the programmer does not always have to have the whole project
    in his head to make sure to not duplicate functionality or interfere with the
    regular flow of the program. This is accomplished by encapsulating functionality
    in chunks to be reusable in other parts. Moving onward, object-oriented programming
    added the ability to further encapsulate functionality in objects, keeping data
    and functions together as one logical unit. One can say a similar thing for functional
    programming, which allows the programmer to think about his program as a flow
    of functions that are defined by their input and therefore can be composed as
    larger units. Domain-driven design now adds a layer on top, which adds abstractions
    to express business logic and can encapsulate it from the outside interaction.
    Creating a business layer that interacts with the outside world via a clearly
    defined API does this in this case.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑创建程序的不同方式，结构化编程对我们今天的编程方式所做的主要改进是，程序员在项目上工作时，不必总是将整个项目记在脑中，以确保不重复功能或干扰程序的正常流程。这是通过将功能封装在可在其他部分重复使用的块中来实现的。接着，面向对象编程增加了进一步将功能封装在对象中的能力，将数据和函数作为一个逻辑单元放在一起。对于函数式编程也可以说类似的事情，它允许程序员将程序看作是由输入定义的函数流，因此可以组合成更大的单元。领域驱动设计现在在此基础上增加了一层，它增加了抽象来表达业务逻辑，并可以将其从外部交互中封装起来。在这种情况下，通过明确定义的API与外部世界进行交互的业务层就是这样做的。
- en: Looking at these different practices, one thing shines through on all levels,
    and this is the idea of removing distractions. When working on a large codebase
    or on a complex problem, the more you have to keep in your head at once, the higher
    the level of distraction from the core problem. This is a major point of **domain-driven
    design**, and we are going to see how this plays out in the next chapter when
    we think about how we can go from a specification that we have seen before, toward
    a problem description we can continue to work with.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些不同的实践中，有一件事在所有层面都闪耀出来，那就是消除分心的想法。在处理大型代码库或复杂问题时，你需要一次记住的东西越多，就越容易分心。这是**领域驱动设计**的一个重要观点，我们将在下一章中看到这是如何发挥作用的，当我们考虑如何从之前看到的规范转向我们可以继续使用的问题描述时。
- en: Focus on the problem at hand
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专注于手头的问题
- en: In a lot of cases, stating the problem is actually not obvious. This is why
    working towards a shared understanding between business experts and developers
    is so important, both sides need to agree on what they expect from a feature,
    or a piece of software. Allowing developers to state in clear terms to the business
    what the feature solves allows the developers to focus on the problem at hand
    and get input more directly. Similar to the principles of test-driven or behavior-driven
    development, stating in a clear fashion what something is intended to do helps
    the development a long way. At this stage, creating a route to get from *A* to
    be *B* as well as objectively stating when a goal has been reached, is what we
    seek. This by no means saves us from reconfirming that the goal is still the one
    to achieve constantly with the business, but it allows us to make this communication
    clear. With the language established, this now does not have to involve multiple
    hour-long meetings with no clear outcome.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，陈述问题实际上并不明显。这就是为什么在业务专家和开发人员之间努力达成共识是如此重要的原因，双方都需要就他们对功能或软件的期望达成一致。允许开发人员清楚地告诉业务功能解决了什么问题，使开发人员能够更直接地专注于手头的问题并获得更直接的输入。类似于测试驱动或行为驱动开发的原则，清晰地陈述某个功能的意图对开发有很大帮助。在这个阶段，创建从*A*到*B*的路径，以及客观地陈述何时达到目标，是我们所追求的。这绝不意味着我们不需要不断确认目标是否仍然是需要不断与业务方确认的，但它使我们能够使这种沟通更加清晰。有了确定的语言，现在就不必再进行多个持续数小时且没有明确结果的会议了。
- en: With all this in mind, it is now time to dive into the essence of domain-driven
    design. Throughout this book, we are going to move our orc dungeon to the 21st
    century, allowing it to flexibly adjust to its business needs. As a first step,
    we are going to sit down and see what running this dungeon is all about and how
    our new software can add value using the concepts and the mindset of domain-driven
    design.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，现在是时候深入领域驱动设计的本质了。在本书中，我们将把我们的兽人地牢带入21世纪，使其能够灵活地适应其业务需求。作为第一步，我们将坐下来看看经营这个地牢到底是什么，以及我们的新软件如何利用领域驱动设计的概念和思维方式增加价值。
- en: Further reading
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Domain-driven design, as seen in this chapter, is described in large by the
    book *Domain-driven design*, by Eric J. Evans. I would recommend every reader
    to follow up with his descriptions to provider a deeper insight into the ideas
    behind domain-driven design in general, outside a more specific topic as described
    here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计，正如本章所述，主要由Eric J. Evans的书《领域驱动设计》描述。我建议每个读者都跟进他的描述，以更深入地了解领域驱动设计的思想，不仅限于本章所描述的更具体的主题。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through the steps of getting started with an application
    as most projects are started today and contrasted it with the domain-driven design
    approach to development. We learned about the key focus of domain-driven design,
    as the communication between the developers and the other parties involved in
    a project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了开始应用程序的步骤，因为大多数项目今天都是这样开始的，并将其与领域驱动设计开发方法进行了对比。我们了解了领域驱动设计的重点，即开发人员与项目中涉及的其他各方之间的沟通。
- en: The key point to takeaway is the strong focus on getting the core feature set
    of the application, before focusing on technology choices and other development-related
    problems that will otherwise subtract resources from the exploration. Another
    important aspect we learned about is how to gather specification in terms of usage.
    The key point here is to gain knowledge about how the work is currently achieved
    and how the application can help besides asking potential users for a specification.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的关键点是，在关注技术选择和其他开发相关问题之前，要着重关注应用程序的核心功能集，否则会从探索中减少资源。我们学到的另一个重要方面是如何收集使用规范。关键点在于获取关于当前工作如何完成以及应用程序如何帮助的知识，而不仅仅是询问潜在用户的规范。
- en: The next chapter focuses deeper on the process of gathering knowledge about
    the use, expected usability of the application, and on the process of starting
    to build a language to aid the communication between the team developing the application,
    build domain experts and developers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章更深入地关注了收集关于应用程序使用、预期可用性的知识的过程，以及开始建立一种语言来帮助开发应用程序的团队、建立领域专家和开发人员之间的沟通过程。
