- en: Concurrent and Multithreaded Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和多线程编程
- en: 'Concurrent programming has always been a difficult task. It is a source of
    many hard-to-solve problems. In this chapter, we will show you different ways
    to incorporate concurrency and some best practices, such as immutability, which
    helps to create multithreaded processing. We will also discuss the implementation
    of some commonly used patterns, such as divide and- conquer and publish-subscribe,
    using the constructs provided by Java. We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程一直是一项困难的任务。它是许多难以解决的问题的根源。在本章中，我们将向您展示不同的整合并发的方式和一些最佳实践，例如不可变性，它有助于创建多线程处理。我们还将讨论一些常用模式的实现，例如分而治之和发布-订阅，使用Java提供的构造。我们将涵盖以下内容：
- en: Using the basic element of concurrency—thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发的基本元素——线程
- en: Different synchronization approaches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的同步方法
- en: Immutability as a means of achieving concurrency
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: Using concurrent collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: Using the executor service to execute async tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork/join实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流来实现发布-订阅模式
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Concurrency—the ability to execute several procedures in parallel—becomes increasingly
    important as big-data analysis moves into the mainstream of modern applications.
    Having CPUs or several cores in one CPU helps increase the throughput, but the
    growth rate of the data volume will always outpace hardware advances. Besides,
    even in a multiple-CPU system, one still has to structure the code and think about
    resource-sharing to take advantage of the available computational power.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并发——能够并行执行多个过程——随着大数据分析进入现代应用程序的主流，变得越来越重要。拥有CPU或一个CPU中的多个核心有助于增加吞吐量，但数据量的增长速度总是超过硬件的进步。此外，即使在多CPU系统中，仍然需要结构化代码并考虑资源共享，以充分利用可用的计算能力。
- en: In the previous chapters, we demonstrated how lambdas with functional interfaces
    and parallel streams made concurrent processing part of the toolkit of every Java
    programmer. One can easily take advantage of this functionality with minimal,
    if any, guidance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们演示了如何使用函数接口和并行流使lambda成为每个Java程序员工具包的一部分，从而实现了并发处理。一个人可以很容易地在最少或没有指导的情况下利用这种功能。
- en: In this chapter, we will describe some other—old (before Java 9) and new—Java
    features and APIs that allow more control over concurrency. The high-level concurrency
    Java API has been around since Java 5\. The JDK Enhancement Proposal (JEP) 266,
    *More Concurrency Updates* ([http://openjdk.java.net/jeps/266](http://openjdk.java.net/jeps/266)), introduced, to
    Java 9 in the `java.util.concurrent `package.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述一些其他（Java 9之前的）和新的Java特性和API，它们允许更多地控制并发。自Java 5以来，高级并发Java API一直存在。JDK增强提案（JEP）266，“更多并发更新”（[http://openjdk.java.net/jeps/266](http://openjdk.java.net/jeps/266)），在Java
    9中引入到`java.util.concurrent`包中。
- en: '"an interoperable publish-subscribe framework, enhancements to the CompletableFuture
    API, and various other improvements"'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “可互操作的发布-订阅框架，对CompletableFuture API的增强以及各种其他改进”
- en: But before we dive into the details of the latest additions, let's review the
    basics of concurrent programming in Java and see how to use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入了解最新添加的细节之前，让我们回顾一下Java中并发编程的基础知识，以及如何使用它们。
- en: Java has two units of execution—process and thread. A process usually represents
    the whole JVM, although an application can create another process using `ProcessBuilder`.
    But since the multiprocess case is outside the scope of this book, we will focus
    on the second unit of execution, that is, a thread, which is similar to a process
    but less isolated from other threads and requires fewer resources for execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两个执行单元——进程和线程。一个进程通常代表整个JVM，尽管应用程序可以使用`ProcessBuilder`创建另一个进程。但由于多进程情况超出了本书的范围，我们将专注于第二个执行单元，即线程，它类似于进程，但与其他线程隔离程度较低，执行所需资源较少。
- en: A process can have many threads running and at least one thread called the *main *thread. Threads
    can share resources, including memory and open files, which allows for better
    efficiency. But it comes with a price of higher risk of unintended mutual interference
    and even blocking of the execution. That is where programming skills and an understanding
    of the concurrency techniques are required. And that is what we are going to discuss
    in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以有许多运行的线程，至少有一个称为*主*线程。线程可以共享资源，包括内存和打开的文件，这可以提高效率。但这也带来了更高的意外相互干扰和甚至阻塞执行的风险。这就需要编程技能和对并发技术的理解。这也是我们将在本章讨论的内容。
- en: Using the basic element of concurrency – thread
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发的基本元素——线程
- en: In this chapter, we will look at the `java.lang.Thread` class and see what it
    can do for concurrency and program performance in general.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究`java.lang.Thread`类，并了解它对并发和程序性能的一般作用。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A Java application starts as the main thread (not counting system threads that
    support the process). It can then create other threads and let them run in parallel,
    sharing the same core via time-slicing or having a dedicated CPU for each thread.
    This can be done using the `java.lang.Thread` class that implements the `Runnable`
    functional interface with only one abstract method, `run()`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序以主线程（不包括支持进程的系统线程）开始。然后它可以创建其他线程，并让它们并行运行，通过时间切片共享同一个核心，或者为每个线程分配一个专用的CPU。这可以使用实现了`Runnable`函数接口的`java.lang.Thread`类来实现，该接口只有一个抽象方法`run()`。
- en: 'There are two ways to create a new thread: creating a subclass of `Thread`,
    or implementing the `Runnable` interface and passing the object of the implementing
    class to the `Thread` constructor. We can invoke the new thread by calling the
    `start()` method of the `Thread` class which, in turn, calls the `run()` method
    that was implemented.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新线程有两种方法：创建`Thread`的子类，或者实现`Runnable`接口并将实现类的对象传递给`Thread`构造函数。我们可以通过调用`Thread`类的`start()`方法来调用新线程，该方法又调用了实现的`run()`方法。
- en: Then, we can either let the new thread run until its completion or pause it
    and let it continue again. We can also access its properties or intermediate results
    if needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以让新线程运行直到完成，或者暂停它然后让它继续。如果需要，我们还可以访问它的属性或中间结果。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'First, we create a class called `AThread` that extends `Thread` and overrides
    its `run()` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`AThread`的类，它扩展了`Thread`并重写了它的`run()`方法：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we want the thread to generate a stream of integers in a certain
    range. Then, we use the `peek()` operation to invoke the `doSomething()` static
    method of the main class for each stream element in order to make the thread busy
    for some time. Refer to the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望线程在特定范围内生成一个整数流。然后，我们使用`peek()`操作来调用主类的`doSomething()`静态方法，以使线程忙碌一段时间。参考以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `doSomething()` method generates a stream of integers in
    the range of `i` to `99999`; it then converts the stream into a stream of doubles,
    calculates the square root of each of the stream elements, and finally calculates
    an average of the stream elements. We discard the result and return the passed-in
    parameter as a convenience that allows us to keep the fluent style in the stream
    pipeline of the thread, which ends by printing out each element. Using this new
    class, we can demonstrate the concurrent execution of the three threads, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`doSomething()`方法生成了一个范围在`i`到`99999`之间的整数流；然后将流转换为双精度流，计算每个流元素的平方根，最后计算流元素的平均值。我们丢弃结果并返回传入的参数，这样可以保持流水线的流畅风格，最后打印出每个元素。使用这个新类，我们可以演示三个线程的并发执行，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thread generates the integers `1`, `2`, and `3`, the second generates
    the integers `11`, `12`, and `13`, and the third thread (main one) generates `21`,
    `22`, and `23`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程生成整数`1`、`2`和`3`，第二个生成整数`11`、`12`和`13`，第三个线程（主线程）生成`21`、`22`和`23`。
- en: 'As mentioned before, we can rewrite the same program by creating and using
    a class that could implement the `Runnable` interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以通过创建和使用一个实现`Runnable`接口的类来重写相同的程序：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One can run the same three threads like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样运行相同的三个线程：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also take advantage of `Runnable` being a functional interface and avoid
    creating an intermediate class by passing in a lambda expression instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用`Runnable`作为一个函数式接口，通过传递lambda表达式来避免创建中间类：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Which implementation is better depends on your goal and style. Implementing
    `Runnable` has an advantage (and in some cases, is the only possible option) that
    allows the implementation to extend another class. It is particularly helpful when
    you would like to add thread-like behavior to an existing class. You can even
    invoke the `run()` method directly, without passing the object to the `Thread`
    constructor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种实现更好取决于你的目标和风格。实现`Runnable`有一个优势（在某些情况下，是唯一可能的选项），允许实现扩展另一个类。当你想要向现有类添加类似线程的行为时，这是特别有帮助的。甚至可以直接调用`run()`方法，而不必将对象传递给`Thread`构造函数。
- en: 'Using a lambda expression wins over the `Runnable` implementation when only the `run()` method
    implementation is needed, no matter how big it is. If it is too big, you can isolate
    it in a separate method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当只需要`run()`方法的实现时，使用lambda表达式胜过`Runnable`实现，无论它有多大。如果它太大，可以将其隔离在一个单独的方法中：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One would be hard-pressed to come up with a shorter implementation of the preceding
    functionality.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想出比前述功能更短的实现。
- en: 'If we run any of the preceding versions, we will get an output that looks something
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行任何前述版本，将会得到类似以下的输出：
- en: '![](img/02e8e127-3a86-4d96-aa56-8c08b69770a4.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e8e127-3a86-4d96-aa56-8c08b69770a4.png)'
- en: As you can see, the three threads print out their numbers concurrently, but
    the sequence depends on the particular JVM implementation and underlying operating
    system. So, you will probably get a different output. Besides, it also may change
    from run to run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这三个线程同时打印出它们的数字，但顺序取决于特定的JVM实现和底层操作系统。因此，你可能会得到不同的输出。此外，它也可能在每次运行时发生变化。
- en: 'The `Thread` class has several constructors that allow setting the thread name
    and the group it belongs to. Grouping threads helps manage them if there are many
    threads running in parallel. The class also has several methods that provide information
    about the thread''s status and properties, and allow us to control the thread''s
    behavior. Add these two lines to the preceding example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有几个构造函数，允许设置线程的名称和所属的组。将线程分组有助于管理它们，如果有许多线程并行运行。该类还有几个方法，提供有关线程状态和属性的信息，并允许我们控制线程的行为。将这两行添加到前面的示例中：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result of the preceding code will look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果将会是这样的：
- en: '![](img/ab04ad0e-d622-42c0-a51f-9bac8a1b1837.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab04ad0e-d622-42c0-a51f-9bac8a1b1837.png)'
- en: 'Next, say you add a name to each thread:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你给每个线程添加一个名字：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, the output will show the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将显示如下内容：
- en: '![](img/e66d2aab-17fb-4b83-ac92-adff52f6f43e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e66d2aab-17fb-4b83-ac92-adff52f6f43e.png)'
- en: The thread's `id` is generated automatically and cannot be changed, but it can
    be reused after the thread is terminated. Several threads, on the other hand,
    can be set with the same name. The execution priority can be set programmatically
    with a value between `Thread.MIN_PRIORITY` and `Thread.MAX_PRIORITY`. The smaller
    the value, the more time the thread is allowed to run, which means it has higher
    priority. If not set, the priority value defaults to `Thread.NORM_PRIORITY`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的`id`是自动生成的，不能更改，但在线程终止后可以重新使用。另一方面，可以为多个线程设置相同的名称。执行优先级可以通过编程方式设置，其值介于`Thread.MIN_PRIORITY`和`Thread.MAX_PRIORITY`之间。值越小，线程被允许运行的时间就越长，这意味着它具有更高的优先级。如果没有设置，优先级值默认为`Thread.NORM_PRIORITY`。
- en: 'The state of a thread can have one of the following values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的状态可以有以下值之一：
- en: '`NEW`: When a thread has not yet started'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`：当一个线程尚未启动时'
- en: '`RUNNABLE`: When a thread is being executed'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`：当一个线程正在执行时'
- en: '`BLOCKED`: When a thread is blocked and is waiting for a monitor lock'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`：当一个线程被阻塞并且正在等待监视器锁时'
- en: '`WAITING`: When a thread is waiting indefinitely for another thread to perform
    a particular action'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`：当一个线程无限期地等待另一个线程执行特定操作时'
- en: '`TIMED_WAITING`: When a thread is waiting for another thread to perform an
    action for up to a specified waiting time'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`：当一个线程等待另一个线程在指定的等待时间内执行操作时'
- en: '`TERMINATED`: When a thread has exited'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`：当一个线程已经退出时'
- en: 'The `sleep()` method can be used to suspend the thread execution for a specified
    (in milliseconds) period of time. The complementary `interrupt()` method sends
    `InterruptedException` to the thread that can be used to wake up the *sleeping*
    thread. Let''s work this out in the code and create a new class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep()`方法可用于暂停线程执行一段指定的时间（以毫秒为单位）。补充的`interrupt()`方法会向线程发送`InterruptedException`，可以用来唤醒*休眠*的线程。让我们在代码中解决这个问题并创建一个新的类：'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code produces intermediate results, which are stored in the `result` property.
    Each time a new result is produced, the thread pauses (sleeps) for one second.
    In this specific example, written for demonstrative purposes only, the code does
    not do anything particularly useful. It just iterates over a set of values and
    considers each of them a result. In real-world code, you would do some calculations
    based on the current state of the system and assign the calculated value to the `result` property.
    Now let''s use this class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会产生中间结果，这些结果存储在`result`属性中。每次产生新的结果时，线程都会暂停（休眠）一秒钟。在这个特定的示例中，仅用于演示目的的代码并没有做任何特别有用的事情。它只是迭代一组值，并将每个值视为结果。在实际的代码中，您将根据系统的当前状态进行一些计算，并将计算出的值分配给`result`属性。现在让我们使用这个类：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/d420d69b-2e20-4865-a348-b973dda270f7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d420d69b-2e20-4865-a348-b973dda270f7.png)'
- en: 'The output may look different on different computers, but you get the idea:
    this way, one thread can control the output of another thread.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在不同的计算机上可能看起来不同，但你明白了：这样，一个线程可以控制另一个线程的输出。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two other important methods that support thread cooperation. The first
    is the `join()` method, which allows the current thread to wait until another
    thread is terminated. Overloaded versions of `join()` accept the parameters that
    define how long the thread has to wait before it can do something else.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个支持线程协作的重要方法。第一个是`join()`方法，它允许当前线程等待另一个线程终止。`join()`的重载版本接受定义线程在可以做其他事情之前必须等待多长时间的参数。
- en: The `setDaemon()` method can be used to make the thread terminate automatically
    after all the non-daemon threads are terminated. Usually, daemon threads are used
    for background and supporting processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`setDaemon()`方法可用于在所有非守护线程终止后使线程自动终止。通常，守护线程用于后台和支持进程。'
- en: Different synchronization approaches
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的同步方法
- en: 'In this recipe, you will learn about the two most popular methods of managing
    concurrent access to common resources in Java: `synchronized method` and `synchronized
    block`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习Java中管理共享资源的并发访问的两种最流行的方法：`synchronized method`和`synchronized block`。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Two or more threads modifying the same value while other threads read it is
    the most general description of one of the problems of concurrent access. Subtler
    problems include **thread interference** and **memory consistency errors**, which
    both produce unexpected results in seemingly benign fragments of code. We are
    going to demonstrate such cases and ways to avoid them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多线程同时修改相同的值，而其他线程读取它，这是并发访问问题的最一般描述。更微妙的问题包括线程干扰和内存一致性错误，这两者都会在看似良性的代码片段中产生意外结果。我们将演示这些情况以及避免它们的方法。
- en: 'At first glance, it seems quite straightforward: just allow only one thread
    at a time to modify/access the resource and that''s it. But if the access takes
    a long time, it creates a bottleneck that might eliminate the advantage of having
    many threads working in parallel. Or, if one thread blocks access to one resource
    while waiting for access to another resource and the second thread blocks access
    to the second resource while waiting for access to the first one, it creates a
    problem called a **deadlock**. These are two very simple examples of the possible
    challenges a programmer has to tackle when dealing with multiple threads.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎很简单：只允许一个线程一次修改/访问资源，就可以了。但是如果访问需要很长时间，就会创建一个可能消除多个线程并行工作优势的瓶颈。或者，如果一个线程在等待访问另一个资源时阻塞了对一个资源的访问，而第二个线程在等待对第一个资源的访问时阻塞了对第二个资源的访问，就会创建一个称为死锁的问题。这些都是程序员在处理多个线程时可能面临的挑战的两个非常简单的例子。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we''ll reproduce a problem caused by the concurrent modification of
    the same value. Let''s create a `Calculator` class that has the `calculate()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重现由并发修改相同值引起的问题。让我们创建一个`Calculator`类，其中有`calculate()`方法：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method assigns an input value to a property and then calculates its square
    root. We also inserted two lines of code that generate streams of 50 and 100 values.
    We did this to keep the method busy for some time. Otherwise, everything is done
    so quickly that there will be little chance for any concurrency to occur. Our
    adding the 100-values-generating code gives another thread a chance to assign
    the `prop` field another value before the current thread calculates the square
    root of the value the current thread has just assigned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将一个输入值分配给一个属性，然后计算其平方根。我们还插入了两行代码，生成了50和100个值的流。我们这样做是为了让方法忙一段时间。否则，一切都会很快完成，几乎没有并发的机会。我们添加生成100个值的代码给另一个线程一个机会，在当前线程计算当前线程刚刚分配的值的平方根之前，为`prop`字段分配另一个值。
- en: 'Now we are going to use the `calculate()` method in the following code fragment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在以下代码片段中使用`calculate()`方法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The two preceding threads modify the same property of the same `Calculator` object
    concurrently. Here is the result we got from one of our runs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个线程同时修改同一个`Calculator`对象的同一个属性。以下是我们从其中一个运行中得到的结果：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you run these examples on your computer and do not see the effect of concurrency,
    try to increase the number of doubles generated in the *slowing* line by replacing `100` with `1000`,
    for example. When the results of the threads are different, it means that in the
    period between setting the value of the `prop` field and returning its square
    root in the `calculate()` method, the other thread managed to assign a different
    value to `prop`. This is the case of thread interference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在计算机上运行这些示例，并且看不到并发效果，请尝试通过将*slowing*行中的`100`替换为`1000`来增加生成的双倍数量，例如。当线程的结果不同时，这意味着在设置`prop`字段的值并在`calculate()`方法中返回其平方根之间的时间段内，另一个线程设法为`prop`分配了不同的值。这是线程干扰的情况。
- en: 'There are two ways to protect code from such a problem: using `synchronized
    method` or `synchronized block`—both help to execute code as an atomic operation
    without any interference from another thread.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 保护代码免受这种问题的两种方法：使用`synchronized method`或`synchronized block`——两者都有助于在没有其他线程干扰的情况下执行代码作为原子操作。
- en: 'Making `synchronized method` is easy and straightforward:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 制作`synchronized method`很容易和直接：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We just add the `synchronized` keyword in front of the method definition. Now,
    the results of both threads are going to always be the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在方法定义前面添加`synchronized`关键字。现在，两个线程的结果将始终相同：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is because another thread cannot enter the synchronized method until the
    current thread (the one that has entered the method already) has exited it. This
    approach may cause performance degradation if the method takes a long time to
    execute. In such cases, `synchronized block` can be used, which wraps not the
    whole method but only several lines of code in an atomic operation. In our case,
    we can move the *slowing* line of code that generates 50 values outside the synchronized
    block:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为另一个线程在当前线程（已经进入方法的线程）退出之前，无法进入同步方法。如果方法执行时间很长，这种方法可能会导致性能下降。在这种情况下，可以使用`synchronized
    block`，它不是包装整个方法，而是包装几行代码，使其成为原子操作。在我们的情况下，我们可以将生成50个值的*slowing*代码行移出同步块：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, the synchronized portion is much smaller, thus it has fewer chances
    to become a bottleneck.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，同步部分要小得多，因此它更少地成为瓶颈的机会。
- en: '`synchronized block` acquires a lock on an object—any object, for that matter.
    In a huge class, you might not notice that the current object (this) is used as
    a lock for several blocks. And a lock acquired on a class is even more susceptible
    to unexpected sharing. So, it is better to use a dedicated lock:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized block`在对象上获取锁—任何对象，无论如何。在一个庞大的类中，您可能不会注意到当前对象（this）被用作多个块的锁。并且在类上获取的锁更容易出现意外共享。因此，最好使用专用锁：'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A dedicated lock has a higher level of assurance that the lock will be used
    to access only a particular block.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 专用锁具有更高的保证级别，该锁将用于仅访问特定块。
- en: 'We did all these examples just to demonstrate synchronization approaches. If
    they were real code, we would just let each thread create its own `Calculator`
    object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了所有这些示例，只是为了演示同步方法。如果它们是真正的代码，我们将让每个线程创建自己的`Calculator`对象：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would be in line with the general idea of making lambda expressions independent
    of the context in which they are created. This is because, in a multithreaded
    environment, one never knows how the context will look during their execution.
    The cost of creating a new object every time is negligible unless a large amount
    of data has to be processed, and testing ensures that the object-creation overhead
    is noticeable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将符合使lambda表达式独立于它们创建的上下文的一般思想。这是因为在多线程环境中，人们永远不知道它们执行期间上下文会是什么样子。每次创建一个新对象的成本是可以忽略不计的，除非必须处理大量数据，并且测试确保对象创建开销是显而易见的。
- en: Memory consistency errors can have many forms and causes in a multithreaded
    environment. They are well discussed in the Javadoc of the `java.util.concurrent` package.
    Here, we will mention only the most common case, which is caused by a lack of
    visibility. When one thread changes a property value, the other might not see
    the change immediately, and you cannot use the `synchronized` keyword for a primitive
    type. In such a situation, consider using the `volatile` keyword for the property;
    it guarantees its read/write visibility between different threads.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，内存一致性错误可能具有许多形式和原因。它们在`java.util.concurrent`包的Javadoc中有很好的讨论。在这里，我们只提到最常见的情况，即由于可见性不足而引起的。当一个线程更改属性值时，另一个可能不会立即看到更改，并且您不能为原始类型使用`synchronized`关键字。在这种情况下，考虑为属性使用`volatile`关键字；它保证了不同线程之间的读/写可见性。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Different types of locks for different needs and with different behaviors are
    assembled in the `java.util.concurrent.locks` package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的锁用于不同的需求，并具有不同的行为，这些锁被组装在`java.util.concurrent.locks`包中。
- en: The `java.util.concurrent.atomic` package provides support for lock-free, thread-safe
    programming on single variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`包提供了对单个变量进行无锁、线程安全编程的支持。'
- en: 'The following classes provide synchronization support too:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类也提供了同步支持：
- en: '`Semaphore`: This restricts the number of threads that can access a resource'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`：这限制了可以访问资源的线程数量'
- en: '`CountDownLatch`: This allows one or more threads to wait until a set of operations
    being performed in other threads are completed'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`：这允许一个或多个线程等待，直到其他线程中执行的一组操作完成'
- en: '`CyclicBarrier`: This allows a set of threads to wait for each other to reach
    a common barrier point'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：这允许一组线程等待彼此达到一个共同的屏障点'
- en: '`Phaser`: This provides a more flexible form of barrier that may be used to
    control phased computation among multiple threads'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`：这提供了一种更灵活的屏障形式，可用于控制多个线程之间的分阶段计算'
- en: '`Exchanger`: This allows two threads to exchange objects at a rendezvous point
    and is useful in several pipeline designs'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger`：这允许两个线程在会合点交换对象，并在几个管道设计中非常有用。'
- en: Each object in Java inherits the `wait()`, `notify()`, and `notifyAll()` methods
    from the base object. These methods can also be used to control the threads' behavior
    and their access to the locks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的每个对象都继承了基本对象的`wait()`、`notify()`和`notifyAll()`方法。这些方法也可以用来控制线程的行为和它们对锁的访问。
- en: 'The `Collections` class has methods that synchronize various collections. However,
    this means that only the modifications of the collection could become thread-safe,
    not the changes to the collection members. Also, while traversing the collection
    via its iterator, it has to be protected too because an iterator is not thread-safe.
    Here is a Javadoc example of the correct usage of a synchronized map:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类有方法来同步各种集合。然而，这意味着只有对集合的修改才能变得线程安全，而对集合成员的更改则不是。此外，通过其迭代器遍历集合时，也必须进行保护，因为迭代器不是线程安全的。以下是一个正确使用同步映射的Javadoc示例：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To add more to your plate as a programmer, you have to realize that the following
    code is not thread-safe:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你必须意识到以下代码不是线程安全的：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because although `List l` is synchronized, in multithreaded processing,
    it is quite possible that some other code would add more elements to the list
    or remove an element.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为虽然`List l`是同步的，在多线程处理中，很可能会有其他代码向列表添加更多元素或删除元素。
- en: The concurrency problems are not easy to solve. That is why it is not surprising
    that more and more developers now take a more radical approach. Instead of managing
    an object state, they prefer processing data in a set of stateless operations.
    We saw examples of such code in [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml),
    *Streams and Pipelines*. It seems that Java and many modern languages and computer
    systems are evolving in this direction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题并不容易解决。这就是为什么越来越多的开发人员现在采取更激进的方法。他们更喜欢在一组无状态操作中处理数据，而不是管理对象状态。我们在[第5章](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml)中看到了这种代码的例子，*流和管道*。看来Java和许多现代语言和计算机系统正在朝着这个方向发展。
- en: Immutability as a means of achieving concurrency
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: In this recipe, you will learn how to use immutability against problems caused
    by concurrency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何使用不可变性来解决并发引起的问题。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A concurrency problem most often occurs when different threads modify and read
    data of the same shared resource. Decreasing the number of modifying operations
    diminishes the risk of concurrency issues. This is where immutability—the condition
    of read-only values—enters the stage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题最常发生在不同的线程修改和读取同一共享资源的数据时。减少修改操作的数量会减少并发问题的风险。这就是不可变性——只读值的条件——进入舞台的地方。
- en: Object immutability means an absence of means to change its state after the
    object has been created. It does not guarantee thread-safety but helps to increase
    it significantly and provide sufficient protection from concurrency problems in
    many practical applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的不可变性意味着在创建对象后无法更改其状态。这并不能保证线程安全，但有助于显著增加线程安全性，并在许多实际应用程序中提供足够的保护，以防止并发问题。
- en: Creating a new object instead of reusing an existing one (by changing its state
    via setters and getters) is often perceived as an expensive approach. But with
    the power of modern computers, there has to be a huge number of object creations
    done for performance to be affected in any significant way. And even if that is
    the case, programmers often choose some performance degradation as the price for
    getting predictable results.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新对象而不是通过设置器和获取器更改其状态来重用现有对象通常被认为是一种昂贵的方法。但是随着现代计算机的强大，必须大量创建对象才能显著影响性能。即使是这种情况，程序员通常也会选择一些性能下降作为获得可预测结果的代价。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is an example of a class that produces mutable objects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个产生可变对象的类的示例：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make it immutable, we need to remove the setter and add the `final` keyword
    to its only property and to the class itself:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其不可变，我们需要删除设置器，并将`final`关键字添加到其唯一属性和类本身：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Adding the `final` keyword to a class prevents it from being extended, so its
    methods cannot be overridden. Adding `final` to a private property is not as obvious.
    The motivation is somewhat complex and has to do with the way the compiler reorders
    the fields during object construction. If the field is declared `final`, it is
    treated by the compiler as synchronized. That is why adding `final` to a private property
    is necessary to make the object completely immutable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 向类添加`final`关键字可以防止其被扩展，因此其方法不能被覆盖。向私有属性添加`final`并不那么明显。动机有些复杂，与编译器在对象构造期间重新排序字段的方式有关。如果字段声明为`final`，编译器会将其视为同步。这就是为什么向私有属性添加`final`是必要的，以使对象完全不可变。
- en: 'The challenge mounts up if the class is composed of other classes, especially
    mutable ones. When this happens, the injected class might bring in code that would
    affect the containing class. Also, the inner (mutable) class, which is retrieved
    by references via the getter, could then be modified and propagate the change
    inside the containing class. The way to close such holes is to generate new objects
    during the composition of the object retrieval. Here is an example of this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类由其他类组成，特别是可变类，挑战就会增加。当这种情况发生时，注入的类可能会带入会影响包含类的代码。此外，通过getter引用检索的内部（可变）类可能会被修改并传播更改到包含类内部。关闭这种漏洞的方法是在对象检索的组合期间生成新对象。以下是一个示例：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In our examples, we used very simple code. If more complexity is added to any
    of the methods, especially with parameters (and especially when some of the parameters
    are objects), it is possible you''ll get concurrency issues again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了非常简单的代码。如果任何方法中添加了更多复杂性，特别是带有参数（尤其是当一些参数是对象时），可能会再次出现并发问题：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even if this method belongs to `ImmutableClass` and does not affect the state
    of the `ImmutableClass` object, it is still a subject of the thread's race and
    has to be analyzed and protected as needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 即使此方法属于`ImmutableClass`，并且不影响`ImmutableClass`对象的状态，它仍然是线程竞争的主题，并且必须根据需要进行分析和保护。
- en: The `Collections` class has methods that make various collections unmodifiable.
    It means that the modification of the collection itself becomes read-only, not
    the collection members.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类具有使各种集合不可修改的方法。这意味着集合本身的修改变为只读，而不是集合成员。'
- en: Using concurrent collections
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: In this recipe, you will learn about the thread-safe collections of the `java.util.concurrent` package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将了解`java.util.concurrent`包的线程安全集合。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A collection can be synchronized if you apply one of the `Collections.synchronizeXYZ()` methods
    to it; here, we have used XYZ as a placeholder that represents either `Set`, `List`,
    `Map`, or one of the several collection types (see the API of the `Collections`
    class). We have already mentioned that the synchronization applies to the collection
    itself, not to its iterator or the collection members.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对集合应用`Collections.synchronizeXYZ()`方法之一，则可以对集合进行同步；在这里，我们使用XYZ作为占位符，表示`Set`、`List`、`Map`或几种集合类型之一（请参阅`Collections`类的API）。我们已经提到，同步适用于集合本身，而不适用于其迭代器或集合成员。
- en: Such synchronized collections are also called **wrappers** because all of the
    functionality is still provided by the collections passed as parameters to the `Collections.synchronizeXYZ()` methods,
    while the wrappers provide only thread-safe access to them. The same effect could
    be achieved by acquiring a lock on the original collection. Obviously, such a
    synchronization incurs a performance overhead in a multithreading environment,
    causing each thread to wait for its turn to access the collection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同步集合也被称为**包装器**，因为所有功能仍由作为参数传递给`Collections.synchronizeXYZ()`方法的集合提供，而包装器仅提供对它们的线程安全访问。通过在原始集合上获取锁也可以实现相同的效果。显然，在多线程环境中，这种同步会产生性能开销，导致每个线程等待轮流访问集合。
- en: A well-tuned application for performance implementation of thread-safe collections
    is provided by the `java.util.concurrent` package.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包提供了性能实现线程安全集合的良好调整的应用程序。'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Each of the concurrent collections of the `java.util.concurrent` package implements
    (or extends, if it is an interface) one of the four interfaces of the `java.util`
    package: `List`, `Set`, `Map`, or `Queue`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包的每个并发集合都实现（或扩展，如果它是一个接口）`java.util`包的四个接口之一：`List`、`Set`、`Map`或`Queue`：'
- en: 'The `List` interface has only one implementation: the `CopyOnWriteArrayList` class.
    The following is taken from the Javadoc of this class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List`接口只有一个实现：`CopyOnWriteArrayList`类。以下摘自此类的Javadoc：'
- en: '"all mutative operations (add, set, and so on) are implemented by making a
    fresh copy of the underlying array... The "snapshot" style iterator method uses
    a reference to the state of the array at the point that the iterator was created.
    This array never changes during the lifetime of the iterator, so interference
    is impossible and the iterator is guaranteed not to throw `ConcurrentModificationException`.
    The iterator will not reflect additions, removals, or changes to the list since
    the iterator was created. Element-changing operations on iterators themselves
    (remove, set, and add) are not supported. These methods throw `UnsupportedOperationException`."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “所有改变操作（添加、设置等）都是通过制作基础数组的新副本来实现的...“快照”样式的迭代器方法使用对迭代器创建时数组状态的引用。在迭代器的生命周期内，此数组永远不会更改，因此不可能发生干扰，并且保证迭代器不会抛出`ConcurrentModificationException`。迭代器不会反映自创建迭代器以来对列表的添加、删除或更改。迭代器本身的元素更改操作（删除、设置和添加）不受支持。这些方法会抛出`UnsupportedOperationException`。”
- en: 'To demonstrate the behavior of the `CopyOnWriteArrayList` class, let''s compare
    it with `java.util.ArrayList` (which is not a thread-safe implementation of `List`).
    Here is the method that adds an element to the list while iterating on the same
    list:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示`CopyOnWriteArrayList`类的行为，让我们将其与`java.util.ArrayList`（不是`List`的线程安全实现）进行比较。以下是在迭代相同列表时向列表添加元素的方法：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Consider the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we execute this code, the result will be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行此代码，结果将如下所示：
- en: '![](img/4ff7a7b6-d0d6-4594-9007-d4f8fe5e9d31.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ff7a7b6-d0d6-4594-9007-d4f8fe5e9d31.png)'
- en: As you can see, `ArrayList` throws `ConcurrentModificationException` when the
    list is modified while being iterated (we used the same thread for simplicity
    and because it leads to the same effect, as in the case of another thread modifying
    the list). The specification, though, does not guarantee that the exception will
    be thrown or the list modification applied (as in our case), so a programmer should
    not base the application logic on such behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当在迭代列表时修改列表时，`ArrayList`会抛出`ConcurrentModificationException`（我们为简单起见使用了相同的线程，因为它会导致与另一个线程修改列表的情况一样的效果）。尽管规范并不保证会抛出异常或应用列表修改（如我们的情况），因此程序员不应该基于这种行为来构建应用程序逻辑。
- en: The `CopyOnWriteArrayList` class, on the other hand, tolerates the same intervention;
    however, note that it does not add a new element to the current list because the
    iterator was created from a snapshot of the fresh copy of the underlying array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`CopyOnWriteArrayList`类容忍相同的干预；但请注意，它不会将新元素添加到当前列表中，因为迭代器是从底层数组的新副本快照创建的。
- en: 'Now let''s try to remove a list element concurrently while traversing the list,
    using this method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用这种方法在遍历列表时并发地删除列表元素：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Consider the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we execute this, we will get the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个，我们将得到以下结果：
- en: '![](img/4bef3bd5-c517-4ec4-9882-24da9bec2772.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bef3bd5-c517-4ec4-9882-24da9bec2772.png)'
- en: The behavior is similar to the previous example. The `CopyOnWriteArrayList` class
    allows the concurrent access to the list but does not allow modify the current
    list's copy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 行为与前面的例子类似。`CopyOnWriteArrayList`类允许并发访问列表，但不允许修改当前列表的副本。
- en: 'We knew `ArrayList` would not be thread-safe for a long time, so we used a
    different technique to remove an element from the list while traversing it. Here
    is how this was done before the Java 8 release:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很久以前就知道`ArrayList`不是线程安全的，因此我们使用了不同的技术来在遍历列表时删除列表中的元素。这是在Java 8发布之前完成的：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s try this and run the code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这样做并运行代码：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result will be as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/c3cdf125-0dbf-4fec-96b7-379aed0651a6.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3cdf125-0dbf-4fec-96b7-379aed0651a6.png)'
- en: 'This is exactly what the Javadoc warned about ([https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/beta2/apidiffs/java/util/concurrent/CopyOnWriteArrayList.html](https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/beta2/apidiffs/java/util/concurrent/CopyOnWriteArrayList.html)):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Javadoc所警告的（[https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/beta2/apidiffs/java/util/concurrent/CopyOnWriteArrayList.html](https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/beta2/apidiffs/java/util/concurrent/CopyOnWriteArrayList.html)）：
- en: '"Element-changing operations on iterators themselves (remove, set, and add)
    are not supported. These methods throw UnsupportedOperationException."'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '"迭代器本身的元素更改操作（删除、设置和添加）不受支持。这些方法会抛出UnsupportedOperationException异常。"'
- en: We should remember this when upgrading an application to make it work in a multithreaded
    environment—just changing from `ArrayList()` to `CopyOnWriteArrayList` would not
    be enough if we use an iterator to remove a list element.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序升级以使其在多线程环境中工作时，我们应该记住这一点——如果我们使用迭代器来删除列表元素，仅仅从`ArrayList()`更改为`CopyOnWriteArrayList`是不够的。
- en: 'Since Java 8, there is a better way to remove an element from a collection
    using a lambda, which should be used as it leaves the plumbing details to the
    library code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，有一种更好的方法可以使用lambda从集合中删除元素，应该使用它，因为它将管道细节留给库代码：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So let''s do this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们这样做：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![](img/f11bd846-7dc6-4cd3-9d78-701ecafaba2a.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f11bd846-7dc6-4cd3-9d78-701ecafaba2a.png)'
- en: It is short and has no problem with any of the collections and is in line with
    the general trend of having a stateless parallel computation that uses streams
    with lambdas and functional interfaces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它很简短，并且不会出现任何与集合相关的问题，符合使用流、lambda和函数接口进行无状态并行计算的一般趋势。
- en: 'Also, after we upgrade an application to use the `CopyOnWriteArrayList` class, we
    can take advantage of a simpler way of adding a new element to the list (without
    first checking whether it is already there):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们将应用程序升级为使用`CopyOnWriteArrayList`类后，我们可以利用一种更简单的方法向列表中添加新元素（无需首先检查它是否已存在）：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With `CopyOnWriteArrayList`, this can be done as an atomic operation, so one
    does not need to synchronize the if-not-present-then-add block of code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CopyOnWriteArrayList`，这可以作为原子操作完成，因此不需要同步如果-不存在-则添加代码块。
- en: Let's review the concurrent collections of the `java.util.concurrent` package
    that implements the `Set` interface. There are three such implementations—`ConcurrentHashMap.KeySetView`,
    `CopyOnWriteArraySet`, and `ConcurrentSkipListSet`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现`Set`接口的`java.util.concurrent`包的并发集合。有三种这样的实现——`ConcurrentHashMap.KeySetView`、`CopyOnWriteArraySet`和`ConcurrentSkipListSet`。
- en: The first one is just a view of the keys of `ConcurrentHashMap`. It is backed
    up by `ConcurrentHashMap` (which can be retrieved by the `getMap()` method). We
    will review the behavior of  `ConcurrentHashMap` later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`ConcurrentHashMap`键的视图。它由`ConcurrentHashMap`支持（可以通过`getMap()`方法检索）。我们稍后将审查`ConcurrentHashMap`的行为。
- en: The second implementation of `Set` in the `java.util.concurrent` package is
    the `CopyOnWriteArraySet` class. Its behavior is similar to the `CopyOnWriteArrayList` class.
    In fact, it uses the `CopyOnWriteArrayList` class's implementation under the hood.
    The only difference is that it does not allow duplicate elements in the collection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包中`Set`的第二个实现是`CopyOnWriteArraySet`类。其行为类似于`CopyOnWriteArrayList`类。实际上，它在底层使用了`CopyOnWriteArrayList`类的实现。唯一的区别是它不允许集合中有重复元素。'
- en: 'The third (and last) implementation of `Set` in the `java.util.concurrent` package
    is `ConcurrentSkipListSet`; it implements a sub-interface of `Set` called `NavigableSet`.
    According to the Javadoc of the `ConcurrentSkipListSet` class, insertion, removal,
    and access operations are safely executed concurrently by multiple threads*.* There
    are some limitations described in the Javadoc too:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent`包中的第三（也是最后一个）`Set`实现是`ConcurrentSkipListSet`；它实现了`Set`的一个子接口`NavigableSet`。根据`ConcurrentSkipListSet`类的Javadoc，插入、移除和访问操作可以由多个线程安全并发执行。Javadoc中也描述了一些限制：
- en: It does not permit the use of `null` elements.
  id: totrans-181
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许使用`null`元素。
- en: The size of the set is calculated dynamically by traversing the collection,
    so it may report inaccurate results if this collection is modified during the
    operation.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的大小是通过遍历集合动态计算的，因此如果在操作期间修改了此集合，它可能报告不准确的结果。
- en: The `addAll()`, `removeIf()`, and `forEach()` operations are not guaranteed
    to be performed atomically. The `forEach()` operation, if concurrent with an `addAll()`
    operation for example, "might observe only some of the added elements."
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll()`，`removeIf()`和`forEach()`操作不能保证原子执行。例如，如果`forEach()`操作与`addAll()`操作并发进行，可能会“观察到只有一些添加的元素”。'
- en: 'The implementation of the  `ConcurrentSkipListSet` class is based on the `ConcurrentSkipListMap` class,
    which we will discuss shortly. To demonstrate the behavior of the `ConcurrentSkipListSet` class,
    let''s compare it with the `java.util.TreeSet` class (non-concurrent implementation
    of `NavigableSet`). We start with removing an element:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListSet`类的实现基于`ConcurrentSkipListMap`类，我们将很快讨论。为了演示`ConcurrentSkipListSet`类的行为，让我们将其与`java.util.TreeSet`类（`NavigableSet`的非并发实现）进行比较。我们首先移除一个元素：'
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, this code is not very efficient; we''ve removed the same element
    many times without checking for its presence. We have done this just for demonstrative
    purposes. Besides, since Java 8, the same `removeIf()` method works for `Set`
    just fine. But we would like to bring up the behavior of the new `ConcurrentSkipListSet` class, so
    let''s execute this code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码并不是很高效；我们多次移除了相同的元素而没有检查其是否存在。我们这样做只是为了演示目的。此外，自Java 8以来，相同的`removeIf()`方法对`Set`也可以正常工作。但我们想提出新的`ConcurrentSkipListSet`类的行为，所以让我们执行这段代码：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output will be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/2bacd443-00a8-45c1-8a5c-14c5fc52e246.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bacd443-00a8-45c1-8a5c-14c5fc52e246.png)'
- en: 'As expected, the `ConcurrentSkipListSet` class handles the concurrency and
    even removes an element from the current set, which is helpful. It also removes
    an element via an iterator without an exception. Consider the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`ConcurrentSkipListSet`类处理并发性，甚至从当前集合中移除一个元素，这是有帮助的。它还通过迭代器移除元素而不会抛出异常。考虑以下代码：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run this for `TreeSet` and  `ConcurrentSkipListSet`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对`TreeSet`和`ConcurrentSkipListSet`运行此操作：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We won''t get any exception:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会得到任何异常：
- en: '![](img/179b44f4-2176-4707-bb2a-dfd3d85e9793.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/179b44f4-2176-4707-bb2a-dfd3d85e9793.png)'
- en: 'This is because, according to the Javadoc, the iterator of `ConcurrentSkipListSet`
    is weakly consistent, which means the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为根据Javadoc，`ConcurrentSkipListSet`的迭代器是弱一致的，这意味着以下内容：
- en: They may proceed concurrently with other operations
  id: totrans-197
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与其他操作同时进行
- en: They will never throw `ConcurrentModificationException`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们永远不会抛出`ConcurrentModificationException`
- en: They are guaranteed to traverse elements as they existed upon construction exactly
    once, and may (but are not guaranteed to) reflect any modifications subsequent
    to construction (from the Javadoc)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们保证遍历元素时仅在构造时存在一次，并且可能（但不保证）反映构造后的任何修改（来自Javadoc）
- en: This "not guaranteed" part is somewhat disappointing, but it is better than
    getting an exception, as with `CopyOnWriteArrayList`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“不保证”的部分有些令人失望，但比起`CopyOnWriteArrayList`抛出异常要好。
- en: 'Adding to a `Set` class is not as problematic as to a `List` class because
    `Set` does not allow duplicates and handles the necessary checks internally:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Set`类添加不像向`List`类那样有问题，因为`Set`不允许重复，并且会在内部处理必要的检查：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Consider the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we run this, we''ll get the following result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们将得到以下结果：
- en: '![](img/6063c61a-3f6d-4680-a137-5b6bc60d1d73.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6063c61a-3f6d-4680-a137-5b6bc60d1d73.png)'
- en: As before, we observe that the concurrent `Set` version handles concurrency
    better.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们观察到并发`Set`版本处理并发性更好。
- en: 'Let''s turn to the `Map` interface, which has two implementations in the `java.util.concurrent` package:
    `ConcurrentHashMap` and `ConcurrentSkipListMap`.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转向`Map`接口，在`java.util.concurrent`包中有两个实现：`ConcurrentHashMap`和`ConcurrentSkipListMap`。
- en: The `ConcurrentHashMap` class from the Javadoc.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`ConcurrentHashMap`类的Javadoc。
- en: '"supports full concurrency of retrievals and high concurrency for updates"'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: “支持检索的完全并发性和更新的高并发性”
- en: It is a thread-safe version of `java.util.HashMap` and is analogous to `java.util.Hashtable`
    in this respect. In fact, the `ConcurrentHashMap` class meets the requirements
    of the same functional specification as `java.util.Hashtable`, although its implementation
    is "somewhat different in synchronization details"(from the Javadoc).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它是`java.util.HashMap`的线程安全版本，并且在这方面类似于`java.util.Hashtable`。实际上，`ConcurrentHashMap`类满足与`java.util.Hashtable`相同的功能规范要求，尽管其实现在“同步细节上有些不同”（来自Javadoc）。
- en: Unlike `java.util.HashMap` and `java.util.Hashtable`, `ConcurrentHashMap` supports,
    according to its Javadoc ([https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ConcurrentHashMap.html](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ConcurrentHashMap.html)),
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与`java.util.HashMap`和`java.util.Hashtable`不同，`ConcurrentHashMap`支持，根据其Javadoc（[https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ConcurrentHashMap.html](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ConcurrentHashMap.html)），
- en: '"a set of sequential and parallel bulk operations that, unlike most Stream
    methods, are designed to be safely, and often sensibly, applied even with maps
    that are being concurrently updated by other threads"'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: “一组顺序和并行的大容量操作，与大多数Stream方法不同，它们被设计为安全地，通常是明智地，即使在被其他线程并发更新的映射中也可以应用”
- en: '`forEach()`: This performs a given action on each element'
  id: totrans-214
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`: 这对每个元素执行给定的操作'
- en: '`search()`: This returns the first available non-null result of applying a
    given function to each element'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`: 这返回将给定函数应用于每个元素的第一个可用的非空结果'
- en: '`reduce()`: This accumulates each element (there are five overloaded versions)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`: 这累积每个元素（有五个重载版本）'
- en: These bulk operations accept a `parallelismThreshold` argument that allows deferring
    parallelization until the map size reaches the specified threshold. Naturally,
    when the threshold is set to `Long.MAX_VALUE`, there will be no parallelism whatsoever.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大容量操作接受一个`parallelismThreshold`参数，允许推迟并行化，直到映射大小达到指定的阈值。当阈值设置为`Long.MAX_VALUE`时，将根本没有并行性。
- en: There are many other methods in the class API, so refer to its Javadoc for an
    overview.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类API中还有许多其他方法，因此请参考其Javadoc以获取概述。
- en: Unlike `java.util.HashMap` (and similar to `java.util.Hashtable`), neither `ConcurrentHashMap` nor
    `ConcurrentSkipListMap` allows null to be used as a key or value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与`java.util.HashMap`不同（类似于`java.util.Hashtable`），`ConcurrentHashMap`和`ConcurrentSkipListMap`都不允许将null用作键或值。
- en: The second implementation of `Map`—the `ConcurrentSkipListSet` class—is based,
    as we mentioned before, on the `ConcurrentSkipListMap` class, so all the limitations of
    the `ConcurrentSkipListSet` class we just described apply to the `ConcurrentSkipListMap` class
    too. The `ConcurrentSkipListSet` class is practically a thread-safe version of
    `java.util.TreeMap`. `SkipList` is a sorted data structure that allows fast searches
    concurrently. All the elements are sorted based on their natural sorting order
    of keys. The `NavigableSet` functionality we demonstrated for the `ConcurrentSkipListSet` class is
    present in the `ConcurrentSkipListMap` class too. For many other methods in the
    class API, refer to its Javadoc.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Map`的实现——`ConcurrentSkipListSet`类——基于我们之前提到的`ConcurrentSkipListMap`类，因此我们刚刚描述的`ConcurrentSkipListSet`类的所有限制也适用于`ConcurrentSkipListMap`类。`ConcurrentSkipListSet`类实际上是`java.util.TreeMap`的线程安全版本。`SkipList`是一种排序的数据结构，允许并发快速搜索。所有元素都根据它们的键的自然排序顺序进行排序。我们为`ConcurrentSkipListSet`类演示的`NavigableSet`功能在`ConcurrentSkipListMap`类中也存在。有关类API中的许多其他方法，请参考其Javadoc。
- en: 'Now let''s demonstrate the difference in the behavior in response to concurrency
    between the `java.util.HashMap`, `ConcurrentHashMap`, and `ConcurrentSkipListMap` classes.
    First, we will write the method that generates a test `Map` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们演示`java.util.HashMap`、`ConcurrentHashMap`和`ConcurrentSkipListMap`类在响应并发性方面的行为差异。首先，我们将编写生成测试`Map`对象的方法：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is the code that adds an element to a `Map` object concurrently:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将元素添加到`Map`对象的代码：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run this for all three implementations of `Map`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Map`的所有三个实现运行此操作：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we do this, we get an output for `HashMap` for the first key only:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们将只为第一个键的`HashMap`获得输出：
- en: '![](img/99df2694-2099-4ac5-8475-84cd92f6a363.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99df2694-2099-4ac5-8475-84cd92f6a363.png)'
- en: 'We also get an output for `ConcurrentHashMap` and `ConcurrentSkipListMap` for
    all the keys, including the newly added ones. Here is the last section of the `ConcurrentHashMap` output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为所有键（包括新添加的键）的`ConcurrentHashMap`和`ConcurrentSkipListMap`获得输出。以下是`ConcurrentHashMap`输出的最后一部分：
- en: '![](img/c935da11-bec2-4daf-b06f-6fc4e2d1aa33.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c935da11-bec2-4daf-b06f-6fc4e2d1aa33.png)'
- en: 'As mentioned already, the appearance of `ConcurrentModificationException` is
    not guaranteed. Now we see that the moment it is thrown (if it is thrown) is the
    moment when the code discovers that the modification has taken place. In the case
    of our example, it happened in the next iteration. Another point worth noting
    is that the current set of keys changes even as we isolate the set in a separate
    variable:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不能保证会出现`ConcurrentModificationException`。现在我们看到，它被抛出的时刻（如果被抛出）是代码发现修改已经发生的时刻。在我们的例子中，它发生在下一个迭代中。另一个值得注意的是，即使我们将集合隔离在一个单独的变量中，当前的键集合也会发生变化：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This reminds us not to dismiss the changes propagated through the objects via
    their references.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们不要忽视通过它们的引用传播的对象的更改。
- en: 'To save ourselves some space and time, we will not show the code for concurrent
    removal and just summarize the results. As expected, `HashMap` throws the `ConcurrentModificationException` exception
    when an element is removed in any of the following ways:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间和时间，我们将不展示并发删除的代码，只总结结果。如预期的那样，当以任何以下方式之一删除元素时，`HashMap`会抛出`ConcurrentModificationException`异常：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The concurrent removal can be done using `Iterator` in one of the following
    ways:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Iterator`以以下一种方式之一进行并发删除：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By contrast, the two concurrent `Map` implementations allow a concurrent element
    removal not just using `Iterator`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这两个并发`Map`实现不仅允许使用`Iterator`进行并发元素删除。
- en: 'Similar behavior is also exhibited by all the concurrent implementations of
    the `Queue` interface: `LinkedTransferQueue`, `LinkedBlockingQueue`, `LinkedBlockingDequeue`,
    `ArrayBlockingQueue`, `PriorityBlockingQueue`, `DelayQueue`, `SynchronousQueue`,
    `ConcurrentLinkedQueue`, and `ConcurrentLinkedDequeue`, all in the `java.util.concurrent`
    package. But to demonstrate all of them would require a separate volume, so we
    leave it up to you to browse the Javadoc and provide an example of `ArrayBlockingQueue`
    only. The queue will be represented by the `QueueElement` class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`接口的所有并发实现也表现出类似的行为：`LinkedTransferQueue`、`LinkedBlockingQueue`、`LinkedBlockingDequeue`、`ArrayBlockingQueue`、`PriorityBlockingQueue`、`DelayQueue`、`SynchronousQueue`、`ConcurrentLinkedQueue`和`ConcurrentLinkedDequeue`，都在`java.util.concurrent`包中。但要演示它们所有将需要一个单独的卷，因此我们将其留给您浏览Javadoc并提供`ArrayBlockingQueue`的示例。队列将由`QueueElement`类表示：'
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The queue producer will be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 队列生产者将如下所示：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following will be the queue consumer:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是队列消费者：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Its results may look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它的结果可能如下所示：
- en: '![](img/1f475fea-7d38-4c00-af7e-518ba520b778.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f475fea-7d38-4c00-af7e-518ba520b778.png)'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before we select which collections to use, read the Javadoc to see whether the
    limitations of the collection are acceptable for your application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要使用的集合之前，请阅读Javadoc，看看集合的限制是否适合您的应用程序。
- en: For example, as per the Javadoc, the `CopyOnWriteArrayList` class
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，根据Javadoc，`CopyOnWriteArrayList`类
- en: '"is ordinarily too costly, but may be more efficient than alternatives when
    traversal operations vastly outnumber mutations, and is useful when you cannot
    or don''t want to synchronize traversals, yet need to preclude interference among
    concurrent threads."'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “通常成本太高，但当遍历操作远远超过变异操作时可能更有效，并且在您不能或不想同步遍历但需要阻止并发线程之间干扰时非常有用。”
- en: Use it when you do not need to add new elements at different positions and do
    not require sorting. Otherwise, use `ConcurrentSkipListSet`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不需要在不同位置添加新元素并且不需要排序时，请使用它。否则，请使用`ConcurrentSkipListSet`。
- en: The `ConcurrentSkipListSet` and `ConcurrentSkipListMap` classes, as per the
    Javadoc,
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Javadoc，`ConcurrentSkipListSet`和`ConcurrentSkipListMap`类
- en: '"provide expected average log(n) time cost for the contains, add, and remove
    operations and their variants. Ascending ordered views and their iterators are
    faster than descending ones."'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “为包含、添加和删除操作及其变体提供预期的平均log(n)时间成本。升序排序的视图及其迭代器比降序排序的视图及其迭代器更快。”
- en: Use them when you need to iterate quickly through the elements in a certain
    order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要按特定顺序快速迭代元素时，请使用它们。
- en: Use `ConcurrentHashMap` when the concurrency requirements are very demanding
    and you need to allow locking on the write operation but do not need to lock the
    element.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发要求非常苛刻并且需要在写操作上允许锁定但不需要锁定元素时，请使用`ConcurrentHashMap`。
- en: '`ConcurrentLinkedQueque` and `ConcurrentLinkedDeque` are an appropriate choice
    when many threads share access to a common collection. `ConcurrentLinkedQueque`
    employs an efficient non-blocking algorithm.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多线程共享对公共集合的访问时，`ConcurrentLinkedQueque`和`ConcurrentLinkedDeque`是一个合适的选择。`ConcurrentLinkedQueque`采用了高效的非阻塞算法。
- en: '`PriorityBlockingQueue` is a better choice when a natural order is acceptable
    and you need fast adding of elements to the tail and fast removing of elements
    from the head of the queue. Blocking means that the queue waits to become non-empty
    when retrieving an element and waits for space to become available in the queue
    when storing an element.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`是一个更好的选择，当自然顺序是可以接受的，并且您需要快速向队列尾部添加元素和快速从队列头部删除元素时。阻塞意味着队列在检索元素时等待变得非空，并在存储元素时等待队列中有空间可用。'
- en: '`ArrayBlockingQueue`, `LinkedBlockingQueue`, and `LinkedBlockingDeque` have
    a fixed size (they are bounded). The other queues are unbounded.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`，`LinkedBlockingQueue`和`LinkedBlockingDeque`具有固定大小（它们是有界的）。其他队列是无界的。'
- en: Use these and similar characteristics and recommendations as the guidelines,
    but execute comprehensive testing and performance-measuring before and after implementing
    your functionality.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些类似特性和建议作为指南，但在实现功能之前进行全面测试和性能测量。
- en: Using the executor service to execute async tasks
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: In this recipe, you will learn how to use `ExecutorService` to implement controllable
    thread-execution.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何使用`ExecutorService`来实现可控的线程执行。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In an earlier recipe, we demonstrated how to create and execute threads using
    the `Thread` class directly. It is an acceptable mechanism for a small number
    of threads that run and produce results predictably quickly. For big-scale applications
    with longer-running threads with complex logic (which might keep them alive for
    an unpredictably long time) and/or a number of threads growing unpredictably too,
    a simple create-and-run-until-exit approach might result in an `OutOfMemory` error
    or require a complex customized system of threads' status maintenance and management.
    For such cases, `ExecutorService` and related classes of the `java.util.concurrent`
    package provides an out-of-the-box solution that relieves a programmer of the
    need to write and maintain a lot of infrastructural code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的示例中，我们演示了如何直接使用`Thread`类创建和执行线程。这是一个适用于少量线程的可接受机制，可以快速运行并产生可预测的结果。对于长时间运行且具有复杂逻辑的大规模应用程序（可能会使它们长时间保持活动状态）和/或线程数量也在不可预测增长的情况下，简单的创建和运行直到退出的方法可能会导致`OutOfMemory`错误，或者需要复杂的自定义线程状态维护和管理系统。对于这种情况，`ExecutorService`和`java.util.concurrent`包的相关类提供了一个开箱即用的解决方案，解除了程序员编写和维护大量基础设施代码的需要。
- en: At the foundation of the Executor Framework lies an `Executor` interface that
    has only one `void execute(Runnable command)` method that executes the given command
    at some time in the future.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Executor Framework的基础上，有一个只有一个`void execute(Runnable command)`方法的`Executor`接口，它在将来的某个时间执行给定的命令。
- en: 'Its subinterface, `ExecutorService`, adds methods that allow you to manage
    the executor:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它的子接口`ExecutorService`添加了一些允许您管理执行器的方法：
- en: The `invokeAny()`, `invokeAll()`, and `awaitTermination()` methods and `submit()` allow
    you to define how the threads will be executed and whether they are expected to
    return some values
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny()`，`invokeAll()`和`awaitTermination()`方法以及`submit()`允许您定义线程将如何执行以及它们是否预期返回一些值'
- en: The `shutdown()` and `shutdownNow()` methods allow you to shut down the executor
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`和`shutdownNow()`方法允许您关闭执行器'
- en: The `isShutdown()` and `isTerminated()` methods provide the status of the executor
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`和`isTerminated()`方法提供了执行器的状态'
- en: 'The objects of `ExecutorService` can be created with the static factory methods
    of the `java.util.concurrent.Executors` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`的对象可以使用`java.util.concurrent.Executors`类的静态工厂方法创建：'
- en: '`newSingleThreadExecutor()`: Creates an `Executor` method that uses a single
    worker thread operating off an unbounded queue. It has an overloaded version with
    `ThreadFactory` as a parameter.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 创建一个使用单个工作线程并在无界队列上运行的`Executor`方法。它有一个带有`ThreadFactory`作为参数的重载版本。'
- en: '`newCachedThreadPool()`: Creates a thread pool that creates new threads as
    needed, but reuses previously constructed threads when they are available. It
    has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 创建一个线程池，根据需要创建新线程，但在可用时重用先前构造的线程。它有一个带有`ThreadFactory`作为参数的重载版本。'
- en: '`newFixedThreadPool(int nThreads)`: Creates a thread pool that reuses a fixed
    number of threads operating off a shared unbounded queue. It has an overloaded
    version with `ThreadFactory` as a parameter.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool(int nThreads)`: 创建一个线程池，该线程池重用固定数量的线程，这些线程在共享的无界队列上运行。它有一个带有`ThreadFactory`作为参数的重载版本。'
- en: The `ThreadFactory` implementation allows you to override the process of creating
    new threads, enabling applications to use special thread subclasses, priorities,
    and so on. A demonstration of its usage is outside the scope of this book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFactory`实现允许您重写创建新线程的过程，使应用程序能够使用特殊的线程子类、优先级等。其使用示例超出了本书的范围。'
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'One important aspect of the behavior of the `Executor` interface you need to
    remember is that once created, it keeps running (waiting for new tasks to execute)
    until the Java process is stopped. So, if you would like to free memory, the `Executor` interface
    has to be stopped explicitly. If not shut down, forgotten executors will create
    a memory leak. Here is one possible way to make sure no executor is left behind:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要记住的`Executor`接口行为的一个重要方面是，一旦创建，它会一直运行（等待执行新任务），直到Java进程停止。因此，如果要释放内存，必须显式停止`Executor`接口。如果不关闭，被遗忘的执行程序将导致内存泄漏。以下是确保没有执行程序被遗留下来的一种可能方法：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can pass a worker (an implementation of either the `Runnable` or `Callable` functional
    interface) for execution to `ExecutorService` in a variety of ways, which we will
    see shortly. In this example, we executed two threads: one using the `execute()`
    method and another using the `submit()` method. Both methods accept `Runnable`
    or `Callable`, but we used only `Runnable` in this example. The `submit()` method returns
    `Future`, which represents the result of an asynchronous computation.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以各种方式将工作程序（`Runnable`或`Callable`功能接口的实现）传递给`ExecutorService`进行执行，我们将很快看到。在本例中，我们执行了两个线程：一个使用`execute()`方法，另一个使用`submit()`方法。这两种方法都接受`Runnable`或`Callable`，但在本例中我们只使用了`Runnable`。`submit()`方法返回`Future`，它表示异步计算的结果。
- en: The `shutdown()` method initiates an orderly shutdown of the previously submitted
    tasks and prevents any new tasks from being accepted. This method does not wait
    for the task to complete the execution. The `awaitTermination()` method does that.
    But after `shutdownDelaySec`, it stops blocking and the code flow gets into the `finally`
    block, where the `isTerminated()` method returns `true` if all the tasks are completed
    following the shutdown. In this example, we have two tasks executed in two different
    statements. But note that other methods of `ExecutorService` accept a collection
    of tasks.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown()`方法启动先前提交的任务的有序关闭，并阻止接受任何新任务。此方法不等待任务完成执行。`awaitTermination()`方法会等待。但是在`shutdownDelaySec`之后，它停止阻塞，代码流进入`finally`块，在该块中，如果所有任务在关闭后都已完成，则`isTerminated()`方法返回true。在本例中，我们在两个不同的语句中执行了两个任务。但请注意，`ExecutorService`的其他方法接受任务集合。'
- en: In such a case, when the service is shutting down, we iterate over the collection
    of `Future` objects. We call each task and cancel it if it is not completed yet,
    possibly doing something else that had to be done before canceling the task. How
    much time to wait (the value of `shutdownDelaySec`) has to be tested for each
    application and the possible running tasks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当服务关闭时，我们遍历`Future`对象的集合。我们调用每个任务，如果任务尚未完成，则取消它，可能在取消任务之前执行其他必须完成的任务。等待多长时间（`shutdownDelaySec`的值）必须针对每个应用程序和可能正在运行的任务进行测试。
- en: Finally, the `shutdownNow()` method says that it
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`shutdownNow()`方法表示
- en: '"attempts to stop all actively executing tasks, halts the processing of waiting
    tasks, and returns a list of the tasks that were awaiting execution"'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表”
- en: (according to the Javadoc).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: （根据Javadoc）。
- en: 'Collect and assess the results. In a real application, we typically do not
    want to shut down a service often. We just check the status of the tasks and collect
    the results of those that return true from the `isDone()` method. In the preceding
    code example, we just show how to make sure that when we do stop the service,
    we do it in a controlled manner, without leaving behind any runaway process. If
    we run that code example, we will get the following:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集和评估结果。在实际应用中，我们通常不希望经常关闭服务。我们只检查任务的状态，并收集那些从`isDone()`方法返回true的任务的结果。在前面的代码示例中，我们只是展示了如何确保当我们停止服务时，我们以一种受控的方式进行，而不会留下任何失控的进程。如果运行该代码示例，我们将得到以下结果：
- en: '![](img/3db89b96-4315-4b22-8ddb-3690ff485551.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3db89b96-4315-4b22-8ddb-3690ff485551.png)
- en: 'Generalize the preceding code and create a method that shuts down a service
    and the task that has returned `Future`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概括前面的代码并创建一个关闭服务和返回`Future`的任务的方法：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Enhance the example by making `Runnable` (using the lambda expression) sleep
    for some time (simulating useful work to be done):'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用lambda表达式使`Runnable`休眠一段时间（模拟需要完成的有用工作）来增强示例：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note the two parameters, `shutdownDelaySec` (defines how long the service will
    wait without allowing new tasks to be submitted before moving on and shutting
    itself down, eventually) and `threadSleepSec` (defines how long the worker is
    sleeping, indicating that the simulating process is doing its job).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个参数，`shutdownDelaySec`（定义服务在继续关闭自身之前等待多长时间，不允许提交新任务）和`threadSleepSec`（定义工作者睡眠的时间，表示模拟过程正在工作）。
- en: 'Run the new code for different implementations of `ExecutorService` and the `shutdownDelaySec` and `threadSleepSec` values:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行不同的`ExecutorService`实现和`shutdownDelaySec`和`threadSleepSec`值的新代码：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is how the output may look (it might be slightly different on your computer,
    depending on the exact timing of the events controlled by the operating system):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的样子（在你的电脑上可能略有不同，取决于操作系统控制的事件的确切时间）：
- en: '![](img/37890a3f-7807-46ef-b5e7-a0ba414fc995.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37890a3f-7807-46ef-b5e7-a0ba414fc995.png)'
- en: 'Analyze the results. In the first example, we find no surprise because of the
    following line:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析结果。在第一个例子中，我们没有惊喜，因为以下一行：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It is blocking for three seconds, whereas each worker works for one second only.
    So it is enough time for each worker to complete its work even for a single-thread
    executor.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它会阻塞三秒，而每个工作者只工作一秒。所以即使是单线程执行器，每个工作者都有足够的时间完成工作。
- en: 'Let''s make the service wait for one second only:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让服务只等待一秒：
- en: '![](img/43c2a4e6-d333-437c-a082-47aceb424a33.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43c2a4e6-d333-437c-a082-47aceb424a33.png)'
- en: When you do this, you will notice that none of the tasks will be completed.
    In this case, worker `One` was interrupted (see the last line of the output),
    while task `Two` was canceled.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会注意到没有一个任务会被完成。在这种情况下，工作者`One`被中断了（参见输出的最后一行），而任务`Two`被取消了。
- en: 'Let''s make the service wait for three seconds:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让服务等待三秒：
- en: '![](img/6b9b8113-e7fe-442f-b0cf-e2fde29a1554.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b9b8113-e7fe-442f-b0cf-e2fde29a1554.png)'
- en: Now we see that worker `One` was able to complete its task, while worker `Two`
    was interrupted.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到工作者`One`能够完成它的任务，而工作者`Two`被中断了。
- en: 'The `ExecutorService` interface produced by `newCachedThreadPool()` or `newFixedThreadPool()`
    performs similarly on a one-core computer. The only significant difference is
    that if the `shutdownDelaySec` value is equal to the `threadSleepSec` value, then
    they both allow you to complete the threads:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由`newCachedThreadPool()`或`newFixedThreadPool()`产生的`ExecutorService`接口在单核计算机上表现类似。唯一的显著区别是，如果`shutdownDelaySec`的值等于`threadSleepSec`的值，那么它们都允许你完成线程：
- en: '![](img/e2998059-be37-4833-83bc-be14f7c2ed44.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2998059-be37-4833-83bc-be14f7c2ed44.png)'
- en: This was the result of using `newCachedThreadPool()`. The output of the example
    using `newFixedThreadPool()` looks exactly the same on a one-core computer.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`newCachedThreadPool()`的结果。使用`newFixedThreadPool()`的例子在单核计算机上看起来完全一样。
- en: 'To have more control over the task, check the returned value of the `Future` object,
    not just submit a task and wait hoping it will be completed as needed. There is
    another method, called `submit()`, in the `ExecutorService` interface that allows
    you to not only return a `Future` object but also include the result that is passed
    to the method as a second parameter in the return object. Let''s check out an
    example of this:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地控制任务，检查`Future`对象的返回值，而不仅仅是提交一个任务并希望它按需要完成。`ExecutorService`接口中还有一个名为`submit()`的方法，允许你不仅返回一个`Future`对象，还可以将结果作为第二个参数传递给该方法并包含在返回对象中。让我们看一个例子：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The value of `result` is `42`. This method can be helpful when you have submitted
    many workers (`nWorkers`) and need to know which one is completed:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`的值是`42`。当你提交了很多工作者（`nWorkers`）并且需要知道哪一个已经完成时，这个方法会很有帮助：'
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Well, the catch is that `future.get()` is a blocking method. This is why we
    use a version of the `get()` method that allows us to set the `delaySec` timeout.
    Otherwise, `get()` blocks the iteration.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，问题在于`future.get()`是一个阻塞方法。这就是为什么我们使用`get()`方法的一个版本，允许我们设置`delaySec`超时。否则，`get()`会阻塞迭代。
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s move a step closer to real-life code and create a class that implements
    `Callable` and allows you to return a result from a worker as an object of the `Result` class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更接近实际代码，创建一个实现`Callable`并允许你将工作者的结果作为`Result`类对象返回的类：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: An actual numeric result is returned by the `getResult()` method. Here, we also
    included the name of the worker and how long the thread is expected to sleep (to
    work) just for convenience and to better illustrate the output.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的数值结果是由`getResult()`方法返回的。在这里，我们还包括了工作者的名字以及线程预计睡眠的时间（为了方便和更好地说明输出）。
- en: 'The worker itself is going to be an instance of the `CallableWorkerImpl` class:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者本身将是`CallableWorkerImpl`类的一个实例：
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, the number `42` is an actual numeric result, which a worker supposedly
    calculated (while sleeping). The  `CallableWorkerImpl` class implemented the `CallableWorker` interface:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字`42`是一个实际的数值结果，一个工作者在睡觉的时候计算出来的。`CallableWorkerImpl`类实现了`CallableWorker`接口：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We had to make the methods default and return some data (they will be overridden
    by the class implementation anyway) to preserve its `functional interface` status.
    Otherwise, we would not be able to use it in lambda expressions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将方法设置为默认的并返回一些数据（它们无论如何都会被类实现覆盖）以保持其`functional interface`状态。否则，我们将无法在lambda表达式中使用它。
- en: 'We will also create a factory that will generate a list of workers:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个工厂，用于生成工作者列表：
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can use all these new classes and methods to demonstrate the `invokeAll()` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用所有这些新的类和方法来演示`invokeAll()`方法：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `printResults()` method outputs the results received from the workers:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResults()`方法输出从工作者那里收到的结果：'
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To get the results, again we use a version of the `get()` method with timeout
    settings. Run the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得结果，我们再次使用了带有超时设置的`get()`方法的一个版本。运行以下代码：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Its output will be as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 它的输出将如下：
- en: '![](img/19552493-b1f0-4f37-965a-adb41534e80e.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19552493-b1f0-4f37-965a-adb41534e80e.png)'
- en: It's probably worth mentioning that the three workers were created with sleep
    times of one, two, and three seconds, while the waiting time before the service
    shuts down is one second. This is why all the workers were canceled.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，三个工作线程的睡眠时间分别为一秒、两秒和三秒，而服务关闭前的等待时间为一秒。这就是为什么所有工作线程都被取消的原因。
- en: 'Now if we set the waiting time to six seconds, the output of the single-thread
    executor will be as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将等待时间设置为六秒，单线程执行程序的输出将如下所示：
- en: '![](img/64677f6d-f5e8-40bc-9fa2-79fde02c30a8.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64677f6d-f5e8-40bc-9fa2-79fde02c30a8.png)'
- en: Naturally, if we increase the waiting time again, all the workers will be able
    to complete their tasks.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们再次增加等待时间，所有工作线程将能够完成它们的任务。
- en: 'The `ExecutorService` interface produced by `newCachedThreadPool()` or `newFixedThreadPool()`
    performs much better even on a one-core computer:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由`newCachedThreadPool()`或`newFixedThreadPool()`产生的`ExecutorService`接口在单核计算机上表现得更好：
- en: '![](img/368e2984-b863-4348-944f-43a6c747de12.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/368e2984-b863-4348-944f-43a6c747de12.png)'
- en: As you can see, all the threads were able to complete even with three seconds
    of waiting time.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，即使等待时间为三秒，所有线程也能够完成。
- en: 'As an alternative, instead of setting a timeout during the service shutdown,
    you can possibly set it on the overloaded version of the `invokeAll()` method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您可以在服务关闭期间设置超时，也可以在`invokeAll()`方法的重载版本上设置超时：
- en: '[PRE64]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'There is one particular aspect of the `invokeAll()` method''s behavior that
    often gets overlooked and causes surprises for first-time users: it returns only
    after all the tasks are complete (either normally or by throwing an exception). Read
    the Javadoc and experiment until you recognize that this behavior is acceptable
    for your application.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAll()`方法的一个特定方面经常被忽视，这会给初次使用者带来惊喜：它只有在所有任务完成（正常或通过抛出异常）后才返回。阅读Javadoc并进行实验，直到您认识到这种行为对您的应用程序是可以接受的。'
- en: By contrast, the `invokeAny()` method blocks only until at least one task is
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`invokeAny()`方法只会阻塞，直到至少有一个任务完成
- en: '"completed successfully (without throwing an exception), if any do. Upon normal
    or exceptional return, tasks that have not completed are cancelled"'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: “成功完成（没有抛出异常），如果有的话。在正常或异常返回时，未完成的任务将被取消”
- en: 'The preceding quote is from the Javadoc ([https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html)).
    Here is an example of the code that does this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引用来自Javadoc（[https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html)）。以下是执行此操作的代码示例：
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can experiment with it, setting different values for the waiting time (`shutdownDelaySec`)
    and sleep time for threads until you are comfortable with how this method behaves.
    As you can see, we have reused the `shutdownAndCancelTasks()` method by passing
    an empty list of `Future` objects since we do not have them here.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试设置等待时间（`shutdownDelaySec`）和线程的睡眠时间的不同值，直到您对此方法的行为感到满意为止。正如您所看到的，我们通过传递一个空的`Future`对象列表来重用了`shutdownAndCancelTasks()`方法，因为我们这里没有这些对象。
- en: There's more...
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are two more static factory methods in the `Executors` class that create
    instances of `ExecutorService`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors`类中还有两个静态工厂方法，用于创建`ExecutorService`的实例：'
- en: '`newWorkStealingPool()`: This creates a work-stealing thread pool using the
    number of available processors as its target parallelism level. It has an overloaded
    version with a parallelism level as a parameter.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newWorkStealingPool()`: 使用可用处理器的数量作为目标并行级别创建工作窃取线程池。它有一个带有并行级别参数的重载版本。'
- en: '`unconfigurableExecutorService(ExecutorService executor)`: This returns an
    object that delegates all the defined `ExecutorService` methods to the given executor,
    except for those methods that might otherwise be accessible using casts.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfigurableExecutorService(ExecutorService executor)`: 返回一个对象，该对象将所有已定义的`ExecutorService`方法委托给给定的执行程序，除了可能使用转换访问的那些方法。'
- en: Also, a sub-interface of the `ExecutorService` interface, called `ScheduledExecutorService`,
    enhances the API with the capability to schedule a thread execution in future
    and/or their periodic execution.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ExecutorService`接口的子接口`ScheduledExecutorService`通过增强API的能力来在将来调度线程执行和/或它们的周期性执行。
- en: 'The objects of `ScheduledExecutorService` can be created using the static factory
    methods of the `java.util.concurrent.Executors` class:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledExecutorService`的对象可以使用`java.util.concurrent.Executors`类的静态工厂方法来创建：'
- en: '`newSingleThreadScheduledExecutor()`: Creates a single-threaded executor that
    can schedule commands to run after a given delay or to execute them periodically.
    It has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`: 创建一个可以在给定延迟后调度命令运行或定期执行命令的单线程执行程序。它有一个带有`ThreadFactory`参数的重载版本。'
- en: '`newScheduledThreadPool(int corePoolSize)`: Creates a thread pool that can
    schedule commands to run after a given delay or to execute them periodically.
    It has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool(int corePoolSize)`: 创建一个可以在给定延迟后调度命令运行或定期执行命令的线程池。它有一个带有`ThreadFactory`参数的重载版本。'
- en: '`unconfigurableScheduledExecutorService( ScheduledExecutorService executor
    )`: Returns an object that delegates all the defined `ScheduledExecutorService`
    methods to the given executor, but not any other methods that might otherwise
    be accessible using casts.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfigurableScheduledExecutorService( ScheduledExecutorService executor
    )`: 返回一个对象，该对象将所有已定义的`ScheduledExecutorService`方法委托给给定的执行程序，但不包括可能使用转换访问的其他方法。'
- en: The `Executors` class also has several overloaded methods that accept, execute,
    and return `Callable` (which, in contrast with `Runnable`, contains the result).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors`类还有几个重载方法，接受、执行和返回`Callable`（与`Runnable`相反，它包含结果）。'
- en: 'The `java.util.concurrent` package also includes classes that implement `ExecutorService`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包还包括实现`ExecutorService`的类：'
- en: '`ThreadPoolExecutor`: This class executes each submitted task using one of
    the several pooled threads, normally configured using the `Executors` factory
    methods.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`：这个类使用几个池化线程中的一个来执行每个提交的任务，通常使用`Executors`工厂方法进行配置。'
- en: '`ScheduledThreadPoolExecutor`: This class extends the `ThreadPoolExecutor`
    class and implements the `ScheduledExecutorService` interface.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`：这个类扩展了`ThreadPoolExecutor`类，并实现了`ScheduledExecutorService`接口。'
- en: '`ForkJoinPool`: It manages the execution of workers (the `ForkJoinTask` processes)
    using a work-stealing algorithm. We will discuss it in the next recipe.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`：它使用工作窃取算法管理工作者（`ForkJoinTask`进程）的执行。我们将在下一个示例中讨论它。'
- en: Instances of these classes can be created via class constructors that accept
    more parameters, including the queue that holds the results, for providing more
    refined thread-pool management.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的实例可以通过接受更多参数的类构造函数创建，包括保存结果的队列，以提供更精细的线程池管理。
- en: Using fork/join to implement divide-and-conquer
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fork/join实现分而治之
- en: In this recipe, you will learn how to use the fork/join framework for the divide-and-conquer
    computation pattern.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用fork/join框架来进行分而治之的计算模式。
- en: Getting ready
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As mentioned in the previous recipe, the `ForkJoinPool` class is an implementation
    of the `ExecutorService` interface that manages the execution of workers—the `ForkJoinTask`
    processes—using the work-stealing algorithm. It takes advantage of multiple processors,
    if available, and works best on tasks that can be broken down into smaller tasks
    recursively, which is also called a **divide-and-conquer** strategy.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一示例中所述，`ForkJoinPool`类是`ExecutorService`接口的实现，使用工作窃取算法管理工作者（`ForkJoinTask`进程）的执行。如果有多个处理器可用，它会充分利用，并且最适合可以递归地分解为更小任务的任务，这也被称为**分而治之**策略。
- en: Each thread in the pool has a dedicated double-ended queue (deque) that stores
    tasks, and the thread picks up the next task (from the head of the queue) as soon
    as the current task is completed. When another thread finishes executing all the
    tasks in its queue, it can take a task (steal it) from the tail of a non-empty
    queue of another thread.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 池中的每个线程都有一个专用的双端队列（deque）来存储任务，线程在当前任务完成后立即从队列头部获取下一个任务。当另一个线程执行完其队列中的所有任务时，它可以从另一个线程的非空队列尾部获取任务（窃取）。
- en: As with any `ExecutorService` implementation, the fork/join framework distributes
    tasks to worker threads in a thread pool. This framework is distinct because it
    uses a work-stealing algorithm. Worker threads that run out of tasks can steal
    tasks from other threads that are still busy.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何`ExecutorService`实现一样，fork/join框架将任务分配给线程池中的工作者线程。这个框架是独特的，因为它使用工作窃取算法。运行完任务的工作者线程可以从仍在忙碌的其他线程中窃取任务。
- en: Such a design balances the load and allows an efficient use of the resources.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计可以平衡负载，并有效利用资源。
- en: For demonstrative purposes, we are going to use the API created in [Chapter
    3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml), *Modular Programming*, the `TrafficUnit`,
    `SpeedModel`, and `Vehicle` interfaces and the `TrafficUnitWrapper`, `FactoryTraffic`,
    `FactoryVehicle`, and `FactorySpeedModel` classes. We will also rely on the streams
    and stream pipelines described in [Chapter 3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml),
    *Modular Programming*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将使用[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中创建的API，*模块化编程*，`TrafficUnit`，`SpeedModel`和`Vehicle`接口以及`TrafficUnitWrapper`，`FactoryTraffic`，`FactoryVehicle`和`FactorySpeedModel`类。我们还将依赖于[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中描述的流和流管道，*模块化编程*。
- en: 'Just to refresh your memory, here is the `TrafficUnitWrapper` class:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒您，这是`TrafficUnitWrapper`类：
- en: '[PRE66]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will also slightly modify the existing API interface and make it a bit more
    compact by introducing a new `DateLocation` class:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将稍微修改现有的API接口，并通过引入一个新的`DateLocation`类使其更加紧凑：
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It will also allow you to hide the details and help you see the important aspects
    of this recipe.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将帮助您隐藏细节，并帮助您看到这个示例的重要方面。
- en: How to do it...
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: All computations are encapsulated inside a subclass of one of the two subclasses
    (`RecursiveAction` or `RecursiveTask<T>`) of the abstract `ForkJoinTask` class.
    You can extend either `RecursiveAction` (and implement the `void compute()` method)
    or `RecursiveTask<T>` (and implement the `T compute()` method). As you may have
    noticed, you can choose to extend the `RecursiveAction` class for tasks that do
    not return any value, and extend `RecursiveTask<T>` when you need your tasks to
    return a value. In our demo, we are going to use the latter because it is slightly
    more complex.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算都封装在`ForkJoinTask`类的两个子类（`RecursiveAction`或`RecursiveTask<T>`）的子类中。您可以扩展`RecursiveAction`（并实现`void
    compute()`方法）或`RecursiveTask<T>`（并实现`T compute()`方法）。正如您可能已经注意到的，您可以选择扩展`RecursiveAction`类以处理不返回任何值的任务，并在需要任务返回值时扩展`RecursiveTask<T>`。在我们的示例中，我们将使用后者，因为它稍微复杂一些。
- en: 'Let''s say we would like to calculate the average speed of traffic in a certain
    location on a certain date and time and driving conditions (all these parameters
    are defined by the `DateLocation` property object). Other parameters will be as
    follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算特定位置在特定日期和时间以及驾驶条件下的交通平均速度（所有这些参数由`DateLocation`属性对象定义）。其他参数如下：
- en: '`timeSec`: The number of seconds during which the vehicles have a chance to
    accelerate after stopping at the traffic light'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeSec`：车辆在交通灯停止后加速的秒数'
- en: '`trafficUnitsNumber`: The number of vehicles to include in the average speed
    calculation'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trafficUnitsNumber`：包括在平均速度计算中的车辆数量'
- en: 'Naturally, the more vehicles included in the calculations, the better the prediction.
    But as this number increases, the number of calculations increases too. This gives
    rise to the need to break down the number of vehicles into smaller groups and
    compute the average speed of each group in parallel with the others. Yet, there
    is a certain minimal number of calculations that is not worth splitting between
    two threads. Here''s what Javadoc ([https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html))
    has to say about it:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，包括在计算中的车辆数量越多，预测就越准确。但随着这个数字的增加，计算的数量也会增加。这就需要将车辆数量分成更小的组，并与其他组并行计算每组的平均速度。然而，有一定数量的计算是不值得分配给两个线程的。Javadoc（[https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html)）对此有以下说明：
- en: '"As a very rough rule of thumb, a task should perform more than 100 and less
    than 10000 basic computational steps, and should avoid indefinite looping. If
    tasks are too big, then parallelism cannot improve throughput. If too small, then
    memory and internal task maintenance overhead may overwhelm processing."'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: “作为一个非常粗略的经验法则，一个任务应该执行超过100个，少于10000个基本计算步骤，并且应该避免无限循环。如果任务太大，那么并行性无法提高吞吐量。如果太小，那么内存和内部任务维护开销可能会压倒处理。”
- en: Yet, as always, the determination of the optimal number of calculations without
    splitting them between parallel threads should be based on testing. This is why
    we recommend you pass it as a parameter. We will call this parameter `threshold`.
    Note that it also serves as a criterion for exiting from the recursion.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一如既往，确定不在并行线程之间分割计算的最佳数量应该基于测试。这就是为什么我们建议您将其作为参数传递。我们将称此参数为`threshold`。请注意，它还用作递归退出的标准。
- en: 'We will call our class (task) `AverageSpeed` and extend `RecursiveTask<Double>`
    because we would like to have as a result of the average speed value of the `double`
    type:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称我们的类（任务）为`AverageSpeed`，并扩展`RecursiveTask<Double>`，因为我们希望将平均速度值作为结果的`double`类型：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Before we finish writing the code for the `compute()` method, let''s write
    the code that will execute this task. There are several ways to do this. We can
    use `fork()` and `join()`, for example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`compute()`方法的编写之前，让我们编写将执行此任务的代码。有几种方法可以做到这一点。例如，我们可以使用`fork()`和`join()`：
- en: '[PRE69]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This technique provided the name for the framework. The `fork()` method, according
    to Javadoc,
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为框架提供了名称。根据Javadoc，`fork()`方法
- en: '"arranges to asynchronously execute this task in the pool the current task
    is running in, if applicable, or using the `ForkJoinPool.commonPool()` if not
    in `ForkJoinPool()`."'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: “安排异步执行此任务，该任务在池中运行，如果适用，或者如果不在`ForkJoinPool()`中，则使用`ForkJoinPool.commonPool()`。”
- en: In our case, we have not used any pool yet, so `fork()` is going to use `ForkJoinPool.commonPool()`
    by default. It places the task in the queue of a thread in the pool. The `join()` method
    returns the result of the computation when it is done.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们还没有使用任何池，因此`fork()`将默认使用`ForkJoinPool.commonPool()`。它将任务放入池中的线程的队列中。`join()`方法在计算完成时返回计算结果。
- en: 'The `createTask()` method contains the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTask()`方法包含以下内容：'
- en: '[PRE70]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note the values of the `trafficUnitsNumber` and `threshold` parameters. This
    will be important for analyzing the results.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`trafficUnitsNumber`和`threshold`参数的值。这对于分析结果非常重要。
- en: 'Another way to accomplish this is to use either the `execute()` or `submit()` method—each
    providing the same functionality—for the execution of the task. The result of
    the execution can be retrieved by the `join()` method (the same as in the previous
    example):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的另一种方法是使用`execute()`或`submit()`方法中的任一种——每种方法都提供相同的功能——用于执行任务。执行的结果可以通过`join()`方法检索（与前面的示例相同）：
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The last method we are going to review is `invoke()`, which is equivalent to
    calling the `fork()` method followed by the `join()` method:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要审查的最后一种方法是`invoke()`，它相当于调用`fork()`方法，然后调用`join()`方法：
- en: '[PRE72]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Naturally, this is the most popular way to start the divide-and-conquer process.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是开始分治过程的最流行的方法。
- en: 'Now let''s get back to the `compute()` method and see how it can be implemented.
    First, let''s implement the `if` block (calculates the average speed of less than
    `threshold` vehicles). We will use the technique and code we described in [Chapter
    3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml), *Modular Programming*:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`compute()`方法，看看它如何实现。首先，让我们实现`if`块（计算少于`threshold`车辆的平均速度）。我们将使用我们在[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中描述的技术和代码，*模块化编程*：
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We get `trafficUnitsNumber` of the vehicles from `FactoryTraffic`. We create
    an object of `TrafficUnitWrapper` for each emitted element and call the `setSpeedModel()`
    method on it (by passing in the newly generated `SpeedModel` object, based on
    the emitted `TrafficUnit` object). Then we calculate the speed, get an average
    of all the speeds in the stream, and get the result as `double` from the `Optional`
    object (the return type of the `average()` operation). We then print out the result
    and round to get a more presentable format.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`FactoryTraffic`获取了车辆的`trafficUnitsNumber`。我们为每个发射的元素创建一个`TrafficUnitWrapper`对象，并在其上调用`setSpeedModel()`方法（通过传入基于发射的`TrafficUnit`对象生成的新生成的`SpeedModel`对象）。然后我们计算速度，得到流中所有速度的平均值，并从`Optional`对象（`average()`操作的返回类型）中得到结果作为`double`。然后我们打印出结果并四舍五入以获得更具有代表性的格式。
- en: It is also possible to achieve the same result using a traditional `for` loop.
    But, as mentioned before, it seems that Java follows the general trend of a more
    fluent and stream-like style, geared toward processing a large amount of data.
    So, we recommend you get used to it.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用传统的`for`循环来实现相同的结果。但是，如前所述，似乎Java遵循了更流畅和类似流的风格的总体趋势，旨在处理大量数据。因此，我们建议您习惯于使用它。
- en: In [Chapter 14](402d6438-f308-4ae7-b637-8e60a1215bc4.xhtml), *Testing*, you
    will see another version of the same functionality that allows better unit testing
    of each step in isolation, which again supports the view that unit testing, along
    with writing code, helps you make your code more testable and decreases the need
    to rewrite it later.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](402d6438-f308-4ae7-b637-8e60a1215bc4.xhtml)中，*测试*，您将看到相同功能的另一个版本，它允许更好地单独测试每个步骤，这再次支持单元测试，以及编写代码，帮助您使代码更具可测试性，并减少以后重写代码的需要。
- en: 'Now, let''s review the options of the `else` block implementation. The first
    few lines are always going to be the same:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾`else`块实现的选项。前几行总是相同的：
- en: '[PRE74]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We divide the `trafficUnitsNumber` number by 2 (we do not worry about possible
    loss of one unit in the case of an average across a big set) and create two tasks.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`trafficUnitsNumber`的数字除以2（我们不担心在大型集合的平均值中可能丢失一个单位），并创建两个任务。
- en: 'The following—the actual task execution code—can be written in several different
    ways. Here is the first possible solution, which is familiar to us already, that
    comes to mind:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来-实际任务执行代码-可以用几种不同的方式编写。这是我们已经熟悉的第一个可能的解决方案，首先想到的：
- en: '[PRE75]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Run the following code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE76]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we do this, we will see the same output (but with different speed values)
    three times:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们将看到相同的输出（但速度值不同）三次：
- en: '![](img/44998580-49bf-4d7f-8e32-13e1151df68b.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44998580-49bf-4d7f-8e32-13e1151df68b.png)'
- en: You see how the original task of calculating average speed over 1,001 units
    (vehicles) was first divided by 2 several times until the number of one group
    (62) fell under the threshold of 100\. Then, an average speed of the last two
    groups was calculated and combined (joined) with the results of other groups.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，首先将计算1,001个单位（车辆）的平均速度的原始任务分成2部分，直到一组的数量（62）降到100以下的阈值。然后，计算最后两组的平均速度，并将其与其他组的结果合并。
- en: 'Another way to implement an `else` block of the `compute()` method could be
    as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`compute()`方法的`else`块的另一种方法可能如下：
- en: '[PRE77]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here''s how the result will look:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/12e0f057-8665-4758-88df-ab8166d67dfd.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e0f057-8665-4758-88df-ab8166d67dfd.png)'
- en: You can see how, in this case, the `compute()` method (of the second task) was
    called recursively many times until it reached the threshold by the number of
    elements, then its results were joined with the results of the call to the `fork()`
    and `join()` methods of the first task.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在这种情况下，`compute()`方法（第二个任务的）被递归调用多次，直到达到元素数量的阈值，然后其结果与对第一个任务调用`fork()`和`join()`方法的结果合并。
- en: 'As mentioned before, all this complexity can be replaced by a call to the `invoke()` method:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有这些复杂性都可以通过调用`invoke()`方法来替换：
- en: '[PRE78]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It produces a result similar to the one produced by calling `fork()` and `join()`
    on each of the tasks:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生的结果类似于对每个任务调用`fork()`和`join()`产生的结果：
- en: '![](img/5b63f37b-25bb-4baf-aa17-144ac7bc60a2.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b63f37b-25bb-4baf-aa17-144ac7bc60a2.png)'
- en: 'Yet, there is an even better way to implement an `else` block of the `compute()` method:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现`compute()`方法的`else`块的更好的方法是：
- en: '[PRE79]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If this looks complex to you, just note that it is just a stream-like way to
    iterate over the results of `invokeAll()`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对您来说看起来很复杂，只需注意这只是一种类似流的方式来迭代`invokeAll()`的结果：
- en: '[PRE80]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It is also to iterate over the results of calling `join()` on each of the returned
    tasks (and combining the results into average). The advantage is that we yield
    to the framework to decide how to optimize the load distribution. The result is
    as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以迭代对每个返回任务调用`join()`的结果（并将结果合并为平均值）。优点是我们让框架决定如何优化负载分配。结果如下：
- en: '![](img/5cd22de5-19dd-45f9-a868-186d9770a80b.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cd22de5-19dd-45f9-a868-186d9770a80b.png)'
- en: You can see that it differs from any of the preceding results and can change
    depending on the availability and load of the CPUs on your computer.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它与之前的任何结果都不同，并且可以根据计算机上CPU的可用性和负载而改变。
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流来实现发布-订阅模式
- en: In this recipe, you will learn about the new publish-subscribe capability introduced
    in Java 9.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将了解Java 9中引入的新的发布-订阅功能。
- en: Getting ready
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'Among many other features, Java 9 introduced these four interfaces in the `java.util.concurrent.Flow` class:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 除了许多其他功能，Java 9还在`java.util.concurrent.Flow`类中引入了这四个接口：
- en: '[PRE81]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: With this, Java stepped into the world of reactive programming—programming with
    the asynchronous processing of data streams.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Java步入了响应式编程的世界-使用数据流的异步处理编程。
- en: We discussed streams in [Chapter 3](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml),
    *Modular Programming,* and pointed out that they are not data structures, as they
    do not keep data in memory. The stream pipeline does nothing until an element
    is emitted. Such a model allows minimal resource-allocation and uses resources
    only as needed. The application behaves *in response* to the appearance of the
    data it reacts to, thus the name.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](1b2f25bd-aef0-4b6f-a9e7-144ee4f8d6e1.xhtml)中讨论了流，*模块化编程*，并指出它们不是数据结构，因为它们不会在内存中保存数据。流管道在发出元素之前不会执行任何操作。这种模型允许最小的资源分配，并且只在需要时使用资源。应用程序对其所反应的数据的出现做出*响应*，因此得名。
- en: In a publish-subscribe pattern, the main two actors are `Publisher`, which streams
    data (publishes), and `Subscriber`, which listens to data (subscribes).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布-订阅模式中，主要的两个角色是`Publisher`，它流式传输数据（发布），以及`Subscriber`，它监听数据（订阅）。
- en: 'The `Flow.Publisher<T>` interface is a functional interface. It only has one
    abstract method:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Publisher<T>`接口是一个函数式接口。它只有一个抽象方法：'
- en: '[PRE82]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: According to the Javadoc ([https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html](https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html)),
    this method,
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Javadoc（[https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html](https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html)），这个方法，
- en: '"adds the given `Flow.Subscriber<T>` if possible. If already subscribed, or
    the attempt to subscribe fails, the `onError()` method of `Flow.Subscriber<T>`
    is invoked with an `IllegalStateException`. Otherwise, the `onSubscribe()` method
    of `Flow.Subscriber<T>` is invoked with a new `Flow.Subscription.` Subscribers
    may enable receiving items by invoking the `request()` method of this `Flow.Subscription`
    and may unsubscribe by invoking its `cancel()` method."'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: “如果可能，添加给定的`Flow.Subscriber<T>`。如果已经订阅，或者订阅失败，则使用`IllegalStateException`调用`Flow.Subscriber<T>`的`onError()`方法。否则，使用新的`Flow.Subscription`调用`Flow.Subscriber<T>`的`onSubscribe()`方法。订阅者可以通过调用此`Flow.Subscription`的`request()`方法启用接收项目，并可以通过调用其`cancel()`方法取消订阅。”
- en: 'The `Flow.Subscriber<T>` interface has four methods:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscriber<T>`接口有四个方法：'
- en: '`void onSubscribe(Flow.Subscription subscription)`: Invoked prior to invoking
    any other `Subscriber` methods for the given `Subscription`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onSubscribe(Flow.Subscription subscription)`: 在给定`Subscription`的其他`Subscriber`方法之前调用'
- en: '`void onError(Throwable throwable)`: Invoked upon an unrecoverable error encountered
    by a `Publisher` or `Subscription`, after which no other `Subscriber` methods
    are invoked by `Subscription`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onError(Throwable throwable)`: 在`Publisher`或`Subscription`遇到不可恢复的错误后调用，之后`Subscription`不会再调用其他`Subscriber`方法'
- en: '`void onNext(T item)`: Invoked with the next item of `Subscription`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onNext(T item)`: 调用`Subscription`的下一个项目'
- en: '`void onComplete()`: Invoked when it is known that no additional `Subscriber`
    method invocations will occur for `Subscription`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onComplete()`: 当已知对于`Subscription`不会再发生额外的`Subscriber`方法调用时调用'
- en: 'The `Flow.Subscription` interface has two methods:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscription`接口有两个方法：'
- en: '`void cancel()`: Causes `Subscriber` to (eventually) stop receiving messages'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void cancel()`: 导致`Subscriber`（最终）停止接收消息'
- en: '`void request(long n)`: Adds the given *n* number of items to the current unfulfilled
    demand for this subscription'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void request(long n)`: 将给定的*n*数量的项目添加到此订阅的当前未满足的需求中'
- en: The `Flow.Processor<T,R>` interface is outside the scope of this book.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor<T,R>`接口超出了本书的范围。'
- en: How to do it...
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To save some time and space, instead of creating our own implementation of
    the `Flow.Publisher<T>` interface, we can use the `SubmissionPublisher<T>` class from
    the `java.util.concurrent` package. But, we will create our own implementation
    of the `Flow.Subscriber<T>` interface:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和空间，我们可以使用`java.util.concurrent`包中的`SubmissionPublisher<T>`类，而不是创建自己的`Flow.Publisher<T>`接口的实现。但是，我们将创建自己的`Flow.Subscriber<T>`接口的实现：
- en: '[PRE83]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We will also implement the `Flow.Subscription` interface:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`Flow.Subscription`接口：
- en: '[PRE84]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you can see, we just followed Javadoc recommendations and expect the `onSubscribe()`
    method of a subscriber to be called when the subscriber is added to a publisher.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只是遵循了Javadoc的建议，并期望当订阅者添加到发布者时，将调用订阅者的`onSubscribe()`方法。
- en: 'Another detail to note is that the `SubmissionPublisher<T>` class has the `submit(T
    item)` method that, according to Javadoc ([https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html](https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html)):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个要注意的细节是，`SubmissionPublisher<T>`类具有`submit(T item)`方法，根据Javadoc（[https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html](https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/SubmissionPublisher.html)）：
- en: '"publishes the given item to each current subscriber by asynchronously invoking
    its `onNext()` method, blocking uninterruptibly while resources for any subscriber
    are unavailable."'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: “通过异步调用其`onNext()`方法将给定项目发布给每个当前订阅者，同时在任何订阅者资源不可用时阻塞不间断地。”
- en: This way, the `SubmissionPublisher<T>` class submits items to the current subscribers
    until it is closed. This allows item generators to act as reactive-streams publishers.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`SubmissionPublisher<T>`类将项目提交给当前订阅者，直到关闭。这允许项目生成器充当反应式流发布者。
- en: 'To demonstrate this, let''s create several subscribers and subscriptions using
    the `demoSubscribe()` method:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '为了演示这一点，让我们使用`demoSubscribe()`方法创建几个订阅者和订阅： '
- en: '[PRE85]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then use them in the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在以下代码中使用它们：
- en: '[PRE86]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The preceding code creates three subscribers, connected to the same publisher
    with a dedicated subscription. The last line generates a stream of numbers, 1,
    2, 3, and 4, and submits each of them to the publisher. We expect that every subscriber
    will get each of the generated numbers as the parameter of the `onNext()` method.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了三个订阅者，连接到具有专用订阅的相同发布者。最后一行生成了一个数字流，1、2、3和4，并将每个数字提交给发布者。我们期望每个订阅者都会将生成的每个数字作为`onNext()`方法的参数。
- en: 'In the `finally` block, we included the code you are already familiar with
    from the previous recipe:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在`finally`块中，我们包含了您已经熟悉的代码，来自上一个示例：
- en: '[PRE87]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If we run the preceding code, the output may look like the following:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，输出可能如下所示：
- en: '![](img/a9ef8e7a-c418-44c6-a0bc-2aa9a68eb56f.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9ef8e7a-c418-44c6-a0bc-2aa9a68eb56f.png)'
- en: As you can see, because of asynchronous processing, the control gets to the
    `finally` block very quickly and waits one second before shutting down the service.
    This period of waiting is enough for the items to be generated and passed to the
    subscribers. We also confirmed that every generated item was sent to each of the
    subscribers. The three `null` values were generated every time the `onSubscribe()`
    method of each of the subscribers was called.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，由于异步处理，控制非常快地到达`finally`块，并在关闭服务之前等待一秒钟。这段等待时间足够生成项目并将其传递给订阅者。我们还确认每个生成的项目都发送给了每个订阅者。每次调用每个订阅者的`onSubscribe()`方法时，都会生成三个`null`值。
- en: It is reasonable to expect that, in future Java releases, there will be more
    support added for reactive (asynchronous and non-blocking) functionality.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 可以合理地期望，在未来的Java版本中，将会为反应式（异步和非阻塞）功能增加更多支持。
