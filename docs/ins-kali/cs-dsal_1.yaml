- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Developing applications is certainly something exciting to work on, but it is
    also challenging, especially if you need to solve some complex problems that involve
    advanced data structures and algorithms. In such cases, you often need to take
    care of performance to ensure that the solution will work smoothly on devices
    with limited resources. Such a task could be really difficult and could require
    significant knowledge regarding not only the programming language, but also data
    structures and algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序肯定是一件令人兴奋的工作，但也具有挑战性，特别是如果您需要解决涉及高级数据结构和算法的复杂问题。在这种情况下，您经常需要关注性能，以确保解决方案在资源有限的设备上能够平稳运行。这样的任务可能非常困难，可能需要对编程语言、数据结构和算法有相当的了解。
- en: Did you know that replacing even one data structure with another could cause
    the performance results to increase hundreds of times? Does it sound impossible?
    Maybe, but it is true! As an example, I would like to tell you a short story about
    one of the projects in which I was involved. The aim was to optimize the algorithm
    of finding connections between blocks on a graphical diagram. Such connections
    should be automatically recalculated, refreshed, and redrawn as soon as any block
    has moved in the diagram. Of course, connections cannot go through blocks and
    cannot overlap other lines, and the number of crossings and direction changes
    should be limited. Depending on the size and the complexity of the diagram, the
    performance results differ. However, while conducting tests, we have received
    results in the range from 1 ms to almost 800 ms for the same test case. What could
    be the most surprising aspect is that such a huge improvement has been reached
    mainly by... changing data structures of two sets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道吗，即使将一个数据结构替换为另一个，也可能导致性能结果增加数百倍？听起来不可能吗？也许，但这是真的！举个例子，我想告诉您一个我参与的项目的简短故事。其目标是优化在图形图表上查找块之间连接的算法。这样的连接应该在图表中的任何块移动时自动重新计算、刷新和重绘。当然，连接不能穿过块，也不能重叠其他线，并且交叉点和方向变化的数量应该是有限的。根据图表的大小和复杂性，性能结果会有所不同。然而，在进行测试时，我们得到了同一个测试用例的结果范围从1毫秒到近800毫秒。最令人惊讶的可能是，这样巨大的改进主要是通过...改变了两组数据结构来实现的。
- en: Now, you could ask yourself the obvious question: *which data structures should
    I use in given circumstances and which algorithms could be used to solve some
    common problems?* Unfortunately, the answer is not simple. However, within this
    book, you will find a lot of information about data structures and algorithms,
    presented in the context of the C# programming language, with many examples, code
    snippets, and detailed explanations. Such content could help you to answer the
    aforementioned questions while developing the next great solutions, which could
    be used by many people all over the world! Are you ready to start your adventure
    with data structures and algorithms? If so, let's start!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会问自己一个显而易见的问题：在特定情况下应该使用哪些数据结构，以及可以用哪些算法来解决一些常见问题？不幸的是，答案并不简单。然而，在本书中，您将找到许多关于数据结构和算法的信息，以C#编程语言的背景呈现，包括许多示例、代码片段和详细解释。这样的内容可以帮助您回答前面提到的问题，同时开发下一个伟大的解决方案，这些解决方案可以被世界各地的许多人使用！您准备好开始您的数据结构和算法之旅了吗？如果是的，让我们开始吧！
- en: 'In this chapter, you will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将涵盖以下主题：
- en: Programming language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程语言
- en: Data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Installation and configuration of the IDE
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE的安装和配置
- en: Creating the project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目
- en: Input and output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出
- en: Launching and debugging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和调试
- en: Programming language
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语言
- en: As a developer, you have certainly heard about many programming languages, such
    as **C#**, **Java**, **C++**, **C**, **PHP**, or **Ruby**. In all of them, you
    can use various data structures, as well as implement algorithms, to solve both
    basic and complex problems. However, each language has its own specificity, which
    could be visible while implementing data structures and accompanying algorithms.
    As already mentioned, this book will focus only on the C# programming language,
    which is also the main topic of this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您肯定听说过许多编程语言，如C#、Java、C++、C、PHP或Ruby。在所有这些语言中，您可以使用各种数据结构，以及实现算法，来解决基本和复杂的问题。然而，每种语言都有其自身的特点，这在实现数据结构和相应的算法时可能是可见的。正如前面提到的，本书将专注于C#编程语言，这也是本节的主要内容。
- en: The C# language, pronounced as "C Sharp", is a modern, general-purpose, strongly-typed,
    and object-oriented programming language that can be used while developing a wide
    range of applications, such as web, mobile, desktop, distributed, and embedded
    solutions, as well as even games. It cooperates with various additional technologies
    and platforms, including ASP.NET MVC, Windows Store, Xamarin, Windows Forms, XAML,
    and Unity. Therefore, when you learn the C# language, as well as getting to know
    more about data structures and algorithms in the context of this programming language,
    you can use such skills to create more than one particular type of software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言，发音为“C Sharp”，是一种现代的、通用的、强类型的、面向对象的编程语言，可用于开发各种应用程序，如Web、移动、桌面、分布式和嵌入式解决方案，甚至游戏。它与各种其他技术和平台合作，包括ASP.NET
    MVC、Windows Store、Xamarin、Windows Forms、XAML和Unity。因此，当您学习C#语言，以及在这种编程语言的背景下更多地了解数据结构和算法时，您可以利用这些技能来创建多种特定类型的软件。
- en: The current version of the language is C# 7.1\. It is worth mentioning its interesting
    history with the following versions of the language (for example, 2.0, 3.0, and
    5.0) in which new features have been added to increase language possibilities
    and to simplify the work of developers. When you take a look at release notes
    for particular versions, you will see how the language is being improved and expanded
    over time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的语言是C# 7.1。值得一提的是它与语言的以下版本（例如2.0、3.0和5.0）的有趣历史，在这些版本中，已添加了新功能以增加语言的可能性并简化开发人员的工作。当您查看特定版本的发布说明时，您将看到语言如何随着时间的推移而得到改进和扩展。
- en: The syntax of the C# programming language is similar to other languages, such
    as Java or C++. For this reason, if you know such languages, you should quite
    easily be able to understand the code written in C#. As an example, similarly
    as in the languages mentioned previously, the code consists of statements that
    end with semicolons (`;`), and curly brackets (`{` and `}`) are used to group
    statements, such as within the `foreach` loop. You could also find similar code
    constructions, such as the `if` statement, or `while` and `for` loops.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言的语法类似于其他语言，比如Java或C++。因此，如果您了解这些语言，您应该很容易理解用C#编写的代码。例如，与之前提到的语言类似，代码由以分号（`;`）结尾的语句组成，花括号（`{`和`}`）用于分组语句，比如在`foreach`循环中。您还可以找到类似的代码结构，比如`if`语句，或`while`和`for`循环。
- en: Developing various applications in the C# language is also simplified by the
    availability of many additional great features, such as **Language Integrated
    Query** (**LINQ**), which allows developers to get data from various collections,
    such as SQL databases or XML documents, in a consistent way. There are also some
    approaches to shorten the required code, such as using lambda expressions, expression-bodied
    members, getters and setters, or string interpolation. It is worth mentioning
    the automatic garbage collection that simplifies the task of releasing memory.
    Of course, the solutions mentioned are only the very limited subset of features
    available while developing in C#. You will see some others in the following parts
    of this book, together with examples and detailed descriptions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#语言中开发各种应用程序也因为许多额外的出色功能而变得简化，比如**语言集成查询**（**LINQ**），它允许开发人员以一致的方式从各种集合中获取数据，比如SQL数据库或XML文档。还有一些缩短所需代码的方法，比如使用lambda表达式、表达式主体成员、getter和setter，或者字符串插值。值得一提的是自动垃圾回收，它简化了释放内存的任务。当然，上述解决方案只是在C#开发中可用功能的非常有限的子集。在本书的后续部分中，您将看到一些其他功能，以及示例和详细描述。
- en: Data types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'While developing applications in the C# language, you could use various data
    types, which are divided into two groups, namely **value types** and **reference
    types**. The difference between them is very simple—a variable of a value type
    directly contains data, while a variable of a reference type just stores a reference
    to data, as shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#语言中开发应用程序时，您可以使用各种数据类型，它们分为两组，即**值类型**和**引用类型**。它们之间的区别非常简单——值类型的变量直接包含数据，而引用类型的变量只是存储对数据的引用，如下所示：
- en: '![](img/d38bd3e0-f4c1-4c4c-8b09-7125d7d0db69.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d38bd3e0-f4c1-4c4c-8b09-7125d7d0db69.png)'
- en: As you can see, a **Value type** stores its actual **Value** directly in the
    **Stack** memory, while a **Reference type** only stores a **Reference** here.
    The actual value is located in the **Heap** memory. Therefore, it is also possible
    to have two or more variables of a reference type that reference exactly the same
    value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，**值类型**直接将其实际**值**存储在**堆栈**内存中，而**引用类型**只在此处存储**引用**。实际值位于**堆**内存中。因此，也可能有两个或更多引用类型的变量引用完全相同的值。
- en: Of course, a difference between value and reference types is very important
    while programming and you should know which types belong to the groups mentioned.
    Otherwise, you could make mistakes in the code that could be quite difficult to
    find. For instance, you should remember to take care while updating the data of
    a reference type, because the change could also be reflected in other variables
    that are referencing the same object. Moreover, you should be careful while comparing
    two objects with the equals (`=`) operator, because you could compare the reference,
    not the data itself, in the case of two instances of a reference type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，值类型和引用类型之间的区别在编程时非常重要，您应该知道哪些类型属于上述组。否则，您可能会在代码中犯错，这可能会很难找到。例如，您应该记住在更新引用类型的数据时要小心，因为更改也可能会反映在引用相同对象的其他变量中。此外，您在使用等号（`=`）运算符比较两个对象时也要小心，因为在比较两个引用类型的实例时，您可能会比较引用而不是数据本身。
- en: 'The C# language also supports **pointer types**, which can be declared as `type*
    identifier` or `void* identifier`. However, such types are beyond the scope of
    this book. You can read more about them at: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言还支持**指针类型**，可以声明为`type* identifier`或`void* identifier`。然而，这些类型超出了本书的范围。您可以在以下链接中了解更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types)。
- en: Value types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: To give you a better understanding of data types, let's start with the analysis
    of the first group (that is, **value types**), which could be further divided
    into **structs** and **enumerations**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更好地理解数据类型，让我们从对第一组（即**值类型**）的分析开始，它可以进一步分为**结构**和**枚举**。
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types)。
- en: Structs
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: Within structs, you have access to many built-in types, which could be used
    either as keywords or types from the `System` namespace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构体中，您可以访问许多内置类型，这些类型可以作为关键字或来自`System`命名空间的类型使用。
- en: One of them is the `Boolean` type (the `bool` keyword), which makes it possible
    to store a **logical value**, that is, one of two values, namely `true` or `false`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是`Boolean`类型（`bool`关键字），它可以存储**逻辑值**，也就是两个值中的一个，即`true`或`false`。
- en: 'As for storing **integer values,** you can use one of the following types:
    `Byte` (the `byte` keyword), `SByte` (`sbyte`), `Int16` (`short`), `UInt16` (`ushort`),
    `Int32` (`int`), `UInt32` (`uint`), `Int64` (`long`), and `UInt64` (`ulong`).
    They differ by the number of bytes for storing values and therefore by the range
    of available values. As an example, the `short` data type supports values in the
    range from -32,768 to 32,767 while `uint` supports values in the range from 0
    to 4,294,967,295\. Another type within the integral types is `Char` (`char`),
    which represents a single Unicode character such as `''a''` or `''M''`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 至于存储**整数值**，您可以使用以下类型之一：`Byte`（`byte`关键字）、`SByte`（`sbyte`）、`Int16`（`short`）、`UInt16`（`ushort`）、`Int32`（`int`）、`UInt32`（`uint`）、`Int64`（`long`）和`UInt64`（`ulong`）。它们通过存储值的字节数和可用值的范围而有所不同。例如，`short`数据类型支持范围从-32,768到32,767的值，而`uint`支持范围从0到4,294,967,295的值。整数类型中的另一种类型是`Char`（`char`），它表示单个Unicode字符，例如`'a'`或`'M'`。
- en: In the case of **floating-point values**, you can use two types, namely `Single`
    (`float`) and `Double` (`double`). The first uses 32 bits, while the second uses
    64 bits. Thus, their precision differs significantly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在**浮点值**的情况下，您可以使用两种类型，即`Single`（`float`）和`Double`（`double`）。第一种使用32位，而第二种使用64位。因此，它们的精度有很大的不同。
- en: What's more, the `Decimal` type (the `decimal` keyword) is available. It uses
    128 bits and is a good choice for monetary calculations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Decimal`类型（`decimal`关键字）也是可用的。它使用128位，是货币计算的一个很好的选择。
- en: 'An example declaration of a variable in the C# programming language is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言中变量的一个示例声明如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can assign a value to a variable using the equals sign (`=`), shown as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用等号（`=`）将值赋给变量，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, declaration and assignment could be performed in the same line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，声明和赋值可以在同一行中执行：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to declare and initialize an **immutable value**, that is, a **constant**,
    you can use the `const` keyword, as shown in the following line of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想声明和初始化一个**不可变值**，也就是一个**常量**，您可以使用`const`关键字，如下面的代码行所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'More information about the built-in data types, together with the complete
    list of ranges, is available at: [https://msdn.microsoft.com/library/cs7y5x0x.aspx](https://msdn.microsoft.com/library/cs7y5x0x.aspx).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关内置数据类型的更多信息，以及完整的范围列表，请访问：[https://msdn.microsoft.com/library/cs7y5x0x.aspx](https://msdn.microsoft.com/library/cs7y5x0x.aspx)。
- en: Enumerations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Apart from structs, the value types contain **enumerations**. Each has a set
    of named constants to specify the available set of values. For instance, you can
    create the enumeration for available languages or supported currencies. An example
    definition is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构体，值类型还包括**枚举**。每个枚举都有一组命名的常量来指定可用的值集。例如，您可以创建可用语言或支持的货币的枚举。一个示例定义如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, you can use the defined enumeration as a data type, as shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将定义的枚举用作数据类型，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth mentioning that enumerations allow you to replace some *magical
    strings* (such as `"PL"` or `"DE"`) with constant values and this has a positive
    impact on code quality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，枚举允许您用常量值替换一些*魔术字符串*（如`"PL"`或`"DE"`），这对代码质量有积极的影响。
- en: 'You can also benefit from more advanced features of enumerations, such as changing
    the underlying type or specifying values for particular constants. You can find
    more information at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从枚举的更高级特性中受益，例如更改基础类型或为特定常量指定值。您可以在此处找到更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)。
- en: Reference types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: The second main group of types is named **reference types**. Just as a quick
    reminder, a variable of a reference type does not directly contain data, because
    it just stores a reference to data. In this group, you can find three built-in
    types, namely `string`, `object`, and `dynamic`. Moreover, you can declare classes,
    interfaces, and delegates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要类型组称为**引用类型**。作为一个快速提醒，引用类型的变量并不直接包含数据，因为它只是存储数据的引用。在这个组中，您可以找到三种内置类型，即`string`、`object`和`dynamic`。此外，您可以声明类、接口和委托。
- en: 'More information about the reference types is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关引用类型的更多信息，请访问：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types)。
- en: Strings
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: There is often the necessity to store some text values. You can achieve this
    goal using the `String` built-in reference type from the `System` namespace, which
    is also available using the `string` keyword. The `string` type is a sequence
    of Unicode characters. It can have zero chars, one or more chars, or the `string`
    variable can be set to `null`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要存储一些文本值。您可以使用`System`命名空间中的内置引用类型`String`来实现这一目标，也可以使用`string`关键字。`string`类型是Unicode字符的序列。它可以有零个字符、一个或多个字符，或者`string`变量可以设置为`null`。
- en: 'You can perform various operations on `string` objects, such as concatenation
    or accessing a particular char using the `[]` operator, as shown as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对`string`对象执行各种操作，例如连接或使用`[]`运算符访问特定字符，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the beginning, the `firstName` variable is declared, and the `"Marcin"` value
    is assigned to it. Similarly, `"Jamro"` is set as a value of the `lastName` variable.
    In the third line, you concatenate five strings (using the `+` operator), namely,
    the current value of `firstName`, the space, the current value of `lastName` converted
    to the upper-case string (by calling the `ToUpper` method), the string `" was
    born in "`, and the current value of the `year` variable. In the last line, the
    first chars from `firstName` and `lastName` variables are obtained, using the
    `[]` operator, as well as concatenated with two dots to form the initials, that
    is, `M.J.`, which are stored as a value of the `initials` variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，声明了“firstName”变量，并将“Marcin”赋给它。同样，“Jamro”被设置为“lastName”变量的值。在第三行，您连接了五个字符串（使用“+”运算符），即“firstName”的当前值，空格，“lastName”的当前值转换为大写字符串（通过调用“ToUpper”方法），字符串“
    was born in ”，以及“year”变量的当前值。在最后一行，使用“[]”运算符获取了“firstName”和“lastName”变量的第一个字符，并与两个点连接起来形成了缩写，即“M.J.”，这些缩写作为“initials”变量的值存储。
- en: 'The `Format` static method could also be used for constructing the string,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “Format”静态方法也可用于构造字符串，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, you specify the **composite format string** with three format
    items, namely the `firstName` (represented by `{0}`), upper-case `lastName` (`{1}`),
    and the `year` (`{2}`). The objects to format are specified as the following parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您指定了包含三个格式项的**复合格式字符串**，即“firstName”（由“{0}”表示），大写“lastName”（“{1}”），以及“year”（“{2}”）。要格式化的对象被指定为以下参数。
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在以下网址找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string)。
- en: 'It is also worth mentioning the **interpolated string**, which uses **interpolated
    expressions** to construct a `string`. To create a `string` using this approach,
    the `$` character should be placed before `"`, as shown in the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是**插值字符串**，它使用**插值表达式**来构造一个`string`。要使用这种方法创建一个`string`，需要在“”之前放置“$”字符，如下例所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interpolated-strings](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interpolated-strings).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在以下网址找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interpolated-strings](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interpolated-strings)。
- en: Object
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: The `Object` class, declared in the `System` namespace, performs a very important
    role while developing applications in the C# language because it is the base class
    for all classes. It means that built-in value types and built-in reference types,
    as well as user-defined types, are derived from the `Object` class, which is also
    available by using the `object` alias.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “Object”类在“System”命名空间中声明，它在C#语言中开发应用程序时扮演着非常重要的角色，因为它是所有类的基类。这意味着内置值类型和内置引用类型，以及用户定义的类型，都是从“Object”类派生出来的，也可以使用“object”别名来访问。
- en: 'As the `object` type is the base entity for all value types, it means that
    it is possible to convert a variable of any value type (for example, `int` or
    `float`) to the `object` type, as well as to convert back a variable of the `object`
    type to a specific value type. Such operations are named **boxing** (the first
    one) and **unboxing** (the other). They are shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“object”类型是所有值类型的基本实体，这意味着可以将任何值类型的变量（例如“int”或“float”）转换为“object”类型，也可以将“object”类型的变量转换回特定的值类型。这些操作分别称为**装箱**（第一个）和**拆箱**（另一个）。它们如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/object](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/object).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在以下网址找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/object](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/object)。
- en: Dynamic
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态
- en: Apart from the types already described, the `dynamic` one is available for developers.
    It allows the bypassing of type checking during compilation so that you can perform
    it during the run time. Such a mechanism is useful while accessing some **ap****plication
    programming interfaces** (**APIs**), but it will not be used in this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经描述的类型，还有“dynamic”类型可供开发人员使用。它允许在编译期间绕过类型检查，以便您可以在运行时执行它。这种机制在访问一些**应用程序编程接口**（**API**）时非常有用，但本书不会使用它。
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在以下网址找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic)。
- en: Classes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: As already mentioned, C# is an object-oriented language and supports declaration
    of classes together with various members, including constructors, finalizers,
    constants, fields, properties, indexers, events, methods, and operators, as well
    as delegates. Moreover, classes support inheritance and implementing interfaces.
    Static, abstract, and virtual members are available, as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C#是一种面向对象的语言，支持声明类以及各种成员，包括构造函数、终结器、常量、字段、属性、索引器、事件、方法和运算符，以及委托。此外，类支持继承和实现接口。还有静态、抽象和虚拟成员可用。
- en: 'An example class is shown as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例类：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Person` class contains the `_location` private field with the default value
    set as the empty string (`string.Empty`), two public properties (`Name` and `Age`),
    a default constructor that sets a value of the `Name` property to `---` using
    the **expression body definition**, an additional constructor that takes two parameters
    and sets values of properties, the `Relocate` method that updates the value of
    the private field, as well as the `GetDistance` method that calls the `GetDistance`
    static method from the `DistanceHelpers` class and returns the distance between
    two cities in kilometers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类包含`_location`私有字段，默认值设置为空字符串（`string.Empty`），两个公共属性（`Name`和`Age`），一个默认构造函数，使用**表达式体定义**将`Name`属性的值设置为`---`，一个接受两个参数并设置属性值的额外构造函数，`Relocate`方法更新私有字段的值，以及`GetDistance`方法调用`DistanceHelpers`类的`GetDistance`静态方法，并返回两个城市之间的距离（以公里为单位）。'
- en: 'You can create an instance of the class using the `new` operator. Then, you
    can perform various operations on the object created, such as calling a method,
    as shown as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`new`运算符创建类的实例。然后，您可以对创建的对象执行各种操作，比如调用方法，如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在此处找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class)。
- en: Interfaces
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In the previous section, a class was mentioned that could implement one or more
    **interfaces**. It means that such a class must implement all methods, properties,
    events, and indexers, that are specified in all implemented interfaces. You can
    easily define interfaces in the C# language using the `interface` keyword.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，提到了一个可以实现一个或多个**接口**的类。这意味着这样一个类必须实现所有在所有实现的接口中指定的方法、属性、事件和索引器。您可以使用`interface`关键字在C#语言中轻松定义接口。
- en: 'As an example, let''s take a look at the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们来看一下以下代码：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `IDevice` interface contains three properties, namely those representing
    a device model (`Model`), serial number (`Number`), and production year (`Year`).
    What's more, it has signatures of three methods, which are `Configure`, `Start`,
    and `Stop`. When a class implements the `IDevice` interface, it should contain
    the mentioned properties and methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDevice`接口包含三个属性，分别表示设备型号（`Model`）、序列号（`Number`）和生产年份（`Year`）。此外，它还具有三个方法的签名，分别是`Configure`、`Start`和`Stop`。当一个类实现`IDevice`接口时，它应该包含上述属性和方法。'
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在此处找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)。
- en: Delegates
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: 'The `delegate` reference type allows specification of the required signature
    of a method. The delegate could then be instantiated, as well as invoked, as shown
    in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate`引用类型允许指定方法的必需签名。然后可以实例化委托，并像下面的代码中所示那样调用它。'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example, the `Mean` delegate specifies the required signature of the
    method for calculating the mean value of three floating-point numbers. It is instantiated
    with the lambda expression (`arithmetic`), anonymous method (`geometric`), and
    named method (`harmonic`). Each delegate is invoked by calling the `Invoke` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`Mean`委托指定了用于计算三个浮点数的平均值的方法的必需签名。它使用lambda表达式（`arithmetic`）、匿名方法（`geometric`）和命名方法（`harmonic`）进行实例化。通过调用`Invoke`方法来调用每个委托。
- en: 'More information is available at: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可在此处找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate)。
- en: Installation and configuration of the IDE
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE的安装和配置
- en: While reading the book, you will see many examples presenting data structures
    and algorithms, together with detailed descriptions. The most important parts
    of the code will be shown directly in the book. Moreover, complete source code
    will be available to download. Of course, you can only read the code from the
    book, but it is strongly recommended to write such code on your own, and then
    launch and debug the program to understand how various data structures and algorithms
    operate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书时，您将看到许多示例，展示了数据结构和算法，以及详细的描述。代码的最重要部分将直接显示在书中。此外，完整的源代码也可以下载。当然，您可以只从书中阅读代码，但强烈建议您自己编写这样的代码，然后启动和调试程序，以了解各种数据结构和算法的运行方式。
- en: As already mentioned, the examples shown in the book will be prepared in the
    C# language. To keep things simple, the console-based applications will be created,
    but such data structures could be used in other kinds of solutions as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本书中展示的示例将使用C#语言准备。为了保持简单，将创建基于控制台的应用程序，但这样的数据结构也可以用在其他类型的解决方案中。
- en: 'The example projects will be created in **Microsoft Visual Studio 2017 Community**.
    This **Integrated Development Environment** (**IDE**) is a comprehensive solution
    for developing various kinds of projects. To download, install, and configure
    it, you should:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目将在**Microsoft Visual Studio 2017 Community**中创建。这个**集成开发环境**（**IDE**）是开发各种项目的综合解决方案。要下载、安装和配置它，您应该：
- en: Open the website [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)
    and choose the Free download option from the Visual Studio Community 2017 section
    just below the Visual Studio Downloads header. The download process of the installer
    should begin automatically.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开网站[https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)，并在Visual
    Studio Community 2017部分的Visual Studio Downloads标题下选择免费下载选项。安装程序的下载过程应该会自动开始。
- en: Run the downloaded file and follow the instructions to start the installation.
    When the screen presenting possible options is shown, choose the .NET desktop
    development option, as shown in the following screenshot. Then, click Install.
    The installation could take some time, but its progress could be observed using
    the Acquiring and Applying progress bars.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下载的文件并按照说明开始安装。当显示可能选项的屏幕时，选择.NET桌面开发选项，如下面的屏幕截图所示。然后，点击安装。安装可能需要一些时间，但可以使用获取和应用进度条来观察其进展。
- en: '![](img/271ec5a2-9e1a-4567-9fb2-98ae4aa24a33.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/271ec5a2-9e1a-4567-9fb2-98ae4aa24a33.png)'
- en: When the message Installation succeeded! is shown, click on the Launch button
    to start the IDE. You will be asked to sign in with the Microsoft account. Then,
    you should choose suitable Development Settings (such as Visual C#) in the Start
    with a familiar environment section. Moreover, you should choose the color theme
    from Blue, Blue (Extra Contrast), Dark, and Light. At the end, click on the Start
    Visual Studio button.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当显示安装成功！的消息时，点击启动按钮启动IDE。您将被要求使用Microsoft帐户登录。然后，您应该在“以熟悉的环境开始”部分选择适当的开发设置（如Visual
    C#）。此外，您应该从蓝色、蓝色（额外对比）、深色和浅色中选择颜色主题。最后，点击“启动Visual Studio”按钮。
- en: Creating the project
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: Just after launching the IDE, let's proceed by creating a new project. Such
    a process will be performed many times while reading the book to create the example
    applications according to information provided in particular chapters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动IDE后，让我们继续创建一个新项目。在阅读本书时，根据特定章节提供的信息，将执行这样的过程多次，以创建示例应用程序。
- en: 'To create a new project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目：
- en: Click on File | New | Project in the main menu.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中点击“文件 | 新建 | 项目”。
- en: 'Choose Installed | Visual C# | Windows Classic Desktop on the left in the New
    Project window, as shown in the following screenshot. Then, click on Console App
    (.NET Framework) in the middle. You should also type a name of the project (Name)
    and a name of the solution (Solution name), as well as select location for the
    files (Location) by pressing the Browse button. At the end, click on OK to automatically
    create the project and generate the necessary files:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目窗口的左侧选择已安装 | Visual C# | Windows经典桌面，如下面的屏幕截图所示。然后，在中间点击Console App (.NET
    Framework)。您还应该输入项目的名称（名称）和解决方案的名称（解决方案名称），并通过按浏览按钮选择文件的位置（位置）。最后，点击确定以自动创建项目并生成必要的文件：
- en: '![](img/f27929bd-547a-45de-b61d-81356765196b.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f27929bd-547a-45de-b61d-81356765196b.png)'
- en: Congratulations, you have just created the first project! But what is inside?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚创建了第一个项目！但里面有什么呢？
- en: Let's take a look at the Solution Explorer window, which presents the structure
    of the project. It is worth mentioning that the project is included in the solution
    with the same name. Of course, a solution could contain more than one project,
    which is a common scenario while developing more complex applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看“解决方案资源管理器”窗口，它显示了项目的结构。值得一提的是，该项目包含在同名的解决方案中。当然，一个解决方案可以包含多个项目，这在开发更复杂的应用程序时是常见的情况。
- en: If you cannot find the Solution Explorer window, you could open it by choosing
    the View | Solution Explorer option from the main menu. In a similar way, you
    could open other windows, such as Output or Class View. If you cannot find a suitable
    window (for example, C# Interactive) directly within the View option, let's try
    to find it in the View | Other Windows node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到“解决方案资源管理器”窗口，可以通过从主菜单中选择“查看 | 解决方案资源管理器”选项来打开它。类似地，您可以打开其他窗口，如输出或类视图。如果在“查看”选项中找不到合适的窗口（例如C#交互），让我们尝试在“查看
    | 其他窗口”节点中找到它。
- en: 'The automatically generated project (named `GettingStarted`) has the following
    structure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的项目（名为`GettingStarted`）具有以下结构：
- en: The Properties node with one file (`AssemblyInfo.cs`) that contains general
    information about the assembly with the application, such as about its title,
    copyright, and version. The configuration is performed using attributes, for example,
    `AssemblyTitleAttribute` and `AssemblyVersionAttribute`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “属性”节点包含一个文件（`AssemblyInfo.cs`），其中包含有关应用程序的程序集的一般信息，例如标题、版权和版本。使用属性进行配置，例如`AssemblyTitleAttribute`和`AssemblyVersionAttribute`。
- en: The References element presents additional assemblies or projects that are used
    by the project. It is worth noting that you could easily add references by choosing
    the Add Reference option from the context menu of the References element. Moreover,
    you could install additional packages using the NuGet Package Manager, which could
    be launched by choosing Manage NuGet Packages from the References context menu.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “引用”元素显示了项目使用的其他程序集或项目。值得注意的是，您可以通过从“引用”元素的上下文菜单中选择“添加引用”选项来轻松添加引用。此外，您可以使用NuGet软件包管理器安装其他软件包，该软件包可以通过从“引用”上下文菜单中选择“管理NuGet软件包”来启动。
- en: It is a good idea to take a look at packages already available before writing
    the complex module on your own because a suitable package could be already available
    for developers. In such a case, you could not only shorten the development time,
    but also reduce the chance of introducing mistakes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己编写复杂模块之前，先看看已经可用的包是个好主意，因为适当的包可能已经为开发人员提供。在这种情况下，您不仅可以缩短开发时间，还可以减少引入错误的机会。
- en: The `App.config` file contains the **Extensible Markup Language** (**XML**)-based
    configuration of the application, including the number of the minimum supported
    version of the .NET Framework platform.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.config`文件包含应用程序的基于**可扩展标记语言**（**XML**）的配置，包括.NET Framework平台的最低支持版本号。'
- en: 'The `Program.cs` file contains the code of the main class in the C# language.
    You could adjust the behavior of the application by changing the following default
    implementation:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.cs`文件包含C#语言中主类的代码。您可以通过更改以下默认实现来调整应用程序的行为：'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The initial content of the `Program.cs` file contains the definition of the
    `Program` class within the `GettingStarted` namespace. The class contains the
    `Main` static method, which is called automatically when the application is launched.
    The five `using` statements are included as well, namely `System`, `System.Collections.Generic`,
    `System.Linq`, `System.Text`, and `System.Threading.Tasks`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs`文件的初始内容包含了`GettingStarted`命名空间中`Program`类的定义。该类包含了`Main`静态方法，当应用程序启动时会自动调用。还包括了五个`using`语句，分别是`System`、`System.Collections.Generic`、`System.Linq`、`System.Text`和`System.Threading.Tasks`。'
- en: Before proceeding, let's take a look at the structure of the project in the
    file explorer, not in the Solution Explorer window. Are such structures exactly
    the same?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们在文件资源管理器中查看项目的结构，而不是在“解决方案资源管理器”窗口中。这些结构是否完全相同？
- en: You could open the directory with the project in the file explorer by choosing
    the Open Folder in File Explorer option from the context menu of the project node
    in the Solution Explorer window.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在“解决方案资源管理器”窗口中的项目节点的上下文菜单中选择“在文件资源管理器中打开文件夹”选项来打开项目所在的目录。
- en: First of all, you can see the `bin` and `obj` directories, which are generated
    automatically. Both contain `Debug` and `Release` directories, whose names are
    related to the configuration set in the IDE. After building the project, a subdirectory
    of the `bin` directory (that is, `Debug` or `Release`) contains `.exe`, `.exe.config`,
    and `.pdb` files, while the subdirectory in the `obj` directory—for example—contains
    `.cache` and some temporary `.cs` files. What's more, there is no `References`
    directory, but there are `.csproj` and `.csproj.user` files with XML-based configurations
    of the project. Similarly, the solution-based `.sln` configuration file is located
    in the solution's directory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以看到自动生成的`bin`和`obj`目录。两者都包含与IDE中设置的配置相关的`Debug`和`Release`目录。构建项目后，`bin`目录的子目录（即`Debug`或`Release`）包含`.exe`、`.exe.config`和`.pdb`文件，而`obj`目录中的子目录，例如，包含`.cache`和一些临时`.cs`文件。此外，没有`References`目录，但是有项目的基于XML的`.csproj`和`.csproj.user`文件。类似地，基于解决方案的`.sln`配置文件位于解决方案的目录中。
- en: If you are using a **version control system**, such as **SVN** or **Git**, you
    could ignore the `bin` and `obj` directories, as well as the `.csproj.user` file.
    All of them can be generated automatically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用**版本控制系统**，比如**SVN**或**Git**，您可以忽略`bin`和`obj`目录，以及`.csproj.user`文件。所有这些都可以自动生成。
- en: If you want to learn how to write some example code, as well as launch and debug
    the program, let's proceed to the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想学习如何编写一些示例代码，以及启动和调试程序，让我们继续到下一节。
- en: Input and output
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出
- en: Many examples shown in the following part of the book will require interaction
    with the user, especially by reading input data and showing output. You can easily
    add such features to the application, as explained in this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 书的后面部分中展示的许多示例将需要与用户进行交互，特别是通过读取输入数据和显示输出。您可以按照本节中的说明轻松地向应用程序添加这些功能。
- en: Reading from input
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从输入中读取
- en: The application can read data from the **standard input stream** using a few
    methods from the `Console` static class from the `System` namespace, such as `ReadLine`
    and `ReadKey`. Both are presented in the examples in this section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用`System`命名空间中`Console`静态类的几种方法从**标准输入流**中读取数据，例如`ReadLine`和`ReadKey`。这两者都在本节的示例中展示了。
- en: 'Let''s take a look at the following line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下面的代码行：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you use the `ReadLine` method. It waits until the user presses the *Enter*
    key. Then, the entered text is stored as a value of the `fullName` string variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`ReadLine`方法。它会等待用户按下*Enter*键。然后，输入的文本将作为`fullName`字符串变量的值存储。
- en: 'In a similar way, you can read data of other types, such as `int`, as shown
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，您可以读取其他类型的数据，例如`int`，如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the same `ReadLine` method is called and the entered text is stored
    as a value of the `numberString` variable. Then, you just need to parse it to
    `int` and store it as a value of the `int` variable. How can you do that? The
    solution is very simple—use the `TryParse` static method of the `Int32` struct.
    It is worth mentioning that such a method returns a Boolean value, indicating
    whether the parsing process has finished successfully. Thus, you can perform some
    additional actions when the provided `string` representation is incorrect.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用了相同的`ReadLine`方法，并将输入的文本存储为`numberString`变量的值。然后，您只需要将其解析为`int`并将其存储为`int`变量的值。您可以如何做到这一点？解决方案非常简单——使用`Int32`结构的`TryParse`静态方法。值得一提的是，这样的方法返回一个布尔值，指示解析过程是否成功完成。因此，当提供的`string`表示不正确时，您可以执行一些额外的操作。
- en: 'A similar scenario, regarding the `DateTime` structure and the `TryParseExact`
    static method, is shown in the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，展示了关于`DateTime`结构和`TryParseExact`静态方法的类似情况：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example is more complicated than the previous one, so let's explain it
    in detail. First of all, the string representation of the date and time is stored
    as a value of the `dateTimeString` variable. Then, the `TryParseExact` static
    method of the `DateTime` struct is called, passing five parameters, namely the
    string representation of the date and time (`dateTimeString`), the expected format
    of the date and time (`M/d/yyyy HH:mm`), the supported culture (`en-US`), the
    additional styles (`None`), as well as the output variable (`dateTime`) passed
    by reference using the `out` parameter modifier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例比之前的更复杂，所以让我们详细解释一下。首先，日期和时间的字符串表示被存储为`dateTimeString`变量的值。然后，调用了`DateTime`结构的`TryParseExact`静态方法，传递了五个参数，即日期和时间的字符串表示（`dateTimeString`）、日期和时间的预期格式（`M/d/yyyy
    HH:mm`）、支持的文化（`en-US`）、附加样式（`None`），以及通过`out`参数修饰符传递的输出变量（`dateTime`）。
- en: If the parsing is not completed successfully, the current date and time (`DateTime.Now`)
    is assigned to the `dateTime` variable. Otherwise, the `dateTime` variable contains
    the `DateTime` instance consistent with the `string` representation provided by
    the user.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析未成功完成，则将当前日期和时间（`DateTime.Now`）分配给`dateTime`变量。否则，`dateTime`变量包含与用户提供的`string`表示一致的`DateTime`实例。
- en: 'While writing the part of code involving the `CultureInfo` class name, you
    could see the following error: `CS0246 The type or namespace name ''CultureInfo''
    could not be found (are you missing a using directive or an assembly reference?)`.
    This means that you do not have a suitable `using` statement at the top of the
    file. You can easily add one by clicking on the bulb icon shown in the left-hand
    margin of the line with the error and choosing the using System.Globalization;
    option. The IDE will automatically add the missing `using` statement and the error
    will disappear.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及`CultureInfo`类名称的代码部分中，您可能会看到以下错误：`CS0246 The type or namespace name 'CultureInfo'
    could not be found (are you missing a using directive or an assembly reference?)`。这意味着您在文件顶部没有合适的`using`语句。您可以通过单击显示在错误行左侧边缘的灯泡图标并选择`using
    System.Globalization;`选项来轻松添加一个。IDE将自动添加缺少的`using`语句，错误将消失。
- en: 'Apart from reading the whole line, you can also get to know which character
    or function key has been pressed by the user. To do so, you can use the `ReadKey`
    method, as shown in the following part of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取整行外，您还可以了解用户按下了哪个字符或功能键。为此，您可以使用`ReadKey`方法，如下面的代码部分所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After calling the `ReadKey` static method and once any key has been pressed
    by a user, information about the pressed key is stored as the `ConsoleKeyInfo`
    instance (that is, `key`, in the current example). Then, you use the `Key` property
    to get an enumeration value (of `ConsoleKey`) representing a particular key. At
    the end, the `switch` statement is used to perform operations depending on the
    key that has been pressed. In the example shown, three keys are supported, namely
    *S*, *F1*, and *Esc*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ReadKey`静态方法后，一旦用户按下任意键，按下的键的信息就会被存储为`ConsoleKeyInfo`实例（在当前示例中为`key`）。然后，您可以使用`Key`属性获取表示特定键的枚举值（`ConsoleKey`）。最后，使用`switch`语句根据按下的键执行操作。在所示的示例中，支持三个键，即*S*，*F1*和*Esc*。
- en: Writing to output
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入输出
- en: Now, you know how to read input data, but how can you ask questions to the user
    or present results on the screen? The answer, together with examples, is shown
    in this section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何读取输入数据，但如何向用户提问或在屏幕上显示结果呢？答案以及示例在本节中展示。
- en: Similarly as in the case of reading data, operations related to the **standard
    output stream** are performed using methods of the `Console` static class from
    the `System` namespace, namely `Write` and `WriteLine`. Let's see them in action!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取数据一样，与**标准输出流**相关的操作使用`System`命名空间中`Console`静态类的方法执行，即`Write`和`WriteLine`。让我们看看它们的运作方式！
- en: 'To write some text, you can just call the `Write` method, passing the text
    as a parameter. An example of code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要写一些文本，您只需调用`Write`方法，将文本作为参数传递。代码示例如下：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding line causes the following output to be shown:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行导致显示以下输出：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What''s important here is that the written text is not followed by the line
    terminator. If you want to write some text and move to the next line, you can
    use the `WriteLine` method, as shown in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，所写的文本后面没有跟随换行符。如果要写一些文本并移到下一行，可以使用`WriteLine`方法，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After executing this line of code, the following output is presented:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此行代码后，将呈现以下输出：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, you can also use `Write` and `WriteLine` methods in more complex
    scenarios. For example, you can pass many parameters to the `WriteLine` method,
    namely the format and additional arguments, as shown in the following part of
    the code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还可以在更复杂的情况下使用`Write`和`WriteLine`方法。例如，您可以向`WriteLine`方法传递许多参数，即格式和附加参数，如下面代码的部分所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the line will contain `Hello`, a comma, a space, a value of the
    `name` variable (that is, `Marcin`), as well as the exclamation mark. The output
    is shown as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该行将包含`Hello`，逗号，空格，`name`变量的值（即`Marcin`），以及感叹号。输出如下所示：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next example presents a significantly more complex scenario of writing
    the line regarding the confirmation of a table reservation at a restaurant. The
    output should have the format `Table [number] has been booked for [count] people
    on [date] at [time]`. You can achieve this goal by using the `WriteLine` method,
    as shown as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例呈现了一个更复杂的场景，涉及在餐厅预订桌子的确认。输出应具有格式`Table [number] has been booked for [count]
    people on [date] at [time]`。您可以通过使用`WriteLine`方法来实现这个目标，如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The example starts with a declaration of four variables, namely `tableNumber`
    (`A100`), `peopleCount` (`4`), and `reservationDateTime` (10/28/2017 at 11:00
    AM), as well as `cultureInfo` (`en-US`). Then, the `WriteLine` method is called
    passing five parameters, namely the format string followed by arguments that should
    be shown in the places marked with `{0}`, `{1}`, `{2}`, and `{3}`. It is worth
    mentioning the last two lines, where the string presenting date (or time) is created,
    based on the current value of the `reservationDateTime` variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例以声明四个变量开始，即`tableNumber`（`A100`），`peopleCount`（`4`），`reservationDateTime`（2017年10月28日上午11:00），以及`cultureInfo`（`en-US`）。然后，调用`WriteLine`方法，传递五个参数，即格式字符串，后跟应显示在标有`{0}`，`{1}`，`{2}`和`{3}`的位置的参数。值得一提的是最后两行，其中基于`reservationDateTime`变量的当前值创建了表示日期（或时间）的字符串。
- en: 'After executing this code, the following line is shown in the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，将在输出中显示以下行：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, in real-world scenarios, you will use read- and write-related methods
    in the same code. For example, you can ask a user to provide a value (using the `Write`
    method) and then read the text entered (using the `ReadLine` method).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实场景中，您将在同一代码中使用读取和写入相关的方法。例如，您可以要求用户提供一个值（使用`Write`方法），然后读取输入的文本（使用`ReadLine`方法）。
- en: 'This simple example, which is also useful in the next section of this chapter,
    is shown as follows. It allows the user to enter data relating to the table reservation,
    namely the table number and the number of people, as well as the reservation date.
    When all of the data is entered, the confirmation is presented. Of course, the
    user will see information about the data that should be provided:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子，在本章的下一节中也很有用，如下所示。它允许用户输入与表格预订相关的数据，即桌号和人数，以及预订日期。当所有数据都输入后，将呈现确认。当然，用户将看到应提供的数据的信息：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code snippet is based on the parts of code shown and described
    previously. After launching the program and entering the necessary data, the output
    could look as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是基于先前显示和描述的代码部分。启动程序并输入必要的数据后，输出可能如下所示：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the code is created, it is a good idea to improve its quality. One of the
    interesting possibilities associated with the IDE is related to removing unused
    `using` statements, together with sorting the remaining ones. You can easily perform
    such an operation by choosing the Remove and Sort Usings option from the context
    menu in the text editor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，改进其质量是个好主意。与IDE相关的有趣可能性之一是删除未使用的`using`语句，以及对剩余语句进行排序。您可以通过在文本编辑器中选择“删除并排序使用”选项来轻松执行此操作。
- en: Launching and debugging
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和调试
- en: Unfortunately, the written code doesn't always work as expected. In such a case,
    it is a good idea to start **debugging** to see how the program operates, find
    the source of the problem, and correct it. This task is especially useful for
    complex algorithms, where the flow could be complicated, and therefore quite difficult
    to analyze just by reading the code. Fortunately, the IDE is equipped with various
    features for debugging that will be presented in this section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，编写的代码并不总是按预期工作。在这种情况下，最好开始**调试**，看看程序的运行方式，找到问题的源头并进行更正。这项任务对于复杂的算法特别有用，其中流程可能很复杂，因此仅通过阅读代码就很难分析。幸运的是，IDE配备了各种调试功能，将在本节中介绍。
- en: First of all, let's launch the application to see it in action! To do so, you
    just need to select a proper configuration from the drop-down list (Debug, in
    this example) and click on the button with the green triangle and the Start caption
    in the main toolbar, or press *F5*. To stop debugging, you can choose Debug |
    Stop Debugging or press *Shift* + *F5*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们启动应用程序，看看它的运行情况！要这样做，您只需从下拉列表中选择适当的配置（在本例中为调试），然后单击主工具栏中带有绿色三角形和“开始”标题的按钮，或按下*F5*。要停止调试，您可以选择调试
    | 停止调试，或按下*Shift* + *F5*。
- en: You can also run the application without debugging. To do so, choose Debug |
    Start Without Debugging from the main menu or press *Ctrl* + *F5*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在不调试的情况下运行应用程序。要这样做，请从主菜单中选择调试 | 启动无调试，或按下*Ctrl* + *F5*。
- en: As already mentioned, there are various debugging techniques, but let's start
    with breakpoint-based debugging, since it is one of the most common approaches
    offering huge opportunities. You can place a **breakpoint** in any line of the
    code. The program will stop as soon as the line is reached, before executing it.
    Then, you can see the values of particular variables to check whether the application
    works as expected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有各种调试技术，但让我们从基于断点的调试开始，因为这是提供巨大机会的最常见方法之一。您可以在代码的任何行中放置**断点**。程序将在达到该行之前停止执行。然后，您可以查看特定变量的值，以检查应用程序是否按预期工作。
- en: 'To add a breakpoint, you can either click on the left-hand margin (next to
    the line on which the breakpoint should be placed) or place the cursor on the
    line (where the breakpoint should be added) and press the *F9* key. In both cases,
    the red circle will be shown, as well as the code from the given line will be
    marked with a red background, as shown in line 17 in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加断点，您可以单击左边的边距（在应放置断点的行旁边）或将光标放在应添加断点的行上，并按下*F9*键。在这两种情况下，将显示红色圆圈，并且给定行的代码将标有红色背景，如下截图中的第17行所示：
- en: '![](img/eb41bd4a-e0b2-4398-a76c-c5790e103123.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb41bd4a-e0b2-4398-a76c-c5790e103123.png)'
- en: When a line with the breakpoint is reached while executing the program, it stops,
    and the line is marked with the yellow background and the margin icon changes,
    as shown in line 15 in the screenshot. Now, you can check the value of the variable
    by simply moving the cursor over its name. The current value will appear in the
    ToolTip.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行程序时到达带有断点的行时，程序将停止，并且该行将标有黄色背景，边距图标也会更改，如截图中的第15行所示。现在，您可以通过简单地将光标移动到其名称上来检查变量的值。当前值将显示在工具提示中。
- en: You can also click on the pin icon located on the right-hand side of the ToolTip
    to pin it in the editor. Its value will then be visible without the necessity
    of moving the cursor over the name of the variable. Such a value will be automatically
    refreshed as soon as it has changed. The result is presented in the following
    screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以单击位于工具提示右侧的图钉图标，将其固定在编辑器中。然后，该值将在不必移动光标到变量名称上的情况下可见。一旦值发生变化，该值将自动刷新。结果如下截图所示。
- en: The IDE could adjust its appearance and features depending on the operations performed
    currently. For example, while debugging, you have access to some special windows,
    such as Locals, Call Stack, and Diagnostic Tools. The first shows available local
    variables together with their types and values. The Call Stack window presents
    information about the following called methods. The last one (namely Diagnostic
    Tools) shows information about memory and CPU usage, as well as events.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: IDE可以根据当前执行的操作调整其外观和功能。例如，在调试时，您可以访问一些特殊的窗口，例如Locals、Call Stack和Diagnostic Tools。第一个显示可用的本地变量及其类型和值。Call
    Stack窗口显示有关以下调用方法的信息。最后一个（即Diagnostic Tools）显示有关内存和CPU使用情况以及事件的信息。
- en: 'Moreover, the IDE supports conditional breakpoints that stop execution of the
    program only if the associated Boolean expression is evaluated to `true`. You
    can add a condition to a given breakpoint by choosing the Conditions option from
    the context menu, which is shown after right-clicking on the breakpoint icon in
    the left-hand margin. Then, the Breakpoint Settings window appears, where you
    should check the Conditions checkbox and specify the Conditional Expression, such
    as the one shown in the following screenshot. In the example, execution will stop
    only when the value of the `count` variable is greater than `5`, that is, `count
    > 5`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IDE支持条件断点，仅当关联的布尔表达式计算为`true`时才停止程序的执行。您可以通过选择上下文菜单中的Conditions选项来为给定的断点添加条件，该菜单在右键单击左侧边栏中的断点图标后显示。然后，断点设置窗口将出现，在那里您应该勾选条件复选框并指定条件表达式，例如在以下屏幕截图中显示的表达式。在示例中，只有当`count`变量的值大于`5`时，即`count
    > 5`时，执行才会停止：
- en: '![](img/b2228230-44fd-477c-bebc-3be5145fc5fd.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2228230-44fd-477c-bebc-3be5145fc5fd.png)'
- en: When the execution is stopped, you can use the step-by-step debugging technique.
    To move execution of the program to the next line (without incorporating another
    breakpoint), you can click on the Step Over icon in the main toolbar or press
    *F10*. If you want to step into the method, which is called in the line where
    the execution has stopped, just click on the Step Into button or press *F11*.
    Of course, you can also go to the next breakpoint by clicking on the Continue
    button or by pressing *F5*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行停止时，您可以使用逐步调试技术。要将程序的执行移动到下一行（而不是加入另一个断点），您可以单击主工具栏中的Step Over图标，或按*F10*。如果要进入在执行停止的行中调用的方法，只需单击Step
    Into按钮或按*F11*。当然，您也可以通过单击Continue按钮或按*F5*来转到下一个断点。
- en: 'The next interesting feature, available in the IDE, is called Immediate Window.
    It allows developers to execute various expressions when the program execution
    is stopped using the current values of the variables. You just need to enter an
    expression in the Immediate Window and press the *Enter* key. The example is shown
    in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: IDE中的下一个有趣功能称为Immediate Window。它允许开发人员在程序执行停止时使用变量的当前值执行各种表达式。您只需在Immediate
    Window中输入表达式，然后按*Enter*键。示例如下屏幕截图所示：
- en: '![](img/a8826820-8d88-47c8-95ab-b75584792e00.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8826820-8d88-47c8-95ab-b75584792e00.png)'
- en: Here, the lower-case version of the table number is returned by executing `table.ToLower()`.
    Then, the total number of minutes between the current date and the `dateTime`
    variable is calculated and shown in the window.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过执行`table.ToLower()`返回表号的小写版本。然后，计算并显示当前日期和`dateTime`变量之间的总分钟数。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was only the first chapter of the book, but it contained quite a lot of
    information that will be useful while reading the remaining ones. At the beginning,
    you saw that using proper data structures and algorithms is not an easy task,
    but could have a significant impact on the performance of the developed solution.
    Then, the C# programming language was briefly presented with a focus on showing
    various data types, both value and reference ones. Classes, interfaces, and delegates
    were also described.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是本书的第一章，但它包含了很多信息，在阅读剩下的章节时将会很有用。一开始，您看到使用适当的数据结构和算法并不是一件容易的事，但可能会对开发解决方案的性能产生重大影响。然后，简要介绍了C#编程语言，重点介绍了各种数据类型，包括值类型和引用类型。还描述了类、接口和委托。
- en: In the following part of the chapter, the process of installation and configuration
    of the IDE was presented. Then, you learned how to create a new project, and its
    structure has been described in details. Next, you saw how to read data from the
    standard input stream, as well as how to write data to the standard output stream.
    The read- and write-related operations were also mixed into one example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，介绍了IDE的安装和配置过程。然后，您学习了如何创建一个新项目，并详细描述了其结构。接下来，您看到了如何从标准输入流中读取数据，以及如何将数据写入标准输出流。读取和写入相关的操作也混合在一个示例中。
- en: At the end of the chapter, you saw how to run the example program, as well as
    how to debug it using breakpoints and step-by-step debugging to find the source
    of the problem. What's more, you learned the possibilities of the Immediate Window
    feature.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您学会了如何运行示例程序，以及如何使用断点和逐步调试来找到问题的根源。此外，您还了解了Immediate Window功能的可能性。
- en: After this introduction, you should be ready to proceed to the next chapter
    and see how to use arrays and lists, as well as accompanying algorithms. Let's
    go!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍完毕后，您应该准备继续下一章，了解如何使用数组和列表，以及相关的算法。让我们开始吧！
