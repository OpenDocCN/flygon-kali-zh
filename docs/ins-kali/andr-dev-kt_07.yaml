- en: Extension Functions and Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数和属性
- en: In previous chapters, most of the concepts were familiar to Java developers.
    In this chapter, we are introducing a feature that was not known in Java at all--extensions.
    It is one of the best Kotlin features, and lots of Kotlin developers are mentioning
    it as their favorite one. Extensions are making a big improvement in Android development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，大多数概念对Java开发人员来说都很熟悉。在本章中，我们介绍了一个在Java中完全不知道的功能--扩展。这是Kotlin最好的功能之一，许多Kotlin开发人员都将其称为自己最喜欢的功能之一。扩展在Android开发中有了很大的改进。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: Extension functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Extension properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展属性
- en: Member extension functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员扩展函数
- en: Generic extension functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用扩展函数
- en: Collection processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合处理
- en: Function type with receiver and function literal with receiver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带接收器的函数类型和带接收器的函数文字
- en: Kotlin generic extension functions to any object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin通用扩展函数到任何对象
- en: Kotlin domain-specific language
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin领域特定语言
- en: Extension functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: 'All bigger Java projects have utility classes, such as `StringUtils` , `ListUtils`
    , `AndroidUtils` , and so on. It is so popular because util functions capture
    common patterns and allow them to be tested and used in a simpler way. The problem
    was that Java really poorly supports the creation and usage of such functions,
    because they have to be implemented as static functions of some class. Let''s
    discuss this problem with an example. Every Java Android developer knows well
    the following code used to show `Toast` :'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有较大的Java项目都有实用程序类，例如`StringUtils`，`ListUtils`，`AndroidUtils`等。这是如此流行，因为util函数捕捉常见模式，并允许以更简单的方式进行测试和使用。问题在于Java对这种函数的创建和使用支持非常差，因为它们必须实现为某个类的静态函数。让我们通过一个例子讨论这个问题。每个Java
    Android开发人员都很熟悉用于显示`Toast`的以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is commonly used in Android projects for showing errors or short messages,
    and often it is presented at the beginning of most Android tutorials. Code that
    implements this functionality is verbose, because of how it is using a static
    function that is used like a builder. Probably every Java Android developer at
    least once has forgotten to invoke the `show` method on a returned object, which
    made him check all surrounding conditions to find out why this is not working.
    This all makes this simple functionality a perfect candidate to be packed as an
    util function. But it is really rarely used this way. Why? To understand it, let''s
    first look at how it could be implemented in Java:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android项目中通常用于显示错误或短消息，并且通常出现在大多数Android教程的开头。由于它使用类似构建器的静态函数，实现此功能的代码是冗长的。也许每个Java
    Android开发人员至少有一次忘记在返回的对象上调用`show`方法，这使他检查所有周围的条件以找出为什么这不起作用。所有这些都使得这个简单的功能成为打包为util函数的完美候选者。但实际上很少以这种方式使用。为什么？要理解这一点，让我们首先看看它在Java中是如何实现的：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When a programmer wants to use the following function, they needs to remember
    that there is such function, in which class it is localized, and what its name
    is. Therefore, its usage is not simpler than previous. It is impossible to implement
    it as a method of `Context` (a superclass of `Activity` ) without changing the
    Android SDK implementation, but in Kotlin, it is possible to create an extension
    function, which acts similarly to an actual method defined inside a class. Here
    is how we can implement `toast` as an extension to `Context` :'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员想要使用以下函数时，他们需要记住有这样的函数，在哪个类中定位，以及它的名称是什么。因此，它的使用并不比以前简单。在不改变Android SDK实现的情况下，无法将其实现为`Context`（`Activity`的超类）的方法，但在Kotlin中，可以创建一个扩展函数，其行为类似于在类内部定义的实际方法。以下是我们如何将`toast`实现为`Context`的扩展：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Context` is not on the argument list, but before the function name. This is
    how we define what type we are extending.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context` 不在参数列表中，而是在函数名之前。这是我们定义我们要扩展的类型的方式。'
- en: Inside the function body, we can use the this keyword to reference the object
    on which the extension function is invoked.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体内，我们可以使用this关键字引用调用扩展函数的对象。
- en: 'The only difference in the general structure between an extension function
    and a standard function is that there is a receiver type specified before the
    function name. A less visible change is inside the body--there, we can access
    the receiver object (the object on which an extension is called) by the `this`
    keyword, or directly call its functions or properties. With such a definition,
    the `toast` function acts like a method defined in `Context` :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数和标准函数之间在一般结构上的唯一区别是在函数名之前指定了接收器类型。在函数体内部，我们可以使用`this`关键字访问接收器对象（调用扩展的对象），或直接调用其函数或属性。有了这样的定义，`toast`函数就像在`Context`中定义的方法一样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This makes usage of the `toast` function much easier than implementation of
    the whole toast-displaying code. We also get suggestions from the IDE, that we
    can invoke this function when we are inside `Context` (like inside `Activity`
    ) or on an instance of `Context` :'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用`toast`函数比实现整个显示toast的代码更容易。我们还可以从IDE中得到建议，在`Context`（如在`Activity`内部）或`Context`的实例中调用此函数时，我们可以调用此函数：
- en: '![](img/Image00044.jpg)![](img/Image00045.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00044.jpg)![](img/Image00045.jpg)'
- en: 'In the preceding example, `Context` is a receiver type of the `toast` function,
    and the `this` instance is a reference to the receiver object. All functions and
    properties of the receiver object can be accessed explicitly, so we can take the
    following definition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Context` 是 `toast` 函数的接收器类型，`this` 实例是对接收器对象的引用。可以显式访问接收器对象的所有函数和属性，因此我们可以采用以下定义：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then replace it with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用以下内容替换它：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are multiple use cases where extension functions are useful. Similar
    extension functions can be defined for `View` , `List` , `String` , and other
    classes defined in the Android framework or a third-party library and custom classes
    defined by the developer. Extension functions can be added to any accessible type,
    even to the `Any` object. Here is an extension function that can be called on
    every object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数有多种有用的用例。类似的扩展函数可以为`View`，`List`，`String`和 Android 框架或第三方库中定义的其他类以及开发人员定义的自定义类定义。扩展函数可以添加到任何可访问的类型，甚至可以添加到`Any`对象。以下是一个可以在每个对象上调用的扩展函数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some call examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些调用示例：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Supposing that we are invoking this in `MainActivity` .
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们在`MainActivity`中调用这个函数。
- en: We can simply add any method to any class we want. This is a great improvement
    for Android development. With it, we have a way to add missing methods or properties
    to types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地向任何我们想要的类添加任何方法。这对于 Android 开发是一个很大的改进。有了它，我们有一种方法可以向类型添加丢失的方法或属性。
- en: Extension functions under the hood
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数的内部机制
- en: 'While Kotlin extension functions might look magical, they are really simple
    under the hood. A top-level extension function is compiled to a static function
    with a receiver object on the first argument. Let''s look at the already presented
    `toast` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 扩展函数可能看起来像魔术，但在幕后它们实际上非常简单。顶级扩展函数被编译为具有接收对象的静态函数的第一个参数。让我们看看已经介绍的`toast`函数：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function, after compilation and decompilation to Java, would look similar
    to the following function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在编译和反编译为 Java 后，会看起来类似于以下函数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Kotlin top-level extension functions are compiled to static functions with
    a receiver object on the first parameter. This is why we can still use extensions
    from Java:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 顶级扩展函数被编译为具有接收对象的静态函数的第一个参数。这就是为什么我们仍然可以从 Java 中使用扩展函数：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, this means that from a JVM bytecode perspective, the method is not really
    added, but during compilation all extension function usages are compiled to static
    function calls. While extension functions are just functions, function modifiers
    can be applied to them the same as they can be also applied to any other function.
    For example, an extension function can be marked as `inline` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这意味着从 JVM 字节码的角度来看，该方法并没有真正添加，但在编译期间，所有扩展函数的用法都被编译为静态函数调用。虽然扩展函数只是函数，但函数修饰符可以应用于它们，就像它们也可以应用于任何其他函数一样。例如，扩展函数可以标记为`inline`：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As with other `inline` functions, the function call will be replaced with an
    actual body during application compilation. We can do with extension functions
    practically everything we can do with other functions. They can be single expression,
    have default arguments, be used by named parameters, and so on. But there are
    also other, less intuitive consequences of such implementation. In the next sections,
    we are going to describe them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`inline`函数一样，函数调用将在应用程序编译期间替换为实际的主体。我们可以使用扩展函数实际上可以做任何我们可以做的事情。它们可以是单个表达式，具有默认参数，可以通过命名参数使用等等。但这种实现还有其他一些不太直观的后果。在接下来的章节中，我们将对它们进行描述。
- en: No method overriding
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有方法重写
- en: 'When there is a member function and an extension function with the same name
    and parameters, the member function always wins. Here is an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在具有相同名称和参数的成员函数和扩展函数时，成员函数总是优先。这是一个例子：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is always true. Even methods from a superclass win with extension functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是成立的。即使是来自超类的方法也会受到扩展函数的影响：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The point is that the extension function is not allowing to modify the behavior
    of a real object. We can only add extra functionalities. This keeps us secured,
    because we know that no one will change the behavior of objects that we are using,
    which might lead to errors that are hard to track.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是扩展函数不允许修改真实对象的行为。我们只能添加额外的功能。这使我们得到了保障，因为我们知道没有人会改变我们正在使用的对象的行为，这可能导致难以追踪的错误。
- en: Access to receiver elements
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问接收器元素
- en: An extension function is compiled to a static function with a receiver object
    on the first parameter, so we have no extra access privilege. The `private` and
    `protected` elements are not accessible, and elements with Java `default` , Java
    `package` , or Kotlin `internal` modifiers are accessed the same as if we would
    just operate on standard object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数被编译为具有接收对象的静态函数的第一个参数，因此我们没有额外的访问权限。`private`和`protected`元素是不可访问的，具有 Java
    `default`，Java `package`或 Kotlin `internal`修饰符的元素与我们对标准对象进行操作时一样被访问。
- en: Thanks to that, these elements are protected as they should be. Remember that
    extension functions, while being really powerful and useful, are just syntactic
    sugar, and there is no magic there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这样，这些元素得到了应有的保护。请记住，扩展函数虽然强大而有用，但只是一种语法糖，其中并没有魔法。
- en: Extensions are resolved statically
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展是静态解析的
- en: 'Extension functions are just functions with a receiver as the first parameter,
    so their calls are resolved at compile time by the type on which the function
    is invoked. For example, when there are extension functions for both superclass
    and subclass, then the extension functions that will be chosen during invocation
    depend on the type of property on which we are operating. Here is an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数只是具有接收器作为第一个参数的函数，因此它们的调用是由调用函数的类型在编译时解析的。例如，当超类和子类都有扩展函数时，那么在调用期间选择的扩展函数取决于我们正在操作的属性的类型。这是一个例子：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we would expect `foo(B)` , while the object is, in fact, of type `B` ,
    but while extensions are resolved statically, it is using an extension function
    for `A` , because the variable is of type `A` and there is no information as to
    what object is there during compilation.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们期望`foo(B)`，而实际上对象的类型是`B`，但是由于扩展是静态解析的，它使用了`A`的扩展函数，因为变量的类型是`A`，在编译期间没有关于对象是什么的信息。
- en: This fact is sometimes problematic, because, when we define an extension function
    to the type we are most often cast to, then we should not implement extension
    functions to its subclasses.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实有时是有问题的，因为当我们为我们最常转换的类型定义扩展函数时，我们不应该为它的子类实现扩展函数。
- en: This is an important limitation, and should be kept in mind, especially during
    public library implementation, because this way, some extension functions can
    block others and cause unexpected behavior.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的限制，应该牢记在心，特别是在公共库实现期间，因为这种方式，一些扩展函数可能会阻止其他函数并导致意外行为。
- en: Companion object extensions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象扩展
- en: 'If a class has a companion object defined, then you can also define extension
    functions (and properties) for this companion object. To distinguish between an
    extension to a class and an extension to a companion object, there needs to be
    `.Companion` added between the extension type and function name:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了一个伴生对象，那么您也可以为这个伴生对象定义扩展函数（和属性）。要区分对类的扩展和对伴生对象的扩展，需要在扩展类型和函数名称之间添加`.Companion`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When it is defined, the `foo` method can be used as if it were defined inside
    the `A` companion object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被定义时，`foo`方法可以像在`A`伴生对象内定义的方法一样使用：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that we are calling this extension using class type, not class instance.
    To allow the creation of an extension function for a companion object, there needs
    to be a companion object explicitly defined inside the class. Even an empty one.
    Without it, it is impossible to define an extension function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用类类型而不是类实例来调用此扩展。要允许为伴生对象创建扩展函数，需要在类内明确定义一个伴生对象。即使是一个空的。没有它，就不可能定义扩展函数：
- en: '![](img/Image00046.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00046.jpg)'
- en: Operator overloading using extension functions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展函数进行操作符重载
- en: Operator overloading is a big Kotlin feature, but often we need to use Java
    libraries and operators that are not defined there. For example, in RxJava, we
    use the `CompositeDisposable` function to manage subscriptions. This collection
    uses the `add` method to add new elements. This is an example subscription added
    to `CompositeDisposable` *:*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符重载是Kotlin的一个重要特性，但通常我们需要使用Java库和那里未定义的操作符。例如，在RxJava中，我们使用`CompositeDisposable`函数来管理订阅。这个集合使用`add`方法来添加新元素。这是一个添加到`CompositeDisposable`的示例订阅*：*
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The standard Kotlin way to add a new element to a mutable collection is by
    using the `plusAssign` operator (`+=` ). It is not only more universal, but also
    cleaner, while we can omit brackets:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向可变集合添加新元素的标准Kotlin方式是使用`plusAssign`运算符（`+=`）。这不仅更通用，而且更清晰，而且我们可以省略括号：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To apply it in our example, we can add the following extension:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例中应用它，我们可以添加以下扩展：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And now we can use the `plusAssign` method on `CompositeDisposable` :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`CompositeDisposable`上使用`plusAssign`方法：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where should top-level extension functions be used?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶级扩展函数应该在哪里使用？
- en: 'Extension functions are most often used when we feel that a class defined by
    other programmers is missing some method. For example, if we think that `View`
    should contain `show` and `hide` methods, usage for which would be easier than
    visibility field setting, then we can just implement it ourselves:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数在我们觉得其他程序员定义的类缺少某些方法时最常用。例如，如果我们认为`View`应该包含`show`和`hide`方法，使用起来比可见性字段设置更容易，那么我们可以自己实现它：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is no need to remember the names of classes that hold util functions.
    In the IDE, we just put a dot after the object, and we can search through all
    methods that are provided together with this object extension functions from the
    project and libraries. Invocation looks good, while it looks like an original
    object member. This is the beauty of extension functions, but it is also a danger.
    Right now, there are already tons of Kotlin libraries that are just packs of extension
    functions. When we use lots of extension functions, we can make our Android code
    unlike normal Android code. This has both pros and cons. Here are the pros:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 无需记住保存util函数的类的名称。在IDE中，我们只需在对象后面加一个点，就可以搜索与该对象一起提供的所有方法，包括来自项目和库的扩展函数。调用看起来不错，就像原始对象成员一样。这就是扩展函数的美，但也是一个危险。现在已经有大量的Kotlin库，它们只是一堆扩展函数。当我们使用大量扩展函数时，我们的Android代码可能不像正常的Android代码。这既有利有弊。以下是利：
- en: Code is short and more readable
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更短，更易读
- en: Code presents more logic instead of Android boilerplate
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码呈现更多逻辑而不是Android样板
- en: Extension functions are most often tested, or at least used in multiple places,
    so it is simpler to find out if they are working correctly
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数通常在多个地方进行测试，或者至少在多个地方使用，因此更容易找出它们是否正常工作
- en: When we use extension functions, there is a smaller chance that we will make
    a stupid error that will lead to hours of code debugging
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用扩展函数时，我们很少会犯一个愚蠢的错误，导致数小时的代码调试
- en: 'To illustrate the last two points, we will go back to the `toast` function.
    It is hard to make an error in writing the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明最后两点，我们将回到`toast`函数。在编写以下内容时很难出错：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While it is much easier to make an error in the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在以下情况下更容易出错：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The biggest problem with strong extension usage in a project is that we are,
    in fact, making our own API. We are naming and implementing functions and we decide
    what arguments should be there. When some developer joins the team, he need to
    learn the entire API, we've created. The Android API has lots of shortcoming,
    but its strength is that it is universal and it is known to all Android developers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中强大的扩展使用的最大问题是，实际上我们正在制定自己的API。我们正在命名和实现函数，并决定应该有哪些参数。当一些开发人员加入团队时，他需要学习我们创建的整个API。Android
    API有很多缺点，但它的优势在于它是通用的，并且所有Android开发人员都知道它。
- en: 'Does this mean we should resign from extensions? Absolutely not! This is a
    great feature that is helping us to make code short and clean. The point is that
    we should use them in a smart way:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们应该放弃扩展？绝对不是！这是一个很好的功能，可以帮助我们使代码简洁清晰。关键是我们应该以聪明的方式使用它们：
- en: Avoid multiple extensions that are doing the same thing.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免执行相同操作的多个扩展。
- en: Short and simple functionality often doesn't need to be an extension.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短小简单的功能通常不需要成为扩展。
- en: Keep one coding style around the project. Talk to your team and specify some
    standards.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目周围保持一种编码风格。与您的团队交流并指定一些标准。
- en: Be careful when you are using public libraries with extensions. Keep them as
    the code that you cannot change and match your extensions to them to keep the
    API clear.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用具有扩展功能的公共库时要小心。将它们保留为无法更改的代码，并将您的扩展与它们匹配以保持API清晰。
- en: Extension properties
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展属性
- en: 'In this section, we will first understand what extension properties are, and
    then we will move on to learn where these properties can be used. As we already
    know, properties in Kotlin are defined by their accessors (getter and setter):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解什么是扩展属性，然后我们将继续学习这些属性可以在哪里使用。正如我们已经知道的，Kotlin中的属性是由它们的访问器（getter和setter）定义的：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can define also extension property. The only limitation is that this property
    can’t have backing field. The reason for this is that extension can’t store state,
    so there is no good place to store this field. Here is an example of extension
    property definition for `TextView` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义扩展属性。唯一的限制是该属性不能有后备字段。原因是扩展不能存储状态，因此没有好地方来存储此字段。以下是`TextView`的扩展属性定义示例：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As with extension functions, the above implementation will be compiled as an
    accessor function with a receiver on the first parameter. Here is the simplified
    result in Java:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展函数一样，上述实现将被编译为具有第一个参数的接收器的访问器函数。以下是Java中的简化结果：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If it were a read-write property, then both setter and getter would be implemented.
    Remember that only properties that don''t need a Java field are allowed to be
    defined as an extension property. For example, this is illegal:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个读写属性，那么setter和getter都将被实现。请记住，只有不需要Java字段的属性才允许被定义为扩展属性。例如，这是非法的：
- en: '![](img/Image00047.jpg)![](img/Image00048.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00047.jpg)![](img/Image00048.jpg)'
- en: Where should extension properties be used?
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展属性应该在哪里使用？
- en: 'Extension properties can often be used interchangeably with extension functions.
    They are both most often used as top-level utils. Extension properties are used
    when we would like an object to have some property that was not developed natively.
    The decision as to whether we should use an extension function or an extension
    property is nearly the same as the decision as to whether we should use a function
    or property without a backing field inside a class. Just to remind you, according
    to conventions, one should prefer a property over a function when the underlying
    algorithm fulfills the following conditions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性通常可以与扩展函数互换使用。它们通常都用作顶级工具。当我们希望对象具有一些未经原生开发的属性时，就会使用扩展属性。决定我们应该使用扩展函数还是扩展属性的决定几乎与我们在类内部使用不带后备字段的函数或属性的决定相同。只是提醒一下，根据惯例，当底层算法满足以下条件时，应优先选择属性而不是函数：
- en: Does not throw errors
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会抛出错误
- en: Has **O** (*1* ) complexity
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有O（1）复杂度
- en: Is cheap to calculate (or caсhed on the first run)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算成本低（或在第一次运行时缓存）
- en: Returns the same result over invocations
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用中返回相同的结果
- en: 'Let''s look at a simple problem. We often need to get some services in Android,
    but the code used to get them is complicated:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的问题。我们经常需要在Android中获取一些服务，但用于获取它们的代码很复杂：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To use a service such as `AlarmManager` or `LayoutInflater` , the programmer
    has to remember the following for each of them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用诸如`AlarmManager`或`LayoutInflater`之类的服务，程序员必须记住每个服务的以下内容：
- en: The name of the function that is providing it (such as `getSystemService` )
    and what class contains it (such as `Context` )
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供它的函数的名称（例如`getSystemService`）和包含它的类（例如`Context`）
- en: The name of the field that is specifying this service (such as `Context.ALARM_SERVICE`
    )
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定此服务的字段名称（例如`Context.ALARM_SERVICE`）
- en: The name of the class that the service should be cast to (such as `AlarmManager`
    )
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该转换为的类的名称（例如`AlarmManager`）
- en: 'This is complex, and this is the perfect place where we can optimize usage
    thanks to extension properties. We can define extension properties this way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这很复杂，这是我们可以通过扩展属性优化使用的完美场所。我们可以这样定义扩展属性：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And from now on, we can use `preferences` , `inflater` , and `alarmManager`
    as if they are properties of `Context` :'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以像`Context`的属性一样使用`preferences`，`inflater`和`alarmManager`：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These are perfect examples of good read-only extension function usage. Let's
    focus on the `inflater` extension property. It is helping to get elements that
    are often needed, but hard to get without extensions. It is helpful, because the
    programmer just needs to remember that what they need is an inflater and that
    they need `Context` to have it, and he does not need to remember the name of method
    that is providing system services (`getSystemService` ), the name of the key used
    to get the `inflater` property (`ALARM_SERVICE` ), where it is located (in `Context`
    ), and what this service should be cast to (`AlarmManager` ). In other words,
    this extension is saving a lot of work and programmer memory. Also, it is correct
    according to guidelines, because the time of property getter execution is short
    and its complexity is **O** (*1* ), it is not throwing any errors, and it is always
    returning the same `inflater` (in fact, it might be a different instance, but
    from a programmer perspective, its usage is always the same, and this is what
    is important).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是良好的只读扩展函数使用的完美例子。让我们专注于`inflater`扩展属性。它有助于获取通常需要的元素，但是没有扩展很难获取。这是有帮助的，因为程序员只需要记住他们需要的是一个inflater，他们需要`Context`来拥有它，而不需要记住提供系统服务的方法的名称（`getSystemService`），获取`inflater`属性的键的名称（`ALARM_SERVICE`），它位于哪里（在`Context`中），以及这个服务应该被转换为什么（`AlarmManager`）。换句话说，这个扩展节省了很多工作和程序员的记忆。此外，根据指南，属性getter的执行时间很短，复杂度为**O**(*1*),它不会抛出任何错误，并且总是返回相同的`inflater`（实际上，它可能是一个不同的实例，但从程序员的角度来看，它的使用方式总是相同的，这才是重要的）。
- en: 'We''ve seen read-only extension properties, but we have not seen read-write
    extension properties. Here is a good example, that is an alternative to the `hide`
    and `show` functions that we saw in the Extension functions section:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了只读扩展属性，但我们还没有看到读写扩展属性。这是一个很好的例子，是对扩展函数部分中我们看到的`hide`和`show`函数的替代品：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can change the visibility of the view element using this property:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个属性来改变视图元素的可见性：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we define it, we can treat is as if it really were a `View` property.
    It is also important that what we are setting is consistent with what we are getting.
    So supposing that there is no other thread which is changing element visibility,
    we can set some property value:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了它，我们就可以将其视为真正的`View`属性。重要的是，我们设置的内容与我们获取的内容保持一致。因此，假设没有其他线程改变元素的可见性，我们可以设置一些属性值：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then the getter will always provide the same value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后getter将始终提供相同的值：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, there is no other logic inside the getter and setter--only a change
    in specific properties. So other conventions we've presented before are satisfied
    too.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，getter和setter内部没有其他逻辑，只是特定属性的更改。因此，我们之前提出的其他约定也得到了满足。
- en: Member extension functions and properties
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员扩展函数和属性
- en: We've seen top-level extension functions and properties, but it is also possible
    to define them inside a class or object. Extensions defined there are called member
    extensions, and they are most often used for different kinds of problems than
    top-level extensions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了顶层扩展函数和属性，但也可以在类或对象内部定义它们。在那里定义的扩展称为成员扩展，它们通常用于不同于顶层扩展的各种问题。
- en: 'Let''s start from the simplest use case where member extensions are used. Let''s
    suppose that we need to drop every third element of a list of `String` . Here
    is the extension function that allows us to drop every i^(th) element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从成员扩展被使用的最简单的用例开始。假设我们需要删除`String`列表的每第三个元素。这是一个允许我们删除每个i^(th)元素的扩展函数：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The problem with that function is that it should not be extracted as a util
    extension, because of the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的问题在于，它不应该被提取为一个util扩展，因为：
- en: It is not prepared for different types of lists (such as a list of `User` ,
    or `Int` )
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有准备好用于不同类型的列表（比如`User`列表或`Int`列表）
- en: It is a rarely useful function, so probably it won't be used anywhere else in
    the project
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个很少有用的函数，所以可能不会在项目的其他地方使用
- en: 'This is why we would want to keep it as private, and it is a good idea to keep
    it inside the class where we are using it, as an member extension function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们希望将其保持为私有，并且将其作为成员扩展函数放在我们使用它的类内部的好主意：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the first reason we use member extension functions, to protect the
    accessibility of functions. In this case, it could be done by defining a function
    on the top level, in the same file, and with a private modifier. But member extension
    functions act differently to top-level functions. The function used in the preceding
    code is public, but it can only be called on `List<String>` and only in `UsersItemAdapter`
    . So it can be used only inside the `UsersItemAdapter` class and its subclasses
    or inside an extension function to `UsersItemAdapter` :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用成员扩展函数的第一个原因，是为了保护函数的可访问性。在这种情况下，可以通过在同一文件中的顶层定义一个带有私有修饰符的函数来实现。但是成员扩展函数的行为与顶层函数不同。在前面的代码中使用的函数是公共的，但它只能在`List<String>`上调用，并且只能在`UsersItemAdapter`中调用。因此，它只能在`UsersItemAdapter`类及其子类内部或在`UsersItemAdapter`的扩展函数内部使用：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that to use a member extension function, we need both the object in which
    it is implemented and the object on which this extension functions will be called.
    It is this way because we can use elements of both of these objects. This is important
    information about member extensions: they can use both elements from receiver
    type and from member type without a qualifier. Let''s see how it might be used.
    Here is another example, which is similar to the previous one, but it is using
    the private property `category` :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要使用成员扩展函数，我们需要实现它的对象和将调用这些扩展函数的对象。这是因为我们可以使用这两个对象的元素。这是关于成员扩展的重要信息：它们可以在没有限定符的情况下使用接收器类型和成员类型的元素。让我们看看它可能如何使用。这是另一个例子，类似于前一个例子，但它使用了私有属性`category`：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the member extension function `fromSameCategory` , we are operating
    on an extension receiver (`List<User>` ), but we are also using the `category`
    property from `UsersItemAdapter` . We see here that a function defined this way
    needs to be a method and it can be used similarly to other methods. The advantage
    over the standard method is that we can call a function on `List` , so we can
    keep clean stream processing, instead of non-extension method usage:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员扩展函数`fromSameCategory`内部，我们正在操作一个扩展接收器（`List<User>`），但我们也在使用`UsersItemAdapter`中的`category`属性。我们在这里看到，以这种方式定义的函数需要是一个方法，并且可以类似于其他方法一样使用。与标准方法相比的优势在于我们可以在`List`上调用函数，因此我们可以保持清晰的流处理，而不是使用非扩展方法：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another common usage is the member extension functions or properties can be
    used like normal methods, but we are using the fact that inside member functions
    we can use receiver properties and methods without naming them, this way we can
    have shorter syntax, and that we are actually calling them on a receiver instead
    of calling them with the same type as an argument. As an example, we can take
    the following method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用法是成员扩展函数或属性可以像普通方法一样使用，但我们正在利用成员函数内部可以使用接收器属性和方法而不命名它们的事实，这样我们可以有更短的语法，并且我们实际上是在接收器上调用它们，而不是使用相同类型作为参数调用它们。例如，我们可以采用以下方法：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we can replace it with the following member extension function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用以下成员扩展函数替换它：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using member extension functions, we can achieve both a simpler call and a simpler
    function body. The biggest problem with this attempt is that it is not clear which
    functions we are using are members of `RecyclerView` , and which are members of
    the `Activity` and `RecyclerView` extensions. This problem will be raised in the
    next pages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用成员扩展函数，我们可以实现更简单的调用和更简单的函数体。这次尝试的最大问题是不清楚我们使用的哪些函数是`RecyclerView`的成员，哪些是`Activity`和`RecyclerView`扩展的成员。这个问题将在接下来的页面中提出。
- en: Type of receivers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收器的类型
- en: 'When we have a member extension function, then it becomes more complicated
    to administer which elements we are calling. Inside a member extension, we have
    implicit access to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个成员扩展函数时，管理我们正在调用哪些元素变得更加复杂。在成员扩展内部，我们隐式访问以下内容：
- en: Member functions and properties, both from this class and superclasses
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自此类及其超类的成员函数和属性。
- en: Receiver type functions and properties, both from the receiver type and its
    supertypes
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收器类型的函数和属性，包括来自接收器类型及其超类型的函数和属性
- en: Top-level functions and properties
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级函数和属性
- en: 'So inside the `setUp` extension function, we can use both member and receiver
    methods and properties:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`setUp`扩展函数内部，我们可以同时使用成员和接收器的方法和属性：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`setText` is the `Button` class method.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setText`是`Button`类的方法。'
- en: We can use the `Button` class and `MainActivity` class members alternately.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以交替使用`Button`类和`MainActivity`类的成员。
- en: It might be tricky--probably most people wouldn't notice if there were an error
    and the `setText` call would be swapped with the `showText` call.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点棘手--也许大多数人不会注意到是否存在错误，并且`setText`调用将与`showText`调用交换。
- en: 'While we can use inside member extension elements from different receivers,
    to allow distinction between them, all kinds of receivers were named. First of
    all, all objects that can be used by the `this` keyword are called **implicit
    receivers** . They''re members can be accessed without a qualifier. Inside `setUp`
    functions, there are two implicit receivers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在成员扩展内部使用来自不同接收器的元素，为了区分它们，所有类型的接收器都被命名。首先，所有可以被`this`关键字使用的对象都被称为**隐式接收器**。它们的成员可以在没有限定符的情况下访问。在`setUp`函数内部，有两个隐式接收器：
- en: '**Extension receiver** : An instance of the class that the extension is defined
    for (`Button` )'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展接收器**：扩展定义的类的实例（`Button`）'
- en: '**Dispatch Receiver** : An instance of the class in which the extension is
    declared (`MainActivity` )'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发接收器**：扩展声明的类的实例（`MainActivity`）'
- en: 'Note that while members of both the extension receiver and dispatch receiver
    are implicit receivers in the same body, it is possible to have a situation where
    we use members that have the same signature in both of them. For example, if we
    change the previous class to show text in `textView` instead of showing it in
    the `toast` function, and change the method name to `setText` , then we are going
    to have methods of dispatch and extension receiver with the same signature (one
    defined in the `Button` class, the other defined in the `MainActivity` class):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然扩展接收器和分发接收器的成员都是同一个函数体中的隐式接收器，但可能存在一种情况，我们在两者中都使用具有相同签名的成员。例如，如果我们将上一个类更改为在`textView`中显示文本而不是在`toast`函数中显示它，并将方法名称更改为`setText`，那么我们将使用具有相同签名的分发和扩展接收器的方法（一个在`Button`类中定义，另一个在`MainActivity`类中定义）：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`setText` is both the method of the dispatch receiver and the extension receiver.
    Which one will be called?'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setText`既是分发接收器的方法，也是扩展接收器的方法。哪一个会被调用？'
- en: 'As a result, the `setText` function will be invoked from the **extension receiver**
    , and as a result, a button click will change the text of the clicked button!
    This is because the extension receiver always takes precedence over the dispatch
    receiver. Still, it is possible to use a dispatch receiver in this situation by
    using qualified this syntax (the `this` keyword with label, that is, distinguishing
    which receiver we want to reference):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`setText`函数将从**扩展接收器**中调用，并且按钮点击将更改所点击按钮的文本！这是因为扩展接收器始终优先于分发接收器。但是，在这种情况下，仍然可以使用分发接收器，方法是使用限定的this语法（带有标签的`this`关键字，即区分我们要引用的接收器）：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This way, we can solve the problem of distinguishing between the dispatch and
    extension receiver.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以解决区分分发接收器和扩展接收器的问题。
- en: Member extension functions and properties under the hood
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员扩展函数和属性在底层
- en: 'Member extension functions and properties are compiled the same way as top-level
    extension functions and properties with the only difference being that they are
    inside a class and they are not static. Here is a simple example of an extension
    function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 成员扩展函数和属性与顶级扩展函数和属性编译方式相同，唯一的区别是它们在类内部，并且它们不是静态的。这是一个简单的扩展函数的例子：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is what it is compiled to (after simplification):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它编译后的样子（经过简化）：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that while they are just methods with a receiver as the first parameter,
    we can do with them everything we can with other functions. Access modifiers are
    working the same way, and if we define the member extension function as open,
    then we can override it in its subclasses.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然它们只是带有接收者作为第一个参数的方法，但我们可以像其他函数一样使用它们。访问修饰符的工作方式相同，如果我们将成员扩展函数定义为open，那么我们可以在其子类中重写它。
- en: Generic extension functions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用扩展函数
- en: 'When we are writing utility functions, often we want them to be generic. The
    most common examples are extensions for collections: `List` , `Map` , and `Set`
    . Here is an example of an extension property for `List` :'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写实用函数时，通常希望它们是通用的。最常见的例子是对集合（`List`，`Map`和`Set`）的扩展。这里有一个对`List`的扩展属性的例子：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding example defines an extension property for a generic type. This
    kind of extension is used for lots of different problems. As an example, starting
    another `Activity` is a repetitive task that most often needs to be implemented
    in multiple places in the project. The methods provided by the Android IDE for
    `Activity` starting do not make it easy. Here is the code used to start a new
    Activity called `SettingsActivity` :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子定义了一个通用类型的扩展属性。这种扩展用于许多不同的问题。例如，启动另一个`Activity`是一个重复的任务，通常需要在项目中的多个地方实现。Android
    IDE提供的用于启动`Activity`的方法并不简单。这是用于启动名为`SettingsActivity`的新Activity的代码：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that this simple and repetitive task needs a lot of code that is not really
    clear. But we can define extension functions that will make `Intent` creation
    and `Activity` without arguments start much more simply using a generic inline
    extension function with `reified` type:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种简单而重复的任务需要大量不太清晰的代码。但是我们可以定义扩展函数，使用`reified`类型的通用内联扩展函数来更简单地创建`Intent`和启动没有参数的`Activity`：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can start `Activity` by simply using the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下简单地启动`Activity`：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or we can create `intent` this way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样创建`intent`：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This way, we can make this common task easier at low cost. To go further, libraries
    such as **Anko** ( [https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)
    ) provide extension functions that provide a simple way to start an `Activity`
    with additional parameters or flags, as in this example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以以较低的成本使这个常见的任务更容易。此外，像**Anko**（[https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)）这样的库提供了扩展函数，提供了一种简单的方式来启动带有额外参数或标志的`Activity`，就像这个例子中一样：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Internal implementation of the library is outside the scope of this book, but
    we can use this extension simply by adding Anko library dependency to our project.
    The point of this example is that nearly all repetitive code can be replaced with
    simpler code using extensions. There are also alternative ways to start an `Activity`
    , such as the `ActivityStarter` library ( [https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)
    ), which is based on parameter injection, and that strongly supports Kotlin. It
    allows classic argument injection:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖库的内部实现，但我们可以通过将Anko库依赖添加到我们的项目中来简单地使用这个扩展。这个例子的重点是几乎所有重复的代码都可以用扩展来替换为更简单的代码。还有其他启动`Activity`的替代方式，比如基于参数注入的`ActivityStarter`库（[https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)），它对Kotlin有很好的支持。它允许经典的参数注入：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or, as an alternative, it allows lazy injection in Kotlin property delegates
    (which are described in [Chapter 8](text00205.html) , *Delegates* ):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为替代方案，它允许在Kotlin属性委托中进行延迟注入（这在[第8章](text00205.html)，*委托*中有描述）：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`Activity` with such arguments can be started using generated static functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 带有这些参数的`Activity`可以使用生成的静态函数启动：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s see another example. In Android, we often need to store objects in JSON
    format. For example, when we need to send them to an API or to store them in a
    file. The most popular library used for serializing and deserializing objects
    into JSON is Gson. Let''s look at standard way of using the Gson library:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。在Android中，我们经常需要以JSON格式存储对象。例如，当我们需要将它们发送到API或将它们存储在文件中时。用于将对象序列化和反序列化为JSON的最流行的库是Gson。让我们看一下使用Gson库的标准方式：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can improve it in Kotlin thanks to extension functions with an `inline`
    modifier. Here is an example of extension functions that are using GSON to pack
    and unpack objects to `String` in JSON format:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过带有`inline`修饰符的扩展函数在Kotlin中改进它。这里有一个使用GSON将对象打包和解包为JSON格式的扩展函数的例子：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `globalGson` instance is a global instance of `Gson` . It is common practice,
    while we often define some serializers and deserializers, and it is a simpler
    and more effective way to define them and build an instance of `Gson` once.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`globalGson`实例是`Gson`的全局实例。这是常见的做法，因为我们经常定义一些序列化程序和反序列化程序，这是定义它们和构建`Gson`实例的更简单和更有效的方式。'
- en: 'Examples are showing what possibilities are generic extension functions giving
    to the developer. They are like the next level of code extraction:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了通用扩展函数给开发人员提供了哪些可能性。它们就像代码提取的下一个级别：
- en: They are top-level, but also invoked on an object, so they are simple to manage
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是顶层的，但也可以在对象上调用，所以很容易管理
- en: They are generic, so are universal and might be applied to anything
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是通用的，因此是通用的，可以应用于任何东西
- en: When inline, they allow us to define `reified` type parameters
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内联时，它们允许我们定义`reified`类型参数
- en: This is why generic extension functions are commonly used in Kotlin. Also, standard
    library provides lots of generic extensions. In the next section, we will see
    some collection extension functions. This part is important, not only because
    it provides knowledge about generic extension function usage, but also because
    it is ultimately describing how list processing in Kotlin works and how it can
    be used.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么泛型扩展函数在Kotlin中经常使用。此外，标准库提供了许多泛型扩展。在下一节中，我们将看到一些集合扩展函数。这部分很重要，不仅因为它提供了关于泛型扩展函数的使用知识，而且因为它最终描述了Kotlin中列表处理的工作原理以及如何使用它。
- en: Collection processing
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合处理
- en: 'Collection processing is one of the most common tasks in programming. This
    is why one of the first things that developers learn is how to iterate over a
    collection to operate on elements. Young developers asked to print all users from
    a list will most probably use a `for` loop:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 集合处理是编程中最常见的任务之一。这就是为什么开发人员学习的第一件事之一是如何迭代集合以对元素进行操作。要求年轻的开发人员从列表中打印所有用户，他们很可能会使用`for`循环：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we asked them to show only users that are passing in school, then they would
    most probably add an `if` condition inside this loop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求他们只显示在学校通过的用户，那么他们很可能会在这个循环中添加一个`if`条件：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is still correct implementation, but the real problem starts when task
    becomes more complex. What if they were asked to print the three best students
    that are passing? It is really complex to implement it in loops, while it is trivial
    to implement it using Kotlin stream processing. Let''s see it on the example.
    Here is example list of students:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是正确的实现，但当任务变得更加复杂时，真正的问题就开始了。如果他们被要求打印通过的三名最优秀的学生呢？在循环中实现这一点非常复杂，而在Kotlin流处理中实现它却很简单。让我们在示例中看看。这是学生的示例列表：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s filter out students using an imperative approach known from Java (using
    loops and sorting method):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用从Java中已知的命令式方法（使用循环和排序方法）来过滤学生：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can achieve the same result in a much simpler way using Kotlin stream processing:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Kotlin流处理以更简单的方式实现相同的结果：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Take only students who passed.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只取通过的学生。
- en: Sort students according to their grade (descending to have students with better
    grade in higher position).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据他们的成绩对学生进行排序（降序以使成绩更好的学生处于更高的位置）。
- en: Take only first three of them.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只取前三个。
- en: Print each of them.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个打印它们。
- en: The key is that each stream processing function, such as `sortedByDescending`
    , `take` , and `forEach` from the preceding example, is extracting a small functionality
    and the power comes from the composition of them. And the result is much simpler
    and more readable then usage of classic loops.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于每个流处理函数，例如前面示例中的`sortedByDescending`，`take`和`forEach`，都提取了一个小功能，其威力来自它们的组合。结果比使用经典循环更简单和更可读。
- en: Stream processing is actually a pretty common language feature. It is known
    in C#, JavaScript, Scala, and many other languages, including Java since version
    8\. Popular reactive programming libraries, such as RxJava, also heavily utilize
    this concept to process data. In this section, we are going to go deeper into
    Kotlin collection processing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理实际上是一种非常常见的语言特性。它在C＃，JavaScript，Scala和许多其他语言中都有，包括自Java 8版本以来。流行的响应式编程库，如RxJava，也大量利用这个概念来处理数据。在本节中，我们将深入研究Kotlin集合处理。
- en: Kotlin collection type hierarchy
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin集合类型层次结构
- en: 'Kotlin type hierarchy is really well designed. Standard collections are actually
    collections from a native language (such as Java), which are hidden behind interfaces.
    Creation of them is made by standard top-level functions (`listOf` , `setOf` ,
    `mutableListOf` , and so on), so they can be created and used in common modules
    (modules compiled to more than one platform). Also Kotlin interfaces can act like
    their equivalent interfaces from Java (like `List` , `Set` , and so on), this
    makes Kotlin collections efficient and highly compatible with external libraries.
    At the same time, Kotlin collection interfaces hierarchy, can be used in common
    modules. This hierarchy is simple and it is profitable to understand it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin类型层次结构设计得非常好。标准集合实际上是来自本地语言（如Java）的集合，这些集合隐藏在接口后面。它们的创建是通过标准的顶层函数（`listOf`，`setOf`，`mutableListOf`等）进行的，因此它们可以在通用模块（编译为多个平台的模块）中创建和使用。此外，Kotlin接口可以像它们在Java中的等效接口一样起作用（如`List`，`Set`等），这使得Kotlin集合高效且与外部库高度兼容。同时，Kotlin集合接口层次结构可以在通用模块中使用。这个层次结构很简单，了解它是有利可图的：
- en: '![](img/Image00049.gif)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00049.gif)'
- en: Kotlin collection interfaces hierarchy
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin集合接口层次结构
- en: 'The most general interface is `Iterable` . It represents a sequence of elements
    that can be iterated over. Any object that implements `iterable` can be used in
    a `for` loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最通用的接口是`Iterable`。它表示可以迭代的元素序列。任何实现`iterable`的对象都可以在`for`循环中使用：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lots of different types implement an iterable interface: all collections, progressions
    (`1..10` , `''a''..''z''` ), and even `String` . They all allow us to iterate
    over their elements:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同类型都实现了可迭代接口：所有集合，进展（`1..10`，`'a'..'z'`），甚至`String`。它们都允许我们迭代它们的元素：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `Collection` interface represents a collection of elements and extends `Iterable`
    . It adds property `size` and the methods `contains` , `containsAll` , and `isEmpty`
    .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`接口表示元素的集合并扩展`Iterable`。它添加了`size`属性和`contains`，`containsAll`和`isEmpty`方法。'
- en: Two main interfaces that inherit from `Collection` are `List` and `Set` . The
    difference between them is that `Set` is unordered and does not contain repetitive
    elements (according to the `equals` method). Both `List` and `Set` interfaces
    do not contain any methods that would allow us to mutate the object state. This
    is why, by default, Kotlin collections are treated as immutable. When we have
    an instance of `List` , then it is most often `ArrayList` in Android. `ArrayList`
    is a mutable collection, but while it is hidden behind the interface `List` ,
    it is actually acting like immutable, because it is not exposing any methods that
    would allow us to apply changes (unless it is downcasted).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Collection`继承的两个主要接口是`List`和`Set`。它们之间的区别在于`Set`是无序的，不包含重复元素（根据`equals`方法）。`List`和`Set`接口都不包含任何允许我们改变对象状态的方法。这就是为什么默认情况下，Kotlin集合被视为不可变的。当我们有一个`List`的实例时，它在Android中很可能是`ArrayList`。`ArrayList`是一个可变集合，但是当它隐藏在`List`接口后，它实际上的行为就像是不可变的，因为它不公开任何允许我们应用更改的方法（除非进行向下转型）。
- en: 'In Java, collections were mutable, but Kotlin collection interfaces provide
    only immutable behavior by default (not methods that change the state of collections,
    for example, `add` and `removeAt` ):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，集合是可变的，但Kotlin集合接口默认只提供不可变行为（例如，没有改变集合状态的方法，比如`add`和`removeAt`）：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'All immutable interfaces (`Collection` , `List` , and so on) have their mutable
    equivalents (`MutableCollection` , `MutableList` , and so on) which inherit from
    corresponding immutable interfaces. Mutable means that the actual object can be
    modified. These are the interfaces that represent mutable collections from standard
    library:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不可变接口（`Collection`，`List`等）都有它们的可变等价物（`MutableCollection`，`MutableList`等），它们继承自相应的不可变接口。可变意味着实际对象可以被修改。这些接口代表了标准库中的可变集合：
- en: '`MutableIterable` allows iteration with applying changes'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutableIterable`允许在应用更改的情况下进行迭代'
- en: '`MutableCollection` ensure methods for adding and removing elements'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutableCollection`确保添加和删除元素的方法'
- en: '`MutableList` and `MutableSet` are mutable equivalents of `List` and `Set`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutableList`和`MutableSet`是`List`和`Set`的可变等价物'
- en: 'Now we can fix our previous example and change the collection using the `add`
    and `remove` methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修复之前的例子，并使用`add`和`remove`方法更改集合：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Both immutable and mutable interfaces provide only a few methods, but the Kotlin
    standard library provides many useful extensions for them:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变和可变接口都只提供了一些方法，但是Kotlin标准库为它们提供了许多有用的扩展：
- en: '![](img/Image00050.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00050.jpg)'
- en: This makes dealing with collections a much easier task than in Java.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得处理集合比在Java中更容易。
- en: Kotlin implements collection processing methods using extensions. This approach
    has many advantages; for example, if we want to implement a custom collection
    (such as `List` ), we only need to implement an `iterable` interface containing
    only a few methods. We can still use all the extensions that are provided for
    the `iterable` interface.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin使用扩展来实现集合处理方法。这种方法有很多优势；例如，如果我们想要实现一个自定义集合（比如`List`），我们只需要实现一个只包含几个方法的`iterable`接口。我们仍然可以使用为`iterable`接口提供的所有扩展。
- en: 'Another reason is how flexibly these functions can be used when they are extensions
    for interfaces. For example, most of these collection processing functions are
    actually extensions for `Iterable` , which is implemented by many more types than
    `Collection` , for example, by `String` or `Range` . Therefore, it is possible
    to use all extension functions to `Iterable` also on `IntRange` . Here is an example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是这些函数作为接口的扩展函数时可以灵活使用。例如，大多数这些集合处理函数实际上是`Iterable`的扩展，而`Iterable`被许多更多的类型实现，例如`String`或`Range`。因此，也可以在`IntRange`上使用所有扩展函数。这是一个例子：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This makes all this extensions really universal. There is also the downside
    of the fact that collection stream processing methods are implemented as extension
    functions. While extensions are resolved statically, it is incorrect to override
    an extension function for a specific type because its behavior will be different
    when it is behind an interface then when it is accessed directly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得所有这些扩展真正通用。集合流处理方法作为扩展函数实现也有一个缺点。虽然扩展是静态解析的，但是为特定类型覆盖扩展函数是不正确的，因为当它在接口后面时，其行为将与直接访问时不同。
- en: Let's analyze some extension functions used for collection processing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一些用于集合处理的扩展函数。
- en: The map, filter, flatMap functions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map、filter、flatMap函数
- en: 'We have already briefly presented `map` , `filter` , and `flatMap` , because
    they are the most basic stream processing functions. The `map` function returns
    a list with elements changed according to the function from the argument:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要介绍了`map`，`filter`和`flatMap`，因为它们是最基本的流处理函数。`map`函数返回根据参数中的函数更改的元素的列表：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `filter` function allows only the elements that match the provided predicate:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数只允许与提供的谓词匹配的元素：'
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `flatMap` function returns a single list of all elements yielded by the
    transform function, which is invoked on each element of the original collection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数返回由原始集合的每个元素调用的变换函数产生的所有元素的单个列表：'
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It is most often used to flatten list of collections:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用于展平集合的列表：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s look at simplified implementations of these extension functions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这些扩展函数的简化实现：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All this functions are inline.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些函数都是内联的。
- en: All these functions internally use for loop, and return a new list containing
    proper elements.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些函数内部都使用for循环，并返回一个包含适当元素的新列表。
- en: 'Most Kotlin standard library extension functions with function type are `inline`
    , because it makes lambda expression usage efficient. As a result, whole collection
    stream processing is actually mostly compiled at runtime to nested loops. As an
    example, here is this simple processing:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Kotlin标准库扩展函数类型都是`inline`的，因为它使lambda表达式的使用更有效率。因此，整个集合流处理实际上在运行时大部分编译为嵌套循环。例如，这是一个简单的处理：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After compilation and decompilation to Java, it looks like the following (cleaned
    up):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和反编译为Java后，它看起来像下面这样（清理过的）：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The forEach and onEach functions
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`forEach`和`onEach`函数'
- en: 'The `forEach` function was already discussed in chapter about functions. It
    is an alternative to a `for` loop, so it performs an action on each element of
    the list:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach`函数已经在关于函数的章节中讨论过。它是`for`循环的一种替代方法，因此它对列表中的每个元素执行一个操作：'
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since Kotlin 1.1, there is a similar function, `onEach` , that also invokes
    an action on each element. It returns an extension receiver (this list), so we
    can invoke an action on each element in the middle of stream processing. Common
    use cases are logging purposes. Here is an example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kotlin 1.1以来，还有一个类似的函数`onEach`，它也对每个元素执行一个操作。它返回一个扩展接收器（这个列表），所以我们可以在流处理的中间对每个元素执行一个操作。常见的用例是日志记录。以下是一个例子：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The withIndex and indexed variants
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有索引和索引变体
- en: 'Sometimes, the way of element processing depends on its index on the list.
    The most universal way to solve this problem is by using the `withIndex` function,
    which returns a list of values with indexes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，元素处理的方式取决于它在列表中的索引。解决这个问题的最通用的方法是使用`withIndex`函数，它返回带有索引的值列表：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Function `withIndex` is packing each element into `IndexedValue` which is containing
    both the elements and its index.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`withIndex`函数将每个元素打包成包含元素和其索引的`IndexedValue`。'
- en: In lambda, `IndexedValue` is destructed into index and value, but while the
    value is unused, there is an underscore placed instead. It might be omitted, but
    this way of code is more readable. This line filters only elements with even index.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在lambda中，`IndexedValue`被解构为索引和值，但是值没有被使用，而是用下划线代替。它可能被省略，但这种方式的代码更易读。这行代码只过滤了偶数索引的元素。
- en: 'Also, there are variants for different stream processing methods that provide
    an index:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有不同流处理方法的变体，提供了一个索引：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The sum, count, min, max, and sorted functions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sum`、`count`、`min`、`max`和`sorted`函数'
- en: 'The `sum` function counts the sum of all elements in a list. It can be invoked
    on `List<Int>` , `List<Long>` , `List<Short>` , `List<Double>` , `List<Float>`
    , and `List<Byte>` :'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数计算列表中所有元素的总和。它可以在`List<Int>`、`List<Long>`、`List<Short>`、`List<Double>`、`List<Float>`和`List<Byte>`上调用：'
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Often we need to sum some properties of elements, such as summing points of
    all users. It might be handled by mapping the list of users to the list of points
    and then counting the sum:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们需要对元素的一些属性进行求和，比如对所有用户的点数进行求和。可以通过将用户列表映射到点数列表，然后计算总和来处理：
- en: '[PRE79]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But we unnecessarily create an intermediate collection by calling the `map`
    function, and it would be more efficient to directly sum points. To do it, we
    can use `sumBy` with an appropriate selector:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们通过调用`map`函数不必要地创建了一个中间集合，直接对点数进行求和会更有效率。为了做到这一点，我们可以使用适当的选择器使用`sumBy`：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`sumBy` is expecting `Int` to be returned from the selector, and it is returning
    `Int` with the sum of all elements. If values are not `Int` but `Double` then
    we can use `sumByDouble` , which returns `Double` :'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumBy`期望从选择器返回`Int`，并返回所有元素的总和为`Int`。如果值不是`Int`而是`Double`，那么我们可以使用`sumByDouble`，它返回`Double`：'
- en: '[PRE81]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'A similar functionality is provided by the `count` function, that is used when
    we need to count elements that match a predicate:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`函数提供了类似的功能，当我们需要计算与谓词匹配的元素时使用它：'
- en: '[PRE82]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `count` function used without any predicate returns the size of the collection
    or iterable:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`函数在没有任何谓词的情况下返回集合或可迭代对象的大小：'
- en: '[PRE83]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The next important functions are `min` and `max` , which are functions that
    return the minimal and maximal elements in a list. They can be used on a list
    of elements that have natural ordering (implement `Comparable<T>` interface).
    Here is an example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的重要函数是`min`和`max`，它们是返回列表中最小和最大元素的函数。它们可以用于具有自然排序的元素列表（实现`Comparable<T>`接口）。以下是一个示例：
- en: '[PRE84]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Similarly, the function `sorted` is used. It returns a sorted list, but it
    needs to be invoked on collections of elements that implement the `Comparable<T>`
    interface. Here is an example of how `sorted` can be used to get a list of strings
    sorted alphanumerically:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用`sorted`函数。它返回一个排序后的列表，但需要在实现`Comparable<T>`接口的元素集合上调用。以下是一个示例，说明如何使用`sorted`来获取按字母数字顺序排序的字符串列表：
- en: '[PRE85]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'What if items are not comparable? There are two ways to sort them. The first
    way is to sort according to comparable member. We''ve already seen an example
    when we were sorting students according to their grades:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不可比较怎么办？有两种方法可以对它们进行排序。第一种方法是根据可比较的成员进行排序。我们已经看到一个例子，当我们根据他们的成绩对学生进行排序时：
- en: '[PRE86]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the preceding example, we sort students using the comparable `grade` property.
    There, `sortedByDescending` is used, which works like `sortedBy` , with the only
    difference being that the order is descending (from biggest to smallest). The
    selector inside the function can return any value that is comparable to itself.
    Here is an example, where `String` is used to specify order:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用可比较的`grade`属性对学生进行排序。在这里，使用了`sortedByDescending`，它的工作方式类似于`sortedBy`，唯一的区别是顺序是降序的（从大到小）。函数内部的选择器可以返回任何可与自身比较的值。以下是一个示例，其中使用`String`来指定顺序：
- en: '[PRE87]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Similar functions can be used to find the minimal and maximal element according
    to the selector:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的函数可以用来根据选择器找到最小和最大的元素：
- en: '[PRE88]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The second way to specify sorting order is to define a `Comparator` that will
    determine how elements should be compared. Function variants that accept comparators
    should have a `With` suffix. Comparators can be defined by an adapter function
    that converts a lambda to SAM type:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 指定排序顺序的第二种方法是定义一个`Comparator`，它将确定如何比较元素。接受比较器的函数变体应该有一个`With`后缀。比较器可以由将lambda转换为SAM类型的适配器函数来定义：
- en: '[PRE89]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Kotlin also includes standard library top-level functions (`compareBy` , `compareByDescending`
    ) used to simplify `Comparator` creation. Here is how we can create a comparator
    to sort students alphanumerically by `surname` and `name` :'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还包括用于简化`Comparator`创建的标准库顶层函数（`compareBy`，`compareByDescending`）。这是我们如何创建一个比较器，按`surname`和`name`按字母顺序对学生进行排序的：
- en: '[PRE90]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Note that we can use property reference instead of lambda expressions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用属性引用而不是lambda表达式：
- en: '[PRE91]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Another important function is `groupBy` , which groups elements according to
    the selector. `groupBy` returns `Map` , that is mapping from the chosen key to
    a list of elements that are selected to map to the following key:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的函数是`groupBy`，它根据选择器对元素进行分组。`groupBy`返回`Map`，即从选择的键到选择映射到以下键的元素列表的映射：
- en: '[PRE92]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s look at a more complex example. We need to get a list of the best students
    from each class. Here is how we can get them from the list of students:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的例子。我们需要从每个班级的学生名单中得到最好的学生名单。这是我们如何从学生名单中得到他们的：
- en: '[PRE93]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Other stream processing functions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他流处理函数
- en: There are lots of different stream processing functions and there is no need
    to describe them all here, while Kotlin contains great documentation on its website.
    The names of most of the extension functions are self-explanatory and there is
    no need to really read the documentation to guess what they are doing. In Android
    Studio, we can check the real implementation by pressing *Ctrl* (*command* key
    on mac) and clicking the function whose implementation we want to read.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的流处理函数，没有必要在这里描述它们全部，因为Kotlin在其网站上包含了很好的文档。大多数扩展函数的名称都是不言自明的，没有必要真正阅读文档来猜测它们在做什么。在Android
    Studio中，我们可以通过按下*Ctrl*（mac上的*command*键）并点击要阅读其实现的函数来检查真正的实现。
- en: 'The important difference in collection processing comes when you are operating
    on mutable collections, because while they can use additional extensions defined
    for mutable types (`MutableIterable` , and `MutableCollection` ), the important
    distinction is that functions that are changing object are formulated in present
    imperative form (for example, `sort` ), while functions that are returning a new
    collection with changed values are most often formulated in the past form of a
    verb (for example, `sorted` ). Here is an example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在对可变集合进行处理时，集合处理的重要区别在于，虽然它们可以使用为可变类型定义的额外扩展（`MutableIterable`和`MutableCollection`），但重要的区别在于改变对象的函数是用现在的祈使形式来表达（例如，`sort`），而返回具有更改值的新集合的函数通常是用动词的过去形式来表达（例如，`sorted`）。这里有一个例子：
- en: '`sort` : Function that is sorting a mutable object. It returns `Unit` .'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`：对可变对象进行排序的函数。它返回`Unit`。'
- en: '`sorted` : Function that is returning a sorted collection. It is not changing
    the collection on which it is invoked.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted`：返回一个排序后的集合的函数。它不会改变被调用的集合。'
- en: '[PRE94]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Examples of stream collection processing
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流集合处理的例子
- en: We've already seen a few stream processing functions, but it needs some skill
    and creativity to use them for complex use cases. This is why, in this part, we
    are going to discuss some complex stream processing examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些流处理函数，但是需要一些技巧和创造力来将它们用于复杂的用例。这就是为什么在这一部分，我们将讨论一些复杂的流处理示例。
- en: 'Let''s suppose that we again need to find the best three students who are passing
    according to their grade. The key difference is that, in this case, the final
    order of students must be the same as it was in the beginning. Note that during
    sorting by grade operation, this order is lost. But we can preserve it if we keep
    together value and index. Thanks to that, we can later sort elements according
    to this preserved index. Here is how to implement this processing:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们再次需要找到根据他们的成绩通过的最好的三名学生。关键区别在于，在这种情况下，学生的最终顺序必须与一开始的顺序相同。请注意，在按成绩排序操作期间，这个顺序会丢失。但是，如果我们保持值和索引在一起，我们可以保留它。由此，我们可以稍后根据保留的索引对元素进行排序。这是如何实现这个处理的：
- en: '[PRE95]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Filter to keep only students that are passing
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤以保留只有通过的学生
- en: Add index to elements to be able to reproduce element order
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加索引以能够重现元素顺序
- en: Sort students according to their grade
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据他们的成绩对学生进行排序
- en: Take only best 10 students
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只取最好的10名学生
- en: Reproduce order by sorting according to indexes
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过排序重现顺序
- en: Mapping values with indexes to just values
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值与索引映射到只有值
- en: Note that this implementation is concise and each operation performed on the
    collection is easy to read line by line.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个实现是简洁的，对集合执行的每个操作都可以逐行轻松阅读。
- en: The big advantage of collection stream processing is that it is easy to manage
    the complexity of this process. We know that the complexity of most operations,
    such as `map` or `filter` , is **O** (*n* ) and the complexity of sorting operations
    is **O** (*n*log(n)* ). The complexity of stream operations is maximal complexity
    of each of the steps, so the complexity of the above processing is **O** (*n*log(n)*
    ) because `sortedBy` is the step with the biggest complexity.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 集合流处理的重大优势在于它易于管理这个过程的复杂性。我们知道大多数操作的复杂度，如`map`或`filter`，是**O**(*n*)，排序操作的复杂度是**O**(*n*log(n)*)。流操作的复杂度是每个步骤的最大复杂度，因此上述处理的复杂度是**O**(*n*log(n)*)，因为`sortedBy`是具有最大复杂度的步骤。
- en: 'As the next example, let''s suppose that we have a list containing the results
    of players in different categories:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一个例子，假设我们有一个包含不同类别中玩家结果的列表：
- en: '[PRE96]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And we have some example data:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些示例数据：
- en: '[PRE97]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here is how we can find the best player in each category:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在每个类别中找到最好的玩家：
- en: '[PRE98]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We group results into categories. The return type is `Map<Category>` , and `List<Result>`
    .
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将结果分组到类别中。返回类型是`Map<Category>`和`List<Result>`。
- en: We are mapping values of the `map` function. Inside, we find the best result
    in this category and we are taking the player who is associated with this result.
    The return of the `mapValues` function is `Map<Category` , `Player?>` .
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在映射`map`函数的值。在内部，我们找到了这个类别中的最佳结果，并且我们正在取得与这个结果相关联的玩家。`mapValues`函数的返回值是`Map<Category>`，`Player?>`。
- en: The preceding example shows how complex problems related to collections can
    be easily solved in Kotlin thanks to collection processing functions. After working
    with Kotlin for a while, most of those functions are well known to programmers,
    and then collection processing problems are quite easy to solve. Of course, functions
    as complicated as presented above are rare, but simple, few-step processing is
    quite common in everyday programming.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了在Kotlin中如何通过集合处理函数轻松解决与集合相关的复杂问题。在使用Kotlin一段时间后，大多数这些函数对程序员来说都很熟悉，然后集合处理问题就变得相当容易解决。当然，像上面介绍的那样复杂的函数很少见，但是简单的、几步的处理在日常编程中是相当常见的。
- en: Sequence
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: '`Sequence` is an interface that is also used to refer to a collection of elements.
    It is an alternative for `Iterable` . For `Sequence` , there are separate implementations
    of most collection processing functions (`map` , `flatMap` , `filter` , `sorted`
    , and so on). The key difference is that all these functions are constructed in
    such a way that, they return sequence, which is packaged over previous sequence.
    Due to this, the following points becomes true:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence`是一个接口，也用于引用元素的集合。它是`Iterable`的替代品。对于`Sequence`，大多数集合处理函数（`map`，`flatMap`，`filter`，`sorted`等）都有单独的实现。关键区别在于，所有这些函数都是以这样的方式构造的，它们返回序列，该序列包装在前一个序列上。由于这个原因，以下几点成为真实：'
- en: The size of sequence does not need to be known in advance
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列的大小不需要事先知道
- en: Sequence processing is more efficient, especially for large collections where
    we want to perform several transformations (details will be described later)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列处理更有效，特别是对于大型集合，我们想要执行多个转换（详细信息将在后面描述）
- en: In Android, sequences are used for processing very big collections or for processing
    elements whose size is not known in advance (such as for reading lines of possibly
    long document). There are different ways to create sequences, but the easiest
    is the `asSequence` function called on `Iterable` or by using the `sequenceOf`
    top-level function to make sequence similarly as list.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，序列用于处理非常大的集合或处理事先不知道大小的元素（例如读取可能很长的文档的行）。有不同的创建序列的方式，但最简单的是在`Iterable`上调用`asSequence`函数，或者使用`sequenceOf`顶级函数来制作类似列表的序列。
- en: 'Sequence size does not need to be known in advance, because values are calculated
    just when they are needed. Here is an example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的大小不需要事先知道，因为值是在需要时计算的。这是一个例子：
- en: '[PRE99]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The function `generateSequence` is one way for sequence generation. This sequence
    contains the next numbers from 1 to infinity.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`generateSequence`是序列生成的一种方式。这个序列包含从1到无穷大的下一个数字。
- en: The `map` function packs a sequence into another that takes the value from the
    first sequence and then it calculates the value after transformation.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`函数将一个序列打包到另一个序列中，它从第一个序列中获取值，然后计算转换后的值。'
- en: The function `take(10)` will also pack a sequence into another one that is finishing
    on the 10th element. Without this line execution, processing time would be infinitive
    while we are operating on an infinite sequence.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`take(10)`还会将一个序列打包到另一个序列中，该序列在第10个元素结束。如果没有这行代码的执行，当我们在一个无限序列上操作时，处理时间将是无限的。
- en: Finally, the function `toList` is processing each value and it returns the final
    list.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，函数`toList`正在处理每个值并返回最终列表。
- en: 'It is important to stress that elements are processed one after another in
    the last step (in terminal operation). Let''s look at another example, where every
    operation is also printing values for logging purposes. Let''s start with the
    following code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，在最后一步（在终端操作中）元素是一个接一个地处理的。让我们看另一个例子，其中每个操作也打印值以进行日志记录。让我们从以下代码开始：
- en: '[PRE100]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'What would be printed in the console? Absolutely nothing. No values were calculated.
    The reason is that all those intermediate operations are lazy. To retrieve a result,
    we need to use some terminal operation, such as `toList` . Let''s use the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台会打印什么？绝对什么都不会打印。没有计算出任何值。原因是所有这些中间操作都是惰性的。要检索结果，我们需要使用一些终端操作，比如`toList`。让我们使用以下操作：
- en: '[PRE101]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then we will see the following in the console:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会在控制台中看到以下内容：
- en: '[PRE102]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Notice that elements are fully processed one after another. In standard list
    processing, the order of operation would be totally different:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元素是一个接一个地完全处理的。在标准列表处理中，操作的顺序将完全不同：
- en: '[PRE103]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The preceding code prints the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码打印如下：
- en: '[PRE104]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This explains why sequences are more efficient than classic collection processing--there
    is no need to create collections in intermediate steps. Values are processed one
    by one on demand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么序列比经典的集合处理更有效--不需要在中间步骤中创建集合。值是按需逐个处理的。
- en: Function literals with receiver
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带接收者的函数文字
- en: 'Just as functions have a function type, which allows them to be kept as an
    object, extension functions have their type that allows them to be kept this way.
    It is called function type with receiver. It looks like the simple function type,
    but the receiver type is located before arguments (like in extension definition):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数有一个函数类型，允许它们被保存为对象一样，扩展函数也有它们的类型，允许它们以这种方式被保存。它被称为带接收者的函数类型。它看起来像简单的函数类型，但接收者类型位于参数之前（就像在扩展定义中一样）：
- en: '[PRE105]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The introduction of function type with receiver makes full cohesion between
    functions and types, because all functions can be now represented as objects.
    It can be defined using a lambda expression with receiver or by an anonymous function
    with receiver.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 引入带接收者的函数类型使函数和类型之间具有完全的内聚性，因为现在所有函数都可以表示为对象。它可以使用带接收者的lambda表达式或带接收者的匿名函数来定义。
- en: 'In a lambda expression with receiver definition, the only difference is that
    we can reference to receiver by `this` , and we can explicitly use receiver elements.
    For lambda expressions, the type must be specified in a parameter, because there
    is no syntax to specify receiver type. Here is `power` defined as a lambda expression
    with receiver:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在带接收者的lambda表达式定义中，唯一的区别是我们可以通过`this`引用接收者，并且可以明确使用接收者元素。对于lambda表达式，必须在参数中指定类型，因为没有语法来指定接收者类型。这里将`power`定义为带接收者的lambda表达式：
- en: '[PRE106]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'An anonymous function also allows us to define the receiver, and its type is
    placed before the function name. In such a function, we can use `this` inside
    the body to refer to the extension receiver object. Note that anonymous extension
    functions are specifying the receiver type, so the property type can be inferred.
    Here is `power` defined as an anonymous extension function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数还允许我们定义接收者，并且其类型放在函数名之前。在这样的函数中，我们可以在主体内部使用`this`来引用扩展接收者对象。请注意，匿名扩展函数正在指定接收者类型，因此可以推断属性类型。这里将`power`定义为匿名扩展函数：
- en: '[PRE107]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A function type with receiver can be used as if it is a method of receiver
    type:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 带接收者的函数类型可以像接收者类型的方法一样使用：
- en: '[PRE108]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'A function type is most often used as a function parameter. Here is an example,
    where a parameter function is used to configure an element after its creation:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型最常用作函数参数。这里有一个示例，其中参数函数用于在创建元素后配置元素：
- en: '[PRE109]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here we are using a lambda expression as an argument.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用lambda表达式作为参数。
- en: Inside the lambda expression, we can directly invoke receiver methods.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在lambda表达式中，我们可以直接调用接收者方法。
- en: Kotlin standard library functions
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin标准库函数
- en: 'The Kotlin stdlib provide a set of extension functions (`let` , `apply` , `also`
    , `with` , `run` , and `to` ) with generic non-restricted receiver (generic types
    have no restrictions). They are small and handy extensions, and it is very profitable
    to understand them, because they are very useful across all Kotlin projects. One
    of these functions, `let` , was briefly introduced in [Chapter 2](text00035.html)
    *, Laying a Foundation* , where we saw how it can be used as an alternative to
    a nullity check:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin stdlib提供了一组扩展函数（`let`，`apply`，`also`，`with`，`run`和`to`），具有通用的非受限接收者（通用类型没有限制）。它们是小巧方便的扩展，了解它们非常有利，因为它们在所有Kotlin项目中都非常有用。其中一个函数`let`在[第2章](text00035.html)中简要介绍过，我们看到它如何可以用作对空值检查的替代方法：
- en: '[PRE110]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'All that `let` does is it calls the specified function and returns its result.
    While in the above example it is used together with a safe call operator, it will
    be called only when the property `savedInstanceState` is not null. The `let` function
    is actually just a generic extension function with a parameter function:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`所做的就是调用指定的函数并返回其结果。在上面的示例中，它与安全调用运算符一起使用，只有当属性`savedInstanceState`不为null时才会调用。`let`函数实际上只是一个带有参数函数的通用扩展函数：'
- en: '[PRE111]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In stdlib, there are more functions similar to `let` . These functions are
    `apply` , `also` , `with` , and `run` . They are a similar so we are going to
    describe them together. Here are definitions of the rest of the functions:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在stdlib中，有更多类似于`let`的函数。这些函数是`apply`，`also`，`with`和`run`。它们很相似，所以我们将一起描述它们。以下是其余函数的定义：
- en: '[PRE112]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Let''s see usage examples:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用示例：
- en: '[PRE113]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The differences are summarized in the following table:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异总结在以下表中：
- en: '| **Returned object / parameter function type** | **Function literal with receiver**(receiver
    object represented as *this* ) | **Function literal**(receiver object represented
    as *it* ) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| **返回的对象/参数函数类型** | **带接收者的函数文字**（接收对象表示为*this*） | **函数文字**（接收对象表示为*it*） |'
- en: '| **Receiver object** | `apply` | `also` |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| **接收对象** | `apply` | `also` |'
- en: '| **Result of function literal** | `run` /`with` | `let` |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| **函数文字的结果** | `run` /`with` | `let` |'
- en: While those functions are similar and, in many cases, it is possible to use
    them interchangeably, there are conventions which define which functions are preferred
    for certain use cases.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些函数很相似，并且在许多情况下可以互换使用，但有一些约定规定了哪些函数更适用于特定的用例。
- en: The let function
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let函数
- en: 'The `let` function is preferred when we want to use standard functions as if
    they are extension functions in stream processing:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在流处理中将标准函数用作扩展函数时，首选`let`函数：
- en: '[PRE114]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Like other extensions, it can be combined with a save call operator:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他扩展一样，它可以与安全调用运算符结合使用：
- en: '[PRE115]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `let` function is also preferred when we just want to unpack a nullable
    read-write property. In this situation, it is not possible to smartcast this property
    and we need to shadow it, like in this solution:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只想要解包可空的可读写属性时，也更倾向于使用`let`函数。在这种情况下，无法智能转换此属性，我们需要对其进行遮蔽，就像在这个解决方案中一样：
- en: '[PRE116]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `name` variable is the shadowing property name, what is necessary if name
    is a read-write property, because smart cast is allowed only on a mutable or local
    variable.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`变量是遮蔽属性名称，如果name是可读写属性，则这是必要的，因为智能转换只允许在可变或局部变量上。'
- en: 'We can replace the preceding code with `let` usage and a safe call operator:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`let`的用法和安全调用运算符来替换前面的代码：
- en: '[PRE117]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that using Elvis operator, we can easily add a `return` or exception throw
    when `name` is `null` :'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用Elvis运算符，当`name`为`null`时，我们可以轻松添加`return`或异常抛出：
- en: '[PRE118]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Similar way, `let` can be used as a replacement for the following statement:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方式，`let`可以用作以下语句的替代：
- en: '[PRE119]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implementation that is using the `let` function would look like the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`函数的实现将如下所示：
- en: '[PRE120]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `let` function used this way is preferred in method chains that transform
    the receiver:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式使用的`let`函数在转换接收器的方法链中是首选的：
- en: '[PRE121]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can also use simpler syntax by passing a function reference as an argument:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将函数引用作为参数来使用更简单的语法：
- en: '[PRE122]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Using the apply function for initialization
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用apply函数进行初始化
- en: 'Sometimes we need to create and initialize an object by calling some methods
    or modifying some properties, such as when we are creating a `Button` :'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要通过调用一些方法或修改一些属性来创建和初始化对象，比如当我们创建一个`Button`时：
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can reduce code verbosity by using the `apply` extension function. We can
    call all these methods from the context where `button` is the receiver object:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`apply`扩展函数来减少代码冗长。我们可以从`button`作为接收对象的上下文中调用所有这些方法：
- en: '[PRE124]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The also function
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: also函数
- en: 'The `also` function is similar to `apply` *,* with the only difference being
    that the parameter function accepts an argument as an parameter rather than as
    an receiver. It is preferred when we want to do some operations on an object,
    which are not initializations:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`also`函数与`apply`类似，唯一的区别是参数函数接受一个参数而不是一个接收器。当我们想对一个对象进行一些不是初始化的操作时，它是首选的：'
- en: '[PRE125]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `also` function is also preferred when we need to do some operation in
    the middle of processing, for example, during object construction using the Builder
    pattern:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在处理过程中进行一些操作时，例如在使用构建器模式构建对象时，`also`函数也是首选的：
- en: '[PRE126]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Another situation where `also` is preferred is when we are already in an extension
    function and we don''t want to add another extension receiver:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`also`更受欢迎的另一种情况是当我们已经在扩展函数中，而且不想添加另一个扩展接收器时：'
- en: '[PRE127]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The run and with function
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: run和with函数
- en: 'The `run` and `with` functions that are both accepting lambda literal with
    receiver as an argument, and returning its result. The difference between them
    is that `run` is accepting a receiver, while the `with` function is not an extension
    function and it takes the object we are operating in as parameter. Both functions
    can be used as an alternative to the `apply` function, when we are setting up
    an object:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`和`with`函数都接受带有接收器的lambda文字作为参数，并返回其结果。它们之间的区别在于`run`接受一个接收器，而`with`函数不是扩展函数，它将我们正在操作的对象作为参数。当我们设置对象时，这两个函数都可以作为`apply`函数的替代品：'
- en: '[PRE128]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The difference between `apply` , `run` , and `with` is that `apply` is returning
    a receiver object, while `run` and `with` are returning the result of function
    literal. Although when we need any of these, we should choose the function that
    is returning it. It is debatable which should be used when we do not need any
    returned value. Most often, it is suggested to use the `run` or `with` function
    than, because `also` is more often used in the situations when returned value
    is needed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`，`run`和`with`之间的区别在于`apply`返回一个接收对象，而`run`和`with`返回函数文字的结果。尽管当我们需要其中任何一个时，我们应该选择返回它的函数。当我们不需要任何返回值时，应该使用哪一个是有争议的。大多数情况下，建议使用`run`或`with`函数，因为`also`更常用于需要返回值的情况。'
- en: 'About differences between the `run` and `with` functions: the `run` function
    is used instead of the `with` function, when a value is nullable, because then
    we can use a safe call or not-null assertion:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`run`和`with`函数之间的区别：当值可为空时，应该使用`run`函数而不是`with`函数，因为这样我们可以使用安全调用或非空断言：
- en: '[PRE129]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The `with` function is preferred over run when an expression is short:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式很短时，`with`函数优于`run`：
- en: '[PRE130]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'On the other hand, `run` is preferred over `with` when an expression is long:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当表达式很长时，`run`优于`with`：
- en: '[PRE131]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The to function
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: to函数
- en: 'Infix functions were introduced in [Chapter 4](text00088.html) , *Classes and
    Objects* , but they can be defined not only as member classes, but also as extension
    functions. It makes it possible to create an infix extension function to any object.
    One of these kinds of extension functions is `to` , which was briefly described
    in [Chapter 2](text00035.html) , *Laying a Foundation* . Now we have the knowledge
    needed to understand its implementation. This is how to is defined:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`infix`函数是在[第4章](text00088.html)，*类和对象*中引入的，但它们不仅可以定义为成员类，还可以定义为扩展函数。这使得可以为任何对象创建一个`infix`扩展函数。其中一种这样的扩展函数是`to`，它在[第2章](text00035.html)，*打下基础*中简要描述过。现在我们有了理解其实现所需的知识。这是`to`的定义：'
- en: '[PRE132]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This makes it possible to place `to` between any two objects and make this
    way `Pair` with them:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以在任何两个对象之间放置`to`，并以这种方式与它们创建`Pair`：
- en: '[PRE133]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Note that the fact that we can make `infix` extension functions makes us allowed
    to define `infix` functions as an extension to any type. Here is an example:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以创建`infix`扩展函数的事实使我们可以将`infix`函数定义为任何类型的扩展。这是一个例子：
- en: '[PRE134]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Domain-specific language
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Features such as lambda literal with receiver and member extension functions
    are making it possible to define type-safe builders, that are known from Groovy.
    The most well-known Android example is Gradle configuration, `build.gradle` *,*
    which is currently written in Groovy. These kinds of builders are a good alternative
    to XML, HTML, or configuration files. The advantage of Kotlin usage instead is
    that we can make such configurations fully type-safe and provide a better IDE.
    Such builders are one example of Kotlin **domain-specific language** (**DSL**
    ).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如带有接收器的lambda文字和成员扩展函数之类的功能使得可以定义类型安全的构建器，这些构建器来自Groovy。最著名的Android示例是Gradle配置，`build.gradle`，目前是用Groovy编写的。这些构建器是XML、HTML或配置文件的良好替代品。与Kotlin的优势是我们可以使这些配置完全类型安全，并提供更好的IDE。这样的构建器是Kotlin**领域特定语言**（**DSL**）的一个例子。
- en: 'The most popular Kotlin DSL pattern in Android is the implementation of optional
    callback classes. It is used to solve a problem with a lack of functional support
    to callback interfaces with multiple methods. Classically, implementation would
    require object-expression usage, like in following example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Android中最流行的Kotlin DSL模式是可选回调类的实现。它用于解决回调接口缺乏对多个方法的功能支持的问题。传统上，实现需要使用对象表达式，就像下面的例子中一样：
- en: '[PRE135]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The main problems with such implementation are as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的主要问题如下：
- en: We need to implement all methods present in interface
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实现接口中的所有方法
- en: Function structure needs to be implemented for each method
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要为每个方法实现函数结构
- en: We need to use object expression
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用对象表达式
- en: 'Let''s define the following class, that is keeping callbacks as mutable properties:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义以下类，将回调作为可变属性保存：
- en: '[PRE136]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Callbacks, which are used when any of the overridden functions is called.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用任何重写的函数时使用的回调。
- en: Functions used to set new callbacks. Their names corresponds to handler function
    names, but they include callback as a parameter.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于设置新回调的函数。它们的名称对应于处理程序函数的名称，但它们包括回调作为参数。
- en: Each event handler functions are just invoking callback if it exists.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个事件处理函数只是在回调存在时调用回调。
- en: To simplify usage, we also changed types, `CharSequence` present in the original
    methods was changed to `String` *.*
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化使用，我们还改变了类型，原始方法中的`CharSequence`被改为了`String`。
- en: 'Now all we need is an extension function that will simplify callback configuration.
    Its name cannot be the same as any name of `TextView,` but all we need to do is
    a small modification:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的是一个扩展函数，它将简化回调配置。它的名称不能与`TextView`的任何名称相同，但我们需要做的只是做一个小修改：
- en: '[PRE137]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'With such definitions, we can define callbacks we need this way:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的定义，我们可以这样定义我们需要的回调：
- en: '[PRE138]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'We use underscore to hide unused parameters, to improve our implementation:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下划线来隐藏未使用的参数，以改进我们的实现：
- en: '[PRE139]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now two other callbacks `beforeTextChanged` and `afterTextChanged` are ignored,
    but we can still add other implementations:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在另外两个回调`beforeTextChanged`和`afterTextChanged`被忽略了，但我们仍然可以添加其他实现：
- en: '[PRE140]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'A listener defined this way has the following properties:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的监听器具有以下属性：
- en: It is shorter than object expression implementation
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比对象表达式实现更短
- en: It includes default functions implementations
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括默认函数实现
- en: It allows us to hide unused parameters
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们隐藏未使用的参数
- en: While in Android SDK there are multiple listeners with more than one handler,
    DSL implementation of optional callback classes is really popular in Android projects.
    Similar implementations can be also found in libraries, such as the already-mentioned
    Anko.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android SDK中，有多个具有多个处理程序的监听器，可选回调类的DSL实现在Android项目中非常流行。类似的实现也可以在库中找到，比如前面提到的Anko。
- en: 'Another example is DSL, which will be used to define layout structure without
    using XML layout files. We will define a function to add and configure `LinearLayout`
    and `TextView` and use it to define a simple view:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是DSL，它将用于定义布局结构，而不使用XML布局文件。我们将定义一个函数来添加和配置`LinearLayout`和`TextView`，并使用它来定义一个简单的视图。
- en: '[PRE141]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can also define our custom DSL from scratch. Let''s make a simple DSL that
    defines a list of articles. We know that each article should be defined in a different
    category, and that article has its name, URL, and tags. What we would like to
    achieve is the following definition:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从头开始定义我们自己的自定义DSL。让我们制作一个简单的DSL，定义一系列文章。我们知道每篇文章应该在不同的类别中定义，并且文章有其名称、URL和标签。我们想要实现的是以下定义：
- en: '[PRE142]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The simplest object here is the `Post` class. It is holding post properties
    and allows them to be changed:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最简单的对象是`Post`类。它保存帖子属性并允许它们被更改：
- en: '[PRE143]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Next, we need to define a class that will hold the category. It needs to store
    a list of posts and it also needs to contain its name. There must be also a defined
    function that will allow simple post addition. This function needs to contain
    a function parameter in which `Post` is the receiver type. Here is the definition:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个类来保存类别。它需要存储一系列帖子，还需要包含其名称。还必须定义一个函数，允许简单的帖子添加。这个函数需要包含一个函数参数，其中`Post`是接收者类型。以下是定义：
- en: '[PRE144]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Also, we need a class that will hold a list of categories and allow simple
    category definition:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一个类来保存类别列表，并允许简单的类别定义：
- en: '[PRE145]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'All we need now is the `definePosts` function, whose definition might be the
    following:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的是`definePosts`函数，其定义可能如下：
- en: '[PRE146]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'And that''s all we need. Now we can define object structure by a simple, type-safe
    builder:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部。现在我们可以通过一个简单的类型安全构建器来定义对象结构：
- en: '[PRE147]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'DSL is a really powerful concept that is more and more used around the Kotlin
    community. It is already possible, thanks to libraries, to use Kotlin DSL to fully
    replace the following:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: DSL是一个非常强大的概念，在Kotlin社区中越来越受欢迎。由于库的存在，已经可以使用Kotlin DSL完全替代以下内容：
- en: Android layout files (Anko)
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android布局文件（Anko）
- en: Gradle configuration files
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle配置文件
- en: HTML files (`kotlinx.html` )
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML文件（`kotlinx.html`）
- en: JSON files (Kotson)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON文件（Kotson）
- en: And lots of other configuration files. Let's look at some example library that
    is defining Kotlin DSL to provide type-safe builders.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他的配置文件。让我们看一个定义了Kotlin DSL以提供类型安全构建器的示例库。
- en: Anko
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anko
- en: 'Anko is a library that provides a DSL to define Android views without any XML
    layouts. This is pretty similar to examples we''ve already seen, but Anko made
    it possible to fully remove XML layout files from a project. Here is an example
    view written in Anko DSL:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Anko是一个库，提供了DSL来定义Android视图，而无需任何XML布局。这与我们已经看到的示例非常相似，但Anko使得完全可以从项目中删除XML布局文件成为可能。这里是一个用Anko
    DSL编写的示例视图：
- en: '[PRE148]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'And here is the result:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果：
- en: '![](img/Image00051.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00051.jpg)'
- en: 'Source: [https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)'
- en: 'It is also possible to define much more complex layouts using Anko DSL. These
    views can be placed either on a custom class that serves as a view or even directly
    inside the `onCreate` method:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Anko DSL也可以定义更复杂的布局。这些视图可以放置在作为视图的自定义类上，甚至直接放在`onCreate`方法中：
- en: '[PRE149]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: To learn more about this example, you can visit Anko Wiki at [https://github.com/Kotlin/anko/wiki/Anko-Layouts](https://github.com/Kotlin/anko/wiki/Anko-Layouts)
    .
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这个例子的信息，您可以访问Anko Wiki网站[https://github.com/Kotlin/anko/wiki/Anko-Layouts](https://github.com/Kotlin/anko/wiki/Anko-Layouts)。
- en: It is still debatable if DSL layoutdefinition are going to replace XML definitions.
    At the time of writing, it is not so popular to define views this way, because
    of a lack of support from Google, but while Google announced that they are going
    to support Kotlin, so it is possible that this idea will become more popular and
    DSL-based layouts will be more supported and maybe even universal someday.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还有争议，DSL布局定义是否会取代XML定义。在撰写本文时，以这种方式定义视图并不那么流行，因为缺乏来自Google的支持，但是Google宣布他们将支持Kotlin，因此这个想法有可能变得更加流行，基于DSL的布局也可能会得到更多支持，甚至有朝一日成为通用的。
- en: Summary
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we discussed Kotlin extension functions and properties, both
    defined top-level and as type member. We''ve seen how Kotlin standard library
    extension functions can be used to simplify collection processing and perform
    various operations. We have also described function type with receiver together
    with function literals with receiver. Also, we''ve seen a few important generic
    functions from standard library, which are using extensions: `let` , `apply` ,
    `also` , `with` , `run` , and `to` . Finally, we''ve seen how DSL can be defined
    in Kotlin, and where it is useful.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Kotlin扩展函数和属性，包括顶层定义和类型成员定义。我们看到了Kotlin标准库扩展函数如何简化集合处理和执行各种操作。我们还描述了带有接收者的函数类型以及带有接收者的函数文字。此外，我们还看到了标准库中一些重要的通用函数，它们使用了扩展：`let`，`apply`，`also`，`with`，`run`和`to`。最后，我们看到了DSL如何在Kotlin中定义以及它的用途。
- en: In the next chapter, there is going to be presented the next feature that was
    not present in the Java world while it is giving really big possibilities in Kotlin
    development--class and property delegates.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将介绍在Java世界中不存在的下一个功能，它在Kotlin开发中提供了非常大的可能性--类和属性委托。
