["```cs\nbool TryAdd (T item); \n```", "```cs\nbool TryTake (out T item);\n```", "```cs\nQueue<int> queue = new Queue<int>();\nfor (int i = 0; i < 500; i++) \n{\n    queue.Enqueue(i);\n}\n```", "```cs\nint sum = 0;\n```", "```cs\nParallel.For(0, 500, (i) =>\n{\n    int localSum = 0;\n    int localValue;\n    while (queue.TryDequeue(out localValue))\n    {\n        Thread.Sleep(10);\n        localSum += localValue;\n    }\n    Interlocked.Add(ref sum, localSum);\n});  \nConsole.WriteLine($\"Calculated Sum is {sum} and should be {Enumerable.Range(0, 500).Sum()}\");\n```", "```cs\nParallel.For(0, 500, (i) =>\n{\n    int localSum = 0;\n    int localValue;\n    Monitor.Enter(_locker);\n    while (cq.TryDequeue(out localValue))\n    {\n       Thread.Sleep(10);\n       localSum += localValue;\n    }\n    Monitor.Exit(_locker);\n    Interlocked.Add(ref sum, localSum);\n});\n```", "```cs\nprivate static void ProducerConsumerUsingConcurrentQueues()\n{\n    // Create a Queue.\n    ConcurrentQueue<int> cq = new ConcurrentQueue<int>();\n    // Populate the queue.\n    for (int i = 0; i < 500; i++){\n        cq.Enqueue(i);\n    }\n    int sum = 0;\n    Parallel.For(0, 500, (i) =>\n    {\n        int localSum = 0;\n        int localValue;\n        while (cq.TryDequeue(out localValue))\n        {\n            Thread.Sleep(10);\n            localSum += localValue;\n        }\n        Interlocked.Add(ref sum, localSum);\n    });\n    Console.WriteLine($\"outerSum = {sum}, should be {Enumerable.Range(0, 500).Sum()}\");\n}\n```", "```cs\nConcurrentStack<int> concurrentStack = new ConcurrentStack<int>();\nconcurrentStack.Push (1);\nconcurrentStack.PushRange(new[] { 1,2,3,4,5});\n```", "```cs\nint localValue;\nconcurrentStack.TryPop(out localValue)\nconcurrentStack.TryPopRange (new[] { 1,2,3,4,5});\n```", "```cs\nprivate static void ProducerConsumerUsingConcurrentStack()\n{\n    // Create a Queue.\n    ConcurrentStack<int> concurrentStack = new ConcurrentStack<int>();\n    // Populate the queue.\n    for (int i = 0; i < 500; i++){\n        concurrentStack.Push(i);\n    }\n    concurrentStack.PushRange(new[] { 1,2,3,4,5});\n    int sum = 0;\n    Parallel.For(0, 500, (i) =>\n    {\n        int localSum = 0;\n        int localValue;\n        while (concurrentStack.TryPop(out localValue))\n        {\n            Thread.Sleep(10);\n            localSum += localValue;\n        }\n        Interlocked.Add(ref sum, localSum);\n    });\n    Console.WriteLine($\"outerSum = {sum}, should be 124765\");\n}\n```", "```cs\nConcurrentBag<int> concurrentBag = new ConcurrentBag<int>();\n//Add item to bag\nconcurrentBag.Add(10);\nint item;\n//Getting items from Bag\nconcurrentBag.TryTake(out item)\n```", "```cs\nstatic ConcurrentBag<int> concurrentBag = new ConcurrentBag<int>();\nprivate static void ConcurrentBackDemo()\n{\n    ManualResetEventSlim manualResetEvent = new ManualResetEventSlim(false);\n    Task producerAndConsumerTask = Task.Factory.StartNew(() =>\n    {\n        for (int i = 1; i <= 3; ++i)\n        {\n            concurrentBag.Add(i);\n        }\n        //Allow second thread to add items\n        manualResetEvent.Wait();\n        while (concurrentBag.IsEmpty == false)\n        {\n            int item;\n            if (concurrentBag.TryTake(out item))\n            {\n                Console.WriteLine($\"Item is {item}\");\n            }\n        }\n    });\n    Task producerTask = Task.Factory.StartNew(() =>\n    {\n        for (int i = 4; i <= 6; ++i)\n        {\n            concurrentBag.Add(i);\n        }\n        manualResetEvent.Set();\n    });\n}\n```", "```cs\nBlockingCollection<int> blockingCollection = new BlockingCollection<int>(10);\n```", "```cs\nblockingCollection.Add(1);\nblockingCollection.TryAdd(3, TimeSpan.FromSeconds(1))\n```", "```cs\nint item = blockingCollection.Take();\nblockingCollection.TryTake(out item, TimeSpan.FromSeconds(1))\n```", "```cs\nBlockingCollection<int> blockingCollection = new BlockingCollection<int>(10);\nTask producerTask = Task.Factory.StartNew(() =>\n{\n    for (int i = 0; i < 5; ++i)\n    {\n        blockingCollection.Add(i);\n    }\n    blockingCollection.CompleteAdding();\n});\nTask consumerTask = Task.Factory.StartNew(() =>\n{\n    while (!blockingCollection.IsCompleted)\n    {\n        int item = blockingCollection.Take();\n        Console.WriteLine($\"Item retrieved is {item}\");\n    }\n});\nTask.WaitAll(producerTask, consumerTask);\n```", "```cs\nBlockingCollection<int>[] produceCollections = new BlockingCollection<int>[2];\nproduceCollections[0] = new BlockingCollection<int>(5);\nproduceCollections[1] = new BlockingCollection<int>(5);\n```", "```cs\nTask producerTask1 = Task.Factory.StartNew(() =>\n{\n    for (int i = 1; i <= 5; ++i)\n    {\n        produceCollections[0].Add(i);\n        Thread.Sleep(100);\n    }\n    produceCollections[0].CompleteAdding();\n});\nTask producerTask2 = Task.Factory.StartNew(() =>\n{\n    for (int i = 6; i <= 10; ++i)\n    {\n        produceCollections[1].Add(i);\n        Thread.Sleep(200);\n    }\n    produceCollections[1].CompleteAdding();\n});\n```", "```cs\nwhile (!produceCollections[0].IsCompleted || !produceCollections[1].IsCompleted)\n{\n int item;\n BlockingCollection<int>.TryTakeFromAny(produceCollections, out item, TimeSpan.FromSeconds(1));\n if (item != default(int))\n {\n Console.WriteLine($\"Item fetched is {item}\");\n }\n}\n```", "```cs\nConcurrentDictionary<int, int> concurrentDictionary = new ConcurrentDictionary<int, int>();\n```", "```cs\nconcurrentDictionary.TryAdd(i, i * i);\nstring value = (i * i).ToString();\n// Add item if not exist or else update\nconcurrentDictionary.AddOrUpdate(i, value,(key, val) => (key * key).ToString()); \n//Fetches item with key 5 or if not exist than add key 5 with value 25\nconcurrentDictionary.GetOrAdd(5, \"25\");\n```", "```cs\nstring value;\nconcurrentDictionary.TryRemove(5, out value);\n```", "```cs\n//If a key with a value of 25 is found, it will be updated to have a value of 30      concurrentDictionary.TryUpdate(5, \"30\",\"25\");\n```", "```cs\nConcurrentDictionary<int, string> concurrentDictionary = new ConcurrentDictionary<int, string>();\nTask producerTask1 = Task.Factory.StartNew(() => \n{\n    for (int i = 0; i < 20; i++)\n    {\n        Thread.Sleep(100);\n        concurrentDictionary.TryAdd(i, (i * i).ToString());\n    }\n});\nTask producerTask2 = Task.Factory.StartNew(() => \n{\n    for (int i = 10; i < 25; i++)\n    {\n        concurrentDictionary.TryAdd(i, (i * i).ToString());\n    }\n});\nTask producerTask3 = Task.Factory.StartNew(() => \n{\n    for (int i = 15; i < 20; i++)\n    {\n        Thread.Sleep(100);\n        concurrentDictionary.AddOrUpdate(i, (i * i).ToString(),(key, value) \n         => (key * key).ToString());\n    }\n});\nTask.WaitAll(producerTask1, producerTask2);            \nConsole.WriteLine(\"Keys are {0} \", string.Join(\",\", concurrentDictionary.Keys.Select(c => c.ToString()).ToArray()));\n```"]