["```java\npublic final class MyStack<E> {\n\u00a0\u00a0private static final int DEFAULT_CAPACITY = 10;\n\u00a0\u00a0private int top;\n\u00a0\u00a0private E[] stack;\n\u00a0\u00a0MyStack() {\n\u00a0\u00a0\u00a0\u00a0stack = (E[]) Array.newInstance(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Object[].class.getComponentType(), \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DEFAULT_CAPACITY);\n\u00a0\u00a0\u00a0\u00a0top = 0; // the initial size is 0\n\u00a0\u00a0}\n\u00a0\u00a0public void push(E e) {}\n\u00a0\u00a0public E pop() {}\n\u00a0\u00a0public E peek() {}\n\u00a0\u00a0public int size() {}\n\u00a0\u00a0public boolean isEmpty() {}\n\u00a0\u00a0public boolean isFull() {}\n\u00a0\u00a0private void ensureCapacity() {}\n}\n```", "```java\n// add an element 'e' in the stack\npublic void push(E e) {\n\u00a0\u00a0// if the stack is full, we double its capacity\n\u00a0\u00a0if (isFull()) {\n\u00a0\u00a0\u00a0\u00a0ensureCapacity();\n\u00a0\u00a0}\n\u00a0\u00a0// adding the element at the top of the stack\n\u00a0\u00a0stack[top++] = e;\n}\n// used internally for doubling the stack capacity\nprivate void ensureCapacity() {\n\u00a0\u00a0int newSize = stack.length * 2;\n\u00a0\u00a0stack = Arrays.copyOf(stack, newSize);\n}\n```", "```java\n// pop top element from the stack\npublic E pop() {\n\u00a0\u00a0// if the stack is empty then just throw an exception\n\u00a0\u00a0if (isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0}\n\u00a0\u00a0// extract the top element from the stack\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0E e = stack[--top];\n\u00a0\u00a0// avoid memory leaks\n\u00a0\u00a0stack[top] = null;\n\u00a0\u00a0return e;\n}\n```", "```java\n// return but not remove the top element in the stack\npublic E peek() {\n\u00a0\u00a0// if the stack is empty then just throw an exception\n\u00a0\u00a0if (isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0}\n\u00a0\u00a0return stack[top - 1];\n}\n```", "```java\npublic final class MyQueue<E> {\n\u00a0\u00a0private static final int DEFAULT_CAPACITY = 10;\n\u00a0\u00a0private int front;\n\u00a0\u00a0private int rear;\n\u00a0\u00a0private int count;\n\u00a0\u00a0private int capacity;\n\u00a0\u00a0private E[] queue;\n\u00a0\u00a0MyQueue() {\n\u00a0\u00a0\u00a0\u00a0queue = (E[]) Array.newInstance(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Object[].class.getComponentType(), \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DEFAULT_CAPACITY);\n\u00a0\u00a0count = 0; // the initial size is 0\n\u00a0\u00a0front = 0;\n\u00a0\u00a0rear = -1;\n\u00a0\u00a0capacity = DEFAULT_CAPACITY;\n\u00a0\u00a0}\n\u00a0\u00a0public void enqueue(E e) {}\n\u00a0\u00a0public E dequeue() {}\n\u00a0\u00a0public E peek() {}\n\u00a0\u00a0public int size() {}\n\u00a0\u00a0public boolean isEmpty() {}\n\u00a0\u00a0public boolean isFull() {}\n\u00a0\u00a0private void ensureCapacity() {}\n} \n```", "```java\n// add an element 'e' in the queue\npublic void enqueue(E e) {\n\u00a0\u00a0// if the queue is full, we double its capacity\n\u00a0\u00a0if (isFull()) {\n\u00a0\u00a0\u00a0\u00a0ensureCapacity();\n\u00a0\u00a0}\n\u00a0\u00a0// adding the element in the rear of the queue\n\u00a0\u00a0rear = (rear + 1) % capacity;\n\u00a0\u00a0queue[rear] = e;\n\u00a0\u00a0// update the size of the queue\n\u00a0\u00a0count++;\n}\n// used internally for doubling the queue capacity\nprivate void ensureCapacity() {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0int newSize = queue.length * 2;\n\u00a0\u00a0queue = Arrays.copyOf(queue, newSize);\n\u00a0\u00a0// setting the new capacity\n\u00a0\u00a0capacity = newSize;\n}\n```", "```java\n// remove and return the front element from the queue\npublic E dequeue() {\n\u00a0\u00a0// if the queue is empty we just throw an exception\n\u00a0\u00a0if (isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0}\n\u00a0\u00a0// extract the element from the front\n\u00a0\u00a0E e = queue[front];\n\u00a0\u00a0queue[front] = null;\n\u00a0\u00a0// set the new front\n\u00a0\u00a0front = (front + 1) % capacity;\n\u00a0\u00a0// decrease the size of the queue\n\u00a0\u00a0count--;\n\u00a0\u00a0return e;\n}\n```", "```java\n// return but not remove the front element in the queue\npublic E peek() {\n\u00a0\u00a0// if the queue is empty we just throw an exception\n\u00a0\u00a0if (isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0}\n\u00a0\u00a0return queue[front];\n}\n```", "```java\npublic static String reverse(String str) {\n\u00a0\u00a0Stack<Character> stack = new Stack();\n\u00a0\u00a0// push characters of the string into the stack\n\u00a0\u00a0char[] chars = str.toCharArray();\n\u00a0\u00a0for (char c : chars) {\n\u00a0\u00a0\u00a0\u00a0stack.push(c);\n\u00a0\u00a0}\n\u00a0\u00a0// pop all characters from the stack and\n\u00a0\u00a0// put them back to the input string\n\u00a0\u00a0for (int i = 0; i < str.length(); i++) {\n\u00a0\u00a0\u00a0\u00a0chars[i] = stack.pop();\n\u00a0\u00a0}\n\u00a0\u00a0// return the string\n\u00a0\u00a0return new String(chars);\n}\n```", "```java\npublic static boolean bracesMatching(String bracesStr) {\n\u00a0\u00a0Stack<Character> stackBraces = new Stack<>();\n\u00a0\u00a0int len = bracesStr.length();\n\u00a0\u00a0for (int i = 0; i < len; i++) {\n\u00a0\u00a0\u00a0\u00a0switch (bracesStr.charAt(i)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case '{':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stackBraces.push(bracesStr.charAt(i));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case '}':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (stackBraces.isEmpty()) { // we found a mismatch\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// for every match we pop the corresponding '{'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stackBraces.pop(); \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0default:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return stackBraces.empty();\n}\n```", "```java\nprivate static final int STACK_SIZE = 3;\nprivate final LinkedList<Stack<Integer>> stacks \n\u00a0\u00a0= new LinkedList<>();\npublic void push(int value) {\n\u00a0\u00a0// if there is no stack or the last stack is full\n\u00a0\u00a0if (stacks.isEmpty() || stacks.getLast().size()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0>= STACK_SIZE) {\n\u00a0\u00a0\u00a0\u00a0// create a new stack and push the value into it\n\u00a0\u00a0\u00a0\u00a0Stack<Integer> stack = new Stack<>();\n\u00a0\u00a0\u00a0\u00a0stack.push(value);\n\u00a0\u00a0\u00a0\u00a0// add the new stack into the list of stacks\n\u00a0\u00a0\u00a0\u00a0stacks.add(stack);\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0// add the value in the last stack\n\u00a0\u00a0\u00a0\u00a0stacks.getLast().push(value);\n\u00a0\u00a0}\n}\n```", "```java\npublic Integer pop() {\n\u00a0\u00a0// find the last stack\n\u00a0\u00a0Stack<Integer> lastStack = stacks.getLast();\n\u00a0\u00a0// pop the value from the last stack\n\u00a0\u00a0int value = lastStack.pop();\n\u00a0\u00a0// if last stack is empty, remove it from the list of stacks\n\u00a0\u00a0removeStackIfEmpty();\n\u00a0\u00a0return value;\n}\nprivate void removeStackIfEmpty() {\n\u00a0\u00a0if (stacks.getLast().isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stacks.removeLast();\n\u00a0\u00a0}\n}\n```", "```java\npublic Integer popAt(int stackIndex) {\n\u00a0\u00a0// get the value from the correspondind stack\n\u00a0\u00a0int value = stacks.get(stackIndex).pop();\n\u00a0\u00a0// pop an element -> must shift the remaining elements\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0shift(stackIndex);\n\u00a0\u00a0// if last stack is empty, remove it from the list of stacks\n\u00a0\u00a0removeStackIfEmpty();\n\u00a0\u00a0return value;\n}\nprivate void shift(int index) {\n\u00a0\u00a0for (int i = index; i<stacks.size() - 1; ++i) {\n\u00a0\u00a0\u00a0\u00a0Stack<Integer> currentStack = stacks.get(i);\n\u00a0\u00a0\u00a0\u00a0Stack<Integer> nextStack = stacks.get(i + 1);\n\u00a0\u00a0\u00a0\u00a0currentStack.push(nextStack.remove(0));\n\u00a0\u00a0}\n}\n```", "```java\npublic static int[] stockSpan(int[] stockPrices) {\n\u00a0\u00a0Stack<Integer> dayStack = new Stack();\n\u00a0\u00a0int[] spanResult = new int[stockPrices.length];\n\u00a0\u00a0spanResult[0] = 1; // first day has span 1\n\u00a0\u00a0dayStack.push(0);\n\u00a0\u00a0for (int i = 1; i < stockPrices.length; i++) {\n\u00a0\u00a0\u00a0\u00a0// pop until we find a price on stack which is \n\u00a0\u00a0\u00a0\u00a0// greater than the current day's price or there \n\u00a0\u00a0\u00a0\u00a0// are no more days left\n\u00a0\u00a0\u00a0\u00a0while (!dayStack.empty() \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& stockPrices[i] > stockPrices[dayStack.peek()]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dayStack.pop();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// if there is no price greater than the current \n\u00a0\u00a0\u00a0\u00a0// day's price then the stock span is the numbers of days\n\u00a0\u00a0\u00a0\u00a0if (dayStack.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spanResult[i] = i + 1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if there is a price greater than the current \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// day's price then the stock span is the \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// difference between the current day and that day\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spanResult[i] = i - dayStack.peek();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// push current day onto top of stack\n\u00a0\u00a0\u00a0\u00a0 dayStack.push(i);\n\u00a0\u00a0}\n\u00a0\u00a0return spanResult;\n}\n```", "```java\npublic class MyStack extends Stack<Integer> {\n\u00a0\u00a0Stack<Integer> stackOfMin;\n\u00a0\u00a0public MyStack() {\n\u00a0\u00a0\u00a0\u00a0stackOfMin = new Stack<>();\n\u00a0\u00a0}\n\u00a0\u00a0public Integer push(int value) {\n\u00a0\u00a0\u00a0\u00a0if (value <= min()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 stackOfMin.push(value);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return super.push(value);\n\u00a0\u00a0}\n\u00a0\u00a0@Override\n\u00a0\u00a0public Integer pop() {\n\u00a0\u00a0\u00a0\u00a0int value = super.pop();\n\u00a0\u00a0\u00a0\u00a0if (value == min()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 stackOfMin.pop();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return value;\n\u00a0\u00a0}\n\u00a0\u00a0public int min() {\n\u00a0\u00a0 if (stackOfMin.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Integer.MAX_VALUE;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return stackOfMin.peek();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic class MyStack {\n\u00a0\u00a0private int min;\n\u00a0\u00a0private final Stack<Integer> stack = new Stack<>();\n\u00a0\u00a0public void push(int value) {\n\u00a0\u00a0\u00a0\u00a0// we don't allow values that overflow int/2 range\n\u00a0\u00a0\u00a0\u00a0int r = Math.addExact(value, value);\n\u00a0\u00a0\u00a0\u00a0if (stack.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(value);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0min = value;\n\u00a0\u00a0\u00a0\u00a0} else if (value > min) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(value);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(r - min);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0min = value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// pop() doesn't return the value since this may be a wrong\u00a0\u00a0 \n\u00a0\u00a0// value (a value that was not pushed by the client)!\n\u00a0\u00a0public void pop() {\n\u00a0\u00a0\u00a0\u00a0if (stack.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int top = stack.peek();\n\u00a0\u00a0\u00a0\u00a0if (top < min) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0min = 2 * min - top;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0stack.pop();\n\u00a0\u00a0}\n\u00a0\u00a0public int min() {\n\u00a0\u00a0\u00a0\u00a0return min;\n\u00a0\u00a0}\n}\n```", "```java\npublic class MyQueueViaStack<E> {\n\u00a0\u00a0private final Stack<E> stackEnqueue;\n\u00a0\u00a0private final Stack<E> stackDequeue;\n\u00a0\u00a0public MyQueueViaStack() {\n\u00a0\u00a0\u00a0\u00a0stackEnqueue = new Stack<>();\n\u00a0\u00a0\u00a0\u00a0stackDequeue = new Stack<>();\n\u00a0\u00a0}\n\u00a0\u00a0public void enqueue(E e) {\n\u00a0\u00a0\u00a0\u00a0stackEnqueue.push(e);\n\u00a0\u00a0}\n\u00a0\u00a0public E dequeue() {\n\u00a0\u00a0\u00a0\u00a0reverseStackEnqueue();\n\u00a0\u00a0\u00a0\u00a0return stackDequeue.pop();\n\u00a0\u00a0}\n\u00a0\u00a0public E peek() {\n\u00a0\u00a0\u00a0\u00a0reverseStackEnqueue();\n\u00a0\u00a0\u00a0\u00a0return stackDequeue.peek();\n\u00a0\u00a0}\n\u00a0\u00a0public int size() {\n\u00a0\u00a0\u00a0\u00a0return stackEnqueue.size() + stackDequeue.size();\n\u00a0\u00a0}\n\u00a0\u00a0private void reverseStackEnqueue() {\n\u00a0\u00a0\u00a0\u00a0if (stackDequeue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (!stackEnqueue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stackDequeue.push(stackEnqueue.pop());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic class MyStackViaQueue<E> {\n\u00a0\u00a0private final Queue<E> queue1;\n\u00a0\u00a0private final Queue<E> queue2;\n\u00a0\u00a0private E peek;\n\u00a0\u00a0private int size;\n\u00a0\u00a0public MyStackViaQueue() {\n\u00a0\u00a0\u00a0\u00a0queue1 = new ArrayDeque<>();\n\u00a0\u00a0\u00a0\u00a0queue2 = new ArrayDeque<>();\n\u00a0\u00a0}\n\u00a0\u00a0public void push(E e) {\n\u00a0\u00a0\u00a0\u00a0if (!queue1.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (peek != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue1.add(peek);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue1.add(e);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (peek != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue2.add(peek);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue2.add(e);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0size++;\n\u00a0\u00a0\u00a0\u00a0peek = null;\n\u00a0\u00a0}\n\u00a0\u00a0public E pop() {\n\u00a0\u00a0\u00a0\u00a0if (size() == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (peek != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E e = peek;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0peek = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return e;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0E e;\n\u00a0\u00a0\u00a0\u00a0if (!queue1.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e = switchQueue(queue1, queue2);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0e = switchQueue(queue2, queue1);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0\u00a0\u00a0return e;\n\u00a0\u00a0}\n\u00a0\u00a0public E peek() {\n\u00a0\u00a0\u00a0\u00a0if (size() == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new EmptyStackException();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (peek == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!queue1.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0peek = switchQueue(queue1, queue2);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0peek = switchQueue(queue2, queue1);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return peek;\n\u00a0\u00a0}\n\u00a0\u00a0public int size() {\n\u00a0\u00a0\u00a0\u00a0return size;\n\u00a0\u00a0}\n\u00a0\u00a0private E switchQueue(Queue from, Queue to) {\n\u00a0\u00a0\u00a0\u00a0while (from.size() > 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0to.add(from.poll());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return (E) from.poll();\n\u00a0\u00a0}\n}\n```", "```java\npublic static int maxAreaUsingStack(int[] histogram) {\n\u00a0\u00a0Stack<Integer> stack = new Stack<>();\n\u00a0\u00a0int maxArea = 0;\n\u00a0\u00a0for (int bar = 0; bar <= histogram.length; bar++) {\n\u00a0\u00a0\u00a0\u00a0int barHeight;\n\u00a0\u00a0\u00a0\u00a0if (bar == histogram.length) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0barHeight = 0; // take into account last bar\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0barHeight = histogram[bar];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0while (!stack.empty() \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& barHeight < histogram[stack.peek()]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we found a bar smaller than the one from the stack\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int top = stack.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// find left boundary\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int left = stack.isEmpty() ? -1 : stack.peek();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// find the width of the rectangular area \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int areaRectWidth = bar - left - 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// compute area of the current rectangle\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int area = areaRectWidth * histogram[top];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxArea = Integer.max(area, maxArea);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// add current bar (index) into the stack\n\u00a0\u00a0\u00a0\u00a0stack.push(bar);\n\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return maxArea;\n}\n```", "```java\npublic static void smallestAfterRemove(String nr, int k) {\n\u00a0\u00a0int i = 0;\n\u00a0\u00a0Stack<Character> stack = new Stack<>();\n\u00a0\u00a0while (i < nr.length()) {\n\u00a0\u00a0\u00a0\u00a0// if the current digit is less than the previous \n\u00a0\u00a0\u00a0\u00a0// digit then discard the previous one\n\u00a0\u00a0\u00a0\u00a0while (k > 0 && !stack.isEmpty()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& stack.peek() > nr.charAt(i)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k--;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0stack.push(nr.charAt(i));\n\u00a0\u00a0\u00a0\u00a0i++;\n\u00a0\u00a0}\n\u00a0\u00a0// cover corner cases such as '2222'\n\u00a0\u00a0while (k > 0) {\n\u00a0\u00a0\u00a0\u00a0stack.pop();\n\u00a0\u00a0\u00a0\u00a0k--;\n\u00a0\u00a0}\n\u00a0\u00a0System.out.println(\"The number is (as a printed stack; \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ \"ignore leading 0s (if any)): \" + stack);\n\u00a0\u00a0}\n}\n```", "```java\n// top, right, bottom, left and 4 diagonal moves\nprivate static final int[] ROW = {-1, -1, -1, 0, 1, 0, 1, 1};\nprivate static final int[] COL = {-1, 1, 0, -1, -1, 1, 0, 1};\n```", "```java\nprivate static booleanisValid(int[][] matrix, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int r, int c, boolean[][] flagged) {\n\u00a0\u00a0return (r >= 0) && (r < flagged.length)\n\u00a0\u00a0\u00a0\u00a0&& (c >= 0) && (c < flagged[0].length)\n\u00a0\u00a0\u00a0\u00a0&& (matrix[r][c] == 1 && !flagged[r][c]);\n}\n```", "```java\nprivate static class Cell {\n\u00a0\u00a0int r, c;\n\u00a0\u00a0public Cell(int r, int c) {\n\u00a0\u00a0\u00a0\u00a0this.r = r;\n\u00a0\u00a0\u00a0\u00a0this.c = c;\n\u00a0\u00a0}\n}\n// there are 8 possible movements from a cell\u00a0\u00a0\u00a0\u00a0\nprivate static final int POSSIBLE_MOVEMENTS = 8;\n// top, right, bottom, left and 4 diagonal moves\nprivate static final int[] ROW = {-1, -1, -1, 0, 1, 0, 1, 1};\nprivate static final int[] COL = {-1, 1, 0, -1, -1, 1, 0, 1};\npublic static int islands(int[][] matrix) {\n\u00a0\u00a0int m = matrix.length;\n\u00a0\u00a0int n = matrix[0].length;\n\u00a0\u00a0// stores if a cell is flagged or not\n\u00a0\u00a0boolean[][] flagged = new boolean[m][n];\n\u00a0\u00a0int island = 0;\n\u00a0\u00a0for (int i = 0; i < m; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < n; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (matrix[i][j] == 1 && !flagged[i][j]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0resolve(matrix, flagged, i, j);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0island++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return island;\n}\nprivate static void resolve(int[][] matrix, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0boolean[][] flagged, int i, int j) {\n\u00a0\u00a0Queue<Cell> queue = new ArrayDeque<>();\n\u00a0\u00a0queue.add(new Cell(i, j));\n\u00a0\u00a0// flag source node\n\u00a0\u00a0flagged[i][j] = true;\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0int r = queue.peek().r;\n\u00a0\u00a0\u00a0\u00a0int c = queue.peek().c;\n\u00a0\u00a0\u00a0\u00a0queue.poll();\n\u00a0\u00a0\u00a0\u00a0// check for all 8 possible movements from current \n\u00a0\u00a0\u00a0\u00a0// cell and enqueue each valid movement\n\u00a0\u00a0\u00a0\u00a0for (int k = 0; k < POSSIBLE_MOVEMENTS; k++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// skip this cell if the location is invalid\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (isValid(matrix, r + ROW[k], c + COL[k], flagged)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flagged[r + ROW[k]][c + COL[k]] = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(new Cell(r + ROW[k], c + COL[k]));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nprivate static int findShortestPath(int[][] board) {\n\u00a0\u00a0// stores if cell is visited or not\n\u00a0\u00a0boolean[][] visited = new boolean[M][N];\n\u00a0\u00a0Queue<Cell> queue = new ArrayDeque<>();\n\u00a0\u00a0// process every cell of first column\n\u00a0\u00a0for (int r1 = 0; r1 < M; r1++) {\n\u00a0\u00a0\u00a0\u00a0// if the cell is safe, mark it as visited and\n\u00a0\u00a0\u00a0\u00a0// enqueue it by assigning it distance as 0 from itself\n\u00a0\u00a0\u00a0\u00a0if (board[r1][0] == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(new Cell(r1, 0, 0));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[r1][0] = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0// pop the front node from queue and process it\n\u00a0\u00a0\u00a0\u00a0int rIdx = queue.peek().r;\n\u00a0\u00a0\u00a0\u00a0int cIdx = queue.peek().c;\n\u00a0\u00a0\u00a0\u00a0int dist = queue.peek().distance;\n\u00a0\u00a0\u00a0\u00a0queue.poll();\n\u00a0\u00a0\u00a0\u00a0// if destination is found then return minimum distance\n\u00a0\u00a0\u00a0\u00a0if (cIdx == N - 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (dist + 1);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// check for all 4 possible movements from \n\u00a0\u00a0\u00a0\u00a0// current cell and enqueue each valid movement\n\u00a0\u00a0\u00a0\u00a0for (int k = 0; k < 4; k++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (isValid(rIdx + ROW_4[k], cIdx + COL_4[k])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& isSafe(board, visited, rIdx + ROW_4[k], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cIdx + COL_4[k])) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mark it as visited and push it into \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// queue with (+1) distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited[rIdx + ROW_4[k]][cIdx + COL_4[k]] = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(new Cell(rIdx + ROW_4[k], \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cIdx + COL_4[k], dist + 1));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```"]