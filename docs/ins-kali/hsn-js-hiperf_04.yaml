- en: Practical Example - A Look at Svelte and Being Vanilla
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例-看看Svelte和Vanilla
- en: Since the past few chapters took a look at the modern web and the APIs available
    to us, we are now going to take a practical example of those same APIs in action.
    There has been quite a bit of development in web frameworks that create a kind
    of *runtime* associated with them. This *runtime* can be almost all attributed
    to a **Virtual DOM** (**VDOM**) and a state system. When these two things are
    interconnected, we are able to create rich and reactive frontend. Examples of
    these frameworks are React, Vue, and Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过去几章讨论了现代网络和我们可用的API，现在我们将实际示例中使用这些API。在创建与之相关的一种*运行时*的Web框架方面已经有了相当多的发展。这个*运行时*几乎可以归因于**虚拟DOM**（**VDOM**）和状态系统。当这两个东西相互关联时，我们能够创建丰富和反应灵敏的前端。这些框架的例子包括React、Vue和Angular。
- en: 'But what happens if we got rid of the VDOM and runtime concept and somehow
    compiled all of this code down to vanilla JavaScript and web API calls? This is
    what the creators of the Svelte framework had in mind: to utilize what we have
    in the browser instead of creating our own version of the browser (this is an
    obvious oversimplification, but it does not stretch the truth too much). In this
    chapter, we will take a look a Svelte and how it achieves some of this magic,
    along with a few examples of applications written in this framework. This should
    give a good understanding of Svelte and the *runtime-less* frameworks that are
    out there and how they could potentially speed up our application runtime speed.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们摆脱VDOM和运行时概念，并以某种方式将所有这些代码编译为纯JavaScript和Web API调用，会发生什么？这就是Svelte框架的创建者所考虑的：利用浏览器中已有的内容，而不是创建我们自己的浏览器版本（这显然是一个过度简化，但并不太离谱）。在本章中，我们将看看Svelte以及它如何实现一些魔术，以及使用这个框架编写的一些应用程序示例。这应该让我们对Svelte和存在的*无运行时*框架有一个很好的理解，以及它们如何潜在地加快我们的应用程序运行速度。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题如下：
- en: A framework for pure speed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯速度的框架
- en: Build the basics – a Todo application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基础-待办事项应用程序
- en: Getting fancier – basic weather application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变得更花哨-基本天气应用程序
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are required for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: An editor or IDE such as **Visual Studio Code** (**VS Code**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如**Visual Studio Code**（**VS Code**）之类的编辑器或IDE
- en: A Node environment setup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node环境设置
- en: A good understanding of the DOM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对DOM的良好理解
- en: A web browser such as Chrome
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome等Web浏览器
- en: The code found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04)找到的代码。
- en: A framework for pure speed
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯速度的框架
- en: 'The Svelte framework decided to shift the focus from a runtime-based system
    to a compiler-based system. This can be seen on their website, located at [https://svelte.dev](https://svelte.dev).
    On their front page, it even states the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte框架决定将焦点从基于运行时的系统转移到基于编译器的系统。这可以在他们的网站上看到，位于[https://svelte.dev](https://svelte.dev)。在他们的首页上，甚至明确指出了以下内容：
- en: Svelte compiles your code to tiny, framework-less vanilla JS – your app starts
    fast and stays fast.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte将您的代码编译为微小的、无框架的vanilla JS-您的应用程序启动快速并保持快速。
- en: 'By moving the steps from the runtime to the initial compile, we are able to
    create applications that will download and run fast. But, before we can start
    looking at this compiler, we need to get it onto our machines. The following steps
    should enable us to start writing code for Svelte (taken directly from [https://svelte.dev/blog/the-easiest-way-to-get-started](https://svelte.dev/blog/the-easiest-way-to-get-started)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将步骤从运行时移至初始编译，我们能够创建下载和运行速度快的应用程序。但是，在我们开始研究这个编译器之前，我们需要将其安装到我们的机器上。以下步骤应该使我们能够开始为Svelte编写代码（直接从[https://svelte.dev/blog/the-easiest-way-to-get-started](https://svelte.dev/blog/the-easiest-way-to-get-started)获取）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With these commands, we now have a running Svelte application located at `localhost:5000`.
    Let's take a look at what the `package.json` has inside of it that got us up and
    running so fast. First, we will notice that we have a bunch of Rollup-based dependencies.
    Rollup is a module bundler for JavaScript that also has a rich set of tools to
    do many other tasks. It is similar to webpack or Parcel, but it is the tool that
    Svelte has decided to rely on. We will look at Rollup in more depth in [Chapter
    12](6662ad13-783a-440b-9565-8a75223284da.xhtml), *Building and Deploying a Full
    Web Application*. Just know that it is compiling and bundling our code for us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些命令，我们现在有一个位于`localhost:5000`的运行中的Svelte应用程序。让我们看看让我们如此快速启动的`package.json`中有什么。首先，我们会注意到我们有一堆基于Rollup的依赖项。Rollup是JavaScript的模块捆绑器，还有一套丰富的工具来执行许多其他任务。它类似于webpack或Parcel，但这是Svelte决定依赖的工具。我们将在[第12章](6662ad13-783a-440b-9565-8a75223284da.xhtml)中更深入地了解Rollup，*构建和部署完整的Web应用程序*。只需知道它正在为我们编译和捆绑我们的代码。
- en: It also seems that we got a `sirv` called (as can be seen in the `package.json`
    file). If we look up `sirv` inside `npm`, we will see that it is a static asset
    server, but, instead of looking for the files directly on the filesystem (which
    is quite an expensive operation), it caches the request headers and responses
    in memory for a certain period of time. This allows it to serve assets that may
    have already been served quickly, since it only has to look at its own memory
    instead of doing an I/O operation to look for the asset. The **command-line interface**
    (**CLI**) allows us to set up the server quite quickly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我们有一个名为`sirv`的东西（可以在`package.json`文件中看到）。如果我们在`npm`中查找`sirv`，我们会发现它是一个静态资产服务器，但是，它不是直接在文件系统上查找文件（这是一个非常昂贵的操作），而是将请求头和响应缓存在内存中一段时间。这使得它能够快速提供可能已经被提供的资产，因为它只需要查看自己的内存，而不是进行I/O操作来查找资产。**命令行界面**（**CLI**）使我们能够快速设置服务器。
- en: 'Finally, we start our application in dev mode. If we look at the `scripts`
    section of the `package.json` file, we will see that it runs the following command: `run-p
    start:dev autobuild`. The `run-p` command says to run all subsequent commands
    in parallel. The `start:dev` command says to start our `sirv` server up in dev
    mode, and the `autobuild` command tells Rollup to compile and watch our code.
    This means that whenever we make changes to the files, it will automatically build
    for us. Let''s quickly see this in action. Let''s go into the `src` folder and
    make a change to the `App.svelte` file. Add the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以开发模式启动我们的应用程序。如果我们查看`package.json`文件的`scripts`部分，我们会看到它运行以下命令：`run-p start:dev
    autobuild`。`run-p`命令表示并行运行所有后续命令。`start:dev`命令表示在开发模式下启动我们的`sirv`服务器，`autobuild`命令告诉Rollup编译和监视我们的代码。这意味着每当我们对文件进行更改时，它都会自动为我们构建。让我们快速看看它的运行情况。让我们进入`src`文件夹并对`App.svelte`文件进行更改。添加以下内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will notice that our web page has automatically updated, and we now have
    a reactive web page based on an event! This is really nice when we are in development
    mode since we don't have to keep triggering the compiler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到我们的网页已经自动更新，现在我们有一个基于事件的响应式网页！这在开发模式下非常好，因为我们不必不断触发编译器。
- en: The editor of choice in these examples is VS Code. If we head to the extensions
    section of VS Code, there is a nice plugin for Svelte. We can utilize this plugin
    for syntax highlighting and some alerts when we are doing something wrong. If
    the preferred editor does not have a Svelte plugin, try to at least get the HTML
    highlighting enabled for the editor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的首选编辑器是VS Code。如果我们转到VS Code的扩展部分，那里有一个很好的Svelte插件。我们可以利用这个插件进行语法高亮和一些警报，当我们做错事时。如果首选编辑器没有Svelte插件，请尝试至少启用编辑器的HTML高亮显示。
- en: 'Alright: this simple example already gives us plenty to look at. First, the
    `App.svelte` file gives us a similar syntax to Vue files. We have a section for
    JavaScript, a section for styling, and a section for our enhanced HTML. We have
    exported two variables, called `name` and `counter`. We also have a function that
    we are utilizing in the click handler of our button. We have also enabled a style
    for our `h1` element.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的：这个简单的例子已经给了我们很多东西可以看。首先，`App.svelte`文件给我们提供了类似Vue文件的语法。我们有一个JavaScript部分，一个样式部分，和一个增强的HTML部分。我们导出了两个变量，名为`name`和`counter`。我们还有一个函数，我们在按钮的点击处理程序中使用。我们还为我们的`h1`元素启用了样式。
- en: It looks like the curly braces add the one-way data binding that we expect from
    these reactive frameworks. It also looks like we attach events in a simple `on:<event>`
    binding, instead of utilizing the built-in `on<event>` system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来花括号添加了我们从这些响应式框架中期望的单向数据绑定。它看起来也像是我们通过简单的`on:<event>`绑定来附加事件，而不是利用内置的`on<event>`系统。
- en: If we now head into the `main.js` file, we will see that we are importing the
    Svelte file that we were just looking at. We then create a new *app* (it should
    look familiar to other reactive frameworks) and we target the body of the document
    with our application. On top of this, we are setting up some properties, the `name`
    and `counter` variables that we exported before. We then export this as the default
    export for this file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在进入`main.js`文件，我们会看到我们正在导入刚刚查看的Svelte文件。然后我们创建一个新的*app*（它应该看起来很熟悉，类似其他响应式框架），并且将我们的应用程序定位到文档的主体。除此之外，我们还设置了一些属性，即我们之前导出的`name`和`counter`变量。然后我们将其作为此文件的默认导出进行导出。
- en: 'All of this should seem quite similar to the previous chapter, when we looked
    at the class and module system that is built into the browsers. Svelte has just
    piggybacked on these similar concepts to write their compiler. Now, we should
    take a look at the output of the compilation process. We will notice that we have
    a `bundle.css` and a `bundle.js` file. If we first take a look at the `bundle.css`
    file that was generated, we will see something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该与前一章非常相似，当我们查看内置于浏览器中的类和模块系统时。Svelte只是借用了这些类似的概念来编写他们的编译器。现在，我们应该看一下编译过程的输出。我们会注意到我们有一个`bundle.css`和一个`bundle.js`文件。如果我们首先查看生成的`bundle.css`文件，我们会看到类似以下的内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Essentially, Svelte is *mimicking* web components by putting them under a unique
    namespace, in this case, `svelte-i7qo5m`. This is quite straightforward, and those
    that have utilized other systems will notice that this is how a lot of frameworks
    create scoped stylesheets.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Svelte通过将它们放在一个唯一的命名空间下来*模仿*Web组件，这种情况下是`svelte-i7qo5m`。这非常简单，那些使用过其他系统的人会注意到这是许多框架创建作用域样式表的方式。
- en: 'Now, if we go into the `bundle.js` file we will see quite a different story.
    First, we have an **Immediately Invoked Function Expression** (**IIFE**), which
    is the live reload code. Next, we have another IIFE that is assigning our application
    to a global variable called `app`. The code inside then has a bunch of boilerplate
    code such as `noop`, `run`, and `blank_object`. We also can see that Svelte wraps
    many of the built-in methods, such as the DOM''s `appendChild` and `createElement`
    APIs. This can be seen in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入`bundle.js`文件，我们会看到一个完全不同的情况。首先，我们有一个**立即调用的函数表达式**（**IIFE**），这是实时重新加载代码。接下来，我们有另一个IIFE，它将我们的应用程序分配给一个名为`app`的全局变量。然后，代码内部有一堆样板代码，如`noop`，`run`和`blank_object`。我们还可以看到Svelte包装了许多内置方法，例如DOM的`appendChild`和`createElement`API。以下代码可以看到：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'They have even wrapped the `addEventListener` system in their own form so they
    can control callbacks and lifetime events. This can be seen with the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 他们甚至将`addEventListener`系统包装在自己的形式中，以便他们可以控制回调和生命周期事件。以下代码可以看到：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: They then have a bunch of arrays that they are utilizing as queues for the various
    events. They loop through them and pop and run the events as they come up. This
    can is seen in the flush method that they have laid out. One interesting note
    is that they have `seen_callbacks` set. This is so that they stop infinite looping
    by counting methods/events that can cause an infinite loop. For example, component
    *A* gets an update that subsequently sends an update to component *B*, which then
    sends an update to component *A*. `WeakSet` may have been a better choice here,
    but they have opted to utilize the regular `Set` since it will be dumped once
    the flush method has finished.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 他们随后有一堆数组，它们被用作各种事件的队列。他们循环遍历这些数组，弹出并运行事件。这可以在他们设计的flush方法中看到。有一个有趣的地方是他们设置了`seen_callbacks`。这是为了通过计算可能导致无限循环的方法/事件来阻止无限循环。例如，组件*A*得到一个更新，随后发送一个更新给组件*B*，然后组件*B*再发送一个更新给组件*A*。在这里，`WeakSet`可能是一个更好的选择，但他们选择使用常规的`Set`，因为一旦flush方法完成，它将被清除。
- en: One of the final functions that would be good to look at is the `create_fragment`
    method. We will notice that it returns an object that has a create function named
    `c`. As we can see, this creates the HTML elements that we had in our Svelte file.
    We will then see an `m` property, which is the mount function that adds our DOM
    elements to the actual document. The `p` property updates the properties that
    we have bound to this Svelte component (in this case, the `name` and `counter`
    properties). Finally, we have the `d` property, which relates to the `destroy`
    method and removes all the DOM elements and the DOM events.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好查看的最终函数是`create_fragment`方法。我们会注意到它返回一个对象，其中有一个名为`c`的create函数。正如我们所看到的，这将创建我们在Svelte文件中拥有的HTML元素。然后我们会看到一个`m`属性，这是将我们的DOM元素添加到实际文档中的mount函数。`p`属性更新了我们绑定到这个Svelte组件的属性（在这种情况下是`name`和`counter`属性）。最后，我们有`d`属性，它与`destroy`方法相关，它会删除所有DOM元素和DOM事件。
- en: Looking through this code, we can see that Svelte is utilizing a lot of the
    concepts that we would use if we were building a UI from scratch and utilizing
    the DOM API ourselves, but they have just wrapped it into a bunch of convenient
    wrappers and clever lines of code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这段代码，我们可以看到Svelte正在利用我们如果从头开始构建UI并自己利用DOM API时会使用的许多概念，但他们只是将它包装成一堆方便的包装器和巧妙的代码行。
- en: A great way to understand a library is to read the source code or see what it
    outputs. By doing this, we can find where the magic usually lies. While this may
    not be beneficial right away, it can help us write for the framework or even utilize
    some of the tricks that we see in their code in our own code bases. One way of
    learning is to imitate others.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个库的一个很好的方法是阅读源代码或查看它的输出。通过这样做，我们可以找到魔力通常存在的地方。虽然这可能不会立即有益，但它可以帮助我们为框架编写代码，甚至利用我们在他们的代码中看到的一些技巧来编写我们自己的代码库。学习的一种方式是模仿他人。
- en: Out of all of this, we can see how Svelte states that there is no runtime. They
    are utilizing the basic elements that the DOM gives us in some nice convenient
    wrappers. They also give us a nice file format to write our code in. Even though
    this may seem like some basic code, we are able to write complex applications
    in this style.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，我们可以看到Svelte声称没有运行时。他们利用了DOM提供的基本元素，以一些方便的包装器的形式。他们还为我们提供了一个很好的文件格式来编写我们的代码。尽管这可能看起来像一些基本的代码，但我们能够以这种风格编写复杂的应用程序。
- en: The first application we will write is a simple Todo application. We will be
    adding some of our own ideas to it, but it will be a traditional Todo application
    at the start.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一个应用程序是一个简单的待办事项应用程序。我们将为其添加一些自己的想法，但它起初将是一个传统的待办事项应用程序。
- en: Build the basics – a Todo application
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基础-一个待办事项应用程序
- en: 'To start off our Todo application, let''s go ahead and utilize the template
    that we already have. Now, in most Todo applications, we want to be able to do
    the following things:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的待办事项应用程序，让我们继续使用我们已经有的模板。现在，在大多数待办事项应用程序中，我们希望能够做以下事情：
- en: Add
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加
- en: Remove/mark complete
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除/标记为完成
- en: Update
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: 'So what we have is a basic CRUD application without any server operations.
    Let''s go ahead and write the Svelte HTML that we would expect for this application:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们拥有一个基本的CRUD应用程序，没有任何服务器操作。让我们继续编写我们期望在这个应用程序中看到的Svelte HTML：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have split our Todo application into a Todo component and the general application.
    The Todo element will hold all of our logic for the completion and deletion of
    the element. As we can see from the preceding example, we are doing the following
    things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的待办事项应用程序分成了一个待办事项组件和一个通用应用程序。待办事项元素将包含我们的所有逻辑，用于完成和删除元素。正如我们从前面的例子中看到的，我们正在做以下事情：
- en: We expose the number this task is and the description.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们公开这项任务的编号和描述。
- en: We have a completed property that is hidden from the main application.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个隐藏在主应用程序中的已完成属性。
- en: We have a class for styling a completed item.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个用于样式化已完成项目的类。
- en: The list element with the completion variable is bound to the complete class.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表元素与完成变量绑定到完成类。
- en: The `num` and `description` properties are tied to information.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num`和`description`属性与信息相关联。'
- en: A checkbox is added for when we complete an item.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们完成一个项目时，会添加一个复选框。
- en: And there's a button that will tell our application what we want to be removed.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个按钮，它会告诉我们的应用程序我们想要删除什么。
- en: 'That is quite a bit to digest, but when we put it all together, we will see
    that this holds most of the logic for an individual Todo item. Now, we need to
    add all of the logic for our application. It should look something like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的内容需要消化，但当我们把它们放在一起时，我们会发现这包含了大部分单个待办事项的逻辑。现在，我们需要添加我们应用程序的所有逻辑。它应该看起来像下面这样：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We first import the `Todo` that we created before. We then have `newTodoText`
    as a property bound to our input text. Then, we create a set to store all of our
    `Todos`. Next, we create an `addTodo` method that will be bound to the `click`
    event of our Add Todo button. This will create a new `Todo`, binding the element
    to our unordered list and setting the properties to our set size and input text
    respectively. We reset the `Todo` text, and add a remove listener to destroy the
    `Todo` and also remove it from our set. Finally, we add it to our set.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入我们之前创建的“待办事项”。然后，我们将`newTodoText`作为与我们的输入文本绑定的属性。然后，我们创建一个集合来存储我们所有的“待办事项”。接下来，我们创建一个`addTodo`方法，该方法将绑定到我们的“添加待办事项”按钮的`click`事件上。这将创建一个新的“待办事项”，将元素绑定到我们的无序列表，并将属性设置为我们的集合大小和输入文本。我们重置“待办事项”文本，并添加一个移除监听器来销毁“待办事项”，并从我们的集合中删除它。最后，我们将其添加到我们的集合中。
- en: 'We now have a basic Todo application! All of this logic should be fairly straightforward.
    Let''s add some additional features as we had in a previous chapter. We will add
    the following things to our Todo application to make it a bit more robust and
    useful:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个基本的待办事项应用程序！所有这些逻辑应该都很简单。让我们添加一些额外的功能，就像在上一章中一样。我们将向我们的待办事项应用程序添加以下内容，使其更加健壮和有用：
- en: Have due dates associated with each `Todo`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个“待办事项”都有关联的截止日期
- en: Keep a count of all the `Todos`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持所有“待办事项”的计数
- en: Create filters that will filter based on overdue, completed, and all
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建过期、已完成和全部过滤器
- en: Transitions based on the filters and the addition of each `Todo`
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于过滤器和每个“待办事项”的添加进行过渡
- en: 'First, let''s add a due date to our Todo application. We will add a new exported
    field inside our `Todo.svelte` file called `dueDate`, and we will also add it
    to our template like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的待办事项应用程序添加一个截止日期。我们将在我们的`Todo.svelte`文件中添加一个名为`dueDate`的新导出字段，并将其添加到我们的模板中，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, inside of our `App.svelte` file, we will add a date control and make
    sure that when we add our `Todo` to the list, we also make sure that we put this
    field back in. This should look like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`App.svelte`文件中，我们将添加一个日期控件，并确保当我们将我们的“待办事项”添加到列表时，我们还要确保将此字段放回去。这应该看起来像以下内容：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now have a fully functioning due date system. Next, we will add the number
    of current `Todos` to our application. This is as simple as binding some text
    in a span to the size of our set, as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完全功能的截止日期系统。接下来，我们将在我们的应用程序中添加当前“待办事项”的数量。这只需要将一些文本绑定到我们集合的大小的span中，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alright, now we want to be able to do something with all of the dates and completed
    states. Let''s add some filters so we can remove `Todos` that do not fit our criteria.
    We will be adding the completed and overdue filters. We are going to make these
    checkboxes since an item can be both overdue and completed at the same time:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们想要对所有日期和已完成状态做一些处理。让我们添加一些过滤器，这样我们就可以删除不符合我们条件的“待办事项”。我们将添加已完成和过期过滤器。我们将把它们做成复选框，因为一项任务可以同时过期和已完成：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our handle filter logic should look something like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理过滤逻辑应该看起来像以下内容：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to make sure that we have the same hide logic for any new `Todo`
    items:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保对任何新的“待办事项”项目都有相同的隐藏逻辑：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, our `Todo.svelte` component should look like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`Todo.svelte`组件应该看起来像以下内容：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Most of this should look familiar, except for the top portion. There are special
    tags that we can add to Svelte files that allow us access to certain properties,
    such as the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大部分应该看起来很熟悉，除了顶部部分。我们可以在Svelte文件中添加特殊标签，以便访问某些属性，例如以下内容：
- en: '`<svelte:window>` gives us access to the window events.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelte:window>` 给了我们访问窗口事件的权限。'
- en: '`<svelte:body>` gives us access to the body events.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelte:body>` 给了我们访问body事件的权限。'
- en: '`<svelte:head>` gives us access to the head of the document.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelte:head>` 给了我们访问文档头部的权限。'
- en: '`<svelte:component>` gives us access to ourselves as a DOM element.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelte:component>` 给了我们访问自己作为DOM元素的权限。'
- en: '`<svelete:self>` allows us to contain ourselves (for recursive structures such
    as trees).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelete:self>` 允许我们包含自己（用于递归结构，如树）。'
- en: '`<svelte:options>` allows us to add compiler options to our component.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<svelte:options>` 允许我们向组件添加编译器选项。'
- en: In this case, we want our parent component to be able to access our properties
    through getters/setters, so we set the `accessors` option to `true`. This is how
    we are able to change our hidden property inside of the `App.svelte` file and
    allows us to get properties that are on each `Todo`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望我们的父组件能够通过getter/setter访问我们的属性，因此我们将`accessors`选项设置为`true`。这就是我们能够在`App.svelte`文件中更改我们的隐藏属性，并允许我们获取每个“待办事项”的属性的方式。
- en: 'Finally, let''s add in some fade in and out transitions. Svelte comes with
    some nice animations when we add/remove elements. The one that we are going to
    use is the `fade` animation. So, our `Todo.svelte` file will now have the following
    added:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些淡入淡出的过渡效果。Svelte在添加/删除元素时带有一些不错的动画。我们要使用的是`fade`动画。因此，我们的`Todo.svelte`文件现在将添加以下内容：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The special syntax is for conditional DOM addition/subtraction. The same way
    we can add/remove children with the DOM API, Svelte is doing the same. Next, we
    can see that we added the `in:fade` and `out:fade` directives to the list elements.
    Now, when the element is added or removed from the DOM, it will fade in and out.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特殊的语法是用于条件性DOM添加/删除。就像我们可以用DOM API添加/删除子元素一样，Svelte也在做同样的事情。接下来，我们可以看到我们在列表元素上添加了`in:fade`和`out:fade`指令。现在，当元素从DOM中添加或移除时，它将淡入和淡出。
- en: We now have a fairly functional Todo application. We have filtering logic, `Todos`
    that are tied to due dates, and even a bit of animation. The next step is to clean
    up the code a bit. We can do this with the stores built into Svelte.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个相当功能齐全的待办事项应用程序。我们有过滤逻辑，与截止日期相关的“待办事项”，甚至还有一点动画。下一步是稍微整理一下代码。我们可以通过Svelte内置的存储来实现这一点。
- en: Stores are a way of sharing state without having to do some of the trickery
    that we have had to use in our application (we opened up the accessor system when
    we probably should not have). The shared state between our `Todos` and our main
    application is the overdue and completed filters. Each `Todo` should most likely
    be in control of this property, but we are currently utilizing the accessor option
    and all of the filtering is done in our main application. With a writable store,
    we no longer have to do that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是一种在不必使用一些我们在应用程序中必须使用的技巧的情况下共享状态的方法（当我们可能不应该打开访问者系统时）。我们的`Todos`和我们的主应用程序之间的共享状态是过期和已完成的过滤器。每个`Todo`很可能应该控制这个属性，但我们目前正在利用访问者选项，并且所有的过滤都是在我们的主应用程序中完成的。有了可写存储，我们就不再需要这样做了。
- en: 'First, we write a `stores.js` file like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写一个`stores.js`文件，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we update our `App.svelte` file to not target the `hidden` property in
    the `Todos`, and we bind the `checked` properties of our checkbox inputs to the
    stores like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新我们的`App.svelte`文件，不再针对`Todos`中的`hidden`属性，并将我们的复选框输入的`checked`属性绑定到存储，如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The dollar sign in front of our stores means that these are stores and not
    variables in our scripts. It allows us to update and subscribe to the stores without
    having to unsubscribe from them on destroy. Finally, we can update our `Todo.svelte`
    file to look like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中的存储前面的美元符号表示这些是存储而不是变量。它允许我们在销毁时更新和订阅存储，而无需取消订阅。最后，我们可以更新我们的`Todo.svelte`文件，使其如下所示：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have added the overdue and completed stores to our system. You may have noticed
    that we got rid of the compiler option at the top of the file. We then link our
    `#if` condition to these stores. We have now put the responsibility of hiding
    the `Todos` based on filters on the `Todos` themselves while also removing quite
    a bit of code. It should start to become obvious that there are many ways that
    we can build applications in Svelte and maintain quite a bit of control over our
    application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将过期和已完成的存储添加到我们的系统中。您可能已经注意到，我们已经摆脱了文件顶部的编译器选项。然后我们将我们的`#if`条件链接到这些存储。我们现在已经将隐藏`Todos`的责任放在了`Todos`自身上，同时也删除了相当多的代码。很明显，我们可以以多种方式构建Svelte应用程序，并对应用程序保持相当多的控制。
- en: Before moving onto the next application, go ahead and look at the bundled JavaScript
    and CSS along with adding new features to the application. Next, we are going
    to look at building a weather application and getting data from a server for this
    information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个应用程序之前，继续查看捆绑的JavaScript和CSS，并向应用程序添加新功能。接下来，我们将看看如何构建一个天气应用程序并从服务器获取这些信息。
- en: Getting fancier – a basic weather application
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变得更加花哨-一个基本的天气应用程序
- en: It should be quite obvious that Svelte has built up its compiler to work with
    most of the modern ECMAScript standards. One area where they do not provide any
    sort of wrapper is for fetching data. A good way to add this and see the effects
    is to build a basic weather application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，Svelte已经建立起了与大多数现代ECMAScript标准兼容的编译器。他们没有提供任何获取数据的包装器的领域是在这里。添加这个并看到效果的一个好方法是构建一个基本的天气应用程序。
- en: A weather application, at its core, needs to be able to take in a zip code or
    city and spit out information about the current weather for that region. We can
    also get an outlook for the weather based on this location. Finally, we can also
    save these choices in the browser, so we can use them when we come back to the
    application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 天气应用程序在其核心需要能够输入邮政编码或城市，并输出该地区的当前天气信息。我们还可以根据这个位置得到天气的预测。最后，我们还可以将这些选择保存在浏览器中，这样我们在回到应用程序时就可以使用它们。
- en: 'For our weather data, we are going to pull from [https://openweathermap.org/api](https://openweathermap.org/api).
    Here, the free service will allow us to get the current weather. On top of this,
    we will need an input system that will accept the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的天气数据，我们将从[https://openweathermap.org/api](https://openweathermap.org/api)获取。在这里，免费服务将允许我们获取当前天气。除此之外，我们还需要一个输入系统，可以接受以下内容：
- en: The city/country
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市/国家
- en: The zip code (if no country is given, we will assume US since that is the default
    for the API)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮政编码（如果没有给出国家，我们将假设是美国，因为这是API的默认值）
- en: When we enter the correct value, we will store it in `LocalStorage`. Later in
    the chapter, we will take a more in-depth look at the `LocalStorage` API, but
    just note that it is a key-value storage mechanism in the browser. When we go
    to enter a value for the input, we will get a drop-down of all of our previous
    searches. We will also add the ability to remove any one of these results from
    the list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入正确的值时，我们将把它存储在`LocalStorage`中。在本章的后面，我们将更深入地研究`LocalStorage`API，但请注意它是浏览器中的键值存储机制。当我们输入输入值时，我们将得到所有先前搜索的下拉列表。我们还将添加删除列表中任何一个结果的功能。
- en: 'First, we need to get an API key. To do so, follow these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取一个API密钥。要做到这一点，请按照以下步骤进行：
- en: Go to [https://openweathermap.org/api](https://openweathermap.org/api) and follow
    the instructions to get an API key.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://openweathermap.org/api](https://openweathermap.org/api)并按照说明获取API密钥。
- en: Once we have created an account and verify it, we will be able to add API keys.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个帐户并验证它，我们就能够添加API密钥。
- en: After login, there should be a tab that says **API keys**. If we go to that,
    we should be greeted with a *no api keys* message.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，应该有一个标签，上面写着**API keys**。如果我们去那里，应该会看到一个*no api keys*的消息。
- en: We can create a key and add a name to it if we want (we can just call it `default`).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个密钥并为其添加一个名称（我们可以称之为`default`）。
- en: With this key, we are now able to start calling their server.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个密钥，我们现在可以开始调用他们的服务器。
- en: 'Let''s go ahead and set up a test call. The following code should work:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置一个测试调用。以下代码应该可以工作：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we put this into a code snippet, we should get back a JSON object with a
    bunch of data inside of it. Now we can move onto utilizing Svelte with this API
    to create a nice weather application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些放入代码片段中，我们应该会得到一个包含大量数据的JSON对象。现在我们可以继续使用Svelte来利用这个API创建一个漂亮的天气应用程序。
- en: 'Let''s set up our application in the same way we set up our Todo application.
    Run the following commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与设置Todo应用程序相同的方式设置我们的应用程序。运行以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have started the environment, let''s create a boilerplate application
    with some basic styling. In the `global.css` file, add the following lines to
    the body:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了环境，让我们创建一个带有一些基本样式的样板应用程序。在`global.css`文件中，将以下行添加到body中：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will make sure our elements are both column-based and that they will start
    from the center and grow out. This will give us a nice look for our application.
    Next, we are going to create two Svelte components, a `WeatherInput` and a `WeatherOutput`
    component. Next, we are going to focus on the input.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们的元素都是基于列的，并且它们将从中心开始并向外扩展。这将为我们的应用程序提供一个漂亮的外观。接下来，我们将创建两个Svelte组件，一个`WeatherInput`和一个`WeatherOutput`组件。接下来，我们将专注于输入。
- en: 'We will need to have the following items so we can get the correct input from
    our users:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下项目，以便从用户那里获得正确的输入：
- en: Input for the zip code or the city
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入邮政编码或城市
- en: Input for the country code
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入国家代码
- en: A Submit button
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提交按钮
- en: 'We are also going to add some conditional logic to our application. Instead
    of trying to parse the input, we are going to conditionally render a text or number
    input based on a checkbox to the left of our input. With these ideas, our `WeatherInput.svelte`
    file should look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向我们的应用程序添加一些条件逻辑。我们将根据输入框左侧的复选框有条件地呈现文本或数字输入，而不是尝试解析输入。有了这些想法，我们的`WeatherInput.svelte`文件应该如下所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we have the basic template for our input. First, we create a `zipcode`
    store to conditionally display a number or text input. Then, we create a couple
    of local variables that we will bind to our input values. The `submitData` function
    will submit everything once we are ready to get some type of response. Currently,
    we are just logging the output to the developer console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了我们输入的基本模板。首先，我们创建一个`zipcode`存储，以有条件地显示数字或文本输入。然后，我们创建了一些本地变量，将它们绑定到我们的输入值上。`submitData`函数将在我们准备好获得某种响应时提交所有内容。目前，我们只是将输出记录到开发者控制台中。
- en: For styling, we just added some basic styling for valid versus invalid inputs.
    Our template gives us a checkbox to turn on the `zipcode` feature or to turn it
    off. We then conditionally show the `zipcode` or the city textbox. Each of these
    textboxes has the built-in validation added to it. Next, we added another text
    field to get a country code from our users. Finally, we added a button that will
    go out and check for the data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样式，我们只是为有效和无效的输入添加了一些基本样式。我们的模板给了我们一个复选框，用于打开`zipcode`功能或关闭它。然后我们有条件地显示`zipcode`或城市文本框。每个文本框都添加了内置验证。接下来，我们添加了另一个文本字段，以从用户那里获取国家代码。最后，我们添加了一个按钮，将会去检查数据。
- en: The brackets are heavily utilized in Svelte. One feature of input validation
    is regex based. The field is called a pattern. If we try to utilize brackets in
    here, it will cause the Svelte compiler to fail. Just be aware of this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Svelte中，括号被大量使用。输入验证的一个特性是基于正则表达式的。该字段称为模式。如果我们在这里尝试使用括号，将会导致Svelte编译器失败。请注意这一点。
- en: 'Before we get to the output, let''s go ahead and add some labels to our input
    to make it easier for users to use. The following should do it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行输出之前，让我们先给我们的输入添加一些标签，以使用户更容易使用。以下内容应该可以做到：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For every `input` element, we have wrapped them in a `label` like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`input`元素，我们已经将它们包装在`label`中，如下所示：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this, we have the basic user interface for our `input` element. Now, we
    need to have the `fetch` call actually output to something that can be available
    to our `WeatherOutput` element once we have made it. Instead of just passing this
    data out as props, let''s create a custom store that implements a `gather` method.
    Inside of `stores.js`, we should have something that looks like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们有了`input`元素的基本用户界面。现在，我们需要让`fetch`调用实际输出到可以在我们创建后可用于`WeatherOutput`元素的东西。让我们创建一个自定义存储来实现`gather`方法，而不是只是将这些数据作为props传递出去。在`stores.js`中，我们应该有以下内容：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have now moved the logic of getting the data into a store and we can now
    subscribe to this store to update ourselves. This will mean that we can make the
    `WeatherOutput` component subscribe to this for some basic output. The following
    code should be put into `WeatherOtuput.svelte`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将获取数据的逻辑移到了存储中，现在我们可以订阅这个存储来更新自己。这意味着我们可以让`WeatherOutput`组件订阅这个存储以获得一些基本输出。以下代码应该放入`WeatherOtuput.svelte`中：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All we are doing for now is putting the output of our weather into a paragraph
    element and stringifying it so we can read the output without looking at the console.
    We also need to update our `App.svelte` file and import the `WeatherOutput` component
    like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所做的就是将我们的天气输出放入一个段落元素中，并对其进行字符串化，以便我们可以在不查看控制台的情况下阅读输出。我们还需要更新我们的`App.svelte`文件，并像这样导入`WeatherOutput`组件：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we now test our application, we should get some ugly-looking JSON, but we
    have now tied our two components through the store! Now, all we need to do is
    pretty up the output, and we have a fully functioning weather application! Change
    the styling and the template inside of `WeatherOutput.svelte` to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试我们的应用程序，我们应该会得到一些难看的JSON，但是我们现在通过存储将我们的两个组件联系起来了！现在，我们只需要美化输出，我们就有了一个完全功能的天气应用程序！更改`WeatherOutput.svelte`中的样式和模板如下：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we should add a new control so our users can pick metric or imperial
    units for the output. Add the following to the `WeatherInput.svelte`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该添加一个新的控件，让我们的用户可以选择输出的公制或英制单位。将以下内容添加到`WeatherInput.svelte`中：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will also use a new `metric` store to the `stores.js` file that defaults
    to `false`. With all of this, we should have now have a functioning weather application!
    The only piece that we have left is to add the `LocalStorage` capabilities.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`stores.js`文件中使用一个新的`metric`存储，默认值为`false`。有了这一切，我们现在应该有一个功能齐全的天气应用程序了！我们唯一剩下的部分是添加`LocalStorage`功能。
- en: There are two types of storage that do similar things. They are `LocalStorage`
    and `SessionStorage`. The main difference is how long they will stay cached. `LocalStorage`
    stays until the user deletes the cache or the application developer decides to
    delete it. `SessionStorage` stays in the cache for the lifetime of the page. Once
    the user decides to leave the page, `SessionStorage` will clear out. Leaving the
    page means closing the tab or navigating away; it does not mean reloading the
    page or Chrome crashing and the user recovering the page. It is up to the designer
    which one to use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的存储可以做类似的事情。它们是`LocalStorage`和`SessionStorage`。主要区别在于它们的缓存时间有多长。`LocalStorage`会一直保留，直到用户删除缓存或应用程序开发人员决定删除它。`SessionStorage`在页面的生命周期内保留在缓存中。一旦用户决定离开页面，`SessionStorage`就会清除。离开页面意味着关闭标签页或导航离开；它不意味着重新加载页面或Chrome崩溃并且用户恢复页面。由设计者决定使用哪种方式。
- en: Utilizing `LocalStorage` is quite easy. The object is held on the window in
    our case (if we were in a worker, it would be held on the global object). One
    thing to keep in mind is that when we utilize `LocalStorage`, it converts all
    values to strings, so we will need to convert complex objects if we want to store
    them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`LocalStorage`非常容易。在我们的情况下，该对象保存在窗口上（如果我们在工作程序中，它将保存在全局对象上）。需要记住的一件事是，当我们使用`LocalStorage`时，它会将所有值转换为字符串，因此如果我们想要存储复杂对象，我们需要进行转换。
- en: 'To change our application, let''s create a new component specifically for our
    drop-down. Let''s call it `Dropdown`. First, create a `Dropdown.svelte` file.
    Next, add the following code to the file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改我们的应用程序，让我们专门为我们的下拉列表创建一个新组件。让我们称之为`Dropdown`。首先，创建一个`Dropdown.svelte`文件。接下来，将以下代码添加到文件中：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is quite a bit of code, so let's break down what we have just done. First,
    we are taking our inputs and changing them to a `dropdown` component. We are also
    internalizing a lot of the state for this component. We open up various fields
    for the user to be able to customize the fields themselves. The main field that
    we need to make sure that we set is `name`. This is what we are using for the
    `LocalStorage` key to store our searches.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的代码，让我们分解一下我们刚刚做的事情。首先，我们将我们的输入更改为`dropdown`组件。我们还将许多状态内部化到这个组件中。我们打开各种字段，以便用户能够自定义字段本身。我们需要确保设置的主要字段是`name`。这是我们用于存储搜索的`LocalStorage`键。
- en: Next, we subscribe to the `weather` store. We do not use the actual data, but
    we do get the event so we can add the selection to the store if it is unique (a
    set could be used here instead of an array). We add some basic logic if we want
    to activate the drop-down if we are focused or if we have clicked outside of our
    drop-down. We also add some logic to the click event of the list element (we actually
    add it to the children of the list element) for putting the text into the drop-down
    or removing from our `LocalStorage`. Finally, we add behavior to the `onMount`
    and the `onDestroy` of our component. `onMount` will pull from `localStorage`
    and add this to our inputs list. The `onDestroy` just removes our subscription
    so we do not have a memory leak.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们订阅`weather`存储。我们不使用实际数据，但我们确实获得事件，因此如果选择是唯一的（可以使用集合而不是数组），我们可以将其添加到存储中。如果我们想要激活下拉列表，我们还添加了一些基本逻辑，如果我们聚焦或者点击了下拉列表之外。我们还为列表元素的点击事件添加了一些逻辑（实际上是将其添加到列表元素的子元素），以将文本放入下拉列表或从我们的`LocalStorage`中删除。最后，我们为组件的`onMount`和`onDestroy`添加了行为。`onMount`将从`localStorage`中获取并将其添加到我们的输入列表中。`onDestroy`只是取消了我们的订阅，以防止内存泄漏。
- en: The rest of the styling and the templating should look familiar, except for
    the `bind:this` in the unordered list system. This allows us to bind a variable
    to the element itself. This allows us to deactivate our drop-down list if the
    element is not inside of the list of elements in the event path.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的样式和模板应该看起来很熟悉，除了无序列表系统中的`bind:this`。这允许我们将变量绑定到元素本身。这使我们能够在事件路径中的元素不在列表中时取消激活我们的下拉列表。
- en: 'With this, make the following updates to the `WeatherInput.svelte`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，对`WeatherInput.svelte`进行以下更新：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have now created a semi-reusable `dropdown` component (we do rely on the
    weather store, so it really only works with our application) and have created
    something that looks like a single component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个半可重用的`dropdown`组件（我们依赖于天气存储，因此它实际上只适用于我们的应用程序），并且已经创建了一个看起来像单个组件的东西。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Svelte is an interesting framework in which we compile our code to Vanilla JavaScript.
    It utilizes modern ideas such as modules, templates, and scoped styling. We are
    also able to create reusable components in a simple manner. While there are even
    more optimizations that we could make to the applications that we have built,
    we can see how fast they truly are. While Svelte may not become a mainstream choice
    for application development, it is a great framework to see many of the concepts
    we have explored in previous chapters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte是一个有趣的框架，我们将代码编译成原生JavaScript。它利用现代思想，如模块、模板和作用域样式。我们还能够以简单的方式创建可重用的组件。虽然我们可以对我们构建的应用程序进行更多的优化，但我们可以看到它们确实有多快。虽然Svelte可能不会成为应用程序开发的主流选择，但它是一个很好的框架，可以看到我们在之前章节中探讨的许多概念。
- en: Next, we will take a break from the browser and take a look at how we can utilize
    JavaScript on the server utilizing Node.js. Many of the ideas that we have seen
    here will be applied there. We will also see new ways of coding our applications
    and how we can use one language across the entire web ecosystem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将暂时离开浏览器，看看如何利用Node.js在服务器上使用JavaScript。我们在这里看到的许多想法将被应用在那里。我们还将看到编写应用程序的新方法，以及如何在整个网络生态系统中使用一种语言。
