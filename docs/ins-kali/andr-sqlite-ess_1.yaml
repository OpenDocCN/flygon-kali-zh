- en: Chapter 1. Enter SQLite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 进入SQLite
- en: 'Dr. Richard Hipp, the architect and primary author of SQLite, explains how
    it all began in his interview with *The Guardian* published in June 2007:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的架构师和主要作者Richard Hipp博士在他2007年6月接受《卫报》采访时解释了一切是如何开始的：
- en: '*"I started on May 29 2000\. It''s just over seven years old," he says. He
    was working on a project which used a database server, but from time to time the
    database went offline. "Then my program would give an error message saying that
    the database isn''t working, and I got the blame for this. So I said, this is
    not a demanding application for the database, why don''t I just talk directly
    to the disk, and build an SQL database engine that way? That was how it started."*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我是在2000年5月29日开始的。现在已经七年多了，”他说。他当时正在做一个项目，使用了一个数据库服务器，但数据库不时会离线。“然后我的程序会出错，说数据库不工作了，我就因此受到指责。所以我说，这个数据库对我的应用来说并不是一个很苛刻的要求，为什么我不直接和磁盘对话，然后以这种方式构建一个SQL数据库引擎呢？就是这样开始的。”
- en: 'Before we begin our journey exploring SQLite in the context of Android, we
    would like to inform you of some prerequisites. The following are very basic requirements
    and will require little effort from you:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索Android环境中的SQLite之旅之前，我们想要告诉您一些先决条件。以下是非常基本的要求，您需要付出很少的努力：
- en: You need to ensure that the environment for building Android applications is
    in place. When we say "environment," we refer to the combination of JDK and Eclipse,
    our IDE choice, ADT plugins, and Android SDK tools. In case these are not in place,
    the ADT bundle, which consists of IDE, ADT plugins, Android SDK tools, and platform
    tools, can be downloaded from [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).
    The steps mentioned in the link are pretty self-explanatory. For JDK, you can
    visit Oracle's website to download the latest version and set it up at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要确保Android应用程序构建的环境已经就位。当我们说“环境”时，我们指的是JDK和Eclipse的组合，我们的IDE选择，ADT插件和Android
    SDK工具。如果这些还没有就位，ADT捆绑包中包含了IDE、ADT插件、Android SDK工具和平台工具，可以从[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)下载。链接中提到的步骤非常易懂。对于JDK，您可以访问Oracle的网站下载最新版本并在[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)设置它。
- en: 'You need to have a basic knowledge of Android components and have run more
    than "Hello World" programs on an Android emulator. If not, a very apt guide is
    present on the Android developer site to set up an emulator. We would suggest
    you become familiar with basic Android components: Intent, Service, Content Providers,
    and Broadcast Receiver. The Android developer site has good repositories of samples
    along with documentation. Some of these are as follows:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要对Android组件有基本的了解，并且在Android模拟器上运行过不止“Hello World”程序。如果没有，Android开发者网站上有一个非常合适的指南来设置模拟器。我们建议您熟悉基本的Android组件：Intent、Service、Content
    Providers和Broadcast Receiver。Android开发者网站上有很好的示例库和文档。其中一些如下：
- en: '**Emulator**: [http://developer.android.com/tools/devices/index.html](http://developer.android.com/tools/devices/index.html)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器：[http://developer.android.com/tools/devices/index.html](http://developer.android.com/tools/devices/index.html)
- en: '**Android basics**: [http://developer.android.com/training/basics/firstapp/index.html](http://developer.android.com/training/basics/firstapp/index.html)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android基础：[http://developer.android.com/training/basics/firstapp/index.html](http://developer.android.com/training/basics/firstapp/index.html)
- en: With these things in place, we can now start our foray into SQLite.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些准备，我们现在可以开始探索SQLite了。
- en: 'In this chapter, we will cover the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Why SQLite?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择SQLite？
- en: The SQLite architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite的架构
- en: A quick review of database fundamentals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库基础知识快速回顾
- en: SQLite in Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android中的SQLite
- en: Why SQLite?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择SQLite？
- en: SQLite is an embedded SQL database engine. It is used by prominent names such
    as Adobe in Adobe Integrated Runtime (AIR); Airbus, in their flight software;
    Python ships with SQLite; PHP; and many more. In the mobile domain, SQLite is
    a very popular choice across various platforms because of its lightweight nature.
    Apple uses it in the iPhone and Google in the Android operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个嵌入式SQL数据库引擎。它被广泛应用于诸如Adobe集成运行时（AIR）中的Adobe、空中客车公司的飞行软件、Python等知名公司。在移动领域，由于其轻量级的特性，SQLite是各种平台上非常受欢迎的选择。苹果在iPhone中使用它，谷歌在Android操作系统中使用它。
- en: 'It is used as an application file format, a database for electronic gadgets,
    a database for websites, and as an enterprise RDBMS. What makes SQLite such an
    interesting choice for these and many other companies? Let''s take a closer look
    at the features of SQLite that make it so popular:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它被用作应用程序文件格式，电子设备的数据库，网站的数据库，以及企业关系数据库管理系统。是什么让SQLite成为这些以及许多其他公司的如此有趣的选择呢？让我们更仔细地看看SQLite的特点，看看它为什么如此受欢迎：
- en: '**Zero-configuration**: SQLite is designed in such a manner that it requires
    no configuration file. It requires no installation steps or initial setup; it
    has no server process running and no recovery steps to take even if it crashes.
    There is no server and it is directly embedded in our application. Furthermore,
    no administrator is required to create or maintain a DB instance, or set permissions
    for users. In short, this is a true DBA-less database.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零配置：SQLite被设计成不需要配置文件。它不需要安装步骤或初始设置；它没有运行服务器进程，即使它崩溃也不需要恢复步骤。它没有服务器，直接嵌入在我们的应用程序中。此外，不需要管理员来创建或维护数据库实例，或者为用户设置权限。简而言之，这是一个真正无需DBA的数据库。
- en: '**No-copyright**: SQLite, instead of a license, comes with a blessing. The
    source code of SQLite is in the public domain; you are free to modify, distribute,
    and even sell the code. Even the contributors are asked to sign an affidavit to
    protect from any copyrights warfare that may occur in future.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无版权：SQLite不是以许可证而是以祝福的形式提供。SQLite的源代码是公有领域的；您可以自由修改、分发，甚至出售代码。甚至贡献者也被要求签署一份声明，以保护免受未来可能发生的任何版权纠纷的影响。
- en: '**Cross-platform**: Database files from one system can be moved to a system
    running a different architecture without any hassle. This is possible because
    the database file format is binary and all the machines use the same format. In
    the following chapters, we will be pulling out a database from an Android emulator
    to Windows.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**: 一个系统的数据库文件可以轻松地移动到运行不同架构的系统上。这是可能的，因为数据库文件格式是二进制的，所有的机器都使用相同的格式。在接下来的章节中，我们将从Android模拟器中提取数据库到Windows。'
- en: '**Compact**: An SQLite database is a single ordinary disk file; it comes without
    a server and is designed to be lightweight and simple. These attributes lead to
    a very lightweight database engine. SQLite Version 3.7.8 has a footprint of less
    than 350 KiB (kibibyte) compared to its other SQL database engines, which are
    much larger.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧凑**: 一个SQLite数据库是一个普通的磁盘文件；它没有服务器，被设计成轻量级和简单。这些特性导致了一个非常轻量级的数据库引擎。与其他SQL数据库引擎相比，SQLite
    Version 3.7.8的占用空间小于350 KiB（kibibyte）。'
- en: '**Fool proof**: The code base is well commented, easy to understand, and modular.
    The test cases and test scripts in SQLite have approximately 1084 times more code
    than the source code of SQLite library and they claim 100 percent branch test
    coverage. This level of testing reaffirms the faith instilled in SQLite by developers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防错**: 代码库有很好的注释，易于理解，而且是模块化的。SQLite中的测试用例和测试脚本的代码量大约是SQLite库源代码的1084倍，他们声称测试覆盖了100%的分支。这种级别的测试重新确立了开发者对SQLite的信心。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested readers can read more about branch test coverage from Wikipedia at
    [http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的读者可以在维基百科上阅读更多关于分支测试覆盖的信息，网址为[http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage)。
- en: The SQLite architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite架构
- en: 'The core, SQL compiler, backend, and database form the SQLite architecture:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 核心、SQL编译器、后端和数据库构成了SQLite的架构：
- en: '![The SQLite architecture](img/2951_01_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![SQLite架构](img/2951_01_01.jpg)'
- en: The SQLite interface
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite接口
- en: At the top of the SQLite library stack, according to documentation, much of
    the public interface to the SQLite library is implemented by the `wen.c`, `legacy.c`,
    and `vdbeapi.c` source files. This is the point of communication for other programs
    and scripts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，在SQLite库堆栈的顶部，大部分公共接口是由`wen.c`，`legacy.c`和`vdbeapi.c`源文件实现的。这是其他程序和脚本的通信点。
- en: The SQL compiler
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL编译器
- en: Tokenizer breaks the SQL string passed from the interface into tokens and hands
    the tokens over to the parser, one by one. Tokenizer is hand-coded in C. The parser
    for SQLite is generated by the Lemon parser generator. It is faster than YACC
    and Bison and, at the same time, is thread safe and prevents memory leaks. The
    parser builds a parse tree from the tokens passed by the tokenizer and passes
    the tree to the code generator. The generator produces virtual machine code from
    the input and passes it to the virtual machine as executables. More information
    about the Lemon parser generator can be found at [http://en.wikipedia.org/wiki/Lemon_Parser_Generator](http://en.wikipedia.org/wiki/Lemon_Parser_Generator).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分词器将从接口传递的SQL字符串分解为标记，并逐个将标记传递给解析器。分词器是用C手工编码的。SQLite的解析器是由Lemon解析器生成器生成的。它比YACC和Bison更快，同时是线程安全的，并防止内存泄漏。解析器从分词器传递的标记构建解析树，并将树传递给代码生成器。生成器从输入生成虚拟机代码，并将其作为可执行文件传递给虚拟机。有关Lemon解析器生成器的更多信息，请访问[http://en.wikipedia.org/wiki/Lemon_Parser_Generator](http://en.wikipedia.org/wiki/Lemon_Parser_Generator)。
- en: The virtual machine
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机
- en: The virtual machine, also known as **Virtual Database Engine** (**VDBE**), is
    the heart of SQLite. It is responsible for fetching and changing values in the
    database. It executes the program generated by the code generator to manipulate
    database files. Each SQL statement is first converted into virtual machine language
    for VDBE. Each instruction of VDBE contains an opcode and up to three additional
    operands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机，也被称为**虚拟数据库引擎**（**VDBE**），是SQLite的核心。它负责从数据库中获取和更改值。它执行代码生成器生成的程序来操作数据库文件。每个SQL语句首先被转换为VDBE的虚拟机语言。VDBE的每个指令都包含一个操作码和最多三个附加操作数。
- en: The SQLite backend
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite后端
- en: B-trees, along with Pager and the OS Interface, form the backend of the SQLite
    architecture. B-trees are used to organize the data. The pager on the other hand
    assists B-tree by caching, modifying, and rolling back data. B-tree, when required,
    requests particular pages from the cache; this request is processed by the pager
    in an efficient and reliable manner. The OS Interface, as the name suggests, provides
    an abstraction layer to port to different operating systems. It hides the unnecessary
    details of communicating with different operating systems from SQLite calls and
    handles them on behalf of SQLite.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: B树，连同Pager和OS接口，形成了SQLite架构的后端。B树用于组织数据。Pager则通过缓存、修改和回滚数据来辅助B树。当需要时，B树会从缓存中请求特定的页面；这个请求由Pager以高效可靠的方式处理。OS接口提供了一个抽象层，可以移植到不同的操作系统。它隐藏了与不同操作系统通信的不必要细节，由SQLite调用代表SQLite处理。
- en: These are the internals of SQLite and an application developer in Android need
    not worry about the internals of Android because the SQLite Android libraries
    have effectively used the concept of abstraction and all the complexities are
    hidden. One just needs to master the APIs provided, and that will cater to all
    the possible use cases of SQLite in an Android application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是SQLite的内部，Android应用程序开发者不需要担心Android的内部，因为SQLite Android库有效地使用了抽象的概念，所有的复杂性都被隐藏起来。只需要掌握提供的API，就可以满足在Android应用程序中使用SQLite的所有可能的用例。
- en: A quick review of database fundamentals
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库基础知识的快速回顾
- en: A database, in simple words, is an organized way to store data in a continual
    fashion. Data is saved in tables. A table consists of columns with different datatypes.
    Every row in a table corresponds to a data record. You may think of a table as
    an Excel spreadsheet. From the perspective of object-oriented programming, every
    table in a database usually describes an object (represented by a class). Each
    table column illustrates a class attribute. Every record in a table represents
    a particular instance of that object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库，简单来说，是一种有序的持续存储数据的方式。数据保存在表中。表由不同数据类型的列组成。表中的每一行对应一个数据记录。您可以将表想象成Excel电子表格。从面向对象编程的角度来看，数据库中的每个表通常描述一个对象（由类表示）。每个表列举了一个类属性。表中的每条记录表示该对象的特定实例。
- en: 'Let''s look at a quick example. Let''s assume you have a `Shop` database with
    a table called `Inventory`. This table might be used to store the information
    about all the products in the shops. The `Inventory` table might contain these
    columns: `Product name` (string), `Product Id` (number), `Cost` (number), `In
    stock` (0/1), and `Numbers available` (number). You could then add a record to
    the database for a product named `Shoe`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的例子。假设您有一个名为`Shop`的数据库，其中有一个名为`Inventory`的表。这个表可以用来存储商店中所有产品的信息。`Inventory`表可能包含这些列：`产品名称`（字符串）、`产品ID`（数字）、`成本`（数字）、`库存`（0/1）和`可用数量`（数字）。然后，您可以向数据库中添加一个名为`鞋子`的产品记录：
- en: '| ID | Product name | Product Id | Cost | In stock | Numbers available |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| ID | 产品名称 | 产品ID | 成本 | 库存 | 可用数量 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | Carpet | 340023 | 2310 | 1 | 4 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 地毯 | 340023 | 2310 | 1 | 4 |'
- en: '| 2 | Shoe | 231257 | 235 | 1 | 2 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 鞋子 | 231257 | 235 | 1 | 2 |'
- en: 'Data in the database is supposed to be checked and influenced. The data within
    a table can be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的数据应该经过检查和影响。表中的数据可以如下所示：
- en: Added (with the `INSERT` command)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`INSERT`命令添加
- en: Modified (with the `UPDATE` command)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UPDATE`命令修改
- en: Removed (with the `DELETE` command)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DELETE`命令删除
- en: You may search for particular data within a database by utilizing what is known
    as a **query**. A query (using the `SELECT` command) can involve one table, or
    a number of tables. To generate a query, you must determine the tables, data columns,
    and values of the data of interest using SQL commands. Each SQL command is concluded
    with a semicolon (`;`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用所谓的**查询**在数据库中搜索特定数据。查询（使用`SELECT`命令）可以涉及一个表，或多个表。要生成查询，必须使用SQL命令确定感兴趣的表、数据列和数据值。每个SQL命令都以分号（`;`）结尾。
- en: What is an SQLite statement?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是SQLite语句？
- en: An SQLite statement is written in SQL, which is issued to a database to retrieve
    data or to create, insert, update, or delete data in the database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite语句是用SQL编写的，用于从数据库中检索数据或创建、插入、更新或删除数据库中的数据。
- en: 'All SQLite statements start with any of the keywords: `SELECT`, `INSERT`, `UPDATE`,
    `DELETE`, `ALTER`, `DROP`, and so on, and all the statements end with a semicolon
    (`;`). For instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SQLite语句都以关键字之一开头：`SELECT`、`INSERT`、`UPDATE`、`DELETE`、`ALTER`、`DROP`等，所有语句都以分号（`;`）结尾。例如：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `CREATE TABLE` command is used to create a new table in an SQLite database.
    A `CREATE TABLE` command describes the following attributes of the new table that
    is being created:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`命令用于在SQLite数据库中创建新表。`CREATE TABLE`命令描述了正在创建的新表的以下属性：'
- en: The name of the new table.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新表的名称。
- en: The database in which the new table is created. Tables may be generated in the
    main database, the temp database, or in any database attached.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新表的数据库。表可以在主数据库、临时数据库或任何已连接的数据库中生成。
- en: The name of each column in the table.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中每列的名称。
- en: The declared type of each column in the table.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中每列的声明类型。
- en: A default value or expression for each column in the table.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表中每列的默认值或表达式。
- en: A default relation sequence to be used with each column.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每列使用的默认关系序列。
- en: Preferably, a `PRIMARY KEY` for the table. This will support both single-column
    and composite (multiple-column) primary keys.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好为表设置一个`PRIMARY KEY`。这将支持单列和复合（多列）主键。
- en: A set of SQL constraints for each table. Constraints such as `UNIQUE`, `NOT
    NULL`, `CHECK`, and `FOREIGN KEY` are supported.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表的一组SQL约束。支持`UNIQUE`、`NOT NULL`、`CHECK`和`FOREIGN KEY`等约束。
- en: In some cases, the table will be a `WITHOUT ROWID` table.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，表将是`WITHOUT ROWID`表。
- en: 'The following is a simple SQLite statement to create a table:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个创建表的简单SQLite语句：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `CREATE TABLE` is the command to create a table with the name `TABLE_CONTACTS`.
    `KEY_ID`, `KEY_NAME` and `KEY_NUMBER` are the column IDs. SQLite requires a unique
    ID to be provided for each column. `INTEGER` and `TEXT` are the datatypes associated
    with the corresponding columns. SQLite requires the type of data to be stored
    in a column to be defined at the time of creation of the table. `PRIMARY KEY`
    is the data column **constraint** (rules enforced on data columns in the table).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CREATE TABLE`是创建一个名为`TABLE_CONTACTS`的表的命令。`KEY_ID`、`KEY_NAME`和`KEY_NUMBER`是列ID。SQLite要求为每个列提供唯一ID。`INTEGER`和`TEXT`是与相应列关联的数据类型。SQLite要求在创建表时定义要存储在列中的数据类型。`PRIMARY
    KEY`是数据列的**约束**（对表中的数据列强制执行的规则）。
- en: 'SQLite supports more attributes that can be used for creating a table, for
    instance, let us create a `create table` statement that inputs a default value
    for empty columns. Notice that for `KEY_NAME`, we are providing a default value
    as `xyz` and for the `KEY_NUMBER` column, we are providing a default value of
    `100`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持更多的属性，可用于创建表，例如，让我们创建一个`create table`语句，为空列输入默认值。请注意，对于`KEY_NAME`，我们提供了一个默认值`xyz`，对于`KEY_NUMBER`列，我们提供了一个默认值`100`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, when a row is inserted in the database, these columns will be preinitialized
    with the default values as defined in the `CREATE` SQL statement.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当在数据库中插入一行时，这些列将以`CREATE` SQL语句中定义的默认值进行预初始化。
- en: There are more keywords, but we don't want you to get bored with a huge list.
    We will be covering other keywords in the subsequent chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的关键字，但我们不想让你因为一个庞大的列表而感到无聊。我们将在后续章节中介绍其他关键字。
- en: The SQLite syntax
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite语法
- en: SQLite follows a unique set of rules and guidelines called **syntax**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite遵循一组称为**语法**的独特规则和指南。
- en: 'An important point to be noted is that SQLite is **case-insensitive**, but
    there are some commands that are case-sensitive, for example, `GLOB` and `glob`
    have different meaning in SQLite. Let us look at the SQLite `DELETE` statement''s
    syntax for instance. Although we have used capital letters, replacing them with
    lowercase letters will also work fine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，SQLite是**不区分大小写**的，但有一些命令是区分大小写的，例如，在SQLite中，`GLOB`和`glob`具有不同的含义。让我们以SQLite
    `DELETE`语句的语法为例。尽管我们使用了大写字母，但用小写字母替换它们也可以正常工作：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Datatypes in SQLite
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite中的数据类型
- en: 'SQLite uses a dynamic and weakly typed SQL syntax, whereas most of the SQL
    databases use static, rigid typing. If we look at other languages, Java is a statically
    typed language and Python is a dynamically typed language. So what do we mean
    when we say dynamic or static? Let us look at an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite使用动态和弱类型的SQL语法，而大多数SQL数据库使用静态、严格的类型。如果我们看其他语言，Java是一种静态类型语言，Python是一种动态类型语言。那么当我们说动态或静态时，我们是什么意思呢？让我们看一个例子：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In statically typed languages, this will throw an exception, whereas in a dynamically
    typed language it will work. In SQLite, the datatype of a value is not associated
    with its container, but with the value itself. This is not a cause of concern
    when dealing with statically typed systems, where a value is determined by a container.
    This is because SQLite is backwards compatible with the more common static type
    systems. Hence, the SQL statements that we use for static systems can be used
    seamlessly here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型的语言中，这将引发异常，而在动态类型的语言中，它将起作用。在SQLite中，值的数据类型与其容器无关，而与值本身相关。当处理静态类型系统时，这不是一个问题，其中值由容器确定。这是因为SQLite向后兼容更常见的静态类型系统。因此，我们用于静态系统的SQL语句可以在这里无缝使用。
- en: Storage classes
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储类
- en: 'In SQLite, we have **storage** classes that are more general than datatypes.
    Internally, SQLite stores data in five storage classes that can also be referred
    to as **primitive datatypes**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite中，我们有比数据类型更一般的**存储**类。在内部，SQLite以五种存储类存储数据，也可以称为**原始数据类型**：
- en: '`NULL`: This represents a missing value from the database.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NULL`：这代表数据库中的缺失值。'
- en: '`INTEGER`: This supports a range of signed integers from 1, 2, 3, 4, 6, or
    8 bytes depending on the magnitude of the value. SQLite handles this automatically
    based on the value. At the time of processing in the memory, they are converted
    to the most general 8-byte signed integer form.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTEGER`：这支持带符号整数的范围，从1、2、3、4、6或8个字节，取决于值的大小。SQLite会根据值的大小自动处理这一点。在内存中处理时，它们会被转换为最一般的8字节带符号整数形式。'
- en: '`REAL`: This is a floating point value, and SQLite uses this as an 8-byte IEEE
    floating point number to store such values.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REAL`：这是一个浮点值，SQLite使用它作为8字节IEEE浮点数来存储这些值。'
- en: '`TEXT`: SQLite supports various character encodings, such as UTF-8, UTF-16BE,
    or UTF-16LE. This value is a text string.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT`：SQLite支持各种字符编码，如UTF-8、UTF-16BE或UTF-16LE。这个值是一个文本字符串。'
- en: '`BLOB`: This type stores a large array of binary data, exactly how it was provided
    as input.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOB`：这种类型存储了一个大的二进制数据数组，就像输入时提供的那样。'
- en: 'SQLite itself does not validate if the types written to the columns are actually
    of the defined type, for example, you can write an integer into a string column
    and vice versa. We can even have a single column with different storage classes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite本身不验证写入列的类型是否实际上是定义的类型，例如，您可以将整数写入字符串列，反之亦然。我们甚至可以有一个单独的列具有不同的存储类：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Boolean datatype
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔数据类型
- en: SQLite does not have a separate storage class for Boolean and uses the `Integer`
    class for this purpose. Integer `0` represents the false state whereas `1` represents
    a true state. This means that there is an indirect support for Boolean and we
    can create Boolean type columns only. The catch is, it won't contain the familiar
    `TRUE`/`FALSE` values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有单独的布尔存储类，而是使用`Integer`类来实现这一目的。整数`0`表示假状态，而`1`表示真状态。这意味着SQLite间接支持布尔类型，我们只能创建布尔类型的列。问题是，它不包含熟悉的`TRUE`/`FALSE`值。
- en: The Date and Time datatype
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间数据类型
- en: 'As we saw for the Boolean datatype, there is no storage class for the Date
    and Time datatypes in SQLite. SQLite has five built-in date and time functions
    to help us with it; we can use date and time as integer, text, or real values.
    Moreover, the values are interchangeable, depending on the need of the application.
    For example, to compute the current date, use the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在布尔数据类型中看到的那样，在SQLite中没有日期和时间数据类型的存储类。SQLite有五个内置的日期和时间函数来帮助我们处理它；我们可以将日期和时间用作整数、文本或实数值。此外，这些值是可互换的，取决于应用程序的需要。例如，要计算当前日期，请使用以下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SQLite in Android
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的SQLite
- en: 'The Android software stack consists of core Linux kernel, Android runtime,
    Android libraries that support the Android framework, and finally Android applications
    that run on top of everything. The Android runtime uses **Dalvik virtual machine**
    (**DVM**) to execute the dex code. In newer versions of Android, that is, from
    KitKat (4.4), Android has enabled an experimental feature known as **ART**, which
    will eventually replace DVM. It is based on **Ahead of Time** (**AOT**), whereas
    DVM is based on **Just in Time** (**JIT**). In the following diagram, we can see
    that SQLite provides native database support and is part of the libraries that
    support the application framework along with libraries such as SSL, OpenGL ES,
    WebKit, and so on. These libraries, written in C/C++, run over the Linux kernel
    and, along with the Android runtime, forms the backbone of the application framework,
    as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Android软件堆栈由核心Linux内核、Android运行时、支持Android框架的Android库以及最终运行在所有这些之上的Android应用程序组成。Android运行时使用**Dalvik虚拟机**（**DVM**）来执行dex代码。在较新的Android版本中，即从KitKat（4.4）开始，Android启用了一个名为**ART**的实验性功能，它最终将取代DVM。它基于**Ahead
    of Time**（**AOT**），而DVM基于**Just in Time**（**JIT**）。在下图中，我们可以看到SQLite提供了本地数据库支持，并且是支持应用程序框架的库的一部分，还有诸如SSL、OpenGL
    ES、WebKit等库。这些用C/C++编写的库在Linux内核上运行，并与Android运行时一起构成了应用程序框架的支撑，如下图所示：
- en: '![SQLite in Android](img/2951_01_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Android中的SQLite](img/2951_01_02.jpg)'
- en: 'Before we start exploring SQLite in Android, let''s take a look at the other
    persistent storage alternatives in Android:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索Android中的SQLite之前，让我们先看看Android中的其他持久存储替代方案：
- en: '**Shared preference**: Data is stored in a shared preference in the key-value
    form. The file itself is an XML file containing the key-value pairs. The file
    is present in the internal storage of an application, and access to it can be
    public or private as needed. Android provides APIs to write and read shared preferences.
    It is advised to use this in case we have to save a small collection of such data.
    A general example would be saving the last read position in a PDF, or saving a
    user''s preference to show a rating box.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享偏好**：数据以键值对的形式存储在共享偏好中。文件本身是一个包含键值对的XML文件。该文件位于应用程序的内部存储中，可以根据需要进行公共或私有访问。Android提供了API来写入和读取共享偏好。建议在需要保存少量此类数据时使用此功能。一个常见的例子是保存PDF中的最后阅读位置，或者保存用户的偏好以显示评分框。'
- en: '**Internal/external storage**: This terminology can be a little misleading;
    Android defines two storage spaces to save files. On some devices, you might have
    an external storage device in form of an SD card, whereas on others, you will
    find that the system has partitioned its memory into two parts, to be labeled
    as internal and external. Paths to the external as well as internal storage can
    be fetched by using Android APIs. Internal storage, by default, is limited and
    accessible only to the application, whereas the external storage may or may not
    be available in case it is mounted.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部/外部存储**：这个术语可能有点误导；Android定义了两个存储空间来保存文件。在一些设备上，你可能会有一个外部存储设备，比如SD卡，而在其他设备上，你会发现系统将其内存分成两部分，分别标记为内部和外部。可以使用Android
    API获取外部和内部存储的路径。默认情况下，内部存储是有限的，只能被应用程序访问，而外部存储可能可用，也可能不可用，具体取决于是否已挂载。'
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`android:installLocation` can be used in the manifest to specify the internal/external
    installation location of an application.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:installLocation`可以在清单中使用，指定应用程序的内部/外部安装位置。'
- en: SQLite version
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite版本
- en: 'Since API level 1, Android ships with SQLite. At the time of writing this book,
    the current version of SQLite was 3.8.4.1\. According to the documentation, the
    version of SQLite is 3.4.0, but different Android versions are known to ship with
    different versions of SQLite. We can easily verify this via the use of a tool
    called **SQLite3** present in the `platform-tools` folder inside the Android SDK
    installation folder and Android Emulator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从API级别1开始，Android就内置了SQLite。在撰写本书时，当前版本的SQLite是3.8.4.1。根据文档，SQLite的版本是3.4.0，但已知不同的Android版本会内置不同版本的SQLite。我们可以通过Android
    SDK安装文件夹内的`platform-tools`文件夹中的名为**SQLite3**的工具以及Android模拟器轻松验证这一点。
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need not worry about the different versions of SQLite and should stick to
    3.5.9 for compatibility, or we can go by the saying that API 14 is the new `minSdkVersion`
    and switch it with 3.7.4\. Until and unless you have something very specific to
    a particular version, it will hardly matter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心SQLite的不同版本，应该坚持使用3.5.9以确保兼容性，或者我们可以按照API 14是新的`minSdkVersion`的说法，并将其切换为3.7.4。除非你有特定于某个版本的需求，否则这几乎不重要。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some additional handy SQLite3 commands are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外方便的SQLite3命令如下：
- en: '`.dump`: To print out the contents of a table'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dump`：打印表的内容'
- en: '`.schema`: To print the `SQL CREATE` statement for an existing table'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.schema`：打印现有表的`SQL CREATE`语句'
- en: '`.help`: For instructions'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.help`：获取指令'
- en: Database packages
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库包
- en: The `android.database` package contains all the necessary classes for working
    with databases. The `android.database.SQLite` package contains the SQLite-specific
    classes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`android.database`包含了所有与数据库操作相关的必要类。`android.database.SQLite`包含了特定于SQLite的类。'
- en: APIs
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API
- en: Android provides various APIs to enable us to create, access, modify, and delete
    a database. The complete list can be quite overwhelming; for the sake of brevity,
    we will cover the most important and used ones.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了各种API来创建、访问、修改和删除数据库。完整的列表可能会让人感到不知所措；为了简洁起见，我们将介绍最重要和最常用的API。
- en: The SQLiteOpenHelper class
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLiteOpenHelper类
- en: 'The `SQLiteOpenHelper` class is the first and most essential class of Android
    to work with SQLite databases; it is present in the `android.database.SQLite`
    namespace. `SQLiteOpenHelper` is a helper class that is designed for extension
    and to implement the tasks and actions you deem important when creating, opening,
    and using a database. This helper class is provided by the Android framework to
    work with the SQLite database and helps in managing the database creation and
    version management. The modus operandi would be to extend the class and implement
    tasks and actions as required by our application. `SQLiteOpenHelper` has constructors
    defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLiteOpenHelper`类是Android中用于处理SQLite数据库的第一个和最重要的类；它位于`android.database.SQLite`命名空间中。`SQLiteOpenHelper`是一个辅助类，旨在进行扩展，并在创建、打开和使用数据库时实现您认为重要的任务和操作。这个辅助类由Android框架提供，用于处理SQLite数据库，并帮助管理数据库的创建和版本管理。操作方式是扩展该类，并根据我们的应用程序的要求实现任务和操作。`SQLiteOpenHelper`有以下定义的构造函数：'
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The application context permits access to all the shared resources and assets
    for the application. The `name` parameter consists of the database filename in
    the Android storage. `SQLiteDatabase.CursorFactory` is a factory class that creates
    cursor objects that act as the output set for all the queries you apply against
    SQLite under Android. The application-specific version number for the database
    will be the version parameter (or more particularly, its schema).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序上下文允许访问应用程序的所有共享资源和资产。`name`参数包括Android存储中的数据库文件名。`SQLiteDatabase.CursorFactory`是一个工厂类，用于创建光标对象，充当针对Android下SQLite应用的所有查询的输出集。数据库的应用程序特定版本号将是版本参数（或更确切地说，它的模式）。
- en: The constructor of `SQLiteOpenHelper` is used to create a helper object to create,
    open, or manage a database. The **context** is the application context that allows
    access to all the shared resources and assets. The `name` parameter either contains
    the name of a database or null for an in-memory database. The `SQLiteDatabase.CursorFactory`
    factory creates a cursor object that acts as the result set for all the queries.
    The `version` parameter defines the version number of the database and is used
    to upgrade/downgrade the database. The `errorHandler` parameter in the second
    constructor is used when SQLite reports database corruption.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLiteOpenHelper`的构造函数用于创建一个帮助对象来创建、打开或管理数据库。**context**是允许访问所有共享资源和资产的应用程序上下文。`name`参数要么包含数据库的名称，要么为内存中的数据库为null。`SQLiteDatabase.CursorFactory`工厂创建一个光标对象，充当所有查询的结果集。`version`参数定义了数据库的版本号，并用于升级/降级数据库。第二个构造函数中的`errorHandler`参数在SQLite报告数据库损坏时使用。'
- en: '`SQLiteOpenHelper` will trigger its `onUpgrade()` method if our database version
    number is not at default `1`. Important methods of the `SQLiteOpenHelper` class
    are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据库版本号不是默认的`1`，`SQLiteOpenHelper`将触发其`onUpgrade()`方法。`SQLiteOpenHelper`类的重要方法如下：
- en: '`synchronized void close()`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized void close()`'
- en: '`synchronized SQLiteDatabase getReadableDatabase()`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized SQLiteDatabase getReadableDatabase()`'
- en: '`synchronized SQLiteDatabase getWritableDatabase()`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized SQLiteDatabase getWritableDatabase()`'
- en: '`abstract void onCreate(SQLiteDatabase db)`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract void onCreate(SQLiteDatabase db)`'
- en: '`void onOpen(SQLiteDatabase db)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onOpen(SQLiteDatabase db)`'
- en: '`abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)`'
- en: The synchronized `close()` method closes any open database object. The `synchronized`
    keyword prevents thread and memory consistency errors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同步的`close()`方法关闭任何打开的数据库对象。`synchronized`关键字可以防止线程和内存一致性错误。
- en: The next two methods, `getReadableDatabase()` and `getWriteableDatabase()`,
    are the methods in which the database is actually created or opened. Both return
    the same `SQLiteDatabase` object; the difference lies in the fact that `getReadableDatabase()`
    will return a readable database in case it cannot return a writable database,
    whereas `getWriteableDatabase()` returns a writable database object. The `getWriteableDatabase()`
    method will throw an `SQLiteException` if a database cannot be opened for writing.
    In case of `getReadableDatabase()`, if a database cannot be opened, it will throw
    the same exception.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法`getReadableDatabase()`和`getWriteableDatabase()`是实际创建或打开数据库的方法。两者都返回相同的`SQLiteDatabase`对象；不同之处在于`getReadableDatabase()`在无法返回可写数据库时将返回可读数据库，而`getWriteableDatabase()`返回可写数据库对象。如果无法打开数据库进行写操作，`getWriteableDatabase()`方法将抛出`SQLiteException`。对于`getReadableDatabase()`，如果无法打开数据库，它将抛出相同的异常。
- en: We can use the `isReadOnly()` method of the `SQLiteDatabase` class on the database
    object to know the state of the database. It returns `true` for read-only databases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SQLiteDatabase`类的`isReadOnly()`方法来了解数据库的状态。对于只读数据库，它返回`true`。
- en: Calling either methods will invoke the `onCreate()` method if the database doesn't
    exist yet. Otherwise, it will invoke the `onOpen()` or `onUpgrade()` methods,
    depending on the version number. The `onOpen()` method should check the `isReadOnly()`
    method before updating the database. Once opened, the database is cached to improve
    performance. Finally, we need to call the `close()` method to close the database
    object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这两个方法中的任何一个将在数据库尚不存在时调用`onCreate()`方法。否则，它将调用`onOpen()`或`onUpgrade()`方法，具体取决于版本号。`onOpen()`方法应在更新数据库之前检查`isReadOnly()`方法。一旦打开，数据库将被缓存以提高性能。最后，我们需要调用`close()`方法来关闭数据库对象。
- en: The `onCreate()`, `onOpen()`, and `onUpgrade()` methods are designed for the
    subclass to implement the intended behavior. The `onCreate()` method is called
    when the database is created for the first time. This is the place where we create
    our tables by using SQLite statements, which we saw earlier in the example. The
    `onOpen()` method is triggered when the database has been configured and after
    the database schema has been created, upgraded, or downgraded as necessary. Read/write
    status should be checked here with the help of the `isReadOnly()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreate()`、`onOpen()`和`onUpgrade()`方法是为了子类实现预期行为。当数据库第一次创建时，将调用`onCreate()`方法。这是我们使用SQLite语句创建表的地方，这些语句在前面的示例中已经看到了。当数据库已经配置并且数据库模式已经根据需要创建、升级或降级时，将触发`onOpen()`方法。在这里应该使用`isReadOnly()`方法检查读/写状态。'
- en: The `onUpgrade()` method is called when the database needs to be upgraded depending
    on the version number supplied to it. By default, the database version is `1`,
    and as we increment the database version numbers and release new versions, the
    upgrade will be performed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库需要根据提供的版本号进行升级时，将调用`onUpgrade()`方法。默认情况下，数据库版本是`1`，随着我们增加数据库版本号并发布新版本，将执行升级。
- en: 'A simple example illustrating the use of the SQLiteOpenHelper class is present
    in the code bundle for this chapter; we would be using it for explanation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包中包含了一个演示SQLiteOpenHelper类的简单示例；我们将用它进行解释：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，直接将文件发送到您的电子邮件。
- en: The SQLiteDatabase class
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLiteDatabase类
- en: Now that you are familiar with the helper class that kick-starts the use of
    SQLite databases within Android, it's time to look at the core `SQLiteDatabase`
    class. `SQLiteDatabase` is the base class required to work with an SQLite database
    in Android and provides methods to open, query, update, and close the database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了在Android中启动SQLite数据库使用的辅助类，是时候看看核心的`SQLiteDatabase`类了。`SQLiteDatabase`是在Android中使用SQLite数据库所需的基类，并提供了打开、查询、更新和关闭数据库的方法。
- en: More than 50 methods are available for the `SQLiteDatabase` class, each with
    its own nuances and use cases. Rather than an exhaustive list, we'll cover the
    most important subsets of methods and allow you to explore some of the overloaded
    methods at your leisure. At any time, you can refer to the full online Android
    documentation for the `SQLiteDatabase` class at [http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLiteDatabase`类提供了50多种方法，每种方法都有其自己的细微差别和用例。我们将覆盖最重要的方法子集，而不是详尽的列表，并允许您在闲暇时探索一些重载方法。您可以随时参考[http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html](http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)上的完整在线Android文档了解`SQLiteDatabase`类。'
- en: 'Some methods of the `SQLiteDatabase` class are shown in the following list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`SQLiteDatabase`类的一些方法：
- en: '`public long insert (String table, String nullColumnHack, ContentValues values)`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public long insert (String table, String nullColumnHack, ContentValues values)`'
- en: '`public Cursor query (String table, String[] columns, String selection, String[]
    selectionArgs, String groupBy, String having, String orderBy)`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Cursor query (String table, String[] columns, String selection, String[]
    selectionArgs, String groupBy, String having, String orderBy)`'
- en: '`public Cursor rawQuery(String sql, String[] selectionArgs)`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Cursor rawQuery(String sql, String[] selectionArgs)`'
- en: '`public int delete (String table, String whereClause, String[] whereArgs)`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int delete (String table, String whereClause, String[] whereArgs)`'
- en: '`public int update (String table, ContentValues values, String whereClause,
    String[] whereArgs)`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int update (String table, ContentValues values, String whereClause,
    String[] whereArgs)`'
- en: 'Let us see these `SQLiteDatabase` classes in action with an example. We will
    insert a name and number in our table. Then we will use the raw query to fetch
    data back from the table. After this, we will go through the `delete()` and `update()`
    methods, both of which will take `id` as a parameter to identify which row of
    data in our database table we intend to delete or update:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看这些`SQLiteDatabase`类的实际应用。我们将在表中插入一个名称和数字。然后，我们将使用原始查询从表中获取数据。之后，我们将介绍`delete()`和`update()`方法，这两种方法都将以`id`作为参数，以确定我们打算删除或更新数据库表中的哪一行数据：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ContentValues
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ContentValues
- en: '`ContentValues` is essentially a set of key-value pairs, where the key represents
    the column for the table and the value is the value to be inserted in that column.
    So, in the case of `values.put("COL_1", 1);`, the column is `COL_1` and the value
    being inserted for that column is `1`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentValues`本质上是一组键值对，其中键表示表的列，值是要插入该列的值。因此，在`values.put("COL_1", 1);`的情况下，列是`COL_1`，要插入该列的值是`1`。'
- en: 'The following is an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Cursor
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游标
- en: A query recovers a `Cursor` object. A `Cursor` object depicts the result of
    a query and fundamentally points to one row of the result of the query. With this
    method, Android can buffer the results of the query in a productive manner; as
    it doesn't need to load all of the data into memory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查询会返回一个`Cursor`对象。`Cursor`对象描述了查询的结果，基本上指向查询结果的一行。通过这种方法，Android可以以一种高效的方式缓冲查询结果；因为它不需要将所有数据加载到内存中。
- en: To obtain the elements of the resulting query, you can use the `getCount()`
    method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`getCount()`方法获取查询结果的元素。
- en: To navigate amid individual data rows, you can utilize the `moveToFirst()` and
    `moveToNext()` methods. The `isAfterLast()` method permits you to analyze whether
    the end of the output has arrived.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在各个数据行之间导航，可以利用`moveToFirst()`和`moveToNext()`方法。`isAfterLast()`方法允许您分析输出是否已经结束。
- en: The `Cursor` object provides typed `get*()` methods, for example, the `getLong(columnIndex)`
    and `getString(columnIndex)` methods to gain entry to the column data for the
    ongoing position of the result. `columnIndex` is the number of the column you
    will be accessing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cursor`对象提供了带类型的`get*()`方法，例如`getLong(columnIndex)`和`getString(columnIndex)`方法，以便访问结果的当前位置的列数据。`columnIndex`是您将要访问的列的编号。'
- en: The `Cursor` object also provides the `getColumnIndexOrThrow(String)` method
    that permits you to get the column index for a column name of the table.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cursor`对象还提供了`getColumnIndexOrThrow(String)`方法，允许您获取表的列名的列索引。'
- en: To close the `Cursor` object, the `close()` method call will be used.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭`Cursor`对象，将使用`close()`方法调用。
- en: A database query returns a cursor. This interface provides random read-write
    access to the result set. It points to a row of the query result that enables
    Android to buffer the results effectively since now it is not required to load
    all the data in the memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询返回一个游标。这个接口提供了对结果集的随机读写访问。它指向查询结果的一行，使得Android能够有效地缓冲结果，因为现在不需要将所有数据加载到内存中。
- en: The pointer of the returned cursor points to the 0th location, which is known
    as the first location of the cursor. We need to call the `moveToFirst()` method
    on the `Cursor` object; it takes the cursor pointer to the first location. Now
    we can access the data present in the first record.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的游标指针指向第0个位置，也就是游标的第一个位置。我们需要在`Cursor`对象上调用`moveToFirst()`方法；它将游标指针移动到第一个位置。现在我们可以访问第一条记录中的数据。
- en: Cursor implementations, if from multiple threads, should perform their own synchronization
    when using the cursor. A cursor needs to be closed to free the resource the object
    holds by calling the `close()` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果来自多个线程的游标实现，应在使用游标时执行自己的同步。通过调用`close()`方法关闭游标以释放对象持有的资源。
- en: 'Some other support methods we will encounter are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到一些其他支持方法，如下所示：
- en: 'The `getCount()` method: This returns the numbers of elements in the resulting
    query.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCount()`方法：返回查询结果中元素的数量。'
- en: 'The `get*()` methods: These are used to access the column data for the current
    position of the result, for example, `getLong(columnIndex)` and `getString(columnIndex)`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get*()`方法：用于访问结果的当前位置的列数据，例如，`getLong(columnIndex)`和`getString(columnIndex)`。'
- en: 'The `moveToNext()` method: This moves the cursor to the next row. If the cursor
    is already past the last entry in the result set, it will return `false`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moveToNext()`方法：将游标移动到下一行。如果游标已经超过了结果集中的最后一个条目，它将返回`false`。'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered in this chapter the know-how of SQLite features and its internal
    architecture. We started with a discussion on what makes SQLite so popular by
    looking at its salient features, then we covered the underlying architecture of
    SQLite and went over database fundamentals such as syntax and datatypes, and finally
    moved on to SQLite in Android. We explored the Android APIs for using SQLite in
    Android.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了SQLite的特性和内部架构。我们从讨论SQLite的显著特点开始，然后介绍了SQLite的基本架构，如语法和数据类型，最后转向了Android中的SQLite。我们探索了在Android中使用SQLite的Android
    API。
- en: In the next chapter, we will focus on carrying forward what we have learned
    in this chapter and apply it to build Android applications. We will focus on the
    UI elements and connecting UI to the database components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于将本章学到的知识应用到构建Android应用程序中。我们将专注于UI元素和将UI连接到数据库组件。
