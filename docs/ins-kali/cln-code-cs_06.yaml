- en: Unit Testing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试
- en: Previously, we looked at exception handling, how to implement it properly, and
    how this can be useful to the customer and the programmer when issues occur. In
    this chapter, we will look at how programmers can implement their own **quality
    assurance** (**QA**) to provide quality code that is robust and less likely to
    generate exceptions in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了异常处理，如何正确实施以及在问题发生时对客户和程序员有何用处。在本章中，我们将看看程序员如何实施他们自己的质量保证（QA），以提供健壮的、不太可能在生产中产生异常的优质代码。
- en: We start by looking at why we should test our own code, and what makes a good
    test. We then look at several testing tools that are available to C# programmers.
    Then, we move on to the three pillars of unit testing that are *Fail, Pass, and
    Refactor*. Finally, we look at redundant unit tests and why they should be removed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看为什么应该测试我们自己的代码，以及什么样的测试才算是好测试。然后，我们看看C#程序员可以使用的几种测试工具。然后，我们转向单元测试的三大支柱：失败、通过和重构。最后，我们看看多余的单元测试以及为什么它们应该被删除。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the reasons for a good test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解好测试的原因
- en: Understanding the testing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试工具
- en: TDD methodology practice – fail, pass, and refactor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD方法实践-失败、通过和重构
- en: Removing redundant tests, comments, and dead code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除多余的测试、注释和无用代码
- en: 'By the end of this chapter, you will have gained the following skills:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得以下技能：
- en: Be able to describe the benefits of good code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够描述良好代码的好处
- en: Be able to describe potential negatives that can arise from not unit testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够描述不进行单元测试可能带来的潜在负面影响
- en: Be able to install and use MSTest to write and run unit tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够安装和使用MSTest来编写和运行单元测试
- en: Be able to install and use NUnit to write and run unit tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够安装和使用NUnit来编写和运行单元测试
- en: Be able to install and use Moq to write fake (mock) objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够安装和使用Moq来编写虚假（模拟）对象
- en: Be able to install and use SpecFlow to write software that adheres to customer
    specifications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够安装和使用SpecFlow来编写符合客户规范的软件
- en: Be able to write tests that fail, then make them pass, and then perform any
    necessary refactoring
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编写失败的测试，然后使其通过，然后进行任何必要的重构
- en: Technical Requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To access the code files of this chapter, you can visit this link: [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的代码文件，你可以访问以下链接：[https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH06)。
- en: Understanding the reasons for a good test
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解好测试的原因
- en: As a programmer, it is nice to work on a new development project that you find
    interesting, especially if you are highly motivated to do so. But it can be extremely
    frustrating if you get called away to work on a bug instead. It can be worse if
    it is not your code, and you don't have the full understanding behind the code.
    It is even worse still if it is your own code and you have that *"What was I thinking?"*
    moment! The more you get called away from new development to perform maintenance
    on existing code, the more you begin to appreciate the need for unit testing.
    As this appreciation grows, you begin to see the real benefits of learning testing
    methodologies and techniques such as **Test-Driven Development (TDD)** and **Behavioral-Driven
    Development (BDD)**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，如果你对一个你觉得有趣的新开发项目感到高度积极，那是很不错的。但是，如果你被叫去处理一个错误，那会非常令人沮丧。如果不是你的代码，你对代码背后的完整理解也不足，那情况会更糟。如果是你自己的代码，你会有那种“我在想什么？”的时刻！你越是被叫去处理现有代码的维护工作，你就越能体会到进行单元测试的必要性。随着这种认识的增长，你开始看到学习测试方法和技术（如测试驱动开发（TDD）和行为驱动开发（BDD））的真正好处。
- en: When you've spent a period of time working as a maintenance programmer on other
    people's code, you get to see the good, the bad, and the ugly. Such code can be
    a positive education that opens your eyes to a better way of programming by understanding
    what not to do and why not to do it. The bad code can make you shout *No. Just
    no!* and the ugly code can cause your eyes to bleed and your mind to go numb.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在其他人的代码上担任维护程序员一段时间后，你会看到好的、坏的和丑陋的代码。这样的代码可以让你积极地学习，让你明白编程的更好方式是什么，以及为什么不应该这样做。糟糕的代码会让你大喊“不。就是不行！”丑陋的代码会让你眼睛发红，头脑麻木。
- en: Dealing directly with customers, providing them with technical support, you
    see just how crucial a good customer experience is to the success of the business.
    Conversely, you also get to see how a bad customer experience can lead to some
    very frustrated, angry, and extremely foul-mouthed customers; and how quickly
    sales can be lost due to customer refunds and loss of customers because of very
    harmful customer rants on social media and review sites.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 直接与客户打交道，为他们提供技术支持，你会看到良好的客户体验对业务成功有多么关键。相反，你也会看到糟糕的客户体验如何导致一些非常沮丧、愤怒和极其粗鲁的客户；以及由于客户退款和因社交媒体和评论网站上的恶劣客户抱怨而导致销售迅速流失的情况。
- en: As a tech lead, it is your responsibility to perform technical code reviews
    to ensure that staff adhere to the company's coding guidelines and policies, triage
    bugs, and assist the project manager in managing the people you are responsible
    for leading. It is important as a tech lead to be good at high-level project management,
    requirements gathering and analysis, architectural design, and clean programming.
    You also need to have good people skills.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技术负责人，你有责任进行技术代码审查，以确保员工遵守公司的编码准则和政策，分类错误，并协助项目经理管理你负责领导的人员。作为技术负责人，高水平的项目管理、需求收集和分析、架构设计和清晰的编程是很重要的。你还需要具备良好的人际交往能力。
- en: Your project manager is only interested in delivering a project on time and
    to budget according to the needs of the business. They really don't care about
    how you code the software, only that you get it done on time and to the agreed
    budget. Most importantly, they care that the released software exactly matches
    what the business asks for – no more and no less – and that the software is to
    a very high and professional standard, as the quality of the code can equally
    boost or destroy a company brand. When a project manager is harsh with you, you
    know the business is putting them under increased pressure. And so that pressure
    trickles down to you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目经理只关心按照业务需求按时按预算交付项目。他们真的不关心你如何编写软件，只关心你能否按时按约定预算完成工作。最重要的是，他们关心发布的软件是否完全符合业务要求——不多也不少——以及软件是否达到非常高的专业水准，因为代码的质量同样可以提升或摧毁公司品牌。当项目经理对你很苛刻时，你知道业务正在给他们施加更大的压力。这种压力会传递给你。
- en: As a tech lead, you are sandwiched between the project manager and the team
    working on the project. In your everyday work, you will be running scrum meetings
    and dealing with problems. Those problems may be the coders needing resources
    from the analysts, testers waiting for bugs to be fixed by the developers, and
    so on. But the most difficult job will be to perform peer code reviews and provide
    constructive feedback that gets the desired results without offending people.
    That is why you should take clean coding very seriously, because if you criticize
    a person's code, you open yourself up for a backlash if your own code is not up
    to scratch. But also, you will be the one to get it in the neck from the project
    manager if the software fails testing or goes out with loads of bugs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技术负责人，你处于项目经理和项目团队之间。在日常工作中，你将主持Scrum会议并处理问题。这些问题可能是编码人员需要分析人员的资源，测试人员等待开发人员修复错误，等等。但最困难的工作将是进行同行代码审查并提供建设性反馈，以达到期望的结果而不冒犯人。这就是为什么你应该非常认真地对待清晰的编码，因为如果你批评一个人的代码，如果你自己的代码不合格，你就会招致反弹。此外，如果软件测试失败或出现大量错误，你将成为项目经理的责骂对象。
- en: That is why, as a tech lead, it is a good idea for you to encourage TDD. The
    best way to do that is by *leading by example*. Now I know that even degree-educated
    and experienced programmers can be very stand-offish to TDD. One of the most common
    reasons is that it can be hard to learn and put into practice, and appear to be
    more time consuming, especially when code becomes more complex. I have experienced
    these kinds of objections from my colleagues who prefer not to unit test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为技术负责人，鼓励TDD是一个好主意。最好的方法是*以身作则*。现在我知道，即使是受过学位教育和经验丰富的程序员也可能对TDD持保留态度。最常见的原因之一是学习和实践起来可能很困难，而且在代码变得更加复杂时，TDD可能会显得更加耗时。我曾经从那些不喜欢单元测试的同事那里听到过这种反对意见。
- en: But as a programmer, if you want to be truly confident (such that once you've
    written a piece of code, you can be confident in its quality and that it will
    not be returned to you to fix your own bugs), then TDD is a fantastic way to up
    your game as a programmer. When you learn to test first before you start programming,
    it soon becomes *habitual*. Such a habit, as a programmer, is very useful and
    beneficial to you, especially when there comes a time to find a new position,
    as many employment opportunities advertise for people with TDD or BDD experience.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为一个程序员，如果你想真正自信（一旦你编写了一段代码，你就能对其质量有信心，并且不会被退回来修复自己的错误），那么TDD是提升自己作为程序员水平的绝佳方式。当你学会在开始编程之前先进行测试，这很快就会成为*习惯性*。作为程序员，这样的习惯对你非常有用和有益，尤其是当你需要找新工作时，因为许多就业机会都在招聘具有TDD或BDD经验的人。
- en: Another thing to consider while writing code is that bugs in a simple, non-critical
    note-taking app are not the end of the world. But what if you work in the defense
    or health sectors? Consider a weapon of mass destruction that has been programmed
    to go in a specific direction to hit a specific target in enemy territory, but
    something goes wrong, and the missile aims for civilian populations that belong
    to your allies. Or, consider what would happen if you had a loved one that was
    on critical life support that died because of a bug in the software of the medical
    equipment that was your own fault. Then, what about some safety software going
    wrong on a passenger jet flying over a populated area that causes the plane to
    crash into the ground, killing people on the plane and on the ground?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时需要考虑的另一件事是，简单的、非关键的记事应用中的错误并不是世界末日。但如果你在国防或医疗领域工作呢？想象一下，一种大规模杀伤性武器被编程以朝特定方向击中敌方领土上的特定目标，但出现了问题，导致导弹瞄准了你盟友的平民人口。或者，想象一下，如果你的亲人因为医疗设备软件中的错误而处于危急生命支持状态，最终死亡，而这是你自己的错。然后，再想想，如果一架载有乘客的客机上的安全软件出现问题，导致飞机坠毁在人口密集区，造成机上和地面的人员伤亡，会发生什么？
- en: The more critical the software, the more the use of unit testing techniques
    (such as TDD and BDD) needs to be taken seriously. We will be discussing BDD and
    TDD tools later in this chapter. When writing software, think about how you would
    be affected if you were the customer and something went wrong with the code you
    are writing. How would it affect your family, friends, and colleagues? Also, think
    of the moral and legal implications if you were responsible for a critical failure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 软件越关键，就越需要认真对待单元测试技术（如TDD和BDD）。我们将在本章后面讨论BDD和TDD工具。在编写软件时，想象一下如果你是客户，如果你编写的代码出现问题，你会受到什么影响。这会如何影响你的家人、朋友和同事？此外，想想如果你对关键故障负责的话，会有哪些道德和法律责任。
- en: It is important to understand why, as a programmer, you should learn to test
    your own code. It is true what they say that *"programmers should never test their
    own code"*. But it is only true in the context where the code is finished and
    ready for testing before it goes into production. So while the code is still being
    programmed, programmers should always be testing their own code. Yet some businesses
    are so time-constrained that proper QA is often sacrificed so that the business
    can be the first to market.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，了解为什么应该学会测试自己的代码是很重要的。他们说“程序员永远不应该测试自己的代码”是对的。但这只适用于代码已经完成并准备好进入生产测试之前的情况。因此，在代码仍在编程过程中，程序员应该始终测试自己的代码。然而，一些企业时间非常紧迫，以至于适当的质量保证经常被牺牲，以便企业能够率先上市。
- en: It may be very important for a business to be the first to market, but first
    impressions count. If a business is first to market, and the product has some
    serious flaws that become globally broadcast, this can have a long-lasting negative
    impact on a business. So you must think very carefully as a programmer and do
    your best to ensure that if the software has flaws, you are not the one responsible.
    When things go wrong in a business, heads will roll. And in Teflon Management,
    the managers will pass the guilt for driving ridiculous deadlines from themselves
    all the way down to the programmers that had to meet the deadline and make sacrifices
    to do so.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业来说，率先上市可能非常重要，但第一印象至关重要。如果一个企业率先上市，而产品存在严重缺陷并被全球广播，这可能会对企业产生长期的负面影响。因此，作为程序员，你必须非常谨慎，并尽力确保如果软件存在缺陷，你不是责任人。当企业出现问题时，责任人将会受到惩罚。在不粘锅管理中，管理人员会把推动荒谬的截止日期的罪责从自己身上转嫁到不得不满足截止日期并做出牺牲的程序员身上。
- en: So you see, it is very important as a programmer that you test your code and
    test it often, especially prior to releasing it to the testing team. That is why
    you are actively encouraged to transition into the mindset and habitual behavior
    of writing your tests first, based upon the specification that you currently implementing.
    Your tests should fail to start with. You then write only enough code to get the
    tests to pass, and then you refactor your code as you need to.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为程序员，你测试自己的代码并经常测试是非常重要的，特别是在将其发布给测试团队之前。这就是为什么你被积极鼓励过渡到根据你当前正在实施的规范编写你的测试的思维方式和习惯行为。你的测试应该一开始就失败。然后你只需编写足够的代码来使测试通过，然后根据需要重构你的代码。
- en: It is hard to get started with TDD or BDD. But once you get the hang of it,
    TDD and BDD become second nature. And you will probably find that in the long
    term, you are left with cleaner code that is easy to read and maintain. You may
    also find that your confidence in your ability to modify the code without breaking
    it may also be greatly improved. Obviously, there is more code in the sense that
    you have the production method and the test method(s). But you may actually end
    up writing less code overall, as you will not be adding extra code that you think
    may be needed!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用TDD或BDD可能很困难。但一旦掌握了，TDD和BDD就会变得很自然。你可能会发现，从长远来看，你留下的代码更加清晰易读，易于维护。你可能还会发现，你对修改代码而不破坏它的能力也大大提高了。显然，从某种意义上来说，代码更多了，因为你有生产方法和测试方法。但实际上，你可能会写更少的代码，因为你不会添加你认为可能需要的额外代码！
- en: Picture yourself at your computer with a software specification that you have
    to translate into working software. A bad habit that many programmers have, and
    that I've been guilty of in the past, is that they jump straight into coding without
    doing any real design work. In my experience, this actually prolongs the time
    it takes to develop a piece of code and can often lead to more bugs and code that
    is hard to maintain and extend. In fact, although it appears to be counter-intuitive
    to some programmers, proper planning and design actually speed up coding, especially
    when you factor in maintenance and extensions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自己坐在电脑前，手头有一份软件规范需要翻译成可运行的软件。许多程序员有一个坏习惯，我过去也曾犯过，那就是他们直接开始编码，而没有进行任何真正的设计工作。根据我的经验，这实际上会延长开发代码的时间，并经常导致更多的错误和难以维护和扩展的代码。事实上，尽管对一些程序员来说似乎违反直觉，但适当的规划和设计实际上会加快编码速度，特别是考虑到维护和扩展。
- en: This is where the test team comes in. Before we go any further, let's describe
    use cases, test designs, test cases, and test suites, and how they relate to one
    another.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试团队的作用。在我们进一步讨论之前，让我们描述一下用例、测试设计、测试用例和测试套件，以及它们之间的关系。
- en: A use case explains the process flow for a single operation, such as adding
    a customer record. A test design will comprise one or more test cases that test
    for different scenarios that could take place for the single use case. The test
    cases may be carried out manually, or they may be automated tests that are executed
    by a test suite. A test suite is a piece of software used to discover and run
    tests and to report their outcomes to an end user. The writing of use cases will
    be the role of the business analyst. As for the test design, test cases, and test
    suite, these will be the responsibility of the dedicated test team. Developers
    need not be concerned with putting together the use cases, test designs of test
    cases, and their execution in the test suite. Developers must focus on writing
    and using their unit tests to write code that fails, then runs, and is then refactored
    as necessary.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用例解释了单个操作的流程，比如添加客户记录。测试设计将包括一个或多个测试用例，用于测试单个用例可能发生的不同情景。测试用例可以手动进行，也可以是由测试套件执行的自动化测试。测试套件是用于发现和运行测试并向最终用户报告结果的软件。编写用例将是业务分析师的角色。至于测试设计、测试用例和测试套件，这将是专门的测试团队的责任。开发人员无需担心编写用例、测试设计或测试用例，并在测试套件中执行它们。开发人员必须专注于编写和使用他们的单元测试来编写失败的代码，然后运行，并根据需要进行重构。
- en: Software testers collaborate with programmers. This collaboration normally starts
    at project inception, and continues right through to the end. Both the development
    team and testing team will collaborate by sharing test cases for each product
    backlog item. This process normally consists of writing test cases. For the tests
    to pass, they will have to meet test criteria. These test cases will normally
    be run using a combination of manual testing and some test suite automation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试人员与程序员合作。这种合作通常从项目开始时开始，并持续到最后。开发团队和测试团队将通过共享每个产品待办事项的测试用例来合作。这个过程通常包括编写测试用例。为了通过测试，它们必须满足测试标准。这些测试用例通常将使用手动测试和一些测试套件自动化的组合来运行。
- en: During the development phases, the testers write their QA tests and the developers
    write their unit tests. When developers submit their code to the test team, the
    test team will run through their battery of tests. The outcome of those tests
    will be fed back to the developers and the project stakeholders. If problems are
    encountered, this is known as technical debt. The development team will have to
    factor in time to address the issues raised by the test team. When the test team
    confirms that the software has been completed to the required level of quality,
    then the code is passed on to infrastructure to release into production.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段，测试人员编写他们的QA测试，开发人员编写他们的单元测试。当开发人员将他们的代码提交给测试团队时，测试团队将运行他们的一系列测试。这些测试的结果将反馈给开发人员和项目利益相关者。如果遇到问题，这被称为技术债务。开发团队将不得不考虑解决测试团队提出的问题所需的时间。当测试团队确认软件已经达到所需的质量水平时，代码将被传递给基础设施以发布到生产环境中。
- en: Assuming we are starting a brand new project (also known as a greenfield project),
    we would select the appropriate project type and tick the option to include a
    test project. This would create a solution that consists of our main project and
    the test project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在启动一个全新的项目（也称为绿地项目），我们将选择适当的项目类型并选中包括测试项目的选项。这将创建一个解决方案，包括我们的主要项目和测试项目。
- en: The type of project that we create and any features of projects to be implemented
    will be dependent upon use cases. Use cases are used during system analysis to
    identify, confirm, and organize software requirements. From use cases, test cases
    can be assigned to the acceptance criteria. As a programmer, you can take these
    use cases and their test cases to build up your own unit tests for each test case.
    Your tests are then run as part of a test suite. In Visual Studio 2019, you can
    access the Test Explorer from the View | Test Explorer menu. When you build your
    project, tests will be discovered. When tests are discovered, they are viewed
    in the Test Explorer. You can then run and/or debug your tests in the Test Explorer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的项目类型和要实施的项目特性将取决于用例。用例在系统分析期间用于识别、确认和组织软件需求。从用例中，测试用例可以分配给验收标准。作为程序员，您可以使用这些用例及其测试用例来为每个测试用例编写自己的单元测试。然后，您的测试将作为测试套件的一部分运行。在Visual
    Studio 2019中，您可以从“视图|测试资源管理器”菜单中访问测试资源管理器。当您构建项目时，将会发现测试。发现测试后，它们将在测试资源管理器中显示。然后，您可以在测试资源管理器中运行和/或调试您的测试。
- en: It is worth noting at this stage that it will be the responsibility of the testers
    and not the developers to design tests and come up with a suitable number of test
    cases. They are also responsible for QA once the software leaves the hands of
    the developers. But it is still the responsibility of the developer to unit test
    their code, and this is where test cases can be a real help and motivation for
    writing unit tests in your code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这个阶段，设计测试并提出适当数量的测试用例将是测试人员的责任，而不是开发人员的责任。一旦软件离开开发人员的手，他们还负责QA。但是，单元测试代码的责任仍然是开发人员的责任，这就是测试用例可以在编写代码的单元测试中提供真正帮助和动力的地方。
- en: When the solution is created, the first thing you do is open the provided test
    class. In that test class, you write the pseudocode for what you must accomplish.
    You then go step by step through the pseudocode and add your test methods that
    test each step that must be accomplished in order to reach your goal of a completed
    software project. Each test method that you write is written to fail. You then
    write just enough code to pass the test. Then, once the test passes, you refactor
    your code before progressing to the next test. So, you can see that unit testing
    is not rocket science. But what does it take to write a good unit test?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建解决方案时，您要做的第一件事是打开提供的测试类。在该测试类中，您编写必须完成的伪代码。然后，您逐步执行伪代码，并添加测试方法，测试必须完成的每个步骤，以便达到完成软件项目的目标。您编写的每个测试方法都是为了失败。然后，您只需编写足够的代码来通过测试。然后，一旦测试通过，您就可以在进行下一个测试之前重构代码。因此，您可以看到，单元测试并不是什么高深的科学。但是，编写一个好的单元测试需要什么呢？
- en: Any code that is under test will be expected to provide a specific function.
    A function takes in input and produces output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正在测试中的代码都应该提供特定的功能。一个功能接受输入并产生输出。
- en: In a normally functioning computer program, a method (or function) will have
    an *acceptable* range of inputs and outputs, and an *unacceptable* range of inputs
    and outputs. And so the perfect unit test will test the lowest acceptable value,
    the highest acceptable value, and will provide test cases that are outside of
    the acceptable range of values both high and low.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常运行的计算机程序中，一个方法（或函数）将具有*可接受*范围的输入和输出，以及*不可接受*范围的输入和输出。因此，完美的单元测试将测试最低可接受值，最高可接受值，并提供超出可接受值范围的测试用例，无论高低。
- en: Unit tests must be atomic, which means that they should only test one thing.
    Since methods can be chained together in the same class and even across multiple
    classes in multiple assemblies, it is often useful to provide fake or mock objects
    for the classes under test to keep them atomic. The output must determine whether
    it passes or fails. Good unit tests must never be inconclusive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试必须是原子的，这意味着它们只能测试一件事。由于方法可以在同一个类中链接在一起，甚至可以跨多个程序集中的多个类进行链接，因此为了保持它们的原子性，通常有必要为受测试的类提供虚假或模拟对象。输出必须确定它是通过还是失败。良好的单元测试绝对不能是不确定的。
- en: 'The result of a test should be repeatable, in that it either always passes
    or always fails in given conditions. That is, the same test run over and over
    again should not have different outcomes each time it is run. If it does, then
    it is not repeatable. Unit tests should not have to rely on other tests being
    run before them, and they should be isolated from other methods and classes. You
    should also aim for unit tests that run in milliseconds. Any test that takes one
    second or more to run is taking too long. If code takes longer than a second,
    then you should consider refactoring or implementing a mock object for testing.
    And since we are busy programmers, unit tests should be easy to set up and not
    require a lot of coding or configuration. The following diagram shows the unit
    testing life cycle:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果应该是可重复的，即在特定条件下，它要么总是通过，要么总是失败。也就是说，同一个测试一遍又一遍地运行时，每次运行都不应该有不同的结果。如果有的话，那么它就不是可重复的。单元测试不应该依赖于其他测试在它们之前运行，并且它们应该与其他方法和类隔离开来。您还应该力求使单元测试在毫秒内运行。任何需要一秒或更长时间才能运行的测试都太长了。如果代码运行时间超过一秒，那么您应该考虑重构或实现一个用于测试的模拟对象。由于我们是忙碌的程序员，单元测试应该易于设置，不需要大量编码或配置。以下图表显示了单元测试的生命周期：
- en: '![](img/3012452a-e653-4059-99a1-54f3a4c3ade9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3012452a-e653-4059-99a1-54f3a4c3ade9.png)'
- en: We'll be writing unit tests and mock objects during this chapter. But before
    we do, we'll need to look at some of the tools that are available to us as C#
    programmers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写单元测试和模拟对象。但在此之前，我们需要了解一些作为C#程序员可用的工具。
- en: Understanding the testing tools
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试工具
- en: The testing tools we'll be looking at within Visual Studio are **MSTest**, **NUnit**,
    **Moq**, and **SpecFlow**. Each testing tool creates a console application and
    the relevant test project. NUnit and MSTest are unit testing frameworks. NUnit
    is much older than MSTest, and so has a more mature and full-featured API compared
    to MSTest. I personally prefer NUnit over MSTest.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Visual Studio中查看的测试工具有**MSTest**、**NUnit**、**Moq**和**SpecFlow**。每个测试工具都会创建一个控制台应用程序和相关的测试项目。NUnit和MSTest是单元测试框架。NUnit比MSTest早得多，因此与MSTest相比，它具有更成熟和功能齐全的API。我个人更喜欢NUnit而不是MSTest。
- en: Moq is different from MSTest and NUnit as it is not a testing framework but
    a mocking framework. A mocking framework replaces the real classes in your project
    with mock (fake) implementations that are used for testing purposes. You can use
    Moq together with MSTest or NUnit. And finally, SpecFlow is a BDD framework. You
    start by writing a feature in a feature file using business language that the
    user and the techy alike will understand. Then a step file is generated for that
    feature. The step file contains the methods as steps necessary to implement that
    feature.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Moq与MSTest和NUnit不同，因为它不是一个测试框架，而是一个模拟框架。模拟框架会用虚拟（假的）实现替换项目中的真实类，用于测试目的。您可以将Moq与MSTest或NUnit一起使用。最后，SpecFlow是一个BDD框架。您首先使用用户和技术人员都能理解的业务语言在一个特性文件中编写一个特性。然后为该特性生成一个步骤文件。步骤文件包含实现该特性所需的方法作为步骤。
- en: By the end of this chapter, you will understand what each tool does and will
    be able to use them in your own projects. So, let's get started by looking at
    MSTest.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解每个工具的作用，并能够在自己的项目中使用它们。因此，让我们开始看看MSTest。
- en: MSTest
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MSTest
- en: In this section, we will install and configure the MSTest Framework. We will
    write a test class with test methods and initialize it. We will perform assembly
    setup and cleanup, class cleanup, and method cleanup, and perform assertions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装和配置MSTest框架。我们将编写一个带有测试方法并初始化的测试类。我们将执行程序集设置和清理、类清理和方法清理，并进行断言。
- en: 'To install the MSTest Framework from the command line in Visual Studio, you
    will need to open the Package Manager Console via Tools | NuGet Package Manager
    | Package Manager Console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio的命令行中安装MSTest框架，您需要通过Tools | NuGet Package Manager | Package
    Manager Console打开Package Manager Console：
- en: '![](img/5b236774-e309-4dfa-b302-588fcceab5f9.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b236774-e309-4dfa-b302-588fcceab5f9.png)'
- en: 'Then, run the following three commands to install the MSTest Framework:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下三个命令来安装MSTest框架：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can add a new project and select Unit Test Project (.NET
    Framework) from the Context | Add menu in the Solution Explorer. See the screenshot
    that follows. When naming test projects, the accepted standard is in the form
    of `<ProjectName>.Tests`. This helps to associate them with the tests and distinguish
    them from the project that is under test:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以添加一个新项目，并在Solution Explorer的Context | Add菜单中选择Unit Test Project (.NET
    Framework)。请参阅以下截图。在命名测试项目时，接受的标准是以`<ProjectName>.Tests`的形式。这有助于将它们与测试关联起来，并将它们与受测试的项目区分开来：
- en: '![](img/8b5325f3-0e39-414a-abbb-65c908b7a64f.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b5325f3-0e39-414a-abbb-65c908b7a64f.png)'
- en: 'The following code is the default unit test code that is generated when you
    add an MSTest project to your solution. As you can see, the class imports the `Microsoft.VisualStudio.TestTools.UnitTesting` namespace.
    The `[TestClass]` attribute identifies to the MS Test Framework that this class
    is a test class. The `[TestMethod]` attribute marks the method as a test method.
    All classes that have the `[TestMethod]` attribute will appear in the test player.
    The `[TestClass]` and `[TestMethod]` attributes are mandatory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是在将MSTest项目添加到解决方案时生成的默认单元测试代码。正如您所看到的，该类导入了`Microsoft.VisualStudio.TestTools.UnitTesting`命名空间。`[TestClass]`属性标识MS测试框架，该类是一个测试类。`[TestMethod]`属性标记该方法为测试方法。所有具有`[TestMethod]`属性的类都将出现在测试播放器中。`[TestClass]`和`[TestMethod]`属性是强制性的：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are other methods and attributes that can optionally be combined to produce
    a complete test execution workflow. These include `[AssemblyInitialize]`, `[AssemblyCleanup]`,
    `[ClassInitialize]`, `[ClassCleanup]`, `[TestInitialize]`, and `[TestCleanup]`.
    As their names imply, the initialization attributes are used to perform any initialization
    at the assembly, class, and method level prior to tests being run. Likewise, the
    cleanup attributes run at the method, class, and assembly level after tests have
    been run to perform any necessary cleanup operations. We will look at each in
    turn and add them to your project as we will see its order of execution when we
    run the final code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法和属性可以选择组合以生成完整的测试执行工作流程。这些包括`[AssemblyInitialize]`、`[AssemblyCleanup]`、`[ClassInitialize]`、`[ClassCleanup]`、`[TestInitialize]`和`[TestCleanup]`。正如它们的名称所暗示的那样，初始化属性用于在运行测试之前在程序集、类和方法级别执行任何初始化。同样，清理属性在测试运行后在方法、类和程序集级别执行以执行任何必要的清理操作。我们将依次查看每个属性，并在运行最终代码时将它们添加到您的项目中，以便了解它们的执行顺序。
- en: 'The `WriteSeparatorLine()` method is a helper method for the purpose of separating
    our testing method outputs. This will help us to more easily follow what''s going
    on with our test class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteSeparatorLine()`方法是一个辅助方法，用于分隔我们的测试方法输出。这将帮助我们更容易地跟踪我们的测试类中发生的情况：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Optionally, assign the `[AssemblyInitialize]` attribute to execute code before
    the tests are executed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，分配`[AssemblyInitialize]`属性以在执行测试之前执行代码：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you can optionally assign the `[ClassInitialize]` attribute to execute
    code once before the tests are executed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以选择分配`[ClassInitialize]`属性以在执行测试之前执行一次代码：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, run the setup code before each unit test by assigning the `[TestInitialize]` attribute
    to a setup method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将`[TestInitialize]`属性分配给设置方法，在每个单元测试之前运行设置代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you have finished your test run, you can optionally assign the `[AssemblyCleanup]` attribute
    to perform any necessary cleanup operations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成测试运行后，可以选择分配`[AssemblyCleanup]`属性以执行任何必要的清理操作：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The optional method marked as `[ClassCleanup]` runs once after all tests in
    the class have been executed. You cannot guarantee when this method will run,
    as it may not run immediately after the execution of all tests:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`[ClassCleanup]`的可选方法在类中的所有测试执行后运行一次。您无法保证此方法何时运行，因为它可能不会立即在所有测试执行后运行：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To perform clean up operations after each test has been run, apply the `[TestCleanup]` attribute
    to the test cleanup method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试运行后执行清理操作，将`[TestCleanup]`属性应用于测试清理方法：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that our code is in place, build it. Then, from the Test menu, select Test
    Explorer. You should see the following test in the Test Explorer. As you can from
    the following screenshot, the test has not yet been run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码已经就位，构建它。然后，从“测试”菜单中，选择“测试资源管理器”。您应该在测试资源管理器中看到以下测试。正如您从以下截图中所看到的，该测试尚未运行：
- en: '![](img/ddfa336a-8927-49a7-a440-fe06d8cc87ef.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddfa336a-8927-49a7-a440-fe06d8cc87ef.png)'
- en: 'So, let''s run our only test. Oh no! Our test has failed, as shown in the following
    screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们运行我们唯一的测试。哦不！我们的测试失败了，如下截图所示：
- en: '![](img/5f5daca3-94d6-43f7-86c2-5ee95570875b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5daca3-94d6-43f7-86c2-5ee95570875b.png)'
- en: 'Update the `TestMethod1()` code as shown in the following snippet, and then
    run the test again:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的片段中所示更新`TestMethod1()`代码，然后再次运行测试：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You see that the test has passed in the Test Explorer, as shown in the screenshot
    that follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到测试在测试资源管理器中已通过，如下截图所示：
- en: '![](img/16ff87f8-3e94-4b04-9129-30ed1b316b5f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16ff87f8-3e94-4b04-9129-30ed1b316b5f.png)'
- en: So, from the previous screenshots, you can see that tests that have not been
    executed are *blue*, tests that fail are *red*, and tests that pass are *green*.
    From Tools | Options | Debugging | General, select Redirect all Output Window
    text to the Immediate Window. Then, select Run | Debug All Tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从先前的截图中，您可以看到尚未执行的测试为*蓝色*，失败的测试为*红色*，通过的测试为*绿色*。从“工具”|“选项”|“调试”|“常规”，选择将所有输出窗口文本重定向到“立即窗口”。然后，选择“运行”|“调试所有测试”。
- en: 'As you run through the tests and the output is printed to Immediate Window,
    it will become apparent in what order the attributes are being executed. The following
    screenshot shows the output from our test methods:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行测试并将输出打印到“立即窗口”时，将清楚地看到属性的执行顺序。以下截图显示了我们测试方法的输出：
- en: '![](img/ca7e3c1b-fac4-4c63-a123-24020262e564.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca7e3c1b-fac4-4c63-a123-24020262e564.png)'
- en: 'As you have seen already, we have used two `Assert` methods—these being `Assert.Fail()`
    and `Assert.IsTrue(true)`. The `Assert` class is very useful and so it pays to
    be aware of the methods available in the class for unit testing. These available
    methods are listed and described as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，我们使用了两个`Assert`方法——`Assert.Fail()`和`Assert.IsTrue(true)`。`Assert`类非常有用，因此了解单元测试类中可用的方法是很值得的。这些可用的方法列在下面并进行描述：
- en: '| **Methods** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Assert.AreEqual()` | Tests whether the specified values are equal and throws
    an exception if the two values are not equal. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreEqual()` | 测试指定的值是否相等，并在两个值不相等时引发异常。|'
- en: '| `Assert.AreNotEqual()` | Tests whether the specified values are unequal and
    throws an exception if the two values are equal. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreNotEqual()` | 测试指定的值是否不相等，并在两个值相等时引发异常。 |'
- en: '| `Assert.ArtNotSame()` | Tests whether the specified objects refer to different
    objects and throws an exception if the two inputs refer to the same object. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ArtNotSame()` | 测试指定的对象是否引用不同的对象，并在两个输入引用相同对象时引发异常。 |'
- en: '| `Assert.AreSame()` | Tests whether the specified objects both refer to the
    same object and throws an exception if the two inputs do not refer to the same
    object. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreSame()` | 测试指定的对象是否都引用同一个对象，并在两个输入不引用相同对象时引发异常。 |'
- en: '| `Assert.Equals()` | This object will always throw with `Assert.Fail`. Hence,
    we can use `Assert.AreEqual` instead. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Equals()` | 此对象将始终使用`Assert.Fail`抛出异常。因此，我们可以使用`Assert.AreEqual`代替。
    |'
- en: '| `Assert.Fail()` | Throws an `AssertFailedException` exception. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Fail()` | 抛出`AssertFailedException`异常。 |'
- en: '| `Assert.Inconclusive()` | Throws an `AssertInconclusiveException` exception.
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.Inconclusive()` | 抛出`AssertInconclusiveException`异常。 |'
- en: '| `Assert.IsFalse()` | Tests whether the specified condition is false and throws
    an exception if the condition is true. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsFalse()` | 测试指定的条件是否为假，并在条件为真时引发异常。 |'
- en: '| `Assert.IsInstanceOfType()` | Tests whether the specified object is an instance
    of the expected type and throws an exception if the expected type is not in the
    inheritance hierarchy of the object. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsInstanceOfType()` | 测试指定的对象是否是预期类型的实例，并在预期类型不在对象的继承层次结构中时引发异常。
    |'
- en: '| `Assert.IsNotInstanceOfType()` | Tests whether the specified object is an
    instance of the wrong type and throws an exception if the specified type is in
    the inheritance hierarchy of the object. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsNotInstanceOfType()` | 测试指定的对象是否是错误类型的实例，并在指定类型在对象的继承层次结构中时引发异常。
    |'
- en: '| `Assert.IsNotNull()` | Tests whether the specified object is non-null and
    throws an exception if it is null. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsNotNull()` | 测试指定的对象是否非null，并在其为null时引发异常。 |'
- en: '| `Assert.IsNull()` | Tests whether the specified object is null and throws
    an exception if it is not null. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsNull()` | 测试指定的对象是否为null，并在其不为null时引发异常。 |'
- en: '| `Assert.IsTrue()` | Tests whether the specified condition is true and throws
    an exception if the condition is false. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.IsTrue()` | 测试指定的条件是否为真，并在条件为假时引发异常。 |'
- en: '| `Assert.ReferenceEquals()` | Determines whether the specified object instances
    are the same instance. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ReferenceEquals()` | 确定指定的对象实例是否是同一个实例。 |'
- en: '| `Assert.ReplaceNullChars()` | Replaces null characters (`''\0''`) with "`\\0`".
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ReplaceNullChars()` | 用"`\\0`"替换空字符（`''\0''`）。 |'
- en: '| `Assert.That()` | Gets the singleton instance of the `Assert` functionality.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.That()` | 获取`Assert`功能的单例实例。 |'
- en: '| `Assert.ThrowsException()` | Tests whether the code specified by delegate
    action throws given an exception of type `T` (and not a derived type) and throws
    `AssertFailedException` if the code does not throw an exception, or throws an
    exception of a type other than `T`. In simple words, this takes a delegate and
    asserts that it throws the expected exception with the expected message. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ThrowsException()` | 测试由委托操作指定的代码是否引发了类型为`T`的给定异常（而不是派生类型），如果代码没有引发异常，或引发了除`T`之外的类型的异常，则引发`AssertFailedException`。简而言之，这需要一个委托，并断言它引发了带有预期消息的预期异常。
    |'
- en: '| `Assert.ThrowsExceptionAsync()` | Tests whether the code specified by delegate
    action throws given the exception of type `T` (and not a derived type) and throws
    `AssertFailedException` if the code does not throw an exception, or throws an
    exception of a type other than `T`. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ThrowsExceptionAsync()` | 测试由委托操作指定的代码是否引发了类型为`T`的给定异常（而不是派生类型），如果代码没有引发异常，或引发了除`T`之外的类型的异常，则引发`AssertFailedException`。
    |'
- en: Now that we have had a look at MSTest, it is time to look at NUnit.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了MSTest，是时候看看NUnit了。
- en: NUnit
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NUnit
- en: 'If NUnit is not installed for Visual Studio, then download and install it via
    Extensions | Manage Extensions. After that, create a new NUnit Test Project (.NET
    Core). The following code contains the default class created by NUnit, called `Tests`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Visual Studio中未安装NUnit，则可以通过Extensions | Manage Extensions下载并安装它。之后，创建一个新的NUnit测试项目（.NET
    Core）。以下代码包含了NUnit创建的默认类，名为`Tests`：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see from the `Test1` method, the test methods also use an `Assert`
    class, as does MSTest for testing assertions in code. The NUnit Assert class makes
    the following methods available to us (note that methods marked as [NUnit] in
    the following table are specific to NUnit; all others are also present in MSTest):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Test1`方法中可以看出，测试方法也使用了`Assert`类，就像MSTest用于测试代码断言一样。 NUnit Assert类为我们提供了以下方法（请注意，以下表中标记为[NUnit]的方法是特定于NUnit的；其他所有方法也存在于MSTest中）：
- en: '| **Methods** | **Description** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Assert.AreEqual()` | Verifies that two items are equal. If they are not
    equal, then an exception is thrown. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreEqual()` | 验证两个项是否相等。如果它们不相等，则引发异常。 |'
- en: '| `Assert.AreNotEqual()` | Verifies that two items are not equal. If they are
    equal, then an exception is thrown. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreNotEqual()` | 验证两个项是否不相等。如果它们相等，则引发异常。 |'
- en: '| `Assert.AreNotSame()` | Verifies that two objects do not refer to the same
    object. If they do, then an exception is thrown. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreNotSame()` | 验证两个对象是否不引用同一个对象。如果是，则引发异常。 |'
- en: '| `Assert.AreSame()` | Verifies that two objects refer to the same object.
    If they don''t, then an exception is thrown. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.AreSame()` | 验证两个对象是否引用同一个对象。如果不是，则引发异常。 |'
- en: '| `Assert.ByVal()` | [NUnit] Applies a constraint to an actual value, succeeding
    if the constraint is satisfied and throwing an assertion exception on failure.
    Used as a synonym for `That` in rare cases where a private setter causes a Visual
    Basic compilation error. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.ByVal()` | [NUnit] 对实际值应用约束，如果约束满足则成功，并在失败时引发断言异常。在私有setter导致Visual
    Basic编译错误的罕见情况下，用作`That`的同义词。 |'
- en: '| `Assert.Catch()` | [NUnit] Verifies that a delegate throws an exception when
    called and returns it. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Catch()` | [NUnit] 验证委托在调用时是否抛出异常，并返回该异常。'
- en: '| `Assert.Contains()` | [NUnit] Verifies whether a value is contained in a
    collection. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Contains()` | [NUnit] 验证值是否包含在集合中。'
- en: '| `Assert.DoesNotThrow()` | [NUnit] Verifies that a method does not throw an
    exception. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '`Assert.DoesNotThrow()` | [NUnit] 验证方法是否不会抛出异常。'
- en: '| `Assert.Equal()` | [NUnit] Do not use. Use `Assert.AreEqual()` instead. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Equal()` | [NUnit] 不要使用。请改用`Assert.AreEqual()`。'
- en: '| `Assert.Fail()` | Throws an `AssertionException`. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Fail()` | 抛出`AssertionException`。'
- en: '| `Assert.False()` | [NUnit] Verifies a condition is false. Throws an exception
    if the condition is true. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '`Assert.False()` | [NUnit] 验证条件是否为假。如果条件为真，则抛出异常。'
- en: '| `Assert.Greater()` | [NUnit] Verifies that the first value is greater than
    the second value. Throws an exception if it is not. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Greater()` | [NUnit] 验证第一个值是否大于第二个值。如果不是，则抛出异常。'
- en: '| `Assert.GreaterOrEqual()` | [NUnit] Verifies that the first value is greater
    than or equal to the second value. Throws an exception if it is not. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '`Assert.GreaterOrEqual()` | [NUnit] 验证第一个值是否大于或等于第二个值。如果不是，则抛出异常。'
- en: '| `Assert.Ignore()` | [NUnit] Throws `IgnoreException` with the message and
    arguments that are passed in. This causes the test to be reported as ignored.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Ignore()` | [NUnit] 抛出带有传入消息和参数的`IgnoreException`。这会导致测试被报告为被忽略。'
- en: '| `Assert.Inconclusive()` | Throws `InconclusiveException` with the message
    and arguments that are passed in. This causes the test to be reported as inconclusive.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Inconclusive()` | 抛出带有传入消息和参数的`InconclusiveException`。这会导致测试被报告为不确定。'
- en: '| `Assert.IsAssignableFrom()` | [NUnit] Verifies that an object may be assigned
    a value of a given type. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsAssignableFrom()` | [NUnit] 验证对象是否可以分配给给定类型的值。'
- en: '| `Assert.IsEmpty()` | [NUnit] Verifies whether a value such as a string or
    collection is empty. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsEmpty()` | [NUnit] 验证值（如字符串或集合）是否为空。'
- en: '| `Assert.IsFalse()` | Verifies whether a condition is false. Throws an exception
    if it is true. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsFalse()` | 验证条件是否为假。如果为真，则抛出异常。'
- en: '| `Assert.IsInstanceOf()` | [NUnit] Verifies that an object is an instance
    of a given type. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsInstanceOf()` | [NUnit] 验证对象是否是给定类型的实例。'
- en: '| `Assert.NAN()` | [NUnit] Verifies that the value is not a number. If it is,
    then an exception is thrown. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '`Assert.NAN()` | [NUnit] 验证值是否不是一个数字。如果是，则抛出异常。'
- en: '| `Assert.IsNotAssignableFrom()` | [NUnit] Verifies that an object is not assignable
    from a given type. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsNotAssignableFrom()` | [NUnit] 验证对象是否不可从给定类型分配。'
- en: '| `Assert.IsNotEmpty()` | [NUnit] Verifies that a string or collection is not
    empty. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsNotEmpty()` | [NUnit] 验证字符串或集合是否不为空。'
- en: '| `Asserts.IsNotInstanceOf()` | [NUnit] Verifies that the object is not an
    instance of a given type. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`Asserts.IsNotInstanceOf()` | [NUnit] 验证对象不是给定类型的实例。'
- en: '| `Assert.InNotNull()` | Verifies that an object is not null. If it is, then
    an exception is thrown. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '`Assert.InNotNull()` | 验证对象是否不为null。如果为null，则抛出异常。'
- en: '| `Assert.IsNull()` | Verifies that an object is null. If it is not, then an
    exception is thrown. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsNull()` | 验证对象是否为null。如果不是，则抛出异常。'
- en: '| `Assert.IsTrue()` | Verifies that a condition is true. If it is false, then
    an exception is thrown. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '`Assert.IsTrue()` | 验证条件是否为真。如果为假，则抛出异常。'
- en: '| `Assert.Less()` | [NUnit] Verifies that the first value is less than the
    second value. If not, then an exception is thrown. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Less()` | [NUnit] 验证第一个值是否小于第二个值。如果不是，则抛出异常。'
- en: '| `Assert.LessOrEqual()` | [NUnit] Verifies that the first value is less than
    or equal to the second value. If not, then an exception is thrown. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '`Assert.LessOrEqual()` | [NUnit] 验证第一个值是否小于或等于第二个值。如果不是，则抛出异常。'
- en: '| `Assert.Multiple()` | [NUnit] Wraps code containing a series of assertions,
    which should all be executed, even if they fail. Failed results are saved and
    reported at the end of the code block. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Multiple()` | [NUnit] 包装包含一系列断言的代码，应该全部执行，即使它们失败。失败的结果将被保存，并在代码块结束时报告。'
- en: '| `Assert.Negative()` | [NUnit] Verifies that a number is negative. If not,
    then an exception is thrown. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Negative()` | [NUnit] 验证数字是否为负数。如果不是，则抛出异常。'
- en: '| `Assert.NotNull()` | [NUnit] Verifies that an object is not null. If it is
    null, then an exception is thrown. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '`Assert.NotNull()` | [NUnit] 验证对象是否不为null。如果为null，则抛出异常。'
- en: '| `Assert.NotZero()` | [NUnit] Verifies that a number is not zero. If it is
    zero, then an exception is thrown. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '`Assert.NotZero()` | [NUnit] 验证数字是否不为零。如果为零，则抛出异常。'
- en: '| `Assert.Null()` | [NUnit] Verifies that an object is null. If not, then an
    exception is thrown. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Null()` | [NUnit] 验证对象是否为null。如果不是，则抛出异常。'
- en: '| `Assert.Pass()` | [NUnit] Throws `SuccessException` with the message and
    arguments that are passed in. This allows a test to be cut short, with a result
    of success returned to NUnit. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Pass()` | [NUnit] 抛出带有传入消息和参数的`SuccessException`。这允许测试被提前结束，并将成功结果返回给NUnit。'
- en: '| `Assert.Positive()` | [NUnit] Verifies that a number is positive. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Positive()` | [NUnit] 验证数字是否为正数。'
- en: '| `Assert.ReferenceEquals()` | [NUnit] Do not use. Throws `InvalidOperationException`.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`Assert.ReferenceEquals()` | [NUnit] 不要使用。抛出`InvalidOperationException`。'
- en: '| `Assert.That()` | Verifies that a condition is true. If not, then an exception
    is thrown. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`Assert.That()` | 验证条件是否为真。如果不是，则抛出异常。'
- en: '| `Assert.Throws()` | Verifies that a delegate throws a particular exception
    when it is called. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Throws()` | 验证委托在调用时是否抛出特定异常。'
- en: '| `Assert.True()` | [NUnit] Verifies that a condition is true. If not, then
    an exception is called. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`Assert.True()` | [NUnit] 验证条件是否为真。如果不是，则调用异常。'
- en: '| `Assert.Warn()` | [NUnit] Issues a warning using the message and arguments
    provided. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Warn()` | [NUnit] 使用提供的消息和参数发出警告。'
- en: '| `Assert.Zero()` | [NUnit] Verifies that a number is zero. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`Assert.Zero()` | [NUnit] 验证数字是否为零。'
- en: 'The NUnit life cycle begins with the `TestFixtureSetup` that is executed once
    before the first test `SetUp`. Then, `SetUp` is executed before each test. After
    each test has executed, `TearDown` is executed. And finally, `TestFixtureTearDown`
    is executed once after the last test `TearDown`. We are now going to update the
    `Tests` class so that we can debug and see the NUnit life cycle in action:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit的生命周期始于`TestFixtureSetup`，在第一个测试`SetUp`之前执行。然后，在每个测试之前执行`SetUp`。每个测试执行完毕后，执行`TearDown`。最后，在最后一个测试`TearDown`之后执行`TestFixtureTearDown`。我们现在将更新`Tests`类，以便我们可以调试并看到NUnit的生命周期在运行中：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have added the `[TestFixture]` to the class and implemented the `IDisposable`
    interface. The `[TextFixture]` attribute is optional for non-parameterized and
    non-generic fixtures. A class will be treated as a `[TextFixture]` as long as
    at least one method is marked with the `[Test]`, `[TestCase]`, or `[TestCaseSource]`
    attributes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在类中添加了`[TestFixture]`并实现了`IDisposable`接口。`[TextFixture]`属性对于非参数化和非泛型的夹具是可选的。只要至少有一个方法被标记为`[Test]`、`[TestCase]`或`[TestCaseSource]`属性，类就会被视为`[TextFixture]`。
- en: 'The `WriteSeparatorLine()` method acts as a separator for our debug output.
    This method will be called at the top of all our methods in the `Tests` class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteSeparatorLine()`方法作为我们调试输出的分隔符。这个方法将在`Tests`类中所有方法的顶部调用：'
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The method marked with the `[OneTimeSetUp]` attribute will only run once before
    any tests in that class are run. Any initialization that is required for all the
    different tests would be carried out here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`[OneTimeSetUp]`属性的方法将在该类中的任何测试运行之前运行一次。这里将执行所有不同测试所需的任何初始化：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The method marked with `[OneTimeTearDown]` is run once after all the tests
    have been run, and before the class is disposed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`[OneTimeTearDown]`属性的方法在所有测试运行后运行一次，并在类被处理之前运行：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The method marked with the `[Setup]` attribute runs once before every test
    method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`[Setup]`属性的方法在每个测试方法之前运行一次：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The method marked with the `[TearDown]` attribute is run once after every test
    method has completed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`[TearDown]`属性的方法在每个测试方法完成后运行一次：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Test2()` method is a test method as denoted by the `[Test]` attribute
    and will be the second test method to run as determined by the `[Order(1)]` attribute.
    This method throws `InconclusiveException`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test2()`方法是一个测试方法，由`[Test]`属性表示，并且将作为第二个测试方法运行，由`[Order(1)]`属性确定。这个方法抛出`InconclusiveException`：'
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Test1()` method is a test method as denoted by the `[Test]` attribute
    and will be the first test method to be run as determined by the `[0rder(0)]` attribute.
    The method passes `SuccessException`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test1()`方法是一个测试方法，由`[Test]`属性表示，并且将作为第一个测试方法运行，由`[0rder(0)]`属性确定。这个方法通过`SuccessException`：'
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Test3()` method is a test method as denoted by the `[Test]` attribute
    and will be the third test method to run as determined by the `[Order(2)]` attribute.
    The method throws `AssertionException`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test3()`方法是一个测试方法，由`[Test]`属性表示，并且将作为第三个测试方法运行，由`[Order(2)]`属性确定。这个方法抛出`AssertionException`：'
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you debug all the tests, your immediate window should look like the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调试所有测试时，你的立即窗口应该看起来像下面的截图：
- en: '![](img/1d3fee70-f43a-4edb-8cdc-c7d7525fa9e1.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d3fee70-f43a-4edb-8cdc-c7d7525fa9e1.png)'
- en: You have now been exposed to MSTest and NUnit, and have seen the testing life
    cycle for each framework in action. It's now time to have a look at Moq.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经接触过MSTest和NUnit，并且已经看到了每个框架的测试生命周期。现在是时候看一下Moq了。
- en: As you can see from the table of NUnit methods compared to the table of MSTest
    methods, NUnit enables more fine-grained unit testing over MSTest and executes
    with better performance, which is why it is more widely used than MSTest.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从NUnit方法表和MSTest方法表的比较中可以看出，NUnit可以实现更精细的单元测试，执行性能更好，因此比MSTest更广泛地使用。
- en: Moq
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Moq
- en: 'A unit test should only test the method under test. See the following diagram. If
    a method under test calls other methods that are either in the current class or
    in different classes, then not only test methods but other methods are also tested:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该只测试被测试的方法。参见下图。如果被测试的方法调用其他方法，这些方法可以是当前类中的方法，也可以是不同类中的方法，那么不仅测试方法，其他方法也会被测试：
- en: '![](img/1d62c94e-84a0-415b-b6e2-31dd12e48f47.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d62c94e-84a0-415b-b6e2-31dd12e48f47.png)'
- en: One way to overcome this is to use mock (fake) objects. The mock object will
    only test the method you want to test, and you can make the mock object work any
    way that you want to. If you were to write your own mock objects, you would soon
    come to appreciate that there is a lot of hard work involved. This may be unacceptable
    in time-sensitive projects, and the more complex your code becomes, the more complex
    your mock objects become.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这个问题的一种方法是使用模拟（虚假）对象。模拟对象只会测试你想要测试的方法，你可以让模拟对象按你想要的方式工作。如果你要编写自己的模拟对象，你很快就会意识到这需要大量的工作。这在时间敏感的项目中可能是不可接受的，而且你的代码变得越复杂，你的模拟对象也变得越复杂。
- en: You will inevitably give it up as a bad job, or you will look for a mocking
    framework that suits your needs. Rhino Mocks and Moq are two mocking frameworks
    for the .NET Framework. For the purposes of this chapter, we will only be looking
    at Moq, which is easier to learn and use compared to Rhino Mocks. For more information
    on Rhino Mocks, visit [http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会放弃这个糟糕的工作，或者你会寻找一个适合你需求的模拟框架。Rhino Mocks和Moq是.NET Framework的两个模拟框架。在本章中，我们只会看Moq，它比Rhino
    Mocks更容易学习和使用。有关Rhino Mocks的更多信息，请访问[http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks)。
- en: When testing using Moq, we start by adding the mock object and then configure
    the mock object to do something. We then assert that the configuration is working
    and that the mock was invoked. These steps enable us to determine that the mock
    is correctly set up. Moq only produces test doubles. It does not test the code.
    You still need a test framework such as NUnit to test your code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Moq进行测试时，我们首先添加模拟对象，然后配置模拟对象执行某些操作。然后我们断言配置是否起作用，并且模拟对象是否被调用。这些步骤使我们能够确定模拟对象是否正确设置。Moq只生成测试替身。它不测试代码。您仍然需要一个像NUnit这样的测试框架来测试您的代码。
- en: We'll now look at an example of using Moq and NUnit together.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一个使用Moq和NUnit的例子。
- en: 'Create a new console application and call it `CH06_Moq`. Add the following
    interface and classes—`IFoo`, `Bar`, `Baz`, and `UnitTests`. Then, via the Nuget
    package manager, install Moq, NUnit, and NUnit3TestAdapter. Update the `Bar` class
    with the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，命名为`CH06_Moq`。添加以下接口和类——`IFoo`、`Bar`、`Baz`和`UnitTests`。然后，通过Nuget包管理器，安装Moq、NUnit和NUnit3TestAdapter。使用以下代码更新`Bar`类：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Bar` class has a virtual property of type `Baz` and a virtual method called
    `Submit()` that returns a Boolean value of false. Now update the `Baz` class as
    follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bar`类有一个虚拟属性，类型为`Baz`，以及一个名为`Submit()`的虚拟方法，返回值为`false`。现在按照以下方式更新`Baz`类：'
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Baz` class has a single virtual property of type string called `Name`.
    Modify the `IFoo` file to contain the following source code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Baz`类有一个名为`Name`的单个虚拟属性，类型为字符串。修改`IFoo`文件，包含以下源代码：'
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `IFoo` interface has a number of properties and methods. As you can see,
    the interface has a reference to the `Bar` class, and we know that the `Bar` class contains
    a reference to the `Baz` class. We will now start updating our `UnitTests` class
    to test our newly-created interface and classes using NUnit and Moq. Modify the
    `UnitTests` class file so that it looks like the code that follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFoo`接口有许多属性和方法。正如您所看到的，该接口引用了`Bar`类，我们知道`Bar`类包含对`Baz`类的引用。我们现在将开始更新我们的`UnitTests`类，使用NUnit和Moq测试我们新创建的接口和类。修改`UnitTests`类文件，使其看起来像下面的代码：'
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, add the `AssertThrows` method that asserts whether a designated exception
    has been thrown or not:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`AssertThrows`方法，断言是否抛出了指定的异常：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `AssertThrows` method is a generic method that will return `true` if your
    method throws the designated exception, and `false` if it does not. We will be
    using this method when we test exceptions further in this chapter. Now, add the
    `DoSomethingReturnsTrue()` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssertThrows`方法是一个通用方法，如果您的方法抛出指定的异常，它将返回`true`，如果没有抛出异常，则返回`false`。在本章的后续测试异常时，我们将使用这个方法。现在，添加`DoSomethingReturnsTrue()`方法：'
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `DoSomethingReturnsTrue()` method creates a new mock implementation of
    the `IFoo` interface. Then it sets up the `DoSomething()` method to accept a string
    containing the word `"ping"`, and then returns `true`. Finally, the method asserts
    that when the `DoSomething()` method is called with the text `"ping"`, the method
    returns a value of `true`. We''ll now implement a similar test method that returns
    `false` if the value is `"tracert"`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoSomethingReturnsTrue()`方法创建了`IFoo`接口的一个新的模拟实现。然后设置`DoSomething()`方法接受包含单词`"ping"`的字符串，并返回`true`。最后，该方法断言当`DoSomething()`方法被调用时，传入文本`"ping"`，方法返回值为`true`。我们现在将实现一个类似的测试方法，如果值为`"tracert"`，则返回`false`：'
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `DoSomethingReturnsFalse()` method follows the same procedure as the `DoSomethingReturnsFalse()`
    method. We create a mock object of the `IFoo` interface, set it up to return `false`
    if the parameter value is `"tracert"`, and then assert that `false` is returned
    for a parameter value of `"tracert"`. Next, we''ll test our arguments:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoSomethingReturnsFalse()`方法遵循与`DoSomethingReturnsFalse()`方法相同的过程。我们创建一个`IFoo`接口的模拟对象，设置它在参数值为`"tracert"`时返回`false`，然后断言参数值为`"tracert"`时返回`false`。接下来，我们将测试我们的参数：'
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `OutArguments()` method creates an implementation of the `IFoo` interface.
    A string that will be used as an out parameter is then declared and assigned the
    value `"ack"`. Next, the `TryParse()` method of the `IFoo` mock object is set
    up to return `true` for an input value of `"ping"` and to output the string value
    of `"ack"`. We then assert that the `outString` is equal to the value `"ack"`.
    The final check asserts that `TryParse()` returns `true` for the input value of
    `"ping"`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutArguments()`方法创建了`IFoo`接口的一个实现。然后声明一个将用作输出参数的字符串，并赋值为`"ack"`。接下来，设置`IFoo`模拟对象的`TryParse()`方法，对输入值`"ping"`返回`true`，并输出字符串值`"ack"`。然后我们断言`outString`等于值`"ack"`。最后的检查断言`TryParse()`对输入值`"ping"`返回`true`：'
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `RefArguments()` method creates an instance of the `Bar` class. Then, a
    mock implementation of the `IFoo` interface is created. The `Submit()` method
    is then set up to return `true` if the reference type passed in is of type `Bar`.
    We then assert that the argument that is passed in is `true` of type `Bar`. In
    our `AccessInvocationArguments()` test method, we create a new implementation
    of the `IFoo` interface:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefArguments()`方法创建了`Bar`类的一个实例。然后，创建了`IFoo`接口的一个模拟实现。然后设置`Submit()`方法，如果传入的引用类型是`Bar`类型，则返回`true`。然后我们断言传入的参数是`Bar`类型的`true`。在我们的`AccessInvocationArguments()`测试方法中，我们创建了`IFoo`接口的一个新实现：'
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we set up the `DoSomethingStringy()` method to convert the input to lowercase
    and return it. Finally, we assert that the string returned is the string passed
    in that has been converted to lowercase:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置`DoSomethingStringy()`方法将输入转换为小写并返回。最后，我们断言返回的字符串是传入的字符串转换为小写后的字符串：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our final test method called `ThrowingWhenInvokedWithSpecificParameters()`,
    we create a mock implementation of the `IFoo` interface. We then configure the
    `DoSomething()` method to throw `InvalidOperationException` when the passed-in
    value is `"reset"`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终测试方法`ThrowingWhenInvokedWithSpecificParameters()`中，我们创建了`IFoo`接口的一个模拟实现。然后配置`DoSomething()`方法，在传入值为`"reset"`时抛出`InvalidOperationException`。
- en: An `ArgumentException` exception of `"command"` is thrown when an empty string
    is passed in. We then assert that `InvalidOperationException` is thrown when the
    input value is `"reset"`. When the input value is an empty string, we assert that
    `ArgumentException` is thrown, with the assertion that the message of `ArgumentException`
    is `"command"`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当传入空字符串时，会抛出一个`ArgumentException`异常。然后我们断言当输入值为`"reset"`时会抛出`InvalidOperationException`。当输入值为空字符串时，我们断言会抛出`ArgumentException`，并断言`ArgumentException`的消息为`"command"`。
- en: You've now seen how to use a mocking framework called Moq to create mock objects
    to test your code using NUnit. The last tool we will now look at is called **SpecFlow**.
    SpecFlow is a BDD tool.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用一个名为Moq的模拟框架来创建模拟对象，以使用NUnit测试你的代码。现在我们要看的最后一个工具是**SpecFlow**。SpecFlow是一个BDD工具。
- en: SpecFlow
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpecFlow
- en: User-focused behavioral tests that are written ahead of the code are the primary
    function behind BDD. BDD is a software development methodology that evolved from
    TDD. You start BDD with a list of features. Features are specifications written
    in a formal business language. This language is understandable by all stakeholders
    on a project. Once the features have been agreed and generated, it is up to the
    developers to then develop step definitions for the feature statements. Once the
    step definitions have been created, the next step is to create the external project
    to implement the feature and add a reference to it. The step definitions are then
    extended to implement the application code for the feature.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用户关注的行为测试是BDD的主要功能，这些测试是在编码之前编写的。BDD是一种从TDD演变而来的软件开发方法。你可以从一系列特性开始BDD。特性是用正式的商业语言编写的规范。这种语言可以被项目中的所有利益相关者理解。一旦特性被同意和生成，开发人员就需要为特性语句开发步骤定义。一旦步骤定义被创建，下一步就是创建外部项目来实现特性并添加引用。然后，步骤定义被扩展以实现特性的应用代码。
- en: One benefit of this approach is that you, as a programmer, are guaranteed to
    deliver on what the business has asked for, rather than give them what you think
    they asked for. This can save the business a lot of money and hours. Past history
    has shown that many projects failed because of the lack of clarity on what needed
    to be delivered between the business teams and the programming teams. BDD helps
    to alleviate this potential hazard when developing new features.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，作为程序员，你可以保证按照业务的要求交付成果，而不是按照你认为他们要求的交付成果。这可以为企业节省大量资金和时间。过去的历史表明，许多项目因为业务团队和编程团队之间对需要交付的内容缺乏清晰度而失败。BDD有助于在开发新特性时减轻这种潜在风险。
- en: In this section of the chapter, we will develop a very simple calculator example
    using the BDD software development methodology by using SpecFlow.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分中，我们将使用BDD软件开发方法来开发一个非常简单的计算器示例，使用SpecFlow。
- en: We will start by writing a feature file that will act as our specification with
    acceptance criteria. Then we will generate our step definitions from our feature
    file that will generate our required methods. Once our step definitions have generated
    the required methods, we will then write the code for them so that our feature
    is complete.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个特性文件，作为我们的规范和验收标准。然后我们将从特性文件中生成我们的步骤定义，以生成我们所需的方法。一旦我们的步骤定义生成了所需的方法，我们将为它们编写代码，以完成我们的特性。
- en: 'Create a new class library and add the following packages—NUnit, NUnit3TestAdapter,
    SpecFlow, SpecRun.SpecFlow and SpecFlow.NUnit. Add a new SpecFlow Feature file
    called `Calculator`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类库，并添加以下包——NUnit、NUnit3TestAdapter、SpecFlow、SpecRun.SpecFlow和SpecFlow.NUnit。添加一个名为`Calculator`的新的SpecFlow
    Feature文件：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding text is the text automatically added to the `Calculator.feature`
    file upon creation. So we'll use this as our starting point for learning BDD using
    SpecFlow. As of the time of writing, it worth noting that SpecFlow and SpecMap
    have been acquired by **Tricentis**. Tricentis has stated that SpecFlow, SpecFlow+,
    and SpecMap will all remain free, so now is a good time to learn and use SpecFlow
    and SpecMap if you haven't already done so.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Calculator.feature`文件时，上述文本会自动添加到文件中。因此，我们将使用这个作为我们学习使用SpecFlow进行BDD的起点。在撰写本文时，值得注意的是SpecFlow和SpecMap已被**Tricentis**收购。Tricentis表示SpecFlow、SpecFlow+和SpecMap都将保持免费，所以现在是学习和使用SpecFlow和SpecMap的好时机，如果你还没有这样做的话。
- en: 'Now that we have our feature file, we need to create step definitions that
    will bind our feature request to our code. Right-click in the code editor and
    a context menu will pop up. Select Generate step definitions. You should see the
    following dialog:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的特性文件，我们需要创建步骤定义，将我们的特性请求与我们的代码绑定。在代码编辑器中右键单击，会弹出上下文菜单。选择生成步骤定义。你应该会看到以下对话框：
- en: '![](img/61f9cd3d-8061-46b9-ae24-40da636c3445.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f9cd3d-8061-46b9-ae24-40da636c3445.png)'
- en: 'Enter the name `CalculatorSteps` for the class name. Click on the Generate
    button to generate the step definition and save the file. Open the `CalculatorSteps.cs`
    file and you should see the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为类名输入`CalculatorSteps`。点击生成按钮生成步骤定义并保存文件。打开`CalculatorSteps.cs`文件，你应该会看到以下代码：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A comparison of the contents of the steps file with the feature file is shown
    in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤文件的内容与特性文件的比较如下截图所示：
- en: '![](img/386ea8ad-8b99-4cc7-861e-30d2c32b3b4b.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/386ea8ad-8b99-4cc7-861e-30d2c32b3b4b.png)'
- en: 'The code that implements the feature must be in a separate file. Create a new
    class library and call it `CH06_SpecFlow.Implementation`. Then, add a file called
    `Calculator.cs`. Add a reference to the newly created library in the SpecFlow
    project, and the following line to the top of the `CalculatorSteps.cs` file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特性的代码必须在一个单独的文件中。创建一个新的类库，命名为`CH06_SpecFlow.Implementation`。然后，添加一个名为`Calculator.cs`的文件。在SpecFlow项目中添加对新创建的库的引用，并在`CalculatorSteps.cs`文件的顶部添加以下行：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are now in a position to extend our step definitions so that they implement
    the application code. In the `CalculatorSteps.cs` file, replace all the `p0` parameters
    with a number. This makes the parameter requirement more *explicit*. At the top
    of the `Calculate` class, add two public properties called `FirstNumber` and `SecondNumber`,
    as shown in the code that follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以扩展我们的步骤定义，以便它们实现应用程序代码。在`CalculatorSteps.cs`文件中，用数字替换所有的`p0`参数。这使参数要求更加*明确*。在`Calculate`类的顶部，添加两个名为`FirstNumber`和`SecondNumber`的公共属性，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `CalculatorSteps` class, update the `GivenIHaveEnteredIntoTheCalculator()`
    method as shown:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CalculatorSteps`类中，更新`GivenIHaveEnteredIntoTheCalculator()`方法如下：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, add the second method, `GivenIHaveAlsoEnteredIntoTheCalculator()`, if
    it does not already exist, and assign the `number` parameter to the calculator''s
    second number:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果尚不存在，添加第二个方法`GivenIHaveAlsoEnteredIntoTheCalculator()`，并将`number`参数分配给计算器的第二个数字：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add `private int result;` to the top of the `CalculatorSteps` class and before
    any steps. Add the `Add()` method to the `Calculator` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CalculatorSteps`类的顶部和任何步骤之前添加`private int result;`。将`Add()`方法添加到`Calculator`类中：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, update the `WhenIPressAdd()` method in the `CalculatorSteps` class and
    update the `result` variable with the result of calling the `Add()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`CalculatorSteps`类中的`WhenIPressAdd()`方法，并用调用`Add()`方法的结果更新`result`变量：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next up, modify the `ThenTheResultShouldBeOnTheScreen()` method as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`ThenTheResultShouldBeOnTheScreen()`方法如下：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Build your project and run your tests. You should see that the tests pass. Only
    the code required by the feature to pass has been written and your code has passed
    the test.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 构建您的项目并运行测试。您应该看到测试通过。只编写了通过功能所需的代码，并且您的代码已通过测试。
- en: You can find out more about SpecFlow at [https://specflow.org/docs/](https://specflow.org/docs/).
    We've covered some of the tools available for you to develop and test your code.
    Now it is time to see a really simple example of how we go about coding using
    TDD. We'll start by writing code that fails. Then, we'll write just enough code
    for the test to compile. And finally, we will refactor the code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://specflow.org/docs/](https://specflow.org/docs/)找到更多关于SpecFlow的信息。我们已经介绍了一些可用于开发和测试代码的工具。现在是时候看一个真正简单的例子，演示我们如何使用TDD进行编码。我们将首先编写失败的代码。然后，我们将编写足够的代码使测试通过。最后，我们将重构代码。
- en: TDD methodology practice – fail, pass, and refactor
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD方法实践-失败，通过和重构
- en: In this section, you will learn to write tests that fail. Then you will learn
    to write just enough code to make the test pass, and then if necessary, you will
    perform any refactoring that needs to take place.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习编写失败的测试。然后，您将学习编写足够的代码使测试通过，然后如果必要，您将执行任何需要进行的重构。
- en: Before we delve into a practical example of TDD, let's consider why we need
    TDD. In the previous section, you saw how we can create feature files and generate
    step files from them to write code that meets a business need. Another way to
    ensure that your code meets the business requirements is with TDD. With TDD, you
    start with a test that fails. Then, you write just enough code to make the test
    pass, and as the need arises, you perform refactoring of your new code. This process
    is repeated until such time as all the features have been coded.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解TDD的实际例子之前，让我们考虑一下为什么我们需要TDD。在前一节中，您看到了我们如何创建功能文件并从中生成步骤文件，以编写满足业务需求的代码。确保您的代码满足业务需求的另一种方法是使用TDD。通过TDD，您从一个失败的测试开始。然后，您只编写足够的代码使测试通过，并在需要时对新代码进行重构。这个过程重复进行，直到所有功能都被编码。
- en: But *why* do we need TDD?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*为什么*我们需要TDD呢？
- en: Business software specifications are put together by business analysts who work
    with project stakeholders to design new software, or extensions and modifications
    to existing software. Some software is critical and cannot afford to be buggy.
    Such software includes financial systems that handle private and business investments;
    medical equipment, including critical life support and scanning equipment, that
    requires functional software for it to work; transport signaling software for
    traffic management and navigation systems; space flight systems; and weapon systems.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 业务软件规格是由与项目利益相关者合作设计新软件或对现有软件进行扩展和修改的业务分析师组合起来的。一些软件是关键的，不能出现错误。这样的软件包括处理私人和商业投资的金融系统；需要功能软件才能工作的医疗设备，包括关键的生命支持和扫描设备；交通管理和导航系统的交通信号软件；太空飞行系统；以及武器系统。
- en: Okay, but where does TDD fit in?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但TDD在哪里适用呢？
- en: Well, you've been given a specification to write a piece of software. The first
    thing you need to do is create your project. Then, you write the pseudocode for
    the functionality that you are going to implement. You then progress to writing
    the tests for each piece of pseudocode. The test fails. You then write the required
    code that causes the test to pass, and then you refactor your code as needed.
    What you are doing here is writing code that is well tested and robust. You are
    able to guarantee that your code will execute as expected in isolation. If your
    code is a component of a larger system, then it will be the responsibility of
    the test team to test the integration of your code, not you. You, as a developer,
    have earned the confidence in your code to release it to the test team. If the
    test team identify use cases that have previously been overlooked, they will share
    them with you. You will then write further tests and make them pass before releasing
    the updated code to them. Such a way of working ensures that code is of the highest
    standard and can be trusted to work as expected by given the expected outputs
    for the given inputs. And finally, TDD makes software progress measurable, which
    is good news for managers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你已经得到了编写软件规范的任务。你需要做的第一件事是创建你的项目。然后，你为你要实现的功能编写伪代码。然后，你继续为每个伪代码编写测试。测试失败。然后，你编写必要的代码使测试通过，然后根据需要重构你的代码。你正在编写经过充分测试和健壮的代码。你能够保证你的代码在隔离环境中按预期执行。如果你的代码是一个更大系统的组件，那么测试团队将负责测试你的代码的集成，而不是你。作为开发人员，你已经赢得了对代码的信心，可以将其发布给测试团队。如果测试团队发现了以前被忽视的用例，他们会与你分享。然后，你将编写进一步的测试并使其通过，然后将更新后的代码发布给他们。这种工作方式确保了代码的最高标准，并且可以信任它按照给定输入的预期输出进行工作。最后，TDD使软件进展可衡量，这对经理来说是个好消息。
- en: It's time for our little demonstration of TDD. In this example, we will use
    TDD to develop a simple logging application that can handle inner exceptions,
    and logs exceptions to a timestamped text file. We will write the program and
    get the tests to pass. Once we have written our program and got all the tests
    to pass, then we will refactor our code to make it reusable and easier to read,
    and of course, we will make sure that our tests still pass.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们进行TDD的小演示的时候了。在这个例子中，我们将使用TDD来开发一个简单的日志记录应用程序，可以处理内部异常，并将异常记录到一个带有时间戳的文本文件中。我们将编写程序并使测试通过。一旦我们编写了程序并使所有测试通过，然后我们将重构我们的代码，使其可重用和更易读，当然，我们将确保我们的测试仍然通过。
- en: 'Create a new console application and call it `CH06_FailPassRefactor`. Add a
    class called `UnitTests` with the following pseudocode:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并将其命名为`CH06_FailPassRefactor`。添加一个名为`UnitTests`的类，其中包含以下伪代码：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll write our first unit test to satisfy the condition `[1]`. In our unit
    test, we will test create the `Logger` variable, call the `Log()` method, and
    pass the test. So, let''s write the code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写我们的第一个单元测试来满足条件`[1]`。在我们的单元测试中，我们将测试创建`Logger`变量，调用`Log()`方法，并通过测试。所以，让我们写代码：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This test will not run as the project will not build. That is because the `Logger`
    class does not exist. So add an internal class called `Logger` to the project.
    Then run your test. The build will still *fail*, and the test won't be run because
    we are now missing the `Log()` method. So let's add the `Log()` method to our
    `Logger` class. Then, we'll try and run our test again. This time, the test should
    succeed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试不会运行，因为项目无法构建。这是因为`Logger`类不存在。因此，在项目中添加一个名为`Logger`的内部类。然后运行你的测试。构建仍然会*失败*，测试也不会运行，因为现在缺少`Log()`方法。所以让我们在`Logger`类中添加`Log()`方法。然后，我们将尝试再次运行我们的测试。这次，测试应该成功。
- en: At this stage, we will perform any necessary refactoring. But since we have
    just started, there is no refactoring to do, so we can move on to our next test.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将执行任何必要的重构。但由于我们刚刚开始，没有需要重构的地方，所以我们可以继续进行下一个测试。
- en: 'Our code to generate the log message and save it to disk will feature private
    members. With NUnit, you don''t test private members. The school of thought is
    that if you have to test private members, then there must be something wrong with
    your code. So, we''ll move on to our next unit test, which will determine whether
    the log file exists. Before we write our unit test, we will write a method that
    returns an exception with an inner exception that has an inner exception. We will
    pass the returned exception into the `Log()` method in our unit test:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码生成日志消息并保存到磁盘的功能将包含私有成员。使用NUnit，你不测试私有成员。这种思想是，如果你必须测试私有成员，那么你的代码肯定有问题。所以，我们将继续进行下一个单元测试，确定日志文件是否存在。在编写单元测试之前，我们将编写一个返回具有内部异常的异常的方法。我们将在我们的单元测试中将返回的异常传递给`Log()`方法：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we have our `GetException()` method in place where we can write our unit
    test to check whether the log file exists:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有了`GetException()`方法，我们可以编写我们的单元测试来检查日志文件是否存在：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we build our code and run the `CheckFileExists()` test, it will fail, so
    we need to write the code for it to succeed. In the `Logger` class, add `private
    StringBuilder _stringBuilder;` to the top of the `Logger` class. Then, modify
    the `Log()` method and add the following method to the `Logger` class:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们构建我们的代码并运行`CheckFileExists()`测试，它将失败，所以我们需要编写代码使其成功。在`Logger`类中，将`private
    StringBuilder _stringBuilder;`添加到`Logger`类的顶部。然后，修改`Log()`方法，并在`Logger`类中添加以下方法：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have called the `Log()` method and a log file is generated. Now, all we
    need is the text to be logged to the file. According to our pseudocode, we need
    to log the main exception and all inner exceptions. Let''s write a test that checks
    whether the log file contains the message `"Exception: Inner Exception Inner Exception"`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们已经调用了`Log()`方法，并生成了一个日志文件。现在，我们只需要将文本记录到文件中。根据我们的伪代码，我们需要记录主异常和所有内部异常。让我们编写一个检查日志文件是否包含消息`"Exception:
    Inner Exception Inner Exception"`的测试：'
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we know that the test will fail because the string builder is *empty*, so
    we will add the method to the `Logger` class that will take an exception, log
    the message, and check whether the exception has an inner exception. If it has,
    then it will call itself with the parameter `isInnerException`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们知道测试将会失败，因为字符串生成器是*空的*，所以我们将在`Logger`类中添加一个方法，该方法将接受一个异常，记录消息，并检查异常是否有内部异常。如果有，那么它将使用参数`isInnerException`调用自身：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, update the `Log()` method of the `Logger` class to call our `BuildExceptionMessage()`
    method:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`Logger`类的`Log()`方法以调用我们的`BuildExceptionMessage()`方法：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All our tests now pass and we have a fully functioning program that does what's
    expected of it, but there is an opportunity here for some refactoring. The method
    called `BuildExceptionMessage()` is a candidate for reuse as it is very useful
    for debugging purposes, especially when you have an exception with an inner exception,
    so we are going to move that method into its own method. Notice that the `Log()`
    method is also building the opening and closing portions of the text to be logged.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的测试都通过了，我们有一个完全正常运行的程序，但是这里有一个重构的机会。名为`BuildExceptionMessage()`的方法是可以重复使用的候选方法，特别是在调试时非常有用，尤其是当您有一个带有内部异常的异常时，所以我们将把该方法移动到自己的方法中。请注意，`Log()`方法也正在构建要记录的文本的开头和结尾部分。
- en: 'We can and will move this into the `BuildExceptionMessage()` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以并且将把这个移到`BuildExceptionMessage()`方法中：
- en: 'Create a new class and call it `Text`. Add a private `StringBuilder` member
    variable and instantiate it in the constructor. Then, update the class by adding
    the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类并将其命名为`Text`。在构造函数中添加一个私有的`StringBuilder`成员变量并对其进行实例化。然后，通过添加以下代码来更新类：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ve now got a useful `Text` class that returns a useful exception message
    from an exception with inner exceptions, but we can also refactor the code in
    the `SaveLog()` method. We can extract the code that generates a unique hashed
    filename into its own method. So, let''s add the following method to the `Text`
    class:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个有用的`Text`类，它可以从带有内部异常的异常中返回有用的异常消息，但是我们也可以重构`SaveLog()`方法中的代码。我们可以将生成唯一哈希文件名的代码提取到自己的方法中。因此，让我们向`Text`类添加以下方法：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `GetHashedTextFileName()` method accepts a name for the file specified by
    the user and a special folder. It then adds a hyphen and the current UTC date's
    hash code to the end of the filename. It then adds the `.txt` file extension and
    assigns the text to the `fileName` variable. The absolute path of the special
    folder requested by the caller is then assigned to the `dir` variable and the
    path and filename are then returned to the user. This method is guaranteed to
    return unique filenames.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetHashedTextFileName()` 方法接受用户指定的文件名和特殊文件夹。然后在文件名末尾添加连字符和当前UTC日期的哈希码。然后添加`.txt`文件扩展名并将文本分配给`fileName`变量。然后将调用者请求的特殊文件夹的绝对路径分配给`dir`变量，然后将路径和文件名返回给用户。此方法保证返回唯一的文件名。'
- en: 'Replace the body of the `Logger` class with the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`Logger`类的主体：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The class is still doing the same thing, but it is cleaner and smaller as the
    message and filename generation has been moved to a separate class. If you run
    the code, it behaves in the same way. If you run the tests, they will all pass.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该类仍然在做同样的事情，但是它更清洁、更小，因为消息和文件名的生成已经移动到一个单独的类中。如果您运行代码，它的行为方式是相同的。如果您运行测试，它们都会通过。
- en: In this section, we have written unit tests that failed, and then modified them
    so that they passed. Then, we refactored the code to make it cleaner, which resulted
    in us writing code that can be reused in the same project or other projects. Let's
    now take a very brief look at redundant tests.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们编写了失败的单元测试，然后修改它们使其通过。然后，我们重构了代码，使其更加清晰，这导致我们编写的代码可以在同一项目或其他项目中重复使用。现在让我们简要地看一下多余的测试。
- en: Removing redundant tests, comments, and dead code
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除多余的测试、注释和死代码
- en: As the book states, we are interested in writing clean code. As our programs
    and tests grow and we start to refactor, some code will become redundant. Any
    code that is redundant and does not get called is known as **dead code**. Dead
    code should always be removed as soon as it is identified. Dead code will not
    be executed in compiled code, but it is still part of the code base that needs
    to be maintained. Code files with dead code are longer than they need to be. Apart
    from the unnecessary fact that it makes your files bigger, it can also make reading
    source code harder, as it may cut through the natural flow of the code and add
    confusion and delay to the programmer reading it. Not only that, but the last
    thing any programmer new to the project needs is to waste valuable time trying
    to understand dead code that will never be used. So it is best to get rid of it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如书中所述，我们对编写清晰的代码很感兴趣。随着我们的程序和测试的增长以及开始重构，一些代码将变得多余。任何多余的代码并且没有被调用的代码都被称为**死代码**。一旦识别出死代码，就应该立即删除。死代码不会在编译后的代码中执行，但它仍然是需要维护的代码库的一部分。带有死代码的代码文件比它们需要的要长。除了使文件变得更大之外，它还可能使阅读源代码变得更加困难，因为它可能打断代码的自然流程，并给阅读它的程序员增加困惑和延迟。不仅如此，对于项目中的新程序员来说，最不希望的是浪费宝贵的时间来理解永远不会被使用的死代码。因此最好是摆脱它。
- en: As for comments, they can be really useful if done right, and API commenting
    is particularly beneficial for API documentation generation. But some comments
    just add noise to the code file, and a surprising number of programmers can become
    really irritated by them. There is one group of programmers that will comment
    on everything. Another group won't comment on anything as they believe the code
    should read like a book. And then there are those who take a balanced approach,
    and only comment on code when it is deemed necessary for people to understand
    the code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 至于注释，如果做得当，它们可以非常有用，特别是API注释对API文档生成特别有益。但有些注释只会给代码文件增加噪音，令人惊讶的是，很多程序员会因此感到非常恼火。有一群程序员会对一切都做注释。另一群则什么都不注释，因为他们认为代码应该像读书一样。还有一些人采取平衡的态度，只在必要时才对代码做注释。
- en: When you see comments like this—*"This generates a random bug every so often.
    Don't know why. But you're welcome to fix it!"*—alarm bells should start ringing.
    First of all, the programmer who wrote the comment should have stuck with the
    code and not moved on until the conditions that generate the bug were identified,
    and then the bug should have been fixed. If you know who the programmer is who
    wrote the comment, then return the code to them to fix and remove the comment.
    I have seen code like that on more than one occasion, and I've seen comments on
    the web expressing these strong sentiments about such comments. I suppose it is
    a way to deal with lazy programmers. Should they not be lazy, but rather simply
    inexperienced, then it is a good learning task in the art of problem diagnosis
    and resolution.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到这样的注释时——“这会偶尔生成一个随机bug。不知道为什么。但欢迎你来修复它！”——警钟应该响起。首先，写下这条注释的程序员应该坚持在代码上工作，直到找出生成bug的条件，然后修复bug。如果你知道写下这条注释的程序员是谁，那就把代码还给他们去修复，并删除注释。我在多个场合看到过这样的代码，也看到过网上对这些注释表达强烈情绪的评论。我想这是应对懒惰程序员的一种方式。如果他们不是懒惰，而只是经验不足，那么这是一个很好的学习任务，可以学习问题诊断和解决的艺术。
- en: If code has been checked in and approved, and you come across blocks of code
    that have been commented out, then delete them. The code will still exist in the
    version control history and you will be able to retrieve it from there if you
    have to.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码已经经过检查和批准，你发现有一些代码块被注释掉了，那就把它们删除。这些代码仍然存在于版本控制历史中，如果需要的话，你可以从那里检索出来。
- en: Code should be read like a book, and so you should not aim to make your code
    cryptic just to look good and impress your colleagues, because I guarantee that
    when you come back to your own code in a few weeks' time, you will scratch your
    head wondering what your own code does and why. I've seen many juniors make this
    mistake.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该像读书一样，所以你不应该让你的代码变得晦涩难懂，只是为了给同事留下好印象，因为我保证，当你几周后回到自己的代码时，你会摸着头想知道自己的代码是做什么的，为什么要这样写。我见过很多初学者犯这个错误。
- en: Redundant tests should also be removed. You only need to run the tests that
    are necessary. Tests for redundant code have no value and can waste considerable
    time. Also, if your company has CI/CD pipelines that also run tests in the cloud,
    then the redundant tests and dead code add business costs to the build, test,
    and deploy pipelines. This means that the fewer lines of code you upload, build,
    test, and deploy, the less your company has to fork out on running costs. Remember,
    running processes in the cloud costs money and the aim of a business is to spend
    as little money as possible, but rake in plenty of money.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 冗余测试也应该被移除。你只需要运行必要的测试。对于冗余代码的测试没有价值，可能会浪费大量时间。此外，如果你的公司有在云中运行测试的CI/CD流水线，那么冗余测试和死代码会给构建、测试和部署流水线增加业务成本。这意味着你上传、构建、测试和部署的代码行数越少，公司在运行成本上的支出就越少。记住，在云中运行进程是要花钱的，企业的目标是尽量少花钱，但赚取大量利润。
- en: So now that we've finished the chapter, let's summarize what we've learned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了这一章，让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started by looking at why it is important for developers to write unit tests
    to develop quality-assured code. Theoretical problems were identified that could
    arise from bugs in the software. These include loss of life and expensive lawsuits.
    Unit testing and what makes a good unit test was then discussed. We identified
    that a good unit test must be atomic, deterministic, repeatable, and fast.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看了开发人员编写单元测试以开发质量保证代码的重要性。我们确定了软件中可能出现的理论问题，包括生命损失和昂贵的诉讼。然后讨论了单元测试和什么是好的单元测试。我们确定了一个好的单元测试必须是原子的、确定性的、可重复的和快速的。
- en: Next, we went on to look at the tools available to developers that assist with
    TDD and BDD. MSTest and NUnit were discussed with examples that showed how to
    implement TDD. Then, we looked at using a mocking framework called Moq in conjunction
    with NUnit for testing mock objects. Our look at tools then concluded with SpecFlow—a
    BDD tool that allows us to write features in a business language that both techies
    and non-techies can understand—to make sure that what the business wants is what
    the business gets.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下开发人员可用的辅助TDD和BDD的工具。我们讨论了MSTest和NUnit，并提供了示例，展示了如何实施TDD。然后，我们看了如何使用一个名为Moq的模拟框架与NUnit一起测试模拟对象。我们的工具介绍最后以SpecFlow结束——这是一个BDD工具，允许我们用业务语言编写功能，技术人员和非技术人员都能理解，以确保业务得到的是业务想要的。
- en: NUnit was then put to work as we worked through a very simple TDD example using
    the *fail, pass, and refactor* methodology, before finally looking at why we should
    remove unnecessary comments, redundant tests, and dead code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们使用 *失败、通过和重构* 方法，通过一个非常简单的TDD示例来使用NUnit，最后看了为什么我们应该删除不必要的注释、冗余测试和死代码。
- en: At the end of this chapter, you will find further resources on testing software
    programs. In the next chapter, we are going to look at end-to-end testing. But
    before that, you might as well have a go at the following questions and see how
    much knowledge on unit testing you have retained.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，您将找到有关测试软件程序的进一步资源。在下一章中，我们将看一下端到端测试。但在那之前，您可能也可以尝试以下问题，看看您对单元测试有多少了解。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What makes a good unit test?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是一个好的单元测试？
- en: What should a good unit test not be?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的单元测试不应该是什么？
- en: What does TDD stand for?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD 代表什么？
- en: What does BDD stand for?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BDD 代表什么？
- en: What is a unit test?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单元测试？
- en: What is a mock object?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模拟对象？
- en: What is a fake object?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是虚拟对象？
- en: Name some unit testing frameworks.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一些单元测试框架。
- en: Name some mocking frameworks.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一些模拟框架。
- en: Name a BDD framework.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出一个 BDD 框架。
- en: What should be removed from source code files?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该从源代码文件中删除什么？
- en: Further reading
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A brief overview of unit testing, with links to further information on different
    types of unit testing including integration testing, acceptance testing, and tester
    job descriptions, can be found at [http://softwaretestingfundamentals.com/unit-testing](http://softwaretestingfundamentals.com/unit-testing/)[.](http://softwaretestingfundamentals.com/unit-testing/)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[http://softwaretestingfundamentals.com/unit-testing](http://softwaretestingfundamentals.com/unit-testing/)找到对单元测试的简要概述，以及链接到不同类型的单元测试，包括集成测试、验收测试和测试人员工作描述的更多信息。
- en: The Rhino Mocks homepage can be found at [http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks).
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rhino Mocks 的主页可以在[http://hibernatingrhinos.com/oss/rhino-mocks](http://hibernatingrhinos.com/oss/rhino-mocks)找到。
