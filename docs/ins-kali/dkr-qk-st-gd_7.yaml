- en: Docker Stacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker堆栈
- en: In this chapter, we will bring together all that we've learned from the first
    six chapters and use it to define, deploy, and manage multi-container applications.
    We will achieve this via the use of Docker stacks. We are going to learn how to
    use Docker stacks and the YAML files required to define multi-container applications.
    And we will leverage what we learned about Docker services, Docker volumes, Docker
    swarm, and Docker networking to create full-featured multi-service Docker-based applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将汇集前六章所学，并用它来定义、部署和管理多容器应用程序。我们将通过使用Docker堆栈来实现这一点。我们将学习如何使用Docker堆栈和定义多容器应用程序所需的YAML文件。我们将利用我们对Docker服务、Docker卷、Docker集群和Docker网络的了解来创建功能齐全的基于Docker的多服务应用程序。
- en: The largest cargo ship is 400 meters long and can carry between 15,000 and 18,000
    shipping containers!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的货船长400米，可以携带15,000至18,000个集装箱！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Docker stacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker堆栈
- en: Deploying a multi-service Docker application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署多服务Docker应用程序
- en: Creating and using compose (stack) YAML files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用compose（堆栈）YAML文件
- en: Scaling a deployed multi-service Docker application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展已部署的多服务Docker应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be pulling Docker images from Docker's public repo, and installing
    network drivers from Weave, so basic internet access is required to execute the
    examples within this chapter. Also, we will be using the jq software package,
    so if you haven't installed it yet, please see the instructions on how to do so;
    they can be found in the* Container inspect command* section of [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml),
    *Learning Docker Commands*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从Docker的公共存储库中拉取Docker镜像，并从Weave安装网络驱动程序，因此执行本章示例需要基本的互联网访问。此外，我们将使用jq软件包，因此如果您尚未安装，请参阅如何安装的说明；可以在[第2章](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml)的*容器检查命令*部分找到。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter07)'
- en: 'Check out the following video to see the code in action: [http://bit.ly/2E2qc9U](http://bit.ly/2E2qc9U)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2E2qc9U](http://bit.ly/2E2qc9U)
- en: Understanding the use of Docker stacks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Docker堆栈的使用
- en: So far, we have mostly been looking at running a Docker container from a single
    Docker image, simplifying the Docker model to imagine a world where every application
    only required a single service, and thus a single Docker image, to run. However,
    as you know, that is a pretty unrealistic model. Real-world applications are composed
    of multiple services, and those services are deployed using multiple Docker images.
    To run all of the necessary containers, and maintain them at the desired number
    of replicas, handling planned and unplanned downtimes, scaling requirements and
    all of the other service management needs is a really daunting and complex task.
    In the recent past, this scenario was handled using a tool called Docker Compose.
    Docker Compose (as you learned in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Docker Development Environment*) is an additional tool that you
    can install in your Docker environment, which we did to complete our workstation's
    environment. While much of the functionality of Docker Compose is similar to what
    you find in Docker stacks, we will be focusing on Docker stacks in this chapter.
    We are doing this because Docker Compose is used to manage containers, and the
    Docker world has evolved toward the commodity unit being services instead of containers.
    Docker stacks manages services, and so I see Docker stacks as the evolution of
    Docker Compose (which was the evolution of a project named Fig). The reason we
    did not install Docker stacks in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, is that Stacks is already included as part
    of a standard Docker installation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是从单个Docker镜像中运行Docker容器，简化Docker模型，想象一个世界，每个应用程序只需要一个服务，因此只需要一个Docker镜像来运行。然而，正如你所知，这是一个相当不现实的模型。现实世界的应用程序由多个服务组成，并且这些服务是使用多个Docker镜像部署的。要运行所有必要的容器，并将它们保持在所需数量的副本，处理计划和非计划的停机时间，扩展需求以及所有其他服务管理需求是一个非常艰巨和复杂的任务。最近，这种情况是使用一个名为Docker
    Compose的工具来处理的。Docker Compose（正如你在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中学到的，*设置Docker开发环境*）是一个额外的工具，你可以在Docker环境中安装，我们已经在工作站的环境中完成了安装。虽然Docker
    Compose的许多功能与Docker堆栈中的功能类似，但我们将在本章中专注于Docker堆栈。我们这样做是因为Docker Compose用于管理容器，而Docker世界已经向服务作为通用单元的演变。Docker堆栈管理服务，因此我认为Docker堆栈是Docker
    Compose的演变（它是一个名为Fig的项目的演变）。我们之所以没有在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中安装Docker堆栈，*设置Docker开发环境*，是因为堆栈已经作为标准Docker安装的一部分包含在内。
- en: OK, so Docker stacks is the new and improved Docker Compose, and it is included
    in our installation. I bet you're thinking, Great. But what does that mean? What
    is the use case of Docker stacks? Great question! Docker stacks is *the* way to
    leverage all of the functionality that we have learned about in the earlier chapters,
    such as the Docker commands, Docker images, Docker services, Docker volumes, Docker
    swarm, and Docker networks, wrapping it all up in an easy-to-use, easy-to-understand,
    declarative document file that will instantiate and maintain a complex, multi-image
    application on our behalf.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以Docker堆栈是新的改进版Docker Compose，并且已包含在我们的安装中。我敢打赌你在想，太好了。但这意味着什么？Docker堆栈的用例是什么？好问题！Docker堆栈是利用我们在前几章中学到的所有功能的方式，比如Docker命令、Docker镜像、Docker服务、Docker卷、Docker集群和Docker网络，将所有这些功能包装在一个易于使用、易于理解的声明性文档文件中，这将代表我们实例化和维护一个复杂的多镜像应用程序。
- en: 'Most of your work, which is still the easy part, will be in creating the compose
    file that will be used in the Docker stack commands. All of the really hard work
    will be done by Docker when it creates, starts, and manages all of the services
    required for your multi-service (multi-container) applications. All of this is
    handled by a single command on your part. Just like image, the container and swarm
    stacks are another Docker management group. Let''s take a look at the stack management
    commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作，仍然是简单的部分，将在创建用于Docker堆栈命令的compose文件中进行。当Docker创建、启动和管理所有多服务（多容器）应用程序所需的所有服务时，所有真正的艰苦工作都将由Docker完成。所有这些都由您的一条命令处理。就像镜像一样，容器和swarm堆栈是另一个Docker管理组。让我们来看看堆栈管理命令：
- en: '![](Images/122c40cb-3742-4665-be75-2ce2ecfaa9df.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/122c40cb-3742-4665-be75-2ce2ecfaa9df.png)'
- en: So, what do we have here? For all the power that this management group represents,
    it has a pretty simple set of commands. The main command is the `deploy` command.
    It is the powerhouse! With this command (and a compose file), you will stand up
    your application, pulling any images that are not local to your environment, running
    the images, creating volumes as needed, creating networks as needed, deploying
    the defined number of replicas for each image, spreading them across your swarm
    for HA and load-balancing purposes, and more. This command is kind of like the
    one ring in *The Lord of the Rings*. In addition to deploying your application,
    you will use this same command to update running applications, when you need to
    do things such as scale your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里有什么？对于这个管理组所代表的所有功能，它有一组非常简单的命令。主要命令是`deploy`命令。它是强大的！通过此命令（和一个compose文件），您将启动您的应用程序，拉取任何不在本地环境中的镜像，运行镜像，根据需要创建卷，根据需要创建网络，为每个镜像部署定义的副本数量，将它们分布在您的swarm中以实现高可用性和负载平衡，并且更多。这个命令有点像《指环王》中的一环。除了部署应用程序，当您需要执行诸如扩展应用程序之类的操作时，您将使用相同的命令来更新正在运行的应用程序。
- en: The next command in the management group is the list stacks command. As the
    name implies, the ls command allows you to get a list of all the stacks currently
    deployed to your swarm. When you need more detailed information about a particular
    stack that is running in your swarm, you will use the `ps` command to list all
    of the tasks of a particular stack. When it comes time to end of life a deployed
    stack, you will use the mighty rm command. And finally, rounding out the management
    commands, we have the services command, which allows us to get a list of the services
    that are part of the stack. There is one more important part of the stack puzzle,
    that being the `--orchestrator` option. With this option, we can instruct Docker
    to use either Docker swarm or Kubernetes for the stack orchestration. Of course,
    to use Kubernetes, it must be installed, and to use swarm—which is the default
    if the option is not specified—swarm mode must be enabled.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 管理组中的下一个命令是列出堆栈的命令。顾名思义，ls命令允许您获取当前部署到您的swarm的所有堆栈的列表。当您需要关于正在swarm中运行的特定堆栈的更详细信息时，您将使用`ps`命令列出特定堆栈的所有任务。当到达结束生命周期部署的堆栈时，您将使用强大的rm命令。最后，作为管理命令的补充，我们有services命令，它允许我们获取堆栈的一部分的服务列表。堆栈谜题的另一个重要部分是`--orchestrator`选项。通过此选项，我们可以指示Docker使用Docker
    swarm或Kubernetes进行堆栈编排。当然，要使用Kubernetes，必须已安装，并且要使用swarm——如果未指定该选项，则必须启用swarm模式。
- en: In the rest of this chapter, we are going to take a deep dive into Docker stacks
    using a sample application. Docker provides several such samples, but the one
    we are going to examine is the voting application sample. I will provide a link
    to the Docker repo for the app, as well as a link to a fork of the project in
    my space in the event that the Docker app changes drastically or the project goes
    away. Let's take a look at the stack file for the example voting application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将深入研究使用示例应用程序的Docker stacks。Docker 提供了几个这样的示例，但我们要检查的是投票应用程序示例。我将提供应用程序的Docker存储库的链接，以及我空间中项目的分支的链接，以防Docker应用程序发生重大变化或项目消失。让我们来看一下示例投票应用程序的堆栈文件。
- en: References
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Check out the following links for more information:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取更多信息：
- en: Docker Compose Overview: [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 概述：[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
- en: Docker stack command reference: [https://docs.docker.com/engine/reference/commandline/stack/](https://docs.docker.com/engine/reference/commandline/stack/)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker stack 命令参考：[https://docs.docker.com/engine/reference/commandline/stack/](https://docs.docker.com/engine/reference/commandline/stack/)
- en: Docker samples: [https://github.com/dockersamples](https://github.com/dockersamples)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 样本：[https://github.com/dockersamples](https://github.com/dockersamples)
- en: Docker voting app example: [https://github.com/dockersamples/example-voting-app](https://github.com/dockersamples/example-voting-app)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 投票应用示例：[https://github.com/dockersamples/example-voting-app](https://github.com/dockersamples/example-voting-app)
- en: My fork of the voting app: [https://github.com/EarlWaud/example-voting-app](https://github.com/EarlWaud/example-voting-app)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的投票应用的分支：[https://github.com/EarlWaud/example-voting-app](https://github.com/EarlWaud/example-voting-app)
- en: How to create and use a compose YAML files for Stacks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建和使用Compose YAML文件用于Stacks
- en: The stack file is a YAML file, and is basically the same thing as a Docker Compose
    file. Both are YAML files that define a Docker base application. Technically,
    a stack file is a compose file that requires a specific version (or above) of
    the compose specification. Only the version 3.0 specification and above are supported
    by Docker stacks. If you have an existing project that uses Docker compose YAML
    files, and those files are using the version 2 or older specification, then you
    will need to update the YAML files to the version 3 spec to be able to use them
    with Docker stacks. It is worth noting that the same YAML file can be used with
    either Docker stacks or Docker compose (provided it is written using the version
    3 specification or higher). However, there are some instructions that will be
    ignored by one or the other tools. For example, the build instruction is ignored
    by Docker stacks. That is because one of the most significant differences between
    stacks and compose is that all utilized Docker images must be pre-created for
    use with stacks, whereas Docker images can be created as part of the process of
    standing up a compose-based application. Another significant difference is the
    stack file is able to define Docker services as part of the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈文件是一个YAML文件，基本上与Docker Compose文件相同。两者都是定义Docker基础应用程序的YAML文件。从技术上讲，堆栈文件是一个需要特定版本（或更高版本）的Compose规范的Compose文件。Docker
    stacks 仅支持版本3.0规范及以上。如果您有一个使用Docker compose YAML文件的现有项目，并且这些文件使用的是版本2或更旧的规范，那么您需要将YAML文件更新到版本3规范，以便能够在Docker
    stacks 中使用它们。值得注意的是，相同的YAML文件可以用于Docker stacks 或 Docker compose（前提是使用了版本3规范或更高版本）。但是，有一些指令将被其中一个工具忽略。例如，Docker
    stacks 会忽略构建指令。这是因为堆栈和compose之间最重要的区别之一是，所有使用的Docker映像必须预先创建以供堆栈使用，而Docker映像可以作为建立基于compose的应用程序的一部分而创建。另一个重要的区别是，堆栈文件能够定义Docker服务作为应用程序的一部分。
- en: 'Now would be a good time to clone the voting app project and the visualizer
    image repos:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是克隆投票应用程序项目和可视化器镜像存储库的好时机。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Strictly speaking, you don''t need to clone these two repos because all you
    really need is the stack compose file from the voting app. This is because all
    of the images are already created and publicly available to pull from hub.docker.com,
    and when you deploy the stack, the images will be pulled for you as part of the
    deployment. So, here is the command to obtain just the stack YAML file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，您不需要克隆这两个存储库，因为您真正需要的只是投票应用程序的堆栈组合文件。这是因为所有的镜像已经被创建并且可以从hub.docker.com公开获取，并且当您部署堆栈时，这些镜像将作为部署的一部分被获取。因此，这是获取堆栈YAML文件的命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, if you want to customize the app in any way, having the project local
    allows you to build your own versions of the Docker images and then deploy your
    custom version of the app using your custom images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您想以任何方式自定义应用程序，将项目本地化可以让您构建自己的Docker镜像版本，然后使用您的自定义镜像部署应用程序的自定义版本。
- en: 'Once you have the project (or at least the `docker-stack.yml` file) on your
    system, you can begin to play around with the Docker stack commands. So now, let''s
    go ahead and kick things off by using the `docker-stack.yml` file to deploy our
    application. You will need to have your Docker nodes set up and have swarm mode
    enabled for this to work, so if you haven''t done so already, set up your swarm
    as described in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker
    Swarm*. Then, use the following command to deploy your example voting application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在系统上拥有项目（或至少有`docker-stack.yml`文件），您就可以开始使用Docker堆栈命令进行操作。现在，让我们继续使用`docker-stack.yml`文件来部署我们的应用程序。您需要设置好Docker节点并启用swarm模式才能使其工作，所以如果您还没有这样做，请按照[第5章](f1681897-580b-44fb-9e43-4aed37e67529.xhtml)中描述的设置您的swarm，*Docker
    Swarm*。然后，使用以下命令来部署您的示例投票应用程序：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is what this might look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它可能看起来的样子：
- en: '![](Images/2aee2f71-d5df-4f98-846b-ac4b0b65e79b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2aee2f71-d5df-4f98-846b-ac4b0b65e79b.png)'
- en: 'Let me quickly explaining this command: we are using the `deploy` command with
    the `docker-stack.yml` compose file, and naming our stack `voteapp`. This command
    will handle all of the configuration, deployment, and management for our new application.
    It will take some time to get everything up and running as defined in the `docker-stack.yml`
    file, so while that is happening, let''s start diving into our stack compose file.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我快速解释一下这个命令：我们正在使用`deploy`命令与`docker-stack.yml`组合文件，并将我们的堆栈命名为`voteapp`。这个命令将处理我们新应用程序的所有配置、部署和管理。根据`docker-stack.yml`文件中定义的内容，需要一些时间来使一切都正常运行，所以在这段时间里，让我们开始深入了解我们的堆栈组合文件。
- en: By now, you know we are using the `docker-stack.yml` file. So, as we explain
    the various parts of the stack compose file, you can bring that file up in your
    favorite editor, and follow along. Here we go!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您知道我们正在使用`docker-stack.yml`文件。因此，当我们解释堆栈组合文件的各个部分时，您可以在您喜欢的编辑器中打开该文件，并跟随我们的讲解。我们开始吧！
- en: 'The first thing we are going to look at is the top-level keys. In this case,
    they are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的第一件事是顶层键。在这种情况下，它们如下所示：
- en: version
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: services
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: networks
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: volumes
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷
- en: 'As mentioned previously, the version must be at least 3 to work with Docker
    stacks. Looking at line 1 (the version key is always on line 1) in the `docker-stack.yml`
    file, we see the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，版本必须至少为3才能与Docker堆栈一起使用。查看`docker-stack.yml`文件中的第1行（版本键始终在第1行），我们看到以下内容：
- en: '![](Images/db63823a-5514-4548-8c15-00c967515e96.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/db63823a-5514-4548-8c15-00c967515e96.png)'
- en: 'Perfect! We have a compose file that is at the version 3 specification. Skipping
    over the (collapsed) services key section for a minute, let''s take a look at
    the networks key and then the volumes key. In the networks key section, we are
    instructing Docker to create two networks, one named frontend, and one named backend.
    Actually, in our case, the networks will have the names `voteapp_frontend` and
    `voteapp_backend`. This is because we named our stack `voteapp`, and Docker will
    prepend the name of the stack to the various components it deploys as part of
    the stack. Simply by including the names for our desired networks within the networks
    key of our stack file, Docker will create our networks when we deploy our stack.
    We can provide specific details for each network (as we learned in [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*), but if we don''t provide any, then certain default values
    will be used. It''s probably been long enough for our stack to deploy our networks,
    so let''s use the network list command and take a look at what networks we have
    now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们有一个符合版本3规范的组合文件。在一分钟内跳过（折叠的）服务密钥部分，让我们看一下网络密钥，然后是卷密钥。在网络密钥部分，我们指示Docker创建两个网络，一个名为frontend，一个名为backend。实际上，在我们的情况下，网络将被命名为`voteapp_frontend`和`voteapp_backend`。这是因为我们将我们的堆栈命名为`voteapp`，Docker将在部署堆栈的一部分时将堆栈的名称前置到各个组件的名称之前。通过在堆栈文件的网络密钥中包含我们所需网络的名称，Docker将在部署堆栈时创建我们的网络。我们可以为每个网络提供特定的细节（正如我们在[第6章](873454a4-2f8e-42df-93ab-7648545167bb.xhtml)中学到的，*Docker网络*），但如果我们不提供任何细节，那么将使用某些默认值。我们的堆栈可能已经足够长时间来部署我们的网络了，所以让我们使用网络列表命令来看看我们现在有哪些网络：
- en: '![](Images/4f26a50f-92fc-4fb0-a453-2a1448250df9.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4f26a50f-92fc-4fb0-a453-2a1448250df9.png)'
- en: 'There they are: `voteapp_frontend` and `voteapp_backend`. You might be wondering
    what the `voteapp_default` network is. When you deploy a stack, you will always
    get a default swarm network and all containers are attached to it if they don''t
    have any other network connection defined for them in the stack compose file.
    This is very cool, right?! You didn''t have to do any docker network create commands,
    and your desired networks are created and ready to use in your application.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在这里：`voteapp_frontend`和`voteapp_backend`。您可能想知道`voteapp_default`网络是什么。当您部署一个堆栈时，您将始终获得一个默认的Swarm网络，如果它们在堆栈组合文件中没有为它们定义任何其他网络连接，那么所有容器都将连接到它。这非常酷，对吧？！您不必执行任何docker网络创建命令，您的所需网络已经在应用程序中创建并准备好使用。
- en: 'The volumes key section does pretty much the same thing as the networks key
    section, except it does it for volumes. You get your defined volumes created automatically
    when you deploy the stack. The volumes are created with default settings if no
    additional configuration is provided in the stack file. In our example, we are
    asking Docker to create a volume named `db-data`. As you may have guessed, the
    volume created actually has the name of `voteapp_db-data` because Docker prepended
    the name of our stack to the volume name. In our case, it looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 卷密钥部分基本上与网络密钥部分做了相同的事情，只是它是为卷而不是网络。当您部署堆栈时，您的定义卷将自动创建。如果在堆栈文件中没有提供额外的配置，卷将以默认设置创建。在我们的示例中，我们要求Docker创建一个名为`db-data`的卷。正如您可能已经猜到的那样，实际创建的卷的名称实际上是`voteapp_db-data`，因为Docker将我们堆栈的名称前置到卷名称之前。在我们的情况下，它看起来像这样：
- en: '![](Images/457d5f8c-cb66-4cd6-96b8-75adb3afcfe9.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/457d5f8c-cb66-4cd6-96b8-75adb3afcfe9.png)'
- en: 'So, deploying our stack created our desired networks and our desired volume.
    All with the easy-to-create, and easy-to-read-and-understand content in our stack
    compose file. OK, so we now have a good grasp of three of the four top-level key
    sections in our stack compose file. Now, let''s return to the services key section.
    If we expand this key section, we will see definitions for each of the services
    we wish to deploy as part of the application. In the case of the `docker-stack.yml`
    file, we have six services defined. These are redis, db, vote, result, worker,
    and visualizer. In the stack compose file, they look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，部署我们的堆栈创建了我们期望的网络和我们期望的卷。所有这些都是通过我们堆栈组合文件中易于创建、易于阅读和理解的内容实现的。好的，现在我们对堆栈组合文件中的四个顶级键部分中的三个有了很好的理解。现在，让我们返回到服务键部分。如果我们展开这个键部分，我们将看到我们希望作为应用程序的一部分部署的每个服务的定义。在`docker-stack.yml`文件的情况下，我们定义了六个服务。这些是redis、db、vote、result、worker和visualizer。在堆栈组合文件中，它们看起来像这样：
- en: '![](Images/3fc6f525-3d09-4045-bc56-d9da65483394.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3fc6f525-3d09-4045-bc56-d9da65483394.png)'
- en: 'Let''s expand the first one, redis, and take a closer look at what is defined
    as the redis service for our application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展第一个redis，并仔细看一下为我们的应用程序定义的redis服务：
- en: '![](Images/4bf276e3-699f-4d20-a441-9182e0db84cb.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4bf276e3-699f-4d20-a441-9182e0db84cb.png)'
- en: 'If you recall the discussion of Docker services from [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml),
    *Docker Swarm*, many of the keys shown here should seem familiar to you. Let''s
    examine the keys in the redis service now. First up, we have the `image` key.
    The image key is required for the service definition. This key is telling docker
    that the Docker image to pull and run for this service is `redis:alpine`. As you
    should understand now, this means that we are using the official redis image from
    hub.docker.com, requesting the version tagged as `alpine`. The next key, `ports`,
    is defining what port the images will be exposing from the container, and from
    the hosts. In this case, the port on the host that is to be mapped to the container''s
    exposed port (`6379`) is left to Docker to assign. You can find the port assigned
    using the `docker container ls` command. In my case, the redis service is mapping
    port `30000` on the host to port `6379` on the container. The next key used is
    `networks`. We already have seen that deploying the stack will create our networks
    for us. This directive is telling Docker which networks that the redis replica
    containers should be connected to; in this case it is the `frontend` network.
    If we inspect a redis replica container, examining the networks section, we will
    see this to be accurate. You can have a look at your deployment with a command
    such as this (note that the container name will be slightly different on your
    system):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回忆一下来自[第5章](f1681897-580b-44fb-9e43-4aed37e67529.xhtml)的Docker服务的讨论，*Docker
    Swarm*，那么这里显示的许多键对您来说应该是很熟悉的。现在让我们来检查redis服务中的键。首先，我们有`image`键。图像键是服务定义所必需的。这个键告诉docker要拉取和运行这个服务的Docker镜像是`redis:alpine`。正如您现在应该理解的那样，这意味着我们正在使用来自hub.docker.com的官方redis镜像，请求标记为`alpine`的版本。接下来使用的键是`ports`。它定义了容器将从主机暴露的端口以及主机的端口。在这种情况下，要映射到容器的暴露端口（`6379`）的主机端口由Docker分配。您可以使用`docker
    container ls`命令找到分配的端口。在我的情况下，redis服务将主机的端口`30000`映射到容器的端口`6379`。接下来使用的键是`networks`。我们已经看到部署堆栈将为我们创建网络。这个指令告诉Docker应该将redis副本容器连接到哪些网络；在这种情况下是`frontend`网络。如果我们检查redis副本容器，检查网络部分，我们将看到这是准确的。您可以使用这样的命令查看您的部署（请注意，容器名称在您的系统上可能略有不同）：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our example, you should see that the container is attached to two networks:
    the ingress network and our `voteapp_frontend` network.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，您应该看到容器连接到两个网络：入口网络和我们的`voteapp_frontend`网络。
- en: 'The next key in our redis service definition is the deploy key. This is a key
    category that was added to the compose file specification with version 3\. It
    is what defines the specifics for running the containers based on the image in
    this service: in this case, the redis image. It is essentially the orchestration
    instructions. The `replicas` tag tells docker how many copies or containers should
    be running when the application is fully deployed. In our example, we are stating
    that we only need one instance of the redis container running for our application.
    The `update_config` key provides two sub keys, `parallelism` and `delay`, that
    tell Docker how many container `replicas` should be started in parallel, and how
    much time to wait between starting each `parallel` set of container `replicas`.
    Of course, with one replica, the parallelism and delay details have little use.
    If the value for `replicas` were something greater, such as `10`, our update_config
    keys would result in two replicas starting at a time, with a wait of 10 seconds
    between starts. The final deploy key is `restart_policy`, and this defines the
    conditions that a new replica will be created in a deployed stack. In this case,
    if a redis container fails, a new redis container will be started to take its
    place. Let''s take a look at the next service in our application, the `db` service:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们redis服务定义中的下一个键是deploy键。这是在compose文件规范的3版本中添加的一个键类别。它定义了基于此服务中的镜像运行容器的具体信息：在这种情况下，是redis镜像。这实质上是编排指令。`replicas`标签告诉docker在应用程序完全部署时应该运行多少副本或容器。在我们的示例中，我们声明我们只需要一个redis容器的实例运行。`update_config`键提供了两个子键，`parallelism`和`delay`，告诉Docker应该以多少容器`replicas`并行启动，并且在启动每个`parallel`容器`replicas`之间等待多长时间。当然，对于一个副本，parallelism和delay的细节几乎没有用处。如果`replicas`的值更大，比如`10`，我们的update_config键将导致两个副本同时启动，并且在启动之间等待10秒。最后的deploy键是`restart_policy`，它定义了在部署的堆栈中新副本将被创建的条件。在这种情况下，如果一个redis容器失败，将启动一个新的redis容器来替代它。让我们来看看我们应用程序中的下一个服务，`db`服务：
- en: '![](Images/05c62070-b99e-44b6-9aeb-87a5a39cd8e4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05c62070-b99e-44b6-9aeb-87a5a39cd8e4.png)'
- en: 'The db service will have several keys in common with the redis service, but
    with different values. First, we have the image key. This time we are indicating
    that we want the official postgres image with the tag for version 9.4\. Our next
    key is the volumes key. We are indicating that we are using the volume named db-data,
    and that in the DB container the volume should be mounted at `/var/lib/postgresql/data`.
    Let''s take a look at the volume information in our environment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: db服务与redis服务将有几个相同的键，但值不同。首先，我们有image键。这次我们指定要使用带有版本9.4标签的官方postgres镜像。我们的下一个键是volumes键。我们指定我们正在使用名为db-data的卷，并且在DB容器中，卷应该挂载在`/var/lib/postgresql/data`。让我们来看看我们环境中的卷信息：
- en: '![](Images/cc874b3a-4a1f-4e7c-9205-1370c49b6cb7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cc874b3a-4a1f-4e7c-9205-1370c49b6cb7.png)'
- en: 'Using the volume inspect command, we get the volume mount point and then compare
    the contents of the folder within the container to the contents of the mount point
    on the host:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用volume inspect命令，我们可以获取卷的挂载点，然后比较容器内文件夹的内容与主机上挂载点的内容：
- en: '![](Images/c15dc49d-8cbc-44b6-92c8-17fa68ade32c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c15dc49d-8cbc-44b6-92c8-17fa68ade32c.png)'
- en: Voila! As expected, they match. This is not as straightforward on a Mac. See
    [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker Volumes,* on
    Docker volumes for details on how to handle this on OS X. The next key is the
    networks key, and here we are directing Docker to attach the backend network to
    our db container. Next up is the deploy key. Here, we see a new sub-key, called
    `placement`. This is a directive to tell Docker that we only want db containers
    to run on manager nodes, that is, on nodes that have the role of `manager`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！正如预期的那样，它们匹配。在Mac上，情况并非如此简单。有关如何在OS X上处理此问题的详细信息，请参阅[Docker Volumes](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)第4章，有关Docker卷的详细信息。接下来是网络密钥，在这里我们指示Docker将后端网络连接到我们的db容器。接下来是部署密钥。在这里，我们看到一个名为`placement`的新子密钥。这是一个指令，告诉Docker我们只希望db容器在管理节点上运行，也就是说，在具有`manager`角色的节点上。
- en: 'You may have noticed that there are some sub-keys of the deploy key that are
    present in the redis service, but are absent in our db service—most notably, the
    `replicas` key. By default, if you do not specify the number of replicas to maintain,
    Docker will default to having one replica. All in all, the description of the
    db service configuration is pretty much the same as the redis service. You will
    see this similarity between the configuration of all the services. This is because
    Docker has made it very easy to define the desired state of our services, and
    by correlation, our applications. To validate this, let''s take a look at the
    next service in the stack compose file, the `vote` service:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，部署密钥的一些子密钥存在于redis服务中，但在我们的db服务中不存在，最显著的是`replicas`密钥。默认情况下，如果您没有指定要维护的副本数量，Docker将默认为一个副本。总的来说，db服务配置的描述与redis服务几乎相同。您将看到所有服务的配置之间的相似性。这是因为Docker已经非常容易地定义了我们服务的期望状态，以及我们的应用程序。为了验证这一点，让我们来看一下堆栈组合文件中的下一个服务，即`vote`服务：
- en: '![](Images/c7b6874c-7c27-4aa9-895c-297b22c27b06.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c7b6874c-7c27-4aa9-895c-297b22c27b06.png)'
- en: You should be starting to get familiar with these keys and their values. Here
    in the vote service we see that the image defined is not one of the official container
    images, but instead is in a public repo named `dockersamples`. Within that repo,
    we are using the image named `examplevotingapp_vote`, with a version tag of `before`.
    Our ports key is telling Docker, and us, that we want to open port `5000` on the
    swarm hosts and have traffic on that port mapped to port 80 in the running vote
    service containers. As it turns out, the vote service is the `face` of our application
    and we will access it via port `5000`. Since it is a service, we can access it
    by going to port `5000` on *any* of the hosts in the swarm, even when a particular
    host is not running one of the replicas.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该开始熟悉这些密钥及其值。在投票服务中，我们看到定义的镜像不是官方容器镜像之一，而是在名为`dockersamples`的公共存储库中。在该存储库中，我们使用了名为`examplevotingapp_vote`的图像，版本标签为`before`。我们的端口密钥告诉Docker和我们，我们要在swarm主机上打开端口`5000`，并且将该端口上的流量映射到正在运行的投票服务容器中的端口80。事实证明，投票服务是我们应用程序的`face`，我们将通过端口`5000`访问它。由于它是一个服务，我们可以通过在swarm中的*任何*主机上的端口`5000`访问它，即使特定主机没有运行其中一个副本。
- en: 'Looking at the next key, we see that we are attaching the `frontend` network
    to our vote service containers. Nothing new there, however, as our next key is
    one we have not seen before: the `depends_on` key. This key is telling Docker
    that our vote service requires the redis service to function. What this means
    to our `deploy` command is that the service or services that are depended on need
    to be started before starting this service. Specifically, the redis service needs
    to be started before the vote service. One key distinction here is that I said
    started. This does not mean that the depended-upon service has to be running before
    starting this service; the depended-on service just has to be started before it.
    Again, specifically, the redis service does not have to be at the state of running
    before starting the vote service, it just has to be started before the vote service
    is started. There is nothing we haven''t seen yet in the deploy key in for the
    vote service, with the only difference being that we are asking for two replicas
    for the vote service. Are you beginning to understand the simplicity and the power
    of the service definition in the stack compose file?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看着下一个关键点，我们看到我们正在将`frontend`网络连接到我们的投票服务容器。在那里没有什么新的，然而，因为我们下一个关键点是我们以前没有见过的：`depends_on`关键点。这个关键点告诉Docker我们的投票服务需要redis服务才能运行。对于我们的`deploy`命令来说，这意味着被依赖的服务需要在启动这个服务之前启动。具体来说，redis服务需要在投票服务之前启动。这里的一个关键区别是我说的是启动。这并不意味着在启动这个服务之前必须运行依赖的服务；依赖的服务只需要在之前启动。再次强调，具体来说，redis服务在启动投票服务之前不必处于运行状态，它只需要在投票服务之前启动。在投票服务的部署关键点中，我们还没有看到任何新的东西，唯一的区别是我们要求投票服务有两个副本。你开始理解堆栈组合文件中服务定义的简单性和强大性了吗？
- en: 'The next service defined in our stack compose file is for the result service.
    However, since there are no keys present in that service definition that we haven''t
    seen in the previous services, I will skip the discussion on the result service,
    and move on to the worker service where we''ll see some new stuff. Here is the
    worker service definition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的堆栈组合文件中定义的下一个服务是结果服务。然而，由于在该服务定义中没有我们之前没有见过的关键点，我将跳过对结果服务的讨论，转而讨论工作人员服务，我们将看到一些新东西。以下是工作人员服务的定义：
- en: '![](Images/b4ddec41-7ece-487d-a782-615d8853be3c.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b4ddec41-7ece-487d-a782-615d8853be3c.png)'
- en: 'You know about the image key and what it means. You know about the networks
    key and what it means too. You know about the deploy key, but we have some new
    sub-keys here so let''s talk about them, starting with the `mode` key. You may
    recall from our discussion of services in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker
    Swarm*, that there is a `--mode `parameter that can have one of two values: `global` or
    `replicated`. This key is exactly the same as the parameter we saw in [Chapter
    5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml), *Docker Swarm*. The default value
    is replicated, and so if you do not specify the mode key, you will get the replicated
    behavior, which is to have exactly the number of replicas that are defined (or
    one replica if no number of replicas is specified). Using the other value option
    of global will ignore the replicas key and deploy exactly one container to every
    host in the swarm.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道图像密钥及其含义。你也知道网络密钥及其含义。你知道部署密钥，但是我们在这里有一些新的子密钥，所以让我们谈谈它们，从`mode`密钥开始。你可能还记得我们在[第5章](f1681897-580b-44fb-9e43-4aed37e67529.xhtml)中讨论服务时，*Docker
    Swarm*，有一个`--mode`参数，可以有两个值：`global`或`replicated`。这个密钥与我们在[第5章](f1681897-580b-44fb-9e43-4aed37e67529.xhtml)中看到的参数完全相同，*Docker
    Swarm*。默认值是replicated，所以如果你不指定mode密钥，你将得到replicated行为，即确切地有定义的副本数量（或者如果没有指定副本数量，则为一个副本）。使用global的其他值选项将忽略replicas密钥，并在集群中的每个主机上部署一个容器。
- en: 'The next key that we have not seen before in this stack compose file is the
    `labels` key. The location of this key is significant as it can appear as its
    own upper-level key, or as a sub-key to the deploy key. What is the distinction?
    When you use the `labels` key as a sub-key to the deploy key, the label will be
    set only on the service. When you use the `labels` key as its own upper-level
    key, the label will be added to each replica, or container, deployed as part of
    the service. In our example, the `APP=VOTING `label will be applied to the service
    because the `labels` key is a sub-key to the deploy key. Again, let''s see this
    in our environment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个堆栈组合文件中以前没有见过的下一个密钥是`labels`密钥。这个密钥的位置很重要，因为它可以作为自己的上层密钥出现，也可以作为deploy密钥的子密钥出现。有什么区别？当你将`labels`密钥作为deploy密钥的子密钥使用时，标签将仅设置在服务上。当你将`labels`密钥作为自己的上层密钥使用时，标签将被添加到作为服务的一部分部署的每个副本或容器中。在我们的例子中，`APP=VOTING`标签将被应用到服务，因为`labels`密钥是deploy密钥的子密钥。再次，在我们的环境中看看这个：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is what that looks like on my system:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上看起来是这样的：
- en: '![](Images/4b1b7fba-94cd-40ec-ac68-66fd1d791c1d.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4b1b7fba-94cd-40ec-ac68-66fd1d791c1d.png)'
- en: 'Executing an inspect command on a worker container to view the labels on it
    will show that the `APP=VOTING` label does not appear. If you want to confirm
    this on your system, the command will look like this (with a different container
    name):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作容器上执行inspect命令以查看其标签，将显示`APP=VOTING`标签不存在。如果你想在你的系统上确认这一点，命令将如下（使用不同的容器名称）：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, here is what it looks like on my system:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上看起来是这样的：
- en: '![](Images/c4206773-5d0a-4903-a6d6-af59fc260ead.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c4206773-5d0a-4903-a6d6-af59fc260ead.png)'
- en: Two new sub-keys for the restart_policy key are the `max_attempts` and `window`
    keys. You can probably guess their purpose; the `max_attempts` key tells Docker
    to keep trying to start the worker containers if they fail to start, up to three
    times before giving up. The `window` key tells Docker how long to wait before
    retrying to start a worker container if it failed to start previously. Pretty
    straightforward, right? Again, these definitions are easy to set up, easy to understand,
    and extremely powerful for orchestrating the services of our application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重启策略键的两个新子键是`max_attempts`和`window`键。你可能能猜到它们的目的；`max_attempts`键告诉Docker在放弃之前尝试启动工作容器的次数，最多三次。`window`键告诉Docker在之前多久等待重新尝试启动工作容器，如果之前启动失败。相当简单，对吧？同样，这些定义很容易设置，易于理解，并且对于编排我们应用程序的服务非常强大。
- en: 'Alright. We have one more service definition to review for new stuff, that
    being the visualizer service. Here is what it looks like in our stack compose
    file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们还有一个服务定义需要审查新内容，那就是可视化服务。在我们的堆栈组合文件中，它看起来是这样的：
- en: '![](Images/9a9366b9-a6af-4510-990e-0c8af430a4da.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9a9366b9-a6af-4510-990e-0c8af430a4da.png)'
- en: The only truly new key is the `stop_grace_period` key. This key tells Docker
    how long to wait after it tells a container to stop before it will forcefully
    stop the container. The default time period, if the `stop_grace_period` key is
    not used, is 10 seconds. When you need to update a stack, essentially do a re-stack,
    the containers of a service will be told to shut down gracefully. Docker will
    wait for the amount of time specified in the `stop_grace_period` key, or for 10
    seconds if the key is not provided. If the container shuts down during that time,
    the container will be removed, and a new container will be started in its place.
    If the container does not shut down during that window of time, it will be stopped
    by force, killing it, then removing it, then starting a new container to take
    its place. The significance of this key is that it allows the necessary time for
    containers that are running processes that take longer to stop gracefully to actually
    stop gracefully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正新的键是`stop_grace_period`键。这个键告诉Docker在它告诉一个容器停止之后等待多长时间才会强制停止容器。如果没有使用`stop_grace_period`键，默认时间段是10秒。当你需要更新一个堆栈，本质上是重新堆叠，一个服务的容器将被告知优雅地关闭。Docker将等待在`stop_grace_period`键中指定的时间量，或者如果没有提供键，则等待10秒。如果容器在那段时间内关闭，容器将被移除，并且一个新的容器将被启动来取代它。如果容器在那段时间内没有关闭，它将被强制停止，杀死它，然后移除它，然后启动一个新的容器来取代它。这个键的重要性在于它允许运行需要更长时间才能优雅停止的进程的容器有必要的时间来实际优雅停止。
- en: 'The last aspect of this service that I want to point out and that is regarding
    the kind of strange volume listed. This is not a typical volume and has no entry
    in the volumes key definitions. The `/var/run/docker.sock:/var/run/docker.sock`
    volume is a way to access the Unix socket that the host''s Docker daemon is listening
    on. In this case, it''s allowing the container to communicate with its host. The
    visualizer container is gathering information about what containers are running
    on what hosts and is able to present that data in a graphical way. You will notice
    that it maps the 8080 host port to the 8080 container port, so we can have a look
    at what data it shares by browsing to port 8080 on any of our swarm nodes. Here
    is what it looks like on my (current) three-node swarm:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出这项服务的最后一个方面，那就是关于列出的有点奇怪的卷。这不是一个典型的卷，并且在卷键定义中没有条目。`/var/run/docker.sock:/var/run/docker.sock`卷是一种访问主机的Docker守护程序正在侦听的Unix套接字的方式。在这种情况下，它允许容器与其主机通信。可视化器容器正在收集关于哪些容器在哪些主机上运行的信息，并且能够以图形方式呈现这些数据。你会注意到它将8080主机端口映射到8080容器端口，所以我们可以通过浏览到任何我们的swarm节点上的8080端口来查看它共享的数据。这是我（当前）三节点swarm上的样子：
- en: '![](Images/51807fb7-0768-419a-80af-5281df5e2ef8.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/51807fb7-0768-419a-80af-5281df5e2ef8.png)'
- en: The rest of the stack commands
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈其余命令
- en: 'Now, let''s take a quick look at our other stack-related commands through the
    lens of the swarm where we deployed our `voteapp` stack. First up, we have the
    list stacks command: `docker stack ls`. Giving that a try looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过我们部署了`voteapp`堆栈的swarm的视角快速看一下我们的其他与堆栈相关的命令。首先，我们有列出堆栈的命令：`docker stack
    ls`。试一下看起来像这样：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is what it looks like in the example environment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例环境中的样子：
- en: '![](Images/9b32a41a-3a67-427f-bc1c-a6d2167d52aa.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b32a41a-3a67-427f-bc1c-a6d2167d52aa.png)'
- en: 'This is showing that we have one stack named voteapp currently deployed, and
    that it is composed of six services and is using swarm mode for its orchestration.
    Knowing the name of a deploy stack allows us to gather more information about
    it using the other stack commands. Next up is the list stack tasks command. Let''s
    give this command a try in our example environment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们当前部署了一个名为voteapp的堆栈，它由六个服务组成，并且正在使用swarm模式进行编排。知道部署堆栈的名称可以让我们使用其他堆栈命令来收集更多关于它的信息。接下来是列出堆栈任务的命令。让我们在示例环境中尝试一下这个命令：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are the results in my environment right now; yours should look very similar:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我当前环境中的结果；你的应该看起来非常相似：
- en: '![](Images/d6dbb6ce-fbfb-4386-8250-2bfd9bc4857e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d6dbb6ce-fbfb-4386-8250-2bfd9bc4857e.png)'
- en: 'Now, we will have a look at the stack services command. This command will give
    us a nice summary of the services that are deployed as part of our stack application.
    The command looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看堆栈服务命令。这个命令将为我们提供一个关于作为堆栈应用程序一部分部署的服务的简要摘要。命令看起来像这样：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is what we see in the example environment:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在示例环境中看到的：
- en: '![](Images/d7c657d4-540a-433b-97ee-b230735ed4c8.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d7c657d4-540a-433b-97ee-b230735ed4c8.png)'
- en: 'This command provides some very useful information. We can quickly see the
    names of our services, the number of replicas desired, and the actual number of
    replicas for each service. We can see the image used to deploy each service, and
    we can see the port mapping used for each service. Here, we can see the visualizer
    service is using port `8080`, as we mentioned earlier. We can also see that our
    vote service is exposed on port `5000` of our swarm hosts. Let''s have a look
    at what we are presenting in our voteapp by browsing to port `5000` (on any node
    in the swarm) now:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提供了一些非常有用的信息。我们可以快速看到我们服务的名称，所需副本的数量，以及每个服务的实际副本数量。我们可以看到用于部署每个服务的镜像，并且我们可以看到每个服务使用的端口映射。在这里，我们可以看到可视化服务正在使用端口`8080`，就像我们之前提到的那样。我们还可以看到我们的投票服务暴露在我们集群主机的端口`5000`上。让我们通过浏览到端口`5000`（在集群中的任何节点上）来看看我们在我们的voteapp中展示了什么：
- en: '![](Images/96258e39-c554-4dd6-b33c-697eb17986ec.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/96258e39-c554-4dd6-b33c-697eb17986ec.png)'
- en: 'Are you a dog person or a cat person? You can express yourself by voting in
    your own voteapp! Cast your vote and then use the data in the stack service command
    to see the results of the vote by browsing to port `5001`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你是狗派还是猫派？你可以通过在你自己的voteapp中投票来表达自己！投票然后使用堆栈服务命令中的数据来查看投票结果，浏览到端口`5001`：
- en: '![](Images/7c015ab2-78dd-47e0-b949-dffb749946d9.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7c015ab2-78dd-47e0-b949-dffb749946d9.png)'
- en: 'Yes, I am a dog person. There is one final stack command: the remove command.
    We can quickly and easily take down an application deployed with the stack deploy
    command by issuing the `rm` command. Here is what that looks like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我是一个狗派。还有一个最终的堆栈命令：删除命令。我们可以通过发出`rm`命令来快速轻松地关闭使用堆栈部署的应用程序。看起来是这样的：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you see it, now you don''t:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到它了，现在你看不到了：
- en: '![](Images/46c33edf-aa70-4eb8-9eb3-598d69cab70a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/46c33edf-aa70-4eb8-9eb3-598d69cab70a.png)'
- en: You should notice that there was none of the are you sure? hand-holding, so
    be very sure and very careful before pressing *Enter* on this command. Let's close
    out the discussion on Docker stacks with a quick look at the best practices for
    scaling or restacking an application deployed as a Docker stack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到这里没有任何“你确定吗？”的提示，所以在按下*Enter*键之前一定要非常确定和非常小心。让我们通过快速查看作为Docker堆栈部署的应用程序的扩展或重新堆叠的最佳实践来结束对Docker堆栈的讨论。
- en: Best practices for scaling a stack application
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展堆栈应用程序的最佳实践
- en: 'As with most things Docker, there are a few different ways to accomplish desired
    states for your applications. When you are using Docker stacks, you should always
    use the same method for updating the application as you did for deploying it.
    Make any desired state changes in the stack compose file, and then run the exact
    same command you used to deploy the stack. This allows you to use standard source-code-control
    features to properly handle your compose file, such as tracking and reviewing
    changes. And, it allows Docker to do the right things for orchestrating your application.
    If you need to scale a service up or down within your application, you should
    update the replicas key in the stack compose file and then run the deploy command
    again. In our example, we have two replicas for our vote service. If the demands
    for voting skyrocketed, we can easily scale our application by changing the replica
    value from 2 to, say, 16 by editing the `docker-stack.yml` file, then issuing
    the same command we originally used to deploy the application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Docker相关的事物一样，有几种不同的方法可以实现应用程序的期望状态。当您使用Docker堆栈时，应始终使用与部署应用程序相同的方法来更新应用程序。在堆栈compose文件中进行任何期望的状态更改，然后运行与部署堆栈时使用的完全相同的命令。这允许您使用标准源代码控制功能来正确处理您的compose文件，例如跟踪和审查更改。而且，它允许Docker正确地为您的应用程序进行编排。如果您需要在应用程序中缩放服务，您应该在堆栈compose文件中更新replicas键，然后再次运行部署命令。在我们的示例中，我们的投票服务有两个副本。如果投票需求激增，我们可以通过将replica值从2更改为16来轻松扩展我们的应用程序，方法是编辑`docker-stack.yml`文件，然后发出与最初用于部署应用程序相同的命令：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we check the services, we can see we are scaling our app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们检查服务时，我们可以看到我们正在扩展我们的应用程序：
- en: '![](Images/c8149abc-acce-4e48-bf42-3d65cb21a180.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c8149abc-acce-4e48-bf42-3d65cb21a180.png)'
- en: There you have it, an easy-to-use, easy-to-understand, and very, very powerful
    Docker application orchestration!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，一个易于使用、易于理解且非常强大的Docker应用程序编排！
- en: References
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Check out the following links for more information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接获取更多信息：
- en: The compose file reference: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose文件参考：[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
- en: Some compose file examples: [https://github.com/play-with-docker/stacks](https://github.com/play-with-docker/stacks)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Compose文件示例：[https://github.com/play-with-docker/stacks](https://github.com/play-with-docker/stacks)
- en: Docker sample images on Docker hub: [https://hub.docker.com/u/dockersamples/](https://hub.docker.com/u/dockersamples/)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker hub上的示例镜像：[https://hub.docker.com/u/dockersamples/](https://hub.docker.com/u/dockersamples/)
- en: Official redis image tags found on Docker hub: [https://hub.docker.com/r/library/redis/tags/](https://hub.docker.com/r/library/redis/tags/)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker hub上找到的官方redis镜像标签：[https://hub.docker.com/r/library/redis/tags/](https://hub.docker.com/r/library/redis/tags/)
- en: A great article about using the Docker daemon socket: [https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd](https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用Docker守护程序套接字的精彩文章：[https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd](https://medium.com/lucjuggery/about-var-run-docker-sock-3bfd276e12fd)
- en: The stack deploy command reference: [https://docs.docker.com/engine/reference/commandline/stack_deploy/](https://docs.docker.com/engine/reference/commandline/stack_deploy/)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈部署命令参考：[https://docs.docker.com/engine/reference/commandline/stack_deploy/](https://docs.docker.com/engine/reference/commandline/stack_deploy/)
- en: The stack ps command reference: [https://docs.docker.com/engine/reference/commandline/stack_ps/](https://docs.docker.com/engine/reference/commandline/stack_ps/)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈ps命令参考：[https://docs.docker.com/engine/reference/commandline/stack_ps/](https://docs.docker.com/engine/reference/commandline/stack_ps/)
- en: The stack services command reference: [https://docs.docker.com/engine/reference/commandline/stack_services/](https://docs.docker.com/engine/reference/commandline/stack_services/)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈服务命令参考：[https://docs.docker.com/engine/reference/commandline/stack_services/](https://docs.docker.com/engine/reference/commandline/stack_services/)
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now you know a lot about Docker stacks. You can easily create application definitions
    with a compose file and then deploy those applications using the stack deploy
    command. You can explore the details of your deployed stacks with the ls, ps,
    and services commands. You can scale your applications with easy modifications
    to your compose file and by executing the same command used to deploy your app.
    Finally, you can remove an application that has reached the end of its life with
    the stack rm command. With great power comes great responsibility, so be very
    careful with that remove command. You have enough information to create and orchestrate world-class
    enterprise-grade applications now, so get busy! However, if you would like to
    learn how to use Docker with Jenkins, you'll be pleased to know that that's the
    topic of [Chapter 8](88652c62-a041-4cec-b42c-0aaa414d7083.xhtml), *Docker and
    Jenkins*, so turn the page and start reading!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对Docker堆栈有了很多了解。你可以使用compose文件轻松创建应用程序定义，然后使用stack deploy命令部署这些应用程序。你可以使用ls、ps和services命令探索已部署堆栈的细节。你可以通过对compose文件进行简单修改并执行与部署应用程序相同的命令来扩展你的应用程序。最后，你可以使用stack
    rm命令移除已经到达生命周期终点的应用程序。伴随着强大的能力而来的是巨大的责任，所以在使用移除命令时要非常小心。现在你已经有足够的信息来创建和编排世界级的企业级应用程序了，所以开始忙碌起来吧！然而，如果你想学习如何将Docker与Jenkins一起使用，你会很高兴地知道这就是第8章《Docker和Jenkins》的主题，所以翻开书页开始阅读吧！
