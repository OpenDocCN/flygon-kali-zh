- en: Chapter 3. Working with Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Docker镜像
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating an account with Docker Hub
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub上创建一个帐户
- en: Creating an image from the container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器创建一个镜像
- en: Publishing an image to the registry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像发布到注册表
- en: Looking at the history of an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看镜像的历史
- en: Deleting an image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除镜像
- en: Exporting an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出镜像
- en: Importing an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入镜像
- en: Building images using Dockerfiles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建镜像
- en: Building an Apache image – a Dockerfile example
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Apache镜像 - 一个Dockerfile示例
- en: Accessing Firefox from a container – a Dockerfile example
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器中访问Firefox - 一个Dockerfile示例
- en: Building a WordPress image – a Dockerfile example
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建WordPress镜像 - 一个Dockerfile示例
- en: Setting up a private index/registry
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置私有索引/注册表
- en: Automated Builds – with GitHub and Bitbucket
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化构建 - 使用GitHub和Bitbucket
- en: Creating the base image – using supermin
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基础镜像 - 使用supermin
- en: Creating the base image – using Debootstrap
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基础镜像 - 使用Debootstrap
- en: Visualizing dependencies between layers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化层之间的依赖关系
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In this chapter, we will focus on operations relating to images. As we know,
    images are required to run containers. You can either use existing images or create
    new custom images. You will need to create custom images to suit your development
    and deployment environment. Once you create an image, you can share it through
    the public or private registry. Before we explore more about Docker images, let''s
    look at the output of the `docker info` command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于与镜像相关的操作。正如我们所知，运行容器需要镜像。您可以使用现有的镜像或创建新的自定义镜像。您需要创建自定义镜像以适应您的开发和部署环境。创建镜像后，您可以通过公共或私有注册表共享它。在我们更多地探索Docker镜像之前，让我们看一下`docker
    info`命令的输出：
- en: '![Introduction](../Images/image00297.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00297.jpeg)'
- en: 'The preceding command gives the current system-wide info as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了当前系统范围的信息如下：
- en: It has 21 containers and 21 images.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有21个容器和21个镜像。
- en: The current storage driver, `devicemapper`, and its related information, such
    as thin pool name, data, metadata file, and so on. Other types of storage drivers
    are aufs, btrfs, overlayfs, vfs, and so on. Devicemapper, btrfs, and overlayfs
    have native support in the Linux kernel. AUFS support needs a patched kernel.
    We talked about the Union filesystem in [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction
    and Installation"), *Introduction and Installation*.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的存储驱动程序，`devicemapper`，以及与之相关的信息，如thin pool名称，数据，元数据文件等。其他类型的存储驱动程序包括aufs，btrfs，overlayfs，vfs等。Devicemapper，btrfs和overlayfs在Linux内核中有原生支持。AUFS支持需要一个经过修补的内核。我们在[第1章](part0015.xhtml#aid-E9OE2
    "第1章。介绍和安装")中讨论了Union文件系统，*介绍和安装*。
- en: To leverage the kernel features that enable containerization, the Docker daemon
    has to talk to the Linux kernel. This is done through the execution driver. `libconatiner`
    or `native` is one of that type. The others are `libvirt`, `lxc`, and so on, which
    we saw in [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation"),
    *Introduction and Installation*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了利用启用容器化的内核特性，Docker守护程序必须与Linux内核通信。这是通过执行驱动程序完成的。`libconatiner`或`native`是其中之一。其他的有`libvirt`，`lxc`等，我们在[第1章](part0015.xhtml#aid-E9OE2
    "第1章。介绍和安装")中看到了，*介绍和安装*。
- en: The kernel version on the host operating system.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机操作系统上的内核版本。
- en: The user account that is registered on the registry mentioned in the next section
    to pull/push images.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一节提到的注册表上注册的用户帐户以拉取/推送镜像。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I am using Fedora 20/21 as my primary environment to run the recipes. They should
    also work with other environments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用Fedora 20/21作为运行配方的主要环境。它们也应该适用于其他环境。
- en: Creating an account with Docker Hub
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker Hub上创建一个帐户
- en: Docker Hub is like GitHub for images. It is a public registry on which you can
    host images both public and private, share them and collaborate with others. It
    has integration with GitHub, Bitbucket, and can trigger automated builds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub就像图像的GitHub。它是一个公共注册表，您可以在其中托管图像，包括公共和私有图像，并与他人合作。它与GitHub、Bitbucket集成，并可以触发自动构建。
- en: As of now, the creation of an account on Docker Hub is free. A repository can
    hold different versions of an image. You can create any number of public repositories
    for your images. By default, you will have one private repository, which will
    not be accessible to the public. You can buy more private repositories. You can
    create an account either through a web browser or from the command line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Docker Hub上创建帐户是免费的。一个仓库可以容纳图像的不同版本。您可以为您的图像创建任意数量的公共仓库。默认情况下，您将拥有一个私有仓库，该仓库对公众不可见。您可以购买更多的私有仓库。您可以通过Web浏览器或命令行创建帐户。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To sign up from the command line, you will need to have Docker installed on
    your system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行注册，您需要在系统上安装Docker。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To create an account through a web browser on Docker Hub, visit [https://hub.docker.com/account/signup/](https://hub.docker.com/account/signup/)
    and create an account:![How to do it…](../Images/image00298.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过Docker Hub的Web浏览器创建帐户，请访问[https://hub.docker.com/account/signup/](https://hub.docker.com/account/signup/)并创建一个帐户：![如何做...](../Images/image00298.jpeg)
- en: 'To create an account using the command line, run the following command and
    submit the required details:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用命令行创建一个帐户，请运行以下命令并提交所需的详细信息：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding steps will create a Docker Hub account for you. Once the account
    is created, you'll get a confirmation mail, through which you need to confirm
    your identity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤将为您创建一个Docker Hub帐户。帐户创建后，您将收到一封确认邮件，通过该邮件您需要确认您的身份。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The documentation on the Docker website:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档：
- en: '[https://docs.docker.com/docker-hub](https://docs.docker.com/docker-hub)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-hub](https://docs.docker.com/docker-hub)'
- en: '[https://docs.docker.com/docker-hub/accounts/](https://docs.docker.com/docker-hub/accounts/)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-hub/accounts/](https://docs.docker.com/docker-hub/accounts/)'
- en: Creating an image from the container
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从容器创建镜像
- en: There are a couple of ways to create images, one is by manually committing layers
    and the other way is through Dockerfiles. In this recipe, we'll see the former
    and look at Dockerfiles later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建镜像的方法，一种是手动提交层，另一种是通过Dockerfile。在这个教程中，我们将看到前者，稍后在本章中再看Dockerfile。
- en: As we start a new container, a read/write layer gets attached to it. This layer
    will get destroyed if we do not save it. In this recipe, we will see how to save
    that layer and make a new image from the running or stopped container using the
    `docker commit` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个新的容器时，会附加一个读/写层。如果我们不保存这个层，它将被销毁。在这个教程中，我们将看到如何保存这个层，并使用`docker commit`命令从正在运行或停止的容器中创建一个新的镜像。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get a Docker image, start a container with it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Docker镜像，请使用它启动一个容器。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To do the commit, run the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行提交，请运行以下命令：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's start a container and create/modify some files using the `install httpd`
    package:![How to do it…](../Images/image00299.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动一个容器并使用`install httpd`包创建/修改一些文件：![如何做...](../Images/image00299.jpeg)
- en: 'Then, open a new terminal and create a new image by doing the commit:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开一个新的终端并通过提交创建一个新的镜像：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![How to do it…](../Images/image00300.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00300.jpeg)'
- en: As you can see, the new image is now being committed to the local repository
    with `nkhare/fedora` as a name and `httpd` as a tag.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新的镜像现在正在使用`nkhare/fedora`作为名称和`httpd`作为标签提交到本地仓库。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In [Chapter 1](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation"),
    *Introduction and Installation*, we saw that while starting a container, a read/write
    filesystem layer will be created on top of the existing image layers from which
    the container started, and with the installation of a package, some files would
    have been added/modified in that layer. All of those changes are currently in
    the ephemeral read/write filesystem layer, which is assigned to the container.
    If we stop and delete the container, then all of the earlier mentioned modifications
    would be lost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation")*介绍和安装*中，我们看到在启动容器时，将在容器启动的现有镜像层之上创建一个读/写文件系统层，并且通过安装软件包，一些文件将被添加/修改到该层中。所有这些更改目前都在临时的读/写文件系统层中，该层分配给容器。如果我们停止并删除容器，那么所有先前提到的修改将丢失。
- en: Using commit, we create a new layer with the changes that have occurred since
    the container started, which get saved in the backend storage driver.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用commit，我们创建一个新的层，其中包含自容器启动以来发生的更改，这些更改保存在后端存储驱动程序中。
- en: There's more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'To look for files, which are changed since the container started:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找自容器启动以来已更改的文件：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our case, we will see something like the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将看到类似以下代码的内容：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see a prefix before each entry of the output. The following is a list
    of those prefixes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出的每个条目之前看到一个前缀。以下是这些前缀的列表：
- en: '`A`: This is for when a file/directory has been added'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`: 当文件/目录被添加时'
- en: '`C`: This is for when a file/directory has been modified'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`: 当文件/目录被修改时'
- en: '`D`: This is for when a file/directory has been deleted'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`: 当文件/目录被删除时'
- en: By default, a container gets paused while doing the commit. You can change its
    behavior by passing `--pause=false` to commit.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，在执行提交时容器会被暂停。您可以通过传递`--pause=false`来更改其行为。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker commit`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker commit`的`help`选项：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#commit](https://docs.docker.com/reference/commandline/cli/#commit)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/commandline/cli/#commit](https://docs.docker.com/reference/commandline/cli/#commit)
- en: Publishing an image to the registry
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像发布到注册表
- en: Let's say you have created an image that suits the development environment in
    your organization. You can either share it using tar ball, which we'll see later
    in this chapter, or put in a central location from where the user can pull it.
    This central location can be either a public or a private registry. In this recipe,
    we'll see how to push the image to the registry using the `docker push` command.
    Later in this chapter, we'll cover how to set up the private registry.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经创建了一个适合组织开发环境的镜像。您可以使用tar ball进行共享，我们将在本章后面看到，或者将其放在用户可以拉取的中央位置。这个中央位置可以是公共的或私有的注册表。在本教程中，我们将看到如何使用`docker
    push`命令将镜像推送到注册表。在本章后面，我们将介绍如何设置私有注册表。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a valid account on Docker Hub to push images/repositories.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Docker Hub上拥有有效的帐户才能推送镜像/仓库。
- en: A local registry must be set up if you are pushing images/repositories locally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要推送本地镜像/仓库，必须设置本地注册表。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, the preceding command will use the username and registry shown in
    the `docker info` command to push the images. As shown in the preceding screenshot,
    the command will use `nkhare` as the username and `https://index.docker.io/v1/`
    as the registry.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，前面的命令将使用`docker info`命令中显示的用户名和注册表来推送镜像。如前面的屏幕截图所示，该命令将使用`nkhare`作为用户名，`https://index.docker.io/v1/`作为注册表。
- en: 'To push the image that we created in the previous section, run the following
    command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送在上一节中创建的图像，请运行以下命令：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How to do it…](../Images/image00301.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00301.jpeg)'
- en: Let's say you want to push the image to the local registry, which is hosted
    on a host called `local-registry`. To do this, you first need to tag the image
    with the registry host's name or IP address with the port number on which the
    registry is running and then push the images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要将图像推送到本地注册表，该注册表托管在名为`local-registry`的主机上。为此，您首先需要使用注册表主机的名称或IP地址以及注册表正在运行的端口号对图像进行标记，然后推送图像。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example, let''s say our registry is configured on `shadowfax.example.com`,
    then to tag the image use the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的注册表配置在`shadowfax.example.com`上，然后使用以下命令标记图像：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, to push the image, use the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要推送图像，请使用以下命令：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It will first list down all the intermediate layers that are required to make
    that specific image. It will then check to see, out of those layers, how many
    are already present inside the registry. At last, it will copy all the layers,
    which are not present in the registry with the metadata required to build the
    image.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将首先列出制作特定图像所需的所有中间层。然后，它将检查这些层中有多少已经存在于注册表中。最后，它将复制所有不在注册表中的层，并附上构建图像所需的元数据。
- en: There's more…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'As we pushed our image to the public registry, we can log in to Docker Hub
    and look for the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将图像推送到公共注册表时，我们可以登录Docker Hub并查找图像：
- en: '![There''s more…](../Images/image00302.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](../Images/image00302.jpeg)'
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker push`:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker push`的`help`选项：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#push](https://docs.docker.com/reference/commandline/cli/#push)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/commandline/cli/#push](https://docs.docker.com/reference/commandline/cli/#push)
- en: Looking at the history of an image
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看图像的历史记录
- en: It is handy to know how the image that we are using has been created. The `docker
    history` command helps us find all the intermediate layers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们正在使用的图像是如何创建的很方便。`docker history`命令帮助我们找到所有中间层。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Pull or import any Docker image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取或导入任何Docker图像。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To look at the history of the image, consider the following syntax:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看图像的历史记录，请考虑以下语法：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s an example using the preceding syntax:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上述语法的示例：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How to do it…](../Images/image00303.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00303.jpeg)'
- en: How it works…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: From the metadata of an image, Docker can know how an image is being created.
    With the `history` command, it will look at the metadata recursively to get to
    the origin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图像的元数据，Docker可以知道图像是如何创建的。使用`history`命令，它将递归查看元数据以找到原始来源。
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Look at the commit message of a layer that got committed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看已提交层的提交消息：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Currently, there is no direct way to look at the commit message for each layer
    using one single command, but we can use the `inspect` command, which we saw earlier,
    for each layer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有直接的方法可以使用一个命令查看每个层的提交消息，但是我们可以使用`inspect`命令，我们之前看到的，对每个层进行查看。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker history`:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker history`的`help`选项：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#history](https://docs.docker.com/reference/commandline/cli/#history)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/commandline/cli/#history](https://docs.docker.com/reference/commandline/cli/#history)
- en: Deleting an image
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除图像
- en: To remove the image from the host, we can use the `docker rmi` command. However,
    this does not remove images from the registry.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要从主机中删除图像，我们可以使用`docker rmi`命令。但是，这不会从注册表中删除图像。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure one or more Docker images are locally available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一个或多个Docker图像在本地可用。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To remove the image, consider the following syntax:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除图像，请考虑以下语法：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In our case, here''s an example using the preceding syntax:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，以下是使用前述语法的示例：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it…](../Images/image00304.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00304.jpeg)'
- en: There's more…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you want to remove all containers and images, then do following; however,
    be sure about what you are doing, as this is very destructive:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除所有容器和镜像，请执行以下操作；但是，请确保自己知道自己在做什么，因为这是非常具有破坏性的：
- en: 'To stop all containers, use the following command:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止所有容器，请使用以下命令：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To delete all containers, use the following command:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除所有容器，请使用以下命令：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To delete all images, use the following command:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除所有图像，请使用以下命令：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker rmi`:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker rmi`的`help`选项：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#rmi](https://docs.docker.com/reference/commandline/cli/#rmi)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/commandline/cli/#rmi](https://docs.docker.com/reference/commandline/cli/#rmi)
- en: Exporting an image
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出图像
- en: Let's say you have a customer who has very strict policies that do not allow
    them to use images from the public domain. In such cases, you can share images
    through tarballs, which later can be imported on another system. In this recipe,
    we will see how to do that using the `docker save` command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个客户，其非常严格的政策不允许他们使用来自公共领域的图像。在这种情况下，您可以通过tar文件共享图像，稍后可以在另一个系统上导入。在本示例中，我们将看到如何使用`docker
    save`命令来做到这一点。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Pull or import one or more Docker images on the Docker host.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker主机上拉取或导入一个或多个Docker图像。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Use the following syntax to save the image in the tar file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语法将图像保存在tar文件中：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, to create a tar archive for Fedora, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为Fedora创建一个tar归档，请运行以下命令：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the tag name is specified with the image name we want to export, such as
    `fedora:latest`, then only the layers related to that tag will get exported.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了标签名称与我们要导出的图像名称，例如`fedora:latest`，那么只有与该标签相关的层将被导出。
- en: There's more…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If `--output` or `-o` is not used, then the output will be streamed to `STDOUT`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用`--output`或`-o`，输出将被流式传输到`STDOUT`：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, the contents of the container''s filesystem can be exported using
    the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用以下命令导出容器文件系统的内容：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker save` and `docker export`:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker save`和`docker export`的`help`选项：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The documentation on the Docker website:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档：
- en: '[https://docs.docker.com/reference/commandline/cli/#save](https://docs.docker.com/reference/commandline/cli/#save)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/reference/commandline/cli/#save](https://docs.docker.com/reference/commandline/cli/#save)'
- en: '[https://docs.docker.com/reference/commandline/cli/#export](https://docs.docker.com/reference/commandline/cli/#export)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/reference/commandline/cli/#export](https://docs.docker.com/reference/commandline/cli/#export)'
- en: Importing an image
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入图像
- en: To get a local copy of the image, we either need to pull it from the accessible
    registry or import it from the already exported image, as we saw in the earlier
    recipe. Using the `docker import` command, we import an exported image.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得图像的本地副本，我们需要从可访问的注册表中拉取它，或者从已导出的图像中导入它，就像我们在之前的示例中看到的那样。使用`docker import`命令，我们导入一个已导出的图像。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need an accessible exported Docker image.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个可访问的导出的Docker镜像。
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To import an image, we can use following syntax:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导入图像，我们可以使用以下语法：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here''s an example using the preceding syntax:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用前述语法的示例：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, you can consider the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以考虑以下示例：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example will first create an empty filesystem and then import
    the contents.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将首先创建一个空的文件系统，然后导入内容。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Look at the `help` option of `docker import`:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker import`的`help`选项：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/commandline/cli/#import](https://docs.docker.com/reference/commandline/cli/#import)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/commandline/cli/#import](https://docs.docker.com/reference/commandline/cli/#import)
- en: Building images using Dockerfiles
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建映像
- en: Dockerfiles help us in automating image creation and getting precisely the same
    image every time we want it. The Docker builder reads instructions from a text
    file (a Dockerfile) and executes them one after the other in order. It can be
    compared as Vagrant files, which allows you to configure VMs in a predictable
    manner.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile帮助我们自动化映像创建，并在我们每次需要时获得完全相同的映像。Docker构建器从文本文件（Dockerfile）中读取指令，并按顺序依次执行。它可以与Vagrant文件进行比较，Vagrant文件允许您以可预测的方式配置虚拟机。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A Dockerfile with build instructions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 具有构建指令的Dockerfile。
- en: 'Create an empty directory:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空目录：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a file named `Dockerfile` with the following content:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Run the following command inside the directory, where we created Dockerfile
    to build the image:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Dockerfile的目录中运行以下命令来构建映像：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it…](../Images/image00305.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](../Images/image00305.jpeg)'
- en: 'We did not specify any repository or tag name while building the image. We
    can give those with the `-t` option as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建映像时，我们没有指定任何存储库或标签名称。我们可以使用`-t`选项来指定：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![How to do it…](../Images/image00306.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](../Images/image00306.jpeg)'
- en: 'The preceding output is different from what we did earlier. However, here we
    are using a cache after each instruction. Docker tries to save the intermediate
    images as we saw earlier and tries to use them in subsequent builds to accelerate
    the build process. If you don''t want to cache the intermediate images, then add
    the `--no-cache` option with the build. Let''s take a look at the available images
    now:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出与我们之前所做的不同。然而，在这里，我们在每个指令之后都使用缓存。Docker尝试保存中间映像，就像我们之前看到的那样，并尝试在后续构建中使用它们来加速构建过程。如果你不想缓存中间映像，那么在构建时添加`--no-cache`选项。现在让我们来看一下可用的映像：
- en: '![How to do it…](../Images/image00307.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](../Images/image00307.jpeg)'
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A context defines the files used to build the Docker image. In the preceding
    command, we define the context to the build. The build is done by the Docker daemon
    and the entire context is transferred to the daemon. This is why we see the `Sending
    build context to Docker daemon 2.048 kB` message. If there is a file named `.dockerignore`
    in the current working directory with the list of files and directories (new line
    separated), then those files and directories will be ignored by the build context.
    More details about `.dockerignore` can be found at [https://docs.docker.com/reference/builder/#the-dockerignore-file](https://docs.docker.com/reference/builder/#the-dockerignore-file).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文定义了用于构建Docker映像的文件。在前面的命令中，我们将上下文定义为构建。构建由Docker守护程序完成，并且整个上下文被传输到守护程序。这就是为什么我们看到`Sending
    build context to Docker daemon 2.048 kB`消息。如果当前工作目录中有一个名为`.dockerignore`的文件，其中包含文件和目录的列表（以换行符分隔），那么这些文件和目录将被构建上下文忽略。有关`.dockerignore`的更多详细信息，请参阅[https://docs.docker.com/reference/builder/#the-dockerignore-file](https://docs.docker.com/reference/builder/#the-dockerignore-file)。
- en: After executing each instruction, Docker commits the intermediate image and
    runs a container with it for the next instruction. After the next instruction
    has run, Docker will again commit the container to create the intermediate image
    and remove the intermediate container created in the previous step.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 执行每个指令后，Docker会提交中间镜像并为下一个指令运行一个容器。在下一个指令运行后，Docker将再次提交容器以创建中间镜像，并删除在上一步中创建的中间容器。
- en: 'For example, in the preceding screenshot, `eb9f10384509` is an intermediate
    image and `c5d4dd2b3db9` and `ffb9303ab124` are the intermediate containers. After
    the last instruction is executed, the final image will be created. In this case,
    the final image is `4778dd1f1a7a`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的屏幕截图中，`eb9f10384509`是一个中间镜像，`c5d4dd2b3db9`和`ffb9303ab124`是中间容器。执行最后一个指令后，将创建最终镜像。在这种情况下，最终镜像是`4778dd1f1a7a`：
- en: '![How it works…](../Images/image00308.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](../Images/image00308.jpeg)'
- en: 'The `-a` option can be specified with the `docker images` command to look for
    intermediate layers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`docker images`命令中使用`-a`选项来查找中间层：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The format of the Dockerfile is:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的格式如下：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generally, instructions are given in uppercase, but they are not case sensitive.
    They are evaluated in order. A `#` at the beginning is treated like a comment.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，指令以大写形式给出，但它们不区分大小写。它们按顺序进行评估。以`#`开头的内容被视为注释。
- en: 'Let''s take a look at the different types of instructions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同类型的指令：
- en: '`FROM`: This must be the first instruction of any Dockerfile, which sets the
    base image for subsequent instructions. By default, the latest tag is assumed
    to be:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：这必须是任何Dockerfile的第一个指令，它为后续指令设置了基础镜像。默认情况下，假定为最新标签：'
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, consider the following tag:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑以下标签：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There can be more than one `FROM` instruction in one Dockerfile to create multiple
    images.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Dockerfile中可以有多个`FROM`指令，以创建多个镜像。
- en: 'If only image names, such as Fedora and Ubuntu are given, then the images will
    be downloaded from the default Docker registry (Docker Hub). If you want to use
    private or third-party images, then you have to mention this as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只提供镜像名称，例如Fedora和Ubuntu，则将从默认的Docker注册表（Docker Hub）下载镜像。如果要使用私有或第三方镜像，则必须按以下方式提及：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is an example using the preceding syntax:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上述语法的示例：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`MAINTAINER`: This sets the author for the generated image, `MAINTAINER <name>`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINER`：这为生成的镜像设置了作者，`MAINTAINER <name>`。'
- en: '`RUN`: We can execute the `RUN` instruction in two ways—first, run in the shell
    (`sh -c`):'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：我们可以以两种方式执行`RUN`指令——首先，在shell中运行（`sh -c`）：'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Second, directly run an executable:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，直接运行可执行文件：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we know with Docker, we create an overlay—a layer on top of another layer—to
    make the resulting image. Through each `RUN` instruction, we create and commit
    a layer on top of the earlier committed layer. A container can be started from
    any of the committed layers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，使用Docker，我们创建一个覆盖层——在另一个层之上的一层——以创建最终的镜像。通过每个`RUN`指令，我们创建并提交一个层，放在之前提交的层之上。可以从任何已提交的层启动容器。
- en: By default, Docker tries to cache the layers committed by different `RUN` instructions,
    so that it can be used in subsequent builds. However, this behavior can be turned
    off using `--no-cache flag` while building the image.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker会尝试缓存不同`RUN`指令提交的层，以便在后续构建中使用。但是，可以在构建镜像时使用`--no-cache`标志来关闭此行为。
- en: '`LABEL`: Docker 1.6 added a new feature to the attached arbitrary key-value
    pair to Docker images and containers. We covered part of this in the *Labeling
    and filtering containers* recipe in [Chapter 2](part0022.xhtml#aid-KVCC1 "Chapter 2. Working
    with Docker Containers"), *Working with Docker Containers*. To give a label to
    an image, we use the `LABEL` instruction in the Dockerfile as `LABEL distro=fedora21`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`：Docker 1.6添加了一个新功能，可以将任意键值对附加到Docker镜像和容器上。我们在[第2章](part0022.xhtml#aid-KVCC1
    "第2章。使用Docker容器")的*标记和过滤容器*中介绍了部分内容，*使用Docker容器*。要为图像添加标签，我们在Dockerfile中使用`LABEL`指令，如`LABEL
    distro=fedora21`。'
- en: '`CMD`: The `CMD` instruction provides a default executable while starting a
    container. If the `CMD` instruction does not have an executable (parameter 2),
    then it will provide arguments to `ENTRYPOINT`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：`CMD`指令在启动容器时提供默认可执行文件。如果`CMD`指令没有可执行文件（参数2），那么它将为`ENTRYPOINT`提供参数。'
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Only one `CMD` instruction is allowed in a Dockerfile. If more than one is specified,
    then only the last one will be honored.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中只允许一个`CMD`指令。如果指定了多个指令，则只有最后一个会被采纳。
- en: '`ENTRYPOINT`: This helps us configure the container as an executable. Similar
    to `CMD`, there can be at max one instruction for `ENTRYPOINT`; if more than one
    is specified, then only the last one will be honored:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：这有助于我们将容器配置为可执行文件。与`CMD`类似，`ENTRYPOINT`最多只能有一条指令；如果指定了多条指令，则只有最后一条会被采纳：'
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once the parameters are defined with the `ENTRYPOINT` instruction, they cannot
    be overwritten at runtime. However, `ENTRYPOINT` can be used as `CMD`, if we want
    to use different parameters to `ENTRYPOINT`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`ENTRYPOINT`指令定义了参数，它们就不能在运行时被覆盖。但是，如果我们想要对`ENTRYPOINT`使用不同的参数，可以将`ENTRYPOINT`用作`CMD`。
- en: '`EXPOSE`: This exposes the network ports on the container on which it will
    listen at runtime:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`：这将在容器上暴露网络端口，容器将在其中运行时监听：'
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can also expose a port while starting the container. We covered this in the
    *Exposing a port while starting a container* recipe in [Chapter 2](part0022.xhtml#aid-KVCC1
    "Chapter 2. Working with Docker Containers"), *Working with Docker Containers*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在启动容器时暴露端口。我们在[第2章](part0022.xhtml#aid-KVCC1 "第2章。使用Docker容器")的*在启动容器时暴露端口*中介绍了这一点，*使用Docker容器*。
- en: '`ENV`: This will set the environment variable `<key>` to `<value>`. It will
    be passed all the future instructions and will persist when a container is run
    from the resulting image:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：这将将环境变量`<key>`设置为`<value>`。它将传递所有未来的指令，并在从生成的镜像运行容器时持久存在：'
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ADD`: This copies files from the source to the destination:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：这将文件从源复制到目的地：'
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following one is for the path containing white spaces:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含空格的路径：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`<src>`: This must be the file or directory inside the build directory from
    which we are building an image, which is also called the context of the build.
    A source can be a remote URL as well.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`：这必须是构建目录中的文件或目录，我们正在从中构建图像，也称为构建的上下文。源也可以是远程URL。'
- en: '`<dest>`: This must be the absolute path inside the container in which the
    files/directories from the source will be copied.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dest>`：这必须是容器内的绝对路径，源中的文件/目录将被复制到其中。'
- en: '`COPY`: This is similar to `ADD.COPY <src> <dest>`:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：这类似于`ADD.COPY <src> <dest>`：'
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`VOLUME`: This instruction will create a mount point with the given name and
    flag it as mounting the external volume using the following syntax:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`：此指令将使用以下语法创建具有给定名称的挂载点，并将其标记为使用外部卷进行挂载：'
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Alternatively, you can use the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下代码：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`USER`: This sets the username for any of the following run instructions using
    the following syntax:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：这将使用以下语法为任何后续的运行指令设置用户名：'
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`WORKDIR`: This sets the working directory for the `RUN`, `CMD`, and `ENTRYPOINT`
    instructions that follow it. It can have multiple entries in the same Dockerfile.
    A relative path can be given which will be relative to the earlier `WORKDIR` instruction
    using the following syntax:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：这为随后的`RUN`、`CMD`和`ENTRYPOINT`指令设置工作目录。它可以在同一个Dockerfile中有多个条目。可以给出相对路径，它将相对于之前的`WORKDIR`指令，使用以下语法：'
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`ONBUILD`: This adds trigger instructions to the image that will be executed
    later, when this image will be used as the base image of another image. This trigger
    will run as part of the `FROM` instruction in downstream Dockerfile using the
    following syntax:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD`：这将向图像添加触发指令，稍后将在将此图像用作另一个图像的基本图像时执行。此触发器将作为下游Dockerfile中的`FROM`指令的一部分运行，使用以下语法：'
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker build`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker build`的`help`选项：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
- en: Building an Apache image – a Dockerfile example
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Apache镜像 - 一个Dockerfile示例
- en: I am going to refer Dockerfiles from the Fedora-Dockerfiles GitHub repo ([https://github.com/fedora-cloud/Fedora-Dockerfiles](https://github.com/fedora-cloud/Fedora-Dockerfiles))
    after forking it. If you are using Fedora, then you can also install the `fedora-dockerfiles`
    package to get the sample Dockerfiles in `/usr/share/fedora-dockerfiles`. In each
    of the subdirectories, you will put a Dockerfile, the supporting files and a README
    file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在从Fedora-Dockerfiles GitHub存储库（[https://github.com/fedora-cloud/Fedora-Dockerfiles](https://github.com/fedora-cloud/Fedora-Dockerfiles)）中引用Dockerfiles，之后对其进行分叉。如果您使用的是Fedora，那么您也可以安装`fedora-dockerfiles`软件包，以获取`/usr/share/fedora-dockerfiles`中的示例Dockerfiles。在每个子目录中，您将放置一个Dockerfile、支持文件和一个README文件。
- en: The Fedora-Dockerfiles GitHub repo would have the latest examples and I highly
    recommend that you try out latest bits.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora-Dockerfiles GitHub存储库将具有最新的示例，我强烈建议您尝试最新的内容。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令克隆Fedora-Dockerfiles Git存储库：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, go to the `apache` subdirectory:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`apache`子目录：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The other supporting files are:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持文件包括：
- en: '`README.md`: This is the README file'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这是README文件'
- en: '`run-apache.sh`: This is the script to run `HTTPD` in the foreground'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run-apache.sh`：这是在前台运行`HTTPD`的脚本'
- en: '`LICENSE`: This is the GPL license'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`：这是GPL许可证'
- en: How to do it…
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following `build` command, we can build a new image:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`build`命令，我们可以构建一个新的镜像：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The build process takes a base image, installs the required `HTTPD` package
    and creates an HTML page. Then, it exposes port `80` to serve the web page and
    sets instructions to start Apache at the start of the container.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程需要一个基本镜像，安装所需的`HTTPD`软件包并创建一个HTML页面。然后，它公开端口`80`以提供网页，并设置指令在容器启动时启动Apache。
- en: There's more…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Let''s run the container from the created image, get its IP address, and access
    the web page from it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建的镜像中运行容器，获取其IP地址，并从中访问网页：
- en: '![There''s more…](../Images/image00309.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](../Images/image00309.jpeg)'
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker build`:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker build`的`help`选项：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
- en: Accessing Firefox from a container – a Dockerfile example
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从容器访问Firefox - 一个Dockerfile示例
- en: We can do something more interesting through a Dockerfile, such as creating
    a container that just runs Firefox. This kind of use case can help run multiple
    browsers of different versions on the same machine, which can be very helpful
    in doing multibrowser testing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过Dockerfile做一些更有趣的事情，比如创建一个只运行Firefox的容器。这种用例可以帮助在同一台机器上运行不同版本的多个浏览器，这在进行多浏览器测试时非常有帮助。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令克隆Fedora-Dockerfiles Git存储库：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Then, go to the `firefox` subdirectory.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`firefox`子目录。
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Supporting files:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 支持文件：
- en: '`README.md`: This is a README file'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这是一个README文件'
- en: '`LICENSE`: This is the GPL license'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`：这是GPL许可证'
- en: '`xstartup`: This is the script to set up the X11 environment'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xstartup`：这是设置X11环境的脚本'
- en: How to do it…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the following command to build the image:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令构建镜像：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start with the base Fedora image, install X Windows System, Firefox, a VNC
    server, and other packages. We then set up the VNC server to start X Windows System,
    which will start Firefox.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的Fedora镜像开始，安装X Windows System，Firefox，VNC服务器和其他软件包。然后设置VNC服务器启动X Windows
    System，然后启动Firefox。
- en: There's more...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To start the container, run the following command:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要启动容器，请运行以下命令：
- en: '[PRE63]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And give `123456` as the password.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 并输入`123456`作为密码。
- en: 'While running the container, we mapped the `5901` port of the host to `5901`
    port of the container. In order to connect to the VNC server inside the container,
    just run the following command from another terminal:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行容器时，我们将主机的`5901`端口映射到容器的`5901`端口。为了连接容器内的VNC服务器，只需从另一个终端运行以下命令：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Alternatively, from another machine in the network, replace `localhost` with
    the Docker host's IP address or FQDN.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从网络中的另一台机器上，用Docker主机的IP地址或FQDN替换`localhost`。
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker build`:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker build`的`help`选项：
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
- en: Building a WordPress image – a Dockerfile example
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建WordPress镜像-一个Dockerfile示例
- en: So far we have seen the example of running just one service inside a container.
    If we want to run an application, which requires us to run one or more services
    simultaneously, then, either we will need to run them on the same container or
    run them on different containers and link them together. WordPress is one such
    example that requires a database and web service.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在容器中运行一个服务的示例。如果我们想要运行一个需要同时运行一个或多个服务的应用程序，那么我们要么需要在同一个容器上运行它们，要么在不同的容器上运行它们并将它们链接在一起。WordPress就是一个这样的例子，它需要数据库和web服务。
- en: Docker only likes one process per container running in the foreground. Thus,
    in order to make Docker happy, we have a controlling process that manages the
    database and web services. The controlling process, in this case, is supervisord
    ([http://supervisord.org/](http://supervisord.org/)). This is a trick we are using
    to make Docker happy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Docker只喜欢每个容器中运行的前台一个进程。因此，为了让Docker满意，我们有一个控制进程来管理数据库和web服务。在这种情况下，控制进程是supervisord（[http://supervisord.org/](http://supervisord.org/)）。这是我们用来让Docker满意的一个技巧。
- en: Again, we will use a Dockerfile from the Fedora-Dockerfiles repository.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将使用Fedora-Dockerfiles存储库中的Dockerfile。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the Fedora-Dockerfiles Git repo using the following command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令克隆Fedora-Dockerfiles Git存储库：
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, go to the `wordpress_single_container` subdirectory:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`wordpress_single_container`子目录：
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The supporting files used in the preceding code are explained as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中使用的支持文件解释如下：
- en: '`foreground.sh`: This is a script to run HTTPS in the foreground.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foreground.sh`：这是一个在前台运行HTTPS的脚本。'
- en: '`LICENSE`, `LICENSE.txt`, and `UNLICENSE.txt`: These files contain the license
    information.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`、`LICENSE.txt`和`UNLICENSE.txt`：这些文件包含许可信息。'
- en: '`README.md`: This is a README file.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这是一个README文件。'
- en: '`supervisord.conf`: This is a resulting container which will have to run `SSHD`,
    `MySQL`, and `HTTPD` at the same time. In this particular case, the supervisor
    is used to manage them. It is a configuration file of the supervisor. More information
    about this can be found at [http://supervisord.org/](http://supervisord.org/).'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supervisord.conf`：这是一个结果容器，必须同时运行`SSHD`、`MySQL`和`HTTPD`。在这种特殊情况下，使用supervisor来管理它们。这是supervisor的配置文件。有关此的更多信息，请访问[http://supervisord.org/](http://supervisord.org/)。'
- en: '`start.sh`: This is a script to set up MySQL, HTTPD, and to start the supervisor
    daemon.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start.sh`：这是一个设置MySQL、HTTPD并启动supervisor守护进程的脚本。'
- en: How to do it…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'As with the other recipes, we start with the base image, install the required
    packages, and copy the supporting files. We will then set up `sudo`, `download`,
    and `untar` WordPress inside the HTTPD document root. After this, we expose the
    ports and run the start.sh scripts, which sets up MySQL, WordPress, HTTPS permissions
    and gives control to supervisord. In the `supervisord.conf`, you will see entries,
    such as the following services that supervisord manages:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，我们从基本镜像开始，安装所需的软件包，并复制支持文件。然后设置`sudo`、`download`和`untar` WordPress在HTTPD文档根目录内。之后，我们暴露端口并运行start.sh脚本，该脚本设置MySQL、WordPress、HTTPS权限并将控制权交给supervisord。在`supervisord.conf`中，您将看到supervisord管理的以下服务条目：
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There's more…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Start the container, get its IP address and open it through a web browser. You
    should see the Welcome screen, as shown in the following screenshot, after doing
    the language selection:![There's more…](../Images/image00310.jpeg)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动容器，获取其IP地址并通过Web浏览器打开。在进行语言选择后，您应该看到欢迎屏幕，如下面的屏幕截图所示：![还有更多…](../Images/image00310.jpeg)
- en: It is now possible to run systemd inside the container, which is a more preferred
    way. Systemd can manage more than one service .You can look at the example of
    systemd at [https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以在容器内运行systemd，这是一种更受欢迎的方式。Systemd可以管理多个服务。您可以在[https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/systemd)中查看systemd的示例。
- en: See also
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `help` option of `docker build`:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`docker build`的`help`选项：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The documentation on the Docker website [https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/reference/builder/](https://docs.docker.com/reference/builder/)
- en: Setting up a private index/registry
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置私有索引/注册表
- en: 'As we saw earlier, the public Docker registry is the available Docker Hub ([https://registry.hub.docker.com/](https://registry.hub.docker.com/))
    through which users can push/pull images. We can also host a private registry
    either on a local environment or on the cloud. There are a few ways to set up
    the local registry:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，公共Docker注册表是可用的Docker Hub（[https://registry.hub.docker.com/](https://registry.hub.docker.com/)），用户可以通过它推送/拉取镜像。我们还可以在本地环境或云上托管私有注册表。有几种设置本地注册表的方法：
- en: Use the Docker registry from Docker Hub
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Hub的Docker注册表
- en: 'Build an image from Dockerfile and run a registry container:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建镜像并运行注册表容器：
- en: '[https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry](https://github.com/fedora-cloud/Fedora-Dockerfiles/tree/master/registry)'
- en: Configure the distribution-specific package such as Fedora, which provides the
    docker-registry package that you can install and configure.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置特定于发行版的软件包，例如提供了docker-registry软件包的Fedora。
- en: The easiest way to set it up is through the registry container itself.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 设置它的最简单方法是通过注册表容器本身。
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker守护程序在主机上运行，并且您可以通过Docker客户端进行连接。
- en: How to do it…
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To run the registry on the container, run the following command:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在容器上运行注册表，请运行以下命令：
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To test the newly created registry, perform the following steps:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试新创建的注册表，请执行以下步骤：
- en: 'Start a container and its ID by using the following command:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动容器及其ID：
- en: '[PRE72]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If needed, attach to the newly created container and make some changes. Then,
    commit those changes to the local repository:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，附加到新创建的容器并进行一些更改。然后，将这些更改提交到本地存储库：
- en: '[PRE73]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To push the image to the local registry, we need to tag the image with the
    hostname or IP address of the registry host. Let''s say our registry host is `registry-host`;
    then, to tag it, use the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将镜像推送到本地注册表，我们需要使用注册表主机的主机名或IP地址对镜像进行标记。假设我们的注册表主机是 `registry-host`；然后，要对其进行标记，请使用以下命令：
- en: '[PRE74]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As we have not configured HTTPS correctly while starting the registry, we will
    get an error such as the `ping attempt failed with error: Get https://dockerhost:5000/v1/_ping`,
    which is expected. For our example to work, we need to add the `--insecure-registry
    registry-host:5000` option to the daemon. If you have started the Docker daemon
    manually, then we have to run the command as follows to allow insecure registry:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于我们在启动注册表时没有正确配置HTTPS，因此我们将收到错误，例如 `ping attempt failed with error: Get https://dockerhost:5000/v1/_ping`，这是预期的。为了使我们的示例工作，我们需要向守护程序添加
    `--insecure-registry registry-host:5000` 选项。如果您手动启动了Docker守护程序，那么我们必须按照以下方式运行命令以允许不安全的注册表：'
- en: '[PRE75]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To push the image, use the following command:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要推送镜像，请使用以下命令：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To pull the image from the local registry, run the following command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从本地注册表中拉取镜像，请运行以下命令：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The preceding command to pull the image will download the official registry
    image from Docker Hub and run it on port `5000`. The `-p` option publishes the
    container port to the host system's port. We will look at the details about port
    publishing in the next chapter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker Hub下载官方注册表镜像并在端口 `5000` 上运行它的上述命令。`-p` 选项将容器端口发布到主机系统的端口。我们将在下一章中详细了解端口发布的细节。
- en: 'The registry can also be configured on any existing servers using the docker-registry
    app. The steps to do this are available at the docker-registry GitHub page:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用docker-registry应用程序在任何现有服务器上配置注册表。执行此操作的步骤可在docker-registry GitHub页面上找到：
- en: '[https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)'
- en: There's more…
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Let''s look at Dockerfile of docker-registry to understand how the registry
    image is being created and how to set different configuration options:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 docker-registry 的 Dockerfile，以了解注册表镜像是如何创建的，以及如何设置不同的配置选项：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the preceding Dockerfile, we will:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述Dockerfile，我们将：
- en: Take Ubuntu's base image install/update packages
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ubuntu的基本镜像安装/更新软件包
- en: Copy the docker-registry source code inside the image
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将docker-registry源代码复制到镜像中
- en: Use the `pip install` docker-registry
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pip install` docker-registry
- en: Set up the configuration file to use while running the registry using the environment
    variable
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置在运行注册表时使用的配置文件的环境变量
- en: Set up the flavor to use while running the registry using the environment variable
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量设置运行注册表时要使用的flavor
- en: Expose port `5000`
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露端口 `5000`
- en: Run the registry executable
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行注册表可执行文件
- en: 'Flavors in the configuration file (`/docker-registry/config/config_sample.yml`)
    provide different ways to configure the registry. With the preceding Dockerfile,
    we will set the `dev` flavor using the environment variables. The different types
    of flavors are:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件（`/docker-registry/config/config_sample.yml`）中的风格提供了配置注册表的不同方式。使用上述 Dockerfile，我们将使用环境变量设置`dev`风格。不同类型的风格包括：
- en: '`common`: This is used by all the other flavors as base settings'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`: 这是所有其他风格的基本设置'
- en: '`local`: This stores data on the local filesystem'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`: 这将数据存储在本地文件系统中'
- en: '`s3`: This stores data in an AWS S3 bucket'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s3`: 这将数据存储在 AWS S3 存储桶中'
- en: '`dev`: This is the basic configuration using the local flavors'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`: 这是使用本地风格的基本配置'
- en: '`test`: This is used by unit tests'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 这是单元测试使用的配置'
- en: '`prod`: This is the production configuration (basically a synonym for the S3
    flavor)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prod`: 这是生产配置（基本上是 S3 风格的同义词）'
- en: '`gcs`: This stores data in Google cloud storage'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcs`: 这将数据存储在 Google 云存储中'
- en: '`swift`: This stores data in OpenStack Swift'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swift`: 这将数据存储在 OpenStack Swift 中'
- en: '`glance`: This stores data in OpenStack Glance, with a fallback to the local
    storage'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glance`: 这将数据存储在 OpenStack Glance 中，备用为本地存储'
- en: '`glance-swift`: This stores data in OpenStack Glance, with a fallback to Swift'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glance-swift`: 这将数据存储在 OpenStack Glance 中，备用为 Swift'
- en: '`elliptics`: This stores data in Elliptics key-value storage'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elliptics`: 这将数据存储在椭圆键值存储中'
- en: For each of preceding flavors, different configuration options such as loglevel,
    authentication, and so on are available. The documentation for all of the options
    are available on the GitHub page of docker-registry, which I mentioned earlier.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述每种风格，都有不同的配置选项，例如日志级别、身份验证等。所有选项的文档都可以在我之前提到的 docker-registry 的 GitHub 页面上找到。
- en: See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation on GitHub [https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 上的文档 [https://github.com/docker/docker-registry](https://github.com/docker/docker-registry)
- en: Automated builds – with GitHub and Bitbucket
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub 和 Bitbucket 进行自动构建
- en: We have seen earlier how to push the Docker images to Docker Hub. Docker Hub
    allows us to create automated images from a GitHub/Bitbucket repository using
    its build clusters. The GitHub/Bitbucket repository should contain the Dockerfile
    and the content required to copy/add inside the image. Let's look at a GitHub
    example in the upcoming sections.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到如何将 Docker 镜像推送到 Docker Hub。Docker Hub 允许我们使用其构建集群从 GitHub/Bitbucket
    存储库创建自动化镜像。GitHub/Bitbucket 存储库应包含 Dockerfile 和所需的内容以复制/添加到镜像中。让我们在接下来的部分中看一个
    GitHub 的例子。
- en: Getting ready
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an account on Docker Hub and GitHub. You will also need a GitHub
    repository with a corresponding Dockerfile at the top level.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要在 Docker Hub 和 GitHub 上拥有帐户。您还需要一个具有相应 Dockerfile 的 GitHub 存储库，位于顶层。
- en: How to do it…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Log in to Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) and
    click on the green plus sign. Add the Repository icon on the top right-hand side
    corner and click on **Automated Build**. Select GitHub as a source to use for
    automated build. Then, select the **Public and Private (recommended)** option
    to connect to GitHub. Provide the GitHub username/password when prompted. Select
    the GitHub repository to perform automated build.![How to do it…](../Images/image00311.jpeg)
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）并单击绿色加号。在右上角添加存储库图标，然后单击**自动化构建**。选择
    GitHub 作为自动化构建的源。然后，选择**公共和私有（推荐）**选项以连接到 GitHub。在提示时提供 GitHub 用户名/密码。选择要执行自动化构建的
    GitHub 存储库。![如何做…](../Images/image00311.jpeg)
- en: After selecting the GitHub repository, it will ask you to pick its branch to
    use for automated build. It will also ask for a tag name to use after the image
    it automatically built. By default, the latest tag name will be used. Then, click
    on the **Save and trigger build** button to start the automated build process.
    That's it!! Your build is now submitted. You can click on the build status to
    check the status of the build.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择GitHub存储库后，它会要求您选择要用于自动构建的分支。它还会要求您提供一个标签名称，以在自动构建的镜像之后使用。默认情况下，将使用最新的标签名称。然后，单击**保存并触发构建**按钮开始自动构建过程。就是这样！您的构建现在已提交。您可以单击构建状态来检查构建的状态。
- en: How it works…
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we select a GitHub repository for automated build, GitHub enables the Docker
    service for that repository. You can look at the **Settings** section of the GitHub
    repository for more configuration. Whenever we make any changes to this GitHub
    repository, such as commits, an automated build gets triggered using the Dockerfile
    that resides in the GitHub repository.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择GitHub存储库进行自动构建时，GitHub会为该存储库启用Docker服务。您可以查看GitHub存储库的**设置**部分以进行更多配置。每当我们对这个GitHub存储库进行任何更改，比如提交，都会使用存储在GitHub存储库中的Dockerfile触发自动构建。
- en: '![How it works…](../Images/image00312.jpeg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](../Images/image00312.jpeg)'
- en: There's more…
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can get the details such as the Dockerfile, build details tags, and other
    information, by going to the **Your Repositories** section. It also has the details
    of how to pull your image:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过转到**您的存储库**部分来获取诸如Dockerfile、构建详细信息标签和其他信息。它还包含了如何拉取您的镜像的详细信息：
- en: '![There''s more…](../Images/image00313.jpeg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](../Images/image00313.jpeg)'
- en: The images that get created using the automated build process cannot be pushed
    through the `docker push` command.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动构建过程创建的镜像无法通过`docker push`命令推送。
- en: You can change the settings in the **Webhooks & Services** section of the repository
    on GitHub to unregister the Docker service. This will stop doing the automated
    builds.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的**Webhooks & Services**部分更改设置，以注销Docker服务。这将停止自动构建。
- en: See also
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The steps for setting up automated build with Bitbucket are almost identical.
    The hook for automated build gets configured under the **Hooks** section of Bitbucket
    repository's **Settings** section.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bitbucket设置自动构建的步骤几乎相同。自动构建的挂钩在Bitbucket存储库的**设置**部分的**Hooks**部分下进行配置。
- en: The documentation on the Docker website [https://docs.docker.com/docker-hub/builds/](https://docs.docker.com/docker-hub/builds/)
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/docker-hub/builds/](https://docs.docker.com/docker-hub/builds/)
- en: Creating the base image – using supermin
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基础镜像-使用supermin
- en: Earlier in this chapter, we used the `FROM` instruction to pick the base image
    to start with. The image we create can become the base image to containerize another
    application and so on. From the very beginning to this chain, we will have a base
    image from the underlying Linux distribution that we want to use such as Fedora,
    Ubuntu, CentOS, and so on.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们使用了`FROM`指令来选择要开始的基础镜像。我们创建的镜像可以成为另一个应用程序容器化的基础镜像，依此类推。从一开始到这个链条，我们将有一个来自我们想要使用的基础Linux发行版的基础镜像，比如Fedora、Ubuntu、CentOS等。
- en: To build such a base image, we will need to have a distribution-specific base
    system installed into a directory, which can then be imported as an image to Docker.
    With chroot utility, we can fake a directory as the root filesystem and then put
    all the necessary files inside it before importing it as a Docker image. Supermin
    and Debootstrap are the kind of tools that can help us make the preceding process
    easier.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这样的基础镜像，我们需要在目录中安装特定于发行版的基本系统，然后将其导入为Docker镜像。使用chroot实用程序，我们可以将一个目录伪装成根文件系统，然后在导入为Docker镜像之前将所有必要的文件放入其中。Supermin和Debootstrap是可以帮助我们使前述过程更容易的工具。
- en: Supermin is a tool to build supermin appliances. These are tiny appliances,
    which get fully instantiated on the fly. Earlier this program was called febootstrap.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Supermin是构建supermin应用程序的工具。这些是微型应用程序，可以在飞行中完全实例化。早期这个程序被称为febootstrap。
- en: Getting ready
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install supermin on the system where you want to build the base image. You
    can install supermin on Fedora with the following command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在要构建基础镜像的系统上安装supermin。您可以使用以下命令在Fedora上安装supermin：
- en: '[PRE79]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Using the `prepare` mode install `bash`, `coreutils`, and the related dependencies
    inside a directory.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`prepare`模式在目录中安装`bash`，`coreutils`和相关依赖项。
- en: '[PRE80]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s an example using the preceding syntax:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用前述语法的示例：
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, with the `build` mode, create a chrooted environment for the base image:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`build`模式为基础镜像创建一个chroot环境：
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s an example using the preceding syntax :'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用前述语法的示例：
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If we do `ls` on the output directory, we will see a directory tree similar
    to any Linux root filesystem:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在输出目录上执行`ls`，我们将看到一个类似于任何Linux根文件系统的目录树：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we can export the directory as a Docker image with the following command:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令将目录导出为Docker镜像：
- en: '[PRE85]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, look at the `docker images` output. You should have a new image with `nkhare/f21_base`
    as the name.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看`docker images`输出。您应该有一个名为`nkhare/f21_base`的新镜像。
- en: How it works…
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Supermins has two modes, `prepare` and `build`. With the `prepare` mode, it
    just puts all the requested packages with their dependencies inside a directory
    without copying the host OS specific files.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Supermin有两种模式，`prepare`和`build`。使用`prepare`模式，它只是将所有请求的软件包及其依赖项放在一个目录中，而不复制主机操作系统特定的文件。
- en: With the `build` mode, the previously created supermin appliance from the `prepare`
    mode gets converted into a full blown bootable appliance with all the necessary
    files. This step will copy the required files/binaries from the host machine to
    the appliance directory, so the packages must be installed on the host machines
    that you want to use in the appliance.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`build`模式，先前通过`prepare`模式创建的supermin应用程序将被转换为具有所有必要文件的完整可引导应用程序。此步骤将从主机复制所需的文件/二进制文件到应用程序目录，因此必须在要在应用程序中使用的主机机器上安装软件包。
- en: The `build` mode has two output formats, chroot, and ext2\. With the chroot
    format, the directory tree gets written into the directory, and with the ext2
    format, a disk image gets created. We exported the directory created through the
    chroot format to create the Docker image.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`模式有两种输出格式，chroot和ext2。使用chroot格式，目录树被写入目录中，而使用ext2格式，则创建磁盘映像。我们通过chroot格式导出创建的目录来创建Docker镜像。'
- en: There's more…
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Supermin is not specific to Fedora and should work on any Linux distribution.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Supermin不特定于Fedora，应该适用于任何Linux发行版。
- en: See also
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Look at the `man` page of supermin for more information using the following
    command:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令查看supermin的`man`页面以获取更多信息：
- en: '[PRE86]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The online documentation [http://people.redhat.com/~rjones/supermin/](http://people.redhat.com/~rjones/supermin/)
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线文档[http://people.redhat.com/~rjones/supermin/](http://people.redhat.com/~rjones/supermin/)
- en: The GitHub repository [https://github.com/libguestfs/supermin](https://github.com/libguestfs/supermin)
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub存储库[https://github.com/libguestfs/supermin](https://github.com/libguestfs/supermin)
- en: Creating the base image – using Debootstrap
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本镜像-使用Debootstrap
- en: Debootstrap is a tool to install a Debian-based system into a directory of an
    already installed system.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Debootstrap是一种工具，用于将基于Debian的系统安装到已安装系统的目录中。
- en: Getting ready
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install `debootstrap` on the Debian-based system using the following command:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Debian的系统上使用以下命令安装`debootstrap`：
- en: '[PRE87]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How to do it…
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following command can be used to create the base image using Debootstrap:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于使用Debootstrap创建基本镜像：
- en: '[PRE88]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`SUITE` refers to the release code name and `MIRROR` is the respective repository.
    If you wanted to create the base image of Ubuntu 14.04.1 LTS (Trusty Tahr), then
    do the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUITE`指的是发布代码名称，`MIRROR`是相应的存储库。如果您想创建Ubuntu 14.04.1 LTS（Trusty Tahr）的基本镜像，则执行以下操作：'
- en: Create a directory on which you want to install the OS. Debootstrap also creates
    the chroot environment to install a package, as we saw earlier with supermin.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要安装操作系统的目录上创建一个目录。Debootstrap还创建了chroot环境以安装软件包，就像我们之前在supermin中看到的那样。
- en: '[PRE89]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, using `debootstrap`, install Trusty Tahr inside the directory we created
    earlier:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`debootstrap`在我们之前创建的目录中安装Trusty Tahr：
- en: '[PRE90]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You will see the directory tree similar to any Linux root filesystem, inside
    the directory in which Trusty Tahr is installed.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到类似于任何Linux根文件系统的目录树，位于Trusty Tahr安装的目录内。
- en: '[PRE91]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we can export the directory as a Docker image with the following command:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将目录导出为Docker镜像：
- en: '[PRE92]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, look at the `docker images` output. You should have a new image with `nkhare/trusty_base`
    as the name.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看`docker images`输出。您应该有一个名为`nkhare/trusty_base`的新镜像。
- en: See also
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Debootstrap wiki page [https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debootstrap维基页面[https://wiki.debian.org/Debootstrap](https://wiki.debian.org/Debootstrap)。
- en: There are a few other ways to create base images. You can find links to them
    at [https://docs.docker.com/articles/baseimages/](https://docs.docker.com/articles/baseimages/).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他几种创建基本镜像的方法。您可以在[https://docs.docker.com/articles/baseimages/](https://docs.docker.com/articles/baseimages/)找到链接。
- en: Visualizing dependencies between layers
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化层之间的依赖关系
- en: As the number of images grows, it becomes difficult to find relation between
    them. There are a few utilities for which you can find the relation between images.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 随着镜像数量的增加，找到它们之间的关系变得困难。有一些实用程序可以找到镜像之间的关系。
- en: Getting ready
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: One or more Docker images on the host running the Docker daemon.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Docker守护程序的主机上有一个或多个Docker镜像。
- en: How to do it…
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Run the following command to get a tree-like view of the images:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以获取图像的树状视图：
- en: '[PRE93]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works…
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The dependencies between layers will be fetched from the metadata of the Docker
    images.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 层之间的依赖关系将从Docker镜像的元数据中获取。
- en: There's more…
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'From `--viz` to `docker` `images`, we can see dependencies graphically; to
    do this, you will need to have the `graphviz` package installed:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 从`--viz`到`docker` `images`，我们可以以图形方式看到依赖关系；要做到这一点，您需要安装`graphviz`软件包：
- en: '[PRE94]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As it states in the warning that appears when running the preceding commands,
    the `-t` and `--viz` options might get deprecated soon.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在运行上述命令时出现的警告中所述，`-t`和`--viz`选项可能很快就会被弃用。
- en: See also
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The following project tries to visualize Docker data as well by using raw JSON
    output from Docker [https://github.com/justone/dockviz](https://github.com/justone/dockviz)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下项目尝试通过使用来自Docker的原始JSON输出来可视化Docker数据[https://github.com/justone/dockviz](https://github.com/justone/dockviz)
