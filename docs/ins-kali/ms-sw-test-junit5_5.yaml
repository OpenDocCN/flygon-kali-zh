- en: Integration Of JUnit 5 With External Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5与外部框架的集成
- en: If I have seen further than others, it is by standing upon the shoulders of
    giants.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我看得比别人更远，那是因为我站在巨人的肩膀上。
- en: '- Isaac Newton'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾萨克·牛顿'
- en: 'As described in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New in JUnit*, the extension model of JUnit 5 allows us to extend the
    core functionality of JUnit 5 by a third party (tool vendor, developers, and so
    on). In the Jupiter extension model, an extension point is a callback interface
    that the extension implements and then registers (activates) in the JUnit 5 framework.
    As we will discover in this chapter, the JUnit 5 extension model can be used to
    provide seamless integration with existing third-party frameworks. Concretely,
    in this chapter, we review JUnit 5 extension for the following technologies:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中描述的，JUnit 5的扩展模型允许我们通过第三方（工具供应商、开发人员等）扩展JUnit
    5的核心功能。在Jupiter扩展模型中，扩展点是扩展实现的回调接口，然后在JUnit 5框架中注册（激活）。正如我们将在本章中发现的那样，JUnit 5的扩展模型可以用于与现有第三方框架提供无缝集成。具体来说，在本章中，我们将审查JUnit
    5与以下技术的扩展：
- en: '**Mockito**: Mock (test double) unit testing framework.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mockito**：模拟（测试替身）单元测试框架。'
- en: '**Spring**: A Java framework for building enterprise applications.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring**：用于构建企业应用程序的Java框架。'
- en: '**Selenium**: A testing framework to automate the navigation and assessment
    of web applications.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**：用于自动化导航和评估Web应用程序的测试框架。'
- en: '**Cucumber**: Testing framework which allows us to create acceptance tests
    written following a **Behavior-Driven Development** (**BDD**) style.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cucumber**：测试框架，允许我们按照**行为驱动开发**（**BDD**）风格编写验收测试。'
- en: '**Docker**: A software technology which allows us to pack and run any application
    as a lightweight and portable container.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：一种软件技术，允许我们将任何应用程序打包并作为轻量级和可移植的容器运行。'
- en: 'Moreover, we discover that the JUnit 5 extension model is not the only way
    to integrate with the external world. Concretely, we study how JUnit 5 can be
    used together with the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们发现JUnit 5扩展模型并不是与外部世界集成的唯一方式。具体来说，我们研究了JUnit 5如何与以下内容一起使用：
- en: '**Android** (mobile operating system based on Linux): We can run Jupiter tests
    in an Android project using a Gradle plugin for JUnit 5.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**（基于Linux的移动操作系统）：我们可以使用JUnit 5的Gradle插件在Android项目中运行Jupiter测试。'
- en: '**REST** (architectural style for designing distributed systems): We can interact
    and verify REST services simply using third-party libraries (such as REST Assured
    or WireMock), or using the fully integrated approach of Spring (tests together
    with the service implementation).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST**（用于设计分布式系统的架构风格）：我们可以简单地使用第三方库（如REST Assured或WireMock）与REST服务进行交互和验证，或者使用Spring的完全集成方法（测试与服务实现一起）。'
- en: Mockito
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito
- en: 'Mockito ([http://site.mockito.org/](http://site.mockito.org/)) is an open source
    mock unit testing framework for Java, first released in April 2008\. Of course,
    Mockito is not the only mock framework for Java; there are others, such as the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito ([http://site.mockito.org/](http://site.mockito.org/))是一个用于Java的开源模拟单元测试框架，于2008年4月首次发布。当然，Mockito并不是Java的唯一模拟框架；还有其他的，比如以下这些：
- en: EasyMock ([http://easymock.org/](http://easymock.org/)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EasyMock ([http://easymock.org/](http://easymock.org/)).
- en: JMock ([http://www.jmock.org/](http://www.jmock.org/)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMock ([http://www.jmock.org/](http://www.jmock.org/)).
- en: PowerMock ([http://powermock.github.io/](http://powermock.github.io/)).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerMock ([http://powermock.github.io/](http://powermock.github.io/)).
- en: JMockit ([http://jmockit.org/](http://jmockit.org/)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMockit ([http://jmockit.org/](http://jmockit.org/)).
- en: 'We can say that, at the time of writing, Mockito is the preferred mock framework
    in Java tests for the most developers and testers. To justify that claim, we use
    the following screenshot, which shows the evolution of the terms Mockito, EasyMock,
    JMock, PowerMock, and JMockit in Google Trends ([https://trends.google.com/](https://trends.google.com/))
    from 2004 to 2017\. At the beginning of this period, we can see there was a significant
    interest on EasyMock and JMock; nevertheless, Mockito was more in demand compared
    with the rest of the frameworks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，在撰写本文时，Mockito是大多数开发人员和测试人员在Java测试中首选的模拟框架。为了证明这一点，我们使用了以下截图，显示了Google趋势（[https://trends.google.com/](https://trends.google.com/)）中Mockito、EasyMock、JMock、PowerMock和JMockit从2004年到2017年的发展。在这段时期的开始，我们可以看到EasyMock和JMock受到了很大的关注；然而，与其他框架相比，Mockito更受欢迎：
- en: '![](img/00096.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: Google Trends evolution of Mockito, EasyMock, JMock, PowerMock, and JMockit
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Google趋势演变的Mockito、EasyMock、JMock、PowerMock和JMockit
- en: Mockito in a nutshell
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito简介
- en: As introduced in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing*, there are different levels
    of software testing, such as unit, integration, system, or acceptance. Regarding
    unit tests, they should be executed in isolation for a single piece of software,
    for example, an individual class. The objective in this level of tests is to verify
    the functionality of the unit and not of its dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)中介绍的，软件测试有不同的级别，如单元测试、集成测试、系统测试或验收测试。关于单元测试，它们应该在单个软件部分（例如单个类）的隔离环境中执行。在这个测试级别，目标是验证单元的功能，而不是它的依赖关系。
- en: In other words, we want to test what is known as the **System Under Test** (**SUT**)
    but not its **Depended-On Components** (**DOCs**). To achieve this isolation,
    we use typically *test doubles* to replace these DOCs. Mock objects are a kind
    of test double, which are programmed with expectations about the real DOC.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们想要测试所谓的**被测系统**（**SUT**），而不是它的**依赖组件**（**DOCs**）。为了实现这种隔离，我们通常使用*测试替身*来替换这些DOCs。模拟对象是一种测试替身，它们被编程为对真实DOC的期望。
- en: 'In few words, Mockito is a testing framework that allows mock object creation,
    stubbing, and verification. To that aim, Mockito provides an API to isolate the
    SUT and its DOCs. Generally speaking, using Mockito involves three different steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Mockito是一个允许创建模拟对象、存根和验证的测试框架。为此，Mockito提供了一个API来隔离SUT及其DOC。一般来说，使用Mockito涉及三个不同的步骤：
- en: '**Mocking objects**: In order to isolate our SUT, we use the Mockito API to
    create mocks of its associated DOC(s). This way, we guarantee that the SUT is
    not depending on its real DOC(s), and our unit test is actually focused on the
    SUT.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟对象**：为了隔离我们的SUT，我们使用Mockito API来创建其关联DOC的模拟对象。这样，我们确保SUT不依赖于其真实的DOC，我们的单元测试实际上是专注于SUT。'
- en: '**Setting expectations**: The differential aspect of mocks object with respect
    to other test doubles (such as stub) is that mock objects can be programmed with
    custom expectations according to the needs of the unit test. This process in the
    Mockito jargon is known as stubbing methods, in which these methods belong to
    the mocks. By default, mock objects mimic the behavior of real objects. In practical
    terms, it means that mock objects return appropriate dummy values such as false
    for Boolean types, null for objects, 0 for integer or long return types, and so
    on. Mockito allows us to change this behavior with a rich API, which allows stubbing
    to return a specific value when a method is called.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置期望**：与其他测试替身（如存根）相比，模拟对象的差异性在于可以根据单元测试的需要编程自定义期望。在Mockito的术语中，这个过程被称为存根方法，这些方法属于模拟对象。默认情况下，模拟对象模仿真实对象的行为。在实际操作中，这意味着模拟对象返回适当的虚拟值，例如布尔类型的false，对象的null，整数或长整数返回类型的0，等等。Mockito允许我们使用丰富的API更改这种行为，该API允许存根在调用方法时返回特定值。'
- en: When a mock object is not programmed with any expectation (that is, it has no
    *stubbing method*), technically speaking, it is not a *mock* object but a *dummy*
    object (take a look at [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing* for the definition).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟对象没有编程任何期望（即，它没有*存根方法*），从技术上讲，它不是*模拟*对象，而是*虚拟*对象（请参阅[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)，*软件质量和Java测试的回顾*，以获取定义）。
- en: '**Verification**: At the end of the day, we are creating tests, and thus, we
    need to implement some kind of verification for the SUT. Mockito provides a powerful
    API to carry out different types of verifications. With this API, we assess the
    interactions with the SUT and DOCs, verifying the invocation order with a mock,
    or capturing and verifying the argument passed to a stubbed method. Furthermore,
    the verification capabilities of Mockito can be complemented with the built-in
    assertion capabilities of JUnit or using a third-party assertion library (for
    example, Hamcrest, AssertJ, or Truth). See section *Assertions* within [Chapter
    3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit 5 Standard Tests*.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证**：归根结底，我们正在创建测试，因此，我们需要为SUT实现某种验证。Mockito提供了一个强大的API来进行不同类型的验证。通过这个API，我们评估与SUT和DOC的交互，验证模拟对象的调用顺序，或捕获和验证传递给存根方法的参数。此外，Mockito的验证能力可以与JUnit的内置断言能力或使用第三方断言库（例如Hamcrest、AssertJ或Truth）相结合。请参阅[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)中的*断言*部分，*JUnit
    5标准测试*。'
- en: 'The following table summarizes the Mockito APIs grouped by the aforementioned
    phases:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了按前述阶段分组的Mockito API：
- en: '| **Mockito API** | **Description** | **Phase** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **Mockito API** | **描述** | **阶段** |'
- en: '| `@Mock` | This annotation identifies a mock object to be created by Mockito.
    This is used typically for DOC(s). | 1.Mocking objects |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `@Mock` | 此注解标识要由Mockito创建的模拟对象。这通常用于DOC。 | 1.模拟对象 |'
- en: '| `@InjectMocks` | This annotation identifies the object in which the mocks
    are going to be injected. This is used typically to the unit we want to test,
    that is, our SUT. | 1.Mocking objects |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `@InjectMocks` | 此注解标识要注入模拟对象的对象。这通常用于我们要测试的单元，也就是我们的SUT。 | 1.模拟对象 |'
- en: '| `@Spy` | In addition to mocks, Mockito allows us to create spy objects (that
    is, a partial mock implementation, since they use the real implementation in non-stubbed
    methods). | 1.Mocking objects |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `@Spy` | 除了模拟对象，Mockito还允许我们创建间谍对象（即部分模拟实现，因为它们在非存根方法中使用真实实现）。 | 1.模拟对象 |'
- en: '| `Mockito.when(x).thenReturn(y)``Mockito.doReturn(y).when(x)` | These methods
    allow us to specify the value (`y`) that should be returned by the stubbed method
    (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenReturn(y)``Mockito.doReturn(y).when(x)` | 这些方法允许我们指定给定模拟对象的存根方法（`x`）应返回的值（`y`）。
    | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenThrow(e)``Mockito.doThrow(e).when(x)` | These methods
    allow us to specify the exception (`e`) that should be thrown when calling a stubbed
    method (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenThrow(e)``Mockito.doThrow(e).when(x)` | 这些方法允许我们指定在调用给定模拟对象的存根方法（`x`）时应抛出的异常（`e`）。
    | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenAnswer(a)``Mockito.doAnswer(a).when(x)` | Unlike returning
    a hardcoded value, a dynamic user-defined logic (`Answer a`) is executed when
    a given method (`x`) of the mock is invoked. | 2.Setting expectations (*stubbing
    methods*) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenAnswer(a)``Mockito.doAnswer(a).when(x)` | 与返回硬编码值不同，当调用模拟对象的给定方法（`x`）时，将执行动态用户定义的逻辑（`Answer
    a`）。 | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenCallRealMethod()``Mockito.doCallRealMethod().when(x)`
    | This method allows us the real implementation of a method instead the mocked
    one. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenCallRealMethod()``Mockito.doCallRealMethod().when(x)`
    | 此方法允许我们调用实际方法而不是模拟方法。 | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.doNothing().when(x)` | When using a spy, the default behavior is
    calling the real methods of the object. In order to avoid the execution of a `void`
    method `x`, this method is used. | 2.Setting expectations (*stubbing methods*)
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.doNothing().when(x)` | 在使用spy时，默认行为是调用对象的真实方法。为了避免执行`void`方法`x`，使用此方法。
    | 2.设置期望（*存根方法*） |'
- en: '| `BDDMockito.given(x).willReturn(y)``BDDMockito.given(x).willThrow(e)``BDDMockito.given(x).willAnswer(a)``BDDMockito.given(x).willCallRealMethod()`
    | Behaviour-driven development is a test methodology in which tests are specified
    in terms of scenarios and implemented as *given* (initial context), *when* (event
    occurs), and *then* (ensure some outcomes). Mockito supports this type of tests
    through the class `BDDMockito`. The behavior of the stubbed methods (`x`) is equivalent
    to `Mockito.when(x)`. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `BDDMockito.given(x).willReturn(y)``BDDMockito.given(x).willThrow(e)``BDDMockito.given(x).willAnswer(a)``BDDMockito.given(x).willCallRealMethod()`
    | 行为驱动开发是一种测试方法，其中测试以场景的形式指定，并作为*给定*（初始上下文）、*当*（事件发生）和*然后*（确保某些结果）实现。Mockito通过`BDDMockito`类支持这种类型的测试。存根方法（`x`）的行为等同于`Mockito.when(x)`。
    | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.verify()` | This method verifies the invocation of mock objects.
    This verification can be optionally enhanced using the following methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Mockito.verify()` | 此方法验证模拟对象的调用。可以使用以下方法选择性地增强此验证：'
- en: '`times(n)`: The stubbed method is invoked exactly `n` times.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`times(n)`: 调用存根方法`n`次。'
- en: '`never()`: The stubbed method is never called.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never()`: 存根方法从未被调用。'
- en: '`atLeastOnce()`: The stubbed method is invoked at least once.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeastOnce()`: 存根方法至少被调用一次。'
- en: '`atLeast(n)`: The stubbed method is called at least n times.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeast(n)`: 存根方法至少被调用n次。'
- en: '`atMost(n)`: The stubbed method is called at the most n times.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atMost(n)`: 存根方法最多调用n次。'
- en: '`only()`: A mock fails if any other method is called on the mock object.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only()`: 如果在模拟对象上调用了任何其他方法，则模拟失败。'
- en: '`timeout(m)`: This method is called in `m` milliseconds at the most.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout(m)`: 在最多`m`毫秒内调用此方法。'
- en: '| 3.Verification |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3.验证 |'
- en: '| `Mockito.verifyZeroInteractions()``Mockito.verifyNoMoreInteractions()` |
    These two methods verify that a stubbed method has no interactions. Internally,
    they use the same implementation. | 3.Verification |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.verifyZeroInteractions()``Mockito.verifyNoMoreInteractions()` |
    这两种方法验证存根方法没有交互。在内部，它们使用相同的实现。 | 3.验证 |'
- en: '| `@Captor` | This annotation allows us to define an `ArgumentChaptor` object,
    aimed to verify the arguments passed to a stubbed method. | 3.Verification |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `@Captor` | 此注释允许我们定义一个`ArgumentChaptor`对象，旨在验证传递给存根方法的参数。 | 3.验证 |'
- en: '| `Mockito.inOrder` | It facilitates verifying whether interactions with a
    mock were performed in a given order. | 3.Verification |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.inOrder` | 它有助于验证与模拟对象的交互是否按照给定的顺序执行。 | 3.验证 |'
- en: 'The use of the different annotations depicted in preceding the table (`@Mock`,
    `@InjectMocks`, `@Spy`, and `@Captor`) is optional, although it is recommendable
    for the shake of test readability. In other words, there are alternatives to the
    use of annotation using different Mockito classes. For instance, in order to create
    a `Mock`, we can use the annotation `@Mock` as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格之前描述的不同注释的使用（`@Mock`，`@InjectMocks`，`@Spy`和`@Captor`）是可选的，尽管出于测试可读性的考虑是值得推荐的。换句话说，有多种使用不同Mockito类的注释的替代方法。例如，为了创建一个`Mock`，我们可以使用注释`@Mock`，如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The alternative to this would be using the method `Mockito.mock`, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的替代方法是使用`Mockito.mock`方法，如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following sections contains comprehensive examples using the Mockito APIs
    described in preceding table within Jupiter tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分包含了在Jupiter测试中使用前面表格中描述的Mockito API的全面示例。
- en: JUnit 5 extension for Mockito
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito的JUnit 5扩展
- en: 'At the time of this writing, there is no official JUnit 5 extension to use
    Mockito in Jupiter tests. Nevertheless, the JUnit 5 team provides a simple ready
    to use Java class implementing a simple but effective extension for Mockito. This
    class can be found in the JUnit 5 user guide ([http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)),
    and its code is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，尚无官方的JUnit 5扩展来在Jupiter测试中使用Mockito。尽管如此，JUnit 5团队提供了一个简单易用的Java类，实现了一个简单但有效的Mockito扩展。这个类可以在JUnit
    5用户指南中找到（[http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)），其代码如下：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This extension (among others) is planned to be released in the open source project
    JUnit Pioneer ([http://junit-pioneer.org/](http://junit-pioneer.org/)). This project
    is maintained by Nicolai Parlog, Java developer and author of the blog CodeFX
    ([https://blog.codefx.org/](https://blog.codefx.org/)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展（以及其他扩展）计划在开源项目JUnit Pioneer（[http://junit-pioneer.org/](http://junit-pioneer.org/)）中发布。该项目由Java开发人员Nicolai
    Parlog维护，他还是博客CodeFX（[https://blog.codefx.org/](https://blog.codefx.org/)）的作者。
- en: 'Inspecting the preceding class, we can check that it is simply a use case of
    the Jupiter extension model (described in [chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New In JUnit 5,* of this book), which implements the extensions callback
    `TestInstancePostProcessor` and `ParameterResolver`. Thanks to the first, after
    the test case is instantiated, the `postProcessTestInstance` method is invoked,
    and in the body of this method, the initialization of mocks is carried out:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的类，我们可以看到它只是Jupiter扩展模型的一个用例（在本书的[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中描述了Jupiter扩展模型），它实现了扩展回调`TestInstancePostProcessor`和`ParameterResolver`。由于第一个，在测试用例实例化后，将调用`postProcessTestInstance`方法，并且在此方法的主体中，将进行模拟的初始化：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This has the same effect that using the JUnit 4 runner for Mockito: `@RunWith(MockitoJUnitRunner.class)`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在JUnit 4中使用Mockito的运行器的效果相同：`@RunWith(MockitoJUnitRunner.class)`。
- en: In addition, this extension also implements the interface `ParameterResolver`.
    That means that dependency injection at method level will be allowed in tests,
    which register the extension (`@ExtendWith(MockitoExtension.class)`). In particular,
    the annotation will inject mock objects for test parameters annotated with `@Mock`
    (located in package `org.mockito`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个扩展还实现了接口`ParameterResolver`。这意味着在测试中，注册了这个扩展（`@ExtendWith(MockitoExtension.class)`）的情况下，将允许在方法级别进行依赖注入。特别是，这个注解将为用`@Mock`注解的测试参数注入模拟对象（位于`org.mockito`包中）。
- en: 'Let’s see some examples to clarify the use of this extension together with
    Mockito. As usual, we can find the source code of this examples on the GitHub
    repository [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
    A copy of the preceding extension (`MockitoExtension`) is contained in the project
    `junit5-mockito`. To guide these examples, we implement a typical use case in
    software applications: the login of a user in a software system.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子来澄清这个扩展与Mockito一起使用的情况。像往常一样，我们可以在GitHub仓库[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)上找到这些例子的源代码。前面的扩展（`MockitoExtension`）的副本包含在项目`junit5-mockito`中。为了指导这些例子，我们在软件应用程序中实现了一个典型的用例：用户在软件系统中的登录。
- en: 'In this use case, we suppose that a user interacts with a system made up by
    three classes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们假设用户与由三个类组成的系统进行交互：
- en: '`LoginController`: The class which receives the request from the user, returning
    a response as a result. This request is dispatched to the `LoginService` component.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginController`：接收用户的请求，并返回响应的类。这个请求被分派到`LoginService`组件。'
- en: '`LoginService`: This class implements the functionality of the use case. To
    that aim, it needs to confirm whether or not the user is authenticated in the
    system. To that, it needs to read the persistence layer, implemented in the `LoginRepository`
    class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginService`：这个类实现了用例的功能。为了实现这个目的，它需要确认用户是否在系统中得到了认证。为了做到这一点，它需要读取`LoginRepository`类中实现的持久化层。'
- en: '`LoginRepository`: This class allows to access the persistence layer of the
    system, typically implemented by means of a database. This class can also be called
    **Data Access Object** (**DAO**).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginRepository`：这个类允许访问系统的持久化层，通常是通过数据库实现的。这个类也可以被称为**数据访问对象**（**DAO**）。'
- en: 'In terms of composition, the relationship of these three classes are is following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合方面，这三个类的关系如下：
- en: '![](img/00097.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: Login use case class diagram (composition relationship among the classes)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用例类图（类之间的组合关系）
- en: 'The sequence diagram of the two basic operations involved in the use case (login
    and logout) is depicted in the following chart:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用例中涉及的两个基本操作（登录和注销）的序列图如下图所示：
- en: '![](img/00098.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: Login use case sequence diagram
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用例序列图
- en: 'We implement this example with several simple Java classes. First, the `LoginController`
    uses the `LoginService` by composition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用几个简单的Java类来实现这个例子。首先，`LoginController`通过组合使用`LoginService`：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `UserForm` object is a simple Java class, sometimes called **Plain-Old
    Java Object** (**POJO**), with two properties username and password:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserForm`对象是一个简单的Java类，有时被称为**普通的Java对象**（**POJO**），有两个属性username和password：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, the service depends on the repository (`LoginRepository`) for data access.
    In this example, the service also implements a user registry using a Java list
    in which the authenticated users are stored:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务依赖于`LoginRepository`进行数据访问。在这个例子中，服务还使用Java列表实现了用户注册，其中存储了经过认证的用户：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the `LoginRepository` is as follows. For the sake of simplicity, instead
    of accessing a real database, this component implements a map in which the credentials
    of the hypothetical user of the system are stored (where `key`*=* username, and
    `value`=password):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LoginRepository`如下。为了简单起见，这个组件实现了一个映射，而不是访问真实的数据库，其中存储了系统中假设用户的凭据（其中`key`*=*
    username，`value`=password）：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we are going to test our system using JUnit 5 and Mockito. First of all,
    we test the controller component. Since we are doing unit tests, we need to isolate
    the `LoginController` login from the rest of the system. To do that, we need to
    mock its dependencies, in this example, the `LoginService` component. Using the
    SUT/DOC terminology explained at the beginning, in this test, our SUT is the class
    `LoginController` and its DOC is the class `LoginService`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用JUnit 5和Mockito来测试我们的系统。首先，我们测试控制器组件。由于我们正在进行单元测试，我们需要将`LoginController`登录与系统的其余部分隔离开来。为了做到这一点，我们需要模拟它的依赖关系，在这个例子中，是`LoginService`组件。使用在开头解释的SUT/DOC术语，在这个测试中，我们的SUT是`LoginController`类，它的DOC是`LoginService`类。
- en: 'To implement our test with JUnit 5, first we need to register the `MockitoExtension`
    with `@ExtendWith`. Then, we declare the SUT with `@InjectMocks` (class `LoginController`)
    and its DOC with `@Mock` (class `LoginService`). We implement two tests (`@Test`).
    First one (`testLoginOk`) specifies when the method login of mock `loginService`
    is called, this method should return true. After that, the SUT is actually exercised,
    and its response is verified (in this case, the returned String must be `OK`).
    Moreover, the Mockito API is used again to assess that no more interactions with
    the mock `LoginService` is done. The second test (`testLoginKo`) is equivalent,
    but stubbing the method login to return false and therefore the response of the
    SUT `(LoginController)` must be `KO` in this case:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用JUnit 5实现我们的测试，首先我们需要使用`@ExtendWith`注册`MockitoExtension`。然后，我们用`@InjectMocks`（类`LoginController`）声明SUT，用`@Mock`（类`LoginService`）声明它的DOC。我们实现了两个测试（`@Test`）。第一个测试（`testLoginOk`）指定了当调用模拟`loginService`的login方法时，这个方法应该返回true。之后，SUT被实际执行，并且它的响应被验证（在这种情况下，返回的字符串必须是`OK`）。此外，Mockito
    API再次被用来评估与模拟`LoginService`的交互是否没有更多。第二个测试（`testLoginKo`）是等价的，但是将login方法的存根设为返回false，因此SUT（`LoginController`）的响应在这种情况下必须是`KO`：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we execute this test, simply inspecting the traces on the standard output
    we can check that the SUT have been actually executed. In addition, we assure
    that the verification stage has been succeeded in both tests since both of them
    have passed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个测试，简单地检查标准输出上的跟踪，我们可以检查SUT是否实际执行了。此外，我们确保验证阶段在两个测试中都成功了，因为它们都通过了：
- en: '![](img/00099.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.gif)'
- en: Execution of unit test of *LoginControllerLoginTest* with JUnit 5 and Mockito
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginControllerLoginTest*的单元测试
- en: 'Let’s move now to other example in which the negative scenarios (that is, error
    situations) are tested for the component `LoginController`. The following class
    contains two tests, first one (`testLoginError`) is devoted to assess the response
    of the system (it should be `ERROR`) when a null form is used. In the second test
    (`testLoginException`), we program the method login of the mock `loginService`
    to raise an exception when any form is used first. Then, we exercise the SUT (`LoginController`)
    and assess that the response is actually an `ERROR`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到另一个例子，在这个例子中，我们测试了`LoginController`组件的负面情况（即错误情况）。以下类包含两个测试，第一个（`testLoginError`）旨在评估系统的响应（应该是`ERROR`），当使用空表单时。在第二个测试（`testLoginException`）中，我们编写了模拟`loginService`的方法，当首次使用任何表单时引发异常。然后，我们执行SUT（`LoginController`）并评估响应是否实际上是`ERROR`：
- en: Note that we are using the argument matcher any (provided out of the box by
    Mockito) when setting the expectations for the mock method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当设置模拟方法的期望时，我们使用了参数匹配器any（Mockito默认提供）。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, when running the tests in the shell, we can confirm that both of tests
    are correctly executed and the SUT is exercised:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在shell中运行测试时，我们可以确认两个测试都正确执行，SUT也被执行了：
- en: '![](img/00100.gif)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.gif)'
- en: Execution of unit test of *LoginControllerErrorTest* with JUnit 5 and Mockito
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginControllerErrorTest*的单元测试
- en: Let’s see an example using the BDD style. To that aim, the class `BDDMockito`
    is used. Notice that the static method given of this class is imported in the
    example. Then, four tests are implemented. In fact, these four tests are exactly
    the same implemented in the previous examples (`LoginControllerLoginTest` and
    `LoginControllerErrorTest`), but this time using the BDD style and a more compact
    style (one-liner commands).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用BDD风格的例子。为此，使用了`BDDMockito`类。请注意，该类的静态方法given在示例中被导入。然后，实现了四个测试。实际上，这四个测试与之前的例子（`LoginControllerLoginTest`和`LoginControllerErrorTest`）完全相同，但这次使用了BDD风格和更紧凑的风格（一行命令）。
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The execution of this test class supposes that four tests are executed. As
    shown in the following screenshot, all of them pass:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个测试类意味着执行了四个测试。如下截图所示，它们全部通过了：
- en: '![](img/00101.gif)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.gif)'
- en: Execution of unit test of *LoginControllerBDDTest* with JUnit 5 and Mockito
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginControllerBDDTest*的单元测试
- en: 'Let’s move now to the next component of our system: `LoginService`. In the
    following example, we aim to unit test that component, and thus first we use the
    annotation `@InjectMocks` to inject the SUT in our test. Then, the DOC (`LoginRepository`)
    is mocked using the annotation `@Mock`. The class contains three tests. The first
    (`testLoginOk`) is devoted to verify the answer of the SUT when a correct form
    is received. The second test (`testLoginKo`) verifies the opposite scenario. Finally,
    the third test also verifies an error situation of the system. The implementation
    of this service keeps a registry of the users logged, and will not allowed to
    login the same user twice. For this reason, we implemented a test (`testLoginTwice`),
    which verifies that the exception `LoginException` is raised when the same user
    tries to login twice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到系统的下一个组件：`LoginService`。在下面的例子中，我们旨在对该组件进行单元测试，因此首先使用注解`@InjectMocks`将SUT注入到我们的测试中。然后，使用注解`@Mock`对DOC（`LoginRepository`）进行模拟。该类包含三个测试。第一个（`testLoginOk`）旨在验证当接收到正确的表单时SUT的响应。第二个测试（`testLoginKo`）验证相反的情况。最后，第三个测试还验证了系统的错误情况。该服务的实现保留了已登录用户的注册表，并且不允许同一用户登录两次。因此，我们实现了一个测试（`testLoginTwice`），用于验证当同一用户尝试两次登录时是否引发了异常`LoginException`：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As usual, the execution of the test in shell gives us an idea of how things
    have gone. We can check that the login service has been exercised four times (since
    in the third test, we did twice). But due to the fact that the `LoginException`
    was expected, that test is succeeded (as well the other two):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在shell中执行测试可以让我们了解事情的进展。我们可以检查登录服务已经被执行了四次（因为在第三个测试中，我们执行了两次）。但由于预期到了`LoginException`，该测试是成功的（其他两个也是）：
- en: '![](img/00102.gif)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.gif)'
- en: Execution of unit test of *LoginServiceTest* with JUnit 5 and Mockito
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginServiceTest*的单元测试
- en: 'The following class provides a simple example for capturing the argument of
    a mock object. We define a class property of type `ArgumentCaptor<UserForm>`,
    which is annotated with `@Captor`. Then, in the body of the test, the SUT (`LoginService`
    in this case) is exercised and the argument of the method login are captured.
    Finally, the value of this argument is assessed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类提供了一个简单的例子，用于捕获模拟对象的参数。我们定义了一个类型为`ArgumentCaptor<UserForm>`的类属性，并用`@Captor`进行了注释。然后，在测试的主体中，执行了SUT（在本例中是`LoginService`）并捕获了方法login的参数。最后，评估了这个参数的值：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once again, in the console, we check that the SUT was exercised and the test
    is declared as successful:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在控制台中，我们检查SUT是否被执行，并且测试被声明为成功：
- en: '![](img/00103.gif)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: Execution of unit test of *LoginServiceChaptorTest* with JUnit 5 and Mockito
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginServiceChaptorTest*的单元测试
- en: The last example we see in this chapter related to Mockito has to do with the
    use of an spy. As introduced before, by default, an spy uses the real implementation
    in non-stubbed methods. Therefore, if we do not stub methods in an spy object,
    what we get is the real object in our test. This is what happens in the next example.
    As we can see, we are using the `LoginService` as our SUT, and then we spy the
    object `LoginRepository`. Due to the fact that in the body of the tests we are
    not programming expectations in the spy object, we are assessing the real system
    in the test.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中看到的最后一个与Mockito相关的示例与使用spy有关。如前所述，默认情况下，spy在非存根方法中使用真实实现。因此，如果我们在spy对象中不存根方法，我们在测试中得到的是真实对象。这就是下一个示例中发生的情况。正如我们所看到的，我们正在使用`LoginService`作为我们的SUT，然后我们对对象`LoginRepository`进行了监视。由于在测试的主体中，我们没有在spy对象中编程期望，我们在测试中评估了真实系统。
- en: 'All in all, the test data is prepared to get a login correct (using username
    as `user` and password as `p1`, which is present in the hardcoded values in the
    real implementation of `LoginRepository`), and then some dummy values for an unsuccessful
    login:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，测试数据准备好了，以获得正确的登录（使用用户名`user`和密码`p1`，这些值在`LoginRepository`的实际实现中是固定的），然后一些虚拟值用于无法登录：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the shell, we can check that both tests were correctly executed, and in
    this case, the real components (both `LoginService` and `LoginRepository`) were
    actually exercised:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中，我们可以检查两个测试是否正确执行，而且在这种情况下，实际组件（`LoginService`和`LoginRepository`）确实被执行：
- en: '![](img/00104.gif)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.gif)'
- en: Execution of unit test of *LoginServiceSpyTest* with JUnit 5 and Mockito
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 5和Mockito执行*LoginServiceSpyTest*的单元测试
- en: These examples demonstrate several of the capabilities of Mockito, but of course
    not all. For further information, visit the official Mockito reference at [http://site.mockito.org/](http://site.mockito.org/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了Mockito的几种功能，但当然不是全部。有关更多信息，请访问官方Mockito参考网站[http://site.mockito.org/](http://site.mockito.org/)。
- en: Spring
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring
- en: Spring ([https://spring.io/](https://spring.io/)) is an open source Java framework
    for building enterprise applications. It was first written by Rod Johnson together
    with his book *Expert One-on-One J2EE Design and Development* in October 2002\.
    The original motivation of Spring was getting rid of the complexity of J2EE, providing
    a light-weight infrastructure aimed to ease the development of enterprise application
    using simple POJOs as building blocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Spring ([https://spring.io/](https://spring.io/))是一个用于构建企业应用程序的开源Java框架。它最初是由Rod
    Johnson在2002年10月与他的书*Expert One-on-One J2EE Design and Development*一起编写的。Spring最初的动机是摆脱J2EE的复杂性，提供一个轻量级的基础设施，旨在使用简单的POJO作为构建块来简化企业应用程序的开发。
- en: Spring in a nutshell
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring简介
- en: The core technology of the Spring Framework is known as **Inversion of Control**
    (**IoC**), which is the process of instantiating objects outside the class in
    which these objects are actually used. These objects are known as beans or components
    in the Spring jargon and are created as *singleton* objects by default. The entity
    in charge of the creation of beans is known as the Spring IoC container. This
    is achieved by **Dependency Injection** (**DI**), which is the process of providing
    dependencies of one object instead of constructing them itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架的核心技术被称为**控制反转**（**IoC**），这是在实际使用这些对象的类之外实例化对象的过程。这些对象在Spring行话中被称为bean或组件，并且默认情况下被创建为*单例*对象。负责创建bean的实体称为Spring
    IoC容器。这是通过**依赖注入**（**DI**）实现的，它是提供对象的依赖关系而不是自己构造它们的过程。
- en: IoC and DI are often used interchangeably. Nevertheless, as depicted in the
    paragraph earlier, these concepts are not exactly the same (IoC is achieved through
    DI).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IoC和DI经常可以互换使用。然而，正如前面的段落所描述的，这些概念并不完全相同（IoC是通过DI实现的）。
- en: 'As depicted in the next part of this section, Spring is a modular framework.
    The core functionally of Spring (that is, IoC) is provided in the `spring-context`
    module. This module provides the ability of creating **application context**,
    that is, the Spring’s DI container. There are many different ways to define application
    contexts in Spring. Two of the most significant types are the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节的下一部分所描述的，Spring是一个模块化的框架。Spring的核心功能（即IoC）在`spring-context`模块中提供。该模块提供了创建**应用程序上下文**的能力，即Spring的DI容器。在Spring中有许多不同的定义应用程序上下文的方式。最重要的两种类型是以下两种：
- en: '`AnnotationConfigApplicationContext`: Application context, which accepts annotated
    classes to identify the Spring beans to be executed in the container. In this
    type of context, beans are identified by annotating plain classes with the annotation
    `@Component`. It is not the only one to declare a class as a Spring bean. There
    are further stereotypes annotations: `@Controller` (stereotype for presentation
    layer, used in the web module, MVC), `@Repository` (stereotype for the persistence
    layer, used in the data access module, called Spring Data), and `@Service` (used
    in the service layer). These three annotations are used to separate the layers
    of an application. Finally, classes annotated with `@Configuration` allows to
    define Spring beans by annotating methods with `@Bean` (the object returned by
    these methods will be Spring beans living in the container):'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationConfigApplicationContext`：应用程序上下文，接受带注释的类来标识要在容器中执行的Spring bean。在这种类型的上下文中，通过使用注释`@Component`对普通类进行注释来标识bean。这不是唯一将类声明为Spring
    bean的方法。还有进一步的原型注释：`@Controller`（用于表示层的原型，在Web模块中使用，MVC），`@Repository`（用于持久层的原型，在数据访问模块中使用，称为Spring
    Data），和`@Service`（用于服务层）。这三个注释用于分离应用程序的各个层。最后，使用`@Configuration`注释的类允许通过使用`@Bean`注释方法来定义Spring
    bean（这些方法返回的对象将成为容器中的Spring bean）：'
- en: '![](img/00105.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: Spring stereotypes used to define beans
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义bean的Spring原型
- en: '`ClassPathXmlApplicationContext`: Application context, which accepts bean definitions
    declared in an XML file located in the project classpath.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassPathXmlApplicationContext`：应用程序上下文，接受在项目类路径中声明的XML文件中的bean定义。'
- en: The annotation-based context configuration was introduced in Spring 2.5\. The
    Spring IoC container is totally decoupled from the format in which configuration
    metadata (that is, bean definition) is actually written. Nowadays many developers
    chose annotation-based configuration rather than XML based. For this reason, in
    this book, we are going to use only annotation-based context configuration in
    the examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注解的上下文配置是在Spring 2.5中引入的。Spring IoC容器与实际编写配置元数据（即bean定义）的格式完全解耦。如今，许多开发人员选择基于注解的配置而不是基于XML的配置。因此，在本书中，我们将只在示例中使用基于注解的上下文配置。
- en: 'Let’s see a simple example. First of all, we need to include the `spring-context`
    dependency in our project. For example, as a Maven dependency:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。首先，我们需要在项目中包含`spring-context`依赖项。例如，作为Maven依赖项：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we create an executable Java class (that is, with a main method). Notice
    that in this class there is one annotation at class level: `@ComponentScan`. This
    is a very important annotation in Spring, since it allows to declare the package
    in which Spring will look for beans definition in the form of annotations. If
    specific packages are not defined (just like in the example), scanning will occur
    from the package of the class that declares this annotation (in the example the
    package `io.github.bonigarcia`). In the body of the main method, we create the
    Spring application context with `AnnotationConfigApplicationContext`. From that
    context, we get the Spring component whose class is `MessageComponent`, and we
    write the result of its `getMessage()` method on the standard output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个可执行的Java类（即带有main方法）。请注意，在这个类中有一个类级别的注解：`@ComponentScan`。这是Spring中非常重要的一个注解，因为它允许声明Spring将在其中查找注解形式的bean定义的包。如果没有定义特定的包（就像在示例中一样），扫描将从声明此注解的类的包中进行（在示例中是包`io.github.bonigarcia`）。在main方法的主体中，我们使用`AnnotationConfigApplicationContext`创建Spring应用程序上下文。从该上下文中，我们获取其类为`MessageComponent`的Spring组件，并将其`getMessage()`方法的结果写入标准输出：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The bean `MessageComponent` is defined in the following class. Notice that
    it is declared as the Spring component simply using the annotation `@Component`
    at class level. Then, in this example, we are injecting another Spring component
    called `MessageService` using the class constructor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: bean `MessageComponent` 在以下类中定义。请注意，它只是在类级别使用`@Component`注解声明为Spring组件。然后，在这个例子中，我们使用类构造函数注入另一个名为`MessageService`的Spring组件：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, it is worth reviewing the different manners to carry out dependency
    injection of Spring components:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得回顾一下进行Spring组件依赖注入的不同方式：
- en: 'Field injection: The injected component is a class field annotated with `@Autowired`,
    just like the example before. As a benefit, this kind of injection removes clutter
    code such as setter methods or constructor parameters.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段注入：注入的组件是一个带有`@Autowired`注解的类字段，就像之前的例子一样。作为一个好处，这种类型的注入消除了杂乱的代码，比如setter方法或构造函数参数。
- en: 'Setter injection: The injected component is declared as a field in the class,
    and then a setter for this field is created and annotated with `@Autowired`.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Setter注入：注入的组件在类中声明为字段，然后为该字段创建一个带有`@Autowired`注解的setter。
- en: 'Constructor injection: The dependency is injected in the class constructor,
    which is annotated with `@Autowired` (3-a in the diagram here). This is the way
    shown in the example earlier. As of Spring 4.3, it is not required anymore to
    annotate the constructor with `@Autowired` to carry out the injection (3-b).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数注入：依赖项被注入到带有`@Autowired`注解的类构造函数中（图中的3-a）。这是前面示例中展示的方式。从Spring 4.3开始，不再需要使用`@Autowired`注解构造函数来进行注入（3-b）。
- en: The latest way of injection (*3-b*) was several benefits, such as the promotion
    of testability without the need of reflection mechanism (implemented, for example,
    by mocking library). In addition, it can make developers to think over the design
    of the class, since many injected dependencies suppose many constructor parameters,
    and this should be avoided (*God object* anti-pattern).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的注入方式（*3-b*）有很多好处，比如促进了无需反射机制的可测试性（例如，通过模拟库实现）。此外，它可以让开发人员思考类的设计，因为许多注入的依赖项意味着许多构造函数参数，这应该被避免（*上帝对象*反模式）。
- en: '![](img/00106.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: Different ways of dependency injection (Autowired) in Spring
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring中依赖注入（Autowired）的不同方式
- en: 'The last component in our example is named `MessageService`. Note that is also
    a Spring component, this time annotated with `@Service` to remark its service
    nature (from a functional perspective, it would be the same than annotating the
    class with `@Component`):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的最后一个组件名为`MessageService`。请注意，这也是一个Spring组件，这次使用`@Service`注解来强调其服务性质（从功能角度来看，这与使用`@Component`注解类是一样的）：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we execute the main class of this example (called `MySpringApplication`,
    see the source code here), we create an annotation-based application context with
    a try with resources (this way the application context will be closed at the end).
    The Spring IoC container will create two beans: `MessageService` and `MessageComponet`.
    Using the application context, we seek the bean `MessageComponet` and invoke its
    method `getMessage`, which is finally written in the standard output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行这个示例的主类（称为`MySpringApplication`，请参见源代码），我们将使用try with resources创建一个基于注解的应用程序上下文（这样应用程序上下文将在最后关闭）。Spring
    IoC容器将创建两个bean：`MessageService`和`MessageComponet`。使用应用程序上下文，我们寻找bean`MessageComponet`并调用其方法`getMessage`，最终将其写入标准输出：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Spring modules
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring模块
- en: 'The Spring framework is modular, allowing developers to use only the needed
    modules provided by the framework. The complete list of this modules can be found
    on [https://spring.io/projects](https://spring.io/projects). The following table
    summarizes some of the most important ones:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架是模块化的，允许开发人员只使用框架提供的所需模块。这些模块的完整列表可以在[https://spring.io/projects](https://spring.io/projects)上找到。以下表格总结了一些最重要的模块：
- en: '| **Spring project** | **Logo** | **Description** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **Spring项目** | **标志** | **描述** |'
- en: '| Spring Framework | ![](img/00107.jpeg) | Provides core support for DI, transaction
    management, web applications (Spring MCV), data access, messaging, and so on.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Spring框架 | ![](img/00107.jpeg) | 提供了对DI，事务管理，Web应用程序（Spring MCV），数据访问，消息传递等的核心支持。
    |'
- en: '| Spring IO Platform | ![](img/00108.jpeg) | Brings together the core Spring
    APIs into a cohesive and versioned foundational platform for modern applications.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Spring IO平台 | ![](img/00108.jpeg) | 将核心Spring API整合成一个具有连贯性和版本化的基础平台，用于现代应用程序。
    |'
- en: '| Spring Boot | ![](img/00109.jpeg) | Simplifies the creation of standalone,
    production-grade Spring-based applications with the minimal configuration. It
    follows the convention-over-configuration approach. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Spring Boot | ![](img/00109.jpeg) | 简化了独立的，生产级的基于Spring的应用程序的创建，最小化配置。它遵循约定优于配置的方法。'
- en: '| Spring Data | ![](img/00110.jpeg) | Simplifies data access by means of comprehensive
    APIs to work with the relational databases, NoSQL, map-reduce algorithms, and
    so on. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Spring数据 | ![](img/00110.jpeg) | 通过全面的API简化数据访问，以处理关系数据库，NoSQL，映射-减少算法等。'
- en: '| Spring Cloud | ![](img/00111.jpeg) | Provides a set of libraries and common
    patterns for building and deploying distributed systems and microservices. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Spring Cloud | ![](img/00111.jpeg) | 提供了一组库和常见模式，用于构建和部署分布式系统和微服务。 |'
- en: '| Spring Security | ![](img/00112.jpeg) | Provides customizable authentication
    and authorization capabilities for Spring-based applications. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Spring安全 | ![](img/00112.jpeg) | 为基于Spring的应用程序提供可定制的身份验证和授权功能。 |'
- en: '| Spring Integration | ![](img/00113.jpeg) | Provides a lightweight, POJO-based
    messaging for Spring-based applications to integrate with external systems. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Spring集成 | ![](img/00113.jpeg) | 为基于Spring的应用程序提供了基于轻量级POJO的消息传递，以与外部系统集成。
    |'
- en: '| Spring Batch | ![](img/00114.jpeg) | Provides a lightweight framework designed
    to enable the development of robust batch applications for operations of enterprise
    systems. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Spring批处理 | ![](img/00114.jpeg) | 提供了一个轻量级框架，旨在实现企业系统操作的稳健批处理应用程序的开发。 |'
- en: Introduction to Spring Test
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring测试简介
- en: 'Spring a module called `spring-test`, which supports unit and integration testing
    of Spring components. Among other features, this module provides the ability to
    create Spring application context for testing purposes or create mock objects
    that to test our code in isolation. There are different annotations supporting
    this testing capabilities. A list of the most significant one is the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有一个名为`spring-test`的模块，支持对Spring组件进行单元测试和集成测试。除其他功能外，该模块提供了创建用于测试目的的Spring应用程序上下文或创建模拟对象以隔离测试代码的能力。有不同的注解支持这些测试功能。最重要的注解列表如下：
- en: '`@ContextConfiguration`: This annotation is used to determine how to load and
    configure an `ApplicationContext` for integration tests. For example, it allows
    to load the application context from annotated classes (using the element classes)
    or bean definitions declared in XML files (using the element locations).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration`：此注解用于确定如何为集成测试加载和配置`ApplicationContext`。例如，它允许从注释类（使用元素类）加载应用程序上下文，或者从XML文件中声明的bean定义（使用元素位置）加载应用程序上下文。'
- en: '`@ActiveProfiles`: This annotation is used to instruct the container about
    which definition profiles should be active during the application context loading
    (for example, development and test profiles).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ActiveProfiles`：此注解用于指示容器在应用程序上下文加载期间应激活哪些定义配置文件（例如，开发和测试配置文件）。'
- en: '`@TestPropertySource`: This annotation is used to configure the locations of
    the properties files and the inline properties to be added.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@TestPropertySource`：此注解用于配置属性文件的位置和要添加的内联属性。'
- en: '`@WebAppConfiguration`: This annotation is used to instruct the Spring context
    that `ApplicationContext` loaded is `WebApplicationContext.`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebAppConfiguration`：此注解用于指示Spring上下文加载的`ApplicationContext`是`WebApplicationContext`。'
- en: 'In addition, the `spring-test` module offers several capabilities to carry
    out different actions typically required in tests, namely:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`spring-test`模块提供了几种功能，用于执行测试中通常需要的不同操作，即：
- en: The `org.springframework.mock.web` package contains a set of Servlet API mock
    objects, useful for testing web contexts. For instance, the object `MockMvc` allows
    to perform HTTP requests (`POST`, `GET`, `PUT`, `DELETE`, and so on) and verify
    the response (status code, content type, or response body).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring的`org.springframework.mock.web`包含一组Servlet API模拟对象，用于测试web上下文。例如，`MockMvc`对象允许执行HTTP请求（`POST`，`GET`，`PUT`，`DELETE`等），并验证响应（状态码，内容类型或响应主体）。
- en: The `org.springframework.mock.jndi` package contains an implementation of the
    **Java Naming and Directory Interface** (**JNDI**) SPI, which can be used to set
    up a simple JNDI environment for tests. For instance, using the class `SimpleNamingContextBuilder`
    we can make a JNDI data source available in our tests.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.mock.jndi`包含**Java命名和目录接口**（**JNDI**）SPI的实现，可用于为测试设置简单的JNDI环境。例如，使用`SimpleNamingContextBuilder`类，我们可以在测试中提供JNDI数据源。'
- en: The `org.springframework.test.jdbc` package contains the class `JdbcTestUtils`,
    which is a collection of JDBC utility functions aimed to simplify standard database
    access.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.test.jdbc`包含`JdbcTestUtils`类，这是一组旨在简化标准数据库访问的JDBC实用函数。'
- en: The `org.springframework.test.util` package contains the class `ReflectionTestUtils`,
    which is a collection of utility methods to set a non-public field or invoke a
    private/protected setter method when testing the application code.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.test.util`包含`ReflectionTestUtils`类，这是一组实用方法，用于在测试应用程序代码时设置非公共字段或调用私有/受保护的setter方法。'
- en: Testing Spring Boot applications
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Spring Boot应用程序
- en: 'As introduced before, Spring Boot is a project of the Spring portfolio aimed
    to simplify the development of Spring applications. The main benefits of using
    Spring Boot are summarized as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Boot是Spring系列项目的一个项目，旨在简化Spring应用程序的开发。使用Spring Boot的主要好处总结如下：
- en: A Spring Boot application is just a Spring `ApplicationContext` in which the
    principal convention over configuration is used. Thank to this, it is faster to
    get started with the Spring development.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot应用程序只是一个使用主要约定优于配置的Spring `ApplicationContext`。由于这一点，使用Spring进行开发变得更快。
- en: The annotation `@SpringBootApplication` is used to identify the main class in
    a Spring Boot project.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication`注解用于标识Spring Boot项目中的主类。'
- en: 'A range of non-functional features are provided out of the box: embedded servlet
    containers (Tomcat, Jetty, and Undertow), security, metrics, health checks, or
    externalized configuration.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot提供了一系列开箱即用的非功能特性：嵌入式servlet容器（Tomcat、Jetty和Undertow）、安全性、度量、健康检查或外部化配置。
- en: A creation of standalone running applications that just run using the command
    `java -jar` (even for web applications).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建独立运行的应用程序，只需使用命令`java -jar`即可（即使是Web应用程序）。
- en: Spring Boot **command line interface** (**CLI**) allows to run Groovy scripts
    for quickly prototyping with Spring.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot **命令行界面**（**CLI**）允许运行Groovy脚本，快速原型化Spring。
- en: 'Spring Boot works in the same way as any standard Java library, that is, to
    use it, we simply need to add the appropriate `spring-boot-*.jar` in our project
    classpath (typically using build tools such as Maven or Gradle). Spring Boot provides
    a number of *starters* aimed to ease the process of adding the different libraries
    to the classpath. The following table contains several of those starters:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot的工作方式与任何标准的Java库相同，也就是说，要使用它，我们只需要在项目类路径中添加适当的`spring-boot-*.jar`（通常使用构建工具如Maven或Gradle）。Spring
    Boot提供了许多*starters*，旨在简化将不同的库添加到类路径的过程。以下表格包含了其中几个起始器：
- en: '| **Name** | **Description** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support
    and logging |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | 核心起始器，包括自动配置支持和日志记录 |'
- en: '| `spring-boot-starter-batch` | Starter for using Spring Batch |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-batch` | 用于使用Spring Batch的起始器 |'
- en: '| `spring-boot-starter-cloud-connectors` | Starter for using Spring Cloud Connectors,
    which simplifies connecting to services in Cloud platforms like Cloud Foundry
    and Heroku |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-cloud-connectors` | 用于使用Spring Cloud Connectors的起始器，简化了连接到云平台（如Cloud
    Foundry和Heroku）中的服务 |'
- en: '| `spring-boot-starter-data-jpa` | Starter for using Spring Data JPA with Hibernate
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` | 用于使用Hibernate的Spring Data JPA的起始器 |'
- en: '| `spring-boot-starter-integration` | Starter for using Spring Integration
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-integration` | 用于使用Spring Integration的起始器 |'
- en: '| `spring-boot-starter-jdbc` | Starter for using JDBC with the Tomcat JDBC
    connection pool |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 用于使用Tomcat JDBC连接池的JDBC的起始器 |'
- en: '| `spring-boot-starter-test` | Starter for testing Spring Boot applications
    with libraries, including JUnit, Hamcrest, and Mockito |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 用于使用库测试Spring Boot应用程序，包括JUnit、Hamcrest和Mockito
    |'
- en: '| `spring-boot-starter-thymeleaf` | Starter for building MVC web applications
    using Thymeleaf views |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-thymeleaf` | 用于使用Thymeleaf视图构建MVC Web应用程序的起始器 |'
- en: '| `spring-boot-starter-web` | Starter for building web, including REST, applications
    using Spring MVC. Uses Tomcat as the default embedded container |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 用于构建Web应用程序，包括REST的起始器，使用Tomcat作为默认的嵌入式容器 |'
- en: '| `spring-boot-starter-websocket` | Starter for building WebSocket applications
    using Spring Framework’s WebSocket support |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-websocket` | 用于使用Spring框架的WebSocket支持构建WebSocket应用程序的起始器
    |'
- en: 'For complete information about Spring Boot visit the official reference: [https://projects.spring.io/spring-boot/.](https://projects.spring.io/spring-boot/)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Boot的完整信息，请访问官方参考：[https://projects.spring.io/spring-boot/.](https://projects.spring.io/spring-boot/)
- en: Spring Boot provides different capabilities to simplify the tests. For instance,
    it provides the `@SpringBootTest` annotation, which is used at classlevel in test
    classes. This annotation will create `ApplicationContext` for these tests (similarly
    to `@ContextConfiguration` but for Spring Boot based applications). As we have
    seen in the section before, in the `spring-test` module, we use the annotation
    `@ContextConfiguration(classes=… )` to specify, which bean definition (Spring
    `@Configuration`) to be loaded. When testing Spring Boot applications this is
    often not required. Spring Boot’s tests annotations will search the primary configuration
    automatically if not explicitly define one. The search algorithm works up from
    the package that contains the test until it finds a `@SpringBootApplication` annotated
    class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了不同的功能来简化测试。例如，它提供了`@SpringBootTest`注解，该注解用于测试类的类级别。此注解将为这些测试创建`ApplicationContext`（类似于`@ContextConfiguration`，但适用于基于Spring
    Boot的应用程序）。正如我们在前一节中所看到的，在`spring-test`模块中，我们使用注解`@ContextConfiguration(classes=…
    )`来指定要加载哪个bean定义（Spring `@Configuration`）。在测试Spring Boot应用程序时，通常不需要这样做。Spring
    Boot的测试注解将自动搜索主配置，如果没有明确定义，则会从包含测试的包开始向上搜索，直到找到一个带有`@SpringBootApplication`注解的类。
- en: Spring Boot also facilitates the use of mocks for Spring components. To that,
    the annotation `@MockBean` is provided. This annotation allows defining a Mockito
    mock for a bean inside our `ApplicationContext`. It can be new beans, but also
    to it can replace a single existing bean definition. Mock beans are automatically
    reset after each test method. This method is usually known as in-container testing,
    in counterpart to out-of-container, in which a mock library (example, Mockito)
    is used to unit test the Spring components in isolation and without the need of
    a Spring `ApplicationContext`. For example of both types of unit tests for Spring
    applications is shown in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot还简化了对Spring组件的模拟使用。为此，提供了`@MockBean`注解。此注解允许在我们的`ApplicationContext`中为bean定义一个Mockito模拟。它可以是新的bean，也可以替换单个现有的bean定义。模拟bean在每个测试方法后会自动重置。这种方法通常被称为容器内测试，与容器外测试相对应，在容器外测试中，使用模拟库（例如Mockito）来单元测试Spring组件，而无需Spring
    `ApplicationContext`。下一节中显示了Spring应用程序的两种类型的单元测试示例。
- en: JUnit 5 extension for Spring
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于Spring的JUnit 5扩展
- en: In order to integrate the `spring-test` capabilities into JUnit 5's Jupiter
    programming model, `SpringExtension` has been developed. This extension is part
    of the `spring-test` module, as of Spring 5\. Let's see several examples of JUnit
    5 and Spring 5 together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`spring-test`的功能集成到JUnit 5的Jupiter编程模型中，开发了`SpringExtension`。这个扩展是Spring
    5的`spring-test`模块的一部分。让我们看看几个Junit 5和Spring 5一起的例子。
- en: 'Let’s suppose we want to make an integration in-container test of the Spring
    application described in the former section, made up of three classes: `MySpringApplication`,
    `MessageComponent`, and `MessageService`. As we have learned, in order to implement
    a Jupiter test against this application, we need to make the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想对前一部分描述的Spring应用程序进行容器内集成测试，由三个类组成：`MySpringApplication`，`MessageComponent`和`MessageService`。正如我们所学的，为了对这个应用程序实施Jupiter测试，我们需要采取以下步骤：
- en: Annotate our test class with `@ContextConfiguration` to specify which `ApplicationContext`
    needs to be loaded.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`@ContextConfiguration`注释我们的测试类，以指定需要加载哪个`ApplicationContext`。
- en: Annotate our test class with `@ExtendWith(SpringExtension.class)` to enable
    `spring-test` into Jupiter.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@ExtendWith(SpringExtension.class)`注释我们的测试类，以启用`spring-test`进入Jupiter。
- en: Inject the Spring component we want to assess in our test class.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的测试类中注入我们想要评估的Spring组件。
- en: Implement our test (`@Test`).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们的测试（`@Test`）。
- en: 'For example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a very simple example in which the Spring component called `MessageComponent`
    is assessed. When this test is started, our `ApplicationContext` is initiated
    with and all our Spring components inside. After that, in this example, the bean
    `MessageComponent` is injected in the test, which is assessed simply calling the
    method `getMessage()` and verifying its response.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，其中评估了名为`MessageComponent`的Spring组件。当启动此测试时，我们的`ApplicationContext`被初始化，并且所有Spring组件都在其中。在这个例子中，bean
    `MessageComponent`被注入到测试中，通过调用方法`getMessage()`并验证其响应来进行评估。
- en: 'It is worth to review which dependencies are needed for this test. When using
    Maven, these dependencies are the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 值得回顾一下这个测试需要哪些依赖项。使用Maven时，这些依赖项如下：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other side, if we use Gradle, the dependencies clause would be as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用Gradle，依赖关系子句将如下所示：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that in both cases the `spring-context` dependency is needed to implement
    the application, and then we need `spring-test` and `junit-jupiter` to test it.
    In order to implement the equivalent application and test, but this time using
    Spring Boot, first we would need to change our `pom.xml` (when using Maven):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两种情况下，实现应用程序需要`spring-context`依赖项，然后我们需要`spring-test`和`junit-jupiter`来测试它。为了实现等效的应用程序和测试，但这次使用Spring
    Boot，首先我们需要更改我们的`pom.xml`（使用Maven时）：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or our `build.gradle` (when using Gradle):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们的`build.gradle`（使用Gradle时）：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to transform our raw Spring application into Spring Boot, our components
    (in the example called `MessageComponent` and `MessageService`) would be exactly
    the same, but our main class would change a bit (see here). Notice that we use
    the annotation `@SpringBootApplication` at class level, implementing the main
    method with the typically bootstrapping mechanism of Spring Boot. Just for logging
    purposes, we are implementing a method annotated with `@PostConstruct`. This method
    will be triggered just before the application context is started:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的原始Spring应用程序转换为Spring Boot，我们的组件（在示例中称为`MessageComponent`和`MessageService`）将完全相同，但我们的主类会有一些变化（见此处）。请注意，我们在类级别使用`@SpringBootApplication`注释，使用Spring
    Boot的典型引导机制实现主方法。仅用于记录目的，我们正在实现一个用`@PostConstruct`注释的方法。这个方法将在启动应用程序上下文之前触发：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The implementation of the test would be straightforward. The only change we
    need to do is to annotate the test with `@SpringBootTest` instead of `@ContextConfiguration`
    (Spring Boot automatically looks for and starts our `ApplicationContext`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的实现将是直接的。我们需要做的唯一更改是用`@SpringBootTest`注释测试，而不是`@ContextConfiguration`（Spring
    Boot自动查找并启动我们的`ApplicationContext`）：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Executing the test in the console, we can see that actually the application
    is started before the test (notice the unmistakable spring ASCII banner at the
    beginning).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台执行测试，我们可以看到实际上应用程序在测试之前启动（请注意开头的不可错过的spring ASCII横幅）。
- en: 'After that, our test uses the `ApplicationContext` to verify one Spring component,
    and as a result the test is succeeded:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们的测试使用`ApplicationContext`来验证一个Spring组件，测试结果成功：
- en: '![](img/00115.gif)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.gif)'
- en: Execution of test using Spring Boot
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot执行测试
- en: To finish with this part, we see a simple web application implemented with Spring
    Boot. With respect to the dependencies, the only change we need to do is to include
    the started `spring-boot-starter-web` (instead of the generic `spring-boot-starter`).
    That’s it, we can start implementing our Spring-based web application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结束这一部分时，我们看到一个使用Spring Boot实现的简单的Web应用程序。关于依赖项，我们需要做的唯一更改是包含启动的`spring-boot-starter-web`（而不是通用的`spring-boot-starter`）。就是这样，我们可以开始实现基于Spring的Web应用程序。
- en: 'We are going to implement a very simple `@Controller`, that is, the Spring
    bean, which handles the request from the browsers. In our example, the only URL
    mapped by the controller is the default resource `/`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常简单的`@Controller`，即处理来自浏览器的请求的Spring bean。在我们的例子中，控制器映射的唯一URL是默认资源`/`：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This component injects a service called `PageService`, responsible of returning
    the actual page to be loaded in response to the request to `/`. The content of
    this service is also very simple:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件注入了一个名为`PageService`的服务，负责返回响应`/`请求加载的实际页面。这个服务的内容也非常简单：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By convention (we are using Spring Boot here), the static resource for Spring-based
    web applications are located in a folder called `static` within the project classpath.
    Following the structure of Maven/Gradle project, this folder is located in the
    `src/main/resources` path (see screenshot below). Note that there are two pages
    there (we switch from one to the other in the tests, stay tuned):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定（我们在这里使用Spring Boot），基于Spring的Web应用程序的静态资源位于项目类路径中的一个名为`static`的文件夹中。根据Maven/Gradle项目的结构，这个文件夹位于`src/main/resources`路径下（见下面的截图）。请注意，这里有两个页面（我们在测试中从一个页面切换到另一个页面，敬请关注）：
- en: '![](img/00116.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: Content of the example project *junit5-spring-boot-web*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目*junit5-spring-boot-web*的内容
- en: 'Let’s move on not the interesting part: the tests. We are implementing three
    Jupiter tests in this project. The first one is devoted to verify a direct call
    to the page `/index.html`. As depicted before, this test needs to use the Spring
    extension (`@ExtendWith(SpringExtension.class)`) and be declared as Spring Boot
    test (`@SpringBootTest`). To carry out the request to web application, we use
    an instance of the `MockMvc`, verifying the response in several ways (HTTP response
    code, content-type, and response content body). This instance is automatically
    configured using the Spring Boot annotation `@AutoConfigureMockMvc`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行有趣的部分：测试。在这个项目中，我们正在实现三个Jupiter测试。第一个测试旨在验证对页面`/index.html`的直接调用。如前所述，这个测试需要使用Spring扩展（`@ExtendWith(SpringExtension.class)`）并声明为Spring
    Boot测试（`@SpringBootTest`）。为了执行对Web应用程序的请求，我们使用`MockMvc`的一个实例，以多种方式验证响应（HTTP响应代码、内容类型和响应内容主体）。这个实例是使用Spring
    Boot注解`@AutoConfigureMockMvc`自动配置的。
- en: Out of Spring Boot, instead of using `@AutoConfigureMockMvc`, the object `MockMvc`
    can be created using a builder class called `MockMvcBuilders`. In this case, the
    application context is used as parameter for that builder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot之外，可以使用一个名为`MockMvcBuilders`的构建器类来创建`MockMvc`对象，而不是使用`@AutoConfigureMockMvc`。在这种情况下，应用程序上下文被用作该构建器的参数。
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Again, running this test in the shell, we check that the application is actually
    executed. By default, the embedded Tomcat listens the port `8080`. After that,
    test is executed successfully:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在shell中运行这个测试，我们可以确认应用程序实际上被执行了。默认情况下，嵌入式Tomcat监听端口`8080`。之后，测试成功执行：
- en: '![](img/00117.gif)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.gif)'
- en: Console output of in-container first test
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内第一次测试的控制台输出
- en: 'Second test is similar, but as a differential factor it uses the test capability
    `@MockBean` to override a spring component (in this example, `PageService`) by
    a mock. In the body of the test, first we stub the method `getPage` of the mock
    to change the default response of the component to `redirect:/page.html`. As a
    result, when requesting the resource `/` in the test with the object `MockMvc`,
    we will obtain an HTTP 302 response (redirect) to the resource `/page.html` (which
    is actually an existing page, as shown in the project screenshot):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试类似，但作为一个差异因素，它使用了测试能力`@MockBean`来通过模拟覆盖一个spring组件（在这个例子中，`PageService`）。在测试的主体中，我们首先对模拟对象的`getPage`方法进行存根处理，以改变组件的默认响应为`redirect:/page.html`。结果，当使用`MockMvc`对象在测试中请求资源`/`时，我们将获得一个HTTP
    302响应（重定向）到资源`/page.html`（实际上是一个存在的页面，如项目截图所示）：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, in the shell we can confirm that the test starts the Spring application
    and then it is executed correctly:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在shell中，我们可以确认测试启动了Spring应用程序，然后正确执行了：
- en: '![](img/00118.gif)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.gif)'
- en: Console output of in-container second test
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内第二次测试的控制台输出
- en: 'The last test in this project is an example of an *out-of-container* test.
    In the previous test examples, the Spring context was used within the test. On
    the other side, the following relies completely in Mockito to exercise the components
    of the system, this time without starting the Spring application context. Note
    that we are using the `MockitoExtension` extension here, using the component `WebController`
    as our SUT (`@InjectMocks`) and the component `PageService` as DOC (`@Mock`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目中的最后一个测试是一个“容器外”测试的示例。在前面的测试示例中，Spring上下文在测试中被使用。另一方面，下面的测试完全依赖Mockito来执行系统组件，这次不启动Spring应用程序上下文。请注意，我们在这里使用`MockitoExtension`扩展，使用组件`WebController`作为我们的SUT（`@InjectMocks`）和组件`PageService`作为DOC（`@Mock`）：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This time, in the execution of the test, we do not see spring traces since
    the application container was not started before executing the test:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在测试的执行中，我们没有看到Spring的痕迹，因为在执行测试之前没有启动应用程序容器：
- en: '![](img/00119.gif)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.gif)'
- en: Console output of out-of-container test
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器外测试的控制台输出
- en: Selenium
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium
- en: Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) is an open
    source web testing framework, since its inception in 2008 has established itself
    as the *de facto* web automation library. In the next section, we are going to
    review the main features of Selenium and how to use it from JUnit 5 tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium（[http://www.seleniumhq.org/](http://www.seleniumhq.org/)）是一个开源的Web测试框架，自2008年成立以来，已经成为事实上的Web自动化库。在接下来的部分中，我们将回顾Selenium的主要特性以及如何在JUnit
    5测试中使用它。
- en: Selenium in a nutshell
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium简介
- en: Selenium is composed by different projects. First, we found the Selenium IDE.
    It is a Firefox plugin implementing the R**ecord and Playback** (**R&P**) pattern
    for web applications. Thus, it allows to record manual interactions with Firefox
    and the playback that recording in an automated fashion.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium由不同的项目组成。首先，我们找到了Selenium IDE。它是一个Firefox插件，实现了用于Web应用程序的“录制和回放”（R&P）模式。因此，它允许记录与Firefox的手动交互，并以自动化方式回放该录制。
- en: The second project was named **Selenium Remote Control** (**RC**). This component
    was capable of driving different types of browser automatically using different
    programming languages, such as Java, C#, Python, Ruby, PHP, Perl, or JavaScript.
    This component injected a JavaScript library (called Selenium Core) in the SUT.
    This library was controlled with an intermediate component called Selenium RC
    Server which receives requests from the test code (see the following figure).
    Selenium RC had important security problems due to same-origin policy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目被命名为**Selenium Remote Control**（**RC**）。这个组件能够使用不同的编程语言（如Java、C#、Python、Ruby、PHP、Perl或JavaScript）自动驱动不同类型的浏览器。这个组件在SUT中注入了一个名为Selenium
    Core的JavaScript库。这个库由一个名为Selenium RC Server的中间组件控制，该组件接收来自测试代码的请求（见下图）。由于同源策略，Selenium
    RC存在重要的安全问题。
- en: 'For that reason, it was deprecated on 2016 in favor of Selenium WebDriver:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它在2016年被弃用，以支持Selenium WebDriver：
- en: '![](img/00120.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: Selenium RC schema
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium RC架构
- en: We review Selenium RC just to introduce Selenium WebDriver. Nowadays, Selenium
    RC is deprecated and its use is highly discouraged.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾Selenium RC只是为了介绍Selenium WebDriver。如今，Selenium RC已经被弃用，强烈不建议使用。
- en: From a functional point of view, Selenium WebDriver is equivalent to RC (that
    is, allows to control browsers using code). As a differential aspect, Selenium
    WebDriver makes calls to the browser using each browser’s native support for automation.
    The language bindings provided by Selenium WebDriver (labeled as Test in next
    figure) communicates with and a browser-specific binary, which acts as a bridge
    between real browser. For instance, this binary is called *chromedriver* ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/))
    for Chrome and *geckodriver* ([https://github.com/mozilla/geckodriver](https://github.com/mozilla/geckodriver))
    for Firefox. The communication between the Test and the driver is done with JSON
    messages over HTTP using the so-called JSON Wire Protocol.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，Selenium WebDriver等同于RC（即允许使用代码控制浏览器）。作为差异化方面，Selenium WebDriver使用每个浏览器的本机支持自动化来调用浏览器。由Selenium
    WebDriver提供的语言绑定（在下图中标记为Test）与特定于浏览器的二进制文件通信，这个二进制文件充当真实浏览器之间的桥梁。例如，这个二进制文件对于Chrome被称为*chromedriver*（[https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/)），对于Firefox被称为*geckodriver*（[https://github.com/mozilla/geckodriver](https://github.com/mozilla/geckodriver)）。测试与驱动程序之间的通信是通过HTTP上的JSON消息使用所谓的JSON
    Wire Protocol完成的。
- en: 'This mechanism, originally proposed by the WebDriver team is standardized in
    the W3C WebDriver API ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制最初由WebDriver团队提出，在W3C WebDriver API中得到了标准化（[https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)）：
- en: '![](img/00121.jpeg)Selenium WebDriver schema'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00121.jpeg)Selenium WebDriver架构'
- en: 'The last project of the Selenium portfolio is called Selenium Grid. It can
    be seen as extension of Selenium WebDriver, since it allows distributing browser
    execution on remote machines. There are a number of Nodes, each running on different
    operating systems and with different browsers. The Hub server keeps a track of
    the nodes and proxies requests to them (see figure below):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium组合中的最后一个项目称为Selenium Grid。它可以被看作是Selenium WebDriver的扩展，因为它允许在远程机器上分发浏览器执行。有许多节点，每个节点在不同的操作系统上运行，并且具有不同的浏览器。Hub服务器跟踪这些节点，并将请求代理给它们（见下图）：
- en: '![](img/00122.jpeg)Selenium Grid schema'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00122.jpeg)Selenium Grid架构'
- en: 'The following table summarizes the main features of the WebDriver API:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了WebDriver API的主要特性：
- en: '| **WebDriver feature and description** | **Example** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **WebDriver特性和描述** | **示例** |'
- en: '| WebDriver object creation:It allows to create WebDriver instances, which
    are used from the test code to control a browser remotely. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 创建WebDriver对象：它允许创建WebDriver实例，这些实例从测试代码中远程控制浏览器。|'
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Navigation:It allows to navigate to a given URL. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 导航：它允许导航到给定的URL。|'
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Locate elements:It allows to identify elements with a web page (WebElement)
    using different strategies: by id, name, class name, CSS selector, link text,
    tag name, or XPath |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 定位元素：它允许使用不同的策略（按id、名称、类名、CSS选择器、链接文本、标签名或XPath）来识别网页上的元素（WebElement）。|'
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Interact with elements:From a given WebElement, we can carry out different
    types of automated interaction, such as click elements, type text or clear input
    fields, read attributes, and so on. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 与元素交互：从给定的WebElement，我们可以进行不同类型的自动交互，比如点击元素、输入文本或清除输入字段、读取属性等。|'
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Handle waits:WebDriver can handle wait both explicit and implicitly. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 处理等待：WebDriver可以处理显式和隐式的等待。|'
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: XPath (XML Path Language) is a language to build expressions to parse and process
    XML-like documents (for example, HTML)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: XPath（XML Path Language）是一种用于构建表达式以解析和处理类似XML的文档（例如HTML）的语言。
- en: JUnit 5 extension for Selenium
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于Selenium的JUnit 5扩展
- en: In order to simplify the use of Selenium WebDriver in JUnit 5, the open source
    JUnit 5 extension called `selenium-jupiter` can be used. This extension has been
    built using the dependency injection capability provided by the extension model
    of JUnit 5\. Thanks to this feature, different types objects can be injected in
    JUnit 5 in `@Test` methods as parameters. Concretely, `selenium-jupiter` allows
    to inject subtypes of the `WebDriver` interface (for example, `ChromeDriver`,
    `FirefoxDriver`, and so on).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化在JUnit 5中使用Selenium WebDriver，可以使用名为`selenium-jupiter`的开源JUnit 5扩展。这个扩展是使用JUnit
    5扩展模型提供的依赖注入功能构建的。由于这个特性，不同类型的对象可以作为参数注入到JUnit 5的`@Test`方法中。具体来说，`selenium-jupiter`允许注入`WebDriver`接口的子类型（例如`ChromeDriver`、`FirefoxDriver`等）。
- en: 'Using `selenium-jupiter` is very easy. First, we need to import the dependency
    in our project (typically as test dependency). In Maven, it is done as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`selenium-jupiter`非常容易。首先，我们需要在项目中导入依赖项（通常作为测试依赖项）。在Maven中，可以按照以下步骤完成：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`selenium-jupiter` depends on several libraries, which are added in our project
    as transitive `dependencies`, namely:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`selenium-jupiter`依赖于几个库，这些库作为传递性`依赖项`添加到我们的项目中，即：'
- en: '`Selenium-java` (`org.seleniumhq.selenium:selenium-java`): Java library for
    Selenium WebDriver.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selenium-java`（`org.seleniumhq.selenium:selenium-java`）：Selenium WebDriver的Java库。'
- en: '`WebDriverManager` (`io.github.bonigarcia:webdrivermanager`): Java library
    for automatic Selenium WebDriver binaries management in runtime for Java ([https://github.com/bonigarcia/webdrivermanager](https://github.com/bonigarcia/webdrivermanager)).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebDriverManager（`io.github.bonigarcia:webdrivermanager`）：用于在Java运行时自动管理Selenium
    WebDriver二进制文件的Java库（[https://github.com/bonigarcia/webdrivermanager](https://github.com/bonigarcia/webdrivermanager)）。
- en: 'Appium (`io.appium:java-client`): Java client for Appium, testing framework
    that extends Selenium to automate testing of native, hybrid, and mobile web apps
    ([http://appium.io/](http://appium.io/)).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Appium（`io.appium:java-client`）：Appium的Java客户端，这是一个测试框架，扩展了Selenium以自动化测试原生、混合和移动Web应用程序（[http://appium.io/](http://appium.io/)）。
- en: 'Once `selenium-jupiter` is included in our project, we need to declare `selenium-jupiter`
    extension in our JUnit 5 test, simply annotating it with `@ExtendWith(SeleniumExtension.class)`.
    Then, we need to include one or more parameters in our `@Test` methods whose types
    implement the WebDriver interface, and `selenium-jupiter` control the lifecycle
    of the WebDriver object internally. He WebDriver subtypes supported by `selenium-jupiter`
    are the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在我们的项目中包含了`selenium-jupiter`，我们需要在我们的JUnit 5测试中声明`selenium-jupiter`扩展，只需用`@ExtendWith(SeleniumExtension.class)`进行注释。然后，在我们的`@Test`方法中需要包含一个或多个参数，其类型实现了WebDriver接口，`selenium-jupiter`在内部控制WebDriver对象的生命周期。`selenium-jupiter`支持的WebDriver子类型如下：
- en: '`ChromeDriver`: This is used to control Google Chrome browser.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChromeDriver`：这用于控制Google Chrome浏览器。'
- en: '`FirefoxDriver`: This is used to control Firefox browser.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirefoxDriver`：这用于控制Firefox浏览器。'
- en: '`EdgeDriver`: This is used to control Microsoft Edge browser.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EdgeDriver`：这用于控制Microsoft Edge浏览器。'
- en: '`OperaDriver`: This is used to control Opera browser.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperaDriver`：这用于控制Opera浏览器。'
- en: '`SafariDriver`: This is used to control Apple Safari browser (only possible
    in OSX El Capitan or greater).'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SafariDriver`：这用于控制Apple Safari浏览器（仅在OSX El Capitan或更高版本中可能）。'
- en: '`HtmlUnitDriver`: This is used to control HtmlUnit (headless browser, that
    is, a browser without GUI).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlUnitDriver`：这用于控制HtmlUnit（无头浏览器，即没有GUI的浏览器）。'
- en: '`PhantomJSDriver`: This is used to control PhantomJS (another headless browser).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhantomJSDriver`：这用于控制PhantomJS（另一个无头浏览器）。'
- en: '`InternetExplorerDriver`: This is used to control Microsoft Internet Explorer.
    Although this browser is supported, Internet Explorer is deprecated (in favor
    of Edge) and its use is highly discouraged.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InternetExplorerDriver`：这用于控制Microsoft Internet Explorer。尽管该浏览器受支持，但Internet
    Explorer已被弃用（支持Edge），强烈不建议使用。'
- en: '`RemoteWebDriver`: This is used to control remote browsers (Selenium Grid).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteWebDriver`：这用于控制远程浏览器（Selenium Grid）。'
- en: '`AppiumDriver`: This is used to control mobile devices (Android and iOS).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppiumDriver`：这用于控制移动设备（Android和iOS）。'
- en: 'Consider the following class, which uses `selenium-jupiter` , that is, declaring
    the Selenium extension using `@ExtendWith(SeleniumExtension.**class**)`. This
    example defines three tests, which are going be executed using local browsers.
    First one (named `testWithChrome`) uses Chrome as browsers. To that aim, and thanks
    to the dependency injection feature of `selenium-jupiter`*,* the method simply
    needs to declare a method argument using the type `ChromeDriver`. Then, in the
    body of the test, the `WebDriver` API is invoked in that object. Note that this
    test simple opens a web page and asserts that the title is as expected. Next,
    test (`testWithFirefoxAndOpera`) is similar, but this time using two different
    browsers at the same time: Firefox (using an instance of `FirefoxDriver`) and
    Opera (using an instance of `OperaDriver`). The third and last test (`testWithHeadlessBrowsers`)
    declares and uses two headless browsers (`HtmlUnit` and `PhantomJS`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类，它使用`selenium-jupiter`，即使用`@ExtendWith(SeleniumExtension.**class**)`声明Selenium扩展。这个例子定义了三个测试，将使用本地浏览器执行。第一个（名为`testWithChrome`）使用Chrome作为浏览器。为此，借助于`selenium-jupiter`的依赖注入功能，方法只需要声明一个使用`ChromeDriver`类型的方法参数。然后，在测试的主体中，调用了该对象中的`WebDriver`
    API。请注意，这个测试只是打开一个网页，并断言标题是否符合预期。接下来的测试（`testWithFirefoxAndOpera`）类似，但这次同时使用两个不同的浏览器：Firefox（使用`FirefoxDriver`的实例）和Opera（使用`OperaDriver`的实例）。第三个也是最后一个测试（`testWithHeadlessBrowsers`）声明并使用了两个无头浏览器（`HtmlUnit`和`PhantomJS`）：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to execute properly this test class, the required browsers (Chrome,
    Firefox, and Opera) should be installed beforehand running it. On the other hand,
    the headless browsers (HtmlUnit and PhantomJS) are consumed as Java dependencies,
    and so there is no need to install them manually.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确执行这个测试类，应该在运行之前安装所需的浏览器（Chrome、Firefox和Opera）。另一方面，无头浏览器（HtmlUnit和PhantomJS）作为Java依赖项使用，因此无需手动安装它们。
- en: 'Let’s see another example, this time using remote browsers (that is, Selenium
    Grid). Again, this class uses the `selenium-jupiter` extension. The test (`testWithRemoteChrome`)
    declares a single parameter called `remoteChrome`, of type `RemoteWedbrider`.
    This argument is annotated with `@DriverUrl` and `@DriverCapabilities`, specifying
    the Selenium Server (or Hub) URL and the required capabilities respectively. Regarding
    the capabilities, we are configuring to use a Chrome browser version 59:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，这次使用远程浏览器（即Selenium Grid）。再次，这个类使用`selenium-jupiter`扩展。测试（`testWithRemoteChrome`）声明了一个名为`remoteChrome`的单个参数，类型为`RemoteWedbrider`。这个参数用`@DriverUrl`和`@DriverCapabilities`进行注释，分别指定了Selenium服务器（或Hub）的URL和所需的能力。关于能力，我们正在配置使用Chrome浏览器版本59：
- en: To run this test properly, a Selenium Server should up and running in the localhost,
    and a node (Chrome 59) needs to be registered in the Hub.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确运行这个测试，Selenium服务器应该在本地主机上运行，并且需要在Hub中注册一个节点（Chrome 59）。
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the last example of this section, we use `AppiumDriver`. Concretely, we
    set up as capabilities the use of a Chrome browser in an Android emulated device
    (`@DriverCapabilities`). Again, this emulator needs to be up and running in the
    machine running the test beforehand:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一个示例中，我们使用了`AppiumDriver`。具体来说，我们设置了使用Android模拟设备中的Chrome浏览器的能力（`@DriverCapabilities`）。同样，这个模拟器需要在运行测试的机器上提前启动和运行：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For further examples of `selenium-jupiter`, visit [https://bonigarcia.github.io/selenium-jupiter/](https://bonigarcia.github.io/selenium-jupiter/).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Selenium-Jupiter`的更多示例，请访问[https://bonigarcia.github.io/selenium-jupiter/](https://bonigarcia.github.io/selenium-jupiter/)。
- en: Cucumber
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cucumber
- en: Cucumber ([https://cucumber.io/](https://cucumber.io/)) is testing framework
    aimed to automate acceptance tests written following a **Behavior-Driven Development**
    (**BDD**) style. Cucumber has been written in Ruby, although implementations for
    other languages (including Java, JavaScript, and Python) are available.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber（[https://cucumber.io/](https://cucumber.io/)）是一个旨在自动化接受测试的测试框架，遵循**行为驱动开发**（**BDD**）风格编写。Cucumber是用Ruby编写的，尽管其他语言的实现（包括Java、JavaScript和Python）也是可用的。
- en: Cucumber in a nutshell
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cucumber简介
- en: Cucumber executes tests specified written in language called Gherkin. It is
    a plaint-text natural language (for example, English or one of other 60+ languages
    supported by Cucumber) with a given structure. Gherkin has been designed to be
    used by non-programmers, typically customers, business analysis, managers, and
    so on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber执行以Gherkin语言编写的测试。这是一种纯文本自然语言（例如英语或Cucumber支持的其他60多种语言之一），具有给定的结构。Gherkin旨在供非程序员使用，通常是客户、业务分析师、经理等。
- en: The extension for Gherkin files is `*.feature*`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin文件的扩展名是`*.feature*`。
- en: 'In a Gherkin file, non-blank lines can start with a keyword, followed by text
    in natural language. The main keywords are the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gherkin文件中，非空行可以以关键字开头，后面是自然语言的文本。主要关键字如下：
- en: '**Feature**: High-level description of the software feature to be tested. It
    can be seen as a use case description.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Feature**：要测试的软件功能的高级描述。它可以被视为用例描述。'
- en: '**Scenario**: Concrete example that illustrates a business rule. Scenarios
    follow the same pattern:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scenario**：说明业务规则的具体示例。场景遵循相同的模式：'
- en: Describe initial context.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述初始上下文。
- en: Describe an event.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述一个事件。
- en: Describe the expected outcome.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述预期的结果。
- en: 'These actions are known in the Gherkin jargon as steps, which are mainly **Given**,
    **When**, or **Then**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作在Gherkin行话中被称为步骤，主要是**Given**、**When**或**Then**：
- en: 'There are two additional steps: **And** (used for logical and for different
    steps) and **But** (used in for negative form of **And**).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个额外的步骤：**And**（用于逻辑和不同步骤）和**But**（用于**And**的否定形式）。
- en: '**Given**: Preconditions and initial state before the start of a test.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given**：测试开始前的前提条件和初始状态。'
- en: '**When**: Actions taken by a user during a test.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**When**：测试期间用户执行的操作。'
- en: '**Then**: Outcome from actions taken in the **When** clause.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then**：在**When**子句中执行的操作的结果。'
- en: '**Background**: To avoid repeat steps in different scenarios, the keyword background
    allows to declared these steps, which are reused in subsequent scenarios.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Background**：为了避免在不同场景中重复步骤，关键字background允许声明这些步骤，这些步骤在后续场景中被重用。'
- en: '**Scenario Outline**: Scenarios in which steps are marked with variables (using
    the symbols `**<**` and `**>**`).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scenario Outline**：在这些场景中，步骤标有变量（使用符号`**<**`和`**>**`）。'
- en: '**Examples**: A scenario outline declaration is always followed by one or more
    examples sections, which is a container table with values for the declared variables
    in the **Scenario Outline**.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Examples**：场景大纲声明总是后跟一个或多个示例部分，这是一个包含**Scenario Outline**中声明的变量值的容器表。'
- en: When one line does not start with a keyword, that line is not interpreted by
    Cucumber. It is used to custom description.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当一行不以关键字开头时，Cucumber不会解释该行。它用于自定义描述。
- en: 'Once we defined our features to be tested we need what it is called *steps
    definition*, which allows to translate plain text Gherkin into actions that actually
    exercise our SUT. In Java, it can be easily done by annotations to annotate methods
    for the step implementation: `@Given`, `@Then`, `@When`, `@And`, and `@But`. The
    string value of each step can contain regular expression which are mapped as fields
    in the method. See an example in the next section.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了要测试的功能，我们需要所谓的*步骤定义*，它允许将纯文本Gherkin转换为实际执行我们的SUT的操作。在Java中，可以通过注解来轻松地实现这一点，用于注释步骤实现的方法：`@Given`、`@Then`、`@When`、`@And`和`@But`。每个步骤的字符串值可以包含正则表达式，这些正则表达式被映射为方法中的字段。在下一节中看一个例子。
- en: JUnit 5 extension for Cucumber
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cucumber的JUnit 5扩展
- en: The latest versions of the Cucumber artifacts for Java incorporates a JUnit
    5 extension for Cucumber. This section contains a complete example of a feature
    defined in Gherkin and the JUnit 5 to execute it with Cucumber. As usual, the
    source code of this example is hosted on GitHub ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的Cucumber Java工件包含了Cucumber的JUnit 5扩展。本节包含了一个在Gherkin中定义的功能的完整示例，以及使用Cucumber执行它的JUnit
    5。和往常一样，这个示例的源代码托管在GitHub上（[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)）。
- en: 'The structure of the project containing this example is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此示例的项目结构如下：
- en: '![](img/00123.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00123.jpeg)'
- en: JUnit 5 with Cucumber project structure and content
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5与Cucumber项目结构和内容
- en: 'First of all, we need to create our Gherkin file, which is aimed to test a
    simple calculator system. This calculator will be the SUT or our test. The content
    of our feature file is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的Gherkin文件，这个文件旨在测试一个简单的计算器系统。这个计算器将是我们的SUT或测试对象。我们的功能文件的内容如下：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we need to implement our steps definition. As described earlier, we use
    annotations and regular expression to map the text contained in the Gherkin file
    to the actual exercise of SUT depending on the step:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现我们的步骤定义。如前所述，我们使用注解和正则表达式将Gherkin文件中包含的文本映射到SUT的实际练习，具体取决于步骤：
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Of course, we still need to implement our JUnit 5 test. To achieve the integration
    of Cucumber and JUnit 5, the Cucumber extension needs to be registered in our
    class by means of `@ExtendWith(CucumberExtension.**class**)`. Internally, `CucumberExtension`
    implements the `ParameterResolver` callback of the Jupiter extension model. The
    objective is to inject the corresponding tests of the Cucumber feature as Jupiter
    `DynamicTest` objects in the tests. Notice in the example how a `@TestFactory`
    is used.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然需要实现我们的JUnit 5测试。为了实现Cucumber和JUnit 5的集成，需要通过`@ExtendWith(CucumberExtension.**class**)`在我们的类中注册Cucumber扩展。在内部，`CucumberExtension`实现了Jupiter扩展模型的`ParameterResolver`回调。其目标是将Cucumber功能的相应测试注入为Jupiter
    `DynamicTest`对象。请注意示例中如何使用`@TestFactory`。
- en: 'Optionally, we can annotate our test class with `@CucumberOptions`. This annotation
    allows to configure the Cucumber settings for our test. The allowed elements for
    this annotation are:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以使用`@CucumberOptions`注释我们的测试类。此注释允许配置测试的Cucumber设置。此注释的允许元素为：
- en: '`plugin`: Built-in formatter: pretty, progress, JSON, usage, among others.
    Default: `{}`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugin`：内置格式：pretty、progress、JSON、usage等。默认值：`{}`。'
- en: '`dryRun`: Checks if all steps have definitions. Default: `false`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dryRun`：检查是否所有步骤都有定义。默认值：`false`。'
- en: '`features`: Paths of the features files. Default: `{}`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`features`：功能文件的路径。默认值：`{}`。'
- en: '`glue`: Paths for step definitions. Default: `{}`.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glue`：步骤定义的路径。默认值：`{}`。'
- en: '`tags`: Tags in the features to be executed. Default `{}`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：要执行的功能中的标签。默认值`{}`。'
- en: '`monochrome`: Displays console output in a readable way. Default: `false`.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monochrome`：以可读的方式显示控制台输出。默认值：`false`。'
- en: '`format`: Reports formatter to be used. Default: `{}`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：要使用的报告格式。默认值：`{}`。'
- en: '`strict`: Fails if there are undefined or pending steps. Default: `false`.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strict`：如果有未定义或挂起的步骤，则失败。默认值：`false`。'
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, we are able to execute our Cucumber suite with JUnit 5\. In
    the following example we see the output when running the test with Gradle:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以使用JUnit 5执行我们的Cucumber套件。在下面的示例中，我们看到了使用Gradle运行测试时的输出：
- en: '![](img/00124.gif)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00124.gif)'
- en: Execution of JUnit 5 using Cucumber with Gradle
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle使用Cucumber执行JUnit 5
- en: Docker
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is an open source
    software technology, which allows to pack and run any application as a lightweight
    and portable container. It provides a command-line program, a background daemon,
    and a set of remote services that simplifies the life cycle of containers.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（[https://www.docker.com/](https://www.docker.com/)）是一种开源软件技术，允许将任何应用程序打包并作为轻量级和便携式容器运行。它提供了一个命令行程序，一个后台守护程序和一组远程服务，简化了容器的生命周期。
- en: Docker in a nutshell
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: Historically, UNIX-style operating systems used the term jail to describe modified
    isolated runtime environments. The **Linux Containers** (**LXC**) project started
    in 2008 and brought together cgroups, kernel namespaces, or chroot (among others)
    to provide complete isolation execution. The problem with LXC is the difficulty,
    and for that reason, the Docker technology emerged.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，UNIX风格的操作系统使用术语"jail"来描述修改后的隔离运行时环境。**Linux容器**（**LXC**）项目始于2008年，汇集了cgroups、内核命名空间或chroot（等等）以提供完全隔离的执行。LXC的问题在于难度，因此Docker技术应运而生。
- en: Docker hides in underlying complexity of the aforementioned resource isolation
    features of the Linux kernel (cgroups, kernel namespaces, and so on) to allow
    independent containers to run within a single Linux instance. Docker provides
    a high-level API, which allows to pack, ship and run any application as a container.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Docker隐藏了Linux内核的上述资源隔离功能（cgroups、内核命名空间等）的底层复杂性，以允许独立的容器在单个Linux实例中运行。Docker提供了一个高级API，允许将任何应用程序打包、分发和作为容器运行。
- en: In Docker, a container contains an application and its dependencies together.
    Multiple containers can run on the same machine and share the same OS kernel with
    other containers. Each container is running as isolated process in user space.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，容器包含应用程序及其依赖项。多个容器可以在同一台机器上运行，并与其他容器共享相同的操作系统内核。每个容器都作为用户空间中的隔离进程运行。
- en: Unlike **virtual machines** (**VMs**), in Docker containers there is no need
    of using a hypervisor, which is the software that allows to create and runs VM
    (example; VirtualBox, VMware, QEMU or Virtual PC).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与**虚拟机**（**VM**）不同，在Docker容器中不需要使用虚拟化程序，虚拟化程序是允许创建和运行VM的软件（例如：VirtualBox、VMware、QEMU或Virtual
    PC）。
- en: 'The architecture of VM and container are depicted in the following diagram:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: VM和容器的架构如下图所示：
- en: '![](img/00125.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00125.jpeg)'
- en: Virtual machine versus container
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机与容器
- en: 'The Docker platform has two components: the Docker Engine, which is responsible
    for creating and running containers; and the Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)),
    a cloud service for distributing containers. The Docker Hub provides an enormous
    number of public container images for download. The Docker Engine is a client-server
    application composed by three major components:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台有两个组件：Docker引擎负责创建和运行容器；Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）是一个用于分发容器的云服务。Docker
    Hub提供了大量的公共容器镜像供下载。Docker引擎是一个由三个主要组件组成的客户端服务器应用程序：
- en: A server implemented as a daemon process (the `dockerd` command).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为守护进程实现的服务器（`dockerd`命令）。
- en: A REST API, which specifies interfaces that programs can use to talk to the
    daemon and instruct it what to do.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个REST API，指定程序可以用来与守护进程通信并指示其要执行的接口。
- en: A **command line interface** (**CLI**) client (the `docker` command).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**命令行界面**（**CLI**）客户端（`docker`命令）。
- en: JUnit 5 extension for Docker
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的JUnit 5扩展
- en: Nowadays, containers are changing the way we develop, distribute, and run software.
    This is especially interesting for **Continuous Integration** (**CI**) testing
    environment, in which the convergence with Docker has a direct impact on the improvement
    of efficiency.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，容器正在改变我们开发、分发和运行软件的方式。这对于**持续集成**（**CI**）测试环境尤其有趣，其中与Docker的融合直接影响效率的提高。
- en: 'Regarding JUnit 5, at the moment of this writing there is an open source JUnit
    5 extension for Docker, named JUnit5-Docker ([https://faustxvi.github.io/junit5-docker/](https://faustxvi.github.io/junit5-docker/)).
    This extension acts as client of the Docker engine and allows to start a Docker
    container (downloaded from the Docker Hub), before running the tests of a class.
    That container is stopped at the end of the tests. In order to use JUnit5-Docker,
    first we need to add the dependency in our project. In Maven:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JUnit 5，在撰写本文时，有一个名为JUnit5-Docker的开源JUnit 5扩展，用于Docker（[https://faustxvi.github.io/junit5-docker/](https://faustxvi.github.io/junit5-docker/)）。该扩展充当Docker引擎的客户端，并允许在运行类的测试之前启动一个Docker容器（从Docker
    Hub下载）。该容器在测试结束时停止。为了使用JUnit5-Docker，首先需要在项目中添加依赖。在Maven中：
- en: '[PRE43]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Gradle:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中：
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The use of JUnit5-Docker is quite straightforward. We simply need to annotate
    our test class with `@Docker`. The elements available in this annotation are the
    following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit5-Docker非常简单。我们只需要用`@Docker`注解标记我们的测试类。此注解中可用的元素如下：
- en: '`image`: Docker image to be started.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：要启动的Docker镜像。'
- en: '`ports`: Port mapping for the Docker container. This is required since at least
    one port must be visible for the container to be useful.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：Docker容器的端口映射。这是必需的，因为至少一个端口必须对容器可见才能有用。'
- en: '`environments`: Optional environment variables to pass to the docker container.
    Default: `{}`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments`：要传递给Docker容器的可选环境变量。默认值：`{}`。'
- en: '`waitFor`: Optional log to wait for before running the tests. Default: `@WaitFor(NOTHING)`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitFor`：在运行测试之前等待的可选日志。默认值：`@WaitFor(NOTHING)`。'
- en: '`newForEachCase`: Boolean flag, which determines if the container should be
    recreated for each test case. This value will be false if it should be created
    only once for the test class. Default: `true`.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newForEachCase`：布尔标志，确定是否应为每个测试用例重新创建容器。如果应该仅为测试类创建一次，则该值将为false。默认值：`true`。'
- en: 'Consider the following example. This test class uses the `@Docker` annotation
    to start a MySql container (container image MySQL) and the beginning of each test.
    The internal container port is `3306`, which will be mapped to the host port `8801`.
    Then, several environment attributes are defined (MySql root password, default
    database, and user name and password). The execution of the test will not start
    until the trace *mysqld: ready for connections* appears in the container log (which
    indicates that the MySql instance is up and running). In the body of the test,
    we start a JDBC connection against the MySQL instance running in the container.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑以下示例。这个测试类使用`@Docker`注解在每个测试开始时启动一个MySql容器（容器镜像MySQL）。内部容器端口是`3306`，将映射到主机端口`8801`。然后，定义了几个环境属性（MySql根密码、默认数据库、用户名和密码）。测试的执行将在容器日志中出现*mysqld:
    ready for connections*的迹象之前不会开始（这表明MySql实例已经启动）。在测试的主体中，我们对在容器中运行的MySQL实例进行JDBC连接。'
- en: This test has been executed in a Windows machine. For that reason, the host
    of the JDBC URL is 192.168.99.100, which is the IP for the Docker Machine. It
    is a tool which allows to install Docker Engine on virtual hosts, such as Windows
    or Mac ([https://docs.docker.com/machine/](https://docs.docker.com/machine/)).
    In a Linux machine, this IP could be 127.0.0.1 (localhost).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试是在Windows机器上执行的。因此，JDBC URL的主机是192.168.99.100，这是Docker Machine的IP。这是一个工具，允许在虚拟主机上安装Docker
    Engine，比如Windows或Mac（[https://docs.docker.com/machine/](https://docs.docker.com/machine/)）。在Linux机器上，这个IP可能是127.0.0.1（本地主机）。
- en: '[PRE45]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The execution of this test in the Docker Windows terminal is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Windows终端中执行此测试的过程如下：
- en: '![](img/00126.gif)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00126.gif)'
- en: Execution of test using JUnit5-Docker extension
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit5-Docker扩展执行测试
- en: Android
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android
- en: Android ([https://www.android.com/](https://www.android.com/)) is an open source
    mobile operating system based on a modified version of Linux. It was originally
    developed by a startup named Android, acquired and championed by Google in 2005.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Android ([https://www.android.com/](https://www.android.com/))是一个基于修改版Linux的开源移动操作系统。它最初由一家名为Android的初创公司开发，于2005年被Google收购和支持。
- en: 'According to the report by Gartner Inc. (American IT research and advisory
    company), in 2017 Android and iOS account more than 99% of global smartphone sales,
    as shown in the following chart:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 根据美国IT研究和咨询公司Gartner Inc.的报告，2017年Android和iOS占全球智能手机销量的99%以上，如下图所示：
- en: '![](img/00127.jpeg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.jpeg)'
- en: Smartphone operative system market. Picture created by www.statista.com.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手机操作系统市场。图片由www.statista.com创建。
- en: Android in a nutshell
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android简介
- en: 'Android is a Linux-based software stack divided into several layers. Those
    layers, from down to top are the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个基于Linux的软件堆栈，分为几个层。这些层，从下到上分别是：
- en: '**Linux kernel**: This is the foundation of the Android platform. This layer
    contains all the low-level device drivers for the various hardware components
    of an Android device.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux内核**：这是Android平台的基础。该层包含Android设备各种硬件组件的低级设备驱动程序。'
- en: '**Hardware Abstraction Layer** (**HAL**): This layer provides standard interfaces
    that expose hardware capabilities to the higher-level Java API framework.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件抽象层**（**HAL**）：该层提供标准接口，将硬件功能暴露给更高级别的Java API框架。'
- en: '**Android Runtime** (**ART**): It provides a runtime environment for `.dex`
    files, a bytecode format designed for minimal memory footprint. ART was the first
    release on Android 5.0 (see table below). Prior to that version, Dalvik was the
    Android runtime.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android运行时**（**ART**）：它为`.dex`文件提供运行时环境，这是一种设计用于最小内存占用的字节码格式。ART是Android
    5.0上的第一个版本（见下表）。在该版本之前，Dalvik是Android运行时。'
- en: '**Native C/C++ libraries**: This layer contains native libraries written in
    C and C++, such as OpenGL ES for high-performance 2D and 3D graphics processing.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地C/C++库**：该层包含用C和C++编写的本地库，如OpenGL ES，用于高性能2D和3D图形处理。'
- en: '**Java API framework**: The entire feature-set of Android is available for
    developers through APIs written in Java. These APIs are the building block for
    creating Android apps, for instance: the View System (for apps UIs), the Resource
    Manager (for I18N, graphics, layouts), the Notification Manager (for custom alerts
    in the status bar), the Activity Manager (to manage the apps lifecycle), or the
    Content Provider (to enable apps access data from other apps, such as the Contacts,
    and so on).'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java API框架**：Android的整个功能集通过用Java编写的API可供开发人员使用。这些API是创建Android应用程序的构建块，例如：视图系统（用于应用程序UI）、资源管理器（用于国际化、图形、布局）、通知管理器（用于状态栏中的自定义警报）、活动管理器（用于管理应用程序的生命周期）或内容提供程序（用于使应用程序能够访问其他应用程序的数据，如联系人等）。'
- en: '**Apps**: Android comes with a set of core apps, such as Phone, Contacts, Browser,
    and so on. In addition, many others apps can be downloaded and installed from
    Google Play (formerly Android Market):'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：Android带有一组核心应用程序，如电话、联系人、浏览器等。此外，还可以从Google Play（以前称为Android Market）下载和安装许多其他应用程序：'
- en: '![](img/00128.jpeg)Android layered architecture'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00128.jpeg)Android分层架构'
- en: 'Android has gone through quite a number of updates since its first release,
    as described in the following table:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 自首次发布以来，Android经历了许多更新，如下表所述：
- en: '| **Android version** | **Codename** | **API level** | **Linux kernel version**
    | **Release date** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '**Android版本** | **代号** | **API级别** | **Linux内核版本** | **发布日期** |'
- en: '| 1.5 | Cupcake | 3 | 2.6.27 | April 30, 2009 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 | Cupcake | 3 | 2.6.27 | 2009年4月30日 |'
- en: '| 1.6 | Donut | 4 | 2.6.29 | September 15, 2009 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 1.6 | Donut | 4 | 2.6.29 | 2009年9月15日 |'
- en: '| 2.0, 2.1 | Eclair | 5, 6, 7 | 2.6.29 | October 26, 2009 |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 2.0, 2.1 | Eclair | 5, 6, 7 | 2.6.29 | 2009年10月26日 |'
- en: '| 2.2 | Froyo | 8 | 2.6.32 | May 20, 2010 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 2.2 | Froyo | 8 | 2.6.32 | 2010年5月20日 |'
- en: '| 2.3 | Gingerbread | 9, 10 | 2.6.35 | December 6, 2010 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 2.3 | Gingerbread | 9, 10 | 2.6.35 | 2010年12月6日 |'
- en: '| 3.0, 3.1, 3.2 | Honeycomb | 11, 12, 13 | 2.6.36 | February 22, 2011 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 3.0, 3.1, 3.2 | Honeycomb | 11, 12, 13 | 2.6.36 | 2011年2月22日 |'
- en: '| 4.0 | Ice Cream Sandwich | 14, 15 | 3.0.1 | October 18, 2011 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | Ice Cream Sandwich | 14, 15 | 3.0.1 | 2011年10月18日 |'
- en: '| 4.1, 4.2, 4.3 | Jelly Bean | 16, 17, 18 | 3.0.31, 3.0.21, 3.4.0 | July 9,
    2012 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 4.1, 4.2, 4.3 | Jelly Bean | 16, 17, 18 | 3.0.31, 3.0.21, 3.4.0 | 2012年7月9日
    |'
- en: '| 4.4 | KitKat | 19, 20 | 3.10 | October 31, 2013 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 4.4 | KitKat | 19, 20 | 3.10 | 2013年10月31日 |'
- en: '| 5.0, 5.1 | Lollipop | 21, 22 | 3.16.1 | November 12, 2014 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 5.0, 5.1 | Lollipop | 21, 22 | 3.16.1 | 2014年11月12日 |'
- en: '| 6.0 | Marshmallow | 23 | 3.18.10 | October 5, 2015 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | Marshmallow | 23 | 3.18.10 | 2015年10月5日 |'
- en: '| 7.0, 7.1 | Nougat | 24, 25 | 4.4.1 | August 22, 2016 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 7.0, 7.1 | Nougat | 24, 25 | 4.4.1 | 2016年8月22日 |'
- en: '| 8.0 | Android O | 26 | TBA | TBA |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 8.0 | Android O | 26 | 待定 | 待定 |'
- en: From a developer point of view, Android provides a rich application framework,
    which allows to build apps for mobile devices. Android apps are written in the
    Java programming language. The Android **Software Development Kit** (**SDK**)
    compile out Java code along with any data and resource files into an `.apk` (Android
    package) file, which contains can be installed in Android-powered devices, such
    as smartphones, tablets, smart TVs, or smartwatches.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，Android提供了丰富的应用程序框架，可以为移动设备构建应用程序。Android应用程序是用Java编程语言编写的。Android
    **软件开发工具包**（**SDK**）将Java代码与任何数据和资源文件编译成一个`.apk`（Android包）文件，该文件可以安装在Android设备上，如智能手机、平板电脑、智能电视或智能手表。
- en: For complete information about Android development, visit [https://developer.android.com/](https://developer.android.com/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Android开发的完整信息，请访问[https://developer.android.com/](https://developer.android.com/)。
- en: 'Android Studio is the official IDE for Android development. It is built based
    on IntelliJ IDEA. In Android Studio, the build process of Android projects is
    managed by the Gradle build system. During the Android Studio installation, two
    additional tools can be also installed:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是Android开发的官方IDE。它是基于IntelliJ IDEA构建的。在Android Studio中，Android项目的构建过程由Gradle构建系统管理。在安装Android
    Studio时，还可以安装两个附加工具：
- en: '**Android SDK**: This contains all of the packages and tools required to develop
    Android apps. The SDK Manager allows to download and install SDK for different
    versions (see the preceding table).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android SDK**：其中包含开发Android应用程序所需的所有软件包和工具。SDK管理器允许下载和安装不同版本的SDK（请参见上表）。'
- en: '**Android Virtual Device** (**AVD**): This is an emulator that allows us to
    model an actual device. The AVD Manager allows to download and install different
    emulated Android virtual devices grouped into four categories: phones, tables,
    TV, and wears.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android虚拟设备**（**AVD**）：这是一个允许我们模拟实际设备的仿真器。AVD管理器允许下载和安装不同的仿真Android虚拟设备，分为四类：手机、平板电脑、电视和手表。'
- en: Gradle plugin for JUnit 5 in Android projects
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android项目中的JUnit 5的Gradle插件
- en: 'At the time of this writing, there is no official support for JUnit 5 in Android
    projects. To solve this problem, an open source Gradle plugin named `android-junit5`
    has been created ([https://github.com/aurae/android-junit5](https://github.com/aurae/android-junit5)).
    To use this plugin, first we need to specify the proper dependency in our `build.gradle`
    file:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Android项目中尚无对JUnit 5的官方支持。为解决这个问题，创建了一个名为`android-junit5`的开源Gradle插件（[https://github.com/aurae/android-junit5](https://github.com/aurae/android-junit5)）。要在项目中使用此插件，首先需要在我们的`build.gradle`文件中指定适当的依赖项：
- en: '[PRE46]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In order to use this plugin in our project, we need to extend our project capabilities
    using the clause `apply plugin` in our `build.gradle` file:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的项目中使用此插件，我们需要在我们的`build.gradle`文件中使用`apply plugin`子句扩展我们的项目功能：
- en: '[PRE47]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `android-junit5` plugin configures the `junitPlatform` task, attaching
    automatically attaches both the Jupiter and Vintage engines during the test execution
    phase. As an example, consider the following project example, as usual hosted
    on GitHub ([https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android)).
    The following is a screenshot of this project imported in Android Studio:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`android-junit5`插件配置了`junitPlatform`任务，在测试执行阶段自动附加了Jupiter和Vintage引擎。例如，考虑以下项目示例，通常托管在GitHub上（[https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android)）。以下是Android
    Studio中导入此项目的屏幕截图：'
- en: '![](img/00129.jpeg)Android project compatible with JUnit 5 on IntelliJ'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00129.jpeg)在IntelliJ上兼容JUnit 5的Android项目'
- en: 'Now, we are going to create an Android JUnit run configuration of Android Studio.
    As can be seen in the screenshot, we use the option `All in package` referred
    to the package containing the tests (`io.github.bonigarcia.myapplication` in this
    example):'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在Android Studio中创建一个Android JUnit运行配置。如屏幕截图所示，我们使用`All in package`选项来引用包含测试的包（在本例中为`io.github.bonigarcia.myapplication`）：
- en: '![](img/00130.jpeg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: Android JUnit run configuration
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Android JUnit运行配置
- en: 'If we launch the aforementioned run configuration, all the tests of the project
    will be executed. These tests can use the JUnit 4 programming model (Vintage)
    and even the JUnit 5 (Jupiter) in a seamless way:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动上述的运行配置，项目中的所有测试都将被执行。这些测试可以无缝地使用JUnit 4编程模型（Vintage）甚至JUnit 5（Jupiter）：
- en: '![](img/00131.jpeg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.jpeg)'
- en: Execution on Jupiter and Vintage tests within an Android project in IntelliJ
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ中的Android项目中执行Jupiter和Vintage测试
- en: REST
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: Roy Fielding is an American computer scientist born in 1965\. He is one of the
    authors of the HTTP protocol and the co-authors of the Apache Web server. In the
    year 2000, Fielding coined the term REST (short for REpresentational State Transfer)
    in his doctoral dissertation entitled *Architectural Styles and the Design of
    Network-based Software Architecture.* REST is an architectural style for designing
    distributed systems. It’s not a standard, but rather a set of constraints. REST
    is commonly used in conjunction with HTTP. On the one hand, the implementations
    which follows the strict principles of REST are often referred as RESTful. On
    the other hand, those which follow a loose adherence of such principles are called
    RESTlike.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding是一位1965年出生的美国计算机科学家。他是HTTP协议的作者之一，也是Apache Web服务器的合著者。在2000年，Fielding在他的博士论文《Architectural
    Styles and the Design of Network-based Software Architecture》中创造了REST（REpresentational
    State Transfer）一词。REST是一种用于设计分布式系统的架构风格。它不是一个标准，而是一组约束。REST通常与HTTP一起使用。一方面，严格遵循REST原则的实现通常被称为RESTful。另一方面，那些遵循这些原则的宽松实现被称为RESTlike。
- en: REST in a nutshell
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST简介
- en: REST follows a client-server architecture. The server is in charge of handling
    a set of services, listening for requests made by clients. The communication between
    client and server must be stateless, meaning that server do not store any record
    from the clients and therefore each request done from the client must contain
    all the information required for the server to process it separately.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: REST遵循客户端-服务器架构。服务器负责处理一组服务，监听客户端发出的请求。客户端和服务器之间的通信必须是无状态的，这意味着服务器不会存储来自客户端的任何记录，因此客户端发出的每个请求都必须包含服务器处理所需的所有信息。
- en: The building blocks of REST architectures are named resources. Resources define
    the type of information that is going to be transferred. Resources should be identified
    in a unique way. In HTTP, the way to access the resource it to provide its full
    URL, also known as API endpoint. Each resource has a representation, which is
    a machine-readable explanation of the current state of a resource. Nowadays, representations
    are usually with JSON, but it can be done in other formats such as XML or YAML.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: REST架构的构建块被称为资源。资源定义了将要传输的信息的类型。资源应该以唯一的方式进行标识。在HTTP中，访问资源的方式是提供其完整的URL，也称为API端点。每个资源都有一个表示，这是资源当前状态的机器可读解释。如今，表示通常使用JSON，但也可以使用其他格式，如XML或YAML。
- en: 'Once we identified the resources and the representation format, we need to
    specify what can be done with them, that is, the actions. Actions could potentially
    be anything, although there is a set of common actions that any resource-oriented
    system should provide: CRUD (create, retrieve, update, and delete) actions. REST
    actions can be mapped to the HTTP methods (so-called verbs), as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了资源和表示格式，我们需要指定可以对它们进行的操作，也就是动作。动作可能是任何东西，尽管有一组任何面向资源的系统都应该提供的常见动作：CRUD（创建、检索、更新和删除）动作。REST动作可以映射到HTTP方法（所谓的动词），如下所示：
- en: '`GET`: Reads a resource.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：读取资源。'
- en: '`POST`: Sends a new resource to the server.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：向服务器发送新资源。'
- en: '`PUT`: Updates a given resource.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新给定资源。'
- en: '`DELETE`: Deletes a resource.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除资源。'
- en: '`PATCH`: update partially a resource.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：部分更新资源。'
- en: '`HEAD`: Asks if a given resource exists without returning any of its representations.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：询问给定资源是否存在，而不返回任何表示。'
- en: '`OPTIONS`: Retrieves a list of available verbs on a given resource.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：检索给定资源上可用动词的列表。'
- en: In REST, it is important the notion of *idempotency*. For example, `GET`, `DELETE`,
    or `PUT` are said to be idempotent, since the effect of these requests should
    be the same whether the command is sent one or several times. On the other hand,
    `POST` is not idempotent, since it creates a different resource each time it is
    requested.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，*幂等性*的概念很重要。例如，`GET`、`DELETE`或`PUT`被认为是幂等的，因为这些请求的效果无论发送一次还是多次都应该是相同的。另一方面，`POST`不是幂等的，因为每次请求都会创建一个不同的资源。
- en: 'REST, when based on HTTP can benefit on standard HTTP status codes. A status
    code is a number that summarizes the response associated to it. The typical HTTP
    status code reused in REST are:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: REST，基于HTTP时可以受益于标准的HTTP状态码。在REST中经常重用的典型HTTP状态码有：
- en: '`200 OK`: The request went fine and the content requested was returned. Normally
    used on GET requests.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`：请求成功，返回了请求的内容。通常用于GET请求。'
- en: '`201 Created`: The resource was created. Useful on responses to POST or PUT
    requests.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 Created`：资源已创建。在响应POST或PUT请求时很有用。'
- en: '`204 No content`: The action was successful, but there is no content returned.
    Useful for actions that do not require a response body, such as a DELETE.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204 No content`：操作成功，但没有返回内容。对于不需要响应主体的操作（例如DELETE）很有用。'
- en: '`301 Moved permanently`: This resource was moved to another location and the
    location is returned.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301 Moved permanently`：此资源已移至另一个位置，并返回该位置。'
- en: '`400 Bad request`: The request issued has problems (for example, lacking some
    required parameters).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 Bad request`：发出的请求有问题（例如，缺少一些必需的参数）。'
- en: '`401 Unauthorized`: Useful for authentication when the requested resource is
    not accessible to the user owning the request.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 Unauthorized`：在请求的资源对用户不可访问时进行身份验证时很有用。'
- en: '`403 Forbidden`: The resource is not accessible, but unlike 401, authentication
    will not affect the response.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 Forbidden`：资源不可访问，但与401不同，身份验证不会影响响应。'
- en: '`404 Not found`: The URL provided does not identify any resource.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 Not found`：提供的URL未标识任何资源。'
- en: 405 Method not allowed. The HTTP verb used on a resource is not allowed. (for
    example, a PUT on a read-only resource).
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 405 Method not allowed. 对资源使用的HTTP动词不允许。（例如，对只读资源进行PUT操作）。
- en: '`500 Internal server error`: A generic error code when an unexpected condition
    in the server side.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 Internal server error`：服务器端发生意外情况时的通用错误代码。'
- en: 'The following picture shows an example of client-server interaction with REST.
    The body of the HTTP messages uses JSON both for requests and responses:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了REST的客户端-服务器交互示例。HTTP消息的主体在请求和响应中都使用JSON：
- en: '![](img/00132.jpeg)REST sequence diagram example'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00132.jpeg)REST序列图示例'
- en: Using REST test libraries with Jupiter
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jupiter的REST测试库
- en: REST APIs are becoming more and more pervasive nowadays. For that reason, a
    proper strategy for assessing REST services is desirable. In this section, we
    are going to learn how to use several test libraries in our JUnit 5 tests.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: REST API如今变得越来越普遍。因此，对REST服务进行评估的适当策略是可取的。在本节中，我们将学习如何在我们的JUnit 5测试中使用多个测试库。
- en: 'First of all, we can use the open source library REST Assured ([http://rest-assured.io/](http://rest-assured.io/)).
    REST Assured allows the validation of REST services by means of a fluent API inspired
    in dynamic languages such as Ruby or Groovy. To use REST Assured in our test project,
    we simply need to add the proper dependency in Maven:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用开源库REST Assured（[http://rest-assured.io/](http://rest-assured.io/)）。REST
    Assured允许通过受Ruby或Groovy等动态语言启发的流畅API验证REST服务。要在我们的测试项目中使用REST Assured，我们只需要在Maven中添加适当的依赖项：
- en: '[PRE48]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'or in Gradle:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Gradle中：
- en: '[PRE49]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, we can use the REST Assured API. The following class contains two
    test examples. First sends a request to the free online REST service [http://echo.jsontest.com/](http://echo.jsontest.com/).
    Then verifies if the response code and the body content are as expected. The second
    test consumes another free online REST service ([http://services.groupkt.com/](http://services.groupkt.com/))
    and also verifies the response:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用REST Assured API。以下类包含两个测试示例。首先向免费在线REST服务[http://echo.jsontest.com/](http://echo.jsontest.com/)发送请求。然后验证响应代码和主体内容是否符合预期。第二个测试使用另一个免费在线REST服务（[http://services.groupkt.com/](http://services.groupkt.com/)），并验证响应：
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running this test in console with Maven, we can check that both tests succeed:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中使用Maven运行此测试，我们可以检查两个测试都成功：
- en: '![](img/00133.gif)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.gif)'
- en: Execution of test using REST Assured
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST Assured执行测试
- en: In the second example, we are going to study, in addition to the test, we are
    also going to implement the server side, that is, the REST service implementation.
    To that aim, we are going to use Spring MVC and Spring Boot, previously introduced
    on this chapter (see section *Spring*).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，除了测试，我们还将实现服务器端，即REST服务实现。为此，我们将使用在本章中介绍的Spring MVC和Spring Boot（请参见*Spring*部分）。
- en: 'The implementation of REST services in Spring is quite straightforward. First,
    we simply need to annotate a Java class with `@RestController`. In the body of
    this class, we need to add methods annotated with `@RequestMapping`. These methods
    will listen to the different URLs (endpoints) implemented in our REST API. The
    accepted elements for the `@RequestMapping` are:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中实现REST服务非常简单。首先，我们只需要使用`@RestController`注解一个Java类。在这个类的主体中，我们需要添加使用`@RequestMapping`注解的方法。这些方法将监听我们的REST
    API中实现的不同URL（端点）。`@RequestMapping`的可接受元素有：
- en: '`value`: This is the path mapping URL.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：这是路径映射URL。'
- en: '`method`: This finds the HTTP request methods to map to.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：找到要映射到的HTTP请求方法。'
- en: '`params`: This finds parameters of the mapped request, narrowing the primary
    mapping.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：找到映射请求的参数，缩小主要映射。'
- en: '`headers`: his finds the headers of the mapped request.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：找到映射请求的标头。'
- en: '`consumes`: This finds consumable media types of the mapped request.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consumes`：找到映射请求的可消耗媒体类型。'
- en: '`produces`: This finds producible media types of the mapped request.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces`：找到映射请求的可生产媒体类型。'
- en: 'As can be seen inspecting the code of the following class, our service example
    implements three different operations: `GET /books` (to read all book in the system),
    `GET /book/{index}` (to read a book given its identifier), and `POST /book` (to
    create a book).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如下类的代码所示，我们的服务示例实现了三种不同的操作：`GET /books`（读取系统中的所有书籍），`GET /book/{index}`（根据其标识符读取书籍），以及`POST
    /book`（创建书籍）。
- en: '[PRE51]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we are implementing a Jupiter test for Spring, we need to use the `SpringExtension`
    and also the `SpringBootTest` annotation. As a novelty, we are going to inject
    a test component provided by `spring-test`, named `TestRestTemplate`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在为Spring实现Jupiter测试，我们需要使用`SpringExtension`和`SpringBootTest`注解。作为新功能，我们将注入`spring-test`提供的测试组件，名为`TestRestTemplate`。
- en: This component is a wrapper of the standard Spring's `RestTemplate` object,
    which allows to implement REST clients in a seamless way. In our test, it requests
    to our service (which is started before executing the tests), and responses are
    used to verify the outcome.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件是标准Spring的`RestTemplate`对象的包装器，可以无缝地实现REST客户端。在我们的测试中，它请求我们的服务（在执行测试之前启动），并使用响应来验证结果。
- en: Notice that the object `MockMvc` (explained in the section *Spring*) could be
    also used to test REST services. The difference with respect to `TestRestTemplate`
    is that the former is used to test from the client-side (that is, response code,
    body, content type, and so on), while the the latter is used to test the service
    from the server side. For instance, in the example here, the responses to the
    service calls (`getForEntity` and `postForEntity`) are Java objects, whose scope
    is only the server side (in the client side, this information is serialized as
    JSON).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象`MockMvc`（在*Spring*部分中解释）也可以用于测试REST服务。与`TestRestTemplate`相比，前者用于从客户端测试（即响应代码、主体、内容类型等），而后者用于从服务器端测试服务。例如，在这个例子中，对服务调用（`getForEntity`和`postForEntity`）的响应是Java对象，其范围仅限于服务器端（在客户端，此信息被序列化为JSON）。
- en: '[PRE52]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As shown in the screenshot below, our Spring application is started before
    running our tests, which are executed successfully:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的截图所示，我们的Spring应用在运行测试之前启动，测试成功执行：
- en: '![](img/00134.gif)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.gif)'
- en: Output of Jupiter test using TestRestTemplate to verify a REST service.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TestRestTemplate输出Jupiter测试的结果以验证REST服务。
- en: To conclude this section, we see an example in which the library WireMock ([http://wiremock.org/](http://wiremock.org/))
    is used. This library allows to mock REST services, that is, a so-called HTTP
    *mock server*. This mock server captures incoming requests to the service, providing
    stubbed responses. This capability is very useful to test a system which consumes
    a REST service, but the service is not available during the tests (or we can test
    the component that calls the service in isolation).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到一个示例，其中使用了WireMock库（[http://wiremock.org/](http://wiremock.org/)）。这个库允许模拟REST服务，即所谓的HTTP
    *模拟服务器*。这个模拟服务器捕获对服务的传入请求，并提供存根化的响应。这种能力对于测试一个消费REST服务的系统非常有用，但在测试期间服务不可用（或者我们可以测试调用服务的组件）。
- en: 'As usual, we see an example to demonstrate its usage. Let''s suppose we have
    a system which consumes a remote REST service. To implement a client for that
    service we use Retrofit 2 ([http://square.github.io/retrofit/](http://square.github.io/retrofit/)),
    which is a highly configurable HTTP client for Java. We define the interface to
    consume this service as illustrated in the class below. Notice that the service
    exposes three endpoints aimed to read a remote file (open file, read stream, and
    close stream):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们看到一个示例来演示其用法。假设我们有一个系统，它消费远程REST服务。为了实现该服务的客户端，我们使用Retrofit 2（[http://square.github.io/retrofit/](http://square.github.io/retrofit/)），这是一个高度可配置的Java
    HTTP客户端。我们定义了用于消费此服务的接口，如下面的类所示。请注意，该服务公开了三个端点，旨在读取远程文件（打开文件、读取流和关闭流）：
- en: '[PRE53]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we implement the class which consumes the REST service. In this example,
    it is a simple Java class which connects to the remote service given its URL passed
    as constructor parameter:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现了消费REST服务的类。在这个例子中，它是一个简单的Java类，根据构造函数参数传递的URL连接到远程服务：
- en: '[PRE54]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Finally, we implement a JUnit 5 test to verify our service. Notce that we are
    creating the mock server (`**new** WireMockServer`) and stubbing the REST service
    calls using the static methods `stubFor(...)` provided by WireMock in the setup
    of the test (`@BeforeEach`). Since in this case, the SUT is very simple and it
    has no DOCs, we directly instantiate the class `RemoteFileService` also in the
    setup of each test, using the mock server URL as constructor argument. Finally,
    we test our service (which uses the mock server) simply exercising the object
    called `wireMockServer`, in this example, by calling to the method `getFile` and
    assessing its output.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个JUnit 5测试来验证我们的服务。请注意，我们正在创建模拟服务器（`**new** WireMockServer`）并在测试的设置中使用WireMock提供的`stubFor(...)`静态方法来存根REST服务调用（`@BeforeEach`）。由于在这种情况下，SUT非常简单且没有文档，我们直接在每个测试的设置中实例化`RemoteFileService`类，使用模拟服务器URL作为构造函数参数。最后，我们测试我们的服务（使用模拟服务器）简单地执行名为`wireMockServer`的对象，例如通过调用`getFile`方法并评估其输出。
- en: '[PRE55]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Executing the test in the console, in the traces we can see how the internal
    HTTP server controlled by WireMock is started before the test execution. Then,
    the three REST operations (open stream, read bytes, close stream) are executed
    by the test, and finally the mock server is disposed:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中执行测试时，我们可以看到内部HTTP服务器由WireMock控制在测试执行之前启动。然后，测试执行了三个REST操作（打开流、读取字节、关闭流），最后处理了模拟服务器：
- en: '![](img/00135.gif)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.gif)'
- en: Execution of test using a mock REST server using WireMock
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WireMock执行模拟REST服务器的测试
- en: Summary
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This section provides a detailed insight of how JUnit 5 can be used in conjunction
    with third-party frameworks, libraries, and platforms. Thanks to the Jupiter extension
    model, developers can create extensions which allows seamless integration with
    external frameworks to JUnit 5\. First, we have seen the *MockitoExtension*, an
    extension provided by the JUnit 5 team to use Mockito (a notorious mock framework
    for Java) in Jupiter tests. Then, we have used the *SpringExtension*, which is
    the official extension provided in the version 5 of the Spring Framework. This
    extension integrates Spring into the JUnit 5 programming model. This way, we are
    able to use Spring’s application contexts (that is, the Spring’s DI container)
    in our tests.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了如何将JUnit 5与第三方框架、库和平台结合使用。由于Jupiter扩展模型，开发人员可以创建扩展，实现与外部框架对JUnit 5的无缝集成。首先，我们看到了*MockitoExtension*，这是JUnit
    5团队提供的一个扩展，用于在Jupiter测试中使用Mockito（Java中臭名昭著的模拟框架）。然后，我们使用了*SpringExtension*，这是Spring
    Framework 5版本中提供的官方扩展。该扩展将Spring集成到JUnit 5编程模型中，使我们能够在测试中使用Spring的应用程序上下文（即Spring的DI容器）。
- en: We have also reviewed the *SeleniumExtension* implemented by *selenium-jupiter,*
    an open source project providing a JUnit 5 extension for Selenium WebDriver (testing
    framework for web applications). Thank to thins extension, we can use different
    browsers to interact automatically with web applications and emulated mobile devices
    (using Appium). Then, we have seen the *CucumberExtension,* allows to specify
    JUnit 5 acceptance tests following a BDD style using the Gherkin language. Finally,
    we have seen how the open source JUnit5-Docker extension can be used to start
    Docker containers (downloading the image from Docker Hub) before the execution
    of our JUnit 5 tests.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还审查了由*selenium-jupiter*实施的*SeleniumExtension*，这是一个为Selenium WebDriver（用于Web应用程序的测试框架）提供JUnit
    5扩展的开源项目。借助这个扩展，我们可以使用不同的浏览器自动与Web应用程序和模拟的移动设备（使用Appium）进行交互。然后，我们看到了*CucumberExtension*，它允许使用Gherkin语言指定JUnit
    5验收测试，遵循BDD风格。最后，我们看到了如何使用开源的JUnit5-Docker扩展在执行JUnit 5测试之前启动Docker容器（从Docker Hub下载镜像）。
- en: 'Moreover, we discovered that the extension model is not the only way of interacting
    with external technologies by JUnit tests. For example, in order to run Jupiter
    tests in an Android project, we can use the `android-junit5` plugin. On the other
    hand, even though there is no custom extension for assessing REST services using
    JUnit 5, the integration with such libraries is strait forward: we simply need
    to include the proper dependency in our project and use it in our tests (for example,
    REST Assured, Spring, or WireMock).'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们发现扩展模型并不是与JUnit测试交互的唯一方式。例如，为了在Android项目中运行Jupiter测试，我们可以使用`android-junit5`插件。另一方面，即使没有专门用于使用JUnit
    5评估REST服务的自定义扩展，与这些库的集成也是直截了当的：我们只需在项目中包含适当的依赖项，并在测试中使用它（例如，REST Assured、Spring或WireMock）。
