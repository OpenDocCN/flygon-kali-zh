- en: Platform Deployment – AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台部署 - AWS
- en: In this chapter, we will cover some of the deployment options available in the
    Amazon AWS platform. The AWS platform is one of the oldest and most mature of
    the cloud service providers. It was introduced in 2002 and has been a leader in
    the space since then. AWS has also been constantly innovating and has introduced
    several new services that have found wide adoption among a broad variety of customers,
    from single person start-ups to enterprises.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍亚马逊AWS平台提供的一些部署选项。 AWS平台是云服务提供商中最古老和最成熟的之一。它于2002年推出，并自那时以来一直是该领域的领导者。
    AWS还不断创新，并推出了几项新服务，这些服务在广泛的客户群中得到了广泛的采用，从单人创业公司到企业。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The AWS platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS平台
- en: AWS platform deployment options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS平台部署选项
- en: AWS platform
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS平台
- en: 'Amazon AWS was the pioneer of cloud computing, and has been expanding its cloud
    offerings ever since to maintain its leadership position. The following diagram
    gives an indicative list of services offered by the AWS platform for application
    developers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊AWS是云计算的先驱，并自那时起一直在扩展其云服务，以保持其领先地位。以下图表提供了AWS平台为应用程序开发人员提供的服务的指示性列表：
- en: '![](img/efc34941-6e16-428a-a07d-c08cdc5dc74e.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efc34941-6e16-428a-a07d-c08cdc5dc74e.jpg)'
- en: This is just an indicative list and by no means an exhaustive list; refer to
    the Amazon AWS portal for a complete list.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个指示性列表，绝不是详尽的列表；请参阅亚马逊AWS门户网站获取完整列表。
- en: 'The categories are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类别如下：
- en: '**Infrastructure**: This is probably the core of the AWS platform that enables
    it to provide a plethora of other services. These can be further classified into:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施：这可能是AWS平台的核心，使其能够提供大量其他服务。这些可以进一步分类为：
- en: '**Compute**: Services such as EC2, Lambda, ECS, and ELB. We will be demonstrating
    the deployment of our sample application using primarily compute services, but
    it is relatively easy to tie them up with the other services offered by AWS.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算：诸如EC2，Lambda，ECS和ELB之类的服务。我们将演示使用主要计算服务部署我们的示例应用程序，但是将它们与AWS提供的其他服务相结合相对容易。
- en: '**Storage**: Services such as S3, EBS, and CloudFront.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：诸如S3，EBS和CloudFront之类的服务。
- en: '**Networking**: Services such as VPC, Route53, and DirectConnect.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络：诸如VPC，Route53和DirectConnect之类的服务。
- en: '**Application**: These services can be used as components to build and support
    applications.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：这些服务可用作构建和支持应用程序的组件。
- en: '**Database**: These services target databases, providing access to different
    **relational database management system** (**RDBMS**) and NoSQL data stores.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：这些服务针对数据库，提供对不同的关系数据库管理系统（RDBMS）和NoSQL数据存储的访问。
- en: '**DevOps**: These services provide the ability to construct build pipelines
    and enable continuous delivery. These include source code hosting, continuous
    integration tools, and cloud and software provisioning tools.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps：这些服务提供了构建流水线和启用持续交付的能力。这些包括源代码托管，持续集成工具以及云和软件供应工具。
- en: '**Security**: These services provide **role-based access control** (**RBAC**)
    to the various services offered by AWS, and provide a mechanism to specify quotas
    and enforce them, key management, and secret storage.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：这些服务为AWS提供了基于角色的访问控制（RBAC），并提供了一种机制来指定配额并强制执行它们，密钥管理和秘密存储。
- en: '**Mobile**: These services are targeted at providing backends for mobile applications
    and services such as notification.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动：这些服务旨在为移动应用程序和通知等服务提供后端。
- en: '**Analytics**: These services include batch systems such as MapReduce, and
    stream processing systems such as Spark are available for building analytics platforms.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析：这些服务包括MapReduce等批处理系统，以及Spark等流处理系统，可用于构建分析平台。
- en: AWS platform deployment options
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS平台部署选项
- en: 'Of the various services offered by the AWS platform, we will be focusing this
    chapter on covering some deployment options specifically targeted for the kind
    of web APIs that we have been using as an example. We will therefore cover the
    deployment into:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS平台提供的各种服务中，我们将重点关注本章涵盖的一些部署选项，这些选项专门针对我们一直作为示例使用的Web API类型。因此，我们将介绍部署到以下内容：
- en: AWS Elastic Beanstalk
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk
- en: AWS Elastic Container Service
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS弹性容器服务
- en: AWS Lambda
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: 'Since we will be running our application in the cloud environment, where we
    will not be required to manage the infrastructure directly, that is, we will not
    be launching virtual machines and installing the application within them, we will
    not require service discovery, as elastic load balancers will automatically route
    to all the instances of the application that are up. So, we will use a version
    of the `product` API that does not use the Eureka discovery client:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在云环境中运行应用程序，因此我们将不需要直接管理基础设施，也就是说，我们将不会启动虚拟机并在其中安装应用程序，因此我们将不需要服务发现，因为弹性负载均衡器将自动路由到所有正在运行的应用程序实例。因此，我们将使用不使用Eureka发现客户端的“产品”API的版本：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Deploying Spring Boot API to Beanstalk
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Spring Boot API部署到Beanstalk
- en: '**AWS Elastic Beanstalk** (**AEB**) is a service offered by AWS to host web
    applications on AWS without having to provision or manage the IaaS layer directly.
    AEB supports popular languages such as Java, .NET, Python, Ruby, Go, and PHP.
    Recently, it has also offered support for running Docker containers. We will take
    a simplified version of the `product` service that we have built so far in our
    journey, and deploy it in AEB as a runnable JAR and also as a Docker container.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk（AEB）是AWS提供的一项服务，可在AWS上托管Web应用程序，而无需直接提供或管理IaaS层。 AEB支持流行的语言，如Java，.NET，Python，Ruby，Go和PHP。最近，它还提供了运行Docker容器的支持。我们将采用我们迄今为止在旅程中构建的“产品”服务的简化版本，并将其部署在AEB中作为可运行的JAR文件，也作为Docker容器。
- en: Deploying a runnable JAR
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署可运行的JAR
- en: 'Log in to the AWS console, select the Elastic Beanstalk service under the Compute
    category, and click on the Get started button:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到AWS控制台，选择计算类别下的弹性Beanstalk服务，并点击“开始”按钮：
- en: '![](img/b572ac6b-6c97-4e58-a2b2-88e582e21ae1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b572ac6b-6c97-4e58-a2b2-88e582e21ae1.png)'
- en: 'Fill in the application details in the next screen:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕中填写应用程序详细信息：
- en: '![](img/560dd240-24b2-400f-a8a6-c83ad680c952.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560dd240-24b2-400f-a8a6-c83ad680c952.png)'
- en: 'Upload the `product.jar` from the `target` folder and click on the Configure
    more options button. You will be presented with the different categories which
    you can configure by selecting Software, and under that, in the Environment properties,
    add a new environment variable called `SERVER_PORT` and set the value to `5000`.
    This is necessary, because by default the NGINX server that is created by the
    AEB environment will proxy all requests to this port, and by setting the variable
    we are making sure that our Spring Boot application will run on port `5000`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上传`target`文件夹中的`product.jar`，然后点击“配置更多选项”按钮。您将看到不同的类别，可以通过选择软件，在环境属性下，添加一个名为`SERVER_PORT`的新环境变量，并将值设置为`5000`。这是必要的，因为默认情况下，AEB环境创建的NGINX服务器将代理所有请求到这个端口，通过设置变量，我们确保我们的Spring
    Boot应用将在端口`5000`上运行：
- en: '![](img/39e95de8-1379-47e4-a8d0-2455339e0eb3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e95de8-1379-47e4-a8d0-2455339e0eb3.png)'
- en: 'Now, a new environment with our application running will be provisioned by
    AWS:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，AWS将提供一个新的环境，我们的应用程序将在其中运行：
- en: '![](img/c31356a5-b7c7-4e21-ab0d-4a3a5e0158a7.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c31356a5-b7c7-4e21-ab0d-4a3a5e0158a7.png)'
- en: 'Once the environment is provisioned, AEB will generate a URL for the application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 环境创建完成后，AEB将为应用程序生成一个URL：
- en: '![](img/1bebd5f7-5986-40b7-b578-f6fe06d55583.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bebd5f7-5986-40b7-b578-f6fe06d55583.png)'
- en: 'We can use this URL to access the API endpoint:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此URL访问API端点：
- en: '![](img/2451c2fd-4a87-4755-94d3-544a8d0996f4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2451c2fd-4a87-4755-94d3-544a8d0996f4.png)'
- en: Deploying Docker containers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Docker容器
- en: Now that we have learned how to deploy a runnable JAR to the Elastic Beanstalk
    service, let's also see a variation of the same where we will deploy a Docker
    container running the same application. The advantage offered by using a Docker
    container is that we can use languages and platforms not already supported by
    the AWS Elastic Beanstalk service and still deploy them in the cloud, reaping
    the benefits offered by the service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将可运行的JAR部署到弹性Beanstalk服务，让我们也看一下相同的变体，我们将部署运行相同应用程序的Docker容器。使用Docker容器的优势在于，我们可以使用AWS弹性Beanstalk服务尚未支持的语言和平台，并且仍然可以在云中部署它们，从而获得该服务提供的好处。
- en: For this deployment, we will be using the Docker registry available within the
    **Elastic Container Service** (**ECS**) offering to store the Docker container
    that we build from our application. We will cover how we can push our local Docker
    containers to the ECS repository, when we are deploying to ECS. For now, let's
    assume that the Docker container that we want to deploy is available in a repository
    called `<aws-account-id>.dkr.ecr.us-west-2.amazonaws.com/product-api`. Since we
    need to access this repository, we need to add the AmazonEC2ContainerRegistryReadOnly
    policy to the default Elastic Beanstalk role, aws-elasticbeanstalk-ec2-role.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此部署，我们将使用**弹性容器服务**（**ECS**）提供的Docker注册表来存储我们从应用程序构建的Docker容器。当我们部署到ECS时，我们将介绍如何将本地Docker容器推送到ECS存储库。现在，让我们假设我们要部署的Docker容器在名为`<aws-account-id>.dkr.ecr.us-west-2.amazonaws.com/product-api`的存储库中可用。由于我们需要访问此存储库，我们需要将AmazonEC2ContainerRegistryReadOnly策略添加到默认的弹性Beanstalk角色aws-elasticbeanstalk-ec2-role。
- en: 'This can be done from the IAM console under the Roles section:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在IAM控制台的角色部分完成：
- en: '![](img/df0c9e42-5a70-4c5d-815e-458437dfef96.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df0c9e42-5a70-4c5d-815e-458437dfef96.png)'
- en: 'Create a file called `Dockerfile.aws.json` with the following contents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile.aws.json`的文件，内容如下：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we are ready to deploy our Docker container. In the Elastic Beanstalk console,
    instead of choosing Java, we will choose a single Docker container and create
    a new application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备部署我们的Docker容器。在弹性Beanstalk控制台中，我们将选择单个Docker容器而不是Java，并创建一个新的应用程序：
- en: '![](img/8a07d769-e612-486c-8d5e-9d1619d4d81a.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a07d769-e612-486c-8d5e-9d1619d4d81a.png)'
- en: 'Select and upload the `Dockerfile.aws.json` to create the environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择并上传`Dockerfile.aws.json`以创建环境：
- en: '![](img/db25cea9-3dd0-4102-8643-40ef14503fe7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db25cea9-3dd0-4102-8643-40ef14503fe7.png)'
- en: 'We can test our API endpoints to verify if our Docker container is running
    correctly. We can also configure the container to use Amazon CloudWatch logging
    and monitoring to better monitor our application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试我们的API端点，以验证我们的Docker容器是否正常运行。我们还可以配置容器使用Amazon CloudWatch日志记录和监控，以更好地监视我们的应用程序：
- en: '![](img/72b589b2-40fd-439c-aaee-774137effd99.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72b589b2-40fd-439c-aaee-774137effd99.png)'
- en: Deploying Spring Boot App to the Elastic Container Service
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Spring Boot应用程序部署到弹性容器服务
- en: 'AWS **Elastic Container Service** (**ECS**) is a service that allows a user
    to deploy applications using a managed Docker instance. Here, the AWS ECS service
    is responsible for provisioning the virtual machine and the Docker installation.
    We can deploy our application by doing the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **弹性容器服务**（**ECS**）是一项允许用户使用托管的Docker实例部署应用程序的服务。在这里，AWS ECS服务负责提供虚拟机和Docker安装。我们可以通过以下步骤部署我们的应用程序：
- en: 'Start ECS, click on Continue:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动ECS，点击“继续”：
- en: '![](img/9c5dd2c2-6787-4539-91ca-bdb9b28e8b9f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c5dd2c2-6787-4539-91ca-bdb9b28e8b9f.png)'
- en: 'Create the ECS repository with name `product-api` and click on Next step:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`product-api`的ECS存储库，然后点击“下一步”：
- en: '![](img/2be15da6-f07b-4c03-9688-e1148fc1d326.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be15da6-f07b-4c03-9688-e1148fc1d326.png)'
- en: 'Build and push a Docker container to the repository, following the instructions
    given on the screen:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并推送Docker容器到存储库，按照屏幕上给出的说明进行：
- en: '![](img/a35fb748-ff23-4d25-b394-590ea2f14536.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a35fb748-ff23-4d25-b394-590ea2f14536.png)'
- en: 'The Docker login command generated by the GUI has an extra `http://` which
    should be excluded for:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GUI生成的Docker登录命令多了一个`http://`，应该去掉：
- en: '![](img/e843f488-de3c-4c27-9d49-c59bc9ad4c70.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e843f488-de3c-4c27-9d49-c59bc9ad4c70.png)'
- en: 'We can now build and push the Docker container to the created repository:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以构建并推送Docker容器到创建的存储库：
- en: '![](img/e8072215-a0ca-40b5-9e1c-8a015e9d383b.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8072215-a0ca-40b5-9e1c-8a015e9d383b.png)'
- en: 'We will use this container repository when configuring our task definition:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置任务定义时，我们将使用此容器存储库：
- en: '![](img/39e6452a-6c6f-485b-b71c-f4fb03a62bcd.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e6452a-6c6f-485b-b71c-f4fb03a62bcd.png)'
- en: 'In the advanced options, we can configure AWS CloudWatch logging to capture
    the logs from the Docker container, under the STORAGE AND LOGGING section:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高级选项中，我们可以配置AWS CloudWatch日志记录，以捕获来自Docker容器的日志，在存储和日志记录部分下：
- en: '![](img/7a1d2053-56e2-4371-8b5a-5100beb71a59.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a1d2053-56e2-4371-8b5a-5100beb71a59.png)'
- en: 'We need to create a corresponding log group in the CloudWatch console to capture
    the logs created from our application:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在CloudWatch控制台中创建相应的日志组，以捕获从我们的应用程序创建的日志：
- en: '![](img/302e0cad-c1ff-4f58-ad4b-e635e80d89a9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/302e0cad-c1ff-4f58-ad4b-e635e80d89a9.png)'
- en: We can create a service mapping to the port exposed from the container, which
    is `8080:`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个服务映射到容器中公开的端口，即`8080：`
- en: '![](img/16a2d1fc-b921-41d6-8b8f-e987a1201dff.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16a2d1fc-b921-41d6-8b8f-e987a1201dff.png)'
- en: 'Optionally, we can picture the EC2 instance type and configure a Key pair so
    that we will be able to log in to the EC2 instance that ECS will create for our
    application:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以描绘EC2实例类型并配置密钥对，以便我们能够登录到ECS将为我们的应用程序创建的EC2实例中：
- en: '![](img/b96f9480-7312-4b84-9a4d-79e12335d242.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b96f9480-7312-4b84-9a4d-79e12335d242.png)'
- en: 'Once we review the configurations and submit, ECS will begin creating the EC2
    instance and deploying our application into it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们审查配置并提交，ECS将开始创建EC2实例并将我们的应用程序部署到其中：
- en: '![](img/bd112413-b82d-47df-add8-b3c08c6bd29c.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd112413-b82d-47df-add8-b3c08c6bd29c.png)'
- en: 'We can click on Auto Scaling group and find the instance that was launched:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以点击自动扩展组并找到已启动的实例：
- en: '![](img/8be45561-dffd-4b6a-873e-e73cf39ff2cc.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8be45561-dffd-4b6a-873e-e73cf39ff2cc.png)'
- en: 'Find the instance:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到实例：
- en: '![](img/66100781-e44f-4520-b946-4bc202fc41fa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66100781-e44f-4520-b946-4bc202fc41fa.png)'
- en: 'Find the instance hostname:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到实例主机名：
- en: '![](img/eecd2566-2434-4c5a-ba2d-4e70088f4358.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eecd2566-2434-4c5a-ba2d-4e70088f4358.png)'
- en: 'Access the application through the instance hostname:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实例主机名访问应用程序：
- en: '![](img/d76205d8-b879-47e8-a636-a304f16d3050.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d76205d8-b879-47e8-a636-a304f16d3050.png)'
- en: 'But it is not feasible to access applications individually by their hostnames,
    so, instead, we will create an Elastic load balancer, which will route requests
    to the instances, thereby allowing us to have a stable endpoint while scaling
    up or down:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是逐个通过它们的主机名访问应用程序是不可行的，因此，我们将创建一个弹性负载均衡器，它将路由请求到实例，从而允许我们在扩展或缩减时拥有稳定的端点：
- en: 'We will go to the EC2 console and select Create under Application Load Balancer:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将转到EC2控制台，并在应用程序负载均衡器下选择创建：
- en: '![](img/93c7bf88-f0f4-4a01-a16e-54f6b6baa465.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93c7bf88-f0f4-4a01-a16e-54f6b6baa465.png)'
- en: 'Configure the Load Balancer Port:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置负载均衡器端口：
- en: '![](img/4a349305-fd46-46b9-b707-cd4ef596de84.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a349305-fd46-46b9-b707-cd4ef596de84.png)'
- en: 'Configure the Target group and the Health checks endpoint:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置目标组和健康检查端点：
- en: '![](img/570e525d-cd1c-419d-b3e0-19e5713b62ba.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/570e525d-cd1c-419d-b3e0-19e5713b62ba.png)'
- en: 'Register the target instances to the instance that was created by our cluster
    definition:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标实例注册到我们的集群定义创建的实例：
- en: '![](img/0dc9ccdb-c7b7-4bb6-8b7b-7cd70c4b5b05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc9ccdb-c7b7-4bb6-8b7b-7cd70c4b5b05.png)'
- en: 'Find the DNS record for the Load balancer:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到负载均衡器的DNS记录：
- en: '![](img/21b3b419-d99c-4c84-8884-989aa0532e6f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b3b419-d99c-4c84-8884-989aa0532e6f.png)'
- en: 'Connect to the load balancer endpoint and verify the application is working:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到负载均衡器端点并验证应用程序是否正常工作：
- en: '![](img/25bb98e1-320c-4504-953d-0bbc2c88468f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25bb98e1-320c-4504-953d-0bbc2c88468f.png)'
- en: Deploying to AWS Lambda
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到AWS Lambda
- en: 'The AWS Lambda service allows the deployment of simple functions to be invoked
    on event triggers. These event triggers can be classified into four types, namely:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda服务允许部署简单函数以在事件触发器上调用。这些事件触发器可以分为四种类型，即：
- en: Data Store (for example, AWS DyanmoDB)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储（例如，AWS DyanmoDB）
- en: Queues and Streams (for example, AWS Kinesis)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列和流（例如，AWS Kinesis）
- en: Blob Store (for example, AWS S3)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blob存储（例如，AWS S3）
- en: 'API Dateways:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API数据门户：
- en: '![](img/bc0e31ba-40c8-477a-a75a-ced5421df4fd.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc0e31ba-40c8-477a-a75a-ced5421df4fd.jpg)'
- en: The complete list of event sources supported by AWS Lamda can be found at [https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda.](https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lamda支持的事件源的完整列表可以在[https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda.](https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#api-gateway-with-lambda)找到
- en: Unlike the other deployment options discussed earlier, AWS Lambda provides the
    most transparent scaling option where the AWS platform scales the instances required,
    based on the demand. We are freed from configuring instances, load balancers,
    and so on, and instead can focus on the application logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的其他部署选项不同，AWS Lambda提供了最透明的扩展选项，AWS平台根据需求自动扩展所需的实例。我们无需配置实例、负载均衡器等，而是可以专注于应用程序逻辑。
- en: We will now build a simple AWS Lambda function and bind it to an API endpoint
    to invoke it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个简单的AWS Lambda函数，并将其绑定到API端点以调用它。
- en: 'We will begin by creating a new Spring Boot application with the following
    dependencies. We will also be using the `maven-shade-plugin` to create a runnable
    JAR:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的Spring Boot应用程序，具有以下依赖项。我们还将使用`maven-shade-plugin`创建可运行的JAR：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now create `HelloHandler.java` with the following contents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建`HelloHandler.java`，内容如下：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since lambda functions are simple functions, we can test them quite easily
    just by using the inputs and outputs of the functions. For example, a sample test
    case could be:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于lambda函数是简单的函数，我们可以通过使用函数的输入和输出很容易地测试它们。例如，一个示例测试用例可能是：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can build the lambda function using Maven:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Maven构建lambda函数：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now built the `hello-lambda.jar`, which we will upload to the AWS Lambda
    function that we will create from the AWS console.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了`hello-lambda.jar`，我们将上传到AWS控制台中创建的AWS Lambda函数。
- en: 'We will begin by going to the API Gateway console, which appears in the Network
    and Content Delivery category of the AWS console, and create a new API:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先转到API Gateway控制台，该控制台出现在AWS控制台的网络和内容交付类别中，并创建一个新的API：
- en: '![](img/334bc46e-e18e-404b-88d5-dc128fed3166.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/334bc46e-e18e-404b-88d5-dc128fed3166.png)'
- en: We will add a new resource called `hello` for the path `/hello:`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为路径`/hello`添加一个名为`hello`的新资源：
- en: '![](img/fa8a523f-d9d8-4c20-b099-165ea8f92079.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa8a523f-d9d8-4c20-b099-165ea8f92079.png)'
- en: 'We will also create a child resource with a path parameter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个带有路径参数的子资源：
- en: '![](img/f55c4fd3-9201-4afb-844b-5b0b314462ae.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f55c4fd3-9201-4afb-844b-5b0b314462ae.png)'
- en: 'Now, we will attach the HTTP `GET` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将附加HTTP `GET`方法：
- en: '![](img/8ceae71e-6427-4b32-8373-2ea5946d2b3a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ceae71e-6427-4b32-8373-2ea5946d2b3a.png)'
- en: 'Create a lambda function with the details shown as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下详细信息的Lambda函数：
- en: '![](img/fde71ba7-3782-4c20-b3e3-fc912d621c42.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fde71ba7-3782-4c20-b3e3-fc912d621c42.png)'
- en: 'Upload the runnable JAR and set the handler method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传可运行的JAR并设置处理程序方法：
- en: '![](img/36753b3c-d25b-4226-9c6d-54ecd4efa730.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36753b3c-d25b-4226-9c6d-54ecd4efa730.png)'
- en: 'Now add this lambda function to the API method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将此Lambda函数添加到API方法中：
- en: '![](img/8d953143-4597-431a-ad81-ade0d5a06fde.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d953143-4597-431a-ad81-ade0d5a06fde.png)'
- en: 'Make sure you select Use Lambda Proxy Integration so that we can use the specific
    `RequestHandler` interface, instead of using the generic `RequestStreamHandler`.
    This will also give API Gateway permission to the lambda function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择使用Lambda代理集成，以便我们可以使用特定的`RequestHandler`接口，而不是使用通用的`RequestStreamHandler`。这也将使API
    Gateway获得对Lambda函数的权限：
- en: '![](img/aba7b22e-dfa9-4368-b3bc-978479ca4ea9.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aba7b22e-dfa9-4368-b3bc-978479ca4ea9.png)'
- en: 'Complete the API definition with the lambda function invocation:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Lambda函数调用完成API定义：
- en: '![](img/a9a15393-71ec-4d46-a7e5-77d41ab348a6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9a15393-71ec-4d46-a7e5-77d41ab348a6.png)'
- en: 'We can test the API endpoint from the console:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从控制台测试API端点：
- en: '![](img/400e475d-1e2c-451a-8ff9-01a6f1ff1f2e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/400e475d-1e2c-451a-8ff9-01a6f1ff1f2e.png)'
- en: 'Now we can deploy the API:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以部署API：
- en: '![](img/d90a2915-d03f-4fa9-ad68-97edba4fa417.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d90a2915-d03f-4fa9-ad68-97edba4fa417.png)'
- en: 'Successful deployment of the API will result in the API endpoint:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功部署API将导致API端点：
- en: '![](img/439bb781-b264-4f30-9f52-5a81dff1e1aa.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/439bb781-b264-4f30-9f52-5a81dff1e1aa.png)'
- en: 'Now we can use this API endpoint, generated for this deployment environment,
    to access the application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用为此部署环境生成的API端点来访问应用程序：
- en: '![](img/c2afc5c0-6922-48c9-8f82-1cde13ab4ed5.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2afc5c0-6922-48c9-8f82-1cde13ab4ed5.png)'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered some options offered by the AWS platform, and how
    we can deploy our application from Elastic Beanstalk, which is for web applications.
    We deployed to ECS, which is for deploying containerized workloads and is not
    restricted to web application workloads. We then deployed an AWS Lambda function
    without any need for configuring the underlying hardware. We will look at deployment
    using Azure in the following chapter to see some of the services that it offers
    for deploying cloud-native applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了AWS平台提供的一些选项，以及我们如何可以从弹性Beanstalk部署我们的应用程序，这是针对Web应用程序的。我们部署到ECS，用于部署容器化工作负载，不限于Web应用程序工作负载。然后，我们部署了一个AWS
    Lambda函数，无需配置底层硬件。在接下来的章节中，我们将看一下使用Azure进行部署，以了解它为部署云原生应用程序提供的一些服务。
