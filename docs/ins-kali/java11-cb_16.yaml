- en: GUI Programming Using JavaFX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaFX进行GUI编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating a GUI using JavaFX controls
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaFX控件创建GUI
- en: Using FXML markup to create a GUI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FXML标记创建GUI
- en: Using CSS to style elements in JavaFX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS为JavaFX中的元素设置样式
- en: Creating a bar chart
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Creating a pie chart
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建饼图
- en: Embedding HTML in an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入HTML
- en: Embedding media in an application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入媒体
- en: Adding effects to controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向控件添加效果
- en: Using the Robot API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器人API
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'GUI programming has been in Java since JDK 1.0, via the API called the **Abstract
    Window Toolkit** (**AWT**). This was a remarkable thing during those times, but
    it had its own limitations, a few of which are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自JDK 1.0以来，Java一直有GUI编程，通过名为**抽象窗口工具包**（**AWT**）的API。在那个时代，这是一件了不起的事情，但它也有自己的局限性，其中一些如下：
- en: It had a limited set of components.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一组有限的组件。
- en: You couldn't create custom reusable components because AWT was using native
    components.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于AWT使用本机组件，因此无法创建自定义可重用组件。
- en: The look and feel of the components couldn't be controlled, and they took the
    look and feel of the host OS.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的外观和感觉无法控制，它们采用了主机操作系统的外观和感觉。
- en: 'Then, in Java 1.2, a new API for GUI development called **Swing** was introduced,
    which worked on the deficiencies of AWT by providing the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Java 1.2中，引入了一种名为**Swing**的新GUI开发API，它通过提供以下功能来解决AWT的不足：
- en: A richer components library.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更丰富的组件库。
- en: Support for creating custom components.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持创建自定义组件。
- en: A native look and feel, and support for plugging in a different look and feel.
    Some well-known Java looks and feel themes are Nimbus, Metal, Motif, and the system
    default.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地外观和感觉，以及支持插入不同的外观和感觉。一些著名的Java外观和感觉主题包括Nimbus、Metal、Motif和系统默认。
- en: A lot of desktop applications that make use of Swing have been built, and a
    lot of them are still being used. However, with time, technology has to evolve;
    otherwise, it will eventually be outdated and seldom used. In 2008, Adobe's **Flex**
    started gaining attention. It was a framework for building **Rich Internet applications**
    (**RIAs**). The desktop applications were always rich component-based UIs, but
    the web applications were not that amazing to use. Adobe introduced a framework
    called Flex, which enabled web developers to create rich, immersive UIs on the
    web. So the web applications were no longer boring.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 已经构建了许多使用Swing的桌面应用程序，其中许多仍在使用。然而，随着时间的推移，技术必须不断发展；否则，它最终将过时并且很少被使用。2008年，Adobe的**Flex**开始引起关注。这是一个用于构建**富互联网应用程序**（**RIA**）的框架。桌面应用程序一直是基于丰富组件的UI，但是Web应用程序并不那么令人惊叹。Adobe推出了一个名为Flex的框架，它使Web开发人员能够在Web上创建丰富、沉浸式的UI。因此，Web应用程序不再无聊。
- en: 'Adobe also introduced a rich internet application runtime environment for the
    desktop called **Adobe AIR**, which allowed the running of Flex applications on
    the desktop. This was a major blow to the age-old Swing API. But let''s go back
    to the market: In 2009, Sun Microsystems introduced something called **JavaFX**.
    This framework was inspired by Flex (which used XML for defining the UI) and introduced
    its own scripting language called **JavaFX** **script**, which was somewhat closer
    to JSON and JavaScript. You could invoke Java APIs from the JavaFX script. There
    was a new architecture introduced, which had a new Windowing toolkit and a new
    graphics engine. It was a much better alternative to Swing, but it had a drawback—developers
    had to learn JavaFX script to develop JavaFX-based applications. In addition to
    Sun Microsystems not being able to invest more on JavaFX and the Java platform,
    in general, JavaFX never took off as envisioned.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe还为桌面引入了一个富互联网应用程序运行时环境，称为**Adobe AIR**，它允许在桌面上运行Flex应用程序。这对古老的Swing API是一个重大打击。但让我们回到市场：2009年，Sun
    Microsystems推出了一个名为**JavaFX**的东西。这个框架受Flex的启发（使用XML定义UI），并引入了自己的脚本语言称为**JavaFX脚本**，它与JSON和JavaScript有些相似。您可以从JavaFX脚本中调用Java
    API。引入了一个新的架构，其中有一个新的窗口工具包和一个新的图形引擎。这是一个比Swing更好的选择，但它有一个缺点——开发人员必须学习JavaFX脚本来开发基于JavaFX的应用程序。除了Sun
    Microsystems无法在JavaFX和Java平台上投入更多投资之外，JavaFX从未像预期的那样起飞。
- en: Oracle (after acquiring Sun Microsystems) announced a new JavaFX Version 2.0,
    which was an entire rewrite of JavaFX, thereby eliminating the scripting language
    and making JavaFX an API within the Java platform. This has made using the JavaFX
    API similar to using Swing APIs. Also, you can embed JavaFX components within
    Swing, thereby making Swing-based applications more functional. Since then, there
    has been no looking back for JavaFX.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle（收购Sun Microsystems后）宣布推出了一个新的JavaFX版本2.0，这是对JavaFX的整体重写，从而消除了脚本语言，并使JavaFX成为Java平台内的API。这使得使用JavaFX
    API类似于使用Swing API。此外，您可以在Swing中嵌入JavaFX组件，从而使基于Swing的应用程序更加功能强大。从那时起，JavaFX就再也没有回头看了。
- en: JavaFX is no longer being bundled with JDK 11 onward (neither Oracle JDK nor
    OpenJDK builds). And it's also no longer being bundled with the OpenJDK 10 build.
    They have to be downloaded separately from the OpenJFX Project page ([https://wiki.openjdk.java.net/display/OpenJFX/Main](https://wiki.openjdk.java.net/display/OpenJFX/Main)).
    A new community website has been launched for OpenJFX ([https://openjfx.io/](https://openjfx.io/))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 11开始（无论是Oracle JDK还是OpenJDK构建），JavaFX都不再捆绑在一起。OpenJDK 10构建也不再捆绑JavaFX。它们必须从OpenJFX项目页面（[https://wiki.openjdk.java.net/display/OpenJFX/Main](https://wiki.openjdk.java.net/display/OpenJFX/Main)）单独下载。OpenJFX还推出了一个新的社区网站（[https://openjfx.io/](https://openjfx.io/)）。
- en: In this chapter, we will focus entirely on the recipes around JavaFX. We will
    try to cover as many recipes as possible to give you all a good experience of
    using JavaFX.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将完全专注于围绕JavaFX的配方。我们将尽量涵盖尽可能多的配方，以便让您充分体验使用JavaFX。
- en: Creating a GUI using JavaFX controls
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaFX控件创建GUI
- en: In this recipe, we will look at creating a simple GUI application, using JavaFX
    controls. We will build an app that will help you compute your age, after you
    provide your date of birth. Optionally, you can even enter your name, and the
    app will greet you and display your age. It is a pretty simple example that tries
    to show how you can create a GUI by using layouts, components, and event handling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用JavaFX控件创建一个简单的GUI应用程序。我们将构建一个应用程序，可以在您提供出生日期后帮助您计算您的年龄。您还可以输入您的姓名，应用程序将向您问候并显示您的年龄。这是一个相当简单的示例，试图展示如何通过使用布局、组件和事件处理来创建GUI。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following are the modules part of JavaFX:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JavaFX的模块的一部分：
- en: '`javafx.base`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.base`'
- en: '`javafx.controls`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.controls`'
- en: '`javafx.fxml`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.fxml`'
- en: '`javafx.graphics`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.graphics`'
- en: '`javafx.media`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.media`'
- en: '`javafx.swing`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.swing`'
- en: '`javafx.web`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.web`'
- en: If you are using Oracle JDK 10 and 9, it comes with the previously mentioned
    JavaFX modules as part of the setup; that is to say, you can find them in the
    `JAVA_HOME/jmods` directory. And if you are using OpenJDK 10 onward and JDK 11
    onward, you need to download the JavaFX SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) [and
    make the JARs at the location `JAVAFX_SDK_PATH/libs` available on your `modulepath`,
    as follows:](https://gluonhq.com/products/javafx/)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Oracle JDK 10和9，它会随着之前提到的JavaFX模块一起安装；也就是说，您可以在`JAVA_HOME/jmods`目录中找到它们。如果您使用的是OpenJDK
    10及更高版本和JDK 11及更高版本，您需要从[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并将`JAVAFX_SDK_PATH/libs`位置的JAR文件可用于您的`modulepath`。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our recipe, we will be using a few modules as and when required from the
    preceding list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将根据需要从上面的列表中使用一些模块。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class that extends `javafx.application.Application`. The `Application`
    class manages the life cycle of the JavaFX application. The `Application` class
    has an abstract method, `start(Stage stage)`, which you have to implement. This
    would be the starting point for the JavaFX UI:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`javafx.application.Application`的类。`Application`类管理JavaFX应用程序的生命周期。`Application`类有一个抽象方法`start(Stage
    stage)`，您必须实现这个方法。这将是JavaFX UI的起始点：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The class can also be the starting point for the application by providing a
    `public static void main(String [] args) {}` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还可以通过提供一个`public static void main(String [] args) {}`方法成为应用程序的起始点：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code for the subsequent steps has to be written within the `start(Stage
    stage)` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 后续步骤的代码必须在`start(Stage stage)`方法中编写。
- en: 'Let''s create a container layout to properly align the components that we will
    be adding. In this case, we will use `javafx.scene.layout.GridPane` to lay out
    the components in the form of a grid of rows and columns:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个容器布局，以正确对齐我们将要添加的组件。在这种情况下，我们将使用`javafx.scene.layout.GridPane`来以行和列的形式布置组件：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Along with creating the `GridPane` instance, we are setting its layout properties,
    such as the alignment of `GridPane`, the horizontal and vertical spaces between
    the rows and columns, and the padding within each cell of the grid.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建`GridPane`实例之外，我们还设置了它的布局属性，比如`GridPane`的对齐方式，行和列之间的水平和垂直间距，以及网格中每个单元格的填充。
- en: 'Create a new label, which will show the name of our application, specifically, `Age
    calculator`, and add it to `gridPane`, which we created in the preceding step:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的标签，它将显示我们应用程序的名称，具体来说是`年龄计算器`，并将其添加到我们在前一步中创建的`gridPane`中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a label and a text input combination, which will be used for accepting
    the user''s name. Then add these two components to `gridPane`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标签和文本输入组合，用于接受用户的姓名。然后将这两个组件添加到`gridPane`中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a label and a date-picker combination, which will be used for accepting
    the user''s date of birth:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标签和日期选择器组合，用于接受用户的出生日期：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a button, which will be used by the user to trigger the age calculation,
    and add it to `gridPane`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮，用户将用它来触发年龄计算，并将其添加到`gridPane`中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a component to hold the result of the computed age:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件来保存计算出的年龄的结果：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to bind an action to the button created in step 6\. The action
    will be to get the name entered in the name field and the date of birth entered
    in the date-picker field. If the date of birth is provided, then use the Java
    time APIs to compute the period between now and the date of birth. If there is
    a name provided, then prepend a greeting, `Hello, <name>`, to the result:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为第6步中创建的按钮绑定一个动作。动作将是获取在名称字段中输入的名称和在日期选择器字段中输入的出生日期。如果提供了出生日期，则使用Java时间API来计算现在和出生日期之间的时间段。如果提供了名称，则在结果前加上一个问候语，`你好，<name>`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an instance of the `Scene` class by providing the `gridPane` object
    we created in step 2 and the dimensions, the width, and height of the scene:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供我们在第2步中创建的`gridPane`对象和场景的宽度和高度，创建`Scene`类的一个实例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An instance of `Scene` holds the graph of the UI components, which is called
    a **scene graph**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`的一个实例保存了UI组件的图形，这被称为**场景图**。'
- en: 'We have seen that the `start()` method provides us with a reference to a `Stage`
    object. The `Stage` object is the top-level container in JavaFX, something like
    a JFrame. We set the `Scene` object to the `Stage` object and use its `show()`
    method to render the UI:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到`start()`方法为我们提供了一个`Stage`对象的引用。`Stage`对象是JavaFX中的顶级容器，类似于JFrame。我们将`Scene`对象设置为`Stage`对象，并使用它的`show()`方法来渲染UI：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we need to launch this JavaFX UI from the main method. We use the `launch(String[]
    args)` method of the `Application` class to launch the JavaFX UI:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要从主方法启动这个JavaFX UI。我们使用`Application`类的`launch(String[] args)`方法来启动JavaFX
    UI：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete code can be found at `Chapter16/1_create_javafx_gui`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/1_create_javafx_gui`中找到。
- en: We have provided two scripts, `run.bat` and `run.sh`, in `Chapter16/1_create_javafx_gui`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Chapter16/1_create_javafx_gui`中提供了两个脚本，`run.bat`和`run.sh`。`run.bat`脚本用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI,
    as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到GUI，如下面的屏幕截图所示：
- en: '![](img/f78eab15-9491-41ba-b503-27def3e0c8e9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f78eab15-9491-41ba-b503-27def3e0c8e9.png)'
- en: 'Enter the name and the date of birth and click on `Calculate` to view the age:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入姓名和出生日期，然后单击`Calculate`查看年龄：
- en: '![](img/f52396d1-5c74-462e-b2b4-4e265c7d99b6.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f52396d1-5c74-462e-b2b4-4e265c7d99b6.png)'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Before going into the other details, let''s give you a brief overview of the
    JavaFX architecture. We have taken the following diagram describing the architecture
    stack from the JavaFX documentation ([http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入其他细节之前，让我们简要概述一下JavaFX架构。我们从JavaFX文档中获取了以下描述架构堆栈的图表（[http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)）：
- en: '![](img/fe62de47-1d02-4f31-afd7-e09bea089b5b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe62de47-1d02-4f31-afd7-e09bea089b5b.png)'
- en: 'Let''s start from the top of the stack:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从堆栈的顶部开始：
- en: '**The JavaFX APIs and Scene graph**: This is the starting point of the application,
    and most of our focus will be around this part. This provides APIs for different
    components, layout, and other utilities, to facilitate developing a JavaFX-based
    UI. The scene graph holds the visual elements of the application.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaFX API和场景图**: 这是应用程序的起点，我们大部分关注点将围绕这部分。它提供了不同组件、布局和其他实用程序的API，以便开发基于JavaFX的UI。场景图保存了应用程序的可视元素。'
- en: '**Prism, Quantum Toolkit, and the other stuff in blue**: These components manage
    the rendering of the UI and provide a bridge between the underlying operating
    system and JavaFX. This layer provides software rendering in cases where the graphics
    hardware is unable to provide hardware-accelerated rendering of rich UI and 3D
    elements.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prism、Quantum Toolkit和蓝色的其他内容**: 这些组件管理UI的渲染，并在底层操作系统和JavaFX之间提供桥梁。在图形硬件无法提供丰富UI和3D元素的硬件加速渲染的情况下，此层提供软件渲染。'
- en: '**The Glass Windowing Toolkit**: This is the windowing toolkit, just like the
    AWT used by Swing.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玻璃窗口工具包**: 这是窗口工具包，就像Swing使用的AWT一样。'
- en: '**The media engine**: This supports media in JavaFX.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体引擎**: 这支持JavaFX中的媒体。'
- en: '**The web engine**: This supports the web component, which allows complete
    HTML rendering.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web引擎**: 这支持Web组件，允许完整的HTML渲染。'
- en: '**The JDK APIs and JVM**: These integrate with the Java API and compile the
    code down to bytecode to run on the JVM.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK API和JVM**: 这些与Java API集成，并将代码编译为字节码以在JVM上运行。'
- en: 'Let''s get back to explaining the recipe. The `javafx.application.Application`
    class is the entry point for launching the JavaFX applications. It has the following
    methods that map to the life cycle of the application (in their invocation order):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到解释这个示例。`javafx.application.Application`类是启动JavaFX应用程序的入口点。它具有以下方法，这些方法映射到应用程序的生命周期（按其调用顺序）：
- en: '**`init()`**: This method is invoked immediately after the instantiation of `javafx.application.Application`.
    You can override this method to do some initialization before the start of the
    application. By default, this method does nothing.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`init()`**: 此方法在`javafx.application.Application`实例化后立即调用。您可以重写此方法，在应用程序启动之前进行一些初始化。默认情况下，此方法不执行任何操作。'
- en: '`start(javafx.stage.Stage)`: This method is called immediately after `init()`
    and after the system has done the required initialization to run the application.
    This method is passed with a `javafx.stage.Stage` instance, which is the primary
    stage on which the components are rendered. You can create other `javafx.stage.Stage`
    objects, but the one provided by the application is the primary stage.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start(javafx.stage.Stage)`: 此方法在`init()`之后立即调用，并在系统完成运行应用程序所需的初始化后调用。此方法传递了一个`javafx.stage.Stage`实例，这是组件呈现的主要stage。您可以创建其他`javafx.stage.Stage`对象，但应用程序提供的是主要stage。'
- en: '`stop()`: This method is called when the application should stop. You can do
    the necessary exit-related operations.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`: 当应用程序应该停止时调用此方法。您可以执行必要的退出相关操作。'
- en: A *stage* is a top-level JavaFX container. The primary stage passed as an argument
    to the `start()` method is created by the platform, and the application can create
    other `Stage` containers as and when required.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*stage*是一个顶级的JavaFX容器。作为`start()`方法的参数传递的主要stage是由平台创建的，应用程序可以根据需要创建其他`Stage`容器。'
- en: 'The other important method related to `javafx.application.Application` is the
    `launch()` method. There are two variants of this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与`javafx.application.Application`相关的另一个重要方法是`launch()`方法。有两种变体：
- en: '`launch(Class<? extends Application> appClass, String... args)`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch(Class<? extends Application> appClass, String... args)`'
- en: '`launch(String... args)`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`launch(String... args)`'
- en: This method is called from the main method, and should be called only once.
    The first variant takes the name of the class that extends the `javafx.application.Application`
    class along with the arguments passed to the main method, and the second variant
    doesn't take the name of the class and, instead, should be invoked from within
    the class that extends the `javafx.application.Application` class. In our recipe,
    we have made use of the second variant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从主方法中调用，应该只调用一次。第一个变体带有扩展`javafx.application.Application`类的类名以及传递给主方法的参数，第二个变体不带类名，而是应该从扩展`javafx.application.Application`类的类内部调用。在我们的示例中，我们使用了第二个变体。
- en: We have created a class, `CreateGuiDemo`, extends `javafx.application.Application`.
    This will be the entry point for JavaFX UI, and we also added a main method to
    the class, making it an entry point for our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类`CreateGuiDemo`，扩展了`javafx.application.Application`。这将是JavaFX UI的入口点，我们还向类中添加了一个main方法，使其成为我们应用程序的入口点。
- en: 'A layout construct determines how your components are laid out. There are multiple
    layouts supported by JavaFX, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 布局构造确定了组件的布局方式。JavaFX支持多种布局，如下所示：
- en: '`javafx.scene.layout.HBox` and `javafx.scene.layout.VBox`: These are used to
    align the components horizontally and vertically.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.HBox`和`javafx.scene.layout.VBox`：这些用于水平和垂直对齐组件。'
- en: '`javafx.scene.layout.BorderPane`: This allows the placing of the components
    in the top, right, bottom, left, and center positions.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.BorderPane`：这允许在顶部、右侧、底部、左侧和中心位置放置组件。'
- en: '`javafx.scene.layout.FlowPane`: This layout allows the placing of the components
    in a flow, that is, besides each other, wrapping at the flow pane''s boundary.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.FlowPane`：此布局允许在流中放置组件，即相邻放置，并在流面板的边界处换行。'
- en: '`javafx.scene.layout.GridPane`: This layout allows the placing of the components
    in a grid of rows and columns.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.GridPane`：此布局允许在行和列的网格中放置组件。'
- en: '`javafx.scene.layout.StackPane`: This layout places the components in a back-to-front
    stack.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.StackPane`：此布局将组件放置在一个从后到前的堆栈中。'
- en: '`javafx.scene.layout.TilePane`: This layout places the components in a grid
    of uniformly sized tiles.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.layout.TilePane`：此布局将组件放置在统一大小的网格中。'
- en: 'In our recipe, we have made use of `GridPane` and configured the layout so
    that we can achieve the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了`GridPane`并配置了布局，以便实现以下目标：
- en: The grid placed at the center (`gridPane.setAlignment(Pos.CENTER);`)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中心放置网格（`gridPane.setAlignment(Pos.CENTER);）
- en: Set the gap between the columns to 10 (`gridPane.setHgap(10);`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列之间的间隙设置为10（`gridPane.setHgap(10);）
- en: Set the gap between the rows to 10 (`gridPane.setVgap(10);`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行之间的间隙设置为10（`gridPane.setVgap(10);`)
- en: Set the padding within the cell of the grid (`gridPane.setPadding(new Insets(25,
    25, 25, 25));`)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格的单元格内设置填充（`gridPane.setPadding(new Insets(25, 25, 25, 25));）
- en: A `javafx.scene.text.Text` component's font can be set using the `javafx.scene.text.Font`
    object as shown here: `appTitle.setFont(Font.font("Arial", FontWeight.NORMAL,
    15));`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`javafx.scene.text.Text`组件的字体可以使用`javafx.scene.text.Font`对象来设置，如下所示：`appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`'
- en: While adding the component to `javafx.scene.layout.GridPane`, we have to mention
    the column number, row number, and column span, that is, how many columns the
    component occupies, and the row span, that is, how many rows the component occupies
    in that order. The column span and the row span are optional. In our recipe, we
    have placed `appTitle` in the first row and column, and it occupies two column
    spaces and one-row space, as shown in the code here: `appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在将组件添加到`javafx.scene.layout.GridPane`时，我们必须提到列号、行号和列跨度，即组件占据多少列，以及行跨度，即组件在该顺序中占据多少行。列跨度和行跨度是可选的。在我们的示例中，我们将`appTitle`放在第一行和列中，并占据两列空间和一行空间，如下所示：`appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
- en: 'The other important part in this recipe is the setting of the event for the `ageCalculator`
    button. We make use of the `setOnAction()` method of the `javafx.scene.control.Button`
    class to set the action performed when the button is clicked. This accepts an
    implementation of the `javafx.event.EventHandler<ActionEvent>` interface. As `javafx.event.EventHandler`
    is a functional interface, its implementation can be written in the form of a
    lambda expression, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中的另一个重要部分是为`ageCalculator`按钮设置事件。我们使用`javafx.scene.control.Button`类的`setOnAction()`方法来设置按钮点击时执行的操作。这接受`javafx.event.EventHandler<ActionEvent>`接口的实现。由于`javafx.event.EventHandler`是一个功能接口，因此可以以lambda表达式的形式编写其实现，如下所示：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding syntax looks similar to your anonymous inner classes widely used
    during the times of Swing. You can learn more about functional interfaces and
    lambda expressions in the recipes in Chapter 4, *Going Functional*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法看起来类似于Swing时期广泛使用的匿名内部类。您可以在第4章“进入函数”中的示例中了解有关功能接口和lambda表达式的更多信息。
- en: 'In our event-handling code, we get the values from `nameField` and `dateOfBirthPicker` by
    using the `getText()` and `getValue()` methods respectively. `DatePicker` returns
    the date selected as an instance of `java.time.LocalDate`. This is one of the
    new date-time APIs added to Java 8\. It represents a date, that is, the year,
    the month, and the day, without any timezone-related information. We then make
    use of the `java.time.Period` class to find the duration between the current date
    and the selected date, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的事件处理代码中，我们通过使用`getText()`和`getValue()`方法从`nameField`和`dateOfBirthPicker`中获取值。`DatePicker`将所选日期作为`java.time.LocalDate`的实例返回。这是Java
    8中添加的新日期时间API之一。它表示一个日期，即年、月和日，没有任何与时区相关的信息。然后我们使用`java.time.Period`类来找到当前日期和所选日期之间的持续时间，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Period` represents the date-based duration in terms of years, months, and
    days, for example, three years, two months, and three days. This is exactly what
    we are trying to extract with this line of code: `String.format("Your age is %d
    years %d months %d days",  period.getYears(), period.getMonths(), period.getDays())`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`表示基于日期的持续时间，例如三年、两个月和三天。这正是我们试图用这行代码提取的内容：`String.format("你的年龄是%d年%d月%d天",
    period.getYears(), period.getMonths(), period.getDays())`。'
- en: We have already mentioned that the UI components in JavaFX are represented in
    the form of a scene graph, and this scene graph is then rendered onto a container,
    called `Stage`*.* The way to create a scene graph is by using the `javafx.scene.Scene`
    class. We create a `javafx.scene.Scene` instance by passing the root of the scene
    graph and also by providing the dimensions of the container in which the scene
    graph is going to be rendered.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，JavaFX中的UI组件以场景图的形式表示，然后将此场景图呈现到一个称为`Stage`的容器上。创建场景图的方法是使用`javafx.scene.Scene`类。我们通过传递场景图的根以及提供场景图将呈现在其中的容器的尺寸来创建`javafx.scene.Scene`实例。
- en: 'We make use of the container provided to the `start()` method, which is nothing
    but an instance of `javafx.stage.Stage`. Setting the scene for the `Stage` object
    and then calling its `show()` methods makes the complete scene graph rendered
    on the display:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用提供给`start()`方法的容器，这只是`javafx.stage.Stage`的一个实例。为`Stage`对象设置场景，然后调用其`show()`方法，使完整的场景图在显示器上呈现：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the FXML markup to create a GUI
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FXML标记创建GUI
- en: In our first recipe, we looked at using Java APIs to build a UI. It often happens
    that a person who is adept at Java might not be a good UI designer; that is, they
    may be poor at identifying the best user experience for their app. In the world
    of web development, we have developers working on the frontend, based on the designs
    given by the UX designer, and the other set of developers working on the backend,
    to build services that are consumed by the frontend.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们使用Java API构建了一个UI。经常发生的情况是，精通Java的人可能不是一个好的UI设计师；也就是说，他们可能不擅长为他们的应用程序确定最佳的用户体验。在Web开发领域，我们有开发人员根据UX设计师提供的设计进行前端开发，另一组开发人员则负责后端开发，构建由前端使用的服务。
- en: Both developer parties agree to a set of APIs and a common data interchange
    model. Front-end developers work by using some mock data based on the data interchange
    model and also integrate the UI with the required APIs. On the other hand, backend
    developers work on implementing APIs so that they return the data in the interchange
    model agreed upon. So, both parties work simultaneously, using their expertise
    in their work areas.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 两个开发人员团队同意一组API和一个共同的数据交换模型。前端开发人员使用基于数据交换模型的一些模拟数据，并将UI与所需的API集成。另一方面，后端开发人员致力于实现API，以便它们返回协商的数据交换模型中的数据。因此，双方同时使用各自领域的专业知识进行工作。
- en: It would be amazing if the same could be replicated (at least to some extent)
    on desktop applications. A step in this direction was the introduction of an XML-based
    language, called **FXML**. This enables a declarative method of UI development,
    where the developer can independently develop the UI using the same JavaFX components
    but available as XML tags. The different properties of the JavaFX components are
    available as attributes of the XML tags. Event handlers can be declared and defined
    in the Java code and then referred from FXML.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果桌面应用程序能够以某种程度上（至少在某种程度上）复制相同的功能将是很棒的。这方面的一大进展是引入了一种基于XML的语言，称为**FXML**。这使得UI开发具有声明性方法，开发人员可以独立使用相同的JavaFX组件开发UI，但可用作XML标记。JavaFX组件的不同属性可用作XML标记的属性。事件处理程序可以在Java代码中声明和定义，然后从FXML中引用。
- en: In this recipe, we will guide you through building the UI using FXML and then
    integrating FXML with the Java code for binding the action and for launching the
    UI defined in the FXML.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将指导您通过使用FXML构建UI，然后将FXML与Java代码集成，以绑定操作并启动在FXML中定义的UI。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道自从Oracle JDK 11开始和Open JDK 10开始，JavaFX库不再随JDK安装一起提供，我们将不得不从[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR文件添加到模块路径中，如下所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will develop a simple age calculator app. This app will ask for the user's
    name (which is optional) and their date of birth, and calculate the age from the
    given date of birth and display it to the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个简单的年龄计算器应用程序。该应用程序将要求用户输入姓名（可选）和出生日期，并根据给定的出生日期计算年龄并显示给用户。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: All the FXML files should end with the `.fxml` extension. Let's create an empty `fxml_age_calc_gui.xml`
    file in the location `src/gui/com/packt`. In the subsequent steps, we will update
    this file with the XML tags for the JavaFX components.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有FXML文件应以`.fxml`扩展名结尾。让我们在`src/gui/com/packt`位置创建一个空的`fxml_age_calc_gui.xml`文件。在随后的步骤中，我们将使用JavaFX组件的XML标签更新此文件。
- en: 'Create a `GridPane` layout, which will hold all the components in a grid of
    rows and columns. We will also provide the required spacing between the rows and
    the columns using the `vgap` and `hgap` attributes. Also, we will provide `GridPane`,
    which is our root component, with the reference to the Java class, where we will
    add the required event handling. This Java class will be like the controller for
    the UI:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GridPane`布局，它将在行和列的网格中容纳所有组件。我们还将使用`vgap`和`hgap`属性为行和列之间提供所需的间距。此外，我们将为`GridPane`（我们的根组件）提供对Java类的引用，我们将在其中添加所需的事件处理。这个Java类将类似于UI的控制器：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will provide the padding within each cell of the grid by defining a `padding`
    tag with `Insets` within `GridPane`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过在`GridPane`中定义`Insets`标签来为网格中的每个单元格提供填充：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next is to add a `Text` tag, which displays the title of the application—`Age
    Calculator`. We provide the required style information in the `style` attribute
    and the placement of the `Text` component within `GridPane` using the `GridPane.columnIndex`
    and `GridPane.rowIndex` attributes. The cell occupancy information can be provided
    using the `GridPane.columnSpan` and `GridPane.rowSpan` attributes:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是添加一个`Text`标签，用于显示应用程序的标题——`年龄计算器`。我们在`style`属性中提供所需的样式信息，并使用`GridPane.columnIndex`和`GridPane.rowIndex`属性将`Text`组件放置在`GridPane`中。可以使用`GridPane.columnSpan`和`GridPane.rowSpan`属性提供单元格占用信息：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then add the `Label` and `TextField` components for accepting the name.
    Note the use of the `fx:id` attribute in `TextField`. This helps in binding this
    component in the Java controller by creating a field with the same name as that
    of the `fx:id` value:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加`Label`和`TextField`组件来接受名称。注意在`TextField`中使用了`fx:id`属性。这有助于通过创建与`fx:id`值相同的字段来绑定Java控制器中的这个组件：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We add the `Label` and `DatePicker` components for accepting the date of birth:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加`Label`和`DatePicker`组件来接受出生日期：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we add a `Button` object and set its `onAction` attribute to the name
    of the method in the Java controller that handles the click event of this button:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`Button`对象，并将其`onAction`属性设置为Java控制器中处理此按钮点击事件的方法的名称：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we add a `Text` component to display the calculated age:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个`Text`组件来显示计算出的年龄：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to implement the Java class, which is directly related to
    the XML-based UI components created in the preceding steps. Create a class named `FxmlController`.
    This will contain the code that is relevant to the FXML UI; that is, it will contain
    the references to the components created in the FXML action handlers for the components
    created in the FXML:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现与前面步骤中创建的基于XML的UI组件相关的Java类。创建一个名为`FxmlController`的类。这将包含与FXML UI相关的代码；也就是说，它将包含对在FXML中创建的组件的引用，以及对在FXML中创建的组件的动作处理程序：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need references to the `nameField`, `dateOfBirthPicker`, and `resultText`
    components. We use the first two to get the entered name and date of birth, respectively,
    and the third to display the result of the age calculation:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要引用`nameField`，`dateOfBirthPicker`和`resultText`组件。我们使用前两个分别获取输入的名称和出生日期，第三个用于显示年龄计算的结果：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is to implement the `calculateAge` method, which is registered
    as the action event handler for the `Calculate` button. The implementation is
    similar to the one in the previous recipe. The only difference is that it is a
    method, unlike the previous recipe, where it was a lambda expression:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现`calculateAge`方法，该方法注册为`Calculate`按钮的动作事件处理程序。实现与上一个示例中类似。唯一的区别是它是一个方法，而不是上一个示例中的lambda表达式：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In both steps 10 and 11, we have used an annotation, `@FXML`. This annotation
    indicates that the class or the member is accessible to the FXML-based UI.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤10和11中，我们使用了一个注解`@FXML`。这个注解表示该类或成员对基于FXML的UI是可访问的。
- en: 'Next, we''ll create another Java class, `FxmlGuiDemo`, which is responsible
    for rendering the FXML-based UI and which would also be the entry point for launching
    the application:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个Java类`FxmlGuiDemo`，负责渲染基于FXML的UI，也将是启动应用程序的入口点：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need to create a scene graph from the FXML UI definition by overriding
    the `start(Stage stage)` method of the `javafx.application.Application` class and
    then render the scene graph within the passed `javafx.stage.Stage` object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要通过覆盖`javafx.application.Application`类的`start(Stage stage)`方法从FXML UI定义创建一个场景图，并在传递的`javafx.stage.Stage`对象中渲染场景图：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we provide the `main()` method implementation:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们提供`main()`方法的实现：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The complete code can be found at the location `Chapter16/2_fxml_gui`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/2_fxml_gui`位置找到。
- en: We have provided two-run scripts, `run.bat` and `run.sh`, in `Chapter16/2_fxml_gui`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Chapter16/2_fxml_gui`中提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到如下屏幕截图所示的GUI：
- en: '![](img/44729bd6-e935-48d0-bccc-d26e225c8469.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44729bd6-e935-48d0-bccc-d26e225c8469.png)'
- en: 'Enter the name and the date of birth and click on `Calculate` to view the age:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输入名称和出生日期，然后点击`Calculate`来查看年龄：
- en: '![](img/d7ef594d-c776-4d68-993e-5e94e3c657c2.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7ef594d-c776-4d68-993e-5e94e3c657c2.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There is no XSD defining the schema for the FXML document. So, to know the
    tags to be used, they follow a simple naming convention. The Java class name of
    the component is also the name of the XML tag. For example, the XML tag for the `javafx.scene.layout.GridPane`
    layout is `<GridPane>`, and for `javafx.scene.control.TextField` it is `<TextField>`,
    and for `javafx.scene.control.DatePicke` it is `<DatePicker>`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义FXML文档模式的XSD。因此，要知道要使用的标签，它们遵循一个简单的命名约定。组件的Java类名也是XML标签的名称。例如，`javafx.scene.layout.GridPane`布局的XML标签是`<GridPane>`，`javafx.scene.control.TextField`的XML标签是`<TextField>`，`javafx.scene.control.DatePicke`的XML标签是`<DatePicker>`：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding line of code makes use of an instance of `javafx.fxml.FXMLLoader`
    to read the FXML file and get the Java representation of the UI components. `FXMLLoader`
    uses an event-based SAX parser to parse the FXML file. Instances of the respective
    Java classes for the XML tags are created via reflection, and the values of attributes
    of the XML tags are populated into the respective properties of the Java classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行利用`javafx.fxml.FXMLLoader`的一个实例来读取FXML文件并获取UI组件的Java表示。`FXMLLoader`使用基于事件的SAX解析器来解析FXML文件。通过反射创建XML标签的相应Java类的实例，并将XML标签的属性值填充到Java类的相应属性中。
- en: As the root of our FXML is `javafx.scene.layout.GridPane`, which extends `javafx.scene.layout.Pane`,
    we can cast the return value from `FXMLoader.load()` to `javafx.scene.layout.Pane`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的FXML的根是`javafx.scene.layout.GridPane`，它扩展了`javafx.scene.layout.Pane`，我们可以将`FXMLoader.load()`的返回值转换为`javafx.scene.layout.Pane`。
- en: 'The other interesting thing in this recipe is the `FxmlController` class. This
    class acts as an interface to FXML. We indicate the same in the FXML by using
    the `fx:controller` attribute to the `<GridPane>` tag. We can get hold of the
    UI components defined in FXML by using the `@FXML` annotation against the member
    fields of the `FxmlController` class, as we did in this recipe:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的另一个有趣的地方是`FxmlController`类。这个类充当了与FXML的接口。我们在FXML中使用`fx:controller`属性指示相同的内容到`<GridPane>`标签。我们可以通过在`FxmlController`类的成员字段上使用`@FXML`注解来获取在FXML中定义的UI组件，就像我们在这个示例中所做的那样：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The name of the member is the same as that of the `fx:id` attribute value in
    FXML, and the type of the member is the same as that of the tag in FXML. For example,
    the first member is bound to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 成员的名称与FXML中的`fx:id`属性值相同，成员的类型与FXML中的标签类型相同。例如，第一个成员绑定到以下内容：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On similar lines, we created an event handler in `FxmlController` and annotated
    it with `@FXML`, and the same has been referenced in FXML with the `onAction`
    attribute of `<Button>`. Note that we have added `#` to the beginning of the method
    name in the `onAction` attribute value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，我们在`FxmlController`中创建了一个事件处理程序，并用`@FXML`对其进行了注释，在FXML中使用了`<Button>`的`onAction`属性引用了它。请注意，我们在`onAction`属性值的方法名称前面添加了`#`。
- en: Using CSS to the style elements in JavaFX
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS来为JavaFX中的元素设置样式
- en: Those from a web development background will be able to appreciate the usefulness
    of the **Cascading Style Sheets** (**CSS**), and for those who are not, we will
    provide an overview of what they are and how they are useful, before diving into
    CSS application in JavaFX.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Web开发背景的人将能够欣赏到**层叠样式表**（**CSS**）的实用性，而对于那些不了解的人，我们将在深入介绍JavaFX中的CSS应用之前，提供它们的概述和用途。
- en: The elements or the components that you see on web pages are often styled according
    to the theme of the website. This styling is made possible by using a language
    called **CSS**. CSS consists of a group of `name:value` pairs, separated by semicolons.
    These `name:value` pairs, when associated with an HTML element, say, `<button>`,
    give it the required styling.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上看到的元素或组件通常根据网站的主题进行样式设置。这种样式是通过使用一种叫做**CSS**的语言实现的。CSS由一组以分号分隔的`name:value`对组成。当这些`name:value`对与HTML元素关联时，比如`<button>`，它就会获得所需的样式。
- en: 'There are multiple ways to associate these `name:value` pairs to the element,
    the simplest being when you put this `name:value` pair within the style attribute
    of your HTML element. For example, to give the button a blue background, we can
    do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法将这些`name:value`对与元素关联起来，最简单的方法是将这些`name:value`对放在HTML元素的style属性中。例如，要给按钮设置蓝色背景，我们可以这样做：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are predefined names for different styling properties, and these take
    a specific set of values; that is, the property, `background-color`, will only
    take valid color values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不同样式属性有预定义的名称，并且它们接受特定的一组值；也就是说，属性`background-color`只能接受有效的颜色值。
- en: 'The other approach is to define these groups of `name:value` pairs in a different
    file with a `.css` extension. Let''s call this group of `name:value` pairs **CSS
    properties**. We can associate these CSS properties with different selectors,
    that is, selectors for choosing the elements on the HTML page to apply the CSS
    properties too. There are three different ways of providing the selectors:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在一个扩展名为`.css`的不同文件中定义这些`name:value`对的组。让我们称这组`name:value`对为**CSS属性**。我们可以将这些CSS属性与不同的选择器关联起来，即选择器用于选择要应用CSS属性的HTML页面上的元素。有三种不同的提供选择器的方法：
- en: By directly giving the name of the HTML element, that is, whether it is an anchor
    tag (`<a>`), button, or input. In such cases, the CSS properties are applied to
    all the types of HTML elements in the page.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接给出HTML元素的名称，即是锚标签（`<a>`）、按钮或输入。在这种情况下，CSS属性将应用于页面中所有类型的HTML元素。
- en: 'By using the `id` attribute of the HTML element. Suppose, we have a button
    with `id="btn1"`, then we can define a selector, `#btn1`, against which we provide
    the CSS properties. Take a look at the following example:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用HTML元素的`id`属性。假设我们有一个`id="btn1"`的按钮，那么我们可以定义一个选择器`#btn1`，针对它提供CSS属性。看下面的例子：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By using the class attribute of the HTML element. Suppose we have a button
    with `class="blue-btn"`, then we can define a selector, `.blue-btn`, against which
    we provide the CSS properties. Check out the following example:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用HTML元素的class属性。假设我们有一个`class="blue-btn"`的按钮，那么我们可以定义一个选择器`.blue-btn`，针对它提供CSS属性。看下面的例子：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The advantage of using a different CSS file is that we can independently evolve
    the appearance of the web pages without getting tightly coupled to the location
    of the elements. Also, this encourages the reuse of CSS properties across different
    pages, thereby giving them a uniform look across all the pages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的CSS文件的优势在于，我们可以独立地改变网页的外观，而不会与元素的位置紧密耦合。此外，这鼓励在不同页面之间重用CSS属性，从而使它们在所有页面上具有统一的外观。
- en: When we apply a similar approach to JavaFX, we can leverage the CSS knowledge
    already available with our web designers to build CSS for JavaFX components, and
    this helps in styling the components more easily than with the use of Java APIs.
    When this CSS is mixed with FXML, then it becomes a known domain for web developers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将类似的方法应用于JavaFX时，我们可以利用我们的Web设计人员已经掌握的CSS知识来为JavaFX组件构建CSS，这有助于比使用Java API更轻松地为组件设置样式。当这种CSS与FXML混合在一起时，它就成为了Web开发人员熟悉的领域。
- en: In this recipe, we will look at styling a few JavaFX components using an external
    CSS file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用外部CSS文件来为一些JavaFX组件设置样式。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道从Oracle JDK 11开始和Open JDK 10开始，JavaFX库不再随JDK安装一起提供，我们需要从[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包包含在模块路径上，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is a small difference in defining the CSS properties for the JavaFX components.
    All the properties must be prefixed with `-fx-`, that is, `background-color` becomes
    `-fx-background-color`. The selectors, that is, `#id` and `.class-name` still
    remain the same in the JavaFX world as well. We can even provide multiple classes
    to the JavaFX components, thereby applying all these CSS properties to the components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义JavaFX组件的CSS属性时有一个小区别。所有的属性都必须以`-fx-`为前缀，也就是说，`background-color`变成了`-fx-background-color`。选择器，即`#id`和`.class-name`在JavaFX世界中仍然保持不变。我们甚至可以为JavaFX组件提供多个类，从而将所有这些CSS属性应用到组件上。
- en: The CSS that I have used in this recipe is based on a popular CSS framework
    called **Bootstrap** ([http://getbootstrap.com/css/](http://getbootstrap.com/css/)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个示例中使用的CSS基于一个名为**Bootstrap**的流行CSS框架（[http://getbootstrap.com/css/](http://getbootstrap.com/css/)）。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create `GridPane`, which will hold the components in a grid of rows
    and columns:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`GridPane`，它将以行和列的网格形式容纳组件：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we will create a button and add two classes, `btn`, and `btn-primary`,
    to it. In the next step, we will define these selectors with the required CSS
    properties:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个按钮，并为其添加两个类，`btn`和`btn-primary`。在下一步中，我们将为这些选择器定义所需的CSS属性：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s provide the required CSS properties for the classes, `btn` and `btn-primary`.
    The selector for the classes are of the form `.<class-name>`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为类`btn`和`btn-primary`提供所需的CSS属性。这些类的选择器形式为`.<class-name>`：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s create another button with a different CSS class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个具有不同CSS类的按钮：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we define the CSS properties for the `.btn-success` selector as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为`.btn-success`选择器定义CSS属性如下：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s create yet another button with a different CSS class:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个具有不同CSS类的按钮：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will define the CSS properties for the selector `.btn-danger`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为选择器`.btn-danger`定义CSS属性。
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s add some labels with different selectors, namely `badge` and `badge-info`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些具有不同选择器的标签，即`badge`和`badge-info`：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The CSS properties for the previous selectors are as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面选择器的CSS属性如下：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s add `TextField` with a `big-input` class:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个带有`big-input`类的`TextField`：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We define CSS properties so that the content of the textbox is large in size
    and red in color:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义CSS属性，使得文本框的内容尺寸大且颜色为红色：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add some radio buttons:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些单选按钮：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We define CSS properties so that the labels of the radio buttons are large
    in size and green in color:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义CSS属性，使得单选按钮的标签尺寸大且颜色为绿色：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we add `javafx.scene.layout.GridPane` to the scene graph and render
    the scene graph on `javafx.stage.Stage`. We also need to associate the `stylesheet.css`
    with the `Scene`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`javafx.scene.layout.GridPane`添加到场景图中，并在`javafx.stage.Stage`上渲染场景图。我们还需要将`stylesheet.css`与`Scene`关联起来：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add a `main()` method to launch the GUI:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main()`方法来启动GUI：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The complete code can be found here: `Chapter16/3_css_javafx`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在这里找到：`Chapter16/3_css_javafx`。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/3_css_javafx`.
    The `run.bat` will be for running the application on Windows, and `run.sh` will
    be for running the application on Linux.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个运行脚本，`run.bat`和`run.sh`，在`Chapter16/3_css_javafx`下。`run.bat`用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，你会看到以下的GUI：
- en: '![](img/fa402889-ce42-4e51-9568-7c90a1ab4cf9.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa402889-ce42-4e51-9568-7c90a1ab4cf9.png)'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we make use of class names and their corresponding CSS selectors
    to associate components with different styling properties. JavaFX supports a subset
    of CSS properties, and there are different properties applicable to different
    types of JavaFX components. The JavaFX CSS reference guide ([http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html))
    will help you identify the supported CSS properties.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们利用类名及其对应的CSS选择器来关联具有不同样式属性的组件。JavaFX支持CSS属性的子集，不同类型的JavaFX组件适用不同的属性。JavaFX
    CSS参考指南（[http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html)）将帮助您识别支持的CSS属性。
- en: All the scene graph nodes extend from an abstract class, `javax.scene.Node`.
    This abstract class provides an API, `getStyleClass()`, that returns a list of
    class names (which are plain `String`) added to the node or to the JavaFX component.
    As this is a simple list of class names, we can even add more class names to it
    by using `getStyleClass().add("new-class-name")`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的场景图节点都是从一个抽象类`javax.scene.Node`继承的。这个抽象类提供了一个API，`getStyleClass()`，返回一个添加到节点或JavaFX组件的类名列表（这些都是普通的`String`）。由于这是一个简单的类名列表，我们甚至可以通过使用`getStyleClass().add("new-class-name")`来添加更多的类名。
- en: The advantage of using class names is that it allows us to group similar components
    by a common class name. This technique is widely used in the web development world.
    Suppose I have a list of buttons on the HTML page and I want a similar action
    to be performed on the click of each button. To achieve this, I will assign each
    of the buttons the same class, say, `my-button`, and then use `document.getElementsByClassName('my-button')`
    to get an array of these buttons. Now we can loop through the array of buttons
    obtained and add the required action handlers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类名的优势在于它允许我们通过共同的类名对类似的组件进行分组。这种技术在Web开发世界中被广泛使用。假设我在HTML页面上有一个按钮列表，我希望在单击每个按钮时执行类似的操作。为了实现这一点，我将为每个按钮分配相同的类，比如`my-button`，然后使用`document.getElementsByClassName('my-button')`来获取这些按钮的数组。现在我们可以循环遍历获取的按钮数组并添加所需的操作处理程序。
- en: After assigning a class to the component, we need to write the CSS properties
    for the given class name. These properties then get applied to all the components
    with the same class name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在为组件分配类之后，我们需要为给定的类名编写CSS属性。然后这些属性将应用于所有具有相同类名的组件。
- en: 'Let''s pick one of the components from our recipe and see how we went about
    styling it. Consider the following component with two classes, `btn` and `btn-primary`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从我们的配方中挑选一个组件，看看我们是如何进行样式化的。考虑以下具有两个类`btn`和`btn-primary`的组件： '
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We have used the selectors, `.btn` and `.btn-primary`, and we have grouped
    all the CSS properties under these selectors, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了选择器`.btn`和`.btn-primary`，并将所有的CSS属性分组在这些选择器下，如下所示：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that, in CSS, we have a `color` property, and its equivalent in JavaFX
    is `-fx-text-fill`. The rest of the CSS properties, namely `border-radius`, `border`,
    `font-size`, `font-weight`, `text-align`, `background-color`, and `border-color`,
    are prefixed with `-fx-`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在CSS中，我们有一个`color`属性，它在JavaFX中的等价物是`-fx-text-fill`。其余的CSS属性，即`border-radius`、`border`、`font-size`、`font-weight`、`text-align`、`background-color`和`border-color`，都以`-fx-`为前缀。
- en: The important part is how you associate the style sheet with the `Scene` component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是如何将样式表与`Scene`组件关联起来。
- en: The `scene.getStylesheets().add("com/packt/stylesheet.css");` line of code associates
    stylesheets with the scene component. As `getStylesheets()` returns a list of
    strings, we can add multiple strings to it, which means that we can associate
    multiple stylesheets to a Scene.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`scene.getStylesheets().add("com/packt/stylesheet.css");`这行代码将样式表与场景组件关联起来。由于`getStylesheets()`返回一个字符串列表，我们可以向其中添加多个字符串，这意味着我们可以将多个样式表关联到一个场景中。'
- en: 'The documentation of `getStylesheets()` states the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStylesheets()`的文档说明如下：'
- en: '"The URL is a hierarchical URI of the form [scheme:][//authority][path]. If
    the URL does not have a [scheme:] component, the URL is considered to be the [path]
    component only. Any leading ''/'' character of the [path] is ignored and the [path]
    is treated as a path relative to the root of the application''s classpath."'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '"URL是形式为[scheme:][//authority][path]的分层URI。如果URL没有[scheme:]组件，则URL被视为仅有[path]组件。[path]的任何前导''/''字符都将被忽略，[path]将被视为相对于应用程序类路径的路径。"'
- en: In our recipe, we are using the `path` component only, and hence it looks for
    the file in the classpath. This is the reason we have added the stylesheet to
    the same package as that of the scene. This is an easier way of making it available
    on the classpath.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们只使用了`path`组件，因此它在类路径中查找文件。这就是我们将样式表添加到与场景相同的包中的原因。这是使其在类路径上可用的更简单的方法。
- en: Creating a bar chart
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建条形图
- en: Data, when represented in the form of tables, is very hard to understand, but
    when data is represented graphically by using charts, it is comfortable for the
    eyes and easy to understand. We have seen a lot of charting libraries for web
    applications. However, the same support was lacking on the desktop application
    front. Swing didn't have native support for creating charts, and we had to rely
    on third-party applications such as **JFreeChart** ([http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)).
    With JavaFX, though, we have native support for creating charts, and we are going
    to show you how to represent the data in the form of charts using the JavaFX chart
    components.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据以表格形式表示时，很难理解，但当数据以图表形式图形化表示时，它对眼睛来说是舒适的，易于理解的。我们已经看到了很多用于Web应用程序的图表库。然而，在桌面应用程序方面缺乏相同的支持。Swing没有本地支持创建图表，我们不得不依赖于第三方应用程序，如**JFreeChart**（[http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)）。不过，JavaFX具有创建图表的本地支持，我们将向您展示如何使用JavaFX图表组件以图表形式表示数据。
- en: 'JavaFX supports the following chart types:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX支持以下图表类型：
- en: Bar chart
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条形图
- en: Line chart
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折线图
- en: Pie chart
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图
- en: Scatter chart
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: Area chart
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域图
- en: Bubble chart
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡图
- en: In the next few recipes, we will cover the construction of each chart type.
    The segregation of each chart type into a recipe of its own will help us in explaining
    the recipes in a simpler way and will aid better understanding.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个配方中，我们将介绍每种图表类型的构建。将每种图表类型分开成自己的配方将有助于我们以更简单的方式解释配方，并有助于更好地理解。
- en: 'This recipe will be all about bar charts. A sample bar chart looks something
    like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将全部关于条形图。一个样本条形图看起来像这样：
- en: '![](img/07097a6b-2eb0-4075-a3d1-b4e10a38f206.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07097a6b-2eb0-4075-a3d1-b4e10a38f206.png)'
- en: Bar charts can have a single bar or multiple bars (as in the preceding diagram)
    for each value on the *x *axis. Multiple bars help us in comparing multiple value
    points for each value on the *x *axis.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图可以在*x*轴上的每个值上具有单个条或多个条（如前面的图表中）。多个条可以帮助我们比较*x*轴上每个值的多个值点。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道从Oracle JDK 11开始和Open JDK 10开始，JavaFX库不会随JDK安装一起提供，因此我们必须从[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包包含在模块路径上，如下所示：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will make use of a subset of data from the student performance machine learning
    repository ([https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)).
    The dataset consists of student performance in two subjects, Mathematics and Portuguese,
    along with their social background information, such as their parents'' occupations
    and education, among other information. There are quite a lot of attributes in
    the dataset, but we will pick the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自学生表现机器学习存储库（[https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)）的数据子集。数据集包括学生在数学和葡萄牙语两门科目中的表现，以及他们的社会背景信息，如父母的职业和教育等其他信息。数据集中有很多属性，但我们将选择以下属性：
- en: Student's gender
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生的性别
- en: Student's age
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生的年龄
- en: Father's education
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父亲的教育
- en: Father's occupation
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父亲的职业
- en: Mother's education
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母亲的教育
- en: Mother's occupation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母亲的职业
- en: Whether the student has taken extra classes
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生是否参加了额外课程
- en: First-term grades
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一学期成绩
- en: Second-term grades
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二学期成绩
- en: Final grades
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终成绩
- en: 'As we mentioned earlier, there are a lot of attributes captured in the data,
    but we should be good with a few important attributes that will help us plot some
    useful charts. Due to this, we have extracted the information from the dataset
    available in the machine learning repository into a separate file, which can be
    found at `Chapter16/4_bar_charts/src/gui/com/packt/students`, in the code download
    for the book. An excerpt from the students file follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，数据中捕获了很多属性，但我们只需要一些重要的属性就可以绘制一些有用的图表。因此，我们已经从机器学习存储库中的数据集中提取了信息，并将其放入了一个单独的文件中，该文件可以在书籍的代码下载中的`Chapter16/4_bar_charts/src/gui/com/packt/students`中找到。以下是从学生文件中摘录的一部分内容：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The entries are separated by semicolons (`;`). Each entry has been explained
    for what it represents. The education information (fields 3 and 4) is a numeric
    value, where each number represents the level of education, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 条目由分号(`;`)分隔。已解释每个条目代表的内容。教育信息（字段3和4）是一个数字值，其中每个数字代表教育水平，如下所示：
- en: '`0`: None'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：无'
- en: '`1`: Primary education (fourth grade)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：小学教育（四年级）'
- en: '`2`: Fifth to ninth grade'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：五到九年级'
- en: '`3`: Secondary education'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：中等教育'
- en: '`4`: Higher education'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：高等教育'
- en: We have created a module for processing the student file. The module name is
    `student.processor` and its code can be found at `Chapter16/101_student_data_processor`.
    So, if you want to change any code there, you can rebuild the JAR by running the
    `build-jar.bat` or `build-jar.sh` file. This will create a modular JAR, `student.processor.jar`,
    in the `mlib` directory. Then, you have to replace this modular JAR with the one
    present in the `mlib` directory of this recipe, that is, `Chapter16/4_bar_charts/mlib`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个用于处理学生文件的模块。模块名称是`student.processor`，其代码可以在`Chapter16/101_student_data_processor`中找到。因此，如果您想更改那里的任何代码，可以通过运行`build-jar.bat`或`build-jar.sh`文件来重新构建JAR。这将在`mlib`目录中创建一个模块化的JAR，`student.processor.jar`。然后，您必须将此模块化JAR替换为本配方的`mlib`目录中的模块化JAR，即`Chapter16/4_bar_charts/mlib`。
- en: We recommend that you build the `student.processor` modular jar from the source
    available in `Chapter16/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you build the JAR. You just have to run the
    script relevant to your platform and then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您从`Chapter16/101_student_data_processor`中提供的源代码构建`student.processor`模块化jar。我们提供了`build-jar.bat`和`build-jar.sh`脚本来帮助您构建JAR。您只需运行与您的平台相关的脚本，然后将构建的jar复制到`101_student_data_processor/mlib`中，然后再复制到`4_bar_charts/mlib`中。
- en: This way, we can reuse this module across all the recipes involving charts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在涉及图表的所有配方中重复使用此模块。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'First, create `GridPane` and configure it to place the charts that we will
    be creating:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建`GridPane`并配置它以放置我们将要创建的图表：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `StudentDataProcessor` class from the `student.processor` module to
    parse the student file and load the data into `List` of `Student`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`student.processor`模块中的`StudentDataProcessor`类来解析学生文件并将数据加载到`Student`的`List`中：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The raw data, that is, the list of `Student` objects, is not useful for plotting
    a chart, so we need to process the students'' grades by grouping the students
    according to their mothers'' and fathers'' education and computing the average
    of those students'' grades (all three terms). For this, we will write a simple
    method that accepts `List<Student>`, a grouping function, that is, the value on
    which the students need to be grouped, and a mapping function, that is, the value
    that has to be used to compute the average:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始数据，即`Student`对象的列表，对于绘制图表来说并不有用，因此我们需要通过根据他们母亲和父亲的教育水平对学生进行分组，并计算这些学生的成绩（所有三个学期）的平均值来处理学生的成绩。为此，我们将编写一个简单的方法，接受`List<Student>`，一个分组函数（即学生需要根据其值进行分组的值），以及一个映射函数（即用于计算平均值的值）：
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding method uses the new Stream-based APIs. These APIs are so powerful
    that they group the students by using `Collectors.groupingBy()` and then compute
    the statistics of their grades by using `Collectors.summarizingInt()`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用了新的基于流的API。这些API非常强大，它们使用`Collectors.groupingBy()`对学生进行分组，然后使用`Collectors.summarizingInt()`计算他们的成绩统计信息。
- en: 'The data for the bar chart is provided as an instance of `XYChart.Series`.
    Each series results in one *y* value for a given *x* value, which is one bar for
    a given *x* value. We will have multiple series, one for each term, that is, first-term
    grades, second-term grades, and the final grades. Let''s create a method that
    takes in the statistics of each term grades and the `seriesName` and returns a
    `series` object:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条形图的数据以`XYChart.Series`的实例提供。每个系列对于给定的*x*值会产生一个*y*值，这是给定*x*值的一个条形图。我们将有多个系列，一个用于每个学期，即第一学期成绩、第二学期成绩和期末成绩。让我们创建一个方法，该方法接受每个学期成绩的统计数据和`seriesName`，并返回一个`series`对象：
- en: '[PRE60]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will create two bar charts—one for the average grade from the mother''s
    education and the other for the average grade from the father''s education. For
    this, we will create a method that will take `List<Student>` and a classifier,
    that is, a function that will return the value to be used to group the students.
    This method will do the necessary computations and return a `BarChart` object:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个条形图——一个用于母亲教育的平均成绩，另一个用于父亲教育的平均成绩。为此，我们将创建一个方法，该方法将获取`List<Student>`和一个分类器，即一个将返回用于对学生进行分组的值的函数。该方法将进行必要的计算并返回一个`BarChart`对象：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create `BarChart` for the average grades from the mother''s education, and
    add it to `gridPane`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为母亲的教育平均成绩创建`BarChart`，并将其添加到`gridPane`：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create `BarChart` for the average grades from the father''s education and add
    it to `gridPane`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为父亲的教育平均成绩创建`BarChart`并将其添加到`gridPane`：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a scene graph using `gridPane` and set it to `Stage`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gridPane`创建一个场景图，并将其设置为`Stage`：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The complete code can be found at `Chapter16/4_bar_charts`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/4_bar_charts`中找到。
- en: We have provided two run scripts: `run.bat` and `run.sh`, under `Chapter16/4_bar_charts`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个运行脚本：`run.bat`和`run.sh`，位于`Chapter16/4_bar_charts`下。`run.bat`脚本将用于在Windows上运行应用程序，`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/68ae46d4-b460-449d-9774-a2e18a499c33.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68ae46d4-b460-449d-9774-a2e18a499c33.png)'
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's first see what it takes to create `BarChart`. `BarChart` is a two axes-based
    chart, where the data is plotted on two axes, namely the *x* axis (horizontal
    axis) and the *y* axis (vertical axis). The other two axes-based charts are area
    chart, bubble chart, and line chart.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看创建`BarChart`需要什么。`BarChart`是一个基于两个轴的图表，其中数据绘制在两个轴上，即*x*轴（水平轴）和*y*轴（垂直轴）。另外两个基于轴的图表是面积图、气泡图和折线图。
- en: 'In JavaFX, there are two types of axes supported:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX中，支持两种类型的轴：
- en: '`javafx.scene.chart.CategoryAxis`: This supports string values on the axes'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.chart.CategoryAxis`：这支持轴上的字符串值'
- en: '`javafx.scene.chart.NumberAxis`: This supports numeric values on the axes'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.chart.NumberAxis`：这支持轴上的数值'
- en: 'In our recipe, we created `BarChart` with `CategoryAxis` as the *x* axis, where
    we plot the education, and `NumberAxis` as the *y* axis, where we plot the grade,
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`CategoryAxis`作为*x*轴创建了`BarChart`，在这里我们绘制教育，使用`NumberAxis`作为*y*轴，在这里我们绘制等级，如下所示：
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the next few paragraphs, we show you how the plotting of `BarChart` works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几段中，我们将向您展示`BarChart`的绘制方式。
- en: 'The data to be plotted on `BarChart` should be a pair of values, where each
    pair represents *(x, y)* values, that is, a point on the *x* axis and a point
    on the *y* axis. This pair of values is represented by `javafx.scene.chart.XYChart.Data`.
    `Data` is a nested class within `XYChart`, which represents a single data item
    for a two axes-based chart. An `XYChart.Data` object can be created quite simply,
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`BarChart`上绘制的数据应该是一对值，其中每对表示*(x, y)*值，即*x*轴上的一个点和*y*轴上的一个点。这一对值由`javafx.scene.chart.XYChart.Data`表示。`Data`是`XYChart`内的一个嵌套类，它表示基于两个轴的图表的单个数据项。`XYChart.Data`对象可以很简单地创建，如下所示：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is just a one-data item. A chart can have multiple data items, that is,
    a series of data items. To represent a series of data items, JavaFX provides a
    class called `javafx.scene.chart.XYChart.Series`. This `XYChart.Series` object
    is a named series of `XYChart.Data` items. Let''s create a simple series, as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个数据项。一个图表可以有多个数据项，也就是一系列数据项。为了表示一系列数据项，JavaFX提供了一个名为`javafx.scene.chart.XYChart.Series`的类。这个`XYChart.Series`对象是`XYChart.Data`项的一个命名系列。让我们创建一个简单的系列，如下所示：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`BarChart` can have multiple series of data items. If we provide it with multiple
    series, then there will be multiple bars for each data point on the *x* axis.
    For our demonstration of how this works, we will stick with one series. But the
    `BarChart` class in our recipe uses multiple series. Let''s add the series to
    the `BarChart` and then render it onto the screen:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`BarChart`可以有多个数据系列。如果我们为其提供多个系列，那么在*x*轴上的每个数据点上将有多个条形图。为了演示这是如何工作的，我们将坚持使用一个系列。但是我们示例中的`BarChart`类使用了多个系列。让我们将系列添加到`BarChart`，然后将其渲染到屏幕上：'
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This results in the following chart:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下图表：
- en: '![](img/a2a1490f-110f-4139-aac4-6685cced09c1.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2a1490f-110f-4139-aac4-6685cced09c1.png)'
- en: 'The other interesting part of this recipe is the grouping of students based
    on the education of the mother and father and then computing the average of their
    first-term, second-term, and final grades. The code that does the grouping and
    average computation are as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的另一个有趣部分是根据母亲和父亲的教育对学生进行分组，然后计算他们的第一学期、第二学期和期末成绩的平均值。进行分组和平均计算的代码如下：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding code does the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: It creates a stream from `List<Student>`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从`List<Student>`创建了一个流。
- en: It reduces this stream to the required grouping by using the `collect()` method.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`collect()`方法将此流减少到所需的分组。
- en: One of the overloaded versions of `collect()` takes two parameters. The first
    one is the function that returns the value on which the students need to be grouped.
    The second parameter is an additional mapping function, which maps the grouped
    student object into the required format. In our case, the required format is to
    get `IntSummaryStatistics` for the group of students on any of their grade values.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect()`的重载版本之一需要两个参数。第一个是返回学生需要分组的值的函数。第二个参数是一个额外的映射函数，将分组的学生对象映射为所需的格式。在我们的情况下，所需的格式是对任何一个成绩值的学生组获取`IntSummaryStatistics`。'
- en: The preceding two pieces (setting up the data for a bar chart and creating the
    required objects to populate a `BarChart` instance) are important parts of the
    recipe; understanding them will give you a clearer picture of the recipe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 设置条形图的数据和创建所需的对象以填充`BarChart`实例是本示例的重要部分；了解它们将使您对示例有更清晰的认识。
- en: Creating a pie chart
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建饼图
- en: 'Pie charts, as the name suggests, are circular charts with slices (either joined
    or separated), where each slice and its size indicates the magnitude of the item
    that the slice represents. Pie charts are used to compare the magnitudes of different
    classes, categories, products, and the like. This is how a sample pie chart looks:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图，顾名思义，是带有切片（连接或分离）的圆形图表，其中每个切片及其大小表示切片代表的项目的大小。饼图用于比较不同类别、产品等的大小。这是一个示例饼图的样子：
- en: '![](img/e42a09ae-bc16-4a33-909c-6c55a4522f70.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e42a09ae-bc16-4a33-909c-6c55a4522f70.png)'
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) [and
    include the JARs present in the SDK's `lib` folder on the modular path using the
    `-p` option, as shown here:](https://gluonhq.com/products/javafx/)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道从Oracle JDK 11开始和Open JDK 10开始，JavaFX库不会随JDK安装一起提供，因此我们将不得不从[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中存在的JAR包含在模块路径中，如下所示：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will make use of the same student data (taken from the machine learning repository and
    processed at our end) that we had discussed in the recipe, *Creating a bar chart*
    recipe. For this, we have created a module, `student.processor`, which will read
    the student data and provide us with a list of `Student` objects. The source code
    for the module can be found at `Chapter16/101_student_data_processor`. We have
    provided the modular jar for the `student.processor` module at `Chapter16/5_pie_charts/mlib`
    of this recipe's code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的学生数据（从机器学习存储库中获取并在我们这里处理）来创建饼图，这是我们在*创建条形图*示例中讨论过的。为此，我们创建了一个名为`student.processor`的模块，它将读取学生数据并为我们提供`Student`对象的列表。模块的源代码可以在`Chapter16/101_student_data_processor`找到。我们已经在本示例代码的`Chapter16/5_pie_charts/mlib`中提供了`student.processor`模块的模块化jar。
- en: We recommend you to build the `student.processor` modular jar from the source
    available in `Chapter16/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform and then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您从`Chapter16/101_student_data_processor`中提供的源代码构建`student.processor`模块化jar。我们提供了`build-jar.bat`和`build-jar.sh`脚本来帮助您构建jar。您只需运行与您的平台相关的脚本，然后将构建的jar复制到`101_student_data_processor/mlib`中的`4_bar_charts/mlib`。
- en: How to do it...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s first create and configure `GridPane` to hold our pie charts:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建和配置`GridPane`来容纳我们的饼图：
- en: '[PRE71]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create an instance of `StudentDataProcessor` (which comes from the `student.processor` module)
    and use it to load `List` of `Student`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`StudentDataProcessor`的实例（来自`student.processor`模块）并使用它加载`Student`的`List`：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now we need to get the count of students by their mothers'' and fathers'' professions.
    We will write a method that will take a list of students and a classifier, that
    is, the function that returns the value on which the students need to be grouped.
    The method returns an instance of `PieChart`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要按照他们母亲和父亲的职业来统计学生的数量。我们将编写一个方法，该方法将接受学生列表和分类器，即返回学生需要分组的值的函数。该方法返回`PieChart`的实例：
- en: '[PRE73]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We will invoke the preceding method twice—one with the mother''s occupation
    as the classifier and the other with the father''s occupation as the classifier.
    We then add the returned `PieChart` instance to `gridPane`. This should be done
    from within the `start()` method:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用前面的方法两次，一次以母亲的职业作为分类器，另一次以父亲的职业作为分类器。然后将返回的`PieChart`实例添加到`gridPane`中。这应该在`start()`方法中完成：
- en: '[PRE74]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The next step is to create the scene graph using `gridPane` and add it to `Stage`:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`gridPane`创建场景图并将其添加到`Stage`：
- en: '[PRE75]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The UI can be launched from the main method by invoking the `Application.launch`
    method:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过调用`Application.launch`方法从主方法启动UI：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The complete code can be found at `Chapter16/5_pie_charts`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/5_pie_charts`找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/5_pie_charts`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个运行脚本，`run.bat`和`run.sh`，位于`Chapter16/5_pie_charts`下。`run.bat`脚本用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/4fcb686c-5890-47b5-8e73-05d663f16210.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fcb686c-5890-47b5-8e73-05d663f16210.png)'
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The most important method which does all the work in this recipe is `getStudentCountByOccupation()`.
    It does the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，完成所有工作的最重要的方法是`getStudentCountByOccupation()`。它执行以下操作：
- en: 'It groups the number of students by profession. This can be done in a single
    line of code using the power of the new streaming APIs (added as part of Java
    8):'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它按职业对学生人数进行分组。这可以通过使用新的流式API的强大功能（作为Java 8的一部分添加）来完成一行代码：
- en: '[PRE77]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Build data required for `PieChart`. The `PieChart` instance''s data is `ObservableList`
    of `PieChart.Data`. We first make use of `Map` obtained in the preceding step
    to create `ArrayList` of `PieChart.Data`. Then, we use the `FXCollections.observableList()`
    API to obtain `ObservableList<PieChart.Data>` from `List<PieChart.Data>`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PieChart`所需的数据。`PieChart`实例的数据是`ObservableList`的`PieChart.Data`。我们首先利用前面步骤中获得的`Map`来创建`ArrayList`的`PieChart.Data`。然后，我们使用`FXCollections.observableList()`API从`List<PieChart.Data>`中获取`ObservableList<PieChart.Data>`：
- en: '[PRE78]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The other important thing in the recipe is the classifiers we use: `Student::getMotherJob`
    and `Student::getFatherJob`. These are the two method references that invoke the `getMotherJob`
    and `getFatherJob` methods on the different instances of `Student` in the list
    of `Student`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例中的另一个重要事项是我们使用的分类器：`Student::getMotherJob`和`Student::getFatherJob`。这是两个方法引用，它们在`Student`列表中的不同实例上调用`getMotherJob`和`getFatherJob`方法。
- en: Once we get the `PieChart` instances, we add them to `GridPane` and then construct
    the scene graph using `GridPane`. The scene graph has to be associated with `Stage`
    for it to be rendered on the screen.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了`PieChart`实例，我们将把它们添加到`GridPane`中，然后使用`GridPane`构建场景图。场景图必须与`Stage`相关联，才能在屏幕上呈现。
- en: The main method launches the UI by invoking the `Application.launch(args);`
    method.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法通过调用`Application.launch(args);`方法启动UI。
- en: 'JavaFX provides APIs for creating different types of charts, such as the following
    ones:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了用于创建不同类型图表的API，例如以下类型：
- en: Area charts
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域图
- en: Bubble charts
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡图
- en: Line charts
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折线图
- en: Scatter charts
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: 'All of these charts are *x* and *y* axis-based charts and can be constructed
    like a bar chart. We have provided some sample implementations to create these
    types of charts, and they can be found at these locations: `Chapter16/5_2_area_charts`,
    `Chapter16/5_3_line_charts`, `Chapter16/5_4_bubble_charts`, and `Chapter16/5_5_scatter_charts`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些图表都是基于*x*和*y*轴的图表，可以像条形图一样构建。我们提供了一些示例实现来创建这些类型的图表，它们可以在这些位置找到：`Chapter16/5_2_area_charts`，`Chapter16/5_3_line_charts`，`Chapter16/5_4_bubble_charts`和`Chapter16/5_5_scatter_charts`。
- en: Embedding HTML in an application
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入HTML
- en: JavaFX provides support for managing web pages via the classes defined in the `javafx.scene.web`
    package. It supports loading the web page, either by accepting the web page URL
    or by accepting the web page content. It also manages the document model of the
    web page, applies the relevant CSS, and runs the relevant JavaScript code. It
    also extends support for a two-way communication between JavaScript and the Java
    code.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了通过`javafx.scene.web`包中定义的类来管理网页的支持。它支持加载网页，可以通过接受网页URL或接受网页内容来实现。它还管理网页的文档模型，应用相关的CSS，并运行相关的JavaScript代码。它还扩展了JavaScript和Java代码之间的双向通信支持。
- en: 'In this recipe, we will build a very primitive and simple web browser that
    supports the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个非常原始和简单的支持以下功能的网络浏览器：
- en: Navigating through the history of the pages visited
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览访问过的页面的历史记录
- en: Reloading the current page
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载当前页面
- en: An address bar for accepting the URL
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于接受URL的地址栏
- en: A button for loading the entered URL
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于加载输入的URL的按钮
- en: Showing the web page
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示网页
- en: Showing the status of loading of the web page
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示网页加载状态
- en: Getting ready
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道JavaFX库从Oracle JDK 11开始和Open JDK 10开始不再随JDK安装而来，我们将不得不从这里[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包包含在模块路径中，如下所示：
- en: '[PRE79]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We will require an internet connection to test the loading of pages. So, make
    sure you are connected to the internet. Apart from this, there is nothing specific
    required to work with this recipe.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个互联网连接来测试页面的加载。因此，请确保您已连接到互联网。除此之外，没有特定的要求来使用这个示例。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个空方法的类，它将代表启动应用程序以及JavaFX UI的主要应用程序：
- en: '[PRE80]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the subsequent steps, we will write all our code within the `start(Stage
    stage)` method.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将在`start(Stage stage)`方法中编写所有的代码。
- en: 'Let''s create a `javafx.scene.web.WebView` component, which will render our
    web page. This has the required `javafx.scene.web.WebEngine` instance, which manages
    the loading of the web page:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`javafx.scene.web.WebView`组件，它将呈现我们的网页。这个组件有必需的`javafx.scene.web.WebEngine`实例，用于管理网页的加载：
- en: '[PRE81]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Get the instance of `javafx.scene.web.WebEngine` used by `webView`. We will
    use this instance of `javafx.scene.web.WebEngine` to navigate through the history
    and load other web pages. Then we will, by default, load the URL, [http://www.google.com](http://www.google.com):'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`webView`使用的`javafx.scene.web.WebEngine`实例。我们将使用这个`javafx.scene.web.WebEngine`实例来浏览历史记录并加载其他网页。然后，我们将默认加载URL，[http://www.google.com](http://www.google.com)：
- en: '[PRE82]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now let''s create a `javafx.scene.control.TextField` component, which will
    act as our browser''s address bar:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`javafx.scene.control.TextField`组件，它将充当我们浏览器的地址栏：
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We want to change the title of the browser and the web page in the address
    bar, based on the title and URL of the completely loaded web page. This can be
    done by listening to the change in the `stateProperty` of `javafx.concurrent.Worker`
    obtained from the `javafx.scene.web.WebEngine` instance:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望根据完全加载的网页的标题和URL来更改浏览器和地址栏中的网页标题。这可以通过监听从`javafx.scene.web.WebEngine`实例获取的`javafx.concurrent.Worker`的`stateProperty`的更改来实现：
- en: '[PRE84]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will load the web page identified by the URL entered in the address bar:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`javafx.scene.control.Button`实例，点击后将加载地址栏中输入的URL标识的网页：
- en: '[PRE85]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will go to the previous web page in the history. To achieve this, we will execute
    the JavaScript code, `history.back()`, from within the action handler:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`javafx.scene.control.Button`实例，点击后将转到历史记录中的上一个网页。为此，我们将在操作处理程序内执行JavaScript代码`history.back()`：
- en: '[PRE86]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will go to the next entry in the history maintained by `javafx.scene.web.WebEngine`
    instance. For this, we will make use of the `javafx.scene.web.WebHistory` API:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`javafx.scene.control.Button`实例，点击后将转到`javafx.scene.web.WebEngine`实例维护的历史记录中的下一个条目。为此，我们将使用`javafx.scene.web.WebHistory`
    API：
- en: '[PRE87]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next is the button for reloading the current page. Again, we will make use
    of `javafx.scene.web.WebEngine` to reload the current page:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是重新加载当前页面的按钮。再次，我们将使用`javafx.scene.web.WebEngine`来重新加载当前页面：
- en: '[PRE88]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now we need to group all the components created so far, namely, `prevButton`, `nextButton`,
    `reloadButton`, `webAddress`, and `goButton`, so that they align horizontally
    with one another. To achieve this, we will make use of `javafx.scene.layout.HBox`
    with relevant spacing and padding to make the components look well spaced:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将迄今为止创建的所有组件，即`prevButton`、`nextButton`、`reloadButton`、`webAddress`和`goButton`分组，以使它们在水平方向上对齐。为此，我们将使用`javafx.scene.layout.HBox`，并设置相关间距和填充，使组件看起来间距均匀：
- en: '[PRE89]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We would want to know whether the web page is loading and whether it has finished.
    Let''s create a `javafx.scene.layout.Label` field to update the status if the
    web page is loaded. Then, we listen to the updates to `workDoneProperty` of the
    `javafx.concurrent.Worker` instance, which we can get from the `javafx.scene.web.WebEngine`
    instance:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想知道网页是否正在加载以及是否已经完成。让我们创建一个`javafx.scene.layout.Label`字段来更新网页加载状态。然后，我们监听`javafx.scene.web.WebEngine`实例的`workDoneProperty`的更新，这可以从`javafx.concurrent.Worker`实例中获取：
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s align the entire address bar (with its navigation buttons), `webView`,
    and `websiteLoadingStatus` vertically:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们垂直对齐整个地址栏（及其导航按钮）、`webView`和`websiteLoadingStatus`：
- en: '[PRE91]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a new `Scene` object with the `VBox` instance created in the preceding
    step as the root:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在前一步中创建的`VBox`实例作为根创建一个新的`Scene`对象：
- en: '[PRE92]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We want the `javafx.stage.Stage` instance to occupy the complete screen size;
    for this, we will make use of `Screen.getPrimary().getVisualBounds()`. Then, as
    usual, we will render the scene graph on the stage:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`javafx.stage.Stage`实例占据整个屏幕大小；为此，我们将使用`Screen.getPrimary().getVisualBounds()`。然后，像往常一样，我们将在舞台上呈现场景图：
- en: '[PRE93]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The complete code can be found at the location, `Chapter16/6_embed_html`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/6_embed_html`位置找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/6_embed_html`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter16/6_embed_html`下提供了两个运行脚本，`run.bat`和`run.sh`。`run.bat`脚本用于在Windows上运行应用程序，`run.sh`用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/be7f6c16-0275-4ca8-99b7-b11ec644d75d.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be7f6c16-0275-4ca8-99b7-b11ec644d75d.png)'
- en: How it works...
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The web-related APIs are available in the `javafx.web` module, so we will have
    to require it in `module-info`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web相关的API可在`javafx.web`模块中使用，因此我们需要在`module-info`中声明它：
- en: '[PRE94]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The following are the important classes in the `javafx.scene.` web package
    when dealing with web pages in JavaFX:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在处理JavaFX中的网页时`javafx.scene.` web包中的重要类：
- en: '`WebView`: This UI component uses `WebEngine` to manage the loading, rendering,
    and interaction with the web page.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebView`：此UI组件使用`WebEngine`来管理加载、渲染和与网页的交互。'
- en: '`WebEngine`: This is the main component that deals with loading and managing
    the web page.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebEngine`：这是处理加载和管理网页的主要组件。'
- en: '`WebHistory`: This records the web pages visited in the current `WebEngine`
    instance.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebHistory`：记录当前`WebEngine`实例中访问的网页。'
- en: '`WebEvent`: These are the instances passed to the event handlers of `WebEngine` invoked
    by the JavaScript event.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebEvent`：这些是传递给由JavaScript事件调用的`WebEngine`事件处理程序的实例。'
- en: In our recipe, we make use of the first three classes.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了前三个类。
- en: We don't directly create an instance of `WebEngine`; instead, we make use of
    `WebView` to get a reference to the `WebEngine` instance managed by it. The `WebEngine` instance
    loads the web page asynchronously by submitting the task of loading the page to
    `javafx.concurrent.Worker` instances. Then, we register change listeners on these
    worker instance properties to track the progress of loading the web page. We have
    made use of two such properties in this recipe, namely, `stateProperty` and `workDoneProperty`.
    The former tracks the change of the state of the worker, and the latter tracks
    the percentage of the work done.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接创建`WebEngine`的实例；相反，我们利用`WebView`来获取由其管理的`WebEngine`实例的引用。`WebEngine`实例通过将加载页面的任务提交给`javafx.concurrent.Worker`实例来异步加载网页。然后，我们在这些worker实例属性上注册更改侦听器，以跟踪加载网页的进度。在这个示例中，我们使用了两个这样的属性，即`stateProperty`和`workDoneProperty`。前者跟踪worker状态的更改，后者跟踪工作完成的百分比。
- en: 'A worker can go through the following states (as listed in the `javafx.concurrent.Worker.State`
    enum):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Worker可以经历以下状态（如列在`javafx.concurrent.Worker.State`枚举中）：
- en: '`CANCELLED`'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`取消`'
- en: '`FAILED`'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`失败`'
- en: '`READY`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`准备就绪`'
- en: '`RUNNING`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行中`'
- en: '`SCHEDULED`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已安排`'
- en: '`SUCCEEDED`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`成功`'
- en: In our recipe, we are only checking for `SUCCEEDED`, but you can enhance it
    to check for `FAILED` as well. This will help us report invalid URLs or even get
    the message from the event object and show it to the user.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的教程中，我们只检查`SUCCEEDED`，但您也可以增强它以检查`FAILED`。这将帮助我们报告无效的URL，甚至从事件对象中获取消息并显示给用户。
- en: 'The way we add the listeners to track the change in the properties is by using
    the `addListener()` method on `*Property()`, where `*` can be `state`, `workDone`,
    or any other attribute of the worker that has been exposed as a property:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加监听器以跟踪属性变化的方式是使用`*Property()`上的`addListener()`方法，其中`*`可以是`state`、`workDone`或工作器的任何其他属性，这些属性已公开为属性：
- en: '[PRE95]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then the `javafx.scene.web.WebEngine` component also supports the following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`javafx.scene.web.WebEngine`组件还支持以下功能：
- en: Reloading the current page
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载当前页面
- en: Getting the history of the pages loaded by it
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取加载的页面的历史记录
- en: Executing the JavaScript code
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: Listening to JavaScript properties, such as showing an alert box or a confirmation
    box
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听JavaScript属性，例如显示警报框或确认框
- en: Interacting with the document model of the web page using the `getDocument()`
    method
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getDocument()`方法与网页的文档模型进行交互
- en: 'In this recipe, we also looked at using `WebHistory` obtained from `WebEngine`.
    `WebHistory` stores the web pages loaded by the given `WebEngine` instance, which
    means one `WebEngine` instance will have one `WebHistory` instance. `WebHistory`
    supports the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们还介绍了从`WebEngine`获取的`WebHistory`的使用。`WebHistory`存储了给定`WebEngine`实例加载的网页，这意味着一个`WebEngine`实例将有一个`WebHistory`实例。`WebHistory`支持以下功能：
- en: Getting the list of entries by using the `getEntries()` method. This will also
    get us the number of entries in the history. This is required while navigating
    forward and backward in history; otherwise, we will end up with an index out of
    bounds exception.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getEntries()`方法获取条目列表。这也将为我们获取历史记录中的条目数。这在导航历史记录时是必需的；否则，我们将遇到索引越界异常。
- en: Getting `currentIndex`, that is, its index within the `getEntries()` list.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取`currentIndex`，即其在`getEntries()`列表中的索引。
- en: Navigating to the specific entry in the entries list of `WebHistory`. This can
    be achieved by using the `go()` method, which accepts an offset. This offset indicates
    which web page to load, relative to the current position. For example, *+1* indicates
    the next entry, and *-1* indicates the previous entry. It's important to check
    for the boundary conditions; otherwise, you will end up going before *0*, that
    is, *-1*, or going past the entry list size.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到`WebHistory`的条目列表中的特定条目。这可以通过使用`go()`方法实现，该方法接受一个偏移量。该偏移量指示要加载的网页相对于当前位置。例如，*+1*表示下一个条目，*-1*表示上一个条目。检查边界条件很重要；否则，您将会在*0*之前，即*-1*之前，或者超出条目列表大小。
- en: There's more...
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we showed you a basic approach to creating a web browser, using
    the support provided by JavaFX. You can enhance this to support the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们向您展示了使用JavaFX提供的支持来创建一个基本的Web浏览器的方法。您可以增强它以支持以下功能：
- en: Better error handling and user messages, that is, to show whether the web address
    is valid by tracking the state change of the worker
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的错误处理和用户消息，即通过跟踪工作器的状态变化来显示网址是否有效
- en: Multiple tabs
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个标签页
- en: Bookmarking
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书签
- en: Storing the state of the browser locally so that the next time it is run it
    loads all the bookmarks and the history
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将浏览器的状态存储在本地，以便下次运行时加载所有书签和历史记录。
- en: Embedding media in an application
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中嵌入媒体
- en: JavaFX provides a component, `javafx.scene.media.MediaView`, for viewing videos
    and listening to audios. This component is backed by a media engine, `javafx.scene.media.MediaPlayer`,
    which loads and manages the playback of the media.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了一个组件`javafx.scene.media.MediaView`，用于查看视频和听音频。该组件由一个媒体引擎`javafx.scene.media.MediaPlayer`支持，该引擎加载和管理媒体的播放。
- en: In this recipe, we will look at playing a sample video and controlling its playback
    by using the methods on the media engine.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何播放一个示例视频，并通过使用媒体引擎上的方法来控制其播放。
- en: Getting ready
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option shown here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道JavaFX库从Oracle JDK 11开始和Open JDK 10开始不再随JDK安装，我们将不得不从这里[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包包含在模块路径上，如下所示：
- en: '[PRE96]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We will make use of the sample video available at `Chapter16/7_embed_audio_video/sample_video1.mp4`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于`Chapter16/7_embed_audio_video/sample_video1.mp4`的示例视频。
- en: How to do it...
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个带有空方法的类，该类将代表启动应用程序以及JavaFX UI的主要应用程序：
- en: '[PRE97]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create a `javafx.scene.media.Media` object for the video located at `Chapter16/7_embed_audio_video/sample_video1.mp4`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为位于`Chapter16/7_embed_audio_video/sample_video1.mp4`的视频创建一个`javafx.scene.media.Media`对象：
- en: '[PRE98]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a new media engine,  `javafx.scene.media.MediaPlayer`, using the `javafx.scene.media.Media`
    object created in the previous step:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步创建的`javafx.scene.media.Media`对象创建一个新的媒体引擎`javafx.scene.media.MediaPlayer`：
- en: '[PRE99]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s track the status of the media player by registering a change listener
    on `statusProperty` of the `javafx.scene.media.MediaPlayer` object:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`javafx.scene.media.MediaPlayer`对象的`statusProperty`上注册更改监听器来跟踪媒体播放器的状态：
- en: '[PRE100]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s now create a media viewer using the media engine created in the previous
    step:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用上一步创建的媒体引擎来创建一个媒体查看器：
- en: '[PRE101]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We will restrict the width and height of the media viewer:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将限制媒体查看器的宽度和高度：
- en: '[PRE102]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we create three buttons to pause the video playback, resume the playback,
    and stop the playback. We will make use of the relevant methods in the `javafx.scene.media.MediaPlayer`
    class:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建三个按钮来暂停视频播放、恢复播放和停止播放。我们将使用`javafx.scene.media.MediaPlayer`类中的相关方法：
- en: '[PRE103]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Align all these buttons horizontally using `javafx.scene.layout.HBox`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.layout.HBox`水平对齐所有这些按钮：
- en: '[PRE104]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Align the media viewer and the buttons bar vertically using `javafx.scene.layout.VBox`:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.layout.VBox`垂直对齐媒体查看器和按钮栏：
- en: '[PRE105]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create a new scene graph using the `VBox` object as the root and set it to
    the stage object:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VBox`对象创建一个新的场景图，并将其设置为舞台对象：
- en: '[PRE106]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Render the stage on the display:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示器上呈现舞台：
- en: '[PRE107]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The complete code can be found at `Chapter16/7_embed_audio_video`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/7_embed_audio_video`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/7_embed_audio_video`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个运行脚本，`run.bat`和`run.sh`，位于`Chapter16/7_embed_audio_video`下。`run.bat`脚本将用于在Windows上运行应用程序，`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/ba1e14aa-5eca-4fd3-b6f1-eea3e18edad4.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba1e14aa-5eca-4fd3-b6f1-eea3e18edad4.png)'
- en: How it works...
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The important classes, in the `javafx.scene.media` package for media playback
    are the following:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 用于媒体播放的`javafx.scene.media`包中的重要类如下：
- en: '`Media`: This represents the source of the media, that is, either video or
    audio. This accepts the source in the form of HTTP/HTTPS/FILE and JAR URLs.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Media`：表示媒体的来源，即视频或音频。这以HTTP/HTTPS/FILE和JAR URL的形式接受来源。'
- en: '`MediaPlayer`: This manages the playback of the media.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaPlayer`：管理媒体的播放。'
- en: '`MediaView`: This is the UI component that allows viewing the media.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaView`：这是允许查看媒体的UI组件。'
- en: 'There are a few other classes, but we haven''t covered them in this recipe.
    The media-related classes are in the `javafx.media` module. So, do not forget
    to require a dependency on it, as shown here:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他类，但我们在本示例中没有涵盖它们。与媒体相关的类位于`javafx.media`模块中。因此，请不要忘记在此处声明对其的依赖关系：
- en: '[PRE108]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In this recipe, we have a sample video at `Chapter16/7_embed_audio_video/sample_video1.mp4`,
    and we make use of the `java.io.File` API to build `File` URL to locate the video:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们有一个位于`Chapter16/7_embed_audio_video/sample_video1.mp4`的示例视频，并且我们使用`java.io.File`
    API来构建`File` URL以定位视频：
- en: '[PRE109]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The media playback is managed by using the API exposed by the `javafx.scene.media.MediaPlayer`
    class. In this recipe, we made use of a few of its methods, namely `play()`, `pause()`,
    and `stop()`. The `javafx.scene.media.MediaPlayer` class is initialized by using
    the `javafx.scene.media.Media` object:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`javafx.scene.media.MediaPlayer`类公开的API管理媒体播放。在本示例中，我们使用了其中的一些方法，即`play()`、`pause()`和`stop()`。`javafx.scene.media.MediaPlayer`类通过使用`javafx.scene.media.Media`对象进行初始化：
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Rendering the media on the UI is managed by the `javafx.scene.media.MediaView` class,
    and it is backed by a `javafx.scene.media.MediaPlayer` object:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI上呈现媒体由`javafx.scene.media.MediaView`类管理，它由`javafx.scene.media.MediaPlayer`对象支持：
- en: '[PRE111]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We can set the height and width of the viewer by using the `setFitWidth()` and
    `setFitHeight()` methods.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`setFitWidth()`和`setFitHeight()`方法设置查看器的高度和宽度。
- en: There's more...
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We gave a basic demo of media support in JavaFX. There's a lot more to explore.
    You can add volume control options, options to seek forward or backward, play
    audios, and audio equalizer.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaFX中提供了媒体支持的基本演示。还有很多可以探索的地方。您可以添加音量控制选项，向前或向后搜索选项，播放音频和音频均衡器。
- en: Adding effects to controls
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向控件添加效果
- en: Adding effects in a controlled way gives a good appearance to the user interface.
    There are multiple effects such as blurring, shadows, reflection, blooming, and
    so on. JavaFX provides a set of classes under the `javafx.scene.effects` package,
    which can be used to add effects to enhance the look of the application. This
    package is available in the `javafx.graphics` module.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以受控方式添加效果可以使用户界面看起来更好。有多种效果，如模糊、阴影、反射、绽放等。JavaFX提供了一组类，位于`javafx.scene.effects`包下，可用于添加效果以增强应用程序的外观。此包在`javafx.graphics`模块中可用。
- en: In this recipe, we will look at a few effects—blur, shadow, and reflection.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将查看一些效果——模糊、阴影和反射。
- en: Getting ready
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option shown as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道JavaFX库从Oracle JDK 11开始和Open JDK 10开始不再随JDK安装一起提供，因此我们必须从此处[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包包含在模块路径上，如下所示：
- en: '[PRE112]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How to do it...
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个带有空方法的类，该类将代表启动应用程序以及JavaFX UI的主要应用程序：
- en: '[PRE113]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The subsequent code will be written within the `start(Stage stage)` method.
    Create and configure `javafx.scene.layout.GridPane`:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后的代码将在`start(Stage stage)`方法中编写。创建并配置`javafx.scene.layout.GridPane`：
- en: '[PRE114]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Create rectangles required for applying the blur effects:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建矩形，用于应用模糊效果：
- en: '[PRE115]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add `javafx.scene.effect.BoxBlur` to `Rectangle r1`, `javafx.scene.effect.MotionBlur`
    to `Rectangle r2`, and `javafx.scene.effect.GaussianBlur` to `Rectangle r3`:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`javafx.scene.effect.BoxBlur`添加到`Rectangle r1`，将`javafx.scene.effect.MotionBlur`添加到`Rectangle
    r2`，将`javafx.scene.effect.GaussianBlur`添加到`Rectangle r3`：
- en: '[PRE116]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Add the rectangles to `gridPane`:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩形添加到`gridPane`：
- en: '[PRE117]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create three circles, required for applying shadows:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个圆，用于应用阴影：
- en: '[PRE118]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Add `javafx.scene.effect.DropShadow` to `c1` and `javafx.scene.effect.InnerShadow`
    to `c2`:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`javafx.scene.effect.DropShadow`添加到`c1`，将`javafx.scene.effect.InnerShadow`添加到`c2`：
- en: '[PRE119]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Add these circles to `gridPane`:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些圆添加到`gridPane`：
- en: '[PRE120]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create a simple text, `Reflection Sample`, on which we will apply the reflection
    effect:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将应用反射效果的简单文本“Reflection Sample”上：
- en: '[PRE121]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create a `javafx.scene.effect.Reflection` effect and add it to the text:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`javafx.scene.effect.Reflection`效果并将其添加到文本中：
- en: '[PRE122]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Add the text component to `gridPane`:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本组件添加到`gridPane`：
- en: '[PRE123]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create a scene graph using `gridPane` as the root node:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gridPane`作为根节点创建一个场景图形：
- en: '[PRE124]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Set the scene graph to the stage and render it on the display:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景图形设置为舞台并在显示器上呈现它：
- en: '[PRE125]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The complete code can be found at `Chapter16/8_effects_demo`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/8_effects_demo`中找到。
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/8_effects_demo`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个运行脚本，`Chapter16/8_effects_demo`下的`run.bat`和`run.sh`。`run.bat`脚本将用于在Windows上运行应用程序，`run.sh`将用于在Linux上运行应用程序。
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run.bat`或`run.sh`运行应用程序，您将看到以下GUI：
- en: '![](img/b86be218-5d25-4a77-ae37-be9a25ee8b56.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b86be218-5d25-4a77-ae37-be9a25ee8b56.png)'
- en: How it works...
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have made use of the following effects:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了以下效果：
- en: '`javafx.scene.effect.BoxBlur`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.BoxBlur`'
- en: '`javafx.scene.effect.MotionBlur`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.MotionBlur`'
- en: '`javafx.scene.effect.GaussianBlur`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.GaussianBlur`'
- en: '`javafx.scene.effect.DropShadow`'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.DropShadow`'
- en: '`javafx.scene.effect.InnerShadow`'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.InnerShadow`'
- en: '`javafx.scene.effect.Reflection`'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javafx.scene.effect.Reflection`'
- en: 'The `BoxBlur` effect is created by specifying the width and height of the blur
    effect, and also the number of times the effect needs to be applied:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定模糊效果的宽度和高度以及需要应用效果的次数来创建`BoxBlur`效果：
- en: '[PRE126]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `MotionBlur` effect is created by providing the angle of the blur and its
    radius. This gives an effect of something captured while in motion:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供模糊的角度和半径来创建`MotionBlur`效果。这会产生一种在运动中捕获到的效果：
- en: '[PRE127]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `GaussianBlur` effect is created by providing the radius of the effect,
    and the effect uses the Gaussian formula to apply the effect:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供效果的半径来创建`GaussianBlur`效果，并且该效果使用高斯公式来应用效果：
- en: '[PRE128]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`DropShadow` adds the shadow behind the object, whereas `InnerShadow` adds
    the shadow within the object. Each of these takes the radius of the shadow, the
    *x* and *y* location of the start of the shadow, and the color of the shadow:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`DropShadow`在物体后面添加阴影，而`InnerShadow`在物体内部添加阴影。每个阴影都有阴影的半径，阴影开始的*x*和*y*位置，以及阴影的颜色：'
- en: '[PRE129]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`Reflection` is a pretty simple effect that adds the reflection of the object.
    We can set the fraction of how much of the original object is reflected:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflection`是一个非常简单的效果，它添加了物体的反射。我们可以设置原始物体的反射比例：'
- en: '[PRE130]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: There's more...
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are quite a few more effects:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他效果：
- en: The blend effect, which blends two different inputs with a predefined blending
    approach
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合效果，将两个不同的输入与预定义的混合方法混合
- en: The bloom effect, which makes the brighter portions appear brighter
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波纹效果，使更亮的部分看起来更亮。
- en: The glow effect, which makes the object glow
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发光效果，使物体发光
- en: The lighting effect, which simulates a light source on the object, thereby giving
    it a 3D appearance.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照效果模拟了物体上的光源，从而使其呈现出3D外观。
- en: We would recommend that you try out these effects in the same way as we have
    tried them out.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您尝试以与我们尝试的方式相同的方式尝试这些效果。
- en: Using the Robot API
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Robot API
- en: '**Robot API** is used to simulate keyboard and mouse actions on the screen,
    which means you would instruct the code to type some text in the text field, choose
    an option, and then click on a button. People coming from the Web UI-testing background
    can relate this to the Selenium Testing Library. **Abstract Window Toolkit** (**AWT**),
    which is an older windowing toolkit in JDK, provides Robot API, but using the
    same API on JavaFX is not straightforward and requires some hacks. The JavaFX
    window toolkit called **Glass** has its own Robot APIs ([https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html)),
    but these are not public. So, as part of the OpenJFX 11 release, new public APIs
    were introduced for the same.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**Robot API**用于模拟屏幕上的键盘和鼠标操作，这意味着您会指示代码在文本字段中输入一些文本，选择一个选项，然后单击一个按钮。来自Web UI测试背景的人可以将其与Selenium测试库联系起来。**抽象窗口工具包**（**AWT**）是JDK中的一个较旧的窗口工具包，提供了Robot
    API，但在JavaFX上使用相同的API并不直接，需要一些技巧。JavaFX窗口工具包称为**Glass**有自己的Robot API（[https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html)），但这些API不是公开的。因此，在OpenJFX
    11发布的一部分中，为其引入了新的公共API。'
- en: In this recipe, we will look at using the Robot API to simulate some actions
    on JavaFX UI.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Robot API来模拟一些JavaFX UI上的操作。
- en: Getting ready
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here ([https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/))
    and include the JARs present in the SDK''s `lib` folder on the modular path, using
    the `-p` option, shown as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道JavaFX库从Oracle JDK 11开始和Open JDK 10开始不再随JDK安装一起提供，因此我们必须从这里（[https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/)）下载JavaFX
    SDK，并使用`-p`选项将SDK的`lib`文件夹中的JAR包含在模块路径上，如下所示：
- en: '[PRE131]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In this recipe, we will create a simple application that accepts a name from
    the user and, on clicking a button, prints a message to the user. This entire
    operation will be simulated using the Robot API, and, finally, before exiting
    the application, we will capture the screen using the Robot API.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个简单的应用程序，接受用户的姓名，并在点击按钮时向用户打印一条消息。整个操作将使用Robot API模拟，并且在退出应用程序之前，我们将使用Robot
    API捕获屏幕。
- en: How to do it...
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a simple class, `RobotApplication` that extends `javafx.application.Application`
    and sets up the UI required for testing the Robot API and also creates an instance
    of `javafx.scene.robot.Robot`. This class will be defined as a static inner class
    to the `RobotAPIDemo` main class :'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的类`RobotApplication`，它扩展了`javafx.application.Application`并设置了测试Robot API所需的UI，还创建了一个`javafx.scene.robot.Robot`的实例。这个类将被定义为`RobotAPIDemo`主类的静态内部类：
- en: '[PRE132]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'As the JavaFX UI will be launched in a different JavaFX application thread
    and there will be some delays in rendering the UI completely before we execute
    the commands to interact with the UI, we will make use of `java.util.concurrent.CountDownLatch`
    to indicate different events. To work with `CountDownLatch`, we create a simple
    static helper method with the following definition in the `RobotAPIDemo` class:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于JavaFX UI将在不同的JavaFX应用程序线程中启动，并且在执行与UI交互的命令之前，UI渲染完全需要一些延迟，我们将使用`java.util.concurrent.CountDownLatch`来指示不同的事件。为了使用`CountDownLatch`，我们在`RobotAPIDemo`类中创建了一个简单的静态辅助方法，定义如下：
- en: '[PRE133]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `typeName()` method is the helper method that types the name of the person
    in the text field:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`typeName()`方法是一个辅助方法，用于在文本字段中输入人的姓名：'
- en: '[PRE134]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `clickButton()` method is the helper method; it clicks on the correct button
    to trigger the greeting message display:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clickButton()`方法是一个辅助方法；它点击正确的按钮来触发问候消息的显示：'
- en: '[PRE135]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `captureScreen()` method is the helper method to take a screenshot of the
    application and save it to the filesystem:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`captureScreen()`方法是一个辅助方法，用于对应用程序进行截屏并将其保存到文件系统：'
- en: '[PRE136]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We will bind the launching of the UI and the created helper methods in the
    `main()` method, as follows:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`main()`方法中绑定UI的启动和创建的辅助方法，如下所示：
- en: '[PRE137]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The complete code for this can be found at `Chapter16/9_robot_api`. You can
    run the sample either by using `run.bat` or `run.sh`. Running the application
    will launch the UI, execute the actions, take a screenshot, and exit the app.
    The screenshot will be placed in the folder from which the application was launched,
    and it would follow the naming convention—`screenCapture-yyyy-dd-M-m-H-ss.png`.
    Here is a sample screenshot:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter16/9_robot_api`中找到。您可以通过使用`run.bat`或`run.sh`来运行示例。运行应用程序将启动UI，执行操作，截取屏幕并退出应用程序。截图将放在启动应用程序的文件夹中，并且将遵循命名约定——`screenCapture-yyyy-dd-M-m-H-ss.png`。这是一个示例截图：
- en: '![](img/2e02b304-5a14-4fe8-805f-d3d9265cada7.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e02b304-5a14-4fe8-805f-d3d9265cada7.png)'
- en: How it works...
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As JavaFX application is run in a different thread, we need to ensure that
    the operations of the Robot API are ordered correctly and the actions of the Robot
    API are executed only when the complete UI has been displayed. To ensure this,
    we have made use of `java.util.concurrent.CountDownLatch` to communicate about
    events such as the following ones:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaFX应用程序在不同的线程中运行，我们需要确保Robot API的操作被正确排序，并且只有在完整的UI显示后才执行Robot API的操作。为了确保这一点，我们使用了`java.util.concurrent.CountDownLatch`来通信以下事件：
- en: Complete loading of the UI
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成UI的加载
- en: Completion of the execution of the action defined for the button
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成为按钮定义的操作的执行
- en: 'The communication about the completion of the loading of the UI is achieved
    by using a `CountDownLatch`, as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`CountDownLatch`来通信UI加载的完成，如下所示：
- en: '[PRE138]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `countDown()` method is invoked in the `Stage` event handler when the window
    is shown thereby releasing the latch and triggering the execution of the following
    block of code in the main method:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口显示时，`countDown()`方法在`Stage`事件处理程序中被调用，从而释放锁并触发主方法中以下代码块的执行：
- en: '[PRE139]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The main thread then again gets blocked from waiting for the `btnActionLatch`
    to be released. The `btnActionLatch` is released after the completion of the action
    in the button greeting. Once the `btnActionLatch` is released, the main thread
    continues execution to invoke the `captureScreen()` method.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 然后主线程再次被阻塞，等待`btnActionLatch`被释放。在按钮问候中的操作完成后，`btnActionLatch`被释放。一旦`btnActionLatch`被释放，主线程继续执行以调用`captureScreen()`方法。
- en: 'Let''s discuss some of the methods we have used from the `javafx.scene.robot.Robot`
    class:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些我们从`javafx.scene.robot.Robot`类中使用的方法：
- en: '`mouseMove()`: This method is used to move the mouse cursor to a given location
    identified from its *x* and *y* co-ordinates. We have used the following line
    of code to get the bounds of the component:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseMove()`：此方法用于将鼠标光标移动到从其*x*和*y*坐标标识的给定位置。我们使用以下代码行来获取组件的边界：'
- en: '[PRE140]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The bounds of a component contain the following:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的边界包括以下内容：
- en: The upper-left *x* and *y* coordinates
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左上角的*x*和*y*坐标
- en: The lower-right *x* and *y* coordinates
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右下角的*x*和*y*坐标
- en: The width and the height of the component
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的宽度和高度
- en: 'So, for our Robot API use case, we make use of the upper-left *x* and *y* coordinates,
    shown as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的Robot API用例，我们使用左上角的*x*和*y*坐标，如下所示：
- en: '[PRE141]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`mouseClick()`: This method is used to click the buttons on the mouse. The
    mouse buttons are identified by the following `enums` in `javafx.scene.input.MouseButton`
    enum:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseClick()`：此方法用于单击鼠标上的按钮。鼠标按钮由`javafx.scene.input.MouseButton`枚举中的以下`enums`标识：'
- en: '`PRIMARY`: Represents the mouse''s left click'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIMARY`：代表鼠标的左键单击'
- en: '`SECONDARY`: Represents the mouse''s right click'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SECONDARY`：代表鼠标的右键单击'
- en: '`MIDDLE`: Represents the mouse''s scroll, or the middle, button.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDDLE`：代表鼠标的滚动或中间按钮。'
- en: 'So, to be able to use `mouseClick()`, we need to move the location of the component
    on which we need to perform the click operation. In our case, as seen in the implementation
    of the method `typeName()`, we move to the location of the text field using `mouseMove()`
    and then invoke the `mouseClick()`, shown as follows:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了能够使用`mouseClick()`，我们需要移动需要执行单击操作的组件的位置。在我们的情况下，如在`typeName()`方法的实现中所示，我们使用`mouseMove()`移动到文本字段的位置，然后调用`mouseClick()`，如下所示：
- en: '[PRE142]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`keyType()`: This method is used to type characters into components that accept
    text input. The characters to be typed are represented by the enums in the `javafx.scene.input.KeyCode`
    enum. In our `typeName()` method implementation, we type the string `Sanaulla`, shown
    as follows:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyType()`: 该方法用于向接受文本输入的组件中输入字符。要输入的字符由`javafx.scene.input.KeyCode`枚举中的枚举表示。在我们的`typeName()`方法实现中，我们输入字符串`Sanaulla`，如下所示：'
- en: '[PRE143]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`getScreenCapture()`: This method is used to take the screenshot of the application.
    The area for capturing the screenshot is determined by the *x* and *y* coordinates
    and the width and the height information passed to the method. The image captured
    is then converted to `java.awt.image.BufferedImage` and saved onto the file system,
    as shown in the following code:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`getScreenCapture()`: 该方法用于对应用程序进行截屏。捕获截屏的区域由传递给该方法的*x*和*y*坐标以及宽度和高度信息确定。然后将捕获的图像转换为`java.awt.image.BufferedImage`并保存到文件系统中，如下面的代码所示：'
- en: '[PRE144]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
