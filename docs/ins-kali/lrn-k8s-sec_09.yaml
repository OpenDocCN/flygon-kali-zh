- en: '*Chapter 7*: Authentication, Authorization, and Admission Control'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：身份验证、授权和准入控制'
- en: Authentication and authorization play a very vital role in securing applications.
    These two terms are often used interchangeably but are very different. Authentication
    validates the identity of a user. Once the identity is validated, authorization
    is used to check whether the user has the privileges to perform the desired action.
    Authentication uses something the user knows to verify their identity; in the
    simplest form, this is a username and password. Once the application verifies
    the user's identity, it checks what resources the user has access to. In most
    cases, this is a variation of an access control list. Access control lists for
    the user are compared with the request attributes to allow or deny an action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权在保护应用程序中起着非常重要的作用。这两个术语经常被交替使用，但它们是非常不同的。身份验证验证用户的身份。一旦身份得到验证，授权就用来检查用户是否有执行所需操作的特权。身份验证使用用户知道的东西来验证他们的身份；在最简单的形式中，这是用户名和密码。一旦应用程序验证了用户的身份，它会检查用户可以访问哪些资源。在大多数情况下，这是访问控制列表的一个变体。用户的访问控制列表与请求属性进行比较，以允许或拒绝操作。
- en: In this chapter, we will discuss how a request is processed by authentication,
    authorization modules, and admission controllers before it is processed by `kube-apiserver`.
    We'll walk through the details of different modules and admission controllers
    and highlight the recommended security configurations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论请求在被`kube-apiserver`处理之前如何经过身份验证、授权模块和准入控制器的处理。我们将详细介绍不同模块和准入控制器的细节，并强调推荐的安全配置。
- en: We will finally look at **Open Policy Agent** (**OPA**), which is an open source
    tool that can be used to implement authorization across microservices. In Kubernetes,
    we will look at how it can be used as a validating admission controller. Many
    clusters require a more granular level of authorization than what is already provided
    by Kubernetes. With OPA, developers can define custom authorization policies that
    can be updated at runtime. There are several open source tools that leverage OPA,
    such as Istio.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍**Open Policy Agent**（**OPA**），这是一个开源工具，可用于在微服务中实现授权。在Kubernetes中，我们将看看它如何作为一个验证准入控制器。许多集群需要比Kubernetes已提供的更细粒度的授权。使用OPA，开发人员可以定义可以在运行时更新的自定义授权策略。有几个利用OPA的开源工具，比如Istio。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Requesting a workflow in Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中请求工作流
- en: Kubernetes authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes身份验证
- en: Kubernetes authorization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes授权
- en: Admission controllers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准入控制器
- en: Introduction to OPA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OPA
- en: Requesting a workflow in Kubernetes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中请求工作流
- en: In Kubernetes, the `kube-apiserver` processes all requests to modify the state
    of the cluster. The `kube-apiserver` first verifies the origin of the request.
    It can use one or more authentication modules, including client certificates,
    passwords, or tokens. The request passes serially from one module to the other.
    If the request is not rejected by all the modules, it is tagged as an anonymous
    request. The API server can be configured to allow anonymous requests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，`kube-apiserver`处理所有修改集群状态的请求。`kube-apiserver`首先验证请求的来源。它可以使用一个或多个身份验证模块，包括客户端证书、密码或令牌。请求依次从一个模块传递到另一个模块。如果请求没有被所有模块拒绝，它将被标记为匿名请求。API服务器可以配置为允许匿名请求。
- en: 'Once the origin of the request is verified, it passes through the authorization
    modules to check whether the origin of the request is permitted to perform the
    action. The authorization modules allow the request if a policy permits the user
    to perform the action. Kubernetes supports multiple authorization modules, such
    as **Attribute-Based Access Control** (**ABAC**), **Role-Based Access Control**
    (**RBAC**), and webhooks. Similar to authentication modules, a cluster can use
    multiple authorizations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求的来源得到验证，它将通过授权模块，检查请求的来源是否被允许执行操作。授权模块允许请求，如果策略允许用户执行操作。Kubernetes支持多个授权模块，如基于属性的访问控制（ABAC）、基于角色的访问控制（RBAC）和webhooks。与认证模块类似，集群可以使用多个授权：
- en: '![Figure 7.1 – Requesting parsing before processing with the kube-apiserver'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 在kube-apiserver处理之前进行请求解析'
- en: '](image/B15566_07_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15566_07_001.jpg)'
- en: Figure 7.1 – Requesting parsing before processing with the kube-apiserver
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 在kube-apiserver处理之前进行请求解析
- en: 'After passing through the authorization and authentication modules, admission
    controllers modify or reject the requests. Admission controllers intercept requests
    that create, update, or delete an object in the admission controller. Admission
    controllers fall into two categories: mutating or validating. Mutating admission
    controllers run first; they modify the requests they admit. Validating admission
    controllers run next. These controllers cannot modify objects. If any of the admission
    controllers reject a request, an error is returned to the user and the request
    will not be processed by the API server.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经过授权和认证模块后，准入控制器修改或拒绝请求。准入控制器拦截创建、更新或删除对象的请求。准入控制器分为两类：变异或验证。变异准入控制器首先运行；它们修改它们承认的请求。接下来运行验证准入控制器。这些控制器不能修改对象。如果任何准入控制器拒绝请求，将向用户返回错误，并且请求将不会被API服务器处理。
- en: Kubernetes authentication
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes认证
- en: 'All requests in Kubernetes originate from external users, service accounts,
    or Kubernetes components. If the origin of the request is unknown, it is treated
    as an anonymous request. Depending on the configuration of the components, anonymous
    requests can be allowed or dropped by the authentication modules. In v1.6+, anonymous
    access is allowed to support anonymous and unauthenticated users for the RBAC
    and ABAC authorization modes. It can be explicitly disabled by passing the `--anonymous-auth=false`
    flag to the API server configuration:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的所有请求都来自外部用户、服务账户或Kubernetes组件。如果请求的来源未知，则被视为匿名请求。根据组件的配置，认证模块可以允许或拒绝匿名请求。在v1.6+中，匿名访问被允许以支持匿名和未经认证的用户，用于RBAC和ABAC授权模式。可以通过向API服务器配置传递`--anonymous-auth=false`标志来明确禁用匿名访问：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Kubernetes uses one or more of these authentication strategies. Let's discuss
    them one by one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用一个或多个这些认证策略。让我们逐一讨论它们。
- en: Client certificates
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端证书
- en: 'Using X509 **Certificate Authority** (**CA**) certificates is the most common
    authentication strategy in Kubernetes. It can be enabled by passing `--client-ca-file=file_path`
    to the server. The file passed to the API server has a list of CAs, which creates
    and validates client certificates in the cluster. The `common name` property in
    the certificate is often used as the username for the request and the `organization`
    property is used to identify the user''s groups:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，使用X509证书颁发机构（CA）证书是最常见的认证策略。可以通过向服务器传递`--client-ca-file=file_path`来启用它。传递给API服务器的文件包含CA的列表，用于在集群中创建和验证客户端证书。证书中的“通用名称”属性通常用作请求的用户名，“组织”属性用于标识用户的组：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create a new certificate, the following steps need to be taken:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新证书，需要执行以下步骤：
- en: 'Generate a private key. A private key can be generated using `openssl`, `easyrsa`,
    or `cfssl`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成私钥。可以使用`openssl`、`easyrsa`或`cfssl`生成私钥：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generate a **Certificate Signing Request** (**CSR**). Using the private key
    and a config file similar to the following generates a CSR. This CSR is for the
    `test` user, which will be part of the `dev` group:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成**证书签名请求**（**CSR**）。使用私钥和类似以下的配置文件生成CSR。此CSR是为`test`用户生成的，该用户将成为`dev`组的一部分：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can generate a CSR using `openssl`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`openssl`生成CSR：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sign the CSR. Create a Kubernetes `CertificateSigningRequest` request using
    the following YAML file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签署CSR。使用以下YAML文件创建一个Kubernetes`CertificateSigningRequest`请求：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The certificate-signing request generated earlier is used with the preceding
    YAML specification to generate a new Kubernetes certificate-signing request:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前生成的证书签名请求与前面的YAML规范一起使用，生成一个新的Kubernetes证书签名请求：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once this request is created, it needs to be approved by the cluster administrators
    to generate the certificate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此请求后，需要由集群管理员批准以生成证书：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Export the CRT. The certificate can be exported using `kubectl`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出CRT。可以使用`kubectl`导出证书：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will look at static tokens, which are a popular mode of authentication
    in development and debugging environments but should not be used in production
    clusters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下静态令牌，这是开发和调试环境中常用的身份验证模式，但不应在生产集群中使用。
- en: Static tokens
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态令牌
- en: The API server uses a static file to read the bearer tokens. This static file
    is passed to the API server using `--token-auth-file=<path>`. The token file is
    a comma-separated file consisting of `secret`, `user`, `uid`, `group1`, and `group2`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器使用静态文件来读取令牌。将此静态文件传递给API服务器使用`--token-auth-file=<path>`。令牌文件是一个逗号分隔的文件，包括`secret`、`user`、`uid`、`group1`和`group2`。
- en: 'The token is passed as an HTTP header in the request:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌作为HTTP标头传递在请求中：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tokens persist indefinitely, and the API server needs to be restarted to
    update the tokens. This is *not* a recommended authentication strategy. These
    tokens can be easily compromised if the attacker is able to spawn a malicious
    pod in a cluster. Once compromised, the only way to generate a new token is to
    restart the API server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌会持久存在，API服务器需要重新启动以更新令牌。这*不*是一种推荐的身份验证策略。如果攻击者能够在集群中生成恶意Pod，这些令牌很容易被破坏。一旦被破坏，生成新令牌的唯一方法是重新启动API服务器。
- en: Next, we will look at basic authentication, a variation of static tokens that
    has been used as a method for authentication by web services for many years.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下基本身份验证，这是静态令牌的一种变体，多年来一直作为Web服务的身份验证方法。
- en: Basic authentication
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: Similar to static tokens, Kubernetes also supports basic authentication. This
    can be enabled by using `basic-auth-file=<path>`. The authentication credentials
    are stored in a CSV file as `password`, `user`, `uid`, `group1`, and `group2`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态令牌类似，Kubernetes还支持基本身份验证。可以通过使用`basic-auth-file=<path>`来启用。认证凭据存储在CSV文件中，包括`password`、`user`、`uid`、`group1`和`group2`。
- en: 'The username and password are passed as an authentication header in the request:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名和密码作为认证标头传递在请求中：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similar to static tokens, basic authentication passwords cannot be changed without
    restarting the API server. Basic authentication should not be used in production
    clusters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态令牌类似，基本身份验证密码无法在不重新启动API服务器的情况下更改。不应在生产集群中使用基本身份验证。
- en: Bootstrap tokens
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导令牌
- en: 'Bootstrap tokens are an improvisation over the static tokens. Bootstrap tokens
    are the default authentication method used in Kubernetes. They are dynamically
    managed and stored as secrets in `kube-system`. To enable bootstrap tokens, do
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 引导令牌是静态令牌的一种改进。引导令牌是Kubernetes中默认使用的身份验证方法。它们是动态管理的，并存储为`kube-system`中的秘密。要启用引导令牌，请执行以下操作：
- en: 'Use `--enable-bootstrap-token-auth` in the API server to enable the bootstrap
    token authenticator:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API服务器中使用`--enable-bootstrap-token-auth`来启用引导令牌验证器：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable `tokencleaner` in the controller manager using the `controller` flag:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`controller`标志在控制器管理器中启用`tokencleaner`：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similar to token authentication, bootstrap tokens are passed as an HTTP header
    in the request:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与令牌身份验证类似，引导令牌作为请求中的HTTP头传递：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first part of the token is the `TokenId` value and the second part of it
    is the `TokenSecret` value. `TokenController` ensures that expired tokens are
    deleted from the system secrets.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的第一部分是`TokenId`值，第二部分是`TokenSecret`值。`TokenController`确保从系统秘密中删除过期的令牌。
- en: Service account tokens
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户令牌
- en: 'The service account authenticator is automatically enabled. It verifies signed
    bearer tokens. The signing key is specified using `--service-account-key-file`.
    If this value is unspecified, the Kube API server''s private key is used:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户验证器会自动启用。它验证签名的持有者令牌。签名密钥是使用`--service-account-key-file`指定的。如果未指定此值，则将使用Kube
    API服务器的私钥：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Service accounts are created by the `kube-apiserver` and are associated with
    the pods. This is similar to instance profiles in AWS. The default service account
    is associated with a pod if no service account is specified.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户由`kube-apiserver`创建，并与pod关联。这类似于AWS中的实例配置文件。如果未指定服务账户，则默认服务账户将与pod关联。
- en: 'To create a service account test, you can use the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为test的服务账户，您可以使用以下命令：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The service account has associated secrets, which includes the CA of the API
    server and a signed token:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户有关联的秘密，其中包括API服务器的CA和签名令牌：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we enumerate the details, we can see the certificate and the token:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们列举细节，我们可以看到证书和令牌：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will talk about webhook tokens. Some enterprises have a remote authentication
    and authorization server, which is often used across all services. In Kubernetes,
    developers can use webhook tokens to leverage the remote services for authentication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论webhook令牌。一些企业拥有远程身份验证和授权服务器，通常在所有服务中使用。在Kubernetes中，开发人员可以使用webhook令牌来利用远程服务进行身份验证。
- en: Webhook tokens
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhook令牌
- en: In webhook mode, Kubernetes makes a call to a REST API outside the cluster to
    determine the user's identity. Webhook mode for authentication can be enabled
    by passing `--authorization-webhook-config-file=<path>` to the API server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在webhook模式下，Kubernetes会调用集群外的REST API来确定用户的身份。可以通过向API服务器传递`--authorization-webhook-config-file=<path>`来启用身份验证的webhook模式。
- en: 'Here is an example of a webhook configuration. In this, [authn.example.com/authenticate](http://authn.example.com/authenticate)
    is used as the authentication endpoint for the Kubernetes cluster:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是webhook配置的示例。在此示例中，[authn.example.com/authenticate](http://authn.example.com/authenticate)用作Kubernetes集群的身份验证端点：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's look at another way that a remote service can be used for authentication.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种远程服务可以用于身份验证的方式。
- en: Authentication proxy
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证代理
- en: '`kube-apiserver` can be configured to identify users using the `X-Remote` request
    header. You can enable this method by adding the following arguments to the API
    server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-apiserver`可以配置为使用`X-Remote`请求头标识用户。您可以通过向API服务器添加以下参数来启用此方法：'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each request has the following headers to identify them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都有以下标头来识别它们：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The API proxy validates the requests using the CA.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: API代理使用CA验证请求。
- en: User impersonation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户冒充
- en: 'Cluster administrators and developers can use user impersonation to debug authentication
    and authorization policies for new users. To use user impersonation, a user must
    be granted impersonation privileges. The API server uses impersonation the following
    headers to impersonate a user:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员和开发人员可以使用用户冒充来调试新用户的身份验证和授权策略。要使用用户冒充，用户必须被授予冒充特权。API服务器使用以下标头来冒充用户：
- en: '`Impersonate-User`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`冒充-用户`'
- en: '`Impersonate-Group`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`冒充-组`'
- en: '`Impersonate-Extra-*`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`冒充-额外-*`'
- en: 'Once the impersonation headers are received by the API server, the API server
    verifies whether the user is authenticated and has the impersonation privileges.
    If yes, the request is executed as the impersonated user. `kubectl` can use the
    `--as` and `--as-group` flags to impersonate a user:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦API服务器接收到冒充标头，API服务器会验证用户是否经过身份验证并具有冒充特权。如果是，则请求将以冒充用户的身份执行。`kubectl`可以使用`--as`和`--as-group`标志来冒充用户：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once the authentication modules verify the identity of a user, they parse the
    request to check whether the user is allowed to access or modify the request.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦身份验证模块验证了用户的身份，它们会解析请求以检查用户是否被允许访问或修改请求。
- en: Kubernetes authorization
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes授权
- en: Authorization determines whether a request is allowed or denied. Once the origin
    of the request is identified, active authorization modules evaluate the attributes
    of the request against the authorization policies of the user to allow or deny
    a request. Each request passes through the authorization module sequentially and
    if any module provides a decision to allow or deny, it is automatically accepted
    or denied.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 授权确定请求是否允许或拒绝。一旦确定请求的来源，活动授权模块会评估请求的属性与用户的授权策略，以允许或拒绝请求。每个请求依次通过授权模块，如果任何模块提供允许或拒绝的决定，它将自动被接受或拒绝。
- en: Request attributes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求属性
- en: 'Authorization modules parse a set of attributes in a request to determine whether
    the request should be parsed, allowed, or denied:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 授权模块解析请求中的一组属性，以确定请求是否应该被解析、允许或拒绝：
- en: '**User**: The originator of the request. This is validated during authentication.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：请求的发起者。这在身份验证期间进行验证。'
- en: '**Group**: The group that the user belongs to. This is provided in the authentication
    layer.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：用户所属的组。这是在身份验证层中提供的。'
- en: '**API**: The destination of the request.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：请求的目的地。'
- en: '**Request verb**: The type of request, which can be `GET`, `CREATE`, `PATCH`,
    `DELETE`, and more.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求动词**：请求的类型，可以是`GET`、`CREATE`、`PATCH`、`DELETE`等。'
- en: '**Resource**: The ID or name of the resource being accessed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：正在访问的资源的ID或名称。'
- en: '**Namespace**: The namespace of the resource being accessed.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：正在访问的资源的命名空间。'
- en: '**Request path**: If the request is for a non-resource endpoint, the path is
    used to check whether the user is allowed to access the endpoint. This is true
    for the `api` and `healthz` endpoints.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求路径**：如果请求是针对非资源端点的，则使用路径来检查用户是否被允许访问端点。这对于`api`和`healthz`端点是正确的。'
- en: Now, let's look at the different authorization modes that use these request
    attributes to determine whether the origin is allowed to initiate the request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用这些请求属性来确定请求发起者是否被允许发起请求的不同授权模式。
- en: Authorization modes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权模式
- en: Let's look at the different authorization modes available in Kubernetes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Kubernetes中可用的不同授权模式。
- en: Node
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: Node authorization mode grants permissions to kubelets to access services, endpoints,
    nodes, pods, secrets, and persistent volumes for a node. The kubelet is identified
    as part of the `system:nodes` group with a username of `system:node:<name>` to
    be authorized by the node authorizer. This mode is enabled by default in Kubernetes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 节点授权模式授予kubelet访问节点的服务、端点、节点、Pod、秘密和持久卷的权限。kubelet被识别为`system:nodes`组的一部分，用户名为`system:node:<name>`，由节点授权者授权。这种模式在Kubernetes中默认启用。
- en: 'The `NodeRestriction` admission controller, which we''ll learn about later
    in this chapter, is used in conjunction with the node authorizer to ensure that
    the kubelet can only modify objects on the node that it is running. The API server
    uses the `--authorization-mode=Node` flag to use the node authorization module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodeRestriction`准入控制器与节点授权者一起使用，我们将在本章后面学习，以确保kubelet只能修改其正在运行的节点上的对象。API服务器使用`--authorization-mode=Node`标志来使用节点授权模块：'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Node authorization is used in conjunction with ABAC or RBAC, which we will look
    at next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 节点授权与ABAC或RBAC一起使用，接下来我们将看一下。
- en: ABAC
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABAC
- en: With ABAC, requests are allowed by validating policies against the attributes
    of the request. ABAC authorization mode can be enabled by using `--authorization-policy-file=<path>`
    and `--authorization-mode=ABAC` with the API server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABAC，通过验证请求的属性来允许请求。可以通过在API服务器中使用`--authorization-policy-file=<path>`和`--authorization-mode=ABAC`来启用ABAC授权模式。
- en: 'The policies include a JSON object per line. Each policy consists of the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 策略包括每行一个JSON对象。每个策略包括以下内容：
- en: '**Version**: The API version for the policy format.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：策略格式的API版本。'
- en: '**Kind**: The `Policy` string is used for policies.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**种类**：`Policy`字符串用于策略。'
- en: '**Spec**: This includes the user, group, and resource properties, such as `apiGroup`,
    `namespace`, and `nonResourcePath` (such as `/version`, `/apis`, `readonly`) to
    allow requests that don''t modify the resource.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范**：包括用户、组和资源属性，如`apiGroup`、`namespace`和`nonResourcePath`（如`/version`、`/apis`、`readonly`），以允许不修改资源的请求。'
- en: 'An example policy is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例策略如下：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This policy allows a kubelet to read any pods. ABAC is difficult to configure
    and maintain. It is not recommended that you use ABAC in production environments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许kubelet读取任何Pod。ABAC难以配置和维护。不建议在生产环境中使用ABAC。
- en: RBAC
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC
- en: 'With RBAC, access to resources is regulated using roles assigned to users.
    RBAC is enabled by default in many clusters since v1.8\. To enable RBAC, start
    the API server with `--authorization-mode=RBAC`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RBAC，通过分配给用户的角色来规范对资源的访问。自v1.8以来，RBAC在许多集群中默认启用。要启用RBAC，请使用`--authorization-mode=RBAC`启动API服务器：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: RBAC uses Role, which is a set of permissions, and RoleBinding, which grants
    permissions to users. Role and RoleBinding are restricted to namespaces. If a
    role needs to span across namespaces, ClusterRole and ClusterRoleBinding can be
    used to grant permissions to users across namespace boundaries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC使用Role，这是一组权限，以及RoleBinding，它向用户授予权限。Role和RoleBinding受到命名空间的限制。如果角色需要跨命名空间，则可以使用ClusterRole和ClusterRoleBinding来向用户授予权限。
- en: 'Here is an example of a `Role` property that allows a user to create and modify
    pods in the default namespace:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是允许用户在默认命名空间中创建和修改Pod的`Role`属性示例：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The corresponding `RoleBinding` can be used with `Role` to grant permissions
    to the user:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`RoleBinding`可以与`Role`一起使用，向用户授予权限：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once `RoleBinding` is applied, you can switch the context to see whether it
    worked correctly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了`RoleBinding`，您可以切换上下文查看是否工作正常：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, if you try to view the deployments, it will result in an error:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果尝试查看部署，将导致错误：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since roles and role bindings are restricted to the default namespace, accessing
    the pods in a different namespace will result in an error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于角色和角色绑定受限于默认命名空间，访问不同命名空间中的Pod将导致错误：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we will talk about webhooks, which provide enterprises with the ability
    to use remote servers for authorization.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论webhooks，它为企业提供了使用远程服务器进行授权的能力。
- en: Webhooks
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhooks
- en: Similar to webhook mode for authentication, webhook mode for authorization uses
    a remote API server to check user permissions. Webhook mode can be enabled by
    using `--authorization-webhook-config-file=<path>`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于用于身份验证的webhook模式，用于授权的webhook模式使用远程API服务器来检查用户权限。可以通过使用`--authorization-webhook-config-file=<path>`来启用webhook模式。
- en: 'Let''s look at a sample webhook configuration file that sets [https://authz.remote](https://authz.remote)
    as the remote authorization endpoint for the Kubernetes cluster:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例webhook配置文件，将[https://authz.remote](https://authz.remote)设置为Kubernetes集群的远程授权端点：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once the request is passed by the authentication and authorization modules,
    admission controllers process the request. Let's discuss admission controllers
    in detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求通过了认证和授权模块，准入控制器就会处理请求。让我们详细讨论准入控制器。
- en: Admission controllers
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制器
- en: Admission controllers are modules that intercept requests to the API server
    after the request is authenticated and authorized. The controllers validate and
    mutate the request before modifying the state of the objects in the cluster. A
    controller can be both mutating and validating. If any of the controllers reject
    the request, the request is dropped immediately and an error is returned to the
    user so that the request will not be processed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是在请求经过认证和授权后拦截API服务器的模块。控制器在修改集群中对象的状态之前验证和改变请求。控制器可以是改变和验证的。如果任何控制器拒绝请求，请求将立即被丢弃，并向用户返回错误，以便请求不会被处理。
- en: 'Admission controllers can be enabled by using the `--enable-admission-plugins`
    flag:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`--enable-admission-plugins`标志来启用准入控制器：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Default admission controllers can be disabled using the `--disable-admission-plugins`
    flag.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`--disable-admission-plugins`标志来禁用默认的准入控制器。
- en: In the following sections, we will look at some important admission controllers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看一些重要的准入控制器。
- en: AlwaysAdmit
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AlwaysAdmit
- en: This admission controller allows all the pods to exist in the cluster. This
    controller has been deprecated since 1.13 and should not be used in any cluster.
    With this controller, the cluster behaves as if no controllers exist in the cluster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此准入控制器允许所有的Pod存在于集群中。自1.13版本以来，该控制器已被弃用，不应在任何集群中使用。使用此控制器，集群的行为就好像集群中不存在任何控制器一样。
- en: AlwaysPullImages
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AlwaysPullImages
- en: This controller ensures that new pods always force image pull. This is helpful
    to ensure updated images are used by pods. It also ensures that private images
    can only be used by users who have the privileges to access them since users without
    access cannot pull images when a new pod is started. This controller should be
    enabled in your clusters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该控制器确保新的Pod始终强制拉取镜像。这有助于确保Pod使用更新的镜像。它还确保只有有权限访问的用户才能使用私有镜像，因为没有访问权限的用户在启动新的Pod时无法拉取镜像。应该在您的集群中启用此控制器。
- en: EventRateLimit
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件速率限制
- en: Denial-of-service attacks are common in infrastructure. Misbehaving objects
    can also cause high consumption of resources, such as the CPU or network, resulting
    in increased cost or low availability. `EventRateLimit` is used to prevent these
    scenarios.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝服务攻击在基础设施中很常见。行为不端的对象也可能导致资源的高消耗，如CPU或网络，从而导致成本增加或可用性降低。`EventRateLimit`用于防止这些情况发生。
- en: The limit is specified using a config file, which can be specified by adding
    a `--admission-control-config-file` flag to the API server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 限制是使用配置文件指定的，可以通过向 API 服务器添加 `--admission-control-config-file` 标志来指定。
- en: 'A cluster can have four types of limits: `Namespace`, `Server`, `User` and
    `SourceAndObject`. With each limit, the user can have a maximum limit for the
    **Queries Per Second** (**QPS**), the burst and cache size.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 集群可以有四种类型的限制：`Namespace`、`Server`、`User` 和 `SourceAndObject`。对于每个限制，用户可以拥有 **每秒查询**
    (**QPS**)、突发和缓存大小的最大限制。
- en: 'Let''s look at an example of a configuration file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个配置文件的例子：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This adds the `qps`, `burst`, and `cacheSize` limits to all API servers and
    namespaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为所有 API 服务器和命名空间添加 `qps`、`burst` 和 `cacheSize` 限制。
- en: Next, we will talk about LimitRanger, which prevents the overutilization of
    resources available in the cluster.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 LimitRanger，它可以防止集群中可用资源的过度利用。
- en: LimitRanger
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LimitRanger
- en: This admission controller observes the incoming request and ensures that it
    does not violate any of the limits specified in the `LimitRange` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个准入控制器观察传入的请求，并确保它不违反 `LimitRange` 对象中指定的任何限制。
- en: 'An example of a `LimitRange` object is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `LimitRange` 对象的例子如下：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this limit range object, any pod requesting memory of more than 128 Mi
    will fail:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个限制范围对象，任何请求内存超过 128 Mi 的 pod 都将失败：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When using LimitRanger, malicious pods cannot consume excess resources.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 LimitRanger 时，恶意的 pod 无法消耗过多的资源。
- en: NodeRestriction
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NodeRestriction
- en: This admission controller restricts the pods and nodes that a kubelet can modify.
    With this admission controller, a kubelet gets a username in the `system:node:<name>`
    format and is only able to modify the node object and pods running on its own
    node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个准入控制器限制了 kubelet 可以修改的 pod 和节点。有了这个准入控制器，kubelet 以 `system:node:<name>` 格式获得一个用户名，并且只能修改自己节点上运行的节点对象和
    pod。
- en: PersistentVolumeClaimResize
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PersistentVolumeClaimResize
- en: This admission controller adds validations for the `PersistentVolumeClaimResize`
    requests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个准入控制器为 `PersistentVolumeClaimResize` 请求添加了验证。
- en: PodSecurityPolicy
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PodSecurityPolicy
- en: This admission controller runs on the creation or modification of pods to determine
    whether the pods should be run based on the security-sensitive configuration of
    the pods. The set of conditions in the policy is checked against the workload
    configuration to verify whether the workload creation request should be allowed.
    A PodSecurityPolicy can check for fields such as `privileged`, `allowHostPaths`,
    `defaultAddCapabilities`, and so on. You'll learn more about PodSecurityPolicy
    in the next chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个准入控制器在创建或修改 pod 时运行，以确定是否应该基于 pod 的安全敏感配置来运行 pod。策略中的一组条件将与工作负载配置进行检查，以验证是否应该允许工作负载创建请求。PodSecurityPolicy
    可以检查诸如 `privileged`、`allowHostPaths`、`defaultAddCapabilities` 等字段。您将在下一章中了解更多关于
    PodSecurityPolicy 的内容。
- en: SecurityContextDeny
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SecurityContextDeny
- en: 'This is the recommended admission controller to use if PodSecurityPolicy is
    not enabled. It restricts the settings of security-sensitive fields, which can
    cause privilege escalation, such as running a privileged pod or adding Linux capabilities
    to a container:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用 PodSecurityPolicy，则建议使用此准入控制器。它限制了安全敏感字段的设置，这可能会导致特权升级，例如运行特权 pod 或向容器添加
    Linux 功能：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is recommended that PodSecurityPolicy is enabled by default in a cluster.
    However, due to the administrative overhead, `SecurityContextDeny` can be used
    until PodSecurityPolicy is configured for the cluster.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 建议默认情况下在集群中启用 PodSecurityPolicy。但是，由于管理开销，可以在为集群配置 PodSecurityPolicy 之前使用 `SecurityContextDeny`。
- en: ServiceAccount
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: '`ServiceAccount` is an identity of the pod. This admission controller implements
    `ServiceAccount`; it should be used if the cluster uses service accounts.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceAccount`是pod的身份。这个准入控制器实现了`ServiceAccount`；如果集群使用服务账户，应该使用它。'
- en: MutatingAdmissionWebhook and ValidatingAdmissionWebhook
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MutatingAdmissionWebhook和ValidatingAdmissionWebhook
- en: Similar to webhook configurations for authentication and authorization, webhooks
    can be used as admission controllers. MutatingAdmissionWebhook modifies the workload's
    specifications. These hooks execute sequentially. ValidatingAdmissionWebhook parses
    the incoming request to verify whether it is correct. Validating hooks execute
    simultaneously.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于用于身份验证和授权的webhook配置，webhook可以用作准入控制器。MutatingAdmissionWebhook修改工作负载的规范。这些钩子按顺序执行。ValidatingAdmissionWebhook解析传入的请求以验证其是否正确。验证钩子同时执行。
- en: Now, we have looked at authentication, authorization, and admission control
    of resources in Kubernetes. Let's look at how developers can implement fine-grained
    access control in their clusters. In the next section, we talk about OPA, an open
    source tool that is used extensively in production clusters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了Kubernetes中资源的身份验证、授权和准入控制。让我们看看开发人员如何在他们的集群中实现细粒度的访问控制。在下一节中，我们将讨论OPA，这是一个在生产集群中广泛使用的开源工具。
- en: Introduction to OPA
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OPA简介
- en: '**OPA** is an open source policy engine that allows policy enforcement in Kubernetes.
    Several open source projects, such as Istio, utilize OPA to provide finer-grained
    controls. OPA is an incubating project hosted by **Cloud Native Computing Foundation**
    (**CNCF**).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPA**是一个开源的策略引擎，允许在Kubernetes中执行策略。许多开源项目，如Istio，利用OPA提供更精细的控制。OPA是由**Cloud
    Native Computing Foundation** (**CNCF**)托管的孵化项目。'
- en: 'OPA is deployed as a service alongside your other services. To make authorization
    decisions, the microservice makes a call to OPA to decide whether the request
    should be allowed or denied. Authorization decisions are offloaded to OPA, but
    this enforcement needs to be implemented by the service itself. In Kubernetes
    environments, it is often used as a validating webhook:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: OPA部署为与其他服务一起的服务。为了做出授权决策，微服务调用OPA来决定请求是否应该被允许或拒绝。授权决策被卸载到OPA，但这种执行需要由服务本身实现。在Kubernetes环境中，它经常被用作验证webhook：
- en: '![Figure 7.2 – Open Policy Agent'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 开放策略代理'
- en: '](image/B15566_07_002.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15566_07_002.jpg)'
- en: Figure 7.2 – Open Policy Agent
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 开放策略代理
- en: 'To make a policy decision, OPA needs the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出策略决策，OPA需要以下内容：
- en: '**Cluster information**: The state of the cluster. The objects and resources
    available in the cluster are important for OPA to make a decision about whether
    a request should be allowed or not.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群信息**：集群的状态。集群中可用的对象和资源对于OPA来说是重要的，以便决定是否应该允许请求。'
- en: '**Input query**: The parameters of the request being parsed by the policy agent
    are analyzed by the agent to allow or deny the request.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入查询**：策略代理分析请求的参数，以允许或拒绝请求。'
- en: '**Policies**: The policy defines the logic that parses cluster information
    and input query to return the decision. Policies for OPA are defined in a custom
    language called Rego.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：策略定义了解析集群信息和输入查询以返回决策的逻辑。OPA的策略是用一种称为Rego的自定义语言定义的。'
- en: Let's look at an example of how OPA can be leveraged to deny the creation of
    pods with a `busybox` image. You can use the official OPA documentation ([https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/](https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/))
    to install OPA on your cluster.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，说明如何利用OPA来拒绝创建带有`busybox`镜像的pod。您可以使用官方的OPA文档([https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/](https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/))在您的集群上安装OPA。
- en: 'Here is the policy that restricts the creation and updating of pods with the
    `busybox` image:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是限制使用`busybox`镜像创建和更新pod的策略：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To apply this policy, you can use the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用此策略，您可以使用以下内容：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once `configmap` is created, `kube-mgmt` loads these policies out of `configmap`
    in the `opa` container, both `kube-mgmt` and `opa` containers are in the `opa`
    pod. Now, if you try to create a pod with the `busybox` image, you get the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`configmap`，`kube-mgmt`会从`configmap`中加载这些策略，在`opa`容器中，`kube-mgmt`和`opa`容器都在`opa`
    pod中。现在，如果您尝试使用`busybox`镜像创建一个pod，您将得到以下结果：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This policy checks the request for the `busybox` image name and denies creation
    of pods with the `busybox` image with an `image not allowed` error:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略检查对`busybox`镜像名称的请求，并拒绝使用`busybox`镜像创建带有`image not allowed`错误的pod：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Similar to the admission controller that we discussed previously, further finer-grained
    admission controllers can be created using OPA in the Kubernetes cluster.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前讨论过的准入控制器，可以使用OPA在Kubernetes集群中创建进一步细粒度的准入控制器。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the importance of authentication and authorization
    in Kubernetes. We discussed the different modules available for authentication
    and authorization and discussed these modules in detail, as well as going through
    detailed examples of how each module is used. When looking at authentication,
    we discussed user impersonation, which can be used by cluster administrators or
    developers to test permissions. Next, we talked about admission controllers, which
    can be used to validate or mutate requests after authentication and authorization.
    We also discussed some admission controllers in detail. Finally, we looked at
    OPA, which can be used in Kubernetes clusters to perform a more fine-grained level
    of authorization.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在Kubernetes中进行身份验证和授权的重要性。我们讨论了可用于身份验证和授权的不同模块，并详细讨论了这些模块，以及详细介绍了每个模块的使用示例。在讨论身份验证时，我们讨论了用户模拟，这可以由集群管理员或开发人员用来测试权限。接下来，我们谈到了准入控制器，它可以用于在身份验证和授权之后验证或改变请求。我们还详细讨论了一些准入控制器。最后，我们看了一下OPA，它可以在Kubernetes集群中执行更细粒度的授权。
- en: Now, you should be able to devise appropriate authentication and authorization
    strategies for your cluster. You should be able to figure out which admission
    controllers work for your environment. In many cases, you'll need more granular
    controls for authorization, which can be provided by using OPA.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够为您的集群制定适当的身份验证和授权策略。您应该能够确定哪些准入控制器适用于您的环境。在许多情况下，您将需要更细粒度的授权控制，这可以通过使用OPA来实现。
- en: In the next chapter, we will take a deep dive into securing pods. The chapter
    will cover some of the topics that we covered in this chapter in more detail,
    such as PodSecurityPolicy. Securing pods is essential to securing application
    deployment in Kubernetes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨保护pod。本章将更详细地涵盖我们在本章中涵盖的一些主题，如PodSecurityPolicy。保护pod对于保护Kubernetes中的应用部署至关重要。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which authorization modules should not be used in a cluster?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些授权模块不应该在集群中使用？
- en: How can cluster administrators test permissions granted to a new user?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集群管理员如何测试对新用户授予的权限？
- en: Which authorization modes are recommended for production clusters?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些授权模式适合生产集群？
- en: What is the difference between the `EventRateLimit` and LimitRange admission
    controllers?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EventRateLimit`和`LimitRange`准入控制器之间有什么区别？'
- en: Can you write a Rego policy to deny the creation of ingress with the `test.example`
    endpoint?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否编写一个Rego策略来拒绝创建带有`test.example`端点的ingress？
- en: Further reading
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接获取更多信息：
- en: 'Admission controllers: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '准入控制器: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do)'
- en: 'OPA: [https://www.openpolicyagent.org/docs/latest/](https://www.openpolicyagent.org/docs/latest/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OPA: [https://www.openpolicyagent.org/docs/latest/](https://www.openpolicyagent.org/docs/latest/)'
- en: 'Kubernetes RBAC: [https://rbac.dev/](https://rbac.dev/)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes RBAC: [https://rbac.dev/](https://rbac.dev/)'
- en: 'audit2RBAC: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'audit2RBAC: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
- en: 'KubiScan: [https://github.com/cyberark/KubiScan](https://github.com/cyberark/KubiScan)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KubiScan: [https://github.com/cyberark/KubiScan](https://github.com/cyberark/KubiScan)'
