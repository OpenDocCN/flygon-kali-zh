- en: 13\. RxJava and Coroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. RxJava和协程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to doing background operations and data manipulations
    with RxJava and coroutines. It covers how to use RxJava to retrieve data from
    an external API and how to do that with coroutines. You'll also learn how to manipulate
    and display the data using RxJava operators and LiveData transformations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用RxJava和协程进行后台操作和数据操作。它涵盖了如何使用RxJava从外部API检索数据以及如何使用协程进行操作。您还将学习如何使用RxJava操作符和LiveData转换来操作和显示数据。
- en: By the end of this chapter, you will be able to use RxJava to manage network
    calls in the background and use RxJava operators to transform data. You will also
    be able to perform network tasks in the background using Kotlin coroutines and
    manipulate data with LiveData transformations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使用RxJava在后台管理网络调用，并使用RxJava操作符转换数据。您还将能够使用Kotlin协程在后台执行网络任务，并使用LiveData转换操作来操作数据。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: You have now learned the basics of Android app development and implemented features
    such as RecyclerViews, notifications, fetching data from web services, and services.
    You've also gained skills in the best practices for testing and persisting data.
    In the previous chapter, you learned about dependency injection. Now, you will
    be learning about background operations and data manipulation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了Android应用程序开发的基础知识，并实现了诸如RecyclerView、通知、从网络服务获取数据和服务等功能。您还掌握了最佳实践的测试和持久化数据的技能。在上一章中，您学习了依赖注入。现在，您将学习后台操作和数据操作。
- en: Some Android applications work on their own. However, most apps would need a
    backend server to retrieve or process data. These operations may take a while,
    depending on the internet connection, device settings, and server specifications.
    If long-running operations are run in the main UI thread, the application will
    be blocked until the tasks are completed. The application might become unresponsive
    and might prompt the user to close it and stop using it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Android应用程序可以自行运行。但是，大多数应用程序可能需要后端服务器来检索或处理数据。这些操作可能需要一段时间，具体取决于互联网连接、设备设置和服务器规格。如果长时间运行的操作在主UI线程中运行，应用程序将被阻塞，直到任务完成。应用程序可能会变得无响应，并可能提示用户关闭并停止使用它。
- en: To avoid this, tasks that can take an indefinite amount of time must be run
    asynchronously. An asynchronous task means it can run in parallel to another task
    or in the background. For example, while fetching data from a data source asynchronously,
    your UI can still display or interact with the users.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，可以将可能需要花费不确定时间的任务异步运行。异步任务意味着它可以与另一个任务并行运行或在后台运行。例如，当异步从数据源获取数据时，您的UI仍然可以显示或与用户交互。
- en: You can use libraries like RxJava and coroutines for asynchronous operations.
    We'll be discussing both of them in this chapter. Let's get started with RxJava.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用RxJava和协程等库进行异步操作。我们将在本章讨论它们。让我们开始使用RxJava。
- en: RxJava
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: RxJava is a Java implementation of **Reactive Extensions** (**Rx**), a library
    for reactive programming. In reactive programming, you have data streams that
    can be observed. When the value changes, your observers can be notified and react
    accordingly. For example, let's say clicking on a button is your observable and
    you have observers listening to it. If the user clicks on that button, your observers
    can react and do a specific action.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava是**Reactive Extensions**（**Rx**）的Java实现，这是一种用于响应式编程的库。在响应式编程中，您有可以被观察的数据流。当值发生变化时，您的观察者可以收到通知并做出相应的反应。例如，假设点击按钮是您的可观察对象，并且您有观察者在监听它。如果用户点击该按钮，您的观察者可以做出反应并执行特定操作。
- en: RxJava makes asynchronous data processing and handling errors simpler. Writing
    it the usual way is tricky and error-prone. If your task involves a chain of asynchronous
    tasks, it will be more complicated to write and debug. With RxJava, it can be
    done more easily and you will have less code, which is more readable and maintainable.
    RxJava also has a wide range of operators that you can use for transforming data
    into the type or format you need.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava使异步数据处理和处理错误变得更简单。以常规方式编写它很棘手且容易出错。如果您的任务涉及一系列异步任务，那么编写和调试将会更加复杂。使用RxJava，可以更轻松地完成，并且代码量更少，更易读和易于维护。RxJava还具有广泛的操作符，可用于将数据转换为所需的类型或格式。
- en: 'RxJava has three main components: observables, observers, and operators. To
    use RxJava, you will need to create observables that emit data, transform the
    data using RxJava operators, and subscribe to the observables with observers.
    The observers can wait for the observables to produce data without blocking the
    main thread.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava有三个主要组件：可观察对象、观察者和操作符。要使用RxJava，您需要创建发出数据的可观察对象，使用RxJava操作符转换数据，并使用观察者订阅可观察对象。观察者可以等待可观察对象产生数据，而不会阻塞主线程。
- en: Observables, Observers, and Operators
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象、观察者和操作符
- en: Let's understand the three main components of RxJava in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解RxJava的三个主要组件。
- en: '**Observables**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**'
- en: An observable is a source of data that can be listened to. It can emit data
    to its listeners.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是可以被监听的数据源。它可以向其监听者发出数据。
- en: 'The `Observable` class represents an observable. You can create observables
    from lists, arrays, or objects with the `Observable.just` and `Observable.from`
    methods. For example, you can create observables with the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`类表示一个可观察对象。您可以使用`Observable.just`和`Observable.from`方法从列表、数组或对象创建可观察对象。例如，您可以使用以下方式创建可观察对象：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are more functions that you can use to create observables, such as `Observable.create`,
    `Observable.defer`, `Observable.empty`, `Observable.generate`, `Observable.never`,
    `Observable.range`, `Observable.interval`, and `Observable.timer`. You can also
    make a function that returns an `observable`. Learn more about creating observables
    at [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多函数可用于创建可观察对象，例如 `Observable.create`、`Observable.defer`、`Observable.empty`、`Observable.generate`、`Observable.never`、`Observable.range`、`Observable.interval`
    和 `Observable.timer`。您还可以创建一个返回 `observable` 的函数。了解有关创建可观察对象的更多信息，请访问 [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)。
- en: Observables can be either hot or cold. Cold observables emit data only when
    they have subscribers listening. Examples are database queries or network requests.
    Hot observables, on the other hand, emits data even if there are no observers.
    Examples of this are UI events in Android like mouse and keyboard events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象可以是热的或冷的。冷可观察对象只有在有订阅者监听时才会发出数据。例如数据库查询或网络请求。另一方面，热可观察对象即使没有观察者也会发出数据。例如，Android
    中的 UI 事件，如鼠标和键盘事件。
- en: Once you have created an observable, the observers can start listening to the
    data the observable will send.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了可观察对象，观察者就可以开始监听可观察对象将发送的数据。
- en: '**Operators**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作符**'
- en: 'Operators allow you to modify and compose the data you get from the observable
    before passing it to the observers. Using an operator returns another observable
    so you can chain operator calls. For example, let''s say you have an observable
    that emits the numbers from 1 to 10\. You can filter it to only get even numbers
    and transform the list into another list containing each item''s square. To do
    that in RxJava, you can use the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符允许您在将数据传递给观察者之前修改和组合从可观察对象获取的数据。使用操作符会返回另一个可观察对象，因此您可以链接操作符调用。例如，假设您有一个可观察对象，它会发出从
    1 到 10 的数字。您可以对其进行过滤，只获取偶数，并将列表转换为另一个包含每个项目平方的列表。要在 RxJava 中执行此操作，您可以使用以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output of the preceding code will be a data stream with the values 4, 16,
    36, 64, and 100\.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将是一个数据流，其中包含值 4、16、36、64 和 100。
- en: '**Observers**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者**'
- en: 'Observers subscribe to observables and are notified when the observers emit
    data. They can listen to the next value or error emitted by the observable. The
    `Observer` class is the interface for observers. It has four methods that you
    can override when making an observer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者订阅可观察对象，并在观察者发出数据时收到通知。它们可以监听可观察对象发出的下一个值或错误。`Observer` 类是观察者的接口。在创建观察者时，它有四种方法可以重写：
- en: '`onComplete`: When the observable has finished sending data'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当可观察对象完成发送数据时'
- en: '`onNext`: When the observable has sent new data'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当可观察对象发送新数据时'
- en: '`onSubscribe`: When an observer is subscribed to an observable'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe`：当观察者订阅可观察对象时'
- en: '`onError`: When the observable encountered an error'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当可观察对象遇到错误时'
- en: 'To subscribe to an observable, you can call `Observable.subscribe()` passing
    in a new instance of the `Observer` interface. For example, if you want to subscribe
    to an observable of even numbers from `2` to `10`, you can do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅可观察对象，可以调用 `Observable.subscribe()`，传入 `Observer` 接口的新实例。例如，如果要订阅从 `2` 到
    `10` 的偶数可观察对象，可以执行以下操作：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this code, the observer will print the next integer. It will also print
    text when it has subscribed, when the observable is completed, and when it encounters
    an error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，观察者将打印下一个整数。它还会在订阅时打印文本，当可观察对象完成时，以及当遇到错误时。
- en: '`Observable.subscribe()` has different overloaded functions wherein you can
    pass the `onNext`, `onError`, `onComplete`, and `onSubscribe` parameters. These
    functions return a `disposable` object. You can call its `dispose` function when
    closing an activity to prevent memory leaks. For example, you can use a variable
    for the `disposable` object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.subscribe()` 具有不同的重载函数，其中您可以传递 `onNext`、`onError`、`onComplete`
    和 `onSubscribe` 参数。这些函数返回一个 `disposable` 对象。在关闭活动时，可以调用其 `dispose` 函数以防止内存泄漏。例如，您可以使用一个变量来存储
    `disposable` 对象：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, in the `onDestroy` function of the activity where you''ve made the observable,
    you can call `disposable.dispose()` to stop the observers from listening to the observable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您创建可观察对象的活动的 `onDestroy` 函数中，您可以调用 `disposable.dispose()` 来阻止观察者监听可观察对象：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Aside from the observables, observers, and operators, you also need to learn
    about RxJava schedulers, which will be covered in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可观察对象、观察者和操作符之外，您还需要了解 RxJava 调度程序，这将在下一节中介绍。
- en: Schedulers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度程序
- en: By default, RxJava is synchronous. This means all processes are done in the
    same thread. There are some tasks that take a while, such as database and network
    operations, which need to be made asynchronous or run in parallel in another thread.
    To do that, you need to use schedulers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RxJava 是同步的。这意味着所有进程都在同一个线程中完成。有一些任务需要一段时间，例如数据库和网络操作，需要异步执行或在另一个线程中并行运行。为此，您需要使用调度程序。
- en: 'Schedulers allow you to control the thread where the actions will be running.
    There are two functions you can use: `observeOn` and `subscribeOn`. You can set
    which thread your observable will run on with the `subscribeOn` function. The
    `observeOn` function allows you to set where the next operators will be executed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序允许您控制操作将在其中运行的线程。您可以使用两个函数：`observeOn` 和 `subscribeOn`。您可以使用 `subscribeOn`
    函数设置可观察对象将在哪个线程上运行。`observeOn` 函数允许您设置下一个操作将在哪里执行。
- en: 'For example, if you have the `getData` function, which fetches data from the
    network and returns an observable, you can subscribe to `Schedulers.io` and observe
    the Android main UI thread with `AndroidSchedulers.mainThread()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有 `getData` 函数，该函数从网络获取数据并返回一个可观察对象，您可以订阅 `Schedulers.io` 并使用 `AndroidSchedulers.mainThread()`
    观察 Android 主 UI 线程：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`AndroidSchedulers` is part of RxAndroid, which is an extension of RxJava for
    Android. You will need RxAndroid to use RxJava in Android app development.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidSchedulers`是RxAndroid的一部分，它是RxJava在Android上的扩展。您需要RxAndroid来在Android应用程序开发中使用RxJava。'
- en: In the next section, you will learn how to add RxJava and RxAndroid to your
    project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何将RxJava和RxAndroid添加到您的项目中。
- en: Adding RxJava to Your Project
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将RxJava添加到您的项目
- en: 'You can add RxJava to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将以下代码添加到`app/build.gradle`文件的依赖项中，将RxJava添加到您的项目中：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will add both the RxJava and RxAndroid libraries to your Android project.
    The RxAndroid library already includes RxJava but it is better to still add the
    RxJava dependency as the one bundled with RxAndroid might not be the latest version.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您的Android项目中添加RxJava和RxAndroid库。RxAndroid库已经包含了RxJava，但最好还是添加RxJava依赖项，因为RxAndroid捆绑的版本可能不是最新版本。
- en: Using RxJava in an Android Project
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android项目中使用RxJava
- en: RxJava has several benefits, one of which is handling long-running operations
    such as network requests in a non-UI thread. The result of a network call can
    be converted to an observable. You can then create an observer that will subscribe
    to the observable and present the data. Before displaying the data to the user,
    you can transform the data with RxJava operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava有几个好处，其中之一是处理长时间运行的操作，比如在非UI线程中进行网络请求。网络调用的结果可以转换为可观察对象。然后，您可以创建一个观察者来订阅可观察对象并呈现数据。在向用户显示数据之前，您可以使用RxJava操作符转换数据。
- en: 'If you are using Retrofit, you can convert the response to an RxJava observable
    by adding a call adapter factory. First, you would need to add `adapter-rxjava3`
    in your `app/build.gradle` file dependencies with the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Retrofit，可以通过添加调用适配器工厂将响应转换为RxJava可观察对象。首先，您需要在`app/build.gradle`文件的依赖项中添加`adapter-rxjava3`，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this, you can use `RxJava3CallAdapterFactory` as the call adapter in your
    `Retrofit` instance. You can do that with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您可以在您的`Retrofit`实例中使用`RxJava3CallAdapterFactory`作为调用适配器。您可以使用以下代码来实现：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, your Retrofit methods can return `Observable` objects that you can listen
    to in your code. For example, in your `getMovies` Retrofit method that calls your
    movie endpoint, you can use the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的Retrofit方法可以返回您可以在代码中监听的`Observable`对象。例如，在调用电影端点的`getMovies` Retrofit方法中，您可以使用以下内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's try what you have learned so far by adding RxJava to an Android project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下您迄今为止学到的知识，通过将RxJava添加到Android项目中。
- en: 'Exercise 13.01: Using RxJava in an Android Project'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：在Android项目中使用RxJava
- en: 'For this chapter, you will be working with an application that displays popular
    movies using The Movie Database API. Go to [https://developers.themoviedb.org/](https://developers.themoviedb.org/)
    and register for an API key. In this exercise, you will be using RxJava to fetch
    the list of all popular movies from the movie/popular endpoint, regardless of
    year:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将使用一个应用程序来显示使用The Movie Database API的热门电影。转到[https://developers.themoviedb.org/](https://developers.themoviedb.org/)并注册API密钥。在这个练习中，您将使用RxJava从电影/流行的端点获取所有热门电影的列表，而不考虑年份：
- en: Create a new project in Android Studio. Name your project `Popular Movies` and
    use the package name `com.example.popularmovies`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目。将项目命名为`Popular Movies`，并使用包名`com.example.popularmovies`。
- en: Set the location where you want to save the project, then click the `Finish` button.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您想要保存项目的位置，然后单击`完成`按钮。
- en: 'Open `AndroidManifest.xml` and add the `INTERNET` permission:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`并添加`INTERNET`权限：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will allow you to use the device's internet connection to do network calls.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您使用设备的互联网连接进行网络调用。
- en: 'Open your `app/build.gradle` file and add the kotlin-parcelize plugin at the
    end of the plugins block:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/build.gradle`文件，并在插件块的末尾添加kotlin-parcelize插件：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will allow you to use Parcelable for the model class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您为模型类使用Parcelable。
- en: 'Add the following in the `android` block:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`android`块中添加以下内容：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These will allow you to use Java 8 for your project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您在项目中使用Java 8。
- en: 'Add the following dependencies in your `app/build.gradle` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中添加以下依赖项：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These lines will add the RecyclerView, Glide, Retrofit, RxJava, RxAndroid, and
    Moshi libraries to your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将向您的项目中添加RecyclerView、Glide、Retrofit、RxJava、RxAndroid和Moshi库。
- en: 'Create a `dimens.xml` file in the `res/values` directory and add a `layout_margin`
    dimension value:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values`目录中创建一个`dimens.xml`文件，并添加一个`layout_margin`维度值：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will be used for the vertical and horizontal margins of the views.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于视图的垂直和水平边距。
- en: 'Create a new layout file named `view_movie_item.xml` and add the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`view_movie_item.xml`的新布局文件，并添加以下内容：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This layout file, containing the movie poster and title text, will be used for
    each movie in the list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局文件包含电影海报和标题文本，将用于列表中的每部电影。
- en: 'Open `activity_main.xml`. Replace the Hello World TextView with RecyclerView:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`。用RecyclerView替换Hello World TextView：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This RecyclerView will be displaying the list of movies. It will be using `GridLayoutManager`
    with two columns.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个RecyclerView将显示电影列表。它将使用`GridLayoutManager`，有两列。
- en: 'Create a new package, `com.example.popularmovies.model`, for your model class.
    Make a new model class named `Movie` with the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的模型类创建一个新包`com.example.popularmovies.model`。创建一个名为`Movie`的新模型类，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will be the model class representing a `Movie` object from the API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是代表API中的`Movie`对象的模型类。
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DetailsActivity`的新活动，使用`activity_details.xml`作为布局文件。
- en: 'Open the `AndroidManifest.xml` file and add `MainActivity` as the value for
    the `parentActivityName` attribute of `DetailsActivity`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`文件，并将`MainActivity`作为`DetailsActivity`的`parentActivityName`属性的值添加进去：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will add an up icon in the details activity to go back to the main screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在详细信息活动中添加一个向上图标，以返回到主屏幕。
- en: Open `activity_details.xml`. Add the required views. (The code below is truncated
    for space. Refer to the file linked below for the full code that you need to add.)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_details.xml`。添加所需的视图。（以下代码由于空间限制而被截断。请参考下面链接的文件以获取您需要添加的完整代码。）
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will add the poster, title, release, and overview on the details screen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在详情屏幕上添加海报、标题、发布日期和概述。
- en: 'Open `DetailsActivity` and add the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailsActivity`并添加以下内容：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will display the poster, title, release, and overview of the movie selected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所选电影的海报、标题、发布日期和概述。
- en: 'Create an adapter class for the movie list. Name the class `MovieAdapter`.
    Add the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为电影列表创建一个适配器类。将类命名为`MovieAdapter`。添加以下内容：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This class will be the adapter for your RecyclerView.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将是您的RecyclerView的适配器。
- en: 'Add `ViewHolder` for your class after the `onBindViewHolder` function:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onBindViewHolder`函数之后为您的类添加`ViewHolder`：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will be the `ViewHolder` used by `MovieAdapter` for the RecyclerView.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是`MovieAdapter`用于RecyclerView的`ViewHolder`。
- en: 'Below the `MovieViewHolder` declaration, add `MovieClickListener`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MovieViewHolder`声明之后，添加`MovieClickListener`：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This interface will be used when clicking on a movie to view the details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口将在点击电影查看详情时使用。
- en: 'Create another class named `PopularMoviesResponse` in the `com.example.popularmovies.model`
    package:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.popularmovies.model`包中创建另一个名为`PopularMoviesResponse`的类：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will be the model class for the response you get from the API endpoint
    for popular movies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是您从热门电影API端点获取的响应的模型类。
- en: 'Create a new package, `com.example.popularmovies.api`, and add a `MovieService`
    interface with the following contents:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包`com.example.popularmovies.api`，并添加一个带有以下内容的`MovieService`接口：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will define the endpoint you will be using to retrieve the popular movies.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义您将使用的端点来检索热门电影。
- en: 'Create a `MovieRepository` class with a constructor for `movieService`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MovieRepository`类，并为`movieService`添加一个构造函数：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `apiKey` (with the value of the API key from The Movie Database API)
    and a `fetchMovies` function to retrieve the list from the endpoint:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`apiKey`（值为The Movie Database API的API密钥）和一个`fetchMovies`函数来从端点检索列表：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an application class named `MovieApplication` with a property for `movieRepository`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MovieApplication`的应用程序类，并为`movieRepository`添加一个属性：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be the application class for the app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是应用程序的应用程序类。
- en: 'Override the `onCreate` function of the `MovieApplication` class and initialize
    `movieRepository`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`MovieApplication`类的`onCreate`函数并初始化`movieRepository`：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set `MovieApplication` as the value for the `android:name` attribute of the
    application in the `AndroidManifest.xml` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MovieApplication`设置为`AndroidManifest.xml`文件中应用程序的`android:name`属性的值：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `MovieViewModel` class with a constructor for `movieRepository`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MovieViewModel`类，并为`movieRepository`添加一个构造函数：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add properties for `popularMovies`, `error`, and `disposable`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`popularMovies`，`error`和`disposable`添加属性：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the `fetchPopularMovies` function. Inside the function, get the popular
    movies from `movieRepository`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`fetchPopularMovies`函数。在函数内部，从`movieRepository`获取热门电影：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will fetch the popular movies asynchronously in the `Schedulers.io` thread
    when subscribed and will return an observable and with operators on the main thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅时，这将在`Schedulers.io`线程中异步获取热门电影，并返回一个可观察对象，并在主线程上使用操作符。
- en: 'Override the `onCleared` function of the `MovieViewModel` and dispose of the `disposable`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`MovieViewModel`的`onCleared`函数并处理`disposable`：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will dispose of the `disposable` when the ViewModel has been cleared, like
    when the activity has been closed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当ViewModel被清除时，例如当活动被关闭时，这将处理`disposable`。
- en: 'Open `MainActivity` and add define a field for the movie adapter:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`并定义一个电影适配器的字段：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will have a listener that will open the details screen when a movie is
    clicked.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有一个监听器，当点击电影时将打开详情屏幕。
- en: 'In the `onCreate` function, set the adapter for the `movie_list` `RecyclerView`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中，为`movie_list`的`RecyclerView`设置适配器：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a `getMovies` function on `MainActivity`. Inside, initialize `movieRepository`
    and `movieViewModel`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`上创建一个`getMovies`函数。在内部，初始化`movieRepository`和`movieViewModel`：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the end of the `getMovies` function, add an observer to the `popularMovies`
    and `error` LiveData from `movieViewModel`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getMovies`函数的末尾，向`movieViewModel`的`popularMovies`和`error` LiveData添加一个观察者：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At the end of the `onCreate` function of the `MainActivity` class, call the
    `getMovies()` function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的`onCreate`函数的末尾，调用`getMovies()`函数：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the `openMovieDetails` function to open the details screen when clicking
    on a movie from the list:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击列表中的电影时添加`openMovieDetails`函数以打开详情屏幕：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run your application. You will see that the app will display a list of popular
    movie titles:![Figure 13.1: How the Popular Movies app will look'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。您将看到该应用程序将显示一个热门电影标题列表：![图13.1：热门电影应用程序的外观
- en: '](img/B15216_13_01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_01.jpg)'
- en: 'Figure 13.1: How the Popular Movies app will look'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：热门电影应用程序的外观
- en: 'Click on a movie, and you will see its details, such as its release date and
    an overview:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击电影，您将看到它的发布日期和概述等详情：
- en: '![Figure 13.2: The movie details screen'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2：电影详情屏幕'
- en: '](img/B15216_13_02.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_02.jpg)'
- en: 'Figure 13.2: The movie details screen'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：电影详情屏幕
- en: You have learned how to use RxJava to retrieve the response from an external
    API. In the next section, you will convert the data you fetched into the data
    that you need to display with RxJava operators.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何使用RxJava从外部API检索响应。在下一节中，您将使用RxJava操作符将获取的数据转换为需要显示的数据。
- en: Modifying Data with RxJava Operators
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RxJava操作符修改数据
- en: When you have an observable that emits data, you can use operators to modify
    the data before passing it to the observers. You can use a single operator or
    a chain of operators to get the data that you want. There are different types
    of operators that you can use, such as transforming operators and filtering operators.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个发出数据的observable时，您可以使用操作符在将其传递给观察者之前修改数据。您可以使用单个操作符或一系列操作符来获取所需的数据。您可以使用不同类型的操作符，例如转换操作符和过滤操作符。
- en: 'Transforming operators can modify items from the observable into your preferred
    data. The `flatMap()` operator transforms the items into an observable. In *Exercise
    13.01,* *Using RxJava in an Android Project*, you transformed the observable of
    `PopularMoviesResponse` into an observable of `Movies` with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 转换操作符可以将observable中的项目修改为您喜欢的数据。 `flatMap（）`操作符将项目转换为observable。在*练习13.01* *在Android项目中使用RxJava*中，您将observable
    `PopularMoviesResponse`转换为observable `Movies`如下：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another operator that can transform data is `map`. The `map(x)` operator applies
    a function `x` to each item and returns another observable with the updated values.
    For example, if you have an observable of a list of numbers, you can transform
    it into another observable list with each number multiplied by 2 with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以转换数据的操作符是`map`。`map（x）`操作符将函数`x`应用于每个项目，并返回具有更新值的另一个observable。例如，如果您有一个数字列表的observable，可以使用以下内容将其转换为另一个observable列表，其中每个数字都乘以2：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Filtering operators allow you to select only some of the items. With `filter()`,
    you can select items based on a set condition. For example, you can filter odd
    numbers with the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤操作符允许您仅选择其中的一些项目。使用`filter（）`，您可以根据一组条件选择项目。例如，您可以使用以下内容过滤奇数：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `first()` and `last()` operators allow you to get the first and last item,
    while with `take(n)` or `takeLast(n)`, you can get *n* first or last items. There
    are other filtering operators such as `debounce()`, `distinct()`, `elementAt()`,
    `ignoreElements()`, `sample()`, `skip()`, and `skipLast()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`first（）`和`last（）`操作符允许您获取第一个和最后一个项目，而使用`take（n）`或`takeLast（n）`，您可以获取*n*个第一个或最后一个项目。还有其他过滤操作符，如`debounce（）`，`distinct（）`，`elementAt（）`，`ignoreElements（）`，`sample（）`，`skip（）`和`skipLast（）`。'
- en: There are many other RxJava operators you can use. Let's try to use RxJava operators
    in an Android project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他RxJava操作符可供您使用。让我们尝试在Android项目中使用RxJava操作符。
- en: 'Exercise 13.02: Using RxJava Operators'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02：使用RxJava操作符
- en: 'In the previous exercise, you used RxJava to fetch the list of popular movies
    from The Movie Database API. Now, before displaying them in RecyclerView, you
    will be adding operators to sort the movies by title and only get the movies released
    last month:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您使用了RxJava从The Movie Database API获取了热门电影列表。现在，在将它们显示在RecyclerView之前，您将添加操作符来按标题排序电影并仅获取上个月发布的电影：
- en: Open the `Popular Movies` project you did in *Exercise 13.01,* *Using RxJava
    in an Android Project*.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开*练习13.01* *在Android项目中使用RxJava*中的`Popular Movies`项目。
- en: Open `MovieViewModel` and navigate to the `fetchPopularMovies` function.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieViewModel`并导航到`fetchPopularMovies`函数。
- en: 'You will be modifying the app to only display popular movies for this year.
    Replace `.map { it.results }` with the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将修改应用程序以仅显示今年的热门电影。将`.map { it.results }`替换为以下内容：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will convert the Observable of `MovieResponse` into an observable of Movies.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`MovieResponse`的Observable转换为`Movies`的observable。
- en: 'Before the `toList()` call, add the following:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toList（）`调用之前，添加以下内容：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will select only the movies released in the previous month.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅选择上个月发布的电影。
- en: 'Run the application. You will see that the other movies are no longer displayed.
    Only those released this year will be on the list:![Figure 13.3: The app with
    the year’s popular movies'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到其他电影不再显示。只有今年发布的电影才会出现在列表上：![图13.3：年度热门电影应用程序
- en: '](img/B15216_13_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_03.jpg)'
- en: 'Figure 13.3: The app with the year''s popular movies'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：年度热门电影应用程序
- en: 'You''ll also notice that the movies displayed are not in alphabetical order.
    Sort the movies by using the `sorted` operator before the `toList()` call:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还会注意到显示的电影没有按字母顺序排列。在`toList（）`调用之前使用`sorted`操作符对电影进行排序：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will sort the movies based on their titles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据它们的标题对电影进行排序。
- en: 'Run the application. You will see that the list of movies is now sorted alphabetically
    by title:![Figure 13.4: The app with the year’s popular movies sorted by title'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到电影列表现在按标题按字母顺序排序：![图13.4：按标题排序的年度热门电影应用程序
- en: '](img/B15216_13_04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_04.jpg)'
- en: 'Figure 13.4: The app with the year''s popular movies sorted by title'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：按标题排序的年度热门电影应用程序
- en: 'Before the `toList()` call, use the `map` operator to map the list of movies
    into another list whose title is in uppercase:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toList（）`调用之前，使用`map`操作符将电影列表映射到另一个标题为大写的列表中：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the application. You will see that the movie titles are now in uppercase letters:![Figure
    13.5: The app with the movie titles in uppercase'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到电影标题现在是大写字母：![图13.5：电影标题为大写的应用程序
- en: '](img/B15216_13_05.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_05.jpg)'
- en: 'Figure 13.5: The app with the movie titles in uppercase'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：电影标题为大写的应用程序
- en: 'Before the `toList()` call, use the `take` operator to only get the first four
    movies from the list:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toList（）`调用之前，使用`take`操作符仅从列表中获取前四部电影：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the application. You will see that the RecyclerView will only show four movies:![Figure
    13.6: The app with only four movies'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到RecyclerView只会显示四部电影：![图13.6：只有四部电影的应用程序
- en: '](img/B15216_13_06.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_06.jpg)'
- en: 'Figure 13.6: The app with only four movies'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：只有四部电影的应用程序
- en: Try other RxJava operators and run the application to see the results.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试其他RxJava操作符并运行应用程序查看结果。
- en: You have learned how to use RxJava operators to manipulate the retrieved response
    from an external API before displaying them in the RecyclerView.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何使用RxJava操作符在显示它们之前操作来自外部API的检索响应。
- en: In the next section, you will learn how to use coroutines instead of RxJava
    to get data from an external API.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何使用协程而不是RxJava从外部API获取数据。
- en: Coroutines
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines were added in Kotlin 1.3 for managing background tasks such as making
    network calls and accessing files or databases. Kotlin coroutines are Google's
    official recommendation for asynchronous programming on Android. Their Jetpack
    libraries, such as LifeCycle, WorkManager, and Room, now include support for coroutines.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 1.3中添加了协程，用于管理后台任务，例如进行网络调用和访问文件或数据库。Kotlin协程是Google在Android上异步编程的官方推荐。他们的Jetpack库，如LifeCycle、WorkManager和Room，现在包括对协程的支持。
- en: With coroutines, you can write your code in a sequential way. The long-running
    task can be made into a suspending function, which when called can pause the thread
    without blocking it. When the suspending function is done, the current thread
    will resume execution. This will make your code easier to read and debug.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程，您可以以顺序方式编写代码。长时间运行的任务可以转换为挂起函数，当调用时可以暂停线程而不阻塞它。当挂起函数完成时，当前线程将恢复执行。这将使您的代码更易于阅读和调试。
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, if you have a function that calls the `getMovies` function,
    which fetches `movies` from your endpoint and then displays it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数标记为挂起函数，可以在其中添加`suspend`关键字；例如，如果您有一个调用`getMovies`函数的函数，该函数从您的端点获取`movies`然后显示它：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can make the `getMovies()` function a suspending function by adding the
    `suspend` keyword:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加`suspend`关键字将`getMovies()`函数设置为挂起函数：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the calling function will invoke `getMovies` and pause. After `getMovies`
    returns a list of movies, it will resume its task and display the movies.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用函数将调用`getMovies`并暂停。在`getMovies`返回电影列表后，它将恢复其任务并显示电影。
- en: 'Suspending functions can only be called in suspending functions or from a coroutine.
    Coroutines have a context, which includes the coroutine dispatcher. Dispatchers
    specify what thread the coroutine will use. There are three dispatchers you can
    use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起函数只能在挂起函数中调用，或者从协程中调用。协程具有上下文，其中包括协程调度程序。调度程序指定协程将使用的线程。您可以使用三个调度程序：
- en: '`Dispatchers.Main`: Used to run on Android''s main thread'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main`：用于在Android的主线程上运行'
- en: '`Dispatchers.IO`: Used for network, file, or database operations'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO`：用于网络、文件或数据库操作'
- en: '`Dispatchers.Default`: Used for CPU-intensive work'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Default`：用于CPU密集型工作'
- en: 'To change the context for your coroutine, you can use the `withContext` function
    for the code that you want to use a different thread with. For example, in your
    suspending function, `getMovies`, which gets movies from your endpoint, you can
    use `Dispatchers.IO`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改协程的上下文，可以使用`withContext`函数，用于您希望在不同线程中使用的代码。例如，在您的挂起函数`getMovies`中，该函数从您的端点获取电影，您可以使用`Dispatchers.IO`：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the next section, we will cover how to create coroutines.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何创建协程。
- en: Creating Coroutines
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建协程
- en: You can create a coroutine with the `async` and `launch` keywords. The `launch`
    keyword creates a coroutine and doesn't return anything. On the other hand, the
    `async` keyword returns a value that you can get later with the `await` function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`async`和`launch`关键字创建一个协程。`launch`关键字创建一个协程并不返回任何东西。另一方面，`async`关键字返回一个值，您可以稍后使用`await`函数获取。
- en: '`async` and `launch` must be created from `CoroutineScope`, which defines the
    lifecycle of the coroutine. For example, the coroutine scope for the main thread
    is `MainScope`. You can then create coroutines with the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`launch`必须从`CoroutineScope`创建，它定义了协程的生命周期。例如，主线程的协程范围是`MainScope`。然后，您可以使用以下内容创建协程：'
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can also create your own `CoroutineScope` instead of using `MainScope`
    by creating one with `CoroutineScope` and passing in the context for the coroutine.
    For example, to create `CoroutineScope` for use on a network call, you can define
    the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的`CoroutineScope`，而不是使用`MainScope`，通过使用`CoroutineScope`创建一个协程的上下文。例如，要为网络调用创建`CoroutineScope`，可以定义如下内容：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The coroutine can be canceled when the function is no longer needed, like when
    you close the activity. You can do that by calling the `cancel` function from
    `CoroutineScope`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要函数时，例如关闭活动时，可以取消协程。您可以通过从`CoroutineScope`调用`cancel`函数来实现：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A ViewModel also has a default `CoroutineScope` for creating coroutines: `viewModelScope`.
    Jetpack''s LifeCycle also has the `lifecycleScope` that you can use. `viewModelScope`
    is canceled when the ViewModel has been destroyed; `lifecycleScope` is also canceled
    when the lifecycle is destroyed. Thus, you no longer need to cancel them.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel还具有用于创建协程的默认`CoroutineScope`：`viewModelScope`。Jetpack的LifeCycle还具有`lifecycleScope`，您可以使用它。当ViewModel被销毁时，`viewModelScope`被取消；当生命周期被销毁时，`lifecycleScope`也被取消。因此，您不再需要取消它们。
- en: In the next section, you will be learning how to add coroutines to your project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何将协程添加到您的项目中。
- en: Adding Coroutines to Your Project
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将协程添加到您的项目中
- en: 'You can add coroutines to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将以下代码添加到您的`app/build.gradle`文件的依赖项中，将协程添加到您的项目中：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`kotlinx-coroutines-core` is the main library for coroutines while `kotlinx-coroutines-android`
    adds support for the main Android thread.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`kotlinx-coroutines-core`是协程的主要库，而`kotlinx-coroutines-android`为主要的Android线程添加了支持。'
- en: You can add coroutines in Android when making a network call or fetching data
    from a local database.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中进行网络调用或从本地数据库获取数据时，可以添加协程。
- en: 'If you''re using Retrofit 2.6.0 or above, you can mark the endpoint function
    as a suspending function with `suspend`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Retrofit 2.6.0或更高版本，可以使用`suspend`将端点函数标记为挂起函数：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, you can create a coroutine that will call the suspending function `getMovies`
    and display the list:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个协程，调用挂起函数`getMovies`并显示列表：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can also use LiveData for the response of your coroutines. LiveData is
    a Jetpack class that can hold observable data. You can add LiveData to your Android
    project by adding the following dependency:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用LiveData来响应您的协程。LiveData是一个Jetpack类，可以保存可观察的数据。通过添加以下依赖项，您可以将LiveData添加到Android项目中：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's try to use coroutines in an Android project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Android项目中使用协程。
- en: 'Exercise 13.03: Using Coroutines in an Android App'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.03：在Android应用程序中使用协程
- en: 'In this exercise, you will be using coroutines to fetch the list of popular
    movies from The Movie Database API. You can use the `Popular Movies` project in
    the previous exercise or make a copy of it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用协程从The Movie Database API获取热门电影列表。您可以使用上一个练习中的`Popular Movies`项目，或者复制一个：
- en: Open the `Popular Movies` project in Android Studio.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`Popular Movies`项目。
- en: 'Open the `app/build.gradle` file and remove the following dependencies:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/build.gradle`文件，并删除以下依赖项：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These dependencies will no longer be needed as you will be using coroutines
    instead of RxJava.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将使用协程而不是RxJava，因此将不再需要这些依赖项。
- en: 'In the `app/build.gradle` file, add the dependencies for the Kotlin coroutines:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中，添加Kotlin协程的依赖项：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: These will allow you to use coroutines in your project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您在项目中使用协程。
- en: 'Also, add the dependencies for the ViewModel and LiveData extension libraries:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加ViewModel和LiveData扩展库的依赖项：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Open the `MovieService` interface and replace it with the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieService`接口，并用以下代码替换它：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will mark `getPopularMovies` as a suspending function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`getPopularMovies`标记为挂起函数。
- en: 'Open `MovieRepository` and add the movies and error LiveData for the list of movies:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieRepository`并为电影列表添加movies和error LiveData：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Replace the `fetchMovies` function with a suspending function to retrieve the
    list from the endpoint:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fetchMovies`函数替换为一个挂起函数，以从端点检索列表：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Update the contents of `MovieViewModel` with the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`MovieViewModel`的内容：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `fetchPopularMovies` function has a coroutine, using `viewModelScope`, that
    will fetch the movies from `movieRepository`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchPopularMovies`函数有一个协程，使用`viewModelScope`，它将从`movieRepository`获取电影。'
- en: 'Open the `MovieApplication` file. In the `onCreate` function, remove the line
    containing `addCallAdapterFactory`. It should look like this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieApplication`文件。在`onCreate`函数中，删除包含`addCallAdapterFactory`的行。它应该是这样的：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Open the `MainActivity` class. Delete the `getMovies` function.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`类。删除`getMovies`函数。
- en: 'In the `onCreate` function, remove the call to `getMovies`. Then, at the end
    of the `onCreate` function, create `movieViewModel`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中，删除对`getMovies`的调用。然后，在`onCreate`函数的末尾，创建`movieViewModel`：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After that, add an observer to the `getPopularMovies` and `error` LiveData
    from `movieViewModel`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，向`movieViewModel`的`getPopularMovies`和`error` LiveData添加观察者：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will update the activity's RecyclerView with the movies fetched. The list
    of movies is filtered using Kotlin's `filter` function to only include movies
    released this year. They are then sorted by title using Kotlin's `sortedBy` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用Kotlin的`filter`函数对电影列表进行过滤，只包括今年发布的电影。然后使用Kotlin的`sortedBy`函数按标题排序。
- en: 'Run the application. You will see that the app will display a list of popular
    movie titles from the current year, sorted by title:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您将看到应用程序将显示今年发布的热门电影标题列表，按标题排序：
- en: '![Figure 13.7: The app displaying popular movies released this year, sorted
    by title'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：应用程序显示今年发布的热门电影，按标题排序'
- en: '](img/B15216_13_07.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_07.jpg)'
- en: 'Figure 13.7: The app displaying popular movies released this year, sorted by
    title'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：应用程序显示今年发布的热门电影，按标题排序
- en: You have used coroutines and LiveData to retrieve and display a list of popular
    movies from a remote data source without blocking the main thread.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用协程和LiveData从远程数据源检索和显示了一组热门电影列表，而不会阻塞主线程。
- en: Before passing the LiveData into the UI for display, you can also transform
    the data first. You will learn about that in the next section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在将LiveData传递到UI进行显示之前，您还可以首先转换数据。您将在下一节中了解到这一点。
- en: Transforming LiveData
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换LiveData
- en: Sometimes, the LiveData you pass from the ViewModel to the UI layer needs to
    be processed first before displaying. For example, you can only select a part
    of the data or do some processing on it first. In the previous exercise, you filtered
    the data to only select popular movies from the current year.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您从ViewModel传递到UI层的LiveData在显示之前需要进行处理。例如，您只能选择部分数据或者首先对其进行一些处理。在上一个练习中，您对数据进行了过滤，只选择了当前年份的热门电影。
- en: To modify LiveData, you can use the `Transformations` class. It has two functions,
    `Transformations.map` and `Transformations.switchMap`, that you can use.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改LiveData，您可以使用`Transformations`类。它有两个函数，`Transformations.map`和`Transformations.switchMap`，您可以使用。
- en: '`Transformations.map` modifies the value of LiveData into another value. This
    can be used for tasks like filtering, sorting, or formatting the data. For example,
    you can transform `movieLiveData` into string LiveData from the movie''s title:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transformations.map`将LiveData的值修改为另一个值。这可用于过滤、排序或格式化数据等任务。例如，您可以将`movieLiveData`从电影标题转换为字符串LiveData：'
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When `movieLiveData` changes value, `movieTitleLiveData` will also change based
    on the movie's title.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当`movieLiveData`的值发生变化时，`movieTitleLiveData`也会根据电影的标题发生变化。
- en: 'With `Transformations.switchMap`, you can transform the value of a LiveData
    into another LiveData. This is used when you want to do a specific task involving
    a database or network operation with the original LiveData. For example, if you
    have a LiveData representing a movie `id` object, you can transform that to movie
    LiveData by applying the function `getMovieDetails`, which returns LiveData of
    movie details from the `id` object (such as from another network or database call):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Transformations.switchMap`，您可以将LiveData的值转换为另一个LiveData。当您想要使用原始LiveData进行涉及数据库或网络操作的特定任务时使用。例如，如果您有一个表示电影`id`对象的LiveData，您可以通过应用函数`getMovieDetails`将其转换为电影LiveData，该函数从`id`对象（例如从另一个网络或数据库调用）返回电影详细信息的LiveData：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let's use LiveData transformations on the list of movies fetched using coroutines.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在使用协程获取的电影列表上使用LiveData转换。
- en: 'Exercise 13.04: LiveData Transformations'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04：LiveData转换
- en: 'In this exercise, you will be transforming the LiveData list of movies before
    passing them to the observers in the `MainActivity` file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在传递给`MainActivity`文件中的观察者之前转换电影的LiveData列表：
- en: In Android Studio, open the `Popular Movies` project you worked on in the previous
    exercise.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，打开您在上一个练习中使用的“热门电影”项目。
- en: 'Open the `MainActivity` file. In the `movieViewModel.popularMovies` observer
    in the `onCreate` function, remove the filter and `sortedBy` function calls. The
    code should look like the following:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`文件。在`onCreate`函数中的`movieViewModel.popularMovies`观察者中，删除过滤器和`sortedBy`函数调用。代码应如下所示：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This will now display all movies in the list without them being sorted by title.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将显示列表中的所有电影，而不按标题排序。
- en: 'Run the application. You should see all movies (even those from the past year),
    not sorted by title:![Figure 13.8: The app with unsorted popular movies'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您应该看到所有电影（甚至是去年的电影），而不是按标题排序：![图13.8：未排序的热门电影应用程序
- en: '](img/B15216_13_08.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_08.jpg)'
- en: 'Figure 13.8: The app with unsorted popular movies'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：未排序的热门电影应用程序
- en: 'Open the `MovieViewModel` class and update `popularMovies` with LiveData transformations
    to filter and sort the movies:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieViewModel`类，并使用LiveData转换来更新`popularMovies`以过滤和排序电影：
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will select the movies released last month and sort them by title before
    passing them to the UI observer in `MainActivity`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择上个月发布的电影，并在传递给`MainActivity`中的UI观察者之前按标题排序。
- en: 'Run the application. You will see that the app shows a list of popular movies
    from the current year, sorted by title:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您会看到应用程序显示了按标题排序的今年热门电影列表：
- en: '![Figure 13.9: The app with the movies released this year sorted by title'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9：按标题排序的今年发布的电影应用程序'
- en: '](img/B15216_13_05.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_05.jpg)'
- en: 'Figure 13.9: The app with the movies released this year sorted by title'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：按标题排序的今年发布的电影应用程序
- en: You have used LiveData transformations to modify the list of movies to select
    only the ones released this year. They were also sorted by title before passing
    them to the observers in the UI layer.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用了LiveData转换来修改电影列表，只选择今年发布的电影。它们在传递给UI层的观察者之前也按标题排序。
- en: Coroutines Channels and Flows
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程通道和流
- en: If your coroutine is fetching a stream of data or you have multiple data sources
    and you process the data one by one, you can use either Channel or Flow.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的协程正在获取数据流或您有多个数据源并且逐个处理数据，您可以使用通道或流。
- en: Channels allow you to pass data between different coroutines. They are a hot
    stream of data. It will run and emit values the moment they are called, even when
    there's no listeners. Flows, meanwhile, are cold asynchronous streams. They only
    emit values when the values are collected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通道允许在不同的协程之间传递数据。它们是热数据流。它将在被调用时运行并发出值，即使没有监听器。而流是冷异步流。只有在收集值时才会发出值。
- en: To learn more about Channels and Flows, you can go to [https://kotlinlang.org](https://kotlinlang.org).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关通道和流的更多信息，您可以访问[https://kotlinlang.org](https://kotlinlang.org)。
- en: RxJava versus Coroutines
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava与协程
- en: Both RxJava and coroutines can be used for doing background tasks in Android,
    such as network calls or database operations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava和协程都可以用于在Android中执行后台任务，例如网络调用或数据库操作。
- en: Which one should you use then? While you can use both in your application, for
    example, RxJava for one task and coroutines for another, you can also use them
    together with `LiveDataReactiveStreams` or `kotlinx-coroutines-rx3`. This, however,
    will increase the number of dependencies you use and the size of your application.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应该使用哪一个？虽然您可以在应用程序中同时使用两者，例如，对于一个任务使用RxJava，对于另一个任务使用协程，您还可以与`LiveDataReactiveStreams`或`kotlinx-coroutines-rx3`一起使用它们。然而，这将增加您使用的依赖项数量和您的应用程序的大小。
- en: 'So, RxJava or coroutines? The following table shows the differences between
    the two:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，RxJava还是协程？以下表格显示了两者之间的区别：
- en: '![Figure 13.10: Differences between coroutines and RxJava'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10：协程和RxJava之间的区别'
- en: '](img/B15216_13_10.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_10.jpg)'
- en: 'Figure 13.10: Differences between coroutines and RxJava'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：协程和RxJava之间的区别
- en: Let's move on to the next activity.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个活动。
- en: 'Activity 13.01: Creating a TV Guide App'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：创建电视指南应用程序
- en: A lot of people watch television. Most of the time, though, they are not sure
    what TV shows are currently on the air. Suppose you wanted to develop an app that
    can display a list of these shows from The Movie Database API's `tv/on_the_air`
    endpoint using Kotlin coroutines and LiveData.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人看电视。然而，大多数时候，他们不确定当前有哪些电视节目正在播放。假设你想开发一个应用程序，可以使用Kotlin协程和LiveData从The Movie
    Database API的`tv/on_the_air`端点显示这些节目的列表。
- en: 'The app will have two screens: the main screen and the details screen. On the
    main screen, you will display a list of the TV shows that are on the air. The
    TV shows will be sorted by name. Clicking on a TV show will open the details screen,
    which displays more information about the selected TV show.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将有两个屏幕：主屏幕和详情屏幕。在主屏幕上，您将显示正在播出的电视节目列表。电视节目将按名称排序。点击一个电视节目将打开详情屏幕，显示有关所选电视节目的更多信息。
- en: 'Steps for completion:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤：
- en: Create a new project in Android Studio and name it `TV Guide`. Set its package name.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个名为`TV Guide`的新项目，并设置其包名称。
- en: Add the `INTERNET` permission in the `AndroidManifest.xml` file.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中添加`INTERNET`权限。
- en: Add the Java 8 compatibility and the dependencies for the RecyclerView, Glide,
    Retrofit, RxJava, RxAndroid, Moshi, ViewModel, and LiveData libraries in your
    `app/build.gradle` file.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中，添加Java 8兼容性和RecyclerView、Glide、Retrofit、RxJava、RxAndroid、Moshi、ViewModel和LiveData库的依赖项。
- en: Add a `layout_margin` dimension value.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`layout_margin`维度值。
- en: Create a `view_tv_show_item.xml` layout file with `ImageView` for the poster
    and `TextView` for the name of the TV show.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`view_tv_show_item.xml`布局文件，其中包含用于海报的`ImageView`和用于电视节目名称的`TextView`。
- en: In the `activity_main.xml` file, remove the Hello World TextView and add a RecyclerView
    for the list of TV shows.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`文件中，删除Hello World TextView，并添加一个用于电视节目列表的RecyclerView。
- en: Create a model class, `TVShow`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TVShow`的模型类。
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DetailsActivity`的新活动，使用`activity_details.xml`作为布局文件。
- en: Open the `AndroidManifest.xml` file and add the `parentActivityName` attribute
    in the `DetailsActivity` declaration.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`文件，在`DetailsActivity`声明中添加`parentActivityName`属性。
- en: In `activity_details.xml`, add the views for the details of the TV show.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_details.xml`中，添加用于电视节目详情的视图。
- en: In `DetailsActivity`, add the code for displaying the details of the TV show selected.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DetailsActivity`中，添加用于显示所选电视节目详情的代码。
- en: Create a `TVShowAdapter` adapter class for the list of TV shows.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为电视节目列表创建一个`TVShowAdapter`适配器类。
- en: Create another class named `TVResponse` for the response you get from the API
    endpoint for the TV shows on air.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`TVResponse`的类，用于从API端点获取正在播出的电视节目的响应。
- en: Create a `TelevisionService` class for adding the Retrofit method.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TelevisionService`类，用于添加Retrofit方法。
- en: Create a `TVShowRepository` class with a constructor for `tvService`, and properties
    for `apiKey` and `tvShows`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TVShowRepository`的类，其中包含`tvService`的构造函数，以及`apiKey`和`tvShows`的属性。
- en: Create a suspending function to retrieve the list of TV shows from the endpoint.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个挂起函数，从端点检索电视节目列表。
- en: Create a `TVShowViewModel` class with a constructor for `TVShowRepository`.
    Add a `getTVShows` function that returns the LiveData for the list of TV shows
    and `fetchTVShows` that fetches the list from the repository.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TVShowViewModel`类，其中包含`TVShowRepository`的构造函数。添加一个`getTVShows`函数，返回电视节目列表的LiveData，以及`fetchTVShows`函数，从存储库中获取列表。
- en: Create an application class named `TVApplication` with a property for `TVShowRepository`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TVApplication`的应用程序类，其中包含`TVShowRepository`的属性。
- en: Set `TVApplication` as the value for the application in the `AndroidManifest.xml`
    file.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TVApplication`设置为`AndroidManifest.xml`文件中应用程序的值。
- en: Open `MainActivity` and add the code to update the RecyclerView when the LiveData
    from `ViewModel` updates its value. Add a function that will open the details
    screen when clicking on a TV show from the list.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`并添加代码，以在`ViewModel`更新其值时更新RecyclerView。添加一个函数，点击列表中的电视节目将打开详情屏幕。
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the show details. The
    main screen and details screen will be similar to the following figure:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序。该应用程序将显示一个电视节目列表。点击一个电视节目将打开详情活动，显示节目详情。主屏幕和详情屏幕将类似于以下图示：
- en: '![Figure 13.11: The main screen and details screen of the TV Guide app'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11：电视指南应用的主屏幕和详情屏幕'
- en: '](img/B15216_13_11.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_13_11.jpg)'
- en: 'Figure 13.11: The main screen and details screen of the TV Guide app'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：电视指南应用的主屏幕和详情屏幕
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused on doing background operations with RxJava and coroutines.
    Background operations are used for long-running tasks such as accessing data from
    the local database or a remote server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了使用RxJava和协程进行后台操作。后台操作用于长时间运行的任务，例如从本地数据库或远程服务器访问数据。
- en: 'You started with the basics of RxJava: observables, observers, and operators.
    Observables are the data sources that provide data. The observers listen to observables;
    when an observable emits data, observers can react accordingly. Operators allow
    you to modify data from an observable to the data you need before it can be passed
    to the observers.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您从RxJava的基础知识开始：可观察对象、观察者和操作符。可观察对象是提供数据的数据源。观察者监听可观察对象；当可观察对象发出数据时，观察者可以做出相应反应。操作符允许您修改可观察对象的数据，使其能够传递给观察者所需的数据。
- en: Next, you learned how to make RxJava calls asynchronous with schedulers. Schedulers
    allow you to set the thread through which the required action will be done. The
    `subscribeOn` function is used for setting which thread your observable will run
    on, and the `observeOn` function allows you to set where the next operators will
    be executed. You then fetched data from an external API with RxJava and used RxJava
    operators to filter, sort, and make modifications to the data.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您学习了如何使用调度程序使RxJava调用异步。调度程序允许您设置执行所需操作的线程。`subscribeOn`函数用于设置可观察对象将在哪个线程上运行，`observeOn`函数允许您设置下一个操作将在哪里执行。然后，您使用RxJava从外部API获取数据，并使用RxJava操作符对数据进行过滤、排序和修改。
- en: Next, you learned about using Kotlin coroutines, which is Google's recommended
    solution for asynchronous programming. You can make a background task into a suspending
    function with the `suspend` keyword. Coroutines can be started with the `async`
    or `launch` keywords.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习使用Kotlin协程，这是Google推荐的异步编程解决方案。你可以使用`suspend`关键字将后台任务转换为挂起函数。协程可以使用`async`或`launch`关键字启动。
- en: You've learned how to create suspending functions and how to start coroutines.
    You also used dispatchers to change the thread where a coroutine runs. Finally,
    you used coroutines for doing network calls and modified the data retrieved with
    the LiveData transformation functions `map` and `switchMap`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何创建挂起函数以及如何启动协程。你还使用调度程序来改变协程运行的线程。最后，你使用协程来进行网络调用，并使用LiveData转换函数`map`和`switchMap`修改检索到的数据。
- en: In the next chapter, you will learn about architecture patterns. You will learn
    about patterns such as **MVVM** (**Model-View-ViewModel**) and how you can improve
    the architecture of your app.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于架构模式。你将学习诸如**MVVM**（**Model-View-ViewModel**）之类的模式，以及如何改进应用程序的架构。
