- en: Chapter 1. Introduction and Installation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍和安装
- en: Welcome to the wonderful world of reactive (functional) programming in JavaScript!
    In this book, we will cover *the good parts* of JavaScript, although we will not
    follow it religiously. We will cover functional programming, reactive programming,
    and the ReactJS library and integrate all of these into functional reactive programming
    with JavaScript. If you are going to study reactive programming, it is our suggestion
    that you seriously consider functional reactive programming, including learning
    functional programming as much you can. In this context, the whole of functional
    reactive programming is more than the sum of its parts. We will be applying reactive
    programming to JavaScript user interface development. User interfaces are one
    domain in which **functional reactive programming** (**FRP**), really shines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到JavaScript中反应式（函数式）编程的美妙世界！在本书中，我们将涵盖JavaScript的*好部分*，尽管我们不会完全遵循它。我们将涵盖函数式编程、反应式编程和ReactJS库，并将所有这些整合到JavaScript的函数式反应式编程中。如果您要学习反应式编程，我们建议您认真考虑函数式反应式编程，包括尽可能多地学习函数式编程。在这种情况下，整个函数式反应式编程的总和大于其各部分。我们将把反应式编程应用到JavaScript用户界面开发中。用户界面是**函数式反应式编程**（**FRP**）真正闪耀的领域。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: 'A 10,000-foot overview of the subject-matter, including:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题的概述，包括：
- en: A discussion of an easier approach to user interface programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更简单的用户界面编程方法的讨论
- en: A brief discussion of programming paradigms, such as functional and reactive
    programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对编程范式的简要讨论，如函数式和反应式编程
- en: An overview of the chapters in this book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中各章的概述
- en: A look at how to install some of the tools used over the course of this book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何安装本书中使用的一些工具
- en: A 10,000-foot overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个概述
- en: There are a lot of things that can be stated, but (functional) reactive programming
    may be easier than you think. Today, much that has been written about functional
    reactive programming is intimidating, much like the instructions for closures
    a few years ago.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情可以说，但（函数式）反应式编程可能比您想象的要容易。今天，关于函数式反应式编程的大部分内容都令人生畏，就像几年前关于闭包的说明一样。
- en: An easier way to handle user interface programming
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理用户界面编程的更简单方法
- en: 'Years ago, when I first began to study JavaScript, I picked one site and literally
    took everything from it that I needed to understand to perform objected-oriented
    information hiding, that is, how to create a JavaScript object that had private
    fields. I read perhaps two or three chapters that were dense with theoretical
    computer science and 10-15 percent of the introduction before giving up. Then
    I saw how easy it was to use a closure to create an object with private fields
    on a simple *monkey see, monkey do* basis:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，当我开始学习JavaScript时，我选择了一个网站，从中我学到了我需要理解的一切，以执行面向对象的信息隐藏，也就是如何创建一个具有私有字段的JavaScript对象。我可能读了两三章，这些章节充满了理论计算机科学，还有引言的10-15%，然后我放弃了。然后我发现使用闭包来创建一个具有私有字段的对象是多么容易，只是简单的*学来用去*：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Right now, functional reactive programming is in the state in which JavaScript
    closures were some years back. The amount of theory you *have to* read before
    you can start reactive programming is astounding, and large portions of the literature
    are of a PhD reading level. That's bad news. But the good news is that you don't
    have to wade through so much reading.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数式反应式编程正处于JavaScript闭包几年前的状态。在开始反应式编程之前，您必须阅读的理论数量令人震惊，而且大部分文献都是博士阅读水平的。这是个坏消息。但好消息是，您不必阅读那么多。
- en: The purpose of this book is to provide something comparable to the *monkey see,
    monkey do* way of conveying how to use a closure to make a JavaScript object with
    private fields. Theory, as such, is not bad, nor is it a problem to introduce
    theory for a discussion, but making a full-fledged dissertation's theoretical
    backing as the price to do something simple is a problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的是提供一种类似于*学来用去*的方式，传达如何使用闭包来创建具有私有字段的JavaScript对象。理论本身并不坏，引入理论进行讨论也不是问题，但是以做一些简单事情的代价来制作一篇完整的论文的理论支持是一个问题。
- en: It is our hope that this book will let you understand why building, for instance,
    a game UI in JavaScript is easier with functional reactive programming than with
    jQuery.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这本书能让您明白，例如，使用函数式反应式编程在JavaScript中构建游戏用户界面比使用jQuery更容易。
- en: Programming paradigms
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程范式
- en: There are multiple programming paradigms around, and not all are mutually exclusive.
    Many programming languages are *multiparadigm* languages, supporting the use of
    more than one paradigm, including not only JavaScript, but also the likes of OCaml,
    PHP, Python, and Perl.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 周围有多种编程范式，并且并非所有都是互斥的。许多编程语言都是*多范式*语言，支持使用多种范式，包括不仅仅是JavaScript，还有OCaml、PHP、Python和Perl等语言。
- en: Note that you can at least sometimes use a paradigm with a language that is
    not explicitly designed to support it. Object-oriented programming was originally
    formulated not for languages such as Java or Ruby that are specifically intended
    to support object-oriented programming, but as matter of an engineering discipline
    originally used in languages that predate object-oriented programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您至少有时可以使用一种语言来支持范式，而该语言并非明确设计为支持它。面向对象编程最初并不是为像Java或Ruby这样专门用于支持面向对象编程的语言而制定的，而是作为一种工程学科的问题，最初是在早于面向对象编程的语言中使用的。
- en: 'Among the programming paradigms, we now have the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程范式中，我们现在有以下内容：
- en: '**Aspect-oriented programming**: Some have suggested that the professional
    development of a programmer moves from procedural programming to object-oriented
    programming, then to aspect-oriented programming, and finally to functional programming.
    A canonical example of an aspect-oriented concern, for an aspect that is spread
    through the program in naïve usage, is logging. Aspect-oriented programming deals
    with cross-cutting aspects of programming, such as security, the diagnostic exposure
    of a state, and logging.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面的编程：有人建议程序员的专业发展从过程式编程转向面向对象编程，然后是面向方面的编程，最后是函数式编程。面向方面编程的一个典型例子是日志记录，它是在程序中通过天真的用法传播的一个方面。面向方面编程处理编程的横切面，如安全性、状态的诊断暴露和日志记录。
- en: '**Declarative programming**: One of the key concepts of functional reactive
    programming is that it is declarative rather than imperative. In other words,
    *c = a + b* does not mean take the present value of *a*, add the present value
    of *b*, and store their sum in *c*. Instead, we declare a lasting relationship
    that works a bit like *C1 = A1 + B1* in a spreadsheet. If *A1* or *B1* changes,
    *C1* is immediately affected by the change. What is stored in *C1* is not the
    value of *A1* plus the value of *B1* at the time of assignment, but something
    more lasting from which individual values may be obtained in a *print on demand*
    fashion.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程：函数式响应式编程的一个关键概念是它是声明式的，而不是命令式的。换句话说，*c = a + b*并不意味着取*a*的当前值，加上*b*的当前值，并将它们的总和存储在*c*中。相反，我们声明一个持久的关系，它的工作方式有点像电子表格中的*C1
    = A1 + B1*。如果*A1*或*B1*发生变化，*C1*会立即受到影响。存储在*C1*中的不是赋值时的*A1*值加上*B1*值的结果，而是更持久的东西，可以按需获取单个值。
- en: '**Defensive programming**: Analogous to defensive driving, defensive coding
    means writing code that behaves correctly when it is given something defective.
    Functional reactive programming is, among other things, an approach to either
    functioning correctly or degrading gracefully in the face of network issues and
    nonideal, real-world conditions.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程：类似于防御性驾驶，防御性编码意味着编写的代码在给定有缺陷的输入时能够正确地运行。函数式响应式编程是一种在面对网络问题和非理想的现实条件时，要么能够正确运行，要么能够在恶劣条件下优雅地降级的方法。
- en: '**Functional programming**: Here, the term *function* has its mathematical
    rather than programming meaning. In imperative programming, functions can (and
    most often, they do) manipulate states. Hence, an `init()` function might initialize
    all of the data that a program initially needs to run initially. A function is
    something that takes zero or more inputs and returns a result. For example, *f(x)
    = 3x+1*, *g(x) = sin(x)*, and *h(x, y) = x''(y)* (the derivative of *x* at *y*)
    are all mathematical functions; none of them command any manipulation of stateful
    data. A pure function is a function under a mathematical definition that excludes
    telling how to deal with states. Functional programming also allows and often
    includes, with the last derivative-based example, higher order functions, or functions
    that act on functions (in calculus, a derivative or an integral represents a higher
    order function, and iterative integration includes a higher order function that
    takes another higher order function as the input). Problems whose solutions center
    on abstract functions that operate on abstract functions tend to be more appealing
    to computer science types than something really used in the business world. The
    higher order functions explored here will be relatively concrete. You need not
    use higher order functions all the time, and once you''ve grasped the core concepts,
    they are not hard to use.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程：这里，术语*函数*具有数学意义，而不是编程意义。在命令式编程中，函数可以（而且通常是）操作状态。因此，`init()`函数可能会初始化程序最初运行所需的所有数据。函数是接受零个或多个输入并返回结果的东西。例如，*f(x)
    = 3x+1*，*g(x) = sin(x)*和*h(x, y) = x'(y)*（在*y*处的*x*的导数）都是数学函数；它们都不涉及任何状态数据的操作。纯函数是在数学定义下排除了如何处理状态的函数。函数式编程还允许并经常包括高阶函数，或者作用于函数的函数（在微积分中，导数或积分代表一个高阶函数，迭代积分包括一个以另一个高阶函数作为输入的高阶函数）。解决方案集中在抽象函数上的问题，这些函数操作抽象函数，往往对计算机科学类型更具吸引力，而不是真正用于商业世界的东西。这里探讨的高阶函数将是相对具体的。你不需要一直使用高阶函数，一旦掌握了核心概念，它们并不难使用。
- en: '**Imperative programming**: Imperative programming is a common way of programming,
    and for the majority of programmers who are first taught imperative programming,
    it may seem the most natural way to work. Functional reactive programming''s marketing
    proposal includes a live alternative to this basic approach. An alternative to
    the natural-seeming tendency towards imperative programming is found in functional
    reactive programming''s declarative programming, pure functions (including higher
    order functions) in functional programming, and the time series of reactive programming.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式编程：命令式编程是一种常见的编程方式，对于大多数首次接触命令式编程的程序员来说，它可能是最自然的工作方式。函数式响应式编程的营销提案包括了对这种基本方法的另类选择。函数式响应式编程的声明式编程、函数式编程中的纯函数（包括高阶函数）以及响应式编程的时间序列，提供了一种对命令式编程自然倾向的替代方案。
- en: '**Information hiding**: Steve McConnel''s *Code Complete* describes several
    methodologies, and tells us which are optimal for different settings (the sweet
    spot for procedural programming is on smaller projects than on object-oriented
    programming, for instance). For information hiding alone, his recommendation was
    *use this as much as possible*. In generic information hiding developments, a
    large project is approached by walling off secrets within the larger area, and
    larger secrets are divided by walling off subsecrets. A large portion of procedural
    programming, object-oriented programming, and functional programming alike is
    intended to facilitate information hiding. Information hiding is the software
    engineering concern behind the Law of Demeter, for example, you may have up to
    one dot in a method call `(foo.bar())`, but not two `(foo.baz.bar())`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息隐藏：Steve McConnel的《代码大全》描述了几种方法，并告诉我们哪些方法对不同的环境最为理想（例如，对于过程式编程，最适合的环境是小型项目而不是面向对象编程）。对于仅仅信息隐藏而言，他的建议是“尽可能多地使用这个”。在通用信息隐藏的发展中，一个大型项目通过在更大的区域内封装秘密来处理，而更大的秘密则通过封装子秘密来分割。过程式编程、面向对象编程和功能性编程的一个很大部分都是为了促进信息隐藏。信息隐藏是洛德米特法则背后的软件工程问题，例如，你可以在方法调用中有一个点`(foo.bar())`，但不能有两个点`(foo.baz.bar())`。
- en: '**Object-oriented programming**: Instead of having a monolithic architecture,
    a program is segmented into objects. These objects have their own methods and
    fields and may in turn be segmented into further objects. This offers an acceptable
    level of information hiding for larger projects than procedural programming, even
    if object-oriented programming more or less starts with procedural programming
    and builds on top of it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程：程序被分割成对象，而不是具有单一结构。这些对象有自己的方法和字段，可能又被分割成更多的对象。这为比过程式编程更大的项目提供了一个可接受的信息隐藏水平，即使面向对象编程基本上是从过程式编程开始并在其基础上构建。
- en: '**Patterns**: Patterns are not a recipe for good software, but at a higher
    level of human abstraction, they provide a way of talking about the best recurring
    solutions so as to avoid reinventing from scratch what has already been solved.
    Also, specific patterns are taken into the limelight, including MVC and now the
    **Observer** pattern, which is often not mentioned in relation to reactive programming
    despite being a founding ingredient.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式：模式并不是好软件的配方，但在更高层次的人类抽象中，它们提供了一种谈论最佳重复解决方案的方式，以避免从头开始重新发明已经解决的问题。此外，特定的模式被提到了台面上，包括MVC和现在的观察者模式，尽管观察者模式通常不会在与响应式编程相关的情况下提到，但它却是一个重要的组成部分。
- en: '**Procedural programming**: Procedural programming is one of the oldest of
    the methodologies mentioned, and it was meant to provide some order to the spaghetti
    code fostered by the even older *goto-based* flow control. Perhaps we can criticize
    procedural programming for not doing enough once object-oriented programming,
    aspect-oriented programming, and object-oriented design patterns are available.
    It is the right thing to move on from procedural programming when you have tools
    to push further than procedural programming from a rat''s nest of gotos, the pointer
    as the goto of data structures, and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程式编程：过程式编程是提到的方法中最古老的之一，它旨在为早期基于*goto*流程控制的意大利面代码提供一些秩序。也许我们可以批评过程式编程，因为一旦面向对象编程、面向方面编程和面向对象设计模式可用，它就不再做足够多的事情。当你有工具可以从goto的鼠窝、指针作为数据结构的goto等方面进一步推进时，从过程式编程转向其他编程是正确的选择。
- en: '**Reactive programming**: Suppose functional programming is, in large measure,
    programming where functions have first-class status and it is possible to make
    higher order functions (functions that act on other functions as input). Then
    reactive programming is, in large measure, programming where time series (functions
    that have different values over time) have first-class status. For music, games,
    user interfaces, and some other use cases, calculating the right value for the
    present moment is an area where reactive programming shines.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程：假设功能性编程在很大程度上是指函数具有第一类地位，并且可以创建高阶函数（作用于其他函数的函数）。那么响应式编程在很大程度上是指时间序列（随时间具有不同值的函数）具有第一类地位。对于音乐、游戏、用户界面和其他一些用例，计算当前时刻的正确值是响应式编程的一个亮点。
- en: '**Functional reactive programming**: Functional reactive programming is reactive
    programming built on functional building blocks, and in which both functions and
    time series are first-class entities. There are some useful, and surprisingly
    simple, functions that act on one time series to provide another time series from
    it (either of these series can be acted on by other functions on time series).
    One of the major selling points of functional reactive programming is that it
    provides a more graceful and much more maintainable approach than following your
    nose straight into the *callback hell*.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性响应式编程：功能性响应式编程是建立在功能构件上的响应式编程，其中函数和时间序列都是第一类实体。有一些有用且令人惊讶地简单的函数，可以作用于一个时间序列，从而提供另一个时间序列（这两个序列中的任何一个都可以被其他时间序列的函数所作用）。功能性响应式编程的一个主要卖点是，它提供了比直接陷入“回调地狱”更为优雅和可维护的方法。
- en: Installing the tools required
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装所需工具
- en: Many readers will be comfortable enough with simply installing Chrome and Node.js,
    if they were not already installed some time ago. For those who would prefer step-by-step
    directions, here are the details of installing the appropriate software.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多读者可能已经安装了Chrome和Node.js，如果他们之前没有安装的话，他们可能会感到很舒适。对于那些更喜欢逐步指导的人，以下是安装适当软件的详细信息。
- en: Google Chrome can be installed from [http://google.com/chrome](http://google.com/chrome).
    Note that for some Linux distributions, Chrome may or may not be available from
    your package manager. Google Chrome is an obvious choice to think of for something
    to include in a distribution's packages, but licensing concerns may list Chrome
    as non-free due to some of its parts, meaning that as far as the distribution
    maintainers are concerned, you may be welcome to use this, but we're not comfortable
    including it in a free-only package repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌浏览器可以从[http://google.com/chrome](http://google.com/chrome)安装。请注意，对于某些Linux发行版，Chrome可能无法从软件包管理器中获取。谷歌浏览器是一个明显的选择，可以考虑将其包含在发行版的软件包中，但由于许可问题，Chrome的某些部分可能被列为非免费，这意味着就发行版维护者而言，您可以使用它，但我们不愿意将其包含在仅免费的软件包存储库中。
- en: Node.js is available from [http://nodejs.org/download](http://nodejs.org/download).
    If you are running Linux, it is probably better to obtain it through your package
    manager. Note that Node.js comes with its own package manager, npm, which can
    be used to download packages that can be used under Node.js.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以从[http://nodejs.org/download](http://nodejs.org/download)获取。如果您使用Linux，最好通过软件包管理器获取。请注意，Node.js自带其自己的软件包管理器npm，可用于下载在Node.js下使用的软件包。
- en: The useful Starter Kit for ReactJS is available from [http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的ReactJS入门套件可以从[http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)获取。
- en: The following instructions are given for Windows 8.1 (I prefers to develop in
    Mac or Linux, but is writing for Windows 8.1 as a common lingua franca).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明适用于Windows 8.1（我更喜欢在Mac或Linux上开发，但是写作Windows 8.1作为通用语言）。
- en: Installing Google Chrome
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装谷歌浏览器
- en: 'We will be using Google Chrome as the primary reference browser:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用谷歌浏览器作为主要的参考浏览器：
- en: To download it, go to [http://google.com/chrome](http://google.com/chrome),
    and click on the **Download now** button to the left, towards the bottom, as shown
    here:![Installing Google Chrome](img/B04108_01_01.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载它，转到[http://google.com/chrome](http://google.com/chrome)，然后点击左下方的**立即下载**按钮，如下所示：![安装谷歌浏览器](img/B04108_01_01.jpg)
- en: Next, click on the **Accept and Install** button down and to the right, as shown
    in the following screenshot:![Installing Google Chrome](img/B04108_01_02.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击右下方的**接受并安装**按钮，如下面的截图所示：![安装谷歌浏览器](img/B04108_01_02.jpg)
- en: After that, click on the **Run** button when asked whether you want to run or
    save the installer, as shown here:![Installing Google Chrome](img/B04108_01_03.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当询问是否要运行或保存安装程序时，点击**运行**按钮，如下所示：![安装谷歌浏览器](img/B04108_01_03.jpg)
- en: Next, authorize Chrome's installer to make changes to the system, as shown in
    the following screenshot:![Installing Google Chrome](img/B04108_01_04.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，授权Chrome的安装程序对系统进行更改，如下面的截图所示：![安装谷歌浏览器](img/B04108_01_04.jpg)
- en: Then click on the **Next** button to install Chrome, as shown in the following
    screenshot:![Installing Google Chrome](img/B04108_01_05.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**下一步**按钮安装Chrome，如下面的截图所示：![安装谷歌浏览器](img/B04108_01_05.jpg)
- en: Wait a minute for it to install and then if you are willing, set Chrome as your
    default browser:![Installing Google Chrome](img/B04108_01_06.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一分钟进行安装，然后如果愿意，将Chrome设置为默认浏览器：![安装谷歌浏览器](img/B04108_01_06.jpg)
- en: And that's it!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: Installing Node.js
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: Installing Node.js is straightforward and it makes it easy to start serving
    HTTP using JavaScript as the only language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js很简单，它使得使用JavaScript作为唯一语言来启动HTTP服务变得容易。
- en: Go to [http://nodejs.org/download](http://nodejs.org/download):![Installing
    Node.js](img/B04108_01_07.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[http://nodejs.org/download](http://nodejs.org/download)：![安装Node.js](img/B04108_01_07.jpg)
- en: Click on the **Windows Installer** and wait for the installer to download. Then
    click on the bottom-left part of the window, as shown in this screenshot:![Installing
    Node.js](img/B04108_01_08.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Windows安装程序**，等待安装程序下载。然后点击窗口的左下角，如此截图所示：![安装Node.js](img/B04108_01_08.jpg)
- en: When the installer starts, click on **Next**, as follows:![Installing Node.js](img/B04108_01_09.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当安装程序启动时，点击**下一步**，如下所示：![安装Node.js](img/B04108_01_09.jpg)
- en: Then click on the checkbox to accept the terms of the agreement, as shown here:![Installing
    Node.js](img/B04108_01_10.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击复选框接受协议条款，如下所示：![安装Node.js](img/B04108_01_10.jpg)
- en: After that, click on the **Next** button to continue, as shown in the following
    screenshot:![Installing Node.js](img/B04108_01_11.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击**下一步**按钮继续，如下截图所示：![安装Node.js](img/B04108_01_11.jpg)
- en: When asked where to install the software, click on the **Next** button, as shown
    in this screenshot:![Installing Node.js](img/B04108_01_12.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问要安装软件的位置时，点击**下一步**按钮，如下截图所示：![安装Node.js](img/B04108_01_12.jpg)
- en: Then click on **Next** to move forward, as shown in the next screenshot. Customize
    the features if you want to:![Installing Node.js](img/B04108_01_13.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**下一步**继续，如下一截图所示。如果需要，自定义功能：![安装Node.js](img/B04108_01_13.jpg)
- en: After that, click on the **Install** button to go ahead with the installation,
    as shown here:![Installing Node.js](img/B04108_01_14.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击**安装**按钮继续安装，如下所示：![安装Node.js](img/B04108_01_14.jpg)
- en: Finally, click on the **Finish** button to finish installing Node.js, as shown
    in this screenshot:![Installing Node.js](img/B04108_01_15.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**完成**按钮完成安装Node.js，如下截图所示：![安装Node.js](img/B04108_01_15.jpg)
- en: Authorize the installer to make changes to your computer, shown as follows:![Installing
    Node.js](img/B04108_01_16.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权安装程序对计算机进行更改，如下所示：![安装Node.js](img/B04108_01_16.jpg)
- en: Installing the Starter Kit for ReactJS
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装ReactJS的入门套件
- en: 'To install the Starter Kit perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装入门套件，请执行以下步骤：
- en: Go to [http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)
    and you will see a screen similar to the following screenshot:![Installing the
    Starter Kit for ReactJS](img/B04108_01_17.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)，您将看到一个类似于以下截图的屏幕：![安装ReactJS的入门套件](img/B04108_01_17.jpg)
- en: Click on **Download Starter Kit 0.12.0** to start the download (this will be
    visible in the bottom-left corner), as shown in the preceding screenshot.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**下载入门套件0.12.0**开始下载（这将显示在左下角），如前面的截图所示。
- en: You will see a ZIP file downloaded at the bottom:![Installing the Starter Kit
    for ReactJS](img/B04108_01_18.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个ZIP文件在底部下载：![安装ReactJS的入门套件](img/B04108_01_18.jpg)
- en: From here, you should be able to explore the contents of the ZIP file:![Installing
    the Starter Kit for ReactJS](img/B04108_01_19.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，您应该能够浏览ZIP文件的内容：![安装ReactJS的入门套件](img/B04108_01_19.jpg)
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a brief overview of programming paradigms to suggest
    where functional reactive programming might fit, and installed the basic tools.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要概述了编程范式，以表明函数式响应式编程可能适用的领域，并安装了基本工具。
- en: We will be moving on to discussing JavaScript in the next chapter. The basics
    of Node.js are discussed in *Appendix*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论JavaScript。Node.js的基础知识在*附录*中讨论。
