- en: Chapter 3. Building Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。构建镜像
- en: In the previous chapter, we explained the image and container handling, and
    its housekeeping techniques and tips to you in detail. In addition to that, we
    also have explained the standard procedure for installing any software package
    on a Docker container and then converting the container into an image for future
    usage and maneuvering. This chapter is quite different from the earlier ones,
    and it is in this chapter to clearly describe how the Docker images are built
    using `Dockerfile`, which is the standard way to bring forth the highly usable
    Docker images. Leveraging `Dockerfile` is the most competent way to build powerful
    images for the software development community.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细向您解释了镜像和容器处理以及其维护技巧和提示。除此之外，我们还解释了在Docker容器上安装任何软件包的标准过程，然后将容器转换为镜像以供将来使用和操作。本章与之前的章节非常不同，它清楚地描述了如何使用`Dockerfile`构建Docker镜像的标准方式，这是为软件开发社区提供高度可用的Docker镜像的最有力的方式。利用`Dockerfile`是构建强大镜像的最有竞争力的方式。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Docker's integrated image building system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker集成的镜像构建系统
- en: Quick overview of the Dockerfile's syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile的语法快速概述
- en: '`Dockerfile` build instructions'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile`构建指令'
- en: How Docker stores images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker如何存储镜像
- en: Docker's integrated image building system
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker集成的镜像构建系统
- en: The Docker images are the fundamental building blocks of containers. These images
    could be very basic operating environments, such as `busybox` or `ubuntu,` as
    we found while experimenting with Docker in the previous chapters. Alternatively,
    the images could craft advanced application stacks for the enterprise and cloud
    IT environments. As we discussed in the previous chapter, we could craft an image
    manually by launching a container from a base image, install all the required
    applications, make the necessary configuration file changes, and then commit the
    container as an image.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是容器的基本构建模块。这些镜像可以是非常基本的操作环境，比如我们在前几章中使用Docker进行实验时发现的`busybox`或`ubuntu`。另外，这些镜像也可以构建用于企业和云IT环境的高级应用程序堆栈。正如我们在上一章中讨论的，我们可以通过从基础镜像启动容器，安装所有所需的应用程序，进行必要的配置文件更改，然后将容器提交为镜像来手动制作镜像。
- en: As a better alternative, we could resort to the automated approach of crafting
    the images by using `Dockerfile`. `Dockerfile` is a text-based build script that
    contains special instructions in a sequence for building the right and relevant
    images from the base images. The sequential instructions inside the `Dockerfile`
    can include the base image selection, installing the required application, adding
    the configuration and the data files, and automatically running the services as
    well as exposing those services to the external world. Thus the Dockerfile-based
    automated build system has simplified the image-building process. It also offers
    a great deal of flexibility in the way in which the build instructions are organized
    and in the way in which they visualize the complete build process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更好的选择，我们可以采用使用`Dockerfile`自动化方法来制作镜像。`Dockerfile`是一个基于文本的构建脚本，其中包含了一系列特殊指令，用于从基础镜像构建正确和相关的镜像。`Dockerfile`中的顺序指令可以包括基础镜像选择、安装所需应用程序、添加配置和数据文件，以及自动运行服务并将这些服务暴露给外部世界。因此，基于Dockerfile的自动化构建系统简化了镜像构建过程。它还在构建指令的组织方式和可视化完整构建过程的方式上提供了很大的灵活性。
- en: The Docker engine tightly integrates this build process with the help of the
    `docker build` subcommand. In the client-server paradigm of Docker, the Docker
    server (or daemon) is responsible for the complete build process and the Docker
    command line interface is responsible for transferring the build context, including
    transferring `Dockerfile` to the daemon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎通过`docker build`子命令紧密集成了这个构建过程。在Docker的客户端-服务器范式中，Docker服务器（或守护程序）负责完整的构建过程，Docker命令行界面负责传输构建上下文，包括将`Dockerfile`传输到守护程序。
- en: 'In order to have a sneak peak into the `Dockerfile` integrated build system
    in this section, we will introduce you to a basic `Dockerfile`. Then we will explain
    the steps for converting that `Dockerfile` into an image, and then launching a
    container from that image. Our `Dockerfile` is made up of two instructions, as
    shown here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了窥探本节中`Dockerfile`集成构建系统，我们将向您介绍一个基本的`Dockerfile`。然后我们将解释将该`Dockerfile`转换为图像，然后从该图像启动容器的步骤。我们的`Dockerfile`由两条指令组成，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following, we will discuss the two instructions mentioned earlier:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论前面提到的两条指令：
- en: The first instruction is for choosing the base image selection. In this example,
    we will select the `busybox:latest` image
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条指令是选择基础图像。在这个例子中，我们将选择`busybox:latest`图像
- en: The second instruction is for carrying out the command `CMD`, which instructs
    the container to `echo Hello World!!`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条指令是执行`CMD`命令，指示容器`echo Hello World!!`。
- en: 'Now, let''s proceed towards generating a Docker image by using the preceding
    `Dockerfile` by calling `docker build` along with the path of `Dockerfile`. In
    our example, we will invoke the `docker build` subcommand from the directory where
    we have stored `Dockerfile,` and the path will be specified by the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过调用`docker build`以及`Dockerfile`的路径来生成一个Docker图像。在我们的例子中，我们将从存储`Dockerfile`的目录中调用`docker
    build`子命令，并且路径将由以下命令指定：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After issuing the preceding command, the `build` process will begin by sending
    `build context` to the `daemon` and then display the text shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 发出上述命令后，`build`过程将通过将`build context`发送到`daemon`并显示以下文本开始：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The build process would continue and, after completing itself, it will display
    the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将继续，并在完成后显示以下内容：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, the image was built by the `IMAGE ID 0a2abe57c325`.
    Let''s use this image to launch a container by using the `docker run` subcommand
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，图像是由`IMAGE ID 0a2abe57c325`构建的。让我们使用这个图像通过使用`docker run`子命令来启动一个容器，如下所示：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Cool, isn't it? With very little effort, we have been able to craft an image
    with `busybox` as the base image, and we have been able to extend that image to
    produce `Hello World!!`. This is a simple application, but the enterprise-scale
    images can also be realized by using the same technology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？凭借极少的努力，我们已经能够制作一个以`busybox`为基础图像，并且能够扩展该图像以生成`Hello World!!`。这是一个简单的应用程序，但是使用相同的技术也可以实现企业规模的图像。
- en: 'Now let''s look at the image details by using the `docker images` subcommand,
    as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`docker images`子命令来查看图像的详细信息，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, you may be surprised to see that the `IMAGE` (`REPOSITORY`) and `TAG`
    name have been listed as `<none>`. This is because we did not specify any image
    or any `TAG` name when we built this image. You could specify an `IMAGE` name
    and optionally a `TAG` name by using the `docker tag` subcommand, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可能会惊讶地看到`IMAGE`（`REPOSITORY`）和`TAG`名称被列为`<none>`。这是因为当我们构建这个图像时，我们没有指定任何图像或任何`TAG`名称。你可以使用`docker
    tag`子命令指定一个`IMAGE`名称和可选的`TAG`名称，如下所示：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The alternative approach is to build the image with an image name during the
    `build` time by using the `-t` option for the `docker build` subcommand, as shown
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在`build`时使用`-t`选项为`docker build`子命令构建镜像名称，如下所示：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since there is no change in the instructions in `Dockerfile`, the Docker engine
    will efficiently reuse the old image that has `ID 0a2abe57c325` and update the
    image name to `busyboxplus`. By default, the build system would apply `latest`
    as the `TAG` name. This behavior can be modified by specifying the `TAG` name
    after the `IMAGE` name by having a `:` separator placed between them. That is,
    `<image name>:<tag name>` is the correct syntax for modifying behaviors, where
    `<image name>` is the name of the image and `<tag name>` is the name of the tag.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Dockerfile`中的指令没有变化，Docker引擎将高效地重用具有`ID 0a2abe57c325`的旧镜像，并将镜像名称更新为`busyboxplus`。默认情况下，构建系统会将`latest`作为`TAG`名称。可以通过在`IMAGE`名称之后指定`TAG`名称并在它们之间放置`:`分隔符来修改此行为。也就是说，`<image
    name>:<tag name>`是修改行为的正确语法，其中`<image name>`是镜像的名称，`<tag name>`是标签的名称。
- en: 'Once again, let''s look at the image details by using the `docker images` subcommand,
    and you will notice that the image (Repository) name is `busyboxplus` and the
    tag name is `latest`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`docker images`子命令查看镜像详细信息，您会注意到镜像（存储库）名称为`busyboxplus`，标签名称为`latest`：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building images with an image name is always recommended as the best practice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议使用镜像名称构建镜像是最佳实践。
- en: Having experienced the magic of `Dockerfile`, in the subsequent sections we
    will introduce you to the syntax or the format of `Dockerfile` and explain a dozen
    `Dockerfile` instructions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在体验了`Dockerfile`的魔力之后，我们将在随后的章节中向您介绍`Dockerfile`的语法或格式，并解释一打`Dockerfile`指令。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest Docker release (1.5) has incorporated an additional option (`-f`)
    in the `docker build` subcommand, and it is used for specifying a `Dockerfile`
    with an alternative name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的Docker发布版（1.5）在`docker build`子命令中增加了一个额外选项（`-f`），用于指定具有替代名称的`Dockerfile`。
- en: A quick overview of the Dockerfile's syntax
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile的语法快速概述
- en: 'In this section, we will explain the syntax or the format of `Dockerfile`.
    A `Dockerfile` is made up of instructions, comments, and empty lines, as shown
    here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释`Dockerfile`的语法或格式。`Dockerfile`由指令、注释和空行组成，如下所示：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The instruction line of `Dockerfile` is made up of two components, where the
    instruction line begins with the instruction itself, which is followed by the
    arguments for the instruction. The instruction could be written in any case, in
    other words, it is case-insensitive. However, the standard practice or convention
    is to use *uppercase* in order to differentiate it from the arguments. Let''s
    take another look at the content of `Dockerfile` in our previous example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的指令行由两个组件组成，指令行以指令本身开头，后面跟着指令的参数。指令可以以任何大小写形式编写，换句话说，它是不区分大小写的。然而，标准做法或约定是使用*大写*以便与参数区分开来。让我们再次看一下我们之前示例中的`Dockerfile`的内容：'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `FROM` is an instruction which has taken `busybox:latest` as an argument,
    and `CMD` is an instruction which has taken `echo Hello World!!` as an argument.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`FROM`是一个指令，它以`busybox:latest`作为参数，`CMD`是一个指令，它以`echo Hello World!!`作为参数。
- en: 'The comment line in `Dockerfile` must begin with the `#` symbol. The `#` symbol
    after an instruction is considered as an argument. If the `#` symbol is preceded
    by a whitespace, then the `docker build` system would consider that as an unknown
    instruction and skip the line. Now, let''s better understand these mentioned cases
    with the help of an example to get a better understanding of the comment line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 中的注释行必须以 `#` 符号开头。指令后的 `#` 符号被视为参数。如果 `#` 符号前面有空格，则 `docker build`
    系统将视其为未知指令并跳过该行。现在，让我们通过一个示例更好地理解这些情况，以更好地理解注释行：'
- en: 'A valid `Dockerfile` comment line always begins with a `#` symbol as the first
    character of the line:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的 `Dockerfile` 注释行始终以 `#` 符号作为行的第一个字符：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `#` symbol can be a part of an argument:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#` 符号可以作为参数的一部分：'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the `#` symbol is preceded by a whitespace, then it is considered as an
    unknown instruction by the build system:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `#` 符号前面有空格，则构建系统将其视为未知指令：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `docker build` system ignores any empty line in the `Dockerfile`, and so
    the author of `Dockerfile` is encouraged to add comments and empty lines to substantially
    improve the readability of `Dockerfile`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 系统会忽略 `Dockerfile` 中的空行，因此鼓励 `Dockerfile` 的作者添加注释和空行，以大大提高 `Dockerfile`
    的可读性。'
- en: The Dockerfile build instructions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 构建指令
- en: So far, we have looked at the integrated build system, the `Dockerfile` syntax
    and a sample life cycle, including how a sample `Dockerfile` is leveraged to generate
    an image and how a container gets spun off from that image. In this section, we
    will introduce the `Dockerfile` instructions, their syntax, and a few fitting
    examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过集成构建系统、`Dockerfile` 语法和一个示例生命周期，包括如何利用示例 `Dockerfile` 生成镜像以及如何从该镜像中生成容器。在本节中，我们将介绍
    `Dockerfile` 指令、它们的语法以及一些合适的示例。
- en: The FROM instruction
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM 指令
- en: The `FROM` instruction is the most important one and it is the first valid instruction
    of a `Dockerfile`. It sets the base image for the build process. The subsequent
    instructions would use this base image and build on top of it. The `docker build`
    system lets you flexibly use the images built by anyone. You can also extend them
    by adding more precise and practical features to them. By default, the `docker
    build` system looks in the Docker host for the images. However, if the image is
    not found in the Docker host, then the `docker build` system will pull the image
    from the publicly available Docker Hub Registry. The `docker build` system will
    return an error if it can not find the specified image in the Docker host and
    the Docker Hub Registry.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令是最重要的指令，也是 `Dockerfile` 的第一个有效指令。它设置了构建过程的基础镜像。随后的指令将使用这个基础镜像并在其上构建。`docker
    build` 系统允许您灵活地使用任何人构建的镜像。您还可以通过添加更精确和实用的功能来扩展它们。默认情况下，`docker build` 系统在 Docker
    主机中查找镜像。但是，如果在 Docker 主机中找不到镜像，则 `docker build` 系统将从公开可用的 Docker Hub Registry
    拉取镜像。如果 `docker build` 系统在 Docker 主机和 Docker Hub Registry 中找不到指定的镜像，则会返回错误。'
- en: 'The `FROM` instruction has the following syntax:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令具有以下语法：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code statement, note the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码语句中，请注意以下内容：
- en: '`<image>`: This is the name of the image which will be used as the base image.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<image>`：这是将用作基础镜像的镜像的名称。'
- en: '`<tag>`: This is the optional tag qualifier for that image. If any tag qualifier
    has not been specified, then the tag `latest` is assumed.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag>`：这是该镜像的可选标签限定符。如果未指定任何标签限定符，则假定为标签 `latest`。'
- en: 'Here is an example of the `FROM` instruction with the image name `centos`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用镜像名称 `centos` 的 `FROM` 指令的示例：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is another example of the `FROM` instruction with the image name `ubuntu`
    and the tag qualifier `14.04`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有镜像名称`ubuntu`和标签限定符`14.04`的`FROM`指令的另一个示例：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Docker allows multiple `FROM` instructions in a single `Dockerfile` in order
    to create multiple images. The Docker build system will pull all the images specified
    in the `FROM` instruction. Docker does not provide any mechanism for naming the
    individual images that are generated with the help of multiple `FROM` instructions.
    We strongly discourage using multiple `FROM` instructions in a single `Dockerfile`,
    as damaging conflicts could arise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许在单个`Dockerfile`中使用多个`FROM`指令以创建多个镜像。Docker构建系统将拉取`FROM`指令中指定的所有镜像。Docker不提供对使用多个`FROM`指令生成的各个镜像进行命名的任何机制。我们强烈不建议在单个`Dockerfile`中使用多个`FROM`指令，因为可能会产生破坏性的冲突。
- en: The MAINTAINER instruction
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAINTAINER指令
- en: The `MAINTAINER` instruction is an informational instruction of a `Dockerfile`.
    This instruction capability enables the authors to set the details in an image.
    Docker does not place any restrictions on placing the `MAINTAINER` instruction
    in `Dockerfile`. However, it is strongly recommended that you should place it
    after the `FROM` instruction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER`指令是`Dockerfile`的信息指令。此指令能力使作者能够在镜像中设置详细信息。Docker不对在`Dockerfile`中放置`MAINTAINER`指令施加任何限制。但强烈建议您在`FROM`指令之后放置它。'
- en: 'The following is the syntax of the `MAINTAINER` instruction, where `<author''s
    detail>` can be in any text. However, it is strongly recommended that you use
    the image author''s name and the e-mail address, as shown in this code syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MAINTAINER`指令的语法，其中`<author's detail>`可以是任何文本。但强烈建议您使用镜像作者的姓名和电子邮件地址，如此代码语法所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example of the `MAINTAINER` instruction with the author name and
    the e-mail address:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有作者姓名和电子邮件地址的`MAINTAINER`指令的示例：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The COPY instruction
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`COPY`指令'
- en: 'The `COPY` instruction enables you to copy the files from the Docker host to
    the filesystem of the new image. The following is the syntax of the `COPY` instruction:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令使您能够将文件从Docker主机复制到新镜像的文件系统中。以下是`COPY`指令的语法：'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code terms bear the explanations shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码术语包含了这里显示的解释：
- en: '`<src>`: This is the source directory, the file in the build context, or the
    directory from where the `docker build` subcommand was invoked.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`：这是源目录，构建上下文中的文件，或者是执行`docker build`子命令的目录。'
- en: '`...`: This indicates that multiple source files can either be specified directly
    or be specified by wildcards.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`：这表示可以直接指定多个源文件，也可以通过通配符指定多个源文件。'
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will get copied. If multiple files have been specified, then
    the destination path must be a directory and it must end with a slash `/`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dst>`：这是新镜像的目标路径，源文件或目录将被复制到其中。如果指定了多个文件，则目标路径必须是目录，并且必须以斜杠`/`结尾。'
- en: Using an absolute path for the destination directory or a file is recommended.
    In the absence of an absolute path, the `COPY` instruction will assume that the
    destination path will start from root `/`. The `COPY` instruction is powerful
    enough for creating a new directory and for overwriting the filesystem in the
    newly created image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐为目标目录或文件使用绝对路径。如果没有绝对路径，`COPY`指令将假定目标路径将从根目录`/`开始。`COPY`指令足够强大，可以用于创建新目录，并覆盖新创建的镜像中的文件系统。
- en: 'In the following example, we will copy the `html` directory from the source
    build context to `/var/www/html`, which is in the image filesystem, by using the
    `COPY` instruction, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用`COPY`指令将源构建上下文中的`html`目录复制到镜像文件系统中的`/var/www/html`，如下所示：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is another example of the multiple files (`httpd.conf` and `magic`) that
    will be copied from the source build context to `/etc/httpd/conf/`, which is in
    the image filesystem:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例，多个文件（`httpd.conf`和`magic`）将从源构建上下文复制到镜像文件系统中的`/etc/httpd/conf/`：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The ADD instruction
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADD指令
- en: The `ADD` instruction is similar to the `COPY` instruction. However, in addition
    to the functionality supported by the `COPY` instruction, the `ADD` instruction
    can handle the TAR files and the remote URLs. We can annotate the `ADD` instruction
    as `COPY` on steroids.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令类似于`COPY`指令。但是，除了`COPY`指令支持的功能之外，`ADD`指令还可以处理TAR文件和远程URL。我们可以将`ADD`指令注释为“功能更强大的COPY”。'
- en: 'The following is the syntax of the `ADD` instruction:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ADD`指令的语法：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The arguments of the `ADD` instruction are very similar to those of the `COPY`
    instruction, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令的参数与`COPY`指令的参数非常相似，如下所示：'
- en: '`<src>`: This is either the source directory or the file that is in the build
    context or in the directory from where the `docker build` subcommand will be invoked.
    However, the noteworthy difference is that the source can either be a TAR file
    stored in the build context or be a remote URL.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<src>`：这既可以是构建上下文中的源目录或文件，也可以是`docker build`子命令将被调用的目录中的文件。然而，值得注意的区别是，源可以是存储在构建上下文中的TAR文件，也可以是远程URL。'
- en: '`...`: This indicates that the multiple source files can either be specified
    directly or be specified by using wildcards.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`：这表示多个源文件可以直接指定，也可以使用通配符指定。'
- en: '`<dst>`: This is the destination path for the new image into which the source
    file or directory will be copied.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dst>`：这是新镜像的目标路径，源文件或目录将被复制到其中。'
- en: 'Here is an example for demonstrating the procedure for copying multiple source
    files to the various destination directories in the target image filesystem. In
    this example, we have taken a TAR file (`web-page-config.tar`) in the source build
    context with the `http` daemon configuration file and the files for the web pages
    are stored in the appropriate directory structure, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了将多个源文件复制到目标镜像文件系统中的各个目标目录的过程。在此示例中，我们在源构建上下文中使用了一个TAR文件（`web-page-config.tar`），其中包含`http`守护程序配置文件和网页文件的目录结构，如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next line in the `Dockerfile` content has an `ADD` instruction for copying
    the TAR file (`web-page-config.tar`) to the target image and extracting the TAR
    file from the root directory (`/`) of the target image, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`内容中的下一行包含一个`ADD`指令，用于将TAR文件（`web-page-config.tar`）复制到目标镜像，并从目标镜像的根目录（`/`）中提取TAR文件，如下所示：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Thus the TAR option of the `ADD` instruction can be used for copying multiple
    files to the target image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“ADD”指令的TAR选项可用于将多个文件复制到目标镜像。
- en: The ENV instruction
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENV指令
- en: The `ENV` instruction sets an environment variable in the new image. An environment
    variable is a key-value pair, which can be accessed by any script or application.
    The Linux applications use the environment variables a lot for a starting configuration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`指令在新镜像中设置环境变量。环境变量是键值对，可以被任何脚本或应用程序访问。Linux应用程序在启动配置中经常使用环境变量。'
- en: 'The following line forms the syntax of the `ENV` instruction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行形成了`ENV`指令的语法：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the code terms indicate the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码术语表示以下内容：
- en: '`<key>`: This is the environment variable'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<key>`：这是环境变量'
- en: '`<value>`: This is the value that is to be set for the environment variable'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<value>`：这是要设置为环境变量的值'
- en: 'The following lines give two examples for the `ENV` instruction, where in the
    first line `DEBUG_LVL` has been set to `3` and, in the second line, `APACHE_LOG_DIR`
    has been set to `/var/log/apache`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行给出了`ENV`指令的两个示例，在第一行中，`DEBUG_LVL`已设置为`3`，在第二行中，`APACHE_LOG_DIR`已设置为`/var/log/apache`：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The USER instruction
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USER指令
- en: The `USER` instruction sets the start up user ID or user Name in the new image.
    By default, the containers will be launched with `root` as the user ID or `UID`.
    Essentially, the `USER` instruction will modify the default user ID from `root`
    to the one specified in this instruction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`指令设置新镜像中的启动用户ID或用户名。默认情况下，容器将以`root`作为用户ID或`UID`启动。实质上，`USER`指令将把默认用户ID从`root`修改为此指令中指定的用户ID。'
- en: 'The syntax of the `USER` instruction is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`指令的语法如下：'
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `USER` instructions accept either `<UID>` or `<UName>` as its argument:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`指令接受`<UID>`或`<UName>`作为其参数：'
- en: '`<UID>`: This is a numerical user ID'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<UID>`：这是一个数字用户ID'
- en: '`<UName>`: This is a valid user Name'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<UName>`：这是一个有效的用户名'
- en: 'The following is an example for setting the default user ID at the time of
    startup to `73`. Here `73` is the numerical ID of the user:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，用于在启动时将默认用户ID设置为`73`。这里`73`是用户的数字ID：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, it is recommended that you have a valid user ID to match with the
    `/etc/passwd` file, the user ID can contain any random numerical value. However,
    the user Name must match with a valid user name in the `/etc/passwd` file, otherwise
    the `docker run` subcommand will fail and it will display the following error
    message:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，建议您拥有一个与`/etc/passwd`文件匹配的有效用户ID，用户ID可以包含任意随机数值。但是，用户名必须与`/etc/passwd`文件中的有效用户名匹配，否则`docker
    run`子命令将失败，并显示以下错误消息：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The WORKDIR instruction
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WORKDIR指令
- en: The `WORKDIR` instruction changes the current working directory from `/` to
    the path specified by this instruction. The ensuing instructions, such as `RUN`,
    `CMD`, and `ENTRYPOINT` will also work on the directory set by the `WORKDIR` instruction.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令将当前工作目录从`/`更改为此指令指定的路径。随后的指令，如`RUN`、`CMD`和`ENTRYPOINT`也将在`WORKDIR`指令设置的目录上工作。'
- en: 'The following line gives the appropriate syntax for the `WORKDIR` instruction:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行提供了`WORKDIR`指令的适当语法：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `<dirpath>` is the path for the working directory to set in. The path
    can be either absolute or relative. In case of a relative path, it will be relative
    to the previous path set by the `WORKDIR` instruction. If the specified directory
    is not found in the target image filesystem, then the director will be created.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<dirpath>`是要设置的工作目录的路径。路径可以是绝对路径或相对路径。在相对路径的情况下，它将相对于`WORKDIR`指令设置的上一个路径。如果在目标镜像文件系统中找不到指定的目录，则将创建该目录。
- en: 'The following line is a clear example of the `WORKDIR` instruction in a `Dockerfile`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行是`Dockerfile`中`WORKDIR`指令的一个明确示例：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The VOLUME instruction
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VOLUME指令
- en: The `VOLUME` instruction creates a directory in the image filesystem, which
    can later be used for mounting volumes from the Docker host or the other containers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令在镜像文件系统中创建一个目录，以后可以用于从Docker主机或其他容器挂载卷。'
- en: 'The `VOLUME` instruction has two types of syntax, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令有两种语法，如下所示：'
- en: 'The first type is either exec or JSON array (all values must be within double-quotes
    (`"`)):'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种类型是exec或JSON数组（所有值必须在双引号（`"`）内）：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second type is shell, as shown here:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种类型是shell，如下所示：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding line, `<mountpoint>` is the mount point that has to be created
    in the new image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行中，`<mountpoint>`是必须在新镜像中创建的挂载点。
- en: The EXPOSE instruction
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXPOSE指令
- en: The `EXPOSE` instruction opens up a container network port for communicating
    between the container and the external world.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令打开容器网络端口，用于容器与外部世界之间的通信。'
- en: 'The syntax of the `EXPOSE` instruction is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令的语法如下：'
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, the code terms mean the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码术语的含义如下：
- en: '`<port>`: This is the network port that has to be exposed to the outside world.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<port>`：这是要向外部世界暴露的网络端口。'
- en: '`<proto>`: This is an optional field provided for a specific transport protocol,
    such as TCP and UDP. If no transport protocol has been specified, then TCP is
    assumed to be the transport protocol.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<proto>`：这是一个可选字段，用于指定特定的传输协议，如TCP和UDP。如果未指定传输协议，则假定TCP为传输协议。'
- en: The `EXPOSE` instruction allows you to specify multiple ports in a single line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令允许您在一行中指定多个端口。'
- en: 'The following is an example of the `EXPOSE` instruction inside a `Dockerfile`
    exposing the port number `7373` as a `UDP` port and the port number `8080` as
    a `TCP` port. As mentioned earlier, if the transport protocol has not been specified,
    then the `TCP` transport is assumed to be the transport protocol:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Dockerfile`中`EXPOSE`指令的示例，将端口号`7373`暴露为`UDP`端口，端口号`8080`暴露为`TCP`端口。如前所述，如果未指定传输协议，则假定`TCP`传输协议为传输协议：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The RUN instruction
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RUN指令
- en: The `RUN` instruction is the real workhorse during the build time, and it can
    run any command. The general recommendation is to execute multiple commands by
    using one `RUN` instruction. This reduces the layers in the resulting Docker image
    because the Docker system inherently creates a layer for each time an instruction
    is called in `Dockerfile`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令是构建时的真正工作马，它可以运行任何命令。一般建议使用一个`RUN`指令执行多个命令。这样可以减少生成的Docker镜像中的层，因为Docker系统固有地为`Dockerfile`中每次调用指令创建一个层。'
- en: 'The `RUN` instruction has two types of syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令有两种语法类型：'
- en: 'The first is the shell type, as shown here:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是shell类型，如下所示：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, the `<command>` is the shell command that has to be executed during the
    build time. If this type of syntax is to be used, then the command is always executed
    by using `/bin/sh -c`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<command>`是在构建时必须执行的shell命令。如果要使用这种类型的语法，那么命令总是使用`/bin/sh -c`来执行。
- en: 'The second syntax type is either exec or the JSON array, as shown here:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法类型要么是exec，要么是JSON数组，如下所示：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Within this, the code terms mean the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，代码术语的含义如下：
- en: '`<exec>`: This is the executable to run during the build time.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是在构建时要运行的可执行文件。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variables (zero or more) number of the
    arguments for the executable.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的参数（零个或多个）。'
- en: Unlike the first type of syntax, this type does not invoke `/bin/sh -c`. Therefore,
    the types of shell processing, such as the variable substitution (`$USER`) and
    the wild card substitution (`*`, `?`), do not happen in this type. If shell processing
    is critical for you, then you are encouraged to use the shell type. However, if
    you still prefer the exec (JSON array type) type, then use your preferred shell
    as the executable and supply the command as an argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一种语法不同，这种类型不会调用`/bin/sh -c`。因此，这种类型不会发生shell处理，如变量替换（`$USER`）和通配符替换（`*`，`?`）。如果shell处理对您很重要，那么建议您使用shell类型。但是，如果您仍然更喜欢exec（JSON数组类型），那么请使用您喜欢的shell作为可执行文件，并将命令作为参数提供。
- en: For example, `RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`RUN ["bash", "-c", "rm", "-rf", "/tmp/abc"]`。
- en: 'Now let''s look at a few examples of the `RUN` instruction. In the first example,
    we will use the `RUN` instruction for adding a greeting line to the `.bashrc`
    file in the target image filesystem, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`RUN`指令的一些示例。在第一个示例中，我们将使用`RUN`指令将问候语添加到目标图像文件系统的`.bashrc`文件中，如下所示：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The second example is a `Dockerfile,` which has the instructions for crafting
    an `Apache2` application image on top of the `Ubuntu 14.04` base image. The ensuing
    steps will explain the `Dockerfile` instructions line by line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例是一个`Dockerfile`，其中包含在`Ubuntu 14.04`基础镜像上构建`Apache2`应用程序镜像的指令。接下来的步骤将逐行解释`Dockerfile`指令：
- en: 'We are going to build an image by using `ubuntu:14.04` as the base image using
    the `FROM` instruction, as shown here:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`FROM`指令构建一个以`ubuntu:14.04`为基础镜像的镜像，如下所示：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Set the author''s details by using the `MAINTAINER` instruction, as shown here:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`MAINTAINER`指令设置作者的详细信息，如下所示：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By using one `RUN` instruction, we will synchronize the `apt` repository source
    list, install the `apache2` package, and then clean the retrieved files, as shown
    here:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一个`RUN`指令，我们将同步`apt`存储库源列表，安装`apache2`软件包，然后清理检索到的文件，如下所示：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The CMD instruction
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMD指令
- en: The `CMD` instruction can run any command (or application), which is similar
    to the `RUN` instruction. However, the major difference between those two is the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched from the newly created image. Therefore,
    the `CMD` instruction provides a default execution for this container. However,
    it can be overridden by the `docker run` subcommand arguments. When the application
    terminates, the container will also terminate along with the application and vice
    versa.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令可以运行任何命令（或应用程序），类似于`RUN`指令。但是，这两者之间的主要区别在于执行时间。通过`RUN`指令提供的命令在构建时执行，而通过`CMD`指令指定的命令在从新创建的镜像启动容器时执行。因此，`CMD`指令为此容器提供了默认执行。但是，可以通过`docker
    run`子命令参数进行覆盖。应用程序终止时，容器也将终止，并且应用程序与之相反。'
- en: 'The `CMD` instruction has three types of syntax, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令有三种语法类型，如下所示：'
- en: 'The first syntax type is the shell type, as shown here:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种语法类型是shell类型，如下所示：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Within this, the `<command>` is the shell command, which has to be executed
    during the launch of the container. If this type of syntax is used, then the command
    is always executed by using `/bin/sh -c`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，`<command>`是shell命令，在容器启动时必须执行。如果使用此类型的语法，则始终使用`/bin/sh -c`执行命令。
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法类型是exec或JSON数组，如下所示：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within this, the code terms mean the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，代码术语的含义如下：
- en: '`<exec>`: This is the executable, which is to be run during the container launch
    time.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是要在容器启动时运行的可执行文件。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of the
    arguments for the executable.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的参数的变量（零个或多个）数字。'
- en: 'The third type of syntax is also exec or the JSON array, which is similar to
    the previous type. However, this type is used for setting the default parameters
    to the `ENTRYPOINT` instruction, as shown here:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种语法类型也是exec或JSON数组，类似于前一种类型。但是，此类型用于将默认参数设置为`ENTRYPOINT`指令，如下所示：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Within this, the code terms mean the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，代码术语的含义如下：
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of the
    arguments for the `ENTRYPOINT` instruction, which will be explained in the next
    section.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是`ENTRYPOINT`指令的变量（零个或多个）数量的参数，将在下一节中解释。'
- en: Syntactically, you can add more than one `CMD` instruction in `Dockerfile`.
    However, the build system would ignore all the `CMD` instructions except for the
    last one. In other words, in the case of multiple `CMD` instructions, only the
    last `CMD` instruction would be effective.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，你可以在`Dockerfile`中添加多个`CMD`指令。然而，构建系统会忽略除最后一个之外的所有`CMD`指令。换句话说，在多个`CMD`指令的情况下，只有最后一个`CMD`指令会生效。
- en: 'Here, in this example, let''s craft an image by using `Dockerfile` with the
    `CMD` instruction for providing a default execution, and then launching a container
    by using the crafted image. The following is `Dockerfile` with a `CMD` instruction
    to `echo` a text:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们使用`Dockerfile`和`CMD`指令来制作一个镜像，以提供默认执行，然后使用制作的镜像启动一个容器。以下是带有`CMD`指令的`Dockerfile`，用于`echo`一段文本：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s build a Docker image by using the `docker build` subcommand and
    `cmd-demo` as the image name. The `docker build` system will read the instruction
    from the `Dockerfile`, which is stored in the current directory (`.`), and craft
    the image accordingly as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`docker build`子命令和`cmd-demo`作为镜像名称来构建一个Docker镜像。`docker build`系统将从当前目录（`.`）中读取`Dockerfile`中的指令，并相应地制作镜像，就像这里所示的那样：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Having built the image, we can launch the container by using the `docker run`
    subcommand, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了镜像之后，我们可以使用`docker run`子命令来启动容器，就像这里所示的那样：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Cool, isn''t it? We have given a default execution for our container and our
    container has faithfully echoed `Dockerfile CMD demo`. However, this default execution
    can be easily overridden by passing another command as an argument to the `docker
    run` subcommand, as shown in the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？我们为容器提供了默认执行，并且我们的容器忠实地回显了`Dockerfile CMD demo`。然而，这个默认执行可以很容易地被通过将另一个命令作为参数传递给`docker
    run`子命令来覆盖，就像下面的例子中所示：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The ENTRYPOINT instruction
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENTRYPOINT指令
- en: The `ENTRYPOINT` instruction will help in crafting an image for running an application
    (entry point) during the complete life cycle of the container, which would have
    been spun out of the image. When the entry point application is terminated, the
    container would also be terminated along with the application and vice versa.
    Therefore, the `ENTRYPOINT` instruction would make the container function like
    an executable. Functionally, `ENTRYPOINT` is akin to the `CMD` instruction, but
    the major difference between the two is that the entry point application is launched
    by using the `ENTRYPOINT` instruction, which cannot be overridden by using the
    `docker run` subcommand arguments. However, these `docker run` subcommand arguments
    will be passed as additional arguments to the entry point application. Having
    said this, Docker provides a mechanism for overriding the entry point application
    through the `--entrypoint` option in the `docker run` subcommand. The `--entrypoint`
    option can accept only word as its argument, and so it has limited functionality.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令将帮助制作一个镜像，用于在容器的整个生命周期中运行一个应用程序（入口点），该应用程序将从镜像中衍生出来。当入口点应用程序终止时，容器也将随之终止，应用程序与容器相互关联。因此，`ENTRYPOINT`指令会使容器的功能类似于可执行文件。从功能上讲，`ENTRYPOINT`类似于`CMD`指令，但两者之间的主要区别在于入口点应用程序是通过`ENTRYPOINT`指令启动的，无法通过`docker
    run`子命令参数来覆盖。然而，这些`docker run`子命令参数将作为额外的参数传递给入口点应用程序。话虽如此，Docker提供了通过`docker
    run`子命令中的`--entrypoint`选项来覆盖入口点应用程序的机制。`--entrypoint`选项只能接受一个单词作为其参数，因此其功能有限。'
- en: 'Syntactically, the `ENTRYPOINT` instruction is very similar to the `RUN` and
    `CMD` instructions, and it has two types of syntax, as shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，`ENTRYPOINT`指令与`RUN`和`CMD`指令非常相似，它有两种语法，如下所示：
- en: 'The first type of syntax is the shell type, as shown here:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种语法是shell类型，如下所示：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, `<command>` is the shell command, which is executed during the launch
    of the container. If this type of syntax is used, then the command is always executed
    by using `/bin/sh -c`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<command>`是在容器启动时执行的shell命令。如果使用这种类型的语法，则始终使用`/bin/sh -c`执行命令。
- en: 'The second type of syntax is exec or the JSON array, as shown here:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种语法是exec或JSON数组，如下所示：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Within this, the code terms mean the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码术语的含义如下：
- en: '`<exec>`: This is the executable, which has to be run during the container
    launch time.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<exec>`：这是在容器启动时必须运行的可执行文件。'
- en: '`<arg-1>, ..., <arg-n>`: These are the variable (zero or more) numbers of arguments
    for the executable.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arg-1>, ..., <arg-n>`：这些是可执行文件的变量（零个或多个）参数。'
- en: Syntactically, you can have more than one `ENTRYPOINT` instruction in a `Dockerfile`.
    However, the build system will ignore all the `ENTRYPOINT` instructions except
    the last one. In other words, in the case of multiple `ENTRYPOINT` instructions,
    only the last `ENTRYPOINT` instruction will be effective.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，你可以在`Dockerfile`中有多个`ENTRYPOINT`指令。然而，构建系统将忽略除最后一个之外的所有`ENTRYPOINT`指令。换句话说，在多个`ENTRYPOINT`指令的情况下，只有最后一个`ENTRYPOINT`指令会生效。
- en: 'In order to gain a better understanding of the `ENTRYPOINT` instruction, let''s
    craft an image by using `Dockerfile` with the `ENTRYPOINT` instruction, and then
    launching a container by using the crafted image. The following is `Dockerfile`
    with an `ENTRYPOINT` instruction to echo a text:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`ENTRYPOINT`指令，让我们使用带有`ENTRYPOINT`指令的`Dockerfile`来创建一个镜像，然后使用这个镜像启动一个容器。以下是带有`ENTRYPOINT`指令的`Dockerfile`，用于回显文本：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s build a Docker image by using the `docker build` as the subcommand
    and `entrypoint-demo` as the image name. The `docker build` system would read
    the instruction from `Dockerfile` stored in the current directory (`.`) and craft
    the image, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`docker build`作为子命令和`entrypoint-demo`作为镜像名称来构建一个Docker镜像。`docker build`系统将从当前目录（`.`）中存储的`Dockerfile`中读取指令，并创建镜像，如下所示：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Having built the image, we can launch the container by using the `docker run`
    subcommand:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完镜像后，我们可以使用`docker run`子命令启动容器：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, the container will run like an executable by echoing the `Dockerfile
    ENTRYPOINT demo` string and then it will exit immediately. If we pass any additional
    arguments to the `docker run` subcommand, then the additional argument would be
    passed to the entry point command. The following is a demonstration of launching
    the same image with the additional arguments given to the `docker run` subcommand:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器将像可执行文件一样运行，回显`Dockerfile ENTRYPOINT demo`字符串，然后立即退出。如果我们向`docker run`子命令传递任何额外的参数，那么额外的参数将传递给入口点命令。以下是使用`docker
    run`子命令给出额外参数启动相同镜像的演示：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s see an example where we override the build time entry point application
    with the `--entrypoint` option and then launch a shell (`/bin/sh`) in the `docker
    run` subcommand, as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个例子，我们可以使用`--entrypoint`选项覆盖构建时的入口应用程序，然后在`docker run`子命令中启动一个shell（`/bin/sh`），如下所示：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The ONBUILD instruction
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ONBUILD指令
- en: The `ONBUILD` instruction registers a build instruction to an image and this
    is triggered when another image is built by using this image as its base image.
    Any build instruction can be registered as a trigger and those instructions will
    be triggered immediately after the `FROM` instruction in the downstream `Dockerfile`.
    Therefore, the `ONBUILD` instruction can be used to defer the execution of the
    build instruction from the base image to the target image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令将构建指令注册到镜像中，并在使用此镜像作为其基本镜像构建另一个镜像时触发。任何构建指令都可以注册为触发器，并且这些指令将在下游`Dockerfile`中的`FROM`指令之后立即触发。因此，`ONBUILD`指令可用于将构建指令的执行从基本镜像延迟到目标镜像。'
- en: 'The syntax of the `ONBUILD` instruction is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令的语法如下：'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Within this, `<INSTRUCTION>` is another `Dockerfile` build instruction, which
    will be triggered later. The `ONBUILD` instruction does not allow the chaining
    of another `ONBUILD` instruction. In addition, it does not allow the `FROM` and
    `MAINTAINER` instructions as `ONBUILD` triggers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，`<INSTRUCTION>`是另一个`Dockerfile`构建指令，稍后将被触发。`ONBUILD`指令不允许链接另一个`ONBUILD`指令。此外，它不允许`FROM`和`MAINTAINER`指令作为`ONBUILD`触发器。
- en: 'Here is an example of the `ONBUILD` instruction:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ONBUILD`指令的示例：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The .dockerignore file
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .dockerignore文件
- en: 'In the *Docker''s integrated image building system* section, we learnt that
    the `docker build` process will send the complete build context to the daemon.
    In a practical environment, the `docker build` context will contain many other
    working files and directories, which would never be built into the image. Nevertheless,
    the `docker build` system would still send those files to the daemon. So, you
    may be wondering how you can optimize the build process by not sending these working
    files to the daemon. Well, the folks behind Docker too have thought about that
    and given a very simple solution: using a `.dockerignore` file.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Docker集成的镜像构建系统*部分，我们了解到`docker build`过程将完整的构建上下文发送到守护程序。在实际环境中，`docker build`上下文将包含许多其他工作文件和目录，这些文件和目录永远不会构建到镜像中。然而，`docker
    build`系统仍然会将这些文件发送到守护程序。因此，您可能想知道如何通过不将这些工作文件发送到守护程序来优化构建过程。嗯，Docker背后的人也考虑过这个问题，并提供了一个非常简单的解决方案：使用`.dockerignore`文件。
- en: The`.dockerignore` is a newline-separated TEXT file, wherein you can provide
    the files and the directories which are to be excluded from the build process.
    The exclusion list in the file can have both the fully specified file or directory
    name and the wild cards.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`是一个以换行分隔的文本文件，在其中您可以提供要从构建过程中排除的文件和目录。文件中的排除列表可以包含完全指定的文件或目录名称和通配符。'
- en: 'The following snippet is a sample `.dockerignore` file through which the build
    system has been instructed to exclude the `.git` directory and all the files that
    have the`.tmp` extension:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是一个示例`.dockerignore`文件，通过它，构建系统已被指示排除`.git`目录和所有具有`.tmp`扩展名的文件：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A brief overview of the Docker image management
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像管理的简要概述
- en: As we have seen in the previous chapter and this chapter, there are many ways
    of getting a handle on a Docker image. You could download a fully set up application
    stack from the public repository by using the `docker pull` subcommand. Otherwise
    you could craft your own application stack either manually by using the `docker
    commit` subcommand or automatically by using `Dockerfile` and the `docker build`
    subcommand combination.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章和本章中所看到的，有许多方法可以控制Docker镜像。您可以使用`docker pull`子命令从公共存储库下载完全设置好的应用程序堆栈。否则，您可以通过使用`docker
    commit`子命令手动或使用`Dockerfile`和`docker build`子命令组合自动创建自己的应用程序堆栈。
- en: The Docker images are being positioned as the key building-blocks of the containerized
    applications that, in turn, enable the realization of distributed applications,
    which will be deployed on the cloud servers. The Docker images are built in layers,
    that is, the images can be built on top of other images. The original image is
    called the parent image and the one that is generated is called the child image.
    The base image is a bundle, which comprises an application's common dependencies.
    Each change that is made to the original image is stored as a separate layer.
    Each time you commit to a Docker image, you will create a new layer on the Docker
    image, and each change that is made to the original image will be stored as a
    separate layer. As the reusability of the layers is facilitated, making new Docker
    images becomes simple and fast. You can create a new Docker image by changing
    a single line in `Dockerfile` and you do not need to rebuild the whole stack.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像被定位为容器化应用程序的关键构建模块，从而实现了部署在云服务器上的分布式应用程序。Docker镜像是分层构建的，也就是说，可以在其他镜像的基础上构建镜像。原始镜像称为父镜像，生成的镜像称为子镜像。基础镜像是一个捆绑包，包括应用程序的常见依赖项。对原始镜像所做的每个更改都将作为单独的层存储。每次提交到Docker镜像时，都会在Docker镜像上创建一个新的层，对原始镜像所做的每个更改都将作为单独的层存储。由于层的可重用性得到了便利，制作新的Docker镜像变得简单而快速。您可以通过更改`Dockerfile`中的一行来创建新的Docker镜像，而无需重新构建整个堆栈。
- en: Now that we have learnt about the layers in the Docker image, you may be wondering
    how one could visualize these layers in a Docker image. Well, the `docker history`
    subcommand is an excellent and handy tool for visualizing the image layers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Docker镜像中的层次结构，您可能想知道如何在Docker镜像中可视化这些层。好吧，`docker history`子命令是可视化图像层的一个非常好用的工具。
- en: 'Let''s see a practical example to better understand the layering in the Docker
    images. For this purpose, let''s follow these three steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子，以更好地理解Docker镜像中的分层。为此，让我们按照以下三个步骤进行：
- en: 'Here, we have `Dockerfile` with the instructions for automatically building
    the Apache2 application image on top of the Ubuntu 14.04 base image. The `RUN`
    section of the previously crafted and used `Dockerfile` of this chapter will be
    reused in this section, as shown here:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`Dockerfile`，其中包含自动构建Apache2应用程序镜像的指令，该镜像是基于Ubuntu 14.04基础镜像构建的。本章之前制作和使用的`Dockerfile`中的`RUN`部分将在本节中被重用，如下所示：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now craft an image from the preceding `Dockerfile` by using the `docker build`
    subcommand, as shown here:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用`docker build`子命令从上述`Dockerfile`中制作一个镜像，如下所示：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, let''s visualize the layers in the Docker image by using the `docker
    history` subcommand:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`docker history`子命令来可视化Docker镜像中的层次结构：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will produce a detailed report on each layer of the `apache2` Docker image,
    as shown here:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成关于`apache2` Docker镜像的每个层的详细报告，如下所示：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, the `apache2` image is made up of ten image layers. The top two layers,
    the layers with image IDs `aa83b67feeba` and `c7877665c770`, are the result of
    `RUN` and `MAINTAINER` instructions in our `Dockerfile`. The remaining eight layers
    of the image will be pulled from the repository by the `FROM` instruction in our
    `Dockerfile`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`apache2`镜像由十个镜像层组成。顶部两层，具有图像ID`aa83b67feeba`和`c7877665c770`的层，是我们`Dockerfile`中`RUN`和`MAINTAINER`指令的结果。图像的其余八层将通过我们`Dockerfile`中的`FROM`指令从存储库中提取。
- en: Best practices for writing Dockerfiles
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Dockerfile的最佳实践
- en: It is an undisputable truth that a set of best practices always plays an indispensable
    role in elevating any new technology. There is a well-written document listing
    all the best practices for crafting a `Dockerfile`. We found it incredible, and
    so, we wanted to share it for your benefit. You can find it at [https://docs.docker.com/articles/dockerfile_best-practices/](https://docs.docker.com/articles/dockerfile_best-practices/).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，一套最佳实践总是在提升任何新技术中起着不可或缺的作用。有一份详细列出所有最佳实践的文件，用于编写`Dockerfile`。我们发现它令人难以置信，因此，我们希望分享给您以供您受益。您可以在[https://docs.docker.com/articles/dockerfile_best-practices/](https://docs.docker.com/articles/dockerfile_best-practices/)找到它。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Building the Docker images is a critical aspect of the Docker technology for
    streamlining the arduous task of containerization. As indicated before, the Docker
    initiative has turned out to be disruptive and transformative for the containerization
    paradigm. Dockerfile is the most prominent way for producing the competent Docker
    images, which can be used meticulously. We have illustrated all the commands,
    their syntax, and their usage techniques in order to empower you with all the
    easy-to-grasp details, and this will simplify the image-building process for you.
    We have supplied a bevy of examples in order to substantiate the inner meaning
    of each command. In the next chapter, we are going to discuss the Docker Hub,
    which is a well-designated store for storing and sharing the Docker images, and
    we will also discuss its profound contribution to the penetration of the containerization
    concept into the IT enterprises.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像是Docker技术的关键方面，用于简化容器化的繁琐任务。正如之前所指出的，Docker倡议已经成为颠覆性和变革性的容器化范式。Dockerfile是生成高效Docker镜像的最主要方式，可以被精心使用。我们已经阐明了所有命令、它们的语法和使用技巧，以赋予您所有易于理解的细节，这将简化您的镜像构建过程。我们提供了大量示例，以证实每个命令的内在含义。在下一章中，我们将讨论Docker
    Hub，这是一个专门用于存储和共享Docker镜像的存储库，并且我们还将讨论它对容器化概念在IT企业中的深远贡献。
