["```cpp\ntemplate <typename RandomAccessIterator, typename F>\nvoid ptransform(RandomAccessIterator begin, RandomAccessIterator end, \n                F&& f)\n{\n   auto size = std::distance(begin, end);\n   if (size <= 10000)\n   {\n      std::transform(begin, end, begin, std::forward<F>(f));\n   }\n   else\n   {\n      std::vector<std::thread> threads;\n      int thread_count = std::thread::hardware_concurrency();\n      auto first = begin;\n      auto last = first;\n      size /= thread_count;\n      for (int i = 0; i < thread_count; ++i)\n      {\n         first = last;\n         if (i == thread_count - 1) last = end;\n         else std::advance(last, size);\n\n         threads.emplace_back([first, last, &f]() {\n            std::transform(first, last, first, std::forward<F>(f));\n         });\n      }\n\n      for (auto & t : threads) t.join();\n   }\n}\n```", "```cpp\ntemplate <typename T, typename F>\nstd::vector<T> palter(std::vector<T> data, F&& f)\n{\n   ptransform(std::begin(data), std::end(data),\n              std::forward<F>(f));\n   return data;\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> data(1000000);\n   // init data\n   auto result = palter(data, [](int const e) {return e * e; });\n}\n```", "```cpp\ntemplate <typename Iterator, typename F>\nauto pprocess(Iterator begin, Iterator end, F&& f)\n{\n   auto size = std::distance(begin, end);\n   if (size <= 10000)\n   {\n      return std::forward<F>(f)(begin, end);\n   }\n   else\n   {\n      int thread_count = std::thread::hardware_concurrency();\n      std::vector<std::thread> threads;\n      std::vector<typename std::\n         iterator_traits<Iterator>::value_type> \n      mins(thread_count);\n\n      auto first = begin;\n      auto last = first;\n      size /= thread_count;\n      for (int i = 0; i < thread_count; ++i)\n      {\n         first = last;\n         if (i == thread_count - 1) last = end;\n         else std::advance(last, size);\n\n         threads.emplace_back([first, last, &f, &r=mins[i]]() {\n         r = std::forward<F>(f)(first, last);\n         });\n      }\n\n      for (auto & t : threads) t.join();\n\n      return std::forward<F>(f)(std::begin(mins), std::end(mins));\n   }\n}\n```", "```cpp\ntemplate <typename Iterator>\nauto pmin(Iterator begin, Iterator end)\n{\n   return pprocess(begin, end,\n                   [](auto b, auto e){return *std::min_element(b, e);});\n}\n\ntemplate <typename Iterator>\nauto pmax(Iterator begin, Iterator end)\n{\n   return pprocess(begin, end,\n                   [](auto b, auto e){return *std::max_element(b, e);});\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> data(count);\n   // init data\n   auto rmin = pmin(std::begin(data), std::end(data));\n   auto rmax = pmin(std::begin(data), std::end(data));\n}\n```", "```cpp\ntemplate <typename Iterator, typename F>\nauto pprocess(Iterator begin, Iterator end, F&& f)\n{\n   auto size = std::distance(begin, end);\n   if (size <= 10000)\n   {\n      return std::forward<F>(f)(begin, end);\n   }\n   else\n   {\n      int task_count = std::thread::hardware_concurrency();\n      std::vector<std::future<\n         typename std::iterator_traits<Iterator>::value_type>> tasks;\n\n      auto first = begin;\n      auto last = first;\n      size /= task_count;\n      for (int i = 0; i < task_count; ++i)\n      {\n         first = last;\n         if (i == task_count - 1) last = end;\n         else std::advance(last, size);\n\n         tasks.emplace_back(std::async(\n            std::launch::async,\n            [first, last, &f]() {\n               return std::forward<F>(f)(first, last);\n         }));\n      }\n\n      std::vector<typename std::iterator_traits<Iterator>::value_type> \n         mins;\n\n      for (auto & t : tasks) \n         mins.push_back(t.get());\n\n      return std::forward<F>(f)(std::begin(mins), std::end(mins));\n   }\n}\n\ntemplate <typename Iterator>\nauto pmin(Iterator begin, Iterator end)\n{\n   return pprocess(begin, end,\n                   [](auto b, auto e){return *std::min_element(b, e);});\n}\n\ntemplate <typename Iterator>\nauto pmax(Iterator begin, Iterator end)\n{\n   return pprocess(begin, end,\n                   [](auto b, auto e){return *std::max_element(b, e);});\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> data(count);\n   // init data\n   auto rmin = pmin(std::begin(data), std::end(data));\n   auto rmax = pmax(std::begin(data), std::end(data));\n}\n```", "```cpp\ntemplate <class RandomIt>\nRandomIt partition(RandomIt first, RandomIt last)\n{\n   auto pivot = *first;\n   auto i = first + 1;\n   auto j = last - 1;\n   while (i <= j)\n   {\n      while (i <= j && *i <= pivot) i++;\n      while (i <= j && *j > pivot) j--;\n      if (i < j) std::iter_swap(i, j);\n    }\n\n    std::iter_swap(i - 1, first);\n\n    return i - 1;\n}\n\n```", "```cpp\ntemplate <class RandomIt>\nvoid pquicksort(RandomIt first, RandomIt last)\n{\n   if (first < last)\n   {\n      auto p = partition(first, last);\n\n      if(last - first <= 100000)\n      {\n         pquicksort(first, p);\n         pquicksort(p + 1, last);\n      }\n      else\n      {\n         auto f1 = std::async(std::launch::async,\n            [first, p](){ pquicksort(first, p);});\n         auto f2 = std::async(std::launch::async,\n            [last, p]() { pquicksort(p+1, last);});\n         f1.wait();\n         f2.wait();\n      }\n   }\n}\n```", "```cpp\nint main()\n{\n   std::random_device rd;\n   std::mt19937 mt;\n   auto seed_data = std::array<int, std::mt19937::state_size> {};\n   std::generate(std::begin(seed_data), std::end(seed_data),   \n                 std::ref(rd));\n   std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n   mt.seed(seq);\n   std::uniform_int_distribution<> ud(1, 1000);\n\n   const size_t count = 1000000;\n   std::vector<int> data(count); \n   std::generate_n(std::begin(data), count, \n   [&mt, &ud]() {return ud(mt); });\n\n   pquicksort(std::begin(data), std::end(data));\n}\n```", "```cpp\nclass logger\n{\nprotected:\n   logger() {}\npublic:\n   static logger& instance()\n   {\n      static logger lg;\n      return lg;\n   }\n\n   logger(logger const &) = delete;\n   logger& operator=(logger const &) = delete;\n\n   void log(std::string_view message)\n   {\n      std::lock_guard<std::mutex> lock(mt);\n      std::cout << \"LOG: \" << message << std::endl;\n   }\n\nprivate:\n   std::mutex mt;\n};\n```", "```cpp\nint main()\n{\n   std::vector<std::thread> modules;\n\n   for(int id = 1; id <= 5; ++id)\n   {\n      modules.emplace_back([id](){\n         std::random_device rd;\n         std::mt19937 mt(rd());\n         std::uniform_int_distribution<> ud(100, 1000);\n\n         logger::instance().log(\n            \"module \" + std::to_string(id) + \" started\");\n\n         std::this_thread::sleep_for(std::chrono::milliseconds(ud(mt)));\n\n         logger::instance().log(\n            \"module \" + std::to_string(id) + \" finished\");\n      });\n   }\n\n   for(auto & m : modules) m.join();\n}\n```", "```cpp\nclass ticketing_machine\n{\npublic:\n   ticketing_machine(int const start) : \n      last_ticket(start),first_ticket(start) \n   {}\n\n   int next() { return last_ticket++; }\n   int last() const { return last_ticket - 1; }\n   void reset() { last_ticket = first_ticket; }\nprivate:\n   int first_ticket;\n   int last_ticket;\n};\n\nclass customer\n{\npublic:\n   customer(int const no) : number(no) {}\n\n   int ticket_number() const noexcept { return number; }\nprivate:\n   int number;\n   friend bool operator<(customer const & l, customer const & r);\n};\n\nbool operator<(customer const & l, customer const & r)\n{\n   return l.number > r.number;\n}\n```", "```cpp\nint main()\n{\n   std::priority_queue<customer> customers;\n   bool office_open = true;\n   std::mutex mt;\n   std::condition_variable cv;\n\n   std::vector<std::thread> desks;\n   for (int i = 1; i <= 3; ++i)\n   {\n      desks.emplace_back([i, &office_open, &mt, &cv, &customers]() {\n         std::random_device rd;\n         auto seed_data = std::array<int, std::mt19937::state_size> {};\n         std::generate(std::begin(seed_data), std::end(seed_data),\n                       std::ref(rd));\n         std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n         std::mt19937 eng(seq);\n         std::uniform_int_distribution<> ud(2000, 3000);\n\n         logger::instance().log(\"desk \" + std::to_string(i) + \" open\");\n\n         while (office_open || !customers.empty())\n         {\n            std::unique_lock<std::mutex> locker(mt);\n\n            cv.wait_for(locker, std::chrono::seconds(1),\n               [&customers]() {return !customers.empty(); });\n\n            if (!customers.empty())\n            {\n               auto const c = customers.top();\n               customers.pop();\n\n               logger::instance().log(\n                  \"[-] desk \" + std::to_string(i) + \" handling customer \"\n                  + std::to_string(c.ticket_number()));\n\n               logger::instance().log(\n                  \"[=] queue size: \" + std::to_string(customers.size()));\n\n               locker.unlock();\n               cv.notify_one();\n\n               std::this_thread::sleep_for(\n                  std::chrono::milliseconds(ud(eng)));\n\n               logger::instance().log(\n                  \"[ ] desk \" + std::to_string(i) + \" done with customer \"\n                  + std::to_string(c.ticket_number()));\n            }\n         }\n\n         logger::instance().log(\"desk \" + std::to_string(i) + \" closed\");\n      });\n   }\n\n   std::thread store([&office_open, &customers, &mt, &cv]() {\n      ticketing_machine tm(100);\n\n      std::random_device rd;\n      auto seed_data = std::array<int, std::mt19937::state_size> {};\n      std::generate(std::begin(seed_data), std::end(seed_data),\n                    std::ref(rd));\n      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n      std::mt19937 eng(seq);\n      std::uniform_int_distribution<> ud(200, 500);\n\n      for (int i = 1; i <= 25; ++i)\n      {\n         customer c(tm.next());\n         customers.push(c);\n\n         logger::instance().log(\"[+] new customer with ticket \" +\n            std::to_string(c.ticket_number()));\n         logger::instance().log(\"[=] queue size: \" +\n            std::to_string(customers.size()));\n\n         cv.notify_one();\n\n         std::this_thread::sleep_for(std::chrono::milliseconds(ud(eng)));\n      }\n\n      office_open = false;\n   });\n\n   store.join(); \n   for (auto & desk : desks) desk.join();\n}\n```", "```cpp\nLOG: desk 1 open\nLOG: desk 2 open\nLOG: desk 3 open\nLOG: [+] new customer with ticket 100\nLOG: [-] desk 2 handling customer 100\nLOG: [=] queue size: 0\nLOG: [=] queue size: 0\nLOG: [+] new customer with ticket 101\nLOG: [=] queue size: 1\nLOG: [-] desk 3 handling customer 101\nLOG: [=] queue size: 0\nLOG: [+] new customer with ticket 102\nLOG: [=] queue size: 1\nLOG: [-] desk 1 handling customer 102\nLOG: [=] queue size: 0\nLOG: [+] new customer with ticket 103\nLOG: [=] queue size: 1\n...\nLOG: [+] new customer with ticket 112\nLOG: [=] queue size: 7\nLOG: [+] new customer with ticket 113\nLOG: [=] queue size: 8\nLOG: [ ] desk 2 done with customer 103\nLOG: [-] desk 2 handling customer 106\nLOG: [=] queue size: 7\n...\nLOG: [ ] desk 1 done with customer 120\nLOG: [-] desk 1 handling customer 123\nLOG: [=] queue size: 1\nLOG: [ ] desk 2 done with customer 121\nLOG: [-] desk 2 handling customer 124\nLOG: [=] queue size: 0\nLOG: [ ] desk 3 done with customer 122\nLOG: desk 3 closed\nLOG: [ ] desk 1 done with customer 123\nLOG: desk 1 closed\nLOG: [ ] desk 2 done with customer 124\nLOG: desk 2 closed\n```"]