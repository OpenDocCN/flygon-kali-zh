- en: Chapter 11. Testing and Monitoring Concurrent Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。测试和监控并发应用程序
- en: '**Software testing** is a critical task of every development process. Every
    application has to fulfill the end user requirements and the testing phase is
    the place to prove this. It has to generate valid results in an acceptable time
    and with the specified format. The main objective of the testing phase is to detect
    as many errors as possible in the software to correct them and increase the global
    quality of the product.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件测试**是每个开发过程的关键任务。每个应用程序都必须满足最终用户的要求，测试阶段是证明这一点的地方。它必须在可接受的时间内以指定的格式生成有效的结果。测试阶段的主要目标是尽可能多地检测软件中的错误，以便纠正错误并提高产品的整体质量。'
- en: Traditionally, in the waterfall model, the testing phase begins when the development
    phase is very advanced but nowadays more and more development teams are using
    agile methodologies where the testing phase is integrated into the development
    phase. The main objective is to test the software as soon as possible to detect
    the errors earlier in the process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在瀑布模型中，测试阶段在开发阶段非常先进时开始，但如今越来越多的开发团队正在使用敏捷方法，其中测试阶段集成到开发阶段中。主要目标是尽快测试软件，以便在流程早期检测错误。
- en: In Java, there are a lot of tools such as **JUnit** or **TestNG** to automatize
    the execution of tests. Other tools such as **JMeter** allow you to test how many
    users can execute your application at the same time, and there are other tools
    such as **Selenium** that you can use to make integration tests in web applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有许多工具，如**JUnit**或**TestNG**，可以自动执行测试。其他工具，如**JMeter**，允许您测试有多少用户可以同时执行您的应用程序，还有其他工具，如**Selenium**，您可以用来在Web应用程序中进行集成测试。
- en: 'The testing phase is more critical and more difficult in concurrent applications.
    You have two or more threads running at the same time, but you can''t control
    their order of execution. You can do a lot of tests of an application, but you
    can''t guarantee that there isn''t an order of execution of the different threads
    that provokes a race condition or a deadlock. This circumstance also causes difficulty
    in the reproduction of errors. You can find an error that only occurs in certain
    circumstances, so it can be difficult to find its real cause. In this chapter,
    we will cover the following topics to help you to test concurrent applications:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试阶段在并发应用程序中更为关键和更为困难。您可以同时运行两个或更多个线程，但无法控制它们的执行顺序。您可以对应用程序进行大量测试，但无法保证不存在执行不同线程的顺序引发竞争条件或死锁的情况。这种情况也导致了错误的再现困难。您可能会发现只在特定情况下发生的错误，因此很难找到其真正的原因。在本章中，我们将涵盖以下主题，以帮助您测试并发应用程序：
- en: Monitoring concurrency objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控并发对象
- en: Monitoring concurrency applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控并发应用程序
- en: Testing concurrency applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试并发应用程序
- en: Monitoring concurrency objects
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控并发对象
- en: Most of the concurrency objects provided by the Java concurrency API include
    methods to know their status. This status can include the number of threads that
    are executing, the number of threads blocked waiting for a condition, the number
    of tasks executed, and so on. In this section, you will learn the most important
    methods you can use and the information you can obtain from them. This information
    can be very useful to detect the cause of an error, especially if it only occurs
    in very rare conditions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的大多数并发对象都包括了用于了解它们状态的方法。此状态可以包括正在执行的线程数、正在等待条件的线程数、已执行的任务数等。在本节中，您将学习可以使用的最重要的方法以及您可以从中获取的信息。这些信息对于检测错误的原因非常有用，特别是如果错误只在非常罕见的情况下发生。
- en: Monitoring a thread
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控线程
- en: 'The thread is the most basic element in the Java concurrency API. It allows
    you to implement a raw task. You decide what code is going to execute (extending
    the `Thread` class or implementing the `Runnable` interface), when it starts its
    execution, and how it synchronizes with other tasks of the application. The `Thread`
    class provides some methods to obtain information about a thread. These are the
    most useful methods:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是Java并发API中最基本的元素。它允许您实现原始任务。您可以决定要执行的代码（扩展`Thread`类或实现`Runnable`接口）、何时开始执行以及如何与应用程序的其他任务同步。`Thread`类提供了一些方法来获取有关线程的信息。以下是最有用的方法：
- en: '`getId()`: This method returns the identifier of the thread. It''s a `long`
    positive number and it''s unique.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: 此方法返回线程的标识符。它是一个`long`正数，且是唯一的。'
- en: '`getName()`: This method returns the name of the thread. By default, it has
    the format `Thread-xxx` but it can be modified in the constructor or using the
    `setName()` method.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName()`: 此方法返回线程的名称。默认情况下，它的格式为`Thread-xxx`，但可以在构造函数中或使用`setName()`方法进行修改。'
- en: '`getPriority()`: This method returns the priority of the thread. By default,
    all the threads have a priority of five but you can change it using the `setPriority()`
    method. Threads with a higher priority may have preference over threads with a
    lower priority.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPriority()`: 此方法返回线程的优先级。默认情况下，所有线程的优先级都为五，但您可以使用`setPriority()`方法进行更改。具有较高优先级的线程可能优先于具有较低优先级的线程。'
- en: '`getState()`: This method returns the state of the thread. It returns a value
    of `Enum` `Thread.State`, which can take the values: `NEW`, `RUNNABLE`, `BLOCKED`,
    `WAITING`, `TIMED_WAITING`, and `TERMINATED`. You can check the API documentation
    to see the real significance of every state.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`: 此方法返回线程的状态。它返回一个`Enum` `Thread.State`的值，可以取值：`NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIMED_WAITING`和`TERMINATED`。您可以查看API文档以了解每个状态的真正含义。'
- en: '`getStackTrace()`: This method returns the stack of calls of this thread as
    an array of `StackTraceElement` objects. You can print this array to know what
    calls have made the thread.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStackTrace()`: 此方法以`StackTraceElement`对象的数组形式返回此线程的调用堆栈。您可以打印此数组以了解线程所做的调用。'
- en: 'For example, you can use a piece of code like this to obtain all the relevant
    information of a thread:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用类似以下的代码片段来获取线程的所有相关信息：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this block of code, you will obtain an output as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码块，您将获得以下输出：
- en: '![Monitoring a thread](img/00035.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/00035.jpeg)'
- en: Monitoring a lock
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视锁
- en: 'A **lock** is one of the basic synchronization elements provided by the Java
    concurrency API. It''s defined in the `Lock` interface and in the `ReentrantLock`
    class. In a basic way, a lock allows you to define a critical section in your
    code, but the `Lock` mechanism is more flexible than other mechanisms as the synchronized
    keyword (for example, you can have different locks to read and write operations
    or have non-linear critical sections). The `ReentrantLock` class has some methods
    that allow you to know the status of a `Lock` object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁**是Java并发API提供的基本同步元素之一。它在`Lock`接口和`ReentrantLock`类中定义。基本上，锁允许您在代码中定义临界区，但`Lock`机制比其他机制更灵活，如同步关键字（例如，您可以有不同的锁来进行读写操作或具有非线性的临界区）。`ReentrantLock`类具有一些方法，允许您了解`Lock`对象的状态：'
- en: '`getOwner()`: This method returns a `Thread` object with the thread that currently
    has the lock, that is to say, the thread that is executing the critical section.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOwner()`: 此方法返回一个`Thread`对象，其中包含当前拥有锁的线程，也就是执行临界区的线程。'
- en: '`hasQueuedThreads()`: This method returns a `boolean` value to indicate if
    there are threads waiting to acquire this lock.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedThreads()`: 此方法返回一个`boolean`值，指示是否有线程在等待获取此锁。'
- en: '`getQueueLength()`: This method returns an `int` value with the number of threads
    that are waiting to acquire this lock.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueueLength()`: 此方法返回一个`int`值，其中包含等待获取此锁的线程数。'
- en: '`getQueuedThreads()`: This method returns a `Collection<Thread>` object with
    the `Thread` objects that are waiting to acquire this lock.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedThreads()`: 此方法返回一个`Collection<Thread>`对象，其中包含等待获取此锁的`Thread`对象。'
- en: '`isFair()`: This method returns a `boolean` value to indicate the status of
    the fairness attribute. The value of this attribute is used to determine which
    will be the next thread that acquires the lock. You can check the Java API information
    to get a detailed description of this functionality.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFair()`: 此方法返回一个`boolean`值，指示公平属性的状态。此属性的值用于确定下一个获取锁的线程。您可以查看Java API信息，以获取有关此功能的详细描述。'
- en: '`isLocked()`: This method returns a `boolean` value to indicate if this lock
    is owned by a thread or not.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLocked()`: 此方法返回一个`boolean`值，指示此锁是否被线程拥有。'
- en: '`getHoldCount()`: This method returns an `int` value with the number of times
    this thread has acquired the lock. The returned value is zero if this thread does
    not hold the lock. Otherwise it returns the number of times the `lock()` method
    was called in the current thread for which the matching `unlock()` method was
    not called.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHoldCount()`: 此方法返回一个`int`值，其中包含此线程获取锁的次数。如果此线程未持有锁，则返回值为零。否则，它将返回当前线程中调用`lock()`方法的次数，而未调用匹配的`unlock()`方法。'
- en: The `getOwner()` and the `getQueuedThreads()` methods are protected so you don't
    have direct access to them. To solve this problem, you can implement your own
    `Lock` class and implement methods that provide you that information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOwner()`和`getQueuedThreads()`方法受到保护，因此您无法直接访问它们。为解决此问题，您可以实现自己的`Lock`类，并实现提供该信息的方法。'
- en: 'For example, you can implement a class named `MyLock` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以实现一个名为`MyLock`的类，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, you can use a fragment of code similar to this to obtain all the relevant
    information about a lock:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以使用类似以下的代码片段来获取有关锁的所有相关信息：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this block of code, you will obtain an output similar to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码块，您将获得类似以下的输出：
- en: '![Monitoring a lock](img/00036.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![监视锁](img/00036.jpeg)'
- en: Monitoring an executor
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视执行器
- en: 'The **executor framework** is a mechanism that allows you to execute concurrent
    tasks without worrying about the creation and management of threads. You can send
    the tasks to the executor. It has an internal pool of threads that re-utilize
    to execute the tasks. The executor also provides a mechanism to control the resources
    consumed by your tasks so you won''t overload the system. The executor framework
    provides the `Executor` and `ExecutorService` interfaces and some classes that
    implement those interfaces. The most basic class that implements them is the `ThreadPoolExecutor`
    class. It provides some methods that allow you to know the status of the executor:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行器框架**是一种机制，允许您执行并发任务，而无需担心线程的创建和管理。您可以将任务发送到执行器。它具有一个内部线程池，用于执行任务。执行器还提供了一种机制来控制任务消耗的资源，以便您不会过载系统。执行器框架提供了`Executor`和`ExecutorService`接口以及一些实现这些接口的类。实现它们的最基本的类是`ThreadPoolExecutor`类。它提供了一些方法，允许您了解执行器的状态：'
- en: '`getActiveCount()`:This method returns the number of threads of the executor
    that are executing tasks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回正在执行任务的执行器线程数。'
- en: '`getCompletedTaskCount()`: This method returns the number of tasks that have
    been executed by the executor and have finished its execution.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 此方法返回已由执行器执行并已完成执行的任务数。'
- en: '`getCorePoolSize()`: This method returns the core number of threads. This number
    determines the minimum number of threads in the pool. Even if there are no tasks
    running in the executor, the pool won''t have less threads than the number returned
    by this method.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCorePoolSize()`: 此方法返回核心线程数。此数字确定池中的最小线程数。即使执行器中没有运行任务，池中的线程数也不会少于此方法返回的数字。'
- en: '`getLargestPoolSize()`: This method returns the maximum number of threads that
    have been in the pool of the executor at the same time.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLargestPoolSize()`: 此方法返回执行器池中同时存在的最大线程数。'
- en: '`getMaximumPoolSize()`: This method returns the maximum number of threads that
    can exist in the pool at the same time.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMaximumPoolSize()`: 此方法返回池中可以同时存在的最大线程数。'
- en: '`getPoolSize()`: This method returns the current number of threads in the pool.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回池中当前线程的数量。'
- en: '`getTaskCount()`: This method returns the number of tasks that have been sent
    to the executor including waiting, running, and already completed tasks.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTaskCount()`: 此方法返回已发送到执行程序的任务数量，包括等待、运行和已完成的任务。'
- en: '`isTerminated()`: This method returns `true` if the `shutdown()` or `shutdownNow()`
    method has been called and the `Executor` has finished the execution of all its
    pending tasks. This method returns `false` otherwise.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 如果已调用`shutdown()`或`shutdownNow()`方法并且`Executor`已完成所有待处理任务的执行，则此方法返回`true`。否则返回`false`。'
- en: '`isTerminating()`: This method returns `true` if the `shutdown()` or `shutdownNow()`
    method has been called but the executor is still executing tasks.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminating()`: 如果已调用`shutdown()`或`shutdownNow()`方法但执行程序仍在执行任务，则此方法返回`true`。'
- en: 'You can use a fragment of code similar to this to obtain the relevant information
    of a `ThreadPoolExecutor`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似以下代码片段来获取`ThreadPoolExecutor`的相关信息：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this block of code, you will obtain an output similar to this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码块，您将获得类似于以下内容的输出：
- en: '![Monitoring an executor](img/00037.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![监控执行程序](img/00037.jpeg)'
- en: Monitoring the Fork/Join framework
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控Fork/Join框架
- en: 'The **Fork/Join Framework** provides a special kind of executor for algorithms
    that can be implemented using the divide and conquer technique. It is based in
    a work-stealing algorithm. You create an initial task that has to process the
    whole problem. This task creates other subtasks that process smaller parts of
    the problem and waits for its finalization. Each task compares the size of the
    sub-problem it has to process with a predefined size. If the size is smaller than
    the predefined size, it solves the problem directly. Otherwise, it splits the
    problem in other subtasks and waits for the results returned by them. The work-stealing
    algorithm takes advantage of the threads that are executing tasks that are waiting
    for the results of their child tasks to execute other tasks. The `ForkJoinPool`
    class provides methods that allow you to obtain its status:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork/Join框架**提供了一种特殊的执行程序，用于可以使用分而治之技术实现的算法。它基于工作窃取算法。您创建一个必须处理整个问题的初始任务。此任务创建其他处理问题较小部分的子任务，并等待其完成。每个任务将要处理的子问题的大小与预定义大小进行比较。如果大小小于预定义大小，则直接解决问题。否则，将问题分割为其他子任务，并等待它们返回的结果。工作窃取算法利用正在执行等待其子任务结果的线程来执行其他任务。`ForkJoinPool`类提供了允许您获取其状态的方法：'
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for the pool.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getParallelism()`: 此方法返回为池设定的期望并行级别。'
- en: '`getPoolSize()`: This method returns the number of threads in the pool.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回池中线程的数量。'
- en: '`getActiveThreadCount()`: This method returns the number of threads in the
    pool that are currently executing tasks.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveThreadCount()`: 此方法返回当前正在执行任务的池中线程数量。'
- en: '`getRunningThreadCount()`: This method returns the number of threads that are
    not waiting for the finalization of their child tasks.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningThreadCount()`: 此方法返回不在等待其子任务完成的线程数量。'
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool that haven''t started their execution yet.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedSubmissionCount()`: 此方法返回已提交到池中但尚未开始执行的任务数量。'
- en: '`getQueuedTaskCount()`: This method returns the number of tasks in the work-stealing
    queues of this pool.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedTaskCount()`: 此方法返回此池的工作窃取队列中的任务数量。'
- en: '`hasQueuedSubmissions()`: This method returns `true` if there are tasks that
    have been submitted to the pool that haven''t started their execution yet. It
    returns `false` otherwise.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedSubmissions()`: 如果已提交到池中但尚未开始执行的任务，则此方法返回`true`。否则返回`false`。'
- en: '`getStealCount()`: This method returns the number of times the Fork/Join pool
    has executed the work-stealing algorithm.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStealCount()`: 此方法返回Fork/Join池执行工作窃取算法的次数。'
- en: '`isTerminated()`: This method returns `true` if the Fork/Join pool has finished
    its execution. It returns `false` otherwise.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 如果Fork/Join池已完成执行，则此方法返回`true`。否则返回`false`。'
- en: 'You can use a fragment of code like this to obtain the relevant information
    of a `ForkJoinPool` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似以下代码片段来获取`ForkJoinPool`类的相关信息：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Where `pool` is a `ForkJoinPool` object (for example, `ForkJoinPool.commonPool()`).
    With this block of code, you will obtain an output similar to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`pool`是一个`ForkJoinPool`对象（例如`ForkJoinPool.commonPool()`）。使用此代码块，您将获得类似于以下内容的输出：
- en: '![Monitoring the Fork/Join framework](img/00038.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![监控Fork/Join框架](img/00038.jpeg)'
- en: Monitoring a Phaser
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控Phaser
- en: 'A **Phaser** is a synchronization mechanism that allows you to execute tasks
    that can be divided into phases. This class also includes some methods to obtain
    the status of the Phaser:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phaser**是一种同步机制，允许您执行可以分为阶段的任务。此类还包括一些方法来获取Phaser的状态：'
- en: '`getArrivedParties()`: This method returns the number of registered parties
    that have finished the current phase.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getArrivedParties()`: 此方法返回已完成当前阶段的注册方数量。'
- en: '`getUnarrivedParties()`: This method returns the number of registered parties
    that haven''t finished the current phase.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUnarrivedParties()`: 此方法返回尚未完成当前阶段的注册方数量。'
- en: '`getPhase()`: This method returns the number of the current phase. The number
    of the first phase is `0`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhase()`: 此方法返回当前阶段的编号。第一个阶段的编号为`0`。'
- en: '`getRegisteredParties()`: This method returns the number of registered parties
    in the Phaser.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRegisteredParties()`: 此方法返回Phaser中注册方的数量。'
- en: '`isTerminated()`: This method returns a `boolean` value to indicate if the
    Phaser has finished its execution.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 此方法返回一个`boolean`值，指示Phaser是否已完成执行。'
- en: 'You can use a fragment of code like this to obtain the relevant information
    of a Phaser:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似以下代码片段来获取Phaser的相关信息：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this block of code, you will obtain an output similar to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码块，您将获得类似于此的输出：
- en: '![Monitoring a Phaser](img/00039.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![监视Phaser](img/00039.jpeg)'
- en: Monitoring a stream
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视流
- en: The stream mechanism is one of the most important new features introduced in
    Java 8\. It allows you to process big collections of data in a concurrent way,
    transforming that data and implementing the map and reduce programming model in
    an easy way. This class doesn't provide any method (except the `isParallel()`
    method that returns if the stream is parallel or not) to know the status of the
    stream, but includes a method named `peek()` that you can include in the pipeline
    of methods to write log information about the operations or transformations that
    you are executing in the stream.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 流机制是Java 8引入的最重要的新功能之一。它允许您以并发方式处理大量数据集，以简单的方式转换数据并实现映射和减少编程模型。这个类没有提供任何方法（除了返回流是否并行的`isParallel()`方法）来了解流的状态，但包括一个名为`peek()`的方法，您可以将其包含在方法管道中，以记录有关在流中执行的操作或转换的日志信息。
- en: 'For example, this code calculates the average of the square of the first 999
    numbers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此代码计算前999个数字的平方的平均值：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first `peek()` method writes the numbers the stream is processing and the
    second one the square of those numbers. If you execute this code, as you''re executing
    the stream in a concurrent way, you will obtain an output similar to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`peek()`方法写入流正在处理的数字，第二个写入这些数字的平方。如果您执行此代码，由于以并发方式执行流，您将获得类似于此的输出：
- en: '![Monitoring a stream](img/00040.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![监视流](img/00040.jpeg)'
- en: Monitoring concurrency applications
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视并发应用程序
- en: When you implement Java applications, you normally use an IDE such as Eclipse
    or NetBeans to create your projects and write your source code. But the **JDK**
    (short for **Java Development Kit**) includes tools you can use to compile, execute,
    or generate Javadoc documents. One of those tools is **Java VisualVM**, which
    is a graphical tool that shows you information about the applications that are
    executing in a JVM. You can find it in the bin directory of your JDK installation
    (`jvisualvm.exe`). You can also install a plugin for Eclipse (Eclipse launcher
    for VisualVM) to integrate its functionality on Eclipse.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您实现Java应用程序时，通常会使用诸如Eclipse或NetBeans之类的IDE来创建项目并编写源代码。但是**JDK**（**Java开发工具包**的缩写）包括可以用于编译、执行或生成Javadoc文档的工具。其中之一是**Java
    VisualVM**，这是一个图形工具，可以显示有关在JVM中执行的应用程序的信息。您可以在JDK安装的bin目录中找到它（`jvisualvm.exe`）。您还可以安装Eclipse的插件（Eclipse
    VisualVM启动器）以集成其功能。
- en: 'If you execute it, you will see a window similar to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行它，您将看到一个类似于这样的窗口：
- en: '![Monitoring concurrency applications](img/00041.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![监视并发应用程序](img/00041.jpeg)'
- en: 'In the left side of the screen, you can see the **Applications** tab where
    you will see all the Java applications that are currently running by the current
    user in your system. If you make a double-click in one of those applications,
    you will see five tabs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的左侧，您可以看到**应用程序**选项卡，其中将显示当前用户在系统中正在运行的所有Java应用程序。如果您在其中一个应用程序上双击，您将看到五个选项卡：
- en: '**Overview**: This tab shows general information about the application.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概述**：此选项卡显示有关应用程序的一般信息。'
- en: '**Monitor**: This tab show graphical information about the CPU, memory, classes,
    and threads used by the application.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**：此选项卡显示有关应用程序使用的CPU、内存、类和线程的图形信息。'
- en: '**Threads**: This tab shows the evolution over time of the threads of the application.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**：此选项卡显示应用程序线程随时间的演变。'
- en: '**Sampler**: This tab shows you information about the utilization of memory
    and CPU by the application. It''s similar to the **Profiler** tab, but it obtains
    the data in a different way.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样器**：此选项卡显示有关应用程序内存和CPU利用率的信息。它类似于**分析器**选项卡，但以不同的方式获取数据。'
- en: '**Profiler**: This tab shows you information about the utilization of memory
    and CPU by the application. It''s similar to the **Sampler** tab, but it obtains
    the data in a different way.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**：此选项卡显示有关应用程序内存和CPU利用率的信息。它类似于**采样器**选项卡，但以不同的方式获取数据。'
- en: In the next sections, you will learn what information you can obtain in every
    tab. You can consult the complete documentation about this tool at [https://visualvm.java.net/docindex.html](https://visualvm.java.net/docindex.html).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将了解每个选项卡中可以获得的信息。您可以在[https://visualvm.java.net/docindex.html](https://visualvm.java.net/docindex.html)上查阅有关此工具的完整文档。
- en: The Overview tab
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述选项卡
- en: 'As we mentioned before, this tab shows you general information about the application.
    This information includes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此选项卡显示有关应用程序的一般信息。此信息包括：
- en: '**PID**: The process ID of the application.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PID**：应用程序的进程ID。'
- en: '**Host**: The name of the machine that is executing the application.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：执行应用程序的计算机名称。'
- en: '**Main class**: The full name of the class that implements the `main()` method
    you''re executing.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主类**：实现`main()`方法的类的完整名称。'
- en: '**Arguments**: The list of arguments you pass to the application.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：您传递给应用程序的参数列表。'
- en: '**JVM**: The version of the JVM that is executing the application.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM**：执行应用程序的JVM版本。'
- en: '**Java**: The version of Java you''re running.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**：您正在运行的Java版本。'
- en: '**Java Home**: The location of the JDK in the system.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java主目录**：系统中JDK的位置。'
- en: '**JVM Flags**: Flags used with the JVM.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM标志**：与JVM一起使用的标志。'
- en: '**JVM Arguments**: This tab shows you the arguments we (or the IDE) passed
    to the JVM to execute the application.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM参数**：此选项卡显示我们（或IDE）传递给JVM以执行应用程序的参数。'
- en: '**System properties**: This tab shows you the properties and the values of
    the properties of the system. You can get this information using the `System.getProperties()`
    method.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统属性**：此选项卡显示系统属性和属性值。您可以使用`System.getProperties()`方法获取此信息。'
- en: 'It''s the default tab when you access the data of an application and has an
    appearance similar to the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是访问应用程序数据时的默认选项卡，并且外观类似于以下截图：
- en: '![The Overview tab](img/00042.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![概述选项卡](img/00042.jpeg)'
- en: The Monitor tab
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视器选项卡
- en: 'As we mentioned earlier, this tab shows you graphical information about the
    CPU, memory, classes, and threads used by the application. You can see the evolution
    of these metrics over time. The appearance of this tab is similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，此选项卡向您显示了有关应用程序使用的CPU、内存、类和线程的图形信息。您可以看到这些指标随时间的演变。此选项卡的外观类似于这样：
- en: '![The Monitor tab](img/00043.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![监视器选项卡](img/00043.jpeg)'
- en: 'In the upper-right corner, you have some checkboxes to select the information
    you want to see. The **CPU** graphic shows you the percentage of CPU used by the
    application. The **Heap** graphic shows you the total size of the heap and the
    size of that heap used by the application. In this part, you can see the same
    information about the **Metaspace** (the memory zone used by the JVM to store
    the classes). The **Classes** graphic shows you the number of classes used by
    the application and the **Threads** graphic shows you the number of threads that
    are running inside the application. You can also use two buttons in this tab:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角，您有一些复选框可以选择要查看的信息。**CPU**图表显示了应用程序使用的CPU的百分比。**堆**图表显示了堆的总大小以及应用程序使用的堆的大小。在这部分，您可以看到有关**元空间**（JVM用于存储类的内存区域）的相同信息。**类**图表显示了应用程序使用的类的数量，**线程**图表显示了应用程序内运行的线程数量。您还可以在此选项卡中使用两个按钮：
- en: '**Perform GC**: It performs a garbage collection in the application immediately'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行GC**：立即在应用程序中执行垃圾回收'
- en: '**Heap Dump**: It allows you to save the current status of the application
    to check it later'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆转储**：它允许您保存应用程序的当前状态以供以后检查'
- en: 'When you create a heap dump, you will have a new tab with its information.
    Its appearance is similar to this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建堆转储时，将会有一个新的选项卡显示其信息。它的外观类似于这样：
- en: '![The Monitor tab](img/00044.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![监视器选项卡](img/00044.jpeg)'
- en: You have different sub-tabs to consult the status of the application in the
    moment you did the heap dump.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您有不同的子选项卡来查询您进行堆转储时应用程序的状态。
- en: The Threads tab
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程选项卡
- en: 'As we mentioned earlier, in the **Threads** tab, you can see the evolution
    of the threads of the application over time. It shows you the following information:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在**线程**选项卡中，您可以看到应用程序线程随时间的演变。它向您展示了以下信息：
- en: '**Live threads**: Number of threads in the application.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动线程**：应用程序中的线程数量。'
- en: '**Daemon threads**: Number of threads marked as daemon threads in the application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护线程**：应用程序中标记为守护线程的线程数量。'
- en: '**Timeline**: The evolution of threads over time including the status of the
    threads (using a color code), the time the thread has been running, and the time
    the thread has existed. On the right of the column `Total`, you can see an arrow.
    If you click it, you can select the columns you see in this tab.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：线程随时间的演变，包括线程的状态（使用颜色代码），线程运行的时间以及线程存在的时间。在`总计`列的右侧，您可以看到一个箭头。如果单击它，您可以选择在此选项卡中看到的列。'
- en: 'Its appearance is similar to this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其外观类似于这样：
- en: '![The Threads tab](img/00045.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![线程选项卡](img/00045.jpeg)'
- en: 'This tab also has the **Thread Dump** button. If you click this button, you
    will see a new tab with the stack trace of every thread running in the application.
    Its appearance is similar to this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡还有**线程转储**按钮。如果单击此按钮，您将看到一个新的选项卡，其中包含应用程序中每个正在运行的线程的堆栈跟踪。其外观类似于这样：
- en: '![The Threads tab](img/00046.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![线程选项卡](img/00046.jpeg)'
- en: The Sampler tab
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样器选项卡
- en: The **Sampler** tab shows you information about the utilization of CPU and memory
    made by your application. To obtain this information, it obtains dumps of all
    the threads of the application and processes that dump. This tab is similar to
    the **Profiler** tab but, as you will see in the next section, the difference
    between them is the way they are used to obtain the information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样器**选项卡向您展示了应用程序使用的CPU和内存的利用信息。为了获取这些信息，它获取了应用程序的所有线程的转储，并处理了该转储。该选项卡类似于**分析器**选项卡，但正如您将在下一节中看到的，它们之间的区别在于它们用于获取信息的方式。'
- en: 'This tab''s appearance is similar to this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡的外观类似于这样：
- en: '![The Sampler tab](img/00047.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![采样器选项卡](img/00047.jpeg)'
- en: 'You have two buttons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个按钮：
- en: '**CPU**: This button is used to obtain information about the use of CPU. If
    you click this button, you will see two sub-tabs:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：此按钮用于获取有关CPU使用情况的信息。如果单击此按钮，您将看到两个子选项卡：'
- en: '**CPU samples**: In this tab, you will see the utilization of CPU of the classes
    of the application'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU样本**：在此选项卡中，您将看到应用程序类的CPU利用率'
- en: '**Thread CPU time**: In this tab, you will see the utilization of CPU per thread'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程CPU时间**：在此选项卡中，您将看到每个线程的CPU利用率'
- en: '**Memory**: This button is used to obtain information about the use of memory.
    If you click this button, you will see another two sub-tabs:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：此按钮用于获取有关内存使用情况的信息。如果单击此按钮，您将看到另外两个子选项卡：'
- en: '**Heap histogram**: In this tab, you will see the number of bytes allocated
    by data type'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆直方图**：在此选项卡中，您将看到按数据类型分配的字节数'
- en: '**Per thread allocations**: In this tab, you can see the amount of memory used
    per every thread'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个线程分配**：在此选项卡中，您可以看到每个线程使用的内存量'
- en: The Profiler tab
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器选项卡
- en: The **Profiler** tab shows you information about the CPU and memory utilization
    by the application using the instrumentation API. Basically, this API adds some
    byte-codes to the methods when the JVM loads them to obtain this information.
    This information is updated over time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**选项卡向您展示了使用仪器API的应用程序的CPU和内存利用信息。基本上，当JVM加载方法时，此API会向方法添加一些字节码以获取这些信息。此信息会随时间更新。'
- en: 'This tab''s appearance is similar to this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡的外观类似于这样：
- en: '![The Profiler tab](img/00048.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![分析器选项卡](img/00048.jpeg)'
- en: By default, this tab doesn't obtain any information. You have to start a profiling
    session. To make this, you can use the **CPU** button to obtain information about
    the CPU utilization. This includes the execution time per method and the number
    of invocations to those methods. You can also use the **Memory** button. In this
    case, you can see the amount of memory and the number of objects per data type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此选项卡不会获取任何信息。您必须启动分析会话。为此，您可以使用**CPU**按钮来获取有关CPU利用率的信息。这包括每个方法的执行时间和对这些方法的调用次数。您还可以使用**内存**按钮。在这种情况下，您可以看到每种数据类型的内存量和对象数量。
- en: You can stop the profiling session when you don't need to obtain more information
    using the **Stop** button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不需要获取更多信息时，可以使用**停止**按钮停止分析会话。
- en: Testing concurrency applications
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并发应用程序
- en: 'Testing concurrency applications is a hard task. The threads of your application
    run in your computer without any guarantee of their execution order (except the
    synchronization mechanisms that you have included) so it''s very difficult (impossible
    most of the time) to test all the circumstances that can occur. You can have errors
    impossible to reproduce because it only happens under rare or unique circumstances
    or errors that happen in one machine but not in others due to the number of cores
    within the CPU. To detect and reproduce this situation, you can use different
    tools:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并发应用程序是一项艰巨的任务。您的应用程序的线程在计算机上运行，没有任何保证它们的执行顺序（除了您包含的同步机制），因此很难（大多数情况下是不可能的）测试所有可能发生的情况。您可能会遇到无法重现的错误，因为它只在罕见或独特的情况下发生，或者因为CPU内核数量的不同而在一台机器上发生而在其他机器上不会发生。为了检测和重现这种情况，您可以使用不同的工具：
- en: '**Debug**: You can use the debugger to debug the application. This process
    will be very tedious if you have only a few threads in the application and you
    have to go step by step in every thread. You can configure Eclipse or NetBeans
    to test concurrent applications.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：您可以使用调试器来调试应用程序。如果应用程序中只有几个线程，您必须逐步进行每个线程的调试，这个过程将非常繁琐。您可以配置Eclipse或NetBeans来测试并发应用程序。'
- en: '**MultithreadedTC**: This is an archived project of **Google Code** that can
    be used to force the order of execution in a concurrent application.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MultithreadedTC**：这是一个**Google Code**的存档项目，可以用来强制并发应用程序的执行顺序。'
- en: '**Java PathFinder**: This is an execution environment used by NASA for verification
    of Java programs. It includes support for validating concurrent applications.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java PathFinder**：这是NASA用于验证Java程序的执行环境。它包括验证并发应用程序的支持。'
- en: '**Unit testin**g: You can create a bunch of unit-tests (using JUnit or TestNG)
    and launch every test, for example, 1,000 times. If every test succeeds then even
    if your application has races, their chance is not very high and probably acceptable
    for production. You can include assertions in your code to verify that it hasn''t
    any race condition.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：您可以创建一堆单元测试（使用JUnit或TestNG），并启动每个测试，例如，1,000次。如果每个测试都成功，那么即使您的应用程序存在竞争，它们的机会也不是很高，可能对生产是可以接受的。您可以在代码中包含断言来验证它是否存在竞争条件。'
- en: In the following sections, you will see basic examples of testing concurrent
    applications with the MultithreadedTC and Java PathFinder tools.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将看到使用MultithreadedTC和Java PathFinder工具测试并发应用程序的基本示例。
- en: Testing concurrent applications with MultithreadedTC
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MultithreadedTC测试并发应用程序
- en: MultithreadedTC is an archived project that you can download from [http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/).
    Its latest version is from 2007, but you can still use it to test small concurrent
    applications or parts of big applications independently. You can't use it to test
    real tasks or threads but you can use it to test different orders of execution
    to check if they provoke race conditions or deadlocks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MultithreadedTC是一个存档项目，您可以从[http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/)下载。它的最新版本是2007年的，但您仍然可以使用它来测试小型并发应用程序或大型应用程序的部分。您不能用它来测试真实的任务或线程，但您可以用它来测试不同的执行顺序，以检查它们是否引起竞争条件或死锁。
- en: It's based in an internal clock that works with ticks that allows you to control
    the order of execution of different threads to test if that order of execution
    can cause any concurrency problems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于一个内部时钟，使用允许您控制不同线程的执行顺序的滴答声。以测试该执行顺序是否会引起任何并发问题。
- en: 'First of all, you need to associate two libraries to your project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将两个库与您的项目关联起来：
- en: '**The MultithreadedTC library**: The latest version is the 1.01 version'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MultithreadedTC库**：最新版本是1.01版本'
- en: '**The JUnit library**: We have tested this example with the 4.12 version'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit库**：我们已经测试了这个例子，使用的是4.12版本'
- en: 'To implement a test using the MultithreadedTC library, you have to extend the
    `MultithreadedTestCase` class that extends the `Assert` class of the JUnit library.
    You can implement the following methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MultithreadedTC库实现测试，您必须扩展`MultithreadedTestCase`类，该类扩展了JUnit库的`Assert`类。您可以实现以下方法：
- en: '`initialize()`: This method will be executed at the beginning of the test execution.
    You can override it if you need to execute initialization code for the creation
    of data objects, database connections, and so on.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`: 这个方法将在测试执行开始时执行。如果需要执行初始化代码来创建数据对象、数据库连接等，您可以重写它。'
- en: '`finish()`: This method will be executed at the end of the test execution.
    You can override it to implement the validations of the test.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish()`: 这个方法将在测试执行结束时执行。您可以重写它来实现测试的验证。'
- en: '`threadXXX()`: You have to implement a method whose name begins with the `thread`
    keyword per every thread you have in your test. For example, if you want to make
    a test with three threads, you will have three methods in your class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadXXX()`: 您必须为测试中的每个线程实现一个以`thread`关键字开头的方法。例如，如果您想要进行一个包含三个线程的测试，您的类将有三个方法。'
- en: The `MultithreadedTestCase` provides the `waitForTick()` method. This method
    receives as a parameter the number of ticks you wait for. This method sleeps the
    calling thread until the internal clock arrives at that tick.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultithreadedTestCase`提供了`waitForTick()`方法。此方法接收等待的时钟周期数作为参数。此方法使调用线程休眠，直到内部时钟到达该时钟周期。'
- en: The first tick is the tick number `0`. The MultithreadedTC framework checks
    every certain time the status of the test threads. If all the running threads
    are waiting in the `waitForTick()` method, it increments the tick number and wakes
    up all the threads that are waiting for that tick.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个时钟周期是时钟周期编号`0`。MultithreadedTC框架每隔一段时间检查测试线程的状态。如果所有运行的线程都在`waitForTick()`方法中等待，它会增加时钟周期编号并唤醒所有等待该时钟周期的线程。
- en: 'Let''s see an example of its use. Suppose you want to test a `Data` object
    with an internal `int` attribute. You want a thread that increments the value
    and a thread that decrements the value. You can create a class named `TestClassOk`
    extending the `MultithreadedTestCase` class. We use three attributes with the
    data object: the amount we will use to increment and decrement the data and the
    initial value of the data:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用它的例子。假设您想要测试具有内部`int`属性的`Data`对象。您希望一个线程增加值，另一个线程减少值。您可以创建一个名为`TestClassOk`的类，该类扩展了`MultithreadedTestCase`类。我们使用数据对象的三个属性：我们将用于增加和减少数据的数量以及数据的初始值：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We implement two methods to simulate the execution of two threads. The first
    thread is implemented in the `threadAdd()` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了两种方法来模拟两个线程的执行。第一个线程在`threadAdd()`方法中实现：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It reads the value of the data, increments its value, and writes again the
    value of the data. The second thread is implemented in the `threadSub()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它读取数据的值，增加其值，并再次写入数据的值。第二个线程在`threadSub()`方法中实现：
- en: '[PRE9]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we wait for the tick `1`. Then, we get the value of the data, decrement
    its value, and rewrite the value of the data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们等待`1`时钟周期。然后，我们获取数据的值，减少其值，并重新写入数据的值。
- en: 'To execute the test, we can use the `runOnce()` method of the `TestFramework`
    class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，我们可以使用`TestFramework`类的`runOnce()`方法：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the execution of the test begins, the two threads (`threadAdd()` and `threadSub()`)
    are launched in a concurrent way. `threadAdd()` begins the execution of its code
    and `threadSub()` waits in the `waitForTick()` method. When `threadAdd()` finishes
    its execution, the internal clock of the MultithreadedTC detects that the only
    thread running is waiting in the `waitForTick()` method, so it increments the
    tick value to `1` and wakes up the thread that executes its code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试开始执行时，两个线程（`threadAdd()`和`threadSub()`）以并发方式启动。`threadAdd()`开始执行其代码，`threadSub()`在`waitForTick()`方法中等待。当`threadAdd()`完成其执行时，MultithreadedTC的内部时钟检测到唯一运行的线程正在等待`waitForTick()`方法，因此它将时钟值增加到`1`并唤醒执行其代码的线程。
- en: In the following screenshot, you can see the output of the execution of this
    example. In this case, everything goes well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到此示例的执行输出。在这种情况下，一切都很顺利。
- en: '![Testing concurrent applications with MultithreadedTC](img/00049.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![使用MultithreadedTC测试并发应用程序](img/00049.jpeg)'
- en: 'But you can change the order of execution of the threads to provoke an error.
    For example, you can implement the following order that will provoke a race condition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以更改线程的执行顺序以引发错误。例如，您可以实现以下顺序，这将引发竞争条件：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the order of execution makes sure that both threads first read
    the value of the data and then makes its operation so the final result won't be
    correct.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，执行顺序确保两个线程首先读取数据的值，然后执行其操作，因此最终结果将不正确。
- en: 'In the following screenshot, you can see the result of the execution of this
    example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到此示例的执行结果：
- en: '![Testing concurrent applications with MultithreadedTC](img/00050.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用MultithreadedTC测试并发应用程序](img/00050.jpeg)'
- en: In this case, the `assertEquals()`method throws an exception because the expected
    and actual values are not equal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`assertEquals()`方法会抛出异常，因为期望值和实际值不相等。
- en: The main limitation of this library is that it is only useful to test basic
    concurrent code and, as you implement the tests, can't be used to test real `Thread`
    code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该库的主要限制是，它仅适用于测试基本的并发代码，并且在实现测试时无法用于测试真正的`Thread`代码。
- en: Testing concurrent applications with Java Pathfinder
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Java Pathfinder测试并发应用程序
- en: '**Java Pathfinder** or JPF is an open source execution environment from NASA
    that can be used to verify Java applications. It includes its own virtual machine
    to execute the Java byte code. Internally, it detects the points of the code where
    there can be more than one execution path and executes all the possibilities.
    In concurrent applications, this means that it will execute all the possible execution
    orders between the threads that run in your application. It also includes tools
    that allow you to detect race conditions and deadlocks.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Pathfinder**或JPF是来自NASA的开源执行环境，可用于验证Java应用程序。它包括自己的虚拟机来执行Java字节码。在内部，它检测代码中可能存在多个执行路径的点，并执行所有可能性。在并发应用程序中，这意味着它将执行应用程序中运行的线程之间的所有可能的执行顺序。它还包括允许您检测竞争条件和死锁的工具。'
- en: 'The main advantage of this tool is that it allow you to completely test your
    concurrent application to guarantee that it is free of race conditions and deadlocks.
    The inconvenient features of this tool are:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具的主要优势是，它允许您完全测试并发应用程序，以确保它不会出现竞争条件和死锁。该工具的不便之处包括：
- en: You have to install it from its source code
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须从源代码安装它
- en: If your application is complex, you will have thousands of possible paths of
    execution and the test will be very long (maybe a lot of hours if the application
    is complex)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序很复杂，您将有成千上万种可能的执行路径，测试将非常漫长（如果应用程序很复杂，可能需要很多小时）
- en: In the following sections, we will show you how to test a concurrent application
    using Java Pathfinder.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将向您展示如何使用Java Pathfinder测试并发应用程序。
- en: Installing Java Pathfinder
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Java Pathfinder
- en: As we mentioned earlier, you have to install JPF from its source code. That
    code is in a Mercurial repository so the first step is to install Mercurial and,
    as we will use the Eclipse IDE, the Mercurial plugin for Eclipse.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您必须从源代码安装JPF。该代码位于Mercurial存储库中，因此第一步是安装Mercurial，并且由于我们将使用Eclipse
    IDE，因此还需要安装Eclipse的Mercurial插件。
- en: You can download Mercurial from [https://www.mercurial-scm.org/wiki/Download](https://www.mercurial-scm.org/wiki/Download).
    You download the installation program that provides an assistant to install Mercurial
    in your computer. Maybe you will need to restart your system after the installation
    of Mercurial.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.mercurial-scm.org/wiki/Download](https://www.mercurial-scm.org/wiki/Download)下载Mercurial。您可以下载提供安装助手的安装程序，在计算机上安装Mercurial后可能需要重新启动系统。
- en: You can download the Mercurial plugin for Eclipse using `Help > Install new
    software` from the Eclipse menu and using the URL [http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable](http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable)
    as the URL to look for the software. Follow the same steps as with other plugins.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Eclipse菜单中使用`Help > Install new software`下载Eclipse的Mercurial插件，并使用URL [http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable](http://mercurialeclipse.eclipselabs.org.codespot.com/hg.wiki/update_site/stable)
    作为查找软件的URL。按照其他插件的步骤进行操作。
- en: You can also install a JPF plugin for Eclipse. You can download from [http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin](http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Eclipse中安装JPF插件。您可以从[http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin](http://babelfish.arc.nasa.gov/trac/jpf/wiki/install/eclipse-plugin)下载。
- en: Now you can access the Mercurial repository explorer perspective and add the
    repository of Java Pathfinder. We will use only the core module that is stored
    in [http://babelfish.arc.nasa.gov/hg/jpf/jpf-core](http://babelfish.arc.nasa.gov/hg/jpf/jpf-core).
    You don't need a username or password to access the repository. Once you have
    created the repository, you can right-click over the repository and select the
    **Clone repository** option to download the source code in your computer. The
    option will open a window to select some options, but you can leave the default
    values and click on the **Next** button. Then you have to choose the version you
    want to load. Leave the default value and click on the **Next** button. Finally,
    click on the **Finish** button to finish the download process. Eclipse will automatically
    run `ant` to compile the project. If you have any compilation problems, you have
    to solve them and relaunch `ant`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以访问Mercurial存储库资源管理器透视图，并添加Java Pathfinder的存储库。我们将仅使用存储在[http://babelfish.arc.nasa.gov/hg/jpf/jpf-core](http://babelfish.arc.nasa.gov/hg/jpf/jpf-core)中的核心模块。您无需用户名或密码即可访问存储库。创建存储库后，您可以右键单击存储库并选择**Clone
    repository**选项，以在计算机上下载源代码。该选项将打开一个窗口以选择一些选项，但您可以保留默认值并单击**Next**按钮。然后，您必须选择要加载的版本。保留默认值并单击**Next**按钮。最后，单击**Finish**按钮完成下载过程。Eclipse将自动运行`ant`来编译项目。如果有任何编译问题，您必须解决它们并重新运行`ant`。
- en: 'If everything went well, you will have a project named `jpf-core` in your workspace
    as in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您的工作区将有一个名为`jpf-core`的项目，如下面的截图所示：
- en: '![Installing Java Pathfinder](img/00051.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![安装Java Pathfinder](img/00051.jpeg)'
- en: The last configuration step is to create a file named `site.properties` with
    the configuration of JPF. If you access the configuration window in **Window**
    | **Preferences** and select the **JPF Preferences** option, you will see the
    route where the JPF plugin is looking for that file. You can change that route
    if you want.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的配置步骤是创建一个名为`site.properties`的文件，其中包含JPF的配置。如果您访问**Window** | **Preferences**中的配置窗口，并选择**JPF
    Preferences**选项，您将看到JPF插件正在查找该文件的路径。如果需要，您可以更改该路径。
- en: '![Installing Java Pathfinder](img/00052.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![安装Java Pathfinder](img/00052.jpeg)'
- en: 'As we will only use the core module, the file will only content the route to
    the `jpf-core` project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只使用核心模块，因此文件将只包含到`jpf-core`项目的路径：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running Java Pathfinder
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Java Pathfinder
- en: Once we have installed JPF, let's see how we can use it to test a concurrent
    application. First, we have to implement a concurrent application. In our case,
    we will use a `Data` class with an internal `int` value. It will be initialized
    with `0` and will have an `increment()` method to increment the value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了JPF后，让我们看看如何使用它来测试并发应用程序。首先，我们必须实现一个并发应用程序。在我们的情况下，我们将使用一个带有内部`int`值的`Data`类。它将初始化为`0`，并且将具有一个`increment()`方法来增加该值。
- en: Then, we will have a task named `NumberTask` that implements the `Runnable`
    interface that will increment 10 times the value of a `Data` object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个名为`NumberTask`的任务，它实现了`Runnable`接口，将增加一个`Data`对象的值10次。
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we have the `MainNumber` class that implements the `main()` method.
    We will launch two `NumberTasks` objects that will modify the same `Data` object.
    Finally, we will obtain the final value of the `Data` object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个实现了`main()`方法的`MainNumber`类。我们将启动两个将修改同一个`Data`对象的`NumberTasks`对象。最后，我们将获得`Data`对象的最终值。
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If everything goes well and no race conditions occur, the final result will
    be 200, but our code doesn't use any synchronization mechanism so it's possible
    that this circumstance occurs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，没有发生竞争条件，最终结果将是200，但我们的代码没有使用任何同步机制，所以可能会发生这种情况。
- en: 'If we want to execute this application with JPF, we need to create a configuration
    file inside the project with the `.jpf` extension. For example, we have created
    the `NumberJPF.jpf` file with the most basic configuration file we can use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用JPF执行此应用程序，我们需要在项目内创建一个具有`.jpf`扩展名的配置文件。例如，我们已经创建了`NumberJPF.jpf`文件，其中包含我们可以使用的最基本的配置文件：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We modify the class path of JPF adding the `bin` directory of our project and
    indicate the main class of our application. Now, we're ready to execute the application
    through JPF. To make this, we right-click over the `.jpf` file and select the
    **Verify** option. We will see how in the console we can see a lot of output messages.
    Every output message comes from a different execution path of the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了JPF的类路径，添加了我们项目的`bin`目录，并指定了我们应用程序的主类。现在，我们准备通过JPF执行应用程序。为此，我们右键单击`.jpf`文件，然后选择**验证**选项。我们将看到在控制台中可以看到大量输出消息。每个输出消息都来自应用程序的不同执行路径。
- en: '![Running Java Pathfinder](img/00053.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![运行Java Pathfinder](img/00053.jpeg)'
- en: 'When JPF ends the execution of all the possible execution paths, it shows statistical
    information about the execution:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当JPF结束所有可能的执行路径的执行时，它会显示有关执行的统计信息：
- en: '![Running Java Pathfinder](img/00054.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![运行Java Pathfinder](img/00054.jpeg)'
- en: The JPF execution says that no errors were detected but we can see that most
    of the results are different from 200, so our application has race conditions
    as we expected.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JPF执行显示未检测到错误，但我们可以看到大多数结果与200不同，因此我们的应用程序存在竞争条件，正如我们所预期的那样。
- en: 'In the introduction of this section, we said that JPF provides tools to detect
    race conditions and deadlocks. JPF implements this as a `Listener` mechanism that
    implements the `Observer` pattern to respond to certain events that occur in the
    execution of the code. For example, we can use the following listeners:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的介绍中，我们说JPF提供了检测竞争条件和死锁的工具。JPF将此实现为实现`Observer`模式以响应代码执行中发生的某些事件的`Listener`机制。例如，我们可以使用以下监听器：
- en: '`PreciseRaceDetector`: Use this listener to detect race conditions'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确竞争检测器：使用此监听器来检测竞争条件
- en: '`DeadlockAnalyzer`: Use this listener to detect deadlock situations'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁分析器：使用此监听器来检测死锁情况
- en: '`CoverageAnalyzer`: Use this listener to write coverage information at the
    end of the execution of JPF'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖分析器：使用此监听器在JPF执行结束时编写覆盖信息
- en: 'You can configure the listeners you want to use in the `.jpf` file with the
    configuration of an execution. For example, we have extended the previous test
    in the `NumberListenerJPF.jpf` file by adding the `PreciseRaceDetector` and the
    `CoverageAnalyzer` listeners:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`.jpf`文件中配置要在执行中使用的监听器。例如，我们通过添加`PreciseRaceDetector`和`CoverageAnalyzer`监听器扩展了先前的测试在`NumberListenerJPF.jpf`文件中：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we execute this configuration file through JPF with the **Verify** option,
    you will see as the application ends when it detects the first race condition
    showing in the console information about this circumstance:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过JPF使用**验证**选项执行此配置文件，您将看到应用程序在检测到第一个竞争条件时结束，并在控制台中显示有关此情况的信息：
- en: '![Running Java Pathfinder](img/00055.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![运行Java Pathfinder](img/00055.jpeg)'
- en: 'You will also see how the `CoverageAnalyzer` listener also writes the information:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将看到`CoverageAnalyzer`监听器也会写入信息：
- en: '![Running Java Pathfinder](img/00056.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![运行Java Pathfinder](img/00056.jpeg)'
- en: JPF is a very powerful application that includes more listeners and more extension
    mechanisms. You can find its whole documentation at [http://babelfish.arc.nasa.gov/trac/jpf/wiki](http://babelfish.arc.nasa.gov/trac/jpf/wiki).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: JPF是一个非常强大的应用程序，包括更多的监听器和更多的扩展机制。您可以在[http://babelfish.arc.nasa.gov/trac/jpf/wiki](http://babelfish.arc.nasa.gov/trac/jpf/wiki)找到其完整文档。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Testing concurrent applications is a very hard task. There's no guarantee of
    the order of execution of the threads (unless the synchronization mechanisms have
    been introduced in your application) so you should test many more different situations
    than in a serial application. Sometimes, you will have errors in your application
    that you can reproduce because they only occur in very rare situations, and sometimes
    you will have errors that only occur in specific machines because of their hardware
    or software configurations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并发应用程序是一项非常艰巨的任务。线程的执行顺序没有保证（除非在应用程序中引入了同步机制），因此您应该测试比串行应用程序更多的不同情况。有时，您的应用程序会出现错误，您可以重现这些错误，因为它们只会在非常罕见的情况下发生，有时，您的应用程序会出现错误，只会在特定的机器上发生，因为其硬件或软件配置。
- en: In this chapter, you have learned some mechanisms that can help you to test
    concurrency applications more easily. First, you have learned how to obtain information
    about the status of the most important components of the Java concurrency API
    as `Thread`, `Lock`, `Executor` or `Stream`. This information can be very useful
    if you need to detect the cause of an error. Then, you learned how to use Java
    VisualVM to monitor Java applications in general and concurrent applications in
    particular. Finally, you learned to use two different tools to test concurrent
    applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了一些可以帮助您更轻松测试并发应用程序的机制。首先，您已经学会了如何获取有关Java并发API的最重要组件（如`Thread`、`Lock`、`Executor`或`Stream`）状态的信息。如果需要检测错误的原因，这些信息可能非常有用。然后，您学会了如何使用Java
    VisualVM来监视一般的Java应用程序和特定的并发应用程序。最后，您学会了使用两种不同的工具来测试并发应用程序。
- en: Through the chapters of this book, you have learned how to use the most important
    components of the Java concurrency API as the executor framework, the `Phaser`
    class, the Fork/Join framework, and the new stream API included in Java 8 to support
    functional-style operations on streams of elements implementing real-world applications
    from the machine learning, data mining, or natural language processing world.
    You have also learned how to work with concurrency data structures and synchronization
    mechanisms and how to synchronize different concurrent blocks that are part of
    a bigger application. Finally, you learned the design principles of concurrent
    applications and how to test them, two critical factors to guarantee success using
    these kinds of applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书的章节，您已经学会了如何使用Java并发API的最重要组件，如执行器框架、`Phaser`类、Fork/Join框架以及Java 8中包含的新流API，以支持对实现机器学习、数据挖掘或自然语言处理的元素流进行函数式操作的真实应用程序。您还学会了如何使用并发数据结构和同步机制，以及如何同步大型应用程序中的不同并发块。最后，您学会了并发应用程序的设计原则以及如何测试它们，这是确保成功使用这些应用程序的两个关键因素。
- en: Implementing concurrent applications is a difficult task but also an exciting
    challenge. I hope this book has been helpful for you to meet this challenge successfully.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并发应用程序是一项艰巨的任务，但也是一项激动人心的挑战。我希望本书对您成功应对这一挑战有所帮助。
