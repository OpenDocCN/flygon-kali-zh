- en: '*Chapter 7*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*'
- en: The Java Collections Framework and Generics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java集合框架和泛型
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this lesson, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本课程结束时，您将能够：
- en: Use collections to process data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合处理数据
- en: Compare objects in different ways
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同的方式比较对象
- en: Sort collections of objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对对象集合进行排序
- en: Use collections to build efficient algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合构建高效的算法
- en: Use the best-suited collection for each use case
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每种用例使用最合适的集合
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous lessons, you learned how objects can be grouped together in arrays
    to help you process data in batches. Arrays are really useful but the fact that
    they have a static length makes them hard to deal with when loading an unknown
    amount of data. Also, accessing objects in the array requires you to know the
    array's index, otherwise traversing the whole array is necessary to find the object.
    You also learned briefly about ArrayList, which behaves like an array that can
    dynamically change its size to support more advanced use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的课程中，您学习了如何将对象组合在一起形成数组，以帮助您批量处理数据。数组非常有用，但它们具有静态长度的事实使得在加载未知数量的数据时很难处理。此外，访问数组中的对象需要您知道数组的索引，否则需要遍历整个数组才能找到对象。您还简要了解了ArrayList，它的行为类似于可以动态改变大小以支持更高级用例的数组。
- en: In this lesson, you'll learn how ArrayList actually works. You'll also learn
    about the Java Collections Framework, which includes some more advanced data structures
    for some more advanced use cases. As part of this journey, you'll also learn how
    to iterate on many data structures, compare objects in many different ways, and
    sort collections in an efficient way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，您将学习ArrayList的实际工作原理。您还将了解Java集合框架，其中包括一些更高级的数据结构，用于一些更高级的用例。作为这个旅程的一部分，您还将学习如何在许多数据结构上进行迭代，以许多不同的方式比较对象，并以高效的方式对集合进行排序。
- en: You'll also learn about generics, which is a powerful way of getting help from
    the compiler on using collections and other special classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解泛型，这是一种强大的方式，可以让编译器帮助您使用集合和其他特殊类。
- en: Reading Data from Files
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: Before we begin, let's go through some fundamentals that we're going to be using
    in the next sections of this lesson.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们先了解一些我们将在本课程后面部分使用的基础知识。
- en: Binary versus Text Files
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制与文本文件
- en: 'There are many types of files in your computer: executable files, configuration
    files, data files, and so on. Files can be split into two basic groups: binary
    and text.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算机中有许多类型的文件：可执行文件、配置文件、数据文件等。文件可以分为两个基本组：二进制和文本。
- en: Binary files are used when human interaction with the files will only be indirect,
    such as executing an application (an executable file), or a spreadsheet file that
    loads inside Excel. If you try to look inside these files, you'll see a bunch
    of unreadable characters. This type of file is very useful because they can be
    made compact to take up less space and be structured so that computers can read
    them quickly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类与文件的交互只会间接发生时，例如执行应用程序（可执行文件）或在Excel中加载的电子表格文件时，使用二进制文件。如果您尝试查看这些文件的内部，您将看到一堆无法阅读的字符。这种类型的文件非常有用，因为它们可以被压缩以占用更少的空间，并且可以被结构化，以便计算机可以快速读取它们。
- en: Text files, on the other hand, contain readable characters. If you open them
    with a text editor, you can see what's in there. Not all of them are meant for
    humans to read and some formats are almost impossible to understand. But the majority
    of text files can be read and easily edited by humans.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，文本文件包含可读字符。如果用文本编辑器打开它们，你可以看到里面的内容。并非所有文本文件都是供人类阅读的，有些格式几乎不可能理解。但大多数文本文件都可以被人类读取和轻松编辑。
- en: CSV Files
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSV文件
- en: 'A comma-separated value (CSV) file is a very common type of text file that
    is used to transport data between systems. CSVs are useful because they are easy
    to generate and easy to read. The structure of such a file is very simple:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）文件是一种非常常见的文本文件类型，用于在系统之间传输数据。CSV非常有用，因为它们易于生成和阅读。这种文件的结构非常简单：
- en: One record per line.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行一个记录。
- en: The first line is the header.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行是标题。
- en: Each record is a long string where values are separated from others using a
    comma (values can also be separated by other delimiters).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个记录都是一个长字符串，其中的值使用逗号分隔（值也可以用其他分隔符分隔）。
- en: 'The following is a piece of a file that was extracted from the sample data
    we''ll be using:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从我们将要使用的示例数据中提取出的文件的一部分。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reading Files in Java
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java中读取文件
- en: 'Java has two basic sets of classes that are used to read files: `Stream`, to
    read binary files, and `Reader`, to read text files. The most interesting part
    of how the `io` package is designed is that `Stream` and `Reader` can be combined
    to incrementally add functionality on top of each other. This capability is called
    piping because it resembles the process of connecting multiple pipes to one another.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两个基本的类集，用于读取文件：`Stream`，用于读取二进制文件，和`Reader`，用于读取文本文件。`io`包设计中最有趣的部分是`Stream`和`Reader`可以组合在一起逐步添加功能。这种能力被称为管道，因为它类似于将多个管道连接在一起的过程。
- en: We're going to be using a simple example to explain these, along with the help
    of `FileReader` and `BufferedReader`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的例子来解释这些，还有`FileReader`和`BufferedReader`的帮助。
- en: '`FileReader` reads characters one at a time. `BufferedReader` can buffer these
    characters to read one line at a time. That simplifies things for us when reading
    a CSV because we can just create a `FileReader` instance, then wrap it with `BufferedReader`,
    and then read line by line from the CSV file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReader`逐个读取字符。`BufferedReader`可以缓冲这些字符以一次读取一行。这对我们在读取CSV时很简单，因为我们可以创建一个`FileReader`实例，然后用`BufferedReader`包装它，然后从CSV文件中逐行读取：'
- en: '![Figure 7.1: Illustration of the process of reading from a CSV file](img/C09581_Figure_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：从CSV文件中读取的过程的示意图](img/C09581_Figure_07_01.jpg)'
- en: 'Figure 7.1: Illustration of the process of reading from a CSV file'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.1：从CSV文件中读取的过程的示意图
- en: 'Exercise 22: Reading a CSV File'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习22：读取CSV文件
- en: 'In this exercise, you''ll use `FileReader` and `BufferedReader` to read lines
    from a CSV file, split them, and process them like a record:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`FileReader`和`BufferedReader`从CSV文件中读取行，拆分它们，并像记录一样处理它们：
- en: 'Create a file called `ReadCSVFile.java` and add a class with the same name,
    and add a `main` method to it:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ReadCSVFile.java`的文件，并添加一个同名的类，并向其中添加一个`main`方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To start, you need to add a String variable that will get the name of the file
    to be loaded from the command-line argument:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要添加一个字符串变量，该变量将从命令行参数中获取要加载的文件的名称：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you create a new `FileReader` and pipe it into `BufferedReader` inside
    a try-with-resource, as in the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您创建一个新的`FileReader`并将其放入`BufferedReader`中，使用try-with-resource，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you have a file open to read, you can read it line by line. `BufferedReader`
    will give you a new line all the way to the end of the file. When the file ends,
    it will return `null`. Because of that, we can declare a variable line and set
    it in the `while` condition. Then, we need to immediately check whether it''s
    null. We also need a variable that will count the number of lines we read from
    the file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经打开了一个文件进行读取，您可以逐行读取它。`BufferedReader`将一直给您新的行，直到文件结束。当文件结束时，它将返回`null`。因此，我们可以声明一个变量行，并在`while`条件中设置它。然后，我们需要立即检查它是否为null。我们还需要一个变量来计算我们从文件中读取的行数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the loop, you increment the line count and ignore line zero, which is
    the header. That''s why we initialized `lineCounter` with `-1` instead of zero:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内，您增加了行计数并忽略了第零行，即标题。这就是为什么我们将`lineCounter`初始化为`-1`而不是零的原因：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you split the line using the `split` method from the `String` class.
    That method receives a separator, which in our case is a comma:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您使用`String`类的`split`方法拆分行。该方法接收一个分隔符，在我们的情况下是逗号：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can see how `FileReader` is passed into `BufferedReader` and then never
    accessed again. That's because we only want the lines and we don't care about
    the intermediate process of transforming characters into lines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`FileReader`是如何传递到`BufferedReader`中，然后再也没有访问的。这是因为我们只想要行，而不关心将字符转换为行的中间过程。
- en: Congratulations! You wrote an application that can read and parse a CSV. Feel
    free to dig deeper into this code and understand what happens when you change
    the initial line count value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您编写了一个可以读取和解析CSV的应用程序。随意深入研究这段代码，并了解当您更改初始行计数值时会发生什么。
- en: 'The output is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Building a CSV Reader
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建CSV读取器
- en: 'Now that you know how to read data from a CSV, we can start thinking about
    abstracting that logic away into its own pipe. Just like `BufferedReader` allows
    you to read a text file line-by-line, the CSV reader allows you to read a CSV
    file record by record. It builds on top of the `BufferedReader` functionality
    and adds the logic of splitting the line using a comma as the separator. The following
    diagram shows how our new pipeline will look with the CSV reader:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何从CSV中读取数据，我们可以开始考虑将该逻辑抽象成自己的管道。就像`BufferedReader`允许您逐行读取文本文件一样，CSV读取器允许您逐条记录读取CSV文件。它建立在`BufferedReader`功能之上，并添加了使用逗号作为分隔符拆分行的逻辑。以下图表显示了我们的新管道将如何使用CSV读取器：
- en: '![Figure 7.2: CSVReader can be added to the chain to read records one by one](img/C09581_Figure_07_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：CSVReader可以添加到链中以逐条读取记录](img/C09581_Figure_07_02.jpg)'
- en: 'Figure 7.2: CSVReader can be added to the chain to read records one by one'
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.2：CSVReader可以添加到链中以逐条读取记录
- en: 'Exercise 23: Building a CSV Reader'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习23：构建CSV读取器
- en: 'In this exercise, we''ll follow the piping pattern and build a simple `CSVReader`
    that we''ll be using throughout the rest of this lesson:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将遵循管道模式，并构建一个简单的`CSVReader`，我们将在本课程的其余部分中使用它：
- en: Create a new file called `CSVReader.java` and open it in your editor.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CSVReader.java`的新文件，并在编辑器中打开它。
- en: 'In this file, create a public class that is called `CSVReader` and implements
    the `Closeable` interface:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，创建一个名为`CSVReader`的公共类，并实现`Closeable`接口：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add two fields, one field to store `BufferedReader` as `final` where we''re
    going to read from, and another to store the line count:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个字段，一个字段用于将`BufferedReader`存储为`final`，我们将从中读取，另一个字段用于存储行计数：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a constructor that receives `BufferedReader` and set it to the field.
    This constructor will also read and discard the first line of the passed-in reader,
    since that is the header and we don''t care about them in this lesson:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数，接收`BufferedReader`并将其设置为字段。此构造函数还将读取并丢弃传入读取器的第一行，因为那是标题，我们在本课程中不关心它们：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `close` method by just calling the `close` method from the underlying
    reader:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用基础读取器的`close`方法来实现`close`方法：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just as `BufferedReader` has a `readLine` method, our `CSVReader` class will
    have a `readRecord` method, which will read the line from `BufferedReader` and
    then return that string, split by a comma. In this method, we''ll keep track of
    how many lines we have read so far. We also need to check whether the reader returned
    a line or not since it can return null, which means it''s finished reading the
    file and has no more lines to give us. If that''s the case, we''ll just follow
    the same pattern and return null:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`BufferedReader`有一个`readLine`方法一样，我们的`CSVReader`类将有一个`readRecord`方法，该方法将从`BufferedReader`读取行，然后返回由逗号分隔的字符串。在这种方法中，我们将跟踪到目前为止已读取多少行。我们还需要检查读取器是否返回了一行，因为它可能返回null，这意味着它已经完成了对文件的读取，并且没有更多的行可以给我们。如果是这种情况，我们将遵循相同的模式并返回null：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In a more elaborate implementation, we could store the header to expose extra
    functionalities for the user of the class, such as fetch value by header name.
    We could also do some tidying and validation on the line to ensure no extra spaces
    are wrapping the values and that they contain the expected amount of values (same
    as the header count).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的实现中，我们可以存储标题以公开类的用户提供额外的功能，例如按标题名称获取值。我们还可以对行进行整理和验证，以确保没有额外的空格包裹值，并且它们包含预期数量的值（与标题计数相同）。
- en: 'Expose `linecount` with a getter:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用getter公开`linecount`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now your new `CSVReader` is ready to be used! Create a new file called `UseCSVReaderSample.java`,
    with a class of the same name and a `main` method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的新`CSVReader`已经准备好使用了！创建一个名为`UseCSVReaderSample.java`的新文件，其中包含同名的类和一个`main`方法：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Following the same pattern we used before to read the lines from the CSV, now
    you can use your `CSVReader` class to read from the CSV file, adding the following
    to your `main` method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前使用的模式来读取CSV中的行，现在你可以使用你的`CSVReader`类来从CSV文件中读取，将以下内容添加到你的`main`方法中：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: From the preceding snippet, you can see that your code is now much simpler.
    It's focused on delivering the business logic (printing the second value with
    line count) and doesn't care about reading a CSV. This is a great practical example
    of how to create your readers to abstract away logic about processing the data
    coming from files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的片段中，你可以看到你的代码现在简单得多。它专注于提供业务逻辑（打印带有行数的第二个值），并不关心读取CSV。这是一个很好的实际例子，说明了如何创建你的读取器来抽象出关于处理来自文件的数据的逻辑。
- en: 'For the code to compile, you''ll need to add the imports from the `java.io`
    package:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使代码编译通过，你需要从`java.io`包中添加导入：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Arrays
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: As you have already learned from previous lessons, arrays are really powerful,
    but their static nature makes things difficult. Suppose you have a piece of code
    that loads users from some database or CSV file. The amount of data that will
    come from the database or file is unknown until you finish loading all the data.
    If you're using an array, you would have to resize the array on each record read.
    That would be too expensive because arrays can't be resized; they need to be copied
    over and over.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经从之前的课程中学到的，数组非常强大，但它们的静态特性使事情变得困难。假设你有一段代码，从某个数据库或CSV文件中加载用户。直到完成加载所有数据之前，从数据库或文件中获取的数据量是未知的。如果你使用的是数组，你将不得不在每次读取记录时调整数组的大小。这将是非常昂贵的，因为数组无法调整大小；它们需要一遍又一遍地复制。
- en: 'The following is some code that illustrates resizing an array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些代码，用于说明如何调整数组的大小：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To be more efficient, you could initialize the array with a specified capacity
    and trim the array after finishing reading all the records to ensure that it doesn't
    contain any extra empty rows in it. You would also need to ensure that the array
    has enough capacity while you're adding new records into it. If not, you'll have
    to make a new array with enough room and copy data over.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效，你可以初始化数组的容量，并在完成读取所有记录后修剪数组，以确保它不包含任何额外的空行。你还需要确保数组在添加新记录时有足够的容量。如果没有，你将不得不创建一个具有足够空间的新数组，并复制数据。
- en: 'Exercise 24: Reading Users from a CSV File into an Array'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：从CSV文件中读取用户到数组中
- en: 'In this exercise, you''ll learn how to use an array to store an unlimited amount
    of data coming from a data source. In our case, we''ll be using the same users
    CSV that we''ve been using throughout the previous sections:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何使用数组来存储来自数据源的无限数量的数据。在我们的例子中，我们将使用在前几节中一直使用的相同的用户CSV：
- en: 'Create a file called `User.java` and add a class with the same name. This class
    will have three fields: `id`, `name`, and `email`. It will also have a constructor
    that can initialize it with all three values. We''ll use this class to represent
    a `User`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`User.java`的文件，并添加一个同名的类。这个类将有三个字段：`id`、`name`和`email`。它还将有一个可以用所有三个值初始化的构造函数。我们将使用这个类来表示一个`User`：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the beginning of the `User` class, add a `static` method that will create
    a user from values coming as an array of strings. This will be useful when creating
    a `User` from the values read from a CSV:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`类的开头，添加一个`static`方法，该方法将从作为字符串数组传递的值创建一个用户。当从CSV中读取的值创建一个`User`时，这将非常有用：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create another file called `IncreaseOnEachRead.java` and add a class with the
    same name and a `main` method that will pass the first argument from the command
    line to another method called `loadUsers`. Then, print the number of users loaded,
    like so:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`IncreaseOnEachRead.java`的文件，并添加一个同名的类和一个`main`方法，该方法将把命令行的第一个参数传递给另一个名为`loadUsers`的方法。然后，打印加载的用户数量，如下所示：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this same file, add another method called `loadUsers`, which will return
    an array of users and receive a String called `fileToRead`, which will be the
    path to the CSV file to read:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，添加另一个名为`loadUsers`的方法，它将返回一个用户数组，并接收一个名为`fileToRead`的字符串，它将是要读取的CSV文件的路径：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this method, start by creating an empty users array and returning it at
    the end:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，首先创建一个空的用户数组，并在最后返回它：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Between those two lines, add the logic to read the CSV record by record using
    your `CSVReader`. For each record, increase the size of the array by one and then
    add a newly created `User` to the last position on the array:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两行之间，添加逻辑来使用你的`CSVReader`逐条读取CSV记录。对于每条记录，增加数组的大小，并将新创建的`User`添加到数组的最后位置：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You now can read from the CSV file and have a reference to all users loaded
    from it. This implements the approach of increasing the array on each record read.
    How would you go about implementing the more efficient approach of initializing
    the array with some capacity and increasing it as needed and trimming it at the
    end?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从CSV文件中读取，并拥有了从中加载的所有用户的引用。这实现了在每次读取记录时增加数组的方法。你将如何实现更有效的方法，即初始化数组的容量，并在需要时增加它，并在最后修剪它？
- en: 'Activity 27: Read Users from CSV Using Array with Initial Capacity'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动27：使用具有初始容量的数组从CSV中读取用户
- en: In this activity you're going to read users from the CSV similar to how you
    did in the previous exercise, but instead of growing the array on every read,
    create the array with an initial capacity and grow it as necessary. At the end,
    you'll need to check if the array has empty spaces left and shrink it to return
    an array with exact size as the number of users loaded.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将从CSV中读取用户，类似于你在上一个练习中所做的，但不是在每次读取时增加数组，而是使用初始容量创建数组，并在需要时增加它。最后，你需要检查数组是否还有空余空间，并将其缩小，以返回一个确切大小与加载的用户数量相同的数组。
- en: 'To complete this activity you''ll need to:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，您需要：
- en: Initialize an array with an initial capacity.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用初始容量初始化数组。
- en: Read the CSV from the path passed in from the command line in a loop, create
    users and add them to the array.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中从命令行传入的路径读取CSV，创建用户并将它们添加到数组中。
- en: Keep track of how many users you loaded in a variable.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪加载的用户数量。
- en: Before adding Users to the array, you'll need to check the size of the array
    and grow it if necessary.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向数组添加用户之前，您需要检查数组的大小，并在必要时进行扩展。
- en: At the end, shrink the array as necessary to return the exact number of users
    loaded.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据需要缩小数组，以返回加载的确切用户数量。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 345.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第345页找到。
- en: The Java Collections Framework
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java集合框架
- en: 'When building complex applications, you need to manipulate collections of objects
    in different ways. Initially, the core Java library was limited to only three
    options: Array, Vector, and Hashtable. All of them are powerful in their own way,
    but with time, it became clear that wasn''t enough. People started building their
    own frameworks to deal with more complex use cases such as grouping, sorting,
    and comparing.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复杂的应用程序时，您需要以不同的方式操作对象的集合。最初，核心Java库仅限于三种选项：数组、向量和哈希表。它们都以自己的方式强大，但随着时间的推移，变得清楚这是不够的。人们开始构建自己的框架来处理更复杂的用例，如分组、排序和比较。
- en: The Java Collections Framework was added to Java Standard Edition to reduce
    programming effort and improve the performance and interoperability of Java applications
    by providing data structures and algorithms that are efficient and easy to use.
    This set of interfaces and implementing classes were designed to provide an easy
    way for Java developers to build APIs that could be shared and reused.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合框架被添加到Java标准版中，以减少编程工作量，并通过提供高效且易于使用的数据结构和算法来改进Java应用程序的性能和互操作性。这组接口和实现类旨在为Java开发人员提供一种简单的方式来构建可以共享和重用的API。
- en: Vectors
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: Vectors solve the problem of arrays being static. They provide a dynamic and
    scalable way of storing many objects. They grow as you add new elements, can be
    prepared to receive large numbers of elements, and it is easy to iterate over
    elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 向量解决了数组是静态的问题。它们提供了一种动态和可扩展的存储许多对象的方式。它们随着添加新元素而增长，可以准备接收大量元素，并且很容易迭代元素。
- en: 'To take care of the internal array without having to resize it unnecessarily,
    a vector initializes it with some capacity and keeps track of what position the
    last element was added to using a pointer value, which is just an integer that
    marks that position. By default, the initial capacity is 10\. When you add more
    than the capacity of the array, the internal array is copied over to a new one
    that is bigger by some factor, leaving more empty space open so that you can add
    extra elements. The copying process is just like you did manually with the array
    in *Exercise 24*: *Reading Users from a CSV File into an Array*. The following
    is an illustration of how that works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理内部数组而不必要地调整大小，向量使用一些容量进行初始化，并使用指针值跟踪最后一个元素添加的位置，这个指针值只是一个标记该位置的整数。默认情况下，初始容量为10。当您添加的元素超过数组的容量时，内部数组将被复制到一个更大的数组中，留下更多的空间，以便您可以添加额外的元素。复制过程就像您在*练习24*中手动处理数组时所做的那样：*从CSV文件中读取用户到数组*。以下是它的工作原理的插图：
- en: '![Figure 7.3: Illustration of Vectors](img/C09581_Figure_07_03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：向量的插图](img/C09581_Figure_07_03.jpg)'
- en: 'Figure 7.3: Illustration of Vectors'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.3：向量的插图
- en: 'Using vectors was the way to get dynamic arrays in Java before the Java Collections
    Framework. However, there were two major problems:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java集合框架之前，使用向量是在Java中获得动态数组的方法。然而，存在两个主要问题：
- en: Lack of a defined interface that was easy to understand and extend
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏易于理解和扩展的定义接口
- en: Fully synchronized, which means it is protected against multi-threaded code
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全同步，这意味着它受到多线程代码的保护
- en: After the Java Collections Framework, vectors were retrofitted to comply with
    the new interfaces, solving the first problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java集合框架之后，向量被改装以符合新的接口，解决了第一个问题。
- en: 'Exercise 25: Reading Users from a CSV File into a Vector'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习25：从CSV文件中读取用户到向量
- en: 'Since a vector solves the problem of growing and shrinking as needed, in this
    exercise, we''ll rewrite the previous exercise, but instead of handling the size
    of the array, we''ll delegate to a vector. We''ll also start building a `UsersLoader`
    class, which we''ll share in all the future exercises:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量解决了根据需要增长和缩小的问题，在这个练习中，我们将重写以前的练习，但是不再处理数组的大小，而是委托给一个向量。我们还将开始构建一个`UsersLoader`类，在所有未来的练习中都会使用：
- en: 'Create a file called `UsersLoader.java` and add a class with the same name
    in it:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UsersLoader.java`的文件，并在其中添加一个同名的类：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You''ll use this class to add the shared methods so that you can load users
    from CSV files in future lessons. The first one you''ll write is going to load
    users from a CSV into a vector. Add a public static method that returns a Vector.
    In this method, instantiate `Vector` and return it at the end:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用这个类来添加共享方法，以便在未来的课程中从CSV文件中加载用户。您将首先编写的方法将从CSV中加载用户到向量中。添加一个公共静态方法，返回一个向量。在这个方法中，实例化`Vector`并在最后返回它：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Between creating `Vector` and returning it, load the data from the CSV and
    add it to `Vector`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`Vector`并返回它之间，从CSV中加载数据并将其添加到`Vector`中：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the imports that are required for this file to compile:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加编译此文件所需的导入项：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a file called `ReadUsersIntoVector.java` and add a class with the same
    name and a `main` method in it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ReadUsersIntoVector.java`的文件，并在其中添加一个同名的类和一个`main`方法：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `main` method, similar to what we did in the array case, call the method
    that loads users from a CSV into `Vector` and then print the size of `Vector`.
    In this case, use the `loadUsersInVector()` method we created in the previous
    step:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，类似于我们在数组情况下所做的，调用从CSV加载用户到`Vector`的方法，然后打印`Vector`的大小。在这种情况下，使用我们在上一步中创建的`loadUsersInVector()`方法：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the imports for this file to compile:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件的导入添加到编译：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Congratulations on finishing one more exercise! This time, you can see that
    your code is much simpler since most of the logic of loading the CSV, splitting
    it into values, creating a user, and resizing arrays is now abstracted away.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了又一个练习！这一次，您可以看到您的代码要简单得多，因为大部分加载CSV、将其拆分为值、创建用户和调整数组大小的逻辑现在都被抽象化了。
- en: 'Activity 28: Reading a Real Dataset Using Vector'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动28：使用Vector读取真实数据集
- en: In this activity you'll download a CSV with income information from the United
    States census and do some calculation over the values in the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您将下载一个包含来自美国人口普查的收入信息的CSV，并对文件中的值进行一些计算。
- en: 'To start, go to this page: [https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data).
    To download the CSV you can click on **Adult_Data**. It will open the data file
    in the browser. Download the file and save it to some place in your computer.
    The extension is irrelevant but you''ll need to remember the name of the file
    and the path.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请转到此页面：[https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data)。要下载CSV，您可以单击**Adult_Data**。它将在浏览器中打开数据文件。下载文件并将其保存到计算机中的某个位置。扩展名无关紧要，但您需要记住文件名和路径。
- en: 'You can read more about the format of the data in the website or just by opening
    it as a text file. Two things to keep in mind while working with this file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网站上阅读有关数据格式的更多信息，或者只需将其作为文本文件打开。在处理此文件时要记住两件事：
- en: There's an extra empty line at the end of the file
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件末尾有一个额外的空行
- en: This file has no header line
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件没有标题行
- en: 'Create an application that will calculate the minimum, maximum and average
    wage in this file. After reading all rows, your application should print these
    results. To accomplish this you''ll need to:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个应用程序，将计算此文件中的最低工资、最高工资和平均工资。在读取所有行之后，您的应用程序应打印这些结果。为了实现这一点，您需要：
- en: Load all wages from the file into a Vector of integers using your `CSVReader`.
    You can modify your `CSVReader` to support files without headers.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的`CSVReader`将文件中的所有工资加载到整数向量中。您可以修改您的`CSVReader`以支持没有标题的文件。
- en: 'Iterate over the values in the Vector and keep track of three values: minimum,
    maximum and sum.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代向量中的值，并跟踪三个值：最小值、最大值和总和。
- en: Print the results at the end. Remember, the average is just the sum divided
    by the size of the Vector.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后打印结果。请记住，平均值只是向量的总和除以大小。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 347.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第347页找到。
- en: Iterating over Collections
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'When working with arrays, you have two ways of iterating over them: you can
    use a `for` loop with an index:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组时，您有两种迭代的方式：您可以使用带有索引的`for`循环：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also iterate using a `for-each` loop, where you don''t have access
    to the index of the element:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`for-each`循环进行迭代，其中您无法访问元素的索引：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you need to iterate over a vector, you can use the loop with an index,
    just like an array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要迭代向量时，您可以使用带有索引的循环，就像数组一样：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also use `Vector` in a `for-each` loop, just like an array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`for-each`循环中使用`Vector`，就像数组一样：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This works because `Vector` implements `Iterable`. Iterable is a simple interface
    that tells the compiler that the instance can be used in a `for-each` loop. In
    fact, you could change your `CSVReader` to implement Iterable and then use it
    in a `for-each` loop, just like in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Vector`实现了`Iterable`。 Iterable是一个简单的接口，告诉编译器该实例可以在`for-each`循环中使用。实际上，您可以将您的`CSVReader`更改为实现Iterable，然后在`for-each`循环中使用它，就像以下代码中一样：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Iterable is a very simple interface; it has only one method that you need to
    implement: `iterator()`. That method returns an iterator. An iterator is another
    simple interface that only has two methods to implement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Iterable是一个非常简单的接口；它只有一个方法需要实现：`iterator()`。该方法返回一个迭代器。迭代器是另一个简单的接口，只有两个方法需要实现：
- en: '`hasNext()`: Returns `true` if the iterator still has elements to return.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext()`: 如果迭代器仍有要返回的元素，则返回`true`。'
- en: '`next()`: Fetches the next record and returns it. It will throw an exception
    if `hasNext()` returns `false` before calling this.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`: 获取下一个记录并返回它。如果在调用此方法之前`hasNext()`返回`false`，它将抛出异常。'
- en: An iterator represents a simple way of getting things out of a collection. But
    it also has another method that is important in some more advanced contexts, `remove()`,
    which removes the current element that was just fetched from calling `next()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器表示从集合中获取事物的一种简单方法。但它还有另一个在一些更高级的上下文中很重要的方法，`remove()`，它会删除刚刚从`next()`调用中获取的当前元素。
- en: This `remove` method is important because when you're iterating on a collection,
    you cannot modify it. This means that if you write a `for-each` loop to read elements
    from the vector and then inside this loop you call `remove(Object)` to remove
    an element from it, `ConcurrentModificationException` would be thrown. So, if
    you want to iterate over a collection using a loop and in this loop you need to
    remove an element from vector, you'll have to use an iterator.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`remove`方法很重要，因为当您在集合上进行迭代时，您不能修改它。这意味着如果您编写一个`for-each`循环来从向量中读取元素，然后在此循环中调用`remove(Object)`来从中删除一个元素，将会抛出`ConcurrentModificationException`。因此，如果您想使用循环迭代集合，并且在此循环中需要从向量中删除一个元素，您将需要使用迭代器。
- en: 'You must be thinking, "why would it be designed to work like this?" Because
    Java is a multi-threaded language. You won''t learn how to create threads or use
    them in this book because it''s an advanced topic. But the idea behind multi-threading
    is that a piece of data in memory can be accessed by two pieces of code at the
    exact same time. This is possible because of the multi-core capabilities of modern
    computers. With collections and arrays, you have to be very careful when working
    on multi-threaded applications. The following is an illustration of how that happens:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定在想，“为什么它要设计成这样？”因为Java是一种多线程语言。你不会在这本书中学习如何创建线程或使用它们，因为这是一个高级主题。但多线程的背后思想是，内存中的一块数据可以被两段代码同时访问。这是可能的，因为现代计算机具有多核能力。在处理多线程应用程序时，使用集合和数组时必须非常小心。以下是说明它发生的过程：
- en: '![Figure 7.4: Illustration of how ConcurrentModificationException occurs.](img/C09581_Figure_07_04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：ConcurrentModificationException发生的说明](img/C09581_Figure_07_04.jpg)'
- en: 'Figure 7.4: Illustration of how ConcurrentModificationException occurs'
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：ConcurrentModificationException发生的说明
- en: '`ConcurrentModificationException` is more common than we expect. The following
    is a sample for loop using an iterator that avoids this problem:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentModificationException`比我们预期的更常见。以下是使用迭代器的示例for循环，避免了这个问题：'
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Activity 29: Iterating on a Vector of Users'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动29：在用户向量上进行迭代
- en: 'Now that you have a method to load all users from the CSV file, and you know
    how to iterate on a vector, write an application that prints the names and emails
    of all users in the file. To complete this activity, you''ll need to follow these
    steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个从CSV文件中加载所有用户的方法，并且知道如何在向量上进行迭代，编写一个应用程序，打印文件中所有用户的姓名和电子邮件。要完成这个活动，你需要按照以下步骤进行：
- en: Create a new Java application that loads data from a CSV file in a vector. The
    file will be specified from the command line.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Java应用程序，从一个向量中加载来自CSV文件的数据。文件将从命令行指定。
- en: Iterate over the users in the vector and print a string that is a concatenation
    of their names and emails.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历向量中的用户，并打印一个字符串，其中包含他们的姓名和电子邮件的连接。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 349.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第349页找到。
- en: Hashtable
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希表
- en: Arrays and vectors are great when dealing with many objects that are to be processed
    in sequence. But when you have a group of objects that need to be indexed by a
    key, for example, some kind of identification, then they become cumbersome.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理需要按顺序处理的许多对象时，数组和向量非常有用。但是当你有一组需要通过键（例如某种标识）进行索引的对象时，它们就变得笨重了。
- en: 'Enter hashtables. They are a very old data structure that was created to solve
    exactly this problem: given a value, quickly identifying it and finding it in
    an array. To solve this, hash tables use a hashing function to uniquely identify
    objects. From that hash, they can use another function (normally a remainder of
    a division) to store the values in an array. That makes the process of adding
    an element to the table deterministic and fetching it very fast. The following
    is an illustration of the process of how a value gets stored in a hashtable:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了哈希表。它们是一个非常古老的数据结构，是为了解决这个问题而创建的：快速识别给定值并在数组中找到它。为了解决这个问题，哈希表使用哈希函数来唯一标识对象。从哈希中，它们可以使用另一个函数（通常是除法的余数）将值存储在数组中。这使得将元素添加到表中的过程是确定性的，并且获取它非常快。以下是说明值如何存储在哈希表中的过程：
- en: '![Figure 7.5: The process behind storing and fetching a value from a hash table](img/C09581_Figure_07_05.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：哈希表存储和提取值的过程](img/C09581_Figure_07_05.jpg)'
- en: 'Figure 7.5: The process behind storing and fetching a value from a hash table'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：哈希表存储和提取值的过程
- en: A hashtable uses an array to internally store an entry, which represents a key-value
    pair. When you put a pair in the hashtable, you provide the key and the value.
    The key is used to find where in the array the entry will be stored. Then, an
    entry holding the key and value is created and stored in the position specified.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表使用数组来内部存储一个条目，代表一个键值对。当你将一对放入哈希表时，你提供键和值。键用于找到条目将被存储在数组中的位置。然后，创建并存储一个持有键和值的条目在指定的位置。
- en: To fetch the value, you pass in the key from which the hash is calculated and
    the entry can be quickly found in the array.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取值，你传入从中计算哈希的键，然后可以快速在数组中找到条目。
- en: An interesting feature you get for free from this process is de-duplication.
    Because adding a value with the same key will generate the same hash, when you
    do that, it will overwrite whatever was stored in there previously.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个过程中，你免费获得的一个有趣的特性是去重。因为使用相同的键添加值将生成相同的哈希，当你这样做时，它将覆盖之前存储在那里的任何内容。
- en: 'Just as with vectors, the `Hashtable` class was added to Java before the Collections
    Framework. It suffered from the same two problems that vectors suffered from:
    lack of defined interfaces and being fully synchronized. It also breaks the Java
    naming convention by not following CamelCase for word separation.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向量一样，`Hashtable`类是在Java的集合框架之前添加的。它遭受了向量遭受的两个问题：缺乏定义的接口和完全同步。它还违反了Java的命名约定，没有遵循驼峰命名法来分隔单词。
- en: Also, as with vectors, after the introduction of the Collections Framework,
    hashtables was retrofitted to comply with the new interfaces, making them a seamless
    part of the framework.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量一样，在引入集合框架后，哈希表也经过了改造，以符合新的接口，使它们成为框架的无缝部分。
- en: 'Exercise 26: Writing an Application that Finds a User by Email'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习26：编写一个通过电子邮件查找用户的应用程序
- en: 'In this exercise, you''ll write an application that reads the users from a
    specified CSV file into a hashtable, using their email as a key. They then receive
    an email address from the command line and search for it in the hashtable, printing
    its information or a friendly message if this isn''t found:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个应用程序，从指定的CSV文件中读取用户到哈希表中，使用他们的电子邮件作为键。然后从命令行接收一个电子邮件地址，并在哈希表中搜索它，打印它的信息或者友好的消息，如果找不到的话：
- en: 'In your `UsersLoader.java` file, add a new method that will load users into
    a hashtable using the email as a key. Create a `Hashtable` at the beginning and
    return it at the end:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`UsersLoader.java`文件中，添加一个新方法，该方法将使用电子邮件将用户加载到Hashtable中。在开始时创建一个`Hashtable`，并在结束时返回它：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Between creating `Hashtable` and returning it, load the users from the CSV
    and put them in `Hashtable` using `email` as the key:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`Hashtable`并返回它之间，使用`email`作为键从CSV中加载用户并将它们放入`Hashtable`中：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Import `Hashtable` so that the file compiles correctly:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Hashtable`以便文件正确编译：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file called `FindUserHashtable.java` and add a class with the same
    name and add a `main` method:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FindUserHashtable.java`的文件，并添加一个同名的类，并添加一个`main`方法：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In your `main` method, load the users into a `Hashtable` using the method we
    created in the previous steps and print the number of users found:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`main`方法中，使用我们在之前步骤中创建的方法将用户加载到`Hashtable`中，并打印找到的用户数量：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Print some text to inform the user that you''re waiting for them to type in
    an email address:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一些文本，通知用户您正在等待他们输入电子邮件地址：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Read the input from the user by using `Scanner`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`Scanner`从用户那里读取输入：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check whether the email address is in `Hashtable`. If not, print a friendly
    message and exit the application:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`Hashtable`中是否存在电子邮件地址。如果没有，打印友好的消息并退出应用程序：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If found, print some information about the user that was found:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到，打印有关找到的用户的一些信息：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the necessary imports:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的导入：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is the output in the first case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一种情况的输出：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is the output in the second case:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二种情况的输出：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Congratulations! In this exercise, you used `Hashtable` to quickly find a user
    by email address.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在这个练习中，您使用了`Hashtable`来快速通过电子邮件地址找到用户。
- en: 'Activity 30: Using a Hashtable to Group Data'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动30：使用Hashtable对数据进行分组
- en: One very common usage of Hashtable, is to group records based on some key. In
    this activity you'll use this to calculate the minimum, maximum and average wages
    from the file downloaded on the previous activity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Hashtable的一个非常常见的用法是根据某个键对记录进行分组。在这个活动中，您将使用它来计算上一个活动中下载的文件的最低、最高和平均工资。
- en: 'If you haven''t already, go to this page: [https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data).
    To download the CSV you can click on **Adult_Data**. As explained before, this
    file contains income data from the United States census.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有，请转到此页面：[https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data)。要下载CSV，可以单击**Adult_Data**。如前所述，此文件包含来自美国人口普查的收入数据。
- en: There are many attributes that are associated with each wage. For this exercise,
    you'll group the records by the education attribute. Then, as you did before,
    print the minimum, maximum and average wages, but now, for each grouped set wages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多属性与每个工资相关联。在这个练习中，您将根据教育属性对记录进行分组。然后，像之前一样，打印最低、最高和平均工资，但现在是对每组工资进行的。
- en: 'To complete this activity you''ll need to:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，您需要：
- en: Load the `adult.data` CSV file using the `CSVReader`. This time, you'll load
    the data into a Hashtable where the keys are Strings and the values are Vectors
    of integers. The key is going to be the education attribute and in the vector,
    you'll store all the wages associated with that education.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CSVReader`加载`adult.data` CSV文件。这次，您将数据加载到一个Hashtable中，其中键是字符串，值是整数的向量。键将是教育属性，并且在向量中，您将存储与该教育相关的所有工资。
- en: With all the wages grouped inside the Hashtable, now you can iterate over the
    entries, key-value pairs, and do the same calculation you did in the previous
    activity.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将所有工资分组在Hashtable中，现在可以遍历条目、键值对，并执行与上一个活动中相同的计算。
- en: For each entry, print the minimum, maximum and average wages for each education
    level found in the file.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个条目，打印文件中找到的每个教育水平的最低、最高和平均工资。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 351.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第351页找到。
- en: Generics
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: Classes that work with other classes in a generic way, like Vector, didn't have
    a way to explicitly tell the compiler that only one type was accepted. Because
    of that, it uses Object everywhere and runtime checks like `instanceof` and casting
    were necessary everywhere.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vector等以通用方式与其他类一起工作的类一样，没有明确告诉编译器只接受一种类型的方法。因此，它在任何地方都使用Object，并且需要在任何地方进行`instanceof`和转换等运行时检查。
- en: To solve this problem, Generic was introduced in Java 5\. In this section you'll
    understand better the problem, the solution and how to use it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Java 5中引入了泛型。在本节中，您将更好地了解问题、解决方案以及如何使用它。
- en: What was the Problem?
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: 'When declaring an array, you tell the compiler what type of data goes inside
    the array. If you try to add something else in there, it won''t compile. Look
    at the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明数组时，您告诉编译器数组中包含的数据类型。如果尝试在其中添加其他内容，它将无法编译。看看以下代码：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s say you try to do something similar with `Vector`, like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您尝试使用`Vector`做类似的事情，如下所示：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The compiler will not help you at all. The same thing goes for `Hashtable`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将一点帮助也没有。`Hashtable`也是如此：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This also occurs when fetching data. When fetching from an array, the compiler
    knows what type of data is in there, so you don''t need to cast it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这也发生在获取数据时。当从数组中获取数据时，编译器知道其中包含的数据类型，因此您不需要对其进行转换：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To fetch data from a collection, you need to cast data. A simple example is
    adding the following code after adding the two elements to the previous `usersVector`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中获取数据，您需要对数据进行转换。一个简单的例子是在向先前的`usersVector`添加两个元素后添加以下代码：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It will compile, but it will throw a `ClassCastException` at runtime:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它将编译，但会在运行时抛出`ClassCastException`：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This was a big source of bugs for a long time in the Java world. And then generics
    came along and changed everything.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Java世界中很长一段时间是一个很大的错误源。然后泛型出现了，改变了一切。
- en: 'Generics is a way for you to tell the compiler that a generic class will only
    work with a specified type. Let''s have a look at what this means:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种告诉编译器泛型类只能与指定类型一起使用的方法。让我们看看这意味着什么：
- en: '**Generic class**: A generic class is a class that has a generic functionality
    which works with different types, like a Vector, that can store any type of object.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泛型类**：泛型类是一个具有泛型功能的类，可以与不同类型一起使用，比如Vector，可以存储任何类型的对象。'
- en: '**Specified type**: With generics, when you instantiate a generic class, you
    specify what type that generic class will be used with. For example, you can specify
    that you only want to store users in your Vector.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定类型**：使用泛型时，当你实例化一个泛型类时，你要指定该泛型类将与何种类型一起使用。例如，你可以指定你只想在你的Vector中存储用户。'
- en: '**Compiler**: It is important to highlight that a generic is a compile time-only
    feature. There''s no information about generic type definition at runtime. At
    runtime, everything behaves like it was before generics.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器**：需要强调的是，泛型是一个仅在编译时存在的特性。在运行时，关于泛型类型定义的信息是不存在的。在运行时，一切都像在泛型之前一样运行。'
- en: 'Generic classes have a special declaration that exposes how many types it requires.
    Some generic classes require multiple types, but most only require one. In the
    Javadocs for generic classes, there''s a special angle brackets arguments list
    that specifies how many type parameters it requires, such as in `<T, R>`. The
    following is a screenshot of the Javadoc for `java.util.Map`, which is one of
    the interfaces in the Collections Framework:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类有一个特殊的声明，公开了它需要多少种类型。一些泛型类需要多种类型，但大多数只需要一种。在泛型类的Javadoc中，有一个特殊的尖括号参数列表，指定了它需要多少个类型参数，比如`<T,
    R>`。以下是`java.util.Map`的Javadoc截图，它是集合框架中的一个接口之一：
- en: '![Figure 7.6: Screenshot of the Javadoc for java.util.Map, where it shows the
    generic type declaration](img/C09581_Figure_07_06.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：java.util.Map的Javadoc截图，显示了泛型类型声明](img/C09581_Figure_07_06.jpg)'
- en: 'Figure 7.6: Screenshot of the Javadoc for java.util.Map, where it shows the
    generic type declaration'
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.6：java.util.Map的Javadoc截图，显示了泛型类型声明
- en: How to Use Generics
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用泛型
- en: 'To use generics, when declaring an instance of a generic class, you specify
    what type will be used for that instance using angle brackets. The following is
    how you declare a vector that only handles users:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型时，在声明泛型类的实例时，你要使用尖括号指定该实例将使用的类型。以下是如何声明一个只处理用户的向量：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For a hashtable, you need to specify the types for the key and value. For a
    hashtable that would store users with their IDs as keys, the declaration would
    look as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于哈希表，你需要指定键和值的类型。对于一个将用户及其ID存储为键的哈希表，声明将如下所示：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Just declaring the generic types with the correct parameters will solve the
    problems we described earlier. For example, let''s say you are declaring a vector
    so that it only handles users. You would try and add a String to it, as in the
    following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用正确的参数声明泛型类型，就可以解决我们之前描述的问题。例如，假设你正在声明一个只处理用户的向量。你会尝试将一个字符串添加到其中，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, this would result in a compilation error:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将导致编译错误：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now that the compiler ensures that nothing except users will be added to the
    vector, you can fetch data from it without having to cast it. The compiler will
    automatically convert the type for you:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器确保只有用户会被添加到向量中，你可以从中获取数据而无需进行类型转换。编译器会自动为你转换类型：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Exercise 27: Finding a User by Text in a Name or Email'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：通过姓名或电子邮件中的文本查找用户
- en: 'In this exercise, you''ll write an application that reads users from a CSV
    file into a vector like you did before. You''ll then be asked for a string that
    will be used to filter the users. The application will print some information
    about all the users that contained the passed-in string in their name or email:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个应用程序，从CSV文件中读取用户到一个向量中，就像之前一样。然后，你将被要求输入一个字符串，该字符串将用于过滤用户。应用程序将打印出所有包含传入字符串的姓名或电子邮件的用户的一些信息：
- en: 'Open your `UsersLoader.java` file and set all the methods to use generic versions
    of collections. Your `loadUsersInHashtableByEmail` should look as follows (only
    showing the lines that have changed):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`UsersLoader.java`文件，并将所有的方法设置为使用集合的泛型版本。你的`loadUsersInHashtableByEmail`应该如下所示（只显示了已更改的行）：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Your `loadUsersInVector` should look as follows (only showing lines that have
    changed):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`loadUsersInVector`应该如下所示（只显示了已更改的行）：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note:'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: You don't have to change other places where you called these methods because
    using them as the non-generic version still works.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必更改其他调用这些方法的地方，因为使用它们作为非泛型版本仍然有效。
- en: 'Create a file named `FindByStringWithGenerics.java` and add a class with the
    same name and a `main` method, like so:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FindByStringWithGenerics.java`的文件，并添加一个同名的类和一个`main`方法，如下所示：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add a call to the `loadUsersInVector` method to your `main` method, storing
    the value in a vector with the specified generic type. Print the number of users
    loaded:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main`方法中添加一个对`loadUsersInVector`方法的调用，使用指定泛型类型的向量存储值。打印加载的用户数量：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After that, ask the user to type a string and store that in a variable after
    transforming it to lowercase:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，要求用户输入一个字符串，并将其存储在一个变量中，转换为小写后存储：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the try-with-resource block, create a variable to count the number of
    users found. Then, iterate over the users from the vector we loaded previously
    and search for the string in the email and name for each user, making sure to
    set all strings to lowercase:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在try-with-resource块内，创建一个变量来计算找到的用户数量。然后，遍历我们之前加载的向量中的用户，并为每个用户在电子邮件和姓名中搜索字符串，确保将所有字符串转换为小写：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, if `totalFound` is zero, meaning no users were found, print a friendly
    message. Otherwise, print the number of users you found:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果`totalFound`为零，表示没有找到用户，则打印友好的消息。否则，打印你找到的用户数量：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here''s the output of the first case:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第一个案例的输出：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here''s the output of the second case:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二个案例的输出：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Congratulations! Now you understand how generics can help you write safe and
    easy code using your collections.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你明白了泛型如何帮助你编写安全且易于使用的代码来处理你的集合。
- en: Sorting and Comparing
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序和比较
- en: 'In our day-to-day lives, we compare things all the time: cold/hot, short/tall,
    thin/thick, big/small. Objects can be compared using different spectrums. You
    can compare them by color, size, weight, volume, height, width, and so on. When
    comparing two objects, you''re normally interested in finding which one is more
    something (or less something) than the other or whether they are equal on whatever
    measure you''re using.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，我们经常比较事物：冷/热，短/高，薄/厚，大/小。对象可以使用不同的标准进行比较。你可以按颜色、大小、重量、体积、高度、宽度等进行比较。在比较两个对象时，通常你想找出哪一个在某个标准上更多（或更少）或者它们在你使用的任何度量上是否相等。
- en: 'There are two basic scenarios where comparing objects is important: finding
    the maximum (or minimum) and sorting.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本情况下比较对象很重要：找到最大值（或最小值）和排序。
- en: When finding the maximum or minimum, you compare all objects with each other
    and then pick the winner in whatever regard you were looking at. Everything else
    can be ignored. You don't need to keep track of the others, as long as you can
    be sure you're not infinitely comparing the same two objects over and over again.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到最大值或最小值时，你将所有对象相互比较，然后根据你所关注的标准选择获胜者。其他一切都可以忽略。你不需要跟踪其他对象，只要确保你不会无限次地重复比较同样的两个对象。
- en: Sorting, on the other hand, is more complicated. You have to keep track of all
    the elements that you have compared so far and you also need to make sure that
    you keep them sorted along the way.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，排序更加复杂。你需要跟踪到目前为止已经比较过的所有元素，并确保在比较过程中保持它们排序。
- en: The Collections Framework includes a few interfaces, classes, and algorithms
    that can help you with all of this.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架包括一些接口、类和算法，可以帮助你处理所有这些。
- en: Comparables and Comparators
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可比较和比较器
- en: 'In Java, there is an interface that describes how objects can be compared to
    each other. The `java.lang.Comparable` interface is a generic interface that has
    only one method that needs to be implemented: `compareTo(T)`. From the Javadocs,
    `compareTo` should return "a negative integer, zero, or a positive integer as
    this object is less than, equal to, or greater than the specified object".'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有一个描述对象如何相互比较的接口。`java.lang.Comparable`接口是一个泛型接口，只有一个需要实现的方法：`compareTo(T)`。根据Javadocs，`compareTo`应该返回"负整数、零或正整数，表示此对象小于、等于或大于指定对象"。
- en: 'To understand how it works, let''s take a String as an example. String implements
    `java.lang.Comparable<String>`, which means you can compare two strings, like
    so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，让我们以一个字符串为例。字符串实现了`java.lang.Comparable<String>`，这意味着你可以比较两个字符串，如下所示：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If the first object on the comparison is "less" than the second, then it will
    return a negative number (it can be any number and the size means nothing). If
    both are the same, then it will return zero. If the first is more than the second,
    then it will return a positive number (again, size means nothing).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比较中第一个对象"小于"第二个，则它将返回一个负数（可以是任何数字，大小无关紧要）。如果两者相同，则返回零。如果第一个大于第二个，则返回一个正数（同样，大小无关紧要）。
- en: 'That''s all well and good until you stumble onto something such as the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，直到你遇到以下情况：
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When you go to read the String Javadoc, its `compareTo` method says that it
    "compares two strings lexicographically". This means that it uses the character
    code to check which string comes first. The difference here is that the character
    codes have all the uppercase letters first, then all the lowercase ones. Because
    of that, "A" comes after "B", since B's character code is before A's.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看String的Javadoc时，它的`compareTo`方法说它"按字典顺序比较两个字符串"。这意味着它使用字符代码来检查哪个字符串排在前面。不同之处在于字符代码首先包括所有大写字母，然后是所有小写字母。因此，"A"在"B"之后，因为B的字符代码在A之前。
- en: 'But what if we want to compare strings alphabetically and not lexicographically?
    As mentioned before, objects can be compared in many different spectrums. Because
    of that, Java provides another interface that can be used to compare two objects:
    `java.util.Comparator`. Classes can implement a comparator using the most common
    use case, like numbers can be compared using their natural order. Then, we can
    create another class that implements `Comparator` to compare objects using some
    other custom algorithm.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想按字母顺序而不是按词典顺序比较字符串怎么办？如前所述，对象可以在许多不同的标准下进行比较。因此，Java提供了另一个接口，可以用于比较两个对象：`java.util.Comparator`。类可以实现一个比较器，使用最常见的用例，比如数字可以使用它们的自然顺序进行比较。然后，我们可以创建另一个实现`Comparator`的类，使用一些其他自定义算法来比较对象。
- en: 'Exercise 28: Creating a Comparator that Compares Strings Alphabetically'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：创建一个按字母顺序比较字符串的比较器
- en: 'In this exercise, you''ll create a class that implements `java.util.Comparator<String>`
    and can be used to compare strings alphabetically, and not lexicographically:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个实现`java.util.Comparator<String>`的类，用于按字母顺序比较字符串，而不是按词典顺序：
- en: 'Create a file called `AlphabeticComparator.java` and add a class with the same
    name that implements `java.util.Comparator<String>` (don''t forget the import):'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AlphabeticComparator.java`的文件，并添加一个同名的类，该类实现`java.util.Comparator<String>`（不要忘记导入）：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the `compareTo` method, you just turn both strings into lowercase and then
    compare them:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compareTo`方法中，你只需将两个字符串转换为小写，然后进行比较：
- en: '[PRE75]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a new file called `UseAlphabeticComparator.java` and add a class with
    the same name with a `main` method in so that you can test your new comparator:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UseAlphabeticComparator.java`的新文件，并添加一个同名的类，其中包含一个`main`方法，以便你可以测试你的新比较器：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now instantiate your class and write some test cases to make sure that your
    class is working as expected:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实例化你的类，并编写一些测试用例，以确保你的类按预期工作：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Congratulations! You wrote your first comparator. Now, let's move on and see
    what else you can do with Comparables and Comparators.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你写了你的第一个比较器。现在，让我们继续看看你可以用Comparables和Comparators做些什么。
- en: Sorting
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: When you have collections of objects, it's very common to want to sort them
    in some way or other. Being able to compare two objects is the basis for all sorting
    algorithms. Now that you know how to compare objects, it's time to use that to
    add sorting logic to your applications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有对象的集合时，很常见希望以某种方式对它们进行排序。能够比较两个对象是所有排序算法的基础。现在你知道如何比较对象了，是时候利用它来为你的应用程序添加排序逻辑了。
- en: 'There are many sorting algorithms out there, each one with its own strengths
    and weaknesses. For simplicity, we''ll discuss only two: bubble sort, because
    of its simplicity, and merge sort, because of its stable performance, which is
    why it was picked by the Java core implementers.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多排序算法，每种算法都有其自身的优势和劣势。为简单起见，我们只讨论两种：冒泡排序，因为它简单；归并排序，因为它的稳定性表现良好，这也是Java核心实现者选择它的原因。
- en: Bubble Sort
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: The most naive sorting algorithm is bubble sort, but it's also the simplest
    to understand and implement. It works by iterating over each element and comparing
    it with the next element. If it finds two elements that are not sorted, it swaps
    them and moves on to the next. When it gets to the end of the array, it checks
    how many elements were swapped. It continues this cycle until the number of swapped
    elements in a cycle is zero, which means that the whole array or collection has
    been sorted.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最天真的排序算法是冒泡排序，但它也是最简单的，易于理解和实现。它通过迭代每个元素并将其与下一个元素进行比较来工作。如果找到两个未排序的元素，它会交换它们并继续下一个。当它到达数组的末尾时，它会检查有多少元素被交换。它会继续这个循环，直到一个循环中交换的元素数为零，这意味着整个数组或集合已经排序完成。
- en: 'The following is an illustration of how sorting an array with seven elements
    using bubble sort would happen:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用冒泡排序对包含七个元素的数组进行排序的示例：
- en: '![Figure 7.7: Illustration showing how bubble sort works](img/C09581_Figure_07_07.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：展示冒泡排序工作原理的示例](img/C09581_Figure_07_07.jpg)'
- en: 'Figure 7.7: Illustration showing how bubble sort works'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：展示冒泡排序工作原理的示例
- en: Bubble sort is very space efficient since it doesn't need any extra arrays or
    a place to store variables. However, it uses a lot of iterations and comparisons.
    In the example from the illustration, there's a total of 30 comparisons and 12
    swaps.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序非常节省空间，因为它不需要任何额外的数组或存储变量的地方。然而，它使用了大量的迭代和比较。在示例中，总共有30次比较和12次交换。
- en: Merge Sort
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'Bubble sort works, but as you may have noticed, it is really naive and it feels
    like there are a lot of wasted cycles. Merge sort, on the other hand, is much
    more efficient and is based on the divide-and-conquer strategy. It works by recursively
    splitting the array/collection in half until you end up with multiple pairs of
    one element. Then, it merges them back together while sorting at the same time.
    You can see how this works in the following illustration:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序虽然有效，但你可能已经注意到，它真的很天真，感觉浪费了很多循环。另一方面，归并排序更有效，基于分而治之的策略。它通过递归地将数组/集合一分为二，直到最终得到多个一元素对。然后，在排序的同时将它们合并在一起。你可以在下面的示例中看到它是如何工作的：
- en: '![Figure 7.8: Illustration of the merge sort algorithm](img/C09581_Figure_07_08.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：归并排序算法的示例](img/C09581_Figure_07_08.jpg)'
- en: 'Figure 7.8: Illustration of the merge sort algorithm'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：归并排序算法的示例
- en: In comparison to bubble sort, the number of comparisons for merge sort is much
    smaller – only 13 for the illustrated example. It uses more memory space since
    every merge step needs an extra array to store the data that is being merged.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与冒泡排序相比，归并排序的比较次数要小得多-仅为示例中的13次。它使用更多的内存空间，因为每个合并步骤都需要额外的数组来存储正在合并的数据。
- en: One good thing that is not explicit in the preceding illustration is that merge
    sort has stable performance since it will always execute the same amount of steps;
    it doesn't matter how shuffled or sorted the data is. Compared to bubble sort,
    the number of swaps can get very high if you get a situation where the array/collection
    is sorted backwards.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的示例中没有明确表达的一点是，归并排序具有稳定的性能，因为它总是执行相同数量的步骤；无论数据是多么混乱或排序。与冒泡排序相比，如果遇到数组/集合是反向排序的情况，交换的次数可能会非常高。 '
- en: Stability is very important for a core library such as the Collections Framework,
    and that's why merge sort was the algorithm that was picked as the implementation
    for sorting in the `java.util.Collections` utility class.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定性对于诸如Collections Framework之类的核心库非常重要，这就是为什么归并排序被选为`java.util.Collections`实用类中排序的实现算法的原因。
- en: 'Activity 31: Sorting Users'
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动31：对用户进行排序
- en: 'Write three user comparators: one to compare by ID, one to compare by name,
    and one to compare by email. Then, write an application that loads the unique
    users and prints the users sorted by a field that was picked from an input from
    the command line. To complete this activity, you will need to follow these steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 编写三个用户比较器：一个按ID比较，一个按名称比较，一个按电子邮件比较。然后，编写一个应用程序，加载唯一用户并按从命令行输入中选择的字段对用户进行排序。要完成此活动，你需要按照以下步骤进行：
- en: Write three classes that implement `java.util.Comparator<User>`. One that compares
    by ID, one that compares by name, and one that compares by email.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写三个实现`java.util.Comparator<User>`的类。一个按ID比较，一个按名称比较，一个按电子邮件比较。
- en: Load the users from the CSV using the method that returns a `Hashtable` instance
    so that you have a collection with unique users.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回`Hashtable`实例的方法从CSV中加载用户，这样你就有了一个包含唯一用户的集合。
- en: Load the values from `Hashtable` into a vector so that you can keep them in
    a specified order.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Hashtable`中的值加载到向量中，以便按指定顺序保留它们。
- en: Read input from the command line to decide what field will be used to sort.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行读取输入以决定使用哪个字段进行排序。
- en: Use the correct comparator to sort the vector using the `java.util.Collections`
    sort method.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的比较器来使用`java.util.Collections`的sort方法对向量进行排序。
- en: Print the users.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印用户。
- en: Note
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 354.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第354页找到。
- en: Data Structures
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'The most fundamental part of building applications is processing data. The
    way you store the data is influenced by the way you''ll need to read and process
    it. Data structures define the way you store data. Different data structures optimize
    for different use cases. So far, we have mentioned two ways of accessing data:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序最基本的部分是处理数据。存储数据的方式受到读取和处理数据的影响。数据结构定义了存储数据的方式。不同的数据结构针对不同的用例进行了优化。到目前为止，我们已经提到了两种访问数据的方式：
- en: Sequentially, as with an array or vector
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序地，就像数组或向量一样
- en: Key-value pairs, as with a hashtable
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值对，就像哈希表一样
- en: Note
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In the following sections, we'll discuss the basic data structure of interfaces
    that have been added to the Collections Framework and how they differ from each
    other. We'll also dive deeper into each implementation and the use cases they
    solve.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论已添加到集合框架中的基本数据结构接口，以及它们与其他接口的区别。我们还将深入研究每个实现以及它们解决的用例。
- en: Collection
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'This is the most generic interface that is the base for all collections except
    Map. The documentation describes it as representing a collection of objects called
    elements. It declares the basic interface for all collections with the following
    most important methods:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最通用的接口，是除Map之外所有集合的基础。文档描述它表示一个称为元素的对象的集合。它声明了所有集合的基本接口，具有以下最重要的方法：
- en: '`add(Element)`: Adds an element to the collection'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(Element)`: 将元素添加到集合中'
- en: '`clear()`: Removes all elements from the collection'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 从集合中删除所有元素'
- en: '`contains(Object)`: Checks whether an object is in the collection'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(Object)`: 检查对象是否在集合中'
- en: '`remove(Object)`: Removes the specified element from the collection, if present'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(Object)`: 从集合中删除指定的元素（如果存在）'
- en: '`size()`: Returns the number of elements stored in the collection'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回集合中存储的元素数量'
- en: List
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: The list interface represents a sequential collection of elements that can grow
    indefinitely. Elements in a list can be accessed by their index, which is the
    position that they were put in, but can change if elements are added between other
    elements.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 列表接口表示一个可以无限增长的元素的顺序集合。列表中的元素可以通过它们的索引访问，这是它们被放置的位置，但如果在其他元素之间添加元素，索引可能会改变。
- en: When iterating over a list, the order that the elements will be fetched in is
    deterministic and will always be based on the order of their indexes, just like
    an array.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历列表时，元素将以确定性的顺序获取，并且始终基于它们的索引顺序，就像数组一样。
- en: As we mentioned previously, Vector was retrofitted to support the Collections
    Framework and it implements the list interface. Let's take a look at the other
    implementations that are available.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Vector被改装以支持集合框架，并实现了列表接口。让我们看看其他可用的实现。
- en: '`List` extends `Collection`, so it inherits all the methods we mentioned previously
    and adds some other important methods, mostly associated with position-based access:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`扩展了`Collection`，因此它继承了我们之前提到的所有方法，并添加了一些其他重要的方法，主要与基于位置的访问相关：'
- en: '`add(int, Element)`: Adds an element at the specified position'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(int, Element)`: 在指定位置添加一个元素'
- en: '`get(int)`: Returns the element at the specified position'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int)`: 返回指定位置的元素'
- en: '`indexOf(Object)`: Returns the index of the object or `-1` if not present in
    the collection'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(Object)`: 返回对象的索引，如果不在集合中则返回`-1`'
- en: '`set(int, Element)`: Replaces the element at the specified position'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(int, Element)`: 替换指定位置的元素'
- en: '`subList(int, int)`: Creates a sublist from the original list'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subList(int, int)`: 从原始列表创建一个子列表'
- en: ArrayList
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArrayList
- en: Just like Vector, ArrayList wraps an array and takes care of scaling it as needed,
    behaving just like a dynamic array. The major difference between the two is that
    vectors are fully synchronized. This means that they protect you from concurrent
    access (multi-threaded applications). It also means that on non-concurrent applications,
    which occurs in the majority of the cases, Vector is slower because of the locking
    mechanisms that are added to it. For that reason, it is recommended that you use
    ArrayList, unless you really need a synchronized list.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Vector一样，ArrayList包装了一个数组，并在需要时对其进行扩展，表现得就像一个动态数组。两者之间的主要区别在于向量是完全同步的。这意味着它们保护您免受并发访问（多线程应用程序）的影响。这也意味着在非并发应用程序中，这在大多数情况下发生，向量由于添加到其中的锁定机制而变慢。因此，建议您使用ArrayList，除非您真的需要一个同步列表。
- en: As we mentioned previously, for all purposes, ArrayList and Vector can be used
    interchangeably. Their functionality is the same and both implement the same interfaces.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，就所有目的而言，ArrayList和Vector可以互换使用。它们的功能是相同的，都实现了相同的接口。
- en: LinkedList
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LinkedList
- en: 'LinkedList is an implementation of List that does not store elements in an
    underlying array, like ArrayList or Vector. It wraps each value in another object
    called a node. A node is an internal class that contains two references to other
    nodes (the next node and the previous node) and the value being stored for that
    element. This type of list is known as a double-linked list because each node
    is linked twice, once in each direction: from the previous to the next and from
    the next to the previous.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedList是List的一种实现，它不像ArrayList或Vector那样在底层数组中存储元素。它将每个值包装在另一个称为节点的对象中。节点是一个包含对其他节点的两个引用（下一个节点和上一个节点）以及存储该元素的值的内部类。这种类型的列表被称为双向链表，因为每个节点都链接两次，一次在每个方向上：从前一个到下一个，从下一个到前一个。
- en: Internally, LinkedList stores a reference to the first and last nodes, so it
    can only traverse the list starting from the beginning or the end. It is not good
    for random or position-based access as with arrays, ArrayLists, and vectors, but
    it is good when adding an undetermined number of elements very fast.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，LinkedList存储对第一个和最后一个节点的引用，因此它只能从开始或结束处遍历列表。与数组、ArrayList和向量一样，它不适用于随机或基于位置的访问，但在非常快速地添加不确定数量的元素时非常适用。
- en: LinkedList also stores a variable that keeps track of the size of the list.
    That way, it doesn't have to traverse the list every time to check the size.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedList还存储一个变量，用于跟踪列表的大小。这样，它就不必每次都遍历列表来检查大小。
- en: 'The following illustration shows how LinkedList is implemented:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了LinkedList的实现方式：
- en: '![Figure 7.9: How a LinkedList works under the hood.](img/C09581_Figure_07_09.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9：LinkedList在内部是如何工作的。](img/C09581_Figure_07_09.jpg)'
- en: 'Figure 7.9: How LinkedList works under the hood'
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：LinkedList在内部是如何工作的
- en: Map
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图
- en: When you need to store elements associated with keys, you use Maps. As we saw
    previously, Hashtable is a powerful mechanism for indexing objects by some key,
    and after the addition of the Collections Framework, Hashtable was retrofitted
    to implement Map.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要存储与键关联的元素时，可以使用地图。正如我们之前所看到的，Hashtable是一种通过某个键对对象进行索引的强大机制，并且在添加了集合框架之后，Hashtable被改装为实现Map。
- en: The most fundamental property of maps is that they cannot contain duplicate
    keys.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的最基本属性是它们不能包含重复的键。
- en: 'Maps are powerful because they allow you to see the dataset from three different
    perspectives: keys, values, and key-value pairs. After adding your elements to
    a map, you can iterate over them from any of those three perspectives, giving
    you extra flexibility when fetching data from it.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 地图之所以强大，是因为它们允许您从三个不同的角度查看数据集：键、值和键值对。将元素添加到地图后，您可以从这三个角度中的任何一个迭代它们，从而在从中提取数据时提供额外的灵活性。
- en: 'The most important methods in the `Map` interface are as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`接口中最重要的方法如下：'
- en: '`clear()`: Remove all keys and values from the map'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 从地图中删除所有键和值'
- en: '`containsKey(Object)`: Check whether the key is present in the map'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsKey(Object)`: 检查地图中是否存在该键'
- en: '`containsValue(Object)`: Check whether the value is present in the map'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsValue(Object)`: 检查地图中是否存在该值'
- en: '`entrySet()`: Return a set of entries with all the key-value pairs in the map'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrySet()`: 返回地图中所有键值对的集合'
- en: '`get(Object)`: Return the value associated with the specified key if present'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(Object)`: 如果存在，返回与指定键关联的值'
- en: '`getOrDefault(Object, Value)`: Return the value associated with the specified
    key if present, otherwise return the specified value'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOrDefault(Object, Value)`: 如果存在，返回与指定键关联的值，否则返回指定的值'
- en: '`keySet()`: A set containing all keys in the map'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keySet()`: 包含地图中所有键的集合'
- en: '`put(Key, Value)`: Add or replace a key-value pair'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(Key, Value)`: 添加或替换键值对'
- en: '`putIfAbsent(Key, Value)`: Same as the previous method, but won''t replace
    if the key is already present'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putIfAbsent(Key, Value)`: 与上一个方法相同，但如果键已经存在，则不会替换'
- en: '`size()`: The number of key-value pairs in this map'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 此地图中键值对的数量'
- en: '`values()`: Return a collection with all the values present in this map'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 返回此地图中所有值的集合'
- en: HashMap
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HashMap
- en: Just like `Hashtable`, `HashMap` implements a hash table to store the entries
    of key-value pairs, and it works exactly the same way. Just as Vector is to ArraySet,
    Hashtable is so to `HashMap`. `Hashtable` existed before the Map interface, so
    HashMap was created as a non-synchronous implementation of the hash table.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Hashtable`一样，`HashMap`实现了哈希表来存储键值对的条目，并且工作方式完全相同。正如Vector是ArraySet一样，Hashtable是`HashMap`一样。`Hashtable`存在于Map接口之前，因此HashMap被创建为哈希表的非同步实现。
- en: 'As we mentioned before, hash tables, and consequently HashMap, are very fast
    to find elements by key. They are great to use as an in-memory cache where you
    load data that''s been keyed by some field, like you did in *Exercise 26*: *Writing
    an Application that Finds a User by Email*.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，哈希表，因此HashMap，非常快速地通过键找到元素。它们非常适合用作内存缓存，您可以在其中加载已由某个字段键入的数据，就像在*练习26*中所做的那样：*编写一个按电子邮件查找用户的应用程序*。
- en: TreeMap
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TreeMap
- en: '`TreeMap` is an implementation of Map that can keep key-value pairs sorted
    by key or by a specified comparator.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap`是可以按键或指定比较器对键值对进行排序的Map的实现。'
- en: 'As the name implies, TreeMap uses a tree as the underlying storage mechanism.
    Trees are very special data structures that are used to keep data sorted as insertions
    happen and at the same time, fetch data with very few iterations. The following
    illustration shows what a tree looks like and how a fetch operation can quickly
    find an element, even in very large trees:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，TreeMap使用树作为底层存储机制。树是非常特殊的数据结构，用于在插入发生时保持数据排序，并且同时使用非常少的迭代获取数据。以下插图显示了树的外观以及如何快速找到元素的获取操作，即使在非常大的树中也是如此：
- en: '![Figure 7.10: A tree data structure being traversed to fetch element](img/C09581_Figure_07_10.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10：正在遍历树数据结构以获取元素](img/C09581_Figure_07_10.jpg)'
- en: 'Figure 7.10: A tree data structure being traversed to fetch an element'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：正在遍历树数据结构以获取元素
- en: Trees have nodes that represent the branches. Everything starts from a root
    node and expands into multiple branches. At the ends of the leaf nodes, there
    are nodes with no children. TreeMap implements a specific type of tree called
    a red-black tree, which is a binary tree, so each node can have only two children.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有代表分支的节点。一切都始于根节点，并扩展为多个分支。在叶节点的末端，有没有子节点的节点。TreeMap实现了一种称为红黑树的特定类型的树，这是一种二叉树，因此每个节点只能有两个子节点。
- en: LinkedHashMap
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LinkedHashMap
- en: 'The name of the `LinkedHashMap` class is a bit cryptic because internally it
    uses two data structures to support some use cases that HashMap didn''t support:
    a hash table and a linked list. The hash table is used to quickly add and fetch
    elements from the map. The linked list is used when iterating over the entries
    by whatever means: key, value, or key-value pair. This gives it the ability to
    iterate over the entries in a deterministic order, which is whatever order they
    were inserted in.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashMap`类的名称有点神秘，因为它在内部使用了两种数据结构来支持一些HashMap不支持的用例：哈希表和链表。哈希表用于快速向地图中添加和获取元素。链表用于通过任何方式迭代条目：键、值或键值对。这使得它能够以确定的顺序迭代条目，这取决于它们被插入的顺序。'
- en: Set
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Set
- en: The main characteristic of sets is that they contain no duplicate elements.
    Sets are useful when you want to collect elements and at the same time eliminate
    duplicate values.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的主要特征是它们不包含重复元素。当您想要收集元素并同时消除重复值时，集合非常有用。
- en: Another important characteristic about sets is that the order that you fetch
    elements from them varies based on the implementation. This means that if you
    want to eliminate duplicates, you have to think about how you're going to read
    them afterward.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集合的另一个重要特征是，根据实现的不同，从集合中获取元素的顺序也会有所不同。这意味着如果您想要消除重复项，您必须考虑之后如何读取它们。
- en: All set implementations in the Collections Framework are based on their corresponding
    Map implementation. The only difference is that they handle the values in the
    set as the keys in the map.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中的所有集合实现都基于它们对应的Map实现。唯一的区别是它们将集合中的值处理为映射中的键。
- en: HashSet
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HashSet
- en: By far the most common of all the sets, HashSet uses a HashMap as the underlying
    storage mechanism. It stores its elements in a random order, based on the hashing
    function used in HashMap.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，所有集合中最常见的HashSet使用HashMap作为底层存储机制。它根据HashMap中使用的哈希函数存储其元素的随机顺序。
- en: TreeSet
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TreeSet
- en: Backed by a TreeMap, `TreeSet` is really useful when you want to store unique
    elements sorted by their natural order (comparables) or using a comparator.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由TreeMap支持，`TreeSet`在想要按其自然顺序（可比较的）或使用比较器对其进行排序的唯一元素时非常有用。
- en: LinkedHashSet
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LinkedHashSet
- en: 'Backed by `LinkedHashMap`, `LinkedHashSet` will keep the insertion order and
    remove duplicates as you add them to the set. It has the same advantages as LinkedHashSet:
    fast insertion and fetching like HashSet, and fast iteration like LinkedList.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由`LinkedHashMap`支持，`LinkedHashSet`将保持插入顺序并在添加到集合时删除重复项。它具有与LinkedHashSet相同的优点：像HashSet一样快速插入和获取，像LinkedList一样快速迭代。
- en: 'Exercise 29: Using TreeSet to Print Sorted Users'
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：使用TreeSet打印排序后的用户
- en: 'In *Activity 31*: *Sorting Users*, you wrote three comparators that can be
    used to sort users. Let''s use them and TreeSet to make an application that prints
    the sorted users in a much more efficient way:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Activity 31*：*Sorting Users*中，您编写了三个可用于对用户进行排序的比较器。让我们使用它们和TreeSet来制作一个以更高效的方式打印排序后用户的应用程序：
- en: 'Add a method to your `UsersLoader` class that can load the users into `Set`:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的`UsersLoader`类添加一个可以将用户加载到`Set`中的方法：
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Import `Set` as follows:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Set`如下：
- en: '[PRE80]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a new file called `SortUsersTreeSet.java` and add a class with the same
    name and add a `main` method:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SortUsersTreeSet.java`的新文件，并添加一个同名的类并添加一个`main`方法：
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Read from the command line what field we''ll sort by:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行读取我们将按哪个字段进行排序：
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create a `TreeSet` of users using the specified comparator, load the users
    into it with your new method, and then print the loaded users to the command line:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的比较器创建一个用户的`TreeSet`，使用您的新方法将用户加载到其中，然后将加载的用户打印到命令行：
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here''s the output of the first case:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第一种情况的输出：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here's the output of the second case
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二种情况的输出
- en: '[PRE85]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here's the output of the third case
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第三种情况的输出
- en: '[PRE86]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here's the output of the fourth case
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第四种情况的输出
- en: '[PRE87]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Congratulations! In this exercise, you used TreeSet to sort and eliminate duplicate
    elements while loading them from the CSV file, all at the same time.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在这个练习中，您使用TreeSet对从CSV文件加载的元素进行排序和去重，同时完成了这些操作。
- en: Queue
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Queue
- en: 'Queues are a special data structure that respect the First In, First Out (FIFO)
    pattern. This means that it keeps the elements in order of insertion and can return
    the elements starting from the first inserted one while adding elements to the
    end. That way, new work can be enqueued at the end of the queue while work to
    be processed gets dequeued from the front. The following is an illustration of
    this process:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种特殊的数据结构，遵循先进先出（FIFO）模式。这意味着它按插入顺序保留元素，并且可以从第一个插入的元素开始返回元素，同时将元素添加到末尾。这样，新的工作可以排队在队列的末尾，而要处理的工作可以从前面出列。以下是此过程的示例：
- en: '![Figure 7.11: A queue that stores work to be processed](img/C09581_Figure_07_11.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11：存储要处理的工作的队列](img/C09581_Figure_07_11.jpg)'
- en: 'Figure 7.11: A queue that stores work to be processed'
  id: totrans-437
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：存储要处理的工作的队列
- en: In the Collections Framework, a queue is represented by the `java.util.Queue`
    interface. To enqueue an element, you can use `add(E)` or `offer(E)`. The first
    will throw an exception if the queue is full, while the second will just return
    `true` or `false`, telling you whether the operation was successful or not. It
    also has methods to dequeue elements or just check what's at the front of the
    queue. `remove()` will return and remove the element at the front or throw an
    exception if the queue is empty. `poll()` will return the element and remove it
    or return null if the queue is empty. `element()` and `peek()` work the same way,
    but only return the element without removing it from the queue, the first throwing
    an exception and the latter returning null if the queue is empty.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合框架中，队列由`java.util.Queue`接口表示。要将元素入队，可以使用`add(E)`或`offer(E)`。第一个如果队列已满将抛出异常，而第二个则只会返回`true`或`false`，告诉您操作是否成功。它还有出队元素或只检查队列前面的元素的方法。`remove()`将返回并移除队列前面的元素，如果队列为空则抛出异常。`poll()`将返回并移除元素，如果队列为空则返回null。`element()`和`peek()`的工作方式相同，但只返回元素而不从队列中移除，第一个抛出异常，后者如果队列为空则返回null。
- en: '`java.util.Deque` is an interface that extends `java.util.Queue` with extra
    methods that allow elements to be added, removed, or peeked at on both sides of
    the queue.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Deque`是一个接口，它扩展了`java.util.Queue`，具有额外的方法，允许在队列的两侧添加、移除或查看元素。'
- en: '`java.util.LinkedList` is an implementation of `java.util.Queue` and `java.util.Deque`
    that also implements `java.util.List`.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.LinkedList`是`java.util.Queue`和`java.util.Deque`的实现，也实现了`java.util.List`。'
- en: java.util.ArrayDeque
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: java.util.ArrayDeque
- en: The implementation of Queue and Deque uses an array as the underlying data store.
    The array grows automatically to support the data that's added to it.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 队列和双端队列的实现使用数组作为底层数据存储。数组会自动增长以支持添加到其中的数据。
- en: java.util.PriorityQueue
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: java.util.PriorityQueue
- en: The implementation of Queue uses a heap to keep elements in sort order. The
    order can be given by the element if it implements `java.lang.Comparable` or by
    a passed-in comparator. A heap is a specialized type of tree that keeps elements
    sorted, similar to `TreeMap`. This implementation of queue is great for processing
    elements that need to be processed in some priority.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的实现使用堆来保持元素的排序顺序。如果元素实现了`java.lang.Comparable`，则可以由元素来确定顺序，或者可以通过传入的比较器来确定顺序。堆是一种特殊类型的树，它可以保持元素排序，类似于`TreeMap`。这种队列的实现非常适合需要按一定优先级处理的元素。
- en: 'Exercise 30: Fake Email Sender'
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：虚假电子邮件发送器
- en: 'In this exercise, you will simulate the process of sending emails to users
    using one processor. For this, you''ll write two applications: one that simulates
    sending the email and one that reads from the CSV and invokes the first one for
    each user. The constraint that forces you to use a queue is that only one process
    can run at a time. This means that while the users are loaded from the CSV, you''ll
    enqueue them and send emails whenever possible:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将模拟使用一个处理器向用户发送电子邮件的过程。为此，您将编写两个应用程序：一个模拟发送电子邮件，另一个从CSV中读取并为每个用户调用第一个。强制您使用队列的约束是一次只能运行一个进程。这意味着当用户从CSV中加载时，您将对其进行排队，并在可能的情况下发送电子邮件：
- en: 'Create a file called `EmailSender.java` with a class and a `main` method in
    it. To simulate sending the email, the class will sleep for a random amount of
    time, up to one second:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EmailSender.java`的文件，其中包含一个类和一个`main`方法。为了模拟发送电子邮件，该类将休眠随机的一段时间，最多一秒：
- en: '[PRE88]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Create another file called `SendAllEmails.java` with a class and a `main` method.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`SendAllEmails.java`的文件，其中包含一个类和一个`main`方法。
- en: '[PRE89]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add a `static` field called `runningProcess`. This will represent the send
    email process that is running:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`runningProcess`的`static`字段。这将代表正在运行的发送电子邮件过程：
- en: '[PRE90]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a `static` method that will try to initiate the process of sending an
    email by dequeuing an element from the queue, if the process is available:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`static`方法，该方法将尝试通过从队列中出队一个元素来启动发送电子邮件的过程，如果该过程可用：
- en: '[PRE91]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the `main` method, create an `ArrayDeque` of strings that will represent
    the queue of emails to send to:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，创建一个字符串的`ArrayDeque`，表示要发送的电子邮件队列：
- en: '[PRE92]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Open the CSV to read each row from it. You can do this by using `CSVReader`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开CSV文件以从中读取每一行。您可以使用`CSVReader`来实现这一点：
- en: '[PRE93]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'With the user loaded, we can add its email to the queue and try to send an
    email immediately:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户加载后，我们可以将其电子邮件添加到队列中，并立即尝试发送电子邮件：
- en: '[PRE94]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Because reading from a file is, in general, very fast, we''ll simulate a slow
    read by adding some sleep time:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于从文件中读取通常非常快，我们将通过添加一些睡眠时间来模拟缓慢读取：
- en: '[PRE95]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Outside the try-with-resources block, that is, after we''ve finished reading
    all users from the file, we need to ensure we drain the queue. For that, we can
    use a `while` loop that runs while the queue is not empty:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在try-with-resources块之外，也就是在我们完成从文件中读取所有用户之后，我们需要确保排空队列。为此，我们可以使用一个`while`循环，只要队列不为空就运行：
- en: '[PRE96]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, it is important to not use 100% of the CPU while you sleep. This
    is very common when processing elements from a queue, like in this case.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很重要的一点是在你睡觉的时候不要使用100%的CPU。这在处理队列中的元素时非常常见，就像在这种情况下一样。
- en: 'Now you can just wait for the last send email process to finish, following
    a similar pattern: check and wait while sleeping:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以等待最后一个发送电子邮件过程完成，遵循类似的模式：检查并在睡眠时等待：
- en: '[PRE97]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Congratulations! You wrote an application that simulates the sending of emails
    using constrained resources (one process only). This application is ignoring the
    fact that users are duplicated in the file. It also ignores the output of the
    send email process. How would you implement a duplicate send detector and avoid
    that issue? How do you think the output of the send process affects the decision
    of duplicate avoidance?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您编写了一个应用程序，使用受限资源（仅一个进程）模拟发送电子邮件。该应用程序忽略了文件中用户的重复情况。它还忽略了发送电子邮件过程的输出。您将如何实现重复发送检测器并避免该问题？您认为发送过程的输出如何影响重复避免的决定？
- en: Properties of Collections
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合的属性
- en: 'When picking a data structure to solve a problem, you''ll have to consider
    the following things:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择数据结构解决问题时，您将不得不考虑以下事项：
- en: Ordering - If order is important when accessing the data, what order the data
    will be accessed?
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序 - 如果在访问数据时顺序很重要，数据将以什么顺序被访问？
- en: Uniqueness - Does it matter if you have the same element multiple times inside
    the collection? How do you define uniqueness?
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独特性 - 如果在集合内部多次具有相同的元素，这是否重要？你如何定义独特性？
- en: Nullables - Can values be null? If mapping key to values, is the null key valid?
    Does it make sense to use null in either?
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空性 - 值是否可以为空？如果将键映射到值，空键是否有效？在任何情况下使用空是否有意义？
- en: 'Use the following table to determine what collection better suits your use
    case:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下表格确定哪种集合更适合您的用例：
- en: '![Table 7.1: Table representing the properties on collections](img/C09581_Table_07_01.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![表7.1：表示集合属性的表格](img/C09581_Table_07_01.jpg)'
- en: 'Table 7.1: Table representing the properties on collections'
  id: totrans-477
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 表7.1：表示集合属性的表格
- en: Note
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '"Sorted naturally" means that it will sort based on the element (or key) if
    the element implements `Comparable` or using a passed-in comparator.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: “自然排序”意味着它将根据元素（或键）进行排序，如果元素实现了`Comparable`，或者使用传入的比较器进行排序。
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When developing applications, processing data is one of the most fundamental
    tasks. In this lesson, you learned how to read and parse data from files so that
    you're able to process them as part of your application. You also learned how
    to compare objects so that you can sort them in different ways.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，处理数据是最基本的任务之一。在本课程中，您学会了如何从文件中读取和解析数据，以便能够将其作为应用程序的一部分进行处理。您还学会了如何比较对象，以便以不同的方式对其进行排序。
- en: As part of processing data, you learned how to store data using basic and advanced
    data structures. Knowing how to efficiently process data is very important so
    that you avoid resource contention scenarios such as running out of memory, or
    requiring too much processing or time to execute the task at hand. A big part
    of processing data efficiently is about picking the right data structures and
    algorithms for the right problems. All the new tools that you have added to your
    belt will help you make the correct decisions when building your Java applications.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 作为处理数据的一部分，您学会了如何使用基本和高级数据结构存储数据。了解如何高效地处理数据非常重要，以便避免资源争用场景，例如内存耗尽，或者需要太多的处理或时间来执行手头的任务。高效处理数据的一个重要部分是选择适合特定问题的正确数据结构和算法。您添加到工具库中的所有新工具将帮助您在构建Java应用程序时做出正确的决策。
- en: In the next lesson, we will have a look at some advanced data structures.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将看一些高级数据结构。
