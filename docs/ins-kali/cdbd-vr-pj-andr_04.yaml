- en: Chapter 4. Launcher Lobby
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。启动器大堂
- en: This project creates a Cardboard VR app that can be used to launch the other
    Cardboard apps installed on your device. We'll call it **LauncherLobby**. When
    you open LauncherLobby, you will see up to 24 icons arranged horizontally. As
    you turn your head to the right or left, the icons scroll as if they are inside
    a cylinder. You can open an app by gazing at its icon and pulling the Cardboard
    trigger.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目创建了一个硬纸板VR应用程序，可用于启动设备上安装的其他硬纸板应用程序。我们将其称为**LauncherLobby**。当您打开LauncherLobby时，您将看到最多24个图标水平排列。当您向右或向左转动头部时，图标会滚动，就好像它们在圆柱体内部一样。您可以通过凝视其图标并拉动硬纸板触发器来打开应用程序。
- en: For this project, we take a minimal approach to creating stereoscopic views.
    The project simulates parallax using standard Android ViewGroup layouts and simply
    shifts the images to the left or right in each eye, creating the parallax visual
    effect. We do not use 3D graphics. We do not use OpenGL directly, though most
    modern versions of Android render views with OpenGL. In fact, we hardly use the
    Cardboard SDK at all; we only use it to paint the split screen overlay and get
    the head orientation. The view layout and image shifting logic, however, is derived
    from Google's Treasure Hunt sample (where it is used to draw a text overlay).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们采用了一种最小化的方法来创建立体视图。该项目使用标准的Android ViewGroup布局来模拟视差，并简单地将图像在每只眼睛中向左或向右移动，从而产生视差视觉效果。我们不使用3D图形。我们不直接使用OpenGL，尽管大多数现代版本的Android都使用OpenGL来渲染视图。事实上，我们几乎完全不使用硬纸板SDK；我们只使用它来绘制分屏叠加层并获取头部方向。然而，视图布局和图像移动逻辑是从Google的Treasure
    Hunt示例中派生的（在那里用于绘制文本叠加）。
- en: The advantages of this approach are multifold. It illustrates how it's possible
    to build Cardboard apps even without high-level graphics, matrix math, render
    engines, and physics. Of course, these are often required, but in this case, they're
    not. If you have experience with Android development, the classes and patterns
    used here may be especially familiar. This project demonstrates how Cardboard
    VR, at a minimum, only needs a Cardboard SDK head transform and a split-screen
    layout to produce a stereoscopic application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是多方面的。它说明了即使没有高级图形、矩阵数学、渲染引擎和物理学，也可以构建硬纸板应用程序。当然，这些通常是必需的，但在这种情况下，它们不是。如果您有Android开发经验，这里使用的类和模式可能会特别熟悉。这个项目演示了硬纸板VR，至少只需要一个硬纸板SDK头部变换和一个分屏布局，就可以生成一个立体应用程序。
- en: Practically speaking, we chose this approach so that we can use Android's TextView.
    Rendering arbitrary text in 3D is actually pretty complicated (though certainly
    possible), so for the sake of simplicity, we are constraining this project to
    2D views and Android layouts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们选择了这种方法，以便我们可以使用Android的TextView。在3D中渲染任意文本实际上相当复杂（尽管肯定是可能的），因此为了简单起见，我们将此项目限制为2D视图和Android布局。
- en: To build the project, we'll first walk you through some basics of putting a
    text string and icon image on the screen and viewing them stereoscopically. Then,
    we'll design a virtual screen that works like the inside of a cylinder unraveled.
    Turning your head horizontally will be like panning across this virtual screen.
    The screen will be divided into slots, each containing the icon and the name of
    a Cardboard app. Gazing at and clicking on one of the slots will launch the corresponding
    application. If you've used the Cardboard Samples app (so called at the time of
    writing), this interface will be familiar.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建项目，我们首先将带您了解一些基础知识，将文本字符串和图标图像放在屏幕上，并以立体方式查看它们。然后，我们将设计一个虚拟屏幕，它的工作原理就像展开的圆柱体内部。水平转动头部就像在这个虚拟屏幕上进行平移。屏幕将被分成插槽，每个插槽包含一个硬纸板应用程序的图标和名称。凝视并点击其中一个插槽将启动相应的应用程序。如果您曾经使用过硬纸板示例应用程序（在撰写时如此称呼），这个界面将很熟悉。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a new Cardboard project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的硬纸板项目
- en: Adding a *Hello Virtual World* text overlay
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个*Hello Virtual World*文本叠加
- en: Using virtual screen space
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟屏幕空间
- en: Responding to head look
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头部查看
- en: Adding an icon to the view
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向视图添加图标
- en: Listing installed Cardboard apps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出已安装的硬纸板应用程序
- en: Highlighting the current app shortcut
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出显示当前应用程序快捷方式
- en: Using the trigger to pick and launch an app
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器选择并启动应用程序
- en: The source code for this project can be found on the Packt Publishing website
    and on GitHub at [https://github.com/cardbookvr/launcherlobby](https://github.com/cardbookvr/launcherlobby)
    (with each topic as a separate commit).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的源代码可以在Packt Publishing网站和GitHub上找到，网址为[https://github.com/cardbookvr/launcherlobby](https://github.com/cardbookvr/launcherlobby)（每个主题作为单独的提交）。
- en: Creating a new project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'If you''d like more details and an explanation of these steps, refer to the
    *Creating a new Cardboard project* section of [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多细节并解释这些步骤，请参考[第2章](ch02.html "第2章。骨架硬纸板项目")中的*创建新的硬纸板项目*部分，*骨架硬纸板项目*，并在那里跟随：
- en: With Android Studio opened, create a new project. Let's name it `LauncherLobby`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`LauncherLobby`，并以**Android 4.4 KitKat (API
    19)**为目标，使用**空活动**。
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将硬纸板SDK的`common.aar`和`core.aar`库文件作为新模块添加到您的项目中，使用**文件** | **新建** | **新建模块...**。
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库模块设置为项目应用程序的依赖项，使用**文件** | **项目结构**。
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AndroidManifest.xml`文件，如[第2章](ch02.html "第2章。骨架硬纸板项目")中所述，*骨架硬纸板项目*，要小心保留此项目的`package`名称。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.gradle`文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*，以编译SDK
    22。
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`activity_main.xml`布局文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*。
- en: 'Edit the `MainActivity` Java class so that it extends `CardboardActivity` and
    implements `CardboardView.StereoRenderer`. Modify the class declaration line as
    follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`MainActivity` Java类，使其扩展`CardboardActivity`并实现`CardboardView.StereoRenderer`。修改类声明行如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add the stub method overrides for the interface (using intellisense **Implement
    Methods** or pressing *Ctrl* + *I*).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为接口添加存根方法覆盖（使用智能感知**实现方法**或按下*Ctrl* + *I*）。
- en: 'Lastly, edit `onCreate()` by adding the `CardboadView` instance as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加以下内容来编辑`onCreate()`中的`CardboadView`实例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding Hello Virtual World text overlay
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Hello Virtual World文本覆盖
- en: 'For starters, we''re just going to put some text on the screen that you might
    use for a toast message to the user, or a **heads-up display** (**HUD**) with
    informative content. We''re going to implement this incrementally in small steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只是在屏幕上放一些文本，您可能会用它作为对用户的提示消息，或者用它来显示有信息内容的**抬头显示**（**HUD**）。我们将逐步以小步骤实现这个：
- en: Create a simple overlay view with some text.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有一些文本的简单覆盖视图。
- en: Center it on the screen.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其居中显示在屏幕上。
- en: Add parallax for stereoscopic viewing.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为立体观看添加视差。
- en: A simple text overlay
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的文本覆盖
- en: First, we'll add some overlay text in a simple way, not stereoscopically, just
    text on the screen. This will be our initial implementation of the `OverlayView`
    class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以简单的方式添加一些覆盖文本，而不是立体地显示在屏幕上。这将是我们对`OverlayView`类的初始实现。
- en: 'Open the `activity_main.xml` file, and add the following lines to add an `OverlayView`
    to your layout:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，并添加以下行以将`OverlayView`添加到您的布局中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we reference the `OverlayView` class with just `.OverlayView`. You
    may do this if your view class is in the same package as your `MainActivity` class.
    We did the same earlier for `.MainActivity`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只用`.OverlayView`引用了`OverlayView`类。如果您的视图类与`MainActivity`类在同一个包中，您可以这样做。我们之前对`.MainActivity`也是这样做的。
- en: Next, we write the Java class. Right-click on the `app/java` folder (`app/src/main/java/com.cardbookvr.launcherlobby/`),
    and navigate to **New** | **Java Class**. Name it `OverlayView`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写Java类。右键单击`app/java`文件夹（`app/src/main/java/com.cardbookvr.launcherlobby/`），然后导航到**新建**
    | **Java类**。命名为`OverlayView`。
- en: 'Define the class so that it extends `LinearLayout`, and add a constructor method,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类，使其扩展`LinearLayout`，并添加一个构造方法，如下：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `OverlayView()` constructor method creates a new `TextView` instance with
    a pleasant greenish color and the text **Hello Virtual World!**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverlayView()`构造方法创建了一个新的`TextView`实例，颜色是宜人的绿色，文本是**Hello Virtual World!**。'
- en: 'Run the app, and you will notice our text in the top-left corner of the screen,
    as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您会注意到我们的文本显示在屏幕左上角，如下面的屏幕截图所示：
- en: '![A simple text overlay](img/B05144_04_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的文本覆盖](img/B05144_04_01.jpg)'
- en: Center the text using a child view
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子视图将文本居中
- en: Next, we create a separate view group and use it to control the text object.
    Specifically, to center it in the view.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个单独的视图组，并使用它来控制文本对象。具体来说，是将其居中在视图中。
- en: 'In the `OverlayView` constructor, replace the `TextView` with an instance of
    a different `ViewGroup` helper class that we''re going to write called `EyeView`.
    Presently, it''s monoscopic but soon we''ll use this class to create two views:
    one for each eye:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OverlayView`构造函数中，用一个名为`EyeView`的不同`ViewGroup`助手类的实例替换`TextView`。目前，它是单眼的，但很快我们将使用这个类来创建两个视图：每个眼睛一个：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We create a new instance of `OverlayEye` named eye, set its color, and add the
    text string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为eye的`OverlayEye`的新实例，设置了它的颜色，并添加了文本字符串。
- en: When using a `ViewGroup` class, you need to specify `LayoutParams` to tell the
    parent how to lay out the view, which we want to be full screen size with no margins
    (refer to [http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html](http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ViewGroup`类时，您需要指定`LayoutParams`来告诉父级如何布局视图，我们希望它是全屏大小且没有边距（参考[http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html](http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html)）。
- en: 'In the same `OverlayView.java` file, we''re going to add the private class
    named `OverlayEye`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`OverlayView.java`文件中，我们将添加名为`OverlayEye`的私有类，如下：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have separated the `TextView` creation from the `OverlayEye` constructor.
    The reason for this will soon become clear.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`TextView`的创建与`OverlayEye`的构造函数分开。这样做的原因很快就会变得清楚。
- en: The `OverlayEye` constructor registers the context and attributes needed to
    add new content views to the group.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverlayEye`构造函数注册了添加新内容视图所需的上下文和属性。'
- en: Then, `addContent` creates the `TextView` instance and adds it to the layout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`addContent`创建`TextView`实例并将其添加到布局中。
- en: 'Now we define `onLayout` for `OverlayEye`, which sets the margins of textview,
    specifically the top margin, as a mechanism to force the text to be vertically
    centered:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`OverlayEye`定义`onLayout`，它设置了textview的边距，特别是顶部边距，作为强制文本垂直居中的机制：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To center the text vertically, we push it down from the top of the screen using
    a top margin. The text will be positioned vertically just below the center of
    the screen, as specified by `verticalTextPos`, a percentage value where 1.0 is
    the full height of the screen. We picked a value of 0.52 to push the top of the
    text down to an extra 2% just below the middle of the screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文本垂直居中，我们使用顶部边距将其从屏幕顶部向下推。文本将垂直定位在屏幕中心的下方，由`verticalTextPos`指定，这是一个百分比值，其中1.0是屏幕的全高。我们选择了一个值0.52，将文本的顶部向下推到额外的2%，刚好在屏幕中间的下方。
- en: 'Run the app, and you will notice that our text is now centered on the screen:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您会注意到我们的文本现在居中显示在屏幕上：
- en: '![Center the text using a child view](img/B05144_04_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用子视图居中文本](img/B05144_04_02.jpg)'
- en: Create stereoscopic views for each eye
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每只眼睛创建立体视图
- en: Now, we get real. Virtually, that is. For VR, we need stereoscopic left and
    right eye views. Fortunately, we have this handy `OverlayEye` class that we can
    reuse for each eye.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们变得真实。虚拟地，也就是说。对于VR，我们需要立体左右眼视图。幸运的是，我们有这个方便的`OverlayEye`类，我们可以为每只眼睛重复使用。
- en: Your eyes are separated by a measurable distance, which is referred to as your
    **interpupillary distance** (**IPD**). When you view a stereoscopic image in a
    Cardboard headset, there are separate views for each eye, offset (horizontally)
    by a corresponding distance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的眼睛之间有一个可测量的距离，称为**瞳距**（**IPD**）。当您在Cardboard头盔中观看立体图像时，每只眼睛有单独的视图，它们之间有一个对应的偏移距离（水平）。
- en: Let's assume that our text is on a plane perpendicular to the view direction.
    That is, we're looking straight at the text plane. Given a numeric value corresponding
    to the distance of the text from your eyes, we can shift the views for the left
    and right eyes horizontally by a fixed number of pixels to create the parallax
    effect. We'll call this the `depthOffset` value. A larger depth offset will cause
    the text to appear closer; a smaller depth offset will cause the text to appear
    further away. A depth offset of zero will indicate no parallax, as if the text
    is very far away (greater than 20 feet).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的文本位于垂直于视线方向的平面上。也就是说，我们直视文本平面。给定一个与文本距离您的眼睛的距离对应的数值，我们可以通过固定数量的像素水平移动左右眼的视图来创建视差效果。我们将称之为`depthOffset`值。较大的深度偏移将使文本看起来更近；较小的深度偏移将使文本看起来更远。深度偏移为零将表示没有视差，就好像文本离得很远（大于20英尺）一样。
- en: For our application, we're going to choose a depth offset factor of 0.01, or
    1% measured in screen coordinates (a fraction of screen size). The icons will
    appear to be about 2 meters away (6 feet), which is a comfortable distance for
    VR, although this value is an ad hoc approximation. Using percentages of screen
    size instead of actual pixel amounts, we can ensure that our application will
    adapt to any screen/device size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将选择一个深度偏移因子为0.01，或者以屏幕坐标（屏幕尺寸的一部分）测量的1%。图标将看起来大约离我们2米远（6英尺），这是VR中的一个舒适距离，尽管这个值是一个临时近似值。使用屏幕尺寸的百分比而不是实际像素数量，我们可以确保我们的应用程序将适应任何屏幕/设备尺寸。
- en: Let's implement this now.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现这个。
- en: 'To begin, declare variables for the `leftEye` and `rightEye` values at the
    top of the `OverlayView` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`OverlayView`类的顶部声明`leftEye`和`rightEye`值的变量：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Initialize them in the `OverlayView` constructor method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OverlayView`的构造方法中初始化它们：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the six lines in the middle where we define `leftView` and `rightView`
    and call `addView` for them. The `setDepthFactor` call will set that value in
    the views.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意中间的六行，我们在那里定义了`leftView`和`rightView`，并为它们调用了`addView`。`setDepthFactor`调用将在视图中设置该值。
- en: 'Add the setter methods for the depth, color, and text content:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加深度、颜色和文本内容的setter方法：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Important: notice that for the `rightEye` value we use a negative of the offset
    value. To create the parallax effect, it needs to be shifted to the opposite direction
    of the left eye view. We can still achieve parallax by only shifting one eye,
    but then all of the content will appear to be slightly off center.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：请注意，对于`rightEye`值，我们使用偏移值的负值。为了创建视差效果，它需要向左眼视图的相反方向移动。我们仍然可以通过只移动一个眼睛来实现视差，但是那样所有的内容看起来都会稍微偏离中心。
- en: 'The `OverlayEye` class needs the depth factor setter, which we convert to pixels
    as `depthOffset`. Also, declare a variable for the physical view width (in pixels):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverlayEye`类需要深度因子setter，我们将其转换为像素作为`depthOffset`。此外，声明物理视图宽度的变量（以像素为单位）：'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `onLayout`, set the view width in pixels after it''s been calculated:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onLayout`中，设置视图宽度（以像素为单位）在计算后：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the setter method, which converts the depth factor to a pixel offset:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 定义将深度因子转换为像素偏移的setter方法：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, when we create `textView` in `addContent`, we can shift it by the `depthOffset`
    value in pixels:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在`addContent`中创建`textView`时，我们可以按`depthOffset`值以像素为单位移动它：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run the app, your screen will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您的屏幕将如下所示：
- en: '![Create stereoscopic views for each eye](img/B05144_04_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![为每只眼睛创建立体视图](img/B05144_04_03.jpg)'
- en: The text is now in stereo views, although it's "stuck to your face" as it doesn't
    move when your head moves. It's attached to a visor or HUD.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文本现在是立体视图，尽管它“贴在您的脸上”，因为当您的头部移动时它不会移动。它附在面罩或HUD上。
- en: Controlling the overlay view from MainActivity
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从MainActivity控制覆盖视图
- en: The next step is to remove some of the hardcoded properties and control them
    from the `MainActivity` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是删除一些硬编码的属性，并从`MainActivity`类中控制它们。
- en: 'In `MainActivity.java`, add an `overlayView` variable at the top of the class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`中，在类的顶部添加一个`overlayView`变量：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize its value in `onCreate`. We''ll display the text using the `addContent()`
    method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中初始化其值。我们将使用`addContent()`方法显示文本：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don''t forget to remove the call to `addContent` from the `OverlayView` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从`OverlayView`方法中删除对`addContent`的调用：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the app one more time. It should look the same as shown earlier.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序。它应该看起来和之前一样。
- en: 'You can use code like this to create a 3D toast, such as a text notification
    message. Or, it can be used to construct a HUD panel to share in-game status or
    report the current device attributes. For example, to show the current screen
    parameters you can put them into `MainActivity`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这样的代码来创建一个3D提示，比如文本通知消息。或者，它可以用来构建一个HUD面板，以分享游戏状态或报告当前设备属性。例如，要显示当前的屏幕参数，您可以将它们放入`MainActivity`中：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will show the phone's physical width and height in pixels.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示手机的物理宽度和高度（以像素为单位）。
- en: Using a virtual screen
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟屏幕
- en: In virtual reality, the space you are looking into is bigger than what is on
    the screen at a given time. The screen is like a viewport into the virtual space.
    In this project, we're not calculating 3D views and clipping planes, and we're
    constraining the head motion to left/right yaw rotation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟现实中，您所看到的空间比屏幕上的空间要大。屏幕就像是虚拟空间的视口。在这个项目中，我们不计算3D视图和裁剪平面，我们将头部运动限制在左/右偏航旋转。
- en: You can think of the visible space as the inside surface of a cylinder, with
    your head at the center. As you rotate your head, a portion of the unraveled cylinder
    is displayed on the screen.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将可见空间看作是圆柱体内表面，您的头位于中心。当您旋转头部时，屏幕上会显示一部分展开的圆柱体。
- en: '![Using a virtual screen](img/B05144_04_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚拟屏幕](img/B05144_04_04.jpg)'
- en: The height of the virtual screen in pixels is the same as the physical device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟屏幕的像素高度与物理设备相同。
- en: We need to calculate the virtual width. One way to do this, for example, would
    be to figure out the number of pixels in one degree of head rotation. Then, the
    width of a full rotation would be *pixels per degree * 360*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算虚拟宽度。例如，一种方法是计算一度头部旋转的像素数。然后，完整旋转的宽度将是*每度像素* 360*。
- en: 'We can easily find the physical width of the display in pixels. In fact, we
    already found it in `onLayout` as the `viewWidth` variable. Alternatively, it
    can be retrieved from the Cardboard SDK call:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松找到显示屏的物理宽度（以像素为单位）。实际上，在`onLayout`中已经找到了它，作为`viewWidth`变量。或者，可以从Cardboard
    SDK调用中检索：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From the SDK, we can also get the **field of view** (**FOV**) angle of the
    Cardboard headset (in degrees). This value will vary from one device to the next
    and is part of the Cardboard device configuration parameters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从SDK中，我们还可以获取Cardboard头盔的**视野**（**FOV**）角度（以度为单位）。这个值会因设备而异，并且是Cardboard设备配置参数的一部分：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Given this, we can calculate the number of pixels per degree and the total width
    in pixels of the virtual screen. For example, on my Nexus 4, the device width
    (landscape mode) is 1,280, and using a Homido viewer, the FOV is 40.0 degrees.
    Thus, the split screen view is 640 pixels, giving us 16.0 pixels per degree and
    a virtual screen width of 5,760 pixels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以计算每度的像素数以及虚拟屏幕的总宽度。例如，在我的Nexus 4上，设备宽度（横向模式）为1,280，使用Homido观看器，FOV为40.0度。因此，分屏视图为640像素，给我们提供了16.0像素每度和虚拟屏幕宽度为5,760像素。
- en: While we're at it, we can also calculate and remember the `pixelsPerRadian`
    value, which will be useful to determine the head offset based on the current
    user's `HeadTransform` (given in radians).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们还可以计算并记住`pixelsPerRadian`值，这将有助于根据当前用户的`HeadTransform`（以弧度给出）确定头部偏移。
- en: 'Let''s add it. At the top of the `OverlayView` class, add these variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加它。在`OverlayView`类的顶部，添加这些变量：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add the following method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下方法：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `onCreate` method of `MainActivity`, add the following call:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`onCreate`方法中，添加以下调用：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the FOV value reported from the device parameters is a rough approximation
    defined by the headset manufacturer, and, in some devices, may be overestimated
    and padded. The actual FOV can be retrieved from the eye object passed to `onDrawEye()`,
    since that represents the actual frustum that should be rendered. Once the project
    is working, you might consider making this change to your own code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从设备参数中报告的FOV值是由头盔制造商定义的粗略近似值，并且在某些设备上可能被高估和填充。实际的FOV可以从传递给`onDrawEye()`的眼睛对象中检索，因为那代表应该被渲染的实际视锥体。一旦项目运行起来，您可能会考虑对自己的代码进行这种更改。
- en: Now, we can use these values to respond to the user's head look rotation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些值来响应用户的头部旋转。
- en: Responding to head look
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应头部观察
- en: Let's make the text move with our head, so it doesn't appear to be stuck to
    your face! As you look left or right, we'll move the text in the opposite direction,
    so it appears to be stationary in space.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让文本随着我们的头部移动，这样它就不会看起来贴在您的脸上！当您向左或向右看时，我们将将文本向相反方向移动，这样它看起来在空间中是静止的。
- en: To do this, we'll start in `MainActivity`. In the `onNewFrame` method, we'll
    determine the horizontal head rotation angle and pass that to the `overlayView`
    object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将从`MainActivity`开始。在`onNewFrame`方法中，我们将确定水平头部旋转角度并将其传递给`overlayView`对象。
- en: 'In `MainActivity`, define `onNewFrame`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，定义`onNewFrame`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `onNewFrame` method receives the current `HeadTransform` instance as an
    argument, which is an object that provides the current head pose.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNewFrame`方法接收当前的`HeadTransform`实例作为参数，这是一个提供当前头部姿势的对象。'
- en: 'There are various ways to mathematically represent the head pose, such as a
    forward XYZ direction vector, or a combination of angles. The `getEulerAngles`
    method gets the pose as three angles called **Euler angles** (pronounced *oiler*),
    about the three axes for pitch, yaw, and roll:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种数学表示头部姿势的方式，例如前向XYZ方向矢量，或者角度的组合。`getEulerAngles`方法将姿势获取为称为**欧拉角**（发音为*欧拉*）的三个角度，分别是俯仰、偏航和滚转：
- en: '**Pitch** turns your head as if nodding "yes"'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pitch**将您的头部转动，就像点头“是”'
- en: '**Yaw** turns your head to the left/right (as if shaking "no")'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yaw**将您的头向左/向右转动（就像摇头“不”一样）'
- en: '**Roll** turns your head from ear to shoulders ("Do a barrel roll!")'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Roll**将您的头部从耳朵转到肩膀（“做一个滚动！”）'
- en: These axes correspond to the *X*, *Y*, and *Z* coordinate axes, respectively.
    We're going to constrain this experience to yaw, as you look left or right to
    select from a row of menu items. Therefore, we send just the second Euler angle,
    `angles[1]`, to the `overlayView` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些轴对应于*X*、*Y*和*Z*坐标轴。我们将限制这种体验到偏航，当您向左或向右选择菜单项时。因此，我们只发送第二个欧拉角`angles[1]`到`overlayView`类。
- en: Note the use of `runOnUiThread`, which ensures that the `overlayView` update
    is run on the UI thread. Otherwise, we'll cause all sorts of exceptions and break
    the UI (you can refer to [http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)](http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable))).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`runOnUiThread`，这确保了`overlayView`更新在UI线程上运行。否则，我们会引发各种异常并破坏UI（你可以参考[http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)](http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable))）。
- en: 'So, back in `OverlayView`, add a variable to `headOffset` and a method to set
    it, `setHeadYaw`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`OverlayView`中，添加一个`headOffset`变量和一个设置它的方法`setHeadYaw`：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The idea here is to convert the head rotation into a positional offset for the
    text object on the screen. When your head turns to the left, move the objects
    to the right. When your head turns to the right, move the objects to the left.
    Thus, the objects scroll on the screen as you turn your head.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是将头部旋转转换为屏幕上文本对象的位置偏移。当你的头部向左转时，将对象移动到右边。当你的头部向右转时，将对象移动到左边。因此，当你转动头部时，对象在屏幕上滚动。
- en: The yaw angle (rotation about the vertical *Y* axis) that we get from the Cardboard
    SDK is in radians. We calculate the number of pixels to offset the view, in the
    opposite direction from the head. Thus, we take the angle and multiply that by
    `pixelsPerRadian`. Why don't we negate the angle? It just turns out that the clockwise
    rotation is registered as a negative rotation in the *Y* axis. Go figure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Cardboard SDK获取的偏航角（围绕垂直*Y*轴的旋转）是以弧度表示的。我们计算要偏移视图的像素数，与头部相反的方向。因此，我们将角度乘以`pixelsPerRadian`。为什么我们不取反角度？事实证明，顺时针旋转在*Y*轴上被注册为负旋转。想想看。
- en: 'Lastly, in `OverlayEye`, define the `setHeadOffset` method to change the X
    position of the view objects. Make sure that you include the `depthOffset` variable
    as well:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`OverlayEye`中，定义`setHeadOffset`方法来改变视图对象的X位置。确保也包括`depthOffset`变量：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the app. When you move your head, the text should scroll in the opposite
    direction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。当你移动头部时，文本应该向相反方向滚动。
- en: Adding an icon to the view
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向视图添加图标
- en: Next, we'll add an icon image to the view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向视图添加一个图标图像。
- en: For now, let's just use a generic icon, such as `android_robot.png`. A copy
    of this can be found on the Internet, and there's a copy included with the files
    for this chapter. Paste the `android_robot.png` file into your project's `app/res/drawable/`
    folder. Don't worry, we'll be using the actual app icons later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只使用一个通用图标，比如`android_robot.png`。这个文件的副本可以在互联网上找到，本章的文件中也包含了一个副本。将`android_robot.png`文件粘贴到项目的`app/res/drawable/`文件夹中。别担心，我们以后会使用实际的应用程序图标。
- en: We want to display both the text and an icon together, so we can add the code
    in order to add the image views to the `addContent` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要同时显示文本和图标，所以我们可以添加代码来将图像视图添加到`addContent`方法中。
- en: 'In the `onCreate` method of `MainActivity`, modify the `addContent` call to
    pass the icon as a second parameter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`onCreate`方法中，修改`addContent`调用，将图标作为第二个参数传递：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `addContent` of `OverlayView`, add the icon parameter and pass it to the
    `OverlayEye` views:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OverlayView`的`addContent`中，添加图标参数并将其传递给`OverlayEye`视图：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now for the `OverlayEye` class. At the top of `OverlayEye`, add a variable
    to the `ImageView` instance:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`OverlayEye`类的时间。在`OverlayEye`的顶部，添加一个变量到`ImageView`实例：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modify `addContent` of `OverlayEye` in order to also take a `Drawable` icon
    and create the `ImageView` instance for it. The modified method now looks like
    this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`OverlayEye`的`addContent`，以便还接受一个`Drawable`图标并为其创建`ImageView`实例。修改后的方法现在如下所示：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `imageView.setScaleType.CENTER_INSIDE` tells the view to scale the image
    from its center. Setting `setAdjustViewBounds` to `true` tells the view to preserve
    the image's aspect ratio.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`imageView.setScaleType.CENTER_INSIDE`告诉视图从中心缩放图像。将`setAdjustViewBounds`设置为`true`告诉视图保持图像的纵横比。
- en: 'Set the layout parameters of `ImageView` in the `onLayout` method of `OverlayEye`.
    Add the following code to the bottom of the `onLayout` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OverlayEye`的`onLayout`方法中设置`ImageView`的布局参数。在`onLayout`方法的底部添加以下代码：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the image is drawn, it will fit within the top and bottom margins, scaled
    automatically. In other words, given a desired image size (such as 10% of the
    screen height, or 0.1f), the image margin factor is *(1 - size)/2*, multiplied
    by the pixel height of the screen to get the margin in pixels. We also add a small
    vertical offset (negative, to move it up) for spacing between the icon and the
    text below it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像被绘制时，它将自动缩放以适应顶部和底部边距。换句话说，给定一个期望的图像大小（例如屏幕高度的10%，或0.1f），图像边距因子为*(1-size)/2*，乘以屏幕的像素高度以获得像素边距。我们还添加了一个小的垂直偏移（负值，向上移动），以便在图标和下面的文本之间留出间距。
- en: 'Finally, add the `imageView` offset to the `setHeadOffset` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`imageView`偏移添加到`setHeadOffset`方法中：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the app. Your screen will look like this. When you move your head, both
    the icon and text will scroll.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。你的屏幕会是这样的。当你移动头部时，图标和文本都会滚动。
- en: '![Adding an icon to the view](img/B05144_04_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![向视图添加图标](img/B05144_04_05.jpg)'
- en: Listing installed Cardboard apps
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出已安装的Cardboard应用程序
- en: If you haven't forgotten, the purpose of this LauncherLobby app is to show a
    list of Cardboard apps on the device and let the user pick one to launch it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有忘记，这个LauncherLobby应用程序的目的是在设备上显示Cardboard应用程序的列表，并让用户选择一个来启动它。
- en: If you like what we've built so far, you may want to save a copy for future
    reference. The changes we're going to make next will significantly modify the
    code to support a list of views as shortcuts to your apps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢我们迄今为止构建的内容，你可能想要保存一份备份以供将来参考。我们接下来要做的更改将显著修改代码，以支持应用程序快捷方式的视图列表。
- en: We're going to replace the `addContent` method with `addShortcut` and the `imageView`
    and `textView` variables with a list of shortcuts. Each shortcut consists of an
    `ImageView` and a `TextView` to display the shortcut, as well as an `ActivityInfo`
    object for the purpose of launching the app. The shortcut images and text will
    appear on top of each other, as shown earlier, and will be arranged horizontally
    in a line, a fixed distance apart.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用`addShortcut`方法替换`addContent`方法，并用快捷方式的列表替换`imageView`和`textView`变量。每个快捷方式包括一个`ImageView`和一个`TextView`来显示快捷方式，以及一个`ActivityInfo`对象，用于启动应用程序。快捷方式的图像和文本将像之前显示的那样重叠显示，并且将水平排列在一条线上，相隔固定距离。
- en: Queries for Cardboard apps
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询Cardboard应用程序
- en: 'First, let''s get the list of Cardboard apps installed on the device. At the
    end of the `onCreate` method of `MainActivity`, add a call to a new method, `getAppList`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取设备上安装的Cardboard应用程序的列表。在`MainActivity`的`onCreate`方法的末尾，添加一个调用一个新方法`getAppList`：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, define this method in `MainActivity`, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`MainActivity`中定义此方法，如下所示：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run it, and review the `logcat` window in Android Studio. The code gets the
    list of Cardboard apps on the current device (`pkgAppsList`) and prints their
    label (`name`) to the debug console.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，并在Android Studio的`logcat`窗口中查看。代码获取当前设备上的Cardboard应用程序列表（`pkgAppsList`）并将它们的标签（`name`）打印到调试控制台。
- en: Cardboard apps are identified by having the `CARDBOARD` intent category, so
    we filter by that. The call to `addFlags` and specifying the flag in `queryIntentActivities`
    are important, because otherwise we won't get the list of intent filters and note
    of the apps will match the `CARDBOARD` category. Also, note that we're using the
    `Activity` class's `getPackageManager()` function. If you need to put this method
    in another class, it will need a reference to the activity. We will be using intents
    again later on in this book. For more information on the package manager and Intents,
    refer to [http://developer.android.com/reference/android/content/pm/PackageManager.html](http://developer.android.com/reference/android/content/pm/PackageManager.html)
    and [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Cardboard应用程序通过具有`CARDBOARD`意图类别来识别，因此我们通过该类别进行过滤。调用`addFlags`并在`queryIntentActivities`中指定标志是重要的，否则我们将无法获取意图过滤器的列表，也无法匹配`CARDBOARD`类别的应用程序。还要注意，我们正在使用`Activity`类的`getPackageManager()`函数。如果您需要将此方法放在另一个类中，它将需要对活动的引用。我们将在本书的后面再次使用意图。有关包管理器和意图的更多信息，请参阅[http://developer.android.com/reference/android/content/pm/PackageManager.html](http://developer.android.com/reference/android/content/pm/PackageManager.html)和[http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html)。
- en: Create the Shortcut class for apps
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为应用程序创建快捷方式类
- en: Next, we'll define a `Shortcut` class that holds the details we require of each
    Cardboard app in a convenient object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个`Shortcut`类，其中包含我们需要的每个Cardboard应用程序的详细信息。
- en: 'Create a new Java class named `Shortcut`. Define it as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Shortcut`的新Java类。定义如下：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `MainActivity`, modify `getAppList()` to build shortcuts from `pkgAppsList`
    and add them to `overlayView`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，修改`getAppList()`以从`pkgAppsList`构建快捷方式并将其添加到`overlayView`：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We need to limit the number of shortcuts that will fit within our view cylinder.
    In this case, I chose 24 as a reasonable number.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要限制适合在我们的视图圆柱体内的快捷方式的数量。在这种情况下，我选择了24作为一个合理的数字。
- en: Add shortcuts to OverlayView
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向OverlayView添加快捷方式
- en: 'Now, we modify `OverlayView` to support a list of shortcuts that will be rendered.
    First, declare a list variable, `shortcuts`, to hold them:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们修改`OverlayView`以支持将要呈现的快捷方式列表。首先，声明一个列表变量`shortcuts`来保存它们：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `addShortcut` method is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`addShortcut`方法如下：'
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, this calls the `addShortcut` method in the `OverlayEye` class.
    This builds a list of `TextView` and `ImageView` instances for the layout.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这调用了`OverlayEye`类中的`addShortcut`方法。这将为布局构建一个`TextView`和`ImageView`实例列表。
- en: 'Note the `maxShortcuts` and `shortcutWidth` variables. `maxShortcuts` defines
    the maximum number of shortcuts we want to fit on the virtual screen, and `shortcutWidth`
    will be the width of each shortcut slot on the screen. Initialize `shortcutWidth`
    in `calcVirtualWidth()`, adding the following line of code at the end of `calcVirtualWidth`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`maxShortcuts`和`shortcutWidth`变量。`maxShortcuts`定义了我们想要在虚拟屏幕上放置的快捷方式的最大数量，`shortcutWidth`将是屏幕上每个快捷方式槽的宽度。在`calcVirtualWidth()`中初始化`shortcutWidth`，在`calcVirtualWidth`的末尾添加以下代码行：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using view lists in OverlayEye
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OverlayEye中使用视图列表
- en: 'At the top of `OverlayEye`, replace the `textView` and `imageView` variables
    with lists:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OverlayEye`的顶部，用列表替换`textView`和`imageView`变量：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we''re ready to write the `addShortcut` method in `OverlayEye`. It looks
    very much like the `addContent` method we''re replacing. It creates `textView`
    and `imageView` (as mentioned earlier) but then stuffs them into a list:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在`OverlayEye`中编写`addShortcut`方法。它看起来非常像我们要替换的`addContent`方法。它创建`textView`和`imageView`（如前所述），然后将它们放入列表中：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting `setAdjustViewBounds` to `true` preserves the image aspect ratio.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将`setAdjustViewBounds`设置为`true`可以保留图像的纵横比。
- en: Delete the obsolete `addContent` method definitions in both the `OverlayView`
    and `OverlayEye` classes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`OverlayView`和`OverlayEye`类中的过时`addContent`方法定义。
- en: 'In `onLayout`, we now iterate over the list of `textViews`, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onLayout`中，我们要迭代`textViews`列表，如下所示：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We also iterate over the list of `imageViews`, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还要迭代`imageViews`列表，如下所示：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Lastly, we also need to iterate over the list in `setHeadOffset`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在`setHeadOffset`中迭代列表：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run the app. You will now see your Cardboard shortcuts neatly arranged in a
    horizontal menu that you can scroll by turning your head.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。现在，您将看到您的Cardboard快捷方式整齐地排列在一个水平菜单中，您可以通过转动头部来滚动。
- en: '![Using view lists in OverlayEye](img/B05144_04_06.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![在OverlayEye中使用视图列表](img/B05144_04_06.jpg)'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some Java programmers out there might point out that the list of shortcuts
    and the list of views in each `OverlayEye` class are redundant. They are, indeed,
    but it turns out to be quite complicated to refactor the draw functionality per-eye
    into the `Shortcut` class. We found that this way was the simplest and easiest
    to understand.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些Java程序员可能会指出，`OverlayEye`类中的快捷方式列表和每个视图的列表是多余的。的确如此，但事实证明，将每个眼睛的绘制功能重构到`Shortcut`类中是相当复杂的。我们发现这种方式是最简单和最容易理解的。
- en: Highlighting the current shortcut
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示当前的快捷方式
- en: When the user gazes at a shortcut, it should be able to indicate that it is
    selectable. In the next section, we'll wire it up to highlight the selected item
    and to actually launch the corresponding app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户凝视快捷方式时，它应该能够指示它是可选择的。在下一节中，我们将连接它以突出显示所选项目并实际启动相应的应用程序。
- en: The trick here is to determine which slot is in front of the user. To highlight
    it, we'll brighten the text color.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的诀窍是确定哪个插槽在用户面前。为了突出显示它，我们将提亮文本颜色。
- en: 'Let''s write a helper method to determine which slot is currently in the gaze,
    based on the `headOffset` variable (which was calculated from the head yaw angle).
    Add the `getSlot` method to the `OverlayView` class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个辅助方法来确定基于`headOffset`变量（从头部偏航角计算得出）当前在凝视中的插槽。将`getSlot`方法添加到`OverlayView`类中：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: One half of the `shortcutWidth` value is added to the `headOffset` value, so
    we detect gazing at the center of the shortcut. Then, we add the negative of `headOffset`
    since that was originally calculated as the positional offset, which is opposite
    of the view direction. Negative values of `headOffset` actually correspond to
    slot numbers greater than zero.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortcutWidth`值的一半被添加到`headOffset`值，因此我们检测凝视在快捷方式的中心。然后，我们添加`headOffset`的负值，因为它最初被计算为位置偏移，与视图方向相反。`headOffset`的负值实际上对应于大于零的插槽编号。'
- en: '`getSlot` should return a number between 0 and the number of slots in our virtual
    layout; in this case, its 24\. Since it is possible to look to the right and set
    a positive `headOffset` variable, `getSlot` can return negative numbers, so we
    check the boundary conditions.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSlot`应该返回0到虚拟布局中插槽数量之间的数字；在这种情况下，是24。由于可能向右看并设置正的`headOffset`变量，`getSlot`可能会返回负数，因此我们要检查边界条件。'
- en: 'Now, we can highlight the currently selected slot. We''ll do it by changing
    the text label color. Modify `setHeadOffset` as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以突出显示当前选定的插槽。我们将通过更改文本标签颜色来实现。修改`setHeadOffset`如下：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the app and the item in front of your gaze will become highlighted. Of course,
    there may be other interesting ways to highlight the selected app, but this is
    good enough for now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您凝视的项目将被突出显示。当然，可能还有其他有趣的突出显示所选应用程序的方法，但现在这已经足够了。
- en: Using the trigger to pick and launch the app
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器选择并启动应用程序
- en: The final piece is to detect which shortcut the user is gazing at and respond
    to a trigger (click) by launching the app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是检测用户正在凝视的快捷方式，并响应触发（点击）启动应用程序。
- en: When we launch a new app from this one, we need to reference the `MainActivity`
    object. One way to do it is to make it a singleton object. Let's do that now.
    Note that you can get into trouble defining activities as singletons. Android
    can launch multiple instances of a single `Activity` class, but even across apps,
    static variables are shared.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从这个应用程序启动一个新应用程序时，我们需要引用`MainActivity`对象。一种方法是将其作为单例对象。现在让我们这样做。请注意，将活动定义为单例可能会导致问题。Android可以启动单个`Activity`类的多个实例，但即使跨应用程序，静态变量也是共享的。
- en: 'At the top of the `MainActivity` class, add an `instance` variable:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部添加一个`instance`变量：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initialize it in `onCreate`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中初始化它：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now in `MainActivity`, add a handler to the Cardboard trigger:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MainActivity`中，添加一个处理Cardboard触发器的处理程序：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, in `OverlayView`, add the following method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`OverlayView`中添加以下方法：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We're using `getSlot` to index into our shortcuts list. Because we checked the
    boundary conditions in `getSlot` itself, we don't need to worry about `ArrayIndexOutOfBounds`
    exceptions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getSlot`来索引我们的快捷方式列表。因为我们在`getSlot`本身中检查了边界条件，所以我们不需要担心`ArrayIndexOutOfBounds`异常。
- en: 'Finally, add a `launch()` method to `Shortcut`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Shortcut`中添加一个`launch()`方法：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use the `ActivityInfo` object that we stored in the `Shortcut` class to create
    a new `Intent` instance, and then call `MainActivity.instance.startActivity` with
    it as an argument to launch the app.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在`Shortcut`类中存储的`ActivityInfo`对象来创建一个新的`Intent`实例，然后调用`MainActivity.instance.startActivity`并将其作为参数传递来启动应用程序。
- en: Note that once you've launched a new app, there's no system-wide way to get
    back to LauncherLobby from within VR. The user will have to remove the phone from
    the Cardboard Viewer, and then click on the back button. However, the SDK does
    support `CardboardView.setOnCardboardBackButtonListener` which can be added to
    your Cardboard apps if you want to present a back or exit button.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦您从此应用程序启动新应用程序，就没有系统范围的方法可以从VR内部返回到LauncherLobby。用户将不得不从Cardboard Viewer中取出手机，然后点击返回按钮。但是，SDK确实支持`CardboardView.setOnCardboardBackButtonListener`，如果您想要呈现返回或退出按钮，可以将其添加到您的Cardboard应用程序中。
- en: There you have it! LauncherLobby is ready to rock and roll.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪！LauncherLobby已经可以开始运行了。
- en: Further enhancements
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步增强
- en: 'Some ideas for how to improve and enhance this project include the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 改进和增强此项目的一些想法包括以下内容：
- en: Support more than 24 shortcuts, perhaps adding multiple rows or an infinite
    scrolling mechanic
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持超过24个快捷方式，可能添加多行或无限滚动机制
- en: Reuse images and text view objects; you only ever see a few at a time
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用图像和文本视图对象；您一次只能看到很少的几个
- en: Currently, really long app labels will overlap, tweak your view code to make
    the text wrap, or introduce an ellipsis (...) when the label is too long
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，非常长的应用标签会重叠，调整您的视图代码以使文本换行，或者在标签过长时引入省略号（...）
- en: Add a cylindrical background image (skybox)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个圆柱形背景图像（天空盒）
- en: Alternative ways to highlight the current shortcut, perhaps with a glow, or
    move it closer by adjusting its parallax offset
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他突出当前快捷方式的替代方法，也许可以通过发光来突出显示，或者通过调整其视差偏移将其移近
- en: Add sounds and/or vibrations to enhance the experience and reinforce the selection
    feedback
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加声音和/或振动以增强体验并加强选择反馈。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built the LauncherLobby app, which can be used to launch
    other Cardboard apps on your device. Rather than using 3D graphics and OpenGL,
    we implemented this using Android GUI and a virtual cylindrical screen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了LauncherLobby应用程序，该应用程序可用于在您的设备上启动其他Cardboard应用程序。我们没有使用3D图形和OpenGL，而是使用Android
    GUI和虚拟圆柱屏幕来实现这一点。
- en: 'The first part of the implementation was largely instructional: how to add
    a `TextView` overlay, center it in the view group, and then display it stereoscopically
    with left/right eye parallax views. Then, we determined the size of the virtual
    screen, an unraveled cylinder, based on the current physical device size and the
    current Cardboard device field of view parameters. Objects are scrolled on the
    virtual screen as the user moves his head left and right (yaw rotation). Finally,
    we queried the Android device for installed Cardboard apps, displayed their icons
    and titles in a horizontal menu, and allowed you to pick one to launch by gazing
    at it and clicking on the trigger.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实施的第一部分主要是教学性的：如何添加`TextView`叠加层，将其居中在视图组中，然后用左/右眼视差视图进行立体显示。然后，我们根据当前物理设备尺寸和当前Cardboard设备视场参数确定了虚拟屏幕的大小，即展开的圆柱体。当用户左右移动头部（偏航旋转）时，对象在虚拟屏幕上滚动。最后，我们查询Android设备上安装的Cardboard应用程序，显示它们的图标和标题在水平菜单中，并允许您通过盯着它并点击触发器来选择要启动的应用程序。
- en: In the next chapter, we go back to 3D graphics and OpenGL. This time, we're
    building a software abstraction layer that helps encapsulate much of the lower
    level details and housekeeping. This engine will be reusable for other projects
    in this book as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到3D图形和OpenGL。这一次，我们正在构建一个软件抽象层，帮助封装许多较低级别的细节和日常工作。这个引擎也将在本书的其他项目中被重复使用。
