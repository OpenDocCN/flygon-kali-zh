- en: Playing with Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转函数
- en: In previous chapters, we've seen Kotlin variables, type systems, and control
    structures. But to create applications, we need building blocks that allow us
    to make structures. In Java, the class is the building block of the code. Kotlin,
    on the other hand, supports functional programming; therefore, it makes it possible
    to create whole programs or libraries without any classes. Function is the most
    basic building block in Kotlin. This chapter introduces functions in Kotlin, together
    with different function features and types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经看到了Kotlin变量、类型系统和控制结构。但是要创建应用程序，我们需要允许我们构建结构的构建块。在Java中，类是代码的构建块。另一方面，Kotlin支持函数式编程；因此，它可以创建整个程序或库而不需要任何类。函数是Kotlin中最基本的构建块。本章介绍了Kotlin中的函数，以及不同的函数特性和类型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic function usage in Kotlin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中的基本函数用法
- en: '`Unit` return type'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unit` 返回类型'
- en: The vararg parameter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数
- en: Single-expression functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单表达式函数
- en: Tail-recursive functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾递归函数
- en: Default argument values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数值
- en: Named argument syntax
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数语法
- en: Top-level functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层函数
- en: Local functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部函数
- en: '`Nothing` return type'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nothing` 返回类型'
- en: Basic function declaration and usages
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的基本函数声明和用法
- en: 'The most common first program that programmers write to test some programming
    language is the `Hello, World!` program. It is a full program that is just displaying
    `Hello, World!` text on the console. We are also going to start with this program,
    because in Kotlin it is based on a function and only on a function (no class is
    needed). So the Kotlin `Hello, World!` program looks as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的程序员编写的第一个程序是用来测试某种编程语言的`Hello, World!`程序。它是一个完整的程序，只是在控制台上显示`Hello, World!`文本。我们也将从这个程序开始，因为在Kotlin中，它基于一个函数，只有一个函数（不需要类）。因此，Kotlin的`Hello,
    World!`程序如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A function defines single parameter args, which contains an array of all arguments
    used to run the program (from the command line). It is defined as non-nullable,
    because an empty array is passed to a method when the program is started without
    any arguments.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数定义了单个参数args，其中包含用于运行程序的所有参数的数组（从命令行）。它被定义为非空，因为在没有任何参数的情况下启动程序时，会将空数组传递给方法。
- en: The `println` function is a Kotlin function defined in the Kotlin standard library
    that is equivalent of the Java function `System.out.println` .
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`println`函数是Kotlin标准库中定义的Kotlin函数，相当于Java函数`System.out.println`。'
- en: 'This program tells us a lot about Kotlin. It shows how function looks like
    and that we can define function without any class. First, let''s analyze the structure
    of the function. It starts with the `fun` keyword, and then comes the name of
    the function, parameters in the bracket, and the function body. Here is another
    example of a simple function, but this one is returning a value:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序告诉我们很多关于Kotlin。它展示了函数的外观以及我们可以定义没有任何类的函数。首先，让我们分析函数的结构。它以`fun`关键字开头，然后是函数的名称，括号中的参数，以及函数体。这是另一个简单函数的示例，但这个函数返回一个值：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Good to know frame**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**好知识框架**'
- en: 'There is much confusion around the difference between methods and function.
    Common definitions are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方法和函数之间的区别存在很多混淆。常见的定义如下：
- en: A function is a piece of code that is called by name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是按名称调用的一段代码。
- en: The method is a function associated with an instance of class (object). Sometimes
    it is called member function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与类（对象）实例相关联的函数。有时它被称为成员函数。
- en: So in simpler words, functions inside classes are called **methods** . In Java,
    there are officially only methods, but academic environments are often arguing
    that static Java methods are in fact functions. In Kotlin we can define functions
    that are not associated with any object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单来说，类内部的函数称为**方法**。在Java中，官方只有方法，但学术环境经常争论静态Java方法实际上是函数。在Kotlin中，我们可以定义不与任何对象相关联的函数。
- en: 'Syntax to call a function is the same in Kotlin as in Java, and most modern
    programming languages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的语法在Kotlin中与Java以及大多数现代编程语言中相同：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We call the double function and assign a value returned by it to a variable.
    Let's discuss the details of parameters and return types of Kotlin functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用double函数并将其返回的值赋给一个变量。让我们讨论Kotlin函数的参数和返回类型的细节。
- en: Parameters
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Parameters in Kotlin functions are declared using the Pascal notation, and
    the type of each parameter must be explicitly specified. All parameters are defined
    as a read-only variable. There is no way to make parameters mutable, because such
    behavior is error-prone and in Java it was often abused by the programmers. If
    there is a need for that, then we can explicitly shadow parameters by declaring
    local variables with the same name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin函数中，参数使用Pascal表示法声明，每个参数的类型必须明确指定。所有参数都被定义为只读变量。无法使参数可变，因为这种行为容易出错，在Java中程序员经常滥用。如果有这样的需要，那么我们可以通过声明具有相同名称的局部变量来显式遮蔽参数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is possible, but it is treated as bad practice, so a warning will be displayed.
    A better approach is to name parameters by data they provide and variables by
    the purpose they serve. These names should be then different in most cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，但被视为不良实践，因此会显示警告。更好的方法是根据它们提供的数据来命名参数，根据它们提供的目的来命名变量。在大多数情况下，这些名称应该是不同的。
- en: '**Parameters versus arguments** In the programming community, arguments and
    parameters are often though to be the same thing. These words cannot be used interchangeably
    because they have different meanings. An argument is an actual value that is passed
    to the function when a function is called. Parameter refers to the variables declared
    inside function declaration. Consider the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数与参数** 在编程社区中，参数和参数经常被认为是相同的东西。这些词不能互换使用，因为它们有不同的含义。参数是在调用函数时传递给函数的实际值。参数是指在函数声明内部声明的变量。考虑以下示例：'
- en: '`fun printSum(a1: Int, a2: Int) { // 1.`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`fun printSum(a1: Int, a2: Int) { // 1.`'
- en: '`print(a1 + a2)`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`print(a1 + a2)`'
- en: '`}`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`add(3, 5) // 2.`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(3, 5) // 2.`'
- en: '`1 - a1 and a2 are parameters`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 - a1和a2是参数`'
- en: '`2 - 3 and 5 are arguments`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`2-3和5是参数`'
- en: 'As with Java, functions in Kotlin can contain multiple parameters:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，Kotlin中的函数可以包含多个参数：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Arguments provided to functions can be subtypes of the type specified in parameter
    declaration. As we know, in Kotlin, the supertype of all the non-nullable types
    is `Any` , so we need to use it, if we want to accept all types:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给函数的参数可以是参数声明中指定类型的子类型。正如我们所知，在Kotlin中，所有非空类型的超类型是`Any`，因此如果我们想接受所有类型，就需要使用它：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To allow null on arguments, the type needs to be specified as nullable. Note
    that `Any?` is supertype of all nullable and non-nullable types, so we can pass
    objects of any type as arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许参数为空，类型需要被指定为可空。注意`Any?`是所有可空和非可空类型的超类型，因此我们可以将任何类型的对象作为参数传递：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Returning functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回函数
- en: 'So far, most of the functions were defined like procedures (functions that
    does not return any values). But in fact, there are no procedures in Kotlin and
    all functions return some value. When it is not specified, the default return
    value is the `Unit` instance. We can set it explicitly for demonstration purposes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数函数都被定义为过程（不返回任何值的函数）。但实际上，Kotlin中没有过程，所有函数都返回某个值。当没有指定时，默认返回值是`Unit`实例。我们可以为演示目的显式设置它：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike in Java, we are defining the return type after function name and parameters.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Java不同，我们在Kotlin中定义返回类型在函数名和参数之后。
- en: 'The `Unit` object is the equivalent of Java''s `void` , but it can be treated
    as any other object. So we can store it in variable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`对象相当于Java的`void`，但它可以被视为任何其他对象。因此我们可以将它存储在变量中：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Of course, Kotlin coding conventions claims that when a function is returning
    `Unit` then the type definition **should** be omitted. This way code is more readable
    and simpler to understand:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Kotlin编码约定声称，当函数返回`Unit`时，类型定义**应该**被省略。这样代码更易读，更容易理解：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Good to know frame** Unit is a singleton, what means that there is only one
    instance of it. So all three conditions are true:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**好知识框架** Unit是一个单例，这意味着只有一个实例。因此所有三个条件都为真：'
- en: '`println(p is Unit) // Print: true`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`println(p is Unit) // 输出：true`'
- en: '`println(p == Unit) // Print: true` `println(p === Unit) // Print: true`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`println(p == Unit) // 输出：true` `println(p === Unit) // 输出：true`'
- en: Singleton pattern is highly supported in Kotlin and it will be more thoroughly
    covered in [Chapter 4](text00088.html) , *Classes and objects* .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中高度支持单例模式，并且将在[第4章](text00088.html) *类和对象*中更加详细地介绍。
- en: 'To return output from functions with `Unit` return type, we can simply use
    a return statement without any value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要从返回类型为`Unit`的函数返回输出，我们可以简单地使用一个没有任何值的返回语句：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no return type specified, so return type is implicitly set to Unit.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有指定返回类型，因此返回类型隐式设置为Unit。
- en: We can just use return without any value.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以只使用没有任何值的返回。
- en: When a function returns Unit, then return call is optional. We don't have to
    use it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数返回Unit时，返回调用是可选的。我们不必使用它。
- en: We could also use return `Unit` , but it should not be used because that would
    be misleading and less readable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用返回`Unit`，但不应该使用，因为那样会误导并且不易读。
- en: 'When we specify the return type, other than the `Unit` , then we always need
    to return the value explicitly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定返回类型时，除了`Unit`，我们总是需要显式返回值：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Function will not compile it, because no return value was specified, the if
    condition is not fulfilled.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数不会编译，因为没有指定返回值，if条件未满足。
- en: 'The problem can be fixed by adding a second return statement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可以通过添加第二个返回语句来解决：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Vararg parameter
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vararg参数
- en: 'Sometimes, the number of parameters is not known in advance. In such cases
    we can add a `vararg` modifier to a parameter. It allows the function to accept
    any number of arguments. Here is an example, where the function is printing the
    sum of multiple integers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，参数的数量事先是未知的。在这种情况下，我们可以将`vararg`修饰符添加到参数中。它允许函数接受任意数量的参数。以下是一个示例，其中函数打印多个整数的总和：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Arguments will be accessible inside the method as an array that holds all the
    provided values. The type of the array will correspond to a `vararg` parameter
    type. Normally we would expect it to be a generic array holding a specified type
    (`Array<T>` ), but as we know, Kotlin has an optimized type for array of `Int`
    called `IntArray` , so this type will be used. Here, for example, is the type
    of the `vararg` parameter with the type `String` :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数将作为一个包含所有提供的值的数组在方法内部可访问。数组的类型将对应于`vararg`参数类型。通常我们期望它是一个持有指定类型的通用数组（`Array<T>`），但正如我们所知，Kotlin有一个优化的`Int`数组类型称为`IntArray`，因此将使用这种类型。例如，这是具有类型`String`的`vararg`参数的类型：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that we are still able to specify more parameters before or after the
    `vararg` parameter, as long as it is clear which argument is directed to which
    parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然能够在`vararg`参数之前或之后指定更多的参数，只要清楚哪个参数指向哪个参数即可：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Additionally, arguments provided to `vararg` parameters can be subtypes of
    the specified type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，提供给`vararg`参数的参数可以是指定类型的子类型：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `joinToString` function can be invoked on lists. It is joining elements
    into a single string. On the first argument there is a separator specified.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`joinToString`函数可以在列表上调用。它将元素连接成一个字符串。在第一个参数中指定了分隔符。'
- en: One limitation with `vararg` usage is that there is only one `vararg` parameter
    allowed per function declaration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`vararg`使用的一个限制是每个函数声明只允许一个`vararg`参数。'
- en: 'When we call `vararg` parameters, we can pass argument values one-by-one, but
    we can also pass an array of values. This can be done using the `spread` operator
    (`*` prefixing array), as in the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`vararg`参数时，我们可以逐个传递参数值，但也可以传递一个值数组。这可以使用`spread`操作符（`*`前缀数组）来实现，就像以下示例中的那样：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Single-expression functions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单表达式函数
- en: 'During typical programming, many functions contain only one expression. Here
    is an example of this kind of function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的编程过程中，许多函数只包含一个表达式。以下是这种类型函数的一个例子：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or another one, which can be often found in Android projects, is a pattern
    used in `Activity` , to define methods that are just getting text from some view
    or providing some other data from the view to allow a presenter to get them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者另一个经常在Android项目中找到的例子是在`Activity`中使用的模式，定义仅从某个视图获取文本或从视图提供其他数据以允许Presenter获取它们的方法：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Both functions are defined to return results of a single expression. In the
    first example, it is the result of `x * x` multiplication, and in the second one
    it is the result of the expression `emailView.text.toString()` . These kinds of
    functions are used all around Android projects. Here are some common use cases:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都被定义为返回单个表达式的结果。在第一个例子中，它是`x * x`乘法的结果，在第二个例子中，它是表达式`emailView.text.toString()`的结果。这些类型的函数在整个Android项目中经常被使用。以下是一些常见用例：
- en: Extracting some small operations (like in the preceding `square` function)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取一些小操作（就像前面的`square`函数中）
- en: Using polymorphism to provide values specific to a class
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多态性提供特定于类的值
- en: Functions that are only creating some object
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅创建某个对象的函数
- en: Functions that are passing data between architecture layers (like in the preceding
    example, `Activity` is passing data from the view to the presenter)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在架构层之间传递数据的函数（就像前面的例子中，“Activity”正在从视图传递数据到Presenter）
- en: Functional programming style functions that are based on recurrence
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于递归的函数式编程风格函数
- en: 'Such functions are often used, so Kotlin has a notation for this kind of them.
    When a function returns a single expression, then curly braces and body of the
    function can be omitted. We specify expression directly using the equality character.
    Functions defined this way are called **single-expression** functions. Let''s
    update our `square` function, and define it as a single-expression function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数经常被使用，因此Kotlin为这种函数提供了一种表示法。当函数返回单个表达式时，可以省略大括号和函数体。我们可以直接使用等号字符指定表达式。以这种方式定义的函数称为**单表达式**函数。让我们更新我们的`square`函数，并将其定义为单表达式函数：
- en: '![](img/Image00032.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00032.jpg)'
- en: As we can see, single-expression functions have expression body instead of block
    body. This notation is shorter, but whole body needs to be just a single expression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，单表达式函数具有表达式体而不是块体。这种表示法更短，但整个体必须只是一个单一表达式。
- en: 'In single-expression functions, declaring the return type is optional, because
    it can be inferred by the compiler from the type of expression. This is why we
    can simplify the `square` function, and define it this way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在单表达式函数中，声明返回类型是可选的，因为它可以从表达式的类型中推断出来。这就是为什么我们可以简化`square`函数，并以这种方式定义它：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are many places inside Android applications where we can utilize single
    expression functions. Let''s consider the `RecyclerView` adapter that is providing
    the layout ID and creating `ViewHolder` :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用程序中有许多地方可以利用单表达式函数。让我们考虑一下提供布局ID并创建`ViewHolder`的`RecyclerView`适配器：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following example, we achieve high readability thanks to a single expression
    function. Single expression functions are also very popular in the functional
    world. The example will be described later, in the section about tail-recursive
    functions. Single expression function notation also pairs well with the `when`
    structure. Here is an example of their connection, used to get specific data from
    an object according to a key (use case from big Kotlin project):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，由于单表达式函数，我们实现了高可读性。单表达式函数在函数式世界中也非常受欢迎。稍后将在关于尾递归函数的部分中描述这个例子。单表达式函数表示法也与`when`结构很搭配。以下是它们的连接示例，用于根据键从对象中获取特定数据（来自大型Kotlin项目的用例）：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We don't need a type, because it is inferred from the when expression.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要类型，因为它是从when表达式中推断出来的。
- en: 'Another common Android example is that we can combine when expressions with
    `activity` method `onOptionsItemSelected` that handles top bar menu clicks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的Android示例是我们可以将when表达式与`activity`方法`onOptionsItemSelected`结合使用，处理顶部菜单点击：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another example where the syntax of the single-expression function is useful
    is when we chain multiple operations on a single object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是单表达式函数语法有用的地方，是当我们在单个对象上链式多个操作时：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, single expression functions can make our code more concise and
    improve readability. Single-expression functions are commonly used in Kotlin Android
    projects and they are really popular for functional programming.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，单表达式函数可以使我们的代码更简洁，提高可读性。单表达式函数在Kotlin Android项目中经常被使用，并且在函数式编程中非常受欢迎。
- en: '**Imperative versus declarative programming** **Imperative programming** :
    This programming paradigm describes the exact sequence of steps required to perform
    an operation. It is most intuitive for most programmers.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式与声明式编程** **命令式编程**：这种编程范式描述了执行操作所需的确切步骤序列。对大多数程序员来说，这是最直观的。'
- en: '**Declarative programming** : This programming paradigm describes a desired
    result, but not necessarily steps to achieve it (implementation of behavior).
    This means that programming is done with expressions or declarations instead of
    statements. Both *functional* and *logic* programming are characterized as declarative
    programming style. Declarative programming is often shorter and more readable
    than imperative.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明式编程**：这种编程范式描述了期望的结果，但不一定是实现它的步骤（行为的实现）。这意味着编程是通过表达式或声明而不是语句来完成的。*函数式*和*逻辑*编程都被描述为声明式编程风格。声明式编程通常比命令式编程更简短和可读。'
- en: Tail-recursive functions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归函数
- en: 'Recursive functions are functions that are calling themselves. Let''s see an
    example of recursive function, `getState` :'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是调用自身的函数。让我们看一个递归函数`getState`的例子：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: They are an important part of functional programming style, but the problem
    is that each recursive function call needs to keep the return address of the previous
    function on the stack. When an application recurse too deeply (there are too many
    functions on the stack), `StackOverflowError` is thrown. This limitation presents
    a very serious problem for recurrence usage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是函数式编程风格的重要组成部分，但问题在于每个递归函数调用都需要在堆栈上保留前一个函数的返回地址。当应用程序递归太深时（堆栈上有太多函数），会抛出`StackOverflowError`。这种限制对于递归使用来说是一个非常严重的问题。
- en: 'A classic solution for this problem was to use iteration instead of recurrence,
    but this approach is less expressive:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个经典解决方案是使用迭代而不是递归，但这种方法表达力较弱：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A proper solution for this problem is usage of the *tail-recursive* function
    supported by modern languages such as Kotlin. Tail-recursive function is a special
    kind of recursive function, where the function is calling itself as the last operation
    it performs (in other words: recursion takes place in last operation of a function).
    This allows us to optimize recursive calls by compiler and perform recursive operations
    in a more efficient way without worrying about potential `StackOverflowError`
    . To make a function tail-recursive, we need to mark it with a `tailrec` modifier:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个合适的解决方案是使用现代语言（如Kotlin）支持的*尾递归*函数。尾递归函数是一种特殊类型的递归函数，其中函数调用自身作为其执行的最后一个操作（换句话说：递归发生在函数的最后一个操作中）。这使我们能够通过编译器优化递归调用，并以更有效的方式执行递归操作，而不必担心潜在的`StackOverflowError`。要使函数成为尾递归，我们需要使用`tailrec`修饰符标记它：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To check out how it is working, let''s compile this code and decompile to Java.
    Here is what can be found then (code after simplification):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它是如何工作的，让我们编译这段代码并反编译成Java。然后可以找到以下内容（简化后的代码）：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implementation is based on iteration, so there is no way that stack overflow
    error might happen. To make the `tailrec` modifier work, there are some requirements
    to be met:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实现是基于迭代的，因此不可能发生堆栈溢出错误。为使`tailrec`修饰符起作用，需要满足一些要求：
- en: The function must call itself only as the last operation it performs
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须只调用自身作为其执行的最后一个操作
- en: It cannot be used within `try` /`catch` /`finally` blocks
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能在`try`/`catch`/`finally`块中使用
- en: At the time of writing, it was allowed only in Kotlin compiled to JVM
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本文时，它只允许在编译为JVM的Kotlin中使用
- en: Different ways of calling a function
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的调用函数的方式
- en: 'Sometimes we need to call a function and provide only selected arguments. In
    Java, we could create multiple overloads of the same method, but this solution
    has some limitations. The first problem is that the number of possible permutations
    of a given method is growing very quickly (2^n ), making them very difficult to
    maintain. The second problem is that overloads must be distinguishable from each
    other, so compiler may know which overload to call, so when a method defines a
    few parameters with the same type we can''t define all possible overloads. That''s
    why in Java, we often need to pass multiple null values to a method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要调用一个函数并只提供选定的参数。在Java中，我们可以创建同一个方法的多个重载，但这种解决方案有一些局限性。第一个问题是给定方法的可能排列数量增长得非常快（2^n），使得它们非常难以维护。第二个问题是重载必须彼此可区分，因此编译器可能需要知道调用哪个重载，所以当一个方法定义了几个相同类型的参数时，我们无法定义所有可能的重载。这就是为什么在Java中，我们经常需要向方法传递多个空值：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Multiple null parameters provide boilerplate. Such a situation greatly decreases
    method readability. In Kotlin, there is no such problem, because Kotlin has a
    feature called *default arguments* and *named argument syntax* .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多个空参数提供样板。这种情况大大降低了方法的可读性。在Kotlin中，没有这样的问题，因为Kotlin有一个称为*默认参数*和*命名参数语法*的特性。
- en: Default arguments values
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'Default arguments are mostly known from C++, which is one of the oldest languages
    supporting it. A default argument provides a value for a parameter in case it
    is not provided during method call. Each function parameter can have a default
    value. It might be any value that is matching a specified type including null.
    This way we can simply define functions that can be called in multiple ways. This
    is an example of a function with default values:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数大多来自于C++，这是支持默认参数的最古老的语言之一。默认参数在方法调用时为参数提供一个值。每个函数参数都可以有一个默认值。它可以是与指定类型匹配的任何值，包括null。这样我们可以简单地定义可以以多种方式调用的函数。这是一个带有默认值的函数的示例：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use this function the same way as a normal function (a function without
    default argument values) by providing values for each parameter (all arguments):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像调用普通函数一样使用这个函数（没有默认参数值的函数），为每个参数提供值（所有参数）：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Thanks to the default argument values, we can call a function by providing
    arguments only for parameters without default values:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认参数值，我们可以只为没有默认值的参数提供参数来调用函数：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also provide all parameters without default values, and only some that
    have a default value:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以提供所有没有默认值的参数，只提供一些具有默认值的参数：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Named arguments syntax
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数语法
- en: 'Sometimes we want only to pass a value for the last argument. Let''s suppose
    that we define want to value for a suffix, but not for a prefix and `inBracket`
    (which is defined before suffix). Normally we would have to provide values for
    all previous parameters including the default parameter values:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们只想为最后一个参数传递一个值。假设我们只想为后缀定义一个值，而不是为前缀和`inBracket`（在后缀之前定义）定义一个值。通常情况下，我们必须为所有先前的参数提供值，包括默认参数值：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By using named argument syntax, we can pass specific arguments using the argument
    name:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命名参数语法，我们可以使用参数名称传递特定的参数：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This allows very flexible syntax, where we can supply only chosen arguments
    when calling a function (that is, the first one and the second from the end).
    It is often used to specify what this argument is because such a call is more
    readable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许非常灵活的语法，我们可以在调用函数时只提供选择的参数（即，从末尾开始的第一个参数和第二个参数）。这经常用于指定这个参数是什么，因为这样的调用更易读：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can set any parameters we want using named parameter syntax in any order
    as long as all parameters without default values are provided. The order of the
    arguments is relevant:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命名参数语法设置任何我们想要的参数，以任何顺序，只要提供所有没有默认值的参数。参数的顺序是相关的：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Order of arguments is different, but both preceding calls are equivalent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的顺序不同，但前面两个调用是等价的。
- en: 'We can also use *named argument syntax* together with *classic call* . The
    only restriction is if we start using named syntax, we cannot use a classic one
    for next arguments we are serving:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将*命名参数语法*与*经典调用*一起使用。唯一的限制是，如果我们开始使用命名语法，我们就不能为接下来的参数使用经典语法：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This feature allows us to call methods in a very flexible way without the need
    to define multiple method overloads.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性允许我们以非常灵活的方式调用方法，而无需定义多个方法重载。
- en: The named argument syntax imposes some extra responsibility for Kotlin programmers.
    We need to keep in mind that when we change a parameter name, we may cause errors
    in the project, because the parameter name may be used in other classes. Android
    Studio will take care of it if we rename the parameter using built-in refactoring
    tools, but this will work only inside our project. The Kotlin library creators
    should be very careful while using named argument syntax. Change of the parameter
    name will break the API. Note that the named argument syntax cannot be used when
    calling Java functions, because Java bytecode does not always preserve names of
    function parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数语法对Kotlin程序员施加了一些额外的责任。我们需要记住，当我们更改参数名称时，可能会在项目中引起错误，因为参数名称可能在其他类中使用。如果我们使用内置的重构工具重命名参数，Android
    Studio会处理它，但这只在我们的项目内有效。Kotlin库的创建者在使用命名参数语法时应该非常小心。更改参数名称将破坏API。请注意，当调用Java函数时，无法使用命名参数语法，因为Java字节码并不总是保留函数参数的名称。
- en: Top-level functions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶层函数
- en: 'Another thing we can observe in a simple `Hello, World!` program, is that the
    `main` function is not located inside any class. In [Chapter 2](text00035.html)
    , *Laying a Foundation* , we already mentioned that Kotlin can define various
    entities at the top level. A function that is defined at top-level is called the
    **top-level function** . Here is an example of one of them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在一个简单的`Hello, World!`程序中观察到的另一件事是，`main`函数不位于任何类中。在[第2章](text00035.html)，*打下基础*中，我们已经提到Kotlin可以在顶层定义各种实体。在顶层定义的函数称为**顶层函数**。以下是其中一个例子：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Top-level functions can be used all around the code (assuming that they are
    public, what is default visibility modifier). We can call them in the same way
    as functions from the local context. To access top-level function, we need to
    explicitly import it into a file by using the import statement. Functions are
    available in code hint list in Android Studio, so imports are automatically added
    when a function is selected (used). As an example, let''s see a top-level function
    defined in `Test.kt` and use it inside the `Main.kt` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层函数可以在代码中的任何地方使用（假设它们是公共的，默认可见性修饰符）。我们可以像从本地上下文中的函数一样调用它们。要访问顶层函数，我们需要使用import语句将其显式导入文件中。在Android
    Studio中，函数在代码提示列表中可用，因此在选择（使用）函数时会自动添加导入。例如，让我们看一个在`Test.kt`中定义的顶层函数，并在`Main.kt`文件中使用它：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Top-level functions are often useful, but it is important to use them wisely.
    Keep in mind that defining public top-level functions will increase the number
    of functions available in code *hint list* (by *hint list* I mean a list of methods
    suggested by the IDE as hints, when we are writing code). It is because public
    top-level functions are suggested by the IDE in every context (because they can
    be used everywhere). If the name of the top-level function does not clearly state
    that this is a top-level function, then it may be confused with a method from
    the local context and used accidentally. Here are some good examples of top-level
    functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层函数通常很有用，但明智地使用它们很重要。请记住，定义公共顶层函数将增加代码*提示列表*中可用函数的数量（*提示列表*是指在编写代码时IDE建议的方法列表）。这是因为IDE会在每个上下文中建议使用公共顶层函数（因为它们可以在任何地方使用）。如果顶层函数的名称没有清楚地说明这是一个顶层函数，那么它可能会被误认为是本地上下文中的方法并被意外使用。以下是一些顶层函数的好例子：
- en: '`factorial`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`factorial`'
- en: '`maxOf` and `minOf`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxOf`和`minOf`'
- en: '`listOf`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listOf`'
- en: '`println`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println`'
- en: 'Here are some examples of functions that may be poor candidates for top level
    functions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能不适合作为顶层函数的函数的示例：
- en: '`sendUserData`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendUserData`'
- en: '`showPossiblePlayers`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showPossiblePlayers`'
- en: This rule is applicable only in Kotlin object-oriented programming projects.
    In function-oriented programming projects, these are valid top-level names, but
    then we suppose that nearly all functions are defined in the top-level and not
    as methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则只适用于Kotlin面向对象编程项目。在面向函数的编程项目中，这些是有效的顶层名称，但我们假设几乎所有函数都是在顶层定义的，而不是作为方法。
- en: Often we define functions we want to use only in specific modules or specific
    classes. To limit function visibility (place where it can be used) we can use
    visibility modifiers. We will discuss visibility modifiers in [Chapter 4](text00088.html)
    *, Classes and Objects* .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们定义我们想要在特定模块或特定类中使用的函数。为了限制函数的可见性（可以使用的位置），我们可以使用可见性修饰符。我们将在[第4章](text00088.html)，*类和对象*中讨论可见性修饰符。
- en: Top-level functions under the hood
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层的顶层函数
- en: 'With the Android projects, Kotlin is compiled to Java bytecode that runs on
    Dalvik Virtual Machine (before Android 5.0) or Android Runtime (Android 5.0 and
    newer). Both virtual machines can execute only the code that is defined inside
    a class. To solve this problem Kotlin compiler generates classes for top-level
    functions. The class name is constructed from the file name and `Kt` suffix. Inside
    such a class, all functions and properties are static. For example, let''s suppose
    that we define a function within the `Printer.kt` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android项目中，Kotlin被编译成Java字节码，可以在Dalvik虚拟机（Android 5.0之前）或Android Runtime（Android
    5.0及更新版本）上运行。两种虚拟机只能执行类内定义的代码。为了解决这个问题，Kotlin编译器为顶层函数生成类。类名由文件名和`Kt`后缀构成。在这样的类内，所有函数和属性都是静态的。例如，假设我们在`Printer.kt`文件中定义一个函数：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Kotlin code is compiled into Java bytecode. The generated bytecode will be
    analogical to the code generated from the following Java class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin代码被编译成Java字节码。生成的字节码将类似于从以下Java类生成的代码：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`PrinterKt` is the name made from the name of file and `*Kt*` suffix.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrinterKt`是由文件名和`*Kt*`后缀构成的名称。'
- en: All top-level functions and properties are compiled to static methods and variables.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有顶层函数和属性都被编译为静态方法和变量。
- en: '`print` is a Kotlin function, but since it is an inline function, its call
    is replaced by its body during compilation time. And its body includes only `System.out.println
    call` .'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`print`是一个Kotlin函数，但由于它是一个内联函数，它的调用在编译时被其主体替换。它的主体只包括`System.out.println`调用。'
- en: Inline functions will be described in [Chapter 5](text00125.html) , *Functions
    as a First Class Citizen* .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数将在[第5章](text00125.html)中描述，*作为一等公民的函数*。
- en: 'Kotlin class at Java bytecode level will contain more data (for example, name
    of parameters). We can also access Kotlin top-level functions from Java files
    by prefixing a function call with the class name:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java字节码级别上，Kotlin类将包含更多数据（例如参数名称）。我们还可以通过在函数调用前加上类名来从Java文件中访问Kotlin顶层函数：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This way, Kotlin top-level functions calls from Java are fully supported. As
    we can see, Kotlin is really interoperable with Java. To make Kotlin top-level
    functions usage more comfortable in Java, we can add an annotation that will change
    the name of a JVM generated class. This comes in handy when making usage of top-level
    Kotlin properties and functions from Java classes. This annotation looks as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，从Java调用Kotlin顶层函数是完全支持的。可以看出，Kotlin与Java真正可以互操作。为了使Java中对Kotlin顶层函数的使用更加舒适，我们可以添加一个注解来更改JVM生成的类的名称。在从Java类中使用顶层Kotlin属性和函数时，这非常方便。该注解如下所示：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to add the `JvmName` annotation at the top of the file (before package
    name). When this is applied, the name of the generated class will be changed to
    `Printer` . This allows us to call the `printTwo` function in Java using Printer
    as the class name:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在文件顶部（在包名之前）添加`JvmName`注解。应用此注解后，生成的类名将更改为`Printer`。这使我们可以在Java中使用`Printer`作为类名调用`printTwo`函数：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Sometimes we are defining top-level functions, and we want to define them in
    separate files, but we also want them in the same class after compilation to JVM.
    This is possible if we use the following annotation in top of the file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们定义顶层函数，并且希望在单独的文件中定义它们，但也希望它们在编译为JVM后在同一个类中。如果我们在文件顶部使用以下注解，这是可能的：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example, let''s assume that we are making a library with mathematical helpers
    that we want to use from Java. We can define the following files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在制作一个数学辅助库，我们希望从Java中使用。我们可以定义以下文件：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we can use it from Java classes this way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Java类中这样使用它：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Thanks to this, we can keep files short and simple, while keeping them all easy
    to use from Java.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们可以保持文件简短和简单，同时使它们都易于从Java中使用。
- en: The `JvmName` annotation to change generated class names is especially useful
    when we create libraries in Kotlin that are also directed to be used in Java classes.
    It can be useful in case of name conflicts too. Such a situation can occur when
    we create both an `X.kt` file with some top-level functions or properties and
    an `XKt` class in the same package. But it is rare and should never take place
    since there is a convention that no classes should have `Kt` suffix.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`JvmName`注解用于更改生成的类名，在创建Kotlin库并且也要在Java类中使用时特别有用。在名称冲突时也很有用。当我们在同一个包中创建了`X.kt`文件和一个`XKt`类时，可能会出现这种情况。但这很少发生，因为有一个约定，即不应该有类带有`Kt`后缀。'
- en: Local functions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部函数
- en: 'Kotlin allows defining functions in many contexts. We can define functions
    at top-level, as members (inside the `class` , `interface` , and so on), and inside
    other function (local function). Consider the following example of the definition
    of local function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许在许多上下文中定义函数。我们可以在顶层定义函数，作为成员（在`class`，`interface`等内部），以及在其他函数内部（局部函数）。考虑以下局部函数定义的示例：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`printThree` is a local function, because it is located inside another function.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printThree`是一个局部函数，因为它位于另一个函数内部。'
- en: Local functions are not accessible from outside the function they were declared
    in.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部函数无法从其声明的函数外部访问。
- en: 'Elements accessible inside local functions don''t have to be passed from enclosing
    functions as arguments because they are accessible directly. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数内可访问的元素不必从封闭函数作为参数传递，因为它们可以直接访问。例如：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Local function can access comment parameter and local variables (downloaded
    and IDs), defined inside an enclosing function.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部函数可以访问封闭函数内定义的注释参数和局部变量（下载和ID）。
- en: 'If we would like to define `printLog` as a top-level function then we would
    have to pass as arguments both `ids` and `downloaded` :'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`printLog`定义为顶层函数，那么我们必须将`ids`和`downloaded`作为参数传递：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This implementation is not only longer, but also harder to maintain. Changes
    in `printLog` might demand different parameters, and a change in parameters demands
    changes in arguments in this function call. Also, if we change the `loadUsers`
    parameter type that is used in `printLog` then we will need to also change the
    parameter of `printLog` . There would be no such problems if `printLog` was a
    local function. This explains when local functions should be used: When we are
    extracting functionality that is used only by a single function, and that functionality
    is using elements (variables, values, parameters) of this function. Also, local
    functions are allowed to modify local variables. Like in this example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现不仅更长，而且更难维护。对`printLog`的更改可能需要不同的参数，而参数的更改则需要更改此函数调用中的参数。此外，如果我们更改了`printLog`中使用的`loadUsers`参数类型，那么我们还需要更改`printLog`的参数。如果`printLog`是一个局部函数，就不会出现这样的问题。这解释了何时应该使用局部函数：当我们提取的功能仅被单个函数使用，并且该功能使用此函数的元素（变量、值、参数）。此外，局部函数允许修改局部变量。就像在这个例子中：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This way, we can extract and reuse functionality that could not be extracted
    in Java. It is good to remember about local functions, because they sometimes
    allow code extraction that is hard to implement in other ways.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以提取和重用在Java中无法提取的功能。记住局部函数是很好的，因为它们有时允许以其他方式难以实现的代码提取。
- en: Nothing return type
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nothing返回类型
- en: 'Sometimes we need to define a function that is always throwing exceptions (never
    terminating normally)*.* Two real-life use cases are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要定义一个总是抛出异常（永远不会正常终止）的函数。两个真实的用例是：
- en: Functions that simplify error throwing. This is especially useful in libraries
    where error system is important and there is a need to provide more data about
    error occurrence. (As an example look at the `throwError` function presented in
    this section).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化错误抛出的函数。这在错误系统重要且需要提供有关错误发生的更多数据时特别有用。（例如，查看本节中介绍的`throwError`函数）。
- en: Functions used for throwing errors in unit tests. This is useful when we need
    to test error handling in our code.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中用于抛出错误的函数。当我们需要测试代码中的错误处理时，这是很有用的。
- en: 'For these kinds of situations, there is a special class called `Nothing` .
    The `Nothing` class is empty type (uninhabited type), meaning it has no instances.
    A function that has `Nothing` return type won''t return anything and it will never
    reach `return` statement. It can only throw an exception. This is why when we
    see that function is returning `Nothing` , then it is designed to throw exceptions.
    This way we can distinguish functions that do not return a value (like Java''s
    `void` , Kotlin''s `Unit` ) from functions that never terminate (returns `Nothing`
    ). Let us have a look at an example of functions that might be used to simplify
    error throwing in unit tests:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，有一个特殊的类叫做`Nothing`。`Nothing`类是空类型（无人居住类型），意味着它没有实例。具有`Nothing`返回类型的函数不会返回任何东西，也永远不会达到`return`语句。它只能抛出异常。这就是为什么当我们看到函数返回`Nothing`时，它被设计为抛出异常。这样我们就可以区分不返回值的函数（如Java的`void`，Kotlin的`Unit`）和永远不会终止的函数（返回`Nothing`）。让我们看一个例子，这个函数可能被用来简化单元测试中的错误抛出：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And functions that are constructing complex error messages using elements available
    in context where it is defined (in class or function):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以及构造复杂错误消息的函数，使用在定义它的上下文中可用的元素（在类或函数中）：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This kind of function is that it can be used, just like a `throw` statement,
    as an alternative that is not influencing function returned type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数的特点是它可以像`throw`语句一样使用，作为不影响函数返回类型的替代品：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'How is it possible? This is a special trait of the `Nothing` class, which is
    acting as if it is a subtype of all the possible types: both nullable and not-nullable.
    This is why `Nothing` is referred as an **empty type** , which means that no value
    can have this type at runtime, and it''s also a subtype of every other class.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么可能的？这是`Nothing`类的一个特殊特性，它表现得好像它是所有可能类型的子类型：可空和非可空的。这就是为什么`Nothing`被称为**空类型**，这意味着在运行时没有值可以具有这种类型，它也是每个其他类的子类型。
- en: '![](img/Image00033.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00033.jpg)'
- en: The concept of uninhabited type is new in the world of Java, and this is why
    it might be confusing. The idea is actually pretty simple. The `Nothing` instance
    is never existing, while there is only an error that might be returned from functions
    that are specifying it as a return type. And there is no need for `Nothing` added
    to something to influence its type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无人居住类型的概念在Java世界中是新的，这就是为什么它可能令人困惑。这个想法实际上非常简单。`Nothing`实例从未存在，只有可能从指定它为返回类型的函数中返回的错误。而且没有必要将`Nothing`添加到某些东西中以影响其类型。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve seen how to define and use functions. We learned how
    functions can be defined on the top-level or inside other functions. There was
    also a discussion on different features connected to functions--vararg parameters,
    default names, and named argument syntax. Finally, we saw some Kotlin special
    return types: `Unit` , which is equivalent of Java `void` , and `Nothing` , which
    is a type that cannot be defined and means that nothing can be returned (only
    exceptions).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何定义和使用函数。我们了解了如何在顶层或其他函数内定义函数。还讨论了与函数相关的不同特性——可变参数、默认名称和命名参数语法。最后，我们看到了一些Kotlin特殊的返回类型：`Unit`，它相当于Java的`void`，以及`Nothing`，它是一种无法定义的类型，意味着什么也不能返回（只能抛出异常）。
- en: In the next chapter, we are going to see how classes are defined in Kotlin.
    Classes are also specially supported by the Kotlin language, and there are lots
    of improvements introduced over Java definitions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到Kotlin中如何定义类。类在Kotlin语言中也得到了特别的支持，并且引入了许多改进，超过了Java的定义。
