- en: Securing and Implementing Resilience in .NET Core Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET Core应用程序中保护和实施弹性
- en: Security and resilience are two important aspects that should be considered
    when developing applications of any scale. Security protects an application's
    secrets, performs authentication, and provides authorized access to secure content,
    whereas resiliency embraces the application if it fails so that it can degrade
    gracefully. Resiliency makes an application highly available and allows the application
    to function properly at the time when an error occurs or when it is in a faulty
    state. It is widely used with the microservices architecture, where an application
    is decomposed into multiple services and each service communicates with other
    services to perform an operation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和弹性是开发任何规模应用程序时应考虑的两个重要方面。安全性保护应用程序的机密信息，执行身份验证，并提供对安全内容的授权访问，而弹性在应用程序失败时保护应用程序，使其能够优雅地降级。弹性使应用程序高度可用，并允许应用程序在发生错误或处于故障状态时正常运行。它在微服务架构中被广泛使用，其中应用程序被分解为多个服务，并且每个服务与其他服务通信以执行操作。
- en: There are various techniques and libraries available in .NET Core that we can
    use to implement security and resiliency. In ASP.NET Core applications, we can
    use Identity to implement user authentication/authorization, a popular Polly framework
    to implement patterns such as circuit breaker, the retry pattern, and others.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中有各种技术和库可用于实现安全性和弹性。在ASP.NET Core应用程序中，我们可以使用Identity来实现用户身份验证/授权，使用流行的Polly框架来实现诸如断路器、重试模式等模式。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Introduction to resilient applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性应用程序简介
- en: Implementing health checks to monitor application performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施健康检查以监视应用程序性能
- en: Implementing the retry pattern in ASP.NET Core applications to retry operations
    on transient faults
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ASP.NET Core应用程序中实施重试模式以重试瞬时故障上的操作
- en: Implementing circuit breaker patterns to prevent calls that are likely to fail
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施断路器模式以防止可能失败的调用
- en: Protecting ASP.NET Core applications and enabling authentication and authorization
    using the Identity framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护ASP.NET Core应用程序并使用Identity框架启用身份验证和授权
- en: Using safe storage to store application secrets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全存储来存储应用程序机密
- en: Introduction to resilient applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性应用程序简介
- en: Developing applications with resiliency as an important factor always makes
    your customers happy. Today, applications are distributed by nature and involve
    lots of communication over the wire. Problems arise when the service is down or
    not responding on time due to network failure, which eventually leads to a delay
    before the client operation is terminated. The purpose of resiliency is to make
    your application recover from a failure and make it responsive again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发具有弹性作为重要因素的应用程序总是会让您的客户感到满意。今天，应用程序本质上是分布式的，并涉及大量的通信。当服务因网络故障而宕机或未能及时响应时，问题就会出现，这最终会导致客户操作终止之前的延迟。弹性的目的是使您的应用程序从故障中恢复，并使其再次响应。
- en: Complexity increases when you call one service and that service calls another
    service, and so on. In a long chain of operations, considering resiliency is important.
    This is the reason it is one of the most widely adopted principles in microservice
    architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个服务，该服务调用另一个服务，依此类推时，复杂性会增加。在一长串操作中，考虑弹性是很重要的。这就是为什么它是微服务架构中最广泛采用的原则之一。
- en: Resilient policies
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性政策
- en: 'Resilient policies are classified into two categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性政策分为两类：
- en: Reactive policies
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应性政策
- en: Proactive policies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积极的政策
- en: In this chapter, we will implement both reactive and proactive policies using
    the Polly framework, which can be used with .NET Core applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Polly框架实施反应性和积极性政策，该框架可用于.NET Core应用程序。
- en: Reactive policies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应性政策
- en: 'According to the reactive policy, we should instantly retry the service request
    if the request fails on its first attempt. To implement the reactive policy, we
    can use the following patterns:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据反应性政策，如果服务请求在第一次尝试时失败，我们应立即重试服务请求。要实施反应性政策，我们可以使用以下模式：
- en: '**Retry**: Retries immediately when the request fails'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**：在请求失败时立即重试'
- en: '**Circuit breaker**: Stops all requests to a service in a faulted state'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：在故障状态下停止对服务的所有请求'
- en: '**Fallback**: Returns a default response if the service is in a faulted state'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退**：如果服务处于故障状态，则返回默认响应'
- en: Implementing the retry pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施重试模式
- en: The retry pattern is used to retry the faulted service a number of times in
    order to get a response. It is widely used in scenarios involving intercommunication
    between services, where one service is dependent on another service to perform
    a particular operation. Transient faults occur when services are hosted separately
    and communicate over the wire, most likely over a HTTP protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重试模式用于重试故障服务多次以获得响应。它在涉及服务之间的相互通信的场景中被广泛使用，其中一个服务依赖于另一个服务执行特定操作。当服务分别托管并通过网络进行通信时，最有可能是通过HTTP协议时，会发生瞬时故障。
- en: 'The following diagram represents two services: a user registration service
    that registers and save the user''s record in a database, and an email service
    to send a confirmation email to the user so that they can activate their account.
    Suppose an email service does not respond. This will return some sort of error,
    and if a retry pattern is implemented, it will retry the request the number of
    times it has been implemented to do so, and will call the email service if it
    fails:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示两个服务：一个用户注册服务，用于在数据库中注册和保存用户记录，以及一个电子邮件服务，用于向用户发送确认电子邮件，以便他们激活他们的帐户。假设电子邮件服务没有响应。这将返回某种错误，如果实施了重试模式，它将重试请求已实施的次数，并在失败时调用电子邮件服务：
- en: '![](img/00077.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'The **User Registration Service** and the **Email Service** are ASP.NET Core
    Web API projects where user registration implements the retry pattern. We will
    use the Polly framework by adding it as a NuGet package in the user registration
    service. To add Polly, we can execute the following command from the NuGet package
    manager console window in Visual Studio:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户注册服务**和**电子邮件服务**是ASP.NET Core Web API项目，其中用户注册实现了重试模式。我们将通过将其添加为NuGet包在用户注册服务中使用Polly框架。要添加Polly，我们可以在Visual
    Studio的NuGet包管理器控制台窗口中执行以下命令：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Polly framework is based on policies. You can define policies that contain
    specific configurations related to the pattern you are implementing and then invoke
    that policy by calling its `ExecuteAsync` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Polly框架基于策略。您可以定义包含与您正在实现的模式相关的特定配置的策略，然后通过调用其`ExecuteAsync`方法来调用该策略。
- en: 'Here is the `UserController` which contains a POST method that implements a
    retry pattern to invoke the email service:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含实现重试模式以调用电子邮件服务的POST方法的`UserController`。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we have used the `HttpClient` class to make a RESTful
    request to the email service API. The `HTTP POST` method receives a user object
    that contains the following five properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`HttpClient`类向电子邮件服务API发出RESTful请求。`HTTP POST`方法接收一个包含以下五个属性的用户对象：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the request will be sent in JSON format, we have to set the `Content-Type`
    header value to `application/json`. Then, we have to define the retry policy to
    wait and retry the operation every three seconds, with the maximum amount of retries
    being three. Finally, we call the `ExecuteAsync` method to invoke the `client.PostAsync`
    method so that it calls the email service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求将以JSON格式发送，我们必须将`Content-Type`标头值设置为`application/json`。然后，我们必须定义重试策略以等待并重试每三秒一次的操作，最大重试次数为三次。最后，我们调用`ExecuteAsync`方法来调用`client.PostAsync`方法，以便调用电子邮件服务。
- en: After running the preceding example, if the email service is down or throws
    an exception, it will be retried three times to try and get the required response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述示例后，如果电子邮件服务宕机或抛出异常，将重试三次以尝试获取所需的响应。
- en: Implementing circuit breaker
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施断路器
- en: Implementing the retry pattern is a good practice when calling services that
    are communicating over a network. However, the calling mechanism itself takes
    resources and bandwidth to execute the operation and delay the response. If the
    services are already in a faulted state, it is not always a good practice to retry
    it multiple times for every request. This is where circuit breaker plays its role.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用通过网络通信的服务时，实现重试模式是一个很好的实践。然而，调用机制本身需要资源和带宽来执行操作并延迟响应。如果服务已经处于故障状态，不总是一个好的实践为每个请求重试多次。这就是断路器发挥作用的地方。
- en: 'Circuit breaker works in three states, as shown in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器有三种状态，如下图所示：
- en: '![](img/00078.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: Initially, the circuit breaker is in a **Closed State**, which means the communication
    between services are working and the target remote service is responding. If the
    target remote service fails, the circuit breaker changes to **Open State**. When
    the state becomes open, then all subsequent requests cannot invoke the target
    remote service for a particular, specified time, and directly returns the response
    to the caller. Once the time elapses, the circuit turns to **Half-open State**
    and tries to invoke the target remote service to get the response. If the response
    is received successfully, the circuit breaker changes back to **Closed State**,
    or if it fails, the state changes back to closed and remains closed for the time
    specified in the configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，断路器处于**关闭状态**，这意味着服务之间的通信正常工作，目标远程服务正在响应。如果目标远程服务失败，断路器将变为**打开状态**。当状态变为打开时，随后的所有请求都无法在特定的指定时间内调用目标远程服务，并直接将响应返回给调用者。一旦时间过去，断路器转为**半开状态**并尝试调用目标远程服务以获取响应。如果成功接收到响应，断路器将变回**关闭状态**，或者如果失败，状态将变回关闭并保持关闭，直到配置中指定的时间。
- en: 'To implement the circuit breaker pattern, we will use the same Polly framework,
    which you can add from the NuGet package. We can add the circuit breaker policy
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实现断路器模式，我们将使用相同的Polly框架，您可以从NuGet包中添加。我们可以按照以下方式添加断路器策略：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the preceding circuit breaker policy inside the `ConfigureServices` method
    in the `Startup` class. The reason for defining it in the `Startup` class is to
    inject the circuit breaker object as a singleton object through **Dependency Injection**
    (**DI**). Therefore, all requests will share the same instance and the state will
    be maintained properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Startup`类的`ConfigureServices`方法中添加上述断路器策略。将其定义在`Startup`类中的原因是通过**依赖注入**（**DI**）将断路器对象注入为单例对象。因此，所有请求将共享相同的实例，并且状态将得到适当维护。
- en: While defining the circuit breaker policy, we set the number of events allowed
    before breaking the circuit as three, which checks how many times the request
    has failed and breaks the circuit once it reaches the threshold value of three.
    It will keep the circuit break *Open* for 10 seconds and then change the state
    to *Half-Open* when the first request comes in after the time has elapsed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义断路器策略时，我们将允许断开电路之前的事件数设置为三次，这将检查请求失败的次数，并在达到三次的阈值时断开电路。它将保持断路器在*打开*状态下10秒钟，然后在时间过去后的第一个请求到来时将状态更改为*半开*。
- en: 'Finally, if the remote service is still failing ,the circuit state changes
    to the *Open* state again; otherwise, it is set as *Close*. We have also defined `OnBreak`,
    `OnReset`, and `OnHalfOpen` delegates that are invoked when the circuit state
    changes. We can log this information somewhere in the database or file system
    if required. Add these delegate methods in the `Startup` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果远程服务仍然失败，断路器状态再次变为*Open*状态；否则，它将被设置为*Close*。我们还定义了`OnBreak`、`OnReset`和`OnHalfOpen`委托，当断路器状态改变时会被调用。如果需要，我们可以在数据库或文件系统中记录这些信息。在`Startup`类中添加这些委托方法：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will add the `circuitBreakerPolicy` and `HttpClient` objects using
    DI in the `ConfigureServices` method in the `Startup` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`Startup`类的`ConfigureServices`方法中使用DI添加`circuitBreakerPolicy`和`HttpClient`对象：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is our `UserController` that takes the `HttpClient` and `CircuitBreakerPolicy`
    object in the parameterized constructor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`UserController`，它在参数化构造函数中接受`HttpClient`和`CircuitBreakerPolicy`对象：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this is the `HTTP POST` method that uses the circuit breaker policy and
    invokes the email service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用断路器策略并调用电子邮件服务的`HTTP POST`方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the classic circuit breaker example. Polly also comes with an advanced
    circuit breaker, which is more useful in cases where you have to break the circuit
    based on the percentage of failed requests in a particular amount of time. When
    working with big applications or applications that involve lots of transactions
    within a minute, there''s a chance that 2% to 5% of transactions will fail due
    to other non-transient failure issues, so we don''t want the circuit to break.
    In this case, we can implement the advanced circuit breaker pattern and define
    the policy in our `ConfigureServices` method, which is shown as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经典的断路器示例。Polly还提供了高级断路器，它在特定时间内基于失败请求的百分比来断开电路，这在需要在一定时间内处理大量事务的大型应用程序或涉及大量事务的应用程序中更有用。在一分钟内，有2%到5%的事务由于其他非瞬态故障问题而失败的可能性，因此我们不希望断路器中断。在这种情况下，我们可以实现高级断路器模式，并在我们的`ConfigureServices`方法中定义策略，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first parameter in the `AdvancedCircuitBreakerAsync` method contains a value
    of 0.1, which is the percentage of requests that have failed in the time frame,
    which is `60` seconds, as specified in the second parameter. The third parameter
    which, defines the value of `5`, is the minimum throughput of requests being served
    in that particular time, as specified in the second parameter which is 60 seconds.
    Finally, the fourth parameter defines the amount of time the circuit remains open
    if any request fails and tries to serve the request again once the time has elapsed.
    The Other parameters are just delegate methods that are called when each state
    is changed, which is the same as in the previous classic circuit breaker example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvancedCircuitBreakerAsync`方法中的第一个参数包含了0.1的值，这是在指定的时间段内（60秒）失败的请求的百分比，如第二个参数所指定的。第三个参数定义了值为5，是在特定时间内（第二个参数为60秒）正在服务的请求的最小吞吐量。最后一个参数定义了如果任何请求失败并尝试再次服务请求的时间量，断路器保持打开状态的时间。其他参数只是在每个状态改变时调用的委托方法，与之前的经典断路器示例中的情况相同。'
- en: Wrapping the circuit breaker with retry
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将断路器与重试包装起来
- en: So far, we have learned how circuit breaker and retry patterns can be used and
    implemented using the Polly framework. The retry pattern is used to retry the
    request if it fails for a specified amount of time, where circuit breaker keeps
    the state of the circuit and, based on the threshold of the requests being failed,
    makes the circuit open and stops calling the remote service for some time, as
    specified in the configuration to save network bandwidth.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用Polly框架来使用和实现断路器和重试模式。重试模式用于在指定的时间内重试请求，如果请求失败，而断路器保持电路的状态，并根据失败请求的阈值打开电路，并停止调用远程服务一段时间，如配置中所指定的，以节省网络带宽。
- en: With the Polly framework, we can use the retry and circuit breaker patterns
    in conjunction and wrap the circuit breaker with the retry pattern to open the
    circuit if the retry pattern reaches the count of the failed request threshold
    limit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Polly框架，我们可以将重试和断路器模式结合起来，并将断路器与重试模式包装在一起，以便在重试模式达到失败请求阈值限制的计数时打开断路器。
- en: In this section, we will develop a custom `HttpClient` class that provides methods
    such as `GET`, `POST`, `PUT`, and `DELETE`, and use retry and circuit breaker
    policies to make it resilient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个自定义的`HttpClient`类，该类提供`GET`、`POST`、`PUT`和`DELETE`等方法，并使用重试和断路器策略使其具有弹性。
- en: 'Create a new `IResilientHttpClient` interface and add four methods for HTTP
    `GET`, `POST`, `PUT`, and `DELETE`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`IResilientHttpClient`接口，并添加四个HTTP `GET`、`POST`、`PUT`和`DELETE`方法：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create a new class called `ResilientHttpClient`, which implements the
    `IResilientHttpClient` interface. We will add a parameterized constructor to inject
    the circuit breaker policy and a `HttpClient` object, which will be used to make
    HTTP `GET`, `POST`, `PUT`, and `DELETE` requests. Here is the constructor implementation
    of the `ResilientHttpClient` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`ResilientHttpClient`的新类，该类实现了`IResilientHttpClient`接口。我们将添加一个参数化构造函数，以注入断路器策略和`HttpClient`对象，该对象将用于进行HTTP
    `GET`、`POST`、`PUT`和`DELETE`请求。以下是`ResilientHttpClient`类的构造函数实现：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we have defined the `CircuitBreakerPolicy<HttpResponseMessage>`
    and `HttpClient` objects, which are injected through DI. We have defined the retry
    policy and set the retry threshold to three times, where each retry will wait
    for three seconds before making a call to the service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经定义了`CircuitBreakerPolicy<HttpResponseMessage>`和`HttpClient`对象，它们是通过DI注入的。我们定义了重试策略，并将重试阈值设置为三次，每次重试都会在调用服务之前等待三秒钟。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will call this method from our GET, POST, PUT, and DELETE implementation
    and define the code that will be executed within the retry and circuit breaker
    policies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的GET、POST、PUT和DELETE实现中调用此方法，并定义将在重试和断路器策略中执行的代码。
- en: 'Here is the implementation for the GET, POST, PUT, and DELETE methods, respectively:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下分别是GET、POST、PUT和DELETE方法的实现：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, in our startup class, we will add the dependencies as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的启动类中，我们将添加以下依赖项：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our `UserController` class, we can inject our custom `ResilientHttpClient`
    object through DI and modify the POST method, which is shown as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`UserController`类中，我们可以通过DI注入我们的自定义`ResilientHttpClient`对象，并修改POST方法，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this implementation, the circuit will be initially closed when the application
    starts. When the request is made to the `EmailService`, if the service does not
    respond, it will try to call the service three times, waiting for three seconds
    on each request. If the service doesn't respond, the circuit will become open
    and for all subsequent requests, will stop calling the email service and will
    return the exception to the user for 60 seconds, as specified in the circuit breaker
    policy. After 60 seconds, the next request will be made to the `EmailService`
    and the circuit breaker state will be changed to Half-open. If it responds, the
    circuit state becomes closed again; otherwise, it remains in an open state for
    the next 60 seconds.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，当应用程序启动时，电路将最初关闭。当对`EmailService`进行请求时，如果服务没有响应，它将尝试三次调用服务，每个请求等待三秒。如果服务没有响应，电路将变为打开状态，并且对于所有后续请求，将停止调用电子邮件服务，并在60秒内将异常返回给用户，如断路器策略中指定的。60秒后，下一个请求将发送到`EmailService`，并且断路器状态将变为半开放状态。如果它有响应，电路状态将再次变为关闭；否则，它将在接下来的60秒内保持打开状态。
- en: Fallback policy with circuit breaker and retry
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有断路器和重试的回退策略
- en: Polly also provides a fallback policy that returns some default responses if
    the service is failing. It can be used in conjunction with both the retry and
    circuit breaker policies. The basic idea behind fallback is to send a default
    response to the consumer rather than returning the actual error in the response.
    The response should give some meaningful information to the user that is specific
    to the application's nature. This is very beneficial when your services are used
    by external consumers of applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Polly还提供了一个回退策略，如果服务失败，它将返回一些默认响应。它可以与重试和断路器策略一起使用。回退的基本思想是向消费者发送默认响应，而不是在响应中返回实际错误。响应应该向用户提供一些与应用程序性质相关的有意义的信息。当您的服务被应用程序的外部消费者使用时，这是非常有益的。
- en: 'We can modify the preceding example and add fallback policies for both the
    retry and circuit breaker exceptions. In the `ResilientHttpClient` class, we will
    add these two variables:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改上面的示例，并为重试和断路器异常添加回退策略。在`ResilientHttpClient`类中，我们将添加这两个变量：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we add the circuit breaker policy to handle the circuit breaker exception
    and return the `HttpResponseMessage` with our custom content message. Add the
    following code in the parameterized constructor of the `ResilientHttpClient` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加断路器策略来处理断路器异常，并返回带有我们自定义内容消息的`HttpResponseMessage`。在`ResilientHttpClient`类的参数化构造函数中添加以下代码：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will add another fallback policy, which will wrap the circuit breaker
    to handle any other exceptions that are not circuit breaker exceptions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加另一个回退策略，它将包装断路器以处理任何不是断路器异常的其他异常：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we will modify the `ExecuteWithRetryandCircuitBreaker` method and
    wrap both the retry and circuit breaker policy inside the fallback policies, which
    returns the general message with the 200 status code to the user:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改`ExecuteWithRetryandCircuitBreaker`方法，并将重试和断路器策略包装在回退策略中，该策略将以200状态代码向用户返回通用消息：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this implementation, the user will not get any errors in response. The
    content contains the actual error, which is shown in the following snapshot, taken
    from Fiddler:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，用户将不会收到任何响应中的错误。内容包含实际错误，如下面从Fiddler中获取的快照所示：
- en: '![](img/00079.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: Proactive policies
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主动策略
- en: According to the proactive policy, we should proactively respond to a request
    if it is leading towards a failure. We can use techniques such as timeout, caching,
    and health checks to proactively monitor application performance, and use them
    to proactively respond in the event of failure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据主动策略，如果请求导致失败，我们应该主动响应。我们可以使用超时、缓存和健康检查等技术来主动监控应用程序的性能，并在发生故障时主动响应。
- en: '**Timeout**: If a request takes more than the usual time, it ends the request'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：如果请求花费的时间超过通常时间，它会结束请求'
- en: '**Caching**: Caches previous responses and uses them for future requests'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：缓存先前的响应并在将来的请求中使用它们'
- en: '**Health checks**: Monitor the application''s performance and invokes alerts
    in the event of failure'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：监控应用程序的性能，并在发生故障时调用警报'
- en: Implementing timeout
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施超时
- en: 'Timeout is a proactive policy, which is applicable in scenarios where the target
    service takes a long time to respond, and rather than letting the client wait
    for a response, we return a general message or response. We can use the same Polly
    framework to define the timeout policy, and it can also be used with the combination
    of retry and circuit breaker patterns we learned earlier:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 超时是一种主动策略，在目标服务需要很长时间来响应的情况下适用，而不是让客户端等待响应，我们返回一个通用消息或响应。我们可以使用相同的Polly框架来定义超时策略，并且它也可以与我们之前学习的重试和断路器模式结合使用：
- en: '![](img/00080.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: In the preceding diagram, the user registration service is calling the email
    service to send emails. Now, if the email service does not respond in a particular
    amount of time, as specified in the timeout policy, the timeout exception will
    be raised.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，用户注册服务正在调用电子邮件服务发送电子邮件。现在，如果电子邮件服务在特定时间内没有响应，如超时策略中指定的，将引发超时异常。
- en: 'To add a timeout policy, declare a `_timeoutPolicy` variable in the `ResilientHttpClient`
    class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加超时策略，请在`ResilientHttpClient`类中声明一个`_timeoutPolicy`变量：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add the following code to initialize the timeout policy:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码来初始化超时策略：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we will wrap the timeout policy and add it in `resiliencyPolicyWrap`.
    Here is the modified code of the `ExecuteWithRetryandCircuitBreaker` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将包装超时策略并将其添加到`resiliencyPolicyWrap`中。以下是`ExecuteWithRetryandCircuitBreaker`方法的修改代码：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Implementing caching
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施缓存
- en: When making a web request or calling a remote service, Polly can be used to
    cache the response from the remote service and improve the performance of the
    application's response time. The Polly cache is classified into two caches, known
    as the in-memory cache and the distributed cache. We will configure the in-memory
    cache in this section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行网络请求或调用远程服务时，Polly可用于缓存来自远程服务的响应，并提高应用程序响应时间的性能。Polly缓存分为两种，即内存缓存和分布式缓存。我们将在本节中配置内存缓存。
- en: 'First, we need to add another `Polly.Caching.MemoryCache` package from NuGet.
    Once this is added, we will modify our `Startup` class and add the `IPolicyRegistry`
    as a member variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从NuGet添加另一个`Polly.Caching.MemoryCache`包。添加完成后，我们将修改我们的`Startup`类，并将`IPolicyRegistry`添加为成员变量：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `ConfigurationServices` method, we will initialize the registry and
    add it as a singleton object through DI:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConfigurationServices`方法中，我们将初始化注册表并通过DI将其添加为单例对象：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the configure method, we will define the cache policy that takes the cache
    provider and the time to cache the responses. Since we are using in-memory cache,
    we will initialize the memory cache provider and specify it in the policy as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置方法中，我们将定义缓存策略，该策略需要缓存提供程序和缓存响应的时间。由于我们使用的是内存缓存，我们将初始化内存缓存提供程序，并在策略中指定如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we will add the `cachepolicy` to our registry, which is initialized
    in the `ConfigurationServices` method. We named our registry `cache`*:*
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`ConfigurationServices`方法中初始化`cachepolicy`并将其添加到我们的注册表中。我们将我们的注册表命名为`cache`。
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Modify our `UserController` class and declare the generic `CachePolicy` as
    follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们的`UserController`类，并声明通用的`CachePolicy`如下：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will now modify our `UserController` constructor and add the registry, which
    will be injected through the DI. This registry object is used to get the cache
    defined in the `Configure` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改我们的`UserController`构造函数，并添加通过DI注入的注册表。此注册表对象用于获取在`Configure`方法中定义的缓存。
- en: 'Here is the modified constructor of the `UserController` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`UserController`类的修改后构造函数：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we will define a `GET` method that calls another service to get the
    list of users and cache it in the memory. To cache the responses, we will wrap
    our custom resilient client GET method with the `Execute` method of the cache
    policy as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义一个`GET`方法，调用另一个服务以获取用户列表并将其缓存在内存中。为了缓存响应，我们将使用缓存策略的`Execute`方法包装我们的自定义弹性客户端GET方法，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the request is returned, it will check whether the cache context is empty
    or expired, and the request will be cached for 10 minutes. All subsequent requests
    during that time will read the response from the in-memory cache store. Once the
    cache has expired, based on the set time limit, it will invoke the remote service
    again and cache the response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求返回时，它将检查缓存上下文是否为空或已过期，并且请求将被缓存10分钟。在此期间的所有后续请求将从内存缓存存储中读取响应。一旦缓存过期，根据设置的时间限制，它将再次调用远程服务并缓存响应。
- en: Implementing health checks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施健康检查
- en: Health checks are part of the proactive strategy, where the services' health
    can be monitored in a timely fashion. They also allow you to take actions proactively
    if any service is not responding or is in a failure state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是积极策略的一部分，可以及时监控服务的健康状况。它们还允许您在任何服务未响应或处于故障状态时采取积极的行动。
- en: 'In ASP.NET Core, we can easily implement health checks by using the `HealthChecks`
    library, which is available as a NuGet package. To use `HealthChecks`, we can
    just simply add the following NuGet package to our ASP.NET Core MVC or Web API
    project:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，我们可以通过使用`HealthChecks`库轻松实现健康检查，该库可作为NuGet包使用。要使用`HealthChecks`，我们只需将以下NuGet包添加到我们的ASP.NET
    Core MVC或Web API项目中：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have to add this package to the application that monitors the services and
    the services whose health needs to be monitored.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将此包添加到监视服务和需要监视健康状况的服务的应用程序中。
- en: 'Add the following code in the `ConfigureServices` method of the `Startup` class
    of the application that is used to check the health of services:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在用于检查服务健康状况的应用程序的`Startup`类的`ConfigureServices`方法中添加以下代码：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we have added two service endpoints to check the health
    status. These endpoints are defined in the `appsettings.json` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已添加了两个服务端点来检查健康状态。这些端点在`appsettings.json`文件中定义。
- en: 'The health check library checks the health of the services specified using
    the `AddUrlCheck` method. However, the services whose health needs to be monitored
    by external applications or services need some modification in the `Startup` class.
    We have to add the following code snippet to all of the services to return their
    health status:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查库通过`AddUrlCheck`方法检查指定服务的健康状况。但是，需要通过`Startup`类对需要由外部应用程序或服务监视健康状况的服务进行一些修改。我们必须将以下代码片段添加到所有服务中，以返回其健康状态：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If their health is good and the service is responding, it will return `Ok`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们的健康状况良好且服务正在响应，它将返回`Ok`。
- en: 'Finally, we can add the URI in the monitoring application, which will trigger
    the health check middleware to check the services'' health and display the health
    status. We have to add `UseHealthChecks` and specify the endpoint used to trigger
    the services'' health status:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在监视应用程序中添加URI，这将触发健康检查中间件来检查服务的健康状况并显示健康状态。我们必须添加`UseHealthChecks`并指定用于触发服务健康状态的端点：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run our monitoring application and access the URI, for example, `http://{base_address}/hc`
    to get the health status, if all the services are in working order, we should
    see the following response:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的监视应用程序并访问URI时，例如`http://{base_address}/hc`以获取健康状态，如果所有服务都正常工作，我们应该看到以下响应：
- en: '![](img/00081.gif)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.gif)'
- en: Storing sensitive information using Application Secrets
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序机密存储敏感信息
- en: Every application has some configuration holding sensitive information, such
    as database connection strings, the secret keys of some third providers, and other
    sensitive information usually stored in the configuration files or the database.
    It is always a better option to secure all sensitive information to protect these
    resources from intruders. Web applications are usually hosted on servers, and
    this information can be read by just navigating to the server's path and accessing
    files, even though servers always have protected access and only authorized users
    are eligible to access the data. However, keeping information in plain text is
    not a good practice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有一些包含敏感信息的配置，例如数据库连接字符串、一些第三方提供商的密钥以及其他敏感信息，通常存储在配置文件或数据库中。将所有敏感信息进行安全保护，以保护这些资源免受入侵者的侵害，这总是一个更好的选择。Web应用程序通常托管在服务器上，这些信息可以通过导航到服务器路径并访问文件来读取，尽管服务器始终具有受保护的访问权限，只有授权用户有资格访问数据。然而，将信息以明文形式存储并不是一个好的做法。
- en: 'In .NET Core, we can use the Secret Manager tool to protect the sensitive information
    of an application. The Secret Manager tool allows you to store information in
    a `secrets.json` file, which is not stored within the application folder itself.
    Instead, that file is saved at the following path for different platforms:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，我们可以使用Secret Manager工具来保护应用程序的敏感信息。Secret Manager工具允许您将信息存储在`secrets.json`文件中，该文件不存储在应用程序文件夹本身中。相反，该文件保存在不同平台的以下路径：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`{userSecretId}` is the unique ID (GUID) associated with your application.
    Since this is saved in the separate path, each developer has to define or create
    this file in their own directory under the `UserSecrets` directory. This restricts
    the developer from checking in the same file for the source control and keeps
    the information separate to each user. There are scenarios where a developer uses
    their own account credentials for database authentication and so this facilitates
    in keeping certain information isolated from other information.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`{userSecretId}`是与您的应用程序关联的唯一ID（GUID）。由于这保存在单独的路径中，每个开发人员都必须在自己的目录下的`UserSecrets`目录下定义或创建此文件。这限制了开发人员检入相同的文件到源代码控制中，并将信息保持分离到每个用户。有些情况下，开发人员使用自己的帐户凭据进行数据库认证，因此这有助于将某些信息与其他信息隔离开来。'
- en: 'From Visual Studio, we can simply add the `secrets.json` file by right-clicking
    on the project and selecting the Manage User Secrets option, which is shown as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio中，我们可以通过右键单击项目并选择管理用户机密选项来简单地添加`secrets.json`文件，如下所示：
- en: '![](img/00082.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'When you select Manage User Secrets, Visual Studio creates a `secrets.json`
    file and opens it in Visual Studio to add configuration settings in JSON format.
    If you open the project file, you see the entry of the `UserSecretsId` stored
    in your project file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择管理用户机密时，Visual Studio会创建一个`secrets.json`文件并在Visual Studio中打开它，以JSON格式添加配置设置。如果您打开项目文件，您会看到`UserSecretsId`存储在项目文件中的条目：
- en: '![](img/00083.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: So, if you accidently close the `secrets.json` file, you can open it from the
    path where `UserSecretsId` is the subfolder inside the user secrets path, which
    is shown in the preceding screenshot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您意外关闭了`secrets.json`文件，您可以从`UserSecretsId`是用户机密路径内的子文件夹中打开它，如上图所示。
- en: 'Here is the sample content of the `secrets.json` file that contains the logging
    information, remote services URL, and the connection string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`secrets.json`文件的示例内容，其中包含日志信息、远程服务URL和连接字符串：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To access this in the ASP.NET Core application, we can add the following namespace
    in our `Startup` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ASP.NET Core应用程序中访问此内容，我们可以在我们的`Startup`类中添加以下命名空间：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, inject the `IConfiguration` object and assign it to the `Configuration`
    property:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，注入`IConfiguration`对象并将其分配给`Configuration`属性：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we can access the variables using the `Configuration` object as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`Configuration`对象访问变量，如下所示：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Protecting ASP.NET Core APIs
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护ASP.NET Core API
- en: Securing web applications is an important milestone for any enterprise-grade
    application to protect not only the data, but also to protect it from different
    attacks from malicious sites.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 保护Web应用程序是任何企业级应用程序的重要里程碑，不仅可以保护数据，还可以保护免受恶意网站的不同攻击。
- en: 'There are various scenarios where security is an important factor for any web
    application:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中，安全性都是一个重要因素的各种场景：
- en: The information sent over the wire contains sensitive information.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络发送的信息包含敏感信息。
- en: APIs are exposed publicly and are used by users to perform bulk operations.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是公开暴露的，并且被用户用于执行批量操作。
- en: APIs are hosted on a server where the user can use some tools to do packet sniffing
    and read sensitive data.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API托管在服务器上，用户可以使用一些工具进行数据包嗅探并读取敏感数据。
- en: 'To address the preceding challenges and to secure our application, we should
    consider the following options:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决上述挑战并保护我们的应用程序，我们应该考虑以下选项：
- en: SSL (Secure Socket Layer)
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL（安全套接字层）
- en: Add security at the transport or network level, where when, the data is sent
    from the client to the server, it should be encrypted. The **SSL** (**Secure Socket
    Layer**) is the recommended way of securing information sent over the wire. Use
    SSL in a web application to encrypt all of the data that is sent from the client's
    browser to the server over the wire where it is decrypted at the server level.
    Apparently, it seems like a performance overhead, but due to the specifications
    of the server resources we have in today's world, it seems quite negligible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输或网络层添加安全性，当数据从客户端发送到服务器时，应该加密。**SSL**（安全套接字层）是在网络上传输信息的推荐方式。在Web应用程序中使用SSL加密从客户端浏览器发送到服务器的所有数据，在服务器级别解密。显然，这似乎会增加性能开销，但由于我们在今天的世界中拥有的服务器资源的规格，这似乎是相当可忽略的。
- en: Enabling SSL in an ASP.NET Core application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core应用程序中启用SSL
- en: 'To enable SSL in our ASP.NET Core project, we can add filters in the `AddMvc`
    method defined in the `ConfigureServices` method of our `Startup` class. Filters
    are used to filter the HTTP calls and take certain actions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ASP.NET Core项目中启用SSL，我们可以在`Startup`类的`ConfigureServices`方法中定义的`AddMvc`方法中添加过滤器。过滤器用于过滤HTTP调用并采取某些操作：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/00084.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: This also modifies the `launchSettings.json` file and adds the SSL. Another
    way is to directly modify the port number from the `launchSetttings.json` file
    itself. Here is the `launchsettings.json` file that uses port `44326` for SSL,
    which has been added under `iisSettings`*:*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这还修改了`launchSettings.json`文件并添加了SSL。另一种方法是直接从`launchSetttings.json`文件本身修改端口号。以下是使用端口`44326`进行SSL的`launchsettings.json`文件，已添加到`iisSettings`下：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The default HTTP port, which is shown in the preceding code, is set to `*3743*`.
    As in the `AddMvc` middleware, we have specified a filter to use SSL for all incoming
    requests. It will automatically redirect to the HTTPS and use port `44326`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中显示的默认HTTP端口设置为`*3743*`。由于在`AddMvc`中间件中，我们已经指定了一个过滤器来对所有传入请求使用SSL。它将自动重定向到HTTPS并使用端口`44326`。
- en: To host ASP.NET Core on IIS, please refer to the following link. Once the website
    is up and running, the HTTPS binding can be added through the Site bindings options
    in IIS: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IIS上托管ASP.NET Core，请参阅以下链接。网站运行后，可以通过IIS中的站点绑定选项添加HTTPS绑定：[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x)
- en: Preventing CSRF (Cross-Site Request Forgery) attacks
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止CSRF（跨站点请求伪造）攻击
- en: CSRF is an attack that executes unsolicited operations on a web application
    on behalf of the authenticated user. Since the attacker is unable to forge the
    response of the request, it is implicated mostly on `HTTP POST`, `PUT`, and `DELETE`
    methods, which are used to modify the insert, update, or delete data on the server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF是一种代表经过身份验证的用户执行未经请求的操作的攻击。由于攻击者无法伪造请求的响应，因此它主要涉及`HTTP POST`，`PUT`和`DELETE`方法，这些方法用于修改服务器上的数据。
- en: 'ASP.NET Core provides a built-in token to prevent CSRF attacks, and you can
    do this yourself by adding the `ValidateAntiForgeryTokenAttribute` filter while
    adding MVC in the `ConfigureServices` method of the `Startup` class. Here is the
    code to add an anti-forgery token globally to your ASP.NET Core application:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了内置令牌以防止CSRF攻击，您可以在向`Startup`类的`ConfigureServices`方法中添加MVC时自行添加`ValidateAntiForgeryTokenAttribute`过滤器。以下是向ASP.NET
    Core应用程序全局添加防伪标记的代码：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, we can also add `ValidateAntyForgeryToken` on specific controller
    action methods. In that case, we don’t have to add the `ValidateAntiForgeryTokenAttribute`
    filter in the `ConfigureServices` method of the `Startup` class. Here is the code
    to protect the `HTTP POST` action method from CSRF attacks:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们还可以在特定的控制器操作方法上添加`ValidateAntyForgeryToken`。在这种情况下，我们不必在`Startup`类的`ConfigureServices`方法中添加`ValidateAntiForgeryTokenAttribute`过滤器。以下是保护`HTTP
    POST`操作方法免受CSRF攻击的代码：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The second option is to enable `CORS (Cross-Origin Security)` for authenticated
    origins, headers, and methods. Setting CORS allows your APIs to be only accessible
    from configured origins. In ASP.NET Core, CORS can be easily set by adding middleware
    and defining its policy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是为经过身份验证的来源、标头和方法启用`CORS（跨源安全）`。设置CORS允许您的API仅从配置的来源访问。在ASP.NET Core中，可以通过添加中间件并定义其策略来轻松设置CORS。
- en: The `ValidateAntiForgery` attribute tells ASP.NET Core to put the token in the
    form, and when it’s submitted, it validates and ensures that the token is valid.
    This prevents your application from CSRF attacks by validating the token for every
    `HTTP POST`, `PUT`, and other HTTP requests, and protects the forms from being
    posted maliciously.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateAntiForgery`属性告诉ASP.NET Core将令牌放在表单中，当提交时，它会验证并确保令牌是有效的。这通过验证每个`HTTP
    POST`，`PUT`和其他HTTP请求的令牌来防止您的应用程序受到CSRF攻击，并保护表单免受恶意发布。'
- en: Reinforcing security headers
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强安全标头
- en: Many modern browsers provide additional security features. These security features
    are automatically enabled by the browser running your site if the response contains
    those headers. In this section, we will discuss how we can add those headers in
    our ASP.NET Core application and enable additional security in the browser.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代浏览器提供了额外的安全功能。如果响应包含这些标头，浏览器运行您的站点时将自动启用这些安全功能。在本节中，我们将讨论如何在我们的ASP.NET Core应用程序中添加这些标头，并在浏览器中启用额外的安全性。
- en: To investigate which headers are missing in our application, we can use the  [www.SecurityHeaders.io](http://www.SecurityHeaders.io)
    site. However, to use this, we need our site to be publicly accessible on the
    internet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要调查我们的应用程序中缺少哪些标头，我们可以使用[www.SecurityHeaders.io](http://www.SecurityHeaders.io)网站。但是，要使用此功能，我们需要使我们的站点在互联网上公开访问。
- en: Alternatively, we can use `ngrok` to make a HTTP tunnel to our local application,
    which makes our site accessible from the internet. The `ngrok` tool can be downloaded
    from the following link: [https://ngrok.com/download](https://ngrok.com/download).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`ngrok`将HTTP隧道到我们的本地应用程序，从而使我们的站点可以从互联网访问。可以从以下链接下载`ngrok`工具：[https://ngrok.com/download](https://ngrok.com/download)。
- en: You can select the version of OS you have and download a particular installer
    accordingly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择您拥有的操作系统版本并相应地下载特定的安装程序。
- en: 'Once `ngrok` is installed, you can open it and the run following command. Please
    note that your site should be running locally before executing the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`ngrok`后，您可以打开它并运行以下命令。请注意，在执行以下命令之前，您的站点应在本地运行：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can replace `localhost` with your server IP and `7204` to the port your
    application is listening on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`localhost`替换为您的服务器IP，将`7204`替换为应用程序侦听的端口。
- en: 'Running the preceding command will generate the public URL, as specified in
    the `Forwarding` property, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将生成公共网址，如`Forwarding`属性中所指定的那样：
- en: '![](img/00085.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: 'We can now use this public URL in [www.securityheaders.io](http://www.securityheaders.io), 
    which scans our site and gives us the result. It categorizes the site and provides
    an alphabet starting from A to F, where A is an excellent score that means the
    site contains all security headers, and F means that the site is not secure and
    does not contain security headers. Scanning the default ASP.NET Core site generated
    from the default template scored F, which is shown as follows. It also shows the
    missing headers, which are boxed in red:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在[www.securityheaders.io](http://www.securityheaders.io)中使用这个公共网址，扫描我们的网站并得到结果。它对网站进行分类，并提供从A到F的字母表，其中A是一个优秀的分数，表示网站包含所有安全标头，而F表示网站不安全且不包含安全标头。从默认模板生成的默认ASP.NET
    Core网站扫描得到F的分数，如下所示。它还显示了缺失的标头，用红色框起来：
- en: '![](img/00086.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'First of all, we should enable HTTPS on our site. To enable HTTPS, please refer
    to the section related to SSL. Next, we will add the `NWebsec.AspNetCore.Middleware`
    package from NuGet as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该在我们的网站上启用HTTPS。要启用HTTPS，请参阅与SSL相关的部分。接下来，我们将从NuGet添加`NWebsec.AspNetCore.Middleware`包，如下所示：
- en: '![](img/00087.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: NWebsec comes with various middleware that can be added to our application from
    the `Configure` method of the `Startup` class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NWebsec提供了各种中间件，可以从`Startup`类的`Configure`方法中添加到我们的应用程序中。
- en: Adding the HTTP strict transport security header
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加HTTP严格传输安全标头
- en: 'The strict transport security header is an excellent feature that strengthens
    the implementation of **TLS** (**Transport Level Security**) by getting the User
    Agent and forcing it to use HTTPS. We can add the strict transport security header
    by adding the following middleware to our `Configure` method of the `Startup`
    class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 严格传输安全标头是一个出色的功能，通过获取用户代理并强制其使用HTTPS来加强**TLS**（传输层安全）的实现。我们可以通过在`Startup`类的`Configure`方法中添加以下中间件来添加严格传输安全标头：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This middleware enforces your site so that it can only be accessed over HTTPS
    for a year. This applies to subdomains as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件强制执行您的网站，以便在一年内只能通过HTTPS访问。这也适用于子域。
- en: Adding the X-Content-Type-Options header
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加X-Content-Type-Options标头
- en: 'This header stops a browser from trying to `MIME-sniff` the content type and
    forces it to stick with the declared content-type. We can add this middleware
    as follows, in the `Configure` method of the `Startup` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此标头阻止浏览器尝试`MIME-sniff`内容类型，并强制其遵循声明的内容类型。我们可以在`Startup`类的`Configure`方法中添加此中间件，如下所示：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Adding the X-Frame-Options header
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加X-Frame-Options标头
- en: 'This header allows the browser to protect your site from being rendered inside
    a frame. By using the following middleware, we can prevent our site from framing
    so that we can defend it against different attacks, where the most famous one
    is clickjacking:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此标头允许浏览器保护您的网站免受在框架内呈现的攻击。通过使用以下中间件，我们可以防止我们的网站被框架化，从而可以防御不同的攻击，其中最著名的是点击劫持：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Adding the X-Xss-Protection header
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加X-Xss-Protection标头
- en: 'This header allows the browser to stop pages from loading when they detect
    Cross Site scripting attacks. We can add this middleware in the `Configure` method
    of the `Startup` class, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此标头允许浏览器在检测到跨站脚本攻击时停止页面加载。我们可以在`Startup`类的`Configure`方法中添加此中间件，如下所示：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Adding the Content-Security-Policy header
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加内容安全策略标头
- en: 'The *Content-Security-Policy* header protects your application by whitelisting
    the sources of approved content and preventing the browser from loading malicious
    resources. This can be added by adding the `NWebsec.Owin` package from NuGet and
    defining it in the `Configure` method of the `Startup` class as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容安全策略*标头通过列入批准内容的来源并阻止浏览器加载恶意资源来保护您的应用程序。这可以通过从NuGet添加`NWebsec.Owin`包并在`Startup`类的`Configure`方法中定义来实现，如下所示：'
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, we have mentioned the `DefaultSources` and `ScriptSources`
    to load all the resources from the same origin. If there are any scripts or images
    that need to be loaded from external sources, we can define the custom sources
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经提到了`DefaultSources`和`ScriptSources`，以从同一来源加载所有资源。如果有任何需要从外部来源加载的脚本或图像，我们可以定义自定义来源，如下所示：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For the complete documentation on this topic, please refer to the following
    URL: [https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html](https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的完整文档，请参阅以下网址：[https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html](https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html)。
- en: Adding the referrer-policy header
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加引荐策略标头
- en: 'When a user navigates the site and click links to other sites, the destination
    site usually receives information about the origin site the user came from. The
    referrer header lets you control what information should be present in the header,
    which can be read by the destination site. We can add the referrer policy middleware
    in the `Configure` method of the `Startup` class as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户浏览网站并点击链接到其他网站时，目标网站通常会收到有关用户来源网站的信息。引荐标头让您控制标头中应该存在的信息，目标网站可以读取该信息。我们可以在`Startup`类的`Configure`方法中添加引荐策略中间件，如下所示：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `NoReferrer` option means that no referrer information will be sent to the
    target site.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoReferrer`选项意味着不会向目标网站发送引荐信息。'
- en: 'After enabling all of the preceding middleware in our ASP.NET Core application,
    when we scan through the [securityheaders.io](http://securityheaders.io) site,
    we will see that we have a security report summary with an A+, which means that
    the site is completely secured:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的ASP.NET Core应用程序中启用所有前面的中间件后，当我们通过[securityheaders.io](http://securityheaders.io)网站进行扫描时，我们将看到我们有一个安全报告摘要，得到A+的分数，这意味着网站完全安全：
- en: '![](img/00088.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: Enabling CORS in the ASP.NET Core application
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core应用程序中启用CORS
- en: CORS stands for Cross-Origin Resource Sharing, and it is restricted by browsers
    to prevent API requests across domains. For example, we have an SPA (Single-Page
    Application) running on a browser using a client-side framework like Angular or
    React to make calls to the Web APIs hosted on another domain, like my SPA site
    having a domain ([*mychapter8webapp.com*](http://mychapter8webapp.com)) and accessing
    the APIs of another domain ([appservices.com](http://appservices.com)), which
    is restricted. Making calls to the services hosted on some other server and domain
    is restricted by browsers, and users will not be able to call those APIs. Enabling
    CORS on the server-side level addresses this problem.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: CORS代表跨域资源共享，它受到浏览器的限制，以防止跨域API请求。例如，我们在浏览器上运行一个SPA（单页应用程序），使用类似Angular或React的客户端框架调用托管在另一个域上的Web
    API，比如我的SPA站点具有一个域（[*mychapter8webapp.com*](http://mychapter8webapp.com)）并访问另一个域（[appservices.com](http://appservices.com)）的API，这是受限制的。浏览器限制了对托管在其他服务器和域上的服务的调用，用户将无法调用这些API。在服务器端启用CORS可以解决这个问题。
- en: 'To enable CORS in our ASP.NET Core project, we can add CORS support in the
    `ConfigureServices` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ASP.NET Core项目中启用CORS，我们可以在`ConfigureServices`方法中添加CORS支持：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `Configure` method, we can use CORS by calling the `UseCors` method
    and defining the policies to allow cross-domain requests. The following code allows
    requests to be made from any header, origin, or method, and also allows us to
    pass credentials in the request header:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Configure`方法中，我们可以通过调用`UseCors`方法并定义策略来使用CORS以允许跨域请求。以下代码允许从任何标头、来源或方法发出请求，并且还允许我们在请求标头中传递凭据：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code will allow CORS globally in the application. Alternatively,
    we can also define CORS policies and enable them on specific controllers depending
    on different scenarios.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将允许应用程序全局使用CORS。或者，我们也可以根据不同的情况定义CORS策略，并在特定控制器上启用它们。
- en: 'The following table defines the basic terminology used in defining CORS:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了定义CORS时使用的基本术语：
- en: '| **Terminology** | **Description** | **Sample** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **描述** | **示例** |'
- en: '| Header | Request header allowed to be passed within the request | Content-Type,
    Accept, and so on |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 标头 | 允许在请求中传递的请求标头 | 内容类型、接受等 |'
- en: '| Method | HTTP verb of the request | GET, POST, DELETE, PUT, and so on |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 请求的HTTP动词 | GET、POST、DELETE、PUT等 |'
- en: '| Origin | Domain or request URL | [http://techframeworx.com](http://techframeworx.com)
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 来源 | 域或请求URL | [http://techframeworx.com](http://techframeworx.com) |'
- en: 'To define the policies, we can add a policy when adding CORS support in the
    `ConfigureServices` method. The following code shows two policies that have been
    defined while adding CORS support:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义策略，我们可以在`ConfigureServices`方法中添加CORS支持时添加一个策略。以下代码显示了在添加CORS支持时定义的两个策略：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The  `AllowOnlyGet` policy will only allow requests that are making a `GET`
    request; the `Techframeworx` policy will only allow requests that are being made
    from [techframeworx.com](http://www.techframeworx.com/)*.*
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllowOnlyGet`策略将只允许进行`GET`请求的请求；`Techframeworx`策略将只允许来自[techframeworx.com](http://www.techframeworx.com/)的请求。'
- en: 'We can use these policies on Controllers and Actions by using the `EnableCors`
    attribute and specifying the name of the attribute:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`EnableCors`属性并指定属性的名称在控制器和操作上使用这些策略：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Authentication and authorization
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: Secure APIs only allow access to authenticated users. In ASP.NET Core, we can
    use the ASP.NET Core Identity framework to authenticate users and provide authorized
    access to protected resources.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的API只允许经过身份验证的用户访问。在ASP.NET Core中，我们可以使用ASP.NET Core Identity框架对用户进行身份验证，并为受保护的资源提供授权访问。
- en: Using ASP.NET Core Identity for authentication and authorization
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core Identity进行身份验证和授权
- en: 'Security, in general, is divided into two mechanisms, which are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，安全性分为两种机制，如下：
- en: Authentication
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: Authorization
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Authentication
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: Authentication is the process of authenticating the user's access by getting
    their username, password, or authentication token and then validating it from
    the backend database or service. Once the user is authenticated, certain actions
    are done, which involves setting up a cookie in the browser or returning a token
    to the user so that it can be passed in the request message to access protected
    resources.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是通过获取用户的用户名、密码或身份验证令牌进行用户访问的认证过程，然后从后端数据库或服务进行验证。一旦用户通过了身份验证，将进行一些操作，其中包括在浏览器中设置一个cookie或向用户返回一个令牌，以便在请求消息中传递以访问受保护的资源。
- en: Authorization
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: Authorization is the process that is done after user authentication. Authorization
    is used to learn the permissions of the user accessing the resource. Even though
    the user is authenticated, it does not mean that all the protected or secured
    resources are accessible. This is where authorization comes into play and only
    allows the user to access resources that they are permitted to access.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是用户认证后进行的过程。授权用于了解访问资源的用户的权限。即使用户已经通过了身份验证，也并不意味着所有受保护或安全的资源都是可访问的。这就是授权发挥作用的地方，它只允许用户访问他们被允许访问的资源。
- en: Implementing authentication and authorization using the ASP.NET Core Identity
    framework
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core Identity框架实现身份验证和授权
- en: ASP.NET Core Identity is the security framework developed by Microsoft and is
    now contributed to by the open source community. This allows a developer to enable
    user authentication and authorization in an ASP.NET Core application. It provides
    the complete system of storing user identities, roles, and claims in a database.
    It contains certain classes for user identity, roles, and so on, which can be
    extended further to support more properties, depending on the requirements. It
    uses Entity Framework Core code for the first model to create the backend database
    and can be easily integrated with existing data models or the application's specific
    tables.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity是由Microsoft开发的安全框架，现在由开源社区贡献。这允许开发人员在ASP.NET Core应用程序中启用用户身份验证和授权。它提供了在数据库中存储用户身份、角色和声明的完整系统。它包含用于用户身份、角色等的某些类，可以根据要求进一步扩展以支持更多属性。它使用Entity
    Framework Core代码为第一个模型创建后端数据库，并可以轻松集成到现有数据模型或应用程序的特定表中。
- en: In this section, we will create a simple application to add ASP.NET Core Identity
    from scratch and modify the `IdentityUser` class to define additional properties
    and use cookie-based authentication to validate requests and secure ASP.NET MVC
    controllers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的应用程序，从头开始添加ASP.NET Core Identity，并修改`IdentityUser`类以定义附加属性，并使用基于cookie的身份验证来验证请求并保护ASP.NET
    MVC控制器。
- en: 'When creating an ASP.NET Core project, we can change the authentication option
    to Individual User Account authentication, which scaffolds all the security-specific
    classes and configures security in your application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建ASP.NET Core项目时，我们可以将身份验证选项更改为个人用户帐户身份验证，该选项为您的应用程序生成所有与安全相关的类并配置安全性：
- en: '![](img/00089.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: This creates an `AccountController` and `PageModels` to register, login, forgot
    password, and other user management-related pages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`AccountController`和`PageModels`来注册、登录、忘记密码和其他与用户管理相关的页面。
- en: 'The `Startup` class also contains some entries related to security. Here is
    the `ConfigureServices` method, which adds some code that is specific to security:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Startup`类还包含一些与安全相关的条目。这是`ConfigureServices`方法，其中添加了一些特定于安全性的代码。'
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`AddDbContext` uses the SQL server to create Identity tables in the database,
    as specified in the `DefaultConnection` key as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDbContext`使用SQL服务器在数据库中创建Identity表，如下所示：`DefaultConnection`键。'
- en: '`services.AddIdentity` is used to enable Identity in our application. It takes
    `ApplicationUser` and `IdentityRole` and defines `ApplicationDbContext` to use
    as the Entity framework, which is used to store the created entities.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services.AddIdentity`用于在我们的应用程序中启用Identity。它接受`ApplicationUser`和`IdentityRole`，并定义`ApplicationDbContext`用作Entity
    Framework，用于存储创建的实体。'
- en: '`AddDefaultTokenProviders` is defined to generate tokens for reset passwords,
    changing email, changing telephone number, and two-factor authentication.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddDefaultTokenProviders` 被定义为生成重置密码、更改电子邮件、更改电话号码和双因素身份验证的令牌。'
- en: 'In the `Configure` method, it adds the `UseAuthentication` middleware, which
    enables the authentication and protects the pages or controllers that are configured
    to authorize requests. Here is the `Configure` method that enables authentication
    in the pipeline. The middleware which is defined is executed in a sequence. Therefore,
    the `UseAuthentication` middleware is defined before the `UseMvc` middleware so
    that all of the requests that will be invoking the controllers will be authenticated
    first:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Configure`方法中，它添加了`UseAuthentication`中间件，该中间件启用了身份验证并保护了已配置为授权请求的页面或控制器。这是在管道中启用身份验证的`Configure`方法。定义的中间件按顺序执行。因此，`UseAuthentication`中间件在`UseMvc`中间件之前定义，以便所有调用控制器的请求首先经过身份验证：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Adding more properties in the user table
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用户表中添加更多属性
- en: '`IdentityUser` is the base class, which contains properties such as email,
    password, and phone number, which are related to the user. When we create the
    ASP.NET Core application, it creates an empty `ApplicationUser` class that inherits
    from the `IdentityUser` class. In the `ApplicationUser` class, we can add more
    properties that will be created once the entity framework migration is run. We
    will add `FirstName`, `LastName`, and `MobileNumber` properties in our `ApplicationUser`
    class, which will be considered when the table is created:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityUser`是基类，包含与用户相关的属性，如电子邮件、密码和电话号码。当我们创建ASP.NET Core应用程序时，它会创建一个空的`ApplicationUser`类，该类继承自`IdentityUser`类。在`ApplicationUser`类中，我们可以添加更多属性，这些属性将在运行实体框架迁移时创建。我们将在我们的`ApplicationUser`类中添加`FirstName`、`LastName`和`MobileNumber`属性，这些属性在创建表时将被考虑：'
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Before running the migration, make sure that the `DefaultConnection` string
    specified in the `ConfigureServices` method of the `Startup` class is valid.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行迁移之前，请确保`Startup`类的`ConfigureServices`方法中指定的`DefaultConnection`字符串是有效的。
- en: 'We can run the migration from the Package Manager Console in Visual Studio
    or through the *dotnet CLI* toolset. From Visual Studio, select the specific project
    and run the `Add-Migration` command, specifying  the migration name, which is
    Initial in our case:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Visual Studio的包管理器控制台或通过*dotnet CLI*工具集运行迁移。从Visual Studio中，选择特定项目并运行`Add-Migration`命令，指定迁移名称，在我们的情况下是Initial：
- en: '![](img/00090.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: 'The preceding command creates the `{timestamp}_Initial` class file containing
    the `Up` and `Down` methods. The `Up` method is used to publish the changes in
    the backend database, whereas the `Down` method is used to revert the changes
    done in the database. To apply the changes to the backend database, we will run
    the `Update-Database` command, which creates a database that contains `AspNet`-related
    tables, which are part of the Identity framework. If you open the `AspNetUsers`
    table in design mode, you will see that the custom columns `FirstName`, `LastName`,
    and `MobileNumber` are there:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了`{timestamp}_Initial`类文件，其中包含`Up`和`Down`方法。`Up`方法用于发布后端数据库中的更改，而`Down`方法用于撤消数据库中的更改。要将更改应用于后端数据库，我们将运行`Update-Database`命令，该命令将创建一个包含`AspNet`相关表的数据库，这些表是身份框架的一部分。如果您以设计模式打开`AspNetUsers`表，您将看到自定义列`FirstName`、`LastName`和`MobileNumber`：
- en: '![](img/00091.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: We can run the application and create users using the Register option. To protect
    our APIs, we have to add the `Authorize` attribute to the `Controller` or `Action`
    level. When the request comes and the user is authenticated, the method will be
    executed; otherwise, it redirects the request to the Login page.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行应用程序并使用注册选项创建用户。为了保护我们的API，我们必须在`Controller`或`Action`级别添加`Authorize`属性。当请求到来并且用户经过身份验证时，方法将被执行；否则，它将重定向请求到登录页面。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about resiliency, which is a very important
    factor when developing highly performant applications in .NET Core. We learned
    about different policies and used the Polly framework to use those policies in
    .NET Core. We also learned about safe storage mechanisms and how to use them in
    a development environment in order to keep sensitive information separate from
    the project repository. At the end of this chapter, we learned about some core
    fundamentals, which included SSL, CSRF, CORS,  enabling security headers, and
    the ASP.NET Core Identity framework to protect ASP.NET Core applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了弹性，这是在.NET Core中开发高性能应用程序时非常重要的因素。我们了解了不同的策略，并使用Polly框架在.NET Core中使用这些策略。我们还学习了安全存储机制以及如何在开发环境中使用它们，以便将敏感信息与项目存储库分开。在本章的结尾，我们学习了一些核心基础知识，包括SSL、CSRF、CORS、启用安全标头以及ASP.NET
    Core身份框架，以保护ASP.NET Core应用程序。
- en: In the next chapter, we will learn about some key metrics and necessary tools
    to monitor the performance of .NET Core applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些关键的指标和必要的工具，以监控.NET Core应用程序的性能。
