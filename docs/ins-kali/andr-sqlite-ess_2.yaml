- en: Chapter 2. Connecting the Dots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。连接点
- en: '|   | *"You don''t understand anything until you learn it more than one way."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"除非你以多种方式学习，否则你不会理解任何东西。"* |   |'
- en: '|   | --*-Marvin Minsky* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*-Marvin Minsky* |'
- en: 'In the previous chapter, we learned the two important Android classes and their
    corresponding methods in order to work with an SQLite database:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了两个重要的Android类及其相应的方法，以便与SQLite数据库一起工作：
- en: The `SQLiteOpenHelper` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLiteOpenHelper`类'
- en: The `SQLiteDatabase` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLiteDatabase`类'
- en: We also saw code snippets explaining their implementation. Now, we are ready
    to use all these concepts in an Android application. We will be leveraging what
    we learned in the previous chapter to make a functional application. We will further
    look into the SQL statements to insert, query, and delete data from a database.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了解释它们实现的代码片段。现在，我们准备在Android应用程序中使用所有这些概念。我们将利用上一章中学到的知识来制作一个功能性的应用程序。我们还将进一步研究插入、查询和删除数据库中的数据的SQL语句。
- en: In this chapter, we will be building and running an Android application on an
    Android emulator. We will also be building our own full-fledged `contacts` database.
    We will encounter Android UI components, such as `Buttons` and `ListView`, while
    progressing through this chapter. In case a revisit of UI components in Android
    is required, please visit the link [http://developer.android.com/design/building-blocks/index.html](http://developer.android.com/design/building-blocks/index.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Android模拟器上构建和运行Android应用程序。我们还将构建我们自己的完整的`contacts`数据库。在本章的过程中，我们将遇到Android
    UI组件，如`Buttons`和`ListView`。如果需要重新访问Android中的UI组件，请访问链接[http://developer.android.com/design/building-blocks/index.html](http://developer.android.com/design/building-blocks/index.html)。
- en: Before we begin, the code in this chapter is meant to explain the concepts related
    to an SQLite database in Android and is not production ready; in a lot of places,
    you will find lack of proper exception handling or lack of proper null checks
    and similar practices to reduce verbosity in the code. You can download the complete
    code from Packt's website for the current and following chapters. For best results,
    we recommend downloading the code and referring to it as we move along the chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，本章的代码旨在解释与Android中的SQLite数据库相关的概念，并不适用于生产；在许多地方，您会发现缺乏适当的异常处理或适当的空值检查以及类似的实践，以减少代码的冗长。您可以从Packt的网站下载当前和以下章节的完整代码。为了获得最佳结果，我们建议在阅读本章的过程中下载代码并参考它。
- en: 'In this chapter, we will cover:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building blocks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建模块
- en: Database handler and queries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库处理程序和查询
- en: Connecting the UI and database
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接UI和数据库
- en: Building blocks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块
- en: Android is known to run on a variety of devices with different hardware and
    software specifications. At the time of writing this book, 1 billion activation
    marks have been crossed. The number of devices running Android is staggering,
    providing users with a rich variety of options in different form factors and on
    different hardware bases. This adds a roadblock when it comes to testing your
    application on different devices, because it is humanly impossible to get hold
    of them all, not to forget the time and capital needed to be invested in it. Emulator
    in itself is a great tool; it enables us to circumvent this problem by giving
    us the flexibility to mimic different hardware features, such as CPU architecture,
    RAM, and camera, and different software versions ranging from early Cupcake to
    KitKat. We will also try to leverage this to our advantage in our project and
    try to run our application on the emulator. An added benefit of using the emulator
    is that we will be running a rooted device that will allow us to perform some
    actions. We will not be able to achieve these actions on a normal device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Android以在不同硬件和软件规格的各种设备上运行而闻名。在撰写本书时，激活标记已经突破了10亿。运行Android的设备数量惊人，为用户提供了不同形态和不同硬件基础的丰富选择。当在不同设备上测试应用程序时，这增加了障碍，因为人类不可能获得所有这些设备，更不用说需要投入其中的时间和资本。模拟器本身是一个很好的工具；它使我们能够通过模拟不同的硬件特性（如CPU架构、RAM和相机）和从早期的Cupcake到KitKat的不同软件版本，来规避这个问题。我们还将尝试利用这一优势来运行我们的应用程序。使用模拟器的另一个好处是，我们将运行一个已root的设备，这将允许我们执行一些操作。在普通设备上，我们将无法执行这些操作。
- en: 'Let''s start by setting up an emulator in Eclipse:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Eclipse中设置模拟器开始：
- en: Go to **Android Virtual Device Manager** from the **Window** menu to start the
    emulator.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**窗口**菜单中的**Android虚拟设备管理器**以启动模拟器。
- en: We can set different hardware properties such as the CPU type, front/back camera,
    RAM preferably less than 768 MB on a Windows machine, internal, and external storage
    size.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置不同的硬件属性，如CPU类型、前/后摄像头、RAM（最好在Windows机器上少于768MB）、内部和外部存储大小。
- en: While launching the app, enable **Save to snapshot**; this will reduce the launch
    time the next time we are launching an emulator instance from the snapshot:![Building
    blocks](img/2951_02_01.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序时，启用**保存快照**；这将减少下次从快照启动模拟器实例时的启动时间：![Building blocks](img/2951_02_01.jpg)
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested readers who want to try out a faster emulator can give Genymotion
    a try at [http://www.genymotion.co](http://www.genymotion.co).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的读者可以尝试在[http://www.genymotion.co](http://www.genymotion.co)上尝试更快的模拟器Genymotion。
- en: Let's start building our Android application now.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始构建我们的Android应用程序。
- en: We will start by creating a new project `PersonalContactManager`. Go to **File**
    | **New** | **Project**. Now, navigate to **Android** and then select **Android
    Application Project**. This step will give us an activity file and a corresponding
    XML file.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建一个名为`PersonalContactManager`的新项目开始。转到**文件** | **新建** | **项目**。现在，导航到**Android**，然后选择**Android应用程序项目**。这一步将为我们提供一个活动文件和一个相应的XML文件。
- en: We will come back to these components after we have all the blocks we need in
    place. For our application, we will create a database called `contact`, which
    will contain one table, `ContactsTable`. In the previous chapter, we went over
    how to create a database using a SQL statement; let's construct a database schema
    for our project. This is a very important step that is based on our application's
    requirements; for example, in our case, we are building a personal contact manager
    and will require fields such as name, number, e-mail, and a display picture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放置所有需要的块之后，我们将回到这些组件。对于我们的应用程序，我们将创建一个名为`contact`的数据库，其中将包含一个名为`ContactsTable`的表。在上一章中，我们讨论了如何使用SQL语句创建数据库；让我们为我们的项目构建一个数据库架构。这是一个非常重要的步骤，它基于我们应用程序的要求；例如，在我们的情况下，我们正在构建一个个人联系人管理器，并且将需要诸如姓名、号码、电子邮件和显示图片等字段。
- en: 'The database schema for `ContactsTable` is outlined:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactsTable`的数据库架构概述如下：'
- en: '| Column | Data type |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 数据类型 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Contact_ID` | Integer / primary key/ autoincrement |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Contact_ID` | 整数/主键/自动递增 |'
- en: '| `Name` | Text |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `姓名` | 文本 |'
- en: '| `Number` | Text |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `号码` | 文本 |'
- en: '| `Email` | Text |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `电子邮件` | 文本 |'
- en: '| `Photo` | Blob |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `照片` | Blob |'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An Android application can have more than one database and each database can
    have more than one table. Each table stores data in the 2D (rows and columns)
    format.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Android应用可以有多个数据库，每个数据库可以有多个表。每个表以2D（行和列）格式存储数据。
- en: The first column is `Contact_ID`. Its datatype is integer and its **column constraint**
    is the primary key. Also, the column is autoincremented, which means for each
    row it will be incremented by one when data is inserted in that row.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是`Contact_ID`。它的数据类型是整数，其**列约束**是主键。此外，当在该行中插入数据时，该列是自动递增的，这意味着对于每一行，它将递增一次。
- en: 'The primary key uniquely identifies each row and cannot be null. Each table
    in a database can have one primary key at the most. The primary key of one table
    can act as the foreign key for another table. The foreign key serves as a connection
    between two related tables; for instance, our current `ContactsTable` schema is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主键唯一标识每一行，不能为null。数据库中的每个表最多可以有一个主键。一个表的主键可以作为另一个表的外键。外键作为两个相关表之间的连接；例如，我们当前的`ContactsTable`架构是：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s say we have another table `ColleagueTable` with the following schema:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有另一个具有以下架构的表`ColleagueTable`：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the primary key of `ContactTable`, that is, `Contact_ID` can be termed
    as a foreign key for `ColleagueTable`. It serves the purpose of linking two tables
    in a relational database and hence allows us to perform operations on `ColleagueTable`.
    We will explore this concept in detail in the chapters and examples ahead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ContactTable`的主键，即`Contact_ID`可以称为`ColleagueTable`的外键。它用于在关系数据库中连接两个表，因此允许我们对`ColleagueTable`执行操作。我们将在接下来的章节和示例中详细探讨这个概念。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Column constraint**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**列约束**'
- en: Constraints are the rules enforced on data columns in a table. This ensures
    the accuracy and reliability of data in the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是对表中数据列强制执行的规则。这确保了数据库中数据的准确性和可靠性。
- en: Unlike most SQL databases, SQLite does not restrict the type of data that may
    be inserted into a column based on the declared type of columns. Instead, SQLite
    uses **dynamic typing**. The declared type of a column is used to determine the
    **affinity** of the column only. There is a type conversion also (automatically)
    when one type of variable is stored in the other.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数SQL数据库不同，SQLite不会根据声明的列类型限制可以插入列的数据类型。相反，SQLite使用**动态类型**。列的声明类型仅用于确定列的**亲和性**。当将一种类型的变量存储在另一种类型中时，也会进行类型转换（自动）。
- en: Constraints can be column level or table level. Column-level constraints are
    applied only to one column, whereas table-level constraints are applied to the
    whole table.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以是列级或表级。列级约束仅应用于一列，而表级约束应用于整个表。
- en: 'The following are the commonly used constraints and keywords available in SQLite:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SQLite中常用的约束和关键字：
- en: 'The `NOT NULL` constraint: This ensures that a column does not have a `NULL`
    value.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT NULL`约束：这确保列没有`NULL`值。'
- en: 'The `DEFAULT` constraint : This provides a default value for a column when
    none is specified.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT`约束：当未指定列的默认值时，这为列提供了默认值。'
- en: 'The `UNIQUE` constraint: This ensures that all the values in a column are different.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIQUE`约束：这确保列中的所有值都不同。'
- en: 'The `PRIMARY` key: This uniquely identifies all rows/records in a database
    table.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键：这个唯一标识数据库表中所有行/记录的键。
- en: 'The `CHECK` constraint: The `CHECK` constraint ensures that all the values
    in a column satisfy certain conditions.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHECK`约束：`CHECK`约束确保列中的所有值满足某些条件。'
- en: 'The `AUTO INCREMENT` keyword: `AUTOINCREMENT` is a keyword used to autoincrement
    a value of a field in the table. We can autoincrement a field value by using the
    `AUTOINCREMENT` keyword when creating a table with a specific column name to autoincrement
    it. The keyword `AUTOINCREMENT` can be used with the `INTEGER` field only.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTO INCREMENT`关键字：`AUTOINCREMENT`是一个用于自动递增表中字段值的关键字。我们可以使用`AUTOINCREMENT`关键字来自动递增一个字段值，当创建一个具有特定列名的表时，使用`AUTOINCREMENT`关键字。关键字`AUTOINCREMENT`只能与`INTEGER`字段一起使用。'
- en: 'The next step is to prepare our data model; we will use our schema to frame
    the data model class. The `ContactModel` class will have `Contact_ID`, `Name`,
    `Number`, `Email`, and `Photo` as fields, they are represented as `id`, `name`,
    `contactNo`, `email`, and `byteArray` respectively. The class will consist of
    a getter/setter method to set and fetch property values as needed. The use of
    a data model will facilitate in the communication of the activity used to show/process
    data and our database handler, which we are going to define later in this chapter.
    We will create a new package and a new class in it called the `ContactModel` class.
    Please note that creating a new package is not a necessary step; it is used to
    organize our classes in a logical and easily accessible manner. This class can
    be described as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备我们的数据模型；我们将使用我们的模式来构建数据模型类。`ContactModel`类将具有`Contact_ID`、`Name`、`Number`、`Email`和`Photo`作为字段，它们分别表示为`id`、`name`、`contactNo`、`email`和`byteArray`。该类将包括一个getter/setter方法，根据需要设置和获取属性值。数据模型的使用将有助于活动与数据库处理程序之间的通信，我们将在本章后面定义。我们将在其中创建一个新的包和一个新的类，称为`ContactModel`类。请注意，创建一个新的包不是必要的步骤；它用于以逻辑和易于访问的方式组织我们的类。这个类可以描述如下：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Eclipse provides a lot of helpful shortcuts but not for generating getter and
    setter methods. We can bind generating getter and setter methods to any key binding
    as per our liking. In Eclipse, go to **Window** | **Preferences** | **General**
    | **Keys**, search for getter, and add your bindings. We are using *Alt* + *Shift*
    + *G*; you are free to set any other key combination.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse提供了很多有用的快捷方式，但不包括生成getter和setter方法。我们可以将生成getter和setter方法绑定到任何我们喜欢的键绑定上。在Eclipse中，转到**窗口**
    | **首选项** | **常规** | **键**，搜索getter，并添加你的绑定。我们使用*Alt* + *Shift* + *G*；你可以自由设置任何其他键组合。
- en: A database handler and queries
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库处理程序和查询
- en: 'We will build our support class that will contain methods to read, update,
    and delete data as per our database requirements. This class will enable us to
    create and update the database and will act as our hub for data management. We
    will use this class to run SQLite queries and send across data to the UI; in our
    case, a listview to display the results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个支持类，该类将根据我们的数据库需求包含读取、更新和删除数据的方法。这个类将使我们能够创建和更新数据库，并充当我们的数据管理中心。我们将使用这个类来运行SQLite查询，并将数据发送到UI；在我们的情况下，是一个listview来显示结果：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will create an object of the `SQLiteDatabase` class, which we will initialize
    later with either `getWritableDatabase()` or `getReadableDatabase()`. We will
    define the constants that we will be using through the class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`SQLiteDatabase`类的对象，稍后我们将用`getWritableDatabase()`或`getReadableDatabase()`来初始化它。我们将定义整个类中将要使用的常量。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, constants are defined in capitals but use of `static final` in
    defining a constant is bit more than the convention. To know more, refer to [http://goo.gl/t0PoQj](http://goo.gl/t0PoQj).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，常量以大写字母定义，但在定义常量时使用`static final`比惯例更多一些。要了解更多，请参考[http://goo.gl/t0PoQj](http://goo.gl/t0PoQj)。
- en: We will define the name of our database as `contact` and define the version
    as 1\. If we look back to the previous chapter, we will recall the importance
    of this value. A quick recap of this enables us to upgrade the database from the
    current version to the new version. The use case will become clear with this example.
    Let's say in future there is a new requirement, that is, we need to add a fax
    number to our contact details. We will modify our current schema to incorporate
    this change and our contact database will correspondingly change. If we are installing
    the application on new devices, there will be no issue; but in case of a device
    where we already have a running instance of the application, we will face problems.
    In this situation, `DB_VERSION` will come in handy and help us replace the old
    version of the database with the current version. Another approach would be to
    uninstall the application and install it again, but that is not encouraged.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把数据库的名称定义为`contact`，并将版本定义为1。如果我们回顾前一章，我们会记得这个值的重要性。对这个值的快速回顾使我们能够将数据库从当前版本升级到新版本。通过这个例子，用例将变得清晰。假设将来有一个新的需求，即我们需要在我们的联系人详细信息中添加传真号码。我们将修改我们当前的模式以包含这个变化，我们的联系人数据库将相应地改变。如果我们在新设备上安装应用程序，就不会有问题；但在已经运行应用程序的设备上，我们将面临问题。在这种情况下，`DB_VERSION`将派上用场，并帮助我们用当前版本替换旧版本的数据库。另一种方法是卸载应用程序并重新安装，但这是不鼓励的。
- en: 'The table name and important fields such as table columns will be defined now.
    `TABLE_ROW_ID` is a very important column. This will serve as the primary key
    for the table; it will also autoincrement and cannot be null. `NOT NULL` is again
    a column constraint, which may only be attached to a column definition and is
    not specified as a table constraint. Not surprisingly, a `NOT NULL` constraint
    dictates that the associated column may not contain a `NULL` value. Attempting
    to set the column value to `NULL` when inserting a new row or updating an existing
    one, causes a constraint violation. This will be used to find a particular value
    in the table. The uniqueness of the ID guarantees that we do not have any conflicts
    with data in the table, since each row is uniquely identified by the key. The
    rest of the table columns are pretty self-explanatory. The constructor for the
    `DatabaseManager` class is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将定义表名和重要字段，如表列。`TABLE_ROW_ID`是一个非常重要的列。这将作为表的主键；它还将自动递增，不能为null。`NOT NULL`再次是一个列约束，它只能附加到列定义，并且不能作为表约束指定。毫不奇怪，`NOT
    NULL`约束规定相关列不能包含`NULL`值。在插入新行或更新现有行时，如果尝试将列值设置为`NULL`，将导致约束违规。这将用于在表中查找特定值。ID的唯一性保证了我们在表中没有与表中数据冲突，因为每一行都是由这个键唯一标识的。表的其余列都相当容易理解。`DatabaseManager`类的构造函数如下：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we are using a class called `CustomSQLiteOpenHelper`. We will come
    back to this later. We will use the class object to get our `SQLitedatabase` instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了一个名为`CustomSQLiteOpenHelper`的类。我们稍后会回到这个问题。我们将使用该类对象来获取我们的`SQLitedatabase`实例。
- en: Building the Create query
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建创建查询
- en: 'To create a table with the desired columns, we will build a query statement
    and execute it. The statement will contain the table name, different table columns,
    and respective datatype. We will now look at methods for creating a new database
    and also upgrading an existing database according to the needs of the application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个具有所需列的表，我们将构建一个查询语句并执行它。该语句将包含表名、不同的表列和相应的数据类型。我们现在将看一下创建新数据库以及根据应用程序的需求升级现有数据库的方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CustomSQLiteOpenHelper` extends `SQLiteOpenHelper` and provides us with the
    key methods `onCreate()` and `onUpgrade()`. We have defined this class as the
    inner class of our `DatabaseManager` class. This enables us to manage all the
    database-related functions, namely CRUD (Create,Read,Update, and Delete), from
    one place.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomSQLiteOpenHelper`扩展了`SQLiteOpenHelper`，并为我们提供了关键方法`onCreate()`和`onUpgrade()`。我们已将此类定义为`DatabaseManager`类的内部类。这使我们能够从一个地方管理所有与数据库相关的功能，即CRUD（创建、读取、更新和删除）。'
- en: 'In our `CustomSQLiteOpenHelper` constructor, which is responsible for creating
    an instance of our class, we will pass a context, which in turn will be passed
    to the super constructor with the following parameters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CustomSQLiteOpenHelper`构造函数中，负责创建我们类的实例，我们将传递一个上下文，然后将其传递给超级构造函数，参数如下：
- en: '`Context context`: This is the context we passed to our constructor'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context context`：这是我们传递给构造函数的上下文'
- en: '`String name`: This is the name of our database'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String name`：这是我们数据库的名称'
- en: '`CursorFactory factory`: This is the cursor factory object, which can be passed
    as `null`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CursorFactory factory`：这是游标工厂对象，可以传递为`null`'
- en: '`int version`: This is the database version of the database'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int version`：这是数据库的版本'
- en: 'The next important method is `onCreate()`. We will build our SQLite query string,
    which will create our database table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的方法是`onCreate()`。我们将构建我们的SQLite查询字符串，用于创建我们的数据库表：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous statement is based on the following syntax diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句基于以下语法图：
- en: '![Building the Create query](img/2951OS_02_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![构建创建查询](img/2951OS_02_02.jpg)'
- en: Here, the keyword `create table` is used to create a table. This is followed
    by the table name, the declaration of columns, and their datatype. After preparing
    our SQL statement, we will execute it using the `execSQL()` method of the SQLite
    database. In case something is wrong with the query statement that we built earlier,
    we will encounter the exception, `android.database.sqlite.SQLiteException`. By
    default, the database is formed in the internal memory space allocated to the
    application. The folder can be found at `/data/data/<yourpackage>/databases/`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，关键字`create table`用于创建表。接着是表名、列的声明和它们的数据类型。准备好我们的SQL语句后，我们将使用SQLite数据库的`execSQL()`方法来执行它。如果我们之前构建的查询语句有问题，我们将遇到异常`android.database.sqlite.SQLiteException`。默认情况下，数据库形成在应用程序分配的内部存储空间中。该文件夹可以在`/data/data/<yourpackage>/databases/`找到。
- en: 'We can easily verify whether our database is formed while running this piece
    of code on an emulator or a rooted phone. In Eclipse, go to the DDMS perspective
    and then go to the file manager. We can easily navigate to the given folder if
    we have sufficient permission, that is, a rooted device. We can also pull up our
    database with the help of the file explorer, and with the help of a standalone
    SQLite manager tool, we can view our database and perform CRUD operations on it
    as well. What makes the Android application''s database readable through another
    tool? Remember how we discussed cross-platform in SQLite features in the last
    chapter? In the following screenshot, notice the table name, the SQL statement
    used to build it, and the column names along with their datatype:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模拟器或已获取root权限的手机上运行这段代码时轻松验证我们的数据库是否已创建。在Eclipse中，转到DDMS透视图，然后转到文件管理器。如果我们有足够的权限，即已获取root权限的设备，我们可以轻松导航到给定的文件夹。我们还可以借助文件资源管理器拉取我们的数据库，并借助独立的SQLite管理工具查看我们的数据库，并对其执行CRUD操作。是什么使得Android应用程序的数据库可以通过其他工具读取？还记得我们在上一章中讨论过SQLite特性中的跨平台吗？在下面的截图中，注意表名、用于构建它的SQL语句以及列名及其数据类型：
- en: '![Building the Create query](img/2951_02_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![构建创建查询](img/2951_02_03.jpg)'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The SQLite Manager tool can be downloaded either in the Chrome or Firefox browser.
    The following is the link for Firefox extension: [http://goo.gl/NLu8JT](http://goo.gl/NLu8JT).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite管理工具可以在Chrome或Firefox浏览器中下载。以下是Firefox扩展的链接：[http://goo.gl/NLu8JT](http://goo.gl/NLu8JT)。
- en: 'Another handy way of pulling up our database or any other file is by using
    the `adb pull` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的方法是使用`adb pull`命令来拉取我们的数据库或任何其他文件：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another interesting point to note is that the datatype of `TABLE_ROW_PHOTOID`
    is `BLOB`. BLOB stands for binary large object. It is different from other datatype,
    such as text and integer, as it can store binary data. The binary data can be
    an image, audio, or any other type of multimedia object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的要点是`TABLE_ROW_PHOTOID`的数据类型是`BLOB`。BLOB代表二进制大对象。它与其他数据类型（如文本和整数）不同，因为它可以存储二进制数据。二进制数据可以是图像、音频或任何其他类型的多媒体对象。
- en: It is not advisable to store large images in a database; we can store filenames
    or locations, but storing images is bit of overkill. Imagine a situation like
    this where we store contact images. To amplify this situation, instead of a few
    hundred contacts, make it a few thousand contacts. The size of the database will
    become large and the access time will also increase. We want to demonstrate the
    use of BLOBs by storing contact images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在数据库中存储大型图像；我们可以存储文件名或位置，但存储图像有点过度。想象一种情况，我们存储联系人图像。为了放大这种情况，让它不是几百个联系人，而是几千个联系人。数据库的大小将变得很大，访问时间也会增加。我们想通过存储联系人图像来演示BLOB的使用。
- en: The `onUpgrade()` method is called when the database is upgraded. The database
    is upgraded by changing the version number of the database. Here, the implementation
    depends on the need of the application. In some cases, the whole table may have
    to be deleted and a new one may need to be created, and in some applications,
    only slight modification is needed. How to migrate from one version to another
    is covered in [Chapter 4](ch04.html "Chapter 4. Thread Carefully"), *Thread Carefully*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库升级时，将调用`onUpgrade()`方法。通过更改数据库的版本号来升级数据库。在这里，实现取决于应用的需求。在某些情况下，可能需要删除整个表并创建一个新表，在某些应用程序中，可能只需要进行轻微修改。如何从一个版本迁移到另一个版本在[第4章](ch04.html
    "第4章. 小心操作")中有所涵盖，*小心操作*。
- en: Building the Insert query
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建插入查询
- en: 'To insert a new row of data in the database table, we need to use either the
    `insert()` method or we can make an insert query statement and use the `execute()`
    method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库表中插入新的数据行，我们需要使用`insert()`方法或者制作一个插入查询语句并使用`execute()`方法：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In case our table name is wrong, SQLite will give a log `no such table` message
    and the exception, `android.database.sqlite.SQLiteException`. The `addRow()` method
    is used to insert contact details in the database row; notice that the parameter
    of the method is an object of `ContactModel`. We have created an additional method
    `prepareData()` to construct a `ContentValues` object from the `ContactModel`
    object''s getter methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的表名错误，SQLite将给出一个日志`no such table`消息和异常`android.database.sqlite.SQLiteException`。`addRow()`方法用于在数据库行中插入联系人详细信息；请注意，该方法的参数是`ContactModel`的对象。我们创建了一个额外的方法`prepareData()`，从`ContactModel`对象的getter方法构造一个`ContentValues`对象。
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the preparation of the `ContentValues` object, we are going to use the
    `insert()` method of the `SQLiteDatabase` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好`ContentValues`对象之后，我们将使用`SQLiteDatabase`类的`insert()`方法：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The parameters of the `insert()` method are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`方法的参数如下：'
- en: '`table`: The database table to insert the row into.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`：要将行插入的数据库表。'
- en: '`values`: This key-value map contains the initial column values for the table
    row. Column names act as keys. Values as the column values.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：这个键值映射包含表行的初始列值。列名充当键。值作为列值。'
- en: '`nullColumnHack`: This is as interesting as its name. Here''s a quote from
    the Android documentation website:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullColumnHack`：这与其名称一样有趣。以下是来自Android文档网站的一句引用：'
- en: '*"optional; may be null. SQL doesn''t allow inserting a completely empty row
    without naming at least one column name. If your provided values are empty, no
    column names are known and an empty row can''t be inserted. If not set to null,
    the nullColumnHack parameter provides the name of nullable column name to explicitly
    insert NULL into the case where your values are empty."*'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “可选；可能为空。SQL不允许插入完全空的行，而不命名至少一个列名。如果您提供的值为空，那么不知道任何列名，也无法插入空行。如果未设置为null，则nullColumnHack参数提供可为空列名的名称，以明确在值为空的情况下插入NULL。”
- en: In short, in cases where we are trying to pass an empty `ContentValues` to be
    inserted, SQLite needs some column that is safe to be assigned `NULL`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在我们试图传递一个空的`ContentValues`以进行插入的情况下，SQLite需要一些安全的列来分配`NULL`。
- en: 'Alternatively, instead of the `insert()` method, we can prepare the SQL statement
    and execute it as shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以准备SQL语句并执行它，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will be covering alternatives for a lot of the methods we mentioned here.
    The idea is to make you comfortable with other possible ways to build and execute
    queries. The explanation of the alternative part is left as an exercise for you.
    The `getRowAsObject()` method will return the fetched row from the database in
    the form of a `ContactModel` object, as shown in the following code. It will require
    `rowID` as a parameter to uniquely identify which row in the table we want to
    access:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖这里提到的许多方法的替代方案。其目的是使您熟悉构建和执行查询的其他可能方式。替代部分的解释留作练习给您。`getRowAsObject()`方法将以`ContactModel`对象的形式返回从数据库中获取的行，如下面的代码所示。它将需要`rowID`作为参数，以唯一标识我们想要访问的表中的哪一行：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method will return the fetched row from the database in the form of a
    `ContactModel` object. We are using the `SQLiteDatabase()` query method to fetch
    the row from our contact table against the provided `rowID` parameter. The method
    returns a cursor over the result set:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将以`ContactModel`对象的形式返回从数据库中获取的行。我们正在使用`SQLiteDatabase()`查询方法从我们的联系人表中根据提供的`rowID`参数获取行。该方法返回结果集上的游标：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following are the parameters of the previous code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的参数：
- en: '`table`: This denotes the database table against which the query will be run.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`：这表示将对其运行查询的数据库表。'
- en: '`columns`: This is a list of the columns that are returned; if we pass `null`,
    it will return all the columns.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns`：这是返回的列的列表；如果我们传递`null`，它将返回所有列。'
- en: '`selection`: This is where we define which rows are to be returned and framed
    as a SQL `WHERE` clause. Passing `null` will return all the rows.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`：这是我们定义要返回哪些行的地方，并作为SQL `WHERE` 子句。传递`null`将返回所有行。'
- en: '`selectionArgs`: We can pass `null` for this parameter or we may include question
    marks in the selection, which will be replaced by the values from `selectionArgs`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectionArgs`：我们可以为这个参数传递`null`，或者我们可以在选择中包含问号，这些问号将被`selectionArgs`中的值替换。'
- en: '`groupBy`: This is a filter framed as a SQL `GROUP BY` clause declaring how
    to group rows. Passing `null` will cause the rows to not be grouped.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy`：这是一个作为SQL `GROUP BY` 子句的过滤器，声明如何对行进行分组。传递`null`将导致行不被分组。'
- en: '`Having`: This is a filter that tells which row groups are to be made part
    of the cursor, framed as a SQL `HAVING` clause. Passing `null` will cause all
    the row groups to be included.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Having`：这是一个过滤器，告诉哪些行组应该成为游标的一部分，作为SQL `HAVING` 子句。传递`null`将导致所有行组被包括。'
- en: '`OrderBy`: This tells the query how to order the rows framed as an SQL `ORDER
    BY` clause. Passing `null` will use the default sort order.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`：这告诉查询如何对行进行排序，作为SQL `ORDER BY`子句。传递`null`将使用默认排序顺序。'
- en: '`limit`: This will limit the number of rows returned by the query framed as
    the `LIMIT` clause. Passing `null` denotes a no `LIMIT` clause.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`：这将限制查询返回的行数，作为`LIMIT`子句。传递`null`表示没有`LIMIT`子句。'
- en: 'Another important concept here is moving the cursor around to access data.
    Notice the following methods: `cursor.moveToFirst()`, `cursor.isAfterLast()`,
    and `cursor.moveToNext()`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个重要的概念是移动游标以访问数据。注意以下方法：`cursor.moveToFirst()`、`cursor.isAfterLast()`和`cursor.moveToNext()`。
- en: When we try to retrieve data-building SQL query statements, the database will
    first create an object of the cursor object and return its reference. The pointer
    of this returned reference is pointing to the 0th location, which is also known
    as "before first location" of the cursor. When we want to retrieve data, we have
    to first move to the first record; hence, the use of `cursor.moveToFirst()`.Talking
    about the rest of the two methods, `cursor.isAfterLast()` returns whether the
    cursor is pointing to the position after the last row and `cursor.moveToNext()`
    moves the cursor to the next row.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试检索数据构建SQL查询语句时，数据库将首先创建游标对象的对象并返回其引用。返回的引用指针指向第0个位置，也称为游标的“第一个位置”之前。当我们想要检索数据时，我们必须首先移动到第一条记录；因此，使用`cursor.moveToFirst()`。谈到其他两种方法，`cursor.isAfterLast()`返回游标是否指向最后一行之后的位置，`cursor.moveToNext()`将游标移动到下一行。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Readers are advised to go through more of the cursor methods at the Android
    developer site: [http://goo.gl/fR75t8](http://goo.gl/fR75t8).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 建议读者查看Android开发者网站上更多的游标方法：[http://goo.gl/fR75t8](http://goo.gl/fR75t8)。
- en: 'Alternatively, we can use the following method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下方法：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `update` statement is based on the following syntax diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`语句基于以下语法图：'
- en: '![Building the Insert query](img/2951OS_02_04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![构建插入查询](img/2951OS_02_04.jpg)'
- en: 'Before we move to other methods in the `datamanager` class, let''s have a look
    at fetching data from a cursor object in the `prepareSendObject()` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到`datamanager`类中的其他方法之前，让我们看一下在`prepareSendObject()`方法中从游标对象中获取数据：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here `cursor.getstring()` takes the column index as a parameter and returns
    the value of the requested column, whereas `cursor.getColumnIndexOrThrow()` takes
    the column name as a parameter and returns the zero-based index for the given
    column name. Instead of this chaining approach, we can directly use `cursor.getstring()`.
    If we know the column number of the required column to fetch data from, we can
    use the following notation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`cursor.getstring()`以列索引作为参数，并返回请求列的值，而`cursor.getColumnIndexOrThrow()`以列名作为参数，并返回给定列名的基于零的索引。除了这种链接方法，我们可以直接使用`cursor.getstring()`。如果我们知道要从中提取数据的所需列的列号，我们可以使用以下表示法：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building the Delete query
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建删除查询
- en: 'To delete a particular row of data from our database table, we need to provide
    the primary key to uniquely identify the data set to be removed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的数据库表中删除特定的数据行，我们需要提供主键来唯一标识要删除的数据集：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method uses the SQLiteDatabase `delete()` method to delete the row of
    the given ID in the table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用SQLiteDatabase的`delete()`方法来删除表中给定ID的行：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following are the parameters of the preceding code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码片段的参数：
- en: '`table`: This is the database table against which the query will be run'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`：这是要针对其运行查询的数据库表。'
- en: '`whereClause`: This is a clause to be applied when deleting a row; passing
    `null` in this clause will delete all the rows'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereClause`：这是在删除行时要应用的子句；在此子句中传递`null`将删除所有行'
- en: '`whereArgs`: We may include question marks in the `where` clause, which will
    be replaced by the values that will be bound as strings'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereArgs`：我们可以在`where`子句中包含问号，这些问号将被绑定为字符串的值'
- en: 'Alternatively, we can use the following method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下方法：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `delete` statement is based on the following syntax diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`语句基于以下语法图：'
- en: '![Building the Delete query](img/2951OS_02_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![构建删除查询](img/2951OS_02_05.jpg)'
- en: Building the Update query
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建更新查询
- en: 'To update an existing value, we need to use the `update()` method with the
    required parameters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有值，我们需要使用`update()`方法和所需的参数：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Generally, we need the primary key, in our case the `rowId` parameter, to identify
    the row to be modified. An SQLiteDatabase `update()` method is used to modify
    the existing data of zero or more rows in a database table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们需要主键，即`rowId`参数，来标识要修改的行。使用SQLiteDatabase的`update()`方法来修改数据库表中零行或多行的现有数据：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following are the parameters of the preceding code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码片段的参数：
- en: '`table`: This is the qualified database table name to be updated.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`：这是要更新的合格数据库表名称。'
- en: '`values`: This is a mapping from the column names to the new column values.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：这是从列名称到新列值的映射。'
- en: '`whereClause`: This is the optional `WHERE` clause to be applied when updating
    a value/row. If the `UPDATE` statement does not have a `WHERE` clause, all the
    rows in the table are modified.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereClause`：这是在更新值/行时要应用的可选`WHERE`子句。如果`UPDATE`语句没有`WHERE`子句，则将修改表中的所有行。'
- en: '`whereArgs`: We may include question marks in the `where` clause, which will
    be replaced by the values that will be bound as strings.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereArgs`：我们可以在`where`子句中包含问号，这些问号将被绑定为字符串的值替换。'
- en: 'Alternatively, you can use the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下代码：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `update` statement is based on the following syntax diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`语句基于以下语法图：'
- en: '![Building the Update query](img/2951OS_02_06.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![构建更新查询](img/2951OS_02_06.jpg)'
- en: Connecting the UI and database
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接UI和数据库
- en: 'Now that we have our database hooks in place, let''s connect our UI with the
    data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在数据库中设置了钩子，让我们将我们的UI与数据连接起来：
- en: The first step would be to get the data from the user. We can use the existing
    contact data from the Android's contact application by means of the content provider.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从用户那里获取数据。我们可以通过内容提供程序使用Android联系人应用程序中的现有联系人数据。
- en: 'We will be covering this approach in the next chapter. For now, we will be
    asking the user to add a new contact, which we will insert into the database:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中介绍这种方法。现在，我们将要求用户添加一个新联系人，我们将把它插入到数据库中：
- en: '![Connecting the UI and database](img/2951_02_07.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![连接UI和数据库](img/2951_02_07.jpg)'
- en: 'We are using standard Android UI widgets, such as `EditText`, `TextView`, and
    `Buttons` to collect the data provided by the user:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用标准的Android UI小部件，如`EditText`、`TextView`和`Buttons`来收集用户提供的数据：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`prepareSendData`() is the method that is responsible for bundling data into
    our object model and later inserting it in our database. Notice that instead of
    using null check and length check on `contactName`, we are using `TextUtils.isEmpty()`,
    which is a very handy method. This returns `true` if the string is null or of
    zero length.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepareSendData()`是负责将数据打包到我们的对象模型中，然后将其插入到我们的数据库中的方法。请注意，我们使用`TextUtils.isEmpty()`而不是对`contactName`进行空值检查和长度检查，这是一个非常方便的方法。如果字符串为null或长度为零，则返回`true`。'
- en: We prepare our `ContactModel` object from the data received by the user filling
    the form. We create an instance of our `DatabaseManager` class and access our
    `addRow()` method passing our contact object to be inserted in the database, as
    we discussed earlier.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从用户填写表单接收的数据准备我们的`ContactModel`对象。我们创建我们的`DatabaseManager`类的一个实例，并访问我们的`addRow()`方法，将我们的联系对象传递给数据库中插入，正如我们之前讨论的那样。
- en: 'Another important method is `getBlob()`, which is used to get the image data
    in the BLOB format:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的方法是`getBlob()`，它用于以BLOB格式获取图像数据：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a new `ByteArrayOutputStream` object `blob`. Bitmap''s `compress()`
    method will be used to write a compressed version of the bitmap to our `o``utputstream`
    object:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`ByteArrayOutputStream`对象`blob`。位图的`compress()`方法将用于将位图的压缩版本写入我们的`outputstream`对象：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following are the parameters of the preceding code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的参数：
- en: '`format`: This is the format of a compressed image, in our case, JPEG.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：这是压缩图像的格式，在我们的情况下是JPEG。'
- en: '`quality`: This is a hint to the compressor, which ranges from `0` to `100`.
    The value `0` means to compress to a smaller size and low quality, while `100`
    is for maximum quality.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quality`：这是对压缩器的提示，范围从`0`到`100`。值`0`表示压缩到较小的尺寸和低质量，而`100`是最高质量。'
- en: '`stream`: This is the output stream to write the compressed data to.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`：这是用于写入压缩数据的输出流。'
- en: Then, we create our `byte[]` object, which will be constructed from the `ByteArrayOutputStream
    toByteArray()` method.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的`byte[]`对象，它将从`ByteArrayOutputStream toByteArray()`方法构造。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that we are not covering all the methods; only those that are
    relevant to data operations and some methods or calls that might cause confusion.
    There are a few more methods that are used to invoke the camera or gallery to
    pick a photo to be used as the contact image. You are advised to explore the methods
    in the code provided along with the book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们并没有涵盖所有的方法；只有与数据操作相关的方法以及可能引起混淆的一些方法或调用。还有一些用于调用相机或画廊以选择要用作联系人图像的照片的方法。建议您探索随书提供的代码中的方法。
- en: 'Let''s move on to the presentation part where we use a custom listview to display
    our contact information in a presentable and readable manner. We are going to
    skip a bulk of the code related to the presentation and concentrate on the parts
    where we fetch and provide data to our listview. We will also implement a context
    menu in order to provide a user with the functionality of deleting a particular
    contact. We will be touching base on the database manager methods such as `getAllData()`
    to fetch all our added contacts. We will use `deleteRow()` in order to remove
    any unwanted contacts from our contacts database. The final outcome will be something
    like the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到演示部分，在那里我们使用自定义listview以一种可呈现和可读的方式显示我们的联系人信息。我们将跳过与演示相关的大部分代码，集中在我们获取和提供数据给我们的listview的部分。我们还将实现上下文菜单，以便为用户提供删除特定联系人的功能。我们将涉及数据库管理器方法，如`getAllData()`来获取所有添加的联系人。我们将使用`deleteRow()`来从我们的联系人数据库中删除任何不需要的联系人。最终结果将类似于以下截图：
- en: '![Connecting the UI and database](img/2951_02_08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![连接UI和数据库](img/2951_02_08.jpg)'
- en: 'To make a custom listview similar to the one shown in the preceding screenshot,
    we create `CustomListAdapter` extending `BaseAdapter` and using the custom layout
    for the listview rows. Notice in the following constructor we have initialized
    a new array list and will use our database manager to fetch values by using the
    getAllData() method to fetch all the database entries:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个类似于前面截图中显示的自定义listview，我们创建`CustomListAdapter`扩展`BaseAdapter`并使用自定义布局来设置listview行。请注意，在以下构造函数中，我们已经初始化了一个新的数组列表，并将使用我们的数据库管理器通过使用`getAllData()`方法来获取所有数据库条目的值：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another very important method is the `getView()` method. This is where we inflate
    our custom layout in a view:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的方法是`getView()`方法。这是我们在视图中填充自定义布局的地方：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the view holder pattern to improve the listview scrolling smoothness:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用视图持有者模式来提高listview的滚动流畅性：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And finally, set the data to the corresponding views:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将数据设置到相应的视图中：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Holding view objects in a view holder improves the performance by reducing calls
    to `findViewById()`. You can read more about this and how to make listview scrolling
    smooth at [http://developer.android.com/training/improving-layouts/smooth-scrolling.html](http://developer.android.com/training/improving-layouts/smooth-scrolling.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图持有者中持有视图对象可以通过减少对`findViewById()`的调用来提高性能。您可以在[http://developer.android.com/training/improving-layouts/smooth-scrolling.html](http://developer.android.com/training/improving-layouts/smooth-scrolling.html)上阅读更多关于此的信息以及如何使listview滚动流畅。
- en: 'We will also be implementing a way to delete a listview entry. We will use
    the context menu for this purpose. We will first create a menu item in the `menu`
    folder under `res` of our application structure:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将实现一种删除listview条目的方法。我们将使用上下文菜单来实现这一目的。我们将首先在应用程序结构的`res`文件夹下的`menu`文件夹中创建一个菜单项：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in our main activity where we will display our listview, we will use the
    following call to register our listview with the context menu. In order to launch
    the context menu, we need to perform a long press action on the listview item:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们将显示listview的主要活动中，我们将使用以下调用来注册我们的listview到上下文菜单。为了启动上下文菜单，我们需要在listview项上执行长按操作：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are a few more methods that we need to implement in order to achieve
    the delete functionality:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一些方法我们需要实现以实现删除功能：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method is used to inflate the context menu with the menu we defined earlier
    in XML. The `MenuInfater` class generates menu objects from the menu XML files.
    Menu inflation relies heavily on the preprocessing of XML files that is done at
    build time; this is done to improve performance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于用我们之前在XML中定义的菜单填充上下文菜单。`MenuInfater`类从菜单XML文件生成菜单对象。菜单膨胀在很大程度上依赖于在构建时对XML文件的预处理；这是为了提高性能而做的。
- en: 'Now, we will implement a method to capture the click on the context menu:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现一种捕获上下文菜单点击的方法：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we will find the position ID of the clicked listview item and invoke
    the `delRow()` method of the CustomListAdapter, and in the end, we will notify
    the adapter that the dataset has changed:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将找到点击的listview项的位置ID，并调用CustomListAdapter的`delRow（）`方法，最后，我们将通知适配器数据集已更改：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `delRow()` method is responsible for connecting our database's `deleteRowAlternative()`
    method to our context menu's `delete()` method. Here, we fetch the ID of the object
    set on the particular listview item and pass it to the `deleteRowAlternative()`
    method of `databaseManager` in order to delete the data from the database. After
    removing the data from the database, we will instruct our listview to remove the
    corresponding entry from our contact list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`delRow（）`方法负责将我们数据库的`deleteRowAlternative（）`方法连接到我们上下文菜单的`delete（）`方法。在这里，我们获取设置在特定listview项上的对象的ID，并将其传递给`databaseManager`的`deleteRowAlternative（）`方法，以从数据库中删除数据。在从数据库中删除数据后，我们将指示我们的listview从我们的联系人列表中删除相应的条目。'
- en: 'In the `onContextItemSelected()` method, we can also see the `update_item`
    in case the user has clicked on the `update` button. We will launch the activity
    to add a new contact and add the data we already have in case the user wants to
    edit some fields. The catch is to know from where the call has been initiated.
    Is it to add a new entry or update an existing one? We take the help of the following
    code to tell the activity that this action is used to update rather than add a
    new entry:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onContextItemSelected（）`方法中，我们还可以看到`update_item`，以防用户点击了`update`按钮。我们将启动添加新联系人的活动，并在用户想要编辑某些字段时添加我们已经拥有的数据。关键是要知道调用是从哪里发起的。是要添加新条目还是更新现有条目？我们借助以下代码告诉活动，此操作用于更新而不是添加新条目：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the steps of building up a database-based application,
    from scratch and then from schema to object model and then from object model to
    building actual databases. We underwent the process of building our database manager
    and finally implemented the UI database connect to achieve a fully functional
    application. The topics covered ranged from the building blocks of the model class,
    database schema to our database handler, and CRUD methods. We also covered the
    important concept of connecting a database to the Android views with proper hooks
    in place to pick up user data, add data to the database, and show relevant information
    after picking up data from the database.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了构建基于数据库的应用程序的步骤，从头开始，然后从模式到对象模型，然后从对象模型到构建实际数据库。我们经历了构建数据库管理器的过程，最终实现了UI数据库连接，实现了一个完全功能的应用程序。涵盖的主题包括模型类的构建块，数据库模式到数据库处理程序和CRUD方法。我们还涵盖了将数据库连接到Android视图的重要概念，并在适当的位置设置钩子以获取用户数据，将数据添加到数据库，并在从数据库中获取数据后显示相关信息。
- en: In the next chapter, we will focus on building upon the groundwork we have done
    here. We will explore `ContentProviders`. We will also learn how to fetch data
    from `ContentProviders`, how to make our own content provider, the best practices
    associated while building them, and much more.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于在这里所做的基础上构建。我们将探索`ContentProviders`。我们还将学习如何从`ContentProviders`获取数据，如何制作我们自己的内容提供程序，以及在构建它们时涉及的最佳实践等等。
