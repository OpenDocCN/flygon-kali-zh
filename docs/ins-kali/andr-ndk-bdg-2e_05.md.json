["```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <manifest \n        package=\"com.packtpub.droidblaster2d\" android:versionCode=\"1\"\n        android:versionName=\"1.0\">\n        <uses-sdk\n            android:minSdkVersion=\"14\"\n            android:targetSdkVersion=\"19\"/>\n\n        <application android:icon=\"@drawable/ic_launcher\"\n            android:label=\"@string/app_name\"\n            android:allowBackup=\"false\"\n            android:theme         =\"@android:style/Theme.NoTitleBar.Fullscreen\">\n     <activity android:name=\"android.app.NativeActivity\"\n                android:label=\"@string/app_name\"\n                android:screenOrientation=\"portrait\">\n                <meta-data android:name=\"android.app.lib_name\"\n     android:value=\"droidblaster\"/>\n                <intent-filter>\n                    <action android:name =\"android.intent.action.MAIN\"/>\n                    <category\n                        android:name=\"android.intent.category.LAUNCHER\"/>\n                </intent-filter>\n            </activity>\n        </application>\n    </manifest>\n    ```", "```kt\n    #ifndef _PACKT_TYPES_HPP_\n    #define _PACKT_TYPES_HPP_\n\n    #include <cstdint>\n\n    #endif\n    ```", "```kt\n        #ifndef _PACKT_LOG_HPP_\n        #define _PACKT_LOG_HPP_\n\n        class Log {\n        public:\n            static void error(const char* pMessage, ...);\n            static void warn(const char* pMessage, ...);\n            static void info(const char* pMessage, ...);\n            static void debug(const char* pMessage, ...);\n        };\n\n        #ifndef NDEBUG\n            #define packt_Log_debug(...) Log::debug(__VA_ARGS__)\n        #else\n            #define packt_Log_debug(...)\n        #endif\n\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n\n    #include <stdarg.h>\n    #include <android/log.h>\n\n    void Log::info(const char* pMessage, ...) {\n        va_list varArgs;\n        va_start(varArgs, pMessage);\n        __android_log_vprint(ANDROID_LOG_INFO, \"PACKT\", pMessage,\n            varArgs);\n        __android_log_print(ANDROID_LOG_INFO, \"PACKT\", \"\\n\");\n        va_end(varArgs);\n    }\n    ...\n    ```", "```kt\n    #ifndef _PACKT_EVENTLOOP_HPP_\n    #define _PACKT_EVENTLOOP_HPP_\n\n    #include <android_native_app_glue.h>\n\n    class EventLoop {\n    public:\n        EventLoop(android_app* pApplication);\n\n        void run();\n\n    private:\n        android_app* mApplication;\n    };\n    #endif\n    ```", "```kt\n    #include \"EventLoop.hpp\"\n    #include \"Log.hpp\"\n\n    EventLoop::EventLoop(android_app* pApplication):\n            mApplication(pApplication)\n    {}\n\n    void EventLoop::run() {\n        int32_t result; int32_t events;\n        android_poll_source* source;\n\n        // Makes sure native glue is not stripped by the linker.\n        app_dummy();\n\n        Log::info(\"Starting event loop\");\n        while (true) {\n            // Event processing loop.\n            while ((result = ALooper_pollAll(-1, NULL, &events,\n                    (void**) &source)) >= 0) {\n                // An event has to be processed.\n                if (source != NULL) {\n                    source->process(mApplication, source);\n                }\n                // Application is getting destroyed.\n                if (mApplication->destroyRequested) {\n                    Log::info(\"Exiting event loop\");\n                    return;\n                }\n            }\n        }\n    }\n    ```", "```kt\n    #include \"EventLoop.hpp\"\n    #include \"Log.hpp\"\n\n    void android_main(android_app* pApplication) {\n        EventLoop(pApplication).run();\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LOCAL_MODULE := droidblaster\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))\n    LOCAL_LDLIBS := -landroid -llog\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue\n\n    include $(BUILD_SHARED_LIBRARY)\n\n    $(call import-module,android/native_app_glue)\n    ```", "```kt\n    APP_ABI := armeabi armeabi-v7a x86\n    ```", "```kt\n...\nint32_t result; int32_t events;\nandroid_poll_source* source;\nwhile (true) {\n    while ((result = ALooper_pollAll(-1, NULL, &events,\n            (void**) &source)) >= 0) {\n        if (source != NULL) {\n           source->process(mApplication, source);\n        }\n        if (mApplication->destroyRequested) {\n            return;\n        }\n    }\n}\n...\n```", "```kt\nstruct android_poll_source {\n    int32_t id; // Source identifier\n    struct android_app* app; // Global android application context\n    void (*process)(struct android_app* app,\n            struct android_poll_source* source); // Event processor\n};\n```", "```kt\n    #ifndef _PACKT_TYPES_HPP_\n    #define _PACKT_TYPES_HPP_\n\n    #include <cstdlib>\n\n    typedef int32_t status;\n\n    const status STATUS_OK   = 0;\n    const status STATUS_KO   = -1;\n    const status STATUS_EXIT = -2;\n\n    #endif\n    ```", "```kt\n        #ifndef _PACKT_ACTIVITYHANDLER_HPP_\n        #define _PACKT_ACTIVITYHANDLER_HPP_\n\n        #include \"Types.hpp\"\n\n        class ActivityHandler {\n        public:\n            virtual ~ActivityHandler() {};\n\n            virtual status onActivate() = 0;\n            virtual void onDeactivate() = 0;\n            virtual status onStep() = 0;\n\n            virtual void onStart() {};\n            virtual void onResume() {};\n            virtual void onPause() {};\n            virtual void onStop() {};\n            virtual void onDestroy() {};\n\n            virtual void onSaveInstanceState(void** pData, size_t* pSize) {};\n            virtual void onConfigurationChanged() {};\n            virtual void onLowMemory() {};\n\n            virtual void onCreateWindow() {};\n            virtual void onDestroyWindow() {};\n            virtual void onGainFocus() {};\n            virtual void onLostFocus() {};\n        };\n        #endif\n        ```", "```kt\n        #ifndef _PACKT_EVENTLOOP_HPP_\n        #define _PACKT_EVENTLOOP_HPP_\n\n        #include \"ActivityHandler.hpp\"\n        #include <android_native_app_glue.h>\n\n        class EventLoop {\n        public:\n            EventLoop(android_app* pApplication,\n                    ActivityHandler& pActivityHandler);\n\n            void run();\n\n        private:\n         void activate();\n         void deactivate();\n\n         void processAppEvent(int32_t pCommand);\n\n         static void callback_appEvent(android_app* pApplication,\n         int32_t pCommand);\n\n        private:\n            android_app* mApplication;\n            bool mEnabled;\n         bool mQuit;\n\n         ActivityHandler& mActivityHandler;\n        };\n        #endif\n        ```", "```kt\n        #include \"EventLoop.hpp\"\n        #include \"Log.hpp\"\n\n        EventLoop::EventLoop(android_app* pApplication,\n                ActivityHandler& pActivityHandler):\n         mApplication(pApplication),\n         mEnabled(false), mQuit(false),\n         mActivityHandler(pActivityHandler) {\n         mApplication->userData = this;\n         mApplication->onAppCmd = callback_appEvent;\n        }\n        ...\n        ```", "```kt\n        ...\n        void EventLoop::run() {\n            int32_t result; int32_t events;\n            android_poll_source* source;\n\n            // Makes sure native glue is not stripped by the linker.\n            app_dummy();\n\n            Log::info(\"Starting event loop\");\n            while (true) {\n                // Event processing loop.\n                while ((result = ALooper_pollAll(mEnabled ? 0 : -1,         NULL,\n         &events, (void**) &source)) >= 0) {\n                    // An event has to be processed.\n                    if (source != NULL) {\n                        Log::info(\"Processing an event\");\n                        source->process(mApplication, source);\n                    }\n                    // Application is getting destroyed.\n                    if (mApplication->destroyRequested) {\n                        Log::info(\"Exiting event loop\");\n                        return;\n                    }\n                }\n\n                // Steps the application.\n         if ((mEnabled) && (!mQuit)) {\n         if (mActivityHandler.onStep() != STATUS_OK) {\n         mQuit = true;\n         ANativeActivity_finish(mApplication->activity);\n                    }\n                }\n            }\n        }\n        ...\n        ```", "```kt\n    ...\n    void EventLoop::activate() {\n        // Enables activity only if a window is available.\n        if ((!mEnabled) && (mApplication->window != NULL)) {\n            mQuit = false; mEnabled = true;\n            if (mActivityHandler.onActivate() != STATUS_OK) {\n                goto ERROR;\n            }\n        }\n        return;\n\n    ERROR:\n        mQuit = true;\n        deactivate();\n        ANativeActivity_finish(mApplication->activity);\n    }\n\n    void EventLoop::deactivate() {\n        if (mEnabled) {\n            mActivityHandler.onDeactivate();\n            mEnabled = false;\n        }\n    }\n    ...\n    ```", "```kt\n        ...\n        void EventLoop::callback_appEvent(android_app* pApplication,\n            int32_t pCommand) {\n            EventLoop& eventLoop = *(EventLoop*) pApplication->userData;\n            eventLoop.processAppEvent(pCommand);\n        }\n        ...\n        ```", "```kt\n    ...\n    void EventLoop::processAppEvent(int32_t pCommand) {\n        switch (pCommand) {\n        case APP_CMD_CONFIG_CHANGED:\n            mActivityHandler.onConfigurationChanged();\n            break;\n        case APP_CMD_INIT_WINDOW:\n            mActivityHandler.onCreateWindow();\n            break;\n        case APP_CMD_DESTROY:\n            mActivityHandler.onDestroy();\n            break;\n        case APP_CMD_GAINED_FOCUS:\n            activate();\n            mActivityHandler.onGainFocus();\n            break;\n        case APP_CMD_LOST_FOCUS:\n            mActivityHandler.onLostFocus();\n            deactivate();\n            break;\n        case APP_CMD_LOW_MEMORY:\n            mActivityHandler.onLowMemory();\n            break;\n        case APP_CMD_PAUSE:\n            mActivityHandler.onPause();\n            deactivate();\n            break;\n        case APP_CMD_RESUME:\n            mActivityHandler.onResume();\n            break;\n        case APP_CMD_SAVE_STATE:\n            mActivityHandler.onSaveInstanceState(\n               &mApplication->savedState, &mApplication->savedStateSize);\n              break;\n        case APP_CMD_START:\n            mActivityHandler.onStart();\n            break;\n        case APP_CMD_STOP:\n            mActivityHandler.onStop();\n            break;\n        case APP_CMD_TERM_WINDOW:\n            mActivityHandler.onDestroyWindow();\n            deactivate();\n            break;\n        default:\n            break;\n        }\n    }\n    ```", "```kt\n    #ifndef _PACKT_DROIDBLASTER_HPP_\n    #define _PACKT_DROIDBLASTER_HPP_\n\n    #include \"ActivityHandler.hpp\"\n    #include \"EventLoop.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n    public:\n        DroidBlaster(android_app* pApplication);\n        void run();\n\n    protected:\n        status onActivate();\n        void onDeactivate();\n        status onStep();\n\n        void onStart();\n        ...\n\n    private:\n        EventLoop mEventLoop;\n    };\n    #endif\n    ```", "```kt\n    #include \"DroidBlaster.hpp\"\n    #include \"Log.hpp\"\n\n    #include <unistd.h>\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mEventLoop(pApplication, *this) {\n        Log::info(\"Creating DroidBlaster\");\n    }\n\n    void DroidBlaster::run() {\n        mEventLoop.run();\n    }\n\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n        return STATUS_OK;\n    }\n\n    void DroidBlaster::onDeactivate() {\n        Log::info(\"Deactivating DroidBlaster\");\n    }\n\n    status DroidBlaster::onStep() {\n        Log::info(\"Starting step\");\n        usleep(300000);\n        Log::info(\"Stepping done\");\n        return STATUS_OK;\n    }\n\n    void DroidBlaster::onStart() {\n        Log::info(\"onStart\");\n    }\n    ...\n    ```", "```kt\n    #include \"DroidBlaster.hpp\"\n    #include \"EventLoop.hpp\"\n    #include \"Log.hpp\"\n\n    void android_main(android_app* pApplication) {\n        DroidBlaster(pApplication).run();\n    }\n    ```", "```kt\n    #ifndef _PACKT_TYPES_HPP_\n    #define _PACKT_TYPES_HPP_\n    ...\n    struct Location {\n     Location(): x(0.0f), y(0.0f) {};\n\n        float x; float y;\n    };\n\n    #define RAND(pMax) (float(pMax) * float(rand()) / float(RAND_MAX))\n    #endif\n    ```", "```kt\n    #ifndef _PACKT_GRAPHICSMANAGER_HPP_\n    #define _PACKT_GRAPHICSMANAGER_HPP_\n\n    #include \"Types.hpp\"\n\n    #include <android_native_app_glue.h>\n\n    struct GraphicsElement {\n        GraphicsElement(int32_t pWidth, int32_t pHeight):\n            location(),\n            width(pWidth), height(pHeight) {\n        }\n\n        Location location;\n        int32_t width;  int32_t height;\n    };\n    ...\n    ```", "```kt\n        ...\n        class GraphicsManager {\n        public:\n            GraphicsManager(android_app* pApplication);\n            ~GraphicsManager();\n\n            int32_t getRenderWidth() { return mRenderWidth; }\n            int32_t getRenderHeight() { return mRenderHeight; }\n\n            GraphicsElement* registerElement(int32_t pHeight, int32_t pWidth);\n\n            status start();\n            status update();\n\n        private:\n            android_app* mApplication;\n\n            int32_t mRenderWidth; int32_t mRenderHeight;\n            GraphicsElement* mElements[1024]; int32_t mElementCount;\n        };\n        #endif\n        ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mRenderWidth(0), mRenderHeight(0),\n        mElements(), mElementCount(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n\n    GraphicsManager::~GraphicsManager() {\n        Log::info(\"Destroying GraphicsManager.\");\n        for (int32_t i = 0; i < mElementCount; ++i) {\n            delete mElements[i];\n        }\n    }\n\n    GraphicsElement* GraphicsManager::registerElement(int32_t pHeight,\n            int32_t pWidth) {\n        mElements[mElementCount] = new GraphicsElement(pHeight, pWidth);\n        return mElements[mElementCount++];\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::start() {\n        Log::info(\"Starting GraphicsManager.\");\n\n        // Forces 32 bits format.\n        ANativeWindow_Buffer windowBuffer;\n        if (ANativeWindow_setBuffersGeometry(mApplication->window, 0, 0,\n            WINDOW_FORMAT_RGBX_8888) < 0) {\n            Log::error(\"Error while setting buffer geometry.\");\n            return STATUS_KO;\n        }\n\n        // Needs to lock the window buffer to get its properties.\n        if (ANativeWindow_lock(mApplication->window,\n                &windowBuffer, NULL) >= 0) {\n            mRenderWidth = windowBuffer.width;\n            mRenderHeight = windowBuffer.height;\n            ANativeWindow_unlockAndPost(mApplication->window);\n        } else {\n            Log::error(\"Error while locking window.\");\n            return STATUS_KO;\n        }\n        return STATUS_OK;\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::update() {\n        // Locks the window buffer and draws on it.\n        ANativeWindow_Buffer windowBuffer;\n        if (ANativeWindow_lock(mApplication->window,\n                &windowBuffer, NULL) < 0) {\n            Log::error(\"Error while starting GraphicsManager\");\n            return STATUS_KO;\n        }\n\n        // Clears the window.\n        memset(windowBuffer.bits, 0, windowBuffer.stride *\n                windowBuffer.height * sizeof(uint32_t*));\n    ...\n    ```", "```kt\n        ...\n            // Renders graphic elements.\n            int32_t maxX = windowBuffer.width - 1;\n            int32_t maxY = windowBuffer.height - 1;\n            for (int32_t i = 0; i < mElementCount; ++i) {\n                GraphicsElement* element = mElements[i];\n\n                // Computes coordinates.\n                int32_t leftX = element->location.x - element->width / 2;\n                int32_t rightX = element->location.x + element->width / 2;\n                int32_t leftY = windowBuffer.height - element->location.y\n                                    - element->height / 2;\n                int32_t rightY = windowBuffer.height - element->location.y\n                                    + element->height / 2;\n\n                // Clips coordinates.\n                if (rightX < 0 || leftX > maxX\n                 || rightY < 0 || leftY > maxY) continue;\n\n                if (leftX < 0) leftX = 0;\n                else if (rightX > maxX) rightX = maxX;\n                if (leftY < 0) leftY = 0;\n                else if (rightY > maxY) rightY = maxY;\n        ...\n        ```", "```kt\n    ...\n            // Draws a rectangle.\n            uint32_t* line = (uint32_t*) (windowBuffer.bits)\n                            + (windowBuffer.stride * leftY);\n            for (int iY = leftY; iY <= rightY; iY++) {\n                for (int iX = leftX; iX <= rightX; iX++) {\n                    line[iX] = 0X000000FF; // Red color\n                }\n                line = line + windowBuffer.stride;\n            }\n        }\n    ...\n    ```", "```kt\n    ...\n        // Finshed drawing.\n        ANativeWindow_unlockAndPost(mApplication->window);\n        return STATUS_OK;\n    }\n    ```", "```kt\n    #ifndef _PACKT_SHIP_HPP_\n    #define _PACKT_SHIP_HPP_\n\n    #include \"GraphicsManager.hpp\"\n\n    class Ship {\n    public:\n        Ship(android_app* pApplication,\n             GraphicsManager& pGraphicsManager);\n\n        void registerShip(GraphicsElement* pGraphics);\n\n        void initialize();\n\n    private:\n        GraphicsManager& mGraphicsManager;\n\n        GraphicsElement* mGraphics;\n    };\n    #endif\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Ship.hpp\"\n    #include \"Types.hpp\"\n\n    static const float INITAL_X = 0.5f;\n    static const float INITAL_Y = 0.25f;\n\n    Ship::Ship(android_app* pApplication,\n            GraphicsManager& pGraphicsManager) :\n      mGraphicsManager(pGraphicsManager),\n      mGraphics(NULL) {\n    }\n\n    void Ship::registerShip(GraphicsElement* pGraphics) {\n        mGraphics = pGraphics;\n    }\n\n    void Ship::initialize() {\n        mGraphics->location.x = INITAL_X\n                * mGraphicsManager.getRenderWidth();\n        mGraphics->location.y = INITAL_Y\n                * mGraphicsManager.getRenderHeight();\n    }\n    ```", "```kt\n    ...\n    #include \"ActivityHandler.hpp\"\n    #include \"EventLoop.hpp\"\n    #include \"GraphicsManager.hpp\"\n    #include \"Ship.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        ...\n\n        GraphicsManager mGraphicsManager;\n        EventLoop mEventLoop;\n\n        Ship mShip;\n    };\n    #endif\n    ```", "```kt\n    ...\n    static const int32_t SHIP_SIZE = 64;\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n     mGraphicsManager(pApplication),\n     mEventLoop(pApplication, *this),\n\n     mShip(pApplication, mGraphicsManager) {\n        Log::info(\"Creating DroidBlaster\");\n\n        GraphicsElement* shipGraphics = mGraphicsManager.registerElement(\n     SHIP_SIZE, SHIP_SIZE);\n     mShip.registerShip(shipGraphics);\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return     STATUS_KO;\n\n     mShip.initialize();\n\n        return STATUS_OK;\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onStep() {\n        return mGraphicsManager.update();\n    }\n    ```", "```kt\nint32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window, int32_t width, int32_t height, int32_t format);\n```", "```kt\n    int32_t ANativeWindow_lock(ANativeWindow* window, ANativeWindow_Buffer* outBuffer,\n            ARect* inOutDirtyBounds);\n    ```", "```kt\n    int32_t ANativeWindow_unlockAndPost(ANativeWindow* window);\n    ```", "```kt\n    void ANativeWindow_acquire(ANativeWindow* window);\n    ```", "```kt\n    ANativeWindow* ANativeWindow_fromSurface(JNIEnv* env, jobject surface);\n    ```", "```kt\n    void ANativeWindow_release(ANativeWindow* window);\n    ```", "```kt\n    int32_t ANativeWindow_getWidth(ANativeWindow* window);\n    int32_t ANativeWindow_getHeight(ANativeWindow* window);\n    int32_t ANativeWindow_getFormat(ANativeWindow* window);\n    ```", "```kt\n        #ifndef _PACKT_TIMEMANAGER_HPP_\n        #define _PACKT_TIMEMANAGER_HPP_\n\n        #include \"Types.hpp\"\n\n        #include <ctime>\n\n        class TimeManager {\n        public:\n            TimeManager();\n\n            void reset();\n            void update();\n\n            double now();\n            float elapsed() { return mElapsed; };\n            float elapsedTotal() { return mElapsedTotal; };\n\n        private:\n            double mFirstTime;\n            double mLastTime;\n            float mElapsed;\n            float mElapsedTotal;\n        };\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"TimeManager.hpp\"\n\n    #include <cstdlib>\n    #include <time.h>\n\n    TimeManager::TimeManager():\n        mFirstTime(0.0f),\n        mLastTime(0.0f),\n        mElapsed(0.0f),\n        mElapsedTotal(0.0f) {\n        srand(time(NULL));\n    }\n\n    void TimeManager::reset() {\n        Log::info(\"Resetting TimeManager.\");\n        mElapsed = 0.0f;\n        mFirstTime = now();\n        mLastTime = mFirstTime;\n    }\n    ...\n    ```", "```kt\n        ...\n        void TimeManager::update() {\n        \tdouble currentTime = now();\n        \tmElapsed = (currentTime - mLastTime);\n        \tmElapsedTotal = (currentTime - mFirstTime);\n        \tmLastTime = currentTime;\n        }\n        ...\n        ```", "```kt\n    ...\n    double TimeManager::now() {\n        timespec timeVal;\n        clock_gettime(CLOCK_MONOTONIC, &timeVal);\n        return timeVal.tv_sec + (timeVal.tv_nsec * 1.0e-9);\n    }\n    ```", "```kt\n    #ifndef PACKT_PHYSICSMANAGER_HPP\n    #define PACKT_PHYSICSMANAGER_HPP\n\n    #include \"GraphicsManager.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    struct PhysicsBody {\n        PhysicsBody(Location* pLocation, int32_t pWidth, int32_t pHeight):\n            location(pLocation),\n            width(pWidth), height(pHeight),\n            velocityX(0.0f), velocityY(0.0f) {\n        }\n\n        Location* location;\n        int32_t width; int32_t height;\n        float velocityX; float velocityY;\n    };\n    ...\n    ```", "```kt\n    ...\n    class PhysicsManager {\n    public:\n        PhysicsManager(TimeManager& pTimeManager,\n                GraphicsManager& pGraphicsManager);\n        ~PhysicsManager();\n\n        PhysicsBody* loadBody(Location& pLocation, int32_t pWidth,\n                int32_t pHeight);\n        void update();\n\n    private:\n        TimeManager& mTimeManager;\n        GraphicsManager& mGraphicsManager;\n\n        PhysicsBody* mPhysicsBodies[1024]; int32_t mPhysicsBodyCount;\n    };\n    #endif\n    ```", "```kt\n    #include \"PhysicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    PhysicsManager::PhysicsManager(TimeManager& pTimeManager,\n            GraphicsManager& pGraphicsManager) :\n      mTimeManager(pTimeManager), mGraphicsManager(pGraphicsManager),\n      mPhysicsBodies(), mPhysicsBodyCount(0) {\n        Log::info(\"Creating PhysicsManager.\");\n    }\n\n    PhysicsManager::~PhysicsManager() {\n        Log::info(\"Destroying PhysicsManager.\");\n        for (int32_t i = 0; i < mPhysicsBodyCount; ++i) {\n            delete mPhysicsBodies[i];\n        }\n    }\n\n    PhysicsBody* PhysicsManager::loadBody(Location& pLocation,\n            int32_t pSizeX, int32_t pSizeY) {\n        PhysicsBody* body = new PhysicsBody(&pLocation, pSizeX, pSizeY);\n        mPhysicsBodies[mPhysicsBodyCount++] = body;\n        return body;\n    }\n    ...\n    ```", "```kt\n    ...\n    void PhysicsManager::update() {\n        float timeStep = mTimeManager.elapsed();\n        for (int32_t i = 0; i < mPhysicsBodyCount; ++i) {\n            PhysicsBody* body = mPhysicsBodies[i];\n            body->location->x += (timeStep * body->velocityX);\n            body->location->y += (timeStep * body->velocityY);\n        }\n    }\n    ```", "```kt\n        #ifndef _PACKT_ASTEROID_HPP_\n        #define _PACKT_ASTEROID_HPP_\n\n        #include \"GraphicsManager.hpp\"\n        #include \"PhysicsManager.hpp\"\n        #include \"TimeManager.hpp\"\n        #include \"Types.hpp\"\n\n        class Asteroid {\n        public:\n            Asteroid(android_app* pApplication,\n                TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,\n                PhysicsManager& pPhysicsManager);\n\n            void registerAsteroid(Location& pLocation, int32_t pSizeX,\n                    int32_t pSizeY);\n\n            void initialize();\n            void update();\n\n        private:\n            void spawn(PhysicsBody* pBody);\n\n            TimeManager& mTimeManager;\n            GraphicsManager& mGraphicsManager;\n            PhysicsManager& mPhysicsManager;\n\n            PhysicsBody* mBodies[1024]; int32_t mBodyCount;\n            float mMinBound;\n            float mUpperBound; float mLowerBound;\n            float mLeftBound; float mRightBound;\n        };\n        #endif\n        ```", "```kt\n    #include \"Asteroid.hpp\"\n    #include \"Log.hpp\"\n\n    static const float BOUNDS_MARGIN = 128;\n    static const float MIN_VELOCITY = 150.0f, VELOCITY_RANGE = 600.0f;\n\n    Asteroid::Asteroid(android_app* pApplication,\n            TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,\n            PhysicsManager& pPhysicsManager) :\n        mTimeManager(pTimeManager),\n        mGraphicsManager(pGraphicsManager),\n        mPhysicsManager(pPhysicsManager),\n        mBodies(), mBodyCount(0),\n        mMinBound(0.0f),\n        mUpperBound(0.0f), mLowerBound(0.0f),\n        mLeftBound(0.0f), mRightBound(0.0f) {\n    }\n\n    void Asteroid::registerAsteroid(Location& pLocation,\n            int32_t pSizeX, int32_t pSizeY) {\n        mBodies[mBodyCount++] = mPhysicsManager.loadBody(pLocation,\n                pSizeX, pSizeY);\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::initialize() {\n        mMinBound = mGraphicsManager.getRenderHeight();\n        mUpperBound = mMinBound * 2;\n        mLowerBound = -BOUNDS_MARGIN;\n        mLeftBound = -BOUNDS_MARGIN;\n        mRightBound = (mGraphicsManager.getRenderWidth() + BOUNDS_MARGIN);\n\n        for (int32_t i = 0; i < mBodyCount; ++i) {\n            spawn(mBodies[i]);\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::update() {\n        for (int32_t i = 0; i < mBodyCount; ++i) {\n            PhysicsBody* body = mBodies[i];\n            if ((body->location->x < mLeftBound)\n             || (body->location->x > mRightBound)\n             || (body->location->y < mLowerBound)\n             || (body->location->y > mUpperBound)) {\n                spawn(body);\n            }\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::spawn(PhysicsBody* pBody) {\n        float velocity = -(RAND(VELOCITY_RANGE) + MIN_VELOCITY);\n        float posX = RAND(mGraphicsManager.getRenderWidth());\n        float posY = RAND(mGraphicsManager.getRenderHeight())\n                      + mGraphicsManager.getRenderHeight();\n\n        pBody->velocityX = 0.0f;\n        pBody->velocityY = velocity;\n        pBody->location->x = posX;\n        pBody->location->y = posY;\n    }\n    ```", "```kt\n    #ifndef _PACKT_DROIDBLASTER_HPP_\n    #define _PACKT_DROIDBLASTER_HPP_\n\n    #include \"ActivityHandler.hpp\"\n    #include \"Asteroid.hpp\"\n    #include \"EventLoop.hpp\"\n    #include \"GraphicsManager.hpp\"\n    #include \"PhysicsManager.hpp\"\n    #include \"Ship.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        TimeManager     mTimeManager;\n        GraphicsManager mGraphicsManager;\n        PhysicsManager  mPhysicsManager;\n        EventLoop mEventLoop;\n\n        Asteroid mAsteroids;\n        Ship mShip;\n    };\n    #endif\n    ```", "```kt\n    ...\n    static const int32_t SHIP_SIZE = 64;\n    static const int32_t ASTEROID_COUNT = 16;\n    static const int32_t ASTEROID_SIZE = 64;\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mTimeManager(),\n        mGraphicsManager(pApplication),\n        mPhysicsManager(mTimeManager, mGraphicsManager),\n        mEventLoop(pApplication, *this),\n\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n     mPhysicsManager),\n        mShip(pApplication, mGraphicsManager) {\n        Log::info(\"Creating DroidBlaster\");\n\n        GraphicsElement* shipGraphics = mGraphicsManager.registerElement(\n                SHIP_SIZE, SHIP_SIZE);\n        mShip.registerShip(shipGraphics);\n\n        for (int32_t i = 0; i < ASTEROID_COUNT; ++i) {\n     GraphicsElement* asteroidGraphics =\n     mGraphicsManager.registerElement(ASTEROID_SIZE,\n     ASTEROID_SIZE);\n     mAsteroids.registerAsteroid(\n     asteroidGraphics->location, ASTEROID_SIZE,\n     ASTEROID_SIZE);\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n\n        mAsteroids.initialize();\n        mShip.initialize();\n\n        mTimeManager.reset();\n        return STATUS_OK;\n    }\n    ...\n    Finally, update managers and components for each game step:\n    ...\n    status DroidBlaster::onStep() {\n        mTimeManager.update();\n        mPhysicsManager.update();\n\n        mAsteroids.update();\n\n        return mGraphicsManager.update();\n    }\n    ...\n    ```", "```kt\ndouble TimeManager::now() {\n    timeval lTimeVal;\n    gettimeofday(&lTimeVal, NULL);\n    return (lTimeVal.tv_sec * 1000.0) + (lTimeVal.tv_usec / 1000.0);\n}\n```"]