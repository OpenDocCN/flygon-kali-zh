- en: Chapter 2. Getting Started with Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开始使用Android
- en: In this chapter, we will take a roller coaster ride through all the Android
    topics that you need to learn in order to get started with Java. It won't just
    be theoretical though. We will be designing a **user interface** (**UI**) of a
    game menu and we will see and edit our first Java code as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过所有Android主题的过山车之旅，这些主题是您需要学习的，以便开始学习Java。不过，这不仅仅是理论。我们将设计一个游戏菜单的**用户界面**（**UI**），并且我们还将看到并编辑我们的第一行Java代码。
- en: In addition, we will see how we can run our apps in either an Android emulator
    on our PC/Mac or on a real Android device if we have one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将看到如何在PC/Mac上的Android模拟器或者如果有的话在真实的Android设备上运行我们的应用程序。
- en: Some of what we will cover in this chapter will be the tip of the iceberg. That
    is, there is a lot more below the surface to some of the topics we discuss than
    would be appropriate for the second chapter of a learning Java book. Sometimes,
    we might need to take a bit of information on faith.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的一些内容只是冰山一角。也就是说，我们讨论的一些主题下面有更多的内容，这些内容不适合于学习Java书籍的第二章。有时，我们可能需要相信一些信息。
- en: This will then enable us to actually design and run our very own Android app
    by the end of this chapter. Then we can start learning Java for real at the beginning
    of the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在本章结束时实际设计和运行我们自己的Android应用程序。然后我们可以在下一章的开始学习真正的Java。
- en: If this chapter seems a little tough, then don't worry; keep going because each
    subsequent chapter lifts the lid a bit more from some of the less clear topics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本章看起来有点困难，那么不要担心；继续前进，因为每个后续章节都会逐渐揭开一些不太清晰的主题。
- en: For this chapter and the next two, we will be building a math game. We will
    start simply and by the end of [Chapter 4](ch04.xhtml "Chapter 4. Discovering
    Loops and Methods"), *Discovering Loops and Methods*, we will scale to game features
    that use significant Java skills.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的两章中，我们将构建一个数学游戏。我们将从简单开始，到[第4章](ch04.xhtml "第4章。发现循环和方法")结束时，*发现循环和方法*，我们将扩展到使用重要的Java技能的游戏功能。
- en: 'In this chapter, we will:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Start our first game project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始我们的第一个游戏项目
- en: Explore Android Studio
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Android Studio
- en: Use the Android Studio visual designer to make our game UI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android Studio可视化设计器制作我们的游戏UI
- en: Learn about structuring our code for Android
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为Android构建代码的结构
- en: Take our first look at some Java code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次查看一些Java代码
- en: Build and install our game on an emulator and a real device
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟器和真实设备上构建和安装我们的游戏
- en: Our first game project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个游戏项目
- en: Now we will get straight down to actually doing something with Android Studio.
    Run Android Studio by double-clicking on the Android Studio icon either on your
    desktop's start menu or in the folder where you installed it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将直接开始使用Android Studio。通过双击桌面的开始菜单上的Android Studio图标，或者在安装它的文件夹中双击Android
    Studio图标来运行Android Studio。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you get any errors in a dialog box mentioning **Privilege elevation**, then
    try running Android Studio with administrator privileges. To do this, find the
    Android Studio icon by clicking on the Windows **Start** button and searching
    for **Android Studio**. Now right-click on the icon and click on **Run as administrator**.
    Do this every time you run Android Studio.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在对话框中收到任何提到**权限提升**的错误，请尝试以管理员权限运行Android Studio。要做到这一点，通过单击Windows **开始**按钮并搜索**Android
    Studio**来找到Android Studio图标。现在右键单击该图标，然后单击**以管理员身份运行**。每次运行Android Studio时都要这样做。
- en: Preparing Android Studio
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Android Studio
- en: 'So with Android Studio and Java installed, we just need to add the latest versions
    of the Android API that we will use to make our first game. Here is what to do
    to install the API:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，安装了Android Studio和Java后，我们只需要添加我们将用于制作第一个游戏的最新版本的Android API。以下是安装API的步骤：
- en: From the menu bar at the top of the Android Studio UI, navigate to **Tools**
    | **Android** | **SDK Manager**. Scroll down in the **Android SDK Manager** window
    and select the checkbox for **Android 4.4.2 (API 19)**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Android Studio UI顶部的菜单栏，导航到**工具** | **Android** | **SDK管理器**。在**Android SDK管理器**窗口中向下滚动，并选择**Android
    4.4.2 (API 19)**的复选框。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that because Android is evolving so quickly, by the time you read this
    chapter, there might be APIs newer than 19—20, 21, and so on. If this is the case
    for you, select the newer (higher numbered) API instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于Android发展如此迅速，当您阅读本章时，可能会有比19更高的API，如20、21等。如果您遇到这种情况，请选择更新的（编号更高的）API。
- en: '![Preparing Android Studio](img/8859OS_02_21.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![准备Android Studio](img/8859OS_02_21.jpg)'
- en: Click on **Install Packages**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装软件包**。
- en: On the next screen, click on the **Accept license** checkbox and then click
    on the **Install** button. Android Studio will download and install the appropriate
    packages.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，点击**接受许可证**复选框，然后点击**安装**按钮。Android Studio将下载并安装适当的软件包。
- en: What we just did was setting up Android Studio to make available the latest,
    prewritten code called an API that we will interact with throughout the book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才所做的是设置Android Studio，以便提供最新的预写代码，称为API，我们将在整本书中与之交互。
- en: Building the project
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: Click on **New Project...** as indicated in the following screenshot:![Building
    the project](img/8859OS_02_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新项目...**，如下面的屏幕截图所示：![构建项目](img/8859OS_02_01.jpg)
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field with `Math Game Chapter 2` and **Company Domain** with `packtpub.com`
    (or you could use your own company website name here), as shown in the following
    screenshot:![Building the project](img/8859OS_02_18.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建新项目**配置窗口将出现。在**应用程序名称**字段中填写`Math Game Chapter 2`，在**公司域**中填写`packtpub.com`（或者您可以在此处使用您自己公司的网站名称），如下面的屏幕截图所示：![构建项目](img/8859OS_02_18.jpg)'
- en: 'Now click on the **Next** button. On the next screen, check that the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select, the fewer are the cutting-edge
    Android features available in our apps. A good balance is to select **API 8: Android
    2.2 (Froyo)**. Go ahead and do that now as shown in the next screenshot:![Building
    the project](img/8859OS_02_19.jpg)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**下一步**按钮。在下一个屏幕上，检查**手机和平板电脑**复选框是否被选中。现在我们必须选择要为其构建应用程序的最早版本的Android。随意在下拉选择器中尝试几个选项。您会发现我们选择的版本越早，我们的应用程序支持的设备百分比就越大。然而，这里的权衡是，我们选择的版本越早，我们的应用程序中可用的尖端Android功能就越少。一个很好的平衡是选择**API
    8：Android 2.2（Froyo）**。现在就像下一个截图中所示那样去做吧：![构建项目](img/8859OS_02_19.jpg)
- en: Click on **Next**. Now select **Blank Activity** as shown in the next screenshot
    and click on **Next** again:![Building the project](img/8859OS_02_20.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**。现在如下截图所示选择**空白活动**，然后再次点击**下一步**：![构建项目](img/8859OS_02_20.jpg)
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，只需将**Activity Name**更改为`MainActivity`，然后点击**完成**。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, Android Studio shows a **Tip of the day** dialog every time it starts.
    Some of the tips might not make sense while you are still learning Java but many
    of them are really useful and reveal great shortcuts and other time savers. It
    is well worth taking a few seconds to read them when they show up. As already
    discussed, Android Studio is built from IntelliJ IDEA, and you can find a complete
    list of keyboard shortcuts at [http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html](http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android Studio在每次启动时都会显示一个“每日提示”对话框。在您还在学习Java时，一些提示可能没有意义，但其中许多确实非常有用，并揭示了很多快捷方式和其他节省时间的方法。当它们出现时，花几秒钟时间阅读它们是非常值得的。正如已经讨论过的，Android
    Studio是从IntelliJ IDEA构建的，您可以在[http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html](http://www.jetbrains.com/idea/webhelp/keyboard-shortcuts-you-cannot-miss.html)找到完整的键盘快捷键列表。
- en: Clear **Tip of the day** by clicking on **Close**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**关闭**清除**每日提示**。
- en: If you are completely new to programming, then the code, options, and files
    might seem a bit daunting. Don't worry; stick to them as we don't need to concern
    ourselves with most of them in order to learn Java. When the time does come to
    interact with the finer details, we will do things one step at a time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是完全新手，那么代码、选项和文件可能看起来有点令人生畏。不要担心；在学习Java时，我们不需要关注它们中的大部分。当与更细节的东西互动的时候，我们将一步一步地进行。
- en: It might be hard to believe that at this stage, but we have just created our
    first working app. We could build and run it on an Android device, and soon we
    will.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也许很难相信，但我们刚刚创建了我们的第一个可工作的应用程序。我们可以在Android设备上构建和运行它，很快我们就会。
- en: Let's take a deeper look at Android Studio before we progress with our game.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行游戏之前，让我们深入了解一下Android Studio。
- en: Exploring Android Studio
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Android Studio
- en: Android Studio is a very deep tool, but it is only necessary to learn one part
    at a time in order to get started. What might be useful for us is naming a few
    parts of the UI so that we can refer to them easily as we progress through the
    book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是一个非常深入的工具，但只需要逐步学习其中的一部分就可以开始。对我们可能有用的是给UI的一些部分命名，这样在阅读本书时可以更容易地参考它们。
- en: Take a look at this numbered diagram and a quick explanation of some of the
    key parts of Android Studio. If you can, try and memorize the parts to make future
    discussions of them easier for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个编号的图表，以及对Android Studio一些关键部分的快速解释。如果可以的话，尽量记住这些部分，以便将来更容易地讨论它们。
- en: '![Exploring Android Studio](img/8859OS_02_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![探索Android Studio](img/8859OS_02_04.jpg)'
- en: Here is a handy table that you can quickly refer to and remember which part
    of Android Studio we are referring to. What follows is a more detailed explanation
    of each area.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的表格，您可以快速参考并记住我们正在提到的Android Studio的哪个部分。接下来是对每个区域的更详细的解释。
- en: '| Number | Name |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 名称 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Project Explorer |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 项目资源管理器 |'
- en: '| 2 | The editor |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 编辑器 |'
- en: '| 3 | Menu bar |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 菜单栏 |'
- en: '| 4 | Toolbar |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 工具栏 |'
- en: '| 5 | Navigation bar |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 导航栏 |'
- en: '| 6 | Important tool windows |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 重要的工具窗口 |'
- en: '**Project Explorer** (**1**): This is shown as **1** in the screenshot and
    is a bit like Windows Explorer. It shows us all the files and folders that have
    been generated for our project. We will do a number of things from here as the
    book continues. Actually, if you delve into the files and folders that Android
    Studio creates, the Project Explorer is not an exact mapping. It is slightly simplified
    and highlighted to make managing and exploring our project easier.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目资源管理器**（**1**）：这在截图中显示为**1**，有点像Windows资源管理器。它显示了为我们的项目生成的所有文件和文件夹。随着本书的继续，我们将从这里做很多事情。实际上，如果您深入研究Android
    Studio创建的文件和文件夹，项目资源管理器并不是一个精确的映射。它稍微简化并突出显示，以便更轻松地管理和探索我们的项目。'
- en: '**The Editor** (**2**): As the name suggests, we will edit our Java code files
    here in the editor. However, as we will soon see, the **Editor** window changes
    depending on the type of file we are editing. We will also be viewing and editing
    UI designs here.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**（**2**）：顾名思义，我们将在编辑器中编辑我们的Java代码文件。但是，正如我们很快将看到的，**编辑器**窗口会根据我们正在编辑的文件类型而发生变化。我们还将在这里查看和编辑UI设计。'
- en: '**Menu bar** (**3**): Like most programs, the **Menu** bar gives us access
    to the full functionality of Android Studio.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单栏**（**3**）：像大多数程序一样，**菜单**栏为我们提供了访问Android Studio全部功能的途径。'
- en: '**Tool bar** (**4**): This contains lots of really useful one-click options
    to do things such as deploying and debugging our games. Hover the mouse cursor
    over an icon to get a pop-up tip and gain greater insight into each toolbar icon.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**（**4**）：这包含了许多非常有用的一键选项，可以执行诸如部署和调试游戏等操作。将鼠标悬停在图标上，以获得弹出提示，并更深入地了解每个工具栏图标。'
- en: '**Navigation bar** (**5**): Like a file path, this shows exactly where the
    file that is currently in the editor is located within the project.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航栏**（**5**）：就像文件路径一样，它显示了当前在编辑器中的文件在项目中的位置。'
- en: '**Important tool windows** (**6**): These are a number of tabs that can be
    popped up and popped down again by clicking on them. If you like, try some of
    them now to see how they work.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重要的工具窗口**（**6**）：这是一些选项卡，可以通过单击弹出并再次单击关闭。如果愿意，现在可以尝试一些选项卡，看看它们是如何工作的。'
- en: Let's talk a bit more about the parts of the Android Studio UI and how the editor
    window can transform itself into a visual UI designer. After that, when we are
    familiar enough, we will look at building a simple menu screen for our math game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地谈谈Android Studio UI的各个部分，以及编辑窗口如何转变为可视化UI设计师。之后，当我们足够熟悉时，我们将看看为我们的数学游戏构建一个简单的菜单屏幕。
- en: Using the Android Studio visual designer
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android Studio可视化设计师
- en: The Android Studio editor window is a very dynamic area. It presents different
    file types in the most useful way possible. A little earlier, when we created
    our project, it also made a basic UI for us. UIs in Android can be built-in Java
    code or, as we will see, in a visual designer without the need for a single line
    of Java. However, as we will investigate after we have built the UI of our game
    menu, to get the UI to do anything useful, we need to interact with it. This interaction
    is always done with Java code. The visual designer also generates the UI code
    for us. We will take a very quick look at that too.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio编辑器窗口是一个非常动态的区域。它以最有用的方式呈现不同的文件类型。稍早一点，当我们创建项目时，它还为我们制作了一个基本的UI。在Android中，UI可以使用Java代码构建，或者，正如我们将看到的那样，在不需要一行Java代码的情况下使用可视化设计师。然而，正如我们在构建游戏菜单的UI之后将要调查的那样，要使UI做任何有用的事情，我们需要与之交互。这种交互总是通过Java代码完成的。可视化设计师还为我们生成UI代码。我们也会快速看一下那个。
- en: As the book progresses, we will mainly shy away from Android UI development,
    as that is a staple of more non-game apps. We will instead spend more time looking
    at directly drawing pixels and images to make our games. Nonetheless, the regular
    Android UI has its uses, and the Android Studio visual designer is the quickest
    way to get started.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着书籍的进展，我们将主要避开Android UI开发，因为这是更多非游戏应用的基本功能。相反，我们将花更多时间直接绘制像素和图像来制作我们的游戏。尽管如此，常规的Android
    UI也有其用途，而Android Studio可视化设计师是最快的入门方式。
- en: 'Let''s have a look at that now:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看：
- en: In the Android Studio Project Explorer, double-click on the `layout` folder
    to reveal the `activity_main.xml` file within it. This should be easy to see unless
    you have collapsed the directories. If you can't see the `layout` folder, navigate
    to it using the Project Explorer. It can be found at `Math Game Chapter2/src/main/res/layout`
    via the Android Studio Project Explorer, as shown in the following screenshot:![Using
    the Android Studio visual designer](img/8859OS_02_05.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio项目资源管理器中，双击`layout`文件夹，以显示其中的`activity_main.xml`文件。这应该很容易看到，除非您已经折叠了目录。如果看不到`layout`文件夹，请使用项目资源管理器导航到它。它可以在Android
    Studio项目资源管理器中找到，路径为`Math Game Chapter2/src/main/res/layout`，如下面的截图所示：![使用Android
    Studio可视化设计师](img/8859OS_02_05.jpg)
- en: Now double-click on **activity_main.xml** to open it in the editor window. After
    a brief loading time, you will see something very similar to the next screenshot.
    The following screenshot shows the entire contents of what previously contained
    just our code. As you can see, what was just a text window now has multiple parts.
    Let's take a closer look at this screenshot:![Using the Android Studio visual
    designer](img/8859OS_02_06.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在双击**activity_main.xml**以在编辑器窗口中打开它。加载一小段时间后，您将看到与下一个截图非常相似的东西。下一个截图显示了以前只包含我们代码的整个内容。正如您所看到的，以前只是一个文本窗口现在有了多个部分。让我们更仔细地看一下这个截图：
- en: In the preceding screenshot labeled (**1**), called **Palette**, you can choose
    from the available Android UI elements and simply click and drag them onto your
    UI design. Area (2) is the visual view of the UI you are building, where you will
    click and drag elements from the palette. To the right of the visual UI view,
    you will see the **Component Tree** area (3). The component tree allows you to
    examine the structure of the complex UI and select specific elements more easily.
    Under this tree is the **Properties** panel (4). Here you can adjust the properties
    of the currently selected UI element. These can be simple things such as color
    and size or much more advanced properties.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面标有（**1**）的截图中，称为**Palette**，您可以从可用的Android UI元素中进行选择，然后简单地点击并将它们拖放到您的UI设计中。区域（2）是您正在构建的UI的可视视图，您将从Palette中点击并拖动元素。在可视UI视图的右侧，您将看到**Component
    Tree**区域（3）。组件树允许您检查复杂UI的结构，并更轻松地选择特定元素。在此树下方是**Properties**面板（4）。在这里，您可以调整当前选定的UI元素的属性。这些可以是简单的东西，如颜色和大小，也可以是更高级的属性。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the tabs labelled (**5**). These tabs allow you to switch between the two
    main views that Android Studio provides for this type of layout file. These views,
    as you can see, are **Design** and **Text**. The design view is the default view
    and is shown in the previous screenshot. The text view also shows your under-construction
    UI, but it shows the code that has been autogenerated for us instead of the **Palette**
    element and the component tree.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意标有（**5**）的标签。这些标签允许您在Android Studio为此类型的布局文件提供的两个主要视图之间切换。正如您所看到的，这些视图是**Design**和**Text**。设计视图是默认视图，并且显示在前面的截图中。文本视图还显示您正在建设的UI，但它显示为我们自动生成的代码，而不是**Palette**元素和组件树。
- en: We don't need to worry about this code as it is all handled for us. It can be
    good to look on this tab from time to time so that we can begin to understand
    what the design tool generates for us. But it is not necessary to do this to learn
    Java. This code is called **eXtensible Markup Language** (**XML**).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心这段代码，因为它都是为我们处理的。不过，偶尔查看一下这个选项卡可能会有好处，这样我们就可以开始理解设计工具为我们生成的内容。但是，这并不是学习Java所必需的。这段代码称为**可扩展标记语言**（**XML**）。
- en: Take a quick look at the **Text** tab, click on the **Design** tab when you're
    done, and we will move on.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速查看**Text**选项卡，完成后点击**Design**选项卡，我们将继续。
- en: Now we have seen an overview of the visual designer and an even briefer glimpse
    of the automatically generated code that it generates for us. We can take a closer
    look at some of the actual UI elements that we will be using in our project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了可视设计师的概述，甚至还瞥见了它为我们生成的自动生成代码。我们可以更仔细地查看一些我们将在项目中使用的实际UI元素。
- en: Android UI types
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android UI类型
- en: We will now take a whirlwind tour of some really useful Android UI elements,
    a few key properties, and how to add them together to make a UI. These will introduce
    us to some of the possibilities as well as how to use them. We will then quickly
    use what we know to make our menu.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速浏览一些非常有用的Android UI元素，一些关键属性，以及如何将它们组合在一起制作UI。这些将为我们介绍一些可能性以及如何使用它们。然后我们将快速使用我们所知道的知识来制作我们的菜单。
- en: TextView
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextView
- en: On the visual UI area, click on the words **Hello world!**. What we have just
    selected is a widget known as a TextView. TextViews can be small text like this
    one or large heading type text, which might be useful in our game menu.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视UI区域，点击**Hello world!**。我们刚刚选择的是一个称为TextView的小部件。TextView可以是像这样的小文本，也可以是大标题类型的文本，在我们的游戏菜单中可能会有用。
- en: 'Let''s try dragging and dropping another TextView onto our visual UI:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将另一个TextView拖放到我们的可视UI上：
- en: Directly under the **Widgets** heading in our palette, you can see there are
    multiple types of TextView. They are presented in the palette as **Plain TextView**,
    **Large Text**, **Medium Text** and **Small Text**. Drag and drop a **Large Text**
    widget onto our visual design. Don't let go straightaway. As you drag it around
    the image of the phone, notice how Android Studio graphically shows you different
    positioning options. In the following screenshot, you can see what the designer
    looks like when the widget being dragged is positioned at the center:![TextView](img/8859OS_02_07.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的调色板中**Widgets**标题下方，您可以看到多种类型的TextView。它们在调色板中呈现为**普通TextView**、**大文本**、**中等文本**和**小文本**。将**大文本**小部件拖放到我们的可视设计中。不要立即放开。当您将其拖动到手机图像周围时，请注意Android
    Studio以图形方式显示不同的定位选项。在下一个屏幕截图中，您可以看到当被拖动的小部件位于中心时设计师的外观：![TextView](img/8859OS_02_07.jpg)
- en: Let go of the left mouse button where you want the widget to go. If you let
    go when it is positioned as shown in the previous screenshot, then the text will
    appear in the center as expected.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您想要小部件放置的位置松开鼠标左键。如果您在上一个屏幕截图中显示的位置放开，那么文本将如预期般出现在中心。
- en: Now we can play with the properties. In the **Properties** window, click just
    to the right of **textSize**. You might need to scroll to find it. Type `100sp`
    as the value and press the *Enter* key. Notice that the text gets much larger.
    We can refine the size of our text by increasing and decreasing the value entered
    here. The unit `sp` stands for scaled pixels, and is simply a measuring system
    that attempts to scale the text to an appropriate equivalent actual size across
    different screen densities.![TextView](img/8859OS_02_08.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以玩一下属性。在**Properties**窗口中，点击**textSize**右侧。您可能需要滚动查找。将值输入为`100sp`并按*Enter*键。注意文本变得更大。我们可以通过增加和减少在此处输入的值来调整文本的大小。单位`sp`代表缩放像素，只是一种尝试在不同屏幕密度下将文本缩放到适当的等效实际大小的测量系统。![TextView](img/8859OS_02_08.jpg)
- en: Play with some more properties if you like and when you're done, click on the
    TextView we just created in the visual designer to highlight it. Then tap on the
    *Delete* key to get rid of it. Now delete the TextView that was present when we
    started—the one that says **Hello world!**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你喜欢的话，可以玩一些更多的属性，完成后，点击我们在可视化设计中创建的TextView以突出显示它。然后点击*删除*键来摆脱它。现在删除我们开始时存在的TextView，上面写着**Hello
    world!**。
- en: Layout elements
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局元素
- en: Now you have an apparently empty screen. However, if you click anywhere on the
    design preview, you will see that we still have some options in the **Properties**
    window. This element is called a RelativeLayout. It is one of several layout element
    types provided as a base to control and align the layout widgets such as buttons,
    text, and so on. If you look at the top of the **Palette** window, you will see
    the main layout options. We will use this layout element when we actually build
    our game menu in a moment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个看似空白的屏幕。但是，如果您在设计预览中的任何位置单击，您将看到**Properties**窗口中仍然有一些选项。这个元素称为RelativeLayout。它是作为基础提供的几种布局元素类型之一，用于控制和对齐布局小部件，如按钮、文本等。如果您查看**Palette**窗口的顶部，您将看到主要的布局选项。我们将在稍后实际构建游戏菜单时使用此布局元素。
- en: ImageView widgets
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ImageView小部件
- en: 'ImageViews unsurprisingly are for displaying images. In the standard Android
    UI, this is a really quick way to add our designers'' artwork to our game:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ImageViews毫不奇怪地用于显示图像。在标准的Android UI中，这是一种快速将我们设计师的艺术品添加到我们的游戏中的方法：
- en: Drag and drop an **ImageView** element onto the design in the same way as you
    positioned the TextView a moment ago. The **ImageView** element can be found below
    the **Widgets** heading. Now position it centrally as before or play with the
    options by dragging it around the design. We will delete it in a minute; we are
    just having a bit of an exploration before we do this for real.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与刚才定位TextView相同的方式将**ImageView**元素拖放到设计中。**ImageView**元素可以在**Widgets**标题下方找到。现在将其放置在中心，或者通过拖动它在设计中玩一下选项。我们将在一会儿删除它；在真正删除之前，我们只是进行了一些探索。
- en: In the **Properties** window, select the **src** property in the same way as
    you selected the **textSize** property previously.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中，以与之前选择**textSize**属性相同的方式选择**src**属性。
- en: Notice that after you select it, you have the option to click on **...** to
    give you more options. Click on **...** and scroll to the bottom of the list of
    options. These are all the image files that we can display in this ImageView.
    Just for fun, scroll to the bottom of the list, choose **ic_launcher**, and click
    on **OK**. We can make any image we like available and this is a simple, powerful
    way to build an attractive game menu screen.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在选择后，您可以点击**...**以获得更多选项。点击**...**并滚动到选项列表的底部。这些都是我们可以在这个ImageView中显示的所有图像文件。只是为了好玩，滚动到列表的底部，选择**ic_launcher**，然后点击**确定**。我们可以使任何我们喜欢的图像可用，这是构建有吸引力的游戏菜单屏幕的一种简单而强大的方法。
- en: Change the **layout:width** property to `150dp` and the **layout:height** property
    to `150dp`. The unit **dp** is a way of sizing elements and widgets that remains
    relatively constant across devices with screens that have very different numbers
    of pixels.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**layout:width**属性更改为`150dp`，将**layout:height**属性更改为`150dp`。单位**dp**是一种在具有非常不同像素数量的屏幕设备上保持相对恒定的元素和小部件大小的方法。
- en: Delete the ImageView in exactly the same way as you deleted the other views
    previously.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与之前删除其他视图相同的方式删除ImageView。
- en: ButtonView
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ButtonView
- en: The use of ButtonView is probably given away by its name. Try to click and drag
    a few buttons onto our layout. Notice that there are a few types of ButtonView,
    such as **Small Button**, **Button**, and, if you look further down the **Widget**
    list, **ImageButton**. We will be using the regular ButtonView, labelled simply
    as **Button**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ButtonView的使用可能已经被它的名称泄露了。尝试在我们的布局上单击并拖动一些按钮。请注意，有几种类型的ButtonView，例如**小按钮**，**按钮**，以及，如果您在**小部件**列表中继续向下查看，**图像按钮**。我们将使用常规的ButtonView，简称为**按钮**。
- en: Now we will do something with each of these Android UI elements combined to
    make our game menu.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将对每个这些Android UI元素进行操作，以制作我们的游戏菜单。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the entire sample from the code download section of the book's
    companion website.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书配套网站的代码下载部分下载整个示例。
- en: Using the sample code
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例代码
- en: 'All of the code in this book is organized in projects. If a project spans more
    than one chapter, a project is provided for each chapter in its finished state.
    This helps you see the progression and not just the end result. All you need to
    do to open the project in Android Studio is explained as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码都是以项目形式组织的。如果一个项目跨越多个章节，那么每个章节都会提供一个已完成状态的项目。这有助于您看到进展，而不仅仅是最终结果。要在Android
    Studio中打开项目，只需按照以下说明操作：
- en: Download the code for this book.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载本书的代码。
- en: In **Android Studio** from the menu bar, navigate to **File** | **Close project**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Android Studio**中，从菜单栏导航到**文件** | **关闭项目**。
- en: Now create a new blank project as we did previously. Browse to where you downloaded
    the code for this book.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个新的空白项目，就像之前一样。浏览到您下载本书代码的位置。
- en: Navigate to the `Chapter2/MathGameChapter2` folder. Here you will find the code
    for all the files we create in this chapter.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Chapter2/MathGameChapter2`文件夹。在这里，您将找到本章中创建的所有文件的代码。
- en: Open the code files using a plain text editor such as the free Notepad++.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用诸如免费的Notepad++之类的纯文本编辑器打开代码文件。
- en: Copy and paste in your Android Studio project or just compare the code as you
    see it.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴到您的Android Studio项目中，或者只是按照您看到的代码进行比较。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although every line of code required in this book is supplied for your convenience,
    you still need to create each project for yourself through Android Studio. You
    can then simply copy and paste either the code in its entirety in the file with
    the matching name, or just the part of the code that you might be struggling with.
    Keep in mind that if you create a project with a different package name, then
    you must *omit* the line of code that is the package name from the supplied code
    files. The reasons for this will be clearer when we talk more about packages later
    in the chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书提供了所需的每一行代码，但您仍然需要通过Android Studio为自己创建每个项目。然后，您可以简单地将代码的全部内容复制并粘贴到具有匹配名称的文件中，或者只是将您可能遇到困难的代码部分复制并粘贴。请记住，如果您创建了一个具有不同包名称的项目，那么您必须从提供的代码文件中*省略*包名称的代码行。当我们在本章后面更多地谈论包时，这一点将更加清晰。
- en: Let's actually see how to do it all for ourselves.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们亲自看看如何做到这一切。
- en: Making our game menu
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作我们的游戏菜单
- en: For now we will just make our game menu functional. Later in [Chapter 5](ch05.xhtml
    "Chapter 5. Gaming and Java Essentials"), *Gaming and Java Essentials*,we will
    see how we can make it look good by adding some cool animation to make the menu
    more visually interesting and fun.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只是让我们的游戏菜单功能正常。稍后在[第5章](ch05.xhtml "第5章。游戏和Java基础")中，*游戏和Java基础*，我们将看到如何通过添加一些酷炫的动画来使菜单更具视觉吸引力和乐趣。
- en: 'Here is what we are aiming for in this tutorial:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本教程中我们的目标：
- en: '![Making our game menu](img/8859OS_02_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![制作我们的游戏菜单](img/8859OS_02_10.jpg)'
- en: 'Before you start coding, you should design your layouts on paper first. However,
    the Android Studio designer is so friendly there is a strong argument, especially
    for simple layouts, to refine your design actually in the layout designer. Perform
    the following steps to create the game menu:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您应该先在纸上设计您的布局。但是，Android Studio的设计师非常友好，特别是对于简单的布局，有很强的论点，可以在布局设计师中实际完善您的设计。执行以下步骤创建游戏菜单：
- en: Delete all widgets from your designer by clicking on them one at a time and
    then tapping the *Delete* key on each in turn. Be careful not to delete the **RelativeLayout**
    layout element as we are going to use it as a base for all the other elements.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过依次单击它们然后依次点击*删除*键，从设计师中删除所有小部件。注意不要删除**RelativeLayout**布局元素，因为我们将把它用作所有其他元素的基础。
- en: Click and drag a **Large Text** element from the palette to the top center of
    the design area and give it the following properties. Remember that you can change
    properties in the **Properties** panel by clicking to the right of the property
    to be changed. Change the **text** property to `My Math Game` and **size** to
    `30sp`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从面板中拖动一个**Large Text**元素到设计区域的顶部中心，并赋予它以下属性。请记住，您可以通过单击要更改的属性右侧来在**Properties**面板中更改属性。将**text**属性更改为`My
    Math Game`，**size**更改为`30sp`。
- en: Click and drag an **ImageView** element from the palette to the center of the
    design, slightly below the previous TextView. Change the **layout:width** property
    to `150dp` and the **layout:height** property to `150dp`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从面板中拖动一个**ImageView**元素到设计的中心，稍微低于之前的TextView。将**layout:width**属性更改为`150dp`，将**layout:height**属性更改为`150dp`。
- en: Now click and drag three buttons for **Play**, **High Scores** and **Quit**.
    Center them vertically, below the previous ImageView and one below the other,
    as per our design shown previously.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击并拖动三个按钮，分别为**Play**，**High Scores**和**Quit**。将它们垂直居中，放在之前的ImageView下方，一个接一个地放置，就像我们之前展示的设计一样。
- en: Click on the top button, configure the **text** property, and enter the value
    `Play`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的按钮，配置**text**属性，并输入值`Play`。
- en: Click on the middle button, configure the **text** property, and enter the value
    `High Scores`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击中间的按钮，配置**text**属性，并输入值`High Scores`。
- en: Click on the lowest button, configure the **text** property, and enter the value
    `Quit`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击最低的按钮，配置**text**属性，并输入值`Quit`。
- en: As the buttons now contain different amounts of text relative to each other,
    they will be of slightly different sizes. You can even them up to match the intended
    layout by clicking and dragging the edges of the smaller buttons to match the
    larger ones. This is done in mostly the same way as you might resize an application
    window in Windows.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于按钮现在包含的文本量相对于彼此不同，它们的大小也会略有不同。您可以通过点击并拖动较小按钮的边缘来使它们与较大的按钮匹配，以匹配预期的布局。这与您在Windows中调整应用程序窗口大小的方式基本相同。
- en: Save the project with *Ctrl* + *S* or by navigating to **File** | **Save All**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *S*保存项目，或者导航到**File** | **Save All**保存项目。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are going to be testing your games on a much larger or much smaller screen
    than the Nexus 4 shown in the designer, then you might like to adjust the values
    of the `sp` and `dp` units used in this tutorial.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要在比设计师中显示的Nexus 4屏幕大得多或小得多的屏幕上测试游戏，那么您可能希望调整本教程中使用的`sp`和`dp`单位的值。
- en: A full discussion of Android UI on multiple devices is beyond the scope of this
    book and is not necessary to make any of the games in this book. If you want to
    start designing for different screens right away, take a look at [http://developer.android.com/training/multiscreen/index.html](http://developer.android.com/training/multiscreen/index.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个设备上讨论Android UI的全部内容超出了本书的范围，也不需要为本书中的任何游戏做任何讨论。如果你想立即开始为不同的屏幕设计，请查看[http://developer.android.com/training/multiscreen/index.html](http://developer.android.com/training/multiscreen/index.html)。
- en: 'You can view what your menu looks like on other devices simply by selecting
    the device from the drop-down menu shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从下拉菜单中选择设备来查看其他设备上的菜单外观，如下面的屏幕截图所示：
- en: '![Making our game menu](img/8859OS_02_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![制作我们的游戏菜单](img/8859OS_02_11.jpg)'
- en: Before we make our menu come to life on an actual device, let's take a look
    at the structure of an Android app and how we can use that structure when writing
    our Java code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜单在实际设备上启动之前，让我们先看一下Android应用程序的结构以及我们在编写Java代码时如何使用该结构。
- en: Structuring our code for Android
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Android构建我们的代码
- en: If you have ever used an Android device, you have probably noticed that it works
    quite differently from many other operating systems. For example, you are using
    an application—say you're checking what people are doing on Facebook. Then you
    get an e-mail notification and you tap the e-mail icon to read it. Midway through
    reading the e-mail, you might get a Twitter notification and because you're waiting
    on important news from someone you follow, you interrupt your e-mail reading and
    change the app to Twitter with a touch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过Android设备，您可能已经注意到它的工作方式与许多其他操作系统有很大不同。例如，您正在使用一个应用程序-比如您正在查看Facebook上的人们在做什么。然后您收到一封电子邮件通知，您点击电子邮件图标阅读它。在阅读电子邮件的过程中，您可能会收到Twitter通知，因为您正在等待您关注的某人的重要消息，所以您中断了阅读电子邮件并触摸了Twitter应用。
- en: After reading the tweet, you fancy a game of Angry Birds, but midway through
    the first daring fling, you suddenly remember that Facebook post. So you quit
    Angry Birds and tap the Facebook icon.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读推特后，你想玩愤怒的小鸟，但在第一次大胆的投掷中途，你突然想起了Facebook的帖子。所以你退出了愤怒的小鸟，点击了Facebook图标。
- en: Then you resume Facebook, probably at the same point you left it. You could
    have resumed reading the e-mail, decided to reply to the tweet, or started an
    entirely new app. All this backwards and forwards takes quite a lot of management
    on the part of the operating system, apparently independent from the individual
    apps themselves.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你恢复了Facebook，可能是在你离开的同一个点。你本可以继续阅读邮件，决定回复推特，或者开始一个全新的应用程序。所有这些来回都需要操作系统进行相当多的管理，显然独立于各个应用程序本身。
- en: The difference between a Windows PC and Android in the context we have just
    discussed is that with Android, although the user decides which app they are using,
    the Android OS decides if and when to actually close down (destroy) an application.
    We just need to consider this when coding our games.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论的情境中，Windows PC和Android之间的区别在于，虽然用户决定使用哪个应用程序，但Android操作系统决定何时关闭（销毁）应用程序。我们在编写游戏时需要考虑这一点。
- en: Life cycle phases – what we need to know
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段-我们需要知道的内容
- en: The Android system has different **phases** that any given app can be in. Depending
    on the phase, the Android system determines how the app is viewed by the user
    or whether it is viewed at all. Android has these phases so that it can decide
    which app is in current use and then allocate the right amount of resources such
    as memory and processing power. But also allow us as game developers to interact
    with these phases. What if someone quits our game to answer a phone call? Will
    they lose their progress?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Android 系统有不同的**阶段**，任何给定的应用程序都可以处于这些阶段中。根据阶段，Android 系统决定应用程序如何被用户查看，或者是否被用户查看。Android
    有这些阶段，以便它可以决定哪个应用程序正在使用，并分配正确数量的资源，如内存和处理能力。但也允许我们作为游戏开发人员与这些阶段进行交互。如果有人退出我们的游戏接听电话呢？他们会失去他们的进度吗？
- en: 'Android has a fairly complex system that, when simplified a little for the
    purpose of explanation, ensures that every app on an Android device is in one
    of the following phases:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Android 有一个相当复杂的系统，简化一下以便解释，确保 Android 设备上的每个应用程序都处于以下阶段之一：
- en: Being created
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在创建
- en: Starting
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始
- en: Resuming
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复
- en: Running
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Pausing
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Stopping
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Being destroyed
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被销毁
- en: The list of phases will hopefully appear fairly logical. As an example, the
    user presses the Facebook app icon and the app is **created**. Then it is *started*.
    All are fairly straightforward so far but next in the list is **resuming**! It
    is not as illogical as it might first appear if, for a moment, we can just accept
    that the app resumes after it starts, and then all will become clear as we proceed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 希望阶段列表看起来相当合乎逻辑。例如，用户按下 Facebook 应用图标，应用程序**创建**。然后它*启动*。到目前为止，所有都相当简单，但接下来的是**恢复**！如果我们能暂时接受应用程序在启动后恢复，那么一切都会变得清晰。
- en: After **resuming,** the app is *running*. This is when the Facebook app has
    control over the screen and probably the greater share of system memory and processing
    power. Now what about our example where we switched from the Facebook app to the
    e-mail app?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**恢复**后，应用程序正在*运行*。这是当 Facebook 应用程序控制屏幕，可能也控制着更多的系统内存和处理能力。那么我们之前从 Facebook
    应用切换到电子邮件应用的例子呢？'
- en: As we tap to go to read our e-mail, the Facebook app will probably have entered
    the **paused** phase, and the e-mail app will enter the **being created** phase
    followed by **resuming** and then **running**. If we decide to revisit Facebook,
    as in the scenario earlier, the Facebook app will probably then go straight to
    the **resume** phase and then **running** again, most likely exactly on the post
    where we left it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击去读我们的电子邮件时，Facebook 应用程序可能已经进入了**暂停**阶段，电子邮件应用程序将进入**正在创建**阶段，然后是**恢复**，然后是**运行**。如果我们决定重新访问
    Facebook，就像之前的情景一样，Facebook 应用程序可能会直接进入**恢复**阶段，然后再次**运行**，很可能会准确地停留在我们离开时的帖子上。
- en: Note that at any time, Android can decide to *stop* or *destroy* an app, in
    which case, when we run the app again, it will need to be *created* all over again.
    So had the Facebook app been inactive long enough or had Angry Birds required
    so many system resources that Android would have *destroyed* the Facebook app,
    then our experience of finding the exact post we were previously reading might
    have been different.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随时，Android 可以决定*停止*或*销毁*一个应用程序，在这种情况下，当我们再次运行应用程序时，它将需要重新*创建*。因此，如果 Facebook
    应用程序长时间不活动，或者愤怒的小鸟需要太多系统资源，以至于 Android 将*销毁* Facebook 应用程序，那么我们之前阅读的确切帖子的体验可能会有所不同。
- en: 'Now, if all this phase stuff is starting to get confusing, then you will be
    pleased to know that the only reasons to mention are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果所有这些阶段的东西开始变得令人困惑，那么你会高兴地知道，提到的唯一原因如下：
- en: You know it exists
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道它存在
- en: We occasionally need to interact with it
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们偶尔需要与它交互
- en: We will take things step by step when we do
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一步一步地进行
- en: Life cycle phases – what we need to do
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段 - 我们需要做什么
- en: When we are making games, how do we possibly interact with this complexity?
    The good news is that the Android code that was autogenerated when we created
    our first project does most of the interaction for us.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们制作游戏时，我们如何可能与这种复杂性进行交互？好消息是，当我们创建第一个项目时自动生成的 Android 代码大部分为我们处理了交互。
- en: All we have to do as game developers is make sure that Android knows what to
    do with our app in each phase when it happens. Even more good news is that all
    of these phases are handled by default, unless we override the default handling.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏开发人员，我们所要做的就是确保 Android 知道在每个阶段发生时该如何处理我们的应用程序。更好的消息是，除非我们覆盖默认处理，否则所有这些阶段都将被默认处理。
- en: This means we can go ahead with learning Java and making games until we come
    to one of the few instances where we need to do something in our game, specifically
    in one of the phases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以继续学习 Java 和制作游戏，直到我们遇到少数需要在游戏中做一些事情的情况，特别是在其中一个阶段。
- en: Dividing our game into activities
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将我们的游戏分成活动
- en: The Java code that we write will be divided into sections or parts called **activities**.
    We can think of activities as different screens for our game. For example, during
    the book, we will often create an activity for a home screen, an activity for
    the game screen and an activity for the high score screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 Java 代码将被分成称为**活动**的部分或部分。我们可以将活动视为游戏的不同屏幕。例如，在游戏中，我们经常会为主屏幕创建一个活动，为游戏屏幕创建一个活动，以及为高分屏幕创建一个活动。
- en: Each activity will have its own life cycle and will be further divided into
    parts that will correspond to (go into) one of the Android phases we just discussed.
    The parts in Java are known as **methods**. Methods are a significant concept
    in Java programming.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动都将有自己的生命周期，并将进一步分成部分，这些部分将对应于我们刚刚讨论的 Android 阶段之一。在 Java 中，这些部分被称为**方法**。方法是
    Java 编程中的一个重要概念。
- en: At this stage, however, all we need to know is that methods are used to compartmentalize
    the Java code we write and that some methods are provided by the Android system
    so that we can easily handle the otherwise complex Android life cycle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个阶段，我们只需要知道方法用于将我们编写的Java代码分隔开，并且一些方法是由Android系统提供的，以便我们可以轻松处理否则复杂的Android生命周期。
- en: The forthcoming list is a quick explanation of the methods provided by Android
    for our convenience, to manage the phases of the life cycle. To clarify our discussion
    of life cycle phases methods are listed next to their corresponding phases that
    we have been discussing. However, as you will see, the method names make it fairly
    clear on their own where they fit in.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的列表是Android为了我们的方便提供的方法的快速解释，以管理生命周期的各个阶段。为了澄清我们对生命周期阶段的讨论，方法被列在我们一直在讨论的相应阶段旁边。然而，正如您将看到的，方法名称本身已经相当清楚地说明了它们在哪里适用。
- en: 'In the list, there is also a brief explanation or suggestion about when we
    should use a given method and thereby interact during a specific phase. We will
    meet most of these methods as we progress through the book. We will see the `onCreate`
    method later in this chapter. Here is the list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，还有关于何时使用给定方法以及在特定阶段进行交互的简要解释或建议。随着我们在书中的进展，我们将遇到大多数这些方法。我们将在本章后面看到`onCreate`方法。以下是列表：
- en: '`onCreate`: This method is executed when the activity is being created. Here
    we get everything ready for the game, including graphics, sound, and perhaps the
    high scores.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：当活动正在创建时，将执行此方法。在这里，我们准备好一切游戏所需的东西，包括图形、声音，也许还有高分。'
- en: '`onStart`: This method is executed when the app is in the starting phase.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart`：当应用程序处于启动阶段时执行此方法。'
- en: '`onResume`: This method runs after `onStart` but can also be entered, perhaps
    most logically, after our activity is resumed after being previously paused. We
    might reload a previously saved game situation when the app had been interrupted,
    perhaps by a phone call or the user running another app.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`：此方法在`onStart`之后运行，但也可以在我们的活动在先前暂停后恢复时进入，这可能是最合乎逻辑的。当应用程序被中断时，我们可能会重新加载先前保存的游戏情况，例如电话呼叫或用户运行其他应用程序。'
- en: '`onPause`: This occurs when our app is pausing. Here we might want to save
    the current game. You are probably getting the hang of these methods.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`：当我们的应用程序暂停时发生。在这里，我们可能希望保存当前的游戏。您可能已经掌握了这些方法。'
- en: '`onStop`: This relates to the stopping phase. This is where we might undo everything
    we did in `onCreate`. If we reach here, our activity will probably get destroyed
    sometime soon.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop`：这与停止阶段有关。这是我们可能会撤消在`onCreate`中所做的一切的地方。如果我们到达这里，我们的活动很可能很快就会被销毁。'
- en: '`onDestroy`: This is when our activity is finally being destroyed—our last
    chance to dismantle our game. If we reach here, we will definitely be going through
    the phases of the life cycle from the beginning again.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy`：这是我们的活动最终被销毁时——我们拆除游戏的最后机会。如果我们到达这里，我们肯定会再次经历生命周期的各个阶段。'
- en: All the method descriptions and their related phases should appear straightforward.
    Perhaps, the only real question is about the running phase. As we will see, when
    we write our code in other methods/phases, the `onCreate`, `onStart`, and `onResume`
    methods will prepare the game, which persists, forming the running phase. The
    `onPause`, `onStop`, and `onDestroy` methods will occur afterwards. Now we can
    actually take a look at one of these methods and some other methods as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法的描述及其相关阶段应该是直接的。也许，唯一真正的问题是关于运行阶段。正如我们将看到的，当我们在其他方法/阶段中编写代码时，`onCreate`、`onStart`和`onResume`方法将准备游戏，这将形成运行阶段。`onPause`、`onStop`和`onDestroy`方法将随后发生。现在我们实际上可以看一下其中一个方法以及其他一些方法。
- en: Our first look at Java
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们对Java的第一次了解
- en: 'So what about all that code that Android Studio generated when we created our
    new project earlier? This is the code that will bring our game menu to life. Let''s
    take a closer look. The very first line of code in the editor window is this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么早些时候在创建新项目时Android Studio生成的所有代码呢？这些代码将使我们的游戏菜单生动起来。让我们仔细看一下。编辑窗口中的第一行代码是这样的：
- en: '[PRE0]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line of code defines the package that we named when we first created the
    project. As the book progresses, we will write more complex code that spans more
    than one file. All the code files we create will need the package they belong
    to, clearly defined like the previous line of code, at the top. The code doesn't
    actually *do* anything in our game. Notice also that the line ends with a semicolon
    (`;`). This is a part of the Java syntax and it denotes the end of a line of code.
    Remove a semicolon and you will get an error because Android Studio tries to make
    sense of two lines together. Try it if you like.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码定义了我们在创建项目时命名的包。随着书籍的进展，我们将编写跨越多个文件的更复杂的代码。我们创建的所有代码文件都需要清楚地定义它们所属的包，就像前一行代码一样。代码实际上并没有在我们的游戏中*做*任何事情。还要注意，这行代码以分号(`;`)结束。这是Java语法的一部分，它表示代码行的结束。删除分号，您将会得到一个错误，因为Android
    Studio试图理解两行代码。如果您愿意，可以尝试一下。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that if you are going to be copying and pasting the code from the download
    bundle, this is the one line of code that might vary depending on how you set
    up your project. If the package name in the code file is different from the package
    name you created, always use the package name from when you created the project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您要从下载包中复制和粘贴代码，这是可能会有所不同的一行代码，具体取决于您如何设置项目。如果代码文件中的包名称与您创建的包名称不同，请始终使用创建项目时的包名称。
- en: 'To see the next four lines of code, you might need to click on the small **+**
    icon to reveal them. Android Studio tries to be helpful by simplifying our view
    of the code. Notice that there are several little **-** icons as well down the
    side of the editor window. You can expand and collapse them to suit yourself without
    affecting the functionality of the program. This is shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看接下来的四行代码，您可能需要单击小**+**图标以显示它们。Android Studio试图通过简化我们对代码的视图来提供帮助。请注意，编辑窗口的侧边还有几个小**-**图标。您可以展开和折叠它们以适应自己的需求，而不会影响程序的功能。如下截图所示：
- en: '![Our first look at Java](img/8859OS_02_12.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![我们第一次接触Java](img/8859OS_02_12.jpg)'
- en: 'Once you have expanded the code, you will see these four lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展代码后，您将看到这四行：
- en: '[PRE1]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that all the preceding lines start with the word `import`. This is an
    instruction to include other packages in our game, not just our own. This is very
    significant because it makes available to us all of the hard work of other programmers,
    the Android development team in this case. It is precisely these imports that
    give us the ability to use the methods we discussed earlier, and allow us to interact
    with the Android life cycle phases. Notice again that all the lines end with a
    semicolon (`;`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有前面的行都以单词`import`开头。这是一个指示，包括其他包在我们的游戏中，而不仅仅是我们自己的包。这非常重要，因为它使我们能够使用其他程序员的辛勤工作，本例中是安卓开发团队的辛勤工作。正是这些导入使我们能够使用我们之前讨论过的方法，并允许我们与安卓生命周期阶段进行交互。再次注意，所有行都以分号（`;`）结尾。
- en: 'The next line introduces a fundamental building block of Java known as a **class**.
    Classes are something that we will continually expand our knowledge and understanding
    of throughout the book. For now, take a look at this line of code, then we will
    discuss it in detail:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行介绍了Java的一个基本构建块，称为**class**。类是我们将在整本书中不断扩展知识和理解的内容。现在，先看一下这行代码，然后我们将详细讨论它：
- en: '[PRE2]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Word by word, here is what is going on. The preceding line is saying: make
    me a new `public class` called `MainActivity` and base it upon (`extends`) `ActionBarActivity`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字逐句，以下是正在发生的事情。前一行是说：创建一个名为`MainActivity`的新`public class`，并基于（`extends`）`ActionBarActivity`。
- en: You might remember that `MainActivity` is the name we chose while creating this
    project. `ActionBarActivity` is the code (known as a class) written by the Android
    development team that enables us to put our Java into Android.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在创建这个项目时我们选择的名称是`MainActivity`。`ActionBarActivity`是由安卓开发团队编写的代码（称为类），它使我们能够将我们的Java代码放入安卓中。
- en: If you have a keen eye, you might notice there is no semicolon at the end of
    this line. There is, however, an opening curly brace (`{`). This is because `MainActivity`
    encompasses the rest of the code. In effect, everything is part of our `MainActivity`
    class, which is built based on the `ActionBarActivity` class/code. If you scroll
    down to the bottom of the editor window, you will see a closing curly brace (`}`).
    This denotes the end of our class called `MainActivity`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有敏锐的眼光，您可能会注意到这行末尾没有分号。但是，有一个左花括号（`{`）。这是因为`MainActivity`包含了其余的代码。实际上，一切都是我们的`MainActivity`类的一部分，它是基于`ActionBarActivity`类/代码构建的。如果您滚动到编辑窗口底部，您将看到一个右花括号（`}`），这表示我们称为`MainActivity`的类的结束。
- en: We do not need to know how a class works yet
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在不需要知道类如何工作
- en: We will use classes to access some methods contained within its code and without
    doing any more, we are already, by default, taking advantage of the Android life
    cycle methods we discussed earlier
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用类来访问其中包含的一些方法的代码，而不需要做任何其他操作，我们已经默认地利用了我们之前讨论过的安卓生命周期方法
- en: We can now pick and choose if, when, and which methods defined in these classes
    we wish to override or leave as default
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以自由选择是否、何时以及在这些类中定义的方法中覆盖或保留默认值
- en: So, it is the `ActionBarActivity` class that contains the methods that enable
    us to interact with the Android life cycle. Actually, there are a number of different
    classes that enable us to do this and in a moment, we will change from using `ActionBarActivity`
    to a more appropriate class that also does all the things just mentioned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`ActionBarActivity`类包含了使我们能够与安卓生命周期交互的方法。实际上，有许多不同的类使我们能够做到这一点，一会儿，我们将从使用`ActionBarActivity`更改为一个更合适的类，该类也执行刚才提到的所有操作。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not important at this point to properly understand Java classes; just
    understand that you can import a package and a package can contain one or more
    classes that you can then use the functionality of or base your own Java programs
    on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此时重要的不是正确理解Java类；只需了解您可以导入一个包，一个包可以包含一个或多个类，然后您可以使用这些类的功能或基于自己的Java程序。
- en: We will bump into classes regularly in the next few chapters. Think of them
    as programming black boxes that do stuff. In [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will open the black box and really get to grips with them and we will even start
    making our own classes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将经常遇到类。把它们看作是做事情的编程黑匣子。在[第6章](ch06.xhtml "Chapter 6. OOP – Using
    Other People's Hard Work")中，*OOP – Using Other People's Hard Work*，我们将打开这个黑匣子，真正掌握它们，甚至开始制作我们自己的类。
- en: Moving on with the code, let's look at what the code that is contained within
    our class actually does.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行代码，让我们看看我们的类中实际包含的代码是做什么的。
- en: 'Here is the code chunk directly after the crucial line we have just been discussing:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论过的关键行之后，直接是代码块：
- en: '[PRE3]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hopefully, some of this code will start to make sense now and tie in with what
    we have already discussed. Although the precise syntax will still feel a little
    alien, we can continue learning Java as long as we are aware of what is happening.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在这些代码中的一些内容开始变得有意义，并与我们已经讨论过的内容联系起来。尽管确切的语法仍然会感觉有点陌生，但只要我们意识到发生了什么，我们就可以继续学习Java。
- en: The first thing we notice in the preceding code is the word `@override`. Remember
    when we said that all the methods that interact with the Android life cycle were
    implemented by default and we can pick and choose if and when to override them?
    This is what we are doing here with the `onCreate` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们注意到的第一件事是`@override`关键字。还记得我们说过所有与Android生命周期交互的方法都是默认实现的，我们可以自行选择是否以及何时覆盖它们吗？这就是我们在这里用`onCreate`方法所做的。
- en: The `@override` word says that the method that follows next is being overridden.
    The `protected void onCreate(Bundle savedInstanceState) {` line contains the method
    we are overriding. You might be able to guess that the action starts with the
    opening `{` at the end of the line in question and ends with the closing `}` three
    lines later.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`@override`关键字表示接下来的方法被覆盖。`protected void onCreate(Bundle savedInstanceState)
    {`行包含我们正在覆盖的方法。你可能能猜到，动作从问题行的`{`开始，三行后以`}`结束。'
- en: 'The somewhat odd-looking `protected void` before the method name `onCreate`
    and `(Bundle savedInstanceState)` after the method name are unimportant at this
    time because they are handled for us. It is to do with the data that travels between
    various parts of our program. We just need to know that what happens here will
    take place in the creating phase of the Android lifecycle. The rest will become
    clear in [Chapter 4](ch04.xhtml "Chapter 4. Discovering Loops and Methods"), *Discovering
    Loops and Methods*. Let''s move on to the line:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法名`onCreate`之前和方法名后的`(Bundle savedInstanceState)`看起来有点奇怪，但这些在这个时候并不重要，因为它们已经为我们处理了。这与数据在我们程序的各个部分之间传递有关。我们只需要知道这里发生的事情将在Android生命周期的创建阶段发生。其余内容将在[第4章](ch04.xhtml
    "第4章。发现循环和方法")*发现循环和方法*中变得清晰。让我们继续到下一行：
- en: '[PRE4]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the `super` keyword is referencing the code in the original `onCreate`
    method, which is still there even though we can''t see it. The code is saying:
    even though I am overriding you, I want you to set things up, just like you normally
    do first. Then, after `onCreate` has done loads of work that we don''t see and
    don''t need to see, the method continues and we actually get to do something ourselves
    with this line of code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`super`关键字引用了原始的`onCreate`方法中的代码，即使我们看不到它，它仍然存在。代码的意思是：尽管我正在覆盖你，但我希望你首先像往常一样设置好一切。然后，在`onCreate`完成了我们看不到也不需要看到的大量工作之后，方法继续进行，我们实际上可以用这行代码做一些事情：
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are telling Android to set the main content view (our users screen),
    which is the cool game menu we created earlier. To be specific, we are stating
    it is an `R` or resource in the `layout` folder and the file is called `activity_main`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Android设置主内容视图（我们用户的屏幕），这是我们之前创建的酷炫游戏菜单。具体来说，我们声明它是`layout`文件夹中的`R`或资源，文件名为`activity_main`。
- en: Cleaning up our code
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理我们的代码
- en: 'The next two blocks of code were created by Android Studio on the assumption
    that we would want to override another two methods. We don''t, because they are
    methods more often used in non-gaming apps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个代码块是由Android Studio创建的，假设我们想要覆盖另外两个方法。但我们不需要，因为这些方法更常用于非游戏应用程序：
- en: 'Delete the entire content shown in the following code. Be careful not to delete
    the closing curly brace of our `MainActivity` class:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码中显示的整个内容。注意不要删除我们`MainActivity`类的结束大括号：
- en: '[PRE6]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can delete a couple of the `@import` statements. The reason for this
    is that we just deleted the overridden methods of classes (imported earlier) we
    no longer need. Notice that the following lines in the editor window are grey.
    Note that the program would still work if you leave them in. Delete them both
    now to make your code as clear as possible:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以删除一些`@import`语句。这是因为我们刚刚删除了不再需要的类的覆盖方法（之前导入的）。请注意编辑器窗口中以下行是灰色的。请注意，如果你保留它们，程序仍然可以正常工作。现在删除它们，以使你的代码尽可能清晰：
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some final amendments before our code is done: at this point, you might be
    thinking that we have deleted and changed so much of our code that we might as
    well have started from an empty page and typed it in. This is almost true. But
    the process of having Android Studio create a new project for us and then making
    these amendments is more thorough and also avoids quite a few steps. Here are
    the last code changes. Change the `import android.support.v7.app.ActionBarActivity;`
    line to `import android.support.app.Activity;`.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码完成之前进行一些最终修改：此时，你可能会认为我们已经删除和更改了我们的代码很多，以至于我们可能干脆从空白页面开始重新输入。这几乎是正确的。但是，让Android
    Studio为我们创建一个新项目，然后进行这些修改的过程更加彻底，也避免了很多步骤。以下是最后的代码更改。将`import android.support.v7.app.ActionBarActivity;`行更改为`import
    android.support.app.Activity;`。
- en: Now you will get several red lines underlining our code and indicating errors.
    This is because we are attempting to use a class we have not yet imported. Simply
    amend the `public class MainActivity extends ActionBarActivity {` line to `public
    class MainActivity extends Activity {`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你会看到我们的代码下面有几条红线标出错误。这是因为我们试图使用一个尚未导入的类。只需将`public class MainActivity extends
    ActionBarActivity {`行更改为`public class MainActivity extends Activity {`。
- en: What we did with those last two changes was using a slightly more appropriate
    version of the `Activity` class. To do this, we also had to change what we imported.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对最后两个更改所做的是使用`Activity`类的稍微更合适的版本。为此，我们还必须更改我们导入的内容。
- en: 'When you''re done, your editor window should look exactly like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的编辑器窗口应该看起来像这样：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code fies from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the fies e-mailed directly to you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.packtpub.com](http://www.packtpub.com)的账户中下载你购买的所有Packt Publishing图书的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，将文件直接发送到你的邮箱。
- en: Now that we know what's going on and our code is clean and lean, we can actually
    take a look at the beginnings of our game in action!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道发生了什么，我们的代码干净而简洁，我们实际上可以看一下我们游戏的开头部分在运行中的样子！
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If any of what we have just discussed seemed complicated, there is no need for
    concern. Android forces us to work within the Activity lifecycle, so the previous
    steps were unavoidable. Even if you didn't follow all the explanations about classes
    and methods and so on, you are still perfectly placed to learn Java from here.
    All the classes and methods will seem much more straightforward as the book progresses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刚才讨论的任何内容看起来复杂，不用担心。安卓强制我们在Activity生命周期内工作，所以之前的步骤是不可避免的。即使你没有完全理解关于类和方法等的所有解释，你仍然完全有能力从这里学习Java。随着书的进展，所有的类和方法都会变得更加简单明了。
- en: Building and installing our game
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和安装我们的游戏
- en: Soon, we will actually see our menu in action. But before we do that, we need
    to find out how to use the Android emulators and how to build our game. Then we
    will put these together and put our game into an emulator or real device to see
    it as our players would.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将实际看到我们的菜单在运行。但在这之前，我们需要找出如何使用安卓模拟器以及如何构建我们的游戏。然后我们将把这些放在一起，把我们的游戏放入模拟器或真实设备中，以便像我们的玩家一样看到它。
- en: Emulators and devices
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器和设备
- en: Now we have the first part of our game ready to run. We need to test it to check
    for any errors, crashes, or anything else unintended. It is also important to
    ensure that it looks good and runs correctly on the device types/sizes and that
    you want to target.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行游戏的第一部分。我们需要测试它，检查是否有任何错误、崩溃或其他意外情况。还要确保它在您想要定位的设备类型/尺寸上看起来好并且运行正确。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not go into any details about handling different device types. All our
    games are fullscreen and we will later lock the orientation and dynamically calculate
    aspects such as screen resolution. So we can get away with writing for a single
    device type and focus on learning Java.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论处理不同设备类型的细节。我们所有的游戏都是全屏的，我们将稍后锁定方向并动态计算屏幕分辨率等方面。所以我们可以只为一个设备类型编写，并专注于学习Java。
- en: It might be useful to know for now that you can create a different layout file
    for any screen size categorization or pixel density. All you need to do is place
    the layout file using exactly the same filename in the appropriate folder. The
    Android device will then *know* the most appropriate layout for it to use. For
    a detailed discussion, see the Google developers website at [http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在知道，你可以为任何屏幕尺寸分类或像素密度创建不同的布局文件。你所需要做的就是将布局文件放在适当的文件夹中，使用完全相同的文件名。安卓设备将*知道*最适合它使用的布局。有关详细讨论，请参阅Google开发者网站[http://developer.android.com/guide/practices/screens_support.html](http://developer.android.com/guide/practices/screens_support.html)。
- en: Note that you do not need to understand any of the information at the preceding
    link to learn Java and publish your first games.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不需要理解上述链接中的任何信息就可以学习Java并发布您的第一个游戏。
- en: There are a few options to do this and we will look at two. First, we will use
    Android Studio and the Android Development Tools to make a device emulator so
    that we can use, test, and debug our games on a wide range of device emulators
    on the same PC/Mac we are developing on. So we don't need to own a device. This
    will allow us to get crash reports from our games.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点，我们将看两种。首先，我们将使用Android Studio和Android开发工具来制作一个设备模拟器，这样我们就可以在同一台PC/Mac上使用、测试和调试我们的游戏在各种设备模拟器上。所以我们不需要拥有一个设备。这将允许我们从我们的游戏中获得崩溃报告。
- en: Then we will install the game directly to a real device so that we can see exactly
    what the owner of that device will see when they download our app.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将直接将游戏安装到真实设备上，以便我们可以看到当他们下载我们的应用时，设备的所有者将看到什么。
- en: There are more options. For example, you can connect a real device via USB and
    debug directly on the device with the errors and syntactical feedback in Android
    Studio. The process for this might vary for different devices and since we won't
    be focusing on anything but basic debugging, we will not cover that in this book.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的选择。例如，您可以通过USB连接真实设备，并在Android Studio中直接调试设备上的错误和语法反馈。这个过程可能因不同的设备而有所不同，由于我们只关注基本的调试，我们不会在本书中涵盖这个内容。
- en: Creating an emulator
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个模拟器
- en: 'Let''s get our emulator up and emulating:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动我们的模拟器：
- en: On the right-hand side of the Android Studio quick launch bar, find the AVD
    manager icon:![Creating an emulator](img/8859OS_02_13.jpg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio快速启动栏的右侧，找到AVD管理器图标：![创建模拟器](img/8859OS_02_13.jpg)
- en: Click on the icon to start the Android Virtual Device Manager. Then click on
    the **Create Virtual Device...** button on the bottom-left side to bring up the
    **Virtual Device Configuration** window.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图标启动Android虚拟设备管理器。然后点击左下角的**创建虚拟设备...**按钮，打开**虚拟设备配置**窗口。
- en: Now click on the **Nexus 4** option and then click on **Next**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**Nexus 4**选项，然后点击**下一步**。
- en: Now we need to choose the version of Android we will use to build and test our
    games on. The latest version (at time of writing) is **Lollipop - 21 - x86**.
    It is the only option where we don't need to complete a download to continue.
    So select it (or whatever the default is at the time you are reading this) and
    then click on **Next** to continue.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要选择我们将在其上构建和测试我们的游戏的安卓版本。最新版本（写作时）是**Lollipop - 21 - x86**。这是唯一一个我们不需要完成下载就可以继续的选项。所以选择它（或者在您阅读本文时的默认选项），然后点击**下一步**继续。
- en: On the next screen we can leave all the default settings. So click on **Finish**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，我们可以保留所有默认设置。所以点击**完成**。
- en: We now have a ready-to-run Android emulator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以直接运行的安卓模拟器。
- en: Running the emulator
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行模拟器
- en: 'Now we will launch (switch on) our virtual device then actually run our game
    that we made earlier by performing the following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将启动（打开）我们的虚拟设备，然后通过以下步骤实际运行我们之前制作的游戏：
- en: Click on **Nexus 4 API 21** under the **Name** column. Now click on the triangular
    play icon to the right of the description of our emulator.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Name**列下的**Nexus 4 API 21**。现在点击描述我们的模拟器右侧的三角形播放图标。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android emulators take a long time to start. Even on a high-specification PC.
    Expect to wait at least a few minutes or even 10.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓模拟器需要很长时间才能启动。即使在高规格的PC上也是如此。预计至少要等待几分钟，甚至10分钟。
- en: Once it has started, unlock the device by clicking and dragging anywhere on
    the screen of the emulated device. This is analogous to swiping to unlock a real
    Nexus 4\. Here is what our Nexus 4 virtual device looks like when it is running
    and unlocked:![Running the emulator](img/8859OS_02_16.jpg)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，通过点击和拖动模拟设备屏幕的任何位置来解锁设备。这类似于在真实的Nexus 4上滑动解锁。当我们的Nexus 4虚拟设备运行并解锁时，它看起来是这样的：![Running
    the emulator](img/8859OS_02_16.jpg)
- en: You can play with this emulator in almost the same way as you can a real Android
    device. However, you cannot download apps from Google Play. You might notice that
    the emulator is a bit slow compared to a real device, even compared to an old
    one. Shortly, we will look at running our apps on a real device.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以几乎以与真实安卓设备相同的方式玩这个模拟器。但是，您无法从Google Play下载应用。您可能会注意到，与真实设备相比，甚至与旧设备相比，模拟器速度有点慢。不久，我们将看看如何在真实设备上运行我们的应用程序。
- en: Running our game on the emulator
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模拟器上运行我们的游戏
- en: 'Once the emulator is running, it''s usually best to leave it running so that
    each time we want to use it, we don''t have to wait for it to start. Let''s use
    the emulator:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模拟器运行起来，通常最好让它保持运行，这样每次我们想要使用它时，就不必等待它启动。让我们使用模拟器：
- en: Launch the emulator if it is not already running and make sure the device is
    unlocked as described previously.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模拟器尚未运行，请启动它，并确保设备已按先前描述的方式解锁。
- en: Click on the run icon in the toolbar (shown next) to run your app. You can achieve
    the same thing by navigating to **Run** | **Math Game Chapter 2** from the menu
    bar:![Running our game on the emulator](img/8859OS_02_17.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏中的运行图标（如下所示）来运行您的应用程序。您也可以通过从菜单栏导航到**Run** | **Math Game Chapter 2**来实现相同的功能：![Running
    our game on the emulator](img/8859OS_02_17.jpg)
- en: After a pause while Android Studio builds our application, a pop-up dialog will
    ask you which device you want to run the app on. Choose the device with **Nexus
    4 API 21** in the description. This is the already running device that we created
    earlier. Now press **OK**.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio构建我们的应用程序时，弹出对话框将询问您要在哪个设备上运行该应用程序。选择描述中带有**Nexus 4 API 21**的设备。这是我们之前创建的已经运行的设备。现在按**OK**。
- en: Notice at this point that the useful Android window appears at the bottom section
    of Android Studio. In the unlikely event of you having any problems, just check
    for typos in the code. If things really don't work out, just go back to the *Using
    the sample code* section to compare with or copy and paste the supplied code.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意此时在Android Studio的底部部分出现了有用的安卓窗口。如果您遇到任何问题，只需检查代码中的拼写错误。如果事情真的不顺利，只需返回到*使用示例代码*部分，与提供的代码进行比较或复制粘贴。
- en: After another pause, our game menu screen will appear on the emulator. Of course,
    it doesn't do anything yet, but it is running and the buttons can be pressed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一段暂停后，我们的游戏菜单屏幕将出现在模拟器上。当然，它现在还没有做任何事情，但它正在运行，按钮可以被按下。
- en: When you're done, you can press the back or home icons to quit the application,
    just as you would on a real Android device.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以按返回或主屏幕图标退出应用程序，就像在真实的安卓设备上一样。
- en: Now we have seen one of the ways we can test our app by running it in the Android
    emulator. Let's find out how to make our code into an app we can distribute and
    use on a real device.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一种我们可以通过在安卓模拟器中运行来测试我们的应用程序的方法。让我们找出如何将我们的代码制作成一个可以在真实设备上分发和使用的应用程序。
- en: Building our game
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的游戏
- en: 'To run our game on a real Android device, we need to create a `.apk` file,
    that is, a file that ends with the extension `.apk`. A `.apk` file is a compressed
    archive of files and folders that the Android system uses to run and install our
    app. These are the steps to use Android Studio to make a `.apk` of our game:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的安卓设备上运行我们的游戏，我们需要创建一个以`.apk`结尾的文件，也就是一个以`.apk`为扩展名的文件。`.apk`文件是安卓系统用来运行和安装我们的应用程序的文件和文件夹的压缩存档。以下是使用安卓工作室制作我们游戏的`.apk`的步骤：
- en: From the menu bar, navigate to **Build** | **Generate Signed APK**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单栏导航到**Build** | **Generate Signed APK**。
- en: 'A slightly verbose window will pop up and say: **For Gradle-based projects,
    the signing configuration should be specified in the Gradle build scripts**. You
    can safely dismiss this window by clicking on **OK**.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个略显冗长的窗口将弹出并显示：**对于基于Gradle的项目，签名配置应在Gradle构建脚本中指定**。您可以点击**OK**安全地关闭此窗口。
- en: Next up is the **Generate Signed APK Wizard** dialog. Here, we are creating
    a key that identifies the key holder as authorized to distribute the APK. At the
    end of this process, you will have a `.keys` file that you can use each time you
    build a `.apk` file. So this step can be missed out in future. Click on the **Create
    new** button.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是**Generate Signed APK Wizard**对话框。在这里，我们正在创建一个标识持有者被授权分发APK的密钥。在此过程结束时，您将获得一个`.keys`文件，您可以在每次构建`.apk`文件时使用。因此，这一步在将来可以省略。点击**Create
    new**按钮。
- en: In the **Key Store Path** field, type or go to a location on your hard drive
    where you would like to store your key. You will then be prompted to choose a
    filename for the keystore. This is arbitrary. Type `MyKeystore` and click on **OK**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Key Store Path**字段中，键入或转到您的硬盘上希望存储密钥的位置。然后，您将被提示选择密钥库的文件名。这是任意的。键入`MyKeystore`并点击**OK**。
- en: Type a password in the **Password** field and then retype it in the **Confirm**
    field. This is the password to a store that will help protect your key.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Password**字段中输入密码，然后在**Confirm**字段中重新输入。这是用于保护您的密钥的存储的密码。
- en: Next, in the **Alias** field, type a memorable alias. You can think of this
    as a kind of username for your key. Again type a password in the **Password**
    field and then retype it in the **Confirm** field. This is the password to your
    key.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**别名**字段中，输入一个易记的别名。您可以将其视为密钥的用户名。再次在**密码**字段中输入密码，然后在**确认**字段中重新输入。这是您的密钥密码。
- en: Leave the **Validity Years** dropdown at the default of **25**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**有效年限**下拉菜单保持默认的**25**。
- en: You can then fill out your Name and organization details (if any) and click
    on **OK**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后您可以填写您的姓名和组织详情（如果有），然后点击**确定**。
- en: Now our key and keystore are complete, and we can click on **OK** on the **Generate
    Signed APK wizard** dialog.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的密钥和密钥库已经完成，我们可以在**生成已签名APK向导**对话框上点击**确定**。
- en: We are then prompted to select **Run Proguard**. Encrypting and optimizing our
    `.apk` is unnecessary at this time. So just click on **Finish** to generate our
    app's `.apk` file.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们被提示选择**运行Proguard**。在这个时候，加密和优化我们的`.apk`是不必要的。所以只需点击**完成**生成我们应用程序的`.apk`文件。
- en: The generated `.apk` file will be put in the same directory that you chose to
    put the project files. For example, `MathGameChapter2/app`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的`.apk`文件将放在您选择放置项目文件的同一目录中。例如，`MathGameChapter2/app`。
- en: We have now built a `.apk` file that can be run on any Android device that was
    specified when we first created the project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了一个`.apk`文件，可以在我们首次创建项目时指定的任何Android设备上运行。
- en: Installing the setup to a device
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将设置安装到设备
- en: So we have our `.apk` file and we know were to find it. Here is how we will
    run it on our Android device.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有了`.apk`文件，也知道了在哪里找到它。以下是我们将在Android设备上运行它的方法。
- en: We can use one of a number of methods to get the `.apk` file into the device.
    The method I find one of the easiest is the use of a cloud storage service such
    as Dropbox. You can then simply click and drag the `.apk` file to your Dropbox
    folder and you're done. Alternatively, your Android device probably came with
    PC synchronization software that allows you to drag and drop files to and from
    your device. After you have placed the `.apk` file on your Android device, continue
    with the tutorial.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法将`.apk`文件传输到设备中。我发现其中一种最简单的方法是使用云存储服务，比如Dropbox。然后您只需点击并拖动`.apk`文件到您的Dropbox文件夹，就完成了。或者，您的Android设备可能附带了PC同步软件，允许您将文件拖放到设备中。在您将`.apk`文件放入Android设备后，继续进行教程。
- en: 'Most Android phones are set not to install apps from anywhere except the Google
    Play Store. So we need to change this. The exact menus you will navigate to might
    vary very slightly on your device but the following options tend to be almost
    the same on most devices, old and new:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Android手机默认设置为只能从Google Play商店以外的地方安装应用程序。所以我们需要改变这一点。您将要导航到的确切菜单在您的设备上可能略有不同，但以下选项在大多数设备上几乎是相同的，无论新旧：
- en: Find and tap the **Settings** app. Most Android phones also have a **Settings**
    menu option. Either will do. Now select **Security** and scroll down to the **Unknown
    sources** option. Tap the **Unknown sources** checkbox to allow apps to be installed
    from unknown sources.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并点击**设置**应用。大多数Android手机也有**设置**菜单选项。任何一个都可以。现在选择**安全**，并滚动到**未知来源**选项。点击**未知来源**复选框，允许从未知来源安装应用程序。
- en: Locate the file on your Android device using the Dropbox app or your devices
    file browser depending on the method you chose to put the APK on your device.
    Tap the `MathGameChapter2.apk` file.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Dropbox应用或您设备的文件浏览器在您的Android设备上找到文件，具体取决于您选择的方法将APK放入设备。点击`MathGameChapter2.apk`文件。
- en: You can now install the app just like any other. When prompted, press **Install**
    and then **Open**. The game will now be running on your device.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以像安装其他应用程序一样安装该应用程序。在提示时，点击**安装**，然后点击**打开**。游戏现在将在您的设备上运行。
- en: Hold your device in a portrait orientation as this is how the UI was designed.
    Congratulations on running your very own Android app on your own device. In a
    later version of the math game, we will lock the orientation to make this more
    user friendly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的设备保持竖直方向，因为这是UI设计的方式。恭喜您在自己的设备上运行自己的Android应用程序。在数学游戏的以后版本中，我们将锁定方向，使其更加用户友好。
- en: Future projects
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来的项目
- en: Throughout the book, we will test and run our game projects. It is entirely
    up to you which of the methods we discussed you prefer. If you are getting crashes
    or unexplained bugs, then you will need to use an emulator. If all is working
    well, then the quickest and probably most pleasing way will be to run it on a
    device you own.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将测试和运行我们的游戏项目。你可以自行选择我们讨论过的方法中的哪一种。如果出现崩溃或无法解释的错误，那么您需要使用模拟器。如果一切正常，那么最快、最令人愉悦的方式可能就是在您拥有的设备上运行它。
- en: Self-test questions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit bemusing?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）如果所有这些关于生命周期、类和方法的讨论让您感到困惑，您应该怎么办？
- en: Q2) What exactly is a Java class?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）什么是Java类？
- en: Q3) What is the difference between a method and a class?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Q3）方法和类之间有什么区别？
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the phases of the life cycle at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Q4）查看Android开发者网站，以及其更详细的生命周期阶段解释，网址为[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)。您能看到我们没有讨论过的阶段及其相关方法吗？在应用程序中它会在什么时候触发？从创建到销毁，活动的确切路径是什么？
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We discussed that so far, it has not been not important to completely understand
    exactly how the code works. This is because it will act just as a container for
    the code we write in the rest of the book. However, as we cover in detail topics
    such as methods in [Chapter 4](ch04.xhtml "Chapter 4. Discovering Loops and Methods"),
    *Discovering Loops and Methods*, and classes in [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*, we
    will begin to make sense of all of the code in our games.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了完全理解代码的工作原理并不重要。这是因为它将仅充当我们在本书其余部分中编写的代码的容器。然而，当我们在[第4章](ch04.xhtml
    "第4章。发现循环和方法")中详细讨论诸如方法和[第6章](ch06.xhtml "第6章。OOP-使用他人的辛勤工作")中的类时，我们将开始理解我们游戏中的所有代码。
- en: We discussed the somewhat complex Android life cycle in detail. We learned that
    all we need to understand at this stage is that we must write our code within
    the correct methods that relate to different phases of the life cycle. Then we
    will have no trouble making good progress with learning Java. As with classes
    and methods, all will be explained along the way and become clearer with practice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了有些复杂的Android生命周期。我们了解到，我们现阶段需要理解的是，我们必须在与生命周期不同阶段相关的正确方法中编写我们的代码。然后，学习Java就不会有任何困难。与类和方法一样，一切都将在实践中得到解释并变得更加清晰。
- en: We also learned the key areas of the Android Studio UI. We built our start menu
    for our math game using the Android Studio designer. Furthermore, we created the
    Java code necessary to make the game appear on the player's device. This was achieved
    mainly by modifying the code that was automatically generated for us.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了Android Studio UI的关键领域。我们使用Android Studio设计师构建了我们数学游戏的开始菜单。此外，我们创建了必要的Java代码，使游戏出现在玩家的设备上。这主要是通过修改为我们自动生成的代码来实现的。
- en: This was probably the most difficult chapter of the book because it was necessary
    to introduce a few things such as Java classes, Java methods, and the Android
    life cycle. We did this because we need to know what is going on around us as
    we learn Java.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本书中最困难的一章，因为我们需要介绍一些东西，比如Java类、Java方法和Android生命周期。我们这样做是因为我们需要了解在学习Java时周围发生的事情。
- en: From now on, however, we can take things a step at a time in a very logical
    manner. If you have reached this point, you will have no problem completing the
    toughest of the projects in this book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从现在开始，我们可以循序渐进地以非常合乎逻辑的方式进行。如果你已经达到了这一点，那么你将毫无问题地完成本书中最艰难的项目。
- en: If this chapter made your brain ache a little, rest assured that the fact that
    you have made it this far is a very good indication that you are going to be a
    Java ace someday soon. Starting from the basics, let's learn some Java now.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一章让你的大脑有点疼，那么请放心，你已经走到了这一步，这非常好地表明你将来会成为Java高手。从基础开始，让我们现在学习一些Java。
