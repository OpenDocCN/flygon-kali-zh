- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Exploring Generics, Delegates, and Beyond
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索通用、委托和更多
- en: The more time you spend programming, the more you start thinking about systems.
    Structuring how classes and objects interact, communicate, and exchange data are
    all examples of systems we've worked with so far; the question now is how to make
    them safer and more efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在编程中花费的时间越多，你就会开始思考系统。构建类和对象如何相互交互、通信和交换数据，这些都是我们迄今为止所使用的系统的例子；现在的问题是如何使它们更安全、更高效。
- en: Since this will be the last practical chapter of the book, we'll be going over
    examples of generic programming concepts, delegation, event creation, and error
    handling. Each of these topics is a large area of study in its own right, so take
    what you learn here and expand on it in your projects. After we complete our practical
    coding, we'll finish up with a brief overview of design patterns and how they'll
    play a part in your programming journey going forward.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将是本书的最后一个实用章节，我们将介绍通用编程概念、委托、事件创建和错误处理的示例。每个主题都是一个独立的大领域，所以在你的项目中学到的东西，可以进一步扩展。在完成我们的实际编码后，我们将简要概述设计模式以及它们在你未来编程之旅中的作用。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generic programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用编程
- en: Using delegates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托
- en: Creating events and subscriptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事件和订阅
- en: Throwing and handling errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出和处理错误
- en: Understanding design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: Introducing generics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍通用
- en: All of our code so far has been very specific in terms of defining and using
    types. However, there will be cases where you need a class or method to treat
    its entities in the same way, regardless of its type, while still being type-safe.
    Generic programming allows us to create reusable classes, methods, and variables
    using a placeholder, rather than a concrete type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有代码在定义和使用类型方面都非常具体。然而，会有一些情况，你需要一个类或方法以相同的方式处理其实体，而不管其类型，同时仍然是类型安全的。通用编程允许我们使用占位符而不是具体类型来创建可重用的类、方法和变量。
- en: When a generic class instance is created at compile time or a method is used,
    a concrete type will be assigned, but the code itself treats it as a generic type.
    Being able to write generic code is a huge benefit when you need to work with
    different object types in the same way, for example, custom collection types that
    need to be able to perform the same operations on elements regardless of type,
    or classes that need the same underlying functionality. While you might be asking
    yourself why we don't just subclass or use interfaces, you'll see in our examples
    that generics help us in a different way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当在编译时创建通用类实例或使用方法时，将分配一个具体类型，但代码本身将其视为通用类型。能够编写通用代码是一个巨大的好处，当你需要以相同的方式处理不同的对象类型时，例如需要能够对元素执行相同操作的自定义集合类型，或者需要相同底层功能的类。虽然你可能会问为什么我们不只是子类化或使用接口，但在我们的例子中，你会看到通用类以不同的方式帮助我们。
- en: We've already seen this in action with the `List` type, which is a generic type.
    We can access all its addition, removal, and modification functions regardless
    of whether it's storing integers, strings, or individual characters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`List`类型中看到了这一点，它是一种通用类型。无论它存储整数、字符串还是单个字符，我们都可以访问它的所有添加、删除和修改函数。
- en: Generic objects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用对象
- en: 'Creating a generic class works the same as creating a non-generic class but
    with one important difference: its generic type parameter. Let''s take a look
    at an example of a generic collection class we might want to create to get a clearer
    picture of how this works:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通用类的方式与创建非通用类的方式相同，但有一个重要的区别：它的通用类型参数。让我们看一个我们可能想要创建的通用集合类的例子，以更清晰地了解它是如何工作的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've declared a generic collection class named `SomeGenericCollection` and
    specified that its type parameter will be named `T`. Now, `T` will stand in for
    the element type that the generic list will store and can be used inside the generic
    class just like any other type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`SomeGenericCollection`的通用集合类，并指定其类型参数将被命名为`T`。现在，`T`将代表通用列表将存储的元素类型，并且可以在通用类内部像任何其他类型一样使用。
- en: 'Whenever we create an instance of `SomeGenericCollection`, we need to specify
    the type of values it can store:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个`SomeGenericCollection`的实例时，我们需要指定它可以存储的值的类型：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, `highScores` stores integer values and `T` stands in for the `int`
    type, but the `SomeGenericCollection` class will treat any element type the same.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`highScores`存储整数值，`T`代表`int`类型，但`SomeGenericCollection`类将以相同的方式处理任何元素类型。
- en: You have complete control over naming a generic type parameter, but the industry
    standard in many programming languages is a capital `T`. If you are going to name
    your type parameters differently, consider starting the name with a capital `T`
    for consistency and readability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全可以控制通用类型参数的命名，但在许多编程语言中，行业标准是使用大写的`T`。如果你要为你的类型参数命名不同的名称，考虑以大写的`T`开头以保持一致性和可读性。
- en: 'Let''s create a more game-focused example next with a generic `Shop` class
    to store some fictional inventory items with the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来创建一个更加游戏化的例子，使用通用的`Shop`类来存储一些虚构的库存物品，具体步骤如下：
- en: 'Create a new C# script in the `Scripts` folder, name it `Shop`, and update
    its code to the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`Shop`，并将其代码更新为以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new instance of `Shop` in `GameBehavior`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中创建一个`Shop`的新实例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: Declares a new generic class named `IShop` with a `T` type parameter
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`IShop`的新通用类，带有`T`类型参数
- en: Adds an inventory `List<T>` of type `T` to store whatever item types we initialize
    the generic class with
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为`T`的库存`List<T>`，用于存储我们用通用类初始化的任何物品类型
- en: Creates a new instance of `Shop<string>` in `GameBehavior` and specifies string
    values as the generic type
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中创建一个`Shop<string>`的新实例，并指定字符串值作为通用类型
- en: Prints out a debug message with the inventory count:![](img/B17573_13_01.png)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出一个带有库存计数的调试消息：![](img/B17573_13_01.png)
- en: 'Figure 13.1: Console output from a generic class'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：来自泛型类的控制台输出
- en: Nothing new has happened here yet in terms of functionality, but Visual Studio
    recognizes `Shop` as a generic class because of its generic type parameter, `T`.
    This sets us up to include additional generic operations like adding inventory
    items or finding how many of each item is available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面还没有发生任何新的事情，但是Visual Studio因为其泛型类型参数`T`而将`Shop`识别为泛型类。这使我们能够包括其他泛型操作，如添加库存项目或查找每种项目的数量。
- en: It's worth noting here that generics aren't supported by the Unity Serializer
    by default. If you want to serialize generic classes, like we did with custom
    classes in the last chapter, you need to add the `Serializable` attribute to the
    top of class, like we did with our `Weapon` class. You can find more information
    at [https://docs.unity3d.com/ScriptReference/SerializeReference.html](https://docs.unity3d.com/ScriptReference/SerializeReference.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Unity Serializer默认不支持泛型。如果要序列化泛型类，就像我们在上一章中对自定义类所做的那样，您需要在类的顶部添加`Serializable`属性，就像我们在`Weapon`类中所做的那样。您可以在[https://docs.unity3d.com/ScriptReference/SerializeReference.html](https://docs.unity3d.com/ScriptReference/SerializeReference.html)找到更多信息。
- en: Generic methods
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型方法
- en: 'A standalone generic method can have a placeholder type parameter, just like
    a generic class, which allows it to be included inside either a generic or non-generic
    class as needed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独立的泛型方法可以有一个占位符类型参数，就像一个泛型类一样，这使它可以根据需要包含在泛型或非泛型类中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `T` type can be used inside the method body and defined when the method
    is called:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`类型可以在方法体内使用，并在调用方法时定义：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to declare a generic method inside a generic class, you don''t
    need to specify a new `T` type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在泛型类中声明泛型方法，则不需要指定新的`T`类型：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you call a non-generic method that uses a generic type parameter, there''s
    no issue because the generic class has already taken care of assigning a concrete
    type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用使用泛型类型参数的非泛型方法时，没有问题，因为泛型类已经处理了分配具体类型的问题：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generic methods can be overloaded and marked as static, just like non-generic
    methods. If you want the specific syntax for those situations, check out [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法可以被重载并标记为静态，就像非泛型方法一样。如果您想要这些情况的具体语法，请查看[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods)。
- en: Your next task is to create a method that adds new generic items to the inventory
    and use it in the `GameBehavior` script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务是创建一个方法，将新的泛型项目添加到库存，并在`GameBehavior`脚本中使用它。
- en: 'Since we already have a generic class with a defined type parameter, let''s
    add a non-generic method to see them working together:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个具有定义类型参数的泛型类，让我们添加一个非泛型方法来看它们如何一起工作：
- en: 'Open up `Shop` and update the code as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Shop`并按以下方式更新代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go into `GameBehavior` and add an item to `itemShop`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`GameBehavior`并向`itemShop`添加一个项目：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down the code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解代码：
- en: Declares a method for adding `newItems` of type `T` to the inventory
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个添加`newItems`的类型`T`到库存的方法
- en: Adds two string items to `itemShop` using `AddItem()` and prints out a debug
    log:![](img/B17573_13_02.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AddItem()`向`itemShop`添加两个字符串项目，并打印出调试日志：![](img/B17573_13_02.png)
- en: 'Figure 13.2: Console output after adding an item to a generic class'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：向泛型类添加项目后的控制台输出
- en: We wrote `AddItem()` to take in a parameter of the same type as our generic
    `Shop` instance. Since `itemShop` was created to hold string values, we add the
    `"Potion"` and `"Antidote"` string values without any issues.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了`AddItem()`以接受与我们的泛型`Shop`实例相同类型的参数。由于`itemShop`被创建为保存字符串值，我们可以毫无问题地添加`"Potion"`和`"Antidote"`字符串值。
- en: 'However, if you try and add an integer, for example, you''ll get an error saying
    that the generic type of the `itemShop` doesn''t match:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果尝试添加一个整数，例如，您将收到一个错误，指出`itemShop`的泛型类型不匹配：
- en: '![](img/B17573_13_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_03.png)'
- en: 'Figure 13.3: Conversion error in a generic class'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：泛型类中的转换错误
- en: Now that you've written a generic method, you need to know how to use multiple
    generic types in a single class. For example, what if we wanted to add a method
    to the `Shop` class that finds out how many of a given item are in stock? We can't
    use type `T` again because it's already been defined in the class definition.
    So what do we do?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经编写了一个泛型方法，需要知道如何在单个类中使用多个泛型类型。例如，如果我们想要向`Shop`类添加一个方法，找出库存中有多少个给定项目？我们不能再次使用类型`T`，因为它已经在类定义中定义了。那么我们该怎么办呢？
- en: 'Add the following method to the bottom of the `Shop` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到`Shop`类的底部：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down our new method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解我们的新方法：
- en: Declares a method that returns an int value for how many matching items of type
    `U` we find in the inventory
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个方法，返回我们在库存中找到的类型`U`的匹配项目的int值
- en: Generic type parameter naming is completely up to you, just like naming variables.
    Conventionally, they start at `T` and continue in alphabetical order from there.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型参数的命名完全取决于您，就像命名变量一样。按照惯例，它们从`T`开始，然后按字母顺序继续。
- en: Creates a variable to hold the number of matching stock items we find and eventually
    return from the inventory
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存我们找到的匹配库存项目的数量，并最终从库存中返回
- en: Uses a `foreach` loop to go through the inventory list and increase the stock
    value every time a match is found
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`foreach`循环遍历库存列表，并在找到匹配时增加库存值
- en: Returns the number of matching stock items
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回匹配库存项目的数量
- en: 'The problem here is that we''re storing string values in our shop, so if we
    try and look up how many string items we have, we''ll get the full inventory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们在商店中存储字符串值，因此如果我们尝试查找我们有多少字符串项目，我们将得到完整的库存：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print something like the following to the console:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印出类似以下内容：
- en: '![](img/B17573_13_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_04.png)'
- en: 'Figure 13.4: Console output from using multiple generic string types'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：使用多个泛型字符串类型的控制台输出
- en: 'On the other hand, if we tried to look up integer types in our inventory, we''d
    get no results because we''re only storing strings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们试图在我们的库存中查找整数类型，我们将得不到结果，因为我们只存储字符串：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will print something like the following to the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印类似以下内容：
- en: '![](img/B17573_13_05.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_05.png)'
- en: 'Figure 13.5: Console output using multiple non-matching generic types'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：使用多个不匹配的泛型类型的控制台输出
- en: Neither of these scenarios is ideal since we can't make sure our shop inventory
    is storing AND can be searched for the same item type. But here's where generics
    really shine—we can add rules for our generic classes and methods to enforce the
    behavior we want, which we'll cover in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都不理想，因为我们无法确保我们的商店库存既存储又可以搜索相同的物品类型。但这就是泛型真正发挥作用的地方——我们可以为我们的泛型类和方法添加规则，以强制执行我们想要的行为，我们将在下一节中介绍。
- en: Constraint type parameters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束类型参数
- en: One of the great things about generics is that their type parameters can be
    limited. This might contradict what we've learned about generics so far, but just
    because a class *can* contain any type, doesn't mean it should be allowed to.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一大优点是它们的类型参数可以受限制。这可能与我们迄今为止学到的有所矛盾，但只是因为一个类*可以*包含任何类型，并不意味着应该允许它这样做。
- en: 'To constrain a generic type parameter, we need a new keyword and a syntax we
    haven''t seen before:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了约束泛型类型参数，我们需要一个新关键字和一个我们以前没有见过的语法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `where` keyword defines the rules that `T` must pass before it can be used
    as a generic type parameter. It essentially says `SomeGenericClass` can take in
    any `T` type as long as it conforms to the constraining type. The constraining
    rules aren''t anything mystical or scary; they''re concepts we''ve already covered:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`关键字定义了`T`必须通过的规则，然后才能用作泛型类型参数。它基本上说`SomeGenericClass`可以接受任何`T`类型，只要它符合约束类型。约束规则并不神秘或可怕；它们是我们已经涵盖的概念：'
- en: Adding the `class` keyword would constrain `T` to types that are classes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`class`关键字将限制`T`为类类型
- en: Adding the `struct` keyword would constrain `T` to types that are structs
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`struct`关键字将限制`T`为结构类型
- en: Adding an interface, such as `IManager`, as the type would limit `T` to types
    that adopt the interface
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加接口，如`IManager`，作为类型将限制`T`为采用该接口的类型
- en: Adding a custom class, such as `Character`, would constrain `T` to only that
    class type
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义类，如`Character`，将限制`T`仅为该类类型
- en: 'If you need a more flexible approach to account for classes that have subclasses,
    you can use `where T : U`, which specifies that the generic `T` type must be of,
    or derive from, the `U` type. This is a little advanced for our needs, but you
    can find more details at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更灵活的方法来考虑具有子类的类，您可以使用`where T：U`，它指定泛型`T`类型必须是`U`类型或派生自`U`类型。这对我们的需求来说有点高级，但您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)找到更多详细信息。
- en: 'Just for fun, let''s constrain `Shop` to only accept a new type called `Collectable`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，让我们将`Shop`限制为只接受一个名为`Collectable`的新类型：
- en: 'Create a new script in the `Scripts` folder, name it `Collectable`, and add
    the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新脚本，命名为`Collectable`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All we've done here is declare a new class called `Collectable` with a name
    property, and created subclasses for potions and antidotes. With this structure,
    we can enforce our `Shop` to only accept `Collectable` types, and our stock finding
    method to only accept `Collectable` types as well so we can compare them and find
    matches.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是声明一个名为`Collectable`的新类，具有一个名称属性，并为药水和解毒剂创建了子类。有了这个结构，我们可以强制我们的`Shop`只接受`Collectable`类型，并且我们的库存查找方法也只接受`Collectable`类型，这样我们就可以比较它们并找到匹配项。
- en: 'Open up `Shop` and update the class declaration:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Shop`并更新类声明：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the `GetStockCount()` method to constrain `U` to equal whatever the
    initial generic `T` type is:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`GetStockCount()`方法以将`U`约束为与初始泛型`T`类型相等：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `GameBehavior`, update the `itemShop` instance to the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中，将`itemShop`实例更新为以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in output like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致类似以下的输出：
- en: '![](img/B17573_13_12.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_12.png)'
- en: 'Figure 13.6: Output from updated GameBehavior script'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：更新后的GameBehavior脚本输出
- en: In our example, we can ensure only collectable types are allowed in our shops.
    If we accidentally try and add non-collectable types in our code, Visual Studio
    will alert us about trying to break our own rules!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以确保只有可收集类型被允许在我们的商店中。如果我们在代码中意外地尝试添加不可收集类型，Visual Studio将警告我们尝试违反我们自己的规则！
- en: Adding generics to Unity objects
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Unity对象添加泛型
- en: Generics also work with Unity scripts and GameObjects. For example, we can easily
    create a generic destroyable class to use on any `MonoBehaviour` or object `Component`
    we want to delete from the scene. If this sounds familiar, it's what our `BulletBehavior`
    does for us, but it's not applicable to anything other than that script. To make
    this more scalable, let's make any script that inherits from `MonoBehaviour` destroyable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型也适用于Unity脚本和游戏对象。例如，我们可以轻松地创建一个通用的可销毁类，用于删除场景中的任何`MonoBehaviour`或对象`Component`。如果这听起来很熟悉，那就是我们的`BulletBehavior`为我们做的事情，但它不适用于除该脚本之外的任何东西。为了使其更具可扩展性，让我们使任何从`MonoBehaviour`继承的脚本都可销毁。
- en: 'Create a new script in the `Scripts` folder, name it `Destroyable`, and add
    the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新脚本，命名为`Destroyable`，并添加以下代码：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Delete all the code inside `BulletBehavior` and inherit from the new generic
    class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`BulletBehavior`中的所有代码，并继承自新的通用类：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've now turned our `BulletBehavior` script into a generic destroyable object.
    Nothing changes in the Bullet Prefab, but we can make any other object destroyable
    by inheriting from the generic `Destroyable` class. In our example, this would
    boost code efficiency and reusability if we created multiple projectile Prefabs
    and wanted them all to be destroyable, but at different times.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将我们的`BulletBehavior`脚本转换为通用的可销毁对象。在Bullet Prefab中没有任何更改，但我们可以通过从通用的`Destroyable`类继承来使任何其他对象可销毁。在我们的示例中，如果我们创建了多个抛射物Prefab并希望它们都在不同的时间被销毁，那么这将提高代码效率和可重用性。
- en: Generic programming is a powerful tool in our toolbox, but with the basics covered
    it's time to talk about an equally important topic as you progress in your programming
    journey—delegation!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通用编程是我们工具箱中的一个强大工具，但是在掌握了基础知识之后，是时候谈谈编程旅程中同样重要的一个主题——委托了！
- en: Delegating actions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托操作
- en: There will be times when you need to pass off, or delegate, the execution of
    a method from one file to another. In C#, this can be accomplished through delegate
    types, which store references to methods and can be treated like any other variable.
    The only caveat is that the delegate itself and any assigned method need to have
    the same signature—just like integer variables can only hold whole numbers and
    strings can only hold text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要将一个文件中的方法执行委托给另一个文件。在C#中，可以通过委托类型来实现这一点，它存储对方法的引用，并且可以像任何其他变量一样对待。唯一的限制是委托本身和任何分配的方法都需要具有相同的签名——就像整数变量只能保存整数和字符串只能保存文本一样。
- en: 'Creating a delegate is a mix between writing a function and declaring a variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '创建委托是编写函数和声明变量的混合： '
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You start with an access modifier followed by the `delegate` keyword, which
    identifies it to the compiler as a `delegate` type. A `delegate` type can have
    a return type and name as a regular function, as well as parameters if needed.
    However, this syntax only declares the `delegate` type itself; to use it, you
    need to create an instance as we do with classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用访问修饰符，然后是`delegate`关键字，这将其标识为`delegate`类型。`delegate`类型可以像常规函数一样具有返回类型和名称，如果需要还可以有参数。但是，这种语法只是声明了`delegate`类型本身；要使用它，您需要像使用类一样创建一个实例：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With a `delegate` type variable declared, it''s easy to assign a method that
    matches the delegate signature:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个`delegate`类型变量后，很容易分配一个与委托签名匹配的方法：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that you don''t include the parentheses when assigning `MatchingMethod`
    to the `someDelegate` variable, as it''s not calling the method at this point.
    What it''s doing is delegating the calling responsibility of `MatchingMethod`
    to `someDelegate`, which means we can call the function as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在将`MatchingMethod`分配给`someDelegate`变量时，不要包括括号，因为此时并不是在调用该方法。它所做的是将`MatchingMethod`的调用责任委托给`someDelegate`，这意味着我们可以如下调用该函数：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This might seem cumbersome at this point in your C# skill development, but I
    promise you that being able to store and execute methods as variables will come
    in handy down the road.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的C#技能发展到这一点时，这可能看起来很麻烦，但我向您保证，能够将方法存储和执行为变量将在未来派上用场。
- en: Creating a debug delegate
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个调试委托
- en: 'Let''s create a simple delegate type to define a method that takes in a string
    and eventually prints it out using an assigned method. Open up `GameBehavior`
    and add the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的委托类型来定义一个接受字符串并最终使用分配的方法打印它的方法。打开`GameBehavior`并添加以下代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s break down the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares a `public delegate` type named `DebugDelegate` to hold a method that
    takes in a `string` parameter and returns `void`
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`DebugDelegate`的`public delegate`类型，用于保存一个接受`string`参数并返回`void`的方法
- en: Creates a new `DebugDelegate` instance named `debug` and assigns it a method
    with a matching signature named `Print()`
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`debug`的新`DebugDelegate`实例，并为其分配一个具有匹配签名的方法`Print()`
- en: Replaces the `Debug.Log(_state)` code inside `Initialize()` with a call to the
    `debug` delegate instance instead
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`debug`委托实例替换`Initialize()`中的`Debug.Log(_state)`代码
- en: Declares `Print()` as a `static` method that takes in a `string` parameter and
    logs it to the console:![](img/B17573_13_06.png)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Print()`为一个接受`string`参数并将其记录到控制台的`static`方法
- en: 'Figure 13.7: Console output from a delegate action'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：委托操作的控制台输出
- en: Nothing in the console has changed, but instead of directly calling `Debug.Log()`
    inside `Initialize()`, that operation has been delegated to the `debug` delegate
    instance. While this is a simplistic example, delegation is a powerful tool when
    you need to store, pass, and execute methods as their types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中没有任何变化，但是现在`Initialize()`中不再直接调用`Debug.Log()`，而是将该操作委托给了`debug`委托实例。虽然这是一个简单的例子，但是当您需要存储、传递和执行方法作为它们的类型时，委托是一个强大的工具。
- en: In Unity, we've already worked with examples of delegation by using the `OnCollisionEnter()`
    and `OnCollisionExit()` methods, which are methods that are called through delegation.
    In the real world, custom delegates are most useful when paired with events, which
    we'll see in a later section of this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，我们已经通过使用`OnCollisionEnter()`和`OnCollisionExit()`方法来处理委托的示例，这些方法是通过委托调用的。在现实世界中，自定义委托在与事件配对时最有用，我们将在本章的后面部分看到。
- en: Delegates as parameter types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托作为参数类型
- en: Since we've seen how to create delegate types for storing methods, it makes
    sense that a delegate type could also be used as a method parameter itself. This
    isn't that far removed from what we've already done, but it's a good idea to cover
    our bases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到如何创建委托类型来存储方法，那么委托类型本身也可以作为方法参数使用就是合情合理的。这与我们已经做过的并没有太大的不同，但是涵盖基础知识是个好主意。
- en: 'Let''s see how a delegate type can be used as a method parameter. Update `GameBehavior`
    with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看委托类型如何作为方法参数使用。使用以下代码更新`GameBehavior`：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s break down the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Calls `LogWithDelegate()` and passes in our `debug` variable as its type parameter
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`LogWithDelegate()`并将我们的`debug`变量作为其类型参数传递
- en: Declares a new method that takes in a parameter of the `DebugDelegate` type
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的方法，接受`DebugDelegate`类型的参数
- en: Calls the delegate parameter's function and passes in a string literal to be
    printed out:![](img/B17573_13_07.png)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用委托参数的函数，并传入一个字符串文字以打印出来：![](img/B17573_13_07.png)
- en: 'Figure 13.8: Console output of a delegate as a parameter type'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：委托作为参数类型的控制台输出
- en: We've created a method that takes in a parameter of the `DebugDelegate` type,
    which means that the actual argument passed in will represent a method and can
    be treated as one. Think of this example as a delegation chain, where `LogWithDelegate()`
    is two steps removed from the actual method doing the debugging, which is `Print()`.
    Creating a delegation chain like this isn't always a common solution in a game
    or application scenario, but when you need to control levels of delegation it's
    important to understand the syntax involved. This is especially true in scenarios
    where your delegation chain is spread across multiple scripts or classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个接受`DebugDelegate`类型参数的方法，这意味着传入的实际参数将表示一个方法，并且可以被视为一个方法。将这个例子视为一个委托链，其中`LogWithDelegate()`距离实际进行调试的方法`Print()`有两个步骤。创建这样的委托链并不总是在游戏或应用程序场景中常见的解决方案，但是当您需要控制委托级别时，了解涉及的语法是很重要的。在涉及到委托链跨多个脚本或类的情况下，这一点尤为重要。
- en: It's easy to get lost with delegation if you miss an important mental connection,
    so go back and review the code from the beginning of the section and check the
    docs at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您错过了重要的心理联系，很容易在委托中迷失，所以回到本节开头的代码并查看文档：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)。
- en: Now that you know how to work with basic delegates, it's time to talk about
    how events can be used to efficiently communicate information between multiple
    scripts. Honestly, the best use case for a delegate is being paired with events,
    which we'll dive into next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何处理基本委托了，是时候谈谈事件如何用于在多个脚本之间高效地传递信息了。老实说，委托的最佳用例是与事件配对使用，接下来我们将深入探讨。
- en: Firing events
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: C# events allow you to essentially create a subscription system based on actions
    in your games or apps. For instance, if you wanted to send out an event whenever
    an item is collected, or when a player presses the spacebar, you could do that.
    However, when an event fires, it doesn't automatically have a subscriber, or receiver,
    to handle any code that needs to execute after the event action.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C#事件允许您基本上创建一个基于游戏或应用程序中的操作的订阅系统。例如，如果您想在收集物品时发送事件，或者当玩家按下空格键时，您可以这样做。然而，当事件触发时，并不会自动有一个订阅者或接收者来处理任何需要在事件动作之后执行的代码。
- en: Any class can subscribe or unsubscribe to an event through the calling class
    the event is fired from; just like signing up to receive notifications on your
    phone when a new post is shared on Facebook, events form a kind of distributed-information
    superhighway for sharing actions and data across your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以通过调用事件被触发的类来订阅或取消订阅事件；就像在手机上注册接收Facebook上分享新帖子通知一样，事件形成了一种分布式信息高速公路，用于在应用程序中共享操作和数据。
- en: 'Declaring events is similar to declaring delegates in that an event has a specific
    method signature. We''ll use a delegate to specify the method signature we want
    the event to have, then create the event using the `delegate` type and the `event`
    keyword:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 声明事件类似于声明委托，因为事件具有特定的方法签名。我们将使用委托来指定我们希望事件具有的方法签名，然后使用`delegate`类型和`event`关键字创建事件：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This setup allows us to treat `eventInstance` as a method because it''s a delegate
    type, which means we can send it out at any time by calling it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置允许我们将`eventInstance`视为一个方法，因为它是一个委托类型，这意味着我们可以随时调用它来发送它：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Your next task is to create an event of your own and fire it off in the appropriate
    place inside `PlayerBehavior`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是在`PlayerBehavior`内部创建一个自己的事件并在适当的位置触发它。
- en: Creating and invoking events
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和调用事件
- en: 'Let''s create an event to fire off any time our player jumps. Open up `PlayerBehavior`
    and add the following changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个事件，以便在玩家跳跃时触发。打开`PlayerBehavior`并添加以下更改：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: Declares a new `delegate` type that returns `void` and takes in no parameters
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个返回`void`并且不带任何参数的新`delegate`类型
- en: Creates an event of the `JumpingEvent` type, named `playerJump`, that can be
    treated as a method that matches the preceding delegate's `void` return and no
    parameter signature
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`JumpingEvent`类型的事件，名为`playerJump`，可以被视为一个方法，与前面的委托的`void`返回和无参数签名相匹配
- en: Calls `playerJump` after the force is applied in `Update()`
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`中施加力后调用`playerJump`
- en: We have successfully created a simple delegate type that takes in no parameters
    and returns nothing, as well as an event of that type to execute whenever the
    player jumps. Each time the player jumps, the `playerJump` event is sent out to
    all of its subscribers to notify them of the action.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功创建了一个简单的委托类型，它不带任何参数并且不返回任何内容，以及一个该类型的事件，以便在玩家跳跃时执行。每次玩家跳跃时，`playerJump`事件都会发送给所有订阅者，通知它们该操作。
- en: After the event fires, it's up to its subscribers to process it and do any additional
    operations, which we'll see in the *Handling event subscriptions* section, next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事件触发后，由订阅者来处理它并执行任何额外的操作，我们将在*处理事件订阅*部分中看到。
- en: Handling event subscriptions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件订阅
- en: 'Right now, our `playerJump` event has no subscribers, but changing that is
    simple and very similar to how we assigned method references to delegate types
    in the last section:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`playerJump`事件没有订阅者，但更改很简单，非常类似于我们在上一节中将方法引用分配给委托类型的方式：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since events are variables that belong to the class they''re declared in, and
    subscribers will be other classes, a reference to the event-containing class is
    necessary for subscriptions. The `+=` operator is used to assign a method that
    will fire when an event executes, just like setting up an out-of-office email.
    Like assigning delegates, the method signature of the event handler method must
    match the event''s type. In our previous syntax example, that means `EventHandler`
    needs to be the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是属于声明它们的类的变量，而订阅者将是其他类，因此需要引用包含事件的类来进行订阅。`+=`运算符用于分配一个方法，当事件执行时将触发该方法，就像设置一个外出邮件一样。与分配委托一样，事件处理程序方法的方法签名必须与事件的类型匹配。在我们之前的语法示例中，这意味着`EventHandler`需要是以下内容：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In cases where you need to unsubscribe from an event, you simply do the reverse
    of the assignment by using the `-=` operator:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要取消订阅事件的情况下，您只需使用“-=”运算符执行分配的相反操作：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Event subscriptions are generally handled when a class is initialized or destroyed,
    making it easy to manage multiple events without messy code implementations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事件订阅通常在类初始化或销毁时处理，这样可以轻松管理多个事件，而不会出现混乱的代码实现。
- en: Now that you know the syntax for subscribing and unsubscribing to events, it's
    your turn to put this into practice in the `GameBehavior` script.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了订阅和取消订阅事件的语法，现在轮到您在`GameBehavior`脚本中将其付诸实践了。
- en: 'Now that our event is firing every time the player jumps, we need a way to
    capture that action:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的事件每次玩家跳跃时都会触发，我们需要一种捕获该动作的方法：
- en: 'Go back to `GameBehavior` and update the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`GameBehavior`并更新以下代码：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s break down the code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: Creates a public variable of type `PlayerBehavior`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PlayerBehavior`类型的公共变量
- en: Declares the `OnEnable()` method, which is called whenever the object the script
    is attached to becomes active in the scene
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`OnEnable()`方法，每当附加了脚本的对象在场景中变为活动状态时都会调用该方法
- en: '`OnEnable` is a method in the `MonoBehaviour` class, so all Unity scripts have
    access to it. This is a great place to put event subscriptions instead of `Awake`
    because it only executes when the object is active, not just in the process of
    loading.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEnable`是`MonoBehaviour`类中的一个方法，因此所有Unity脚本都可以访问它。这是一个很好的地方来放置事件订阅，而不是在`Awake`中执行，因为它只在对象活动时执行，而不仅仅是在加载过程中执行。'
- en: Finds the `Player` object in the scene and stores its `GameObject` in a local
    variable
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中查找`Player`对象并将其`GameObject`存储在一个局部变量中
- en: Uses `GetComponent()` to retrieve a reference to the `PlayerBehavior` class
    attached to the `Player` and stores it in the `playerBehavior` variable
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetComponent()`检索附加到`Player`的`PlayerBehavior`类的引用，并将其存储在`playerBehavior`变量中
- en: Subscribes to the `playerJump` event declared in `PlayerBehavior` with a method
    named `HandlePlayerJump` using the `+=` operator
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`+=`运算符订阅了在`PlayerBehavior`中声明的`playerJump`事件，并使用名为`HandlePlayerJump`的方法
- en: Declares the `HandlePlayerJump()` method with a signature that matches the event's
    type and logs a success message using the debug delegate each time the event is
    received:![](img/B17573_13_08.png)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`HandlePlayerJump()`方法，其签名与事件的类型匹配，并使用调试委托每次接收到事件时记录成功消息！[](img/B17573_13_08.png)
- en: 'Figure 13.9: Console output from a delegate event subscription'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：委托事件订阅的控制台输出
- en: To correctly subscribe and receive events in `GameBehavior`, we had to grab
    a reference to the `PlayerBehavior` class attached to the player. We could have
    done this all in one line, but it's much more readable when it's split up. We
    then assigned a method to the `playerJump` event that will execute whenever the
    event is received, and complete the subscription process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确订阅和接收`GameBehavior`中的事件，我们必须获取到玩家附加的`PlayerBehavior`类的引用。我们本可以一行代码完成所有操作，但将其拆分开来更加可读。然后，我们分配了一个方法给`playerJump`事件，每当接收到事件时都会执行该方法，并完成订阅过程。
- en: 'Now each time you jump, you''ll see a debug message with the event message:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次跳跃时，您都会看到带有事件消息的调试消息：
- en: '![](img/B17573_13_09.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_09.png)'
- en: 'Figure 13.10: Console output from a delegate event firing'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：委托事件触发的控制台输出
- en: Since event subscriptions are configured in scripts, and scripts are attached
    to Unity objects, our job isn't done yet. We still need to handle how we clean
    up subscriptions when the object is destroyed or removed from the scene, which
    we'll cover in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件订阅是在脚本中配置的，并且脚本附加到Unity对象上，我们的工作还没有完成。当对象被销毁或从场景中移除时，我们仍然需要处理如何清理订阅，这将在下一节中介绍。
- en: Cleaning up event subscriptions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理事件订阅
- en: Even though our player is never destroyed in our prototype, that's a common
    feature in games when you lose. It's always important to clean up event subscriptions
    because they take up allocated resources, as we discussed with streams in *Chapter
    12*, *Saving, Loading, and Serializing Data*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们的原型中，玩家永远不会被销毁，但在游戏中失去玩家是一个常见的特性。清理事件订阅非常重要，因为它们占用了分配的资源，正如我们在*第12章*“保存、加载和序列化数据”中讨论的流一样。
- en: 'We don''t want any subscriptions hanging around after the subscribed object
    has been destroyed, so let''s clean up our jumping event. Add the following code
    to `GameBehavior` after the `OnEnable` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在订阅对象被销毁后仍然保留任何订阅，因此让我们清理一下我们的跳跃事件。在`OnEnable`方法之后，将以下代码添加到`GameBehavior`中：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s break down our new code addition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解我们的新代码添加：
- en: Declares the `OnDisable()` method, which belongs to the `MonoBehavior` class
    and is the companion to the `OnEnable()` method we used earlier
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`OnDisable()`方法，它属于`MonoBehavior`类，并且是我们之前使用的`OnEnable()`方法的伴侣
- en: Any cleanup code you need to write should generally go in this method, as it
    executes when the object the script is attached to is inactive
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要编写的任何清理代码通常应该放在这个方法中，因为它在附加了脚本的对象处于非活动状态时执行
- en: Unsubscribes the `playerJump` event from `HandlePlayerJump` using the `-=` operator
    and print out a console message
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“-=”运算符取消`HandlePlayerJump`中的`playerJump`事件的订阅，并打印出控制台消息
- en: Now our script properly subscribes and unsubscribes to an event when the GameObject
    is enabled and disabled, leaving no unused resources in our game scene.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的脚本在游戏对象启用和禁用时正确订阅和取消订阅事件，不会在我们的游戏场景中留下未使用的资源。
- en: That wraps up our discussion on events. Now you can broadcast them to every
    corner of your game from a single script and react to scenarios like a player
    losing life, collecting items, or updating the UI. However, we still have to discuss
    a very important topic that no program can succeed without, and that's error handling.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对事件的讨论。现在你可以从一个脚本广播它们到游戏的每个角落，并对玩家失去生命、收集物品或更新UI等情况做出反应。然而，我们仍然需要讨论一个非常重要的话题，没有它，没有程序能成功，那就是错误处理。
- en: Handling exceptions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: Efficiently incorporating errors and exceptions into your code is both a professional
    and personal benchmark in your programming journey. Before you start yelling "Why
    would I add errors when I've spent all this time trying to avoid them?!", you
    should know that I don't mean adding errors to break your existing code. It's
    quite the opposite—including errors or exceptions and handling them appropriately
    when pieces of functionality are used incorrectly makes your code base stronger
    and less prone to crashes, not weaker.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地将错误和异常纳入代码中，是你编程之旅中的专业和个人标杆。在你开始大喊“我花了这么多时间避免错误，为什么要添加错误？！”之前，你应该知道我并不是指添加错误来破坏你现有的代码。相反，包括错误或异常，并在功能部分被错误使用时适当处理它们，会使你的代码库更加强大，更不容易崩溃，而不是更弱。
- en: Throwing exceptions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: When we talk about adding errors, we refer to the process as *exception throwing*,
    which is an apt visual analogy. Throwing exceptions is part of something called
    defensive programming, which essentially means that you actively and consciously
    guard against improper or unplanned operations in your code. To mark those situations,
    you throw out an exception from a method that is then handled by the calling code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论添加错误时，我们将这个过程称为*异常抛出*，这是一个恰当的视觉类比。抛出异常是防御性编程的一部分，这基本上意味着你在代码中积极有意识地防范不当或非计划的操作。为了标记这些情况，你从一个方法中抛出一个异常，然后由调用代码处理。
- en: 'Let''s take an example: say we have an `if` statement that checks whether a
    player''s email address is valid before letting them sign up. If the email entered
    is not valid, we want our code to throw an exception:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：假设我们有一个`if`语句，检查玩家的电子邮件地址是否有效，然后才允许他们注册。如果输入的电子邮件无效，我们希望我们的代码抛出异常：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the `throw` keyword to send out the exception, which is created with
    the `new` keyword followed by the exception we specify. `System.ArgumentException()`
    will log the information about where and when the exception was executed by default,
    but can also accept a custom string if you want to be more specific.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`throw`关键字来抛出异常，异常是使用`new`关键字后跟我们指定的异常创建的。`System.ArgumentException()`默认会记录关于异常在何时何地执行的信息，但也可以接受自定义字符串，如果你想更具体。
- en: '`ArgumentException` is a subclass of the `Exception` class and is accessed
    through the `System` class shown previously. C# comes with many built-in exception
    types, including subclasses for checking for null values, out or range collection
    values, and invalid operations. Exceptions are a prime example of using the right
    tool for the right job. Our example only needs the basic `ArgumentException`,
    but you can find the full descriptive list at [https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard](https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentException`是`Exception`类的子类，并且通过之前显示的`System`类访问。C#带有许多内置的异常类型，包括用于检查空值、超出范围的集合值和无效操作的子类。异常是使用正确的工具来做正确的工作的一个典型例子。我们的例子只需要基本的`ArgumentException`，但你可以在[https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard](https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard)找到完整的描述列表。'
- en: 'Let''s keep things simple on our first foray into exceptions and make sure
    that our level only restarts if we provide a positive scene index number:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试异常处理时，让事情保持简单，并确保我们只有在提供正的场景索引号时才重新开始关卡：
- en: 'Open up `Utilities` and add the following code to the overloaded version of
    `RestartLevel(int)`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Utilities`并将以下代码添加到重载版本的`RestartLevel(int)`中：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Change `RestartLevel()` in `GameBehavior` to take in a negative scene index
    and lose the game:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中将`RestartLevel()`更改为接受负场景索引并且输掉游戏：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s break down the code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: Declares an `if` statement to check that `sceneIndex` is not less than 0 or
    a negative number
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`if`语句来检查`sceneIndex`是否不小于0或负数
- en: Throws an `ArgumentException` with a custom message if a negative scene index
    is passed in as an argument
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传入一个负的场景索引作为参数，抛出一个带有自定义消息的`ArgumentException`
- en: Calls `RestartLevel()` with a scene index of `-1`:![](img/B17573_13_10.png)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用场景索引为`-1`调用`RestartLevel()`：![](img/B17573_13_10.png)
- en: 'Figure 13.11: Console output when an exception is thrown'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：抛出异常时的控制台输出
- en: When we lose the game now, `RestartLevel()` is called, but since we're using
    `-1` as the scene index argument, our exception is fired before any of the scene
    manager logic is executed. We don't have any other scenes configured in our game
    at the moment, but this defensive code acts as a safeguard and doesn't let us
    take an action that might crash the game (Unity doesn't support negative indexes
    when loading scenes).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们输掉游戏时，会调用`RestartLevel()`，但由于我们使用`-1`作为场景索引参数，我们的异常会在任何场景管理逻辑执行之前被触发。我们目前游戏中没有配置其他场景，但这个防御性代码作为保障，不让我们执行可能导致游戏崩溃的操作（Unity在加载场景时不支持负索引）。
- en: Now that you've successfully thrown an error, you need to know how to handle
    the fallout from the error, which leads us to our next section and the `try-catch`
    statement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你成功地抛出了一个错误，你需要知道如何处理错误的后果，这将引导我们进入下一节和`try-catch`语句。
- en: Using try-catch
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用try-catch
- en: 'Now that we''ve thrown an error, it''s our job to safely handle the possible
    outcomes that calling `RestartLevel()` might have because at this point, this
    is not addressed properly. The way to do this is with a new kind of statement,
    called `try-catch`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经抛出了一个错误，我们的工作是安全地处理调用`RestartLevel()`可能产生的可能结果，因为在这一点上，这没有得到适当的处理。要做到这一点，需要使用一种新的语句，称为`try-catch`：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `try-catch` statement is made up of consecutive code blocks that are executed
    on different conditions; it's like a specialized `if`/`else` statement. We call
    any methods that potentially throw exceptions in the `try` block—if no exceptions
    are thrown, the code keeps executing without interruption. If an exception is
    thrown, the code jumps to the `catch` statement that matches the thrown exception,
    just like `switch` statements do with their cases. `catch` statements need to
    define what exception they are accounting for and specify a local variable name
    that will represent it inside the `catch` block.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-catch`语句由连续的代码块组成，这些代码块在不同的条件下执行；它就像一个专门的`if`/`else`语句。我们在`try`块中调用可能引发异常的任何方法——如果没有引发异常，代码将继续执行而不中断。如果引发异常，代码将跳转到与抛出异常匹配的`catch`语句，就像`switch`语句与其case一样。`catch`语句需要定义它们要处理的异常，并指定一个本地变量名，该变量将在`catch`块内表示它。'
- en: 'You can chain as many `catch` statements after the `try` block as you need
    to handle multiple exceptions thrown from a single method, provided they are catching
    different exceptions. For example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`try`块之后链接多个`catch`语句，以处理从单个方法抛出的多个异常，只要它们捕获不同的异常。例如：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There''s also an optional `finally` block that can be declared after any `catch`
    statements that will execute at the very end of the `try-catch` statement, regardless
    of whether an exception was thrown:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可选的`finally`块，可以在任何`catch`语句之后声明，无论是否抛出异常，它都将在`try-catch`语句的最后执行：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your next task is to use a `try-catch` statement to handle any errors thrown
    from restarting the level unsuccessfully. Now that we have an exception that is
    thrown when we lose the game, let''s handle it safely. Update `GameBehavior` with
    the following code and lose the game again:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务是使用`try-catch`语句处理重新启动关卡时抛出的任何错误。现在我们有一个在游戏失败时抛出的异常，让我们安全地处理它。使用以下代码更新`GameBehavior`，然后再次失败游戏：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s break down the code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares the `try` block and moves the call to `RestartLevel()` inside with
    a `debug` command to print out if the restart is completed without any exceptions.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`try`块，并将调用`RestartLevel()`移至其中，并使用`debug`命令打印出重新启动是否完成而没有任何异常。
- en: Declares the `catch` block and defines `System.ArgumentException` as the exception
    type it will handle and `exception` as the local variable name.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`catch`块，并将`System.ArgumentException`定义为它将处理的异常类型，`exception`作为局部变量名。
- en: 'Restarts the game at the default scene index if the exception is thrown:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抛出异常，则在默认场景索引处重新启动游戏：
- en: Uses the `debug` delegate to print out a custom message, plus the exception
    information, which can be accessed from `exception` and converted into a string
    with the `ToString()` method
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`debug`委托打印出自定义消息，以及可以从`exception`访问并使用`ToString()`方法将其转换为字符串的异常信息
- en: Since `exception` is of the `ArgumentException` type, there are several properties
    and methods associated with the `Exception` class that you can access. These are
    often useful when you need detailed information about a particular exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`exception`是`ArgumentException`类型，因此与`Exception`类关联的有几个属性和方法，您可以访问这些属性和方法。当您需要关于特定异常的详细信息时，这些通常很有用。
- en: Adds a `finally` block with a debug message to signal the end of the exception-handling
    code:![](img/B17573_13_11.png)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有调试消息的`finally`块，以表示异常处理代码的结束！[](img/B17573_13_11.png)
- en: 'Figure 13.12: Console output of a complete try-catch statement'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：完整的try-catch语句的控制台输出
- en: When `RestartLevel()` is called now, our `try` block safely allows it to execute,
    and if an error is thrown, it's caught inside the `catch` block. The `catch` block
    restarts the level at the default scene index and the code proceeds to the `finally`
    block, which simply logs a message for us.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在调用`RestartLevel()`时，我们的`try`块安全地允许其执行，如果出现错误，则在`catch`块内捕获。`catch`块在默认场景索引处重新启动关卡，代码继续执行到`finally`块，该块只是为我们记录一条消息。
- en: It's important to understand how to work with exceptions, but you shouldn't
    get into the habit of putting them everywhere in your code. This will lead to
    bloated classes and might affect the game's processing time. Instead, you want
    to use exceptions where they are most needed—invalidation or data processing,
    rather than game mechanics.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理异常很重要，但不应该养成在代码中随处放置异常的习惯。这将导致臃肿的类，并可能影响游戏的处理时间。相反，您应该在最需要的地方使用异常——无效或数据处理，而不是游戏机制。
- en: 'C# allows you the freedom to create your exception types to suit any specific
    needs your code might have, but that''s beyond the scope of this book. It''s just
    a good thing to remember for the future: [https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许您自由创建自己的异常类型，以满足代码可能具有的任何特定需求，但这超出了本书的范围。这只是一个未来要记住的好事情：[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions)。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While this chapter brings us to the end of our practical adventure into C# and
    Unity 2020, I hope that your journey into game programming and software development
    has just begun. You've learned everything from creating variables, methods, and
    class objects to writing your game mechanics, enemy behavior, and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章将我们带到了C#和Unity 2020的实际冒险的尽头，但我希望您的游戏编程和软件开发之旅刚刚开始。您已经学会了从创建变量、方法和类对象到编写游戏机制、敌人行为等方方面面的知识。
- en: 'The topics we''ve covered in this chapter have been a level above what we dealt
    with for the majority of this book, and with good reason. You already know your
    programming brain is a muscle that you need to exercise before you can advance
    to the next plateau. That''s all generics, events, and design patterns are: just
    the next rung up the programming ladder.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题已经超出了我们在大部分书中处理的水平，这是有充分理由的。你已经知道你的编程大脑是需要锻炼的肌肉，才能进入下一个阶段。泛型、事件和设计模式都只是编程阶梯上的下一个台阶。
- en: In the next chapter, I will leave you with resources, further reading, and lots
    of other helpful (and, dare I say, cool) opportunities and information about the
    Unity community and the software development industry at large.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将为你提供资源、进一步阅读以及有关Unity社区和软件开发行业的大量其他有用（我敢说，很酷）的机会和信息。
- en: Happy coding!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编程愉快！
- en: Pop quiz – intermediate C#
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出测验-中级C#
- en: What is the difference between a generic and non-generic class?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型和非泛型类之间有什么区别？
- en: What needs to match when assigning a value to a delegate type?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为委托类型分配值时需要匹配什么？
- en: How would you unsubscribe from an event?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何取消订阅事件？
- en: Which C# keyword would you use to send out an exception in your code?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中，你会使用哪个C#关键字来发送异常？
- en: JOIN us on Discord!
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流，以及更多。
- en: Join Now!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
