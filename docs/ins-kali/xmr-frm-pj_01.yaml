- en: Introduction to Xamarin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin简介
- en: This chapter is all about getting to know what Xamarin is and what to expect
    from it. It is the only chapter that is a pure theory chapter; all the others
    will cover hands-on projects. You're not expected to write any code at this point,
    but instead, simply read through the chapter to develop a high-level understanding
    of what Xamarin is and how Xamarin.Forms are related to Xamarin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍Xamarin是什么以及可以从中期望什么。这是唯一的纯理论章节；其他章节将涵盖实际项目。您不需要在此时编写任何代码，而是简单地阅读本章，以开发对Xamarin是什么以及Xamarin.Forms与Xamarin的关系的高层理解。
- en: We will start by defining what a native application is and what .NET as a technology
    brings to the table. After that, we will look at how Xamarin.Forms fit into the
    bigger picture and
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义什么是原生应用程序以及.NET作为一种技术带来了什么。之后，我们将看一下Xamarin.Forms如何适应更大的图景和
- en: learn when it is appropriate to use traditional Xamarin and Xamarin.Forms. We
    often use the term *traditional Xamarin* to describe applications that don't use Xamarin.Forms,
    even though Xamarin.Forms applications are bootstrapped through a traditional Xamarin application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习何时适合使用传统的Xamarin和Xamarin.Forms。我们经常使用术语*传统的Xamarin*来描述不使用Xamarin.Forms的应用程序，尽管Xamarin.Forms应用程序是通过传统的Xamarin应用程序引导的。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Native applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生应用程序
- en: Xamarin and Mono
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin和Mono
- en: Xamarin.Forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.Forms
- en: Setting up a development machine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发机器
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Native applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生应用程序
- en: 'The term **native application** means different things to different people. For
    some people, it is an application that is developed using the tools specified
    by the creator of the platform, such as an application developed for iOS with
    Objective-C or Swift, an Android app developed with Java or Kotlin, or a Windows
    app developed with .NET. Other people use the term *native application* to refer
    to applications that are compiled to machine code that is native. In this book,
    we will define a native application as one that has a native user interface, performance,
    and API access. The following list explains these three concepts in greater detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**原生应用程序**对不同的人有不同的含义。对一些人来说，这是使用平台创建者指定的工具开发的应用程序，例如使用Objective-C或Swift开发的iOS应用程序，使用Java或Kotlin开发的Android应用程序，或使用.NET开发的Windows应用程序。其他人使用术语*原生应用程序*来指代编译为本机机器代码的应用程序。在本书中，我们将定义原生应用程序为具有本机用户界面、性能和API访问的应用程序。以下列表详细解释了这三个概念：
- en: '**Native user interface**:Applications built with Xamarin use the standard
    controls for each platform. This means, for example, that an iOS app built with
    Xamarin will look and behave as an iOS user would expect, and an Android app built
    with Xamarin will look and behave as an Android user would expect.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生用户界面**：使用Xamarin构建的应用程序使用每个平台的标准控件。这意味着，例如，使用Xamarin构建的iOS应用程序将看起来和行为与iOS用户期望的一样，使用Xamarin构建的Android应用程序将看起来和行为与Android用户期望的一样。'
- en: '**Native performance**: Applications built with Xamarin are compiled for native
    performance and could use platform-specific hardware acceleration.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生性能**：使用Xamarin构建的应用程序经过本地性能编译，可以使用特定于平台的硬件加速。'
- en: '**Native API access: **Native API access means that applications built with
    Xamarin could use everything that the target platforms and devices offer to developers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生API访问：**原生API访问意味着使用Xamarin构建的应用程序可以使用目标平台和设备为开发人员提供的一切。'
- en: Xamarin and Mono
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin和Mono
- en: Xamarin is a developer platform that is used for developing native applications
    for iOS (Xamarin.iOS), Android (Xamarin.Android), and macOS (Xamarin.Mac). It is
    technically a binding layer on top of these platforms. Binding to platform APIs
    enables .NET developers to use C# (and F#) to develop native applications with
    the full capacity of each platform. The C# APIs we use when we develop applications
    with Xamarin are more or less identical to the platform APIs, but they are *.NETified*.
    For example, APIs are often customized to follow .NET naming conventions, and
    Android `set` and `get` methods are often replaced by properties. The reason for
    this is that APIs should be easier to use for .NET developers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin是一个开发平台，用于开发iOS（Xamarin.iOS）、Android（Xamarin.Android）和macOS（Xamarin.Mac）的原生应用程序。它在这些平台的顶部技术上是一个绑定层。绑定到平台API使.NET开发人员可以使用C#（和F#）开发具有每个平台完整功能的原生应用程序。我们在使用Xamarin开发应用程序时使用的C#
    API与平台API几乎相同，但它们是*.NET化*的。例如，API通常定制以遵循.NET命名约定，并且Android的`set`和`get`方法通常被属性替换。这样做的原因是API应该更容易供.NET开发人员使用。
- en: Mono ([https://www.mono-project.com](https://www.mono-project.com/)) is an open
    source implementation of the Microsoft .NET framework, which is based on the **European
    Computer Manufacturers Association** (**ECMA**) standards for C# and the **common
    language runtime** (**CLR**). Mono was created to bring the .NET framework to
    platforms other than Windows. It is part of the .NET foundation ([http://www.dotnetfoundation.org](http://www.dotnetfoundation.org/)),
    an independent organization that supports open development and collaboration involving
    the .NET ecosystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Mono（[https://www.mono-project.com](https://www.mono-project.com/)）是Microsoft
    .NET框架的开源实现，基于C#和公共语言运行时（CLR）的**欧洲计算机制造商协会**（**ECMA**）标准。Mono的创建是为了将.NET框架带到Windows以外的平台。它是.NET基金会（[http://www.dotnetfoundation.org](http://www.dotnetfoundation.org/)）的一部分，这是一个支持涉及.NET生态系统的开放发展和协作的独立组织。
- en: With the combination of Xamarin platforms and Mono, we will be able to use both
    all platform-specific APIs and all platform-independent parts of .NET, including,
    for example, namespaces, systems, `System.Linq`, `System.IO`, `System.Net`, and
    `System.Threading.Tasks`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Xamarin平台和Mono的组合，我们将能够同时使用所有特定于平台的API和.NET的所有平台无关部分，包括例如命名空间、系统、`System.Linq`、`System.IO`、`System.Net`和`System.Threading.Tasks`。
- en: There are several reasons to use Xamarin for mobile application development,
    as we will see in the following sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因可以使用Xamarin进行移动应用程序开发，我们将在以下部分中看到。
- en: Code sharing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码共享
- en: 'If there is one common programming language for multiple mobile platforms,
    and even server platforms, then we can share a lot of code between our target
    platforms, as illustrated in the following diagram. All code that isn''t related
    to the target platform can be shared with other .NET platforms. Code that is typically
    shared in this way includes business logic, network calls, and data models:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个通用的编程语言适用于多个移动平台，甚至服务器平台，那么我们可以在目标平台之间共享大量代码，如下图所示。所有与目标平台无关的代码都可以与其他.NET平台共享。通常以这种方式共享的代码包括业务逻辑、网络调用和数据模型：
- en: '![](img/a2fe69f7-b69c-49d3-a132-71120bc830bc.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2fe69f7-b69c-49d3-a132-71120bc830bc.png)'
- en: There is also a large community based around the .NET platforms and a wide range
    of third-party libraries and components that can be downloaded from NuGet ([https://nuget.org](https://nuget.org))
    and used across the .NET platforms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了围绕.NET平台的大型社区外，还有大量的第三方库和组件可以从NuGet（[https://nuget.org](https://nuget.org)）下载并在.NET平台上使用。
- en: Code sharing across platforms will lead to shorter development times. It will
    also lead to applications of a higher quality because we only need to write the
    code for business logic once. There will be a lower risk of bugs, and we will
    also be able to guarantee that a calculation will return the same result, no matter
    what platform our users are using.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台的代码共享将导致更短的开发时间。这也将导致更高质量的应用程序，因为我们只需要编写一次业务逻辑的代码。出现错误的风险会降低，我们还能够保证计算将返回相同的结果，无论用户使用什么平台。
- en: Using existing knowledge
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用现有知识
- en: For .NET developers who want to start building native mobile applications, it
    is easier to just learn the APIs for the new platforms than it is to learn programming
    languages and APIs for both old and new platforms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要开始构建原生移动应用程序的.NET开发人员来说，学习新平台的API比学习新旧平台的编程语言和API更容易。
- en: Similarly, organizations that want to build native mobile applications could
    use their existing developers with their knowledge of .NET to develop applications. Because
    there are more .NET developers than Objective-C and Swift developers, it would
    be easier to find new developers for mobile application development projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，想要构建原生移动应用程序的组织可以利用其现有的具有.NET知识的开发人员来开发应用程序。因为.NET开发人员比Objective-C和Swift开发人员更多，所以更容易找到新的开发人员来进行移动应用程序开发项目。
- en: Xamarin.iOS
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.iOS
- en: 'Xamarin.iOS is used for building applications for iOS with .NET, and contains
    the bindings to the iOS APIs mentioned previously. Xamarin.iOS uses **ahead of
    time** (**AOT**) compiling to compile the C# code to **Advanced RISC Machines** (**ARM**)
    assembly language. The Mono runtime runs along with the Objective-C runtime. Code
    that uses .NET namespaces, such as `System.Linq` or `System.Net`, will be executed
    by the Mono runtime, while code that uses iOS-specific namespaces will be executed
    by the Objective-C runtime. Both the Mono runtime and the Objective-C runtime
    will run on top of the Unix-like kernel, **X is Not Unix** (**XNU**) ([https://en.wikipedia.org/wiki/XNU](https://en.wikipedia.org/wiki/XNU)),
    which is developed by Apple. The following diagram shows an overview of the iOS
    architecture:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS用于使用.NET构建iOS应用程序，并包含了之前提到的iOS API的绑定。Xamarin.iOS使用**提前编译**（**AOT**）将C#代码编译为**高级精简机器**（**ARM**）汇编语言。Mono运行时与Objective-C运行时一起运行。使用.NET命名空间的代码，如`System.Linq`或`System.Net`，将由Mono运行时执行，而使用iOS特定命名空间的代码将由Objective-C运行时执行。Mono运行时和Objective-C运行时都运行在由苹果开发的类Unix内核**X
    is Not Unix**（**XNU**）（[https://en.wikipedia.org/wiki/XNU](https://en.wikipedia.org/wiki/XNU)）之上。以下图表显示了iOS架构的概述：
- en: '![](img/9e678a4e-5d11-4c85-b899-307cf14ca8ed.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e678a4e-5d11-4c85-b899-307cf14ca8ed.png)'
- en: Xamarin.Android
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Android
- en: Xamarin.Android is used to build applications for Android with .NET, and contains
    the bindings to the Android APIs. The Mono runtime and the Android runtime run
    side by side on top of a Linux kernel. Xamarin.Android applications could either
    be **just-in-time** (**JIT**)-compiled or AOT-compiled, but to AOT-compile them,
    you need to use Visual Studio Enterprise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Android用于使用.NET构建Android应用程序，并包含了对Android API的绑定。Mono运行时和Android运行时并行运行在Linux内核之上。Xamarin.Android应用程序可以是**即时编译**（**JIT**）或AOT编译的，但要对其进行AOT编译，需要使用Visual
    Studio Enterprise。
- en: 'Communication between the Mono runtime and the Android runtime occurs via a **Java
    Native Interface** (**JNI**) bridge. There are two types of JNI bridges: **manage
    callable wrapper** (**MCW**) and **Android callable wrapper** (**ACW**). An **MCW**
    is used when the code needs to run in the **Android runtime** (**ART**) and an
    **ACW** is used when **ART** needs to run code in the Mono runtime, as shown in
    the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Mono运行时和Android运行时之间的通信通过**Java本地接口**（**JNI**）桥接发生。有两种类型的JNI桥接：**管理可调用包装器**（**MCW**）和**Android可调用包装器**（**ACW**）。当代码需要在**Android运行时**（**ART**）中运行时，使用**MCW**，当**ART**需要在Mono运行时中运行代码时，使用**ACW**，如下图所示：
- en: '![](img/0518e509-0678-47a7-a27f-0c938156cd28.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0518e509-0678-47a7-a27f-0c938156cd28.png)'
- en: Xamarin.Mac
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Mac
- en: 'Xamarin.Mac is for building applications for macOS with .NET, and contains
    the bindings to the macOS APIs. Xamarin.Mac has the same architecture as Xamarin.iOS—the
    only difference is that Xamarin.Mac applications are JIT compiled, unlike Xamarin.iOS
    apps, which are AOT-compiled. This is shown in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Mac用于使用.NET构建macOS应用程序，并包含了对macOS API的绑定。Xamarin.Mac与Xamarin.iOS具有相同的架构，唯一的区别是Xamarin.Mac应用程序是JIT编译的，而不像Xamarin.iOS应用程序是AOT编译的。如下图所示：
- en: '![](img/8bf5e05e-0103-4f2c-b6db-884bc295e604.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bf5e05e-0103-4f2c-b6db-884bc295e604.png)'
- en: Xamarin.Forms
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms
- en: 'Xamarin.Forms is a UI framework that is built on top of Xamarin (for iOS and
    Android) and the **Universal Windows Platform** (**U****WP**). Xamarin.Forms enables
    developers to create a UI for iOS, Android, and UWP with one shared code base,
    as illustrated in the following diagram. If we are building an application with Xamarin.Forms, we
    can use XAML, C#, or a combination of both to create the UI:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xamarin.Forms**是建立在Xamarin（用于iOS和Android）和**通用Windows平台**（**UWP**）之上的UI框架。**Xamarin.Forms**使开发人员能够使用一个共享的代码库为iOS、Android和UWP创建UI，如下图所示。如果我们正在使用**Xamarin.Forms**构建应用程序，我们可以使用XAML、C#或两者的组合来创建UI：'
- en: '![](img/01a60523-6c5f-4b50-b0e4-43aa8e316150.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01a60523-6c5f-4b50-b0e4-43aa8e316150.png)'
- en: The architecture of Xamarin.Forms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Xamarin.Forms**的架构'
- en: Xamarin.Forms is more or less just an abstract layer on top of each platform. Xamarin.Forms has
    a shared layer, which is used by all platforms, as well as a platform-specific
    layer. The platform-specific layer contains renderers. A renderer is a class that
    maps a Xamarin.Forms control into a platform-specific native control. Each Xamarin.Forms
    control has a platform-specific renderer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Xamarin.Forms**基本上只是每个平台上的一个抽象层。**Xamarin.Forms**有一个共享层，被所有平台使用，以及一个特定于平台的层。特定于平台的层包含渲染器。渲染器是一个将**Xamarin.Forms**控件映射到特定于平台的本机控件的类。每个**Xamarin.Forms**控件都有一个特定于平台的渲染器。'
- en: 'The following diagram illustrates how an entry control in Xamarin.Forms is
    rendered to a **UITextField** control from the **UIKit** namespace when the shared Xamarin.Forms code
    is used in an iOS app. The same code in Android renders an **EditText** control
    from the **Android.Widget** namespace:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了当在iOS应用中使用共享的Xamarin.Forms代码时，**Xamarin.Forms**中的输入控件是如何渲染为**UIKit**命名空间中的**UITextField**控件的。在Android中相同的代码会渲染为**Android.Widget**命名空间中的**EditText**控件：
- en: '![](img/ce6bbb96-42b4-4064-b80d-456b22ec7ae4.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce6bbb96-42b4-4064-b80d-456b22ec7ae4.png)'
- en: Defining a user interface using XAML
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XAML定义用户界面
- en: The most common way to declare your user interface in Xamarin.Forms is by defining
    it in a XAML document. It is also possible to create the GUI in C#, since XAML
    is really only a markup language for instantiating objects. You could, in theory,
    use XAML to create any type of object, as long as it has a parameterless constructor. A
    XAML document is an **Extensible Markup Language** (**XML**) document with a specific
    schema.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中声明用户界面的最常见方式是在XAML文档中定义它。也可以通过C#创建GUI，因为XAML实际上只是用于实例化对象的标记语言。理论上，您可以使用XAML来创建任何类型的对象，只要它具有无参数的构造函数。XAML文档是具有特定模式的**可扩展标记语言**(**XML**)文档。
- en: Defining a Label control
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个标签控件
- en: 'As a simple example, let''s look at the following snippet of XAML:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，让我们来看一下以下XAML代码片段：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the XAML parser encounters this snippet, it will create an instance of
    a `Label` object and then set the properties of the object that correspond to
    the attributes in the XAML. This means that if we set a `Text` property in XAML,
    it will set the `Text` property on the instance of the `Label` object that is
    created. The XAML in the preceding example will have the same effect as the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当XAML解析器遇到这个代码片段时，它将创建一个`Label`对象的实例，然后设置与XAML中的属性对应的对象的属性。这意味着如果我们在XAML中设置了`Text`属性，它将设置在创建的`Label`对象的实例上的`Text`属性。上面例子中的XAML将产生与以下相同的效果：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'XAML exists to make it easier to view the object hierarchy that you need to
    create in order to make a GUI. An object model for a GUI is also hierarchical
    by design, so XAML has support for adding child objects. You can simply add them
    as child nodes, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: XAML的存在是为了更容易地查看您需要创建的对象层次结构，以便创建GUI。GUI的对象模型也是按层次结构设计的，因此XAML支持添加子对象。您可以简单地将它们添加为子节点，如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `StackLayout` is a container control that will organize the children vertically
    or horizontally within that container. A vertical organization is the default
    value, and will be used unless you specify otherwise. There are also a number
    of other containers, such as the `Grid` and the `FlexLayout`. These will be used
    in many of the projects in the following chapters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout`是一个容器控件，它将在该容器内垂直或水平地组织子元素。垂直组织是默认值，除非您另行指定。还有许多其他容器，如`Grid`和`FlexLayout`。这些将在接下来的章节中的许多项目中使用。'
- en: Creating a page in XAML
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在XAML中创建页面
- en: 'A single control is no good unless it has a container that hosts it. Let''s
    see what an entire page would look like. A fully valid `ContentPage` defined in
    XAML is an XML document. This means that we must start with an XML declaration.
    After that, we must have one, and only one, root node, as shown in the following
    code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单个控件没有容器来承载它是不好的。让我们看看整个页面会是什么样子。在XAML中定义的完全有效的`ContentPage`是一个XML文档。这意味着我们必须从一个XML声明开始。之后，我们必须有一个，且只有一个，根节点，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we have defined a `ContentPage` that translates into
    a single view on each platform. In order to make it valid XAML, you must specify
    a default namespace (`) and then add the `x` namespace (`).``
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们定义了一个`ContentPage`，它在每个平台上都会被翻译成一个视图。为了使它成为有效的XAML，您必须指定一个默认命名空间(`)然后添加`x`命名空间(`)。
- en: The default namespace lets you create objects without prefixing them, like the
    `StackLayout` object. The `x` namespace lets you access properties such as the
    `x:Class`, which tells the XAML parser which class to instantiate to control the
    page when the `ContentPage` object is being created.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认命名空间允许您创建对象而无需为它们加前缀，就像`StackLayout`对象一样。`x`命名空间允许您访问属性，如`x:Class`，它告诉XAML解析器在创建`ContentPage`对象时实例化哪个类来控制页面。
- en: A `ContentPage` can have only one child. In this case, it's a `StackLayout`
    control. Unless you specify otherwise, the default layout orientation is vertical.
    A `StackLayout` can, therefore, have multiple children. Later on, we will touch
    on more advanced layout controls, such as the `Grid` and the `FlexLayout` control.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage`只能有一个子元素。在这种情况下，它是一个`StackLayout`控件。除非您另行指定，默认的布局方向是垂直的。因此，`StackLayout`可以有多个子元素。稍后，我们将介绍更高级的布局控件，如`Grid`和`FlexLayout`控件。'
- en: In this specific example, we are going to create a `Label` control as the first
    child of the `StackLayout`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们将创建一个`Label`控件作为`StackLayout`的第一个子元素。
- en: Creating a page in C#
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中创建页面
- en: 'For clarity, the following code shows how the same thing would look in C#:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，以下代码展示了相同的内容在C#中的写法：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `page` is a class that inherits from the `Xamarin.Forms.ContentPage`. This
    class is autogenerated for you if you create a XAML page, but if you go code-only,
    then you will need to define it yourself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`page`是一个从`Xamarin.Forms.ContentPage`继承的类。如果你创建一个XAML页面，这个类会自动生成，但如果你只用代码，那么你就需要自己定义它。'
- en: 'Let''s create the same control hierarchy as the XAML page we defined earlier
    using the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码创建与之前定义的XAML页面相同的控件层次结构：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first statement creates a `page`. You could, in theory, create a new page
    directly of the `ContentPage` type, but this would prohibit you from writing any
    code behind it. For this reason, it's a good practice to subclass each page that
    you are planning to create.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句创建了一个`page`。理论上，你可以直接创建一个`ContentPage`类型的新页面，但这会禁止你在其后写任何代码。因此，最好的做法是为你计划创建的每个页面创建一个子类。
- en: The block following this first statement creates the `StackLayout` control that
    contains the `Label` control that is added to the `Children` collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着第一条语句的是创建包含添加到`Children`集合中的`Label`控件的`StackLayout`控件的代码块。
- en: Finally, we need to assign the `StackLayout` to the `Content` property of the
    page.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`StackLayout`分配给页面的`Content`属性。
- en: XAML or C#?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML还是C#？
- en: Generally, using XAML will give you a much better overview, since the page is
    a hierarchical structure of objects and XAML is a very nice way of defining that
    structure. In code, the structure gets flipped around since you must define the
    innermost object first, making it harder to read the structure of your page. This
    was shown in an earlier example in this chapter. Having said that, it is generally
    a matter of preference as to how you decide to define the GUI. This book will
    use XAML rather than C# in the projects to come.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用XAML会给你一个更好的概览，因为页面是对象的分层结构，而XAML是定义这种结构的一种非常好的方式。在代码中，结构会被颠倒，因为你必须先定义最内部的对象，这样就更难读取页面的结构。这在本章的早些例子中已经展示过了。话虽如此，如何定义GUI通常是一种偏好。本书将在以后的项目中使用XAML而不是C#。
- en: Xamarin.Forms versus traditional Xamarin
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xamarin.Forms与传统Xamarin
- en: 'While this book is about Xamarin.Forms, we will highlight the difference between
    using traditional Xamarin and Xamarin.Forms. Traditional Xamarin is used when
    developing applications that use iOS and Android SDK without any means of abstraction.
    For example, we can create an iOS app that defines its user interface in a storyboard
    or in the code directly. This code will not be reusable for other platforms, such
    as Android. Applications built using this approach can still share non-platform-specific
    code by simply referencing a .NET standard library. This relationship is shown
    in the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书是关于Xamarin.Forms的，但我们将强调使用传统Xamarin和Xamarin.Forms之间的区别。当开发使用iOS和Android
    SDK而没有任何抽象手段的应用程序时，使用传统的Xamarin。例如，我们可以创建一个iOS应用程序，在故事板或直接在代码中定义其用户界面。这段代码将无法在其他平台上重用，比如Android。使用这种方法构建的应用程序仍然可以通过简单引用.NET标准库来共享非特定于平台的代码。这种关系在下图中显示：
- en: '![](img/7344a947-57f3-4259-804a-7610cd0ffb78.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7344a947-57f3-4259-804a-7610cd0ffb78.png)'
- en: 'Xamarin.Forms, on the other hand, is an abstraction of the GUI, which allows
    us to define user interfaces in a platform-agnostic way. It still builds on top
    of Xamarin.iOS, Xamarin.Android, and all other supported platforms. The Xamarin.Forms
    application can be created as a .NET standard library or as a shared code project,
    where the source files are linked as copies and built within the same project
    as the platform you are currently building for. This relationship is shown in
    the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Xamarin.Forms是GUI的抽象，它允许我们以一种与平台无关的方式定义用户界面。它仍然建立在Xamarin.iOS、Xamarin.Android和所有其他支持的平台之上。Xamarin.Forms应用程序可以创建为.NET标准库或共享代码项目，其中源文件被链接为副本，并在当前构建的平台的同一项目中构建。这种关系在下图中显示：
- en: '![](img/e626305f-5a27-434c-a805-c29ee3f90c5f.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e626305f-5a27-434c-a805-c29ee3f90c5f.png)'
- en: Having said that, Xamarin.Forms cannot exist without traditional Xamarin, since
    it's bootstrapped through an application for each platform. This gives you the
    ability to extend Xamarin.Forms on each platform using custom renderers and platform-specific
    code that can be exposed to your shared code base through interfaces. We'll look
    at these concepts in detail later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，没有传统的Xamarin，Xamarin.Forms就无法存在，因为它是通过每个平台的应用程序引导的。这使您能够通过接口将自定义渲染器和特定于平台的代码扩展到每个平台上的Xamarin.Forms。我们将在本章后面详细讨论这些概念。
- en: When to use Xamarin.Forms
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Xamarin.Forms
- en: We can use Xamarin.Forms in most cases and for most types of applications. If
    we need to use controls that not are available in Xamarin.Forms, we can always
    use the platform-specific APIs. There are, however, cases where Xamarin.Forms
    is not useful. The most common situation in which we might want to avoid using
    Xamarin.Forms is if we are building an app that we want to look very different
    across our target platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在大多数情况下和大多数类型的应用中使用Xamarin.Forms。如果我们需要使用Xamarin.Forms中没有的控件，我们可以随时使用特定于平台的API。然而，有一些情况下Xamarin.Forms是无法使用的。我们可能希望避免使用Xamarin.Forms的最常见情况是，如果我们正在构建一个希望在目标平台上看起来非常不同的应用程序。
- en: Setting up a development machine
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发机器
- en: 'To develop an app for multiple platforms imposes higher demands on our development
    machine. One reason for this is that we often want to run one or multiple simulators
    or emulators on our development machine. Different platforms also have different
    requirements with regard to what is needed to begin development. Regardless of
    whether we are using Mac or Windows, Visual Studio will be our IDE. There are
    several versions of Visual Studio, including the free community edition. Go to [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)
    to compare the available versions of Visual Studio. The following list is a summary
    of what we need to begin development for each platform:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个适用于多个平台的应用程序对我们的开发机器提出了更高的要求。其中一个原因是我们经常希望在开发机器上运行一个或多个模拟器或仿真器。不同的平台对于开始开发所需的要求也不同。无论我们使用的是Mac还是Windows，Visual
    Studio都将是我们的集成开发环境。Visual Studio有几个版本，包括免费的社区版。请访问[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)比较可用的Visual
    Studio版本。以下列表总结了我们为每个平台开始开发所需的内容：
- en: '**iOS**:To develop an app for iOS, we need a Mac. This could either be the
    machine that we are developing on or a machine on our network, if we are using
    one. The reason that we need to connect to a Mac is that we need Xcode for compiling
    and debugging an app. Xcode also provides the iOS simulator.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：要为iOS开发应用程序，我们需要一台Mac。这可以是我们正在开发的机器，也可以是我们网络上的一台机器（如果我们正在使用）。我们需要连接到Mac的原因是我们需要Xcode来编译和调试应用程序。Xcode还提供了iOS模拟器。'
- en: '**Android**:Android apps can be developed on either macOS or Windows. Everything
    you need, including SDKs and simulators, are installed with Visual Studio.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：Android应用可以在macOS或Windows上开发。包括SDK和模拟器在内的一切都将与Visual Studio一起安装。'
- en: '**UWP**:UWP apps can only be developed in Visual Studio on a Windows machine.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UWP**：UWP应用只能在Windows机器上的Visual Studio中开发。'
- en: Setting up a Mac
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Mac
- en: There are two main tools that are required to develop applications for iOS and
    Android with Xamarin on a Mac. These are Visual Studio for Mac (if we are only developing
    Android applications, this is the only tool we need) and Xcode. In the following
    sections, we will take a look at how to set up a Mac for app development.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上开发使用Xamarin开发iOS和Android应用程序需要两个主要工具。这些工具是Visual Studio for Mac（如果我们只开发Android应用程序，这是我们唯一需要的工具）和Xcode。在接下来的部分中，我们将看看如何为应用程序开发设置Mac。
- en: Installing Xcode
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Xcode
- en: Before we install Visual Studio, we need to download and install Xcode. Xcode
    is the official development IDE from Apple and contains all the tools they provide
    for iOS development, including SDKs for iOS, macOS, tvOS, and watchOS.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Visual Studio之前，我们需要下载并安装Xcode。Xcode是苹果的官方开发IDE，包含了他们为iOS开发提供的所有工具，包括iOS、macOS、tvOS和watchOS的SDK。
- en: We can download Xcode from the Apple developer portal ([https://developer.apple.com](https://developer.apple.com))
    or from Apple App Store. I recommend that you download it from App Store because
    this will always provide you with the latest stable version. The only reason to
    download Xcode from the developer portal is if we want to use a prerelease version
    of Xcode, to develop for a prerelease of iOS, for example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从苹果开发者门户([https://developer.apple.com](https://developer.apple.com))或苹果应用商店下载Xcode。我建议您从应用商店下载，因为这将始终为您提供最新的稳定版本。从开发者门户下载Xcode的唯一原因是，如果我们想要使用Xcode的预发布版本，例如为iOS的预发布版本进行开发。
- en: After the first installation, and after each update of Xcode, it is important
    to open it. Xcode often needs to install additional components after an installation
    or an update. You also need to open Xcode to accept the license agreement with
    Apple.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次安装后，以及每次更新Xcode后，打开它很重要。Xcode经常需要在安装或更新后安装额外的组件。您还需要打开Xcode以接受与苹果的许可协议。
- en: Installing Visual Studio
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: To install Visual Studio, we first need to download it from [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Visual Studio，我们首先需要从[https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)下载它。
- en: When we start the Visual Studio installer via the file we downloaded, it will
    start to check what we already have installed on our machine. When the check has
    finished, we will be able to select which platforms and tools we would like to
    install. Note that Xamarin Inspector requires a Visual Studio Enterprise license.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过下载的文件启动Visual Studio安装程序时，它将开始检查我们的机器上已安装了什么。检查完成后，我们将能够选择要安装的平台和工具。请注意，Xamarin
    Inspector需要Visual Studio企业许可证。
- en: 'Once we have selected the platforms that we want to install, Visual Studio
    will download and install everything that we need to get started with app development
    using Xamarin, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了要安装的平台，Visual Studio将下载并安装我们使用Xamarin开始应用程序开发所需的一切，如下图所示：
- en: '![](img/e0283eac-aad0-47d5-bfa5-28ba0fee9a90.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0283eac-aad0-47d5-bfa5-28ba0fee9a90.png)'
- en: Configuring the Android emulator
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Android模拟器
- en: Visual Studio will use the Android emulators provided by Google. If we would
    like the emulator to be fast, then we need to ensure that it is hardware-accelerated.
    To hardware-accelerate the Android emulator, we need to install the **Intel ****Hardware
    Accelerated Execution Manager** (**HAXM**), which can be downloaded from [https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm](https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio将使用Google提供的Android模拟器。如果我们希望模拟器运行速度快，那么我们需要确保它是硬件加速的。要对Android模拟器进行硬件加速，我们需要安装**Intel
    Hardware Accelerated Execution Manager**（**HAXM**），可以从[https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm](https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm)下载。
- en: 'The next step is to create an Android Emulator. First, we need to ensure that
    the Android emulator and the Android OS images are installed. To do this, go through the
    following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个Android模拟器。首先，我们需要确保已安装了Android模拟器和Android操作系统映像。要做到这一点，请按照以下步骤进行：
- en: 'Go to the Tools tab to install the Android Emulator:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到工具选项卡安装Android模拟器：
- en: '![](img/8d7b72e8-7184-48e4-a971-f01877061f10.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d7b72e8-7184-48e4-a971-f01877061f10.png)'
- en: 'We also need to install one or multiple images to use with the emulator. We
    can install multiple images if, for example, we want to run our application on
    different versions of Android. We will select emulators with Google Play (as shown
    in the following screenshot) so that we can use Google Play services in our app,
    even when we are running it in an emulator. This is required if, for example,
    we want to use Google Maps in our app:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要安装一个或多个图像以与模拟器一起使用。例如，如果我们想要在不同版本的Android上运行我们的应用程序，我们可以安装多个图像。我们将选择具有Google
    Play的模拟器（如下面的屏幕截图所示），以便在模拟器中运行应用程序时可以使用Google Play服务。例如，如果我们想要在应用程序中使用Google地图，则需要这样做：
- en: '![](img/007644d2-f786-499f-9e19-43cbe66ac4c1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/007644d2-f786-499f-9e19-43cbe66ac4c1.png)'
- en: 'Then, to create and configure an emulator, go to the Android Device Manager
    from the Tools tab in Visual Studio. From the Android Device Manager, we can start
    an emulator if we have already created one, or we can create new emulators, as
    shown in the following screenshot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要创建和配置模拟器，请转到Visual Studio中的工具选项卡中的Android设备管理器。从Android设备管理器，如果我们已经创建了一个模拟器，我们可以启动一个模拟器，或者我们可以创建新的模拟器，如下面的屏幕截图所示：
- en: '![](img/5e485948-27b2-4b9f-9587-6b3829d7d952.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e485948-27b2-4b9f-9587-6b3829d7d952.png)'
- en: If we click the New Device button, we can create a new emulator with the specifications
    that we need. The easiest way to create a new emulator here is to select a base
    device that matches our needs. These base devices will be preconfigured, and that
    is often enough. However, it is also possible to edit the properties of the device
    so that we can get an emulator that matches our specific needs.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单击“新设备”按钮，我们可以创建一个具有我们需要的规格的新模拟器。在这里创建新模拟器的最简单方法是选择与我们需求匹配的基础设备。这些基础设备将被预先配置，通常足够。但是，也可以编辑设备的属性，以便获得与我们特定需求匹配的模拟器。
- en: 'Because we will not run the emulator on a device with an ARM processor, we
    have to select either an x86 processor or an x64 processor, as shown in the following
    screenshot. If we try to use an ARM processor, the emulator will be very slow:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不会在具有ARM处理器的设备上运行模拟器，所以我们必须选择x86处理器或x64处理器，如下面的屏幕截图所示。如果我们尝试使用ARM处理器，模拟器将非常慢：
- en: '![](img/f20ac9a7-abd5-4799-9a96-c59d1f76198c.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f20ac9a7-abd5-4799-9a96-c59d1f76198c.png)'
- en: Setting up a Windows machine
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Windows机器
- en: We can either use a virtual or a physical Windows machine for development with
    Xamarin. We can, for example, run a virtual Windows machine on our Mac. The only
    tool we need for app development on our Windows machine is Visual Studio.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用虚拟或物理Windows机器进行Xamarin开发。例如，我们可以在Mac上运行虚拟Windows机器。我们在Windows机器上进行应用程序开发所需的唯一工具是Visual
    Studio。
- en: Installing Xamarin for Visual Studio
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio的Xamarin
- en: If we already have Visual Studio installed, we must first open Visual Studio
    Installer; otherwise, we need to go to [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)
    to download the installation files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经安装了Visual Studio，我们必须首先打开Visual Studio安装程序；否则，我们需要转到[https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)下载安装文件。
- en: Before the installation starts, we need to select which workloads we want to
    install.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装开始之前，我们需要选择要安装的工作负载。
- en: 'If we want to develop apps for Windows, we need to select the Universal Windows
    Platform development workload, as shown in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为Windows开发应用程序，我们需要选择通用Windows平台开发工作负载，如下面的屏幕截图所示：
- en: '![](img/555232f0-58a2-4465-95f2-bd91630d08f0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/555232f0-58a2-4465-95f2-bd91630d08f0.png)'
- en: 'For Xamarin development, we need to install Mobile development with .NET. If
    you want to use Hyper-V for hardware acceleration, we can deselect the checkbox
    for Intel HAXM in the detailed description of the Mobile development with .NET
    workload on the left-hand side, as shown in the following screenshot. When we
    deselect Intel HAXM, the Android emulator will also be deselected, but we can
    install it later:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Xamarin开发，我们需要安装带有.NET的移动开发。如果您想要使用Hyper-V进行硬件加速，我们可以在左侧的.NET移动开发工作负载的详细描述中取消选择Intel
    HAXM的复选框，如下面的屏幕截图所示。当我们取消选择Intel HAXM时，Android模拟器也将被取消选择，但我们可以稍后安装它：
- en: '![](img/b1ec5c90-089a-4391-be25-2030819a270a.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ec5c90-089a-4391-be25-2030819a270a.png)'
- en: When we first start Visual Studio, we will be asked whether we want to sign
    in. It is not necessary for us to sign in unless we want to use Visual Studio
    Professional or Enterprise, in which case we have to sign in so that our license
    can be verified.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次启动Visual Studio时，将询问我们是否要登录。除非我们想要使用Visual Studio专业版或企业版，否则我们不需要登录，否则我们必须登录以便验证我们的许可证。
- en: Pairing Visual Studio with a Mac
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Visual Studio与Mac配对
- en: If we want to run, debug, and compile our iOS app, then we need to connect it
    to a Mac. We can set up the Mac manually, as described earlier in this chapter,
    or we can use Automatic Mac Provisioning. This will install Mono and Xamarin.iOS
    on the Mac that we are connecting to. It will not install the Visual Studio IDE,
    but this isn't necessary if you just want to use it as a build machine. We do,
    however, need to install Xcode manually.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要运行，调试和编译我们的iOS应用程序，那么我们需要将其连接到Mac。我们可以手动设置Mac，如本章前面描述的那样，或者我们可以使用自动Mac配置。这将在我们连接的Mac上安装Mono和Xamarin.iOS。它不会安装Visual
    Studio IDE，但如果您只想将其用作构建机器，则不需要。但是，我们需要手动安装Xcode。
- en: 'To be able to connect to the Mac—either to a manually-installed Mac or using
    Automatic Mac Provisioning—the Mac needs to be accessible via our network and
    we need to enable Remote Login on the Mac. To do this, go to Settings | Sharing and
    select the checkbox for Remote Login. To the left of the window, we can select
    which users are allowed to connect with Remote Login, as shown in the following
    screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够连接到Mac（无论是手动安装的Mac还是使用自动Mac配置），Mac需要通过我们的网络访问，并且我们需要在Mac上启用远程登录。要做到这一点，转到设置
    | 共享，并选择远程登录的复选框。在窗口的左侧，我们可以选择允许连接远程登录的用户，如下截图所示：
- en: '![](img/ade641e3-b0e9-4f90-8516-95895b732961.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ade641e3-b0e9-4f90-8516-95895b732961.png)'
- en: 'To connect to the Mac from Visual Studio, use the Pair to Mac button in the
    toolbar (as shown in the following screenshot), or, in the top menu, select Tools
    | iOS and finally Pair to Mac:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio连接到Mac，可以在工具栏中使用“连接到Mac”按钮（如下截图所示），或者在顶部菜单中选择工具 | iOS，最后选择连接到Mac：
- en: '![](img/8abe2796-8856-489d-a5ff-f2cc6e85060f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8abe2796-8856-489d-a5ff-f2cc6e85060f.png)'
- en: 'A dialog will appear showing all the Macs that can be found on the network.
    If the Mac doesn''t appear in the list of available Macs, we can use the Add Mac
    button in the bottom left corner to enter an IP address, as shown in the following
    screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个对话框，显示可以在网络上找到的所有Mac。如果Mac不出现在可用Mac列表中，我们可以使用左下角的“添加Mac”按钮输入IP地址，如下截图所示：
- en: '![](img/d964085d-d4bd-45dd-ae24-349ffb07293c.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d964085d-d4bd-45dd-ae24-349ffb07293c.png)'
- en: 'If everything that you require is installed on the Mac, then Visual Studio
    will connect and we can start building and debugging our iOS app. If Mono is missing
    on the Mac, a warning will appear. This warning will also give us the option to
    install it, as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Mac上安装了您需要的一切，那么Visual Studio将连接，我们可以开始构建和调试我们的iOS应用程序。如果Mac上缺少Mono，将会出现警告。此警告还将给我们安装它的选项，如下截图所示：
- en: '![](img/9148b63d-f1ad-46b0-b828-649fd206c73a.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9148b63d-f1ad-46b0-b828-649fd206c73a.png)'
- en: Configuring an Android emulator and hardware acceleration
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Android模拟器和硬件加速
- en: If we want a fast Android emulator that works smoothly, we need to enable hardware
    acceleration. This can be done using either Intel HAXM or Hyper-V. The disadvantage
    of Intel HAXM is that it can't be used on machines with an **Advanced Micro Devices**
    (**AMD**) processor; you have to have a machine with an Intel processor. We can't
    use Intel HAXM in parallel with Hyper-V.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个运行流畅的快速Android模拟器，就需要启用硬件加速。这可以使用Intel HAXM或Hyper-V来实现。Intel HAXM的缺点是它不能在装有**AMD**处理器的机器上使用；你必须有一台装有Intel处理器的机器。我们不能同时使用Intel
    HAXM和Hyper-V。
- en: 'For these reasons, Hyper-V is the preferred way to hardware accelerate the
    Android emulator on a Windows machine. To use Hyper-V with the Android emulator, we
    need to have the April 2018 update (or later) for Windows and Visual Studio version
    15.8 (or later) installed. To enable Hyper-V, you need to go through the following
    steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Hyper-V是在Windows机器上硬件加速Android模拟器的首选方式。要在Android模拟器中使用Hyper-V，我们需要安装2018年4月更新（或更高版本）的Windows和Visual
    Studio 15.8版本（或更高版本）。要启用Hyper-V，需要按照以下步骤进行：
- en: 'Open the Start menu and type Turn Windows features on or off. Click the option
    that appears to open it, as shown in the following screenshot:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开始菜单，键入“打开或关闭Windows功能”。单击出现的选项以打开它，如下截图所示：
- en: '![](img/ec50af38-1f5e-4eac-87d0-82598cc258f4.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec50af38-1f5e-4eac-87d0-82598cc258f4.png)'
- en: 'To enable Hyper-V, select the Hyper-V checkbox. Also, expand the Hyper-V option
    and check the Hyper-V Platform checkbox. We also need to select the Windows Hypervisor
    Platform checkbox, as shown in the following screenshot:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用Hyper-V，选择Hyper-V复选框。此外，展开Hyper-V选项并选中Hyper-V平台复选框。我们还需要选择Windows Hypervisor
    Platform复选框，如下截图所示：
- en: '![](img/f42fe911-996d-4ad2-999d-1c192743f9e8.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f42fe911-996d-4ad2-999d-1c192743f9e8.png)'
- en: Restart the machine when Windows prompts you to.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Windows提示时重新启动机器。
- en: Because we didn't install an Android emulator during the installation of Visual
    Studio, we need to install it now. Go to the Tools menu in Visual Studio, click
    on Android, and then Android SDK Manager.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在安装Visual Studio时我们没有安装Android模拟器，所以现在需要安装它。转到Visual Studio的工具菜单，点击Android，然后点击Android
    SDK Manager。
- en: 'Under Tools in Android SDK Manager, we can install the emulator by selecting
    Android Emulator, as shown in the following screenshot. Also, we should ensure
    that the latest version of Android SDK Build Tools is installed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android SDK Manager的工具中，我们可以通过选择Android模拟器来安装模拟器，如下截图所示。此外，我们应该确保安装了最新版本的Android
    SDK构建工具：
- en: '![](img/d709c8c4-25b6-40c8-bf65-592fc3d78761.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d709c8c4-25b6-40c8-bf65-592fc3d78761.png)'
- en: We recommend installing the **NDK** (**Native Development Kit**). The NDK makes
    it possible to import libraries that are written in C or C++. NDK is also required
    if we want to AOT compile an app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议安装**NDK**（**Native Development Kit**）。NDK使得可以导入用C或C++编写的库。如果我们想要AOT编译应用程序，也需要NDK。
- en: The Android SDK allows for multiple emulator images to be installed simultaneously.
    We can install multiple images if, for example, we want to run our application
    on different versions of Android. Select emulators with Google Play (as shown
    in the following screenshot) so we can use Google Play services in our app even
    when we are running it in an emulator.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK允许同时安装多个模拟器映像。例如，如果我们想要在不同版本的Android上运行我们的应用程序，我们可以安装多个映像。选择带有Google
    Play的模拟器（如下截图所示），这样我们可以在模拟器中运行应用程序时使用Google Play服务。
- en: 'This is required if we want to use Google Maps in our app, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序中使用谷歌地图，就需要这样做：
- en: '![](img/eddbd280-3ed0-45ae-9af0-41413e7181df.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eddbd280-3ed0-45ae-9af0-41413e7181df.png)'
- en: 'The next step is to create a virtual device to use the emulator image. To create
    and configure an emulator, go to the Android Device Manager, which we will open
    from the Tools tab in Visual Studio. From the Device Manager, we can either start
    an emulator—if we already have created one—or we can create new emulators, as
    shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个虚拟设备来使用模拟器图像。要创建和配置模拟器，请转到 Android 设备管理器，我们将从 Visual Studio 的工具选项卡中打开。从设备管理器，我们可以启动模拟器（如果我们已经创建了一个），或者我们可以创建新的模拟器，如下图所示：
- en: '![](img/5475de4c-2f72-4b8e-9701-e67c79807ed1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5475de4c-2f72-4b8e-9701-e67c79807ed1.png)'
- en: If we click the New Device button, we can create a new emulator with the specifications
    that we need. The easiest way to create a new emulator here is to select a base
    device that matches our needs. These base devices will be preconfigured, which
    is often enough. However, it is possible to edit the properties of the device
    so that we can get an emulator that matches our specific needs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击“新设备”按钮，我们可以创建一个符合我们需求的新模拟器。在这里创建新模拟器的最简单方法是选择符合我们需求的基础设备。这些基础设备将被预先配置，通常已经足够了。但是，我们也可以编辑设备的属性，以便获得符合我们特定需求的模拟器。
- en: 'We have to select either an x86 processor (as shown in the following screenshot) or
    an x64 processor since we will not run the emulator on a device with an ARM processor.
    If we try to use an ARM processor, the emulator will be very slow:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须选择 x86 处理器（如下图所示）或 x64 处理器，因为我们不会在 ARM 处理器的设备上运行模拟器。如果我们尝试使用 ARM 处理器，模拟器将非常慢：
- en: '![](img/41d02e83-cec8-48f0-b248-850440d3f10d.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41d02e83-cec8-48f0-b248-850440d3f10d.png)'
- en: Configuring UWP developer mode
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 UWP 开发者模式
- en: 'If we want to develop UWP apps, we need to activate developer mode on our development
    machine. To do this, go to Settings | Update & Security | For developers. Then,
    click on Developer Mode, as shown in the following screenshot. This makes it possible
    for us to sideload and debug apps via Visual Studio:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想开发 UWP 应用程序，我们需要在开发机器上激活开发者模式。要做到这一点，请转到“设置”|“更新和安全”|“开发人员”，然后点击“开发人员模式”，如下图所示。这样我们就可以通过
    Visual Studio 侧载和调试应用程序了。
- en: '![](img/6bd60b6b-e5ad-4794-bff4-46c5b771ccfa.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd60b6b-e5ad-4794-bff4-46c5b771ccfa.png)'
- en: If we select Sideload apps instead of Developer Mode, we will only be able to
    install apps without going via Microsoft Store. If we have a machine to test,
    rather than debug our apps on, we can just select Sideload apps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择侧载应用程序而不是开发者模式，我们只能安装应用程序，而不需要经过 Microsoft Store。如果我们有一台用于测试而不是调试我们的应用程序的机器，我们可以选择侧载应用程序。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should feel a little bit more comfortable about
    what Xamarin is and how Xamarin.Forms relates to Xamarin itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该对 Xamarin 是什么以及 Xamarin.Forms 与 Xamarin 本身的关系有了一些了解。
- en: 'In this chapter, we established our definition of what a native application
    is, which includes the following elements:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确定了我们对本地应用程序的定义，其中包括以下元素：
- en: Native user interface
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地用户界面
- en: Native performance
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地性能
- en: Native API access
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 API 访问
- en: We talked about how Xamarin is based on Mono, which is an open source implementation
    of the .NET framework, and discussed how, at its core, Xamarin is a set of bindings
    to platform-specific APIs. We then looked in detail at how Xamarin.iOS and Xamarin.Android
    work under the hood.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了 Xamarin 是基于 Mono 构建的，Mono 是 .NET 框架的开源实现，并讨论了在其核心，Xamarin 是一组绑定到特定平台 API
    的工具。然后我们详细了解了 Xamarin.iOS 和 Xamarin.Android 是如何工作的。
- en: After that, we started to touch upon the core topic of this book, which is Xamarin.Forms.
    We started off with an overview of how platform-agnostic controls are rendered
    into platform-specific controls and how to use XAML to define a hierarchy of controls
    to assemble a page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始接触本书的核心主题，即 Xamarin.Forms。我们首先概述了平台无关控件如何渲染为特定于平台的控件，以及如何使用 XAML 定义控件层次结构来组装页面。
- en: We then spent some time looking at the difference between a Xamarin.Forms application
    and a traditional Xamarin application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们花了一些时间来看 Xamarin.Forms 应用程序和传统 Xamarin 应用程序之间的区别。
- en: A traditional Xamarin app uses platform-specific APIs directly, without any
    abstraction other than what .NET adds as a platform.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Xamarin 应用程序直接使用特定于平台的 API，除了 .NET 添加的平台之外没有其他抽象。
- en: Xamarin.Forms is an API that is built on top of the traditional Xamarin APIs,
    and allows us to define platform-agnostic GUIs in XAML or in code that is rendered to
    platform-specific controls. There's more to Xamarin.Forms than this, but this
    is what it does at its core.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms 是建立在传统 Xamarin API 之上的 API，允许我们在 XAML 或代码中定义平台无关的 GUI，然后渲染为特定于平台的控件。Xamarin.Forms
    还有更多功能，但这是它的核心功能。
- en: In the last part of this chapter, we discussed how to set up a development machine
    on Windows or macOS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们讨论了如何在 Windows 或 macOS 上设置开发机器。
- en: Now it's time to put our newly acquired knowledge to use! We will start off
    by creating a To-Do app from the ground up in the next chapter. We will look at
    concepts such as **Model–View–ViewModel** (**MVVM**), for a clean separation between
    business logic and the user interface, and SQLite.NET, for persisting data to
    a local database on your device. We will do this for three platforms at the same
    time—read on!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们新获得的知识付诸实践了！我们将从头开始创建一个待办事项应用程序，这将是下一章的内容。我们将研究诸如 Model-View-ViewModel（MVVM）等概念，以实现业务逻辑和用户界面的清晰分离，以及
    SQLite.NET，以将数据持久保存到设备上的本地数据库。我们将同时为三个平台进行开发，敬请期待！
