- en: Using Trees for Faster Lookup and Modifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树进行更快的查找和修改
- en: Trees are one of the most advanced and complex data structures out there. It
    opens doors to graph theory, which is used to represent a relationship between
    objects. The objects can be of any type, and as long as they have an established
    relationship, it can be represented in the form of a tree.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树是最先进和复杂的数据结构之一。它为图论打开了大门，用于表示对象之间的关系。对象可以是任何类型，只要它们有一个确定的关系，就可以以树的形式表示。
- en: Although there are tens of trees out there, it is not possible to cover them
    all in the chapter, so we will take a different approach and learn about trees
    in a more practical way when we go through the examples, instead of doing it upfront
    like in previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有成千上万种树，但在本章中不可能涵盖所有树，因此我们将采取不同的方法，在示例中以更实际的方式学习树，而不是像在之前的章节中那样提前学习。
- en: 'In this chapter, we will be exploring the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Creating a base angular application,
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的Angular应用程序，
- en: Creating a typeahead lookup component using **trie trees**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**trie树**创建一个自动完成查找组件
- en: Creating a credit card approval predictor using the ID3 algorithm.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ID3算法创建信用卡批准预测器。
- en: So, let's dig into it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们深入研究一下。
- en: Creating an Angular application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Angular应用程序
- en: Before we implement any trees, let's set up a base application, which we can
    use in our subsequent examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现任何树之前，让我们建立一个基本应用程序，我们可以在随后的示例中使用。
- en: 'Like we did in previous chapters, we will be creating an Angular application
    using the Angular CLI using the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的章节中所做的那样，我们将使用Angular CLI创建一个Angular应用程序，具体步骤如下：
- en: 'Install the Angular CLI using the following command (if not done already):'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装Angular CLI（如果尚未完成）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the new project in the folder of your choice by running the following
    command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令在您选择的文件夹中创建新项目：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After these two steps, you should be able to see the new project created and
    all the corresponding node modules installed and ready to go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这两个步骤后，您应该能够看到新创建的项目以及所有相应的节点模块已安装并准备就绪。
- en: 'To run your application, run the following command from Terminal:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行您的应用程序，请从终端运行以下命令：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a typeahead lookup
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自动完成查找
- en: Imagine this, you have a form for user signup, and your users have to fill out
    their information, including their country. Lucky for us, there are only a fixed
    number of countries, so the user experience around populating and selecting can
    be made extremely fun and easy rather than having them scroll through hundreds
    of options.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个用户注册表格，你的用户必须填写他们的信息，包括他们的国家。幸运的是，只有固定数量的国家，所以围绕填充和选择的用户体验可以变得非常有趣和简单，而不是让他们浏览数百个选项。
- en: In this example, we will be creating a trie tree and prepopulating it with a
    list of all the countries. The users can then type the name of their country and
    our component will work as a typeahead and show the available options to the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个trie树，并预先填充它与所有国家的列表。然后用户可以输入他们国家的名称，我们的组件将作为自动完成，并向用户显示可用的选项。
- en: 'Let''s now discuss why we need a trie tree. According to Wikipedia, the following
    is the definition of a simple trie tree:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论为什么我们需要trie树。根据维基百科的定义，简单trie树的定义如下：
- en: In computer science, a trie, also called digital tree and sometimes radix tree or prefix
    tree (as they can be searched by prefixes), is a kind of search tree — an ordered
    tree data structure that is used to store a dynamic set or associate array where
    the keys are usually strings
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，trie，也称为数字树，有时称为基数树或前缀树（因为它们可以通过前缀搜索），是一种搜索树——一种用于存储动态集合或关联数组的有序树数据结构，其中键通常是字符串
- en: 'In other words, a trie tree is an optimized search tree where the keys are
    strings. Let''s illustrate this with a simple example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，trie树是一种优化的搜索树，其中键是字符串。让我们用一个简单的例子来说明这一点：
- en: 'Let''s consider that we have an array of strings:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个字符串数组：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This, when converted into a `trie` tree, would look as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个，当转换成`trie`树时，会看起来像这样：
- en: '![](assets/06376a37-7b3e-4c2a-a135-4951d8f616f4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06376a37-7b3e-4c2a-a135-4951d8f616f4.png)'
- en: From the preceding diagram, we can note that the tree starts at the root and
    then, based on the input strings, the tree gets constructed. While inserting the
    strings into the `trie` tree, the words are broken into individual characters
    and then the duplicate nodes are not reinserted but rather reused to construct
    the rest of the tree.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，我们可以注意到树从根开始，然后根据输入字符串构建树。在将字符串插入到`trie`树中时，单词被分解为单个字符，然后重复的节点不会被重新插入，而是被重用来构建树的其余部分。
- en: Creating a trie tree
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个trie树
- en: Let's now create the `trie` tree, which we will be using within our application.
    Within our application, let's first create the directory called `utils` under
    the `src` folder in which we will be adding our `trie.ts` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`trie`树，在我们的应用程序中使用。在我们的应用程序中，让我们首先在`src`文件夹下创建一个名为`utils`的目录，在其中添加我们的`trie.ts`文件。
- en: 'The API for our tree will be quite concise with only two methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们树的API将非常简洁，只有两种方法：
- en: '`add()`: Adds elements to the `trie` tree'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`：向`trie`树添加元素'
- en: '`search()` : Accepts an input string and returns the subtree that matches the
    query string:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`：接受一个输入字符串并返回与查询字符串匹配的子树：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once created, let''s inject it into the list of providers in our main module
    listed in `app.module.ts` so that our components have access to the tree, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完毕后，让我们将其注入到我们主模块中的提供者列表中，列在`app.module.ts`中，以便我们的组件可以访问树，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing the add() method
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`add()`方法
- en: 'Now, our tree is ready to have its first method implemented. Our tree starts
    off with no elements in it (that is, an empty object). You can use any data structure
    for your implementation, but we will use objects as our data store for simplicity:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的树已经准备好实现其第一个方法了。我们的树一开始是空的（即一个空对象）。您可以使用任何数据结构来实现，但为了简单起见，我们将使用对象作为我们的数据存储：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the preceding code, this method is made up of the following
    two steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，这种方法由以下两个步骤组成：
- en: Determine what level the tree is already built to and ignore those characters.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定树已经建到哪一级并忽略这些字符。
- en: Add the remainder as a new subtree and continue till the end.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数作为新的子树添加并继续直到结束。
- en: The friends' example
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 朋友的例子
- en: Let's put our knowledge to use in an example in which our user wants to add
    two elements to this tree, **Adam**, and **Adrian**. First, we will add **Adam**to
    the tree so we have nodes **a***,* **d**, **a**, and **m**. Then, when adding
    **Adrian***, *we check what is already added—**a** and **d**, in this case—and
    thus the rest of the word **rian** is added as a new subtree.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个示例中运用我们的知识，其中我们的用户想要向这棵树添加两个元素**Adam**和**Adrian**。首先，我们将**Adam**添加到树中，所以我们有节点**a**，**d**，**a**和**m**。然后，当添加**Adrian**时，我们检查已经添加的内容——在这种情况下是**a**和**d**，因此单词的其余部分**rian**被添加为新的子树。
- en: 'When logged, the following is what we see:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录时，我们看到以下内容：
- en: '![](assets/8cf13a76-f164-4301-a7d8-eb21e0d5ad93.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cf13a76-f164-4301-a7d8-eb21e0d5ad93.png)'
- en: As you can see from the preceding screenshot, **a** and **d** are common for
    both the words and then the rest are two subtrees for each string that we added.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的截图中所看到的，**a**和**d**对于两个单词都是相同的，然后其余部分是我们添加的每个字符串的两个子树。
- en: Implementing the search() method
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`search()`方法
- en: 'The `search()` method is even simpler and highly efficient with a complexity
    of O(n), where n is the length of the search input. The big O notation is something
    that will be covered in detail in a later chapter:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`方法更简单，效率更高，复杂度为O(n)，其中n是搜索输入的长度。大O符号将在后面的章节中详细介绍：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's take the friends example described in the preceding code. If the user
    types a,for example, we extract the subtree using the `search()` method just implemented.
    We get the subtree below a*. *
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面代码中描述的朋友示例为例。例如，如果用户输入a，我们使用刚刚实现的`search()`方法提取子树。我们得到了a*下面的子树。
- en: 'The more input character the user provides, the more granular the response
    object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的输入字符越多，响应对象就越精细：
- en: '![](assets/31bdb223-08c7-4bc6-80c2-ba7b343c9681.png) ![](assets/3b1c2519-b178-411a-8c95-c9358a525bb9.png) ![](assets/7a675cd2-1ae0-45fb-8105-0e6f5bfac4a9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31bdb223-08c7-4bc6-80c2-ba7b343c9681.png) ![](assets/3b1c2519-b178-411a-8c95-c9358a525bb9.png)
    ![](assets/7a675cd2-1ae0-45fb-8105-0e6f5bfac4a9.png)'
- en: As we can see from the preceding screenshots, as the user types more, our `search()`
    method keeps returning the sub-tree of the node that matches with it while the
    entire tree can be seen below it. And to render it on the screen we are using
    the following code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，随着用户输入更多内容，我们的`search()`方法会持续返回与之匹配的节点的子树，而整个树可以在其下面看到。为了在屏幕上呈现它，我们使用以下代码。
- en: 'In our `app.component.ts` file we add the following, which queries the `search()`
    method on the `Trie` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.component.ts`文件中，我们添加以下内容，查询`Trie`类上的`search()`方法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then this search result is bound to the template using a simple `pre` tag:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用简单的`pre`标记将此搜索结果绑定到模板：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Retaining remainders at nodes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点保留余数
- en: The `search()` method that we implemented earlier works great; however, as a
    developer, you would now need to loop over the returned sub-tree and construct
    the remainder of the word out of it to be displayed on the UI. That's kind of
    a hassle, isn't it? What if we can simplify it so that the tree would return the
    sub-tree along with the remainder of the words that they form? Actually, it's
    quite easy to achieve this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前实现的`search()`方法效果很好；然而，作为开发人员，您现在需要循环遍历返回的子树，并构建出其中的单词余数，以便在UI上显示。这有点麻烦，不是吗？如果我们可以简化它，使树能够返回子树以及它们形成的单词余数，那会怎么样？实际上，实现这一点相当容易。
- en: 'We will need to make a small change to our algorithm and add remainders set
    at each node; that way, whenever a node is recognized, we can add the remainder
    to that set and also push new elements into this set while creating new nodes.
    Let''s take a look at how this modifies our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对算法进行小的修改，并在每个节点处添加余数集合；这样，每当识别到一个节点时，我们可以将余数添加到该集合中，并在创建新节点时将新元素推入该集合。让我们看看这如何修改我们的代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the preceding code, adding two lines has made our job a lot
    easier than earlier. No more unnecessary looping over the subtree objects, and
    we have the remainder of the words at each node of the sub-tree returned:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，添加两行使我们的工作比以前更容易了。不再需要在子树对象上进行不必要的循环，我们在子树的每个节点上都返回了单词的余数：
- en: '![](assets/8ea81431-11ef-45ca-9cdd-ab0cfe219707.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ea81431-11ef-45ca-9cdd-ab0cfe219707.png)'
- en: 'This would also mean that we have to update our `search()` method''s failure
    condition to return an empty object with a `remainder` set instead of an empty
    object, unlike earlier:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们必须更新我们的`search()`方法的失败条件，以返回一个带有`remainder`设置的空对象，而不是一个空对象，与以前不同：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The final form
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终形式
- en: Putting this all together and adding simple changes to our UI, we can finally
    search through a list and show the results in a very fast and efficient manner.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，并对我们的UI进行简单的更改，我们最终可以以非常快速和高效的方式搜索列表并显示结果。
- en: 'With the previous changes incorporated, our `app.component.ts` is ready to
    take its final form:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 经过前面的更改，我们的`app.component.ts`已经准备好最终形式：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, update the `app.component.html` template to show the search results:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，更新`app.component.html`模板以显示搜索结果：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](assets/45135af2-d8bf-421b-b721-74b33cbb1c44.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45135af2-d8bf-421b-b721-74b33cbb1c44.png)'
- en: Creating a credit card approval predictor
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信用卡批准预测器
- en: Trees are ubiquitous. No matter what application you are using, chances are
    that there are trees in play internally. Having said that, not all trees are data
    structures. In this example, we will explore something different, which is a really
    popular but not a typical data structure, that is, a decision tree.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 树是无处不在的。无论您使用什么应用程序，都有可能在内部使用树。话虽如此，并非所有树都是数据结构。在这个例子中，我们将探索一些不同的东西，这是一种非常流行但不是典型的数据结构，即决策树。
- en: At some stage, you would have come across some sort of an automatic prediction
    system. Whether it is a sports website that predicts the winner of a game or credit
    scoring websites that tell you which credit card you should apply for to get a
    quick approval. In this example, we will go with a credit card approval predictor,
    but this can be easily transferred to any application of your choice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个阶段，您可能已经遇到某种自动预测系统。无论是预测游戏赢家的体育网站，还是告诉您应该申请哪张信用卡以获得快速批准的信用评分网站。在这个例子中，我们将使用信用卡批准预测器，但这可以轻松转移到您选择的任何应用程序。
- en: 'In a majority of the cases, we have a complex Machine Learning model running
    behind the scenes to generate an accurate prediction, but, because we know that
    the number of factors affecting the approval or rejection is finite, we can use
    a decision tree to determine the chances of approval based on the past patterns
    exhibited. The following is the list of tasks that we will have to achieve in
    this example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们有一个复杂的机器学习模型在后台运行，以生成准确的预测，但是，因为我们知道影响批准或拒绝的因素数量是有限的，我们可以使用决策树来确定基于过去展示的模式的批准机会。以下是我们在这个例子中需要完成的任务列表：
- en: Creating the decision tree by implementing  **Iterative Dichotomiser 3** (**ID3**)
    algorithm to classify future samples.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现**迭代二分器3**（**ID3**）算法创建决策树以对未来样本进行分类。
- en: Creating a training dataset.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建训练数据集。
- en: Running new inputs through the algorithm and validating responses.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新输入通过算法并验证响应。
- en: ID3 algorithm
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ID3算法
- en: So far, the algorithms that we have seen were not very complex; they were rather
    trivial, and most of our focus was on implementing the API for a particular data
    structure. In this example, there is no data structure to implement; the algorithm
    itself generates the decision tree that we would be using for our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的算法并不是非常复杂；它们相当琐碎，我们大部分的关注点都在实现特定数据结构的API上。在这个例子中，没有数据结构需要实现；算法本身生成了我们将用于应用程序的决策树。
- en: First, let's take a look at how a table of historical data can be converted
    into a decision tree. The tree that is formed primarily is made up of **decision
    nodes** (which indicate a decision) and **leaf nodes** (which indicates the final
    response, such as yes or no).  The decision nodes can have two or more subnodes,
    depending on the dataset. However, the tree has to start from somewhere, right?
    What would be the root node and how do we get it?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何将历史数据表转换为决策树。主要形成的树由**决策节点**（表示决策）和**叶节点**（表示最终响应，如是或否）组成。决策节点可以有两个或更多的子节点，取决于数据集。然而，树必须从某个地方开始，对吧？根节点是什么，我们如何得到它？
- en: 'To determine the root node, we will first need to know some basics of Information
    Theory here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定根节点，我们首先需要在这里了解一些信息理论的基础知识：
- en: '**Entropy**: Entropy is the measure of uncertainty of a series of inputs—the
    more uncertain the number of input messages, the more inputs are needed to determine
    what the message is; for example, if our input series always sends the same message,
    there is no uncertainty, and thus the entropy is zero. Such an input series is
    also known as pure. However, if the same series sends *n* different types of inputs
    with the same probability, then the entropy becomes high and the receiver needs
    to ask log[2]n Boolean questions to determine the message. The average number
    of bits needed to identify a message is a measure of the sender''s entropy.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**熵**：熵是一系列输入的不确定性度量——输入消息越不确定，就需要更多的输入来确定消息是什么；例如，如果我们的输入系列总是发送相同的消息，那么就没有不确定性，因此熵为零。这样的输入系列也被称为纯的。然而，如果相同的系列以相同的概率发送*n*种不同类型的输入，那么熵就会变高，接收者需要询问log[2]n个布尔问题来确定消息。需要识别消息的平均位数是发送者熵的度量。'
- en: '**Information gain**: To determine the root node, first we will need to split
    the dataset based on the attributes provided, and then determine the entropy at
    each attribute, the difference of entropy at each attribute and that of the target
    determines the information gain or loss of each attribute.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息增益**：为了确定根节点，首先我们需要根据提供的属性拆分数据集，然后确定每个属性的熵，每个属性的熵与目标的差异确定了每个属性的信息增益或损失。'
- en: The attribute with the highest information gain becomes the root attribute.
    Then, we repeat the process for each subtree until we get no entropy. Let's take
    a look at this with an example and then start off with the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最高信息增益的属性成为根属性。然后，我们为每个子树重复该过程，直到没有熵为止。让我们通过一个例子来看看这个，然后开始编码。
- en: 'For the following example, we will take a simple input and popular dataset
    to decide whether a game is going to be played or not based on the weather conditions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下示例，我们将采用简单的输入和流行的数据集，根据天气条件决定是否要玩游戏：
- en: '| **Outlook** | **Temperature** | **Humidity** | **Wind** | **Play Soccer**
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **外观** | **温度** | **湿度** | **风** | **踢足球** |'
- en: '| Sunny | Hot | High | Weak | No |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 晴朗 | 炎热 | 高 | 弱 | 否 |'
- en: '| Sunny | Hot | High | Strong | No |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 晴朗 | 炎热 | 高 | 强 | 否 |'
- en: '| Overcast | Hot | High | Weak | Yes |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 阴天 | 炎热 | 高 | 弱 | 是 |'
- en: '| Rain | Mild | High | Weak | Yes |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 雨 | 温和 | 高 | 弱 | 是 |'
- en: '| Rain | Cool | Normal | Weak | Yes |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 雨 | 凉爽 | 正常 | 弱 | 是 |'
- en: '| Sunny | Cool | Normal | Weak | Yes |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 晴朗 | 凉爽 | 正常 | 弱 | 是 |'
- en: '| Rain | Mild | Normal | Weak | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 雨 | 温和 | 正常 | 弱 | 是 |'
- en: '| Sunny | Mild | Normal | Strong | Yes |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 晴朗 | 温和 | 正常 | 强 | 是 |'
- en: '| Overcast | Mild | High | Strong | Yes |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 阴天 | 温和 | 高 | 强 | 是 |'
- en: '| Overcast | Hot | Normal | Weak | Yes |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Overcast | Hot | Normal | Weak | Yes |'
- en: '| Rain | Cool | Normal | Strong | No |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Rain | Cool | Normal | Strong | No |'
- en: '| Overcast | Cool | Normal | Strong | Yes |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Overcast | Cool | Normal | Strong | Yes |'
- en: '| Sunny | Mild | High | Weak | No |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Sunny | Mild | High | Weak | No |'
- en: In the preceding example, the target is the *Play Soccer *attribute. Let's assume
    that our input source has a capability of sending *n* messages and the probability
    of sending each message is P[n] , then the entropy of the source is the summation
    over *n* of the probabilities *E = -p[i] * log[2](p[i])*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，目标是*Play Soccer*属性。假设我们的输入源有发送*n*条消息的能力，每条消息发送的概率是P[n]，那么源的熵是概率*p[i]
    * log[2](p[i])*的*n*的总和。
- en: Calculating target entropy
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算目标熵
- en: 'Since we have two possible outputs for the *Play Soccer* (target) attribute,
    we will calculate the entropy using the frequency table (indicating how many times
    a particular value was received) of the target attribute:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*Play Soccer*（目标）属性有两种可能的输出，我们将使用目标属性的频率表（指示接收到特定值的次数）来计算熵：
- en: The probability of receiving yes is the total times it was received divided
    by the total number of messages received and so on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接收yes的概率是接收到的总次数除以接收到的消息总数，依此类推。
- en: '| **Play Soccer** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **Play Soccer** |'
- en: '| Yes | No |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Yes | No |'
- en: '| 9 | 4 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 4 |'
- en: 'So, the entropy of the target would be as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目标的熵如下：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Calculating branch entropy
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算分支熵
- en: 'Now, let''s break the dataset down further and calculate the entropy based
    on each branch. We have the following four main branches here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步分解数据集，并根据每个分支计算熵。我们这里有以下四个主要分支：
- en: Outlook
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Outlook
- en: Temperature
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Temperature
- en: Humidity
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Humidity
- en: Wind
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wind
- en: 'Let''s first start with the branch for Outlook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从Outlook分支开始：
- en: '|  |  | Play |  |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |  | Play |  |  |'
- en: '|  |  | Yes | No | Total |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |  | Yes | No | Total |'
- en: '| Outlook | Sunny | 2 | 3 | 5 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Outlook | Sunny | 2 | 3 | 5 |'
- en: '|  | Overcast | 4 | 0 | 4 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  | Overcast | 4 | 0 | 4 |'
- en: '|  | Rain | 3 | 1 | 4 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  | Rain | 3 | 1 | 4 |'
- en: '|  |  |  |  | 13 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | 13 |'
- en: 'To calculate the entropy of the branch, we will first calculate the probability
    of each sub-branch and then multiply it with the entropy of that branch. We will
    then add the resultant entropy for each sub-branch to get the total entropy of
    the branch; then, we can calculate the information gain for the branch:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算分支的熵，我们将首先计算每个子分支的概率，然后将其与该分支的熵相乘。然后，我们将每个子分支的结果熵相加，以获得分支的总熵；然后，我们可以计算分支的信息增益：
- en: '*P(Play, Outlook) = P(Outcast) * E(4,0) + P(Sunny) * E(2,3)  + P(Rain) * E(3,1) *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*P(Play, Outlook) = P(Outcast) * E(4,0) + P(Sunny) * E(2,3)  + P(Rain) * E(3,1) *'
- en: '*= (4/13) * 0 + (5/13) *  0.970 + (4/13) * 0.811*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*= (4/13) * 0 + (5/13) *  0.970 + (4/13) * 0.811*'
- en: '*= 0.62261538461*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*= 0.62261538461*'
- en: So, *the total Information gain for Outlook branch = targetEntropy - branchEntropy*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*Outlook分支的总信息增益=目标熵-分支熵*
- en: '*= 0.89049164021 - 0.62261538461*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*= 0.89049164021 - 0.62261538461*'
- en: '*= 0.2678762556 or **0.27***'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*= 0.2678762556或**0.27***'
- en: The final information gain per branch
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个分支的最终信息增益
- en: 'Now, we can calculate the entropy of all the branches using a frequency table
    of two attributes for the rest of the columns, similar to what we did for Outlook,
    and get the following result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用其余列的两个属性的频率表来计算所有分支的熵，类似于我们为Outlook所做的操作，并得到以下结果：
- en: 'For the branch Humidity*, *there are two possible sub-branches, which have
    the following results breakup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Humidity分支，有两个可能的子分支，其结果分解如下：
- en: '|  |  | yes | no | total |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |  | yes | no | total |'
- en: '| Humidity | high | 3 | 3 | 6 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Humidity | high | 3 | 3 | 6 |'
- en: '|  | normal | 6 | 1 | 7 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | normal | 6 | 1 | 7 |'
- en: '|  |  |  |  | 13 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | 13 |'
- en: 'Similarly, for Wind, the breakup is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于Wind，分解如下：
- en: '|  |  | yes | no | total |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |  | yes | no | total |'
- en: '| Wind | weak | 6 | 2 | 8 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Wind | weak | 6 | 2 | 8 |'
- en: '|  | strong | 3 | 2 | 5 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  | strong | 3 | 2 | 5 |'
- en: '|  |  |  |  | 13 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | 13 |'
- en: 'For Temperature, it is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Temperature，情况如下：
- en: '|  |  | yes | no | total |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |  | yes | no | total |'
- en: '| Temperature | Hot | 2 | 2 | 4 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Temperature | Hot | 2 | 2 | 4 |'
- en: '|  | Mild | 4 | 1 | 5 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | Mild | 4 | 1 | 5 |'
- en: '|  | Cool | 3 | 1 | 4 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | Cool | 3 | 1 | 4 |'
- en: '|  |  |  |  | 13 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | 13 |'
- en: 'We calculate the *branchEntropy* and the *Information gain* for each branch,
    and here are the results following similar steps as we did for the Outlook branch:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算每个分支的*branchEntropy*和*Information gain*，以下是结果，步骤与我们为Outlook分支所做的类似：
- en: '|  | Outlook | Temperature | Humidity | Wind |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | Outlook | Temperature | Humidity | Wind |'
- en: '| Gain | 0.27 | 0.055510642 | 0.110360144 | 0.017801027 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Gain | 0.27 | 0.055510642 | 0.110360144 | 0.017801027 |'
- en: Since Outlook has the highest information gain, we can make it the root decision
    node and split the tree based on its branches and then recursively continue the
    process until we get all the leaf nodes, for example, entropy 0.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Outlook具有最高的信息增益，我们可以将其作为根决策节点，并根据其分支拆分树，然后递归继续该过程，直到获得所有叶节点，例如熵为0。
- en: 'With the root node selected, our input data looks as follows from left to right:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择根节点后，我们的输入数据从左到右如下所示：
- en: '|  | Overcast | Hot | High | Weak | Yes |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | Overcast | Hot | High | Weak | Yes |'
- en: '|  | Overcast | Mild | High | Strong | Yes |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  | Overcast | Mild | High | Strong | Yes |'
- en: '|  | Overcast | Hot | Normal | Weak | Yes |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | Overcast | Hot | Normal | Weak | Yes |'
- en: '|  | Overcast | Cool | Normal | Strong | Yes |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  | Overcast | Cool | Normal | Strong | Yes |'
- en: '|  |  |  |  |  |  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |'
- en: '|  | Sunny | Hot | High | Weak | No |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  | Sunny | Hot | High | Weak | No |'
- en: '| Outlook | Sunny | Hot | High | Strong | No |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| Outlook | Sunny | Hot | High | Strong | No |'
- en: '|  | Sunny | Cool | Normal | Weak | Yes |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  | Sunny | Cool | Normal | Weak | Yes |'
- en: '|  | Sunny | Mild | Normal | Strong | Yes |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | Sunny | Mild | Normal | Strong | Yes |'
- en: '|  | Sunny | Mild | High | Weak | No |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  | Sunny | Mild | High | Weak | No |'
- en: '|  |  |  |  |  |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |'
- en: '|  | Rain | Mild | High | Weak | Yes |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  | Rain | Mild | High | Weak | Yes |'
- en: '|  | Rain | Cool | Normal | Weak | Yes |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  | Rain | Cool | Normal | Weak | Yes |'
- en: '|  | Rain | Mild | Normal | Weak | Yes |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  | Rain | Mild | Normal | Weak | Yes |'
- en: '|  | Rain | Cool | Normal | Strong | No |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  | Rain | Cool | Normal | Strong | No |'
- en: Now, we can see that the branch Overcast always yields response as *Yes* (rightmost
    column), so we can leave that branch out, as the entropy is always 0, that is,
    node Overcast is a leaf node.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到分支Overcast总是产生*Yes*的响应（最右边的列），所以我们可以将该分支排除在外，因为熵总是0，也就是说，节点Overcast是一个叶节点。
- en: Now, at the branch Outlook -> Sunny, we will need to determine the next decision
    node by repeating the process that we did similar to the root. Basically, the
    steps we did previously will continue recursively until we determine all the leaf
    nodes. Let's translate this into code for our credit card example and see it in
    action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在分支Outlook -> Sunny，我们将需要通过重复我们类似于根节点的过程来确定下一个决策节点。基本上，我们之前做过的步骤将继续递归进行，直到确定所有叶节点。让我们将这个转化为代码，用我们的信用卡示例来看看它的运行情况。
- en: Coding the ID3 algorithm
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ID3算法的代码
- en: First, we would need to have an application; let's go ahead and create an Angular
    application as shown previously.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个应用程序；让我们继续创建一个Angular应用程序，如前所示。
- en: 'From the previous example, we have seen that the first thing we will need is
    to list out our training data, which will be fed into our algorithm. In this case,
    we will need to first identify the different attributes that are affecting our
    target attribute (approved). Without going in too deep, the following are the
    major factors (and their possible values), which we are taking as an example of
    something, which can affect your approval chances:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们已经看到，我们首先需要列出我们的训练数据，这些数据将被输入到我们的算法中。在这种情况下，我们首先需要确定影响我们目标属性（approved）的不同属性。不深入讨论，以下是我们将作为影响您批准机会的主要因素（及其可能的值）的示例：
- en: 'Credit score: Overall score of your credit (Excellent, Good, Average, and Poor)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用评分：您的信用总体评分（优秀、良好、一般、差）
- en: 'Credit age: Age of your credit history in years ( >10, >5, >2, >=1)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用年龄：您的信用历史年限（>10、>5、>2、>=1）
- en: 'Derogatory remarks: If there are any remarks on your account (0, 1, 2, >=3)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贬损性言论：如果您的账户上有任何言论（0、1、2、>=3）
- en: 'Utilization: How much of your approved credit you use (High, Medium, and Low)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用率：您使用的批准信用额度的比例（高、中、低）
- en: 'Hard inquiries: How many new accounts did you open recently (0, 1, 2, >=3)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 困难的问题：您最近开了多少个新账户（0、1、2、>=3）
- en: Because of the fixed number of combinations of the preceding list, we can, in
    theory, generate a dataset that comprises all scenarios and then we can predict
    with 100% accuracy using that dataset, but where is the fun in that. We will instead
    be only taking half of the generated dataset and use it to predict the outcome
    of the other half.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面列表的组合数量是固定的，理论上我们可以生成一个包含所有场景的数据集，然后我们可以使用该数据集预测100%的准确性，但这样做有什么乐趣呢。相反，我们将只取生成数据集的一半，并用它来预测另一半的结果。
- en: Generating training dataset
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成训练数据集
- en: 'Although generating the training dataset can be done manually, it''s not fun.
    So, let''s write a small script, which will help us to create the dataset:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以手动生成训练数据集，但这并不有趣。所以，让我们编写一个小脚本，来帮助我们创建数据集：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the preceding script, let''s create a small Node.js project within our
    credit-card project. At the root of the project, from Terminal, run the following
    commands to create the project:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行上述脚本，让我们在credit-card项目中创建一个小的Node.js项目。在项目的根目录中，从终端运行以下命令来创建项目：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the script above logs the `trainingDataWithApprovals` and `predictionDataWithApprovals`*.*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的脚本会记录`trainingDataWithApprovals`和`predictionDataWithApprovals`。
- en: 'Next, copy the `trainingDataWithApprovals` into a file at the following path: `src/utils/training-data/credit-card.ts`*. *The
    data that is logged from the preceding code logs the data, an example of which
    can be seen in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`trainingDataWithApprovals`复制到以下路径的文件中：`src/utils/training-data/credit-card.ts`。从前面的代码中记录的数据，可以在以下截图中看到一个示例：
- en: '![](assets/13e98339-b02f-458f-886c-4213a5cd38ed.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13e98339-b02f-458f-886c-4213a5cd38ed.png)'
- en: 'We can now move the `predictionDataWithApprovals` into the `app.component.ts`
    file and rename the `approved ` attribute to `expected` as that is what we expect
    the output to be. We will compare the actual output against this later:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`predictionDataWithApprovals`移到`app.component.ts`文件中，并将`approved`属性重命名为`expected`，因为这是我们期望的输出。稍后我们将把实际输出与此进行比较：
- en: '![](assets/8319c073-7981-42f0-a73d-e8c44b6cdbc3.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8319c073-7981-42f0-a73d-e8c44b6cdbc3.png)'
- en: Now that we have the training data ready and imported into the project, let's
    create the rest of the algorithm to complete the tree.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好训练数据并导入到项目中，让我们创建算法的其余部分来完成树。
- en: Generating the decision tree
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成决策树
- en: To keep the code complexity to a minimum, we will be extracting all the helper
    methods that we would be recursively calling, as seen in the previous example.
    We can start with the `train()` method because that is going to be called first
    to determine the root decision node.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将代码复杂性降到最低，我们将提取所有我们将递归调用的辅助方法，就像前面的示例中所看到的那样。我们可以从`train()`方法开始，因为这将首先被调用以确定根决策节点。
- en: 'Before we do that, let''s create an Injectable service for our ID3 algorithm
    in the `utils` folder which we will be injecting where we wish to use it. This
    logic can live anywhere you wish, server or client side. One thing to note is
    that the dataset, in this case, is relatively small, so training the dataset and
    predicting the outcomes are an okay thing to do on the client side. With larger
    datasets, which take much longer to train, it is recommended to do this on the
    server side, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，让我们在`utils`文件夹中为我们的ID3算法创建一个可注入的服务，我们将在希望使用它的地方进行注入。这个逻辑可以存在于您希望的任何地方，服务器端或客户端。需要注意的一点是，这种情况下的数据集相对较小，所以在客户端进行训练数据集和预测结果是可以接受的。对于需要更长时间进行训练的更大数据集，建议在服务器端进行。
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At each step of the algorithm, we will be relying heavily on helper methods
    to keep the implementation details clear; most of these would be provided by `lodash`,
    so let''s install and import it so that we can implement the `train()` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的每一步，我们将大量依赖辅助方法来保持实现细节清晰；其中大部分将由`lodash`提供，所以让我们安装并导入它，以便我们可以实现`train()`方法：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once `lodash` is installed, we can start with the `train()` method, which accepts
    three parameters: the training dataset, the target attribute, and the list of
    all the attributes extracted from the training dataset sans the target:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`lodash`后，我们可以开始使用`train()`方法，它接受三个参数：训练数据集、目标属性和从训练数据集中提取的所有属性列表，除了目标属性：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To use this service, mark it as a `provider` in the main module and then inject
    it in the `app.component`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个服务，在主模块中将其标记为`provider`，然后在`app.component`中注入它：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, to consume it in the main component, we can just import the ID3 service
    we have just created and then call the `train()` method on the service instance:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了在主组件中使用它，我们只需导入我们刚刚创建的ID3服务，然后在服务实例上调用`train()`方法：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us also add some styles to our page to make it look nice, so update the
    `app.component.scss` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也给我们的页面添加一些样式，使其看起来更漂亮，所以更新`app.component.scss`文件：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As discussed in the preceding algorithm, the first thing that we do in our
    application is to determine the root decision node, for example, the attribute
    with the highest information gain:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的算法所讨论的，我们应用程序中的第一件事是确定根决策节点，例如，具有最高信息增益的属性：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the preceding code, you can see that we calculate the root decision node
    of the tree first by calculating the branch entropies of each attribute and determining
    the maximum information gain.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，您可以看到我们首先计算树的根决策节点，通过计算每个属性的分支熵并确定最大信息增益。
- en: Now that we have the root, we can recursively repeat the process for each branch
    of the node and then continue to find the decision nodes until we hit the entropy
    of 0, that is, leaf nodes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了根节点，我们可以递归地重复这个过程，对节点的每个分支进行操作，然后继续查找决策节点，直到熵为0，也就是叶节点。
- en: 'This modifies our `train()` method as follows :'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改我们的`train()`方法如下：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With that, the `train()` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`train()`方法：
- en: Takes the input training data, the target attribute, and the attributes list.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受输入的训练数据、目标属性和属性列表。
- en: Gets the current root attribute by calculating the maximum information gain
    at each of the branch of the attribute and creates the root node of the tree.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算每个属性的分支的最大信息增益来获取当前根属性，并创建树的根节点。
- en: Pushes the recursively generated sub-tree into the branches of the root node.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将递归生成的子树推入根节点的分支中。
- en: Predicting outcome of sample inputs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测样本输入的结果
- en: 'Now that our tree is ready and returned, we can use this in our `app.component`
    to determine whether the prediction matches that of the expected outcome using
    the `predict()` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的树已经准备好并返回，我们可以在`app.component`中使用它，使用`predict()`方法来确定预测是否与预期结果匹配：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, in the `app.component`, we consume the `predict()` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`app.component`中，我们调用`predict()`方法：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Visualization of the tree and output
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的可视化和输出
- en: Although we have generated the tree and the expected/actual results of the input
    dataset based on training set, it's really difficult to visualize this data right
    now. So, to do that, let's create a small component that accepts the tree and
    renders the nested format of the tree on the UI. This is pretty minimal and is
    only for the purpose of understanding our data in the form of the decision tree.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经生成了树和基于训练集的输入数据的预期/实际结果，但现在很难可视化这些数据。因此，为了做到这一点，让我们创建一个小组件，接受树并在UI上呈现树的嵌套格式。这非常简单，只是为了理解我们的数据以决策树的形式。
- en: Under the `utils` folder, let's first create the folder called `treeview` to
    contain our component. Let's call it `treeview`, as we create the component and
    inject it into the main module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`文件夹下，让我们首先创建一个名为`treeview`的文件夹，用于包含我们的组件。当我们创建组件并将其注入到主模块中时，让我们称之为`treeview`。
- en: 'For the `treeview`, let''s first create the`treeview.ts` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`treeview`，让我们首先创建`treeview.ts`文件：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we will create the template that goes with the component and add it as
    `treeview.html`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建与组件配套的模板，并将其添加为`treeview.html`：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s style the `treeview` to make it more legible, `treeview.scss`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`treeview`添加样式，使其更易读，`treeview.scss`：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, to consume the `treeview` component, let''s add it to the declarations
    in `app.module.ts`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用`treeview`组件，让我们在`app.module.ts`的declarations中添加它：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To use this, we just have to bind the tree that we generated in our `app.component`
    to the `tree-view` component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个，我们只需要将我们在`app.component`中生成的树绑定到`tree-view`组件：
- en: 'With the `treeview` added, `app.component.html` gets updated as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`treeview`后，`app.component.html`将更新如下：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This renders the tree on the UI as expected:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将如预期地在UI上呈现树：
- en: '![](assets/510c04ba-2032-4311-83cb-fb901db0b870.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/510c04ba-2032-4311-83cb-fb901db0b870.png)'
- en: 'However, this is only a part of the big tree that is generated, which is tough
    to read and visualize. Let''s try the same with the Soccer example by switching
    the training and testing data with Soccer data instead, which we saw in the previous
    sections:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是生成的大树的一部分，很难阅读和可视化。让我们尝试使用相同的方法来处理足球示例，通过将训练和测试数据与足球数据进行交换，这是我们在前几节中看到的：
- en: '![](assets/286e3703-535c-4aec-90f9-a37f8841c963.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/286e3703-535c-4aec-90f9-a37f8841c963.png)'
- en: 'Let''s render the input data that we passed in for testing our decision tree.
    For that, we can modify our `app.component.html`to show the table and visualization
    simultaneously:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们渲染我们传入的输入数据，以测试我们的决策树。为此，我们可以修改我们的`app.component.html`来同时显示表格和可视化：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To style the table, we can add the following to our `app.component.scss` file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给表格添加样式，我们可以在我们的`app.component.scss`文件中添加以下内容：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The expected output is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![](assets/8432186a-20ff-4bfa-be3c-8c3f10a2be95.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8432186a-20ff-4bfa-be3c-8c3f10a2be95.png)'
- en: 'For the Soccer example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足球示例：
- en: '![](assets/d5a6ae12-b846-4521-aab9-aed522fae6f9.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d5a6ae12-b846-4521-aab9-aed522fae6f9.png)'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a rather orthodox approach to understanding trees as
    data structures, where we deviated from the standard process of learning about
    a tree and implementing its methods. We instead took some real-world example and
    implemented the trees as we see fit, based on the use case at hand. This will
    be the case where you are provided the data and are challenged to implement it
    in a generic way to expand the use cases. In the next chapter, we will expand
    this approach and take it one step further, where we will note how it expands
    into graph theory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们采取了一种相当正统的方法来理解树作为数据结构，我们偏离了学习树和实现其方法的标准流程。相反，我们采用了一些真实世界的例子，并根据手头的用例实现了树。这将是一个情况，你会被提供数据，并被挑战以一种通用的方式来扩展用例。在下一章中，我们将扩展这种方法，并将其推进一步，我们将注意到它如何扩展到图论中。
