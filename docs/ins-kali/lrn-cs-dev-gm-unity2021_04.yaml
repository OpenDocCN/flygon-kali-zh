- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Control Flow and Collection Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流和集合类型
- en: One of the central duties of a computer is to control what happens when predetermined
    conditions are met. When you click on a folder, you expect it to open; when you
    type on the keyboard, you expect the text to mirror your keystrokes. Writing code
    for applications or games is no different—they both need to behave in a certain
    way in one state, and in another when conditions change. In programming terms,
    this is called control flow, which is apt because it controls the flow of how
    code is executed in different scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一个核心职责是在满足预定条件时控制发生的事情。当你点击一个文件夹时，你期望它会打开；当你在键盘上输入时，你期望文本会反映你的击键。为应用程序或游戏编写代码也是一样的——它们在一种状态下需要以某种方式行为，而在条件改变时则需要另一种方式。在编程术语中，这被称为控制流，这很合适，因为它控制了代码在不同情况下的执行流程。
- en: 'In addition to working with control statements, we''ll be taking a hands-on
    look at collection data types. Collections are a category of types that allow
    multiple values, and groupings of values, to be stored in a single variable. We''ll
    break the chapter down into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用控制语句，我们还将亲自了解集合数据类型。集合是一类允许在单个变量中存储多个值和值组合的类型。我们将把本章分解为以下主题：
- en: Selection statements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句
- en: Working with array, dictionary, and list collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组、字典和列表集合
- en: Iteration statements with `for`, `foreach`, and `while` loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`、`foreach`和`while`循环的迭代语句
- en: Fixing infinite loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复无限循环
- en: Selection statements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: The most complex programming problems can often be boiled down to sets of simple
    choices that a game or program evaluates and acts on. Since Visual Studio and
    Unity can't make those choices by themselves, writing out those decisions is up
    to us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的编程问题通常可以归结为一系列简单选择，游戏或程序会评估并执行。由于Visual Studio和Unity不能自己做出这些选择，编写这些决策就取决于我们。
- en: 'The `if-else` and `switch` selection statements allow you to specify branching
    paths, based on one or more conditions, and the actions you want to be taken in
    each case. Traditionally, these conditions include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`和`switch`选择语句允许您根据一个或多个条件指定分支路径，以及在每种情况下要执行的操作。传统上，这些条件包括以下内容：'
- en: Detecting user input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测用户输入
- en: Evaluating expressions and Boolean logic
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估表达式和布尔逻辑
- en: Comparing variables or literal values
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较变量或文字值
- en: You're going to start with the simplest of these conditional statements, `if-else`,
    in the following section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从最简单的条件语句`if-else`开始，在下一节中。
- en: The if-else statement
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if-else语句
- en: '`if-else` statements are the most common way of making decisions in code. When
    stripped of all its syntax, the basic idea is, *If my condition is met, execute
    this block of code; if it''s not, execute this other block of code*. Think of
    these statements as gates, or doors, with the conditions as their keys. To pass
    through, the key needs to be valid. Otherwise, entry will be denied and the code
    will be sent to the next possible gate. Let''s take a look at the syntax for declaring
    one of these gates.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`语句是代码中做出决策的最常见方式。当剥离所有语法时，基本思想是，“如果我的条件满足，执行这一段代码；如果不满足，执行另一段代码”。把这些语句想象成门，或者说是门，条件就是它们的钥匙。要通过，钥匙必须有效。否则，入口将被拒绝，代码将被发送到下一个可能的门。让我们来看看声明这些门的语法。'
- en: 'A valid `if-else` statement requires the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的`if-else`语句需要以下内容：
- en: The `if` keyword at the beginning of the line
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行首的`if`关键字
- en: A pair of parentheses to hold the condition
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对括号来保存条件
- en: A statement body inside curly brackets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号内的语句体
- en: 'It looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Optionally, an `else` statement can be added to store the action you want to
    take when the `if` statement condition fails. The same rules apply for the `else`
    statement:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以添加一个`else`语句来存储当`if`语句条件失败时要采取的操作。`else`语句也适用相同的规则：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In blueprint form, the syntax almost reads like a sentence, which is why this
    is the recommended approach:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以蓝图形式，语法几乎读起来像一句话，这就是为什么这是推荐的方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since these are great introductions to logical thinking, at least in programming,
    we''ll break down the three different `if-else` variations in more detail:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是逻辑思维的很好入门，至少在编程中，我们将更详细地解释三种不同的`if-else`变体：
- en: 'A single `if` statement can exist by itself in cases where you don''t care
    about what happens if the condition isn''t met. In the following example, if `hasDungeonKey`
    is set to `true`, then a debug log will print out; if set to `false`, no code
    will execute:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个`if`语句可以独立存在，如果不关心条件不满足时会发生什么。在下面的例子中，如果`hasDungeonKey`设置为`true`，那么会打印出一个调试日志；如果设置为`false`，则不会执行任何代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When referring to a condition as being met, I mean that it evaluates to true,
    which is often referred to as a passing condition.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到条件被满足时，我的意思是它评估为true，这通常被称为通过条件。
- en: 'Add an `else` statement in cases where an action needs to be taken whether
    the condition is true or false. If `hasDungeonKey` were `false`, the `if` statement
    would fail and the code execution would jump to the `else` statement:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要无论条件是否为真都需要采取行动的情况下，可以添加一个`else`语句。如果`hasDungeonKey`为`false`，`if`语句将失败，代码执行将跳转到`else`语句：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For cases where you need to have more than two possible outcomes, add an `else-if`
    statement with its parentheses, conditions, and curly brackets. This is best shown
    rather than explained, which we'll do next.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于需要有两个以上可能结果的情况，可以添加一个`else-if`语句，其中包括括号、条件和花括号。这最好通过示例来展示，而不是解释，我们将在下一节中做。
- en: Keep in mind that `if` statements can be used by themselves, but the other statements
    cannot exist on their own. You can also create more complex conditions with basic
    math operations, such as `>` (greater than), `<` (less than), `>=` (greater than
    or equal to), `<=` (less than or equal to), and `==` (equivalent). For example,
    a condition of (2 > 3) will return `false` and fail, while a condition of (2 <
    3) will return `true` and pass.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`if`语句可以单独使用，但其他语句不能单独存在。您还可以使用基本的数学运算符创建更复杂的条件，例如`>`（大于），`<`（小于），`>=`（大于或等于），`<=`（小于或等于）和`==`（等于）。例如，条件（2>3）将返回`false`并失败，而条件（2<3）将返回`true`并通过。
- en: Don't worry too much about anything beyond this right now; you'll get your hands
    on this stuff soon enough.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要太担心任何其他事情；你很快就会接触到这些东西。
- en: 'Let''s write out an `if-else` statement that checks the amount of money in
    a character''s pocket, returning different debug logs for three different cases—greater
    than `50`, less than `15`, and anything else:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个`if-else`语句来检查角色口袋里的钱数，对三种不同情况返回不同的调试日志——大于`50`，小于`15`，以及其他任何情况：
- en: 'Open up `LearningCurve` and add a new public `int` variable, named `CurrentGold`.
    Set its value to between 1 and 100:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`并添加一个新的公共`int`变量，名为`CurrentGold`。将其值设置在1到100之间：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a `public` method with no return value, called `Thievery`, and call it
    inside `Start`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的`public`方法，名为`Thievery`，并在`Start`中调用它。
- en: 'Inside the new function, add an `if` statement to check whether `CurrentGold`
    is greater than `50`, and print a message to the console if this is true:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新函数中，添加一个`if`语句来检查`CurrentGold`是否大于`50`，如果是，则向控制台打印一条消息：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add an `else-if` statement to check whether `CurrentGold` is less than `15`
    with a different debug log:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`else-if`语句来检查`CurrentGold`是否小于`15`，并添加一个不同的调试日志：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add an `else` statement with no condition and a final default log:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个没有条件的`else`语句和一个最终的默认日志：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file, check that your method matches the code below, and click on
    play:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，检查您的方法是否与下面的代码匹配，并点击播放：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With `CurrentGold` set to `32` in my example, we can break down the code sequence
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，将`CurrentGold`设置为`32`，我们可以将代码序列分解如下：
- en: The `if` statement and debug log are skipped because `CurrentGold` is not greater
    than `50`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if`语句和调试日志被跳过，因为`CurrentGold`不大于`50`。'
- en: The `else-if` statement and debug log are also skipped because `CurrentGold`
    is not less than `15`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`else-if`语句和调试日志也被跳过，因为`CurrentGold`不小于`15`。'
- en: Since 32 is not less than 15 or greater than 50, neither of the previous conditions
    was met. The `else` statement executes and the third debug log is displayed:![](img/B17573_04_01.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于32既不小于15也不大于50，之前的条件都没有满足。`else`语句执行并显示第三个调试日志：![](img/B17573_04_01.png)
- en: 'Figure 4.1: Screenshot of the console showing the debug output'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：控制台截图显示调试输出
- en: After trying out some other values for `CurrentGold` on your own, let's discuss
    what happens if we want to test a failing condition.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己尝试一些其他`CurrentGold`值之后，让我们讨论一下如果我们想测试一个失败的条件会发生什么。
- en: Using the NOT operator
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NOT运算符
- en: 'Use cases won''t always require checking for a positive, or `true`, condition,
    which is where the `NOT` operator comes in. Written with a single exclamation
    point, the `NOT` operator allows negative, or false, conditions to be met by `if`
    or `else-if` statements. This means that the following conditions are the same:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用例并不总是需要检查正条件或`true`条件，这就是`NOT`运算符发挥作用的地方。用一个感叹号写成的`NOT`运算符允许`if`或`else-if`语句满足负条件或false条件。这意味着以下条件是相同的：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you already know, you can check for Boolean values, literal values, or expressions
    in an `if` condition. So, naturally, the `NOT` operator has to be adaptable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，您可以在`if`条件中检查布尔值、文字值或表达式。因此，`NOT`运算符必须是可适应的。
- en: 'Take a look at the following example of two different negative values, `hasDungeonKey`
    and `weaponType`, used in an `if` statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下两个不同负值`hasDungeonKey`和`weaponType`在`if`语句中的使用示例：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can evaluate each statement as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对每个语句进行评估：
- en: The first statement can be translated to, "If `hasDungeonKey` is `false`, the
    `if` statement evaluates to true and executes its code block."
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条语句可以翻译为，“如果`hasDungeonKey`为`false`，`if`语句评估为true并执行其代码块。”
- en: 'If you''re asking yourself how a false value can evaluate to true, think of
    it this way: the `if` statement is not checking whether the value is true, but
    that the expression itself is true. `hasDungeonKey` might be set to false, but
    that''s what we''re checking for, so it''s true in the context of the `if` condition.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想一个false值怎么能评估为true，可以这样想：`if`语句并不是检查值是否为true，而是检查表达式本身是否为true。`hasDungeonKey`可能被设置为false，但这就是我们要检查的，所以在`if`条件的上下文中是true。
- en: The second statement can be translated to, "If the string value of `weaponType`
    is `not equal` to `Longsword`, then execute this code block."
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条语句可以翻译为，“如果`weaponType`的字符串值`不等于` `Longsword`，则执行此代码块。”
- en: 'You can see the debug results in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到调试结果：
- en: '![](img/B17573_04_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_02.png)'
- en: 'Figure 4.2: Screenshot of the console showing the NOT operator output'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：控制台截图显示NOT运算符的输出
- en: However, if you're still confused, copy the code we've looked at in this section
    into `LearningCurve` and play around with the variable values until it makes sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你还是感到困惑，可以将我们在本节中看到的代码复制到`LearningCurve`中，并尝试改变变量的值，直到弄明白为止。
- en: So far, our branching conditions have been fairly simple, but C# also allows
    conditional statements to be nested inside each other for more complex situations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的分支条件相当简单，但C#也允许条件语句嵌套在彼此内部，以处理更复杂的情况。
- en: Nesting statements
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套语句
- en: 'One of the most valuable functions of `if-else` statements is that they can
    be nested inside each other, creating complex logic routes through your code.
    In programming, we call them decision trees. Just like a real hallway, there can
    be doors behind other doors, creating a labyrinth of possibilities:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 语句最有价值的功能之一是它们可以嵌套在彼此内部，从而在代码中创建复杂的逻辑路线。在编程中，我们称它们为决策树。就像真正的走廊一样，后面可能有门，从而创造出一系列可能性的迷宫：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s break down the preceding example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的例子：
- en: First, an `if` statement checks whether we have `weaponEquipped`. At this point,
    the code only cares whether it's `true`, not what type of weapon it is.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一个 `if` 语句检查我们是否装备了武器。此时，代码只关心它是否为 `true`，而不关心它是什么类型的武器。
- en: The second `if` statement checks the `weaponType` and prints out the associated
    debug log.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 `if` 语句检查 `weaponType` 并打印出相关的调试日志。
- en: If the first `if` statement evaluates to `false`, the code would jump to the
    `else` statement and its debug log. If the second `if` statement evaluates to
    `false`, nothing is printed because there is no `else` statement.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个 `if` 语句评估为 `false`，代码将跳转到 `else` 语句及其调试日志。如果第二个 `if` 语句评估为 `false`，则不会打印任何内容，因为没有
    `else` 语句。
- en: The responsibility of handling logic outcomes is 100% on the programmer. It's
    up to you to determine the possible branches or outcomes your code can take.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 处理逻辑结果的责任完全在程序员身上。你需要确定代码可能走的分支或结果。
- en: What you've learned so far will get you through simple use cases with no problem.
    However, you'll quickly find yourself in need of more complex statements, which
    is where evaluating multiple conditions comes into play.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你学到的东西将让你轻松应对简单的用例。然而，你很快会发现自己需要更复杂的语句，这就是评估多个条件的地方。
- en: Evaluating multiple conditions
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估多个条件
- en: 'In addition to nesting statements, it''s also possible to combine multiple
    condition checks into a single `if` or `else-if` statement with `AND` `OR` logic
    operators:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌套语句，还可以将多个条件检查组合成单个 `if` 或 `else-if` 语句，使用 `AND` `OR` 逻辑运算符：
- en: '`AND` is written with two ampersand characters, `&&`. Any condition using the
    `AND` operator means that all conditions need to evaluate to true for the `if`
    statement to execute.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND` 用两个和字符 `&&` 写成。使用 `AND` 运算符的任何条件都意味着所有条件都需要为 `if` 语句评估为真才能执行。'
- en: '`OR` is written with two pipe characters, `||`. An `if` statement using the
    `OR` operator will execute if one or more of its conditions is true.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR` 用两个竖线字符 `||` 写成。使用 `OR` 运算符的 `if` 语句将在其条件中的一个或多个为真时执行。'
- en: Conditions are always evaluated from left to right.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件总是从左到右进行评估。
- en: 'In the following example, the `if` statement has been updated to check for
    both `weaponEquipped` and `weaponType`, both of which need to be true for the
    code block to execute:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`if` 语句已更新为检查 `weaponEquipped` 和 `weaponType`，两者都需要为真才能执行代码块：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AND` `OR` operators can be combined to check multiple conditions in any
    order. There is also no limit on how many operators you can combine. Just be careful
    when using them together that you don't create logic conditions that will never
    execute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`AND` `OR` 运算符可以组合在一起以任意顺序检查多个条件。你可以组合的运算符数量也没有限制。只是当一起使用它们时要小心，不要创建永远不会执行的逻辑条件。'
- en: It's time to put everything we've learned so far about `if` statements to the
    test. So, review this section if you need to, and then move on to the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将到目前为止学到的关于 `if` 语句的一切付诸实践了。所以，如果需要的话，请复习本节，然后继续下一节。
- en: 'Let''s cement this topic with a little treasure chest experiment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小宝箱实验来巩固这个主题：
- en: 'Declare three variables at the top of `LearningCurve`: `PureOfHeart` is a `bool`
    and should be `true`, `HasSecretIncantation` is also a `bool` and should be `false`,
    and `RareItem` is a string and its value is up to you:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LearningCurve` 的顶部声明三个变量：`PureOfHeart` 是一个 `bool`，应该为 `true`，`HasSecretIncantation`
    也是一个 `bool`，应该为 `false`，`RareItem` 是一个字符串，其值由你决定：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a `public` method with no return value, called `OpenTreasureChamber`,
    and call it from inside `Start()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的 `public` 方法，名为 `OpenTreasureChamber`，并从 `Start()` 中调用它。
- en: 'Inside `OpenTreasureChamber`, declare an `if-else` statement to check whether
    `PureOfHeart` is `true` *and* that `RareItem` matches the string value you assigned
    to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OpenTreasureChamber` 中，声明一个 `if-else` 语句来检查 `PureOfHeart` 是否为 `true` *并且*
    `RareItem` 是否与你分配给它的字符串值匹配：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a nested `if-else` statement inside the first, checking whether `HasSecretIncantation`
    is `false`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个内部创建一个嵌套的 `if-else` 语句，检查 `HasSecretIncantation` 是否为 `false`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add debug logs for each `if-else` case.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个 `if-else` 情况添加调试日志。
- en: 'Save, check that your code matches the code below, and click play:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，检查你的代码是否与下面的代码匹配，然后点击播放：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you matched the variable values to the preceding screenshot, the nested
    `if` statement debug log will be printed out. This means that our code got past
    the first `if` statement checking for two conditions, but failed the third:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将变量值与前面的截图匹配，嵌套的 `if` 语句调试日志将被打印出来。这意味着我们的代码通过了检查两个条件的第一个 `if` 语句，但未通过第三个条件：
- en: '![](img/B17573_04_03.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_03.png)'
- en: 'Figure 4.3: Screenshot of debut output in the console'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：控制台中的调试输出截图
- en: Now, you could stop here and use even bigger `if-else` statements for all your
    conditional needs, but that's not going to be efficient in the long run. Good
    programming is about using the right tool for the right job, which is where the
    `switch` statement comes in.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以停在这里，甚至为你所有的条件需求使用更大的 `if-else` 语句，但从长远来看这并不高效。良好的编程是关于使用正确的工具来完成正确的工作，这就是
    `switch` 语句的用武之地。
- en: The switch statement
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: '`if-else` statements are a great way to write decision logic. However, when
    you have more than three or four branching actions, they just aren''t feasible.
    Before you know it, your code can end up looking like a tangled knot that''s hard
    to follow, and a headache to update.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 语句是编写决策逻辑的好方法。然而，当你有三四个以上的分支动作时，它们就不可行了。在你意识到之前，你的代码可能会变得像一个难以理解的纠结，更新起来也会很头疼。'
- en: '`switch` statements take in expressions and let us write out actions for each
    possible outcome, but in a much more concise format than `if-else`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句接受表达式，并让我们为每种可能的结果编写操作，但格式比`if-else`更简洁。'
- en: '`switch` statements require the following elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句需要以下元素：'
- en: The `switch` keyword followed by a pair of parentheses holding its condition
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`关键字后面跟着一对括号，括号中是条件'
- en: A pair of curly brackets
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对大括号
- en: 'A `case` statement for each possible path ending with a colon: individual lines
    of code or methods, followed by the `break` keyword and a semicolon'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个可能路径的`case`语句以冒号结尾：单行代码或方法，后跟`break`关键字和分号
- en: 'A default `case` statement ending with a colon: individual lines of code or
    methods, followed by the `break` keyword and a semicolon'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以冒号结尾的默认`case`语句：单行代码或方法，后跟`break`关键字和分号
- en: 'In blueprint form, it looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以蓝图形式，它看起来像这样：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The highlighted keywords in the preceding blueprint are the important bits.
    When a `case` statement is defined, anything between its colon and `break` keyword
    acts like the code block of an `if-else` statement. The `break` keyword just tells
    the program to exit the `switch` statement entirely after the selected `case`
    fires. Now, let's discuss how the statement determines which `case` gets executed,
    which is called pattern matching.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的蓝图中，突出显示的关键字是重要的部分。当定义一个`case`语句时，在其冒号和`break`关键字之间的任何内容都像`if-else`语句的代码块一样。`break`关键字只是告诉程序在选择的`case`触发后完全退出`switch`语句。现在，让我们讨论语句如何确定执行哪个`case`，这被称为模式匹配。
- en: Pattern matching
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配
- en: In `switch` statements, pattern matching refers to how a match expression is
    validated against multiple `case` statements. A match expression can be of any
    type that isn't null or nothing; all `case` statement values need to match the
    type of the match expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`语句中，模式匹配指的是如何将匹配表达式与多个`case`语句进行验证。匹配表达式可以是任何非空或非空的类型；所有`case`语句的值都需要与匹配表达式的类型匹配。
- en: For example, if we had a `switch` statement that was evaluating an integer variable,
    each `case` statement would need to specify an integer value for it to check against.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个`switch`语句，正在评估一个整数变量，那么每个`case`语句都需要指定一个整数值来检查。
- en: The `case` statement with a value that matches the expression is the one that
    is executed. If no `case` is matched, the default `case` fires. Let's try this
    out for ourselves!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 具有与表达式匹配的值的`case`语句将被执行。如果没有匹配的`case`，则默认的`case`将被执行。让我们自己试一试！
- en: 'That was a lot of new syntax and information, but it helps to see it in action.
    Let''s create a simple `switch` statement for different actions a character could
    take:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多新的语法和信息，但看到它在实际中运行会有所帮助。让我们为角色可能采取的不同行动创建一个简单的`switch`语句：
- en: Create a new string variable (member or local), named `CharacterAction`, and
    set it to `Attack:`
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的字符串变量（成员或本地），名为`CharacterAction`，并将其设置为`Attack:`
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a `public` method with no return value called `PrintCharacterAction`,
    and call it inside `Start`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的`public`方法，名为`PrintCharacterAction`，并在`Start`内调用它。
- en: 'Declare a `switch` statement and use `CharacterAction` as the match expression:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`switch`语句，并使用`CharacterAction`作为匹配表达式：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create two `case` statements for `Heal` and `Attack` with different debug logs.
    Don''t forget to include the `break` keyword at the end of each:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Heal`和`Attack`创建两个`case`语句，其中包含不同的调试日志。不要忘记在每个末尾包括`break`关键字：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add a default case with a debug log and `break:`
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有调试日志和`break`的默认情况：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save the file, make sure your code matches the screenshot below, and click
    play:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，确保您的代码与下面的截图匹配，然后点击播放：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since `CharacterAction` is set to `Attack`, the `switch` statement executes
    the second case and prints out its debug log:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CharacterAction`设置为`Attack`，`switch`语句执行第二个`case`并打印其调试日志：
- en: '![](img/B17573_04_04.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_04.png)'
- en: 'Figure 4.4: Screenshot of the switch statement output in the console'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：控制台中`switch`语句输出的截图
- en: Change `CharacterAction` to either `Heal` or an undefined action to see the
    first and default cases in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CharacterAction`更改为`Heal`或未定义的动作，以查看第一个和默认情况的执行情况。
- en: There are going to be times where you need several, but not all, `switch` cases
    to perform the same action. These are called fall-through cases and are the subject
    of our next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要几个，但不是所有的`switch`情况都执行相同的操作。这些被称为贯穿案例，是我们下一节的主题。
- en: Fall-through cases
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贯穿案例
- en: '`switch` statements can execute the same action for multiple cases, similar
    to how we specified several conditions in a single `if` statement. The term for
    this is called fall-through or, sometimes, fall-through cases. Fall-through cases
    let you define a single set of actions for multiple cases. If a case block is
    left empty or has code without the `break` keyword, it will fall through to the
    case directly beneath it. This helps keep your switch code clean and efficient,
    without duplicated case blocks.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句可以为多个情况执行相同的操作，类似于我们在单个`if`语句中指定多个条件。这个术语叫做贯穿，有时也叫贯穿案例。贯穿案例允许您为多个情况定义一组操作。如果一个`case`块为空或者有没有`break`关键字的代码，它将贯穿到直接下面的`case`。这有助于保持`switch`代码的清晰和高效，避免重复的`case`块。'
- en: Cases can be written in any order, so creating fall-through cases greatly increases
    code readability and efficiency.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`可以以任何顺序编写，因此创建贯穿案例大大增加了代码的可读性和效率。'
- en: 'Let''s simulate a tabletop game scenario with a `switch` statement and fall-through
    case, where a dice roll determines the outcome of a specific action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟一个桌面游戏场景，使用`switch`语句和贯穿案例，其中骰子的点数决定了特定动作的结果：
- en: 'Create an `int` variable, named `DiceRoll`, and assign it a value of `7`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`int`变量，名为`DiceRoll`，并将其赋值为`7`：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a `public` method with no return value, called `RollDice`, and call it
    inside `Start`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有返回值的`public`方法，名为`RollDice`，并在`Start`内调用它。
- en: 'Add a `switch` statement with `DiceRoll` as the match expression:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`switch`语句，使用`DiceRoll`作为匹配表达式：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Add three cases for possible dice rolls at `7`, `15`, and `20`, with a default
    `case` statement at the end.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为可能的骰子点数`7`、`15`和`20`添加三种情况，并在最后添加一个默认的`case`语句。
- en: Cases `15` and `20` should have their own debug logs and `break` statements,
    while case `7` should fall through to case `15:`
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`15`和`20`的情况应该有它们自己的调试日志和`break`语句，而情况`7`应该通过到情况`15`：'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save the file and run it in Unity.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在Unity中运行它。
- en: If you want to see the fall-through case in action, try adding a debug log to
    case 7, but without the `break` keyword.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看穿透情况的情况，请尝试在情况7中添加调试日志，但不使用`break`关键字。
- en: 'With `DiceRoll` set to `7`, the `switch` statement will match with the first
    `case`, which will fall through and execute `case 15` because it lacks a code
    block and a `break` statement. If you change `DiceRoll` to `15` or `20`, the console
    will show their respective messages, and any other value will fire off the default
    case at the end of the statement:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DiceRoll`设置为`7`，`switch`语句将与第一个`case`匹配，然后通过并执行`case 15`，因为它缺少代码块和`break`语句。如果将`DiceRoll`更改为`15`或`20`，控制台将显示它们各自的消息，而任何其他值都将触发语句末尾的默认情况：
- en: '![](img/B17573_04_05.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_05.png)'
- en: 'Figure 4.5: Screenshot of fall-through switch statement code'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：穿透switch语句代码的屏幕截图
- en: '`switch` statements are extremely powerful and can simplify even the most complex
    decision logic. If you want to dig deeper into switch pattern matching, refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句非常强大，甚至可以简化最复杂的决策逻辑。如果您想深入了解switch模式匹配，请参考[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch)。'
- en: That's all we need to know about conditional logic for the moment. So, review
    this section if you need to, and then test yourself on the following quiz before
    moving on to collections!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们目前需要了解的有关条件逻辑的全部内容。因此，在继续学习集合之前，请复习本节内容，然后在进行下一步之前进行以下测验！
- en: Pop quiz 1 – if, and, or but
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验1 - if，and，or but
- en: 'Test your knowledge with the following questions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下问题测试您的知识：
- en: What values are used to evaluate `if` statements?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于评估`if`语句的值是什么？
- en: Which operator can turn a true condition false or a false condition true?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个运算符可以将真条件变为假，假条件变为真？
- en: If two conditions need to be true for an `if` statement's code to execute, what
    logical operator would you use to join the conditions?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`语句的代码需要两个条件都为真才能执行，您会使用什么逻辑运算符来连接这些条件？
- en: If only one of two conditions needs to be true to execute an `if` statement's
    code, what logical operator would you use to join the two conditions?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`语句的代码只需要两个条件中的一个为真才能执行，您会使用什么逻辑运算符来连接这两个条件？
- en: With that done, you're ready to step into the world of collection data types.
    These types are going to open up a whole new subset of programming functionality
    for your games and C# programs!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您就可以进入集合数据类型的世界了。这些类型将为您的游戏和C#程序打开全新的编程功能子集！
- en: Collections at a glance
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一览集合
- en: So far, we've only needed variables to store a single value, but there are many
    conditions where a group of values will be required. Collection types in C# include
    arrays, dictionaries, and lists—each has its strengths and weaknesses, which we'll
    discuss in the following sections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需要变量来存储单个值，但有许多情况需要一组值。C#中的集合类型包括数组、字典和列表，每种类型都有其优势和劣势，我们将在接下来的部分讨论。
- en: Arrays
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: '**Arrays** are the most basic collection that C# offers. Think of them as containers
    for a group of values, called *elements* in programming terminology, each of which
    can be accessed or modified individually:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是C#提供的最基本的集合。将它们视为一组值的容器，在编程术语中称为*元素*，每个元素都可以单独访问或修改：'
- en: Arrays can store any type of value; all the elements need to be of the same
    type.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以存储任何类型的值；所有元素都需要是相同的类型。
- en: The length, or the number of elements an array can have, is set when it's created
    and can't be modified afterward.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的长度或元素数量在创建时确定，之后不能修改。
- en: If no initial values are assigned when it's created, each element will be given
    a default value. Arrays storing number types default to zero, while any other
    type gets set to null or nothing.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在创建数组时未分配初始值，则每个元素将被赋予默认值。存储数字类型的数组默认为零，而任何其他类型都设置为null或nothing。
- en: Arrays are the least flexible collection type in C#. This is mainly because
    elements can't be added or removed after they have been created. However, they
    are particularly useful when storing information that isn't likely to change. That
    lack of flexibility makes them faster compared to other collection types.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是C#中最不灵活的集合类型。这主要是因为元素在创建后无法添加或删除。然而，当存储不太可能改变的信息时，它们特别有用。这种缺乏灵活性使它们与其他集合类型相比更快。
- en: 'Declaring an array is similar to other variable types we''ve worked with, but
    has a few modifications:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 声明数组与我们之前使用的其他变量类型类似，但有一些修改：
- en: Array variables require a specified element type, a pair of square brackets,
    and a unique name.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组变量需要指定的元素类型、一对方括号和一个唯一的名称。
- en: The `new` keyword is used to create the array in memory, followed by the value
    type and another pair of square brackets. The reserved memory area is the exact
    size of the data you're intending to store in the new array.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`关键字用于在内存中创建数组，后跟值类型和另一对方括号。保留的内存区域的大小与您打算存储在新数组中的数据的确切大小相同。'
- en: The number of elements the array will store goes inside the second pair of square
    brackets.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组将存储的元素数量放在第二对方括号中。
- en: 'In blueprint form, it looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式中，它看起来像这样：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s take an example where we need to store the top three high scores in
    our game:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们需要存储游戏中的前三个最高分：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Broken down, `topPlayerScores` is an array of integers that will store three
    integer elements. Since we didn't add any initial values, each of the three values
    in `topPlayerScores` is `0`. However, if you change the array size, the contents
    of the original array are lost, so be careful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`topPlayerScores`被分解为一个将存储三个整数元素的整数数组。由于我们没有添加任何初始值，`topPlayerScores`中的三个值都是`0`。但是，如果更改数组大小，则原始数组的内容将丢失，因此要小心。'
- en: 'You can assign values directly to an array when it''s created by adding them
    inside a pair of curly brackets at the end of the variable declaration. C# has
    a longhand and shorthand way of doing this, but both are equally valid:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在变量声明的末尾将值直接赋给数组，方法是将它们添加到一对花括号中。C#有一种长格式和短格式的做法，但两者都是有效的：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Initializing arrays with the shorthand syntax is very common, so I'll be using
    it for the rest of the book. However, if you want to remind yourself of the details,
    feel free to use the explicit wording.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简写语法初始化数组非常常见，因此我将在本书的其余部分中使用它。但是，如果您想提醒自己有关细节，可以随时使用显式措辞。
- en: Now that the declaration syntax is no longer a mystery, let's talk about how
    array elements are stored and accessed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明语法不再是一个谜了，让我们来谈谈数组元素是如何存储和访问的。
- en: Indexing and subscripts
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和下标
- en: Each array element is stored in the order it's assigned, which is referred to
    as its index. Arrays are zero-indexed, meaning that the element order starts at
    zero instead of one. Think of an element's index as its reference, or location.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组元素都按分配顺序存储，这称为它的索引。数组是从零开始索引的，这意味着元素顺序从零开始而不是从一开始。将元素的索引视为其引用或位置。
- en: 'In `topPlayerScores`, the first integer, `452`, is located at index `0`, `713`
    at index `1`, and `984` at index `2`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`topPlayerScores`中，第一个整数`452`位于索引`0`，`713`位于索引`1`，`984`位于索引`2`：
- en: '![](img/B17573_04_06.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_06.png)'
- en: 'Figure 4.6: Array indexes mapped to their values'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：数组索引映射到它们的值
- en: 'Individual values are located by their index using the subscript operator,
    which is a pair of square brackets that contains the index of the elements. For
    example, to retrieve and store the second array element in `topPlayerScores`,
    we would use the array name followed by subscript brackets and index `1`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下标运算符，可以通过其索引找到各个值，下标运算符是一对包含元素索引的方括号。例如，要检索并存储`topPlayerScores`中的第二个数组元素，我们将使用数组名称，后跟下标括号和索引`1`：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The subscript operator can also be used to directly modify an array value just
    like any other variable, or even passed around as an expression by itself:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下标运算符也可以用于直接修改数组值，就像任何其他变量一样，甚至可以作为表达式传递：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The values in `topPlayerScores` would then be `452`, `1001`, and `984`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`topPlayerScores`中的值将是`452`，`1001`和`984`。'
- en: Range exceptions
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围异常
- en: 'When arrays are created, the number of elements is set and unchangeable, which
    means we can''t access an element that doesn''t exist. In the `topPlayerScores`
    example, the array length is 3, so the range of valid indices is from `0` to `2`.
    Any index of `3` or higher is out of the array''s range and will generate an aptly-named
    `IndexOutOfRangeException` error in the console:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组时，元素的数量是固定的，无法更改，这意味着我们无法访问不存在的元素。在`topPlayerScores`示例中，数组长度为3，因此有效索引的范围是从`0`到`2`。任何`3`或更高的索引都超出了数组的范围，并将在控制台中生成一个名为`IndexOutOfRangeException`的错误：
- en: '![](img/B17573_04_07.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_07.png)'
- en: 'Figure 4.7: Screenshot of index out of range exception'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：索引超出范围异常的屏幕截图
- en: Good programming habits dictate that we avoid range exceptions by checking whether
    the value we want is within an array's index range, which we'll cover in the *Iteration
    statements* section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程习惯要求我们通过检查我们想要的值是否在数组的索引范围内来避免范围异常，这将在*迭代语句*部分中介绍。
- en: 'You can always check the length of an array, that is, how many items it contains,
    with the `Length` property:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Length`属性始终检查数组的长度，即它包含多少项：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our case, the length of `topPlayerScores` is 4.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`topPlayerScores`的长度为4。
- en: Arrays aren't the only collection types C# has to offer. In the next section,
    we'll deal with lists, which are more flexible and more common in the programming
    landscape.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 数组并不是C#提供的唯一集合类型。在下一节中，我们将处理列表，它们在编程领域中更加灵活和常见。
- en: Lists
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: '**Lists** are closely related to arrays, collecting multiple values of the
    same type in a single variable. They''re much easier to deal with when it comes
    to adding, removing, and updating elements, but their elements aren''t stored
    sequentially. They are also mutable, meaning you can change the length or number
    of items you''re storing, without overwriting the whole variable. This can, sometimes,
    lead to a higher performance cost over arrays.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**与数组密切相关，可以在单个变量中收集相同类型的多个值。在添加、删除和更新元素时，它们要处理起来更加容易，但它们的元素并不是按顺序存储的。它们也是可变的，这意味着您可以更改正在存储的项目的长度或数量，而不必覆盖整个变量。这有时可能会导致与数组相比更高的性能成本。'
- en: Performance cost refers to how much of a computer's time and energy a given
    operation takes up. Nowadays, computers are fast, but they can still get overloaded
    with big games or applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 性能成本是指给定操作占用计算机时间和能量的多少。如今，计算机速度很快，但仍然可能因大型游戏或应用程序而过载。
- en: 'A list-type variable needs to meet the following requirements:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表类型变量需要满足以下要求：
- en: The `List` keyword, its element type inside left and right arrow characters,
    and a unique name
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`关键字，其元素类型在左右箭头字符内，以及一个唯一的名称'
- en: The `new` keyword to initialize the list in memory, with the `List` keyword
    and element type between arrow characters
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`关键字在内存中初始化列表，使用`List`关键字和箭头字符之间的元素类型
- en: A pair of parentheses capped off by a semicolon
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由分号结束的一对括号
- en: 'In blueprint form, it reads as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图形式中，它的读法如下：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: List length can always be modified, so there is no need to specify how many
    elements it will eventually hold when created.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表长度总是可以修改的，因此在创建时不需要指定它最终将容纳多少元素。
- en: 'Like arrays, lists can be initialized in the variable declaration by adding
    element values inside a pair of curly brackets:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，列表可以在变量声明中初始化，方法是在一对花括号中添加元素值：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Elements are stored in the order they are added (instead of the sequential order
    of the values themselves), are zero-indexed, and can be accessed using the subscript
    operator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 元素按添加顺序存储（而不是值本身的顺序），从零开始索引，并且可以使用下标运算符进行访问。
- en: Let's start setting up a list of our own to test out the basic functionality
    this class has on offer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置自己的列表，以测试该类提供的基本功能。
- en: 'Let''s do a warm-up exercise by creating a list of party members in a fictional
    role-playing game:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个虚构角色扮演游戏中的成员列表来进行热身练习：
- en: 'Create a new `List` of the `string` type inside `Start` called `QuestPartyMembers`,
    and initialize it with the names of three characters:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`内部创建一个名为`QuestPartyMembers`的`string`类型的新`List`，并用三个角色的名称初始化它：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a debug log to print out the number of party members in the list using
    the `Count` method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调试日志，使用`Count`方法打印出列表中的成员数量：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save the file and play it in Unity.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在Unity中播放它。
- en: We initialized a new list, called `QuestPartyMembers`, which now holds three
    string values, and used the `Count` method from the `List` class to print out
    the number of elements. Notice that you use `Count` for lists, but `Length` for
    arrays.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个名为`QuestPartyMembers`的新列表，其中现在包含三个字符串值，并使用`List`类的`Count`方法打印出元素的数量。请注意，您对列表使用`Count`，但对数组使用`Length`。
- en: '![](img/B17573_04_08.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_08.png)'
- en: 'Figure 4.8: Screenshot of list item output in the console'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：控制台中列表项输出的屏幕截图
- en: Knowing how many elements are in a list is highly useful; however, in most cases,
    that information is not enough. We want to be able to modify our lists as needed,
    which we'll discuss next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 知道列表中有多少元素非常有用；但是，在大多数情况下，这些信息是不够的。我们希望能够根据需要修改我们的列表，接下来我们将讨论这一点。
- en: Accessing and modifying lists
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问和修改列表
- en: List elements can be accessed and modified like arrays with a subscript operator
    and index, as long as the index is within the `List` class's range. However, the
    `List` class has a variety of methods that extend its functionality, such as adding,
    inserting, and removing elements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素可以像数组一样使用下标运算符和索引进行访问和修改，只要索引在`List`类的范围内。但是，`List`类具有各种方法来扩展其功能，例如添加、插入和删除元素。
- en: 'Sticking with the `QuestPartyMembers` list, let''s add a new member to the
    team:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`QuestPartyMembers`列表，让我们向团队添加一个新成员：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Add()` method appends the new element at the end of the list, which brings
    the `QuestPartyMembers` count to four and the element order to the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`方法将新元素附加到列表末尾，这将使`QuestPartyMembers`计数为四，并且元素顺序如下：'
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To add an element to a specific spot in a list, we can pass the index and the
    value that we want to add to the `Insert()` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要将元素添加到列表中的特定位置，我们可以将索引和要添加到`Insert()`方法的值传递：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When an element is inserted at a previously occupied index, all the elements
    in the list have their indices increased by `1`. In our example, `"Tanis the Thief"`
    is now at index `1`, meaning that `"Merlin the Wise"` is now at index `2` instead
    of `1`, and so on:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素插入到先前占用的索引时，列表中的所有元素的索引都增加了`1`。在我们的例子中，`“Tanis the Thief”`现在位于索引`1`，这意味着`“Merlin
    the Wise”`现在位于索引`2`而不是`1`，依此类推：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Removing an element is just as simple; all we need is the index or the literal
    value, and the `List` class does the work:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素同样简单；我们只需要索引或文字值，`List`类就会完成工作：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the end of our edits, `QuestPartyMembers` now contains the following elements
    indexed from `0` to `3`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的编辑结束时，`QuestPartyMembers`现在包含以下从`0`到`3`的元素：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are many more `List` class methods that allow for value checks, finding
    and sorting elements, and working with ranges. A full method list, with descriptions,
    can be found here: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`类有许多其他方法，允许进行值检查、查找和排序元素，并处理范围。可以在此处找到完整的方法列表和描述：[https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2)。'
- en: While lists are great for single-value elements, there are cases where you'll
    need to store information or data containing more than one value. This is where
    dictionaries come into play.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表非常适合单个值元素，但有些情况下，您需要存储包含多个值的信息或数据。这就是字典发挥作用的地方。
- en: Dictionaries
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'The **Dictionary** type steps away from arrays and lists by storing value pairs
    in each element, instead of single values. These elements are referred to as key-value
    pairs: the key acts as the index, or lookup value, for its corresponding value.
    Unlike arrays and lists, dictionaries are unordered. However, they can be sorted
    and ordered in various configurations after they are created.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**类型通过在每个元素中存储值对而不是单个值，而不是数组和列表。这些元素被称为键值对：键充当其对应值的索引或查找值。与数组和列表不同，字典是无序的。但是，它们可以在创建后以各种配置进行排序和排序。'
- en: 'Declaring a dictionary is almost the same as declaring a list, but with one
    added detail—both the key and the value type need to be specified inside the arrow
    symbols:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 声明字典几乎与声明列表相同，但有一个额外的细节——需要在箭头符号内指定键和值类型：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To initialize a dictionary with key-value pairs, do the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用键值对初始化字典，请执行以下操作：
- en: Use a pair of curly brackets at the end of the declaration.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明的末尾使用一对花括号。
- en: Add each element within its pair of curly brackets, with the key and the value
    separated by a comma.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个元素添加到其花括号对中，键和值用逗号分隔。
- en: Separate elements with a comma, except the last element where the comma is optional.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用逗号分隔元素，最后一个元素的逗号是可选的。
- en: 'It looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An important note to consider when picking key values is that each key must
    be unique, and they cannot be changed. If you need to update a key, then you need
    to change its value in the variable declaration or remove the entire key-value
    pair and add another in code, which we'll look at next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择键值时需要考虑的一个重要注意事项是，每个键必须是唯一的，且不能更改。如果需要更新键，则需要在变量声明中更改其值，或者在代码中删除整个键值对并添加另一个，我们将在下面看到。
- en: Just like with arrays and lists, dictionaries can be initialized on a single
    line with no problems from Visual Studio. However, writing out each key-value
    pair on its line, as in the preceding example, is a good habit to get into—both
    for readability and your sanity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组和列表一样，字典可以在一行上初始化，而不会受到来自Visual Studio的问题。然而，像前面的例子中那样在每一行上写出每个键值对，是一个良好的习惯——无论是为了可读性还是为了你的理智。
- en: 'Let''s create a dictionary to store items that a character might carry:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个字典来存储角色可能携带的物品：
- en: Declare a `Dictionary` with a `key` type of `string` and a `value` type of `int`
    called `ItemInventory` in the `Start` method.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中声明一个`key`类型为`string`，`value`类型为`int`的`Dictionary`，名为`ItemInventory`。
- en: 'Initialize it to `new Dictionary<string, int>()`, and add three key-value pairs
    of your choice. Make sure each element is in its pair of curly brackets:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其初始化为`new Dictionary<string, int>()`，并添加三个自己选择的键值对。确保每个元素都在其花括号对中：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a debug log to print out the `ItemInventory.Count` property so that we
    can see how items are stored:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调试日志以打印出`ItemInventory.Count`属性，以便我们可以看到物品是如何存储的：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save the file and play.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并播放。
- en: 'Here, a new dictionary, called `ItemInventory`, was created and initialized
    with three key-value pairs. We specified the keys as strings, with corresponding
    values as integers, and printed out how many elements `ItemInventory` currently
    holds:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为`ItemInventory`的新字典，并用三个键值对进行了初始化。我们将键指定为字符串，对应的值为整数，并打印出`ItemInventory`当前持有的元素数量：
- en: '![](img/B17573_04_09.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_09.png)'
- en: 'Figure 4.9: Screenshot of dictionary count in console'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：控制台中字典计数的截图
- en: Like lists, we need to be able to do more than just print out the number of
    key-value pairs in a given dictionary. We'll explore adding, removing, and updating
    these values in the following section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，我们需要能够做的不仅仅是打印出给定字典中键值对的数量。我们将在下一节中探讨添加、删除和更新这些值。
- en: Working with dictionary pairs
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理字典对
- en: 'Key-value pairs can be added, removed, and accessed from dictionaries using
    both subscript and class methods. To retrieve an element''s value, use the subscript
    operator with the element''s key—in the following example, `numberOfPotions` would
    be assigned a value of `5`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对可以使用下标和类方法从字典中添加、删除和访问。使用下标运算符和元素的键来检索元素的值，在下面的例子中，`numberOfPotions`将被赋予`5`的值：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An element''s value can be updated using the same method—the value associated
    with `"Potion"` would now be `10`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同的方法更新元素的值——与`"Potion"`相关联的值现在将是`10`：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Elements can be added to dictionaries in two ways: with the `Add` method and
    with the subscript operator. The `Add` method takes in a key and a value and creates
    a new key-value element, as long as their types correspond to the dictionary declaration:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`Add`方法和下标运算符的两种方式向字典中添加元素。`Add`方法接受一个键和一个值，并创建一个新的键值元素，只要它们的类型与字典声明相对应：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the subscript operator is used to assign a value to a key that doesn''t
    exist in a dictionary, the compiler will automatically add it as a new key-value
    pair. For example, if we wanted to add a new element for `"Bandage"`, we could
    do so with the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用下标运算符为字典中不存在的键分配一个值，编译器将自动将其添加为新的键值对。例如，如果我们想要为`"Bandage"`添加一个新元素，我们可以使用以下代码：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This brings up a crucial point about referencing key-value pairs: it''s better
    to be certain that an element exists before trying to access it, to avoid mistakenly
    adding new key-value pairs. Pairing the `ContainsKey` method with an `if` statement
    is the simple solution since `ContainsKey` returns a Boolean value based on whether
    the key exists. In the following example, we make sure that the `"Aspirin"` key
    exists using an `if` statement before modifying its value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个关键的问题，关于引用键值对：最好在尝试访问之前确定元素是否存在，以避免错误地添加新的键值对。将`ContainsKey`方法与`if`语句配对是一个简单的解决方案，因为`ContainsKey`根据键是否存在返回一个布尔值。在下面的例子中，我们确保在修改其值之前使用`if`语句检查`"Aspirin"`键是否存在：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, a key-value pair can be deleted from a dictionary using the `Remove()`
    method, which takes in a key parameter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用`Remove()`方法从字典中删除一个键值对，该方法接受一个键参数：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Like lists, dictionaries offer a variety of methods and functionality to make
    development easier, but we can't cover them all here. If you're curious, the official
    documentation can be found at [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，字典提供了各种方法和功能，使开发更加容易，但我们无法在这里覆盖它们所有。如果你感兴趣，官方文档可以在[https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2)找到。
- en: 'Collections are safely in our toolkit, so it''s time for another quiz to make
    sure you''re ready to move on to the next big topic: iteration statements.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 集合已经安全地放在我们的工具包中，所以现在是时候进行另一个测验，以确保你已经准备好转向下一个重要主题：迭代语句。
- en: Pop quiz 2 – all about collections
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验2——关于集合的一切
- en: What is an element in an array or list?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组或列表中的元素是什么？
- en: What is the index number of the first element in an array or list?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组或列表中第一个元素的索引号是多少？
- en: Can a single array or list store different types of data?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个数组或列表可以存储不同类型的数据吗？
- en: How can you add more elements to an array to make room for more data?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向数组中添加更多元素以为更多数据腾出空间？
- en: Since collections are groups or lists of items, they need to be accessible in
    an efficient manner. Luckily, C# has several iteration statements, which we'll
    talk about in the following section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是项目的组或列表，它们需要以有效的方式访问。幸运的是，C#有几个迭代语句，我们将在下一节中讨论。
- en: Iteration statements
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代语句
- en: We've accessed individual collection elements through the subscript operator,
    along with collection type methods, but what do we do when we need to go through
    the entire collection element by element? In programming, this is called iteration,
    and C# provides several statement types that let us loop through (or iterate over,
    if you want to be technical) collection elements. Iteration statements are like
    methods, in that they store a block of code to be executed; unlike methods, they
    can repeatedly execute their code blocks as long as their conditions are met.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过下标运算符访问了单个集合元素，以及集合类型的方法，但是当我们需要逐个遍历整个集合元素时该怎么办呢？在编程中，这称为迭代，C#提供了几种语句类型，让我们可以循环遍历（或者如果你想要更严谨一些，可以说迭代）集合元素。迭代语句就像方法一样，它们存储要执行的代码块；与方法不同的是，它们可以根据条件重复执行它们的代码块。
- en: for loops
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环
- en: The `for` loop is most commonly used when a block of code needs to be executed
    a certain number of times before the program continues. The statement itself takes
    in three expressions, each with a specific function to perform before the loop
    executes. Since `for` loops keep track of the current iteration, they are best
    suited to arrays and lists.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在程序在继续之前需要执行一定次数的代码块时最常用。语句本身包含三个表达式，每个表达式在循环执行之前执行特定的功能。由于`for`循环跟踪当前迭代，因此最适合于数组和列表。'
- en: 'Take a look at the following looping statement blueprint:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下循环语句的蓝图：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s break this down:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: The `for` keyword starts the statement, followed by a pair of parentheses.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`关键字开始语句，后面跟着一对括号。'
- en: 'Inside the parentheses are the gatekeepers: the `initializer`, `condition`,
    and `iterator` expressions.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 括号内是守门人：`initializer`、`condition`和`iterator`表达式。
- en: The loop starts with the `initializer` expression, which is a local variable
    created to keep track of how many times the loop has executed—this is usually
    set to 0 because collection types are zero-indexed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环从`initializer`表达式开始，这是一个本地变量，用于跟踪循环执行的次数——通常设置为0，因为集合类型是从零开始索引的。
- en: Next, the `condition` expression is checked and, if true, proceeds to the iterator.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将检查`condition`表达式，如果为真，则继续进行迭代。
- en: The `iterator` expression is used to either increase or decrease (increment
    or decrement) the initializer, meaning the next time the loop evaluates its condition,
    the initializer will be different.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iterator`表达式用于增加或减少（递增或递减）`initializer`，这意味着下次循环评估其条件时，`initializer`将不同。'
- en: Increasing and decreasing a value by 1 is called incrementing and decrementing,
    respectively (`--` will decrease a value by 1, and `++` will increase it by 1).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加和减少1来增加和减少一个值分别称为递增和递减（`--`将一个值减少1，`++`将一个值增加1）。
- en: 'That all sounds like a lot, so let''s look at a practical example with the
    `QuestPartyMembers` list we created earlier:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很复杂，让我们用我们之前创建的`QuestPartyMembers`列表来看一个实际的例子：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s go through the loop again and see how it works:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次通过循环并看看它是如何工作的：
- en: First, the `initializer` in the `for` loop is set as a local `int` variable
    named `i` with a starting value of `0`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`for`循环中的`initializer`被设置为一个名为`i`的本地`int`变量，初始值为`0`。
- en: 'To ensure we never get an out-of-range exception, the `for` loop makes sure
    that the loop only runs another time if `i` is less than the number of elements
    in `QuestPartyMembers`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们永远不会得到超出范围的异常，`for`循环确保只有在`i`小于`QuestPartyMembers`中元素的数量时才运行另一次：
- en: With arrays, we use the `Length` property to determine how many items it has
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数组，我们使用`Length`属性来确定它有多少项。
- en: With lists, we use the `Count` property
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表，我们使用`Count`属性
- en: Finally, `i` is increased by 1 each time the loop runs with the `++` operator.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`i`每次循环运行时都会增加1，使用`++`运算符。
- en: Inside the `for` loop, we've just printed out the index and the list element
    at that index using `i`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环内部，我们刚刚使用`i`打印出了该索引和该索引处的列表元素。
- en: Notice that `i` is in step with the index of the collection elements, since
    both start at 0:![](img/B17573_04_10.png)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`i`与集合元素的索引保持一致，因为两者都从0开始！
- en: 'Figure 4.10: Screenshot of list values printed out with a for loop'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：使用for循环打印出列表值的屏幕截图
- en: Traditionally, the letter `i` is typically used as the initializer variable
    name. If you happen to have nested `for` loops, the variable names used should
    be the letters j, k, l, and so on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，字母`i`通常用作初始化变量名。如果你碰巧有嵌套的`for`循环，那么使用的变量名应该是字母j、k、l等。
- en: Let's try out our new iteration statements on one of our existing collections.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们现有的集合中尝试一下我们的新迭代语句。
- en: 'While we loop through `QuestPartyMembers`, let''s see whether we can identify
    when a certain element is iterated over and add a special debug log just for that
    case:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们循环遍历`QuestPartyMembers`时，让我们看看是否能够确定何时迭代某个元素，并为该情况添加一个特殊的调试日志：
- en: Move the `QuestPartyMembers` list and `for` loop into a public function called
    `FindPartyMember` and call it in `Start`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`QuestPartyMembers`列表和`for`循环移动到名为`FindPartyMember`的公共函数中，并在`Start`中调用它。
- en: Add an `if` statement below the debug log in the `for` loop to check whether
    the current `questPartyMember` list matches `"Merlin the Wise":`
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环中的调试日志下面添加一个`if`语句，以检查当前的`questPartyMember`列表是否与`"Merlin the Wise"`匹配：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If it does, add a debug log of your choice, check that your code matches the
    screenshot below, and hit play:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，添加一个你选择的调试日志，检查你的代码是否与下面的屏幕截图匹配，然后点击播放：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The console output should look almost the same, except that there is now an
    extra debug log—one that only printed once when it was Merlin''s turn to go through
    the loop. More specifically, when `i` was equal to `1` on the second loop, the
    `if` statement fired and two logs were printed out instead of just one:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出应该几乎相同，只是现在有一个额外的调试日志——当Merlin轮到他通过循环时，这个日志只打印了一次。更具体地说，当`i`在第二次循环时等于`1`时，`if`语句触发了，打印出了两个日志而不是一个：
- en: '![](img/B17573_04_11.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_11.png)'
- en: 'Figure 4.11: Screenshot of the for loop printing out list values and matching
    if statements'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：打印列表值和匹配if语句的for循环的屏幕截图
- en: Using a standard `for` loop can be highly useful in the right situation, but
    there's seldom just one way to do things in programming, which is where the `foreach`
    statement comes into play.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的情况下，使用标准的`for`循环可能非常有用，但在编程中很少只有一种方法，这就是`foreach`语句发挥作用的地方。
- en: foreach loops
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foreach循环
- en: '`foreach` loops take each element in a collection and store each one in a local
    variable, making it accessible inside the statement. The local variable type must
    match the collection element type to work properly. `foreach` loops can be used
    with arrays and lists, but they are especially useful with dictionaries, since
    dictionaries are key-value pairs instead of numeric indexes.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环获取集合中的每个元素，并将每个元素存储在本地变量中，使其在语句内可访问。本地变量类型必须与集合元素类型匹配才能正常工作。`foreach`循环可以与数组和列表一起使用，但与字典一起使用尤其有用，因为字典是键值对而不是数字索引。'
- en: 'In blueprint form, a `foreach` loop looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以蓝图形式，`foreach`循环看起来像这样：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s stick with the `Q``uestPartyMembers` list example and do a roll call
    for each of its elements:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用`QuestPartyMembers`列表示例，并为其每个元素进行点名：
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can break this down as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其分解如下：
- en: The element type is declared as a `string`, which matches the values in `QuestPartyMembers`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素类型声明为`string`，与`QuestPartyMembers`中的值匹配。
- en: A local variable, called `partyMember`, is created to hold each element as the
    loop repeats.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`partyMember`的本地变量，以便在循环重复时保存每个元素。
- en: The `in` keyword, followed by the collection we want to loop through, in this
    case, `QuestPartyMembers`, finishes things off:![](img/B17573_04_12.png)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`关键字，后跟我们想要循环遍历的集合，这种情况下是`QuestPartyMembers`，完成了一切！[](img/B17573_04_12.png)'
- en: 'Figure 4.12: Screenshot of a foreach loop printing out list values'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：打印列表值的foreach循环的屏幕截图
- en: This is a good deal simpler than the `for` loop. However, when dealing with
    dictionaries, there are a few important differences we need to mention—namely
    how to deal with key-value pairs as local variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这比`for`循环简单得多。但是，在处理字典时，有一些重要的区别需要提到，即如何处理键值对作为本地变量。
- en: Looping through key-value pairs
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环遍历键值对
- en: To capture a key-value pair in a local variable, we need to use the aptly named
    `KeyValuePair` type, assigning both the key and value types to match the dictionary's
    corresponding types. Since `KeyValuePair` is its type, it acts just like any other
    element type, as a local variable.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地变量中捕获键值对，我们需要使用名为`KeyValuePair`的类型，将键和值类型分配为与字典对应类型相匹配。由于`KeyValuePair`是其类型，它就像任何其他元素类型一样，作为本地变量。
- en: 'For example, let''s loop through the `ItemInventory` dictionary we created
    earlier in the *Dictionaries* section and debug each key-value like a shop item
    description:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们循环遍历我们在*字典*部分中创建的`ItemInventory`字典，并调试每个键值对，就像商店物品描述一样：
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've specified a local variable of `KeyValuePair`, called `kvp`, which is a
    common naming convention in programming, like calling the `for` loop initializer
    `i`, and setting the `key` and `value` types to `string` and `int` to match `ItemInventory`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个名为`KeyValuePair`的本地变量`kvp`，这是编程中的一种常见命名惯例，就像将`for`循环初始化器称为`i`，并将`key`和`value`类型设置为`string`和`int`以匹配`ItemInventory`。
- en: To access the key and value of the local `kvp` variable, we use the `KeyValuePair`
    properties of `Key` and `Value`, respectively.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本地`kvp`变量的键和值，我们分别使用`KeyValuePair`的`Key`和`Value`属性。
- en: 'In this example, the keys are `strings` and the `values` are integers, which
    we can print out as the item name and item price:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，键是`字符串`，`值`是整数，我们可以将其打印出来作为项目名称和项目价格：
- en: '![](img/B17573_04_13.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_13.png)'
- en: 'Figure 4.13: Screenshot of a foreach loop printing out dictionary key-value
    pairs'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：打印字典键值对的foreach循环的屏幕截图
- en: If you're feeling particularly adventurous, try out the following optional challenge
    to drive home what you've just learned.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到特别有冒险精神，可以尝试以下可选挑战，以加深你刚刚学到的知识。
- en: Hero's trial – finding affordable items
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 英雄的试炼-寻找实惠的物品
- en: Using the preceding script, create a variable to store how much gold your fictional
    character has, and see whether you can add an `if` statement inside the `foreach`
    loop to check for items that you can afford.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的脚本，创建一个变量来存储你虚构角色拥有的金币数量，并查看是否可以在`foreach`循环内添加一个`if`语句来检查你能负担得起的物品。
- en: 'Hint: use `kvp.Value` to compare prices with what''s in your wallet.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用`kvp.Value`来比较你的钱包中的价格。
- en: while loops
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: '`while` loops are similar to `if` statements in that they run as long as a
    single expression or condition is true.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环类似于`if`语句，因为它们只要单个表达式或条件为真就会运行。'
- en: Value comparisons and Boolean variables can be used as `while` conditions, and
    they can be modified with the `NOT` operator.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 值比较和布尔变量可以用作`while`条件，并且可以用`NOT`运算符进行修改。
- en: 'The `while` loop syntax says, *While my condition is true, keep running my
    code block indefinitely*:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环语法是这样说的，*只要我的条件为真，就无限运行我的代码块*：'
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With `while` loops, it's common to declare an initializer variable, as in a
    `for` loop, and manually increment or decrement it at the end of the loop's code
    block. We do this to avoid an infinite loop, which we will discuss at the end
    of the chapter. Depending on your situation, the initializer is usually part of
    the loop's condition.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环时，通常会声明一个初始化变量，就像`for`循环一样，并在循环代码块的末尾手动增加或减少它。我们这样做是为了避免无限循环，我们将在本章末讨论这个问题。根据您的情况，初始化变量通常是循环条件的一部分。
- en: '`while` loops are very useful when coding in C#, but they are not considered
    good practice in Unity because they can negatively impact performance and routinely
    need to be manually managed.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程中，`while`循环非常有用，但在Unity中并不被认为是良好的实践，因为它们可能会对性能产生负面影响，并且通常需要手动管理。
- en: 'Let''s take a common use case where we need to execute code while the player
    is alive, and then debug when that''s no longer the case:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个常见的用例，我们需要在玩家还活着时执行代码，然后在不再是这种情况时进行调试：
- en: 'Create an initializer variable called `PlayerLives` of the `int` type, and
    set it to `3`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PlayerLives`的`int`类型的初始化变量，并将其设置为`3`：
- en: '[PRE61]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Create a new public function called `HealthStatus` and call it in `Start`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HealthStatus`的新公共函数，并在`Start`中调用它。
- en: 'Declare a `while` loop with the condition checking whether `PlayerLives` is
    greater than `0` (that is, the player is still alive):'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`while`循环，检查`PlayerLives`是否大于`0`（也就是玩家还活着）：
- en: '[PRE62]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Inside the `while` loop, debug something to let us know the character is still
    kicking, then decrement `PlayerLives` by 1 using the `--` operator:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环内，调试一些内容，让我们知道角色仍然活着，然后使用`--`运算符将`PlayerLives`减1：
- en: '[PRE63]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a debug log after the `while` loop curly brackets to print something when
    our lives run out:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环的大括号后添加一个调试日志，以便在生命耗尽时打印一些内容：
- en: '[PRE64]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Your code should look like the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该如下所示：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With `PlayerLives` starting out at `3`, the `while` loop will execute three
    times. During each loop, the debug log, `"Still alive!"`, fires, and a life is
    subtracted from `PlayerLives`. When the `while` loop goes to run a fourth time,
    our condition fails because `PlayerLives` is `0`, so the code block is skipped
    and the final debug log prints out:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PlayerLives`从`3`开始时，`while`循环将执行三次。在每次循环中，调试日志`"Still alive!"`会触发，并且会从`PlayerLives`中减去一条生命。当`while`循环要执行第四次时，我们的条件失败了，因为`PlayerLives`为`0`，所以代码块被跳过，最终的调试日志打印出来：
- en: '![](img/B17573_04_14.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_04_14.png)'
- en: 'Figure 4.14: Screenshot of while-loop output in the console'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：控制台中while循环输出的屏幕截图
- en: If you're not seeing multiple "Still alive!" debug logs, make sure the **Collapse**
    button in the **Console** toolbar isn't selected.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到多个"Still alive!"的调试日志，请确保**控制台**工具栏中的**折叠**按钮没有被选中。
- en: The question now is what happens if a loop never stops executing? We'll discuss
    this issue in the following section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，如果循环永远不停止执行会发生什么？我们将在下一节讨论这个问题。
- en: To infinity and beyond
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到无穷大和更远
- en: 'Before finishing this chapter, we need to understand one extremely vital concept
    when it comes to iteration statements: *infinite loops*. These are exactly what
    they sound like: when a loop''s conditions make it impossible for it to stop running
    and move on in the program. Infinite loops usually happen in `for` and `while`
    loops when the iterator is not increased or decreased; if the `PlayerLives` line
    of code was left out of the `while` loop example, Unity would freeze and/or crash,
    recognizing that `PlayerLives` would always be 3 and execute the loop forever.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们需要了解一个非常重要的概念，即迭代语句：*无限循环*。这正是它们的名字：当循环的条件使得它无法停止运行并继续在程序中执行时。无限循环通常发生在`for`和`while`循环中，当迭代器没有增加或减少时；如果在`while`循环示例中省略了`PlayerLives`代码行，Unity将会冻结和/或崩溃，因为`PlayerLives`将永远是3，并且循环会一直执行下去。
- en: Iterators are not the only culprits to be aware of; setting conditions in a
    `for` loop that will never fail, or evaluate to false, can also cause infinite
    loops. In the party members example, from the *Looping through key-value pairs*
    section, if we had set the `for` loop condition to `i < 0` instead of `i < QuestPartyMembers.Count`,
    `i` would always be less than `0`, looping until Unity crashed.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器并不是唯一需要注意的问题；在`for`循环中设置永远不会失败或评估为false的条件也会导致无限循环。在*遍历键值对*部分的团队成员示例中，如果我们将`for`循环的条件设置为`i
    < 0`而不是`i < QuestPartyMembers.Count`，`i`将永远小于`0`，循环直到Unity崩溃。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we bring the chapter to a close, we should reflect on how much we've accomplished
    and what we can build with that new knowledge. We know how to use simple `if-else`
    checks and more complex `switch` statements, allowing decision making in code.
    We can create variables that hold collections of values with arrays and lists
    or key-value pairs with dictionaries. This allows complex and grouped data to
    be stored efficiently. We can even choose the right looping statement for each
    collection type, while carefully avoiding infinite-loop crashes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们应该反思我们取得了多少成就，以及我们可以用这些新知识构建什么。我们知道如何使用简单的`if-else`检查和更复杂的`switch`语句，在代码中进行决策。我们可以使用数组和列表存储值的集合，或者使用字典存储键值对。这样可以高效地存储复杂和分组的数据。我们甚至可以为每种集合类型选择合适的循环语句，同时小心避免无限循环崩溃。
- en: If you're feeling overloaded, that's perfectly OK—logical, sequential thinking
    is all part of exercising your programming brain.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感到不知所措，那完全没问题——逻辑、顺序思维都是锻炼您编程大脑的一部分。
- en: The next chapter will complete the basics of C# programming with a look at classes,
    structs, and **object-oriented programming** (**OOP**). We'll be putting everything
    we've learned so far into these topics, preparing for our first real dive into
    understanding and controlling objects in the Unity engine.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将完成C#编程的基础知识，介绍类、结构体和**面向对象编程**（**OOP**）。我们将把迄今为止学到的所有内容都应用到这些主题中，为我们第一次真正深入理解和控制Unity引擎中的对象做准备。
- en: JOIN us on Discord!
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流，以及更多。
- en: Join Now!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
