- en: Chapter 3. Data Structures and Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。数据结构和操作
- en: 'Most of the time that you spend in programming, you do something to manipulate
    data. You process properties of data, derive conclusions based on the data, and
    change the nature of the data. In this chapter, we will take an exhaustive look
    at various data structures and data manipulation techniques in JavaScript. With
    the correct usage of these expressive constructs, your programs will be correct,
    concise, easy to read, and most probably faster. This will be explained with the
    help of the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，大部分时间都是在处理数据。你处理数据的属性，根据数据得出结论，并改变数据的性质。在本章中，我们将详细介绍JavaScript中各种数据结构和数据操作技术。通过正确使用这些表达性构造，你的程序将是正确的、简洁的、易于阅读的，而且很可能更快。这将在以下主题的帮助下加以解释：
- en: Regular expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Exact match
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确匹配
- en: Match from a class of characters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一类字符中匹配
- en: Repeated occurrences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复出现
- en: Beginning and end
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和结束
- en: Backreferences
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向引用
- en: Greedy and lazy quantifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪和懒惰的量词
- en: Arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Maps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Sets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: A matter of style
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格问题
- en: Regular expressions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: If you are not familiar with regular expressions, I request you to spend time
    learning them. Learning and using regular expressions effectively is one of the
    most rewarding skills that you will gain. During most of the code review sessions,
    the first thing that I comment on is how a piece of code can be converted to a
    single line of **regular expression** (or **RegEx**). If you study popular JavaScript
    libraries, you will be surprised to see how ubiquitous RegEx are. Most seasoned
    engineers rely on RegEx primarily because once you know how to use them, they
    are concise and easy to test. However, learning RegEx will take a significant
    amount of effort and time. A regular expression is a way to express a pattern
    to match strings of text. The expression itself consists of terms and operators
    that allow us to define these patterns. We'll see what these terms and operators
    consist of shortly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉正则表达式，我建议你花时间学习它们。学习并有效地使用正则表达式是你将获得的最有价值的技能之一。在大部分的代码审查会议中，我首先评论的是如何将一段代码转换为一行**正则表达式**（或**RegEx**）。如果你研究流行的JavaScript库，你会惊讶地发现正则表达式是多么普遍。大多数经验丰富的工程师主要依赖于正则表达式，因为一旦你知道如何使用它们，它们就是简洁易测的。然而，学习正则表达式需要大量的努力和时间。正则表达式是一种表达匹配文本字符串的模式的方式。表达式本身由术语和操作符组成，允许我们定义这些模式。我们很快就会看到这些术语和操作符的组成。
- en: 'In JavaScript, there are two ways to create a regular expression: via a regular
    expression literal and constructing an instance of a `RegExp` object.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有两种创建正则表达式的方式：通过正则表达式字面量和构造`RegExp`对象的实例。
- en: 'For example, if we wanted to create a RegEx that matches the string test exactly,
    we could use the following RegEx literal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要创建一个正则表达式，精确匹配字符串test，我们可以使用以下正则表达式字面量：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'RegEx literals are delimited using forward slashes. Alternatively, we could
    construct a `RegExp` instance, passing the RegEx as a string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式字面量使用斜杠进行分隔。或者，我们可以构造一个`RegExp`实例，将正则表达式作为字符串传递：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both of these formats result in the same RegEx being created in the variable
    pattern. In addition to the expression itself, there are three flags that can
    be associated with a RegEx:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种格式都会得到相同的正则表达式被创建在变量模式中。除了表达式本身，还有三个标志可以与正则表达式关联：
- en: '`i`: This makes the RegEx case-insensitive, so `/test/i` matches not only `test`,
    but also `Test`, `TEST`, `tEsT`, and so on.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：这使得正则表达式不区分大小写，所以`/test/i`不仅匹配`test`，还匹配`Test`、`TEST`、`tEsT`等。'
- en: '`g`: This matches all the instances of the pattern as opposed to the default
    of local, which matches the first occurrence only. More on this later.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：这匹配模式的所有实例，而不是默认的局部匹配，后者只匹配第一次出现。稍后会详细介绍。'
- en: '`m`: This allows matches across multiple lines that might be obtained from
    the value of a `textarea` element.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：这允许跨多行匹配，可能是从`textarea`元素的值中获得的。'
- en: These flags are appended to the end of the literal (for example, `/test/ig`)
    or passed in a string as the second parameter to the `RegExp` constructor (`new
    RegExp("test", "ig")`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志被附加到字面量的末尾（例如，`/test/ig`）或作为第二个参数传递给`RegExp`构造函数的字符串（`new RegExp("test",
    "ig")`）。
- en: 'The following example illustrates the various flags and how they affect the
    pattern match:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了各种标志以及它们对模式匹配的影响：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It isn't very exciting if we can just test whether the pattern matches a string.
    Let's see how we can express more complex patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只能测试模式是否与字符串匹配，那就不太令人兴奋。让我们看看如何表达更复杂的模式。
- en: Exact match
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确匹配
- en: 'Any sequence of characters that''s not a special RegEx character or operator
    represents a character literal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是特殊正则表达式字符或操作符的字符序列都代表一个字符字面量：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We mean `o` followed by `r` followed by `a` followed by `n` followed by …—you
    get the point. We rarely use exact match when using RegEx because that is the
    same as comparing two strings. Exact match patterns are sometimes called simple
    patterns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意思是`o`后跟`r`后跟`a`后跟`n`后跟…—你懂的。我们很少在使用正则表达式时使用精确匹配，因为那就相当于比较两个字符串。精确匹配模式有时被称为简单模式。
- en: Match from a class of characters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一类字符中匹配
- en: 'If you want to match against a set of characters, you can place the set inside
    `[]`. For example, `[abc]` would mean any character `a`, `b`, or `c`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想匹配一组字符，你可以将该组放在`[]`中。例如，`[abc]`表示任何字符`a`、`b`或`c`：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can specify that you want to match anything but the pattern by adding a
    `^` (caret sign) at the beginning of the pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在模式的开头添加`^`（插入符号）来指定你想匹配除了该模式之外的任何东西：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One critical variation of this pattern is a range of values. If we want to
    match against a sequential range of characters or numbers, we can use the following
    pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个关键变化是数值范围。如果我们想匹配一系列顺序的字符或数字，我们可以使用以下模式：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Special characters such as `$` and period (`.`) characters either represent
    matches to something other than themselves or operators that qualify the preceding
    term. In fact, we've already seen how `[`, `]`, `-`, and `^` characters are used
    to represent something other than their literal values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符，如`$`和句点（`.`）字符，要么表示与它们自身不同的东西的匹配，要么表示限定前面项的运算符。事实上，我们已经看到了`[`、`]`、`-`和`^`字符是如何用来表示与它们的文字值不同的东西的。
- en: How do we specify that we want to match a literal `[` or `$` or `^` or some
    other special character? Within a RegEx, the backslash character escapes whatever
    character follows it, making it a literal match term. So `\[` specifies a literal
    match to the `[` character rather than the opening of a character class expression.
    A double backslash (`\\`) matches a single backslash.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何指定我们想匹配文字`[`或`$`或`^`或其他一些特殊字符？在正则表达式中，反斜杠字符转义其后的任何字符，使其成为文字匹配项。因此，`\[`指定了与`[`字符的文字匹配，而不是字符类表达式的开头。双反斜杠（`\\`）匹配单个反斜杠。
- en: In the preceding examples, we saw the `test()` method that returns **true**
    or **false** based on the pattern matched. There are times when you want to access
    occurrences of a particular pattern. The `exec()` method comes in handy in such
    situations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了`test()`方法，根据匹配的模式返回**true**或**false**。有时候你想要访问特定模式的出现次数。在这种情况下，`exec()`方法非常方便。
- en: 'The `exec()` method takes a string as an argument and returns an array containing
    all matches. Consider the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`方法接受一个字符串作为参数，并返回一个包含所有匹配项的数组。考虑下面的例子：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return all the occurrences of the word `oyo` from the original text.
    The String object contains the `match()` method that has similar functionality
    of the `exec()` method. The `match()` method is called on a String object and
    the RegEx is passed to it as a parameter. Consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回原始文本中单词`oyo`的所有出现。String对象包含`match()`方法，它具有与`exec()`方法类似的功能。`match()`方法在String对象上调用，正则表达式作为参数传递给它。考虑下面的例子：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are calling the `match()` method on the String object. We
    pass the RegEx as a parameter to the `match()` method. The results are the same
    in both these cases.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在String对象上调用`match()`方法。我们将正则表达式作为参数传递给`match()`方法。在这两种情况下结果是一样的。
- en: 'The other String object method is `replace()`. It replaces all the occurrences
    of a substring with a different string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个String对象方法是`replace()`。它用不同的字符串替换所有子字符串的出现：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is possible to pass a function as a second parameter of the `replace()`
    method. The `replace()` function takes the matching text as a parameter and returns
    the text that is used as a replacement:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将函数作为`replace()`方法的第二个参数。`replace()`函数将匹配的文本作为参数，并返回用作替换的文本：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The String object''s `split()` method also takes a RegEx parameter and returns
    an array containing all the substrings generated after splitting the original
    string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: String对象的`split()`方法也接受一个正则表达式参数，并返回一个包含在分割原始字符串后生成的所有子字符串的数组：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need to add a backslash before the comma because a comma is treated specially
    in RegEx and we need to escape it if we want to use it literally.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在逗号前面加上反斜杠，因为逗号在正则表达式中被特殊对待，如果我们想要使用它，就需要转义它。
- en: 'Using simple character classes, you can match multiple patterns. For example,
    if you want to match `cat`, `bat`, and `fat`, the following snippet shows you
    how to use simple character classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的字符类，你可以匹配多个模式。例如，如果你想匹配`cat`、`bat`和`fat`，下面的代码片段展示了如何使用简单的字符类：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, this variation opens up possibilities to write concise RegEx
    patterns. Take the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种变化为编写简洁的正则表达式模式打开了可能性。看下面的例子：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, we are matching the numeric part of the matching string with
    a range `[0-5]`, hence we get a match from `i0` to `i5`. You can also use the
    negation class `^` to filter the rest of the matches:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在匹配匹配字符串的数字部分，范围为`[0-5]`，因此我们从`i0`到`i5`得到了一个匹配。你也可以使用否定类`^`来过滤其余的匹配项：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Observe how we are negating only the range clause and not the entire expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只否定了范围子句，而没有否定整个表达式。
- en: 'Several character groups have shortcut notations. For example, the shortcut
    `\d` means the same thing as `[0-9]`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 几个字符组有快捷方式表示。例如，快捷方式`\d`的意思与`[0-9]`相同：
- en: '| Notation | Meaning |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 意义 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\d` | Any digit character |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任何数字字符 |'
- en: '| `\w` | An alphanumeric character (word character) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 字母数字字符（单词字符） |'
- en: '| `\s` | Any whitespace character (space, tab, newline, and similar) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 任何空白字符（空格、制表符、换行符等） |'
- en: '| `\D` | A character that is not a digit |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 非数字字符 |'
- en: '| `\W` | A non-alphanumeric character |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 非字母数字字符 |'
- en: '| `\S` | A non-whitespace character |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 |'
- en: '| `.` | Any character except for newline |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除换行符外的任何字符 |'
- en: 'These shortcuts are valuable in writing concise RegEx. Consider this example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快捷方式在编写简洁的正则表达式中非常有价值。考虑这个例子：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This expression definitely looks a bit strange. We can replace `[0-9]` with
    `\d` and make this a bit more readable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式看起来确实有点奇怪。我们可以用`\d`替换`[0-9]`，使其更易读：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, you will soon see that there are even better ways to do something like
    this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很快你会发现有更好的方法来做类似的事情。
- en: Repeated occurrences
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复出现
- en: So far, we saw how we can match fixed characters or numeric patterns. Most often,
    you want to handle certain repetitive natures of patterns also. For example, if
    I want to match 4 `a`s, I can write `/aaaa/`, but what if I want to specify a
    pattern that can match any number of `a`s?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何匹配固定字符或数字模式。大多数情况下，你想要处理某些重复的模式特性。例如，如果我想匹配4个`a`，我可以写`/aaaa/`，但是如果我想指定一个可以匹配任意数量的`a`的模式呢？
- en: 'Regular expressions provide you with a wide variety of repetition quantifiers.
    Repetition quantifiers let us specify how many times a particular pattern can
    occur. We can specify fixed values (characters should appear *n* times) and variable
    values (characters can appear at least *n* times till they appear *m* times).
    The following table lists the various repetition quantifiers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式为您提供了各种重复量词。重复量词让我们指定特定模式可以出现多少次。我们可以指定固定值（字符应该出现*n*次）和可变值（字符可以至少出现*n*次，直到它们出现*m*次）。以下表列出了各种重复量词：
- en: '`?`: Either 0 or 1 occurrence (marks the occurrence as optional)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：0次或1次出现（标记出现为可选）'
- en: '`*`: 0 or more occurrences'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：0次或多次出现'
- en: '`+`: 1 or more occurrences'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：1次或多次出现'
- en: '`{n}`: Exactly `n` occurrences'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n}`：恰好`n`次出现'
- en: '`{n,m}`: Occurrences between `n` and `m`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,m}`：`n`和`m`之间的出现次数'
- en: '`{n,}`: At least an `n` occurrence'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{n,}`：至少出现`n`次'
- en: '`{,n}`: 0 to `n` occurrences'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{,n}`：0到`n`次出现'
- en: 'In the following example, we create a pattern where the character `u` is optional
    (has 0 or 1 occurrence):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们创建了一个模式，其中字符`u`是可选的（出现0次或1次）：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It helps to read the `/behaviou?r/` expression as 0 or 1 occurrences of character
    `u`. The repetition quantifier succeeds the character that we want to repeat.
    Let''s try out some more examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`/behaviou?r/`表达式时，将其解释为字符`u`的0次或1次出现。重复量词成功地重复了我们想要重复的字符。让我们尝试一些更多的例子：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should read and interpret the `\d+` expression as `'` is a literal character
    match, `\d` matches characters `[0-9]`, the `+` quantifier will allow one or more
    occurrences, and `'` is a literal character match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将`\d+`表达式解释为`'`是文字字符匹配，`\d`匹配字符`[0-9]`，`+`量词将允许一个或多个出现，`'`是文字字符匹配。
- en: 'You can also group character expressions using `()`. Observe the following
    example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`()`对字符表达式进行分组。观察以下例子：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break the preceding expression into smaller chunks to understand what
    is going on in here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的表达式分解成较小的块，以了解其中发生了什么：
- en: '`H`: literal character match'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：文字字符匹配'
- en: '`a+`: 1 or more occurrences of character `a`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：字符`a`的1次或多次出现'
- en: '`(`: start of the expression group'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`（`：表达式组开始'
- en: '`H`: literal character match'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`：文字字符匹配'
- en: '`a+`: 1 or more occurrences of character `a`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：字符`a`的1次或多次出现'
- en: '`)`: end of expression group'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ）：表达式组结束
- en: '`+`: 1 or more occurrences of expression group (`Ha+`)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：表达式组（`Ha+`）的1次或多次出现'
- en: Now it is easier to see how the grouping is done. If we have to interpret the
    expression, it is sometimes helpful to read out the expression, as shown in the
    preceding example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易看到分组是如何完成的。如果我们必须解释表达式，有时将表达式读出来是有帮助的，就像前面的例子所示的那样。
- en: Often, you want to match a sequence of letters or numbers on their own and not
    just as a substring. This is a fairly common use case when you are matching words
    that are not just part of any other words. We can specify the word boundaries
    by using the `\b` pattern. The word boundary with `\b` matches the position where
    one side is a word character (letter, digit, or underscore) and the other side
    is not. Consider the following examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您希望匹配一系列字母或数字，而不仅仅是作为子字符串。当您匹配不仅仅是其他单词的一部分时，这是一个相当常见的用例。我们可以使用`\b`模式指定单词边界。带有`\b`的单词边界匹配一个边界，其中一侧是一个单词字符（字母、数字或下划线），另一侧不是。考虑以下例子。
- en: 'The following is a simple literal match. This match will also be successful
    if `cat` is part of a substring:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的文字匹配。如果`cat`是子字符串的一部分，这个匹配也将成功：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, in the following example, we define a word boundary by indicating
    `\b` before the word `cat`—this means that we want to match only if `cat` is a
    word and not a substring. The boundary is established before `cat`, and hence
    a match is found on the text, `a black cat`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下面的例子中，我们通过在单词`cat`之前指示`\b`来定义一个词边界——这意味着我们只想匹配`cat`是一个单词而不是一个子字符串。边界在`cat`之前建立，因此在文本`a
    black cat`中找到了一个匹配：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we use the same boundary with the word `tomcat`, we get a failed match
    because there is no word boundary before `cat` in the word `tomcat`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在单词`tomcat`中使用相同的边界时，我们得到了一个失败的匹配，因为在单词`tomcat`中`cat`之前没有单词边界：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is a word boundary after the string `cat` in the word `tomcat`, hence
    the following is a successful match:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词“tomcat”中的字符串`cat`后有一个词边界，因此以下是一个成功的匹配：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following example, we define the word boundary before and after the
    word `cat` to indicate that we want `cat` to be a standalone word with boundaries
    before and after:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们在单词`cat`之前和之后定义了单词边界，以指示我们希望`cat`是一个独立的单词，并在之前和之后有边界：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Based on the same logic, the following match fails because there are no boundaries
    before and after `cat` in the word `concatenate`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相同的逻辑，以下匹配失败，因为在单词“concatenate”中在`cat`之前和之后没有边界：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `exec()` method is useful in getting information about the match found
    because it returns an object with information about the match. The object returned
    from `exec()` has an `index` property that tells us where the successful match
    begins in the string. This is useful in many ways:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`方法在获取有关找到的匹配的信息方面很有用，因为它返回一个包含有关匹配信息的对象。从`exec()`返回的对象具有一个`index`属性，告诉我们成功匹配在字符串中的开始位置。这在许多方面都很有用：'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alternatives – OR
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代 - 或
- en: Alternatives can be expressed using the `|` (pipe) character. For example, `/a|b/`
    matches either the `a` or `b` character, and `/(ab)+|(cd)+/` matches one or more
    occurrences of either `ab` or `cd`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`|`（管道）字符来表示替代。例如，`/a|b/`匹配`a`或`b`字符，`/(ab)+|(cd)+/`匹配一个或多个`ab`或`cd`的出现。
- en: Beginning and end
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束
- en: 'Frequently, we may wish to ensure that a pattern matches at the beginning of
    a string or perhaps at the end of a string. The caret character, when used as
    the first character of the RegEx, anchors the match at the beginning of the string
    such that `/^test/` matches only if the test substring appears at the beginning
    of the string being matched. Similarly, the dollar sign (`$`) signifies that the
    pattern must appear at the end of the string: `/test$/`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能希望确保模式与字符串的开头或结尾匹配。当插入符号作为RegEx的第一个字符使用时，它会将匹配锚定在字符串的开头，因此`/^test/`只有在测试子字符串出现在被匹配字符串的开头时才匹配。同样，美元符号（`$`）表示模式必须出现在字符串的末尾：`/test$/`。
- en: 'Using both `^` and `$` indicates that the specified pattern must encompass
    the entire candidate string: `/^test$/`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用`^`和`$`表示指定的模式必须包含整个候选字符串：`/^test$/`。
- en: Backreferences
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向引用
- en: After an expression is evaluated, each group is stored for later use. These
    values are known as backreferences. Backreferences are created and numbered by
    the order in which opening parenthesis characters are encountered going from left
    to right. You can think of backreferences as the portions of a string that are
    successfully matched against terms in the regular expression.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式被评估后，每个组都被存储以供以后使用。这些值被称为反向引用。反向引用是按照从左到右遇到的开括号字符的顺序创建和编号的。您可以将反向引用视为成功匹配正则表达式中的术语的字符串部分。
- en: The notation for a backreference is a backslash followed by the number of the
    capture to be referenced, beginning with 1, such as `\1`, `\2`, and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 反向引用的表示方法是反斜杠后跟要引用的捕获的编号，从1开始，例如`\1`、`\2`等。
- en: 'An example could be `/^([XYZ])a\1/`, which matches a string that starts with
    any of the `X`, `Y`, or `Z` characters followed by an `a` and followed by whatever
    character matched the first capture. This is very different from `/[XYZ] a[XYZ]/`.
    The character following `a` can''t be any of `X`, or `Y`, or `Z`, but must be
    whichever one of those that triggered the match for the first character. Backreferences
    are used with String''s `replace()` method using the special character sequences,
    `$1`, `$2`, and so on. Suppose that you want to change the `1234 5678` string
    to `5678 1234`. The following code accomplishes this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`/^([XYZ])a\1/`，它匹配以`X`、`Y`或`Z`中的任何一个字符开头，后跟一个`a`，然后跟着与第一个捕获匹配的任何字符。这与`/[XYZ]
    a[XYZ]/`非常不同。跟在`a`后面的字符不能是`X`、`Y`或`Z`中的任何一个，而必须是触发第一个字符匹配的那些字符之一。反向引用与String的`replace()`方法一起使用，使用特殊字符序列`$1`、`$2`等。假设您想将`1234
    5678`字符串更改为`5678 1234`。以下代码可以实现这一点：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, the regular expression has two groups each with four digits.
    In the second argument of the `replace()` method, `$2` is equal to `5678` and
    `$1` is equal to `1234`, corresponding to the order in which they appear in the
    expression.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，正则表达式有两个组，每个组有四个数字。在`replace()`方法的第二个参数中，`$2`等于`5678`，`$1`等于`1234`，与它们在表达式中出现的顺序相对应。
- en: Greedy and lazy quantifiers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪和懒惰量词
- en: All the quantifiers that we discussed so far are greedy. A greedy quantifier
    starts looking at the entire string for a match. If there are no matches, it removes
    the last character in the string and reattempts the match. If a match is not found
    again, the last character is again removed and the process is repeated until a
    match is found or the string is left with no characters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有量词都是贪婪的。贪婪量词开始查找整个字符串以进行匹配。如果没有匹配，它会删除字符串中的最后一个字符并重新尝试匹配。如果再次找不到匹配，最后一个字符将再次被删除，这个过程将重复，直到找到匹配或字符串不再有字符。
- en: The `\d+` pattern, for example, will match one or more digits. For example,
    if your string is `123`, a greedy match would match `1`, `12`, and `123`. Greedy
    pattern `h`.`+l` would match `hell` in a string `hello`—which is the longest possible
    string match. As `\d+` is greedy, it will match as many digits as possible and
    hence the match would be `123`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，模式`\d+`将匹配一个或多个数字。例如，如果您的字符串是`123`，贪婪匹配将匹配`1`、`12`和`123`。贪婪模式`h`.`+l`会在字符串`hello`中匹配`hell`，这是可能的最长字符串匹配。由于`\d+`是贪婪的，它将匹配尽可能多的数字，因此匹配将是`123`。
- en: In contrast to greedy quantifiers, a lazy quantifier matches as few of the quantified
    tokens as possible. You can add a question mark (`?`) to the regular expression
    to make it lazy. A lazy pattern `h.?l` would match `hel` in the string `hello`—which
    is the shortest possible string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与贪婪量词相反，懒惰量词匹配尽可能少的被量化的标记。您可以在正则表达式中添加一个问号（`?`）来使其变成懒惰的。懒惰模式`h.?l`会在字符串`hello`中匹配`hel`，这是可能的最短字符串。
- en: The `\w*?X` pattern will match zero or more words and then match an `X`. However,
    a question mark after `*` indicates that as few characters as possible should
    be matched. For an `abcXXX` string, the match can be `abcX`, `abcXX`, or `abcXXX`.
    Which one should be matched? As `*?` is lazy, as few characters as possible are
    matched and hence the match is `abcX`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`\w*?X`将匹配零个或多个单词，然后匹配一个`X`。但是，在`*`后面加上一个问号表示应该匹配尽可能少的字符。对于一个`abcXXX`字符串，匹配可以是`abcX`、`abcXX`或`abcXXX`。应该匹配哪一个？由于`*?`是懒惰的，因此匹配尽可能少的字符，因此匹配是`abcX`。
- en: With this necessary information, let's try to solve some common problems using
    regular expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些必要的信息，让我们尝试使用正则表达式来解决一些常见问题。
- en: 'Removing extra white space from the beginning and end of a string is a very
    common use case. As a String object did not have the `trim()` method until recently,
    several JavaScript libraries provide and use an implementation of string trimming
    for older browsers that don''t have the `String.trim()` method. The most commonly
    used approach looks something like the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串的开头和结尾删除额外的空格是一个非常常见的用例。由于直到最近，String对象没有`trim()`方法，因此一些JavaScript库为那些没有`String.trim()`方法的旧浏览器提供并使用了字符串修剪的实现。最常用的方法看起来像以下代码：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What if we want to replace repeated whitespaces with a single whitespace?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用单个空格替换重复的空格呢？
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Arrays
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is an ordered set of values. You can refer to the array elements with
    a name and index. These are the three ways to create arrays in JavaScript:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一组有序的值。您可以使用名称和索引引用数组元素。这是 JavaScript 中创建数组的三种方式：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When these values are specified, the array is initialized with them as the array's
    elements. An array's `length` property is equal to the number of arguments. The
    bracket syntax is called an array literal. It's a shorter and preferred way to
    initialize arrays.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 指定这些值时，数组将以它们作为数组元素进行初始化。数组的 `length` 属性等于参数的数量。方括号语法称为数组文字。这是初始化数组的一种更短和更常用的方式。
- en: 'You have to use the array literal syntax if you want to initialize an array
    with a single element and the element happens to be a number. If you pass a single
    number value to the `Array()` constructor or function, JavaScript considers this
    parameter as the length of the array, not as a single element:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用单个元素初始化数组，并且该元素恰好是一个数字，则必须使用数组文字语法。如果将单个数字值传递给 `Array()` 构造函数或函数，则 JavaScript
    将此参数视为数组的长度，而不是单个元素：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: JavaScript does not have an explicit array data type. However, you can use the
    predefined `Array` object and its methods to work with arrays in your applications.
    The `Array` object has methods to manipulate arrays in various ways, such as joining,
    reversing, and sorting them. It has a property to determine the array length and
    other properties for use with regular expressions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有显式的数组数据类型。但是，您可以使用预定义的 `Array` 对象及其方法来处理应用程序中的数组。`Array` 对象具有各种方法来以各种方式操作数组，例如连接、反转和排序它们。它具有用于确定数组长度的属性和其他用于正则表达式的属性。
- en: 'You can populate an array by assigning values to its elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为其元素分配值来填充数组：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also populate an array when you create it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在创建数组时填充数组：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In most languages, the elements of an array are all required to be of the same
    type. JavaScript allows an array to contain any type of values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，数组的元素都必须是相同类型的。JavaScript 允许数组包含任何类型的值：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can refer to elements of an `Array` using the element''s index number.
    For example, suppose you define the following array:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用元素的索引号引用 `Array` 的元素。例如，假设您定义了以下数组：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You then refer to the first element of the array as `colors[0]` and the second
    element of the array as `colors[1]`. The index of the elements starts with `0`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将数组的第一个元素称为 `colors[0]`，将数组的第二个元素称为 `colors[1]`。元素的索引从 `0` 开始。
- en: 'JavaScript internally stores array elements as standard object properties,
    using the array index as the property name. The `length` property is different.
    The `length` property always returns the index of the last element plus one. As
    we discussed, JavaScript array indexes are 0-based: they start at `0`, not `1`.
    This means that the `length` property will be one more than the highest index
    stored in the array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在内部将数组元素存储为标准对象属性，使用数组索引作为属性名。`length` 属性是不同的。`length` 属性始终返回最后一个元素的索引加一。正如我们讨论过的，JavaScript
    数组索引是基于 0 的：它们从 `0` 开始，而不是 `1`。这意味着 `length` 属性将比数组中存储的最高索引多一个：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also assign to the `length` property. Writing a value that is shorter
    than the number of stored items truncates the array; writing `0` empties it entirely:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以分配给 `length` 属性。写入比存储的项目数量短的值会截断数组；写入 `0` 会完全清空它：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you query a non-existent array index, you get `undefined`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询不存在的数组索引，则会得到 `undefined`。
- en: 'A common operation is to iterate over the values of an array, processing each
    one in some way. The simplest way to do this is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的操作是遍历数组的值，以某种方式处理每个值。这样做的最简单方法如下：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `forEach()` method provides another way of iterating over an array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()` 方法提供了另一种遍历数组的方式：'
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function passed to `forEach()` is executed once for every item in the array,
    with the array item passed as the argument to the function. Unassigned values
    are not iterated in a `forEach()` loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `forEach()` 的函数会针对数组中的每个项目执行一次，数组项作为参数传递给函数。未分配的值不会在 `forEach()` 循环中迭代。
- en: The `Array` object has a bunch of useful methods. These methods allow the manipulation
    of the data stored in the array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 对象有一堆有用的方法。这些方法允许操作数组中存储的数据。'
- en: 'The `concat()` method joins two arrays and returns a new array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 方法连接两个数组并返回一个新数组：'
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `join()` method joins all the elements of an array into a string. This
    can be useful while processing a list. The default delimiter is a comma (`,`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法将数组的所有元素连接成一个字符串。在处理列表时，这可能很有用。默认分隔符是逗号（`,`）：'
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `pop()` method removes the last element from an array and returns that
    element. This is analogous to the `pop()` method of a stack:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()` 方法从数组中移除最后一个元素并返回该元素。这类似于栈的 `pop()` 方法：'
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `push()` method adds one or more elements to the end of an array and returns
    the resulting length of the array:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 方法在数组的末尾添加一个或多个元素，并返回数组的新长度：'
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `shift()` method removes the first element from an array and returns that
    element:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift()` 方法从数组中移除第一个元素并返回该元素：'
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `unshift()` method adds one or more elements to the front of an array and
    returns the new length of the array:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshift()` 方法在数组的前面添加一个或多个元素，并返回数组的新长度：'
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `reverse()` method reverses or transposes the elements of an array—the
    first array element becomes the last and the last becomes the first:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()` 方法反转或转置数组的元素——第一个数组元素变为最后一个，最后一个变为第一个：'
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `sort()` method sorts the elements of an array:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法对数组的元素进行排序：'
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `sort()` method can optionally take a callback function to define how the
    elements are compared. The function compares two values and returns one of three
    values. Let us study the following functions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法可以选择接受一个回调函数来定义元素的比较方式。该函数比较两个值并返回三个值中的一个。让我们学习以下函数：'
- en: '`indexOf(searchElement[, fromIndex])`: This searches the array for `searchElement`
    and returns the index of the first match:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(searchElement[, fromIndex])`：这个函数在数组中搜索 `searchElement` 并返回第一个匹配的索引：'
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`lastIndexOf(searchElement[, fromIndex])`: This works like `indexOf()`, but
    only searches backwards:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf(searchElement[, fromIndex])`：这个函数与 `indexOf()` 类似，但是只向后搜索：'
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have covered JavaScript arrays in depth, let me introduce you to
    a fantastic library called **Underscore.js** ([http://underscorejs.org/](http://underscorejs.org/)).
    Underscore.js provides a bunch of exceptionally useful functional programming
    helpers to make your code even more clear and functional.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入了解了 JavaScript 数组，让我向你介绍一个名为 **Underscore.js** 的绝妙库（[http://underscorejs.org/](http://underscorejs.org/)）。Underscore.js
    提供了一堆非常有用的函数式编程助手，使你的代码更加清晰和功能性。
- en: 'We will assume that you are familiar with **Node.js**; in this case, install
    Underscore.js via npm:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你熟悉 **Node.js**；在这种情况下，通过 npm 安装 Underscore.js：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we are installing Underscore as a Node module, we will test all the examples
    by typing them in a `.js` file and running the file on Node.js. You can install
    Underscore using **Bower** also.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将 Underscore 安装为一个 Node 模块，我们将通过在 `.js` 文件中输入所有示例并在 Node.js 上运行文件来测试它们。你也可以使用
    **Bower** 安装 Underscore。
- en: Like jQuery's `$` module, Underscore comes with a `_` module defined. You will
    call all functions using this module reference.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与 jQuery 的 `$` 模块一样，Underscore 也带有一个定义的 `_` 模块。你将使用这个模块引用来调用所有函数。
- en: 'Type the following code in a text file and name it `test_.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本文件中输入以下代码，并将其命名为 `test_.js`：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This can be written as follows, without using `each()` function from underscore
    library:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以写成如下形式，而不使用 underscore 库中的 `each()` 函数：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: What you see here is a powerful functional construct that makes the code much
    more elegant and concise. You can clearly see that the traditional approach is
    verbose. Many languages such as Java suffer from this verbosity. They are slowly
    embracing functional paradigms. As JavaScript programmers, it is important for
    us to incorporate these ideas into our code as much as possible.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是一个功能强大的函数构造，使代码更加优雅和简洁。你可以清楚地看到传统方法很啰嗦。许多语言，比如 Java，都受到这种冗长的影响。它们正在慢慢接受函数式范式。作为
    JavaScript 程序员，我们需要尽可能多地将这些想法融入我们的代码中。
- en: The `each()` function we saw in the preceding example iterates over a list of
    elements, yielding each to an iteratee function in turn. Each invocation of iteratee
    is called with three arguments (element, index, and list). In the preceding example,
    the `each()` function iterates over the array `[1,2,3]`, and for each element
    in the array, the `print` function is called with the array element as the parameter.
    This is a convenient alternative to the traditional looping mechanism to access
    all the elements in an array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`each()` 函数在前面的例子中遍历元素列表，依次将每个元素传递给迭代函数。每次调用迭代函数时都会传递三个参数（元素、索引和列表）。在前面的例子中，`each()`
    函数遍历数组 `[1,2,3]`，并且对数组中的每个元素，都使用数组元素作为参数调用 `print` 函数。这是访问数组中所有元素的传统循环机制的便利替代方法。'
- en: 'The `range()` function creates lists of integers. The start value, if omitted,
    defaults to `0` and step defaults to `1`. If you''d like a negative range, use
    a negative step:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数创建整数列表。如果省略了起始值，则默认为 `0`，步长默认为 `1`。如果你想要一个负范围，可以使用负步长：'
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By default, `range()` populates the array with integers, but with a little
    trick, you can populate other data types also:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`range()` 用整数填充数组，但是通过一点技巧，你也可以填充其他数据类型：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is a fast and convenient way to create and initialize an array with values.
    We frequently do this by traditional loops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种快速方便的方法，用来创建和初始化一个具有值的数组。我们经常通过传统循环来做到这一点。
- en: 'The `map()` function produces a new array of values by mapping each value in
    the list through a transformation function. Consider the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数通过将列表中的每个值映射到一个转换函数来生成一个新的值数组。考虑以下示例：'
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `reduce()` function reduces a list of values to a single value. The initial
    state is passed by the iteratee function and each successive step is returned
    by the iteratee. The following example shows the usage:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 函数将一系列值减少为单个值。初始状态由迭代函数传递，每个连续步骤由迭代函数返回。以下示例展示了用法：'
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, the line, `console.log(memo,num);`, is just to make the idea
    clear. The output will be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`console.log(memo,num);` 这一行只是为了让这个想法更清晰。输出将如下所示：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The final output is a sum of *1+2+3=6*. As you can see, two values are passed
    to the iteratee function. On the first iteration, we call the iteratee function
    with two values `(0,1)`—the value of the `memo` is defaulted in the call to the
    `reduce()` function and `1` is the first element of the list. In the function,
    we sum `memo` and `num` and return the intermediate `sum`, which will be used
    by the `iterate()` function as a `memo` parameter—eventually, the `memo` will
    have the accumulated `sum`. This concept is important to understand how the intermediate
    states are used to calculate eventual results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出是 *1+2+3=6* 的总和。你可以看到，两个值被传递给迭代函数。在第一次迭代中，我们使用两个值 `(0,1)` 调用迭代函数——`memo`
    的值在调用 `reduce()` 函数时被默认设置，`1` 是列表的第一个元素。在函数中，我们对 `memo` 和 `num` 求和，并返回中间的 `sum`，这将被
    `iterate()` 函数用作 `memo` 参数——最终，`memo` 将累积 `sum`。理解中间状态如何用于计算最终结果是很重要的概念。
- en: 'The `filter()` function iterates through the entire list and returns an array
    of all the elements that pass the condition. Take a look at the following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数遍历整个列表，并返回通过条件的所有元素的数组。看下面的例子：'
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `filter()` function's iteratee function should return a truth value. The
    resulting `evens` array contains all the elements that satisfy the truth test.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数的迭代函数应该返回一个真值。结果的 `evens` 数组包含所有满足真值测试的元素。'
- en: 'The opposite of the `filter()` function is `reject()`. As the name suggests,
    it iterates through the list and ignores elements that satisfy the truth test:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数的相反函数是 `reject()`。顾名思义，它遍历列表并忽略满足条件的元素：'
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are using the same code as the previous example but using the `reject()`
    method instead of `filter()`—the result is exactly the opposite.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与前一个例子相同的代码，但使用`reject()`方法而不是`filter()`——结果完全相反。
- en: 'The `contains()` function is a useful little function that returns `true` if
    the value is present in the list; otherwise, returns `false`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains()`函数是一个有用的小函数，如果值存在于列表中则返回`true`；否则返回`false`：'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'One very useful function that I have grown fond of is `invoke()`. It calls
    a specific function on each element in the list. I can''t tell you how many times
    I have used it since I stumbled upon it. Let us study the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢的一个函数是`invoke()`。它在列表中的每个元素上调用特定的函数。自从我发现它以来，我已经用过它多少次了，我无法告诉你。让我们来学习下面的例子：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this example, the `sort()` method of the `Array` object is called for each
    element in the array. Note that this would fail:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Array`对象的`sort()`方法被用于数组中的每个元素。请注意，这将失败：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is because the `sort` method is not part of the String object. This, however,
    would work perfectly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`sort`方法不是String对象的一部分。不过，下面的代码将完美地工作：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is because `toUpperCase()` is a String object method and all elements of
    the list are of the String type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`toUpperCase()`是String对象的方法，而列表中的所有元素都是String类型。
- en: 'The `uniq()` function returns the array after removing all duplicates from
    the original one:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq()`函数返回删除了原始数组中所有重复项后的数组：'
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `partition()` function splits the array into two; one whose elements satisfy
    the predicate and the other whose elements don''t satisfy the predicate:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()`函数将数组分成两部分；一个是满足谓词的元素，另一个是不满足谓词的元素：'
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `without()` function returns a copy of the array with all instances of
    the specific values removed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`without()`函数返回删除了所有特定值实例的数组副本：'
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Maps
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Sets
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: ECMAScript 6 introduces sets. Sets are collections of values and can be iterated
    in the order of the insertion of their elements. An important characteristic about
    sets is that a value can occur only once in a set.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6引入了集合。集合是值的集合，并且可以按照它们的元素插入顺序进行迭代。关于集合的一个重要特点是，集合中的值只能出现一次。
- en: 'The following snippet shows some basic operations on sets:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了集合的一些基本操作：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We discussed briefly that JavaScript arrays are not really arrays in a traditional
    sense. In JavaScript, arrays are objects that have the following characteristics:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了JavaScript数组实际上并不是传统意义上的数组。在JavaScript中，数组是具有以下特征的对象：
- en: The `length` property
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`属性'
- en: The functions that inherit from `Array.prototype` (we will discuss this in the
    next chapter)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Array.prototype`继承的函数（我们将在下一章讨论）
- en: Special handling for keys that are numeric keys
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字键的特殊处理
- en: 'When we write an array index as numbers, they get converted to strings—`arr[0]`
    internally becomes `arr["0"]`. Due to this, there are a few things that we need
    to be aware of when we use JavaScript arrays:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将数组索引写为数字时，它们会转换为字符串——`arr[0]`在内部变成了`arr["0"]`。由于这个原因，当我们使用JavaScript数组时，有一些事情需要注意：
- en: Accessing array elements by an index is not a constant time operation as it
    is in, say, C. As arrays are actually key-value maps, the access will depend on
    the layout of the map and other factors (collisions and others).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引访问数组元素不是一个常数时间操作，就像在C语言中一样。因为数组实际上是键值映射，访问将取决于映射的布局和其他因素（碰撞等）。
- en: 'JavaScript arrays are sparse (most of the elements have the default value),
    which means that the array can have gaps in it. To understand this, look at the
    following snippet:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript数组是稀疏的（大多数元素具有默认值），这意味着数组中可能存在间隙。要理解这一点，请看下面的代码片段：
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You will see the output as `[undefined, undefined, undefined]`—`undefined` is
    the default value stored on the array element.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到输出为`[undefined, undefined, undefined]`——`undefined`是存储在数组元素上的默认值。
- en: 'Consider the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的例子：
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can see that there are gaps in this array. Only two elements have elements
    and the rest are gaps with the default value. Knowing this helps you in a couple
    of things. Using the `for...in` loop to iterate an array can result in unexpected
    results. Consider the following example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这个数组中存在间隙。只有两个元素有元素，其余的都是默认值的间隙。了解这一点有助于您做一些事情。使用`for...in`循环来迭代数组可能会导致意想不到的结果。考虑下面的例子：
- en: '[PRE76]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A matter of style
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格问题
- en: Like the previous chapters, we will spend some time discussing the style considerations
    while creating arrays.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 和前几章一样，我们将花一些时间讨论创建数组时的风格考虑。
- en: 'Use the literal syntax for array creation:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字面语法创建数组：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use `Array#push` instead of a direct assignment to add items to an array:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Array#push`而不是直接赋值来向数组添加项目：
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As JavaScript matures as a language, its tool chain also becomes more robust
    and effective. It is rare to see seasoned programmers staying away from libraries
    such as Underscore.js. As we see more advanced topics, we will continue to explore
    more such versatile libraries that can make your code compact, more readable,
    and performant. We looked at regular expressions—they are first-class objects
    in JavaScript. Once you start understanding `RegExp`, you will soon find yourself
    using more of them to make your code concise. In the next chapter, we will look
    at JavaScript Object notation and how JavaScript prototypal inheritance is a new
    way of looking at object-oriented programming.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript作为一种语言的成熟，它的工具链也变得更加健壮和有效。很少见到经验丰富的程序员远离Underscore.js等库。随着我们看到更多高级主题，我们将继续探索更多这样多才多艺的库，可以使您的代码更紧凑、更可读和更高效。我们看了正则表达式——它们在JavaScript中是一流对象。一旦您开始理解`RegExp`，您很快会发现自己使用更多的正则表达式来使您的代码简洁。在下一章中，我们将看一下JavaScript对象表示法，以及JavaScript原型继承是一种看待面向对象编程的新方式。
