- en: Chapter 5. Extracting Data Physically from Android Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。从Android设备物理提取数据
- en: 'This chapter will be covering physical data extraction using free and open
    source tools wherever possible. The majority of the material covered in this chapter
    will use the ADB methods previously discussed in this book. By the end of this
    chapter, the reader should be familiar with the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将尽可能使用免费和开源工具来进行物理数据提取。本章涵盖的大部分内容将使用本书中先前讨论过的ADB方法。在本章结束时，读者应该熟悉以下概念：
- en: What physical extraction means
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理提取意味着什么
- en: What data to expect from physical extractions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从物理提取中期望什么数据
- en: Physical data extractions using the `dd` and `nanddump` commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dd`和`nanddump`命令进行物理数据提取
- en: RAM imaging and analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM镜像和分析
- en: SD card acquisitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SD卡获取
- en: JTAG and chip-off methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JTAG和芯片脱落方法
- en: Physical extraction overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理提取概述
- en: In digital forensics, a physical extraction is an exact bit-for-bit image of
    the electronic media, and this definition remains true for mobile devices too.
    In traditional computer forensics, this typically involves removing the evidence
    drive from the suspect's computer and imaging it via a write blocker without ever
    booting the drive, resulting in an image file containing an exact copy of the
    suspect's drive. The output is frequently referred to as a **raw image**, or simply
    a **bin** (binary) file. Physical extractions differ from logical, in that, they
    are an exact copy of the device's memory, and include unallocated space, file
    slack, volume slack, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字取证中，物理提取是电子媒体的精确比特对比图像，对于移动设备也是如此。在传统的计算机取证中，这通常涉及从嫌疑人的计算机中取出证据驱动器，并通过写入阻断器对其进行镜像，而无需启动驱动器，从而生成包含嫌疑人驱动器的精确副本的图像文件。输出通常被称为原始图像，或简称为bin（二进制）文件。物理提取与逻辑提取不同，它们是设备内存的精确副本，并包括未分配的空间、文件松弛、卷松弛等。
- en: In mobile forensics, the result is the same; an exact bit-for-bit image of the
    device, but the methods are somewhat different. For example, removing the flash
    memory from the device to image can be both time-consuming and expensive, and
    requires a lot of specialized knowledge (though it can be done as discussed in
    the chip-off section later in the chapter). Furthermore, short of using advanced
    **Joint Test Action Group** (**JTAG**) or chip-off methods, the device must be
    booted to some degree (and written to in many cases) in order to access the data.
    Finally, finding a tool that can even parse the final image file can be very difficult.
    Hard drive images and file systems have long been documented and studied, while
    mobile images and file systems change frequently; in some cases mobile file systems
    are even unique to a specific manufacturer. Knowing what to do with the image
    after it is acquired can be just as challenging as acquiring the image in the
    first place!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动取证中，结果是相同的；设备的精确比特对比图像，但方法有所不同。例如，从设备中移除闪存存储器进行镜像既耗时又昂贵，并且需要大量专业知识（尽管后面章节中讨论的芯片脱落方法可以实现）。此外，除了使用高级的JTAG或芯片脱落方法，设备必须在某种程度上引导（在许多情况下还必须写入）才能访问数据。最后，找到甚至可以解析最终图像文件的工具可能非常困难。硬盘镜像和文件系统长期以来一直被记录和研究，而移动镜像和文件系统经常发生变化；在某些情况下，移动文件系统甚至是特定制造商独有的。知道在获取图像后该如何处理图像可能与首次获取图像一样具有挑战性！
- en: Many of the techniques discussed in [Chapter 4](part0031.xhtml "Chapter 4. Extracting
    Data Logically from Android Devices"), *Extracting Data Logically from Android
    Devices*, will still apply here. Booting into a custom recovery is still the most
    forensically sound process; physically acquiring a live device should be avoided
    if at all possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在第4章中讨论的技术，即《从Android设备逻辑提取数据》，在这里仍然适用。引导到自定义恢复仍然是最具法医学意义的过程；尽量避免物理获取活动设备。
- en: What data can be acquired physically?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以从物理上获取哪些数据？
- en: 'The short answer is: *everything*. As a physical acquisition is an exact image
    of the device, every bit of data on the device is in the image file. As mentioned
    previously, with a physical extraction, an examiner is usually only limited by
    their ability to find the relevant data. Generally, this is due to a lack of good
    image analysis tools in the mobile forensics space. To further compound the matter,
    applications have been known to encode or otherwise obfuscate user data, so simply
    browsing through the image in a hex editor will frequently miss valuable evidence.
    This chapter will show various methods to mount or otherwise view the filesystem
    of a physical extraction, while [Chapter 7](part0053.xhtml "Chapter 7. Forensic
    Analysis of Android Applications"), *Forensic Analysis of Android Applications*,
    will focus on analyzing data from specific applications.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是：一切。由于物理获取是设备的精确图像，因此图像文件中包含设备上的所有数据。如前所述，通过物理提取，取证人通常只受其查找相关数据的能力所限制。一般来说，这是由于移动取证领域缺乏良好的图像分析工具。更进一步，应用程序已知会对用户数据进行编码或其他混淆，因此仅通过在十六进制编辑器中浏览图像将经常错过有价值的证据。本章将展示各种方法来挂载或以其他方式查看物理提取的文件系统，而第7章《Android应用程序的取证分析》将专注于分析特定应用程序的数据。
- en: Root access
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Root访问
- en: Once again, just as in logical extractions, root access is going to be a critically
    important aspect of physical extractions. To manually image a device, we are going
    to have to execute commands on the device from the ADB shell, and these will require
    root permissions. If root access cannot be obtained, the SD card can generally
    still be imaged. The only recourse beyond that is JTAG or chip-off methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与逻辑提取一样，Root访问对于物理提取来说也是至关重要的。要手动对设备进行镜像，我们需要在设备上执行ADB shell中的命令，这将需要Root权限。如果无法获得Root访问权限，通常仍然可以对SD卡进行镜像。除此之外，还有JTAG或芯片脱落方法。
- en: Extracting data physically with dd
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dd物理提取数据
- en: The `dd` command should be familiar to any examiner who has done traditional
    hard drive forensics. The `dd` command is a Linux command-line utility used by
    definition to convert and copy files, but is frequently used in forensics to create
    bit-by-bit images of entire drives. Many variations of the `dd` commands also
    exist and are commonly used, such as `dcfldd`, `dc3dd`, `ddrescue`, and `dd_rescue`.
    As the `dd` command is built for Linux-based systems, it is frequently included
    on Android platforms. This means that a method for creating an image of the device
    often already exists on the device!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令对于任何已经进行过传统硬盘取证的检查员来说应该是很熟悉的。`dd`命令是一个Linux命令行实用程序，用于转换和复制文件，但在取证中经常用于创建整个驱动器的逐位图像。还存在许多`dd`命令的变体，通常也经常使用，如`dcfldd`、`dc3dd`、`ddrescue`和`dd_rescue`。由于`dd`命令是为基于Linux的系统构建的，因此它经常包含在Android平台中。这意味着在设备上通常已经存在创建图像的方法！'
- en: 'The `dd` command has many options that can be set, of which only forensically
    important options are listed here. The format of the `dd` command is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令有许多可以设置的选项，这里只列出了具有法医学重要性的选项。`dd`命令的格式如下：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`if`: This option specifies the path of the input file to read from.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`：此选项指定要从中读取的输入文件的路径。'
- en: '`of`: This option specifies the path of the output file to write to.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of`：此选项指定要写入的输出文件的路径。'
- en: '`bs`: This option specifies the block size. Data is read and written in the
    size of the block specified, defaults to 512 bytes if not specified.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bs`：此选项指定块大小。数据以指定块的大小读取和写入，默认情况下为512字节。'
- en: '`conv`: This option specifies the conversion options as its attributes:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conv`：此选项指定其属性作为转换选项：'
- en: '`notrunc`: This option does not truncate the output file.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notrunc`：此选项不会截断输出文件。'
- en: '`noerror`: This option continues imaging if an error is encountered.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noerror`：如果遇到错误，此选项将继续成像。'
- en: '`sync`: In conjunction with the `noerror` option, this option writes `\x00`
    for blocks with an error. This is important for maintaining file offsets within
    the image.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`：与`noerror`选项一起，此选项为出现错误的块写入`\x00`。这对于在图像内保持文件偏移很重要。'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not mix up the `if` and `of` flags, this could result in overwriting the
    target device!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆`if`和`of`标志，否则可能会覆盖目标设备！
- en: A full list of command options can be found at [http://man7.org/linux/man-pages/man1/dd.1.html](http://man7.org/linux/man-pages/man1/dd.1.html).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://man7.org/linux/man-pages/man1/dd.1.html](http://man7.org/linux/man-pages/man1/dd.1.html)找到命令选项的完整列表。
- en: 'Note that there is an important correlation between the block size and the
    `noerror` and `sync` flags: if an error is encountered, `\x00` will be written
    for the entire block that was read (as determined by the block size). Thus, smaller
    block sizes result in less data being missed in the event of an error. The downside
    is that, typically, smaller block sizes result in a slower transfer rate. An examiner
    will have to decide whether a timely or more accurate acquisition is preferred.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意块大小与`noerror`和`sync`标志之间的重要关联：如果出现错误，将为整个读取的块（由块大小确定）写入`\x00`。因此，较小的块大小会导致在出现错误时丢失的数据较少。缺点是，通常情况下，较小的块大小会导致传输速率较慢。检查员将不得不决定是更喜欢及时还是更准确的获取。
- en: As discussed in the previous chapter, booting into recovery mode for the imaging
    process is the most forensically sound method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中讨论过，进入恢复模式进行成像过程是最具法医学意义的方法。
- en: Determining what to image
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定要成像的内容
- en: 'When imaging a computer, an examiner must first find what the drive is mounted
    as; `/dev/sda`, for example. The same is true when imaging an Android device.
    The first step is to launch the ADB shell and view the `/proc/partitions` file
    using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在成像计算机时，检查员必须首先找到驱动器的挂载方式；例如`/dev/sda`。在成像Android设备时也是如此。第一步是启动ADB shell，并使用以下命令查看`/proc/partitions`文件：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will show all partitions on the device:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示设备上的所有分区：
- en: '![Determining what to image](img/image00359.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![确定要成像的内容](img/image00359.jpeg)'
- en: In the output shown in the preceding screenshot, `mmcblk0` is the entirety of
    the flash memory on the device. To image the entire flash memory, we could use
    `/dev/blk/mmcblk0` as the input file flag (`if`) for the `dd` command. Everything
    following it, indicated by `p1`- `p29`, is a partition of the flash memory. The
    size is shown in blocks, in this case the block size is 1024 bytes for a total
    internal storage size of approximately 32 GB. To obtain a full image of the device's
    internal memory, we would run the `dd` command with `mmcblk0` as the input file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中显示的输出中，`mmcblk0`是设备上的整个闪存。要成像整个闪存，我们可以使用`/dev/blk/mmcblk0`作为`dd`命令的输入文件标志（`if`）。其后的内容，由`p1`-`p29`表示，是闪存的一个分区。块的大小以块为单位显示，本例中块大小为1024字节，总内部存储大小约为32GB。要获取设备内存的完整图像，我们将使用`mmcblk0`作为输入文件运行`dd`命令。
- en: 'However, we know from previous chapters that most of these partitions are unlikely
    to be forensically interesting; we''re most likely only interested in a few of
    them. To view the corresponding names for each partition, we can look in the device''s
    `by-name` directory. This does *not* exist on every device, and is sometimes in
    a different path, but for this device it is found at `/dev/block/msm_sdcc.1/by-name`.
    By navigating to that directory and running the `ls -al` command, we can see to
    where each block is symbolically linked as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们知道从前几章的内容，大多数这些分区不太可能具有法医学意义；我们可能只对其中的一些感兴趣。要查看每个分区的相应名称，我们可以查看设备的`by-name`目录。这并不是每个设备都有的，有时路径也不同，但对于这个设备，它位于`/dev/block/msm_sdcc.1/by-name`。通过导航到该目录并运行`ls
    -al`命令，我们可以看到每个块符号链接到哪里，如下面的屏幕截图所示：
- en: '![Determining what to image](img/image00360.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![确定要成像的内容](img/image00360.jpeg)'
- en: If our investigation was only interested in the `userdata` partition, we now
    know that it is `mmcblk0p28`, and could use that as the input file to the `dd`
    command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的调查只对`userdata`分区感兴趣，我们现在知道它是`mmcblk0p28`，可以将其用作`dd`命令的输入文件。
- en: If the `by-name` directory does not exist on the device, it may not be possible
    to identify every partition on the device. However, many of them can still be
    found by using the `mount` command within the ADB shell. Note that the following
    screenshot is from a different device that does not contain a `by-name` directory,
    so the data partition is not `mmcblk0p28`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备上不存在`by-name`目录，则可能无法识别设备上的每个分区。但是，仍然可以使用ADB shell中的`mount`命令找到其中许多分区。请注意，以下截图来自不包含`by-name`目录的不同设备，因此数据分区不是`mmcblk0p28`。
- en: '![Determining what to image](img/image00361.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![确定要镜像的内容](img/image00361.jpeg)'
- en: On this device, the data partition is `mmcblk0p34`. If the `mount` command does
    not work, the same information can be found using the `cat /proc/mounts` command.
    Other options to identify partitions depending on the device are the `cat /proc/mtd`
    or `cat /proc/yaffs` commands; these may work on older devices. Newer devices
    may include an `fstab` file in the root directory (typically called `fstab.<device>`)
    that will list mountable partitions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设备上，数据分区是`mmcblk0p34`。如果`mount`命令不起作用，可以使用`cat /proc/mounts`命令找到相同的信息。根据设备的不同，还可以使用`cat
    /proc/mtd`或`cat /proc/yaffs`命令来识别分区；这些命令可能适用于旧设备。更新的设备可能在根目录中包含一个名为`fstab`的文件（通常称为`fstab.<device>`），其中列出了可挂载的分区。
- en: Writing to an SD card
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入SD卡
- en: The output file of the `dd` command can be written to the device's SD card.
    This should only be done if the suspect SD card can be removed and replaced with
    a forensically sterile SD to ensure that the `dd` command's output is not overwriting
    evidence. Obviously, if writing to an SD card, ensure that the SD card is larger
    than the partition being imaged.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令的输出文件可以写入设备的SD卡。只有在可移除嫌疑SD卡并用取证无菌SD卡替换以确保`dd`命令的输出不会覆盖证据时才应执行此操作。显然，如果要写入SD卡，请确保SD卡大于正在镜像的分区。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On newer devices, the `/sdcard` partition is actually a symbolic link to `/data/media`.
    In this case, using the `dd` command to copy the `/data` partition to the SD card
    won't work, and could corrupt the device because the input file is essentially
    being written to itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新的设备上，`/sdcard`分区实际上是指向`/data/media`的符号链接。在这种情况下，使用`dd`命令将`/data`分区复制到SD卡将无效，并且可能会损坏设备，因为输入文件实质上是被写入自身。
- en: To determine where the SD card is symbolically linked to, simply open the ADB
    shell and run the `ls -al` command. If the SD card partition is not shown, the
    SD likely needs to be mounted in recovery mode using the steps shown in [Chapter
    4](part0031.xhtml "Chapter 4. Extracting Data Logically from Android Devices"),
    *Extracting Data Logically from Android Devices*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定SD卡符号链接到哪里，只需打开ADB shell并运行`ls -al`命令。如果未显示SD卡分区，则可能需要使用[第4章](part0031.xhtml
    "第4章。从Android设备逻辑上提取数据")中显示的步骤在恢复模式下挂载SD卡，*从Android设备逻辑上提取数据*。
- en: In the following example, `/sdcard` is symbolically linked to `/data/media`.
    This indicates that the `dd` command's output should not be written to the SD
    card.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`/sdcard`被符号链接到`/data/media`。这表明`dd`命令的输出不应写入SD卡。
- en: '![Writing to an SD card](img/image00362.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![写入SD卡](img/image00362.jpeg)'
- en: 'In the example that follows, the `/sdcard` is not a symbolic link to `/data`,
    so the `dd` command''s output can be used to write the `/data` partition image
    to the SD card:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，`/sdcard`不是指向`/data`的符号链接，因此`dd`命令的输出可以用来将`/data`分区图像写入SD卡：
- en: '![Writing to an SD card](img/image00363.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![写入SD卡](img/image00363.jpeg)'
- en: On older devices, the SD card may not even be symbolically linked.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧设备上，SD卡甚至可能没有被符号链接。
- en: 'After determining which block to read and to where the SD card is symbolically
    linked, image the `/data` partition to the `/sdcard`, using the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要读取的块以及SD卡符号链接的位置后，使用以下命令将`/data`分区镜像到`/sdcard`：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Writing to an SD card](img/image00364.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![写入SD卡](img/image00364.jpeg)'
- en: Now, an image of the `/data` partition exists on the SD card. It can be pulled
    to the examiner's machine with the ADB `pull` command, or simply read from the
    SD card.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SD卡上存在`/data`分区的图像。可以使用ADB `pull`命令将其拉到检查员的计算机上，或者直接从SD卡中读取。
- en: Writing directly to an examiner's computer with netcat
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用netcat直接写入检查员的计算机
- en: If the image cannot be written to the SD card, an examiner can use **netcat**
    to write the image directly to their machine. The netcat tool is a Linux-based
    tool used for transferring data over a network connection. We recommend using
    a Linux or a Mac computer for using netcat as it is built-in, though Windows versions
    do exist. The examples below were done on a Mac.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像无法写入SD卡，检查员可以使用**netcat**直接将图像写入其计算机。netcat工具是一种基于Linux的工具，用于在网络连接上传输数据。我们建议在Linux或Mac计算机上使用netcat，因为它是内置的，尽管也存在Windows版本。以下示例是在Mac上完成的。
- en: Installing netcat on the device
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在设备上安装netcat
- en: Very few Android devices, if any, come with netcat installed. To check, simply
    open the ADB shell and type `nc`. If it returns saying `nc is not found`, netcat
    will have to be installed manually on the device. Netcat compiled for Android
    can be found at many places online. We have shared the version we used at [http://sourceforge.net/projects/androidforensics-netcat/files/](http://sourceforge.net/projects/androidforensics-netcat/files/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有Android设备（如果有的话）预装了netcat。要检查，只需打开ADB shell并键入`nc`。如果返回`nc未找到`，则必须在设备上手动安装netcat。可以在许多在线位置找到为Android编译的netcat。我们分享了我们在[http://sourceforge.net/projects/androidforensics-netcat/files/](http://sourceforge.net/projects/androidforensics-netcat/files/)上使用的版本。
- en: 'If we look back at the results from our `mount` command in the previous section,
    we can see that the `/dev` partition is mounted as `tmpfs`. The Linux term `tmpfs`
    means that the partition is meant to appear as an actual filesystem on the device,
    but is truly only stored in RAM. This means we can `push` netcat here without
    making any permanent changes to the device using the following command on the
    examiner''s computer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下前一节中`mount`命令的结果，我们可以看到`/dev`分区被挂载为`tmpfs`。Linux术语`tmpfs`表示该分区旨在在设备上显示为实际文件系统，但实际上只存储在RAM中。这意味着我们可以在取证人的计算机上使用以下命令`push`
    netcat，而不对设备进行任何永久更改：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The command should have created the `Examiner_Folder` in `/dev`, and `nc` should
    be in it. This can be verified by running the following command in the ADB shell:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该已经在`/dev`中创建了`Examiner_Folder`，并且`nc`应该在其中。可以通过在ADB shell中运行以下命令来验证：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using netcat
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用netcat
- en: 'Now that the netcat binary is on the device, we need to give it permission
    to execute from the ADB shell. This can be done as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在netcat二进制文件已经在设备上，我们需要在ADB shell中给予它执行权限。可以按照以下步骤完成：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will need two terminal windows open with the ADB shell open in one of them.
    The other will be used to listen to the data being sent from the device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要打开两个终端窗口，其中一个打开了ADB shell。另一个将用于监听从设备发送的数据。
- en: 'Now we need to enable port forwarding over ADB from the examiner''s computer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在取证人的计算机上通过ADB启用端口转发：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`9999` is the port we chose to use for netcat; it can be any arbitrary port
    number between 1023 and 65535 on a Linux or Mac system (1023 and below are reserved
    for system processes, and require root permission to use). Windows will allow
    *any* port to be assigned.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`9999`是我们选择用于netcat的端口；在Linux或Mac系统上，可以是1023到65535之间的任意端口号（1023及以下保留给系统进程，需要root权限才能使用）。Windows将允许分配*任何*端口。'
- en: 'In the terminal window with ADB shell, run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有ADB shell的终端窗口中，运行以下命令：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`mmcblk0p34` is the user data partition on this device, however, the entire
    flash memory or any other partition could also be imaged with this method. In
    most cases, it is best practice to image the entirety of the flash memory in order
    to acquire all possible data from the device. Some commercial forensic tools may
    also require the entire memory image, and may not properly handle an image of
    a single partition.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmcblk0p34`是该设备上的用户数据分区，但是整个闪存或任何其他分区也可以使用这种方法进行镜像。在大多数情况下，最佳做法是镜像整个闪存，以便从设备中获取所有可能的数据。一些商业取证工具可能还需要整个内存映像，并且可能无法正确处理单个分区的映像。'
- en: 'In the other terminal window, run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中运行：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `data_partition.img` file should now be created in the current directory
    of the examiner's computer. When the data is finished transferring, netcat in
    both terminals will terminate and return to the command prompt. The process can
    take a significant amount of time depending on the size of the image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_partition.img`文件现在应该在取证人计算机的当前目录中创建。当数据传输完成时，两个终端中的netcat将终止并返回到命令提示符。这个过程可能需要相当长的时间，具体取决于图像的大小。'
- en: Extracting data physically with nanddump
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nanddump物理提取数据
- en: In all of the preceding examples, the partitions were all **Multimedia Card**
    (**MMC**) blocks, which is typically seen in newer devices. Older devices, however,
    are far more likely to consist of **Memory Technology Device** (**MTD**) blocks.
    We have seen cases in the past where the `dd` command was unable to properly image
    an MTD block, although more often than not, it works fine. If `dd` fails, there
    is a widely distributed utility called `MTD-Utils` used to read and write from
    MTD blocks; the `nanddump` command is a part of `MTD-Utils`, and can be used similarly
    to `dd` in order to read from an MTD block. In those cases where `dd` failed,
    `nanddump` was always successful.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的示例中，分区都是**多媒体卡**（MMC）块，这在较新的设备中很常见。然而，较旧的设备更有可能由**存储器技术设备**（MTD）块组成。我们过去曾看到`dd`命令无法正确镜像MTD块的情况，尽管往往它可以正常工作。如果`dd`失败，有一个被广泛分发的实用程序叫做`MTD-Utils`，用于从MTD块读取和写入；`nanddump`命令是`MTD-Utils`的一部分，并且可以类似于`dd`用于从MTD块读取。在`dd`失败的情况下，`nanddump`总是成功的。
- en: Versions of `nanddump` compiled for Android can be found in many places online;
    we used the one found at [https://github.com/jakev/android-binaries/blob/master/nanddump](https://github.com/jakev/android-binaries/blob/master/nanddump).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为Android编译的`nanddump`版本可以在许多在线地方找到；我们使用的是在[https://github.com/jakev/android-binaries/blob/master/nanddump](https://github.com/jakev/android-binaries/blob/master/nanddump)找到的版本。
- en: 'The process to put `nanddump` on the device is the same as the one used previously
    for netcat:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nanddump`放到设备上的过程与之前用于netcat的过程相同：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just like `dd`, the `nanddump` command can be used to write either to an SD
    card or the examiner''s computer via netcat. From a terminal window, run the following
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`dd`一样，`nanddump`命令可以用于通过netcat写入SD卡或取证人的计算机。从终端窗口中，运行以下命令：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From a separate terminal window within the ADB shell, run the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在ADB shell中的一个单独的终端窗口中运行以下命令：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the first terminal window where the `adb forward` command was used, run
    the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`adb forward`命令的第一个终端窗口中，运行以下命令：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Verifying a full physical image
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证完整的物理映像
- en: 'Verifying whether an image file is identical to the device is a critical step
    in traditional digital forensics. On Android devices, it can be a little trickier,
    if not impossible. The image created can be hashed using whatever tool the examiner
    typically uses. Verifying the memory on the device can be done through the ADB
    shell using the following command, where the path given is the block or partition
    that was imaged:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 验证图像文件是否与设备相同是传统数字取证中的关键步骤。在Android设备上，这可能会有点棘手，甚至是不可能的。可以使用取证人通常使用的任何工具对创建的图像进行哈希处理。可以通过在ADB
    shell中使用以下命令来验证设备上的内存，其中给定的路径是被镜像的块或分区：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, the `md5sum` command is not included on all Android devices. If it
    is not included, an examiner may be able to find a version compiled for their
    device online, and push it to the device in a `tmpfs` partition as shown previously
    with netcat and `nanddump`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`md5sum`命令并非所有Android设备都包含。如果没有包含，检查员可能可以在网上找到适用于其设备的版本，并将其推送到`tmpfs`分区中，如之前使用netcat和`nanddump`所示。
- en: Another issue is that if the image was acquired live, i.e. not in recovery mode
    as discussed in the previous chapter, it is a virtual certainty that the MD5 hashes
    will *not* match, as data is constantly changing on the device (even if it is
    **radio frequency** (**RF**) shielded or in Airplane mode). In this case, an examiner
    would have to document that the device was live when acquired and explain that
    the hashes are not expected to match.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果图像是在活动状态下获取的，即不是在恢复模式下获取的，正如前一章中所讨论的，那么MD5哈希值几乎肯定不会匹配，因为设备上的数据不断变化（即使是**无线电频率**（**RF**）屏蔽或处于飞行模式）。在这种情况下，检查员必须记录设备在获取时处于活动状态，并解释哈希值不会匹配的原因。
- en: Analyzing a full physical image
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析完整的物理图像
- en: Once an image has been obtained using one of the discussed methods, an examiner
    could conceivably go through the image manually and extract each partition, but
    would probably prefer to avoid doing that. Luckily, there is a wide variety of
    mobile forensic tools that can ingest a physical image, such as Cellebrite, XRY,
    Mobile Phone Examiner, and many others. Unfortunately, none of these are free
    or open source. By far the most popular analysis tool that is free and open source
    is Autopsy by Brian Carrier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用讨论过的方法之一获取了图像，检查员可能可以手动浏览图像并提取每个分区，但可能更倾向于避免这样做。幸运的是，有各种各样的移动取证工具可以接收物理图像，如Cellebrite、XRY、Mobile
    Phone Examiner等。不幸的是，这些工具都不是免费或开源的。迄今为止，最受欢迎的免费开源分析工具是Brian Carrier的Autopsy。
- en: Autopsy
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Autopsy
- en: The Sleuth Kit began as a set of Linux-based command line tools for forensics;
    eventually, a browser-based GUI named Autopsy was added. Recently, Autopsy has
    been released as a stand-alone platform on Windows, and includes support for analyzing
    Android images. Version 3.1.1 is shown in the following screenshots. The full
    process for loading and analyzing an image will be covered in [Chapter 8](part0076.xhtml
    "Chapter 8. Android Forensic Tools Overview"), *Forensic Analysis of Android Applications*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Sleuth Kit最初是一组基于Linux的命令行工具，用于取证；最终，添加了一个名为Autopsy的基于浏览器的GUI。最近，Autopsy已作为Windows上的独立平台发布，并包括分析Android图像的支持。版本3.1.1如下截图所示。加载和分析图像的完整过程将在[第8章](part0076.xhtml
    "第8章。Android取证工具概述")中进行介绍，*Android应用程序的取证分析*。
- en: Autopsy can be downloaded at [http://www.sleuthkit.org/](http://www.sleuthkit.org/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Autopsy可以在[http://www.sleuthkit.org/](http://www.sleuthkit.org/)下载。
- en: 'Once the image has been loaded, expanding the image will show all the volumes
    that Autopsy found, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载后，扩展图像将显示Autopsy发现的所有卷，如下截图所示：
- en: '![Autopsy](img/image00365.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Autopsy](img/image00365.jpeg)'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Far more volumes were found than the number of partitions on the device. They
    may either be false positives created by the tool, or a result of wear-leveling
    on the device.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上发现的卷远远多于分区的数量。它们可能是工具创建的误报，也可能是设备上的磨损平衡的结果。
- en: One of these volumes will be the data partition, seen as follows:.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个卷将是数据分区，如下所示：
- en: '![Autopsy](img/image00366.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Autopsy](img/image00366.jpeg)'
- en: 'Note that the media directory seen above is the SD card, as it was symbolically
    linked to the `data` partition. The `data` folder within the `data` partition
    will contain application data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面看到的媒体目录是SD卡，因为它被符号链接到`data`分区。`data`分区中的`data`文件夹将包含应用程序数据：
- en: '![Autopsy](img/image00367.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Autopsy](img/image00367.jpeg)'
- en: As each application is installed, a directory is created for it. The directories
    shown in the preceding screenshot with a red cross on the folder icon were deleted,
    indicating that the application was removed from the device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每安装一个应用程序，都会为其创建一个目录。在前面的屏幕截图中，带有文件夹图标上的红色叉号的目录已被删除，表明该应用程序已从设备中移除。
- en: Finally, Autopsy does a good job pulling out some data automatically for an
    examiner, but as with all forensic tools, this information should be verified
    manually, as seen in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Autopsy可以自动提取一些数据供检查员使用，但与所有取证工具一样，这些信息应该进行手动验证，如[第7章](part0053.xhtml "第7章。Android应用程序的取证分析")中所示，*Android应用程序的取证分析*。
- en: '![Autopsy](img/image00368.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Autopsy](img/image00368.jpeg)'
- en: Issues with analyzing physical dumps
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析物理转储的问题
- en: The most common problem we see on many forensic forums and email lists is examiners
    obtaining a physical dump and then not being able to load that dump into a tool
    that claims to support the device. Most of the time, this is because the examiner
    fails to account for the **Out-of-Band** (**OOB**) area.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多取证论坛和邮件列表上看到的最常见问题是，检查员获取了物理转储，然后无法将其加载到声称支持该设备的工具中。大多数情况下，这是因为检查员未考虑**带外**（**OOB**）区域。
- en: The OOB area, sometimes called the spare area, is a small section of the flash
    memory reserved for metadata. The metadata usually consists of **error correcting
    code** (**ECC**), information about bad blocks, and in some cases, information
    about the filesystem. This causes an issue for examiners because most mobile forensic
    tools do not account for the OOB area; they expect it to not be included in the
    image. When presenting the tool with an image containing the spare area, the tool
    frequently does not know what to do and fails to parse the data properly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 带外区域，有时称为备用区域，是保留用于元数据的闪存小部分。元数据通常包括**纠错码**（**ECC**）、有关坏块的信息，以及在某些情况下，有关文件系统的信息。这对检查员来说是一个问题，因为大多数移动取证工具不考虑带外区域；它们期望图像中不包含它。当向工具呈现包含备用区域的图像时，工具通常不知道该怎么做，并且无法正确解析数据。
- en: The reason that tools fail to account for the OOB area is that it is *not* included
    in `dd` images, which is what most tools use to create their images. The OOB area
    may be included when using the `nanddump` command, though depending on the binary
    used, there may be an option to exclude it. The OOB area is included with chip-off
    and JTAG images.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 工具无法考虑OOB区域的原因是，它*不*包括在`dd`镜像中，这是大多数工具用来创建它们的镜像的。使用`nanddump`命令时，OOB区域可能会被包括在内，尽管根据使用的二进制文件，可能有一个选项来排除它。OOB区域包括在芯片脱焊和JTAG镜像中。
- en: To properly load the image into forensic tools, the OOB area will need to be
    removed first. A general rule of thumb is that the OOB size is based on the page
    size of the device; for every 512 bytes of page size there will be 16 bytes of
    OOB area. For example, a device with 2048 byte page sizes would likely have 64
    bytes of OOB area at the end of each page. However, this is completely up to the
    memory manufacturer. Before attempting to remove the OOB area, an examiner should
    find the datasheet for the specific memory chip to confirm the page and OOB area
    sizes. This can generally be done by finding the memory chip on the phone's circuit
    board and searching for the model number of the chip.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确加载图像到取证工具中，首先需要删除OOB区域。一个经验法则是，OOB大小基于设备的页面大小；对于每512字节的页面大小，将有16字节的OOB区域。例如，具有2048字节页面大小的设备可能在每个页面的末尾有64字节的OOB区域。然而，这完全取决于存储芯片制造商。在尝试删除OOB区域之前，检查员应该找到特定存储芯片的数据表，以确认页面和OOB区域的大小。通常可以通过在手机电路板上找到存储芯片并搜索芯片的型号来完成这一点。
- en: 'The following is some sample code for a Python script that will remove the
    OOB area from an image. Just as in the last chapter, we don''t claim to be Python
    experts and we''re sure there are better, more efficient ways to do this, but
    this one does work:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Python脚本的示例代码，用于从图像中删除OOB区域。就像上一章一样，我们并不是Python专家，我们确信有更好、更有效的方法来做到这一点，但这个方法确实有效：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This file, if named `OOB_Remover.py`, would be executed with the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名为`OOB_Remover.py`，则可以使用以下命令执行此文件：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output file, with no OOB area, would be named `file_out.bin` in the directory
    where the script was executed. The original is not edited or modified in anyway.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件，没有OOB区域，将被命名为`file_out.bin`，保存在执行脚本的目录中。原始文件不会被编辑或修改。
- en: Note that the code as it is written assumes a page size of 2048 and an OOB size
    of 64; these two numbers would have to be edited for the specific sizes of the
    memory chip the image was taken from. The output should then be able to be loaded
    into commercial mobile forensic tools.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码的编写假定页面大小为2048，OOB大小为64；这两个数字需要根据图像所在的存储芯片的具体大小进行编辑。然后输出应该能够加载到商用移动取证工具中。
- en: Imaging and analyzing Android RAM
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成像和分析Android RAM
- en: Pulling Android memory is not applicable in a very large number of cases due
    to the fact that it requires root access. Most public root processes involve rebooting
    the phone, which erases volatile RAM, meaning that by the time an examiner gains
    root to image the RAM, it's too late because the RAM has been erased. Because
    of this and possibly other reasons, there is not great support for Android RAM
    imaging and analysis in the commercial forensic world. However, there are cases
    where imaging RAM is applicable, and may prove invaluable. If a device is already
    rooted when it is seized, imaging the RAM should be a mandatory step in the seizure
    process. As powering the phone off will erase the RAM, the device should be placed
    in Airplane mode (any other network connections such as Wi-Fi and Bluetooth disabled),
    and the RAM should be imaged immediately to avoid the device battery dying before
    the RAM can be pulled.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于拉取Android内存需要root访问权限，在很多情况下并不适用。大多数公共root过程涉及重新启动手机，这会擦除易失性RAM，这意味着当检查员获得root权限来镜像RAM时，为时已晚，因为RAM已经被擦除。由于这个原因和可能的其他原因，在商业取证领域对Android
    RAM成像和分析的支持并不是很好。然而，有些情况下成像RAM是适用的，并可能非常有价值。如果设备在被扣押时已经root，那么镜像RAM应该是扣押过程中的一个强制步骤。由于关闭手机将擦除RAM，设备应该被置于飞行模式（任何其他网络连接，如Wi-Fi和蓝牙都应该被禁用），并且应该立即镜像RAM，以避免设备电池在RAM被拉取之前耗尽。
- en: The main challenge when it comes to RAM is the analysis. RAM is completely raw,
    unstructured data; there is no filesystem. When viewed in a hex editor, RAM appears
    to just be a giant blob of data with very little rhyme or reason to help examiners
    figure out what they are looking at. This difficulty is compounded by the fact
    that modern devices commonly have gigabytes worth of RAM. RAM can easily be searched
    for keywords using traditional forensic tools and methods, but that presumes an
    examiner knows exactly what they are looking for.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到RAM时，主要挑战在于分析。RAM是完全原始的、无结构的数据；没有文件系统。在十六进制编辑器中查看RAM时，RAM似乎只是一个巨大的数据块，几乎没有任何规律可以帮助检查员弄清楚他们在看什么。现代设备通常有几十GB的RAM，这种困难是由此而来的。RAM可以很容易地使用传统取证工具和方法搜索关键字，但这假设检查员确切地知道他们在寻找什么。
- en: What can be found in RAM?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAM中可以找到什么？
- en: Any data that is written to the flash memory *must* pass through RAM, there
    is no other way for the processor to communicate with the flash memory. This means
    that almost anything done on the device may be found in the contents of a RAM
    dump. Depending on the amount of device usage, data may remain in RAM indefinitely,
    until it needs to be overwritten. RAM dumps frequently contain text typed on the
    device, including usernames and passwords, and application data that is not stored
    permanently on the device. For example, older versions of the Facebook application
    stored the contents of a user's News Feed in a database in its application folder;
    newer versions do not save the user's News Feed, but it exists in RAM.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 任何写入闪存的数据*必须*通过RAM传递，处理器与闪存之间没有其他通信方式。这意味着几乎在设备上执行的任何操作都可能在RAM转储的内容中找到。根据设备使用量的不同，数据可能会一直保留在RAM中，直到需要被覆盖。RAM转储经常包含在设备上键入的文本，包括用户名和密码，以及不会永久存储在设备上的应用程序数据。例如，旧版本的Facebook应用程序将用户的动态消息内容存储在其应用程序文件夹中的数据库中；新版本不保存用户的动态消息内容，但它存在于RAM中。
- en: Imaging RAM with LiME
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LiME成像RAM
- en: The most common tool for Android RAM acquisition is the **Linux Memory Extractor**
    (**LiME**), previously known as DMD. LiME is free and open source, but isn't highly
    user-friendly as it requires the user to compile it from the source code, which
    can only be done on a Linux system. The compilation process must also be done
    for each specific version of Android for each device being examined, which somewhat
    limits its usability in the field. This is necessary because LiME is not a binary
    (as were the netcat and nanddump tools we used before); instead it is a kernel
    module that must be built specifically for each kernel it will be loaded into.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Android RAM获取最常用的工具是**Linux Memory Extractor**（**LiME**），以前被称为DMD。LiME是免费和开源的，但并不是非常用户友好，因为它需要用户从源代码编译，这只能在Linux系统上完成。编译过程还必须针对每个要检查的设备的每个特定版本的Android进行，这在一定程度上限制了它在现场的可用性。这是必要的，因为LiME不是一个二进制文件（就像我们之前使用的netcat和nanddump工具一样）；相反，它是一个必须为将要加载的每个内核专门构建的内核模块。
- en: 'In order to ensure the proper kernel source code is downloaded, we will need
    to determine the model and software version for a device, which can be done by
    scrolling through the phone menu to **Setting** | **About Phone**. Alternatively,
    this information can be found in the ADB shell by running the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保下载正确的内核源代码，我们需要确定设备的型号和软件版本，可以通过在手机菜单中滚动到**设置** | **关于手机**来完成。或者，可以通过在ADB
    shell中运行以下命令来找到这些信息：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The software version in the model should be in the first few lines at the top
    of the file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 型号中的软件版本应该在文件顶部的前几行中。
- en: 'Luckily, most Android manufacturers do release their kernel source code; a
    quick Google search can usually turn up source code for each model and software
    version. The following are the open source release sites for a few major manufacturers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数Android制造商确实发布他们的内核源代码；快速的谷歌搜索通常可以找到每个型号和软件版本的源代码。以下是一些主要制造商的开放源发布网站：
- en: '**Samsung**: [http://opensource.samsung.com/reception.do](http://opensource.samsung.com/reception.do)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Samsung**: [http://opensource.samsung.com/reception.do](http://opensource.samsung.com/reception.do)'
- en: '**Motorola**: [http://sourceforge.net/motorola/](http://sourceforge.net/motorola/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Motorola**: [http://sourceforge.net/motorola/](http://sourceforge.net/motorola/)'
- en: '**HTC**: [http://www.htcdev.com/devcenter](http://www.htcdev.com/devcenter)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTC**: [http://www.htcdev.com/devcenter](http://www.htcdev.com/devcenter)'
- en: '**Google Nexus**: [https://source.android.com/source/building-kernels.html](https://source.android.com/source/building-kernels.html)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Nexus**: [https://source.android.com/source/building-kernels.html](https://source.android.com/source/building-kernels.html)'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The correct model and version source must be used. Using the wrong kernel source
    to compile LiME will, at the very least, not work on the device. Loading an incompatible
    kernel module could also crash the device.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用正确的型号和版本源。使用错误的内核源编译LiME将至少无法在设备上工作。加载不兼容的内核模块也可能导致设备崩溃。
- en: To obtain the source code for LiME, navigate to [https://github.com/504ensicsLabs/LiME](https://github.com/504ensicsLabs/LiME)
    and choose the **Download ZIP** option, then extract the zip.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取LiME的源代码，请转到[https://github.com/504ensicsLabs/LiME](https://github.com/504ensicsLabs/LiME)，然后选择**Download
    ZIP**选项，然后提取zip文件。
- en: 'There are many excellent resources online explaining how to compile LiME for
    a specific kernel, and also how to create a custom `Volatility` plugin to examine
    the resulting RAM dump, so we won''t detail them here. A couple of them are listed
    here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线资源解释了如何为特定内核编译LiME，以及如何创建自定义的`Volatility`插件来检查生成的RAM转储，因此我们在这里不会详细介绍它们。以下是其中一些：
- en: '[http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf](http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf](http://lime-forensics.googlecode.com/files/LiME_Documentation_1.1.pdf)'
- en: '[https://code.google.com/p/volatility/wiki/AndroidMemoryForensics](https://code.google.com/p/volatility/wiki/AndroidMemoryForensics)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/volatility/wiki/AndroidMemoryForensics](https://code.google.com/p/volatility/wiki/AndroidMemoryForensics)'
- en: One point missing from these sources is that the step that uses ADB `pull` to
    obtain the `/proc/config.gz` file may not work on all devices. If the file does
    not exist, the correct config file can be found in the source code, usually in
    the `/arch/arm/configs` folder. It is usually named after the processor model,
    for example, `apq8064_defconfig`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些来源中缺少的一点是，使用ADB `pull`获取`/proc/config.gz`文件的步骤可能无法在所有设备上工作。如果文件不存在，则可以在源代码中找到正确的配置文件，通常在`/arch/arm/configs`文件夹中。通常以处理器型号命名，例如`apq8064_defconfig`。
- en: Imaging RAM with mem
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mem成像RAM
- en: As described in the preceding section, using LiME is not for the faint-hearted;
    it is a very daunting process fraught with complications. It seems unlikely that
    an examiner in the field will download and compile kernel source code. The **mem**
    tool was developed by James Nuttall to address these issues. Rather than a kernel
    module that needs to be compiled on a device-specific basis, mem is a binary similar
    to the netcat and nanddump examples used previously in this chapter. The mem tool
    can be downloaded at [http://sourceforge.net/projects/androidforensics-mem/files/](http://sourceforge.net/projects/androidforensics-mem/files/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，使用LiME并非易事；这是一个充满复杂性的艰巨过程。在现场，调查员不太可能下载和编译内核源代码。**mem**工具是由James Nuttall开发的，旨在解决这些问题。与需要根据设备特定情况编译的内核模块不同，mem是一个二进制文件，类似于本章前面使用的netcat和nanddump示例。mem工具可以在[http://sourceforge.net/projects/androidforensics-mem/files/](http://sourceforge.net/projects/androidforensics-mem/files/)下载。
- en: Mem is an executable binary that needs to be pushed to the device and executed
    using the exact procedures detailed previously for netcat and nanddump. It may
    seem counter-intuitive to push something to RAM in order to read the RAM, but
    this is an accepted necessity in computer forensics. In our opinion, it is better
    to overwrite a small portion of RAM than to actually push it to the device and
    overwrite evidentiary user data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Mem是一个可执行二进制文件，需要推送到设备并使用之前详细介绍的netcat和nanddump的确切过程来执行。在计算机取证中，将某些东西推送到RAM以读取RAM可能看起来有些违反直觉，但这是计算机取证中的一种必要操作。在我们看来，覆盖一小部分RAM要比实际推送到设备并覆盖证据用户数据要好。
- en: 'Mem has the capability to read the entire RAM, or to target specific, forensically-interesting
    processes (applications). Assuming that mem is pushed to the same location on
    the device used for netcat above, the format for running mem is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Mem具有读取整个RAM的能力，或者针对特定的取证感兴趣的进程（应用程序）。假设mem被推送到上面使用netcat的设备相同位置，运行mem的格式如下：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`PID` is the ID of the process to read; if it is set to 0, all of RAM will
    be imaged. To view the list of processes within the ADB shell, use the following
    command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`PID`是要读取的进程的ID；如果设置为0，将镜像整个RAM。要在ADB shell中查看进程列表，使用以下命令：'
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following screenshot, we can see that `PID` is the second column of
    the output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到`PID`是输出的第二列：
- en: '![Imaging RAM with mem](img/image00369.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用mem镜像RAM](img/image00369.jpeg)'
- en: 'The output can be quite large, though interesting processes can be found by
    simply reading through the list:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能相当大，但通过简单阅读列表可以找到有趣的进程：
- en: '![Imaging RAM with mem](img/image00370.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![使用mem镜像RAM](img/image00370.jpeg)'
- en: 'In the above screenshot, we can see that Kik, Facebook, Calendar, and Gmail
    are all running. An alternative to reading the entire output is to search for
    known applications using `grep`. For example, to find Facebook in the output we
    could run the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到Kik、Facebook、日历和Gmail都在运行。另一种方法是搜索已知应用程序，使用`grep`。例如，要在输出中找到Facebook，我们可以运行以下命令：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of which would show only the entry for Facebook as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出将只显示Facebook的条目如下：
- en: '![Imaging RAM with mem](img/image00371.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![使用mem镜像RAM](img/image00371.jpeg)'
- en: 'We can see that the PID of Facebook is `2252`. To avoid overwriting data on
    the device, mem is written to be used in conjunction with netcat just as shown
    in the *Writing directly to an examiner''s computer with netcat* section of this
    chapter. So, capturing the RAM used by Facebook requires the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Facebook的PID是`2252`。为了避免在设备上覆盖数据，mem被设计为与netcat一起使用，就像本章的*直接使用netcat将数据写入调查员计算机*部分所示的那样。因此，捕获Facebook使用的RAM需要以下步骤：
- en: 'In a terminal on the examiner''s computer, run:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调查员计算机上的终端中运行：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In a terminal window within ADB shell, run:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ADB shell中的终端窗口中运行：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the terminal window on the examiner''s computer run:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调查员计算机上的终端窗口中运行：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When mem has finished running, there should be a file called `FB_RAM.bin` in
    the working directory of the examiner's computer.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当mem运行结束时，调查员的计算机工作目录中应该会有一个名为`FB_RAM.bin`的文件。
- en: Output from mem
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从mem输出
- en: 'As mentioned previously, there aren''t many good ways to examine RAM because
    there is no filesystem; the output is just a blob of data. This is still true
    for data acquired with mem; the output from the Facebook RAM pulled above is a
    550 MB unstructured blob of data. The following screenshot can be viewed as an
    example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，检查RAM的好方法并不多，因为没有文件系统；输出只是一大块数据。这对于使用mem获取的数据仍然成立；上面提取的Facebook RAM的输出是一个550MB的无结构数据块。以下截图可以作为示例查看：
- en: '![Output from mem](img/image00372.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![从mem输出](img/image00372.jpeg)'
- en: We suggest using strings or some other search function to narrow down the data
    to hopefully find useful user data. The file can also be loaded into computer
    forensic tools like EnCase or FTK in order to search for keywords, and carving
    tools can be used to locate images.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用字符串或其他搜索功能来缩小数据范围，以便找到有用的用户数据。该文件也可以加载到计算机取证工具如EnCase或FTK中，以搜索关键词，也可以使用雕刻工具来定位图像。
- en: 'However, with enough patience and dedication, useful information can be found,
    such as this post from a user''s news feed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要有足够的耐心和奉献精神，就可以找到有用的信息，比如用户新闻订阅中的这篇帖子：
- en: '![Output from mem](img/image00373.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![从mem输出](img/image00373.jpeg)'
- en: Eventually, the mem developers hope to work on a volatility profile to help
    with analyzing the output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，mem的开发人员希望能够开发出一种用于分析输出的volatility配置文件。
- en: Acquiring Android SD cards
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Android SD卡
- en: As discussed above and in previous chapters, the SD card can refer to a physical,
    external SD card or a partition within the flash memory. A removable external
    SD card can be imaged separately from the device through a write-blocker with
    typical computer forensics tools, or using the `dd`/`nanddump` techniques shown
    in the previous section, although the former is usually faster as it does not
    need to write data over netcat.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在前几章中，SD卡可以指外部物理SD卡或闪存内的分区。可通过写阻断器和典型的计算机取证工具，或使用前一节中显示的`dd`/`nanddump`技术，单独成像可移动的外部SD卡，尽管前者通常更快，因为它不需要通过netcat写入数据。
- en: Physically imaging an SD card is very similar to the physical imaging discussed
    above; in fact, if the SD card is symbolically linked to the `/data` partition,
    it would be acquired as part of the `/data` partition as seen in the Autopsy screenshots.
    The only difference in the process is that if the SD card is being imaged, the
    output file cannot be written to the SD card! This means using the netcat methods
    covered previously is the best option for physically imaging an internal SD card.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对SD卡进行物理成像与上面讨论的物理成像非常相似；实际上，如果SD卡被符号链接到`/data`分区，它将作为`/data`分区的一部分在Autopsy截图中被获取。该过程的唯一区别在于，如果正在成像SD卡，则无法将输出文件写入SD卡！这意味着使用先前介绍的netcat方法是对内部SD卡进行物理成像的最佳选择。
- en: What can be found on an SD card?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SD卡上可能会发现什么？
- en: By default, the SD card is typically used to store large files, including downloaded
    items and pictures taken with the device. Many applications will also create their
    own directory on the SD card for storing data such as images sent or received
    through chat applications. In some cases, as will be seen in [Chapter 8](part0076.xhtml
    "Chapter 8. Android Forensic Tools Overview"), *Android Forensic Tools Overview*,
    there even are applications that will routinely perform a backup of all their
    data to the SD card. This is especially useful to forensic examiners because they
    may not be able to access the internal memory due to security settings or the
    inability to obtain root, but may be able to access the SD card.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SD卡通常用于存储大文件，包括下载的项目和使用设备拍摄的照片。许多应用程序还会在SD卡上创建自己的目录，用于存储通过聊天应用程序发送或接收的图像等数据。在某些情况下，正如在[第8章](part0076.xhtml
    "第8章。Android取证工具概述")中所看到的，*Android取证工具概述*，甚至有一些应用程序会定期将所有数据备份到SD卡上。这对取证人员特别有用，因为他们可能无法访问内部存储器，由于安全设置或无法获取root权限，但可能可以访问SD卡。
- en: 'Common SD card locations of interest include, but of course are not limited
    to, the following locations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的常见SD卡位置包括但不限于以下位置：
- en: '`/DCIM`: This location includes pictures taken on the device'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/DCIM`：此位置包括设备上拍摄的照片'
- en: '`/Pictures/Screenshots`: This location contains screenshots taken on the device'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Pictures/Screenshots`：此位置包含设备上拍摄的截图'
- en: '`/Download`: This location contains downloaded files'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Download`：此位置包含下载的文件'
- en: '`/Android/data`: This is the storage location for many applications'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Android/data`：这是许多应用程序的存储位置'
- en: '`/AppName`: This is the storage location for many applications'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/AppName`：这是许多应用程序的存储位置'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `/Android/data` and `/AppName` folders may persist even if the app has been
    deleted. Contents of the folders will be deleted, but the folders may remain;
    which is an indication that the application was previously installed on the device.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用已被删除，`/Android/data`和`/AppName`文件夹可能仍然存在。文件夹的内容将被删除，但文件夹可能仍然存在；这表明该应用程序先前曾安装在设备上。
- en: These are just common default locations. If a device is rooted, the user could
    place any data from the internal memory onto the SD card.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是常见的默认位置。如果设备已获取root权限，用户可以将内部存储器中的任何数据放到SD卡上。
- en: SD card security
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SD卡安全
- en: In older versions of Android, simply plugging a phone into a computer would
    logically mount the SD card and allow an examiner access to its data. In some
    version of Android (possibly 3.0) this changed, although the exact version could
    not be found in the various change logs that we examined. Newer versions of Android
    will not automatically allow access to the SD card from a computer if a screen
    lock is in use, meaning the screen lock will have to be bypassed in order to gain
    access to the SD card. The obvious exception to this is a physical, external SD
    card can still be removed and analyzed with traditional computer forensic methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的Android中，只需将手机插入计算机即可逻辑挂载SD卡，并允许取证人员访问其数据。在某些Android版本（可能是3.0）中发生了变化，尽管在我们检查的各种更改日志中找不到确切的版本。如果使用屏幕锁定，较新版本的Android将不会自动允许从计算机访问SD卡，这意味着必须绕过屏幕锁定才能访问SD卡。显而易见的例外是，可以仍然通过传统的计算机取证方法移除并分析物理的外部SD卡。
- en: SD cards can also be encrypted, either through the device full-disk encryption
    if it is an internal SD card, or through third-party applications if it is external.
    In some cases, activating the full-disk encryption will leave the SD card unencrypted,
    though this varies depending upon the device manufacturer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SD卡也可以进行加密，可以通过设备全盘加密（如果是内部SD卡）或通过第三方应用程序（如果是外部SD卡）进行加密。在某些情况下，激活全盘加密会使SD卡保持未加密状态，尽管这取决于设备制造商。
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The full-disk encryption in Android Lollipop also encrypts the SD card.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Android Lollipop中的全盘加密也会加密SD卡。
- en: Advanced forensic methods
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级取证方法
- en: In addition to the methods discussed in the previous chapters, there are also
    more advanced, specialized methods available. JTAG and chip-off methods are both
    highly useful tools in many common situations, but require advanced training (and
    a lot of practice before working on live evidence!). The final advanced method,
    a cold boot attack to recover encryption keys, is far more theoretical.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几章讨论的方法外，还有更高级的专业方法可用。JTAG和芯片取下方法在许多常见情况下都是非常有用的工具，但需要先进的培训（以及在处理现场证据之前进行大量实践！）。最终的高级方法是冷启动攻击以恢复加密密钥，这更多是理论性的。
- en: JTAG
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JTAG
- en: JTAG is a standard developed by the **Institute of Electrical and Electronics
    Engineers** (**IEEE**). During the device production process, it is used to communicate
    with the processor through a specialized interface for testing purposes. Luckily
    for forensic examiners, it also allows them to communicate directly with the processor
    and retrieve a full physical image of the flash memory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG是由电气和电子工程师学会（IEEE）制定的标准。在设备生产过程中，它用于通过专用接口与处理器进行通信以进行测试。幸运的是，对于法医检查员来说，它还允许他们直接与处理器通信并检索闪存的完整物理图像。
- en: 'To perform a JTAG extraction, the device must be taken apart down to the circuit
    board. The circuit board will contain multiple taps (physical contacts on the
    device circuit board), though they are commonly unlabelled and there are usually
    far more taps than required for JTAG. To determine the correct taps, an examiner
    would have to either find a pin-out online (or included with their tool of choice),
    or use electronic test equipment to determine what each tap is. The examiner will
    then have to solder a wire to each tap, or use adapters (sometimes called jigs)
    that are commercially available, and connect to their JTAG box through a provided
    adapter as shown in the following image:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行JTAG提取，设备必须拆开到电路板。电路板上将包含多个接触点（设备电路板上的物理接触点），尽管它们通常没有标记，并且通常比JTAG所需的接触点多得多。要确定正确的接触点，检查员必须找到在线引脚布局图（或与其选择的工具一起提供），或使用电子测试设备确定每个接触点。然后，检查员必须将一根导线焊接到每个接触点，或使用商业可用的适配器（有时称为夹具），并通过提供的适配器连接到他们的JTAG盒子，如下图所示：
- en: '![JTAG](img/image00374.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![JTAG](img/image00374.jpeg)'
- en: HTC Evo before and after being hooked up for JTAG (courtesy of http://lowcostwin4n6.blogspot.com/)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: HTC Evo在连接JTAG之前和之后的照片（由http://lowcostwin4n6.blogspot.com/提供）
- en: 'JTAG may sound complicated (perhaps it is), but it serves many useful purposes
    and two advantages are listed here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG可能听起来很复杂（也许是），但它有许多有用的用途，以下列出了两个优点：
- en: 'It does not require the device to be powered on and so:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不需要设备通电，因此：
- en: Can be successful even if the device is damaged
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使设备损坏，也可能成功
- en: There are no RF-shielding concerns
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有射频屏蔽的担忧
- en: Does not require root, ADB, or USB debugging
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要root、ADB或USB调试
- en: 'It can be used to recover device PINs/passwords and so:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以用于恢复设备的PIN/密码，因此：
- en: Can image the entire flash memory and recover/crack password files as shown
    in Chapter 4
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对整个闪存进行成像，并恢复/破解密码文件，如第4章所示
- en: Many manufacturers make JTAG tools; many of the common ones used for mobile
    forensics can be found at [http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/](http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/).
    The RIFF box listed on the site is probably the most frequently used for mobile
    forensics, as it comes with support (including pin-outs) for a wide variety of
    devices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 许多制造商都生产JTAG工具；用于移动取证的许多常用工具可以在[http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/](http://teeltech.com/mobile-device-forensic-tools/jtag-equipment/)找到。该网站上列出的RIFF
    box可能是移动取证中最常用的工具，因为它支持（包括引脚布局）各种设备。
- en: JTAG is not always successful, or even possible. Though the interface is almost
    always on the circuit board, the manufacturer can choose to disable it after the
    device is manufactured.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG并非总是成功，甚至可能不可能。尽管接口几乎总是在电路板上，但制造商可以选择在设备制造后禁用它。
- en: Chip-off
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chip-off
- en: Chip-off involves heating the device's circuit board until the solder holding
    the components to the board melts, and then removing the flash memory chip. The
    memory chip can then be read using commercial tools, resulting in a full physical
    image. Chip-off techniques, like JTAG, stem from the commercial electronic production
    process. The process of melting the solder (commonly called reflow or rework)
    is used to place and remove components from a circuit board, and the readers used
    to acquire the memory are used to both read and write to memory chips, often in
    bulk quantities.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Chip-off涉及加热设备的电路板，直到焊料将组件固定到板上融化，然后取出闪存芯片。然后可以使用商业工具读取存储芯片，得到完整的物理图像。Chip-off技术和JTAG一样，源自商业电子生产过程。熔化焊料的过程（通常称为回流或返工）用于在电路板上放置和移除组件，用于获取存储器的读卡器通常用于读取和写入存储芯片，通常是批量使用。
- en: '![Chip-off](img/image00375.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Chip-off](img/image00375.jpeg)'
- en: A memory chip being removed from a damaged phone (courtesy of www.binaryintel.com/services/jtag-chip-off-forensics/chip-off_forensics/)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从损坏手机中取出的存储芯片（由www.binaryintel.com/services/jtag-chip-off-forensics/chip-off_forensics/提供）
- en: 'Chip-off has the same benefits as JTAG: it does not require the device to power
    on, and can be used to acquire the PIN/password from a locked device; though acquiring
    the PIN/password is generally a moot point, chip-off is normally considered to
    be a destructive process. While the memory chip can be replaced on the device,
    it is a technically demanding process and requires further training. But, as a
    last resort, chip-off is an excellent alternative for devices that would otherwise
    be impossible to examine.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Chip-off具有与JTAG相同的优点：它不需要设备通电，并且可以用于获取锁定设备的PIN/密码；尽管获取PIN/密码通常是一个无意义的点，但chip-off通常被认为是一种破坏性的过程。虽然存储芯片可以更换到设备上，但这是一个技术上要求严格的过程，并需要进一步的培训。但作为最后的手段，chip-off是无法检查的设备的一个很好的替代方法。
- en: Chip-off is significantly more expensive than JTAG, as a specialized rework
    station and commercial memory reader is required. There are dozens of rework stations
    available and they all provide essentially the same functionality. There is also
    a wide range of memory readers, though we have had great success with this reasonably
    priced model at [http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html](http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html).
    A rework station and reader aren't the only costs associated with chip-off; most
    readers will also require a specific adapter for each model of chip to be read.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Chip-off的成本要比JTAG高得多，因为需要专门的重焊站和商用存储器读卡器。有数十种重焊站可用，它们都提供基本相同的功能。还有各种各样的存储器读卡器，尽管我们在[http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html](http://www.dataman.com/programmers/universal/dataman-48pro2-super-fast-universal-isp-programmer.html)上使用了这个价格合理的型号，并取得了巨大成功。重焊站和读卡器并不是与Chip-off相关的唯一成本；大多数读卡器还需要为每个芯片型号读取特定的适配器。
- en: Bypassing Android full-disk encryption
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过Android全盘加密
- en: Before going any further, please note that this section is *highly* impractical.
    However, we present it here in the hopes that some aspiring forensic developer
    will see it and decide it is a worthy enough cause to make it more widely applicable
    (and also because it's really neat).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，本节*非常*不切实际。但是，我们希望一些有抱负的取证开发人员能看到它，并决定它是一个足够值得的事业，使其更广泛适用（也因为它真的很酷）。
- en: 'Cold boot attacks have been demonstrated and used many times, but until recently
    could not be used effectively against Android devices. A cold boot attack is based
    on the idea that RAM is less volatile at lower temperatures (the data remains
    longer), so freezing a device can allow an examiner to access RAM and find the
    key needed to decrypt the device. This was recently demonstrated successfully
    by a team of researchers whose paper and research can be found here: [https://www1.informatik.uni-erlangen.de/frost](https://www1.informatik.uni-erlangen.de/frost).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 冷启动攻击已经被证明并多次使用，但直到最近才能有效地用于Android设备。冷启动攻击是基于RAM在较低温度下（数据保留更长时间）不太易挥发的想法，因此冷冻设备可以允许检查员访问RAM并找到解密设备所需的密钥。最近，一组研究人员成功地进行了演示，他们的论文和研究可以在这里找到：[https://www1.informatik.uni-erlangen.de/frost](https://www1.informatik.uni-erlangen.de/frost)。
- en: Again, note that these techniques were only validated against one device (the
    Galaxy Nexus), and their tool is a loadable kernel module, much like LiME, and
    relies on a custom recovery image that would have to be created for each device
    it is used against.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这些技术仅针对一个设备（Galaxy Nexus）进行了验证，它们的工具是一个可加载的内核模块，就像LiME一样，并依赖于一个为每个使用的设备创建的自定义恢复映像。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter discussed several techniques used for physically imaging internal
    memory or SD cards and some of the common problems associated with them:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了用于物理成像内部存储器或SD卡的几种技术，以及与它们相关的一些常见问题：
- en: '| Technique | Problems associated |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 相关问题 |'
- en: '| --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| dd |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| dd |'
- en: Usually pre-installed on device
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常预装在设备上
- en: May not work on MTD blocks
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能无法在MTD块上工作
- en: Does not obtain Out-of-Band area
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法获取带外区域
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| nanddump |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| nanddump |'
- en: Not commonly found on the device, must be pushed to device
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不常见于设备上，必须推送到设备上
- en: Works well with MTD blocks
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与MTD块配合使用效果很好
- en: May obtain Out-of-Band area, based on options in the binary used
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能根据使用的二进制文件中的选项获取带外区域
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Additionally, each imaging technique can be used to either save the image on
    the device (typically on the SD card), or used with netcat to write the file to
    the examiner''s computer:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每种成像技术都可以用于将图像保存在设备上（通常在SD卡上），或者与netcat一起将文件写入检查员的计算机：
- en: '| Technique | Features |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 特点 |'
- en: '| --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Writing to SD card |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 写入SD卡 |'
- en: Easy, doesn't require additional binaries to be pushed to the device
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单，不需要将额外的二进制文件推送到设备
- en: Familiar to most examiners
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数检查员都熟悉
- en: Cannot be used if SD card is symbolically linked to the partition being imaged
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果SD卡被符号链接到正在成像的分区，则无法使用
- en: Cannot be used if the entire memory is being imaged
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在成像整个存储器，则无法使用
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Using netcat |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 使用netcat |'
- en: Usually requires yet another binary to be pushed to the device
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要将另一个二进制文件推送到设备
- en: Somewhat complicated, must follow steps exactly
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些复杂，必须严格按步骤进行
- en: Works no matter what is being imaged
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论正在成像什么都能工作
- en: May be more time consuming than writing to the SD
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能比写入SD卡更耗时
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Multiple tools used for RAM imaging were also demonstrated:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 还演示了用于RAM成像的多个工具：
- en: '| Tool | Features |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 特点 |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| LiME |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| LiME |'
- en: Must be compiled for each device being examined
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须为每个被检查的设备编译
- en: Very complicated process
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常复杂的过程
- en: Known, well-documented procedures for analysis
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的，有详细记录的分析程序
- en: Output is a dump of all RAM
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是所有RAM的转储
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Mem |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: 内存
- en: Can be used on any device with no additional steps
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在任何设备上使用，无需额外步骤
- en: New tool, not as widely used and documented
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新工具，使用和记录不如广泛
- en: Output is one file for each process running on the device
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是设备上运行的每个进程的一个文件
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finally, we briefly discussed chip-off and JTAG techniques on an introductory
    level.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要讨论了Chip-off和JTAG技术的入门级别。
- en: The next chapter will demonstrate the recovery of deleted data from physical
    images like the ones created in this chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将演示从物理图像中恢复删除的数据，就像本章创建的那样。
