- en: Developing Dockerized .NET Framework and .NET Core Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Docker化的.NET Framework和.NET Core应用程序
- en: 'Docker is a platform for packaging, distributing, running, and managing applications.
    When you package your applications as Docker images, they all have the same shape.
    You can deploy, manage, secure, and upgrade them all in the same way. All Dockerized
    applications have the same requirements to run them: a Docker Engine running on
    a compatible operating system. Applications run in isolated environments, so you
    can host different application platforms and different platform versions on the
    same machine with no interference.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个用于打包、分发、运行和管理应用程序的平台。当您将应用程序打包为Docker镜像时，它们都具有相同的形状。您可以以相同的方式部署、管理、保护和升级它们。所有Docker化的应用程序在运行时都具有相同的要求：在兼容的操作系统上运行Docker引擎。应用程序在隔离的环境中运行，因此您可以在同一台机器上托管不同的应用程序平台和不同的平台版本而不会发生干扰。
- en: In the .NET world, this means you can run multiple workloads on a single Windows
    machine. They could be ASP.NET websites, or **Windows Communication Foundation**
    (**WCF**) apps running as .NET console applications or .NET Windows Services.
    In the previous chapter we looked at Dockerizing legacy .NET applications without
    any code changes, but Docker has some simple expectations about how applications
    running inside containers should behave so that they can get the full benefit
    of the platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET世界中，这意味着您可以在单个Windows机器上运行多个工作负载。它们可以是ASP.NET网站，也可以是作为.NET控制台应用程序或.NET
    Windows服务运行的**Windows Communication Foundation**（**WCF**）应用程序。在上一章中，我们讨论了如何在不进行任何代码更改的情况下将传统的.NET应用程序Docker化，但是Docker对容器内运行的应用程序应该如何行为有一些简单的期望，以便它们可以充分利用该平台的全部优势。
- en: 'In this chapter we''ll look at how to build applications so that they can take
    complete advantage of the Docker platform, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何构建应用程序，以便它们可以充分利用Docker平台，包括：
- en: The integration points between Docker and your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker与您的应用程序之间的集成点
- en: Configuring your application with config files and environment variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件和环境变量配置您的应用程序
- en: Monitoring applications with health checks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用健康检查监视应用程序
- en: Running distributed solutions with components in different containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同容器中运行分布式解决方案的组件
- en: This will help you develop .NET and .NET Core applications that behave in a
    way Docker expects so that you can manage them fully with Docker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您开发符合Docker期望的.NET和.NET Core应用程序，以便您可以完全使用Docker进行管理。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Building good citizens for Docker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Docker构建良好的应用程序
- en: Separating dependencies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离依赖项
- en: Breaking up monolithic applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分单片应用程序
- en: Building good citizens for Docker
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Docker构建良好的应用程序
- en: The Docker platform makes very few demands on applications which use it. You're
    not restricted to certain languages or frameworks, you don't need to use special
    libraries to communicate between the app and container, and you don't need to
    structure your application in a certain way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台对使用它的应用程序几乎没有要求。您不受限于特定的语言或框架，您不需要使用特殊的库来在应用程序和容器之间进行通信，也不需要以特定的方式构建您的应用程序。
- en: To support the widest possible range of applications, Docker uses the console
    to communicate between the application and the container runtime. Application
    logs and error messages are expected on the console output and error streams.
    Storage managed by Docker is presented as a normal disk to the operating system,
    and Docker's networking stack is transparent. Applications will appear to be running
    on their own machine, connected to other machines by a normal TCP/IP network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持尽可能广泛的应用程序范围，Docker使用控制台在应用程序和容器运行时之间进行通信。应用程序日志和错误消息预期出现在控制台输出和错误流中。由Docker管理的存储被呈现为操作系统的普通磁盘，Docker的网络堆栈是透明的。应用程序将看起来像是在自己的机器上运行，通过普通的TCP/IP网络连接到其他机器。
- en: 'A good citizen for Docker is an app which makes very few assumptions about
    the system it''s running on, and uses basic mechanisms which all operating systems
    support: the filesystem, environment variables, networking, and the console. Most
    importantly, the application should only do one thing. As you''ve seen, when Docker
    runs a container, it starts the process specified in the Dockerfile or the command
    line, and it watches that process. When the process ends, the container exits.
    So ideally you should build your app to have a single process, which ensures Docker
    is watching the process that matters.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的一个良好应用是一个对其运行的系统几乎没有假设，并且使用所有操作系统支持的基本机制：文件系统、环境变量、网络和控制台。最重要的是，应用程序应该只做一件事。正如你所看到的，当Docker运行一个容器时，它启动Dockerfile或命令行中指定的进程，并监视该进程。当进程结束时，容器退出。因此，理想情况下，你应该构建你的应用程序只有一个进程，这样可以确保Docker监视重要的进程。
- en: These are recommendations though, not requirements. You can start multiple processes
    in a bootstrap script when a container starts and Docker will run it happily,
    but it will only monitor the last process that started. Your apps can write log
    entries to local files instead of the console and Docker will still run them,
    but you won't see any output if you use Docker to check the container logs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是建议，而不是要求。当容器启动时，你可以在引导脚本中启动多个进程，Docker会愉快地运行它，但它只会监视最后启动的进程。你的应用程序可以将日志条目写入本地文件，而不是控制台，Docker仍然会运行它们，但如果你使用Docker来检查容器日志，你将看不到任何输出。
- en: In .NET you can easily meet the recommendations by running a console application,
    which provides simplified integration between the application and the host, and
    it's one reason why all .NET Core apps – including websites and Web APIs – run
    as console applications. With legacy .NET apps, you won't be able to make them
    into perfect citizens, but you can take care to package them so that they make
    good use of the Docker platform.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，你可以通过运行控制台应用程序轻松满足建议，这提供了应用程序和主机之间的简化集成，这也是为什么所有.NET Core应用程序（包括网站和Web
    API）都作为控制台应用程序运行的一个原因。对于传统的.NET应用程序，你可能无法使它们成为完美的应用程序，但你可以注意打包它们，以便它们充分利用Docker平台。
- en: Hosting Internet Information Services (IIS) applications in Docker
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中托管Internet信息服务（IIS）应用程序
- en: Complete .NET Framework apps can be easily packaged into Docker images, but
    there are some limitations you need to be aware of. Microsoft provides Nano Server
    and Windows Server Core base images for Docker. The complete .NET Framework doesn't
    run on Nano Server, so to host your existing .NET apps in Docker, you need to
    use the Windows Server Core base image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的.NET Framework应用程序可以轻松打包成Docker镜像，但你需要注意一些限制。微软为Docker提供了Nano Server和Windows
    Server Core基础镜像。完整的.NET Framework无法在Nano Server上运行，因此要在Docker中托管现有的.NET应用程序，你需要使用Windows
    Server Core基础镜像。
- en: 'Running from Windows Server Core means your application images will be around
    4 GB in size, the bulk of which is in the base image. You have a complete Windows
    Server operating system, with all the packages available to enable Windows Server
    features, like **Domain Name System** (**DNS**) and **Dynamic Host Configuration
    Protocol** (**DHCP**), even though you only want to use it for a single application
    role. It''s perfectly reasonable to run containers from Windows Server Core, but
    you need to be aware of the implications:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从Windows Server Core运行意味着您的应用程序镜像大小约为4 GB，其中大部分在基础镜像中。您拥有完整的Windows Server操作系统，所有软件包都可用于启用Windows
    Server功能，如域名系统（DNS）和动态主机配置协议（DHCP），即使您只想将其用于单个应用程序角色。从Windows Server Core运行容器是完全合理的，但您需要了解其影响：
- en: The base image has a large surface area with a lot of software installed, which
    means it's likely to have more frequent security and functional patches.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础镜像具有大量安装的软件，这意味着它可能会有更频繁的安全和功能补丁。
- en: The OS runs a lot of its own processes in addition to your application process,
    as several core parts of Windows run as background Windows services.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统除了您的应用程序进程外，还运行了许多自己的进程，因为Windows的几个核心部分作为后台Windows服务运行。
- en: Windows has its own application platforms, with high-value feature sets for
    hosting and management, which do not natively integrate with the Docker approach.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows拥有自己的应用程序平台，具有高价值的特性集，用于托管和管理，这些特性与Docker方法不会自然集成。
- en: You can take an ASP.NET web application and Dockerize it in a few hours. It
    will build into a large Docker image that takes a little longer to distribute
    and start up than an application built on a lightweight, modern application stack.
    But you'll still have a single package with your whole application deployed, configured,
    and ready to run. This is a big step in improving quality and reducing deployment
    time, and it can be the first part of a program to modernize a legacy application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将ASP.NET Web应用程序Docker化几个小时。它将构建为一个大型Docker镜像，比基于轻量级现代应用程序堆栈构建的应用程序需要更长的时间来分发和启动。但您仍将拥有一个部署、配置和准备运行的整个应用程序的单一软件包。这是提高质量和减少部署时间的重要一步，也可以是现代化传统应用程序计划的第一部分。
- en: To integrate an ASP.NET app more closely with Docker, you can modify how IIS
    logs are written, specify how Docker checks whether the container is healthy,
    and inject configuration into containers without any changes to the application
    code. If changing code is part of your modernization program, then with minimal
    changes, you can use the container's environment variables and filesystem for
    application configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将ASP.NET应用程序与Docker更紧密地集成，可以修改IIS日志的编写方式，指定Docker如何检查容器是否健康，并向容器注入配置，而无需对应用程序代码进行任何更改。如果更改代码是现代化计划的一部分，那么只需进行最小的更改，就可以使用容器的环境变量和文件系统进行应用程序配置。
- en: Configuring IIS for Docker-friendly logging
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Docker友好的日志记录配置IIS
- en: IIS writes log entries to text files, recording HTTP requests and responses.
    You can configure exactly what fields are written, but the default installation
    records useful things like the route of the HTTP request, the response status
    code, and the time taken for IIS to respond. It would be good to surface these
    logs entries to Docker, but IIS manages its own log files, buffering entries before
    writing them to the disk, and rotating log files to manage the disk space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: IIS将日志条目写入文本文件，记录HTTP请求和响应。您可以精确配置要写入的字段，但默认安装记录了诸如HTTP请求的路由、响应状态代码和IIS响应所需的时间等有用信息。将这些日志条目呈现给Docker是很好的，但IIS管理自己的日志文件，将条目缓冲到磁盘之前，并旋转日志文件以管理磁盘空间。
- en: Log management is a fundamental part of application platforms, which is why
    IIS takes care of it for web apps, but Docker has its own logging system. Docker
    logging is far more powerful and pluggable than the text filesystem that IIS uses,
    but it only reads log entries from the container's console output stream. You
    can't have IIS writing logs to the console because it runs in a background Windows
    Service with no console attached, so you need a different approach.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 日志管理是应用程序平台的基本组成部分，这就是为什么IIS为Web应用程序负责，但Docker有自己的日志记录系统。Docker日志记录比IIS使用的文本文件系统更强大和可插拔，但它只从容器的控制台输出流中读取日志条目。您不能让IIS将日志写入控制台，因为它在后台作为Windows服务运行，没有连接到控制台，所以您需要另一种方法。
- en: There are two options for this. The first is to build an HTTP module which plugs
    into the IIS platform with an event handler that receives logs from IIS. This
    handler can publish all messages to a queue or a Windows pipe, so you don't change
    how IIS logs; you just add another log sink. Then, you'd package your web application
    together with a console app that listens for published log entries and relays
    them on the console. The console app would be the entry point when a container
    starts, so every IIS log entry would get routed to the console for Docker to read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种选择。第一种是构建一个HTTP模块，它插入到IIS平台中，具有一个事件处理程序，从IIS接收日志。此处理程序可以将所有消息发布到队列或Windows管道，因此您不会改变IIS日志的方式；您只是添加了另一个日志接收端。然后，您会将您的Web应用程序与一个监听已发布的日志条目并将其中继到控制台的控制台应用程序打包在一起。控制台应用程序将是容器启动时的入口点，因此每个IIS日志条目都会被路由到控制台供Docker读取。
- en: The HTTP module approach is robust and scalable, but it adds more complexity
    than we need when we're getting started. The second option is simpler - configure
    IIS to write all of the log entries to a single text file, and in the startup
    command for the container, run a PowerShell script to watch that file and echo
    new log entries to the console. When the container is running, all the IIS log
    entries get echoed to the console, which surfaces them to Docker.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP模块方法是强大且可扩展的，但在我们刚开始时，它增加了比我们需要的更多复杂性。第二个选项更简单 - 配置IIS将所有日志条目写入单个文本文件，并在容器的启动命令中运行一个PowerShell脚本来监视该文件，并将新的日志条目回显到控制台。当容器运行时，所有IIS日志条目都会回显到控制台，从而将它们呈现给Docker。
- en: 'To set this up in the Docker image, you first need to configure IIS so that
    it writes all of the log entries from any site to a single file, and it lets the
    file grow without rotating it. You can do this with PowerShell, using the `Set-WebConfigurationProperty`
    cmdlet in the Dockerfile, modifying the central logging properties at the application
    host level. I use this cmdlet in the Dockerfile for the `dockeronwindows/ch03-iis-log-watcher`
    image:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker镜像中设置这一点，首先需要配置IIS，使其将任何站点的所有日志条目写入单个文件，并允许文件增长而不进行旋转。您可以在Dockerfile中使用PowerShell来完成这一点，使用`Set-WebConfigurationProperty`
    cmdlet来修改应用程序主机级别的中央日志属性。我在`dockeronwindows/ch03-iis-log-watcher`镜像的Dockerfile中使用了这个cmdlet：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is ugly code, but it shows you can write whatever you need in a Dockerfile
    to set up your application. It configures IIS to log all entries to a file in
    `C:\iislog`, and to set the maximum file size for log rotation, letting the log
    file grow to 4 GB. That's plenty of room to play with - remember, containers are
    not meant to be long-lived, so we shouldn't have gigabytes of log entries in a
    single container. IIS still uses a subdirectory format for the log file, so the
    actual log file path will be `C:\iislog\W3SVC\u_extend1.log`. Now that I have
    a known log file location, I can use PowerShell to echo log entries to the console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是丑陋的代码，但它表明你可以在Dockerfile中编写任何你需要设置应用程序的内容。它配置IIS将所有条目记录到`C:\iislog`中的文件，并设置日志轮换的最大文件大小，让日志文件增长到4GB。这足够的空间来使用
    - 记住，容器不应该长时间存在，所以我们不应该在单个容器中有几GB的日志条目。IIS仍然使用子目录格式来记录日志文件，所以实际的日志文件路径将是`C:\iislog\W3SVC\u_extend1.log`。现在我有了一个已知的日志文件位置，我可以使用PowerShell来回显日志条目到控制台。
- en: 'I do this in the `CMD` instruction, so the final command that Docker runs and
    monitors is the PowerShell cmdlet to echo log entries. When new entries are written
    to the console, they get picked up by Docker. PowerShell makes it easy to watch
    the file, but there''s a complication because the file needs to exist before PowerShell
    can watch it. In the Dockerfile, I run multiple commands in sequence at startup:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`CMD`指令中执行这个操作，所以Docker运行和监控的最终命令是PowerShell的cmdlet来回显日志条目。当新条目被写入控制台时，它们会被Docker捕捉到。PowerShell可以很容易地监视文件，但是有一个复杂的地方，因为文件需要在PowerShell监视之前存在。在Dockerfile中，我在启动时按顺序运行多个命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Four things happen when a container starts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动时会发生四件事情：
- en: Start the IIS Windows service (W3SVC).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动IIS Windows服务（W3SVC）。
- en: Make an HTTP `GET` request to the localhost, which starts the IIS worker process
    and writes the first log entry.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出HTTP `GET`请求到本地主机，启动IIS工作进程并写入第一个日志条目。
- en: Flush the HTTP log buffer, so the log file gets written to the disk and exists
    for PowerShell to watch.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新HTTP日志缓冲区，这样日志文件就会被写入磁盘并存在于PowerShell监视之中。
- en: Read the content of the log file in tail mode, so any new lines written to the
    file are shown on the console.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以尾部模式读取日志文件的内容，这样文件中写入的任何新行都会显示在控制台上。
- en: 'I can run a container from this image in the usual way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以以通常的方式从这个镜像中运行一个容器：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When I send some traffic to the site by browsing to the container''s IP address
    (or using `Invoke-WebRequest` in PowerShell), I can see the IIS log entries that
    are relayed to Docker from the `Get-Content` cmdlet using `docker container logs`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我通过浏览到容器的IP地址（或在PowerShell中使用`Invoke-WebRequest`）发送一些流量到站点时，我可以看到从`Get-Content`
    cmdlet使用`docker container logs`中中继到Docker的IIS日志条目：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'IIS always buffers log entries in the memory before writing them to the disk,
    so it micro-batches writes to improve performance. Flushing happens every 60 seconds,
    or when the buffer is 64 KB in size. If you want to force the IIS log in a container
    to flush, use the same `netsh` command I used in the Dockerfile: `docker container
    exec log-watcher netsh http flush logbuffer`. You''ll see an `Ok` output, and
    new entries will be in `docker container logs`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: IIS始终在将日志条目写入磁盘之前在内存中缓冲日志条目，以提高性能进行微批量写入。刷新每60秒进行一次，或者当缓冲区大小为64KB时。如果你想强制容器中的IIS日志刷新，可以使用与我在Dockerfile中使用的相同的`netsh`命令：`docker
    container exec log-watcher netsh http flush logbuffer`。你会看到一个`Ok`输出，并且新的条目将在`docker
    container logs`中。
- en: I've added the configuration to IIS in the image and a new command, which means
    all IIS log entries get echoed to the console. This will work for any application
    hosted in IIS, so I can echo HTTP logs for ASP.NET applications and static websites
    without any changes to the apps or the site content. Console output is where Docker
    looks for log entries, so this simple extension integrates logging from the existing
    application into the new platform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将配置添加到映像中的IIS和一个新命令，这意味着所有IIS日志条目都会被回显到控制台。这将适用于托管在IIS中的任何应用程序，因此我可以在不更改应用程序或站点内容的情况下回显ASP.NET应用程序和静态网站的HTTP日志。控制台输出是Docker查找日志条目的地方，因此这个简单的扩展将现有应用程序的日志集成到新平台中。
- en: Managing application configuration
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序配置
- en: The goal of packaging applications in Docker images is to use the same image
    in every environment. You don't build separate images for test and production,
    because that would make them separate apps and there could be inconsistencies
    between them. You should deploy your production app from the exact same Docker
    image that was tested by the users, which is the exact same image generated by
    the build process and used for all of your automated integration tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker映像中打包应用程序的目标是在每个环境中使用相同的映像。您不会为测试和生产构建单独的映像，因为这将使它们成为单独的应用程序，并且可能存在不一致性。您应该从用户测试的完全相同的Docker映像部署生产应用程序，这是生成过程生成的完全相同的映像，并用于所有自动集成测试的映像。
- en: Of course, some things need to change between environments – connection strings
    for the database, logging level, and feature switches. This is application configuration,
    and in the Docker world you build your application image with a default set of
    configuration, typically for the development environment.  At runtime you inject
    the correct configuration for the current environment into the container, and
    that overwrites the default configuration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些东西需要在环境之间进行更改 - 数据库的连接字符串，日志级别和功能开关。这是应用程序配置，在Docker世界中，您使用默认配置构建应用程序映像，通常用于开发环境。在运行时，您将当前环境的正确配置注入到容器中，并覆盖默认配置。
- en: There are different approaches to injecting this configuration. In this chapter
    I'll show you how to use volume mounts and environment variables. In production,
    you'll be running a cluster of machines running Docker, and you can store configuration
    data in the cluster's secure database, as Docker config objects or Docker secrets.
    I'll cover this in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml), *Orchestrating
    Distributed Solutions with Docker Swarm*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来注入此配置。在本章中，我将向您展示如何使用卷挂载和环境变量。在生产中，您将运行运行Docker的机器集群，并且可以将配置数据存储在集群的安全数据库中，作为Docker配置对象或Docker秘密。我将在[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)中介绍这一点，*使用Docker
    Swarm编排分布式解决方案*。
- en: Mounting configuration files in Docker volumes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker卷中挂载配置文件
- en: Traditional application platforms use configuration files to change behavior
    between environments. .NET Framework apps have a rich XML-based configuration
    framework, and Java apps commonly use key-value pairs in properties files. You
    can add these configuration files to your application image in a Dockerfile, and
    when you run a container from the image, it will use this default configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的应用程序平台使用配置文件在环境之间更改行为。 .NET Framework应用程序具有丰富的基于XML的配置框架，而Java应用程序通常在属性文件中使用键值对。您可以在Dockerfile中向应用程序映像添加这些配置文件，并且当您从映像运行容器时，它将使用此默认配置。
- en: 'Your application setup should use a specific directory for configuration files,
    and this will let you overwrite them at runtime by mounting a Docker volume. I''ve
    done this with a simple ASP.NET WebForms application in `dockeronwindows/ch03-aspnet-config:2e`.
    The Dockerfile only uses commands you''ve already seen:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序设置应该使用一个特定的目录来存储配置文件，这样可以通过挂载Docker卷在运行时覆盖它们。我已经在`dockeronwindows/ch03-aspnet-config:2e`中使用了一个简单的ASP.NET
    WebForms应用程序。Dockerfile只使用了您已经看到的命令：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This uses Microsoft's ASP.NET image as the base, and copies in my application
    files – an ASPX page and some config files. In this example I'm using the default
    IIS website, which loads content from `C:\inetpub\wwwroot`, so I just have the `COPY`
    instructions in the Dockerfile, I don't need to run any PowerShell scripts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了微软的ASP.NET镜像作为基础，并复制了我的应用程序文件 - 一个ASPX页面和一些配置文件。在这个例子中，我正在使用默认的IIS网站，它从`C:\inetpub\wwwroot`加载内容，所以我只需要在Dockerfile中使用`COPY`指令，而不需要运行任何PowerShell脚本。
- en: 'ASP.NET expects to find the `Web.config` file in the application directory,
    but you can split out sections of config into separate files. I''ve done this
    with the `appSettings ` and `connectionStrings` sections, which are loaded from
    files in a subdirectory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET期望在应用程序目录中找到`Web.config`文件，但您可以将配置的部分拆分成单独的文件。我已经在一个子目录中的文件中做到了这一点，这些文件是从`appSettings`和`connectionStrings`部分加载的：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `config` directory is populated with default configuration files, so I
    can run a container from the image without having to specify any extra settings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`目录填充了默认配置文件，所以我可以从镜像中运行容器，而不需要指定任何额外的设置：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When I fetch the container''s port and browse to it, I see the web page displaying
    values from the default config files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我获取容器的端口并浏览到它时，我看到网页显示来自默认配置文件的值：
- en: '![](Images/c2ba482d-3bc5-451f-af92-3f10af0aebb4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c2ba482d-3bc5-451f-af92-3f10af0aebb4.png)'
- en: 'I can run the app for a different environment by loading configuration files
    from a directory on the host, mounting the local directory as a volume targeting
    `C:\inetpub\wwwroot\config` inside the container. When the container runs, the
    contents of that directory will be loaded from the directory on the host:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过从主机上的目录加载配置文件，将本地目录挂载为一个卷，以`C:\inetpub\wwwroot\config`为目标，来为不同的环境运行应用程序。当容器运行时，该目录的内容将从主机上的目录加载：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I'm using PowerShell to run this command, which expands `$pwd` to the full value
    of the current directory, so I'm saying the `prod-config` directory in the current
    path should be mounted as `C:\inetpub\wwwroot\config` in the container. You can
    use fully-qualified paths too.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用PowerShell来运行这个命令，它会将`$pwd`扩展到当前目录的完整值，所以我在说当前路径中的`prod-config`目录应该被挂载为容器中的`C:\inetpub\wwwroot\config`。您也可以使用完全限定的路径。
- en: 'When I browse to this container''s port, I see different config values displayed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我浏览到这个容器的端口时，我看到不同的配置值显示出来：
- en: '![](Images/a42dd810-c2c0-4f38-9f3b-455b9164f98d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a42dd810-c2c0-4f38-9f3b-455b9164f98d.png)'
- en: The important thing here is that I'm using the exact same Docker image, with
    the same setup and the same binaries in every environment. Only the configuration
    files change, and Docker provides an elegant way of doing this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，我在每个环境中使用完全相同的Docker镜像，具有相同的设置和相同的二进制文件。只有配置文件会改变，Docker提供了一种优雅的方法来做到这一点。
- en: Promoting environment variables
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推广环境变量
- en: Modern apps increasingly use environment variables for configuration settings
    because they're supported by practically every platform, from physical machines
    to PaaS, to serverless functions. All platforms use environment variables in the
    same way – as a store of key-value pairs – so by using environment variables for
    configuration, you make your app highly portable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序越来越多地使用环境变量作为配置设置，因为它们几乎被每个平台支持，从物理机器到PaaS，再到无服务器函数。所有平台都以相同的方式使用环境变量
    - 作为键值对的存储，因此通过使用环境变量进行配置，可以使您的应用程序具有高度的可移植性。
- en: ASP.NET apps already have the rich configuration framework in `Web.config`,
    but with some small code changes, you can take key settings and move them to environment
    variables. This lets you build one Docker image for your app, which you can run
    in different platforms, setting environment variables in containers to change
    configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET应用程序已经在`Web.config`中具有丰富的配置框架，但通过一些小的代码更改，您可以将关键设置移动到环境变量中。这样，您可以为应用程序构建一个Docker镜像，在不同的平台上运行，并在容器中设置环境变量以更改配置。
- en: 'Docker lets you specify environment variables in the Dockerfile and give them
    initial default values. The `ENV` instruction sets environment variables, and
    you can set either one variable or many variables in each `ENV` instruction. The
    following example is from the Dockerfile for `dockeronwindows/ch03-iis-environment-variables:2e`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许您在Dockerfile中指定环境变量并给出初始默认值。`ENV`指令设置环境变量，您可以在每个`ENV`指令中设置一个或多个变量。以下示例来自于`dockeronwindows/ch03-iis-environment-variables:2e`的Dockerfile。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Settings added to the Dockerfile with `ENV` become part of the image, so every
    container you run from the image will have these values set. When you run a container,
    you can add new environment variables or replace the values of existing image
    variables using the `--env` or `-e` option. You can see how environment variables
    work with a simple Nano Server container:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENV`在Dockerfile中添加的设置将成为镜像的一部分，因此您从该镜像运行的每个容器都将具有这些值。运行容器时，您可以使用`--env`或`-e`选项添加新的环境变量或替换现有镜像变量的值。您可以通过一个简单的Nano
    Server容器看到环境变量是如何工作的。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With apps hosted in IIS, there's a complication in using environment variables
    from Docker. When IIS starts it reads all the environment variables from the system
    and caches them. When Docker runs a container with environment variables set,
    it writes them at the process level, but that happens after IIS has cached the
    original values, so they don't get updated and IIS applications won't see the
    new value. IIS doesn't cache machine-level environment variables in the same way
    however, so we can promote the values set by Docker to machine-level environment
    variables, and IIS apps will be able to read them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIS中托管的应用程序使用Docker中的环境变量存在一个复杂性。当IIS启动时，它会从系统中读取所有环境变量并对其进行缓存。当Docker运行具有设置的环境变量的容器时，它会将它们写入进程级别，但这发生在IIS缓存了原始值之后，因此它们不会被更新，IIS应用程序将无法看到新值。然而，IIS并不以相同的方式缓存机器级别的环境变量，因此我们可以将Docker设置的值提升为机器级别的环境变量，这样IIS应用程序就能够读取它们。
- en: 'Promoting environment variables can be done by copying them from the process
    level to the machine level. You can use  a PowerShell script in your container
    startup command, which does it by looping through all process-level variables
    and copying them to the machine level, unless the machine-level key that already
    exists:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 推广环境变量可以通过将它们从进程级别复制到机器级别来实现。您可以在容器启动命令中使用PowerShell脚本，通过循环遍历所有进程级别变量并将它们复制到机器级别，除非机器级别键已经存在。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You don't need to do this if you're using an image based on Microsoft's IIS
    image, because it's done for you with a utility called `ServiceMonitor.exe`, which
    is packaged in the IIS image. ServiceMonitor does three things – it makes process-level
    environment variables available, it starts a background Windows Service, and then
    it watches the service to make sure it keeps running. This means you can use ServiceMonitor
    as the start process for your container, and if the IIS Windows Service fails,
    ServiceMonitor will exit and Docker will see that your application has stopped.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是基于Microsoft的IIS镜像的图像，则无需执行此操作，因为它会为您使用一个名为`ServiceMonitor.exe`的实用程序，该实用程序已打包在IIS镜像中。ServiceMonitor执行三件事——它使进程级环境变量可用，启动后台Windows服务，然后监视服务以确保其保持运行。这意味着您可以使用ServiceMonitor作为容器的启动进程，如果IIS
    Windows服务失败，ServiceMonitor将退出，Docker将看到您的应用程序已停止。
- en: '`ServiceMonitor.exe` is available as a binary file on GitHub, but it''s not
    open source and not all its behavior is documented (it seems to only work for
    the default IIS App Pool). It''s copied into Microsoft''s IIS image and set as
    the `ENTRYPOINT` for containers. The ASP.NET image is based on the IIS image,
    so it also has ServiceMonitor configured.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceMonitor.exe`可以在GitHub上作为二进制文件使用，但它不是开源的，并且并非所有行为都有文档记录（它似乎只适用于默认的IIS应用程序池）。它被复制到Microsoft的IIS镜像中，并设置为容器的`ENTRYPOINT`。ASP.NET镜像是基于IIS镜像构建的，因此它也配置了ServiceMonitor。'
- en: 'If you want to use ServiceMonitor along with your own logic to echo out IIS
    logs, you need to start ServiceMonitor in the background and finish your startup
    command in the Dockerfile with the log read. I do this in `dockeronwindows/ch03-iis-environment-variables:2e`,
    running ServiceMonitor with PowerShell''s `Start-Process` cmdlet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在自己的逻辑中使用ServiceMonitor来回显IIS日志，您需要在后台启动ServiceMonitor，并在Dockerfile中的启动命令中完成日志读取。我在`dockeronwindows/ch03-iis-environment-variables:2e`中使用PowerShell的`Start-Process`命令运行ServiceMonitor：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ENTRYPOINT` and `CMD` instructions both tell Docker how to run your application.
    You can combine them to specify a default entry point and allow users of your
    image to override the command when they start a container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`和`CMD`指令都告诉Docker如何运行您的应用程序。您可以将它们组合在一起，以指定默认的入口点，并允许您的镜像用户在启动容器时覆盖命令。'
- en: 'The application in the image is a simple ASP.NET Web Forms page that lists
    environment variables. I can run this in a container in the usual way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的应用程序是一个简单的ASP.NET Web Forms页面，列出了环境变量。我可以以通常的方式在容器中运行这个应用程序：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the container starts, I can get the container''s port and open a browser
    on the ASP.NET Web Forms page a some simple PowerShell script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/2e618d29-6ac9-4bbd-9146-05ec35667a31.png)'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The website show the default environment variable values from the Docker image
    listed as process-level variables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 网站显示了来自Docker镜像的默认环境变量值，这些值被列为进程级变量：
- en: '![](Images/2e618d29-6ac9-4bbd-9146-05ec35667a31.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: 当容器启动时，我可以获取容器的端口，并在ASP.NET Web Forms页面上打开浏览器，使用一些简单的PowerShell脚本：
- en: 'You can run the same image with different environment variables, overriding
    one of the image variables and adding a new variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的环境变量运行相同的镜像，覆盖其中一个镜像变量并添加一个新变量：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Browse the new container''s port and you''ll see the new values written out
    by the ASP.NET page:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览新容器的端口，您将看到ASP.NET页面写出的新值：
- en: '![](Images/ef181092-bc3c-4348-8c38-689692850087.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ef181092-bc3c-4348-8c38-689692850087.png)'
- en: I've added support for Docker's environment variable management into an IIS
    image now, so ASP.NET apps can use the `System.Environment` class to read the
    configuration settings. I've retained the IIS log echo in this new image, so this
    is a good Docker citizen and now you can configure the application and check the
    logs through Docker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经将对Docker环境变量管理的支持添加到了IIS镜像中，因此ASP.NET应用程序可以使用`System.Environment`类来读取配置设置。我在这个新镜像中保留了IIS日志回显，因此这是一个良好的Docker公民，现在您可以通过Docker配置应用程序并检查日志。
- en: One last improvement I can make is to tell Docker how to monitor the application
    running inside the container, so Docker can determine whether the application
    is healthy and take action if it becomes unhealthy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以做的最后一个改进是告诉Docker如何监视容器内运行的应用程序，以便Docker可以确定应用程序是否健康，并在其变得不健康时采取行动。
- en: Building Docker images that monitor applications
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建监视应用程序的Docker镜像
- en: When I add these new features to the NerdDinner Dockerfile and run a container
    from the image, I'll be able to see the web request and response logs with the
    `docker container logs` command, which relays all of the IIS log entries captured
    by Docker, and I can use environment variables and configuration files to specify
    API keys and database user credentials. This makes running and administering the
    legacy ASP.NET application consistent with how I use any other containerized application
    running on Docker. I can also configure Docker to monitor the container for me,
    so I can manage any unexpected failures.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将这些新功能添加到NerdDinner Dockerfile并从镜像运行容器时，我将能够使用`docker container logs`命令查看Web请求和响应日志，该命令中继了Docker捕获的所有IIS日志条目，并且我可以使用环境变量和配置文件来指定API密钥和数据库用户凭据。这使得运行和管理传统的ASP.NET应用程序与我在Docker上运行的任何其他容器化应用程序的方式一致。我还可以配置Docker来监视容器，以便我可以管理任何意外故障。
- en: Docker provides the ability to monitor an application's health, rather than
    just checking whether the application process is still running, with the `HEALTHCHECK`
    instruction in the Dockerfile. With `HEALTHCHECK` you tell Docker how to test
    whether the application is still healthy. The syntax is similar to the `RUN` and
    `CMD` instructions. You pass in a shell command to execute, which should have
    a return code of `0` if the application is healthy, and `1` if it's not. Docker
    runs a health check periodically when the container is running and emits status
    events if the health of a container changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了监视应用程序健康状况的能力，而不仅仅是检查应用程序进程是否仍在运行，使用Dockerfile中的`HEALTHCHECK`指令。使用`HEALTHCHECK`告诉Docker如何测试应用程序是否仍然健康。语法类似于`RUN`和`CMD`指令。您传递一个要执行的shell命令，如果应用程序健康，则应该返回`0`，如果不健康，则返回`1`。Docker在容器运行时定期运行健康检查，并在容器的健康状况发生变化时发出状态事件。
- en: The simple definition of *healthy* for a web application is the ability to respond
    normally to HTTP requests. Which request you make depends on how thorough you
    want the check to be. Ideally the request should execute key parts of your application,
    so you're confident it is all working correctly. But equally, the request should
    complete quickly and have a minimal compute impact, so processing lots of health
    checks doesn't affect consumer requests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的*健康*的简单定义是能够正常响应HTTP请求。您进行的请求取决于您希望检查的彻底程度。理想情况下，请求应该执行应用程序的关键部分，以便您确信它全部正常工作。但同样，请求应该快速完成并且对计算影响最小，因此处理大量的健康检查不会影响消费者请求。
- en: 'A simple health check for any web application is to just use the `Invoke-WebRequest`
    PowerShell cmdlet to fetch the home page and check whether the HTTP response code
    is `200`, which means the response was successfully received:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Web应用程序的简单健康检查只需使用`Invoke-WebRequest` PowerShell命令来获取主页并检查HTTP响应代码是否为`200`，这意味着成功接收到响应：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For a more complex web application, it can be useful to add a new endpoint specifically
    for health checks. You can add a diagnostic endpoint to APIs and websites that
    exercises some of the core logic of your app and returns a Boolean result to indicate
    whether the app is healthy. You can call this endpoint in the Docker health check
    and check the response content, as well as the status code, in order to give you
    more confidence that the app is working correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的Web应用程序，添加一个专门用于健康检查的新端点可能很有用。您可以向API和网站添加一个诊断端点，该端点执行应用程序的一些核心逻辑并返回一个布尔结果，指示应用程序是否健康。您可以在Docker健康检查中调用此端点，并检查响应内容以及状态码，以便更有信心地确认应用程序是否正常工作。
- en: 'The `HEALTHCHECK` instruction in the Dockerfile is very simple. You can configure
    the interval between checks and the number of checks that can fail before the
    container is considered unhealthy, but to use the default values just specify
    the test script in `HEALTHCHECK CMD`. The following example from the Dockerfile
    for the `dockeronwindows/ch03-iis-healthcheck:2e` image uses PowerShell to make
    a `GET` request to the diagnostics URL and check the response status code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中的`HEALTHCHECK`指令非常简单。您可以配置检查之间的间隔和容器被视为不健康之前可以失败的检查次数，但是要使用默认值，只需在`HEALTHCHECK
    CMD`中指定测试脚本。以下是来自`dockeronwindows/ch03-iis-healthcheck:2e`镜像的Dockerfile的示例，它使用PowerShell向诊断URL发出`GET`请求并检查响应状态码：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I've specified an interval for the health check, so Docker will execute this
    command inside the container every 5 seconds (the default interval is 30 seconds
    if you don't specify one). The health check is very cheap to run as it's local
    to the container, so you can have a short interval like this and catch any problems
    quickly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为健康检查指定了一个间隔，因此Docker将每5秒在容器内执行此命令（如果您不指定间隔，则默认间隔为30秒）。健康检查非常便宜，因为它是本地容器的，所以您可以设置这样的短间隔，并快速捕捉任何问题。
- en: 'The application in this Docker image is an ASP.NET Web API app, which has a
    diagnostics endpoint, and a controller you can use to toggle the health of the
    application. The Dockerfile contains a health check, and you can see how Docker
    uses it when you run a container from that image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此Docker镜像中的应用程序是一个ASP.NET Web API应用程序，其中有一个诊断端点和一个控制器，您可以使用该控制器来切换应用程序的健康状态。Dockerfile包含一个健康检查，当您从该镜像运行容器时，您可以看到Docker如何使用它：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you run `docker container ls` after starting that container, you''ll see
    a slightly different output in the status field, similar to `Up 3 seconds (health:
    starting)`. Docker runs the health check every 5 seconds for this container, so
    at this point, the check hasn''t been run. Wait a little longer and then the status
    will be something like `Up 46 seconds (healthy)`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您在启动该容器后运行`docker container ls`，您会看到状态字段中稍有不同的输出，类似于`Up 3 seconds (health:
    starting)`。Docker每5秒运行一次此容器的健康检查，所以在这一点上，检查尚未运行。稍等一会儿，然后状态将变为类似于`Up 46 seconds
    (healthy)`。'
- en: 'You can check the current health of the API by querying the `diagnostics` endpoint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查询“诊断”端点来检查API的当前健康状况：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the returned content, you''ll see `"Status":"GREEN"` meaning the API is
    healthy. This container will stay healthy until I make a call to the controller
    to toggle the health. I can do that with a `POST` request that sets the API to
    return HTTP status `500` for all subsequent requests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的内容中，您会看到`"Status":"GREEN"`，这意味着API是健康的。直到我调用控制器来切换健康状态之前，这个容器将保持健康。我可以通过一个`POST`请求来做到这一点，该请求将API设置为对所有后续请求返回HTTP状态`500`：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now the application will respond with a 500 response to all the `GET` requests
    that the Docker platform makes, which will fail the healthcheck. Docker keeps
    trying the healthcheck, and if there are three failures in a row then it considers
    the container to be unhealthy. At this point, the status field in the container
    list shows `Up 3 minutes (unhealthy)`. Docker doesn't take automatic action on
    single containers that are unhealthy, so this one is left running and you can
    still access the API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序将对Docker平台发出的所有`GET`请求响应500，这将导致健康检查失败。Docker会继续尝试健康检查，如果连续三次失败，则认为容器不健康。此时，容器列表中的状态字段显示`Up
    3 minutes (unhealthy)`。Docker不会对不健康的单个容器采取自动操作，因此此容器仍在运行，您仍然可以访问API。
- en: Healthchecks are important when you start running containers in a clustered
    Docker environment (which I cover in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm*), and it's good practice
    to include them in all Dockerfiles. Being able to package an application which
    the platform can test for health is a very useful feature - it means that wherever
    you run the app, Docker can keep a check on it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群化的Docker环境中运行容器时，健康检查非常重要（我在[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)中介绍了*使用Docker
    Swarm编排分布式解决方案*），并且在所有Dockerfile中包含它们是一个良好的实践。能够打包一个平台可以测试健康状况的应用程序是一个非常有用的功能
    - 这意味着无论在哪里运行应用程序，Docker都可以对其进行检查。
- en: Now you have all the tools to containerize an ASP.NET application and make it
    a good Docker citizen, integrating with the platform so it can be monitored and
    administered in the same way as other containers. A full .NET Framework application
    running on Windows Server Core can't meet the expectation of running a single
    process, because of all the necessary background Windows services, but you should
    still build container images so they run only one logical function and separate
    any dependencies.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您拥有了所有工具，可以将ASP.NET应用程序容器化，并使其成为Docker的良好组成部分，与平台集成，以便可以像其他容器一样进行监视和管理。在Windows
    Server Core上运行的完整.NET Framework应用程序无法满足运行单个进程的期望，因为所有必要的后台Windows服务，但您仍应构建容器映像，以便它们仅运行一个逻辑功能并分离任何依赖项。
- en: Separating dependencies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离依赖项
- en: 'In the last chapter I Dockerized the legacy NerdDinner app and got it running,
    but without a database. The original application expected to use SQL Server LocalDB
    on the same host where the app is running. LocalDB is an MSI-based installation,
    and I can add it to the Docker image by downloading the MSI and installing it
    with `RUN` commands in the Dockerfile. But this means that when I start a container
    from the image, it has two functions: hosting a web application and running a
    database.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我将传统的NerdDinner应用程序Docker化并使其运行起来，但没有数据库。原始应用程序期望在与应用程序运行的同一主机上使用SQL Server
    LocalDB。LocalDB是基于MSI的安装，我可以通过下载MSI并在Dockerfile中使用`RUN`命令安装它来将其添加到Docker镜像中。但这意味着当我从镜像启动容器时，它具有两个功能：托管Web应用程序和运行数据库。
- en: Having two functions in one container is not a good idea. What would happen
    if you wanted to upgrade your website without changing the database? Or what if
    you needed to do some maintenance on the database, which didn't impact the website?
    What if you need to scale out the website? By coupling the two functions together,
    you've added deployment risk, test effort, and administration complexity, and
    reduced your operational flexibility.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个容器中具有两个功能并不是一个好主意。如果您想要升级网站而不更改数据库会发生什么？或者如果您需要对数据库进行一些维护，而这不会影响网站会发生什么？如果您需要扩展网站呢？通过将这两个功能耦合在一起，您增加了部署风险、测试工作量和管理复杂性，并减少了操作灵活性。
- en: Instead I'm going to package the database in a new Docker image, run it in a
    separate container and use Docker's network layer to access the database container
    from the website container. SQL Server is a licensed product, but the free variant
    is SQL Server Express, which is available from Microsoft as an image on Docker
    Hub and comes with a production license. I can use this as the base for my image,
    building on it to prepare a preconfigured database instance, with the schema deployed
    and ready to connect to the web application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我将把数据库打包到一个新的Docker镜像中，在一个单独的容器中运行它，并使用Docker的网络层从网站容器访问数据库容器。SQL Server是一个有许可的产品，但免费的变体是SQL
    Server Express，它可以从Docker Hub上的微软镜像中获得，并带有生产许可证。我可以将其用作我的镜像的基础，构建它以准备一个预配置的数据库实例，其中架构已部署并准备连接到Web应用程序。
- en: Creating Docker images for SQL Server databases
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SQL Server数据库创建Docker镜像
- en: 'Setting up a database image is just like any other Docker image. I''ll be encapsulating
    the setup tasks in a Dockerfile. Broadly, for a new database, the steps will be:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数据库镜像就像设置任何其他Docker镜像一样。我将把设置任务封装在一个Dockerfile中。总的来说，对于一个新的数据库，步骤将是：
- en: Install SQL Server
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: Configure SQL server
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置SQL Server
- en: Run DDL scripts to create the database schema
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行DDL脚本来创建数据库架构
- en: Run DML scripts to populate static data
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行DML脚本来填充静态数据
- en: This fits in very well with a typical build process using Visual Studio's SQL
    database project type and the Dacpac deployment model. The output from publishing
    the project is a `.dacpac` file which contains the database schema and any custom
    SQL scripts to run. Using the `SqlPackage` tool you can deploy the Dacpac file
    to a SQL Server instance, and it will either create a new database if one doesn't
    exist, or it will upgrade an existing database so the schema matches the Dacpac.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合使用Visual Studio的SQL数据库项目类型和Dacpac部署模型的典型构建过程。从发布项目的输出是一个包含数据库架构和任何自定义SQL脚本的`.dacpac`文件。使用`SqlPackage`工具，您可以将Dacpac文件部署到SQL
    Server实例，它将创建一个新的数据库（如果不存在），或者升级现有的数据库，使架构与Dacpac匹配。
- en: 'This approach is perfect for a custom SQL Server Docker image. I can use multi-stage
    builds again for the Dockerfile, so other users don''t need Visual Studio installed
    to package the database from the source code. This is the first stage of the Dockerfile
    for the `dockeronwindows/ch03-nerd-dinner-db:2e` image:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常适合自定义SQL Server Docker镜像。我可以再次使用多阶段构建来为Dockerfile构建，这样其他用户就不需要安装Visual
    Studio来从源代码打包数据库。这是`dockeronwindows/ch03-nerd-dinner-db:2e`镜像的Dockerfile的第一阶段：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's quite a bit in here, but it's all straightforward. The `builder` stage
    starts from Microsoft's .NET Framework SDK image. That gives me `NuGet` and `MSBuild`,
    but not the dependencies I need to build the SQL Server Dacpac. The first two
    `RUN` instructions install the SQL Server Data Tools and the `SqlPackage` tool.
    I could package this as a separate SQL Server SDK image if I had many database
    projects to containerize.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，但都很简单。`builder`阶段从微软的.NET Framework SDK镜像开始。这给了我`NuGet`和`MSBuild`，但没有我构建SQL
    Server Dacpac所需的依赖项。前两个`RUN`指令安装了SQL Server数据工具和`SqlPackage`工具。如果我有很多数据库项目要容器化，我可以将其打包为一个单独的SQL
    Server SDK镜像。
- en: The rest of the stage just copies in the SQL project source and runs `MSBuild`
    to produce the Dacpac.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段的其余部分只是复制SQL项目源代码并运行`MSBuild`来生成Dacpac。
- en: 'Here''s the second stage of the Dockerfile, which packages the NerdDinner Dacpac
    to run in SQL Server Express:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Dockerfile的第二阶段，它打包了NerdDinner Dacpac以在SQL Server Express中运行：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I'm using my own Docker image with SQL Server Express 2017 installed here. Microsoft
    do have SQL Server images published on Docker Hub for Windows and Linux, but the
    Windows versions haven't been regularly maintained. SQL Server Express is freely
    distributed, so you can package it into your own Docker image (the Dockerfile
    for `dockeronwindows/ch03-sql-server` is on GitHub in the `sixeyed/docker-on-windows`
    repository).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用我自己的Docker镜像，其中安装了SQL Server Express 2017。微软在Docker Hub上发布了用于Windows和Linux的SQL
    Server镜像，但Windows版本并没有定期维护。SQL Server Express是免费分发的，所以你可以将其打包到自己的Docker镜像中（`dockeronwindows/ch03-sql-server`的Dockerfile在GitHub的`sixeyed/docker-on-windows`存储库中）。
- en: There are no new instructions here, beyond what you've seen so far. There's
    a volume set up for the SQL Server data files, and an environment variable to
    set the default data file path to `C:\data`. You'll see that there are no `RUN`
    commands, so I'm not actually setting up the database schema when I build the
    image; I'm just packaging the Dacpac file into the image so I have everything
    I need to create or upgrade the database when the container starts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您迄今为止看到的内容之外，这里没有新的说明。为SQL Server数据文件设置了一个卷，并设置了一个环境变量来将默认数据文件路径设置为`C:\data`。您会看到没有`RUN`命令，所以当我构建镜像时，我实际上并没有设置数据库架构；我只是将Dacpac文件打包到镜像中，这样我就有了创建或升级数据库所需的一切。
- en: In the `CMD` instruction, I run a PowerShell script which sets up the database.
    It's sometimes not a good idea to hide all the startup details in a separate script,
    because that means you can't see from the Dockerfile alone what's going to happen
    when the container runs. But in this case, the startup procedure has quite a few
    functions, and they would make for a huge Dockerfile if we put them all in there.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CMD`指令中，我运行一个设置数据库的PowerShell脚本。有时将所有启动细节隐藏在一个单独的脚本中并不是一个好主意，因为这意味着仅凭Dockerfile就无法看到容器运行时会发生什么。但在这种情况下，启动过程有很多功能，如果我们把它们都放在那里，Dockerfile会变得非常庞大。
- en: The base SQL Server Express image defines an environment variable called `sa_password`
    to set the administrator password. I extend this image and set a default value
    for the variable. I'll use the variable in the same way in order to allow users
    to specify an administrator password when they run the container. The rest of
    the startup script deals with the problem of storing database state in a Docker
    volume.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的SQL Server Express镜像定义了一个名为`sa_password`的环境变量来设置管理员密码。我扩展了这个镜像并为该变量设置了默认值。我将以相同的方式使用该变量，以便允许用户在运行容器时指定管理员密码。启动脚本的其余部分处理了在Docker卷中存储数据库状态的问题。
- en: Managing database files for SQL Server containers
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理SQL Server容器的数据库文件
- en: A database container is like any other Docker container, but with a focus on
    statefulness. You'll want to ensure your database files are stored outside of
    the container, so you can replace the database container without losing any data.
    You can easily do this with volumes as we saw in the last chapter, but there is
    a catch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库容器与任何其他Docker容器一样，但侧重于状态。您需要确保数据库文件存储在容器之外，这样您就可以替换数据库容器而不会丢失任何数据。您可以像我们在上一章中看到的那样轻松地使用卷来实现这一点，但有一个问题。
- en: If you build a custom SQL Server image with a deployed database schema, your
    database files will be inside the image in a known location. You can run a container
    from that image without mounting a volume and it will just work, but the data
    will be stored in the container's writeable layer. If you replace the container
    when you have a database upgrade to perform, then you'll lose all your data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建了一个带有部署的数据库架构的自定义SQL Server镜像，那么您的数据库文件将位于已知位置的镜像中。您可以从该镜像运行一个容器，而无需挂载卷，它将正常工作，但数据将存储在容器的可写层中。如果您在需要执行数据库升级时替换容器，那么您将丢失所有数据。
- en: Instead you can run the container with a volume mounted from the host, mapping
    the expected SQL Server data directory from a host directory, so your files live
    outside of the container in a known location on the host. This way, you can ensure
    your data files are stored somewhere reliable, like in a RAID array on your server.
    But that means you can't deploy the database in the Dockerfile, because the data
    directory will have data files stored in the image, and if you mount a volume
    over the directory these files will be hidden.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用从主机挂载的卷来运行容器，将预期的SQL Server数据目录从主机目录映射到一个已知位置的主机上，这样，您的文件就可以存放在容器之外的主机上。这样，您可以确保您的数据文件存储在可靠的地方，比如在服务器上的RAID阵列中。但这意味着您不能在Dockerfile中部署数据库，因为数据目录将在镜像中存储数据文件，如果您在目录上挂载卷，这些文件将被隐藏。
- en: The SQL Server images from Microsoft deal with this by letting you attach a
    database and log files when it runs, so it works on the basis that you already
    have your database files on the host. In this case, you can use the image directly,
    mount your data folder, and run a SQL Server container with arguments telling
    it which database(s) to attach. This is a very limited approach – it means you
    need to create the database on a different SQL Server instance first, and then
    attach it when you run the container. That doesn't fit with an automated release
    process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的SQL Server镜像通过在运行时附加数据库和日志文件来处理这个问题，因此它的工作原理是您已经在主机上拥有数据库文件。在这种情况下，您可以直接使用该镜像，挂载您的数据文件夹，并使用参数运行SQL
    Server容器，告诉它要附加哪个数据库。这是一个非常有限的方法 - 这意味着您需要首先在不同的SQL Server实例上创建数据库，然后在运行容器时附加它。这与自动化发布流程不符。
- en: For my custom image I want to do something different. The image contains the
    Dacpac, so it has everything it needs to deploy the database. When the container
    starts, I want it to check the data directory, and if it's empty, then I create
    a new database by deploying the Dacpac model. If the database files already exist
    when the container starts, then attach the database files first and upgrade the
    database using the Dacpac model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的自定义镜像，我想做一些不同的事情。镜像包含了Dacpac，因此它具有部署数据库所需的一切。当容器启动时，我希望它检查数据目录，如果它是空的，那么我通过部署Dacpac模型来创建一个新的数据库。如果在容器启动时数据库文件已经存在，则首先附加数据库文件，然后使用Dacpac模型升级数据库。
- en: This approach means you can use the same image to run a fresh database container
    for a new environment, or upgrade an existing database container without losing
    any of its data. This works just as well whether you mount the database directory
    from the host or not, so you can let the user choose how to manage the container
    storage, so the image supports many different scenarios.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法意味着您可以使用相同的镜像在新环境中运行一个新的数据库容器，或者升级现有的数据库容器而不丢失任何数据。无论您是否从主机挂载数据库目录，这都能很好地工作，因此您可以让用户选择如何管理容器存储，因此该镜像支持许多不同的场景。
- en: 'The logic to do this is all in the `Initialize-Database.ps1` PowerShell script,
    which the Dockerfile sets as the entry point for containers. In the Dockerfile,
    I pass the data directory to the PowerShell script in the `data_path` variable,
    and the script checks whether the NerdDinner data (`mdf`) and log (`ldf`) files
    are in that directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的逻辑都在`Initialize-Database.ps1` PowerShell脚本中，Dockerfile将其设置为容器的入口点。在Dockerfile中，我将数据目录传递给PowerShell脚本中的`data_path`变量，并且脚本检查该目录中是否存在NerdDinner数据（`mdf`）和日志（`ldf`）文件：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This script looks complex, but actually, it's just building a `CREATE DATABASE...FOR
    ATTACH` statement, filling in the paths of the MDF data file and LDF log files
    if they exist. Then it invokes the SQL statement, which attaches the database
    files from the external volume as a new database in the SQL Server container.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本看起来很复杂，但实际上，它只是构建了一个`CREATE DATABASE...FOR ATTACH`语句，如果MDF数据文件和LDF日志文件存在，则填写路径。然后它调用SQL语句，将外部卷中的数据库文件作为SQL
    Server容器中的新数据库附加。
- en: 'This covers the scenario where a user runs a container with a volume mount,
    and the host directory already contains data files from a previous container.
    These files are attached, and the database is available in the new container.
    Next, the script uses the `SqlPackage` tool to generate a deployment script from
    the Dacpac. I know the `SqlPackage` tool exists and I know the path to it because
    it''s packaged into my image from the builder stage:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了用户使用卷挂载运行容器的情况，主机目录已经包含来自先前容器的数据文件。这些文件被附加，数据库在新容器中可用。接下来，脚本使用`SqlPackage`工具从Dacpac生成部署脚本。我知道`SqlPackage`工具存在，也知道它的路径，因为它是从构建阶段打包到我的镜像中的：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the database directory was empty when the container started, there's no `NerdDinner`
    database on the container, and `SqlPackage` will generate a script with a set
    of `CREATE` statements to deploy the new database. If the database directory did
    contain files, then the existing database would be attached. In that case `SqlPackage`
    would generate a script with a set of `ALTER` and `CREATE` statements to bring
    the database in line with the Dacpac.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器启动时数据库目录为空，则容器中没有`NerdDinner`数据库，并且`SqlPackage`将生成一个包含一组`CREATE`语句的脚本来部署新数据库。如果数据库目录包含文件，则现有数据库将被附加。在这种情况下，`SqlPackage`将生成一个包含一组`ALTER`和`CREATE`语句的脚本，以使数据库与Dacpac保持一致。
- en: The `deploy.sql` script generated in this step will create the new schema, or
    apply changes to the old schema to upgrade it. The final database schema will
    be the same in both cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步生成的`deploy.sql`脚本将创建新模式，或者对旧模式进行更改以升级它。最终数据库模式在两种情况下都将是相同的。
- en: 'Lastly, the PowerShell script executes the SQL script, passing in variables
    for the database name, file prefixes, and data paths:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PowerShell脚本执行SQL脚本，传入数据库名称、文件前缀和数据路径的变量：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the SQL script runs, the database exists in the container with the schema
    modeled in the Dacpac, which was built from the SQL project in the builder stage
    of the Dockerfile. The database files are in the expected location with the expected
    names, so if this container is replaced with another one from the same image,
    the new container will find the existing database and attach it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQL脚本运行后，数据库在容器中存在，并且其模式与Dacpac中建模的模式相同，Dacpac是从Dockerfile的构建阶段中的SQL项目构建的。数据库文件位于预期位置，并具有预期名称，因此如果用相同镜像的另一个容器替换此容器，新容器将找到现有数据库并附加它。
- en: Running databases in containers
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行数据库
- en: Now I have a database image that can work for new deployments and for upgrades.
    The image can be used by developers who might run it without mounting a volume
    while they're working on a feature, so they can start with a fresh database every
    time they run a container. And the same image can be used in environments where
    the existing database needs to be preserved by running the container with a volume
    that contains the database files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有一个数据库镜像，可以用于新部署和升级。开发人员可以使用该镜像，在他们开发功能时运行它而不挂载卷，这样他们每次运行容器时都可以从一个新的数据库开始。同样的镜像也可以在需要保留现有数据库的环境中使用，通过使用包含数据库文件的卷来运行容器。
- en: 'This is how you run the NerdDinner database in Docker, using the default administrator
    password, with a host directory for the database files, and naming the container
    so that I can access it from other containers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您在Docker中运行NerdDinner数据库的方式，使用默认管理员密码，带有数据库文件的主机目录，并命名容器，以便我可以从其他容器中访问它：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first time you run this container, the Dacpac will run to create the database,
    saving the data and log files in the mounted directory on the host. You can check
    whether the files exist on your host with `ls`, and the output from `docker container
    logs` shows the generated SQL script running, and creating resources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此容器时，Dacpac将运行以创建数据库，并将数据和日志文件保存在主机上的挂载目录中。您可以使用`ls`检查主机上是否存在文件，并且`docker
    container logs`的输出显示生成的SQL脚本正在运行，并创建资源：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `docker container run` command I used also publishes the standard SQL Server
    port `1433`, so you can connect to the database running inside the container remotely
    through a .NET connection, or with **SQL Server Management Studio** (**SSMS**).
    If you already have a SQL Server instance running on your host, you can map the
    container's port `1433` to a different port on the host.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的`docker container run`命令还发布了标准的SQL Server端口`1433`，因此您可以通过.NET连接或**SQL Server
    Management Studio**（**SSMS**）远程连接到容器内运行的数据库。如果您的主机上已经运行了SQL Server实例，您可以将容器的端口`1433`映射到主机上的不同端口。
- en: 'To connect to the SQL Server instance running in the container with SSMS, Visual
    Studio, or Visual Studio Code, use `localhost` as the the server name, select
    SQL Server Authentication, and use the `sa` credentials. I use **SqlElectron**,
    which is a very lightweight SQL database client:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SSMS、Visual Studio或Visual Studio Code连接到运行在容器中的SQL Server实例，请使用`localhost`作为服务器名称，选择SQL
    Server身份验证，并使用`sa`凭据。我使用的是**SqlElectron**，这是一个非常轻量级的SQL数据库客户端：
- en: '![](Images/6fb1e102-ad53-4aca-a138-a1de00d35260.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6fb1e102-ad53-4aca-a138-a1de00d35260.png)'
- en: Then, you can work with the Dockerized database just like any other SQL Server
    database, querying tables and inserting data. From the Docker host machine, you
    use `localhost` as the database server name. By publishing the port, you can access
    the containerized database outside of the host, using the host machine name as
    the server name. Docker will route any traffic on port `1433` into SQL Server
    running on the container.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像处理任何其他SQL Server数据库一样处理Docker化的数据库，查询表并插入数据。从Docker主机机器上，您可以使用`localhost`作为数据库服务器名称。通过发布端口，您可以在主机之外访问容器化的数据库，使用主机机器名称作为服务器名称。Docker将端口`1433`上的任何流量路由到运行在容器上的SQL
    Server。
- en: Connecting to database containers from application containers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序容器连接到数据库容器
- en: 'Docker has a DNS server built into the platform, which is used by containers
    for service discovery. I started the NerdDinner database container with an explicit
    name, and any other containers running in the same Docker network can access this
    container by its name, in exactly the same way as a web server would access a
    remote database server by its DNS hostname:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台内置了一个DNS服务器，容器用它来进行服务发现。我使用了一个显式名称启动了NerdDinner数据库容器，同一Docker网络中运行的任何其他容器都可以通过名称访问该容器，就像Web服务器通过其DNS主机名访问远程数据库服务器一样：
- en: '![](Images/57115c85-6752-43a3-9e3e-9f7c07780995.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/57115c85-6752-43a3-9e3e-9f7c07780995.png)'
- en: This makes application configuration much simpler than a traditional distributed
    solution. Every environment will look the same. In development, integration testing,
    QA, and production, the web container will always connect to a database using
    the `nerd-dinner-db` hostname, which is actually running inside a container. The
    container could be on the same Docker host or a separate machine in a Docker Swarm
    cluster, and that's transparent to the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得应用程序配置比传统的分布式解决方案简单得多。每个环境看起来都是一样的。在开发、集成测试、QA和生产中，Web容器将始终使用`nerd-dinner-db`主机名连接到实际运行在容器内的数据库。容器可以在同一台Docker主机上，也可以在Docker
    Swarm集群中的另一台独立机器上，对应用程序来说是透明的。
- en: Service discovery in Docker isn't for containers only. A container can access
    another server on the network using its hostname. You could run your web application
    in a container, but still have it connected to SQL Server running on a physical
    machine rather than using a database container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的服务发现不仅适用于容器。容器可以使用其主机名访问网络上的另一台服务器。您可以在容器中运行Web应用程序，但仍然让它连接到物理机上运行的SQL
    Server，而不是使用数据库容器。
- en: There's one piece of configuration that could be different for each environment,
    and that's the SQL Server login credentials. In the NerdDinner database image,
    I use the same configuration approach I used earlier in this chapter with `dockeronwindows/ch03-aspnet-config`.
    I've split the `appSettings` and `connectionStrings` sections from `Web.config` into
    separate files, and the Docker image bundles those configuration files with default
    values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境可能有一个不同的配置，那就是SQL Server的登录凭据。在NerdDinner数据库镜像中，我使用了与本章前面的`dockeronwindows/ch03-aspnet-config`相同的配置方法。我已经将`Web.config`中的`appSettings`和`connectionStrings`部分拆分成单独的文件，并且Docker镜像将这些配置文件与默认值捆绑在一起。
- en: Developers can just run a container from the image and it will use the default
    database credentials, which match the default credentials built into the NerdDinner
    database Docker image. In other environments, containers can be run with a volume
    mount, using configuration files on the host server, which specify different application
    settings and database connection strings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以直接从镜像中运行容器，并且它将使用默认的数据库凭据，这些凭据与NerdDinner数据库Docker镜像中内置的默认凭据相匹配。在其他环境中，可以通过在主机服务器上使用配置文件进行卷挂载来运行容器，这些配置文件指定了不同的应用程序设置和数据库连接字符串。
- en: This is a simplified approach to security credentials, which I'm using to show
    how we can make our application more Docker-friendly without changing the code.
    Keeping credentials in a plain-text file on the server isn't a great way to manage
    secrets, and I'll look at this again in Chapter 9, *Understanding the Security
    Risks and Benefits of Docker,* when I cover security in Docker.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的安全凭据方法，我用它来展示如何使我们的应用更加适合Docker，而不改变代码。将凭据保存在服务器上的纯文本文件中并不是管理机密信息的好方法，我将在第9章*了解Docker的安全风险和好处*中再次讨论这个问题，当时我会介绍Docker中的安全性。
- en: 'There are some updates to the Dockerfile for NerdDinner in this chapter. I''ve
    added a health check and the setup to echo logs out from IIS. I still haven''t
    made any functional changes to the NerdDinner code base, only splitting up the
    `Web.config` file and setting the default database connection string to use the
    SQL Server database container. When I run the web application container now, it
    will be able to connect to the database container by name and use the SQL Server
    Express database running in Docker:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对NerdDinner的Dockerfile进行了一些更新。我添加了健康检查和从IIS中输出日志的设置。我仍然没有对NerdDinner代码库进行任何功能性更改，只是将`Web.config`文件拆分，并将默认数据库连接字符串设置为使用运行在Docker中的SQL
    Server数据库容器。现在运行Web应用程序容器时，它将能够通过名称连接到数据库容器，并使用在Docker中运行的SQL Server Express数据库：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can explicitly specify the Docker network a container should join when it's
    created, but on Windows, all containers default to joining the system-created
    Docker network called `nat`. The database container and web container are both
    connected to the `nat` network, so they can reach each other by the container
    name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在创建容器时明确指定Docker网络应加入的容器，但在Windows上，所有容器默认加入名为`nat`的系统创建的Docker网络。数据库容器和Web容器都连接到`nat`网络，因此它们可以通过容器名称相互访问。
- en: 'When the container starts up, I can now open the website using the container''s
    port, click on the Register link, and create an account:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，我现在可以使用容器的端口打开网站，点击注册链接并创建一个账户：
- en: '![](Images/3a32ee44-2cc1-4d04-9244-6d2dd9139dad.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3a32ee44-2cc1-4d04-9244-6d2dd9139dad.png)'
- en: 'The Register page queries the ASP.NET membership database, running in the SQL
    Server container. If the registration page is functioning, then the web application
    has a working connection to the database. I can verify this in Sqlectron, querying
    the `UserProfile` table and seeing the new user row:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注册页面查询运行在SQL Server容器中的ASP.NET成员数据库。如果注册页面正常运行，则Web应用程序与数据库之间存在有效的连接。我可以在Sqlectron中验证这一点，查询`UserProfile`表并查看新用户行：
- en: '![](Images/d293f55f-0ad4-4806-b9a6-f5e771799b2e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d293f55f-0ad4-4806-b9a6-f5e771799b2e.png)'
- en: I've now separated the SQL Server database from the web application, and each
    component is running in a lightweight Docker container. On my development laptop,
    each container uses less than 1% of the host CPU at idle, with the database using
    250 MB of memory, and the web server 70 MB.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已将SQL Server数据库与Web应用程序分离，每个组件都在一个轻量级的Docker容器中运行。在我的开发笔记本上，每个容器在空闲时使用的主机CPU不到1%，数据库使用250MB内存，Web服务器使用70MB。
- en: '`docker container top` shows you information on the processes running inside
    a container, including memory and CPU.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container top`可以显示容器内运行的进程信息，包括内存和CPU。'
- en: Containers are light on resources, so there's no penalty in splitting functional
    units into different containers, then you can scale, deploy, and upgrade these
    components individually.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 容器资源占用较少，因此将功能单元拆分为不同的容器没有任何惩罚，然后可以单独扩展、部署和升级这些组件。
- en: Breaking up monolithic applications
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分单片应用程序
- en: Traditional .NET web applications which rely on a SQL Server database can be
    migrated to Docker with minimal effort and without having to rewrite any application
    code. At this stage in my NerdDinner migration, I have an application Docker image
    and a database Docker image which I can reliably and repeatedly deploy and maintain.
    I also have some beneficial side effects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的依赖于SQL Server数据库的.NET Web应用程序可以以最小的工作量迁移到Docker，而无需重写任何应用程序代码。在我的NerdDinner迁移的这个阶段，我有一个应用程序Docker镜像和一个数据库Docker镜像，我可以可靠地和重复地部署和维护。我还有一些有益的副作用。
- en: Encapsulating the database definition in a Visual Studio project may be a new
    approach, but it adds quality assurance to database scripts and brings the schema
    into the code base, so it can be source-controlled and managed alongside the rest
    of the system. Dacpacs, PowerShell scripts, and Dockerfiles provide a new common
    ground for different IT functions. Development, operations, and database administration
    teams can work together on the same artifacts, using the same language.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio项目中封装数据库定义可能是一种新的方法，但它可以为数据库脚本添加质量保证，并将模式引入代码库，因此可以与系统的其余部分一起进行源代码控制和管理。Dacpacs、PowerShell脚本和Dockerfiles为不同的IT功能提供了一个新的共同基础。开发、运维和数据库管理团队可以共同使用相同的语言在相同的工件上进行工作。
- en: Docker is an enabler for DevOps transitions, but whether or not DevOps is on
    your road map, Docker provides the foundation for fast, reliable releases. To
    make the best use of this, you need to look at breaking down monolithic apps into
    smaller pieces, so you can release high-value components frequently without having
    to do a regression test on the whole of a large application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是DevOps转型的推动者，但无论您的路线图上是否有DevOps，Docker都为快速、可靠的发布提供了基础。为了最大限度地利用这一点，您需要考虑将单片应用程序分解为更小的部分，这样您就可以频繁发布高价值组件，而无需对整个大型应用程序进行回归测试。
- en: Extracting core components from an existing application lets you bring modern,
    lightweight technologies into your system without having to do a large, complex
    rewrite. You can apply microservices architecture principles to an existing solution,
    where you already understand the areas which are worth extracting into their own
    services.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有应用程序中提取核心组件可以在不进行大规模、复杂的重写的情况下将现代、轻量级技术引入您的系统。您可以将微服务架构原则应用于现有解决方案，其中您已经了解了值得提取到自己服务中的领域。
- en: Extracting high-value components from monoliths
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体中提取高价值组件
- en: The Docker platform offers a huge opportunity to modernize legacy applications,
    allowing you to take features out of monoliths and run them in separate containers.
    If you can isolate the logic in a feature, this is also an opportunity to migrate
    it to .NET Core, which lets you package it into a much smaller Docker image.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台为现代化传统应用程序提供了巨大的机会，使您可以将特性从单体中取出并在单独的容器中运行。如果您可以隔离特性中的逻辑，这也是将其迁移到.NET
    Core的机会，这样您可以将其打包成更小的Docker镜像。
- en: Microsoft's road map for .NET Core has seen it adopt more and more functionality
    of the full .NET Framework, but porting parts of a legacy .NET application to
    .NET Core could still be a large undertaking. It's an option worth evaluating,
    but it doesn't have to be part of your modernization approach. The value in breaking
    down the monolith is having features which can be developed, deployed, and maintained
    independently. If those components are using the full .NET Framework, you still
    get those benefits.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的.NET Core路线图已经看到它采用了更多的完整.NET Framework功能，但将传统.NET应用程序的部分移植到.NET Core仍然可能是一项艰巨的任务。这是一个值得评估的选项，但它不必成为您现代化方法的一部分。分解单体的价值在于拥有可以独立开发、部署和维护的功能。如果这些组件正在使用完整的.NET
    Framework，您仍然可以获得这些好处。
- en: The advantage you have when you're modernizing a legacy app is that you already
    understand the feature set. You can identify the high-value functionality in your
    system and start by extracting those features into their own components. Good
    candidates would be features that offer value to the business if they change frequently,
    so new feature requests can be rapidly built and deployed without modifying and
    testing the whole application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现代化传统应用程序时的优势在于您已经了解了功能集。您可以识别系统中的高价值功能，并从中提取这些功能到它们自己的组件中。优秀的候选对象将是那些如果频繁更改就能为业务提供价值的功能，因此新的功能请求可以快速构建和部署，而无需修改和测试整个应用程序。
- en: Equally good candidates are features that offer value to IT if they stay the
    same – complex components with a lot of dependencies which the business doesn't
    change often. Extracting such a feature into a separate component means you can
    deploy upgrades to the main application without having to test the complex component
    because it remains unchanged. Breaking up a monolith like this gives you a set
    of components that each have their own delivery cadence.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样优秀的候选特性是那些如果保持不变就能为IT提供价值的特性-具有许多依赖关系的复杂组件，业务很少改变。将这样的特性提取到一个单独的组件中意味着您可以部署主应用程序的升级，而无需测试复杂组件，因为它保持不变。像这样分解单体应用程序会给您一组具有自己交付节奏的组件。
- en: 'In NerdDinner, there are some good candidates to break out into their own services.
    In the rest of this chapter, I''ll focus on one of them: the home page. The home
    page is the feature that renders the HTML for the first page of the application.
    A process to deploy changes to the home page quickly and safely in production
    will let the business experiment with a new look and feel, evaluate the impact
    of the new version, and decide whether to continue with it.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在NerdDinner中，有一些很适合分离成自己的服务的候选项。在本章的其余部分，我将专注于其中之一：主页。主页是渲染应用程序第一页的HTML的功能。在生产环境中快速而安全地部署主页更改的过程将让业务能够尝试新的外观和感觉，评估新版本的影响，并决定是否继续使用它。
- en: 'The current application is distributed between two containers. For this part
    of this chapter, I''ll break the home page out into its own component, so the
    whole NerdDinner app will run across three containers:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序分布在两个容器之间。在本章的这一部分，我将把主页分离成自己的组件，这样整个NerdDinner应用程序将在三个容器中运行：
- en: '![](Images/d7df03c2-ff8d-42c1-ae41-cda4c2ad0df0.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d7df03c2-ff8d-42c1-ae41-cda4c2ad0df0.png)'
- en: 'I won''t change the routing for the application. Users will still come to the
    NerdDinner application first, and the application container will call the new
    home page service container to get the content to appear. This way I don''t need
    to expose the new container publicly. There is only one technical requirement
    for the change: the main application needs to be able to communicate with the
    new homepage service component.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会改变应用程序的路由。用户仍然会首先进入NerdDinner应用程序，然后应用程序容器将调用新的主页服务容器以获取内容显示。这样我就不需要公开新的容器。更改只有一个技术要求：主应用程序需要能够与新的主页服务组件通信。
- en: You're free to choose how applications in containers communicate. Docker networking
    gives you full protocol support for TCP/IP and UDP. You could make the whole process
    asynchronous, running a message queue in another container, with message handlers
    listening in other containers. But I'll start with something simpler in this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由选择容器中应用程序的通信方式。Docker网络为TCP/IP和UDP提供了完整的协议支持。您可以使整个过程异步运行，将消息队列放在另一个容器中，并在其他容器中监听消息处理程序。但是在本章中，我将从更简单的方式开始。
- en: Hosting a UI component in an ASP.NET Core application
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ASP.NET Core应用程序中托管UI组件
- en: ASP.NET Core is a modern application stack which delivers the best of ASP.NET
    MVC and Web API in a fast and lightweight runtime. ASP.NET Core websites run as
    console applications, they write logs to the console output stream, and they can
    use environment variables and files for configuration. The architecture makes
    them good Docker citizens out of the box.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是一个现代的应用程序堆栈，它在快速而轻量的运行时中提供了ASP.NET MVC和Web API的最佳功能。ASP.NET Core网站作为控制台应用程序运行，它们将日志写入控制台输出流，并且它们可以使用环境变量和文件进行配置。这种架构使它们成为优秀的Docker公民。
- en: 'The easiest way to extract the NerdDinner home page into a new service is to
    write it as an ASP.NET Core website with a single page and relay the new application''s
    output from the existing application. The following screenshot shows my stylish,
    modern redesign of the home page running in ASP.NET Core Razor Pages in Docker:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将NerdDinner主页提取为一个新的服务的最简单方法是将其编写为一个ASP.NET Core网站，具有单个页面，并从现有应用程序中中继新应用程序的输出。以下屏幕截图显示了我在Docker中使用ASP.NET
    Core Razor Pages运行的时尚、现代化的主页重新设计：
- en: '![](Images/76fda9ae-bd4e-4b22-894c-26fef2521d7a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/76fda9ae-bd4e-4b22-894c-26fef2521d7a.png)'
- en: To package the home page application as a Docker image I'm using the same multi-stage
    build approach I used for the main application and the database images. In [Chapter
    10](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml), *Powering a Continuous Deployment
    Pipeline with Docker,* you'll see how to use Docker to power a CI/CD build pipeline
    and tie the whole automated deployment process together.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将主页应用程序打包为Docker镜像，我正在使用与主应用程序和数据库镜像相同的多阶段构建方法。在[第10章](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml)中，*使用Docker支持持续部署流水线*，您将看到如何使用Docker来支持CI/CD构建流水线，并将整个自动化部署过程联系在一起。
- en: 'The Dockerfile for the `dockeronwindows/ch03-nerd-dinner-homepage:2e` image
    uses the same pattern I have for the full ASP.NET application. The builder stages
    uses the SDK image and separates the package restore and the compilation steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockeronwindows/ch03-nerd-dinner-homepage:2e`镜像的Dockerfile使用了与完整ASP.NET应用程序相同的模式。构建器阶段使用SDK镜像并分离包恢复和编译步骤：'
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final stage of the Dockerfile provides a default value for the `NERD_DINNER_URL`
    environment variable. The application uses it as the target for the link on the
    home page. The rest of the Dockerfile instructions just copy in the published
    application and set up the entry point:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的最后阶段为`NERD_DINNER_URL`环境变量提供了默认值。应用程序将其用作主页上链接的目标。 Dockerfile的其余指令只是复制已发布的应用程序并设置入口点：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I can run the home page component in a separate container, but it's not connected
    to the main NerdDinner app yet. With the approach I've taken in this chapter,
    I need to make a code change to the original app in order to integrate the new
    home page service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在单独的容器中运行主页组件，但它尚未连接到主NerdDinner应用程序。使用本章中采用的方法，我需要对原始应用程序进行代码更改，以便集成新的主页服务。
- en: Connecting to application containers from other application containers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他应用程序容器连接到应用程序容器
- en: 'Calling the new home page service from the main application container is fundamentally
    the same as connecting to the database: I will run the home page container with
    a known name, and I can access the service in other containers using its name
    and Docker''s built-in service discovery.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从主应用程序容器调用新主页服务基本上与连接到数据库相同：我将使用已知名称运行主页容器，并且可以使用其名称和Docker内置服务发现在其他容器中访问服务。
- en: 'A simple change to the `HomeController` class in the main NerdDinner application
    will relay the response from the new home page service instead of rendering the
    page from the main application:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在主NerdDinner应用程序的`HomeController`类中进行简单更改，将从新主页服务中继承响应，而不是从主应用程序呈现页面：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the new code I get the URL for the home page service from an environment
    variable. Just as with the database connection, I can set a default value for
    that in the Dockerfile. This would be bad practice in a distributed application
    where we can't guarantee where the components are running, but, in a Dockerized
    application I can do it safely because I will control the names of the containers,
    so I can be sure the service names are correct when I deploy them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我从环境变量中获取主页服务的URL。与数据库连接一样，我可以在Dockerfile中为其设置默认值。在分布式应用程序中，这将是不好的做法，因为我们无法保证组件在何处运行，但是在Docker化应用程序中，我可以安全地这样做，因为我将控制容器的名称，因此在部署它们时，我可以确保服务名称是正确的。
- en: 'I''ve tagged this updated image as `dockeronwindows/ch03-nerd-dinner-web:2e-v2`.
    To start the whole solution now, I need to run three containers:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将此更新的镜像标记为`dockeronwindows/ch03-nerd-dinner-web:2e-v2`。现在，要启动整个解决方案，我需要运行三个容器：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the containers are running, I browse to the NerdDinner container''s published
    port, and I see the home page from the new component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器正在运行时，我浏览到NerdDinner容器的发布端口，我可以看到来自新组件的主页：
- en: '![](Images/f9efcc3f-8948-422d-84bb-56c6411792bb.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f9efcc3f-8948-422d-84bb-56c6411792bb.png)'
- en: The Find Dinner link takes me back to the original web app, and now I can iterate
    over the home page and release a new UI just by replacing that container – without
    releasing or testing the rest of the app.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: “找晚餐”链接将我带回原始的Web应用程序，现在我可以在主页上迭代并通过替换该容器发布新的用户界面 - 而无需发布或测试应用程序的其余部分。
- en: What happened to the new UI? In this simple example, the integrated home page
    doesn't have the styling of the new ASP.NET Core version because the main application
    only reads the HTML for the page, not the CSS files or other assets. A better
    approach would be to run a reverse proxy in a container and use that as the entry
    point to other containers, so each container serves all its assets. I'll do that
    later in the book.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 新的用户界面发生了什么？在这个简单的例子中，集成的主页没有新的ASP.NET Core版本的样式，因为主应用程序只读取页面的HTML，而不是CSS文件或其他资产。更好的方法是在容器中运行反向代理，并将其用作其他容器的入口点，这样每个容器都可以提供所有资产。我会在书中稍后做到这一点。
- en: Now that I have my solution split across three containers, I've dramatically
    improved flexibility. At build time I can focus on features that give the highest
    value without expending effort to test components that haven't changed. At deployment
    time, I can release quickly and confidently, knowing that the new image we push
    to production will be exactly what was tested. Then at runtime, I can scale components
    independently according to their requirements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的解决方案分布在三个容器中，我大大提高了灵活性。在构建时，我可以专注于提供最高价值的功能，而不必费力测试未更改的组件。在部署时，我可以快速而自信地发布，知道我们推送到生产环境的新镜像将与测试的内容完全相同。然后在运行时，我可以根据其要求独立地扩展组件。
- en: I do have a new non-functional requirement, which is to ensure that all the
    containers have the expected names, are started in the correct order, and are
    in the same Docker network, so the solution as a whole works correctly. Docker
    has support for this, which is focused on organizing distributed systems with
    Docker Compose. I'll show you this in [Chapter 6](83637474-1791-48b6-8ce1-5aa07f00b46c.xhtml),
    *Organizing Distributed Solutions with Docker Compose.*
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实有一个新的非功能性要求，那就是确保所有容器都具有预期的名称，按正确的顺序启动，并且在同一个Docker网络中，以便整个解决方案正常工作。Docker对此提供了支持，重点是使用Docker
    Compose组织分布式系统。我会在[第6章](83637474-1791-48b6-8ce1-5aa07f00b46c.xhtml)中向您展示这一点，*使用Docker
    Compose组织分布式解决方案*。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered three main topics. First, we covered containerizing
    legacy .NET Framework applications so that they are good Docker citizens and integrate
    with the platform for configuration, logging, and monitoring.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了三个主要主题。首先，我们介绍了将传统的.NET Framework应用程序容器化，使其成为良好的Docker公民，并与平台集成以进行配置、日志记录和监视。
- en: Then we covered containerizing database workloads with SQL Server Express and
    the Dacpac deployment model, building a versioned Docker image that can run a
    container as a new database or upgrade an existing database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了如何使用SQL Server Express和Dacpac部署模型将数据库工作负载容器化，构建一个版本化的Docker镜像，可以将容器作为新数据库运行，或升级现有数据库。
- en: Finally we showed how to extract functionality from monolithic apps into separate
    containers, using ASP.NET Core and Windows Nano Server to package a fast, lightweight
    service that the main application consumes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了如何将单片应用程序的功能提取到单独的容器中，使用ASP.NET Core和Windows Nano Server打包一个快速、轻量级的服务，主应用程序可以使用。
- en: You've learned how to use more images from Microsoft on Docker Hub and how to
    use Windows Server Core for full .NET applications, SQL Server Express for databases,
    and the Nano Server flavors of the .NET Core image.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何在Docker Hub上使用来自Microsoft的更多图像，以及如何为完整的.NET应用程序使用Windows Server Core，为数据库使用SQL
    Server Express，以及.NET Core图像的Nano Server版本。
- en: In later chapters I'll return to NerdDinner and continue to modernize it by
    extracting features into dedicated services. Before that, in the next chapter,
    I'll look more closely at using Docker Hub and other registries to store images.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我会回到NerdDinner，并继续通过将功能提取到专用服务中来使其现代化。在那之前，在下一章中，我会更仔细地研究如何使用Docker
    Hub和其他注册表来存储镜像。
