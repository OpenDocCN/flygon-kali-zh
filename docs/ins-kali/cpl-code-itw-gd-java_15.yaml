- en: '*Chapter 12*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第12章*：'
- en: Stacks and Queues
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和队列
- en: This chapter covers the most popular interview coding challenges involving stacks
    and queues. Mainly, you will learn how to provide a stack/queue implementation
    from scratch and how to tackle coding challenges via Java's built-in implementations,
    such as the `Stack` class, and the `Queue` interface implementations, especially
    `ArrayDeque`. Commonly, a coding challenge from this category will ask you to
    build a stack/queue or will ask you to solve a certain problem using Java's built-in
    implementations. Depending on the problem, it may explicitly disallow you to call
    certain built-in methods that will lead you to finding an easy solution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了涉及栈和队列的最受欢迎的面试编码挑战。主要是，您将学习如何从头开始提供栈/队列实现，以及如何通过Java的内置实现来解决编码挑战，例如`Stack`类和`Queue`接口实现，特别是`ArrayDeque`。通常，此类别的编码挑战将要求您构建栈/队列，或者要求您使用Java的内置实现解决特定问题。根据问题的不同，它可能明确禁止您调用某些内置方法，这将导致您找到一个简单的解决方案。
- en: By the end of this chapter, you'll have a deep insight into stacks and queues,
    you'll be able to exploit their capabilities, and also recognize and write solutions
    that depend on stacks and queues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将深入了解栈和队列，能够利用它们的功能，并且能够识别和编写依赖于栈和队列的解决方案。
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Stacks in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述栈
- en: Queues in a nutshell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述队列
- en: Coding challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Let's start by briefly covering the data structures of stacks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先简要介绍栈的数据结构。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code files presented in this chapter are available on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提供的所有代码文件都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12)。
- en: Stacks in a nutshell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述栈
- en: A stack is a linear data structure that uses the **Last-In-First-Out** (**LIFO**)
    principle. Think of a stack of plates that needs to be washed. You take the first
    plate from the top (which was the last one to be added) and you wash it. Afterward,
    you take the next plate from the top and so on. This is exactly what a real-life
    stack is (for example, a stack of plates, a stack of books, a stack of CDs, and
    so on).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种使用**后进先出**（**LIFO**）原则的线性数据结构。想象一堆需要清洗的盘子。您从顶部取出第一个盘子（最后添加的盘子），然后清洗它。然后，您从顶部取出下一个盘子，依此类推。这正是现实生活中的栈（例如，一堆盘子，一堆书，一堆CD等）。
- en: So, technically speaking, in a stack, the elements are only added (known as
    the **push** operation) and removed (known as the **pop** operation) to/from one
    end of it (known as the **top**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从技术上讲，在栈中，元素只能从一端添加（称为**push**操作）和移除（称为**pop**操作）（称为**top**）。
- en: 'The most common operations that are performed in a stack are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈中执行的最常见操作如下：
- en: '`push(E e)`: Adds an element to the top of the stack'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push(E e)`: 将元素添加到栈的顶部'
- en: '`E pop()`: Removes the top element from the stack'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E pop()`: 移除栈顶的元素'
- en: '`E peek()`: Returns (but doesn''t remove) the top element from the stack'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E peek()`: 返回（但不移除）栈顶的元素'
- en: '`boolean isEmpty()`: Returns `true` if the stack is empty'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEmpty()`: 如果栈为空则返回`true`'
- en: '`int size()`: Returns the size of the stack'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int size()`: 返回栈的大小'
- en: '`boolean isFull()`: Returns `true` if the stack is full'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isFull()`: 如果栈已满则返回`true`'
- en: 'Unlike an array, a stack does not provide access to the *n*th element in constant
    time. However, it does provide constant time for adding and removing elements.
    A stack can be implemented on top of an array or even on top of a linked list.
    The implementation that''s being used here is based on an array and is named `MyStack`.
    The stub of this implementation is listed here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，栈不以常数时间提供对第n个元素的访问。但是，它确实提供了添加和移除元素的常数时间。栈可以基于数组甚至基于链表实现。这里使用的实现是基于数组的，并命名为`MyStack`。该实现的存根如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pushing an element into a stack means adding that element to the end of the
    underlying array. Before pushing an element, we have to ensure that the stack
    is not full. If it is full, then we can signal this via a message/exception, or
    we can increase its capacity, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素推入栈意味着将该元素添加到基础数组的末尾。在推入元素之前，我们必须确保栈不是满的。如果满了，我们可以通过消息/异常来表示这一点，或者我们可以增加其容量，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, every time we reach the stack''s capacity, we double its size.
    Popping an element from the stack means that we return the element that was last
    added to the underlying array. This element is removed from the underlying array
    by nullifying the last index, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每当我们达到栈的容量时，我们都会将其大小加倍。从栈中弹出一个元素意味着我们返回最后添加到基础数组中的元素。通过将最后一个索引置空来从基础数组中移除该元素，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Peeking an element from a stack means returning the element that was added
    last to the underlying array but without removing it from this array:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中查看元素意味着返回最后添加到基础数组中的元素，但不从该数组中移除它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since this implementation can represent the coding challenge you may face in
    an interview, it is advised that you take your time and dissect its code. The
    complete application is called *MyStack*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此实现可能代表您在面试中可能遇到的编码挑战，建议您花时间分析其代码。完整的应用程序称为*MyStack*。
- en: Queues in a nutshell
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述队列
- en: A queue is a linear data structure that uses the **First-In-First-Out** (**FIFO**)
    principle. Think of people standing in a queue to buy stuff. You can also imagine
    ants that are walking in a queue formation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一种使用**先进先出**（**FIFO**）原则的线性数据结构。想象排队购物的人。您还可以想象成蚂蚁在队列中行走。
- en: So, technically speaking, the elements are removed from the queue in the same
    order that they are added. In a queue, the elements added at one end referred
    to as the rear (this operation is known as the enqueue operation) and removed
    from the other end referred to as the front (this operation is known as the dequeue
    or poll operation).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从技术上讲，元素的移除顺序与它们添加的顺序相同。在队列中，添加到一端的元素称为后端（这个操作称为入队操作），从另一端移除的元素称为前端（这个操作称为出队或轮询操作）。
- en: 'The common operations in a queue are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的常见操作如下：
- en: '`enqueue(E e)`: Adds an element to the rear of the queue'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue(E e)`: 将元素添加到队列的末尾'
- en: '`E dequeue()`: Removes and returns the element from the front of the queue'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E dequeue()`: 删除并返回队列前面的元素'
- en: '`E peek()`: Returns (but doesn''t remove) the element from the front of the
    queue'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E peek()`: 返回（但不删除）队列前面的元素'
- en: '`boolean isEmpty()`: Returns `true` if the queue is empty'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEmpty()`: 如果队列为空则返回`true`'
- en: '`int size()`: Returns the size of the queue'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int size()`: 返回队列的大小'
- en: '`boolean isFull()` : Returns `true` if the queue is full'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isFull()`：如果队列已满则返回`true`'
- en: 'Unlike an array, a queue does not provide access to the *n*th element in constant
    time. However, it does provide constant time for adding and removing elements.
    A queue can be implemented on top of an array or even on top of a linked list
    or a stack (which is built on top of an array or a linked list). The implementation
    used here is based on an array and is named `MyQueue`. The stub of this implementation
    is listed here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，队列不提供以常量时间访问第n个元素的功能。但是，它确实提供了添加和删除元素的常量时间。队列可以基于数组实现，甚至可以基于链表或堆栈（堆栈是基于数组或链表构建的）实现。这里使用的实现是基于数组的，并且命名为`MyQueue`。这个实现的存根在这里列出：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Enqueuing an element into a queue means adding this element to the end of the
    underlying array. Before enqueuing an element, we have to ensure that the queue
    is not full. If it is full, then we can signal this via a message/exception, or
    we can increase its capacity, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素加入队列意味着将该元素添加到底层数组的末尾。在将元素加入队列之前，我们必须确保队列不是满的。如果满了，我们可以通过消息/异常来表示，或者我们可以增加其容量，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Dequeuing an element from a queue means returning the next element from the
    beginning of the underlying array. This element is removed from the array:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中出列一个元素意味着从底层数组的开头返回下一个元素。该元素从数组中删除：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Peeking an element from a queue means returning the next element from the beginning
    of the underlying array without removing it from the array:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中窥视一个元素意味着从底层数组的开头返回下一个元素，而不将其从数组中删除：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since this implementation can represent the coding challenge you may face in
    an interview, it is advised that you take your time and dissect its code. The
    complete application is called *MyQueue*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现可以代表你在面试中可能遇到的编码挑战，建议你花时间来分析它的代码。完整的应用程序称为*MyQueue*。
- en: Coding challenges
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: In the next 11 coding challenges, we will cover the most popular problems involving
    stacks and queues that have appeared in interviews in the past few years in a
    wide range of companies that hire Java developers. One of the most common problems,
    *Implementing three stacks with one array*, was covered in [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的11个编码挑战中，我们将涵盖在过去几年中出现在面试中的涉及栈和队列的最流行问题，这些问题涉及到各种雇佣Java开发人员的公司。其中最常见的问题之一，*使用一个数组实现三个栈*，在[*第10章*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*，数组和字符串*中有所涉及。
- en: The solutions to the following coding challenges rely on the Java built-in `Stack`
    and `ArrayDeque` APIs. So, let's get started!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编码挑战的解决方案依赖于Java内置的`Stack`和`ArrayDeque`API。所以，让我们开始吧！
- en: Coding challenge 1 – Reverse string
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - 反转字符串
- en: '**Problem**: Consider you''ve been given a string. Use a stack to reverse it.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个字符串。使用堆栈将其反转。'
- en: '**Solution**: Reversing a string using a stack can be done as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：使用堆栈反转字符串可以按以下方式完成：'
- en: Loop the string from left to right and push each character into the stack.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右循环字符串，并将每个字符推入堆栈。
- en: Loop the stack and pop the characters one by one. Each popped character is put
    back into the string.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环堆栈并逐个弹出字符。每个弹出的字符都放回字符串中。
- en: 'The code based on these two steps is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两个步骤的代码如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete application is called *StackReverseString*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*StackReverseString*。
- en: Coding challenge 2 – Stack of curly braces
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 大括号堆栈
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`String` containing curly braces. Write a snippet of code that returns `true`
    if there are matching pairs of curly braces. If we can find a closing curly brace
    for an opening one in the proper order, then we can say that we have a matching
    pair. For example, a string containing matching pairs looks like this: {{{}}}{}{{}}.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 包含大括号的字符串。编写一小段代码，如果有匹配的大括号对，则返回`true`。如果我们可以找到适当顺序的闭合大括号来匹配开放的大括号，那么我们可以说有一个匹配的对。例如，包含匹配对的字符串如下：{{{}}}{}{{}}。
- en: '`false`. Second, if their number is equal, then they must be in the proper
    order; otherwise, we return `false`. By the proper order, we understand that the
    last opened curly brace is the first one to be closed, the one prior to the last
    is the second to be closed, and so on. If we rely on a stack, then we can elaborate
    on the following algorithm:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`。其次，如果它们的数量相等，则它们必须按适当的顺序；否则，我们返回`false`。按适当的顺序，我们理解最后打开的大括号是第一个关闭的，倒数第二个是第二个关闭的，依此类推。如果我们依赖于堆栈，那么我们可以详细说明以下算法：'
- en: 'For each character of the given string, take one of the following decisions:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于给定字符串的每个字符，做出以下决定之一：
- en: a. If the character is an opening curly brace, {, then put it on the stack.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果字符是一个开放的大括号，{，那么将其放入堆栈。
- en: 'b. If the character is a closing curly brace, }, then do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果字符是闭合大括号，}，则执行以下操作：
- en: i. Check the top of stack, and if it is {, pop and move it to the next character.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: i. 检查堆栈顶部，如果是{，则弹出并将其移动到下一个字符。
- en: ii. If it is not {, then return `false`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ii. 如果不是{，则返回`false`。
- en: If the stack is empty, return `true` (we found all pairs); otherwise, return
    `false` (the stack contains curly braces that do not match).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果堆栈为空，则返回`true`（我们找到了所有配对）；否则返回`false`（堆栈包含不匹配的大括号）。
- en: 'Putting these steps into code results in the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤转化为代码，结果如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *StackBraces*. Challenge yourself by implementing
    a similar problem but for multiple types of parentheses (for example, allow ()
    {} [] in the same given string).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*StackBraces*。通过实现类似的问题，但是对于多种类型的括号（例如，在相同的给定字符串中允许(){}[]），来挑战自己。
- en: Coding challenge 3 – Stack of plates
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战3 - 堆叠盘
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`push()` and `pop()` methods will work like there is a single stack. Additionally,
    write a `popAt(int stackIndex)` method that pops a value from the stack, as indicated
    via `stackIndex`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`和`pop()`方法将像单个堆栈一样工作。另外，编写一个`popAt(int stackIndex)`方法，它会从堆栈中弹出一个值，如`stackIndex`所示。'
- en: '**Solution**: We know how to deal with a single stack, but how do we link multiple
    stacks together? Well, since we have to *link*, how about a linked list? If the
    linked list contains a stack in each node, then the next pointer of a node will
    point to the next stack. The following diagram visualizes this solution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们知道如何处理单个堆栈，但是如何将多个堆栈链接在一起呢？嗯，既然我们需要*链接*，那么链表怎么样？如果链表中每个节点都包含一个堆栈，那么节点的下一个指针将指向下一个堆栈。以下图表可视化了这个解决方案：'
- en: '![Figure 12.1 – Linked list of stacks'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 - 堆栈的链表'
- en: '](img/Figure_12.1_B15403.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B15403.jpg)'
- en: Figure 12.1 – Linked list of stacks
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 堆栈的链表
- en: 'Whenever the current stack capacity is exceeded, we create a new node and append
    it to the linked list. Java''s built-in linked list (`LinkedList`) gives us access
    to the last node via the `getLast()` method. In other words, via `LinkedList#getLast()`,
    we can easily operate on the current stack (for example, we can push or pop an
    element). Adding a new stack is quite simple via the `LinkedList#add()` method.
    Based on these statements, we can implement the `push()` method, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当当前堆栈容量超过时，我们就创建一个新节点并将其附加到链表中。Java的内置链表（`LinkedList`）通过`getLast()`方法使我们可以访问最后一个节点。换句话说，通过`LinkedList#getLast()`，我们可以轻松操作当前堆栈（例如，我们可以推送或弹出一个元素）。通过`LinkedList#add()`方法很容易添加一个新的堆栈。基于这些语句，我们可以实现`push()`方法，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to pop an element, then we have to do so from the last stack, so
    `LinkedList#getLast()` is very handy here. The corner-case here is represented
    by the moment we pop the last element from the last stack. When this happens,
    we must remove the last stack, in which case the one before the last (if any)
    will become the last. The following code speaks for itself:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要弹出一个元素，那么我们必须从最后一个堆栈中这样做，所以`LinkedList#getLast()`在这里非常方便。这里的特殊情况是当我们从最后一个堆栈中弹出最后一个元素时。当这种情况发生时，我们必须删除最后一个堆栈，在这种情况下，倒数第二个（如果有的话）将成为最后一个。以下代码说明了这一点：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let''s focus on implementing the `popAt(int stackIndex)` method. We
    can pop from the `stackIndex` stack by simply calling `stacks.get(stackIndex).pop()`.
    Once we''ve popped an element, we must shift the remaining elements. The bottom
    element of the next stack will become the top element of the stack being pointed
    to by `stackIndex` and so on. If the last stack contains a single element, then
    shifting the other elements will eliminate the last stack, and the one before
    it will become the last. Let''s see this in terms of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们专注于实现`popAt(int stackIndex)`方法。我们可以通过简单调用`stacks.get(stackIndex).pop()`从`stackIndex`堆栈中弹出。一旦我们弹出一个元素，我们必须移动剩余的元素。下一个堆栈的底部元素将成为由`stackIndex`指向的堆栈的顶部元素，依此类推。如果最后一个堆栈包含单个元素，则移动其他元素将消除最后一个堆栈，并且其前面的堆栈将成为最后一个堆栈。让我们通过代码来看一下：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *StackOfPlates*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*StackOfPlates*。
- en: Coding challenge 4 – Stock span
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战4 - 股票跨度
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given an array of prices of a single stock
    for multiple consecutive days. A stock span is represented by the number of consecutive
    days prior to the current day (today) when the price of a stock was less than
    or equal to the price of the current day. For example, consider the prices of
    a stock covering 10 days; that is, {55, 34, 22, 23, 27, 88, 70, 42, 51, 100}.
    The resulting stock span is {1, 1, 1, 2, 3, 6, 1, 1, 2, 10}. Notice that, for
    the first day, the stock span is always 1\. Write a snippet of code that computes
    the stock span for the given list of prices.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经获得了一个单一股票连续多天的价格数组。股票跨度由前几天（今天）的股票价格小于或等于当前天（今天）的股票价格的天数表示。例如，考虑股票价格覆盖10天的情况；即{55,
    34, 22, 23, 27, 88, 70, 42, 51, 100}。结果的股票跨度是{1, 1, 1, 2, 3, 6, 1, 1, 2, 10}。注意，对于第一天，股票跨度始终为1。编写一小段代码，计算给定价格列表的股票跨度。'
- en: '**Solution**: We can start from the given example and try to visualize it,
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以从给定的示例开始，尝试将其可视化，如下所示：'
- en: '![Figure 12.2 – Stock span for 10 days'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 - 10天的股票跨度'
- en: '](img/Figure_12.2_B15403.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B15403.jpg)'
- en: Figure 12.2 – Stock span for 10 days
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 10天的股票跨度
- en: 'From the preceding figure, we can observe the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以观察到以下内容：
- en: For the first day, the span is always 1\.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一天，跨度始终为1。
- en: For day 2, the price is 34\. Since 34 is less than the price of the prior day
    (55), the stock span of day 2 is also 1\.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第2天，价格为34。由于34小于前一天（55）的价格，第2天的股票跨度也是1。
- en: For day 3, the price is 22\. Since 22 is less than the price of the prior day
    (34), the stock span of day 3 is also 1\. Days 7 and 8 fall under the same scenario.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第3天，价格为22。由于22小于前一天（34）的价格，第3天的股票跨度也是1。第7天和第8天也属于同样的情况。
- en: For day 4, the price is 23\. Since 23 is greater than the price of the prior
    day (22), but is less than the price of day 2, the stock span is 2\. Day 9 is
    similar to day 4\.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第4天，价格是23。由于23大于前一天的价格（22），但小于第2天的价格，所以股票跨度为2。第9天与第4天类似。
- en: For day 5, the price is 27\. Since this price is greater than the prices of
    days 3 and 4 but less than the price of day 2, the stock span is 3.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第5天，价格是27。由于这个价格大于第3天和第4天的价格，但小于第2天的价格，所以股票跨度为3。
- en: For day 6, the price is 88\. This is the biggest price so far, so the stock
    span is 6.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第6天，价格是88。这是迄今为止最高的价格，所以股票跨度是6。
- en: For day 10, the price is 100\. This is the biggest price so far, so the stock
    span is 10.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第10天，价格是100。这是迄今为止最高的价格，所以股票跨度是10。
- en: 'Notice that we compute the stock span of the current day as the difference
    between the index of the current day and the index of the day corresponding to
    the last biggest stock price. After tracking this scenario, the first idea that
    we have may sound like this: for each day, scan all days prior to it and increment
    the stock span until the price of the stock is bigger than the current day. In
    other words, we are using the brute-force approach. As I mentioned earlier in
    this book, the brute-force approach should be used as a last resort in an interview
    since it has a poor performance and the interviewers won''t be impressed. In this
    case, the brute-force approach works in O(n2) complexity time.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们计算当前天的股票跨度，是当前天的索引与对应于最后一个最大股价的那一天的索引之间的差。在追踪这种情况之后，我们可能会有这样的第一个想法：对于每一天，扫描它之前的所有天，直到股价大于当前天。换句话说，我们使用了蛮力方法。正如我在本书中早些时候提到的，蛮力方法应该在面试中作为最后的手段使用，因为它的性能较差，面试官不会感到印象深刻。在这种情况下，蛮力方法的时间复杂度为O(n2)。
- en: However, let's try another perspective of thought. For each day, we want to
    find a prior day that has a bigger price than the current day. In other words,
    we are looking for the last price that is bigger than the price of the current
    day.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们换个角度来思考。对于每一天，我们想找到一个之前的一天，它的价格比当前天的价格高。换句话说，我们要找到最后一个价格比当前天的价格高的那一天。
- en: Here, we should choose a LIFO data structure that allows us to push the prices
    in descending order and pop the last pushed price. Once we have this in place,
    we can go through each day and compare the price at the top of the stack with
    the current day's price. Until the price on top of the stack is less than the
    current day's price, we can pop from the stack. But if the price at the top of
    the stack is bigger than the price of the current day, then we compute the stock
    span of the current day as the difference in days between the current day and
    the day for the price on top of the stack. This will work if we push the prices
    into the stack in descending order – the biggest price is at the top of the stack.
    However, since we can compute the stock span as the difference between the index
    of the current day and the index of the day corresponding to the last biggest
    stock price (let's denote it with `i`), we can simply store the `i` index in the
    stack; `stackPrices[i]` (let's denote the prices array as `stackPrices`) will
    return the price of the stock on the *i*th day.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该选择一个后进先出的数据结构，它允许我们按降序推入价格并弹出最后推入的价格。一旦我们做到这一点，我们可以遍历每一天，并将栈顶的价格与当前天的价格进行比较。直到栈顶的价格小于当前天的价格，我们可以从栈中弹出。但是如果栈顶的价格大于当前天的价格，那么我们计算当前天的股票跨度，就是当前天和栈顶价格对应的那一天之间的天数差。如果我们按降序将价格推入栈中，这将起作用
    - 最大的价格在栈顶。然而，由于我们可以将股票跨度计算为当前天的索引与对应于最后一个最大股价的那一天的索引之间的差（我们用`i`表示），我们可以简单地将`i`索引存储在栈中；`stackPrices[i]`（我们将价格数组表示为`stackPrices`）将返回第*i*天的股票价格。
- en: 'This can be accomplished by the following algorithm:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下算法实现：
- en: The first day has a stock span of 1 and an index of 0 – we push this index into
    the stack (let's denote it as `dayStack`; therefore, `dayStack.push(0)`).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一天的股票跨度为1，索引为0 - 我们将这个索引推入栈中（我们将其表示为`dayStack`；因此，`dayStack.push(0)`）。
- en: 'We loop the remaining days (day 2 has index 1, day 3 has index 2, and so on)
    and do the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们循环剩余的天数（第2天的索引为1，第3天的索引为2，依此类推）并执行以下操作：
- en: a. While `stockPrices[i] > stockPrices[dayStack.peek()]` and `!dayStack.empty()`,
    we pop from the stack (`dayStack.pop()`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: a. 当`stockPrices[i] > stockPrices[dayStack.peek()]`并且`!dayStack.empty()`时，我们从栈中弹出（`dayStack.pop()`）。
- en: If `dayStack.empty()`, then the stock span in `i+1`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`dayStack.empty()`，那么`i+1`的股票跨度。
- en: If `stockPrices[i] <= stockPrices[dayStack.peek()]`, then the stock span is
    `i - dayStack.peek()`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`stockPrices[i] <= stockPrices[dayStack.peek()]`，那么股票跨度就是`i - dayStack.peek()`。
- en: Push the index of the current day, `i`, into the stack (`dayStack`).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前天的索引`i`推入栈中（`dayStack`）。
- en: 'Let''s see how this algorithm works for our test case:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个算法如何适用于我们的测试案例：
- en: The first day has a stock span of 1 and an index of 0 – we push this index into
    the stack, `dayStack.push(0)`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一天的股票跨度为1，索引为0 - 我们将这个索引推入栈中，`dayStack.push(0)`。
- en: For the second day, `stockPrices[1]=34` and `stockPrices[0]=55`. Since 34 <
    55, the stock span of day 2 is `i - dayStack.peek()` = 1 - 0 = 1\. We push in
    stack 1, `dayStack.push(1)`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第2天，`stockPrices[1]=34`，`stockPrices[0]=55`。由于34 < 55，第2天的股票跨度为`i - dayStack.peek()`
    = 1 - 0 = 1。我们将1推入栈中，`dayStack.push(1)`。
- en: For the third day, `stockPrices[2]`=22 and `stockPrices[1]`=34\. Since 22 <
    34, the stock span of day 3 is 2 - 1 = 1\. We push in stack 1, `dayStack.push(2`).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三天，`stockPrices[2]`=22，`stockPrices[1]`=34。由于22 < 34，第3天的股票跨度为2 - 1 = 1。我们将1推入栈中，`dayStack.push(2)`。
- en: For the fourth day, `stockPrices[3]`=23 and `stockPrices[2]`=22\. Since 23 >
    22 and the stack is not empty, we pop the top, so we pop the value 2\. Since 23
    < 34 (`stockPrices[1]`), the stock span of day 4 is 3 - 1 = 2\. We push in stack
    3, `dayStack.push(3)`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第4天，`stockPrices[3]`=23，`stockPrices[2]`=22。由于23 > 22并且栈不为空，我们弹出栈顶，所以我们弹出值2。由于23
    < 34（`stockPrices[1]`），第4天的股票跨度为3 - 1 = 2。我们将3推入栈中，`dayStack.push(3)`。
- en: For the fifth day, `stockPrices[4]`=27 and `stockPrices[3]`=23\. Since 27 >
    23 and the stack is not empty, we pop the top, so we pop the value 3\. Next, 27
    < 34 (remember that we popped the value 2 in the previous step, so the next top
    has the value 1), and the stock span of day 5 is 4 - 1 = 3\. We push in stack
    4, `dayStack.push(4)`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第五天，`stockPrices[4]`=27 和 `stockPrices[3]`=23。由于 27 > 23 并且栈不为空，我们弹出栈顶，所以我们弹出值
    3。接下来，27 < 34（记住我们在上一步弹出了值 2，所以下一个栈顶的值为 1），第 5 天的股票跨度为 4 - 1 = 3。我们在栈中推入 4，`dayStack.push(4)`。
- en: For the sixth day, `stockPrices[5]`=88 and `stockPrices[4]`=27\. Since 88 >
    27 and the stack is not empty, we pop the top, so we pop the value 4\. Next, 88
    > 34 and the stack is not empty, so we pop the value 1\. Next, 88 > 55 and the
    stack is not empty, so we pop the value 0\. Next, the stack is empty and the stock
    span of day 6 is 5 + 1 = 6\.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第六天，`stockPrices[5]`=88 和 `stockPrices[4]`=27。由于 88 > 27 并且栈不为空，我们弹出栈顶，所以我们弹出值
    4。接下来，88 > 34 并且栈不为空，所以我们弹出值 1。接下来，88 > 55 并且栈不为空，所以我们弹出值 0。接下来，栈为空，第 6 天的股票跨度为
    5 + 1 = 6。
- en: 'Well, I think you got the idea, so now, challenge yourself and continue until
    day 10\. For now, we have enough information to put this algorithm into code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我想你已经明白了，现在，挑战自己，继续到第 10 天。目前，我们有足够的信息将这个算法转化为代码：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The complete application is called *StockSpan*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为 *StockSpan*。
- en: Coding challenge 5 – Stack min
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战 5 – 栈最小值
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`push()`, `pop()`, and `min()` methods should operate in O(1) time.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`、`pop()` 和 `min()` 方法应在 O(1) 时间内运行。'
- en: '`push()` and `pop()` to run in O(1) time.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 和 `pop()` 在 O(1) 时间内运行。'
- en: 'The solution that respects the problem''s constraints requires an additional
    stack for tracking the minimum. Mainly, when the pushed value is smaller than
    the current minimum, we add this value to the auxiliary stack (let''s denote it
    as `stackOfMin`) and the original stack. If the value that''s popped from the
    original stack is the top of `stackOfMin`, then we pop it from `stackOfMin` as
    well. In terms of code, we have the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 符合问题约束的解决方案需要一个额外的栈来跟踪最小值。主要是，当推送的值小于当前最小值时，我们将这个值添加到辅助栈（我们将其表示为 `stackOfMin`）和原始栈中。如果从原始栈中弹出的值是
    `stackOfMin` 的栈顶，则我们也从 `stackOfMin` 中弹出它。在代码方面，我们有以下内容：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Done! Our solution performed in O(1) complexity time. The complete application
    is called *MinStackConstantTime*. A problem related to this one requires you to
    implement the same functionality in constant time and space. The solution to this
    problem imposes several restrictions, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们的解决方案以 O(1) 复杂度时间运行。完整的应用程序称为 *MinStackConstantTime*。与此相关的一个问题要求您在常数时间和空间内实现相同的功能。这个问题的解决方案施加了几个限制，如下：
- en: The `pop()` method returns `void` to avoid returning incorrect values.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()` 方法返回 `void`，以避免返回不正确的值。'
- en: The given value multiplied by 2 should not exceed the `int` data type domain.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定值乘以 2 不应超出 `int` 数据类型的范围。
- en: In short, these restrictions are caused by the solution itself. We cannot use
    extra space; therefore, we will use the initial stack of values to store the minimum
    as well. Moreover, we need to multiply the given value by 2, so we should ensure
    that the `int` domain is not exceeded. Why do we need to multiply the given value
    by 2?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这些限制是由解决方案本身造成的。我们不能使用额外的空间；因此，我们将使用初始值栈来存储最小值。此外，我们需要将给定值乘以 2，因此我们应确保不超出
    `int` 范围。为什么我们需要将给定值乘以 2？
- en: Let's bring some light to this subject! Let's assume that we need to push a
    value into a stack that has a certain minimum value. If this value is bigger than
    or equal to the current minimum value, then we can simply push it into the stack.
    But if it is smaller than the minimum, then we push 2**value-minimum*, which should
    be smaller than the value itself. Then, we update the current minimum as value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下这个问题！假设我们需要将一个值推入一个具有特定最小值的栈中。如果这个值大于或等于当前最小值，那么我们可以简单地将它推入栈中。但是如果它小于最小值，那么我们推入
    2**值-最小值*，这应该小于值本身。然后，我们将当前最小值更新为值。
- en: 'When we pop a value, we have to consider two aspects. If the popped value is
    bigger or equal to the minimum, then this is the real value that was pushed earlier.
    Otherwise, the popped value is not the pushed value. The real pushed value is
    stored in the minimum. After we pop the top of the stack (the minimum value),
    we have to restore the previous minimum. The previous minimum is obtained as 2**minimum
    - top.* In other words, since the current top is 2**value - previous_minimum*
    and the value is the current minimum, the previous minimum is 2**current_minimum
    - top*. The following code illustrates this algorithm:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们弹出一个值时，我们必须考虑两个方面。如果弹出的值大于或等于最小值，那么这是之前推送的真实值。否则，弹出的值不是推送的值。真正推送的值存储在最小值中。在我们弹出栈顶（最小值）之后，我们必须恢复先前的最小值。先前的最小值可以通过
    2**最小值 - 栈顶* 获得。换句话说，由于当前栈顶是 2**值 - 先前的最小值*，而值是当前最小值，先前的最小值是 2**当前最小值 - 栈顶*。以下代码说明了这个算法：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete application is called *MinStackConstantTimeAndSpace*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为 *MinStackConstantTimeAndSpace*。
- en: Coding challenge 6 – Queue via stacks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战 6 – 通过栈实现队列
- en: '**Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Design a queue via two stacks.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：通过两个栈设计一个队列。'
- en: '**Solution**: In order to find the proper solution to this problem, we must
    start from the main difference between a queue and a stack. We know that a queue
    works on FIFO, while a stack works on LIFO. Next, we have to think of the main
    operations (push, pop, and peek) and identify the differences.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了找到这个问题的合适解决方案，我们必须从队列和栈之间的主要区别开始。我们知道队列按照先进先出的原则工作，而栈按照后进先出的原则工作。接下来，我们必须考虑主要的操作（推入、弹出和查看）并确定它们之间的区别。'
- en: Both of them push new elements in the same way. When we push an element into
    a queue, we push it at one end (the rear of the queue). When we push an element
    into a stack, we push it from the new top of the stack, which can be considered
    the same as the rear of the queue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都以相同的方式推送新元素。当我们将一个元素推入队列时，我们是从一端（队列的后端）推入的。当我们将一个元素推入栈时，我们是从栈的新顶部推入的，这可以被视为与队列的后端相同。
- en: 'When we pop or peek a value from a stack, we do so from the top. However, when
    we perform the same operations on a queue, we do so from the front. This means
    that, while popping or peeking an element, a reversed stack will act as a queue.
    The following diagram exemplifies this statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从栈中弹出或查看一个值时，我们是从顶部这样做的。然而，当我们在队列上执行相同的操作时，我们是从前面这样做的。这意味着，当弹出或查看一个元素时，一个反转的栈将充当队列。以下图表说明了这一点：
- en: '![Figure 12.3 – Queue via two stacks'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - 通过两个栈实现队列'
- en: '](img/Figure_12.3_B15403.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B15403.jpg)'
- en: Figure 12.3 – Queue via two stacks
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 通过两个栈实现队列
- en: So, each new element is pushed into the *enqueue stack* as the new top. When
    we need to pop or peek a value, we use the *dequeue* stack, which is the reversed
    version of the *enqueue stack*. Notice that we don't have to reverse the *enqueue
    stack* at each pop/peek operation. We can let the elements sit in the *dequeue
    stack* until we absolutely must reverse the elements. In other words, for each
    pop/peek operation, we can check if the *dequeue stack* is empty. As long as the
    *dequeue stack* is not empty, we don't need to reverse the *enqueue stack* because
    we have at least one element to pop/peek.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个新元素都被推入*enqueue stack*作为新的顶部。当我们需要弹出或查看一个值时，我们使用*dequeue*栈，这是*enqueue stack*的反转版本。请注意，我们不必在每次弹出/查看操作时都反转*enqueue
    stack*。我们可以让元素停留在*dequeue stack*中，直到我们绝对必须反转元素。换句话说，对于每个弹出/查看操作，我们可以检查*dequeue
    stack*是否为空。只要*dequeue stack*不为空，我们就不需要反转*enqueue stack*，因为我们至少有一个元素可以弹出/查看。
- en: 'Let''s see this in terms of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用代码来看一下：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The complete application is called *QueueViaStack*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*QueueViaStack*。
- en: Coding challenge 7 – Stack via queues
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 - 通过队列实现栈
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Adobe**，**Microsoft**'
- en: '**Problem**: Design a stack via two queues.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计一个通过两个队列实现的栈。'
- en: '**Solution**: In order to find the proper solution to this problem, we must
    start from the main difference between a stack and a queue. We know that a stack
    is a LIFO, while a queue is a FIFO. Next, we have to think of the main operations
    (push, pop, and peek) and identify the differences.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了找到这个问题的合适解决方案，我们必须从栈和队列之间的主要区别开始。我们知道栈是后进先出，而队列是先进先出。接下来，我们必须考虑主要操作（推入、弹出和查看）并确定它们之间的区别。'
- en: Both of them push new elements in the same way. When we push an element into
    a stack, we push it from the new top of the stack. When we push an element into
    a queue, we push it from one end (the rear of the queue). The rear of the queue
    is like the top of the stack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都以相同的方式推送新元素。当我们将一个元素推入栈时，我们是从栈的新顶部推入的。当我们将一个元素推入队列时，我们是从一端（队列的后端）推入的。队列的后端就像栈的顶部。
- en: 'When we pop or peek a value from a queue, we do so from the front. However,
    when we perform the same operations on a stack, we do so from the top. This means
    that, while popping or peeking an element from a queue that acts as a stack, we
    need to poll all the elements except the last one. The last element is the one
    that we pop/peek. The following diagram exemplifies this statement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从队列中弹出或查看一个值时，我们是从前面这样做的。然而，当我们在栈上执行相同的操作时，我们是从顶部这样做的。这意味着，当我们从充当栈的队列中弹出或查看一个元素时，我们需要轮询除最后一个元素之外的所有元素。最后一个元素就是我们弹出/查看的元素。以下图表说明了这一点：
- en: '![Figure 12.4 – Stack via two queues'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - 通过两个队列实现栈'
- en: '](img/Figure_12.4_B15403.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B15403.jpg)'
- en: Figure 12.4 – Stack via two queues
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 通过两个队列实现栈
- en: As the left-hand side of the preceding diagram reveals, pushing an element into
    a stack and a queue is a simple operation. The right-hand side of the preceding
    diagram shows that problems occur when we want to pop/peek an element from the
    queue that acts as a stack. Mainly, before popping/peeking an element, we have
    to move the elements from the queue (denoted in the preceding diagram as *queue1*)
    between (*rear*-1) and *front* into another queue (denoted in the preceding diagram
    as *queue2*). In the preceding diagram, on the right-hand side, we poll the elements
    2, 5, 3, and 1 from *queue1* and add them to *queue2*. Next, we pop/peek the last
    element from *queue1*. If we pop element 6, then *queue1* remains empty. If we
    peek element 6, then *queue1* remains with this element.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表左侧所显示的，将一个元素推入栈和队列是一个简单的操作。前面图表的右侧显示了当我们想要从充当栈的队列中弹出/查看一个元素时会出现问题。主要是，在弹出/查看元素之前，我们必须将队列（在前面的图表中标记为*queue1*）中的元素（*rear*-1和*front*之间）移动到另一个队列（在前面的图表中标记为*queue2*）。在前面的图表中，右侧，我们从*queue1*中轮询元素2、5、3和1，并将它们添加到*queue2*中。接下来，我们从*queue1*中弹出/查看最后一个元素。如果我们弹出元素6，那么*queue1*就会保持为空。如果我们查看元素6，那么*queue1*就会保留这个元素。
- en: 'Now, the remaining elements are in *queue2*, so in order to perform another
    operation (push, peek, or pop), we have two options:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的元素都在*queue2*中，所以为了执行另一个操作（推入、查看或弹出），我们有两个选项：
- en: Restore *queue1* by moving the remaining elements from *queue2* back.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*queue2*中剩余的元素移回*queue1*，恢复*queue1*。
- en: Use *queue2* as if it was *queue1*, which means using *queue1* and *queue2*
    alternatively.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*queue2*就像它是*queue1*一样，这意味着交替使用*queue1*和*queue2*。
- en: In the case of the second option, we avoid the overhead of moving the elements
    from *queue2* back to *queue1*, with the purpose of performing the next operation
    on *queue1*. While you can challenge yourself to implement the first option, let's
    focus more on the second one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个选项中，我们避免了将*queue2*中的元素移回*queue1*的开销，目的是在*queue1*上执行下一个操作。虽然你可以挑战自己来实现第一个选项，但让我们更多地关注第二个选项。
- en: 'Trying to use *queue1* and *queue2* alternatively can be done if we consider
    that the queue that we should use for the next operation is the one that is not
    empty. Since we move the elements between these two queues, one of them is always
    empty. Hence, a problem arises when we peek an element because the peek operation
    doesn''t remove the element, so one of the queues remains with that element. Since
    none of the queues are empty, we don''t know which queue should be used for the
    next operation. The solution is quite simple: we poll the last element, even for
    the peek operation, and we store it as an instance variable. Subsequent peek operations
    will return this instance variable. A push operation will push this instance variable
    back into the queue before pushing the given value and will set this instance
    variable to `null`. The pop operation will check if this instance variable is
    `null` or not. If it is not `null`, then this is the element to pop.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑到我们应该使用的下一个操作的队列是不空的，那么可以交替使用*queue1*和*queue2*。由于我们在这两个队列之间移动元素，其中一个始终为空。因此，当我们查看一个元素时，会出现问题，因为查看操作不会移除元素，因此其中一个队列仍然保留该元素。由于没有一个队列是空的，我们不知道下一个操作应该使用哪个队列。解决方案非常简单：我们弹出最后一个元素，即使是对于查看操作，我们也将其存储为实例变量。随后的查看操作将返回此实例变量。推送操作将在推送给定值之前将此实例变量推回队列，并将此实例变量设置为`null`。弹出操作将检查此实例变量是否为`null`。如果不是`null`，那么这就是要弹出的元素。
- en: 'Let''s see the code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete application is called *StackViaQueue*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*StackViaQueue*。
- en: Coding challenge 8 – Max histogram area
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8 - 最大直方图面积
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given the histogram shown in the following
    image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了下图中显示的直方图：'
- en: '![Figure 12.5 – Histogram with the class interval equal to 1](img/Figure_12.5_B15403.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 - 直方图，类间隔等于1](img/Figure_12.5_B15403.jpg)'
- en: Figure 12.5 – Histogram with the class interval equal to 1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 直方图，类间隔等于1
- en: We define a histogram as a diagram of rectangular bars where the area is proportional
    to the frequency of a certain variable. The width of a bar is known as the histogram
    class interval. For example, the histogram in the preceding image has a class
    interval equal to 1\. There are six bars whose widths are equal to 1 and whose
    heights are 4, 2, 8, 6, 5, and 3.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直方图定义为一个矩形条的图表，其中面积与某个变量的频率成比例。条的宽度称为直方图类间隔。例如，前面图像中的直方图的类间隔等于1。有六个宽度均为1，高度分别为4、2、8、6、5和3的条。
- en: 'Consider you''ve been given these heights as an array of integers (this is
    the input of the problem). Write a snippet of code that uses a stack for computing
    the largest rectangular area in the histogram. For a better understanding of this,
    the following image highlights several rectangles (not all) that can be formed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经得到了这些高度作为整数数组（这是问题的输入）。编写一小段代码，使用栈来计算直方图中最大的矩形区域。为了更好地理解这一点，下图突出显示了几个（不是全部）可以形成的矩形：
- en: '![Figure 12.6 – Rectangles of a histogram'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 - 直方图的矩形'
- en: '](img/Figure_12.6_B15403.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.6_B15403.jpg)'
- en: Figure 12.6 – Rectangles of a histogram
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 - 直方图的矩形
- en: In the preceding image, the largest rectangular area (that is, the largest rectangle)
    is the one in the middle, 3 x 5 = 15.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，最大的矩形区域（即最大的矩形）是中间的一个，3 x 5 = 15。
- en: '**Solution**: This problem is harder than it may seem at first sight. First
    of all, we need to analyze the given image and formulate several statements. For
    example, it is very important to notice that a bar can only be part of a rectangular
    area if its height is less than or equal to the height of that area. Moreover,
    for each bar, we can say that all the bars from the left-hand side that are higher
    than the current bar can form a rectangular area with the current bar. Similarly,
    all the bars on the right-hand side that are higher than the current bar can form
    a rectangular area with the current bar.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题比起初看起来要困难得多。首先，我们需要分析给定的图像并制定几个声明。例如，非常重要的是要注意，只有当某个条的高度小于或等于该区域的高度时，该条才能成为矩形区域的一部分。此外，对于每个条，我们可以说，所有左侧高于当前条的条都可以与当前条形成一个矩形区域。同样，所有右侧高于当前条的条都可以与当前条形成一个矩形区域。'
- en: 'This means that every rectangular area is delimited by a *left* and a *right*
    boundary, and (*right - left*) ** current_bar* give us the value of this area.
    We should compute all the possible areas and peek the highest area as the output
    of our implementation. The following image highlights the left and right boundaries
    of the 3 x 5 rectangle:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个矩形区域由*左*和*右*边界限定，而(*右 - 左*) ** current_bar*给出了这个区域的值。我们应该计算所有可能的区域，并选择最高的区域作为我们实现的输出。以下图像突出显示了3
    x 5矩形的左右边界：
- en: '![Figure 12.7 – Left and right boundaries'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 - 左右边界'
- en: '](img/Figure_12.7_B15403.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.7_B15403.jpg)'
- en: Figure 12.7 – Left and right boundaries
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 - 左右边界
- en: Remember that we must use a stack to solve this problem. Now that we have some
    statements that can lead us to the solution, it is time to bring the stack into
    the discussion. Mainly, we can use the stack to compute the left and right boundaries.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们必须使用栈来解决这个问题。现在我们有了一些可以引导我们解决问题的声明，是时候把栈引入讨论了。主要是，我们可以使用栈来计算左右边界。
- en: 'We start from the first bar and we push the index of it (index 0) into the
    stack. We continue with the remaining bars and do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个条开始，将其索引（索引0）推入栈中。我们继续处理剩下的条，并执行以下操作：
- en: 'Repeat *steps 1a*, *1b*, and *1c* as long as the current bar is smaller than
    the top of the stack and the stack is not empty:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1a*、*1b*和*1c*，直到当前条小于栈顶部并且栈不为空：
- en: a. We pop the top of the stack.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: a.我们弹出栈顶部。
- en: b. We compute the left boundary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: b.我们计算左边界。
- en: c. We compute the width of the rectangular area that can be formed between the
    computed left boundary bar and the current bar.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: c. 我们计算可以在计算的左边界条和当前条之间形成的矩形区域的宽度。
- en: d. We compute the area as the computed width multiplied by the height of the
    bar that we popped in *step 1a.*
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: d. 我们计算面积为计算的宽度乘以我们在*步骤1a*中弹出的条的高度。
- en: e. If this area is bigger than the previous one, then we store this one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: e. 如果这个区域比以前的大，那么我们存储这个区域。
- en: Push the index of the current bar into the stack.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前条的索引推入栈中。
- en: Repeat from *step 1* until every bar is processed.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤1*直到每个条都被处理。
- en: 'Let''s see this in terms of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码方面的情况：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The time complexity of this code is O(n). Moreover, the additional space complexity
    is O(n). The complete application is called *StackHistogramArea*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度是O(n)。此外，额外的空间复杂度是O(n)。完整的应用程序称为*StackHistogramArea*。
- en: Coding challenge 9 – Smallest number
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9 - 最小数字
- en: '**Problem**: Consider you''ve been given a string representing a number of
    *n* digits. Write a snippet of code that prints the smallest possible number after
    removing the given *k* digits.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到一个表示*n*位数的字符串。编写一小段代码，删除给定的*k*位数后打印出最小可能的数字。'
- en: '**Solution**: Let''s consider that the given number is *n*=4514327 and *k*=4\.
    In this case, the smallest number after removing four digits is 127\. If *n*=2222222,
    then the smallest number is 222\.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设给定的数字是*n*=4514327和*k*=4。在这种情况下，删除四位数字后的最小数字是127。如果*n*=2222222，那么最小数字是222。'
- en: 'The solution can be easily implemented via a `Stack` and the following algorithm:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以通过`Stack`和以下算法轻松实现：
- en: Iterate the given number from left to right, digit by digit.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右迭代给定的数字，逐位数字。
- en: 'a. While the given *k* is greater than 0, the stack is not empty and the top
    element in the stack is greater than the currently traversed digit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: a. 只要给定的*k*大于0，栈不为空，并且栈中的顶部元素大于当前遍历的数字：
- en: i. Pop out the top element from the stack.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: i. 从栈中弹出顶部元素。
- en: ii. Decrement *k* by 1.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ii. 将*k*减1。
- en: b. Push the current digit to the stack.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将当前数字推入栈中。
- en: 'While the given *k* is greater than 0, do the following (to handle special
    cases such as 222222):'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当给定的*k*大于0时，执行以下操作（处理特殊情况，如222222）：
- en: a. Pop out elements from the stack.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: a. 从栈中弹出元素。
- en: b. Decrement *k* by 1.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将*k*减1。
- en: 'In terms of code, we have the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is called *SmallestNumber*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SmallestNumber*。
- en: Coding challenge 10 – Islands
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 - 岛屿
- en: '**Amazon**, **Adobe**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**'
- en: '**Problem**: Consider you''ve been given a matrix, *m*x*n*, containing only
    0s and 1s. By convention, 1 means land and 0 means water. Write a snippet of code
    that counts the number of islands. An island is defined as a group of 1s surrounded
    by 0s.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到一个包含只有0和1的*m*x*n*矩阵。按照惯例，1表示陆地，0表示水。编写一小段代码来计算岛屿的数量。岛屿被定义为由0包围的1组成的区域。'
- en: '**Solution**: Let''s visualize a test case. The following is a 10x10 matrix
    that contains 6 islands, highlighted as 1, 2, 3, 4, 5, and 6:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们想象一个测试案例。以下是一个包含6个岛屿的10x10矩阵，分别标记为1、2、3、4、5和6：'
- en: '![Figure 12.8 – Islands via a 10x10 matrix'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 - 10x10矩阵中的岛屿'
- en: '](img/Figure_12.8_B15403.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.8_B15403.jpg)'
- en: Figure 12.8 – Islands via a 10x10 matrix
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - 10x10矩阵中的岛屿
- en: 'In order to find the islands, we have to traverse the matrix. In other words,
    we have to traverse each cell of the matrix. Since a cell is characterized by
    a row (let''s denote it as *r*) and a column (let''s denote it as *c*), we observe
    that, from a cell (*r, c*), we can move in eight directions: (*r-*1*, c-*1), (*r-*1*,
    c*), (*r-*1*, c+*1), (*r, c-*1), (*r, c+*1), (*r+*1*, c-*1), (*r+*1*, c*), and
    (*r+*1*, c+*1). This means that from the current cell (*r, c*), we can move to
    (*r+ROW*[*k*]*, c+COL*[*k*]) as long as `ROW` and `COL` are the below arrays and
    0 ≤ *k* ≤ 7:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到岛屿，我们必须遍历矩阵。换句话说，我们必须遍历矩阵的每个单元格。由于一个单元格由行（我们将其表示为*r*）和列（我们将其表示为*c*）来表示，我们观察到，从一个单元格(*r,
    c*)，我们可以朝八个方向移动：(*r-*1*, c-*1), (*r-*1*, c*), (*r-*1*, c+*1), (*r, c-*1), (*r,
    c+*1), (*r+*1*, c-*1), (*r+*1*, c*), 和 (*r+*1*, c+*1)。这意味着从当前单元格(*r, c*)，我们可以移动到(*r+ROW*[*k*]*,
    c+COL*[*k*])，只要`ROW`和`COL`是下面的数组，且0 ≤ *k* ≤ 7：
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moving to a cell is valid as long as we do the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们做到以下几点，移动到一个单元格就是有效的：
- en: Don't fall from the grid.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从网格上掉下来。
- en: Step on a cell representing land (a cell of 1).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 踩在代表陆地的单元格上（一个1的单元格）。
- en: Haven't been in that cell before.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有在该单元格之前。
- en: In order to ensure that we don't visit the same cell multiple times, we use
    a boolean matrix denoted as `flagged[][]`. Initially, this matrix contains only
    values of `false`, and each time we visit a cell (`r`, `c`), we flip the corresponding
    `flagged[r][c]` to `true`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不多次访问同一个单元格，我们使用一个布尔矩阵表示为`flagged[][]`。最初，这个矩阵只包含`false`的值，每次我们访问一个单元格(`r`,
    `c`)时，我们将相应的`flagged[r][c]`翻转为`true`。
- en: 'The following is the preceding three bullet points in code form:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码形式中的前三个要点：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So far, we know how to decide if a move from the current cell to another cell
    (from the eight possible movements) is valid or not. Furthermore, we have to define
    an algorithm to determine a movement pattern. We know that from a cell (*r, c*),
    we can move in eight directions in neighboring cells. So, the most convenient
    algorithm consists of trying to move from the current cell into all the valid
    neighbors, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何决定从当前单元格移动到另一个单元格（从八个可能的移动中）。此外，我们必须定义一个算法来确定移动模式。我们知道从一个单元格(*r,
    c*)，我们可以在相邻单元格中的八个方向移动。因此，最方便的算法是尝试从当前单元格移动到所有有效的邻居，如下所示：
- en: Start with an empty queue.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空队列开始。
- en: Move to a valid cell (*r, c*), enqueue it, and mark it as flagged – the starting
    point should be cell (0, 0).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到一个有效的单元格(*r, c*)，将其入队，并标记为已访问 - 起始点应该是单元格(0, 0)。
- en: Dequeue the current cell and resolve all its eight neighboring cells – resolving
    a cell means to enqueue it if it is valid and mark it as flagged.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出队当前单元并解决其周围的八个相邻单元 - 解决单元意味着如果有效则将其入队并标记为已访问。
- en: Repeat *step 3* until the queue is empty. When the queue is empty, this means
    we've found an island.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤3*直到队列为空。当队列为空时，这意味着我们找到了一个岛屿。
- en: Repeat from *step 2* until there are no more valid cells.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤2*直到没有更多有效单元格。
- en: 'In terms of code, we have the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete application is called *QueueIslands*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*QueueIslands*。
- en: Coding challenge 11 – Shortest path
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11-最短路径
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider you''ve been given a matrix, *m* x *n*, containing only
    0s and 1s. By convention, 1 means safe land, while 0 represents unsafe land. More
    precisely, a 0 represents a sensor that should not be activated. Moreover, all
    eight adjacent cells can activate the sensor. Write a snippet of code that computes
    the shortest route from any cells of the first column to any cell of the last
    column. You can only move one step at a time; either left, right, up, or down.
    The resulting route (if its exists) should contain only values of 1.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设给定一个只包含0和1的矩阵*m* x *n*。按照惯例，1表示安全土地，而0表示不安全的土地。更准确地说，0表示不应该被激活的传感器。此外，所有八个相邻的单元格都可以激活传感器。编写一小段代码，计算从第一列的任何单元格到最后一列的任何单元格的最短路径。您只能一次移动一步；向左、向右、向上或向下。结果路径（如果存在）应只包含值为1的单元格。'
- en: '**Solution**: Let''s visualize a test case. The following is a 10 x 10 matrix.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们想象一个测试案例。以下是一个10 x 10的矩阵。'
- en: 'On the left-hand side of the following image, you can see the given matrix.
    Notice the values of 0 representing sensors that should not be activated. On the
    right, you can see the matrix being used by the application and a possible solution.
    This matrix is obtained from the given matrix by expanding the sensor''s coverage
    area. Remember that the eight adjacent cells of a sensor can activate the sensor
    as well. The solution starts from the first column (cell(4, 0)) and ends in the
    last column (cell (9, 9)) and contains 15 steps (from 0 to 14). You can see these
    steps in the following image:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图的左侧，您可以看到给定的矩阵。请注意，值为0表示不应该被激活的传感器。在右侧，您可以看到应用程序使用的矩阵和可能的解决方案。这个矩阵是通过扩展传感器的覆盖区域从给定的矩阵中获得的。请记住，传感器的八个相邻单元格也可以激活传感器。解决方案从第一列（单元格（4,0））开始，以最后一列（单元格（9,9））结束，并包含15个步骤（从0到14）。您可以在下图中看到这些步骤：
- en: '![Figure 12.9 – The given matrix (left-hand side) and the resolved matrix (right-hand
    side)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 - 给定矩阵（左侧）和解析矩阵（右侧）'
- en: '](img/Figure_12.9_B15403.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.9_B15403.jpg)'
- en: Figure 12.9 – The given matrix (left-hand side) and the resolved matrix (right-hand
    side)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 - 给定矩阵（左侧）和解析矩阵（右侧）
- en: 'From a safe cell of coordinates (*r, c*), we can move in four safe directions:
    (*r*-1*, c*), (*r, c*-1), (*r*+1*, c*), and (*r, c*+1). If we think of the possible
    movements as directions (edges) and the cells as vertices, then we can visualize
    this problem in the context of a graph. The edges are the possible moves, while
    the vertices are the possible cells where we can go. Each move holds the distance
    from the current cell to the start cell (a start cell is a cell from the first
    column). For each move, the distance is increased by 1\. So, in the context of
    a graph, the problem reduces to finding the shortest path in a graph. Hence, we
    can use the **Breadth-first Search (BFS)** approach to solve this problem. In
    [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*, Trees and Graphs*,
    you were provided with a description of the BFS algorithm, and another problem
    was solved in the same manner as the one being solved here – the *Chess Knight*
    problem.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从坐标（*r，c*）的安全单元格，我们可以朝四个安全方向移动：（*r*-1*，c*），（*r，c*-1），（*r*+1*，c*）和（*r，c*+1）。如果我们将可能的移动视为方向（边）并将单元格视为顶点，则可以在图的上下文中可视化这个问题。边是可能的移动，而顶点是我们可以到达的可能单元格。每次移动都保持从当前单元格到起始单元格的距离（起始单元格是第一列的单元格）。对于每次移动，距离增加1。因此，在图的上下文中，问题可以简化为在图中找到最短路径。因此，我们可以使用**广度优先搜索（BFS）**方法来解决这个问题。在[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*，树和图*中，您已经了解了BFS算法的描述，并且另一个问题也是以与此处解决的问题相同的方式解决的-
    *国际象棋骑士*问题。
- en: 'Now, based on the experience provided by the previous problem, we can elaborate
    on this algorithm:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据前面问题提供的经验，我们可以详细说明这个算法：
- en: Start with an empty queue.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空队列开始。
- en: Enqueue all the safe cells of the first column and set their distances to 0
    (here, 0 represents the distance from each cell to itself). Moreover, these cells
    are marked as visited or flagged.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一列的所有安全单元格入队，并将它们的距离设置为0（这里，0表示每个单元格到自身的距离）。此外，这些单元格被标记为已访问或标记。
- en: 'As long as the queue is not empty, do the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要队列不为空，执行以下操作：
- en: a. Pop the cell representing the top of the queue.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: a. 弹出表示队列顶部的单元格。
- en: b. If the popped cell is the destination cell (that is, it is on the last column),
    then simply return its distance (the distance from the destination cell to the
    source cell on the first column).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果弹出的单元格是目的地单元格（即在最后一列），则简单地返回其距离（从目的地单元格到第一列源单元格的距离）。
- en: c. If the popped cell is not the destination then, for each of the four adjacent
    cells of this cell, enqueue each valid cell (safe and unvisited) into the queue
    with distance (+1) and mark it as visited.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果弹出的单元格不是目的地，则对该单元格的四个相邻单元格中的每一个，将每个有效单元格（安全且未访问）入队到队列中，并标记为已访问。
- en: d. If we processed all the cells in the queue without reaching the destination,
    then there is no solution. Return -1.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: d. 如果我们处理了队列中的所有单元格但没有到达目的地，则没有解决方案。返回-1。
- en: 'Since we rely on the BFS algorithm, we know that all the cells whose shortest
    paths are 1 are visited first. Next, the visited cells are the adjacent cells
    who have the shortest paths as 1+1=2 and so on. So, the cell that has the shortest
    path is equal to the *shortest path of its parent +* 1\. This means that, when
    we traverse the target cell for the first time, it gives us the final result.
    This is the shortest path. Let''s see the most relevant part of the code for this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖BFS算法，我们知道所有最短路径为1的单元格首先被访问。接下来，被访问的单元格是具有最短路径为1+1=2等的相邻单元格。因此，具有最短路径的单元格等于其父级的最短路径+1。这意味着当我们第一次遍历目标单元格时，它给出了我们的最终结果。这就是最短路径。让我们看看代码中最相关的部分：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The complete application is called *ShortestSafeRoute*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*ShortestSafeRoute*。
- en: Infix, postfix, and prefix expressions
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中缀、后缀和前缀表达式
- en: 'Prefix, postfix, and infix expressions are not a very common interview topic
    these days, but it can be considered a topic that should be covered at least once
    by any developer. The following is a quick overview:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀、后缀和中缀表达式在当今并不是一个非常常见的面试话题，但它可以被认为是任何开发人员至少应该涵盖一次的一个话题。以下是一个快速概述：
- en: '**Prefix expressions**: This is a notation (algebraic expression) that''s used
    for writing arithmetic expressions in which the operands are listed after their
    operators.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀表达式**：这是一种表示法（代数表达式），用于编写算术表达式，其中操作数在其运算符之后列出。'
- en: '**Postfix expressions**: This is a notation (algebraic expression) that''s
    used for writing arithmetic expressions in which the operands are listed before
    their operators.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后缀表达式**：这是一种表示法（代数表达式），用于编写算术表达式，其中操作数在其运算符之前列出。'
- en: '**Infix expressions**: This is a notation (algebraic expression) that''s typically
    used in arithmetic formulas or statements where the operators are written in between
    their operands.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中缀表达式**：这是一种表示法（代数表达式），通常用于算术公式或语句中，其中运算符写在其操作数之间。'
- en: 'If we have three operators, a, b, and c, we can write the expressions shown
    in the following image:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有三个运算符a、b和c，我们可以写出下图中显示的表达式：
- en: '![Figure 12.10 – Infix, postfix, and prefix'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 - 中缀、后缀和前缀'
- en: '](img/Figure_12.10_B15403.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B15403.jpg)'
- en: Figure 12.10 – Infix, postfix, and prefix
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 - 中缀、后缀和前缀
- en: The most common problems refer to evaluating prefix and postfix expressions
    and converting between prefix, infix, and postfix expressions. All these problems
    have solutions that rely on stacks (or binary trees) and are covered in any serious
    book dedicated to fundamental algorithms. Take your time and harvest some resources
    about this topic to get familiar with it. Since this topic is widely covered in
    dedicated books and is not a common topic in interviews, we will not cover it
    here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的问题涉及评估前缀和后缀表达式以及在前缀、中缀和后缀表达式之间进行转换。所有这些问题都有依赖于堆栈（或二叉树）的解决方案，并且在任何专门致力于基本算法的严肃书籍中都有涵盖。花些时间，收集一些关于这个主题的资源，以便熟悉它。由于这个主题在专门的书籍中得到了广泛的涵盖，并且在面试中并不常见，我们将不在这里进行涵盖。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the must-know stack and queue problems for any candidate
    that is preparing for a Java developer technical interview. Stacks and queues
    occur in many real applications, so mastering them is one of the top skills that
    an interviewer will test you on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了任何准备进行Java开发人员技术面试的候选人必须了解的堆栈和队列问题。堆栈和队列出现在许多实际应用中，因此掌握它们是面试官将测试您的顶级技能之一。
- en: In the next chapter, *Trees, Tries, and Graphs*, you'll see that stacks and
    queues are frequently used for solving problems that involve trees and graphs
    as well, which means they also deserve your attention.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章《树、Trie和图形》中，您将看到堆栈和队列经常用于解决涉及树和图形的问题，这意味着它们也值得您的关注。
