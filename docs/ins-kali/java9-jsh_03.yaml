- en: Chapter 3. Classes and Instances
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。类和实例
- en: 'In this chapter, we will start working with examples on how to code classes
    and customize the initialization of instances in Java 9\. We will understand how
    classes work as blueprints to generate instances and dive deeply into the garbage
    collection mechanism. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用Java 9中如何编写类和自定义实例初始化的示例。我们将了解类如何作为生成实例的蓝图工作，并深入了解垃圾回收机制。我们将：
- en: Understand classes and instances in Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中理解类和实例
- en: Work with object initialization and its customization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理对象初始化及其自定义
- en: Learn about an object's lifecycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解对象的生命周期
- en: Introduce garbage collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍垃圾回收
- en: Declare classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明类
- en: Customize constructors and initialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义构造函数和初始化
- en: Understand how garbage collection works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解垃圾回收的工作原理
- en: Create instances of classes and understand their scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类的实例并了解其范围
- en: Understanding classes and instances in Java 9
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 9中理解类和实例
- en: In the previous chapter, we learned some of the basics of the object-oriented
    paradigm, including classes and objects. We started working on the backend for
    a Web Service related to 2D shapes. We ended up creating a UML diagram with the
    structure of many classes, including their hierarchy, fields, and methods. It
    is time to take advantage of JShell to start coding a basic class and work with
    its instances in JShell.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了面向对象范式的一些基础知识，包括类和对象。我们开始为与2D形状相关的Web服务的后端工作。我们最终创建了一个具有许多类结构的UML图，包括它们的层次结构、字段和方法。现在是利用JShell开始编写基本类并在JShell中使用其实例的时候了。
- en: In Java 9, a class is always the type and blueprint. The object is the working
    instance of the class, and therefore, objects are also known as **instances**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，类始终是类型和蓝图。对象是类的工作实例，因此对象也被称为**实例**。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Classes are first-class citizens in Java 9 and they will be the main building
    blocks of our object-oriented solutions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类在Java 9中是一流公民，它们将是我们面向对象解决方案的主要构建块。
- en: 'One or more variables can hold a reference to an instance. For example, consider
    that we have the following three variables of the `Rectangle` type:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个变量可以持有对实例的引用。例如，考虑以下三个`Rectangle`类型的变量：
- en: '`rectangle1`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形1`'
- en: '`rectangle2`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形2`'
- en: '`rectangle10`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形10`'
- en: '`rectangle2``0`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形20`'
- en: Let's consider that the `rectangle1` variable holds a reference to an instance
    of the `Rectangle` class with its `width` set to `36` and its `height` set to
    `20`. The `rectangle10` variable holds a reference to the same instance referenced
    by `rectangle1`. Thus, we have two variables that hold a reference to the same
    `Rectangle` object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`rectangle1`变量持有对`Rectangle`类实例的引用，其`width`设置为`36`，`height`设置为`20`。`rectangle10`变量持有对`rectangle1`引用的相同实例。因此，我们有两个变量持有对相同的`Rectangle`对象的引用。
- en: The `rectangle2` variable holds a reference to an instance of the `Rectangle`
    class with its `width` set to `22` and its `height` set to `41`. The `rectangle20`
    variable holds a reference to the same instance referenced by `rectangle2`. We
    have another two variables that hold a reference to the same `Rectangle` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`rectangle2`变量持有对`Rectangle`类实例的引用，其`width`设置为`22`，`height`设置为`41`。`rectangle20`变量持有对`rectangle2`引用的相同实例。我们还有另外两个变量持有对相同的`Rectangle`对象的引用。'
- en: The following picture illustrates the situation where many variables of the
    `Rectangle` type that hold a reference to a single instance. The variable names
    are at the left-hand side and the rectangles with their width and height values
    represent a specific instance of the `Rectangle` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了许多`Rectangle`类型的变量持有对单个实例的引用的情况。变量名位于左侧，带有宽度和高度值的矩形代表`Rectangle`类的特定实例。
- en: '![Understanding classes and instances in Java 9](img/00033.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在Java 9中理解类和实例](img/00033.jpeg)'
- en: We will work with many variables that hold a reference to a single instance
    in JShell later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将在JShell中使用许多持有对单个实例的引用的变量。
- en: Working with object initialization and its customization
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理对象初始化及其自定义
- en: When you ask Java to create an instance of a specific class, something happens
    under the hood. Java creates a new instance of the specified type, the **JVM**
    (**Java Virtual Machine**) allocates the necessary memory, and then executes the
    code specified in the constructor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您要求Java创建特定类的实例时，底层会发生一些事情。Java创建指定类型的新实例，**JVM**（**Java虚拟机**）分配必要的内存，然后执行构造函数中指定的代码。
- en: When Java executes the code within the constructor, there is already a live
    instance of the class. Thus, the code in the constructor has access to the fields
    and methods defined in the class. Obviously, we must be careful in the code we
    put within the constructor because we might end up generating huge delays when
    we create instances of the class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java执行构造函数中的代码时，类已经存在一个活动实例。因此，构造函数中的代码可以访问类中定义的字段和方法。显然，我们必须小心构造函数中放置的代码，因为我们可能会在创建类的实例时产生巨大的延迟。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Constructors are extremely useful to execute setup code and properly initialize
    a new instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数非常有用，可以执行设置代码并正确初始化新实例。
- en: Let's forget about the hierarchy structure in which we were working for the
    classes that represent 2D shapes. Imagine that we have to code the `Circle` class
    as a standalone class that doesn't inherit from any other class. Before we can
    call either the `calculateArea` or `calculatePerimeter` methods, we want the `radius`
    field for each new `Circle` instance to have a value initialized to the appropriate
    value that represents the circle. We don't want new `Circle` instances to be created
    without specifying an appropriate value for the `radius` field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们忘记我们之前为代表2D形状的类工作的层次结构。想象一下，我们必须将`Circle`类编码为一个独立的类，不继承自任何其他类。在我们调用`calculateArea`或`calculatePerimeter`方法之前，我们希望每个新的`Circle`实例的`半径`字段都有一个初始化为代表圆的适当值的值。我们不希望创建新的`Circle`实例而不指定`半径`字段的适当值。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Constructors are extremely useful when we want to define the values for the
    fields of the instances of a class right after their creation and before we can
    access the variables that reference the created instances. In fact, the only way
    to create instances of a specific class is to use the constructors we provide.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在创建实例后立即为类的实例的字段定义值，并在访问引用创建的实例的变量之前使用构造函数时，构造函数非常有用。事实上，创建特定类的实例的唯一方法是使用我们提供的构造函数。
- en: Whenever we need specific arguments to be available at the time we create an
    instance, we can declare many different constructors with the necessary arguments
    and use them to create instances of a class. Constructors allow us to make sure
    that there is no way of creating specific classes without using the provided constructors
    that make the necessary arguments required. Thus, if the provided constructor
    requires a `radius` argument, we won't be able to create an instance of the class
    without specifying a value for the `radius` argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要在创建实例时提供特定参数时，我们可以声明许多不同的构造函数，其中包含必要的参数，并使用它们来创建类的实例。构造函数允许我们确保没有办法创建特定的类，而不使用提供必要参数的构造函数。因此，如果提供的构造函数需要一个`半径`参数，那么我们将无法创建类的实例，而不指定`半径`参数的值。
- en: Imagine that we have to code the `Rectangle` class as a standalone class that
    doesn't inherit from any other class. Before we can call either the `calculateArea`
    or `calculatePerimeter` methods, we want both the `width` and `height` fields
    for each new `Rectangle` instance to have their values initialized to the appropriate
    values that represent each rectangle. We don't want new `Rectangle` instances
    to be created without specifying an appropriate value for the `width` and `height`
    fields. Thus, we will declare a constructor for this class that requires values
    for `width` and `height`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们必须将`Rectangle`类编码为一个独立的类，不继承自任何其他类。在我们调用`calculateArea`或`calculatePerimeter`方法之前，我们希望每个新的`Rectangle`实例的`宽度`和`高度`字段都有一个初始化为代表每个矩形的适当值的值。我们不希望创建新的`Rectangle`实例而不指定`宽度`和`高度`字段的适当值。因此，我们将为这个类声明一个需要`宽度`和`高度`值的构造函数。
- en: Introducing garbage collection
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入垃圾收集
- en: At some specific time, your application won't require to work with an instance
    anymore. For example, once you have calculated the perimeter of a circle and you
    have returned the necessary data in the Web Service response, you don't need to
    continue working with the specific `Circle` instance anymore. Some programming
    languages require you to be careful about leaving live instances alive and you
    have to explicitly destroy them and deallocate the memory that it was consuming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个特定时间，您的应用程序将不再需要使用实例。例如，一旦您计算了圆的周长，并且已经在Web服务响应中返回了必要的数据，您就不再需要继续使用特定的`Circle`实例。一些编程语言要求您小心地保留活动实例，并且必须显式销毁它们并释放它们消耗的内存。
- en: Java provides automatic memory management. The JVM runtime uses a garbage collection
    mechanism that automatically deallocates memory used by instances that aren't
    referenced anymore. The garbage collection process is extremely complicated, there
    are many different algorithms with their advantages and disadvantages, and the
    JVM has specific considerations that should be taken into account to avoid unnecessary
    huge memory pressure. However, we will keep our focus on the object's life cycle.
    In Java 9, when the JVM runtime detects you aren't referencing an instance anymore
    or the last variable that holds a reference to a specific instance has run out
    of scope, it makes the instance ready to be part of the next garbage collection
    cycle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了自动内存管理。JVM运行时使用垃圾收集机制，自动释放不再被引用的实例使用的内存。垃圾收集过程非常复杂，有许多不同的算法及其优缺点，JVM有特定的考虑因素，应该考虑避免不必要的巨大内存压力。然而，我们将专注于对象的生命周期。在Java
    9中，当JVM运行时检测到您不再引用实例，或者最后一个保存对特定实例的引用的变量已经超出范围时，它会使实例准备好成为下一个垃圾收集周期的一部分。
- en: For example, let's consider our previous example where we had four variables
    that hold references to two instances of the `Rectangle` class. Consider that
    both the `rectangle1` and the `rectangle2` variables run out of scope. The instance
    that was referenced by `rectangle1` is still being referenced by `rectangle10`,
    and the instance that was referenced by `rectangle2` is still being referenced
    by `rectangle20`. Thus, none of the instances can be removed from memory, as they
    are still being referenced. The following picture illustrates the situation. The
    variables that are out of scope have a NO sign at the right-hand side.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们先前的例子，其中有四个变量保存对`Rectangle`类的两个实例的引用。考虑到`rectangle1`和`rectangle2`变量都超出了范围。被`rectangle1`引用的实例仍然被`rectangle10`引用，而被`rectangle2`引用的实例仍然被`rectangle20`引用。因此，由于仍在被引用，没有一个实例可以从内存中删除。下图说明了这种情况。超出范围的变量在右侧有一个NO标志。
- en: '![Introducing garbage collection](img/00034.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![引入垃圾收集](img/00034.jpeg)'
- en: After `rectangle10` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    instance that is ready to be removed from memory has a recycle symbol.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rectangle10`超出范围后，它引用的实例变得可处理，因此可以安全地添加到可以从内存中删除的对象列表中。以下图片说明了这种情况。准备从内存中删除的实例具有回收符号。
- en: '![Introducing garbage collection](img/00035.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![引入垃圾收集](img/00035.jpeg)'
- en: After `rectangle20` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    two instances are ready to be removed from memory and both of them have a recycle
    symbol.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rectangle20`超出范围后，它引用的实例变得可处理，因此可以安全地添加到可以从内存中删除的对象列表中。以下图片说明了这种情况。这两个实例都准备从内存中删除，它们都有一个回收符号。
- en: '![Introducing garbage collection](img/00036.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![引入垃圾收集](img/00036.jpeg)'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JVM automatically runs the garbage collection process in the background
    and automatically claims back the memory consumed by the instances that were ready
    for garbage collection and aren't referenced anymore. We don't know when the garbage
    collection process will occur for specific instances and we shouldn't interfere
    in the process. The garbage collection algorithm has been improved in Java 9.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JVM会在后台自动运行垃圾收集过程，并自动回收那些准备进行垃圾收集且不再被引用的实例所消耗的内存。我们不知道垃圾收集过程何时会发生在特定实例上，也不应该干预这个过程。Java
    9中的垃圾收集算法已经得到改进。
- en: Imagine that we have to distribute the items that we store in a box. After we
    distribute all the items, we must throw the box in a recycle bin. We cannot throw
    the box to the recycle bin when we still have one or more items in it. We definitely
    don't want to lose the items we have to distribute because they are very expensive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们必须分发我们存放在盒子里的物品。在我们分发所有物品之后，我们必须将盒子扔进回收站。当我们还有一个或多个物品在盒子里时，我们不能将盒子扔进回收站。我们绝对不想丢失我们必须分发的物品，因为它们非常昂贵。
- en: 'The problem has a very easy solution: we just need to count the number of items
    that remain in the box. When the number of items in the box reaches zero, we can
    get rid of the box, that is, we can throw it to the recycle bin. Then, the garbage
    collection process will remove all the items that have been thrown to the recycle
    bin.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有一个非常简单的解决方案：我们只需要计算盒子中剩余物品的数量。当盒子中的物品数量达到零时，我们可以摆脱盒子，也就是说，我们可以将其扔进回收站。然后，垃圾收集过程将移除所有被扔进回收站的物品。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Luckily, we don't have to worry about throwing instances to a recycle bin. Java
    does it automatically for us. It is completely transparent for us.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必担心将实例扔进回收站。Java会自动为我们做这些。对我们来说完全透明。
- en: One or more variables can hold a reference to a single instance of a class.
    Thus, it is necessary to take into account the number of references to an instance
    before Java can put an instance into the garbage collection ready list. When the
    number of references to a specific instance reaches zero, it is considered safe
    to remove the instance from memory and claim back the memory consumed by the instance
    because nobody needs this specific instance anymore. At this time, the instance
    is ready to be removed by the garbage collection process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个变量可以持有对类的单个实例的引用。因此，在Java可以将实例放入准备进行垃圾收集的列表之前，有必要考虑对实例的引用数量。当对特定实例的引用数量达到零时，可以安全地从内存中删除该实例并回收该实例消耗的内存，因为没有人再需要这个特定的实例。此时，实例已准备好被垃圾收集过程移除。
- en: For example, we can create an instance of a class and assign it to a variable.
    Java will know that there is one reference to this instance. Then, we can assign
    the same instance to another variable. Java will know there are two references
    to this single instance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个类的实例并将其分配给一个变量。Java将知道有一个引用指向这个实例。然后，我们可以将相同的实例分配给另一个变量。Java将知道有两个引用指向这个单一实例。
- en: After the first variable runs out of scope, the second variable that holds a
    reference to the instance will still be accessible. Java will know there is still
    another variable that holds a reference to this instance, and therefore, the instance
    won't be ready for garbage collection. At this point, the instance must still
    be available, that is, we need it alive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个变量超出范围后，仍然可以访问持有对实例的引用的第二个变量。Java将知道仍然有另一个变量持有对这个实例的引用，因此该实例不会准备进行垃圾收集。此时，实例仍然必须可用，也就是说，我们需要它存活。
- en: After the second variable runs out of scope, there are no more variables that
    hold a reference to the instance. At this point, Java will mark the instance as
    ready for garbage collection because there are no more variables holding a reference
    to the instance and it can be safely removed from memory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个变量超出范围后，没有更多的变量持有对实例的引用。此时，Java将标记该实例为准备进行垃圾收集，因为没有更多的变量持有对该实例的引用，可以安全地从内存中删除。
- en: Declaring classes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明类
- en: The following lines declare a new minimal `Rectangle` class in Java. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_01.java` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个新的最小`Rectangle`类在Java中。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_01.java`文件中。
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `class` keyword, followed by the class name (`Rectangle`), composes the
    header of the class definition. In this case, we don't specify a parent class
    or superclass for the `Rectangle` class. A pair of curly braces (`{}`) encloses
    the class body after the class header. In the forthcoming chapters, we will declare
    classes that inherit from another class, and therefore, they will have a superclass.
    In this case, the class body is empty. The `Rectangle` class is the simplest possible
    class we can declare in Java 9.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`关键字，后面跟着类名（`Rectangle`），构成了类定义的头部。在这种情况下，我们没有为`Rectangle`类指定父类或超类。大括号（`{}`）对在类头部之后包围了类体。在接下来的章节中，我们将声明从另一个类继承的类，因此它们将有一个超类。在这种情况下，类体是空的。`Rectangle`类是我们可以在Java
    9中声明的最简单的类。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any new class you create that doesn't specify a superclass will be a subclass
    of the `java.lang.Object` class. Thus, the `Rectangle` class is a subclass of
    `java.lang.Object`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你创建的新类，如果没有指定超类，将会是`java.lang.Object`类的子类。因此，`Rectangle`类是`java.lang.Object`的子类。
- en: The following lines represent an equivalent way of creating the `Rectangle`
    class. However, we don't need to specify that the class inherits from `java.lang.Object`
    because it adds unnecessary boilerplate code. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_02.java`
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代表了创建`Rectangle`类的等效方式。然而，我们不需要指定类继承自`java.lang.Object`，因为这会增加不必要的样板代码。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_02.java`文件中。
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Customizing constructors and initialization
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义构造函数和初始化
- en: We want to initialize instances of the `Rectangle` class with the width and
    height values for the new rectangle. In order to do so, we can take advantage
    of the previously introduced constructors. Constructors are special class methods
    that are automatically executed when we create an instance of a given type. Java
    runs the code within the constructor before any other code within a class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用新矩形的宽度和高度值来初始化`Rectangle`类的实例。为了做到这一点，我们可以利用之前介绍的构造函数。构造函数是特殊的类方法，在我们创建给定类型的实例时会自动执行。在类内部的任何其他代码之前，Java会运行构造函数内的代码。
- en: We can define a constructor that receives both the width and height values as
    arguments, and use it to initialize the fields with the same names. We can define
    as many constructors as we want to, and therefore, we can provide many different
    ways of initializing a class. In this case, we just need one constructor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个构造函数，它接收宽度和高度值作为参数，并用它来初始化具有相同名称的字段。我们可以定义尽可能多的构造函数，因此我们可以提供许多不同的初始化类的方式。在这种情况下，我们只需要一个构造函数。
- en: The following lines create a `Rectangle` class and define a constructor within
    the class body. At this time, we aren't using access modifiers at all because
    we want to keep the class declaration as simple as possible. We will work with
    them later. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_03.java` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个`Rectangle`类，并在类体内定义了一个构造函数。此时，我们并没有使用访问修饰符，因为我们希望保持类声明尽可能简单。我们稍后会使用它们。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_03.java`文件中。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor is a class method that uses the same name as the class: `Rectangle`.
    In our sample `Rectangle` class, the constructor receives two arguments of the
    `double` type: `width` and `height`. The code within the constructor prints a
    message indicating that the code is initializing a new `Rectangle` instance and
    prints the values for the `width` and `height`. This way, we will understand when
    the code within the constructor is executed. Because the constructor has an argument,
    it is known as a **parameterized constructor**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个使用与类相同名称的类方法：`Rectangle`。在我们的示例`Rectangle`类中，构造函数接收`double`类型的两个参数：`width`和`height`。构造函数内的代码打印一条消息，指示代码正在初始化一个新的`Rectangle`实例，并打印`width`和`height`的值。这样，我们将了解构造函数内的代码何时被执行。因为构造函数有一个参数，它被称为**参数化构造函数**。
- en: Then, the following line assigns the `width` double value received as an argument
    to the `width` double field. We use `this.width` to access the `width` field for
    the instance and `width` to reference the argument. The `this` keyword provides
    access to the instance that has been created and we want to initialize, that is,
    the object that is being built. We use `this.height` to access the `height` field
    for the instance and `height` to reference the argument.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下行将作为参数接收的`width`双精度值分配给`width`双精度字段。我们使用`this.width`来访问实例的`width`字段，使用`width`来引用参数。`this`关键字提供了对已创建的实例的访问，我们希望初始化的对象，也就是正在构建的对象。我们使用`this.height`来访问实例的`height`字段，使用`height`来引用参数。
- en: The two lines before the constructor declare the `width` and `height` double
    field. These two fields are member variables that we can access without restrictions
    after the constructor finishes its execution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数之前的两行声明了`width`和`height`双精度字段。这两个字段是成员变量，在构造函数执行完毕后我们可以无限制地访问它们。
- en: The following lines create four instances of the `Rectangle` class named `rectangle1`,
    `rectangle2`, `rectangle3`, and `rectangle4`. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_04.java`
    file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了`Rectangle`类的四个实例，分别命名为`rectangle1`、`rectangle2`、`rectangle3`和`rectangle4`。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_04.java`文件中。
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each line that creates an instance specifies the type for the new variable (`Rectangle`)
    followed by the variable name that will hold the reference to the new instance
    (`rectangle1`, `rectangle2`, `rectangle3`, or `rectangle4`). Then each line assigns
    the result of using the `new` keyword followed by the desired value for the `width`
    and `height` arguments separated by a comma and enclosed in parentheses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例的每一行都指定了新变量（`Rectangle`）的类型，然后是将保存对新实例的引用的变量名（`rectangle1`、`rectangle2`、`rectangle3`或`rectangle4`）。然后，每一行都分配了使用`new`关键字后跟由逗号分隔并括在括号中的`width`和`height`参数的所需值的结果。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Java 9, we have to specify the type for the variable in which we want to
    hold the reference to an instance. In this case, we declare each variable with
    the `Rectangle` type. In case you have experience with other programming languages
    that provide a keyword to generate implicitly typed local variables such as the
    `var` keyword in C#, you must know there is no equivalent in Java 9.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，我们必须指定要保存对实例的引用的变量的类型。在这种情况下，我们使用`Rectangle`类型声明每个变量。如果您有其他编程语言的经验，这些语言提供了一个关键字来生成隐式类型的局部变量，比如C#中的`var`关键字，您必须知道在Java
    9中没有相应的关键字。
- en: 'After we enter all the lines that declare the class and create the four instances
    in JShell, we will see four messages that say `"Initializing a new Rectangle instance"`
    followed by the width and height values specified in the call to the constructor
    of each instance. The following screenshot shows the results of executing the
    code in JShell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入了声明类和在JShell中创建了四个实例的所有行之后，我们将看到四条消息，这些消息说“正在初始化新的Rectangle实例”，然后是在构造函数调用中指定的宽度和高度值。以下截图显示了在JShell中执行代码的结果：
- en: '![Customizing constructors and initialization](img/00037.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![自定义构造函数和初始化](img/00037.jpeg)'
- en: After we execute the previous lines, we can check the values for the `width`
    and `height` fields for each of the instances we have created. The following lines
    show expressions that JShell can evaluate to display the values for each field.
    The code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_05.java` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了前面的行之后，我们可以检查我们创建的每个实例的`width`和`height`字段的值。以下行显示了JShell可以评估的表达式，以显示每个字段的值。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_05.java`文件中。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following screenshot shows the results of evaluating the previous expressions
    in JShell.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中评估先前表达式的结果。
- en: '![Customizing constructors and initialization](img/00038.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![自定义构造函数和初始化](img/00038.jpeg)'
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_06.java` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下表达式。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_06.java`文件中。
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is an instance of the `Rectangle` class. The `instanceof`
    keyword allows us to test whether an object is of the specified type. With this
    keyword, we can determine whether an object is a `Rectangle` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示`true`作为对先前表达式的评估结果，因为`rectangle1`是`Rectangle`类的一个实例。`instanceof`关键字允许我们测试对象是否为指定类型。使用此关键字，我们可以确定对象是否为`Rectangle`对象。
- en: As previously explained, `Rectangle` is a subclass of the `java.lang.Object`
    class. JShell already imported all the types from `java.lang`, and therefore,
    we can just reference this class as `Object`. Enter the following expression in
    JShell. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_07.java` file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Rectangle`是`java.lang.Object`类的一个子类。JShell已经从`java.lang`导入了所有类型，因此，我们可以将这个类简称为`Object`。在JShell中输入以下表达式。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_07.java`文件中。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is also an instance of the `java.lang.Object` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示`true`作为对先前表达式的评估结果，因为`rectangle1`也是`java.lang.Object`类的一个实例。
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_08.java` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下表达式。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_08.java`文件中。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JShell will display `"Rectangle"` as a result for the previous line because
    the `rectangle1` variable holds an instance of the `Rectangle` class. The `getClass`
    method allows us to retrieve the runtime class of an object. The method is inherited
    from the `java.lang.Object` class. The `getName` method converts the runtime type
    to a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示`"Rectangle"`作为先前行的结果，因为`rectangle1`变量持有`Rectangle`类的一个实例。`getClass`方法允许我们检索对象的运行时类。该方法是从`java.lang.Object`类继承的。`getName`方法将运行时类型转换为字符串。
- en: Now, we will try to create an instance of `Rectangle` without providing arguments.
    The following line won't allow Java to compile the code and will display a build
    error in JShell because the compiler cannot find a parameterless constructor declared
    in the `Rectangle` class. The only constructor declared for this class requires
    two `double` arguments, and therefore, Java doesn't allow `Rectangle` instances
    to be created without specifying the values for `width` and `height`. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_09.java` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试创建一个`Rectangle`的实例，而不提供参数。以下行不会允许Java编译代码，并且将在JShell中显示构建错误，因为编译器找不到在`Rectangle`类中声明的无参数构造函数。对于这个类声明的唯一构造函数需要两个`double`参数，因此，Java不允许创建未指定`width`和`height`值的`Rectangle`实例。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_09.java`文件中。
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next screenshot shows the detailed error message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了详细的错误消息：
- en: '![Customizing constructors and initialization](img/00039.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![自定义构造函数和初始化](img/00039.jpeg)'
- en: Understanding how garbage collection works
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解垃圾回收的工作原理
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following lines show the new complete code for the `Rectangle` class. The
    new lines are highlighted. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_10.java` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Rectangle`类的新完整代码。新的行已经突出显示。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_10.java`文件中。
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new lines declare a `finalize` method that overrides the inherited method
    from `java.lang.Object` and prints a message indicating that it is finalizing
    a `Rectangle` instance and displays the width and height values for the instance.
    Don't worry about the pieces of the code that you don't understand yet because
    we will learn them in the forthcoming chapters. The goal for the new piece of
    code included in the class is to let us know when the garbage collection process
    is going to remove the object from memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 新的行声明了一个`finalize`方法，覆盖了从`java.lang.Object`继承的方法，并打印一条消息，指示正在完成`Rectangle`实例，并显示实例的宽度和高度值。不要担心你尚不理解的代码片段，因为我们将在接下来的章节中学习它们。包含在类中的新代码的目标是让我们知道垃圾收集过程何时将对象从内存中删除。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid writing code that overrides the `finalize` method. Java 9 doesn't promote
    the usage of the `finalize` method to perform cleanup operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 避免编写覆盖`finalize`方法的代码。Java 9不鼓励使用`finalize`方法执行清理操作。
- en: The following lines create two instances of the `Rectangle` class named `rectangleToCollect1`
    and `rectangleToCollect2`. Then, the next lines assign `null` to both variables,
    and therefore, the reference count for both objects reaches zero and they become
    ready for garbage collection. The two instances can be safely removed from memory
    because there are no more variables in scope holding a reference to them. The
    code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_11.java` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了两个名为`rectangleToCollect1`和`rectangleToCollect2`的`Rectangle`类实例。然后，下一行将`null`分配给这两个变量，因此，两个对象的引用计数都达到了零，它们已准备好进行垃圾收集。这两个实例可以安全地从内存中删除，因为作用域中没有更多变量持有对它们的引用。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_11.java`文件中。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上述行的结果：
- en: '![Understanding how garbage collection works](img/00040.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![理解垃圾收集的工作原理](img/00040.jpeg)'
- en: The two rectangle instances can be safely removed from memory but we don't see
    the messages indicating that the `finalize` method has been executed for each
    of these instances. Remember that we don't know when the garbage collection process
    will determine that it is necessary to claim back the memory used by these instances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 两个矩形实例可以安全地从内存中删除，但我们没有看到消息表明对这些实例的`finalize`方法已被执行。请记住，我们不知道垃圾收集过程何时确定有必要回收这些实例使用的内存。
- en: In order to understand how the garbage collection process works, we will force
    a garbage collection. However, it is very important to understand that we should
    never force a garbage collection in real-life applications. We must leave the
    JVM select the most appropriate time to perform a collection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解垃圾收集过程的工作原理，我们将强制进行垃圾收集。但是，非常重要的是要理解，在实际应用中我们不应该强制进行垃圾收集。我们必须让JVM在最合适的时机执行收集。
- en: The next line shows the code that calls the `System.gc` method to force the
    JVM to perform a garbage collection. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_12.java` file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行显示了调用`System.gc`方法强制JVM执行垃圾收集的代码。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_12.java`文件中。
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following screenshot shows the results of executing the previous line in
    JShell. We will see the messages that indicate that the `finalize` method for
    the two instances has been called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上述行的结果。我们将看到表明两个实例的`finalize`方法已被调用的消息。
- en: '![Understanding how garbage collection works](img/00041.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![理解垃圾收集的工作原理](img/00041.jpeg)'
- en: The following lines create an instance of the `Rectangle` class named `rectangle5`
    and then assign a reference to this object to the `referenceToRectangle5` variable.
    This way, the reference count to the object increases to two. The next line assigns
    `null` to `rectangle5` and makes the reference count for the object to go down
    from two to one. The `referenceToRectangle5` variable stills holds a reference
    to the `Rectangle` instance, and therefore, the next line that forces a garbage
    collection won't remove the instance from memory and we won't see the results
    of the execution of the code in the `finalize` method. There is still one variable
    on scope that holds a reference to the instance. The code file for the sample
    is included in the `java_9_oop_chapter_03_01` folder, in the `example03_13.java`
    file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`rectangle5`的`Rectangle`类实例，然后将一个引用分配给`referenceToRectangle5`变量。这样，对象的引用计数增加到两个。下一行将`null`分配给`rectangle5`，使得对象的引用计数从两个减少到一个。`referenceToRectangle5`变量仍然持有对`Rectangle`实例的引用，因此，下一行强制进行垃圾收集不会将实例从内存中删除，我们也不会看到在`finalize`方法中代码执行的结果。仍然有一个在作用域中持有对实例的引用的变量。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_13.java`文件中。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上述行的结果：
- en: '![Understanding how garbage collection works](img/00042.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![理解垃圾收集的工作原理](img/00042.jpeg)'
- en: Now, we will execute a line that assigns `null` to `referenceToRectangle5` to
    force the reference count to reach zero for the referenced instance and we will
    force the garbage collection process to run in the next line. The code file for
    the sample is included in the `java_9_oop_chapter_03_01` folder, in the `example03_14.java`
    file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行一行代码，将`null`分配给`referenceToRectangle5`，以使引用实例的引用计数达到零，并在下一行强制运行垃圾收集过程。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_14.java`文件中。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行前几行的结果。我们将看到指示实例的`finalize`方法已被调用的消息。
- en: '![Understanding how garbage collection works](img/00043.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![了解垃圾回收的工作原理](img/00043.jpeg)'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is very important to know that you don't need to assign `null` to a reference
    to force the JVM to claim back the memory from objects. In the previous examples,
    we wanted to understand how the garbage collection worked. Java will automatically
    destroy the objects when they aren't referenced anymore in a transparent way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，你不需要将引用赋值为`null`来强制JVM从对象中回收内存。在前面的例子中，我们想要了解垃圾回收的工作原理。Java会在对象不再被引用时自动以透明的方式销毁对象。
- en: Creating instances of classes and understanding their scope
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类的实例并了解它们的作用域
- en: We will write a few lines of code that create an instance of the `Rectangle`
    class named `rectangle` within the scope of a `getGeneratedRectangleHeight` method.
    The code within the method uses the created instance to access and return the
    value of its `height` field. In this case, the code uses the `final` keyword as
    a prefix to the `Rectangle` type to declare an **immutable reference** to the
    `Rectangle` instance named `rectangle`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写几行代码，在`getGeneratedRectangleHeight`方法的作用域内创建一个名为`rectangle`的`Rectangle`类的实例。方法内的代码使用创建的实例来访问并返回其`height`字段的值。在这种情况下，代码使用`final`关键字作为`Rectangle`类型的前缀来声明对`Rectangle`实例的**不可变引用**。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An immutable reference is also known as a constant reference because we cannot
    replace the reference held by the `rectangle` constant with another instance of
    `Rectangle`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变引用也被称为常量引用，因为我们不能用另一个`Rectangle`实例替换`rectangle`常量持有的引用。
- en: After we define the new method, we will call it and we will force a garbage
    collection. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_15.java` file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义新方法后，我们将调用它并强制进行垃圾回收。示例的代码文件包含在`java_9_oop_chapter_03_01`文件夹中的`example03_15.java`文件中。
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called after the call to the `getGeneratedRectangleHeight`
    method and the next call to force the garbage collection. When the method returns
    a value, rectangle becomes out of scope because its reference count goes down
    from one to zero.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行前几行的结果。我们将看到在调用`getGeneratedRectangleHeight`方法后，指示实例的`finalize`方法已被调用，并在下一次强制垃圾回收时的消息。当方法返回一个值时，矩形会超出作用域，因为它的引用计数从1下降到0。
- en: The instanced reference by immutable variable is safe for garbage collection.
    Thus, when we force the garbage collection, we see the message displayed by the
    `finalize` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不可变变量引用的实例是安全的垃圾回收。因此，当我们强制进行垃圾回收时，我们会看到`finalize`方法显示的消息。
- en: '![Creating instances of classes and understanding their scope](img/00044.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![创建类的实例并了解它们的作用域](img/00044.jpeg)'
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you understand an object's life cycle, it is time to spend some time
    in JShell creating new classes and instances.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了对象的生命周期，是时候在JShell中花一些时间创建新的类和实例了。
- en: Exercise 1
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1
- en: 'Create a new `Student` class with a constructor that requires two `String`
    arguments: `firstName` and `lastName`. Use the arguments to initialize fields
    with the same names as the arguments. Display a message with the values for `firstName`
    and `lastName` when an instance of the class is created.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Student`类，其中包含一个需要两个`String`参数`firstName`和`lastName`的构造函数。使用这些参数来初始化与参数同名的字段。在创建类的实例时显示一个带有`firstName`和`lastName`值的消息。
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Student`类的实例并将其分配给一个变量。检查在JShell中打印的消息。
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Student`类的实例并将其分配给一个变量。检查在JShell中打印的消息。
- en: Exercise 2
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2
- en: 'Create a function that receives two `String` arguments: `firstName` and `lastName`.
    Create an instance of the previously defined `Student` class with the received
    arguments as parameters for the creation of the instance. Use the instance properties
    to print a message with the first name followed by a space and the last name.
    You will be able to create a method and add it to the `Student` class later to
    perform the same task. However, we will learn more about this in the forthcoming
    chapters.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接收两个`String`参数`firstName`和`lastName`的函数。使用接收到的参数来创建先前定义的`Student`类的实例。使用实例属性打印一个带有名字和姓氏的消息。稍后你可以创建一个方法并将其添加到`Student`类中来执行相同的任务。但是，我们将在接下来的章节中了解更多相关内容。
- en: Call the previously created function with the necessary arguments. Check the
    message printed in JShell.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用必要的参数调用先前创建的函数。检查在JShell中打印的消息。
- en: Test your knowledge
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'When Java executes the code within a constructor:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Java执行构造函数中的代码时：
- en: We cannot access any members defined in the class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们无法访问类中定义的任何成员。
- en: There is already a live instance of the class. We can access methods defined
    in the class but we cannot access its fields.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类已经存在一个活动实例。我们可以访问类中定义的方法，但无法访问其字段。
- en: There is already a live instance of the class and we can access its members.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类已经存在一个活动实例，我们可以访问它的成员。
- en: 'Constructors are extremely useful to:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数非常有用：
- en: Execute setup code and properly initialize a new instance.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行设置代码并正确初始化一个新实例。
- en: Execute cleanup code before the instance is destroyed.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例被销毁之前执行清理代码。
- en: Declare methods that will be accessible to all the instances of the class.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明将对类的所有实例可访问的方法。
- en: 'Java 9 uses one of the following mechanisms to automatically deallocate the
    memory used by instances that aren''t referenced anymore:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9 使用以下机制之一来自动释放不再被引用的实例使用的内存：
- en: Instance map reduce.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例映射减少。
- en: Garbage compression.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾压缩。
- en: Garbage collection.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集。
- en: 'Java 9 allows us to define:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9允许我们定义：
- en: A main constructor and two optional secondary constructors.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个主构造函数和两个可选的次要构造函数。
- en: Many constructors with different arguments.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多具有不同参数的构造函数。
- en: Only one constructor per class.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类只有一个构造函数。
- en: 'Any new class we create that doesn''t specify a superclass will be a subclass
    of:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的任何不指定超类的新类都将是一个子类：
- en: '`java.lang.Base`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.lang.Base`'
- en: '`java.lang.Object`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`'
- en: '`java.object.BaseClass`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.object.BaseClass`'
- en: 'Which of the following lines create an instance of the `Rectangle` class and
    assign its reference to the `rectangle` variable:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行创建了`Rectangle`类的一个实例并将其引用分配给`rectangle`变量：
- en: '`var rectangle = new Rectangle(50, 20);`'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var rectangle = new Rectangle(50, 20);`'
- en: '`auto rectangle = new Rectangle(50, 20);`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`auto rectangle = new Rectangle(50, 20);`'
- en: '`Rectangle rectangle = new Rectangle(50, 20);`'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rectangle rectangle = new Rectangle(50, 20);`'
- en: 'Which of the following lines access the `width` field for the `rectangle` instance:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行访问了`rectangle`实例的`width`字段：
- en: '`rectangle.field`'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle.field`'
- en: '`rectangle..field`'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle..field`'
- en: '`rectangle->field`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle->field`'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about an object's life cycle. You also learned
    how object constructors work. We declared our first simple class to generate a
    blueprint for objects. We understood how types, variables, classes, constructors,
    instances, and garbage collection work with live examples in JShell.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了对象的生命周期。您还了解了对象构造函数的工作原理。我们声明了我们的第一个简单类来生成对象的蓝图。我们了解了类型、变量、类、构造函数、实例和垃圾收集是如何在JShell中的实时示例中工作的。
- en: Now that you have learned to start creating classes and instances, we are ready
    to share, protect, use, and hide data with the data encapsulation features included
    in Java 9, which is what we are going to discuss in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了开始创建类和实例，我们准备在Java 9中包含的数据封装功能中分享、保护、使用和隐藏数据，这是我们将在下一章讨论的内容。
