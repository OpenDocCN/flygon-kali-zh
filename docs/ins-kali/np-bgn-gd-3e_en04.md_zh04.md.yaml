- en: Chapter 4. Convenience Functions for Your Convenience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：为您带来便利的便利函数
- en: '*As we have seen, NumPy has a great number of functions. Many of those functions
    exist just for convenience, and knowing them will greatly increase your productivity.
    This includes functions that select certain parts of your arrays (based on a Boolean
    condition, for instance) or manipulate polynomials. This chapter has an example
    of computing correlation to give you a taste of data analysis with NumPy.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，NumPy 具有大量函数。 这些函数中的许多函数只是为了方便起见，知道这些函数将大大提高您的生产率。 这包括选择数组某些部分（例如，基于布尔条件）或处理多项式的函数。
    本章提供了一个计算相关性示例，使您可以使用 NumPy 进行数据分析。
- en: 'In this chapter, we shall cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Data selection and extraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据选择与提取
- en: Simple data analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的数据分析
- en: Examples of correlation of returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收益相关的示例
- en: Polynomials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式
- en: Linear algebra functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性代数函数
- en: In [Chapter 3](ch03.html "Chapter 3. Getting Familiar with Commonly Used Functions"),
    *Getting Familiar with Commonly Used Functions*, we had one data file to play
    around with. Things have improved in this chapter—we now have two data files.
    Let's explore the data with NumPy.
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章，“熟悉常用函数”中，我们有一个数据文件可以使用。 在本章中，情况有所改善-我们现在有两个数据文件。 让我们使用 NumPy 探索数据。
- en: Correlation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关
- en: Have you noticed that the stock price of some companies will be closely followed
    by another, usually a rival in the same sector? The theoretical explanation is
    that because these two companies are in the same type of business, they share
    the same challenges, require the same materials and resources, and compete for
    the same type of customers.
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到某些公司的股价会紧随其后，通常是同一行业的竞争对手？ 理论上的解释是，由于这两家公司属于同一类型的业务，因此它们面临着相同的挑战，需要相同的材料和资源，并争夺相同类型的客户。
- en: You could think of many possible pairs, but you need to check for a real relationship.
    One way is to take a look at the correlation of the stock returns of both stocks
    (see [https://www.khanacademy.org/math/probability/statistical-studies/types-of-studies/v/correlation-and-causality](https://www.khanacademy.org/math/probability/statistical-studies/types-of-studies/v/correlation-and-causality)).
    A high correlation implies a relationship of some sort. It is not proof of causality
    though, especially if you don't use sufficient data.
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想到了许多可能的对，但是您需要检查一下真实的关系。 一种方法是查看两种股票的股票收益的相关性和因果关系（见[`www.khanacademy.org/math/probability/statistical-studies/types-of-studies/v/correlation-and-causality`](https://www.khanacademy.org/math/probability/statistical-studies/types-of-studies/v/correlation-and-causality)）。
    高相关性意味着某种关系。 但是，这并不是因果关系的证明，尤其是如果您没有使用足够的数据。
- en: Time for action – trading correlated pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：交易相关货币对
- en: 'For this section, we will use two sample datasets, containing end-of-day price
    data. The first company is BHP Billiton (BHP), which is active in mining of petroleum,
    metals, and diamonds. The second is Vale (VALE), which is also a metals and mining
    company. So, there is some overlap of activity, albeit not 100 percent. For evaluating
    correlated pairs, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两个样本数据集，其中包含日末价格数据。 第一家公司是必和必拓（`BHP`），该公司活跃于石油，金属和钻石的开采。 第二个是淡水河谷（`VALE`），这也是一家金属和采矿公司。
    因此，活动有一些重叠，尽管不是 100%。 要评估相关偶对，请按照下列步骤操作：
- en: First, load the data, specifically the close price of the two securities, from
    the CSV files in the example code directory of this chapter and calculate the
    returns. If you don't remember how to do it, look at the examples in [Chapter
    3](ch03.html "Chapter 3. Getting Familiar with Commonly Used Functions"), *Getting
    Familiar with Commonly Used Functions*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从本章示例代码目录中的 CSV 文件加载数据，特别是两种证券的收盘价，并计算收益。 如果您不记得该怎么做，请参阅第三章，“熟悉常用函数”中的示例。
- en: 'Covariance tells us how two variables vary together; which is nothing more than
    unnormalized correlation (see [https://www.khanacademy.org/math/probability/regression/regression-correlation/v/covariance-and-the-regression-line](https://www.khanacademy.org/math/probability/regression/regression-correlation/v/covariance-and-the-regression-line)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协方差告诉我们两个变量如何一起变化；无非就是相关性（见[`khanacademy.org/math/probability/regression/regression-correlation/v/covariance-and-the-regression-lin`](https://www.khanacademy.org/math/probability/regression/regression-correlation/v/covariance-and-the-regression-line)）：
- en: '![Time
    for action – trading correlated pairs](img/4154_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：交易相关货币对](img/4154_04_04.jpg)'
- en: 'Compute the covariance matrix from the returns with the `cov()` function (it''s
    not strictly necessary to do this, but it will allow us to demonstrate a few matrix
    operations):'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cov()`函数从返回值计算协方差矩阵（并非严格如此，但这可以让我们演示一些矩阵运算）：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The covariance matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵如下：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'View the values on the diagonal with the `diagonal()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`diagonal()`方法查看对角线上的值：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The diagonal values of the covariance matrix are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵的对角线值如下：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the values on the diagonal are not equal to each other. This is
    different from the correlation matrix.
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对角线上的值彼此不相等。 这与相关矩阵不同。
- en: 'Compute the trace, the sum of the diagonal values, with the `trace()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`trace()`方法计算轨迹，即对角线值的总和：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The trace values of the covariance matrix are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差矩阵的跟踪值如下：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The correlation of two vectors is defined as the covariance, divided by the
    product of the respective standard deviations of the vectors. The equation for
    vectors `a` and `b` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个向量的相关性定义为协方差，除以向量各自标准偏差的乘积。 向量`a`和`b`的等式如下：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The correlation matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 相关矩阵如下：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will measure the correlation of our pair with the correlation coefficient.
    The correlation coefficient takes values between `-1` and `1`. The correlation
    of a set of values with itself is `1` by definition. This would be the ideal value;
    however, we will also be happy with a slightly lower value. Calculate the correlation
    coefficient (or, more accurately, the correlation matrix) with the `corrcoef()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用相关系数来衡量我们偶对的相关性。 相关系数取介于 -1 和 1 之间的值。 根据定义，一组值与自身的相关性为 1。 这将是理想值； 但是，我们也会对较低的值感到满意。
    使用`corrcoef()`函数计算相关系数（或更准确地说，相关矩阵）：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The coefficients are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 系数如下：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The values on the diagonal are just the correlations of the BHP and VALE with
    themselves and are, therefore, equal to 1\. In all likelihood, no real calculation
    takes place. The other two values are equal to each other since correlation is
    symmetrical, meaning that the correlation of BHP with VALE is equal to the correlation
    of VALE with BHP. It seems that here the correlation is not that strong.
  prefs: []
  type: TYPE_NORMAL
  zh: 对角线上的值仅是`BHP`和`VALE`与它们自身的相关性，因此等于 1。在任何可能性下，都不会进行任何实际计算。 由于相关性是对称的，因此其他两个值彼此相等，这意味着`BHP`与`VALE`的相关性等于`VALE`与`BHP`的相关性。
    似乎这里的相关性不是那么强。
- en: Another important point is whether the two stocks under consideration are in
    sync or not. Two stocks are considered out of sync if their difference is two
    standard deviations from the mean of the differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个要点是，正在考虑的两只股票是否同步。 如果两只股票的差额是与均值之差的两个标准差，则认为它们不同步。
- en: 'If they are out of sync, we could initiate a trade, hoping that they will eventually
    get back in sync again. Compute the difference between the close prices of the
    two securities to check the synchronization:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们不同步，我们可以发起交易，希望它们最终能够再次恢复同步。 计算两种证券的收盘价之间的差异，以检查同步：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check whether the last difference in price is out of sync; see the following
    code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 检查最后的价格差异是否不同步； 请参阅以下代码：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unfortunately, we cannot trade yet:'
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们还不能交易：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Plotting requires `matplotlib`; this will be discussed in [Chapter 9](ch09.html
    "Chapter 9. Plotting with matplotlib"), *Plotting with matplotlib*. Plotting can
    be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘图需要`matplotlib`；这将在第九章"matplotlib 绘图”中讨论。 可以按以下方式进行绘制：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting plot is shown here:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如下所示：
- en: '![Time for action – trading correlated pairs](img/4154_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：交易相关货币对](img/4154_04_01.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We analyzed the relation of the closing stock prices of BHP and VALE. To be
    precise, we calculated the correlation of their stock returns. We achieved this
    with the `corrcoef()` function. Furthermore, we saw how to compute the covariance
    matrix from which the correlation can be derived. As a bonus, we demonstrated
    the `diagonal()` and `trace()` methods that give us the diagonal values and the
    trace of a matrix, respectively. For the source code, see the `correlation.py`
    file in this book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了`BHP`和`VALE`收盘价的关系。 确切地说，我们计算了他们的股票收益的相关性。 我们通过  `corrcoef()`函数实现了这一目标。
    此外，我们看到了如何计算可以从中得出相关性的协方差矩阵。 另外，我们演示了`diagonal()`和`trace()`方法，它们分别为我们提供对角线值和矩阵迹线。
    有关源代码，请参见本书代码包中的`correlation.py`文件：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pop quiz – calculating covariance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验 - 计算协方差
- en: Q1\. Which function returns the covariance of two arrays?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个函数返回两个数组的协方差？
- en: covariance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`covariance`'
- en: covar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`covar`'
- en: cov
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cov`'
- en: cvar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cvar`'
- en: Polynomials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式
- en: Do you like calculus? Well I love it! One of the ideas in calculus is **Taylor
    expansion**, that is, representing a differentiable function as an infinite series
    (see [https://www.khanacademy.org/math/integral-calculus/sequences_series_approx_calc/taylor-series/v/generalized-taylor-series-approximation](https://www.khanacademy.org/math/integral-calculus/sequences_series_approx_calc/taylor-series/v/generalized-taylor-series-approximation)
    and [http://en.wikipedia.org/wiki/Taylor_series](http://en.wikipedia.org/wiki/Taylor_series).).
  prefs: []
  type: TYPE_NORMAL
  zh: 您喜欢微积分吗？ 好吧，我喜欢它！ 微积分学中的一种思想是**泰勒展开**，即代表无穷级数的可微函数（请参见[`www.khanacademy.org/math/integral-calculus/sequences_series_approx_calc/taylor-series/v/generalized-taylor-series-approximation`](https://www.khanacademy.org/math/integral-calculus/sequences_series_approx_calc/taylor-series/v/generalized-taylor-series-approximation)和[`en.wikipedia.org/wiki/Taylor_series`](http://en.wikipedia.org/wiki/Taylor_series)）。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Taylor series is defined as the following sum:'
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数的定义如下所示：
- en: '![Polynomials](img/4154_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![多项式](img/4154_04_05.jpg)'
- en: '![Polynomials](img/4154_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![多项式](img/4154_04_06.jpg)'
- en: in this definition is the *nth* derivative of the function *f* computed at the
    point *a*.
  prefs: []
  type: TYPE_NORMAL
  zh: 在此定义中，是在点`a`上计算的函数`f`的`n`阶导数。
- en: In practice, this means that we can estimate any differentiable, and therefore
    continuous, function with a polynomial of a high degree. We would then assume
    that the terms of the higher degrees are negligibly small.
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着我们可以使用高阶多项式来估计任何可微的，因此是连续的函数。 然后，我们假设较高学位的条款可以忽略不计。
- en: Time for action – fitting to polynomials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：拟合多项式
- en: 'The NumPy `polyfit()` function fits a set of data points to a polynomial, even
    if the underlying function is not continuous:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `polyfit()`函数拟合多项式的一组数据点，即使基础函数不是连续的：
- en: 'Continuing with the price data of BHP and VALE, look at the difference of their
    close prices and fit it to a polynomial of the third power:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用`BHP`和`VALE`的价格数据，查看其收盘价之间的差异，并将其拟合为三次方的多项式：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The polynomial fit (in this example, a cubic polynomial was chosen) is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式拟合（在此示例中，选择了三次多项式）如下：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The numbers you see are the coefficients of the polynomial. Extrapolate to
    the next value with the `polyval()` function and the polynomial object that we
    got from the fit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您看到的数字是多项式的系数。 用`polyval()`函数和我们从拟合中得到的多项式对象外插到下一个值：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next value we predict will be this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预测的下一个值将是：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ideally, the difference between the close prices of BHP and VALE should be
    as small as possible. In an extreme case, it might be zero at some point. Find
    out when our polynomial fit reaches zero with the `roots()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理想情况下，`BHP`和`VALE`的收盘价之间的差异应尽可能小。 在极端情况下，它有时可能为零。 使用`roots()`函数找出多项式拟合何时达到零：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The roots of the polynomial are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的根如下：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another thing you may have learned in calculus class was to find **extrema**—these
    could be potential maxima or minima. Remember, from calculus, that these are the
    points where the derivative of our function is zero. Differentiate the polynomial
    fit with the `polyder()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微积分课上，您可能学到的另一件事是找到“极值”，这些极值可能是最大值或最小值。 从微积分中记住，这些是我们函数的导数为零的点。 用`polyder()`函数来微分多项式拟合：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The coefficients of the derivative polynomial are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 导数多项式的系数如下：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Get the roots of the derivative:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取导数的根：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The extremas that we get are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的极值如下：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s double-check and compute the values of the fit with the `polyval()`
    function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`polyval()`函数仔细检查并计算拟合值：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, find the maximum and minimum values with the `argmax()` and the `argmin()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`argmax()`和`argmin()`函数找到最大值和最小值：
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This gives us the expected results shown in the following screenshot. OK, not
    quite the same results, but, if we backtrack to step 1, we can see that `t` was
    defined with the `arange()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下屏幕快照中所示的预期结果。 好的，结果并不完全相同，但是，如果我们退回到步骤 1，我们可以看到`t`是通过  `arange()`函数定义的：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Plot the data and the fit it to get the following plot:'
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制数据并对其拟合  ，以得到以下曲线：
- en: '![Time for action – fitting to polynomials](img/4154_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：拟合多项式](img/4154_04_02.jpg)'
- en: Obviously, the smooth line is the fit and the jagged line is the underlying
    data. But as it's not that good a fit, you might want to try a higher order polynomial.
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，平滑线是拟合的，而锯齿线是基础的数据。 但是由于不太适合，您可能需要尝试更高阶的多项式。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We fit data to a polynomial with the `polyfit()` function. We learned about
    the `polyval()` function that computes the values of a polynomial, the `roots()`
    function that returns the roots of the polynomial, and the `polyder()` function
    that gives back the derivative of a polynomial (see `polynomials.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用  `polyfit()`函数将数据拟合为多项式。 我们了解了用于计算多项式值的`polyval()`函数，用于返回多项式的根的`roots()`函数以及用于返回多项式导数的`polyder()`函数（
    参见`polynomials.py`）：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Have a go hero – improving the fit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：改进拟合
- en: You could do a number of things to improve the fit. For example, try a different
    power as, in this section, a cubic polynomial was chosen. Consider smoothing the
    data before fitting it. One way you could smooth the data is with a moving average.
    You can find examples of simple and EMA calculations in the [Chapter 3](ch03.html
    "Chapter 3. Getting Familiar with Commonly Used Functions"), *Getting Familiar
    with Commonly Used Functions*.
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以做很多事情来改进拟合。 例如，尝试使用其他幂，因为在本节中选择了三次多项式。 考虑在拟合之前对数据进行平滑处理。 平滑数据的一种方法是移动平均值。
    您可以在第三章，“熟悉常用函数”中找到简单和 EMA 计算的示例。
- en: On-balance volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 余量
- en: Volume is a very important variable in investing; it indicates how big a price
    move is. The on-balance volume indicator is one of the simplest stock price indicators.
    It is based on the close price of the current and previous days and the volume
    of the current day. For each day, if the close price today is higher than the
    close price of yesterday, then the value of the on-balance volume is equal to
    the volume of today. On the other hand, if today's close price is lower than yesterday's
    close price, then the value of the on-balance volume indicator is the difference
    between the on-balance volume and the volume of today. However, if the close price
    did not change, then the value of the on-balance volume is zero.
  prefs: []
  type: TYPE_NORMAL
  zh: 交易量是在投资中非常重要的变量； 它表明价格走势有多大。 平衡交易量指标是最简单的股票价格指标之一。 它基于当日和前几日的收盘价以及当日的交易量。 对于每一天，如果今天的收盘价高于昨天的收盘价，那么余额表上的交易量的值等于今天的交易量。
    另一方面，如果今天的收盘价低于昨天的收盘价，那么资产负债表上交易量指标的值就是资产负债表上的交易量与今天的交易量之差。 但是，如果收盘价没有变化，那么余额表上的交易量的值为零。
- en: Time for action – balancing volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：平衡交易量
- en: 'In other words, we need to multiply the sign of the close price and the volume.
    In this section, we look at two approaches to this problem: one using the NumPy
    `sign()` function and the other using the NumPy `piecewise()` function.'
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要乘以收盘价和交易量的符号。 在本节中，我们研究解决此问题的两种方法：一种使用 NumPy `sign()`函数，另一种使用 NumPy
    `piecewise()`函数。
- en: 'Load the BHP data into a close and volume array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BHP`数据加载到`close`和`volume`数组中：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compute the absolute value changes. Calculate the change of the closing price
    with the `diff()` function. The `diff()` function computes the difference between
    two sequential array elements and returns an array containing these differences:'
  prefs: []
  type: TYPE_NORMAL
  zh: 计算绝对值的变化。 用`diff()`函数计算收盘价的变化。 `diff()`函数计算两个连续数组元素之间的差，并返回包含这些差的数组：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The changes of the close price are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 收盘价变化如下：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The NumPy `sign()` function returns the signs for each element in an array.
    -1 is returned for a negative number, 1 for a positive number, and 0, otherwise.
    Apply the `sign()` function to the `change` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 的`sign()`函数返回数组中每个元素的符号。 -1 表示负数，1 表示正数，否则返回 0。 将`sign()`函数应用于`change`数组：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The signs of the change array are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 更改数组的符号如下：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, we can calculate the signs with the `piecewise()` function.
    The `piecewise()` function, as its name suggests, evaluates a function piece-by-piece.
    Call the function with the appropriate return values and conditions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以用`piecewise()`函数来计算  。 顾名思义，`piecewise()`函数逐段求值函数  。 使用适当的返回值和条件调用该函数：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The signs are shown again as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志再次显示如下：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check that the outcome is the same:'
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果是否相同：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And the outcome is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The on-balance volume depends on the change of the previous close, so we cannot
    calculate it for the first day in our sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 余额的大小取决于前一个收盘价的变化，因此我们无法在样本的第一天进行计算：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The on-balance volume is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 余额余额如下：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We computed the on-balance volume that depends on the change of the closing
    price. Using the NumPy `sign()` and `piecewise()` functions, we went over two
    different methods to determine the sign of the change (see `obv.py`) as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了取决于收盘价变化的余额数量。 使用 NumPy `sign()`和`piecewise()`函数，我们遍历了两种不同的方法来确定更改的符号（请参见`obv.py`），如下所示：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: Often, you would want to try something out first. Play around, experiment, but
    preferably without blowing things up or getting dirty! NumPy is perfect for experimentation.
    We will use NumPy to simulate a trading day, without actually losing money. Many
    people like to buy on the dip or, in other words, wait for the price of stocks
    to drop before buying. A variant of this is to wait for the price to drop a small
    percentage, say 0.1 percent below the opening price of the day.
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会想先尝试一下。 玩耍，试验，但最好不要炸东西或变脏！ NumPy 非常适合进行实验。 我们将使用 NumPy 模拟交易日，而不会实际亏损。 许多人喜欢逢低买入，换句话说，等待股票价格下跌之后再购买。
    一个变种是等待价格下跌一小部分，例如比当天的开盘价低 0.1%。
- en: Time for action – avoiding loops with vectorize()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用`vectorize()`避免循环
- en: 'The `vectorize()` function is a yet another trick to reduce the number of loops
    in your programs. Calculate the profit of a single trading day following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`vectorize()`函数是  ，这是另一个可以减少程序循环次数的技巧  。 请按照以下步骤计算一个交易日的利润：'
- en: 'First, load the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，加载数据：
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `vectorize()` function is the NumPy equivalent of the Python `map()` function.
    Call the `vectorize()` function, giving it as an argument the `calc_profit()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vectorize()`函数与 Python `map()`函数的 NumPy 等效。 调用`vectorize()`函数，并将其作为参数作为`calc_profit()`函数：'
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can now apply `func()` as if it is a function. Apply the `func()` function
    result that we got to the price arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以应用`func()`，就好像它是一个函数一样。 将我们获得的的`func()`函数结果应用于价格数组：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `calc_profit()` function is pretty simple. First, we try to buy slightly
    below the open price. If this is outside of the daily range, then, obviously,
    our attempt failed and no profit was made, or we incurred a loss, therefore, will
    return 0\. Otherwise, we sell at the close price and the profit is simply the
    difference between the buy price and the close price. Actually, it is, in fact,
    more interesting to have a look at the relative profit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`calc_profit()`函数非常简单。 首先，我们尝试以较低的开盘价购买。 如果这超出每日范围，那么很明显，我们的尝试失败，没有获利，或者我们蒙受了损失，因此将返回
    0。否则，我们以收盘价卖出利润仅仅是买入价和收盘价之间的差。 实际上，查看相对利润实际上更有趣：'
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Assume that there are two days with zero profits, where there was either no
    net gain or a loss. Select the days with trades and calculate the averages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有两天的利润为零，既没有净收益也没有亏损。 选择交易日并计算平均值：
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The trades summary is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 交易摘要如下所示：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As optimists, we are interested in winning trades with a gain greater than
    zero. Select the days with winning trades and calculate the averages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为乐观主义者，我们对赢得大于零的交易感兴趣。 选择获胜交易的天数并计算平均值：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The winning trades statistics are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 获胜行业统计如下：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, as pessimists, we are interested in losing trades with a profit
    less than zero. Select the days with losing trades and calculate the averages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，作为悲观主义者，我们对小于零的亏损交易感兴趣。 选择亏损交易的天数并计算平均值：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The losing trades statistics are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 亏损交易统计如下：
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We vectorized a function, which is just another way to avoid using loops. We
    simulated a trading day with a function, which returned the relative profit of
    each day''s trade. We printed a statistics summary of the losing and winning trades
    (see `simulation.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对函数进行向量化，这是避免使用循环的另一种方法。 我们用一个函数模拟了一个交易日，该函数返回了每天交易的相对利润。 我们打印了亏损交易和获胜交易的统计摘要（请参见`simulation.py`）：
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Have a go hero – analyzing consecutive wins and losses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：分析连续的获胜和失败
- en: Although the average profit is positive, it is also important to know whether
    we had to endure a long streak of consecutive losses. If this is the case, we
    might be left with little or no capital, and then the average profit would not
    matter.
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管平均利润为正，但了解我们是否必须承受连续亏损也很重要。 如果是这种情况，我们可能只剩下很少甚至没有资本，那么平均利润就无关紧要。
- en: Find out if there was such a losing streak. If you want, you can also find out
    if there was a prolonged winning streak.
  prefs: []
  type: TYPE_NORMAL
  zh: 找出是否有这样的损失。 如果需要，您还可以找出是否有长时间的连胜纪录。
- en: Smoothing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平滑
- en: Noisy data is difficult to deal with, so we often need to do some smoothing.
    Besides calculating moving averages, we can use one of the NumPy functions to
    smooth data.
  prefs: []
  type: TYPE_NORMAL
  zh: 嘈杂的数据很难处理，因此我们经常需要进行一些平滑处理。 除了计算移动平均值外，我们还可以使用 NumPy 函数之一来平滑数据。
- en: 'The `hanning()` function is a window function formed by a weighted cosine (see
    [http://en.wikipedia.org/wiki/Hann_function](http://en.wikipedia.org/wiki/Hann_function)):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`hanning()`函数是由加权余弦形成的窗口函数（见[`en.wikipedia.org/wiki/Hann_function`](http://en.wikipedia.org/wiki/Hann_function)）：'
- en: '![Smoothing](img/4154_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![平滑](img/4154_04_07.jpg)'
- en: In the preceding formula, `N` corresponds to the size of the window. We will
    cover the other window functions in later chapters.
  prefs: []
  type: TYPE_NORMAL
  zh: 在上式中， `N`对应于窗口的大小。 在后面的章节中，我们将介绍其他窗口函数。
- en: Time for action – smoothing with the hanning() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用`hanning()`函数进行平滑处理
- en: 'We will use the `hanning()` function to smooth arrays of stock returns, as
    shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用  `hanning()`函数来平滑股票收益数组，如以下步骤所示：
- en: 'Call the `hanning()` function to compute weights for a certain length window
    (in this example 8) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`hanning()`函数来计算特定长度窗口的权重（在本示例中为 8），如下所示：
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The weights are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 权重如下：
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Calculate the stock returns for the BHP and VALE quotes using `convolve()`
    with normalized weights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有标准化权重的`convolve()`计算`BHP`和`VALE`报价的股票收益：
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Plot with `matplotlib` using this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码使用`matplotlib`进行绘图：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The chart would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表如下所示：
- en: '![Time for action – smoothing with the hanning() function](img/4154_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：使用`hanning()`函数进行平滑处理](img/4154_04_03.jpg)'
- en: The thin lines on the preceding chart are the stock returns and the thick lines
    are the result of smoothing. As you can see, the lines cross a few times. These
    points might be important because the trend might have changed there. Or, at least,
    the relation of BHP to VALE might have changed. These turning inflection points
    probably occur often, so we might want to project into the future.
  prefs: []
  type: TYPE_NORMAL
  zh: 上图的细线是股票收益，粗线是平滑的结果。 如您所见，这些线交叉了几次。 这些点可能很重要，因为趋势可能在那里更改了  。 或者至少，`BHP`与`VALE`的关系可能已更改。
    这些拐点可能经常发生，因此我们可能希望展望未来。
- en: 'Fit the result of the smoothing step to polynomials as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平滑步骤的结果拟合为多项式，如下所示：
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we need to evaluate the situation, where the polynomials we found in
    the previous step were equal to each other. This boils down to subtracting the
    polynomials and finding the roots of the resulting polynomial. Subtract the polynomials
    using `polysub()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要评估在上一步中找到的多项式彼此相等的情况。 归结为减去多项式并找到所得多项式的根。 使用`polysub()`减去多项式：
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The points are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点如下所示：
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The numbers we get are complex, and that is not good for us (unless there is
    such a thing as imaginary time). Check which numbers are real with the `isreal()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到的数字很复杂，这对我们不利（除非存在假想时间）。 使用`isreal()`函数检查哪些数字是实数：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Some of the numbers are real, so select them with the `select()` function.
    The `select()` function forms an array by taking elements from a list of choices,
    based on a list of conditions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数字是实数，因此请使用`select()`函数选择它们。 `select()`函数根据条件列表从选项列表中获取元素来形成数组：
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The real intersection points are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 实际交点如下：
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We managed to pick up some zeroes. The `trim_zeros()` function strips the leading
    and trailing zeroes from a one-dimensional array. Get rid of the zeroes with the
    `trim_zeros()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设法得到一些零。 `trim_zeros()`函数从一维数组中去除前导零和尾随零。 使用`trim_zeros（）`函数消除零：
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The zeroes are gone, and the output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 零消失了，输出如下所示：
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We applied the `hanning()` function to smooth arrays containing stock returns.
    We subtracted two polynomials with the `polysub()` function. We then checked for
    real numbers with the `isreal()` function and selected the real numbers with the
    `select()` function. Finally, we stripped zeroes from an array with the `trim_zeros()`
    function (see `smoothing.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`hanning()`函数应用于包含股票收益的数组。 我们用  `polysub()`函数减去了两个多项式。 然后，我们使用`isreal()`函数检查实数  ，然后使用`select()`函数选择实数。
    最后，我们使用`trim_zeros()`函数从数组中剥离了零（请参见`smoothing.py`）：
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Have a go hero – smoothing variations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：平滑变化
- en: Experiment with the other smoothing functions—`hamming()`, `blackman()`, `bartlett()`,
    and `kaiser()`. They work in more or less the same way as the `hanning()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 试用其他平滑函数——`hamming()`，`blackman()`，`bartlett()`和`kaiser()`。 它们的工作方式几乎与`hanning()`函数相同。
- en: Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: So far in this book, we encountered several convenient functions for intializing
    arrays. The `full()` and `full_like()` functions were recently added to NumPy
    to make initialization even easier.
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们遇到了一些用于初始化数组的便捷函数。 `full()`和`full_like()`函数最近被添加到 NumPy，以使初始化更加容易。
- en: 'The following short Python session shows (abbreviated) documentation for these
    two functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的 Python 会话显示了这两个函数的（缩写）文档：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Return a full array with the same shape and type as a given array.
  prefs: []
  type: TYPE_NORMAL
  zh: 返回形状和类型与给定数组相同的完整数组。
- en: Time for action – creating value initialized arrays with the full() and full_like()
    functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用`full()`和`full_like()`函数创建值初始化的数组
- en: 'Let''s demonstrate how the `full()` and `full_like()` functions work. If you
    are not in a Python shell already, type the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示`full()`和`full_like()`函数的工作方式。 如果您还不在 Python shell 中，请输入以下  ：
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a one-by-two array with the `full()` function filled with the number
    `42` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用充满数字 42 的`full()`函数创建一个二分之一的数组，如下所示：
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can deduce from the output, the array elements are floating-point numbers,
    which is the default data type for NumPy arrays. Specify an integer data type
    as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出可以推断出，数组元素是浮点数，这是 NumPy 数组的默认数据类型。 指定整数数据类型，如下所示：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `full_like()` function looks at the metadata of an input array and uses
    that information to create a new array, filled with a specified value. For instance,
    after creating an array with the `linspace()` function, use that as a template
    for the `full_like()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`full_like()`函数查看输入数组的元数据，并使用该信息创建一个填充有指定值的新数组。 例如，在使用`linspace()`函数创建数组之后，将其用作`full_like()`函数的模板：'
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Again we have an array filled with `42`. To change the data type to integer,
    type the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有一个充满`42`的数组。 要将数据类型更改为整数，请键入以下内容：
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We created arrays using the `full()` and `full_like()` functions. The `full()`
    function filled the array with the number `42`. The `full_like()` function uses
    the metadata of an input array to create a new array. Both functions allow you
    to specify the data type.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`full()`和`full_like()`函数创建了数组。 `full()`函数用数字`42`填充数组。 `full_like()`函数使用输入数组的元数据来创建新数组。
    这两个函数都可以指定数据类型。
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We calculated the correlation of the stock returns of two stocks with the `corrcoef()`
    function. As a bonus, we demonstrated the `diagonal()` and `trace()` functions,
    which can give us the diagonal and trace of a matrix.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`corrcoef()`函数计算了两只股票的股票收益率的相关性。 另外，我们演示了`diagonal()` 和`trace()`函数，它们可以为我们提供矩阵的对角线和迹线。
- en: We fit data to a polynomial with the `polyfit()` function. We learned about
    the `polyval()` function that computes the values of a polynomial, the `roots()`
    function that returns the roots of the polynomial, and the `polyder()` function,
    which gives back the derivative of a polynomial.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`polyfit()`函数将数据拟合为多项式。 我们了解了用于计算多项式值的`polyval()`函数，用于返回多项式根的`roots()`函数以及用于返回多项式导数的`polyder()`函数。
- en: We saw that the `full()` function fills an array with a number, and the `full_like()`
    function uses the metadata of an input array to create a new array. Both functions
    allow you to specify the data type.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`full()`函数用数字填充数组，`full_like()`函数使用输入数组的元数据创建一个新数组。 这两个函数都可以指定数据类型。
- en: Hopefully, you have increased your productivity, so that we can continue in
    the next chapter with matrices and **Universal** **Functions** (**ufuncs**).
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您提高了工作效率，因此我们可以在下一章继续使用矩阵和**通用函数**（**ufuncs**）。
