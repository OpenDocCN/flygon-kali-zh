- en: '*Chapter 2*: Data Types and Operators'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：数据类型和运算符'
- en: In the previous chapter, we learned about .NET Framework and understood the
    basic structure of a C# program. In this chapter, we will learn about data types
    and objects in C#. Alongside control statements, which we will explore in the
    next chapter, these are the building blocks of every program. We will discuss
    built-in data types, explain the difference between value types and reference
    types, and learn how to convert between types. We will also discuss the operators
    defined by the language as we move on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了.NET Framework并理解了C#程序的基本结构。在本章中，我们将学习C#中的数据类型和对象。除了控制语句，我们将在下一章中探讨，这些是每个程序的构建块。我们将讨论内置数据类型，解释值类型和引用类型之间的区别，并学习如何在类型之间进行转换。随着我们的学习，我们还将讨论语言定义的运算符。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basic built-in data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本内置数据类型
- en: Variables and constants
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和常量
- en: Reference types and value types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和值类型
- en: Nullable type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空类型
- en: Arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Type conversion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: By the end of this chapter, you will be able to write a simple C# program using
    the aforementioned language features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够使用上述语言特性编写一个简单的C#程序。
- en: Basic data types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: 'In this section, we will explore the basic data types. The `System` namespace.
    All of them, however, have a *C# alias*. These aliases are keywords in the C#
    language, which means they can only be used in the context of their designated
    purpose and not elsewhere, such as variable, class, or method names. The C# name
    and the .NET name, along with a short description of each type, are listed in
    the following table (listed alphabetically by the C# name):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨基本数据类型。`System`命名空间。然而，它们都有*C#别名*。这些别名是C#语言中的关键字，这意味着它们只能在它们指定的上下文中使用，而不能在其他地方使用，比如变量、类或方法名。C#名称和.NET名称以及每种类型的简短描述列在以下表中（按C#名称字母顺序列出）：
- en: '![](img/Chapter_2_Table_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_1.jpg)'
- en: 'The types listed in this table are called **simple types** or **primitive types**.
    Apart from these, there are two more built-in types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此表中列出的类型称为**简单类型**或**原始类型**。除了这些，还有两种内置类型：
- en: '![](img/Chapter_2_Table_2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_2.jpg)'
- en: Let's explore all of the primitive types in detail in the following sections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在接下来的章节中详细探讨所有原始类型。 '
- en: The integral types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: 'C# supports eight integer types that represent various ranges of integral numbers.
    The bits and range of each of them are shown in the following table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持表示各种整数范围的八种整数类型。它们的位数和范围如下表所示：
- en: '![](img/Chapter_2_Table_3.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_3.jpg)'
- en: As shown in the preceding table, C# defines both signed and unsigned integer
    types. The major difference between signed and unsigned integers is the way in
    which the high order bit is read. In the case of a signed integer, the high order
    bit is considered the sign flag. If the sign flag is 0, then the number is positive
    but if the sign flag is 1, then the number is negative.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，C#定义了有符号和无符号整数类型。有符号和无符号整数之间的主要区别在于高阶位的读取方式。对于有符号整数，高阶位被视为符号标志。如果符号标志为0，则数字为正数，但如果符号标志为1，则数字为负数。
- en: The default value of all integral types is 0\. All of these types define two
    constants called `MinValue` and `MaxValue`, which provide the minimum and maximum
    value of the type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有整数类型的默认值都是0。所有这些类型都定义了两个常量，称为`MinValue`和`MaxValue`，它们提供了类型的最小值和最大值。
- en: 'Integral literals, which are numbers that appear directly in code (such as
    0, -42, and so on), can be specified as decimal, hexadecimal, or binary literals.
    Decimal literals do not require any suffix. Hexadecimal literals are prefixed
    with `0x` or `0X`, and binary literals are prefixed with `0b` or `0B`. An underscore
    (`_`) can be used as a digit separator with all numeric literals. Examples of
    such literals are shown in the following snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面值，即直接出现在代码中的数字（如0、-42等），可以指定为十进制、十六进制或二进制字面值。十进制字面值不需要任何后缀。十六进制字面值以`0x`或`0X`为前缀，二进制字面值以`0b`或`0B`为前缀。下划线（`_`）可以用作所有数字字面值的数字分隔符。此类字面值的示例如下片段所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An integral value without any suffix is inferred by the compiler as `int`. To
    indicate a long integer, use `l` or `L` for a signed 64-bit integer and `ul` or
    `UL` for an unsigned 64-bit integer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器推断没有后缀的整数值为`int`。要表示长整数，使用`l`或`L`表示有符号64位整数，使用`ul`或`UL`表示无符号64位整数。
- en: The floating-point types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'The floating-point types are used to represent numbers having fractional components.
    C# defines two floating-point types, as shown in the following table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型用于表示具有小数部分的数字。C#定义了两种浮点类型，如下表所示：
- en: '![](img/Chapter_2_Table_4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_4.jpg)'
- en: The `float` type represents a 32-bit, single-precision floating-point number,
    whereas `double` represents a 64-bit, double-precision floating-point number.
    These types are implementations of the **IEEE Standard for Floating-Point Arithmetic
    (IEEE 754),** which is a standard established by the **Institute of Electrical
    and Electronics Engineers (IEEE)** in 1985 for floating-point arithmetic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`类型表示32位单精度浮点数，而`double`表示64位双精度浮点数。这些类型是**IEEE浮点算术标准（IEEE 754）**的实现，这是**电气和电子工程师学会（IEEE）**在1985年制定的浮点算术标准。'
- en: 'The default value for floating-point types is 0\. These types also define two
    constants called `MinValue` and `MaxValue` that provide the minimum and maximum
    value of the type. However, these types also provide constants that represent
    not-a-number (`System.Double.NaN`) and infinity (`System.Double.NegativeInfinity`
    and `System.Double.PositiveInfinity`). The following code listing shows several
    variables initialized with floating-point values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的默认值是 0。这些类型还定义了两个常量，称为 `MinValue` 和 `MaxValue`，提供类型的最小值和最大值。然而，这些类型还提供了表示非数字（`System.Double.NaN`）和无穷大（`System.Double.NegativeInfinity`
    和 `System.Double.PositiveInfinity`）的常量。下面的代码列表显示了用浮点值初始化的几个变量：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, a non-integer number such as `42.99` is considered a double. If
    you want to specify this as a float type, then you need to suffix the value with
    the `f` or `F` character, such as in `42.99f` or `42.99F`. Alternatively, you
    can also explicitly indicate a double literal with the `d` or `D` suffix, such
    as in `42.99d` or `42.99D`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，非整数数字如 `42.99` 被视为双精度。如果要将其指定为浮点类型，则需要在值后加上 `f` 或 `F` 字符，如 `42.99f` 或
    `42.99F`。另外，也可以使用 `d` 或 `D` 后缀来明确指定双精度字面量，如 `42.99d` 或 `42.99D`。
- en: Floating-point types store fractional parts as inverse powers of two. For this
    reason, they can only represent exact values such as `10`, `10.25`, `10.5`, and
    so on. Other numbers, such as `1.23` or `19.99`, cannot be represented exactly
    and are only an approximation. Even if `double` has 15 decimal digits of precision,
    as compared to only 7 for `float`, precision loss starts to accumulate when performing
    repeated calculations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型将小数部分存储为二的倒数。因此，它们只能表示精确值，如 `10`、`10.25`、`10.5` 等。其他数字，如 `1.23` 或 `19.99`，无法精确表示，只是一个近似值。即使
    `double` 有 15 位小数精度，而 `float` 只有 7 位，但在执行重复计算时，精度损失开始积累。
- en: This makes `double` and `float` difficult or even inappropriate to use in certain
    types of applications, such as financial applications, where precision is key.
    For this purpose, the `decimal` type is provided.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `double` 和 `float` 在某些类型的应用中难以使用，甚至不合适，比如金融应用，其中精度很重要。为此，提供了 `decimal` 类型。
- en: The decimal type
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十进制类型
- en: 'The `decimal` type can represent up to 28 decimal places. The details for the
    decimal type are shown in the following table:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 类型最多可以表示 28 位小数。`decimal` 类型的详细信息如下表所示：'
- en: '![](img/Chapter_2_Table_5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_5.jpg)'
- en: 'The default value for the decimal type is 0\. `MinValue` and `MaxValue` constants
    that define the minimum and maximum value of the type are also available. A `decimal`
    literal can be specified using the `m` or `M` suffix as shown in the following
    snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制类型的默认值是 0。还有定义了类型的最小值和最大值的 `MinValue` 和 `MaxValue` 常量。十进制字面量可以使用 `m` 或 `M`
    后缀来指定，如下面的片段所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is important to note that the `decimal` type minimizes errors during rounding
    but does not eliminate the need for rounding. For instance, the result of the
    operation `1m / 3 * 3` is not 1 but `0.9999999999999999999999999999`. On the other
    hand, `Math.Round(1m / 3 * 3)` yields the value 1`.`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`decimal` 类型可以最小化舍入误差，但并不能消除对舍入的需求。例如，`1m / 3 * 3` 的操作结果不是 1，而是 `0.9999999999999999999999999999`。另一方面，`Math.Round(1m
    / 3 * 3)` 得到的值是 1。
- en: The `decimal` type is designed for use in applications where precision is key.
    Floats and doubles are much faster types (because they use binary math, which
    is faster to compute), while the `decimal` type is slower (as the name implies,
    it uses decimal math, which is slower to compute). The `decimal` type can be an
    order of magnitude slower than the `double` type. Financial applications, where
    small inaccuracies can accumulate to important values over repeated computations,
    are a typical use case for the `decimal` type. In such applications, speed is
    not important, but precision is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 类型适用于需要精度的应用程序。浮点数和双精度是更快的类型（因为它们使用二进制数学，计算速度更快），而 `decimal` 类型较慢（顾名思义，它使用十进制数学，计算速度较慢）。`decimal`
    类型可能比 `double` 类型慢一个数量级。金融应用程序是 `decimal` 类型的典型用例，其中小的不准确性可能在重复计算中积累成重要的值。在这种应用中，速度不重要，但精度很重要。'
- en: The char type
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类型
- en: 'The character type is used to represent a 16-bit Unicode character. Unicode
    defines a character set that is intended to represent the characters of most languages
    in the world. Characters are represented by enclosing them in single quotation
    marks (`''''`). Examples of this include `''A''`, `''B''`, `''c''` and `''\u0058''`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型用于表示 16 位 Unicode 字符。Unicode 定义了一个字符集，旨在表示世界上大多数语言的字符。字符用单引号括起来表示（`''`）。例如，`'A'`、`'B'`、`'c'`
    和 `'\u0058'`：
- en: '![](img/Chapter_2_Table_6.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_6.jpg)'
- en: 'Character values can be literals, hexadecimal escape sequences that have the
    form `''\xdddd''`, or Unicode representations that have the form `''\udddd''`
    (where `dddd` is a 16 hexadecimal value). The following listing shows several
    examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字符值可以是字面量、十六进制转义序列（形式为 `'\xdddd'`），或者具有形式 `'\udddd'` 的 Unicode 表示（其中 `dddd`
    是一个十六进制值）。下面的列表显示了几个示例：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default value for the `char` type is decimal 0, or its equivalents, `'\0'`,
    `'\x0000'`, or `'\u0000'`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型的默认值是十进制 0，或其等价值 `''\0''`、`''\x0000''` 或 `''\u0000''`。'
- en: The bool type
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'C# uses the `bool` keyword to represent the Boolean type. It can have two values,
    `true` or `false`, as shown in the following table:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C# 使用 `bool` 关键字来表示布尔类型。它可以有两个值，`true` 或 `false`，如下表所示：
- en: '![](img/Chapter_2_Table_7.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_7.jpg)'
- en: The default value for the bool type is `false`. Unlike other languages (such
    as C++), integer values or any other values do not implicitly convert into the
    `bool` type. A Boolean variable can be either assigned a Boolean literal (`true`
    or `false`) or an expression that evaluates to `bool`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型的默认值是 `false`。与其他语言（如 C++）不同，整数值或任何其他值不会隐式转换为 `bool` 类型。布尔变量可以被赋予布尔字面量（`true`
    或 `false`）或求值为 `bool` 的表达式。
- en: The string type
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类型
- en: A string is an array of characters. In C#, the type for representing a string
    is called `string` and is an alias for the .NET `System.String`. You can use any
    of these two types interchangeably. Internally, a string contains a read-only
    collection of `char` objects. This makes strings immutable, which means that you
    cannot change a string but need to create a new one every time you want to modify
    the content of an existing string. Strings are not *null-terminated* (unlike other
    languages such as C++) and can contain any number of null characters (`'\0'`).
    The string length will contain the total number of the `char` objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符数组。在C#中，表示字符串的类型称为`string`，它是.NET`System.String`的别名。您可以互换使用这两种类型。在内部，字符串包含一个只读的`char`对象集合。这使得字符串是不可变的，这意味着您不能更改字符串，但需要每次修改现有字符串的内容时创建一个新的字符串。字符串不是*以null结尾*（与其他语言如C++不同），可以包含任意数量的空字符(`'\0'`)。字符串长度将包含`char`对象的总数。
- en: 'Strings can be declared and initialized in a variety of ways, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以以各种方式声明和初始化，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is important to note that the only situation when you use the `new` operator
    to create a string object is when you initialize it from an array of characters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，唯一需要使用`new`运算符创建字符串对象的情况是当您从字符数组初始化它时。
- en: 'As mentioned before, strings are immutable. Although you have access to the
    characters of the string, you can read them, but you cannot change them:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，字符串是不可变的。虽然您可以访问字符串的字符，但您可以读取它们，但不能更改它们：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are the methods that seem to be modifying a string:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是似乎修改字符串的方法：
- en: '`Remove()`: This removes a part of the string.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()`: 这会删除字符串的一部分。'
- en: '`ToUpper()`/`ToLower()`: This converts all of the characters into uppercase
    or lowercase.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToUpper()`/`ToLower()`: 这将所有字符转换为大写或小写。'
- en: Neither of these methods modifies the existing string, but instead returns a
    new one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都不会修改现有字符串，而是返回一个新的字符串。
- en: 'In the following example, `s6` is the string defined earlier, `s8` will contain
    `hello`, `s9` will contain `HELLO WORLD`, and `s6` will continue to contain `hello
    world`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`s6`是之前定义的字符串，`s8`将包含`hello`，`s9`将包含`HELLO WORLD`，而`s6`将继续包含`hello world`：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can convert any built-in type, such as integer or floating-point numbers,
    into a string using the `ToString()` method. This is actually a virtual method
    of the `System.Object` type, that is, the base class for any .NET type. By overriding
    this method, any type can provide a way to serialize an object to a string:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ToString()`方法将任何内置类型，如整数或浮点数，转换为字符串。这实际上是`System.Object`类型的虚拟方法，即任何.NET类型的基类。通过重写此方法，任何类型都可以提供一种将对象序列化为字符串的方法：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Strings can be composed in several ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以以几种方式组成：
- en: It can be done using the concatenating operator, `+`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用连接运算符`+`来完成。
- en: 'Using the `Format()` method: The first argument of this method is the format,
    in which each parameter is indicated positionally with the index specified in
    curly braces, such as `{0}`, `{1}`, `{2}`and so on. Specifying an index beyond
    the number of arguments results in a runtime exception.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Format()`方法：此方法的第一个参数是格式，在其中每个参数都用花括号中指定的索引位置表示，例如`{0}`，`{1}`，`{2}`等。指定超出参数数量的索引会导致运行时异常。
- en: 'Using string interpolation, which is practically a syntactic shortcut for using
    the `String.Format()` method: The string must be prefixed with `$` and the arguments
    are specified directly in curly braces.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串插值，这实际上是使用`String.Format()`方法的一种语法快捷方式：字符串必须以`$`为前缀，并且参数直接在花括号中指定。
- en: 'An example of all of these methods is shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了所有这些方法的示例：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some characters have a special meaning and are prefixed with a backslash (`\`).
    These are called escaped sequences. The following table lists all of them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符具有特殊含义，并以反斜杠(`\`)为前缀。这些称为转义序列。以下表列出了所有这些转义序列：
- en: '![](img/Chapter_2_Table_8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_8.jpg)'
- en: 'Escape sequences are necessary in certain cases, such as when you specify a
    Windows file path or when you need a text that spawns multiple lines. The following
    code shows several examples where escape sequences are used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要使用转义序列，例如当指定Windows文件路径或需要生成多行文本时。以下代码显示了使用转义序列的几个示例：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can, however, avoid using escape sequences by using verbatim strings. These
    are prefixed with the `@` symbol. When the compiler encounters such a string,
    it does not interpret escape sequences. If you want to use quotation marks in
    a string when using verbatim strings, you must double them. The following sample
    shows the preceding examples rewritten with verbatim strings:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以通过使用逐字字符串来避免使用转义序列。这些字符串以`@`符号为前缀。当编译器遇到这样的字符串时，它不会解释转义序列。如果要在使用逐字字符串时在字符串中使用引号，必须将其加倍。以下示例显示了使用逐字字符串重写的前面的示例：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Prior to C# 8, if you wanted to use string interpolation with verbatim strings,
    you had to first specify the `$` symbol for string interpolation and then `@`
    for verbatim strings. In C# 8, you can specify these two symbols in any order.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8之前，如果要在逐字字符串中使用字符串插值，必须首先为字符串插值指定`$`符号，然后为逐字字符串指定`@`。在C# 8中，您可以以任何顺序指定这两个符号。
- en: The object type
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类型
- en: The `object` type is the base type for all other types in C#, even though you
    do not specify this explicitly, as we will see in the following chapters. The
    `object` keyword in C# is an alias for the .NET `System.Object` type. You can
    use these two interchangeably.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型是C#中所有其他类型的基本类型，即使您没有明确指定，我们将在接下来的章节中看到。C#中的`object`关键字是.NET`System.Object`类型的别名。您可以互换使用这两个。'
- en: 'The `object` type provides some basic functionalities to all other classes
    in the form of several virtual methods that any derived class can override, if
    necessary. These methods are listed in the following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型以几种虚拟方法的形式为所有其他类提供一些基本功能，任何派生类都可以覆盖这些方法，如果有必要的话。这些方法列在下表中：'
- en: '![](img/Chapter_2_Table_9.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_9.jpg)'
- en: Apart from these, the `object` class contains several other methods. An important
    one to note is the `GetType()` method, which is not virtual and which returns
    a `System.Type` object with information about the type of the current instance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`object`类包含几个其他方法。一个重要的方法是`GetType()`方法，它不是虚拟的，并返回一个`System.Type`对象，其中包含有关当前实例类型的信息。
- en: Another important thing to notice is the way the `Equals()` method works because
    its behavior is different for reference and value types. We have not covered these
    concepts yet but will do so later in this chapter. For the time being, keep in
    mind that, for reference types, this method performs reference equality; this
    means it checks whether the two variables point to the same object on the heap.
    For value types, it performs value equality; this means that the two variables
    are of the same type and that the public and private fields of the two objects
    are equal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要注意的是`Equals()`方法的工作方式，因为它对于引用类型和值类型的行为是不同的。我们还没有涵盖这些概念，但稍后在本章中会详细介绍。暂时要记住的是，对于引用类型，这个方法执行引用相等性；这意味着它检查两个变量是否指向堆上的同一个对象。对于值类型，它执行值相等性；这意味着两个变量是相同类型，并且两个对象的公共和私有字段是相等的。
- en: The `object` type is a reference type. The default value of a variable of the
    `object` type is `null`. However, a variable of the `object` type can be assigned
    any value of any type. When you assign a value type value to `object`, the operation
    is called `object` into a value type is called **unboxing**. This will be detailed
    in a later section in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型是一个引用类型。`object`类型的变量的默认值是`null`。然而，`object`类型的变量可以被赋予任何类型的任何值。当你将值类型的值赋给`object`时，这个操作被称为**拆箱**。这将在本章的后面部分详细介绍。'
- en: You will learn more about the `object` type and its methods throughout this
    book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中更多地了解`object`类型及其方法。
- en: Variables
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables are defined as a named memory location that can be assigned to a
    value. There are several types of variables, including the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 变量被定义为一个命名的内存位置，可以赋予一个值。有几种类型的变量，包括以下几种：
- en: '**Local variables**: These are variables that are defined within a method and
    their scope is local to that method.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：这些是在方法内部定义的变量，它们的作用域局限于该方法。'
- en: '**Method parameters**: These are variables that hold the arguments passed to
    a method during a function call.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：这些是在函数调用期间传递给方法的参数。'
- en: '**Class fields**: These are variables that are defined in the scope of the
    class and are accessible to all of the class methods and depending on the accessibility
    of the field to other classes too.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类字段**：这些是在类范围内定义的变量，可以被所有类方法访问，并取决于字段对其他类的可访问性。'
- en: '**Array elements**: These are variables that refer to elements in an array.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组元素**：这些是指向数组中元素的变量。'
- en: 'In this section, we will refer to local variables, which are variables declared
    in the body of a function. Such variables are declared using the following syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提到局部变量，这些变量是在函数体中声明的。这些变量使用以下语法声明：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this statement, `datatype` is the data type of the variable and `variable_name`
    is the name of the variable. Here are several examples:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，`datatype`是变量的数据类型，`variable_name`是变量的名称。以下是几个例子：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, `f` is an uninitialized `bool` variable. Uninitialized variables
    cannot be used in any expression. An attempt to do so will result in a compiler
    error. All variables must be initialized before they are used. A variable can
    be initialized when declared, such as with `ch`, `b`, and `c` in the preceding
    example, or at any later time, such as with `a` and `f`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`f`是一个未初始化的`bool`变量。未初始化的变量不能在任何表达式中使用。这样做将导致编译器错误。所有变量在使用之前必须初始化。变量可以在声明时初始化，比如前面例子中的`ch`、`b`和`c`，也可以在以后的任何时间初始化，比如`a`和`f`。
- en: Multiple variables of the same type can be declared and initialized in a single
    statement, separated by a comma. This is exemplified in the preceding code snippet
    with the `int` variables `a`, `b`, and `c`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相同类型的多个变量可以在单个语句中声明和初始化，用逗号分隔。在前面的代码片段中，`int`变量`a`、`b`和`c`就是一个例子。
- en: Naming convention
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'There are several rules that must be followed for naming a variable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有几条规则必须遵循以命名变量：
- en: Variable names can consist of letters, digits, and underscore characters (`_`)
    only.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名只能由字母、数字和下划线字符（`_`）组成。
- en: You cannot use any special character other than underscore (`_`) when naming
    a variable. Consequently, *@sample*, *#tag*, *name%*, and so on are illegal variable
    names.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名变量时，不能使用除下划线（`_`）之外的任何特殊字符。因此，*@sample*、*#tag*、*name%*等都是非法的变量名。
- en: The variable name must begin with a letter or an underscore character (`_`).
    The name of the variable cannot start with a digit. Therefore, `2small` as a variable
    name will throw a compile-time error.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名必须以字母或下划线字符（`_`）开头。变量的名称不能以数字开头。因此，`2small`作为变量名将会引发编译时错误。
- en: Variable names are case-sensitive. Therefore, `person` and `PERSON` are considered
    two different variables.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名区分大小写。因此，“person”和“PERSON”被视为两个不同的变量。
- en: A variable name cannot be any reserved keyword of C#. Hence `true`, `false`,
    `double`, `float`, `var`, and so on are illegal variable names. However, prefixing
    a keyword with `@` enables the compiler to treat them as identifiers, rather than
    keywords. Therefore, variables names such as `@true`, `@return`, `@var` are allowed.
    These are called **verbatim identifiers**.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能是C#的任何保留关键字。因此，`true`、`false`、`double`、`float`、`var`等都是非法的变量名。然而，使用`@`前缀使编译器将它们视为标识符而不是关键字。因此，像`@true`、`@return`、`@var`这样的变量名是允许的。这些被称为**逐字标识符**。
- en: Apart from the language rules that you must follow when naming variables, you
    should also make sure the names you choose are descriptive and easy to understand.
    You should always prefer that over short, abbreviated names that are hard to comprehend.
    There are various coding standards and naming conventions and you should adhere
    to one. These promote consistency and make the code easier to read, understand,
    and maintain.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在命名变量时必须遵循的语言规则外，你还应该确保所选择的名称具有描述性且易于理解。你应该始终优先选择这种名称，而不是难以理解的缩写名称。有各种编码规范和命名约定，你应该遵循其中的一种。这有助于保持一致性，并使代码更易于阅读、理解和维护。
- en: 'When it comes to naming conventions, you should do the following when programming
    in C#:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名约定方面，编写C#代码时应该遵循以下规则：
- en: Use *pascal case* for classes, structures, enums, delegates, constructors, methods,
    properties, and constants. In Pascal case, each word in a name is capitalized;
    examples include `ConnectionString`, `UserGroup`, and `XmlReader`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于类、结构、枚举、委托、构造函数、方法、属性和常量，使用*帕斯卡命名法*。在帕斯卡命名法中，名称中的每个单词都首字母大写；例如`ConnectionString`、`UserGroup`和`XmlReader`。
- en: Use *camel case* for fields, local variables, and method parameters. In camel
    case, the first word of a name is not capitalized, but all of the others are;
    examples include `userId`, `xmlDocument`, and `uiControl`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于字段、局部变量和方法参数，使用*驼峰命名法*。在驼峰命名法中，名称的第一个单词不大写，但其他单词都大写；例如`userId`、`xmlDocument`和`uiControl`。
- en: Do not use *underscore* in identifiers unless to prefix private fields, such
    as in `_firstName`, and`_lastName`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了用于私有字段前缀的情况外，不要在标识符中使用*下划线*，例如`_firstName`和`_lastName`。
- en: Prefer *descriptive name* over abbreviations. For example, prefer `labelText`
    over `lbltxt` or `employeeId` over `eid`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择*描述性名称*而不是缩写。例如，优先选择`labelText`而不是`lbltxt`或`employeeId`而不是`eid`。
- en: You can learn more about coding standards and naming conventions in C# by consulting
    additional resources.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查阅其他资源了解更多关于C#编码规范和命名约定的信息。
- en: Implicity-typed variables
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式类型的变量
- en: As we have seen in previous examples, we need to specify the type of a variable
    when we are declaring it. However, C# provides us with another way to declare
    variables that allows the compiler to infer the variable type based on the value
    assigned to it during initialization. These are known as **implicitly typed variables**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中看到的，当我们声明变量时，需要指定变量的类型。然而，C#还提供了另一种声明变量的方式，允许编译器根据初始化时赋予的值推断变量的类型。这些被称为**隐式类型的变量**。
- en: 'We can create an implicitly typed variable using the `var` keyword. Such variables
    must always be initialized on the declaration because the compiler infers the
    type of the variable from the value that it is initialized with. Here is an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`var`关键字创建一个隐式类型的变量。这种变量必须在声明时进行初始化，因为编译器会根据初始化的值推断变量的类型。以下是一个例子：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the `a` variable is initialized with an integer literal, `a` is considered
    as an `int` variable by the compiler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a`变量被初始化为整数字面量，编译器将`a`视为`int`类型的变量。
- en: 'When declaring variables with `var`, you must keep in mind the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`var`声明变量时，你必须牢记以下事项：
- en: An implicitly typed variable must be initialized to a value at the time of declaration,
    otherwise, the compiler has no reference to infer the variable type and it results
    in a compile-time error.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型的变量必须在声明时初始化一个值，否则编译器无法推断变量类型，会导致编译时错误。
- en: You cannot initialize it to null.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将其初始化为null。
- en: The variable type cannot be changed once it is declared and initialized.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量类型一旦声明并初始化后就不能更改。
- en: Information box
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The `var` keyword is not a datatype but a placeholder for an actual type. Using
    `var` to declare variables is useful when the type name is long and you want to
    avoid typing a lot (for example, `Dictionary<string, KeyValuePair<int, string>>`)
    or you do not care about the actual type, only the value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字不是一种数据类型，而是实际类型的占位符。在声明变量时使用`var`是有用的，当类型名称很长并且你想避免输入大量内容时（例如`Dictionary<string,
    KeyValuePair<int, string>>`），或者你只关心值而不关心实际类型时。'
- en: 'Now that you learned how you can declare variables, let''s look at a key concept:
    the scope of variables.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何声明变量，让我们来看一个关键概念：变量的作用域。
- en: Understanding the scope and lifetime of variables
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量的作用域和生命周期
- en: A **scope** in C# is defined as a block between an opening curly brace and its
    corresponding closing curly brace. The scope defines the visibility and lifetime
    of a variable. A variable can be accessed only within the scope in which it is
    defined. A variable that is defined in a particular scope is not visible to the
    code outside that scope.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，**作用域**被定义为在开放大括号和对应的闭合大括号之间的代码块。作用域定义了变量的可见性和生命周期。变量只能在其定义的作用域内访问。在特定作用域中定义的变量对该作用域外的代码不可见。
- en: 'Let''s understand this with the help of an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这一点：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `i` variable is defined inside the `for` loop, hence it
    cannot be accessed outside the `for` loop as it goes out of scope once the control
    exits the loop. You will learn more about the `for` loop in the next chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`i`变量是在`for`循环内部定义的，因此一旦控制流退出循环，它就超出了作用域，无法在`for`循环外部访问。你将在下一章学习更多关于`for`循环的知识。
- en: We can also have nested scopes. This means a variable defined in a scope can
    be accessed in another scope that is enclosed in that scope. However, the variables
    from the outer scope are visible to the inner scope but the inner scope variables
    are not accessible in the outer scope. The C# compiler won't allow you to create
    two variables with the same name within a scope.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以有嵌套作用域。这意味着在一个作用域中定义的变量可以在包含在该作用域内的另一个作用域中访问。然而，外部作用域的变量对内部作用域可见，但内部作用域的变量在外部作用域中不可访问。C#编译器不允许在一个作用域内创建两个同名的变量。
- en: 'Let''s extend the code in the previous example to understand this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前面例子中的代码来理解这一点：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the integer variable `a` is defined outside the `for` loop but within
    the scope of `Main`. Hence, it can be accessed within the `for` loop as it is
    in the scope of this. However, the `i` variable, which is defined inside the `for`
    loop, cannot be accessed inside the scope of `Main`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，整数变量`a`在`for`循环之外定义，但在`Main`的作用域内。因此，它可以在`for`循环内部访问，因为它在此作用域内。然而，在`for`循环内部定义的`i`变量无法在`Main`的作用域内访问。
- en: If we try to declare another variable with the same name in the scope, we will
    get a compile-time error. Consequently, we cannot declare a character variable
    `a` inside the `for` loop as we already have an integer variable with the same
    name.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在作用域内声明另一个同名变量，将会得到一个编译时错误。因此，我们不能在`for`循环内部声明字符变量`a`，因为我们已经有一个同名的整数变量。
- en: Understanding constants
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常量
- en: There are some scenarios in which we do not want to change the value of a variable
    after it is initialized. Examples can include mathematical constants (pi, Euler's
    number, and so on), physical constants (Avogadro's number, the Boltzmann constant,
    and so on), or any application-specific constants (the maximum allowed number
    of logins, the maximum number of retries for a failed operation, status codes,
    and many others). C# provides us with constant variables for this purpose. Once
    defined, the value of a constant variable cannot be changed during its scope.
    If you try to change the value of a constant variable after it is initialized,
    the compiler will throw an error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，我们不希望在初始化后改变变量的值。例如数学常数（π，欧拉数等），物理常数（阿伏伽德罗常数，玻尔兹曼常数等），或任何应用程序特定的常数（最大允许的登录次数，失败操作的最大重试次数，状态码等）。C#为我们提供了常量变量来实现这一目的。一旦定义，常量变量的值在其作用域内不能被改变。如果尝试在初始化后改变常量变量的值，编译器将抛出错误。
- en: 'To make a variable constant, we need to prefix it with the `const` keyword.
    The constant variables must be initialized at the time of declaration. Here is
    an example of an integer constant initialized with the value `42`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要使变量成为常量，我们需要在前面加上`const`关键字。常量变量必须在声明时初始化。下面是一个初始化为`42`的整数常量的例子：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is important to note that only the built-in types can be used to declare
    constants. User-defined types cannot be used for this purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，只有内置类型可以用来声明常量。用户定义的类型不能用于此目的。
- en: Reference types and value types
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型和值类型
- en: The data types in C# are divided into value types and reference types. There
    are several important differences between these two, such as **copy semantics**.
    We will look at these in detail in the following sections.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的数据类型分为值类型和引用类型。这两者之间有一些重要的区别，比如**复制语义**。我们将在接下来的章节中详细讨论这些区别。
- en: Value types
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: A variable of a value type contains the value directly. When a value type variable
    is assigned from another, the stored value is copied. The primitive data types
    we have seen earlier are all value types. All user-defined types declared as structures
    (with the `struct` keyword) are value types. Although all types are implicitly
    derived from the `object`, type value types do not support explicit inheritance,
    which is a topic discussed in [*Chapter 4*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083),
    *Understanding the Various User-Defined Types*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的变量直接包含值。当从另一个值类型变量赋值时，存储的值会被复制。我们之前看到的原始数据类型都是值类型。所有使用`struct`关键字声明的用户定义类型都是值类型。尽管所有类型都是隐式从`object`派生的，值类型不支持显式继承，这是[*第4章*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083)中讨论的一个主题，*理解各种用户定义类型*。
- en: 'Let''s see an example here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里看一个例子：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Value types are typically stored on the stack in memory, although this is an
    implementation detail and not a characteristic of value types. If you assign the
    value of a value type to another variable, then the value is copied to the new
    variable and changing one variable will not affect the other:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型通常存储在内存中的堆栈上，尽管这是一个实现细节，而不是值类型的特征。如果将值类型的值赋给另一个变量，那么该值将被复制到新变量中，改变一个变量不会影响另一个变量：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding example, the value of `a` is initialized to `20` and then
    assigned to the variable `b`. At this point, both variables contain the same value.
    However, after assigning the value `42` to the `a` variable, the value of `b`
    remains unchanged. This is shown, conceptually, in the following diagram:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`a`的值被初始化为`20`，然后赋给变量`b`。此时，两个变量都包含相同的值。然而，在将值`42`赋给`a`变量后，`b`的值保持不变。这在下面的图表中概念上显示出来：
- en: '![Figure 2.1 – A conceptual representation of the changes in the stack during
    the execution of the previous code'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - 在执行前面代码时堆栈中的变化的概念表示'
- en: '](img/Figure_2.1_B12346.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B12346.jpg)'
- en: Figure 2.1 – A conceptual representation of the changes in the stack during
    the execution of the previous code
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 在执行前面代码时堆栈中的变化的概念表示
- en: Here, you can see that, initially, a storage location corresponding to the `a`
    integer was allocated on the stack and had the value 20\. Then, a second storage
    location was allocated and the value from the first was copied to it. Then, we
    changed the value of the `a` variable and therefore, the value available in the
    first storage location. The second one was left untouched.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，最初在堆栈上分配了一个对应于整数`a`的存储位置，并且其值为20。然后，分配了第二个存储位置，并将第一个的值复制到了第二个存储位置。然后，我们改变了`a`变量的值，因此第一个存储位置中的值也改变了。第二个存储位置保持不变。
- en: Reference types
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'A variable of a reference type does not contain the value directly but a reference
    to a memory location where the actual value is stored. The built-in data types
    `object` and `string` are reference types. Arrays, interfaces, delegates, and
    any user-defined type defined as a class are also called **reference types**.
    The following example shows several variables of different reference types:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的变量不直接包含值，而是包含对存储实际值的内存位置的引用。内置数据类型`object`和`string`都是引用类型。数组、接口、委托和任何定义为类的用户定义类型也被称为**引用类型**。以下示例显示了几个不同引用类型的变量：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Reference types are stored on the heap. Variables of a reference type can be
    assigned the `null` value that indicates that the variable does not store a reference
    to an instance of an object. When trying to use a variable assigned the `null`
    value the result is a runtime exception. When a variable of a reference type is
    assigned a value, the reference to the actual memory location of the object is
    copied and not the value of the object itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型存储在堆上。引用类型的变量可以被分配`null`值，表示变量不存储对对象实例的引用。当尝试使用分配了`null`值的变量时，结果是运行时异常。当引用类型的变量被分配一个值时，复制的是对象的实际内存位置的引用，而不是对象本身的值。
- en: 'In the following example, `a1` is an array of two integers. The reference to
    the array is copied to the `a2` variable. When the content of the array changes,
    the changes are visible both through `a1` and `a2`, since both these variables
    refer to the same array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`a1`是一个包含两个整数的数组。数组的引用被复制到变量`a2`中。当数组的内容发生变化时，通过`a1`和`a2`都可以看到这些变化，因为这两个变量都指向同一个数组：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This example is explained conceptually in the following diagram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在下面的图中以概念方式解释：
- en: '![Figure 2.2 – The conceptual representation of the stack and the heap during
    the execution of the preceding snippet'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - 在上述片段执行期间堆栈和堆的概念表示'
- en: '](img/Figure_2.2_B12346.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B12346.jpg)'
- en: Figure 2.2 – The conceptual representation of the stack and the heap during
    the execution of the preceding snippet
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 在上述片段执行期间堆栈和堆的概念表示
- en: You can see in this diagram that `a1` and `a2` are variables on the stack pointing
    to the same array of integers allocated on the heap. When the first element of
    the array is changed through the `a1` variable, the changes are automatically
    visible to the `a2` variable because `a1` and `a2` refer to the same object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此图中看到，`a1`和`a2`是堆上分配的相同整数数组的堆栈上的变量。当通过`a1`变量更改数组的第一个元素时，这些更改会自动显示在`a2`变量上，因为`a1`和`a2`指向同一个对象。
- en: 'Although the `string` type is a reference type, it appears to behave differently.
    Take the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`string`类型是引用类型，但它似乎表现不同。看下面的例子：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `s1` is initialized with the `"help"` literal and then the reference to
    the actual array heap object is copied to the `s2` variable. At this point, they
    both refer to the `"help"` string. However, `s1` is later assigned a new string,
    `"demo"`. At this point, `s2` will continue to refer to the `"help"` string. The
    reason for this is that strings are immutable. That means when you modify a string
    object, a new string is created, and the variable will receive the reference to
    the new string object. Any other variables referring to the old string will continue
    to do so.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`用`"help"`字面量初始化，然后将实际数组堆对象的引用复制到变量`s2`中。此时，它们都指向`"help"`字符串。然而，稍后`s1`被分配一个新的字符串`"demo"`。此时，`s2`将继续指向`"help"`字符串。原因是字符串是不可变的。这意味着当您修改一个字符串对象时，将创建一个新的字符串，并且变量将接收对新字符串对象的引用。任何其他引用旧字符串的变量将继续这样做。
- en: Boxing and unboxing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装箱和拆箱
- en: 'We briefly mentioned boxing and unboxing earlier in this chapter when we talked
    about the `object` type. Boxing is the process of storing a value type inside
    an `object`, and unboxing is the opposite operation of converting the value of
    an `object` to a value type. Let''s understand this with the help of an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面简要提到了装箱和拆箱，当我们谈到`object`类型时。装箱是将值类型存储在`object`中的过程，而拆箱是将`object`的值转换为值类型的相反操作。让我们通过一个例子来理解这一点：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `a` is a variable of the type integer that is initialized
    with the value `42`. Being a value type, the integer value `42` is stored on the
    stack. On the other hand, `o` is a variable of type `object`. This is a reference
    type. That means it only contains a reference to a heap memory location where
    the actual object is stored. So, when `a` is assigned to `o`, the process called
    **boxing** occurs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`a`是一个初始化为值`42`的整数类型的变量。作为值类型，整数值`42`存储在堆栈上。另一方面，`o`是一个`object`类型的变量。这是一个引用类型。这意味着它只包含对存储实际对象的堆内存位置的引用。因此，当`a`分配给`o`时，发生了称为**装箱**的过程。
- en: During the boxing process an object is allocated on the heap, the value of `a`
    (which is `42`) is copied to it, and then a reference to this object is assigned
    to the `o` variable. When we later assigned the value `43` to `o`, only the boxed
    object changes and not `a`. Lastly, we copy the value of the object referred by
    `o` to a new variable called `b`. This will have the value `43` and, being an
    `int,` is also stored on the stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈上分配一个对象，将`a`的值（即`42`）复制到该对象中，然后将对该对象的引用分配给变量`o`。当我们稍后将值`43`分配给`o`时，只有装箱对象发生变化，而`a`没有发生变化。最后，我们将由`o`引用的对象的值复制到一个名为`b`的新变量中。这将具有值`43`，并且作为`int`也存储在堆栈上。
- en: 'The process described here is shown graphically in the following diagram:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的过程在下面的图中以图形方式显示：
- en: '![Figure 2.3 – Conceptual representation of the stack showing the boxing and
    unboxing process described previously'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - 显示先前描述的装箱和拆箱过程的堆栈的概念表示'
- en: '](img/Figure_2.3_B12346.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B12346.jpg)'
- en: Figure 2.3 – Conceptual representation of the stack showing the boxing and unboxing
    process described previously
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 显示先前描述的装箱和拆箱过程的堆栈的概念表示
- en: Now that you understand the difference between value and reference types, let's
    look at the topic of nullable types.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了值类型和引用类型之间的区别，让我们来看看可空类型的主题。
- en: Nullable types
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空类型
- en: Reference types have the default value `null`, which indicates that a variable
    is not assigned to the instance of any object. Value types do not have such an
    option. However, there are cases when no value is a valid value for a value type
    too. To represent such cases, you can use a nullable type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的默认值是`null`，表示变量未分配给任何对象的实例。值类型没有这样的选项。但是，有些情况下，对于值类型来说，没有值也是有效的值。为了表示这样的情况，可以使用可空类型。
- en: 'A `System.Nullable<T>`, a generic value type that can represent the values
    of an underlying `T` type, which can only be a value type, as well as an additional
    `null` value. The following sample shows a few examples:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Nullable<T>`是一个泛型值类型，可以表示基础`T`类型的值，该类型只能是值类型，还可以表示额外的`null`值。以下示例展示了一些示例：'
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the shorthand syntax, `T?`, instead of `Nullable<T>`; these two
    are *interchangeable*. The following examples are alternatives for the preceding
    ones:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简写语法`T?`来代替`Nullable<T>`；这两者是可以互换的。以下示例是前面示例的替代方案：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use the `HasValue` property to check whether a nullable type object
    has a value, and `Value` to access the underlying value:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`HasValue`属性来检查可空类型对象是否有值，使用`Value`来访问基础值：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is a list of some of the characteristics of nullable types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可空类型的特征列表：
- en: You assign values to a nullable type object the same way you would assign to
    the underlying type.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以像为基础类型赋值一样为可空类型对象赋值。
- en: You can use the `GetValueOrDefault()` method to get either the assigned value
    or the default value of the underlying type if no value is assigned.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`GetValueOrDefault()`方法来获取已分配的值或基础类型的默认值（如果没有分配值）。
- en: Boxing is performed on the underlying type. If the nullable type object has
    not assigned any value, the result of boxing is a `null` object.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装箱是在基础类型上执行的。如果可空类型对象没有分配任何值，装箱的结果是一个`null`对象。
- en: You can use the null-coalescing operator, `??`, to access the value of the object
    of a nullable type (for example, `int d = c ?? -1;`).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用空值合并运算符`??`来访问可空类型对象的值（例如，`int d = c ?? -1;`）。
- en: 'In C# 8, nullable reference types and non-nullable reference types have been
    introduced. That is a feature that you must opt for in the project properties.
    It allows you to make sure that only objects of reference types that are declared
    nullable, using the `T?` syntax can be assigned the `null` value. Attempts to
    do so on non-nullable reference types will result in a compiler warning (not an
    error, because that has the potential to affect large portions of existing code):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，引入了可空引用类型和非可空引用类型。这是一个您必须在项目属性中选择的功能。它允许您确保只有声明为可空的引用类型对象，使用`T?`语法可以被赋予`null`值。尝试在非可空引用类型上这样做将导致编译器警告（不是错误，因为这可能会影响大量现有代码的部分）：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will learn more about nullable reference types in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第15章“C# 8的新特性”中了解更多关于可空引用类型的内容。
- en: Arrays
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a data structure that holds multiple values (including zero or a
    single one) of the same data type. It is a fixed-size sequence of homogeneous
    elements that are stored in contiguous memory locations. Arrays in C# are zero-indexed,
    meaning that the position of the first element of an array is zero and the position
    of the last element of the array is a total number of elements minus one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种数据结构，可以容纳相同数据类型的多个值（包括零个或一个）。它是一系列同类元素的固定大小序列，存储在连续的内存位置中。C#中的数组是从零开始索引的，意味着数组的第一个元素的位置是零，最后一个元素的位置是元素总数减一。
- en: The array type is a reference type and therefore arrays are allocated on the
    heap. The default value for the elements of numeric arrays is zero and for arrays
    of reference types, the default value is `null`. The type of the elements of an
    array can be of any type, including another array type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型是引用类型，因此数组是在堆上分配的。数值数组的元素的默认值是零，引用类型数组的默认值是`null`。数组的元素类型可以是任何类型，包括另一个数组类型。
- en: Arrays in C# can be one-dimensional, multi-dimensional, or jagged. Let's explore
    these in detail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的数组可以是一维的、多维的或交错的。让我们详细探讨这些。
- en: One-dimensional arrays
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一维数组
- en: 'A one-dimensional array can be defined using the syntax `datatype[] variable_name`.
    Arrays can be initialized when they are declared. If an array variable is not
    initialized, its value is `null`. You can specify the number of elements of the
    array when you initialize it, or you can skip this and let the compiler infer
    it from the initialization expression. The following sample shows various ways
    of declaring and initializing arrays:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用语法`datatype[] variable_name`来定义一维数组。数组可以在声明时初始化。如果数组变量没有初始化，它的值为`null`。您可以在初始化时指定数组的元素数量，也可以跳过这一步，让编译器从初始化表达式中推断出来。以下示例展示了声明和初始化数组的各种方式：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, `arr1` and `arr2` have the value `null`. `arr3` is an array
    of six integer elements all set to `0` because no initialization was provided.
    `arr4`, `arr5`, and `arr6` are arrays of six integers, all containing the same
    values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`arr1`和`arr2`的值为`null`。`arr3`是一个包含六个整数元素的数组，因为没有提供初始化，所以所有元素都被设置为`0`。`arr4`、`arr5`和`arr6`是包含相同值的六个整数的数组。
- en: Once initialized, the size of the array cannot be changed. If you need to do
    so, you must either create a new array object or instead use a variable-size container,
    such as `List<T>`, which we will look at in [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，数组的大小不能改变。如果需要改变，必须创建一个新的数组对象，或者使用可变大小的容器，比如`List<T>`，我们将在第7章“集合”中讨论。
- en: 'You can access the elements of the array using the indexer, or with an enumerator.
    The following snippets are equivalent:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用索引器或枚举器访问数组的元素。以下代码片段是等价的：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although the effect of these two loops is the same, there is a subtle difference—using
    an enumerator does not make it possible to modify the elements of the array. Accessing
    the elements by their index using the index operator does provide write access
    to the elements. Using an enumerator is possible because array types derive implicitly
    from the base type, `System.Array`, which implements `IEnumerable` and `IEnumerable<T>`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个循环的效果是相同的，但有一个细微的区别——使用枚举器不允许修改数组的元素。使用索引运算符按索引访问元素确实提供了对元素的写访问权限。使用枚举器是可能的，因为数组类型隐式地从基本类型`System.Array`派生，该类型实现了`IEnumerable`和`IEnumerable<T>`。
- en: 'This is shown in the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中显示：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the first loop, we access the elements of the array by their index and can
    modify them. However, in the second loop, an iterator is used, and this provides
    read-only access to the elements. Trying to modify them produces a compile-time
    error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个循环中，我们通过它们的索引访问数组的元素并且可以修改它们。然而，在第二个循环中，使用了一个迭代器，这提供了对元素的只读访问。试图修改它们会产生编译时错误。
- en: Multi-dimensional arrays
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: A multi-dimensional array is an array with more than one dimension. It is also
    called a **rectangular array**. This can be, for instance, a two-dimensional array
    (a matrix) or a three-dimensional array (a cube). The maximum number of dimensions
    is **32**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组是具有多个维度的数组。它也被称为**矩形数组**。这可以是一个二维数组（矩阵）或一个三维数组（立方体），最大维数为**32**。
- en: 'A two-dimensional array can be defined using the following syntax: `datatype[,]
    variable_name;`. Multi-dimensional arrays are declared and initialized in a similar
    fashion with single-dimensional arrays. You can specify the rank (which is the
    number of elements) of each dimension or you can leave it to the compiler to infer
    it from an initialization expression. The following snippet shows different ways
    of declaring and initializing two-dimensional arrays:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下语法定义二维数组：`datatype[,] variable_name;`。多维数组的声明和初始化方式与单维数组类似。您可以指定每个维度的秩（即元素的数量），也可以让编译器从初始化表达式中推断出来。以下代码片段显示了声明和初始化二维数组的不同方式：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, `arr1` is initially `null` and then assigned a reference to
    an array of two rows and three columns. Similarly, `arr2` is also `null`. On the
    other hand, `arr3`, `arr4`, `arr5`, and `arr6` are arrays of two rows and three
    columns; `arr3` has all of the elements set to zero, while the others are initialized
    with the specified values. The arrays in this example have the following form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`arr1`最初是`null`，然后被赋予一个包含两行三列的数组的引用。同样，`arr2`也是`null`。另一方面，`arr3`、`arr4`、`arr5`和`arr6`都是包含两行三列的数组；`arr3`的所有元素都设置为零，而其他元素则使用指定的值进行初始化。这个例子中的数组具有以下形式：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can retrieve the number of elements of each dimension using the `GetLength()`
    or `GetLongLength()` methods (the first returns a 32-bit integer, the second a
    64-bit integer). The following example prints the content of the `arr6` array
    to the console:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`GetLength()`或`GetLongLength()`方法检索每个维度的元素数量（第一个返回32位整数，第二个返回64位整数）。以下示例将`arr6`数组的内容打印到控制台：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Arrays with more than two dimensions are created and handled in a similar way.
    The following example shows how to declare and initialize a three-dimensional
    array of *4 x 3 x 2* elements:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 超过两个维度的数组以类似的方式创建和处理。以下示例显示了如何声明和初始化一个*4 x 3 x 2*元素的三维数组：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another form of multi-dimensional arrays is the so-called **jagged array**.
    We will learn about this next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种多维数组的形式是所谓的**不规则数组**。我们将在下面学习这个。
- en: Jagged arrays
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不规则数组
- en: 'Jagged arrays are arrays of arrays. These consist of other arrays, and each
    array inside a jagged array can be of a different size. We can declare a two-dimensional
    jagged array, for instance, using the syntax `datatype [][] variable_name;`. The
    following snippet shows various examples of declaring and initializing jagged
    arrays:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则数组是数组的数组。这些包含其他数组，不规则数组中的每个数组的大小可以不同。例如，我们可以使用语法`datatype [][] variable_name;`声明一个二维不规则数组。以下代码片段显示了声明和初始化不规则数组的各种示例：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, `arr1` and `arr2` are both set to `null`. On the other hand,
    `arr3` is an array of two arrays. Its first element is set to an array of three
    elements that are initialized with zero; its second element is set to an array
    of six elements initialized from the provided values.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`arr1`和`arr2`都被设置为`null`。另一方面，`arr3`是一个包含两个数组的数组。它的第一个元素被设置为一个包含三个初始化为零的元素的数组；它的第二个元素被设置为一个包含从提供的值初始化的六个元素的数组。
- en: The `arr4` and `arr5` arrays are equivalent, but `arr5` uses the shorthand syntax
    for array initialization. `arr6` mixes jagged arrays with multi-dimensional arrays.
    It is an array of two arrays, the first one being a two-dimensional array of *2x2*,
    and the second a two-dimensional array of *2x3* elements.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr4`和`arr5`数组是等价的，但`arr5`使用了数组初始化的简写语法。`arr6`混合了不规则数组和多维数组。它是一个包含两个数组的数组，第一个数组是一个*2x2*的二维数组，第二个数组是一个*2x3*元素的二维数组。'
- en: 'The elements of a jagged array can be accessed using the `arr[i][j]` syntax
    (this example is for two-dimensional arrays). The following snippet shows how
    to print the content of the `arr5` array shown earlier:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`arr[i][j]`语法访问不规则数组的元素（此示例适用于二维数组）。以下代码片段显示了如何打印先前显示的`arr5`数组的内容：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we have looked at the type of arrays we can use in C#, let's move to
    another important topic, which is conversion between various data types.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了在C#中可以使用的数组类型，让我们转移到另一个重要的主题，即各种数据类型之间的转换。
- en: Type conversion
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'Sometimes we need to convert one data type into another, and that is where
    **type conversion** comes in picture. Type conversion can be classified into several
    categories:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将一种数据类型转换为另一种数据类型，这就是**类型转换**的作用。类型转换可以分为几类：
- en: Implicit type conversion
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型转换
- en: Explicit type conversion
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型转换
- en: User-defined conversions
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的转换
- en: Conversions with helper classes
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助类进行转换
- en: Let's explore these in detail.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨这些内容。
- en: Implicit type conversion
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式类型转换
- en: 'For built-in numeric types, when we assign the value of a variable to one of
    another data type, implicit type conversion occurs if both types are compatible
    and the range of destination type is more than that of the source type. For example,
    `int` and `float` are compatible types. Therefore, we can assign an integer variable
    to a variable of the `float` type. Similarly, the `double` type is large enough
    to hold values from any other numerical type, including `long` and `float`, as
    shown in the following example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内置的数字类型，当我们将一个变量的值赋给另一个数据类型时，如果两种类型兼容且目标类型的范围大于源类型的范围，则会发生隐式类型转换。例如，`int`和`float`是兼容的类型。因此，我们可以将整数变量赋给`float`类型的变量。同样，`double`类型足够大，可以容纳任何其他数字类型的值，包括`long`和`float`，如下例所示：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following table shows the implicit type conversion between numeric types
    in C#:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了C#中数字类型之间的隐式类型转换：
- en: '![](img/Chapter_2_Table_10.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_10.jpg)'
- en: 'There are several things to note about implicit numeric conversions:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式数字转换有几点需要注意：
- en: You can convert any integral type to any floating-point type.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将任何整数类型转换为任何浮点类型。
- en: There is no implicit conversion to the `char`, `byte`, and `sbyte` types.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`、`byte`和`sbyte`类型之间没有隐式转换。'
- en: There is no implicit conversion from `double` and `decimal`; this includes no
    implicit conversion from `decimal` to `double` or `float`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`和`decimal`之间没有隐式转换；这包括从`decimal`到`double`或`float`的隐式转换。'
- en: 'For reference types, the implicit conversion is always possible between a class
    and one of its direct or indirect base classes or interfaces. Here is an example
    with an implicit conversion from `string` to `object`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，类和其直接或间接基类或接口之间始终可以进行隐式转换。以下是一个从`string`到`object`的隐式转换的示例：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `object` type (which is an alias for `System.Object`) is the base class
    for all .NET types, including `string` (which is an alias for `System.String`).
    Therefore, an implicit conversion from `string` into `object` exists.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型（它是`System.Object`的别名）是所有.NET类型的基类，包括`string`（它是`System.String`的别名）。因此，存在从`string`到`object`的隐式转换。'
- en: Explicit type conversion
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式类型转换
- en: When an implicit conversion between two types is not possible because there
    is a risk of losing information (such as while assigning the value of a 32-bit
    integer to a 16-bit integer), explicit type conversion is necessary. **Explicit
    type** conversion is also called a **cast**. To perform casting, we need to specify
    the target data type in parentheses in front of the source variable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当两种类型之间无法进行隐式转换，因为存在丢失信息的风险（例如将32位整数的值赋给16位整数时），就需要进行显式类型转换。**显式类型**转换也称为**强制转换**。要执行强制转换，我们需要在源变量前面的括号中指定目标数据类型。
- en: 'For example, `double` and `int` are *incompatible types*. Consequently, we
    need to do an explicit type conversion between them. In the following example,
    we assign a `double` value (`d`) to an integer using explicit type conversion.
    However, while doing this conversion, the fractional part of the `double` variable
    will be truncated. Hence, the value of `i` will be `12`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`double`和`int`是*不兼容的类型*。因此，我们需要在它们之间进行显式类型转换。在下面的例子中，我们使用显式类型转换将`double`值（`d`）赋给整数。但是，在进行此转换时，`double`变量的小数部分将被截断。因此，`i`的值将为`12`：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following table shows the list of predefined explicit conversions between
    numeric types in C#:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了C#中数字类型之间的预定义显式转换列表：
- en: '![](img/Chapter_2_Table_11.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_11.jpg)'
- en: 'There are several things to note about explicit numeric conversions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意关于显式数字转换：
- en: An explicit conversion may result in precision loss or in throwing an exception,
    such as `OverflowException`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式转换可能导致精度丢失或抛出异常，例如`OverflowException`。
- en: When converting from an integral type to another integral type, the result depends
    on the so-called **checked context** and may result either in a successful conversion,
    which may discard extra most-significant bytes, or in an overflow exception.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从一个整数类型转换为另一个整数类型时，结果取决于所谓的**checked上下文**，可能会导致成功转换，可能会丢弃额外的最高有效字节，也可能会导致溢出异常。
- en: When you convert a floating-point type to an integral type, the value is rounded
    toward zero to the nearest integral value. The operation may, however, also result
    in an overflow exception.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将浮点类型转换为整数类型时，值将向零舍入到最接近的整数值。但是，该操作也可能导致溢出异常。
- en: C# statements can execute either in a *checked* or *unchecked* context, which
    is control either with the `check` and `unchecked` keywords or with the compiler
    option, `-checked`. When none of these are specified, the context is considered
    unchecked for non-constant expressions. For constant expressions, which can be
    evaluated at compile time, the default context is always checked. In a checked
    context, overflow checking is enabled for integral-type arithmetic operations
    and conversions. In an unchecked context, these checks are suppressed. When overflow
    checking is enabled and overflow occurs, the runtime throws a `System.OverflowException`
    exception.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: C#语句可以在*checked*或*unchecked*上下文中执行，可以使用`check`和`unchecked`关键字或编译器选项`-checked`来控制。当没有指定这些选项时，对于非常量表达式，上下文被视为未经检查。对于可以在编译时计算的常量表达式，默认上下文始终为checked。在checked上下文中，对于整数类型的算术操作和转换启用了溢出检查。在unchecked上下文中，这些检查被抑制。当启用溢出检查并发生溢出时，运行时会抛出`System.OverflowException`异常。
- en: 'For reference types, an explicit cast is required when you want to convert
    from a base class or interface into a derived class. The following example shows
    a cast from an `object` to a `string` value:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，在想要从基类或接口转换为派生类时，需要进行显式转换。以下示例显示了从`object`到`string`值的转换：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The conversion from `string` into `object` is performed implicitly. However,
    the opposite requires an explicit conversion in the `(string)o` form, as shown
    in the preceding snippet.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从`string`到`object`的转换是隐式进行的。然而，相反的情况需要在`(string)o`形式中进行显式转换，如前面的代码片段所示。
- en: User-defined type conversions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的类型转换
- en: 'A user-defined conversion can define an implicit or explicit conversion or
    both from one type into another. The type that defines these conversions must
    be either the *source* or the *target type*. To do so, you must use the `operator`
    keyword followed by `implicit` or `explicit`. The following example shows a type
    called `fancyint`, which defines implicit and explicit conversions from and to
    `int`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的转换可以定义从一种类型到另一种类型的隐式转换或显式转换，或者两者都定义。定义这些转换的类型必须是*源*类型或*目标类型*之一。为此，您必须使用`operator`关键字，后面跟隐式或显式。以下示例显示了一个名为`fancyint`的类型，它定义了从`int`到`int`的隐式和显式转换：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can use this type as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以如下使用这种类型：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, `a` is an object of the `fancyint` type. The value of `a` can
    be implicitly converted into `int`, because an implicit conversion operator is
    defined. However, the conversion from `int` to `fancyint` is defined as explicit,
    therefore a cast is necessary, as in `(fancyint)i`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a`是`fancyint`类型的对象。`a`的值可以隐式转换为`int`，因为定义了隐式转换运算符。然而，从`int`到`fancyint`的转换被定义为显式，因此需要进行转换，如`(fancyint)i`。
- en: Conversions with helper classes
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用辅助类进行转换
- en: Conversion with a helper class or method is useful to convert between incompatible
    types, such as between a string and an integer or a `System.DateTime` object.
    There are various helper classes provided by the framework, such as the `System.BitConverter`
    class, the `System.Convert` class, and the `Parse()` and `TryParse()` methods
    of the built-in numeric types. However, you can provide your own classes and methods
    to convert between any types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助类或方法进行转换对于在不兼容类型之间进行转换非常有用，比如在字符串和整数之间或`System.DateTime`对象之间。框架提供了各种辅助类，如`System.BitConverter`类，`System.Convert`类以及内置数值类型的`Parse()`和`TryParse()`方法。但是，您可以提供自己的类和方法来在任何类型之间进行转换。
- en: 'The following listing shows several examples of conversion using helper classes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了使用辅助类进行转换的几个示例：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is important to note the key difference between `Parse()` and `TryParse()`.
    The former tries to perform parsing and if that succeeds, it returns the parsed
    value; but if it fails, it throws an exception. The latter does not throw an exception,
    but returns `bool`, indicating the success or failure, and sets the second `out`
    parameter to the parsed value if successful or to the default value if it fails.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意`Parse()`和`TryParse()`之间的关键区别。前者尝试执行解析，如果成功，则返回解析后的值；但如果失败，则会抛出异常。后者不会抛出异常，而是返回`bool`，指示成功或失败，并将第二个`out`参数设置为解析成功时的值，或者在失败时设置为默认值。
- en: Operators
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'C# provides an extensive set of operators for built-in types. Operators are
    broadly classified in the following categories: arithmetic, relational, logical,
    bitwise, assignment, and other operators. Some operators can be overloaded for
    user-defined types. This topic will be further discussed in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103),
    *Object-Oriented Programming in C#*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C#为内置类型提供了广泛的运算符集。运算符在以下类别中广泛分类：算术、关系、逻辑、位、赋值和其他运算符。一些运算符可以被重载为用户定义的类型。这个主题将在[*第5章*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103)，*C#面向对象编程*中进一步讨论。
- en: When evaluating an expression, operator precedence and associativity determine
    the order in which the operations are performed. You can change this order by
    using *parentheses*, just like you would do with a mathematical expression.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估表达式时，运算符优先级和结合性确定了操作的执行顺序。您可以通过使用*括号*来改变这个顺序，就像您在数学表达式中所做的那样。
- en: 'The following table lists the order of the operators with the highest precedence
    at the top and the lowest at the bottom. Operators that are listed together, on
    the same row, have equal precedence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了具有最高优先级的运算符在顶部，最低优先级在底部的顺序。在同一行上列出的运算符具有相同的优先级：
- en: '![](img/Chapter_2_Table_12.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_12.jpg)'
- en: 'For operators with the same precedence, associativity determines which one
    is evaluated first. There are two types of associativity:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有相同优先级的运算符，结合性决定了首先计算哪个。有两种类型的结合性：
- en: '**Left-associativity**: This determines operators to be evaluated from *left
    to right*. All of the binary operators are left-associative except for the assignment
    operators and the null coalescing operators.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左结合性**：这确定了运算符从*左到右*进行计算。除了赋值运算符和空值合并运算符之外，所有二元运算符都是左结合的。'
- en: '**Right-associativity**: This determines operators to be evaluated from *right
    to left*. The assignment operator, the null-coalescing operator, and the conditional
    operator are right-associative.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右结合性**：这确定了运算符从*右到左*进行计算。赋值运算符、空值合并运算符和条件运算符都是右结合的。'
- en: In the following sections, we will take a closer look at each category of operators.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地研究每个运算符类别。
- en: Arithmetic operators
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: '**Arithmetic operators** perform arithmetic operations on the numerical type
    and can be unary or binary operators. A unary operator has a single operand, and
    a binary operator has two operands. The following set of arithmetic operators
    are defined in C#:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术运算符**对数字类型执行算术运算，并且可以是一元或二元运算符。一元运算符有一个操作数，而二元运算符有两个操作数。在C#中定义了以下一组算术运算符：'
- en: '![](img/Chapter_2_Table_13.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_13.png)'
- en: '`+`, `-`, and `*` will work as per the mathematical rules of addition, subtraction,
    and multiplication respectively. However, the `/` operator behaves a bit differently.
    When applied to an integer, it will truncate the remainder of the division. For
    example, 20/3 will return 6\. To get the remainder, we need to use the modulus
    operator. For example, 20%3 will return 2.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`，`-`和`*`将按照加法，减法和乘法的数学规则工作。但是，`/`操作符的行为有点不同。当应用于整数时，它将截断除法的余数。例如，20/3将返回6。要获得余数，我们需要使用模运算符。例如，20%3将返回2。'
- en: 'Among these, the increment and decrement operators require special attention.
    These operators have two forms:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，递增和递减操作符需要特别注意。这些操作符有两种形式：
- en: A postfix form
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀形式
- en: A prefix form
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀形式
- en: 'The increment operator will increase the value of its operand by `1`, whereas
    the decrement operator will decrease the value of its operand by `1`. In the following
    example, the `a` variable is initially `10`, but after applying the increment
    operator, its value will be `11`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 递增操作符将增加其操作数的值`1`，而递减操作符将减少其操作数的值`1`。在以下示例中，`a`变量最初为`10`，但应用递增操作符后，其值将为`11`：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The prefix and the postfix variants differ in the following way:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀和后缀变体在以下方面不同：
- en: The prefix operator first performs the operation and then returns the value.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀操作符首先执行操作，然后返回值。
- en: The postfix operator first retains the value, then increments it, and then returns
    the original value.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀运算符首先保留值，然后递增它，然后返回原始值。
- en: 'Let''s understand this with the help of the following code snippet. In the
    following example, `a` is `10`. When `a++` is assigned to `b`, `b` takes the value
    `10` and `a` is incremented to `11`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段来理解这一点。在以下示例中，`a`为`10`。当`a++`赋值给`b`时，`b`取值`10`，`a`递增为`11`：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, if we change this so that we assign `++a` to `b`, then `a` will be
    incremented to `11`, and that value will be assigned to `b`, so both `a` and `b`
    will have the value `11`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将`++a`赋值给`b`，那么`a`将递增为`11`，并且该值将被赋给`b`，因此`a`和`b`都将具有值`11`：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next category of operators that we will learn about is the relational operator.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习的下一个操作符类别是关系操作符。
- en: Relational operators
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系操作符
- en: 'Relational operators, also called **comparison operators**, perform a comparison
    on their operands. C# defines the following sets of relational operators:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符，也称为**比较操作符**，对其操作数执行比较。C#定义了以下一组关系操作符：
- en: '![](img/Chapter_2_Table_14.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_14.jpg)'
- en: The result of a relational operator is a `bool` value. These operators support
    all of the built-in numerical and floating-point types. However, enumerations
    also support these operators. For operands of the same enumeration type, the corresponding
    values of the underlying integral types are compared. Enumerations will be later
    discussed in [*Chapter 4*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083), *Understanding
    the Various User-Defined Types*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符的结果是`bool`值。这些操作符支持所有内置的数值和浮点类型。但是，枚举类型也支持这些操作符。对于相同枚举类型的操作数，将比较基础整数类型的相应值。枚举将在稍后讨论[*第4章*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083)，*理解各种用户定义类型*中。
- en: 'The next code listing shows several relational operators being used:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码清单显示了几个关系操作符的使用：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `<`, `>`, `<=`, and `>=` operators can be overloaded for user-defined types.
    However, if a type overloads `<` or `>`, it must overload both of them. Similarly,
    if a type overloads `<=` or `>=`, it must overload both of them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`，`>`，`<=`和`>=`操作符可以为用户定义的类型进行重载。但是，如果类型重载了`<`或`>`，它必须同时重载两者。同样，如果类型重载了`<=`或`>=`，它必须同时重载两者。'
- en: Logical operators
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑操作符
- en: 'Logical operators perform a logical operation on `bool` operands. The following
    set of logical operators are defined in C#:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑操作符对`bool`操作数执行逻辑操作。C#中定义了以下一组逻辑操作符：
- en: '![](img/Chapter_2_Table_15.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_15.jpg)'
- en: 'The following example shows these operands in use:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了这些操作数的使用：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, since `a` is `true` and `b` is `false`, `c` will be `false`
    and `d` will be `true`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于`a`为`true`，`b`为`false`，`c`将为`false`，`d`将为`true`。
- en: Bitwise and shift operators
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位和移位操作符
- en: 'A bitwise operator will work directly on the bits of their operands. A bitwise
    operator can only be used with integer operands. The following table lists all
    of the bitwise and shift operators:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 按位操作符将直接在其操作数的位上工作。按位操作符只能与整数操作数一起使用。以下表格列出了所有按位和移位操作符：
- en: '![](img/Chapter_2_Table_16.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_16.jpg)'
- en: 'In the following example, `a` is `10`, which in binary is `1010`, and `b` is
    `5`, which in binary is `0101`. The result of the bitwise AND is `0000`, so `c`
    will have the value `0`, and the result of bitwise OR is `1111`, so `d` will have
    the value `15`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`a`为`10`，在二进制中为`1010`，`b`为`5`，在二进制中为`0101`。按位AND的结果是`0000`，因此`c`将具有值`0`，按位OR的结果是`1111`，因此`d`将具有值`15`：
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The left-shift operator shifts the left-hand operand to the left by the number
    of bits defined by the right-hand operand. Similarly, the right-shift operator
    shifts the left-hand operand to the right by the number of bits defined by the
    right-hand operand. The left-shift operator discards the higher-order bits that
    are outside the range of the result type and sets the lower-order bits to zero.
    The right-shift operator discards the lower-order bits and the higher-order bits
    are set as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 左移运算符将左操作数向左移动右操作数定义的位数。类似地，右移运算符将左操作数向右移动右操作数定义的位数。左移运算符丢弃超出结果类型范围的高阶位，并将低阶位设置为零。右移运算符丢弃低阶位，并将高阶位设置如下：
- en: If the value that is shifted is `int` or `long`, an arithmetic shift is performed.
    That means the sign bit is propagated to the right on the higher-order empty bits.
    As a result, for a positive number, the higher-order bits are set to zero (because
    the sign bit is *0*) and for a negative number, the higher-order bits are set
    to one (because the sign bit is *1*).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被移位的值是`int`或`long`，则执行算术移位。这意味着符号位在高阶空位上向右传播。因此，对于正数，高阶位设置为零（因为符号位为*0*），对于负数，高阶位设置为1（因为符号位为*1*）。
- en: If the value that is shifted is `uint` or `ulong`, a logical shift is performed.
    In this case, the higher-order bits are always set to `0`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被移位的值是`uint`或`ulong`，则执行逻辑移位。在这种情况下，高阶位始终设置为`0`。
- en: The shift operations are only defined for `int`, `uint`, `long`, and `ulong`.
    If the left-hand operand is of another integral type, it is converted to `int`
    before the operation is applied. The result of a shift operation will always contain
    at least 32 bits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 移位操作仅对`int`、`uint`、`long`和`ulong`定义。如果左操作数是另一种整数类型，则在应用操作之前将其转换为`int`。移位操作的结果将始终包含至少32位。
- en: 'The following listing shows examples of shifting operations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了移位操作的示例：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, we initialized the `x` and `y` variables with binary literals
    to make it easier to understand how shifting works. The value of the variables
    after shifting is also shown in binary in the comments.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用二进制字面量初始化了`x`和`y`变量，以便更容易理解移位的工作原理。移位后变量的值也以二进制形式显示在注释中。
- en: Assignment operators
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'An assignment operator assigns a value to its left operand based on the value
    of its right operand. The following assignment operators are available in C#:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符根据其右操作数的值将一个值分配给其左操作数。C#中提供了以下赋值运算符：
- en: '![](img/Chapter_2_Table_17.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_2_Table_17.jpg)'
- en: In this table, we have the simple assignment operator (`=`) that assigns the
    right-hand value to the left operand, and then we have compound assignment operators,
    that first perform an operation (arithmetical, shifting, or bitwise) and then
    assign the result of the operation to the left operand. Therefore, operations
    such as `a = a + 2` and `a += 2` are equivalent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，我们有简单的赋值运算符（`=`），它将右操作数的值分配给左操作数，然后我们有复合赋值运算符，它首先执行一个操作（算术、移位或位运算），然后将操作的结果分配给左操作数。因此，诸如`a
    = a + 2`和`a += 2`的操作是等价的。
- en: Other operators
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他运算符
- en: Apart from the operators discussed so far, there are other useful operators
    in C# that work both on built-in types and user-defined types. These include the
    conditional operator, the null-conditional operators, the null-coalescing operator,
    and the null-coalescing assignment operator. We will look at these operators in
    the following pages.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迄今为止讨论的运算符外，C#中还有其他对内置类型和用户定义类型都适用的有用运算符。这些包括条件运算符、空值条件运算符、空值合并运算符和空值合并赋值运算符。我们将在接下来的页面中介绍这些运算符。
- en: The ternary conditional operator
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 三元条件运算符
- en: The `?:` and often simply referred to as the *conditional operator*. It allows
    you to return a value from two available options based on whether a Boolean condition
    evaluates to `true` or `false`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`?:`通常简称为*条件运算符*。它允许您根据布尔条件的评估结果返回两个可用选项中的一个值。'
- en: 'The syntax of the ternary operator is as follow:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符的语法如下：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If the Boolean condition evaluates to `true`, the `consequent` expression will
    be evaluated, and its result returned. Otherwise, the `alternative` expression
    will be evaluated, and its result returned. The ternary conditional operator can
    also be perceived as a shorthand for an `if-else` statement.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔条件评估为`true`，则将评估`consequent`表达式并返回其结果。否则，将评估`alternative`表达式并返回其结果。三元条件运算符也可以被视为`if-else`语句的简写。
- en: 'In the following example, the function called `max()` returns the maximum of
    two integers. The conditional operator is used to check whether `a` is greater
    or equal to `b`, in which case the value of `a` is returned; otherwise, the result
    is the value of `b`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，名为`max()`的函数返回两个整数中的最大值。条件运算符用于检查`a`是否大于或等于`b`，在这种情况下返回`a`的值；否则，结果是`b`的值：
- en: '[PRE51]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There is another form of this operator called **conditional ref expression**
    (available since C# 7.2) that allows returning the reference to the result of
    one of the two expressions. The syntax, in this case, is as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种形式的这个运算符叫做**条件ref表达式**（自C# 7.2起可用），它允许返回对两个表达式中的一个结果的引用。在这种情况下，语法如下：
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The result reference can be assigned to a `ref` local or `ref` read-only local
    variable and uses it as a reference return value or as a ref method parameter.
    The conditional `ref` expression requires the type of `consequent` and `alternative`
    to be the same.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 结果引用可以分配给`ref`本地变量或`ref`只读本地变量，并将其用作引用返回值或作为ref方法参数。条件`ref`表达式要求`consequent`和`alternative`的类型相同。
- en: 'In the following example, the conditional `ref` expression is used to select
    between two alternatives based on user input. If an even number is introduced,
    the `v` variable will hold a reference to `a`; otherwise, it will hold a reference
    to `b`. The value of `v` is incremented and then `a` and `b` are printed to the
    console:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，条件`ref`表达式用于根据用户输入在两个选择项之间进行选择。如果输入的是偶数，则`v`变量将保存对`a`的引用；否则，它将保存对`b`的引用。增加`v`的值，然后将`a`和`b`打印到控制台：
- en: '[PRE53]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: While the conditional operator checks whether a condition is true or not, the
    null-conditional operator checks whether an operand is null or not. We will look
    at this operator in the next section.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然条件运算符检查条件是否为真，但空值条件运算符检查操作数是否为null。我们将在下一节中介绍这个运算符。
- en: The null-conditional operators
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值条件运算符
- en: The `?.` (also known as the `?[]` to apply element access for an array. These
    operators apply the operation to their operand if and only if that operand is
    not `null`. Otherwise, the result of applying the operator is also `null`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`?.`（也称为`?[]`用于数组的元素访问）。这些运算符仅在其操作数不为`null`时才应用操作。否则，应用运算符的结果也为`null`。'
- en: 'The following example shows how to use the null-conditional operator to invoke
    a method called `run()` from an instance of a class called `foo`, through an object
    that might be `null`. Notice that the result is a nullable type (`int?`) because
    if the operand of `?.` is `null`, then the result of its evaluation is also `null`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何使用空合并运算符来调用名为`run()`的方法，通过一个可能为`null`的类`foo`的实例，通过`?.`的操作数是`null`，那么其评估结果也是`null`：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The null-conditional operators can be *chained* together. However, if one operator
    in the chain is evaluated to `null`, the rest of the chain is *short-circuited*
    and does not evaluate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符可以*链接*在一起。但是，如果链中的一个运算符求值为`null`，则链的其余部分将被*短路*，不进行求值。
- en: 'In the following example, the `bar` class has a property of the `foo` type.
    An array of `bar` objects is created and we try to retrieve the value from the
    execution of the `run()` method from the `f` property of the first `bar` element
    in the array:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`bar`类具有`foo`类型的属性。创建了一个`bar`对象数组，并尝试从数组中的第一个`bar`元素的`f`属性的`run()`方法的执行中检索值：
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can avoid the use of a nullable type if we combine the null-conditional
    operator with the null-coalescing operator and provide a default value in case
    the null-conditional operator returns `null`. An example is shown here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将空合并运算符与空合并赋值运算符结合起来，并在空合并运算符返回`null`时提供默认值，就可以避免使用可空类型。下面是一个示例：
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The null-coalescing operator is discussed in the following section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符在下一节中讨论。
- en: The null-coalescing and null-coalescing assignment operators
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空合并和空合并赋值运算符
- en: The `??`, will return the left-hand operand if it is not `null`; otherwise,
    it will evaluate the right-hand operand and return its result. The left-hand operand
    cannot be a non-nullable value type. The right-hand operand is only evaluated
    if the left-hand operand is `null`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`??`如果左操作数不为`null`，则返回左操作数；否则，将对右操作数进行求值并返回其结果。左操作数不能是非可空值类型。只有在左操作数为`null`时才会对右操作数进行求值。'
- en: The `??=`, is a new operator added in C# 8\. It assigns the value of its right-hand
    operand to its left-hand operand, if and only if the left-hand operand evaluates
    to `null`. If the left-hand operand is not `null`, then the right-hand operand
    is not evaluated.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`??=`是C# 8中新增的一个新操作符。如果左操作数求值为`null`，则将其右操作数的值赋给左操作数。如果左操作数不为`null`，则不会对右操作数进行求值。'
- en: Both `??` and `??=` are *right-associative*. That means, the expression `a ??
    b ?? c` is evaluated as `a ?? (b ?? c)`. Similarly, the expression `a ??= b ??=
    c` is evaluated as `a ??= (b ??= c)`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`??`和`??=`都是*右关联*的。这意味着表达式`a ?? b ?? c`将被解释为`a ?? (b ?? c)`。同样，表达式`a ??= b
    ??= c`将被解释为`a ??= (b ??= c)`。'
- en: 'Take a look at the following code snippet:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE57]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have defined a nullable variable, `n1`, and initialized it to `null`. The
    value of `n2` will be set to `2` as `n1` is `null`. After assigning `n1` a non-null
    value, we will apply the conditional operator on `n1` and integer `2`. In this
    case, since `n1` is not `null`, the value of `n3` will be the same as that of
    `n1`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个可空变量`n1`，并将其初始化为`null`。由于`n1`为`null`，因此`n2`的值将被设置为`2`。在给`n1`赋予非空值后，我们将在`n1`和整数`2`上应用条件运算符。在这种情况下，由于`n1`不为`null`，因此`n3`的值将与`n1`的值相同。
- en: 'The null-coalescing operator can be used multiple times in an expression. In
    the following example, the `GetDisplayName()` function returns the value of `name`
    if this is not `null`; otherwise, it returns the value of `email` if it is not
    `null`; if `email` is also `null`, then it returns `"unknown"`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符可以在表达式中多次使用。在下面的示例中，`GetDisplayName()`函数返回`name`的值（如果不为`null`），否则返回`email`的值（如果不为`null`）；如果`email`也为`null`，则返回`"unknown"`：
- en: '[PRE58]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The null-coalescing operator can also be used in argument checking. If a parameter
    is expected to be non-null, but it is in fact `null`, you can throw an exception
    from the right-hand operand. This is shown in the following example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并运算符也可以用于参数检查。如果期望参数为非空，但实际上为`null`，则可以从右操作数抛出异常。下面是一个示例：
- en: '[PRE59]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The null-coalescing assignment operator is useful in replacing code that checks
    whether a variable is `null` before assigning it with a simpler, more succinct
    form. Basically, the `??=` operator is syntactic sugar for the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并赋值运算符在替换检查变量是否为`null`的代码时非常有用，可以用更简洁的形式来实现。基本上，`??=`运算符是以下代码的语法糖：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This can be replaced with `a ??= b`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用`a ??= b`来替换。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about built-in data types in C#, which are the numerical
    types, floating-point types, Boolean and character types, string, and object.
    Moreover, we also covered nullable types and array types. We learned about variables
    and constants and looked at the differences between value types and reference
    types. In addition to this, we covered the concepts of type conversion and casting.
    At the end of this chapter, we learned about the various types of operators available
    in C#.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C#中的内置数据类型，包括数值类型、浮点类型、布尔和字符类型、字符串和对象。此外，我们还涵盖了可空类型和数组类型。我们学习了变量和常量，并查看了值类型和引用类型之间的区别。除此之外，我们还涵盖了类型转换和强制转换的概念。在本章的最后，我们学习了C#中可用的各种类型的运算符。
- en: In the next chapter, we will explore control statements and exceptions in C#.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C#中的控制语句和异常。
- en: Test what you learned
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: What are the integral built-in types in C#?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中的整数内置类型有哪些？
- en: What are the differences between the floating-point types and the `decimal`
    type?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浮点类型和`decimal`类型之间有什么区别？
- en: How do you concatenate strings?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何连接字符串？
- en: What are escape sequences and how are they related to verbatim strings?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转义序列是什么，它们与逐字字符串有什么关系？
- en: What is an implicitly typed variable? Can these variables be initialized with
    `null`?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐式类型变量是什么？这些变量可以用`null`初始化吗？
- en: What are value types? What are reference types? What are the main differences
    between them?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是值类型？什么是引用类型？它们之间的主要区别是什么？
- en: What are boxing and unboxing?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是装箱和拆箱？
- en: What is a nullable type and how do you declare a nullable integer variable?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可空类型，如何声明可空整数变量？
- en: How many types of arrays exist and what is the difference between them?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少种类型的数组存在，它们之间有什么区别？
- en: What are the available type conversions and how do you provide user-defined
    type conversion?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些可用的类型转换，如何提供用户定义的类型转换？
