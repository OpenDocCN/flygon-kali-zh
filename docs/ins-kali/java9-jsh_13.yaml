- en: Chapter 13. Modularity in Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。Java 9中的模块化
- en: 'In this chapter, we will take advantage of one of the new features added to
    Java 9 to allow us to modularize the source code and easily manage dependencies.
    We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用Java 9添加的新功能之一，使我们能够将源代码模块化并轻松管理依赖关系。我们将：
- en: Refactor existing code to take advantage of object-oriented programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构现有代码以利用面向对象编程
- en: Organize object-oriented code with the new modularity in Java 9
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中使用新的模块化组织面向对象的代码
- en: Create modular source code in Java 9
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中创建模块化源代码
- en: Compile multiple modules with the Java 9 compiler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java 9编译器编译多个模块
- en: Run modularized code with Java 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java 9运行模块化代码
- en: Refactoring existing code to take advantage of object-oriented programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构现有代码以利用面向对象编程
- en: If we start writing object-oriented code from scratch, we can take advantage
    of everything we learned in the previous chapters and all the features included
    in Java 9\. As the requirements evolve, we will have to make changes to the interfaces
    and the classes to further generalize or specialize them, edit them, and create
    new ones. The fact that we started our project with an object-oriented approach
    will make it easy to make the necessary adjustments to the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从头开始编写面向对象的代码，我们可以利用我们在前几章学到的一切以及Java 9中包含的所有功能。随着需求的演变，我们将不得不对接口和类进行更改，进一步泛化或专门化它们，编辑它们，并创建新的接口和类。我们以面向对象的方式开始项目的事实将使我们能够轻松地对代码进行必要的调整。
- en: Sometimes, we are extremely lucky and we have the chance to follow best practices
    as soon as we kick off a project. However, many other times we aren't so lucky
    and we have to work on projects that didn't follow best practices. In these cases,
    instead of following the same bad practices that generated error-prone, repetitive,
    and difficult-to-maintain code, we can use the features provided by our favorite
    IDE and additional helper tools to refactor existing code, and generate object-oriented
    code that promotes code reuse and allows us to reduce maintenance headaches.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们非常幸运，有机会在启动项目时就遵循最佳实践。然而，很多时候我们并不那么幸运，不得不处理未遵循最佳实践的项目。在这些情况下，我们可以利用我们喜爱的IDE提供的功能和额外的辅助工具来重构现有代码，生成促进代码重用并允许我们减少维护工作的面向对象代码，而不是遵循生成容易出错、重复且难以维护的代码的相同不良实践。
- en: 'For example, imagine that we have to develop a Web Service that allows us to
    work with 3D models and render them on a 2D image with a specific resolution.
    The requirements specify that the first two 3D models that we will have to render
    with our Web Service are a sphere and a cube. The Web Service must allow us to
    change the following parameters of a perspective camera that allows us to see
    a specific part of the 3D world rendered on a 2D screen:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要开发一个Web服务，允许我们处理3D模型并在具有特定分辨率的2D图像上渲染它们。需求指定我们将使用我们的Web服务渲染的前两个3D模型是一个球体和一个立方体。Web服务必须允许我们更改透视摄像机的以下参数，以便我们可以在2D屏幕上看到渲染的3D世界的特定部分：
- en: Position (*X*, *Y*, and *Z* values)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（*X*、*Y*和*Z*值）
- en: Direction (*X*, *Y*, and *Z* values)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方向（*X*、*Y*和*Z*值）
- en: Up vector (*X*, *Y*, and *Z* values)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上向量（*X*、*Y*和*Z*值）
- en: Perspective field of view in degrees
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透视视野（以度为单位）
- en: Near clipping plane
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近裁剪平面
- en: Far clipping plane
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远裁剪平面
- en: Imagine that other developers started working on the project and generated a
    single Java file with a class wrapper that declares two static methods. One of
    these methods renders a cube and the other method renders a sphere. These methods
    receive all the necessary arguments to render each 3D figure, including all the
    necessary parameters to determine the 3D figure's location and size, and configure
    the perspective camera and a directional light.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设其他开发人员开始在项目上工作，并生成了一个包含声明两个静态方法的类包装器的单个Java文件。其中一个方法渲染一个立方体，另一个方法渲染一个球体。这些方法接收渲染每个3D图形所需的所有参数，包括确定3D图形位置和大小以及配置透视摄像机和定向光的所有必要参数。
- en: 'The following lines show an example of the declaration of the class named `Renderer`
    with two static methods: `renderCube` and `renderSphere`. The first one sets up
    and renders a cube, and the second one sets up and renders a sphere. It is very
    important to understand that the sample code doesn''t follow best practices and
    we will refactor it. Take into account that the two static methods have a lot
    of code in common. The code file for the sample is included in the `java_9_oop_chapter_13_01`
    folder, in the `example13_01.java` file.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了一个名为`Renderer`的类的声明示例，其中包含两个静态方法：`renderCube`和`renderSphere`。第一个方法设置并渲染一个立方体，第二个方法设置并渲染一个球体。非常重要的是要理解，示例代码并不遵循最佳实践，我们将对其进行重构。请注意，这两个静态方法有很多共同的代码。示例的代码文件包含在`java_9_oop_chapter_13_01`文件夹中的`example13_01.java`文件中。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each static method requires a huge number of parameters. Now, let's imagine
    we have new requirements for our Web Service. We have to add code to render additional
    shapes, and add different types of cameras and lights. In addition, we have to
    work in an **IoT** (**Internet of Things**) project in which we have to reuse
    shapes in a computer vision application, and therefore, we want to take advantage
    of the code we have for our Web Service and share the code base with this new
    project. In addition, we have to work on another project that will run on a powerful
    IoT board, specifically a member of the Intel Joule series that will run a rendering
    service and will use its 4K video output capabilities to display the generated
    graphics. We will use the powerful quad-core CPU included in this board to run
    the local rendering service and, in this case, we won't be calling the Web Service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个静态方法都需要大量的参数。现在，让我们想象一下我们对我们的Web服务有新的要求。我们必须添加代码来渲染额外的形状，并添加不同类型的摄像机和灯光。此外，我们必须在一个**IoT**（**物联网**）项目中工作，在这个项目中，我们必须在计算机视觉应用程序中重用形状，因此，我们希望利用我们为Web服务编写的代码，并与这个新项目共享代码库。此外，我们必须在另一个项目上工作，这个项目将在一块强大的IoT板上运行，具体来说，是英特尔Joule系列的一员，它将运行一个渲染服务，并利用其4K视频输出功能来显示生成的图形。我们将使用这块板载的强大四核CPU来运行本地渲染服务，在这种情况下，我们不会调用Web服务。
- en: Many applications have to share many pieces of code and our code must be ready
    for new shapes, cameras, and lights. The code can easily become a really big mess,
    repetitive, and difficult to maintain. Of course, the previously shown code is
    already difficult to maintain. Hence, we will refactor the existing code, and
    we will create many interfaces and classes to create an object-oriented version
    that we will be able to expand based on new requirements and reuse in our different
    applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序必须共享许多代码片段，我们的代码必须为新的形状、摄像机和灯光做好准备。代码很容易变得非常混乱、重复，并且难以维护。当然，先前显示的代码已经很难维护了。因此，我们将重构现有的代码，并创建许多接口和类来创建一个面向对象的版本，我们将能够根据新的要求进行扩展，并在不同的应用程序中重用。
- en: So far, we have been working with JShell to run our code samples. This time,
    we will create one Java source code file for each interface or class. In addition,
    we will organize these files into the new modules introduced in Java 9\. Finally,
    we will compile these modules and run a console application. You can use your
    favorite editor or IDE to create the different code files. Remember that you can
    download the indicated code files and you don't have to type any code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用JShell来运行我们的代码示例。这一次，我们将为每个接口或类创建一个Java源代码文件。此外，我们将把这些文件组织到Java
    9中引入的新模块中。最后，我们将编译这些模块并运行一个控制台应用程序。您可以使用您喜欢的编辑器或IDE来创建不同的代码文件。请记住，您可以下载指定的代码文件，而不必输入任何代码。
- en: 'We will create the following public interfaces, abstract classes, and concrete
    classes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下公共接口、抽象类和具体类：
- en: '`Vector3d`: This concrete class represents a mutable 3D vector with `int` values
    for `x`, `y`, and `z`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector3d`：这个具体类表示一个可变的3D向量，具有`x`、`y`和`z`的`int`值。'
- en: '`Rendereable`: This interface specifies the requirements for an element that
    has a location and can be rendered.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可渲染`：这个接口指定了具有位置并且可以被渲染的元素的要求。'
- en: '`SceneElement`: This abstract class implements the `Rendereable` interface,
    and represents any element that has a location and can be rendered. All the scene
    elements will inherit from this abstract class.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`场景元素`：这个抽象类实现了`可渲染`接口，表示任何具有位置并且可以被渲染的元素。所有的场景元素都将继承自这个抽象类。'
- en: '`Light`: This abstract class inherits from `SceneElement` and represents a
    light in the scene that must provide a description of its properties.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`灯光`：这个抽象类继承自`场景元素`，表示场景中的灯光，必须提供其属性的描述。'
- en: '`DirectionalLight`: This concrete class inherits from `Light` and represents
    a directional light that has a specific color.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`定向光`：这个具体类继承自`灯光`，表示具有特定颜色的定向光。'
- en: '`Camera`: This abstract class inherits from `SceneElement` and represents a
    camera in the scene.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摄像机`：这个抽象类继承自`场景元素`，表示场景中的摄像机。'
- en: '`PerspectiveCamera`: This concrete class inherits from `Camera` and represents
    a perspective camera that has a direction, an up vector, a field of view, a near
    clipping plane, and a far clipping plane.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`透视摄像机`：这个具体类继承自`摄像机`，表示具有方向、上向量、视野、近裁剪平面和远裁剪平面的透视摄像机。'
- en: '`Shape`: This abstract class inherits from `SceneElement`, and represents a
    shape in the scene that can be rendered with an active camera and receives multiple
    lights.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`形状`：这个抽象类继承自`场景元素`，表示场景中可以使用活动摄像机渲染并接收多个灯光的形状。'
- en: '`Sphere`: This concrete class inherits from `Shape` and represents a sphere.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`球体`：这个具体类继承自`形状`，表示一个球体。'
- en: '`Cube`: This concrete class inherits from `Shape` and represents a cube.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`立方体`：这个具体类继承自`形状`，表示一个立方体。'
- en: '`Scene`: This concrete class represents the scene with an active camera, shapes,
    and lights. We can use an instance of this class to compose a scene and render
    it.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`场景`：这个具体类表示具有活动摄像机、形状和灯光的场景。我们可以使用这个类的实例来组合一个场景并渲染它。'
- en: '`Example01`: This concrete class will declare a main static method that will
    use a `PerspectiveCamera`, a `Sphere`, a `Cube`, and a `DirectionalLight` to create
    a `Scene` instance and call its render method.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`示例01`：这个具体类将声明一个主静态方法，该方法将使用`透视摄像机`、`球体`、`立方体`和`定向光`来创建一个`场景`实例并调用其渲染方法。'
- en: We will declare each of the previously enumerated interfaces, abstract classes,
    and concrete classes in a file with the `.java` extension and with the same name
    as the type we declare. For example, we will declare the `Vector3d` class in the
    `Vector3d.java` file, also known as the Java source file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个扩展名为`.java`的文件中声明之前列举的每个接口、抽象类和具体类，并且文件名与我们声明的类型相同。例如，我们将在名为`Vector3d.java`的文件中声明`Vector3d`类，也就是Java源文件。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good practice and a common convention to declare a single public interface
    or class in a Java source file with the same name as the type we declare. The
    Java compiler will generate an error in a case where we declare more than one
    public type in a Java source file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java源文件中，声明与类型相同名称的单个公共接口或类是一种良好的实践和常见约定。如果我们在Java源文件中声明了多个公共类型，Java编译器将生成错误。
- en: Organizing object-oriented code with the new modularity in Java 9
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java 9中的新模块化组织面向对象的代码
- en: When we have just a few interfaces and classes, hundreds of lines of object-oriented
    code are easy to organize and maintain. However, as the number of types and lines
    of code start to increase, it is necessary to follow some rules to organize the
    code and make it easy to maintain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有一些接口和类时，数百行面向对象的代码很容易组织和维护。然而，随着类型和代码行数的增加，有必要遵循一些规则来组织代码并使其易于维护。
- en: A very well-written object-oriented code can generate a maintenance headache
    if it isn't organized in an effective way. We don't have to forget that a well-written
    object-oriented code promotes code reuse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的面向对象的代码如果没有以有效的方式组织，就会产生维护上的头疼。我们不应该忘记，一个良好编写的面向对象的代码促进了代码重用。
- en: In our example, we will have just a few interfaces, abstract classes, and concrete
    classes. However, we must imagine that we will have a huge number of additional
    types to support the additional requirements. Hence, we will end up with dozens
    of classes related to the mathematical operations required to render the elements
    that compose a scene, additional types of lights, new types of cameras, classes
    related to these new lights and cameras, and dozens of additional shapes and their
    related classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只会有一些接口、抽象类和具体类。然而，我们必须想象我们将有大量额外的类型来支持额外的需求。因此，我们最终将拥有数十个与渲染场景组成元素所需的数学运算相关的类，额外类型的灯光，新类型的摄像机，与这些新灯光和摄像机相关的类，以及数十个额外的形状及其相关的类。
- en: We will create many modules to allow us to create units of software that have
    a name, require other modules, and export a public API that is usable and accessible
    by other modules. When a module requires other modules, it means that this module
    depends on the modules listed as requirements. The name for each module will follow
    the same conventions we usually use for packages in Java.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建许多模块，以便我们可以创建具有名称、需要其他模块并导出其他模块可用和可访问的公共API的软件单元。当一个模块需要其他模块时，这意味着该模块依赖于列出的模块。每个模块的名称将遵循我们通常在Java中使用的包的相同约定。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Other modules can only access the public types that a module exports. If we
    declare a public type within a module but we don't include it in the exported
    API, we won't be able to access it outside of the module. We have to avoid circular
    dependencies when we create module dependencies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块只能访问模块导出的公共类型。如果我们在模块内声明了一个公共类型，但没有将其包含在导出的API中，那么我们将无法在模块外部访问它。在创建模块依赖关系时，我们必须避免循环依赖。
- en: 'We will create the following eight modules:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下八个模块：
- en: '`com.renderer.math`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.math`'
- en: '`com.renderer.sceneelements`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.sceneelements`'
- en: '`com.renderer.lights`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.lights`'
- en: '`com.renderer.cameras`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.cameras`'
- en: '`com.renderer.shapes`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.shapes`'
- en: '`com.renderer.shapes.curvededges`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.shapes.curvededges`'
- en: '`com.renderer.shapes.polyhedrons`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer.shapes.polyhedrons`'
- en: '`com.renderer`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.renderer`'
- en: Now, whenever we need to work with lights, we will explore the types declared
    in the `com.renderer.lights` module. Whenever we need to work with 3D shapes with
    curved edges, we will explore the types declared in the `com.renderer.shapes.curvededges`
    module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们需要处理灯光时，我们将探索`com.renderer.lights`模块中声明的类型。每当我们需要处理具有曲边的3D形状时，我们将探索`com.renderer.shapes.curvededges`模块中声明的类型。
- en: Each module will declare the classes and interfaces in a package that will have
    the same name as the module name. For example, the `com.renderer.cameras` module
    will declare classes in the `com.renderer.cameras` package. A **package** is a
    grouping of related types. Each package generates a namespace that declares a
    scope. Thus, we will work with packages in combination with modules.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块将在与模块名称相同的包中声明类和接口。例如，`com.renderer.cameras`模块将在`com.renderer.cameras`包中声明类。**包**是相关类型的分组。每个包生成一个声明范围的命名空间。因此，我们将与模块结合使用包。
- en: The following table summarizes the modules we will create, and the interfaces,
    abstract classes, and concrete interfaces that we will declare within each module.
    In addition, the table specifies the list of modules that each module requires.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们将创建的模块，以及我们将在每个模块中声明的接口、抽象类和具体接口。此外，表格还指定了每个模块所需的模块列表。
- en: '| Module name | Declared public types | Module requirements |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 模块名称 | 声明的公共类型 | 模块要求 |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `com.renderer.math` | `Vector3d` | `-` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.math` | `Vector3d` | `-` |'
- en: '| `com.renderer.sceneelements` | `Rendereable``SceneElement` | `com.renderer.math`
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.sceneelements` | `Rendereable``SceneElement` | `com.renderer.math`
    |'
- en: '| `com.renderer.lights` | `Light``DirectionalLight` | `com.renderer.math``com.renderer.sceneelements`
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.lights` | `Light``DirectionalLight` | `com.renderer.math``com.renderer.sceneelements`
    |'
- en: '| `com.renderer.cameras` | `Camera``PerspectiveCamera` | `com.renderer.math``com.renderer.sceneelements`
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.cameras` | `Camera``PerspectiveCamera` | `com.renderer.math``com.renderer.sceneelements`
    |'
- en: '| `com.renderer.shapes` | `Shape` | `com.renderer.math``com.renderer.sceneelements``com.renderer.lights``com.renderer.cameras`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.shapes` | `Shape` | `com.renderer.math``com.renderer.sceneelements``com.renderer.lights``com.renderer.cameras`
    |'
- en: '| `com.renderer.shapes.curvededges` | `Sphere` | `com.renderer.math``com.renderer.lights``co`
    `m.renderer.shapes` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.shapes.curvededges` | `Sphere` | `com.renderer.math``com.renderer.lights``co`
    `m.renderer.shapes` |'
- en: '| `com.renderer.shapes.polyhedrons` | `Cube` | `com.renderer.math``com.renderer.lights``com.renderer.shapes`
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer.shapes.polyhedrons` | `Cube` | `com.renderer.math``com.renderer.lights``com.renderer.shapes`
    |'
- en: '| `com.renderer` | `Scene``Example01` | `com.renderer.math``com.renderer.cameras``com.renderer.lights``com.renderer.shapes``com.renderer.shapes.curvededges``com.renderer.shapes.polyhedrons`
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `com.renderer` | `Scene``Example01` | `com.renderer.math``com.renderer.cameras``com.renderer.lights``com.renderer.shapes``com.renderer.shapes.curvededges``com.renderer.shapes.polyhedrons`
    |'
- en: It is very important to notice that all the modules also require the `java.base`
    module that exports all of the platform's core packages such as `java.io`, `java.lang`,
    `java.math`, `java.net`, and `java.util`, among others. However, every module
    depends implicitly on the `java.base` module, and therefore, there is no need
    to include it in the dependency list when we declare the new modules and specify
    their required modules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，所有模块还需要`java.base`模块，该模块导出所有平台的核心包，如`java.io`、`java.lang`、`java.math`、`java.net`和`java.util`等。然而，每个模块都隐式依赖于`java.base`模块，因此，在声明新模块并指定其所需模块时，无需将其包含在依赖列表中。
- en: The next diagram shows the module graph in which the modules are nodes and a
    dependency of one module on another one is a directed edge. We don't include `java.lang`
    in the module graph.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表显示了模块图，其中模块是节点，一个模块对另一个模块的依赖是一个有向边。我们不在模块图中包括`java.lang`。
- en: '![Organizing object-oriented code with the new modularity in Java 9](img/00101.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Java 9中的新模块化组织面向对象的代码](img/00101.jpeg)'
- en: We won't work with any specific IDE to create all the modules. This way, we
    will understand the directory structure and all the required files. Then, we can
    take advantage of the features included in our favorite IDE to easily create new
    modules and their necessary directory structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用任何特定的IDE来创建所有模块。这样，我们将了解目录结构和所有必需的文件。然后，我们可以利用我们喜欢的IDE中包含的功能轻松创建新模块及其必需的目录结构。
- en: There is a convention that specifies that the source code for the module must
    be located in a directory with the same name as the module name. For example,
    the module named `com.renderer.math` must be located in a directory named `com.renderer.math`.
    We have to create a module descriptor for each desired module, that is, a source
    code file named `module-info.java`, within the root folder for the module. This
    file specifies the module name, the modules that are required, and the packages
    that the module exports. The exported packages will be visible by the modules
    that require the module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个约定规定，模块的源代码必须位于与模块名称相同的目录中。例如，名为`com.renderer.math`的模块必须位于名为`com.renderer.math`的目录中。我们必须为每个所需的模块创建一个模块描述符，即在模块的根文件夹中创建一个名为`module-info.java`的源代码文件。该文件指定了模块名称、所需的模块和模块导出的包。导出的包将被需要该模块的模块看到。
- en: Then, it is necessary to create subdirectories for each name separated by a
    dot (`.`) in the module name. For example, we will create the `com/renderer/math`
    directories (`com\renderer\math` sub-folders in Windows) within the `com.renderer.math`
    directory. The Java source files that declare the interfaces, abstract classes,
    and concrete classes for each module will be located in these sub-folders.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要为模块名称中由点（`.`）分隔的每个名称创建子目录。例如，我们将在`com.renderer.math`目录中创建`com/renderer/math`目录（在Windows中为`com\renderer\math`子文件夹）。声明每个模块的接口、抽象类和具体类的Java源文件将位于这些子文件夹中。
- en: We will create a base directory named `Renderer` with a sub-folder named `src`
    that will include all the source code for our modules. So, we will have `Renderer/src`
    (`Renderer\src` in Windows) as our base directory for the source code. Then, we
    will create a folder for each module with the `module-info.java` file and the
    sub-folders with the Java source code files. The following directory structure
    shows the final contents we will have within the `Renderer/src` (`Renderer\src`
    in Windows) directory. The file names are highlighted.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Renderer`的基本目录，其中包含一个名为`src`的子文件夹，其中包含我们所有模块的源代码。因此，我们将`Renderer/src`（在Windows中为`Renderer\src`）作为我们的源代码基本目录。然后，我们将为每个模块创建一个文件夹，其中包含`module-info.java`文件和Java源代码文件的子文件夹。以下目录结构显示了我们将在`Renderer/src`（在Windows中为`Renderer\src`）目录中拥有的最终内容。文件名已突出显示。
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating modular source code
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块化源代码。
- en: Now it is time to start creating the necessary directory structures, and write
    the code for the `module-info.java` files and the source Java files for each module.
    We will create the `com.renderer.math` module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始创建必要的目录结构，并为每个模块编写`module-info.java`文件和源Java文件的代码了。我们将创建`com.renderer.math`模块。
- en: Create a directory named `Renderer` and a `src` sub-directory. We will use `Renderer/src`
    (`Renderer\src` in Windows) as our base directory for the source code. However,
    take into account that you don't need to create any folder in a case where you
    download the source code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Renderer`的目录和一个`src`子目录。我们将使用`Renderer/src`（在Windows中为`Renderer\src`）作为我们的源代码基本目录。但是，请注意，如果您下载源代码，则无需创建任何文件夹。
- en: Now create the `com.renderer.math` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.math`. The code file for the sample is included in
    the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.math` sub-folder, in the
    `module-info.java` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（在Windows中为`Renderer\src`）中创建`com.renderer.math`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。下面的行组成了名为`com.renderer.math`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.math`子文件夹中的`module-info.java`文件中。
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `module` keyword followed by the module name `com.renderer.math` begins
    the module declaration. The lines included within the curly braces specify the
    module body. The `exports` keyword followed by the package name `com.renderer.math`
    indicates that this module exports all the public types declared within the `com.renderer.math`
    package.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`module`关键字后跟模块名称`com.renderer.math`开始模块声明。花括号中包含的行指定了模块主体。`exports`关键字后跟包名`com.renderer.math`表示该模块导出`com.renderer.math`包中声明的所有公共类型。'
- en: Create the `com/renderer/math` (`com\renderer\math` in Windows) folders in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `Vector3d.java`
    in the recently created sub-folder. The next lines declare the public `Vector3d`
    concrete class as a member of the `com.renderer.math` package. We will use the
    `Vector3d` class instead of working with separate values for `x`, `y`, and `z`.
    The `package` keyword followed by the package name indicates the package in which
    the class will be included.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（在Windows中为`Renderer\src`）中创建`com/renderer/math`（在Windows中为`com\renderer\math`）文件夹。将以下行添加到名为`Vector3d.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Vector3d`具体类，作为`com.renderer.math`包的成员。我们将使用`Vector3d`类，而不是使用`x`、`y`和`z`的单独值。`package`关键字后面跟着包名，表示类将被包含在其中的包。
- en: The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.math/com/renderer/math`
    sub-folder, in the `Vector3d.java` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.math/com/renderer/math`子文件夹中，名为`Vector3d.java`。
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now create the `com.renderer.sceneelements` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.sceneelements`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements` sub-folder,
    in the `module-info.java` file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（在Windows中为`Renderer\src`）中创建`com.renderer.sceneelements`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.sceneelements`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements`子文件夹中，名为`module-info.java`。
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `module` keyword followed by the module name, `com.renderer.sceneelements`
    begins the module declaration. The lines included within the curly braces specify
    the module body. The `requires` keyword followed by a module name, `com.renderer.math`,
    indicates that this module requires the types exported in the previously declared
    `com.renderer.math` module. The `exports` keyword followed by the package name,
    `com.renderer.sceneelements`, indicates that this module exports all the public
    types declared within the `com.renderer.sceneelements` package.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`module`关键字后面跟着模块名`com.renderer.sceneelements`开始模块声明。花括号内包含的行指定了模块主体。`requires`关键字后面跟着模块名`com.renderer.math`，表示该模块需要先前声明的`com.renderer.math`模块中导出的类型。`exports`关键字后面跟着包名`com.renderer.sceneelements`，表示该模块导出`com.renderer.sceneelements`包中声明的所有公共类型。'
- en: Create the `com/renderer/sceneelements` (`com\renderer\sceneelements` in Windows)
    folders in `Renderer/src` (`Renderer\src` in Windows). Add the following lines
    to a file named `Rendereable.java` in the recently created sub-folder. The next
    lines declare the public `Rendereable` interface as a member of the `com.renderer.sceneelements`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneeelements/com/renderer/sceneelements`
    sub-folder, in the `Rendereable.java` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（在Windows中为`Renderer\src`）中创建`com/renderer/sceneelements`（在Windows中为`com\renderer\sceneelements`）文件夹。将以下行添加到名为`Rendereable.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Rendereable`接口，作为`com.renderer.sceneelements`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneeelements/com/renderer/sceneelements`子文件夹中，名为`Rendereable.java`。
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add the following lines to a file named `SceneElement.java` in the recently
    created sub-folder. The next lines declare the public `SceneElement` abstract
    class as a member of the `com.renderer.sceneelements` package. The code file for
    the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements/com/renderer/sceneelements`
    sub-folder, in the `SceneElement.java` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到名为`SceneElement.java`的文件中。接下来的行声明了公共`SceneElement`抽象类，作为`com.renderer.sceneelements`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.sceneelements/com/renderer/sceneelements`子文件夹中，名为`SceneElement.java`。
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SceneElement` abstract class implements the previously defined `Rendereable`
    interface. The class represents a 3D element that is part of a scene and has a
    location specified with a `Vector3d`. The class is the base class for all the
    scene elements that require a location in the 3D space.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneElement`抽象类实现了先前定义的`Rendereable`接口。该类表示场景中的3D元素，并具有使用`Vector3d`指定的位置。该类是所有需要在3D空间中具有位置的场景元素的基类。'
- en: Now create the `com.renderer.lights` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.lights`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights` sub-folder,
    in the `module-info.java` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（在Windows中为`Renderer\src`）中创建`com.renderer.lights`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.lights`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights`子文件夹中，名为`module-info.java`。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous lines declare the `com.renderer.lights` module and specifies that
    the module requires two modules: `com.renderer.math` and `com.renderer.sceneelements`.
    The `exports` keyword followed by the package name, `com.renderer.lights`, indicates
    that this module exports all the public types declared within the `com.renderer.lights`
    package.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer.lights`模块，并指定该模块需要两个模块：`com.renderer.math`和`com.renderer.sceneelements`。`exports`关键字后面跟着包名`com.renderer.lights`，表示该模块导出`com.renderer.lights`包中声明的所有公共类型。
- en: Create the `com/renderer/lights` (`com\renderer\lights` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Light.java` in the recently created sub-folder. The next lines declare
    the public `Light` abstract class as a member of the `com.renderer.lights` package.
    The class inherits from the `SceneElement` class and declares an abstract `getPropertiesDescription`
    method that must return a `String` with the description for all the properties
    that the light has. The concrete classes that inherit from the `Light` class will
    be responsible for providing the implementation for this method. The code file
    for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`
    sub-folder, in the `Light.java` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`中创建`com/renderer/lights`（在Windows中为`com\renderer\lights`）文件夹。将以下行添加到名为`Light.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Light`抽象类作为`com.renderer.lights`包的成员。该类继承自`SceneElement`类，并声明了一个必须返回`String`类型的描述所有灯光属性的抽象`getPropertiesDescription`方法。从`Light`类继承的具体类将负责为此方法提供实现。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`子文件夹中的`Light.java`文件中。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add the following lines to a file named `DirectionalLight.java` in the recently
    created sub-folder. The next lines declare the public `DirectionalLight` concrete
    class as a member of the `com.renderer.lights` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`
    sub-folder, in the `DirectionalLight.java` file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到名为`DirectionalLight.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`DirectionalLight`具体类作为`com.renderer.lights`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.lights/com/renderer/lights`子文件夹中的`DirectionalLight.java`文件中。
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `DirectionalLight` concrete class inherits from the previously defined `Light`
    abstract class. The `DirectionalLight` class represents a directional light, and
    provides an implementation for both the `render` and `getPropertiesDescription`
    methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectionalLight`具体类继承自先前定义的`Light`抽象类。`DirectionalLight`类表示定向光，并为`render`和`getPropertiesDescription`方法提供实现。'
- en: Now create the `com.renderer.cameras` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.cameras`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras` sub-folder,
    in the `module-info.java` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`中创建`com.renderer.cameras`目录（在Windows中为`Renderer\src`）。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.cameras`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras`子文件夹中的`module-info.java`文件中。
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous lines declare the `com.renderer.cameras` module and specifies
    that the module requires two modules: `com.renderer.math` and `com.renderer.sceneelements`.
    The `exports` keyword followed by the package name, `com.renderer.cameras`, indicates
    that this module exports all the public types declared within the `com.renderer.cameras`
    package.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer.cameras`模块，并指定该模块需要两个模块：`com.renderer.math`和`com.renderer.sceneelements`。`exports`关键字后跟包名`com.renderer.cameras`，表示该模块导出`com.renderer.cameras`包中声明的所有公共类型。
- en: Create the `com/renderer/cameras` (`com\renderer\cameras` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Camera.java` in the recently created sub-folder. The next lines declare
    the public `Camera` abstract class as a member of the `com.renderer.cameras` package.
    The class inherits from the `SceneElement` class. The class represents a 3D camera.
    It is the base class for all cameras. In this case, the class declaration is empty,
    and we only declare it because we know that there will be many types of cameras.
    In addition, we want to be able to generalize the common requirements for all
    types of cameras in the future, as we did for the lights. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`
    sub-folder, in the `Camera.java` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`中创建`com/renderer/cameras`（在Windows中为`com\renderer\cameras`）文件夹。将以下行添加到名为`Camera.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Camera`抽象类作为`com.renderer.cameras`包的成员。该类继承自`SceneElement`类。该类表示3D相机。这是所有相机的基类。在这种情况下，类声明为空，我们只声明它是因为我们知道将会有许多类型的相机。此外，我们希望能够在将来概括所有类型相机的共同要求，就像我们为灯光做的那样。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`子文件夹中的`Camera.java`文件中。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Add the following lines to a file named `PerspectiveCamera.java` in the recently
    created sub-folder. The next lines declare the public `PerspectiveCamera` concrete
    class as a member of the `com.renderer.cameras` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`
    sub-folder, in the `PerspectiveCamera.java` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到名为`PerspectiveCamera.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`PerspectiveCamera`具体类作为`com.renderer.cameras`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.cameras/com/renderer/cameras`子文件夹中的`PerspectiveCamera.java`文件中。
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `PerspectiveCamera` concrete class inherits from the previously defined
    `Camera` abstract class. The `PerspectiveCamera` class represents a perspective
    camera with many getter and setter methods for the camera's properties. The class
    provides an implementation for the `render` method that displays all the details
    for the created camera and the values for its different properties.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerspectiveCamera`具体类继承自先前定义的`Camera`抽象类。`PerspectiveCamera`类表示具有许多获取器和设置器方法的透视相机的实现。该类为`render`方法提供了一个显示所创建相机的所有细节和其不同属性值的实现。'
- en: Now create the `com.renderer.shapes` directory in `Renderer/src` (`Renderer\src`
    in Windows). Add the following lines to a file named `module-info.java` in the
    recently created sub-folder. The next lines compose the module descriptor for
    a module named `com.renderer.shapes`. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes` sub-folder,
    in the `module-info.java` file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（Windows中为`Renderer\src`）中创建`com.renderer.shapes`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.shapes`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes`子文件夹中的`module-info.java`文件中。
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The previous lines declare the `com.renderer.shapes` module and specifies that
    the module requires four modules: `com.renderer.math`, `com.renderer.sceneelements`,
    `com.renderer.lights`, and `com.renderer.cameras`. The `exports` keyword followed
    by the package name, `com.renderer.shapes`, indicates that this module exports
    all the public types declared within the `com.renderer.shapes` package.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer.shapes`模块，并指定该模块需要四个模块：`com.renderer.math`、`com.renderer.sceneelements`、`com.renderer.lights`和`com.renderer.cameras`。`exports`关键字后跟包名`com.renderer.shapes`，表示该模块导出了`com.renderer.shapes`包中声明的所有公共类型。
- en: Create the `com/renderer/shapes` (`com\renderer\shapes` in Windows) folders
    in `Renderer/src` (`Renderer\src` in Windows). Add the following lines to a file
    named `Shape.java` in the recently created sub-folder. The next lines declare
    the public `Shape` abstract class as a member of the `com.renderer.shapes` package.
    The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes/com/renderer/shapes`
    sub-folder, in the `Shape.java` file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（Windows中为`Renderer\src`）中创建`com/renderer/shapes`（Windows中为`com\renderer\shapes`）文件夹。将以下行添加到名为`Shape.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Shape`抽象类作为`com.renderer.shapes`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes/com/renderer/shapes`子文件夹中的`Shape.java`文件中。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Shape` class inherits from the `SceneElement` class. The class represents
    a 3D shape and is the base class for all the 3D shapes. The class defines the
    following methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`类继承自`SceneElement`类。该类表示一个3D形状，是所有3D形状的基类。该类定义了以下方法：'
- en: '`setActiveCamera`: This public method receives a `Camera` instance and saves
    it as the active camera.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setActiveCamera`：这个公共方法接收一个`Camera`实例并将其保存为活动摄像机。'
- en: '`setLights`: This public method receives a `List<Light>` and saves it as the
    list of lights that must be considered to render the shape.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLights`：这个公共方法接收一个`List<Light>`并将其保存为必须考虑以渲染形状的灯光列表。'
- en: '`isValidForRender`: This protected method returns a `boolean` value indicating
    whether the shape has an active camera and at least one light. Otherwise, the
    shape is not valid for being rendered.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isValidForRender`：这个受保护的方法返回一个`boolean`值，指示形状是否具有活动摄像机和至少一个灯光。否则，该形状不适合被渲染。'
- en: '`generateConsideringLights`: This protected method returns a `String` with
    the lights that are being considered to render the shape, with their locations
    and their properties descriptions.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generateConsideringLights`：这个受保护的方法返回一个带有正在考虑渲染形状的灯光、它们的位置和属性描述的`String`。'
- en: Each subclass of the `Shape` class that will represent a specific 3D shape will
    provide an implementation for the `render` method. We will code these subclasses
    in two additional modules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`类的每个子类，代表特定的3D形状，将为`render`方法提供实现。我们将在另外两个模块中编写这些子类。'
- en: Now create the `com.renderer.shapes.curvededges` directory in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `module-info.java`
    in the recently created sub-folder. The next lines compose the module descriptor
    for a module named `com.renderer.curvededges`. The code file for the sample is
    included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.curvededges`
    sub-folder, in the `module-info.java` file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（Windows中为`Renderer\src`）中创建`com.renderer.shapes.curvededges`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.curvededges`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.curvededges`子文件夹中的`module-info.java`文件中。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous lines declare the `com.renderer.shapes` module and specifies that
    the module requires three modules: `com.renderer.math`, `com.renderer.lights`,
    and `com.renderer.shapes`. The `exports` keyword followed by the package name,
    `com.renderer.shapes.curvededges`, indicates that this module exports all the
    public types declared within the `com.renderer.shapes.curvededges` package.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer.shapes`模块，并指定该模块需要三个模块：`com.renderer.math`、`com.renderer.lights`和`com.renderer.shapes`。`exports`关键字后跟包名`com.renderer.shapes.curvededges`，表示该模块导出了`com.renderer.shapes.curvededges`包中声明的所有公共类型。
- en: Create the `com/renderer/shapes/curvededges` (`com\renderer\shapes\curvededges`
    in Windows) folders in `Renderer/src` (`Renderer\src` in Windows). Add the following
    lines to a file named `Sphere.java` in the recently created sub-folder. The next
    lines declare the public `Sphere` concrete class as a member of the `com.renderer.shapes.curvededges`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.curvededges/com/renderer/shapes/curvededges`
    sub-folder, in the `Sphere.java` file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（Windows中为`Renderer\src`）中创建`com/renderer/shapes/curvededges`（Windows中为`com\renderer\shapes\curvededges`）文件夹。将以下行添加到名为`Sphere.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Sphere`具体类作为`com.renderer.shapes.curvededges`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.curvededges/com/renderer/shapes/curvededges`子文件夹中的`Sphere.java`文件中。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Sphere` class inherits from the `Shape` class and requires a radius value
    in the constructor in addition to the `Vector3d` instance that specifies the location
    for the sphere. The class provides an implementation for the `render` method that
    checks the value returned by the `isValidForRender` method. If the method returns
    `true`, the sphere is valid for being rendered, and the code builds a message
    with the sphere radius, its location, and the lights that are being considered
    when rendering the sphere. The code calls the `generateConsideringLights` method
    to build the message.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sphere`类继承自`Shape`类，并在构造函数中需要一个半径值，除了指定球体位置的`Vector3d`实例。该类提供了`render`方法的实现，该方法检查`isValidForRender`方法返回的值。如果该方法返回`true`，则球体可以被渲染，并且代码将使用球体半径、位置以及在渲染球体时考虑的灯光构建消息。代码调用`generateConsideringLights`方法来构建消息。'
- en: Now create the `com.renderer.shapes.polyhedrons` directory in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `module-info.java`
    in the recently created sub-folder. The next lines compose the module descriptor
    for a module named `com.renderer.polyhedrons`. The code file for the sample is
    included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.polyhedrons`
    sub-folder, in the `module-info.java` file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（Windows中为`Renderer\src`）中创建`com.renderer.shapes.polyhedrons`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer.polyhedrons`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.polyhedrons`子文件夹中的`module-info.java`文件中。
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous lines declare the `com.renderer.polyhedrons` module and specifies
    that the module requires three modules: `com.renderer.math`, `com.renderer.lights`,
    and `com.renderer.shapes`. The `exports` keyword followed by the package name,
    `com.renderer.shapes.polyhedrons`, indicates that this module exports all the
    public types declared within the `com.renderer.shapes.polyhedrons` package.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer.polyhedrons`模块，并指定该模块需要三个模块：`com.renderer.math`、`com.renderer.lights`和`com.renderer.shapes`。`exports`关键字后跟包名`com.renderer.shapes.polyhedrons`，表示该模块导出`com.renderer.shapes.polyhedrons`包中声明的所有公共类型。
- en: Create the `com/renderer/shapes/polyhedrons` (`com\renderer\shapes\polyhedrons`
    in Windows) folders in `Renderer/src` (`Renderer\src` in Windows). Add the following
    lines to a file named `Cube.java` in the recently created sub-folder. The next
    lines declare the public `Cube` concrete class as a member of the `com.renderer.shapes.polyhedrons`
    package. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.polyhedrons/com/renderer/shapes/polyhedrons`
    sub-folder, in the `Cube.java` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（Windows中为`Renderer\src`）中创建`com/renderer/shapes/polyhedrons`（Windows中为`com\renderer\shapes\polyhedrons`）文件夹。将以下行添加到名为`Cube.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Cube`具体类作为`com.renderer.shapes.polyhedrons`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer.shapes.polyhedrons/com/renderer/shapes/polyhedrons`子文件夹中的`Cube.java`文件中。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Cube` class inherits from the `Shape` class and requires an `edgeLength`
    value in the constructor in addition to the `Vector3d` that specifies the location
    for the cube. The class provides an implementation for the `render` method that
    checks the value returned by the `isValidForRender` method. If the method returns
    `true`, the cube is valid for being rendered and the code builds a message with
    the cube's edge length, its location, and the lights that are being considered
    when rendering the cube. The code calls the `generateConsideringLights` method
    to build the message.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cube`类继承自`Shape`类，并在构造函数中需要一个`edgeLength`值，除了指定立方体位置的`Vector3d`。该类提供了`render`方法的实现，该方法检查`isValidForRender`方法返回的值。如果该方法返回`true`，则立方体可以被渲染，并且代码将使用立方体的边长、位置以及在渲染立方体时考虑的灯光构建消息。代码调用`generateConsideringLights`方法来构建消息。'
- en: Now create the `com.renderer` directory in `Renderer/src` (`Renderer\src` in
    Windows). Add the following lines to a file named `module-info.java` in the recently
    created sub-folder. The next lines compose the module descriptor for a module
    named `com.renderer`. The code file for the sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer`
    sub-folder, in the `module-info.java` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Renderer/src`（Windows中为`Renderer\src`）中创建`com.renderer`目录。将以下行添加到名为`module-info.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行组成了名为`com.renderer`的模块描述符。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer`子文件夹中的`module-info.java`文件中。
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous lines declare the `com.renderer` module and specifies that the
    module requires six modules: `com.renderer.math`, `com.renderer.cameras`, `com.renderer.lights`,
    `com.renderer.shapes`, `com.renderer.shapes.curvededges`, and `com.renderer.shapes.polyhedrons`.
    The `exports` keyword followed by the package name, `com.renderer`, indicates
    that this module exports all the public types declared within the `com.renderer`
    package.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`com.renderer`模块，并指定该模块需要六个模块：`com.renderer.math`、`com.renderer.cameras`、`com.renderer.lights`、`com.renderer.shapes`、`com.renderer.shapes.curvededges`和`com.renderer.shapes.polyhedrons`。`exports`关键字后跟包名`com.renderer`，表示该模块导出`com.renderer`包中声明的所有公共类型。
- en: Create the `com/renderer` (`com\renderer` in Windows) folders in `Renderer/src`
    (`Renderer\src` in Windows). Add the following lines to a file named `Scene.java`
    in the recently created sub-folder. The next lines declare the public `Scene`
    concrete class as a member of the `com.renderer` package. The code file for the
    sample is included in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer`
    sub-folder, in the `Scene.java` file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer/src`（Windows中为`Renderer\src`）中创建`com/renderer`（Windows中为`com\renderer`）文件夹。将以下行添加到名为`Scene.java`的文件中，该文件位于最近创建的子文件夹中。接下来的行声明了公共`Scene`具体类作为`com.renderer`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer`子文件夹中的`Scene.java`文件中。
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Scene` class represents the scene to be rendered. The class declares an
    `activateCamera` protected field that holds a `Camera` instance. The `lights`
    protected field is a `List` of `Light` instances, and the `shapes` protected field
    is a `List` of `Shape` instances that compose the scene. The `addLight` method
    adds the `Light` instance received as an argument to the `List<Light>lights`.
    The `addShape` method adds the `Shape` instance received as an argument to the
    `List<Shape> shapes`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`类表示要渲染的场景。该类声明了一个`activateCamera`受保护字段，其中包含一个`Camera`实例。`lights`受保护字段是`Light`实例的`List`，`shapes`受保护字段是组成场景的`Shape`实例的`List`。`addLight`方法将接收到的`Light`实例添加到`List<Light>lights`中。`addShape`方法将接收到的`Shape`实例添加到`List<Shape>
    shapes`中。'
- en: 'The `render` method calls the render method for the active camera and all the
    lights. Then, the code performs the following actions for each shape: sets its
    active camera, sets the lights, and calls the `render` method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法调用活动摄像机和所有灯光的渲染方法。然后，代码对每个形状执行以下操作：设置其活动摄像机，设置灯光，并调用`render`方法。'
- en: Finally, add the following lines to a file named `Example01.java` in the recently
    created sub-folder. The next lines declare the public `Example01` concrete class
    as a member of the `com.renderer` package. The code file for the sample is included
    in the `java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer` sub-folder,
    in the `Example01.java` file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下行添加到名为`Example01.java`的文件中。接下来的行声明了公共`Example01`具体类作为`com.renderer`包的成员。示例的代码文件包含在`java_9_oop_chapter_13_01/Renderer/src/com.renderer/com/renderer`子文件夹中的`Example01.java`文件中。
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Example01` class is the main class for our test application. The class
    just declares a `static` method named `main` that receives an array of `String`
    named `args` as an argument. Java will call this method when we execute the application
    and will pass the arguments in the `args` parameter. In this case, the code in
    the `main` method doesn't take into account any specified argument.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example01`类是我们测试应用程序的主类。该类只声明了一个名为`main`的`static`方法，该方法接收一个名为`args`的`String`数组作为参数。当我们执行应用程序时，Java将调用此方法，并将参数传递给`args`参数。在这种情况下，`main`方法中的代码不考虑任何指定的参数。'
- en: The main method creates a `PerspectiveCamera` instance with the necessary parameters,
    and then creates a `Shape` and a `Cube` named `shape` and `cube`. Then, the code
    creates a `DirectionalLight` instance named `light`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法创建一个具有必要参数的`PerspectiveCamera`实例，然后创建一个名为`shape`和`cube`的`Shape`和`Cube`。然后，代码创建一个名为`light`的`DirectionalLight`实例。
- en: The next line creates a `Scene` instance with `camera` as the value for the
    `activeCamera` argument. Then, the code calls the `scene.addShape` method twice
    with `sphere` and `cube` as arguments. Finally, the code calls `scene.addLight`
    with `light` as an argument and calls the `scene.render` method to display the
    messages generated by the simulated render process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行创建一个具有`camera`作为`activeCamera`参数值的`Scene`实例。然后，代码两次调用`scene.addShape`方法，参数分别为`sphere`和`cube`。最后，代码调用`scene.addLight`，参数为`light`，并调用`scene.render`方法来显示模拟渲染过程生成的消息。
- en: Compiling multiple modules with the Java 9 compiler
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java 9编译器编译多个模块
- en: Create a sub-folder named `mods` within the base directory named `Renderer`.
    This new sub-folder will replicate the directory structure that we created in
    the `Renderer/src` (`Renderer\src` in Windows) folder. We will run the Java compiler
    to generate a Java class file for each Java source file. A Java class file will
    contain Java bytecode that can be executed on the **Java Virtual Machine**, also
    known as the **JVM**. We will have a file with the `.class` extension for each
    Java source file with the `.java` extension, including the module descriptors.
    For example, after we successfully use the Java compiler to compile the `Renderer/src/com.renderer.math/com/renderer/math/Vector3d.java`
    source file, the compiler will generate a `Renderer/mods/com.renderer.math/com/renderer/math/Vector3d.class`
    file with Java bytecode (known as a Java class file). In Windows, we must use
    a backslash (`\`) as the path separator instead of the slash (`/`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`Renderer`的基本目录中创建一个名为`mods`的子文件夹。这个新的子文件夹将复制我们在`Renderer/src`（Windows中的`Renderer\src`）文件夹中创建的目录结构。我们将运行Java编译器为每个Java源文件生成一个Java类文件。Java类文件将包含可以在**Java虚拟机**上执行的Java字节码，也称为**JVM**。对于每个具有`.java`扩展名的Java源文件，包括模块描述符，我们将有一个具有`.class`扩展名的文件。例如，当我们成功使用Java编译器编译`Renderer/src/com.renderer.math/com/renderer/math/Vector3d.java`源文件时，编译器将生成一个`Renderer/mods/com.renderer.math/com/renderer/math/Vector3d.class`文件，其中包含Java字节码（称为Java类文件）。在Windows中，我们必须使用反斜杠（`\`）作为路径分隔符，而不是斜杠（`/`）。
- en: Now, open a Terminal window on macOS or Linux, or Command Prompt in Windows,
    and go to the `Renderer` folder. Make sure the `javac` command is included in
    the path, and that it is the Java compiler for Java 9 and not for previous Java
    versions that aren't compatible with the modules introduced in Java 9.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在macOS或Linux上打开一个终端窗口，或者在Windows上打开命令提示符，并转到`Renderer`文件夹。确保`javac`命令包含在路径中，并且它是Java
    9的Java编译器，而不是之前版本的Java编译器，这些版本不兼容Java 9中引入的模块。
- en: In macOS or Linux, run the following command to compile all the modules we have
    recently created and place the generated Java class files in a directory structure
    within the `mods` folder. The `-d` option specifies where to place the generated
    class files and the `--module-source-path` option indicates where to find the
    input source files for multiple modules.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中，运行以下命令来编译我们最近创建的所有模块，并将生成的Java类文件放在`mods`文件夹中的目录结构中。`-d`选项指定了生成类文件的位置，`--module-source-path`选项指示了多个模块的输入源文件的位置。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Windows, run the following command to achieve the same goal:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，运行以下命令以实现相同的目标：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The following directory structure shows the final contents we will have within
    the `Renderer/mods` (`Renderer\mods` in Windows) directory. The Java class files
    generated by the Java compiler are highlighted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下目录结构显示了我们将在`Renderer/mods`（Windows中的`Renderer\mods`）目录中拥有的最终内容。Java编译器生成的Java类文件已经高亮显示。
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run modularized code with Java 9
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 9 运行模块化代码
- en: Finally, we can use the `java` command to launch the Java application. Go back
    to the Terminal window on macOS or Linux, or a Command Prompt in Windows, and
    make sure you are in the `Renderer` folder. Make sure the `java` command is included
    in the path, and that it is the `java` command for Java 9 and not for previous
    Java versions that aren't compatible with the modules introduced in Java 9.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `java` 命令启动 Java 应用程序。返回 macOS 或 Linux 上的终端窗口，或者 Windows 上的命令提示符，并确保你在
    `Renderer` 文件夹中。确保 `java` 命令包含在路径中，并且它是 Java 9 的 `java` 命令，而不是不兼容 Java 9 中引入的模块的先前
    Java 版本的 `java` 命令。
- en: In macOS, Linux or Windows, run the following command to load the compiled modules,
    resolve the `com.renderer` module, and run the `main` static method for the `Example01`
    class declared in the `com.renderer` package. The `--module-path` option specifies
    the directory in which the modules can be found. In this case, we just specify
    the `mods` folder. However, we may include many directories separated by a semicolon
    (`;`). The `-m` option specifies the initial module name to resolve followed by
    a slash (`/`) and the name of the main class to execute.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS、Linux 或 Windows 中，运行以下命令来加载已编译的模块，解析 `com.renderer` 模块，并运行 `com.renderer`
    包中声明的 `Example01` 类的 `main` 静态方法。`--module-path` 选项指定可以找到模块的目录。在这种情况下，我们只指定 `mods`
    文件夹。但是，我们可以包括许多由分号 (`;`) 分隔的目录。`-m` 选项指定要解析的初始模块名称，后面跟着一个斜杠 (`/`) 和要执行的主类的名称。
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The following lines show the generated output after executing the previous command
    that runs the `main` static method for the `Example01` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行先前命令后运行 `Example01` 类的 `main` 静态方法后生成的输出。
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In previous Java versions we could aggregate many Java class files, and their
    associated metadata and resources into a compressed file with the `.jar` extension,
    known as a **JAR** (**Java Archive**) file. We can also package modules as modularJARs
    that include the `module-info.class` file within the compressed file in the top-level
    folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的 Java 版本中，我们可以将许多 Java 类文件及其关联的元数据和资源聚合到一个名为 **JAR**（**Java 存档**）文件的压缩文件中。我们还可以将模块打包为包含
    `module-info.class` 文件的模块化 JAR，该文件在顶层文件夹中的压缩文件中。
- en: In addition, we can use the Java linking tool (`jlink`) to create a customized
    runtime image with only the modules that are required for our application. This
    way, we can take advantage of whole-program optimizations and generate a custom
    runtime image that will run on top of the JVM.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 Java 链接工具 (`jlink`) 创建一个定制的运行时映像，其中只包括我们应用程序所需的模块。这样，我们可以利用整体程序优化，并生成一个在
    JVM 之上运行的自定义运行时映像。
- en: Test your knowledge
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'By default, a module requires:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，模块需要：
- en: The `java.base` module.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.base` 模块。'
- en: The `java.lang` module.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.lang` 模块。'
- en: The `java.util` module.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.util` 模块。'
- en: 'There is a convention that specifies that the source code for a Java 9 module
    must be located in a directory with:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个约定规定，Java 9 模块的源代码必须位于一个具有以下内容的目录中：
- en: The same name as the main class exported by the module.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与模块导出的主类相同的名称。
- en: The same name as the module name.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与模块名称相同的名称。
- en: The same name as the main type exported by the module.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与模块导出的主类型相同的名称。
- en: 'Which of the following source code files is a module descriptor:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个源代码文件是模块描述符：
- en: '`module-def.java`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module-def.java`'
- en: '`module-info.java`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module-info.java`'
- en: '`module-data.java`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module-data.java`'
- en: 'Which of the following keywords must be followed by the module name in the
    module descriptor:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是模块描述符中必须跟随模块名称的关键字：
- en: '`name`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`module-name`'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module-name`'
- en: '`module`'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`module`'
- en: 'The `exports` keyword followed by a package name in the module descriptor indicates
    that the module exports:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块描述符中的 `exports` 关键字后跟包名表示模块导出：
- en: All the classes declared within the package.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包中声明的所有类。
- en: All the types declared within the package.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包中声明的所有类型。
- en: All the public types declared within the package.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包中声明的所有公共类型。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned to refactor existing code to take full advantage
    of object-oriented code with Java 9\. We have prepared the code for future requirements,
    reduce maintenance costs, and maximized code reuse.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了重构现有代码，充分利用 Java 9 的面向对象代码。我们已经为未来的需求准备好了代码，减少了维护成本，并最大程度地重用了代码。
- en: We learned to organize object-oriented code. We created many Java source files.
    We declared interfaces, abstract classes, and concrete classes in different Java
    source files. We took advantage of the new modularity features included in Java
    9 to create many modules that have dependencies on different modules and exported
    specific types. We learned to declare modules, compile them to Java bytecode,
    and launch an application outside of JShell.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了组织面向对象的代码。我们创建了许多 Java 源文件。我们在不同的 Java 源文件中声明了接口、抽象类和具体类。我们利用了 Java 9 中包含的新模块化特性，创建了许多具有对不同模块的依赖关系并导出特定类型的模块。我们学会了声明模块，将它们编译成
    Java 字节码，并在 JShell 之外启动应用程序。
- en: Now that you have learned to write object-oriented code in Java 9, you are ready
    to use everything you learned in real-life desktop applications, mobile apps,
    enterprise applications, Web Services, and web applications. These applications
    will maximize code reuse, simplify maintenance, and they will be always ready
    for future requirements. The fact that you can use JShell to easily prototype
    new interfaces and classes will boost your productivity as an object-oriented
    Java 9 developer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会在 Java 9 中编写面向对象的代码，你可以在真实的桌面应用程序、移动应用、企业应用程序、Web 服务和 Web 应用程序中使用你学到的一切。这些应用程序将最大程度地重用代码，简化维护，并且始终为未来的需求做好准备。你可以使用
    JShell 轻松地原型化新的接口和类，这将提高你作为面向对象的 Java 9 开发人员的生产力。
