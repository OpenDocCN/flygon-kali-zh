- en: '*Chapter 19*: Scene Performance Optimization'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第19章*：场景性能优化'
- en: Welcome to the third part of this book—I am glad you have reached this part
    as it means that you have almost completed a full game! In this chapter, we are
    going to discuss optimization techniques to review your game's performance and
    improve it, as having a good and constant framerate is vital to any game. Performance
    is a broad topic that requires a deep understanding of several Unity systems and
    could span several books. We are going to look at how to measure performance and
    explore the effects of our changes to systems to learn how they work through testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第三部分——我很高兴您已经到达这一部分，因为这意味着您几乎完成了一个完整的游戏！在本章中，我们将讨论优化技术，以审查游戏的性能并改进它，因为良好和稳定的帧率对于任何游戏都至关重要。性能是一个广泛的主题，需要对几个Unity系统有深入的了解，并且可能需要涵盖几本书。我们将研究如何衡量性能，并探索我们对系统的更改的影响，通过测试了解它们的工作原理。
- en: 'In this chapter, we will examine the following performance concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下性能概念：
- en: Optimizing graphics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化图形
- en: Optimizing processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化处理
- en: Optimizing memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化内存
- en: By the end of this chapter, you will be able to gather performance data of the
    three main pieces of hardware that run your game—the GPU, CPU, and RAM. You will
    be able to analyze that data to detect possible performance issues and understand
    how to solve the most common ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够收集运行游戏的三个主要硬件部件的性能数据——GPU、CPU和RAM。您将能够分析这些数据，以检测可能的性能问题，并了解如何解决最常见的问题。
- en: Optimizing graphics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化图形
- en: The most common cause of performance issues is related to the misuse of assets,
    especially on the graphics side, due to not having enough knowledge of how Unity's
    graphic engines work. We are going to explore how a GPU works at a high level
    and how to improve its usage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题最常见的原因与资源的错误使用有关，特别是在图形方面，因为缺乏对Unity图形引擎工作方式的了解。我们将探讨GPU在高层次上的工作方式以及如何改进其使用。
- en: 'In this section, we will examine the following graphics optimization concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下图形优化概念：
- en: Introduction to graphic engines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形引擎简介
- en: Using Frame Debugger
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用帧调试器
- en: Using batching
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用批处理
- en: Other optimizations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他优化
- en: We will start by looking at a high-level overview of how graphics are rendered
    to better understand the performance data that we will gather later in Frame Debugger.
    Based on the debugger's results, we are going to identify the areas that we can
    apply batching to (which is a technique to combine the rendering process of several
    objects, thereby reducing its cost), along with other common optimizations to
    keep in mind.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先概述图形渲染的高级概述，以更好地理解我们稍后在帧调试器中收集的性能数据。根据调试器的结果，我们将确定可以应用批处理的领域（这是一种将多个对象的渲染过程合并在一起，从而降低成本的技术），以及其他常见的优化要点。
- en: Introduction to graphic engines
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形引擎简介
- en: Nowadays, every gaming device, whether it is a computer, a mobile device, or
    a console, has a video card—a set of hardware that specializes in graphics processing.
    It differs from a CPU in a subtle but important way. Graphics processing involves
    the processing of thousands of mesh vertices and the rendering of millions of
    pixels, so the GPU is designed to run short programs for a massive length of time,
    while the CPU can handle programs of any length but with limited parallelization
    capabilities. The reason for having those processing units is so that our program
    can use each one when needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现今，无论是计算机、移动设备还是游戏机，每个游戏设备都有一个视频卡——一组专门用于图形处理的硬件。它与CPU有微妙但重要的区别。图形处理涉及处理成千上万的网格顶点和渲染数百万像素，因此GPU被设计为长时间运行短程序，而CPU可以处理任何长度的程序，但并行化能力有限。拥有这些处理单元的原因是，我们的程序可以在需要时使用每一个。
- en: The problem here is that graphics don't just rely on the GPU. The CPU is also
    involved in the process, making calculations and issuing commands to the GPU,
    so they must work together. For that to happen, both processing units need to
    communicate, and because they are (usually) physically separated, they need another
    piece of hardware to allow this—a bus, the most common type being the **Peripheral
    Component Interconnect Express** (**PCI Express**) bus.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于图形不仅依赖于GPU。CPU也参与其中，进行计算并向GPU发出命令，因此它们必须共同工作。为了实现这一点，两个处理单元需要进行通信，因为它们（通常）是物理上分开的，它们需要另一种硬件来实现这一点——总线，最常见的类型是**外围组件互联**（**PCI
    Express**）总线。
- en: 'PCI Express is a type of connection that allows massive amounts of data to
    be moved between the GPU and CPU, but the problem is that even if it''s very fast,
    the communication time can be noticeable if you issue a lot of commands between
    both units. So, the key concept here is that graphics performance is improved
    mainly by reducing the communications between the GPU and CPU:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express是一种连接类型，允许大量数据在GPU和CPU之间传输，但问题在于，即使速度非常快，如果在两个单元之间发出大量命令，通信时间也会很明显。因此，关键概念在于，图形性能主要通过减少GPU和CPU之间的通信来改善：
- en: '![Figure 19.1 – CPU/GPU communication through a PCI Express bus'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.1 – 通过PCI Express总线进行CPU/GPU通信'
- en: '](img/Figure_19.01_B14199.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.01_B14199.jpg)'
- en: Figure 19.1 – CPU/GPU communication through a PCI Express bus
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1 – 通过PCI Express总线进行CPU/GPU通信
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Nowadays, new hardware architecture allows the CPU and GPU to coexist in the
    same chipset, reducing its communication time and even sharing memory. Sadly,
    that architecture doesn't allow the necessary processing power needed for video
    games. It is likely that we will only see it applied to high-end gaming, but not
    in the near future, or even ever.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现今，新的硬件架构允许CPU和GPU共存于同一芯片组中，减少了它们的通信时间，甚至共享内存。遗憾的是，该架构不允许视频游戏所需的必要处理能力。很可能我们只会在高端游戏中看到它的应用，但在不久的将来甚至永远也不会。
- en: The basic algorithm of a graphics engine is to determine which objects are visible
    using culling algorithms, sorting and grouping them according to their similarities,
    and then issuing drawing commands to the GPU to render those groups of objects,
    sometimes more than once (as in [*Chapter 8*](B14199_08_Final_SK_ePub.xhtml#_idTextAnchor122)*,
    Lighting Using Universal Render Pipeline*). Here, the main form of communication
    are those drawing commands, usually called **draw calls**, and our main task when
    optimizing graphics is to reduce them as much as we can. The problem is that there
    are several sources of draw calls that need to be considered, such as the lighting,
    and the scale of objects to see whether they are static or not. Studying every
    single one of them will take a long time, and even so, new versions of Unity can
    introduce new graphic features with their own draw calls. Instead, we will explore
    a way to discover these draw calls using Frame Debugger.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图形引擎的基本算法是使用裁剪算法确定哪些对象是可见的，根据它们的相似性对它们进行排序和分组，然后向GPU发出绘制命令以渲染这些对象组，有时会多次（如[*第8章*](B14199_08_Final_SK_ePub.xhtml#_idTextAnchor122)*，使用通用渲染管线进行照明*）。在这里，主要的通信形式是那些绘制命令，通常称为**绘制调用**，我们在优化图形时的主要任务是尽量减少它们。问题在于有几个绘制调用的来源需要考虑，例如照明和对象的比例，以查看它们是否是静态的。研究它们中的每一个将需要很长时间，即使这样，Unity的新版本也可能引入具有自己绘制调用的新图形功能。相反，我们将探索一种使用帧调试器发现这些绘制调用的方法。
- en: Using Frame Debugger
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用帧调试器
- en: '**Frame Debugger** is a tool that allows us to see a list of all the drawing
    commands or draw calls that the Unity rendering engine sends to the GPU. It not
    only lists them but also provides information about each draw call, including
    the data needed to detect optimization opportunities. By using **Frame Debugger**,
    we can see how our changes modify the number of draw calls, giving us immediate
    feedback on our efforts.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧调试器**是一个工具，允许我们查看Unity渲染引擎发送到GPU的所有绘制命令或绘制调用的列表。它不仅列出它们，还提供有关每个绘制调用的信息，包括检测优化机会所需的数据。通过使用**帧调试器**，我们可以看到我们的更改如何修改绘制调用的数量，从而使我们对我们的努力得到即时反馈。'
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that reducing draw calls is sometimes not enough to improve performance,
    as each draw call can have different processing times; but usually, that difference
    is not big enough to consider. Also, in certain special rendering techniques,
    such as ray tracing or ray marching, a single draw call can drain all of our GPU
    power. This won't be the case in our game, so we won't take that into account
    right now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，减少绘制调用有时不足以提高性能，因为每个绘制调用的处理时间可能不同；但通常，这种差异不足以考虑。此外，在某些特殊的渲染技术中，例如光线追踪或光线行军，单个绘制调用可能耗尽我们所有的GPU功率。这在我们的游戏中不会发生，所以我们现在不会考虑这一点。
- en: 'Let''s use Frame Debugger to analyze the rendering process of our game by doing
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用帧调试器通过以下方式分析我们游戏的渲染过程：
- en: Open Frame Debugger (**Window** | **Analysis** | **Frame Debugger**).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开帧调试器（**窗口** | **分析** | **帧调试器**）。
- en: Play the game and if you want to analyze the performance, click the **Enable**
    button in the top-left corner of the window (press *Esc* to regain control of
    the mouse while playing):![Figure 19.2 – Enabling Frame Debugger
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放游戏，如果要分析性能，请单击窗口左上角的**启用**按钮（在播放时按*Esc*重新获得鼠标控制）：![图19.2 - 启用帧调试器
- en: '](img/Figure_19.02_B14199.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.02_B14199.jpg)'
- en: Figure 19.2 – Enabling Frame Debugger
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2 - 启用帧调试器
- en: Click on the **Game** tab to open the Game view.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**游戏**选项卡以打开游戏视图。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Sometimes, it is useful to have both the **Scene** and **Game** panels in sight,
    which you can accomplish by dragging one of them to the bottom of Unity to have
    them separated and visible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，同时看到**场景**和**游戏**面板是有用的，您可以通过将它们中的一个拖动到Unity底部来实现它们的分离和可见。
- en: Drag the slider to the right of the **Disable** button slowly from left to right
    to see how the scene is rendered. Each step is a draw call that is being executed
    in the CPU for that given game frame. You can also observe how the list in the
    left part of the window highlights the name of the executed draw call at that
    moment:![Figure 19.3 – Analyzing our frame's draw calls
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块从**禁用**按钮右侧缓慢向右拖动，以查看场景是如何渲染的。每一步都是在CPU中执行的给定游戏帧的绘制调用。您还可以观察窗口左侧的列表如何在那一刻突出显示执行的绘制调用的名称：![图19.3
    - 分析我们帧的绘制调用
- en: '](img/Figure_19.03_B14199.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.03_B14199.jpg)'
- en: Figure 19.3 – Analyzing our frame's draw calls
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3 - 分析我们帧的绘制调用
- en: Click on any draw call from the list and observe the details in the right part
    of the window.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击列表中的任何绘制调用，并观察窗口右侧的详细信息。
- en: 'Most of them can be confusing to you if you are not used to code engines or
    shaders, but you can see that some of them have a human-readable part called `Why
    this draw call can''t be batched with the previous one,` which tells you why two
    objects weren''t drawn together in a single draw call. We will examine those reasons
    later:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不习惯于编码引擎或着色器，大多数可能会让您感到困惑，但您可以看到其中一些具有称为`为什么这个绘制调用不能与上一个批处理在一起`的可读部分，它告诉您为什么两个对象没有一起绘制在单个绘制调用中。我们将稍后检查这些原因：
- en: '![Figure 19.4 – The batching break reasons in Frame Debugger'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.4 - 帧调试器中的批处理中断原因'
- en: '](img/Figure_19.04_B14199.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.04_B14199.jpg)'
- en: Figure 19.4 – The batching break reasons in Frame Debugger
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 - 帧调试器中的批处理中断原因
- en: With the window open in **Play** mode, disable the terrain and see how the amount
    of draw calls changes immediately. Sometimes, just turning objects on and off
    can be enough to detect what is causing performance issues. Also, try disabling
    postprocessing and other graphics-related objects, such as particles.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**播放**模式下打开窗口，禁用地形并查看绘制调用的数量如何立即改变。有时，只需打开和关闭对象就足以检测到导致性能问题的原因。还可以尝试禁用后期处理和其他与图形相关的对象，如粒子。
- en: Even if we are not fully aware of what each one of these draw calls came from,
    we can at least start by modifying the settings throughout Unity to see the impact
    of those changes. There's no better way of discovering how something as massive
    as Unity works than going through every toggle and seeing the impact of those
    changes through a measuring tool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不完全了解这些绘制调用来自何处，我们至少可以通过修改Unity中的设置来开始，以查看这些更改的影响。没有比通过测量工具逐个切换并查看这些更改的影响更好地了解Unity这样庞大的东西的方法。
- en: Now, let's discuss the basic techniques for reducing draw calls and see their
    effects in Frame Debugger.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论减少绘制调用的基本技术，并在Frame Debugger中看到它们的效果。
- en: Using batching
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用批处理
- en: We discussed several optimization techniques in previous chapters, with lighting
    being the most important one. If you measure the draw calls as you implement the
    techniques, you will notice the impact of those actions on the draw call count.
    However, in this section, we will focus on another graphics optimization technique
    known as batching. Batching is the process of grouping several objects to draw
    them together in a single draw call. You may be wondering why we can't just draw
    everything in a single draw call, and while that is technically possible, there
    is a set of conditions that need to be met in order to combine two objects, the
    usual case being combining materials.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中讨论了几种优化技术，其中照明是最重要的。如果你在实施这些技术时测量绘制调用，你会注意到这些行动对绘制调用数量的影响。然而，在本节中，我们将专注于另一种称为批处理的图形优化技术。批处理是将多个对象分组在单个绘制调用中一起绘制的过程。你可能会想为什么我们不能只在一个绘制调用中绘制所有东西，虽然从技术上讲这是可能的，但需要满足一组条件才能合并两个对象，通常情况下是合并材质。
- en: Remember that materials are assets that act as graphic profiles, from specifying
    a `SetPass` call needs to be called before issuing its draw call, which is another
    form of CPU/GPU communication used to set the `SetPass` call from the first object
    is reused by the second, and that opens the opportunity to batch the objects.
    If they share the same settings, Unity can combine the meshes into a single one
    in the CPU, and then send the combined mesh in a single draw call to the GPU.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，材质是作为图形配置文件的资产，需要在发出绘制调用之前指定一个`SetPass`调用，这是CPU/GPU通信的另一种形式，用于设置第一个对象的`SetPass`调用被第二个对象重用，并且这打开了批处理对象的机会。如果它们共享相同的设置，Unity可以在CPU中将网格组合成一个，并将组合的网格在单个绘制调用中发送到GPU。
- en: 'There are several ways to reduce the number of materials, such as removing
    duplicates, but the most effective way is through a concept called texture atlasing.
    This means merging textures from different objects into a single one. This way,
    several objects can use the same material due to the fact that the texture used
    there can be applied to several objects and an object that has its own texture
    requires its own material. Sadly, there''s no automatic system in Unity to combine
    the textures of three-dimensional objects, such as the **Texture Atlas** object
    we used in 2D. There are probably some systems in the Asset Store, but automatic
    systems can have several side effects. This work is usually done by an artist,
    so just keep this technique in mind when working with a dedicated 3D artist (or
    if you are your own artist):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种减少材质数量的方法，比如删除重复的材质，但最有效的方法是通过一个叫做纹理合并的概念。这意味着将不同对象的纹理合并成一个。这样，由于该纹理可以应用于多个对象，并且具有自己纹理的对象需要自己的材质。遗憾的是，Unity中没有自动系统来合并三维对象的纹理，就像我们在2D中使用的**纹理图集**对象。Asset
    Store中可能有一些系统，但自动系统可能会有一些副作用。这项工作通常由艺术家完成，所以在与专门的3D艺术家合作时（或者如果你自己是艺术家），请记住这个技术：
- en: '![Figure 19.5 – Pieces of different metallic objects'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.5 - 不同金属物体的碎片'
- en: '](img/Figure_19.05_B14199.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.05_B14199.jpg)'
- en: Figure 19.5 – Pieces of different metallic objects
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5 - 不同金属物体的碎片
- en: 'Let''s explore batching with Frame Debugger by doing the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式使用Frame Debugger来探索批处理：
- en: Search for the **Render Pipeline** asset that we currently want to use (**Edit**
    | **Project Settings** | **Graphics** | **Scriptable Render Settings**):![Figure
    19.6 – Scriptable Render Pipeline settings
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们当前想要使用的**渲染管线**资产（**编辑** | **项目设置** | **图形** | **可编程渲染设置**）：![图19.6 - 可编程渲染管线设置
- en: '](img/Figure_19.06_B14199.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.06_B14199.jpg)'
- en: Figure 19.6 – Scriptable Render Pipeline settings
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6 - 可编程渲染管线设置
- en: Uncheck **SRP Batcher** in the **Advanced** section. We will discuss this later:![Figure
    19.7 – Disabling SRP Batcher
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**高级**部分取消选择**SRP批处理器**。我们稍后会讨论这个：![图19.7 - 禁用SRP批处理器
- en: '](img/Figure_19.07_B14199.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.07_B14199.jpg)'
- en: Figure 19.7 – Disabling SRP Batcher
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.7 - 禁用SRP批处理器
- en: Create a new empty scene for testing (**File** | **New Scene**).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为测试创建一个新的空场景（**文件** | **新建场景**）。
- en: Create two materials of different colors.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两种不同颜色的材质。
- en: Create two cubes and put one material into the first and the other into the
    second.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个立方体，将一个材质放入第一个立方体，另一个放入第二个。
- en: Open Frame Debugger and click **Enable** to see the call list for the draw calls
    of our cubes:![Figure 19.8 – The draw calls for the cubes
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Frame Debugger并单击**启用**以查看我们立方体的绘制调用列表：![图19.8 - 立方体的绘制调用
- en: '](img/Figure_19.08_B14199.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.08_B14199.jpg)'
- en: Figure 19.8 – The draw calls for the cubes
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.8 - 立方体的绘制调用
- en: Select the second **Draw Mesh Cube** call and look at the batch-breaking reason.
    It should say that the objects have different materials.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第二个**绘制网格立方体**调用并查看批处理中断的原因。它应该说对象有不同的材质。
- en: Use one of the materials on both cubes and look at the list again. You will
    notice that now we just have one **Draw Mesh Cube** call. You might need to disable
    and enable Frame Debugger again for it to refresh properly.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个立方体上使用一个材质，然后再次查看列表。现在你会注意到我们只有一个**绘制网格立方体**调用。你可能需要再次禁用和启用Frame Debugger才能正确刷新。
- en: Now, I challenge you to try the same steps but create spheres instead of cubes.
    If you do that, you will probably notice that even with the same materials, the
    spheres are not batched! Here is where we need to introduce the concept of dynamic
    batching.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我挑战你尝试相同的步骤，但是创建球体而不是立方体。如果您这样做，您可能会注意到即使具有相同的材质，球体也没有被批处理！这就是我们需要介绍动态批处理的概念的地方。
- en: Remember that GameObjects have a **Static** checkbox, which serves to notify
    several Unity systems that the object won't move so that they can apply several
    optimizations. Objects that don't have this checkbox checked are considered dynamic.
    So far, the cubes and spheres we used for our tests have been dynamic, so Unity
    needed to combine them in every frame because they can move, and combining is
    not "free." Its cost is associated directly with the number of vertexes in the
    model. You can get the exact numbers and all the required considerations from
    the Unity manual, which will appear if you search **Unity Batching**. However,
    it is enough to say that if the number of vertexes of an object is big enough,
    that object won't be batched, and doing so would require more than issuing two
    draw calls. That's why our spheres weren't batched; a sphere has too many vertices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，游戏对象有一个**静态**复选框，用于通知几个Unity系统该对象不会移动，以便它们可以应用几个优化。没有勾选此复选框的对象被视为动态。到目前为止，我们用于测试的立方体和球体都是动态的，因此Unity需要在每帧中组合它们，因为它们可以移动，并且组合不是“免费”的。其成本与模型中的顶点数直接相关。您可以从Unity手册中获取确切的数字和所有必要的考虑，如果搜索**Unity
    Batching**，手册将显示出来。但是，可以说，如果对象的顶点数足够大，该对象将不会被批处理，这样做将需要发出两个以上的绘制调用。这就是为什么我们的球体没有被批处理；球体的顶点太多了。
- en: 'Now, things are different if we have static objects because they use a second
    batching system—the static batcher. The concept of this is the same. Merge objects
    to render them in one draw call, and again these objects need to share the same
    material. The main difference is that this batcher will batch more objects than
    the dynamic batcher because merging is done once at the time that the scene loads
    and is then saved in memory to use in the next frames, costing memory but saving
    lots of processing time each frame. You can use the same approach we used to test
    the dynamic batcher to test the static version just by checking the **Static**
    checkbox of the spheres this time and seeing the result in **Play** mode; in **Edition**
    mode (when it is not playing), the static batcher won''t work:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有静态对象，情况就不同了，因为它们使用第二个批处理系统——静态批处理器。这个概念是一样的。合并对象以在一个绘制调用中渲染它们，再次这些对象需要共享相同的材质。主要区别在于，这个批处理器将批处理比动态批处理器更多的对象，因为合并是在场景加载时进行一次，然后保存在内存中以在下一帧中使用，这会消耗内存，但每帧节省大量处理时间。您可以使用我们用来测试动态批处理器的相同方法来测试静态版本，只需勾选球体的**静态**复选框，然后在**播放**模式下查看结果；在**编辑**模式下（不播放时），静态批处理器不起作用。
- en: '![Figure 19.9 – A static sphere and its static batch'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.9-一个静态球体及其静态批处理'
- en: '](img/Figure_19.09_B14199.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.09_B14199.jpg)'
- en: Figure 19.9 – A static sphere and its static batch
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.9-一个静态球体及其静态批处理
- en: 'Before moving on, let''s discuss why we disabled SRP Batcher and how that changes
    what we just discussed. In its 2020 edition, Unity introduced URP (Universal Render
    Pipeline), a new Render Pipeline. Along with several improvements, one that is
    relevant right now is SRP Batcher, a new batcher that works on dynamic objects
    with no vertex or material limits (but with other limits). Instead of relying
    on sharing the same material with batch objects, SRP Batcher can have a batch
    of objects with materials that use the same Shader, meaning we can have, for example,
    100 objects with 100 different materials for each one, and they will be batched
    regardless of the number of vertexes, as long as the material uses the same Shader
    and Variant:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们讨论为什么我们禁用了SRP批处理器以及它如何改变我们刚刚讨论的内容。在其2020年版中，Unity推出了URP（通用渲染管线），一个新的渲染管线。除了几项改进之外，现在相关的是SRP批处理器，一个在动态对象上工作的新批处理器，没有顶点或材质限制（但有其他限制）。SRP批处理器不依赖于与批处理对象共享相同的材质，而是可以批处理使用相同着色器的材质的对象，这意味着我们可以有，例如，100个对象，每个对象有100种不同的材质，它们将被批处理，而不管顶点数多少，只要材质使用相同的着色器和变体：
- en: '![Figure 19.10 – GPU data persistence for materials, which allows SRP Batcher
    to exist'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.10-材质的GPU数据持久性，这使得SRP批处理器存在'
- en: '](img/Figure_19.10_B14199.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.10_B14199.jpg)'
- en: Figure 19.10 – GPU data persistence for materials, which allows SRP Batcher
    to exist
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.10-材质的GPU数据持久性，这使得SRP批处理器存在
- en: One Shader can have several versions or Variants, and the selected Variant is
    chosen based on the settings. We can have a Shader that doesn't use normal mapping
    and a Variant that doesn't calculate normals will be used, so that can affect
    SRP Batcher. So, there's basically no drawback to using SRP Batcher, so go ahead
    and turn it on again. Try creating lots of spheres with as many materials as you
    can and check the number of batches it will generate in Frame Debugger. Just consider
    that if you need to work on a project done in a pre-URP era, this won't be available,
    so you will need to know the proper batching strategy to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个着色器可以有几个版本或变体，所选的变体是根据设置选择的。我们可以有一个不使用法线贴图的着色器，将使用不计算法线的变体，这可能会影响SRP批处理。因此，使用SRP批处理基本上没有任何缺点，所以继续打开它。尝试创建尽可能多的具有尽可能多材质的球体，并在帧调试器中检查它将生成的批次数量。只需考虑，如果您需要处理在URP之前完成的项目，这将不可用，因此您需要了解适当的批处理策略。
- en: Other optimizations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他优化
- en: As mentioned before, there are lots of possible graphics optimizations, so let's
    discuss briefly the basic ones, starting with **Level of Detail** (**LOD**). LOD
    is the process of changing the mesh of an object based on its distance to the
    camera. This can reduce draw calls if you replace, for example, a house with several
    parts and pieces with a single combined mesh with reduced detail when the house
    is far. Another benefit of using LOD is that you reduce the cost of a draw call
    because of the reduction in the vertex count.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有许多可能的图形优化，因此让我们简要讨论基本的优化，从**细节级别**（**LOD**）开始。LOD是根据对象到相机的距离改变网格的过程。例如，当房子很远时，这可以减少绘制调用，如果您用一个减少了细节的组合网格替换了一个由多个部分和零件组成的房子。使用LOD的另一个好处是，由于顶点数减少，您减少了绘制调用的成本。
- en: 'To use this feature, do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，请执行以下操作：
- en: Create an empty object and parent the two versions of the model. You need to
    use models that have several versions with different levels of detail, but for
    now, we are just going to test this feature using a cube and a sphere:![Figure
    19.11 – A single object with two LOD meshes
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空对象并将模型的两个版本作为子对象。您需要使用具有不同细节级别的多个版本的模型，但现在，我们只是要使用一个立方体和一个球来测试这个功能：![图19.11
    – 一个带有两个LOD网格的单个对象
- en: '](img/Figure_19.11_B14199.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.11_B14199.jpg)'
- en: Figure 19.11 – A single object with two LOD meshes
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.11 – 一个带有两个LOD网格的单个对象
- en: Add an LOD group component to the parent.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LOD组件添加到父对象。
- en: The default LOD group is prepared to support three LOD mesh groups, but as we
    only have two, right-click on one and click **Delete**. You can also select **Insert
    Before** to add more LOD groups:![Figure 19.12 – Removing an LOD group
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的LOD组准备支持三个LOD网格组，但由于我们只有两个，右键单击一个并单击**删除**。您还可以选择**在之前插入**以添加更多LOD组：![图19.12
    – 移除LOD组
- en: '](img/Figure_19.12_B14199.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.12_B14199.jpg)'
- en: Figure 19.12 – Removing an LOD group
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.12 – 移除LOD组
- en: Select **LOD 0**, the highest detail LOD group, and click on the **Add** button
    in the **Renderers** list below this to add the sphere to that group. You can
    add as many mesh renderers as you want.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 0**，最高细节LOD组，并单击下面的**渲染器**列表中的**添加**按钮，将球添加到该组。您可以添加任意数量的网格渲染器。
- en: Select **LOD 1** and add the cube:![Figure 19.13 – Adding renderers to LOD groups
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 1**并添加立方体：![图19.13 – 将渲染器添加到LOD组
- en: '](img/Figure_19.13_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.13_B14199.jpg)'
- en: Figure 19.13 – Adding renderers to LOD groups
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.13 – 将渲染器添加到LOD组
- en: Drag the line between the two groups to control the distance range that each
    group will occupy. As you drag it, you will see a preview of how far the camera
    needs to be to switch groups. Also, you have the culled group, which is the distance
    from where the camera will not render any group.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动两个组之间的线以控制每个组占用的距离范围。当您拖动它时，您将看到相机需要切换组的预览距离。此外，您还有被剔除的组，即相机不会渲染任何组的距离。
- en: Just move the camera around in **Edit** mode to see how the meshes are swapped.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需在**编辑**模式下移动相机，以查看网格是如何交换的。
- en: Something to consider here is that the colliders of the objects won't be disabled,
    so just have the renderers in the LOD sub-objects. Put the collider with the shape
    of LOD 0 in the parent object, or just remove the colliders from the LOD group
    objects, except group 0.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要考虑的一点是，对象的碰撞体不会被禁用，因此只需在LOD子对象中放置渲染器。将LOD 0的形状碰撞体放在父对象中，或者只是从LOD组对象中移除碰撞体，除了组0。
- en: 'Another optimization to consider is frustum culling. By default, Unity will
    render any object that falls into the view area or frustum of the camera, skipping
    the ones that don''t. The algorithm is cheap enough to always use, and there''s
    no way to disable it. However, it does have a flaw. If we have a wall hiding all
    the objects behind it, even if they are occluded, they fall inside the frustum,
    so they will be rendered anyway. Detecting whether every pixel of a mesh occludes
    every pixel of the other mesh is almost impossible to do in realtime, but luckily,
    we have a workaround: occlusion culling.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要考虑的优化是截锥体裁剪。默认情况下，Unity会渲染相机视图区域或截锥体内的任何对象，跳过不在其中的对象。该算法足够便宜，因此始终使用，并且无法禁用。但是，它确实有一个缺陷。如果有一堵墙遮挡了其后的所有物体，即使它们被遮挡，它们仍然会落入截锥体内，因此仍然会被渲染。在实时中检测一个网格的每个像素是否遮挡另一个网格的每个像素几乎是不可能的，但幸运的是，我们有一个变通方法：遮挡剔除。
- en: 'Occlusion culling is a process that analyzes a scene and determines which objects
    can be seen in different parts of the scene, dividing them into sectors and analyzing
    each one. As this process can take quite a long time, it is done in the editor,
    as is done with lightmapping. As you can imagine, it only works on static objects.
    To use it, do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡剔除是分析场景并确定在场景的不同部分中可以看到哪些对象的过程，将它们分成部分并分析每个部分。由于这个过程可能需要相当长的时间，因此在编辑器中进行，就像进行光照贴图一样。正如你可以想象的那样，它只对静态对象起作用。要使用它，请执行以下操作：
- en: Mark the objects that shouldn't move as static, or if you only want this object
    to be considered static for the occlusion culling system, check the **Occluder**
    and **Ocludee** checkboxes of the arrow to the right of the **Static** checkbox.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不应移动的对象标记为静态，或者如果您只希望将此对象视为遮挡剔除系统的静态对象，请选中**静态**复选框右侧的箭头旁边的**遮挡者**和**被遮挡者**复选框。
- en: Open the **Occlusion Culling** window (**Window** | **Rendering** | **Occlusion
    Culling**).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**遮挡剔除**窗口（**窗口** | **渲染** | **遮挡剔除**）。
- en: Save the scene and hit the **Bake** button at the bottom of the window, and
    then wait for the baking process. If you don't save the scene before the baking
    process, it won't be executed.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并在窗口底部单击**烘焙**按钮，然后等待烘焙过程。如果在烘焙过程之前不保存场景，它将不会执行。
- en: Select the **Visualization** tab in the **Occlusion Culling** window.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**遮挡剔除**窗口中选择**可视化**选项卡。
- en: With the **Occlusion Culling** window visible, select the camera and drag it
    around, seeing how objects are occluded as the camera moves:![Figure 19.14 – On
    the left is the normal scene and on the right is the scene with occlusion culling
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**遮挡裁剪**窗口可见时，选择摄像机并拖动它，看看随着摄像机移动对象是如何被遮挡的：![图19.14 – 左边是正常场景，右边是带有遮挡裁剪的场景
- en: '](img/Figure_19.14_B14199.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.14_B14199.jpg)'
- en: Figure 19.14 – On the left is the normal scene and on the right is the scene
    with occlusion culling
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.14 – 左边是正常场景，右边是带有遮挡裁剪的场景
- en: 'Take into account that if you move the camera outside the calculated area,
    the process won''t take place, and Unity will only calculate areas near the static
    objects. You can extend the calculation area by creating an empty object and adding
    an **Occlusion Area** component, setting its position and size to cover the area
    that the camera will reach, and finally, rebaking the culling. Try to be sensible
    with the size of the cube. The larger the area to calculate, the larger the space
    needed in your disk to store the generated data. You can use several of these
    areas to be more precise—for example, in an L-shaped scene, you can use two of
    them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果将摄像机移出计算区域，处理将不会发生，Unity只会计算靠近静态对象的区域。您可以通过创建一个空对象并添加一个**遮挡区域**组件，设置其位置和大小以覆盖摄像机将到达的区域，最后重新烘焙裁剪来扩展计算区域。尝试合理设置立方体的大小。计算的区域越大，磁盘中存储生成数据所需的空间就越大。您可以使用多个这样的区域来更精确地计算，例如，在一个L形场景中，您可以使用两个：
- en: '![Figure 19.15 – Occlusion Area'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.15 – 遮挡区域'
- en: '](img/Figure_19.15_B14199.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.15_B14199.jpg)'
- en: Figure 19.15 – Occlusion Area
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.15 – 遮挡区域
- en: If you see that the objects are not being occluded, it could be that the occluder
    object (the wall in this case) is not big enough to be considered. You can increase
    the size of the object or reduce the **Smallest Occluder** setting in the **Bake**
    tab of the window. Doing that will subdivide the scene further to detect smaller
    occluders, but that will take more space in the disk to store more data. So again,
    be sensible with this setting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现对象没有被遮挡，可能是遮挡对象（在这种情况下是墙）不够大。你可以增加对象的大小或者在窗口的**烘焙**选项卡中减少**最小遮挡者**设置。这样做会进一步细分场景以检测更小的遮挡者，但这将占用更多磁盘空间来存储更多数据。所以再次，要合理设置这个选项。
- en: There are still some more techniques that we can apply to our game, but the
    ones we have discussed are sufficient. So now, let's start discussing other optimization
    areas, such as the processing area.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以应用一些其他技术到我们的游戏中，但我们已经讨论过的足够了。所以现在，让我们开始讨论其他优化领域，比如处理领域。
- en: Optimizing processing
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化处理
- en: While graphics usually take up most of the time that a frame needs to be generated,
    we should never underestimate the cost of badly optimized code and scenes. There
    are several parts of the game that are still calculated in the CPU, including
    part of the graphics process (such as the batching calculations), Unity Physics,
    audio, and our code. Here, we have a lot more causes of performance issues than
    on the graphics side, so again, instead of discussing every optimization, let's
    learn how to discover them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图形通常占据生成一帧所需时间的大部分，但我们不应低估糟糕优化的代码和场景的成本。游戏中仍然有一些部分是在CPU中计算的，包括图形处理的一部分（如批处理计算）、Unity物理、音频和我们的代码。在这里，我们遇到的性能问题比图形方面多得多，所以再次，与其讨论每一个优化，不如学习如何发现它们。
- en: 'In this section, we will examine the following CPU optimization concepts:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下CPU优化概念：
- en: Detecting CPU- and GPU-bound
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测CPU和GPU负载
- en: Using the CPU Usage Profiler
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CPU使用率分析器
- en: General CPU optimization techniques
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般的CPU优化技术
- en: We will start by discussing the concepts of CPU- and GPU-bound, which focus
    on the optimization process, determining whether the problem is GPU- or CPU-related.
    Later, as with the GPU optimization process, we will look at how to gather the
    performance data of the CPU and interpret it to detect possible optimization techniques
    to be applied.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论CPU-和GPU受限的概念开始，这些概念侧重于优化过程，确定问题是GPU还是CPU相关。稍后，就像GPU优化过程一样，我们将看看如何收集CPU的性能数据并解释它以检测可能应用的优化技术。
- en: Detecting CPU- and GPU-bound
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测CPU和GPU负载
- en: As with Frame Debugger, the Unity Profiler allows us to gather data about the
    performance of our game through a series of Profiler modules, each one designed
    to gather data about different Unity systems per frame, such as Physics, audio,
    and, most importantly, CPU usage. This last module allows us to see every single
    function that Unity called to process the frame—that is, from our script's executed
    functions to other systems, such as Physics and graphics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与帧调试器一样，Unity Profiler允许我们通过一系列性能分析器模块收集有关游戏性能的数据，每个模块都旨在收集关于不同Unity系统的每帧数据，例如物理、音频，最重要的是CPU使用情况。这个最后的模块允许我们看到Unity处理帧所调用的每个函数，也就是从我们脚本执行的函数到其他系统，比如物理和图形。
- en: Before exploring CPU usage, one important bit of data that we can gather in
    this module is whether we are CPU- or GPU- bound. As explained before, a frame
    is processed using both CPU and GPU, and those pieces of hardware can work in
    parallel. While GPU is executing drawing commands, the CPU can execute Physics
    and our scripts in a very efficient way. But now, let's say that the CPU finishes
    its work while the GPU is still working. Can the CPU start to work on the next
    frame? The answer is no. This would lead to a de-synchronization, so in this scenario,
    the CPU will need to wait. This is known as CPU-bound, and we have also the opposite
    case, GPU-bound, when the GPU finishes earlier than the CPU.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索CPU使用率之前，我们可以在这个模块中收集的一个重要数据是我们是CPU-还是GPU-受限。如前所述，一帧使用CPU和GPU并行处理。当GPU执行绘图命令时，CPU可以以非常高效的方式执行物理和我们的脚本。但现在，假设CPU完成了它的工作，而GPU仍在工作。CPU可以开始处理下一帧吗？答案是否定的。这将导致不同步，所以在这种情况下，CPU将需要等待。这就是所谓的CPU受限，我们也有相反的情况，GPU受限，当GPU比CPU更早完成时。
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is worth mentioning that on mobile devices, it is sometimes preferable to
    reduce the framerate of our game to reduce battery consumption, making the game
    idle for a moment between frame to frame, but that could lead to a slower response
    in our commands and input. To solve that, Unity has created a package that adds
    the ability to skip the rendering process after a configurable number of frames,
    which keeps the processing working but skips rendering. So, naturally, those frames
    will be CPU-bound only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在移动设备上，有时最好降低游戏的帧率以减少电池消耗，使游戏在帧之间空闲一会儿，但这可能会导致命令和输入的响应变慢。为了解决这个问题，Unity创建了一个包，可以在可配置的帧数之后跳过渲染过程，从而保持处理工作但跳过渲染。因此，自然而然地，这些帧将仅受CPU限制。
- en: 'It is important to concentrate our optimization efforts, so if we detect that
    our game is GPU-bound, we will focus on GPU graphics optimization, and if it is
    CPU-bound, then we will focus on the rest of the systems and the CPU side of graphics
    processing. To detect whether our game is one or the other, do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 集中我们的优化工作非常重要，因此如果我们发现游戏受GPU限制，我们将专注于GPU图形优化；如果受CPU限制，我们将专注于其他系统和CPU图形处理的优化。要检测我们的游戏是哪一种情况，可以按照以下步骤进行：
- en: Open **Profiler** (**Window** | **Analysis** | **Profiler**).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Profiler**（**Window** | **Analysis** | **Profiler**）。
- en: In the **Profiler Modules** dropdown in the top-left corner, tick **GPU** to
    enable the GPU profiler:![Figure 19.16 – Enabling the GPU profiler
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的**Profiler Modules**下拉菜单中，勾选**GPU**以启用GPU分析器：![图19.16 – 启用GPU分析器
- en: '](img/Figure_19.16_B14199.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.16_B14199.jpg)'
- en: Figure 19.16 – Enabling the GPU profiler
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.16 – 启用GPU分析器
- en: Play the game and select the **CPU Usage** profiler, clicking on its name in
    the left part of the **Profiler** window.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并选择**CPU使用率**分析器，在**Profiler**窗口的左侧部分点击其名称。
- en: Observe the bar with the **CPU** and **GPU** labels in the middle of the window.
    It should say how many milliseconds are being consumed by the CPU and GPU. The
    one with the higher number will be the one that is limiting our framerate and
    will determine whether we are GPU- or CPU-bound:![Figure 19.17 – Determining whether
    we are CPU- or GPU-bound
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察窗口中间带有**CPU**和**GPU**标签的条形图。它应该显示CPU和GPU消耗了多少毫秒。数字较高的那个将限制我们的帧率，并确定我们是受GPU限制还是受CPU限制：![图19.17
    – 确定我们是受CPU限制还是受GPU限制
- en: '](img/Figure_19.17_B14199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.17_B14199.jpg)'
- en: Figure 19.17 – Determining whether we are CPU- or GPU-bound
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.17 – 确定我们是受CPU限制还是受GPU限制
- en: Click the button that says Timeline and select Hierarchy instead:![Figure 19.18
    – Selecting Hierarchy
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标有Timeline的按钮，选择Hierarchy：![图19.18 – 选择Hierarchy
- en: '](img/Figure_19.18_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.18_B14199.jpg)'
- en: Figure 19.18 – Selecting Hierarchy
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.18 – 选择Hierarchy
- en: There is a chance that when you try to open the GPU profiler, you will see a
    not supported message, and this can happen in certain cases (such as on some mac
    devices). In that scenario, another way to see whether we are GPU-bound is by
    searching `waitforpresent` in the search bar right next to the CPU/GPU labels
    while selecting the CPU Usage profiler:![Figure 19.19 – Searching waitforpresent
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试打开GPU分析器时，有可能会看到不支持的消息，在某些情况下会发生这种情况（例如在某些Mac设备上）。在这种情况下，另一种查看我们是否受GPU限制的方法是在选择CPU使用率分析器时，在CPU/GPU标签旁边的搜索栏中搜索`waitforpresent`：![图19.19
    – 搜索waitforpresent
- en: '](img/Figure_19.19_B14199.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.19_B14199.jpg)'
- en: Figure 19.19 – Searching waitforpresent
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.19 – 搜索waitforpresent
- en: Here, you can see how long the CPU has been waiting for the GPU. Check the `0.00`,
    this is because the CPU is not waiting for the GPU, meaning we are not GPU-bound.
    In the preceding screenshot, you can see that my screen displays `0.00` while
    the CPU is taking `9.41ms` and the GPU is taking `6.73ms`. So, my device is CPU-bound.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您可以看到CPU等待GPU的时间有多长。检查`0.00`，这是因为CPU没有等待GPU，这意味着我们不受GPU限制。在前面的截图中，您可以看到我的屏幕显示`0.00`，而CPU花费了`9.41ms`，GPU花费了`6.73ms`。因此，我的设备受CPU限制。
- en: Now that we can detect whether we are CPU- or GPU-bound, we can focus our optimization
    efforts. So far, we discussed how to profile and optimize part of the GPU process.
    Now, if we detect that we are CPU-bound, let's see how to profile the CPU.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检测我们是受CPU限制还是受GPU限制，然后集中我们的优化工作。到目前为止，我们讨论了如何对GPU过程的一部分进行分析和优化。现在，如果我们发现我们受CPU限制，让我们看看如何对CPU进行分析。
- en: Using the CPU Usage profiler
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CPU使用率分析器
- en: Profiling the CPU is done in a similar way to profiling the GPU. We need to
    get a list of actions the CPU executes and try to reduce them, and here is where
    the CPU Usage profiler module comes in—a tool that allows us to see all the instructions
    that the CPU executed in one frame. The main difference is that the GPU mostly
    executes draw calls, and we have a few types of them, while the CPU can have hundreds
    of different instructions to execute, and sometimes some of them cannot be deleted,
    such as Physics Update or audio processing. In these scenarios, we are looking
    to reduce the cost of these functions in case they are consuming too much time.
    So, again, an important note here is to detect which function is taking too much
    time and then reduce its cost or remove it, which requires a deeper understanding
    of the underlying system. Let's start detecting the function first.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对CPU进行分析的方式与对GPU进行分析的方式类似。我们需要获取CPU执行的操作列表并尝试减少它们，这就是CPU使用率分析器模块的作用——这是一个工具，允许我们查看CPU在一个帧中执行的所有指令。主要区别在于GPU主要执行绘制调用，而我们有几种类型的绘制调用，而CPU可能有数百种不同的指令需要执行，有时其中一些是无法删除的，例如物理更新或音频处理。在这些情况下，我们希望减少这些功能的成本，以防它们消耗太多时间。因此，重要的一点是要检测哪个功能花费了太多时间，然后减少其成本或删除它，这需要对底层系统有更深入的了解。让我们首先开始检测这个功能。
- en: 'When you play the game with the **Profiler** tab opened, you will see a series
    of graphics showing the performance of our game, and in the CPU Usage profiler,
    you will see that the graphic is split into different colors, each one referring
    to different parts of frame processing. You can check the information to the left
    of the profiler to see what each color means, but let''s discuss the most important
    ones. In the following screenshot, you can see how the graphic should look:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在打开**Profiler**选项卡时玩游戏，您将看到一系列图形显示我们游戏的性能，在CPU使用率分析器中，您将看到图形被分成不同的颜色，每种颜色代表帧处理的不同部分。您可以查看分析器左侧的信息来了解每种颜色的含义，但让我们讨论最重要的部分。在下面的截图中，您可以看到图形应该是什么样子的：
- en: '![Figure 19.20 – Analyzing the CPU Usage graph'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.20 – 分析CPU使用率图'
- en: '](img/Figure_19.20_B14199.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.20_B14199.jpg)'
- en: Figure 19.20 – Analyzing the CPU Usage graph
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.20 – 分析CPU使用率图
- en: 'If you check the graphic, you will probably assume that the dark-green part
    of the graph is taking up most of the performance time, and while that is true,
    you can also see from the legend that dark green means **Others**, and that''s
    because we are profiling the game in the editor. The editor won''t behave exactly
    like the final game. In order for it to run, it has to do lots of extra processing
    that won''t be executed in the game, so the best you can do is profile directly
    in the build of the game. There, you will gather more accurate data. We are going
    to discuss how to do builds in the next chapter, so for now, we can ignore that
    area. What we can do now is simply click on the colored square to the left of
    the **Others** label to disable that measurement from the graph in order to clean
    it up a little bit. If you also see a large section of yellow, it is referring
    to VSync, which is basically the time spent waiting for our processing to match
    the monitor''s refresh rate. This is also something that we can ignore, so you
    should also disable it. In the next screenshot, you can check the graphic color
    categories and how to disable them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看图形，您可能会认为图表的深绿色部分占用了大部分性能时间，虽然这是真的，但您也可以从图例中看到深绿色代表**其他**，这是因为我们是在编辑器中对游戏进行分析。编辑器的行为不会完全像最终游戏那样。为了使其运行，它必须进行大量额外的处理，这些处理在游戏中不会执行，因此您能做的最好的事情就是直接在游戏的构建版本中进行分析。在那里，您将收集到更准确的数据。我们将在下一章讨论如何进行构建，所以现在我们可以忽略那个区域。现在我们可以简单地点击**其他**标签左侧的彩色方块，以禁用图表中的该测量，以便稍微清理一下。如果您还看到大片黄色，那是指VSync，基本上是等待我们的处理与显示器的刷新率匹配所花费的时间。这也是我们可以忽略的东西，所以您也应该禁用它。在下一个截图中，您可以查看图形颜色类别以及如何禁用它们：
- en: '![Figure 19.21 – Disabling VSync and Others from the profiler'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.21 – 从分析器中禁用VSync和其他功能'
- en: '](img/Figure_19.21_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.21_B14199.jpg)'
- en: Figure 19.21 – Disabling VSync and Others from the profiler
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.21 – 从分析器中禁用VSync和其他功能
- en: Now that we have cleaned up the graph, we can get a good idea of our games potential
    framerate by looking at the line with the ms label (in our case, **5ms (200 FPS)**),
    which indicates that frames below that line have more than 200 FPS, and frames
    above that line have less. In my case, I have excellent performance, but remember,
    I am testing this on a powerful machine. The best way to profile is not only in
    the build of the game (as an executable) but also in the target device, which
    should be the lowest spec hardware we intend our game to run on. Our target device
    depends a lot on the target audience of the game. If we are making a casual game,
    we are probably targeting mobile devices, so we should test the game on the lowest
    spec phone we can, but if we are targeting hardcore gamers, they will probably
    have a powerful machine to run our game on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了图形，我们可以通过查看带有ms标签的线（在我们的情况下，**5ms (200 FPS)**）来很好地了解我们游戏的潜在帧率，这表明低于该线的帧率超过200
    FPS，而高于该线的帧率低于200 FPS。在我的情况下，性能非常好，但请记住，我是在一台性能强大的机器上测试的。最佳的分析方法不仅是在游戏的构建版本中（作为可执行文件），而且还要在目标设备上进行分析，这应该是我们打算运行游戏的最低规格硬件。我们的目标设备在很大程度上取决于游戏的目标受众。如果我们正在制作休闲游戏，我们可能会针对移动设备，因此我们应该在尽可能低规格的手机上测试游戏，但如果我们的目标是硬核玩家，他们可能会有一台强大的机器来运行我们的游戏。
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are targeting hardcore gamers, of course, this doesn't mean that we can
    just make a very unoptimized game because of that, but it will give us enough
    processing space to add more detail. Anyway, I strongly recommend you avoid those
    kinds of games if you are a beginner as they are more difficult to develop, which
    you will probably realize. Stick to simple games to begin with.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标是硬核玩家，当然，这并不意味着我们可以制作一个非常未优化的游戏，但这将为我们提供足够的处理空间来增加更多细节。无论如何，我强烈建议您避免那些类型的游戏，如果您是初学者，因为它们更难开发，您可能会意识到这一点。先从简单的游戏开始。
- en: Looking at the graphics colors, you can observe the cost on the CPU side of
    rendering in light green, which the graph shows is taking up a significant portion
    of the processing time, which is actually normal. Then, in blue, we can see the
    cost of our scripts' execution, which is also taking up a significant portion,
    but again, this is quite normal. Also, we can observe a little bit of orange,
    which is Physics, and also a little bit of light blue, which is Animation. Remember
    to check the colored labels in the profiler to remember which color refers to
    what.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察图形颜色，您可以看到CPU端渲染的成本是浅绿色，图表显示它占用了大部分处理时间，这实际上是正常的。然后，在蓝色中，我们可以看到脚本执行的成本，这也占用了相当大的部分，但同样，这也是相当正常的。此外，我们还可以观察到一点橙色，那是物理，还有一点浅蓝色，那是动画。记得检查分析器中的彩色标签，以记住每种颜色代表什么。
- en: 'Now, those colored bars represent a group of operations, so if we consider
    the **Rendering** bar to be representing 10 operations, how do we know which operations
    that includes? Also, how do we know which of these operations is taking up the
    most performance time? Out of those 10 operations, a single one could be causing
    these issues. Here is where the bottom part of the profiler is useful. It shows
    a list of all the functions being called in the frame. To use it, do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些彩色条代表一组操作，所以如果我们认为**渲染**条代表10个操作，我们如何知道包括哪些操作？又如何知道这些操作中哪些占用了最多的性能时间？在这10个操作中，可能有一个单独的操作导致了这些问题。这就是分析器底部部分的用处。它显示了帧中调用的所有功能的列表。使用它，按照以下步骤进行：
- en: Clear the search bar we used earlier. It will filter function calls by name,
    and we want to see them all. Remember to switch from Timeline to Hierarchy mode
    if not already there.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除我们之前使用的搜索栏。它将按名称过滤功能调用，而我们希望看到它们全部。如果尚未在那里，请记得从时间轴切换到层次结构模式。
- en: Click on the **Time ms** column until you see an arrow pointing downward. This
    will order the calls by cost in descending order.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**时间ms**列，直到出现向下的箭头。这将按成本降序排列调用。
- en: Click on a frame that is taking your attention in the graph—probably one of
    the ones with the biggest height that consumes more processing time. This will
    make the profiler stop the game straight away and show you information about that
    frame.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图表中引起你注意的帧 - 可能是消耗更多处理时间的最高的帧之一。这将使分析器立即停止游戏并显示有关该帧的信息。
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are two things to consider when looking at the graph. If you see peaks
    that are significantly higher than the rest of the frames, that can cause a hiccup
    in your game—a very brief moment where the game is frozen—which can break the
    performance. Also, you can look for a long series of frames with higher time consumption.
    Try to reduce them as well. Even if this is only temporary, the impact of it will
    be easily perceived by the player.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图表时需要考虑两件事。如果你看到峰值明显高于其他帧，这可能会导致游戏出现瞬间卡顿，这会影响性能。此外，你还可以寻找一长串时间消耗较高的帧。也要尽量减少它们。即使这只是暂时的，玩家也会很容易察觉到它的影响。
- en: '**PlayerLoop** will probably appear as the most time-consuming frame, but that''s
    not very informative. You can explore it further by expanding it by clicking on
    the arrow to its left.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PlayerLoop**可能会出现为消耗时间最长的帧，但这并不是很有信息性。你可以通过点击其左侧的箭头来展开它以进一步探索。'
- en: Click on each function to highlight it in the graph. Functions with higher processing
    times will be highlighted with thicker bars, and those are the ones we will focus
    on:![Figure 19.22 – The Render Camera function highlighted in the graph
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击每个功能以在图表中突出显示。处理时间较长的功能将以较粗的条形突出显示，这些是我们将要关注的功能：![图19.22 - 在图表中突出显示的渲染相机功能
- en: '](img/Figure_19.22_B14199.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.22_B14199.jpg)'
- en: Figure 19.22 – The Render Camera function highlighted in the graph
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.22 - 在图表中突出显示的渲染相机功能
- en: 'You can keep click on the arrows to further explore the functions until you
    hit a limit. If you want to go deeper, enable the **Deep Profiler** mode in the
    top bar of the profiler. This will give you more details, but take into account
    that this process is expensive and will make the game go slower, altering the
    time shown in the graph, making it appear much higher than the real time. Here,
    ignore the numbers and look at how much of the process a function is taking up
    based on the graph. You will need to stop, enable **Deep Profile**, and play it
    again to make it work:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以继续点击箭头以进一步探索功能，直到达到极限。如果想要更深入，可以在分析器的顶部栏中启用**深度分析**模式。这将提供更多细节，但要注意这个过程是昂贵的，会使游戏变慢，改变图表中显示的时间，使其看起来比实际时间要长得多。在这里，忽略数字，看看根据图表，一个功能占用了多少进程。你需要停止，启用**深度分析**，然后再次播放才能使其生效。
- en: '![Figure 19.23 – Enabling Deep Profile'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.23 - 启用深度分析'
- en: '](img/Figure_19.23_B14199.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.23_B14199.jpg)'
- en: Figure 19.23 – Enabling Deep Profile
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.23 - 启用深度分析
- en: With this knowledge, we can start improving our game performance (if it's below
    the target framerate), but each function is called by the CPU and is improved
    in its own unique way, which requires a greater knowledge of Unity's internal
    workings. That could span several books, and anyway, the internals change on a
    version-to-version basis. Instead, you could study how each function works by
    looking up data about that specific system on the internet, or again, by just
    disabling and enabling objects or parts of our code to explore the impact of our
    actions, as we did with Frame Debugger. Profiling requires creativity and inference
    to interpret and react accordingly on the data obtained, so you will need some
    patience here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以开始改善游戏性能（如果低于目标帧率），但每个功能都是由CPU调用并以其独特的方式进行改进，这需要对Unity的内部工作有更深入的了解。这可能需要涉及几本书，而且内部工作会随着版本的变化而变化。相反，你可以通过在互联网上查找有关特定系统的数据，或者通过禁用和启用对象或代码的部分来探索我们行为的影响，就像我们在帧调试器中所做的那样。分析需要创造力和推理来解释和相应地对所获得的数据做出反应，因此你需要一些耐心。
- en: Now that we have discussed how to get the profiling data relating to the CPU,
    let's discuss some common ways to reduce CPU usage.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何获取与CPU相关的分析数据，让我们讨论一些常见的减少CPU使用率的方法。
- en: General CPU optimization techniques
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU优化的一般技术
- en: In terms of CPU optimizations, there are lots of possible causes of high performance,
    including the abuse of Unity's features, a large amount of Physics or audio objects,
    improper asset/objects configurations, and so on. Our scripts can also be coded
    in an unoptimized way, abusing or misusing expensive Unity API functions. So far,
    we have discussed several good practices of using Unity Systems, such as audio
    configurations, texture sizes, batching, and finding functions such as `GameObject.Find`
    and replacing them with managers. So, let's discuss some specific details about
    common cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU优化方面，有许多可能导致性能不佳的原因，包括滥用Unity的功能，大量的物理或音频对象，不正确的资源/对象配置等。我们的脚本也可能以非优化的方式编写，滥用或错误使用昂贵的Unity
    API函数。到目前为止，我们已经讨论了使用Unity系统的几种良好实践，例如音频配置，纹理大小，批处理，以及查找函数，如`GameObject.Find`并用管理器替换它们。因此，让我们讨论一些关于常见情况的具体细节。
- en: 'Let''s start by seeing how a large number of objects impacts our performance.
    Here, you can just create lots of objects with `Rigidbody` configured in `Physics.Processing`
    function is responsible for this increase:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看大量对象对性能的影响。在这里，您可以创建大量配置为`Physics.Processing`的`Rigidbody`的对象，该函数负责此增加：
- en: '![Figure 19.24 – The Physics processing of several objects'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.24 – 多个对象的物理处理'
- en: '](img/Figure_19.24_B14199.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.24_B14199.jpg)'
- en: Figure 19.24 – The Physics processing of several objects
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.24 – 多个对象的物理处理
- en: 'Another test to see the impact of several objects could be to create lots of
    audio sources. In the following screenshot, you can see that we needed to re-enable
    **Others** because audio processing comes under that category. We mentioned earlier
    that **Others** belongs to the editor, but it can encompass other processes as
    well, so keep that in mind:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试是看看多个对象的影响，可以创建大量的音频源。在下面的截图中，您可以看到我们需要重新启用**其他**，因为音频处理属于该类别。我们之前提到**其他**属于编辑器，但它也可以包括其他进程，所以请记住这一点：
- en: '![Figure 19.25 – The Physics processing of several objects'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.25 – 多个对象的物理处理'
- en: '](img/Figure_19.25_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.25_B14199.jpg)'
- en: Figure 19.25 – The Physics processing of several objects
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.25 – 多个对象的物理处理
- en: 'So, to discover these kinds of problems, you can just start disabling and enabling
    objects and see whether they increase the time. A final test is on particles.
    Create a system that spawns a big enough number of particles to affect our framerate
    and check the profiler. In the following screenshot, you can check how the particle
    processing function is highlighted in the graph, showing that it takes a large
    amount of time:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要发现这些问题，您可以开始禁用和启用对象，看它们是否增加了时间。最后一个测试是关于粒子。创建一个系统，产生足够多的粒子以影响我们的帧率，并检查性能分析器。在下面的截图中，您可以看到粒子处理函数在图表中被突出显示，表明它花费了大量时间：
- en: '![Figure 19.26 – Particle processing'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.26 – 粒子处理'
- en: '](img/Figure_19.26_B14199.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.26_B14199.jpg)'
- en: Figure 19.26 – Particle processing
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.26 – 粒子处理
- en: Then, on the scripting side, we have other kinds of things to consider, some
    of which are common to all programming languages and platforms, such as iterating
    long lists of objects, the misuse of data structures, and deep recursion. However,
    in this section, I will mainly be discussing Unity-specific APIs, starting with
    `print` or `Debug.Log`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在脚本方面，我们还有其他需要考虑的事情，其中一些是所有编程语言和平台共有的，例如迭代长列表的对象，滥用数据结构和深度递归。然而，在本节中，我主要将讨论特定于Unity的API，从`print`或`Debug.Log`开始。
- en: This function is useful to get debugging information in the console, but it
    can also be costly because all logs are written onto the disk immediately to avoid
    losing valuable information if our game crashes. Of course, we want to keep those
    valuable logs in the game, but we don't want it to affect performance, so what
    can we do?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对于在控制台中获取调试信息很有用，但也可能很昂贵，因为所有日志都会立即写入磁盘，以避免在游戏崩溃时丢失宝贵的信息。当然，我们希望在游戏中保留这些宝贵的日志，但我们不希望它影响性能，那么我们该怎么办呢？
- en: 'One possible approach is to keep those messages but disable the non-essential
    ones in the final build, such as informative messages, keeping the error-reporting
    function active. One way to do this is through compiler directives, such as the
    ones used in the following screenshot. Remember that this kind of `if` statement
    is executed by the compiler and can exclude entire portions of code when compiling
    if its conditions are not met:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是保留这些消息，但在最终构建中禁用非必要的消息，例如信息性消息，保持错误报告功能处于活动状态。一种方法是通过编译器指令，例如下面截图中使用的指令。请记住，这种`if`语句是由编译器执行的，如果条件不满足，编译时可以排除整个代码部分：
- en: '![Figure 19.27 – Disabling code'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.27 – 禁用代码'
- en: '](img/Figure_19.27_B14199.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.27_B14199.jpg)'
- en: Figure 19.27 – Disabling code
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.27 – 禁用代码
- en: In the preceding screenshot, you can see how we are asking whether this code
    is being compiled by the editor or for a development build, which is a special
    kind of build intended to be used for testing (more on that in the next chapter).
    You can also create your own kind of logging system with functions with the compiler
    directives, so you don't need to use them in every log that you want to exclude.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到我们正在询问此代码是由编辑器编译还是用于开发构建，这是一种特殊类型的构建，旨在用于测试（在下一章中将详细介绍）。您还可以使用编译器指令创建自己的日志记录系统，因此您不需要在每个要排除的日志中使用它们。
- en: There are a few other script aspects that can affect performance not only on
    the processing side but also on the memory side, so let's discuss them in the
    next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他脚本方面的问题可能会影响性能，不仅在处理方面，还在内存方面，所以让我们在下一节中讨论它们。
- en: Optimizing memory
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化内存
- en: We discussed how to profile and optimize two pieces of hardware—the CPU and
    GPU—but there is another piece of hardware that plays a key role in our game—RAM.
    This is the place where we put all of our game's data. Games can be memory-intensive
    applications, and unlike several other applications, they are constantly executing
    code, so we need to be especially careful about that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何对两个硬件部分——CPU和GPU进行性能分析和优化，但是还有另一部分硬件在我们的游戏中扮演着关键角色——RAM。这是我们放置所有游戏数据的地方。游戏可能是内存密集型应用程序，与其他几种应用程序不同的是，它们不断执行代码，因此我们需要特别小心。
- en: 'In this section, we will examine the following memory optimization concepts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下内存优化概念：
- en: Memory allocation and the garbage collector
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配和垃圾收集器
- en: Using the Memory Profiler
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存分析器
- en: Let's start discussing how memory allocation works and what role garbage collection
    plays here.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论内存分配的工作原理以及垃圾收集在这里扮演的角色。
- en: Memory allocation and the garbage collector
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配和垃圾收集器
- en: Each time we instantiate an object, we are allocating memory in RAM, and in
    a game, we will be allocating memory constantly. In other programming languages,
    aside from allocating the memory, you need to manually deallocate it, but C# has
    a garbage collector, which is a system that tracks unused memory and cleans it.
    This system works with a reference counter, which tracks how many references to
    an object exist, and when that counter reaches `0`, it means all references have
    become null and the object can be deallocated. This deallocation process can be
    triggered in several situations, the most common situation being when we reach
    the maximum assigned memory and we want to allocate a new object. In that scenario,
    we can release enough memory to allocate our object, and if that is not possible,
    the memory is expanded.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实例化一个对象，我们都在RAM中分配内存，在游戏中，我们将不断地分配内存。在其他编程语言中，除了分配内存，您还需要手动释放它，但是C#有一个垃圾收集器，它是一个跟踪未使用内存并清理它的系统。该系统使用引用计数器，跟踪对象存在多少引用，当计数器达到`0`时，意味着所有引用都变为null，对象可以被释放。这个释放过程可以在几种情况下触发，最常见的情况是当我们达到最大分配内存并且想要分配一个新对象时。在这种情况下，我们可以释放足够的内存来分配我们的对象，如果不可能，内存就会被扩展。
- en: 'In any game, you will probably be allocating and deallocating memory constantly,
    which can lead to memory fragmentation, meaning there are small spaces between
    alive object memory blocks that are mostly useless because they aren''t big enough
    to allocate an object, or maybe the sum of the spaces are big enough, but we need
    continuous memory space to allocate our objects. In the following diagram, you
    can see a classic example of trying to fit a big chunk of memory into the little
    gaps generated by fragmentation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中，您可能会不断地分配和释放内存，这可能导致内存碎片化，意味着存活对象内存块之间存在小空间，这些空间大多是无用的，因为它们不足以分配一个对象，或者可能空间的总和足够大，但我们需要连续的内存空间来分配我们的对象。在下图中，您可以看到一个经典的例子，试图将一个大块内存放入碎片化产生的小间隙中：
- en: '![Figure 19.28 – Trying to instantiate an object in a fragmented memory space'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.28 – 尝试在碎片化的内存空间中实例化对象'
- en: '](img/Figure_19.28_B14199.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.28_B14199.jpg)'
- en: Figure 19.28 – Trying to instantiate an object in a fragmented memory space
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.28 – 尝试在碎片化的内存空间中实例化对象
- en: Some types of garbage collection systems, such as the one in regular C#, are
    generational, meaning memory is split into generation buckets according to the
    "age" of its memory. Newer memory will be placed in the first bucket, and this
    memory tends to be allocated and deallocated frequently. Because this bucket is
    small, working within it is fast. The second bucket has the memory that survived
    a previous deallocation sweep process in the first bucket. That memory is moved
    to the second bucket to prevent it from being checked constantly if it survived
    the process, and it is possible that that memory will last the length of our program's
    lifetime. The third bucket is just another layer of bucket 2\. The idea is that
    most of the time, the allocation and deallocation system will be working in bucket
    1, and as it is small enough, it is quick to allocate, deallocate, and compact
    memory in a continuous fashion.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一些垃圾收集系统，例如常规C#中的系统，是分代的，这意味着内存根据其内存的“年龄”被分成代桶。新的内存将放在第一个桶中，这些内存往往会频繁分配和释放。因为这个桶很小，所以在其中工作是快速的。第二个桶中有在第一个桶的先前释放扫描过程中幸存的内存。该内存被移动到第二个桶中，以防止它被不断检查是否幸存了该过程，并且可能该内存将持续整个程序的生命周期。第三个桶只是第二个桶的另一层。这个想法是大部分时间，分配和释放系统将在第一个桶中工作，并且由于它足够小，因此可以快速地分配、释放和压缩内存。
- en: The problem here is that Unity uses its own version of the garbage collection
    system, and that version is non-generational and non-compacting, meaning memory
    is not split into buckets and memory won't be moved to fill the gaps. This suggests
    that allocating and deallocating memory in Unity will still result in the fragmentation
    problem, and if you don't regulate your memory allocation, you might end up with
    an expensive garbage collection system being executed very often, producing hiccups
    in our game, which you can see in the Profiler CPU Usage module as a pale yellow
    color.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于Unity使用自己的垃圾收集系统版本，该版本是非分代和非压缩的，这意味着内存不会分成桶，并且内存不会被移动以填补空隙。这表明在Unity中分配和释放内存仍然会导致碎片化问题，如果您不调节内存分配，您可能最终会得到一个执行非常频繁的昂贵垃圾收集系统，在我们的游戏中产生中断，您可以在Profiler
    CPU Usage模块中看到它呈现为淡黄色。
- en: 'One way to deal with this is by preventing memory allocation as much as you
    can, avoiding it when is not necessary. There are a few tweaks here and there
    that you can make to prevent memory allocation, but before looking at those, again,
    it is important to first get data about the problem before start fixing things
    that may not be an issue. This advice applies to any type of optimization process.
    Here, we can still use the CPU Usage profiler to see how much memory is allocated
    to each function call that the CPU executes in each frame, and that is simply
    done by looking at the **GC Alloc** column, which indicates the amount of memory
    that the function allocated:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是尽量避免内存分配，不必要时避免它。有一些微调可以做到这一点，但在查看这些之前，再次重申，首先获取有关问题的数据非常重要，然后再开始修复可能不是问题的事情。这个建议适用于任何类型的优化过程。在这里，我们仍然可以使用CPU使用率分析器来查看CPU在每帧中执行的每个函数调用分配了多少内存，只需查看**GC
    Alloc**列，该列指示函数分配的内存量。
- en: '![Figure 19.29 – The memory allocation of the Update event function of Sight'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.29 – Sight的Update事件函数的内存分配'
- en: '](img/Figure_19.29_B14199.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.29_B14199.jpg)'
- en: Figure 19.29 – The memory allocation of the Update event function of Sight
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.29 – Sight的Update事件函数的内存分配
- en: In the preceding screenshot, we can see how our function is allocating too much
    memory, which is produced because there are a large number of enemies in the scene.
    But that's no excuse; we are allocating that much RAM at every frame, so we need
    to improve this. There are several things that can contribute to our memory being
    claimed by allocations, so let's discuss the basic ones, starting with array-returning
    functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到我们的函数分配了太多的内存，这是因为场景中有大量的敌人。但这并不是借口；我们在每一帧都分配了这么多RAM，所以我们需要改进这一点。有几件事情可能导致我们的内存被分配，所以让我们讨论一些基本的事情，从返回数组的函数开始。
- en: 'If we review the Sight code, we can see that the only moment where we are allocating
    memory is in the call to `Physics.OverlapSphere`, and that is evident because
    it is an array-returning function, which is a function that returns a varying
    amount of data. To do this, it needs to allocate an array and return that array
    to us. This needs to be done on the side that created the function, Unity, but
    in this case, Unity gives us two versions of the function—the one that we are
    using and the `NonAlloc` version. It is usually recommended to use the second
    version, but Unity uses the other one to make coding simpler for beginners. The
    `NonAlloc` version looks as in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们审查Sight代码，我们会发现唯一分配内存的时刻是在调用`Physics.OverlapSphere`时，这是显而易见的，因为它是一个返回数组的函数，这是一个返回可变数量数据的函数。为了做到这一点，它需要分配一个数组并将该数组返回给我们。这需要在创建函数的一侧——Unity上完成，但在这种情况下，Unity给我们提供了两个版本的函数——我们正在使用的版本和`NonAlloc`版本。通常建议使用第二个版本，但Unity使用另一个版本来使初学者编码更简单。`NonAlloc`版本如下截图所示：
- en: '![Figure 19.30 – Memory allocation of the Update event function of Sight'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.30 – Sight的Update事件函数的内存分配'
- en: '](img/Figure_19.30_B14199.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.30_B14199.jpg)'
- en: Figure 19.30 – Memory allocation of the Update event function of Sight
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.30 – Sight的Update事件函数的内存分配
- en: This version requires us to allocate an array with enough space to save the
    largest amount of colliders our `OverlapSphere` variable can find and pass it
    as the third parameter. This allows us to allocate the array just once and reuse
    it on every occasion that we need it. In the preceding screenshot, you can see
    how the array is static, which means it is shared between all the Sight variables
    as they won't execute in parallel (no `Update` function will). This will work
    fine. Keep in mind that the function will return the number of objects that were
    detected, so we just iterate on that count. The array can have previous results
    stored within it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本要求我们分配一个足够大的数组，以保存我们的`OverlapSphere`变量可以找到的最大数量的碰撞体，并将其作为第三个参数传递。这使我们能够只分配一次数组，并在每次需要时重复使用它。在前面的截图中，您可以看到数组是静态的，这意味着它在所有Sight变量之间是共享的（它们不会并行执行`Update`函数）。这将很好地工作。请记住，该函数将返回检测到的对象数量，因此我们只需迭代该计数。数组中可以存储先前的结果。
- en: Now, check your profiler and notice how the amount of memory allocated has been
    reduced greatly. There might be some remaining memory allocation within our function,
    but sometimes there is no way to keep it at `0`. However, you can try to look
    at the reasons for this using deep profiling or by commenting some code and seeing
    which comment removes the allocation. I challenge you to try this. Also, `OverlapSphere`
    is not the only case where this could occur. You have others, such as the `GetComponents`
    functions family, which, unlike `GetComponent,` finds all the components of a
    given type, not just the first one, so pay attention to any array-returning function
    of Unity and try to replace it with a non-allocating version, if there is one.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查一下你的性能分析器，注意分配的内存量已经大大减少。我们的函数内可能仍然存在一些内存分配，但有时无法将其保持为`0`。但是，您可以尝试使用深度分析或通过注释一些代码来查看造成这种情况的原因，并查看哪些注释可以消除分配。我向您挑战尝试一下。此外，`OverlapSphere`并不是唯一可能发生这种情况的情况。还有其他情况，比如`GetComponents`函数系列，与`GetComponent`不同，它不仅找到给定类型的第一个组件，而是找到所有组件，因此请注意Unity的任何返回数组的函数，并尝试用不分配版本替换它，如果有的话。
- en: 'Another common source of memory allocation is string concatenation. Remember
    that strings are immutable, meaning they cannot change if you concatenate two
    strings. A third one needs to be generated with enough space to hold the first
    ones. If you need to concatenate a large number of times, consider using `string.Format`
    if you are just replacing placeholders in a template string, such as putting the
    name of the player and the score they got in a message or using `StringBuilder`,
    a class that just holds all the strings to be concatenated in a list and, when
    necessary, concatenates them together, instead of concatenating them one by one
    as the **+** operator does. Also, consider using the new string interpolation
    functionality of C#. You can see some examples in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的内存分配来源是字符串连接。记住字符串是不可变的，这意味着如果你连接两个字符串，它们是无法改变的。需要生成一个足够大的第三个字符串来容纳前两个字符串。如果你需要大量连接，考虑使用`string.Format`，如果你只是在模板字符串中替换占位符，比如在消息中放置玩家的名字和他们得到的分数，或者使用`StringBuilder`，这是一个只保存所有要连接的字符串的类，当需要时，将它们一起连接起来，而不是像**+**运算符一样一个接一个地连接它们。还要考虑使用C#的新字符串插值功能。你可以在下面的截图中看到一些例子：
- en: '![Figure 19.31 – String management in C#'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.31 – C#中的字符串管理'
- en: '](img/Figure_19.31_B14199.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.31_B14199.jpg)'
- en: Figure 19.31 – String management in C#
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.31 – C#中的字符串管理
- en: 'Finally, a classic technique to consider is object pooling, which is suitable
    in cases where you need to instantiate and destroy objects constantly, such as
    with bullets or effects. In that scenario, the use of regular `Instantiate` and
    `Destroy` functions will lead to memory fragmentation, but object pooling fixes
    that by allocating the maximum amount of required objects possible. It replaces
    `Instantiate` by taking one of the preallocated functions and it replaces `Destroy`
    by returning the object to the pool. A simple pool can be seen in the following
    screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个经典的技术是对象池，适用于需要不断实例化和销毁对象的情况，比如子弹或特效。在这种情况下，使用常规的`Instantiate`和`Destroy`函数会导致内存碎片，但对象池通过分配可能需要的最大数量的对象来解决这个问题。它通过取其中一个预分配的函数来替换`Instantiate`，并通过将对象返回到池中来替换`Destroy`。一个简单的对象池可以在下面的截图中看到：
- en: '![Figure 19.32 – A simple object pool'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.32 – 一个简单的对象池'
- en: '](img/Figure_19.32_B14199.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.32_B14199.jpg)'
- en: Figure 19.32 – A simple object pool
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.32 – 一个简单的对象池
- en: There are several ways to improve this pool, but it is fine as it is for now.
    Note that objects need to be reinitialized when they are taken out of the pool,
    and you can do that with the `OnEnable` event function or by creating a custom
    function to inform the object to do so.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以改进这个池，但现在它已经很好了。请注意，当从池中取出对象时，需要重新初始化对象，你可以使用`OnEnable`事件函数或创建一个自定义函数来通知对象这样做。
- en: Now that we have explored some basic memory allocation reduction techniques,
    let's look at a new Memory Profiler tool, introduced in the latest version of
    Unity, to explore memory in greater detail.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了一些基本的内存分配减少技术，让我们来看看一个新的内存分析器工具，它是在Unity的最新版本中引入的，可以更详细地探索内存。
- en: Using the Memory Profiler
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存分析器
- en: With this profiler, we can detect memory allocated on a frame per-frame basis,
    but it won't show the total memory allocated so far, which would be useful to
    study how we are using our memory. This is where the Memory Profiler can help
    us. This relatively new Unity package allows us to take memory snapshots of every
    single object allocated both on the native and managed side—native meaning the
    internal C++ Unity code, and managed meaning anything that belongs to the C# side
    (that is, both our code and Unity's C# engine code). We can explore snapshots
    with a visual tool and rapidly see which type of object is consuming the most
    RAM and how they are referenced by other objects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个分析器，我们可以检测每帧分配的内存，但它不会显示到目前为止分配的总内存，这对于研究我们如何使用内存很有用。这就是内存分析器可以帮助我们的地方。这个相对较新的Unity包允许我们对每个分配的对象进行内存快照，包括本地和托管端的对象——本地指的是内部的C++
    Unity代码，托管指的是属于C#端的任何东西（也就是我们的代码和Unity的C#引擎代码）。我们可以使用可视化工具探索快照，并快速看到哪种类型的对象消耗了最多的RAM，以及它们如何被其他对象引用。
- en: 'To start using the Memory Profiler, do the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用内存分析器，请执行以下操作：
- en: Install the `Package Manager` (**Window** | **Package Manager**). Remember to
    set **Packages Mode** to **Unity Registry** and enable the preview packages (**Wheel
    Icon | Advanced Project Settings | Enable Preview Packages**).![Figure 19.33 –
    Enabling preview packages
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`包管理器`（**窗口** | **包管理器**）。记得将**包模式**设置为**Unity注册表**并启用预览包（**齿轮图标 | 高级项目设置
    | 启用预览包**）。![图19.33 – 启用预览包
- en: '](img/Figure_19.33_B14199.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.33_B14199.jpg)'
- en: Figure 19.33 – Enabling preview packages
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.33 – 启用预览包
- en: Open `Memory Profiler` in **Window** | **Analysis** | **Memory Profiler**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**窗口** | **分析** | **内存分析器**中打开`内存分析器`。
- en: Play the game and click on the **Capture Player** button in the **Memory Profiler**
    window:![Figure 19.34 – Enabling preview packages
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并在**内存分析器**窗口中点击**捕获玩家**按钮：![图19.34 – 启用预览包
- en: '](img/Figure_19.34_B14199.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.34_B14199.jpg)'
- en: Figure 19.34 – Enabling preview packages
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.34 – 启用预览包
- en: Click on the **Open** button next to the snapshot that was captured to open
    the tree view, where you can see the memory split into blocks by type:![Figure
    19.35 – Memory blocks
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击快照旁边的**打开**按钮以打开树视图，在这里你可以看到内存按类型分成块：![图19.35 – 内存块
- en: '](img/Figure_19.35_B14199.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.35_B14199.jpg)'
- en: Figure 19.35 – Memory blocks
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.35 – 内存块
- en: In our case, we can see that `RenderTexture` uses up the most memory, which
    belongs to the image that is displayed in the scene, as well as some textures
    used by postprocessing effects. Try to disable the `PPVolume` object and take
    another snapshot to detect the difference.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们可以看到`RenderTexture`使用了最多的内存，这属于在场景中显示的图像，以及一些用于后处理效果的纹理。尝试禁用`PPVolume`对象并拍摄另一个快照以检测差异。
- en: In my case, that dropped off 130 MB. There are other textures needed for other
    effects, such as HDR. If you want to explore where those remaining MBs came from,
    click on the block to subdivide it into its objects and take your own guesses
    based on the names of the textures:![Figure 19.36 – Memory blocks in detail
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的情况下，这减少了130 MB。还有其他用于其他效果的纹理，例如HDR。如果您想探索剩余MB的来源，请单击块以将其细分为其对象，并根据纹理的名称进行猜测：![图19.36
    - 内存块详细信息
- en: '](img/Figure_19.36_B14199.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.36_B14199.jpg)'
- en: Figure 19.36 – Memory blocks in detail
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.36 - 内存块详细信息
- en: You can repeat the same process in the `Texture2D` block type, which belongs
    to the textures used in the materials of our models. You can look at the biggest
    one and detect its usage—maybe it is a big texture that is never seen close enough
    to justify its size. Then, we can reduce its size using the Max Size of the Texture
    import settings.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在Texture2D块类型中重复相同的过程，该类型属于我们模型材质中使用的纹理。您可以查看最大的纹理并检测其使用情况 - 也许这是一个从未被近距离看到的大纹理，无法证明其大小。然后，我们可以使用纹理导入设置的最大尺寸来减小其大小。
- en: Important note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As with any profiler, it is always useful to carry out the profiling directly
    in the build (more on that in the next chapter) because taking snapshots in the
    editor will capture lots of memory that is used by the editor and will not be
    used in the build. An example of this is the loading of unnecessary textures because
    the editor probably loaded them when you clicked them to see their previews in
    the Inspector window.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何性能分析器一样，直接在构建中进行性能分析总是有用的（关于这一点，我们将在下一章中详细介绍），因为在编辑器中拍摄快照将捕获编辑器使用的大量内存，并且在构建中不会使用。这种情况的一个例子是加载不必要的纹理，因为编辑器可能在您单击它们以在检查器窗口中查看其预览时加载了它们。
- en: Take into account the fact that due to the Memory Profiler being a package,
    its UI can change often, but its basic idea will remain. You can use this tool
    to detect whether you are using the memory in unexpected ways. Something useful
    to consider here is how Unity loads assets when loading a scene, which consists
    of loading all assets referenced in the scene at load time. This means that you
    can have, as an example, an array of prefabs that have references to materials
    that have references to textures, and even if you don't instantiate a single instance
    of them, the prefabs must be loaded in memory, causing them to occupy space. In
    this scenario, I recommend that you explore the use of addressables, which provide
    a way to load assets dynamically. But let's keep things simple for now.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于内存分析器是一个包，其用户界面可能经常发生变化，但其基本思想将保持不变。您可以使用此工具来检测是否以意外的方式使用内存。在这里需要考虑的一个有用的事情是Unity在加载场景时加载资产的方式，这包括在加载时加载场景中引用的所有资产。这意味着您可以有一个例如，具有对材质的引用的预制体数组，甚至如果您不实例化它们的任何实例，预制体也必须在内存中加载，导致它们占用空间。在这种情况下，我建议您探索地址可寻址性的使用，它提供了一种动态加载资产的方式。但现在让我们保持简单。
- en: You can do more with the profiler, such as access a list view of all objects
    and observe every field of it and its references to see which objects are using
    it (from the main menu, go to **TreeMap** | **Table** | **All objects**), but
    for beginners, I found that view a little bit confusing. A good alternative to
    the Memory Profiler reference navigation system is using the Memory module of
    the profiler. This is a basic version of the Memory Profiler that won't show you
    the memory with a nice tree view or in the amount of detail that the Memory Profiler
    can provide, but provides a simpler version of a reference navigator, which can
    be enough most of the time.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过性能分析器做更多事情，例如访问所有对象的列表视图，并观察每个对象的每个字段及其引用，以查看使用它的对象（从主菜单，转到TreeMap | Table
    | All objects），但对于初学者来说，我发现那个视图有点混乱。内存分析器引用导航系统的一个很好的替代方案是使用性能分析器的内存模块。这是内存分析器的基本版本，不会向您显示带有良好树状视图的内存，也不会提供内存分析器可以提供的详细信息，但提供了一个更简单的引用导航器版本，这在大多数情况下已经足够了。
- en: 'To use it, do the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，请执行以下操作：
- en: Open the profiler (**Window** | **Analysis** | **Profiler**).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开性能分析器（窗口 | 分析 | 性能分析器）。
- en: While in play mode, scroll down through the list of profiler modules and select
    **Memory**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在播放模式下，通过性能分析器模块列表向下滚动，并选择内存。
- en: With the **Gather object references** toggle turned on, click on **Take Sample
    Playmode**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Gather object references切换打开的情况下，单击Take Sample Playmode。
- en: 'Explore the list that pops up, open the categories, and select an asset. In
    the following screenshot, you can see that I have selected the texture and on
    the right panel, I can explore the references. This texture is used by a material
    named base color, which is referenced by a mesh renderer in a GameObject called
    `floor_1_LOD0`. You can even click on an item in the reference list to highlight
    the referencer object:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索弹出的列表，打开类别并选择一个资产。在下面的屏幕截图中，您可以看到我已经选择了纹理，并且在右侧面板上，我可以探索引用。这个纹理被一个名为base color的材质使用，该材质被一个名为floor_1_LOD0的GameObject中的网格渲染器引用。您甚至可以单击引用列表中的项目以突出显示引用对象：
- en: '![Figure 19.37 – Reference list'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.37 - 参考列表'
- en: '](img/Figure_19.37_B14199.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.37_B14199.jpg)'
- en: Figure 19.37 – Reference list
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.37 - 参考列表
- en: As you can see, both the Memory Profiler and the Memory module in the profiler
    do similar things. They can take snapshots of memory for you to analyze them.
    I believe that with time, Unity will unify those tools, but for now, use one or
    the other based on their strong and weak points, such as the ability of the Memory
    Profiler to compare two snapshots to analyze differences, or its ability to explore
    low-level data of the memory, such as seeing which managed object is using which
    native object (which is pretty advanced and most times unnecessary). You can use
    the Memory module to analyze references to see which object is using which texture
    and why.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，内存分析器和分析器中的内存模块做了类似的事情。它们可以为您拍摄内存快照以供分析。我相信随着时间的推移，Unity将统一这些工具，但目前，根据它们的优势和劣势，例如内存分析器比较两个快照以分析差异的能力，或者探索内存的低级数据的能力，比如查看哪个托管对象正在使用哪个本机对象（这是相当高级的，大多数情况下是不必要的）。您可以使用内存模块来分析引用，查看哪个对象正在使用哪个纹理以及原因。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Optimizing a game is not an easy task, especially if you are not familiar with
    the internals of how each Unity system works. Sadly, this is a Titanic task and
    no one knows every single system in its finest details, but with the tools learned
    in this chapter, we have a way to explore how changes affect systems through exploration.
    We learned how to profile the CPU, GPU, and RAM and what the key hardware in any
    game is, and also covered some common good practices to avoid abusing them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 优化游戏并不是一项容易的任务，特别是如果您不熟悉每个Unity系统的内部工作原理。遗憾的是，这是一项艰巨的任务，没有人知道每个系统的细节，但是通过本章学习的工具，我们有一种方法通过探索来探索变化如何影响系统。我们学会了如何对CPU、GPU和RAM进行分析，以及任何游戏中关键硬件是什么，并且涵盖了一些常见的良好实践方法，以避免滥用它们。
- en: Now you are able to diagnose performance issues in your game, gathering data
    about the performance of the three main pieces of hardware—the CPU, GPU, and RAM—and
    then use that data to focus your optimization efforts into applying the correct
    optimization technique. Performance is important as your game needs to run smoothly
    to give your users a pleasant experience.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以诊断游戏中的性能问题，收集关于三个主要硬件部件（CPU、GPU和RAM）性能的数据，然后利用这些数据来集中优化工作，应用正确的优化技术。性能很重要，因为您的游戏需要顺畅运行，给用户带来愉快的体验。
- en: In the next chapter, we are going to see how to create a build of our game to
    share with other people without needing to install Unity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何创建我们游戏的构建版本，与其他人分享，而无需安装Unity。
