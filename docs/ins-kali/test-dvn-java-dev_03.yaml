- en: Red-Green-Refactor – From Failure Through Success until Perfection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红绿重构——从失败到成功直至完美
- en: '"Knowing is not enough; we must apply. Willing is not enough; we must do."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “知道不足以;我们必须应用。愿意不足以;我们必须去做。”
- en: – Bruce Lee
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 李小龙'
- en: The **Red-Green-Refactor** technique is the basis of **test-driven development**
    (**TDD**). It is a game of ping pong in which we are switching between tests and
    implementation code at great speed. We'll fail, then we'll succeed, and, finally,
    we'll improve.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**红绿重构**技术是**测试驱动开发**（**TDD**）的基础。这是一个乒乓球游戏，在这个游戏中，我们以很快的速度在测试和实现代码之间切换。我们会失败，然后我们会成功，最后，我们会改进。'
- en: We'll develop a Tic-Tac-Toe game by going through each requirement one at a
    time. We'll write a test and see if it fails. Then, we'll write code that implements
    that test, run all the tests, and see them succeed. Finally, we'll refactor the
    code and try to make it better. This process will be repeated many times until
    all the requirements are successfully implemented.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过逐个满足每个需求来开发一个井字棋游戏。我们将编写一个测试并查看是否失败。然后，我们将编写实现该测试的代码，运行所有测试，并看到它们成功。最后，我们将重构代码并尝试使其更好。这个过程将重复多次，直到所有需求都成功实现。
- en: We'll start by setting up the environment with Gradle and JUnit. Then, we'll
    go a bit deeper into the Red-Green-Refactor process. Once we're ready with the
    setup and theory, we'll go through the high-level requirements of the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用Gradle和JUnit设置环境开始。然后，我们将深入了解红绿重构过程。一旦我们准备好设置和理论，我们将通过应用的高级需求。
- en: With everything set, we'll dive right into the code—one requirement at a time.
    Once everything is done, we'll take a look at the code coverage and decide whether
    it is acceptable or whether more tests need to be added.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们将立即进入代码——逐个需求。一切都完成后，我们将查看代码覆盖率，并决定是否可以接受，或者是否需要添加更多测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the environment with Gradle and JUnit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle和JUnit设置环境
- en: The Red-Green-Refactor process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红绿重构过程
- en: Tic-Tac-Toe's requirements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 井字棋的需求
- en: Developing Tic-Tac-Toe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发井字棋
- en: Code coverage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: More exercises
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多练习
- en: Setting up the environment with Gradle and JUnit
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle和JUnit设置环境
- en: You are probably familiar with the setup of Java projects. However, you might
    not have worked with IntelliJ IDEA before or you might have used Maven instead
    of Gradle. In order to make sure that you can follow the exercise, we'll quickly
    go through the setup.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉Java项目的设置。但是，您可能以前没有使用过IntelliJ IDEA，或者您可能使用的是Maven而不是Gradle。为了确保您能够跟上练习，我们将快速浏览一下设置。
- en: Setting up Gradle/Java project in IntelliJ IDEA
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IntelliJ IDEA中设置Gradle/Java项目
- en: The main purpose of this book is to teach TDD, so we will not go into detail
    about Gradle and IntelliJ IDEA. Both are used as an example. All exercises in
    this book can be done with different choices for IDE and build tools. You can,
    for example, use Maven and Eclipse instead. For most, it might be easier to follow
    the same guidelines as those presented throughout the book, but the choice is
    yours.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目的是教授TDD，因此我们不会详细介绍Gradle和IntelliJ IDEA。两者都是作为示例使用的。本书中的所有练习都可以使用不同的IDE和构建工具来完成。例如，您可以使用Maven和Eclipse。对于大多数人来说，遵循本书中提出的相同指南可能更容易，但选择权在您手中。
- en: 'The following steps will create a new Gradle project in IntelliJ IDEA:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将在IntelliJ IDEA中创建一个新的Gradle项目：
- en: Open IntelliJ IDEA. Click on Create New Project and select Gradle from the left-hand
    side menu. Then, click on Next.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IntelliJ IDEA。单击创建新项目，然后从左侧菜单中选择Gradle。然后，单击下一步。
- en: 'If you are using IDEA 14 and higher, you will be asked for an Artifact ID.
    Type `tdd-java-ch03-tic-tac-toe` and click on Next twice. Type `tdd-java-ch03-tic-tac-toe`
    as the project name. Then, click on the Finish button:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是IDEA 14及更高版本，则会要求您输入Artifact ID。键入`tdd-java-ch03-tic-tac-toe`，然后单击两次“下一步”。将`tdd-java-ch03-tic-tac-toe`输入为项目名称。然后，单击“完成”按钮：
- en: '![](img/5fd91dbe-7381-43e8-a2c3-c64d6b955ea6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fd91dbe-7381-43e8-a2c3-c64d6b955ea6.png)'
- en: In the New Project dialog, we can observe that IDEA has already created the
    `build.gradle` file. Open it and you'll see that it already contains the JUnit
    dependency. Since this is our framework of choice in this chapter, there is no
    additional configuration that we should do. By default, `build.gradle` is set
    to use Java 1.5 as a source compatibility setting. You can change it to any version
    you prefer. The examples in this chapter will not use any of the Java features
    that came after Version 5, but that doesn't mean that you cannot solve the exercise
    using, for example, JDK 8.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目对话框中，我们可以观察到IDEA已经创建了`build.gradle`文件。打开它，你会看到它已经包含了JUnit依赖项。由于这是本章中我们选择的框架，因此我们不需要进行额外的配置。默认情况下，`build.gradle`设置为使用Java
    1.5作为源兼容性设置。您可以将其更改为任何您喜欢的版本。本章的示例不会使用Java 5版本之后的任何功能，但这并不意味着您不能使用其他版本，例如JDK 8来解决练习。
- en: 'Our `build.gradle` file should look like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`build.gradle`文件应该如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, all that's left to do is to create packages that we'll use for tests and
    the implementation. From the Project dialog, right-click to bring up the Context
    menu and select New|Directory. Type `src/test/java/com/packtpublishing/tddjava/ch03tictactoe`
    and click on the OK button to create the tests package. Repeat the same steps
    with the `src/main/java/com/packtpublishing/tddjava/ch03tictactoe` directory to
    create the implementation package.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是创建我们将用于测试和实现的包。从项目对话框中，右键单击以弹出上下文菜单，然后选择New|Directory。键入`src/test/java/com/packtpublishing/tddjava/ch03tictactoe`，然后单击“确定”按钮以创建测试包。重复相同的步骤，使用`src/main/java/com/packtpublishing/tddjava/ch03tictactoe`目录创建实现包。
- en: Finally, we need to the make test and implementation classes. Create the `TicTacToeSpec`
    class inside the `com.packtpublishing.tddjava.ch03tictactoe` package in the `src/test/java`
    directory. This class will contain all our tests. Repeat the same for the `TicTacToe`
    class in the `src/main/java` directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建测试和实现类。在`src/test/java`目录中的`com.packtpublishing.tddjava.ch03tictactoe`包内创建`TicTacToeSpec`类。这个类将包含所有我们的测试。在`src/main/java`目录中的`TicTacToe`类中重复相同的操作。
- en: 'Your Project structure should be similar to the one presented in the following
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目结构应该类似于以下截图中呈现的结构：
- en: '![](img/862be672-6457-43c7-b2e0-bad2d7b0925b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/862be672-6457-43c7-b2e0-bad2d7b0925b.png)'
- en: The source code can be found in the `00-setup` branch of the `tdd-java-ch03-tic-tac-toe`
    Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/00-setup](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/00-setup).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`00-setup`分支的`tdd-java-ch03-tic-tac-toe` Git存储库中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/00-setup](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/00-setup)。
- en: Always separate tests from the implementation code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将测试与实现代码分开。
- en: 'The benefits are as follows: this avoids accidentally packaging tests together
    with production binaries; many build tools expect tests to be in a certain source
    directory.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好处如下：这样可以避免意外地将测试与生产二进制文件打包在一起；许多构建工具期望测试位于特定的源目录中。
- en: A common practice is to have at least two source directories. The implementation
    code should be located in `src/main/java` and the test code in `src/test/java`.
    In bigger projects, the number of source directories can increase, but the separation
    between implementation and tests should remain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的做法是至少有两个源目录。实现代码应该位于`src/main/java`，测试代码位于`src/test/java`。在更大的项目中，源目录的数量可能会增加，但实现和测试之间的分离应该保持不变。
- en: Build tools such as Maven and Gradle expect source directories, separation,
    as well as naming conventions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Maven和Gradle等构建工具期望源目录、分离以及命名约定。
- en: That's it. We're set to start working on our Tic-Tac-Toe application using JUnit
    as the testing framework of choice and Gradle for compilation, dependencies, testing,
    and other tasks. In [Chapter 1](b6de418b-e05d-4d6a-a0cf-918aa5dea4c1.xhtml), *Why
    Should I Care for Test-Driven Development?*, you first encountered the Red-Green-Refactor
    procedure. Since it is the cornerstone of TDD and is the main objective of the
    exercise in this chapter, it might be a good idea to go into a bit more detail
    before we start the development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们准备使用JUnit作为首选的测试框架，使用Gradle进行编译、依赖、测试和其他任务，开始开发我们的井字游戏应用程序。在[第1章](b6de418b-e05d-4d6a-a0cf-918aa5dea4c1.xhtml)中，*为什么我应该关心测试驱动开发？*，你首次遇到了红-绿-重构过程。由于它是TDD的基石，并且是本章练习的主要目标，可能是一个好主意在开始开发之前更详细地了解一下。
- en: The Red-Green-Refactor process
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红-绿-重构过程
- en: The Red-Green-Refactor process is the most important part of TDD. It is the
    main pillar, without which no other aspect of TDD will work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 红-绿-重构过程是TDD的最重要部分。这是主要支柱，没有它，TDD的其他方面都无法运行。
- en: The name comes from the states our code is in within the cycle. When in the
    red state, code does not work; when in the green state, everything is working
    as expected, but not necessarily in the best possible way. Refactor is the phase
    when we know that features are well covered with tests and thus gives us the confidence
    to change it and make it better.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 名称来自于代码在循环中所处的状态。在红色状态下，代码不起作用；在绿色状态下，一切都按预期工作，但不一定是最佳方式。重构是一个阶段，我们知道功能已经得到了充分的测试覆盖，因此我们有信心对其进行更改并使其更好。
- en: Writing a test
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: Every new feature starts with a test. The main objective of this test is to
    focus on requirements and code design before writing the code. A test is a form
    of an executable documentation and can be used later on to get an understanding
    of what the code does or what are the intentions behind it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新功能都以测试开始。这个测试的主要目标是在编写代码之前专注于需求和代码设计。测试是一种可执行文档，以后可以用来理解代码的功能或意图。
- en: At this point, we are in the red state since the execution of tests fails. There
    is a discrepancy between what tests expect from the code and what the implementation
    code actually does. To be more specific, there is no code that fulfills the expectation
    of the last test; we haven't written it yet. It is possible that at this stage
    all the tests are actually passing, but that's the sign of a problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们处于红色状态，因为测试执行失败。测试对代码的期望与实现代码实际执行的不一致。更具体地说，没有代码满足最后一个测试的期望；我们还没有编写它。在这个阶段，所有测试实际上都通过了，但这是一个问题的迹象。
- en: Running all the tests and confirming that the last one is failing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行所有测试，并确认最后一个测试失败
- en: Confirming that the last test is failing, confirms that the test would not,
    mistakenly, pass without the introduction of a new code. If the test is passing,
    then the feature already exists or the test is producing a false positive. If
    that's the case and the test actually always passes independently of the implementation,
    it is, in itself, worthless and should be removed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 确认最后一个测试失败，确认测试不会误以为没有引入新代码而通过。如果测试通过，那么该功能已经存在，或者测试产生了错误的积极结果。如果是这种情况，测试实际上总是独立于实现而通过，那么它本身是毫无价值的，应该被移除。
- en: A test must not only fail, but must fail for the expected reason. In this phase,
    we are still in the red stage. Tests were run and the last one failed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不仅必须失败，而且必须因为预期的原因而失败。在这个阶段，我们仍然处于红色阶段。测试已经运行，最后一个测试失败了。
- en: Writing the implementation code
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写实现代码
- en: The purpose of this phase is to write code that will make the last test pass.
    Do not try to make it perfect, nor try to spend too much time with it. If it's
    not well-written or is not optimum, that is still okay. It'll become better later
    on. What we're really trying to do is to create a safety net in the form of tests
    that are confirmed to pass. Do not try to introduce any functionality that was
    not described in the last test. To do that, we are required to go back to the
    first step and start with a new test. However, we should not write new tests until
    all the existing ones are passing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的目的是编写代码，使最后一个测试通过。不要试图让它完美，也不要花太多时间。如果它写得不好或者不是最佳的，那也没关系。以后会变得更好。我们真正想做的是创建一种以测试形式确认通过的安全网。不要试图引入任何上一个测试中没有描述的功能。要做到这一点，我们需要回到第一步，从新的测试开始。然而，在所有现有测试都通过之前，我们不应该编写新的测试。
- en: In this phase, we are still in the red stage. While the code that was written
    would probably pass all the tests, that assumption is not yet confirmed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们仍处于红色阶段。虽然编写的代码可能会通过所有测试，但这个假设尚未得到确认。
- en: Running all the tests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: It is very important that all the tests are run and not only the last test that
    was written. The code that we just wrote might have made the last test pass while
    breaking something else. Running all the tests confirms not only that the implementation
    of the last test is correct, but also that it did not break the integrity of the
    application as a whole. This slow execution of the whole test suite is a sign
    of poorly written tests or having too much coupling in the code. Coupling prevents
    the easy isolation of external dependencies, thus increasing the time required
    for the execution of tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是运行所有的测试，而不仅仅是最后编写的测试。我们刚刚编写的代码可能使最后一个测试通过，同时破坏了其他东西。运行所有的测试不仅确认了最后一个测试的实现是正确的，而且确认了它没有破坏整个应用程序的完整性。整个测试套件的缓慢执行表明测试编写不好或者代码耦合度太高。耦合阻止了外部依赖的轻松隔离，从而增加了测试执行所需的时间。
- en: In this phase, we are in the green state. All the tests are passing and the
    application behaves as we expect it to behave.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们处于绿色状态。所有的测试都通过了，应用程序的行为符合我们的预期。
- en: Refactoring
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: While all the previous steps are mandatory, this one is optional. Even though
    refactoring is rarely done at the end of each cycle, sooner or later it will be
    desired, if not mandatory. Not every implementation of a test requires refactoring.
    There is no rule that tells you when to refactor and when not to. The best time
    is as soon as one gets a feeling that the code can be rewritten in a better or
    more optimum way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有之前的步骤都是强制性的，但这一步是可选的。尽管重构很少在每个周期结束时进行，但迟早会被期望，如果不是强制的。并不是每个测试的实现都需要重构。没有规则告诉你何时重构何时不重构。最佳时间是一旦有一种感觉，代码可以以更好或更优的方式重写时。
- en: What constitutes a candidate for refactoring? This is a hard question to answer
    since it can have many answers—it's hard to understand code, the illogical location
    of a piece of code, duplication, names that do not clearly state a purpose, long
    methods, classes that do too many things, and so on. The list can go on and on.
    No matter what the reasons are, the most important rule is that refactoring cannot
    change any existing functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 什么构成重构的候选？这是一个难以回答的问题，因为它可能有很多答案——难以理解的代码、代码片段的不合理位置、重复、名称不清晰的目的、长方法、做太多事情的类等等。列表可以继续下去。无论原因是什么，最重要的规则是重构不能改变任何现有功能。
- en: Repeating
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复
- en: Once all the steps (with refactor being optional) are finished, we repeat them.
    At first glance, the whole process might seem too long or too complicated, but
    it is not. Experienced TDD practitioners write one to ten lines of code before
    switching to the next step. The whole cycle should last anything between a couple
    of seconds and no more than a few minutes. If it takes more than that, the scope
    of a test is too big and should be split into smaller chunks. Be fast, fail fast,
    correct, and repeat.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有步骤（重构是可选的）完成，我们就重复它们。乍一看，整个过程可能看起来太长或太复杂，但实际上并不是。有经验的TDD从业者在切换到下一步之前写一到十行代码。整个周期应该持续几秒钟到几分钟。如果时间超过这个范围，测试的范围就太大，应该分成更小的块。快速失败，纠正，重复。
- en: With this knowledge in mind, let us go through the requirements of the application
    we're about to develop using the Red-Green-Refactor process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，让我们通过使用红-绿-重构过程开发的应用程序的要求。
- en: Tic-Tac-Toe game requirements
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字游戏要求
- en: Tic-Tac-Toe is most often played by young children. The rules of the game are
    fairly simple.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 井字游戏通常由年幼的孩子玩。游戏规则相当简单。
- en: Tic-Tac-Toe is a paper-and-pencil game for two players, *X* and *O*, who take
    turns marking the spaces in a 3×3 grid. The player who succeeds in placing three
    respective marks in a horizontal, vertical, or diagonal row, wins the game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 井字游戏是一种纸笔游戏，供两名玩家*X*和*O*轮流在3×3的网格中标记空格。成功在水平、垂直或对角线上放置三个相应标记的玩家获胜。
- en: For more information about the game, please visit Wikipedia ([http://en.wikipedia.org/wiki/Tic-tac-toe](http://en.wikipedia.org/wiki/Tic-tac-toe)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关游戏的更多信息，请访问维基百科（[http://en.wikipedia.org/wiki/Tic-tac-toe](http://en.wikipedia.org/wiki/Tic-tac-toe)）。
- en: More detailed requirements will be presented later on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的要求将在以后提出。
- en: The exercise consists of the creation of a single test that corresponds to one
    of the requirements. The test is followed by the code that fulfills the expectations
    of that test. Finally, if needed, the code is refactored. The same procedure should
    be repeated with more tests related to the same requirement. Once we're satisfied
    with tests and the implementation of that requirement, we'll move to the next
    one until they're all done.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习包括创建一个与需求相对应的单个测试。测试后面是满足该测试期望的代码。最后，如果需要，对代码进行重构。应该重复相同的过程，直到满意为止，然后转移到下一个需求，直到所有需求都完成。
- en: In real-world situations, you wouldn't get such detailed requirements, but dive
    right into tests that would act as both requirements and validation. However,
    until you get comfortable with TDD, we'll have to define requirements separately
    from tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的情况下，您不会得到如此详细的要求，但是可以直接进行既是要求又是验证的测试。然而，在您熟悉TDD之前，我们必须将需求与测试分开定义。
- en: Even though all the tests and the implementation are provided, try to read only
    one requirement at a time and write tests and implementation code yourself. Once
    done, compare your solution with the one from this book and move to the next requirement.
    There is no one and only one solution; yours might be better than the ones presented
    here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有的测试和实现都已经提供，但请一次只阅读一个需求，并自己编写测试和实现代码。完成后，将您的解决方案与本书中的解决方案进行比较，然后转到下一个需求。没有唯一的解决方案；您的解决方案可能比这里提供的更好。
- en: Developing Tic-Tac-Toe
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发井字棋
- en: Are you ready to code? Let's start with the first requirement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您准备好编码了吗？让我们从第一个需求开始。
- en: Requirement 1 – placing pieces
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求1-放置棋子
- en: We should start by defining the boundaries and what constitutes an invalid placement
    of a piece.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先定义边界和什么构成了一个棋子的无效放置。
- en: A piece can be placed on any empty space of a 3×3 board.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个棋子可以放在3×3棋盘的任何空位上。
- en: 'We can split this requirement into three tests:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个需求分成三个测试：
- en: When a piece is placed anywhere outside the *x*-axis, then `RuntimeException`
    is thrown
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个棋子被放置在*x*轴之外的任何地方，就会抛出`RuntimeException`
- en: When a piece is placed anywhere outside the *y*-axis, then `RuntimeException`
    is thrown
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个棋子被放置在*y*轴之外的任何地方，就会抛出`RuntimeException`
- en: When a piece is placed on an occupied space, then `RuntimeException` is thrown
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个棋子被放在一个已占用的空间上时，就会抛出`RuntimeException`
- en: As you can see, the tests related to this first requirement are all about validations
    of the input argument. There is nothing in the requirements that says what should
    be done with those pieces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，与第一个需求相关的测试都是关于验证输入参数的。在需求中没有提到应该对这些棋子做什么。
- en: Before we proceed with the first test, a brief explanation of how to test exceptions
    with JUnit is in order.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行第一个测试之前，有必要简要解释一下如何使用JUnit测试异常。
- en: 'Starting from Release 4.7, JUnit introduced a feature called `Rule`. It can
    be used to do many different things (more information can be found at [https://github.com/junit-team/junit/wiki/Rules](https://github.com/junit-team/junit/wiki/Rules)),
    but in our case we''re interested in the `ExpectedException` rule:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.7版本开始，JUnit引入了一个名为`Rule`的功能。它可以用于执行许多不同的操作（更多信息可以在[https://github.com/junit-team/junit/wiki/Rules](https://github.com/junit-team/junit/wiki/Rules)找到），但在我们的情况下，我们对`ExpectedException`规则感兴趣：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we defined that the `ExpectedException` is a rule. Later on,
    in the `doFooThrowsRuntimeException` test, we're specifying that we are expecting
    the `RuntimeException` to be thrown after the `Foo` class is instantiated. If
    it is thrown before, the test will fail. If the exception is thrown after, the
    test is successful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了`ExpectedException`是一个规则。稍后在`doFooThrowsRuntimeException`测试中，我们指定我们期望在`Foo`类实例化后抛出`RuntimeException`。如果在之前抛出，测试将失败。如果在之后抛出，测试就成功了。
- en: '`@Before` can be used to annotate a method that should be run before each test.
    It is a very useful feature with which we can, for example, instantiate a class
    used in tests or perform some other types of actions that should be run before
    each test:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before`可以用来注释一个在每个测试之前运行的方法。这是一个非常有用的功能，例如我们可以实例化一个在测试中使用的类，或者执行一些其他类型的在每个测试之前运行的操作：'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `Foo` class will be instantiated before each test. This
    way, we can avoid having repetitive code that would instantiate `Foo` inside each
    test method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Foo`类将在每个测试之前实例化。这样，我们就可以避免在每个测试方法中实例化`Foo`的重复代码。
- en: 'Each test should be annotated with `@Test`. This tells `JunitRunner` which
    methods constitute tests. Each of them will be run in a random order so make sure
    that each test is self-sufficient and does not depend on the state that might
    be created by other tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都应该用`@Test`进行注释。这告诉`JunitRunner`哪些方法构成测试。它们中的每一个都将以随机顺序运行，所以确保每个测试都是自给自足的，并且不依赖于其他测试可能创建的状态：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this knowledge, you should be able to write your first test and follow
    it with the implementation. Once done, compare it with the solution provided.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，您应该能够编写您的第一个测试，并跟随着实现。完成后，将其与提供的解决方案进行比较。
- en: Use descriptive names for test methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为测试方法使用描述性的名称。
- en: One of the benefits is that it helps to understand the objective of tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个好处是它有助于理解测试的目标。
- en: Using method names that describe tests is beneficial when trying to figure out
    why some tests failed or when the coverage should be increased with more tests.
    It should be clear what conditions are set before the test, what actions are performed,
    and what the expected outcome is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试弄清楚为什么一些测试失败或者测试覆盖率应该增加更多测试时，使用描述测试的方法名称是有益的。在测试之前应该清楚地设置条件，执行什么操作，以及预期的结果是什么。
- en: There are many different ways to name test methods. My preferred method is to
    name them using the given/when/then syntax used in BDD scenarios. `Given` describes
    (pre)conditions, `When` describes actions, and `Then` describes the expected outcome.
    If a test does not have preconditions (usually set using the `@Before` and `@BeforeClass`
    annotations), `Given` can be skipped.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来命名测试方法。我偏好的方法是使用BDD场景中使用的给定/当/那么语法来命名它们。`给定`描述（前）条件，`当`描述动作，`那么`描述预期结果。如果一个测试没有前提条件（通常使用`@Before`和`@BeforeClass`注解设置），`给定`可以被省略。
- en: Do not rely only on comments to provide information about test objectives. Comments
    do not appear when tests are executed from your favorite IDE, nor do they appear
    in reports generated by the CI or build tools.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅依靠注释提供有关测试目标的信息。注释在从您喜爱的IDE执行测试时不会出现，也不会出现在CI或构建工具生成的报告中。
- en: 'Besides writing tests, you''ll need to run them as well. Since we are using
    Gradle, they can be run from the command prompt:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写测试，你还需要运行它们。由于我们使用Gradle，它们可以从命令提示符中运行：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: IntelliJ IDEA provides a very good Gradle tasks model that can be reached by
    clicking on View|Tool Windows|Gradle. It lists all the tasks that can be run with
    Gradle (`test` being one of them).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA提供了一个非常好的Gradle任务模型，可以通过点击View|Tool Windows|Gradle来访问。它列出了所有可以使用Gradle运行的任务（其中之一就是`test`）。
- en: The choice is yours—you can run tests in any way you see fit, as long as you
    run all of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你手中-你可以以任何你认为合适的方式运行测试，只要你运行所有测试。
- en: Test – board boundaries I
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试-板边界I
- en: 'We should start by checking whether a piece is placed within the boundaries
    of the 3x3 board:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先检查一个棋子是否放在3x3棋盘的边界内：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When a piece is placed anywhere outside the *x*-axis, then `RuntimeException`
    is thrown.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个棋子被放置在*x*轴之外的任何地方时，会抛出`RuntimeException`。
- en: In this test, we are defining that `RuntimeException` is expected when the `ticTacToe.play(5,
    2)` method is invoked. It's a very short and easy test, and making it pass should
    be easy as well. All we have to do is create the `play` method and make sure that
    it throws `RuntimeException` when the `x` argument is smaller than 1 or bigger
    than 3 (the board is 3x3). You should run this test three times. The first time,
    it should fail because the `play` method doesn't exist. Once it is added, it should
    fail because `RuntimeException` is not thrown. The third time, it should be successful
    because the code that corresponds with this test is fully implemented.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们定义了当调用`ticTacToe.play(5, 2)`方法时，会抛出`RuntimeException`。这是一个非常简短和简单的测试，使其通过也应该很容易。我们所要做的就是创建`play`方法，并确保当`x`参数小于1或大于3（棋盘是3x3）时抛出`RuntimeException`。你应该运行这个测试三次。第一次，它应该失败，因为`play`方法不存在。一旦添加了它，它应该失败，因为没有抛出`RuntimeException`。第三次，它应该成功，因为与这个测试对应的代码已经完全实现。
- en: Implementation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Now that we have a clear definition of when an exception should be thrown,
    the implementation should be straightforward:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们清楚了什么时候应该抛出异常，实现应该很简单：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this code does not contain anything else, but the bare minimum
    required for the test to pass.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这段代码除了让测试通过所需的最低限度之外，没有别的东西。
- en: Some TDD practitioners tend to take minimum as a literal meaning. They would
    have the `play` method with only the `throw new RuntimeException();` line. I tend
    to translate minimum to as little as possible within reason.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些TDD实践者倾向于将最小化理解为字面意义。他们会让`play`方法只有`throw new RuntimeException();`这一行。我倾向于将最小化理解为在合理范围内尽可能少。
- en: We're not adding numbers, nor are we returning anything. It's all about making
    small changes very fast. (Remember the game of ping pong?) For now, we're doing
    red-green steps. There's not much we can do to improve this code so we're skipping
    the refactoring.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不添加数字，也不返回任何东西。这一切都是关于非常快速地进行小的更改。（记住乒乓球游戏吗？）目前，我们正在进行红绿步骤。我们无法做太多来改进这段代码，所以我们跳过了重构。
- en: Let's move on to the next test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行下一个测试。
- en: Test – board boundaries II
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试-板边界II
- en: 'This test is almost the same as the previous one. This time we should validate
    the *y*-axis:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试几乎与上一个测试相同。这次我们应该验证*y*轴：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When a piece is placed anywhere outside the *y*-axis, then `RuntimeException`
    is thrown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个棋子被放置在*y*轴之外的任何地方时，会抛出`RuntimeException`。
- en: Implementation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation of this specification is almost the same as the previous
    one. All we have to do is throw an exception if `y` does not fall within the defined
    range:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范的实现几乎与上一个相同。我们所要做的就是如果`y`不在定义的范围内，则抛出异常：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In order for the last test to pass, we had to add the `else` clause that checks
    whether `Y` is inside the board.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让最后一个测试通过，我们必须添加检查`Y`是否在棋盘内的`else`子句。
- en: Let's do the last test for this requirement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个要求做最后一个测试。
- en: Test – occupied spot
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试-占用的位置
- en: 'Now that we know that pieces are placed within the board''s boundaries, we
    should make sure that they can be placed only on unoccupied spaces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道棋子是放在棋盘边界内的，我们应该确保它们只能放在未占用的空间上：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a piece is placed on an occupied space, then `RuntimeException` is thrown.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个棋子被放在一个已占用的空间上时，会抛出`RuntimeException`。
- en: That's it; this was our last test. Once the implementation is finished, we can
    consider the first requirement as done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；这是我们的最后一个测试。一旦实现完成，我们就可以认为第一个要求已经完成了。
- en: Implementation
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'To implement the last test, we should store the location of the placed pieces
    in an array. Every time a new piece is placed, we should verify that the place
    is not occupied, or else throw an exception:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现最后一个测试，我们应该将放置的棋子的位置存储在一个数组中。每次放置一个新的棋子时，我们应该验证该位置是否被占用，否则抛出异常：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're checking whether a place that was played is occupied and, if it is not,
    we're changing the array entry value from empty (`\0`) to occupied (`X`). Keep
    in mind that we're still not storing who played (`X` or `O`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查所玩的位置是否被占用，如果没有被占用，我们将数组条目值从空（`\0`）更改为占用（`X`）。请记住，我们仍然没有存储是谁玩的（`X`还是`O`）。
- en: Refactoring
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'While the code that we have done so far fulfills the requirements set by the
    tests, it looks a bit confusing. If someone read it, it would not be clear as
    to what the `play` method does. We should refactor it by moving the code into
    separate methods. The refactored code will look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的代码满足了测试设置的要求，但看起来有点混乱。如果有人阅读它，就不清楚`play`方法的作用。我们应该通过将代码移动到单独的方法中来重构它。重构后的代码将如下所示：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this refactoring, we did not change the functionality of the `play` method.
    It behaves exactly the same as it behaved before, but the new code is a bit more
    readable. Since we had tests that covered all the existing functionality, there
    was no fear that we might do something wrong. As long as all tests are passing
    all the time and refactoring did not introduce any new behavior, it is safe to
    make changes to the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种重构，我们没有改变`play`方法的功能。它的行为与以前完全相同，但新代码更易读。由于我们有测试覆盖了所有现有功能，所以不用担心我们可能做错了什么。只要所有测试一直通过，重构没有引入任何新的行为，对代码进行更改就是安全的。
- en: The source code can be found in the `01-exceptions` branch of the `tdd-java-ch03-tic-tac-toe`
    Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/01-exceptions](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/01-exceptions).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`01-exceptions` Git存储库的`tdd-java-ch03-tic-tac-toe`分支中找到[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/01-exceptions](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/01-exceptions)。
- en: Requirement 2 – adding two-player support
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求2-添加双人支持
- en: Now it's time to work on the specification of which player is about to play
    his turn.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始规范哪个玩家即将轮到他出手了。
- en: There should be a way to find out which player should play next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一种方法来找出下一个应该出手的玩家。
- en: 'We can split this requirement into three tests:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个需求分成三个测试：
- en: The first turn should be played by player `X`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一轮应该由玩家`X`来玩
- en: If the last turn was played by `X`, then the next turn should be played by `O`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上一轮是由`X`玩的，那么下一轮应该由`O`玩。
- en: If the last turn was played by `O`, then the next turn should be played by `X`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上一轮是由`O`玩的，那么下一轮应该由`X`玩。
- en: 'Until this moment, we haven''t used any of the JUnit''s asserts. To use them,
    we need to `import` the `static` methods from the `org.junit.Assert` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有使用任何JUnit的断言。要使用它们，我们需要从`org.junit.Assert`类中`import`静态方法：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In their essence, methods inside the `Assert` class are very simple. Most of
    them start with `assert`. For example, `assertEquals` compares two objects—`assertNotEquals`
    verifies that two objects are not the same and `assertArrayEquals` verifies that
    two arrays are the same. Each of those asserts has many overloaded variations
    so that almost any type of Java object can be used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assert`类内部，方法的本质非常简单。它们中的大多数以`assert`开头。例如，`assertEquals`比较两个对象-`assertNotEquals`验证两个对象不相同，`assertArrayEquals`验证两个数组相同。每个断言都有许多重载的变体，以便几乎可以使用任何类型的Java对象。
- en: In our case, we'll need to compare two characters. The first is the one we're
    expecting and the second one is the actual character retrieved from the `nextPlayer`
    method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要比较两个字符。第一个是我们期望的字符，第二个是从`nextPlayer`方法中检索到的实际字符。
- en: Now it's time to write those tests and the implementation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写这些测试和实现了。
- en: Write the test before writing the implementation code .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写实现代码之前编写测试。
- en: The benefits of doing this are as follows—it ensures that testable code is written
    and ensures that every line of code gets tests written for it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处如下-它确保编写可测试的代码，并确保为每一行代码编写测试。
- en: By writing or modifying the test first, the developer is focused on requirements
    before starting to work on a code. This is the main difference when compared to
    writing tests after the implementation is done. An additional benefit is that
    with tests first, we are avoiding the danger that the tests work as quality checking
    instead of quality assurance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过先编写或修改测试，开发人员在开始编写代码之前专注于需求。这是与在实施完成后编写测试相比的主要区别。另一个好处是，有了先验测试，我们避免了测试作为质量检查而不是质量保证的危险。
- en: Test – X plays first
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试- X先玩
- en: 'Player `X` has the first turn:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家`X`有第一轮：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first turn should be played by Player `X`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一轮应该由玩家`X`来玩。
- en: This test should be self-explanatory. We are expecting the `nextPlayer` method
    to return `X`. If you try to run this, you'll see that the code does not even
    compile. That's because the `nextPlayer` method does not even exist. Our job is
    to write the `nextPlayer` method and make sure that it returns the correct value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试应该是不言自明的。我们期望`nextPlayer`方法返回`X`。如果你尝试运行这个测试，你会发现代码甚至无法编译。那是因为`nextPlayer`方法甚至不存在。我们的工作是编写`nextPlayer`方法，并确保它返回正确的值。
- en: Implementation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'There''s no real need to check whether it really is the player''s first turn
    or not. As it stands, this test can be fulfilled by always returning `X`. Later
    tests will force us to refine this code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 没有真正的必要检查是否真的是玩家的第一轮。就目前而言，这个测试可以通过始终返回`X`来实现。稍后的测试将迫使我们完善这段代码：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Test – O plays right after X
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试- O在X之后玩
- en: 'Now, we should make sure that players are changing. After `X` is finished,
    it should be `O`''s turn, then again `X`, and so on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该确保玩家在变化。在`X`完成后，应该轮到`O`，然后再次是`X`，依此类推：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the last turn was played by `X`, then the next turn should be played by `O`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一轮是由`X`玩的，那么下一轮应该由`O`玩。
- en: Implementation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'In order to track who should play next, we need to store who played last:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪谁应该下一步出手，我们需要存储上一次出手的玩家：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You are probably starting to get the hang of it. Tests are small and easy to
    write. With enough experience, it should take a minute, if not seconds, to write
    a test and as much time or less to write the implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能开始掌握了。测试很小，很容易写。有了足够的经验，应该只需要一分钟，甚至几秒钟来编写一个测试，编写实现的时间也不会超过这个时间。
- en: Test – X plays right after O
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试- X在O之后玩
- en: Finally, we can check whether `X`'s turn comes after `O` played.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查`O`下完棋后是否轮到`X`下棋。
- en: If the last turn was played by `O`, then the next turn should be played by `X`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一步是由`O`下的，那么下一步应该由`X`下。
- en: There's nothing to do to fulfill this test and, therefore, the test is useless
    and should be discarded. If you write this test, you'll discover that it is a
    false positive. It would pass without changing the implementation; try it out.
    Write this test and if it is successful without writing any implementation code,
    discard it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么可以做来满足这个测试，因此这个测试是无用的，应该被丢弃。如果你写这个测试，你会发现它是一个错误的阳性。它会在不改变实现的情况下通过；试一下。写下这个测试，如果它成功了而没有写任何实现代码，就把它丢弃。
- en: The source code can be found in the `02-next-player` branch of the `tdd-java-ch03-tic-tac-toe`
    Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/02-next-player](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/02-next-player).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`tdd-java-ch03-tic-tac-toe` Git存储库的`02-next-player`分支中找到[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/02-next-player](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/02-next-player)。
- en: Requirement 3 – adding winning conditions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求3 - 添加获胜条件
- en: It's time to work on winning according to the rules of the game. This is the
    part where, when compared with the previous code, work becomes a bit more tedious.
    We should check all the possible winning combinations and, if one of them is fulfilled,
    declare a winner.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是根据游戏规则来处理获胜的时候了。与之前的代码相比，这部分工作变得有点繁琐。我们应该检查所有可能的获胜组合，如果其中一个被满足，就宣布获胜者。
- en: A player wins by being the first to connect a line of friendly pieces from one
    side or corner of the board to the other.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过首先连接棋盘的一侧或角落到另一侧的友方棋子线来获胜。
- en: To check whether a line of friendly pieces is connected, we should verify horizontal,
    vertical, and diagonal lines.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查友方棋子线是否连接，我们应该验证水平、垂直和对角线。
- en: Test – by default there's no winner
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 默认情况下没有赢家
- en: 'Let''s start by defining the default response of the `play` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义`play`方法的默认响应开始：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If no winning condition is fulfilled, then there is no winner.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有满足获胜条件，那么就没有赢家。
- en: Implementation
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The default return values are always easiest to implement and this one is no
    exception:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认返回值总是最容易实现的，这个也不例外：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Test – winning condition I
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 获胜条件 I
- en: 'Now that we have declared what the default response is (`No winner`), it''s
    time to start working on different winning conditions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了默认响应是“没有赢家”，是时候开始处理不同的获胜条件了：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The player wins when the whole horizontal line is occupied by his pieces.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家赢得比赛当整个水平线被他的棋子占据。
- en: Implementation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'To fulfill this test, we need to check whether any horizontal line is filled
    by the same mark as the current player. Until this moment, we didn''t care what
    was put on the board array. Now, we need to introduce not only which board boxes
    are empty, but also which player played them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个测试，我们需要检查是否有任何水平线被当前玩家的标记填满。直到此刻，我们并不关心棋盘数组上放了什么。现在，我们不仅需要介绍哪些棋盘格子是空的，还需要介绍哪个玩家下的棋：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refactoring
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'The preceding code satisfies the tests, but is not necessarily the final version.
    It served its purpose of getting code coverage as quickly as possible. Now, since
    we have tests that guarantee the integrity of the expected behavior, we can refactor
    the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码满足了测试，但不一定是最终版本。它达到了尽快实现代码覆盖率的目的。现在，既然我们有了测试来保证预期行为的完整性，我们可以重构代码了：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This refactored solution looks better. The `play` method keeps being short and
    easy to understand. Winning logic is moved to a separate method. Not only have
    we kept the `play` method's purpose clear, but this separation also allows us
    to grow the winning condition's code in separation from the rest.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构后的解决方案看起来更好。`play`方法保持简短易懂。获胜逻辑被移动到一个单独的方法中。我们不仅保持了`play`方法的目的清晰，而且这种分离还允许我们将获胜条件的代码与其余部分分开发展。
- en: Test – winning condition II
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 获胜条件 II
- en: 'We should also check whether there is a win by filling the vertical line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该检查是否通过填充垂直线来获胜：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The player wins when the whole vertical line is occupied by his pieces.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家赢得比赛当整个垂直线被他的棋子占据。
- en: Implementation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'This implementation should be similar to the previous one. We already have
    horizontal verification and now we need to do the same vertically:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现应该类似于之前的实现。我们已经有了水平验证，现在我们需要做垂直验证：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Test – winning condition III
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 获胜条件 III
- en: 'Now that horizontal and vertical lines are covered, we should move our attention
    to diagonal combinations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在水平和垂直线都已经覆盖，我们应该把注意力转移到对角线组合上：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The player wins when the whole diagonal line from the top-left to bottom-right
    is occupied by his pieces.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家赢得比赛当整个从左上到右下的对角线被他的棋子占据。
- en: Implementation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Since there is only one line that can constitute with the requirement, we can
    check it directly without any loops:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一条线符合要求，我们可以直接检查它，而不需要任何循环：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Code coverage
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: We did not use code coverage tools throughout this exercise. The reason is that
    we wanted you to be focused on the Red-Green-Refactor model. You wrote a test,
    saw it fail, wrote the implementation code, saw that all the tests were executed
    successfully, refactored the code whenever you saw an opportunity to make it better,
    and then you repeated the process. Did our tests cover all cases? That's something
    that code coverage tools such as JaCoCo can answer. Should you use those tools?
    Probably, only in the beginning. Let me clarify that. When you are starting with
    TDD, you will probably miss some tests or implement more than what the tests defined.
    In those cases, using code coverage is a good way to learn from your own mistakes.
    Later on, the more experienced you become with TDD, the less of a need you'll
    have for such tools. You'll write tests and just enough of the code to make them
    pass. Your coverage will be high with or without tools such as JaCoCo. There will
    be a small amount of code not covered by tests because you'll make a conscious
    decision about what is not worth testing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习过程中，我们没有使用代码覆盖工具。原因是我们希望您专注于红-绿-重构模型。您编写了一个测试，看到它失败，编写了实现代码，看到所有测试都成功执行，然后在看到机会使代码更好时重构了代码，然后重复了这个过程。我们的测试覆盖了所有情况吗？这是JaCoCo等代码覆盖工具可以回答的问题。您应该使用这些工具吗？可能只有在开始时。让我澄清一下。当您开始使用TDD时，您可能会错过一些测试或者实现超出了测试定义的内容。在这些情况下，使用代码覆盖是从自己的错误中学习的好方法。随着您在TDD方面的经验增加，您对这些工具的需求将会减少。您将编写测试，并编写足够的代码使其通过。无论是否使用JaCoCo等工具，您的覆盖率都会很高。由于您会对不值得测试的内容做出有意识的决定，因此只有少量代码不会被测试覆盖。
- en: Tools such as JaCoCo were designed mostly as a way to verify that the tests
    written after the implementation code are providing enough coverage. With TDD,
    we are taking a different approach with the inverted order (tests before the implementation).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如JaCoCo之类的工具主要是作为一种验证实现代码后编写的测试是否提供足够覆盖率的方式。通过TDD，我们采用了不同的方法，即倒置顺序（先编写测试，再实现）。
- en: Still, we suggest you use JaCoCo as a learning tool and decide for yourself
    whether to use it in the future.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们建议您将JaCoCo作为学习工具，并自行决定是否在将来使用它。
- en: 'To enable JaCoCo within Gradle, add the following to `build.gradle`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Gradle中启用JaCoCo，请将以下内容添加到`build.gradle`中：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'From now on, Gradle will collect JaCoCo metrics every time we run tests. Those
    metrics can be transformed into a nice report using the `jacocoTestReport` Gradle
    target. Let''s run our tests again and see what the code coverage is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次运行测试时，Gradle都会收集JaCoCo指标。这些指标可以使用`jacocoTestReport` Gradle目标转换为漂亮的报告。让我们再次运行测试，看看代码覆盖率是多少：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The end result is the report located in the `build/reports/jacoco/test/html`
    directory. Results will vary depending on the solution you made for this exercise.
    My results say that there is a 100% of instructions coverage and 96% of branches
    coverage; 4% is missing because there was no test case where the player played
    on a box 0 or negative. The implementation of that case is there, but there is
    no specific test that covers it. Overall, this is a pretty good coverage:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是报告位于`build/reports/jacoco/test/html`目录中。结果将取决于您为此练习制定的解决方案。我的结果显示指令覆盖率为100%，分支覆盖率为96%；缺少4%是因为没有测试案例中玩家在0或负数的方框上下棋。该情况的实现已经存在，但没有特定的测试覆盖它。总的来说，这是一个相当不错的覆盖率。
- en: '![](img/ad410f3d-0ec5-4109-a35a-0e9ca579d7d7.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad410f3d-0ec5-4109-a35a-0e9ca579d7d7.png)'
- en: JaCoCo will be added in the source code. This is found in the `05-jacoco` branch
    of the `tdd-java-ch03-tic-tac-toe` Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/05-jacoco](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/05-jacoco).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JaCoCo将被添加到源代码中。这可以在`05-jacoco`分支的` tdd-java-ch03-tic-tac-toe` Git存储库中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/05-jacoco](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/05-jacoco)。
- en: Test – winning condition IV
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 获胜条件IV
- en: 'Finally, there is the last possible winning condition to tackle:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有最后一个可能的获胜条件要解决：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The player wins when the whole diagonal line from the bottom-left to top-right
    is occupied by his pieces.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当整个对角线从左下到右上的线被玩家的棋子占据时，玩家获胜。
- en: Implementation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'The implementation of this test should be almost the same as the previous one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的实现应该几乎与上一个相同：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Refactoring
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'The way we''re handling possible diagonal wins, the calculation doesn''t look
    right. Maybe the reutilization of the existing loop would make more sense:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理可能的对角线获胜的方式，计算看起来不对。也许重新利用现有的循环会更有意义：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The source code can be found in the `03-wins` branch of the `tdd-java-ch03-tic-tac-toe`
    Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/03-wins](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/03-wins).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在` tdd-java-ch03-tic-tac-toe` Git存储库的`03-wins`分支中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/03-wins](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/03-wins)。
- en: Now, let's go through the last requirement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看最后一个要求。
- en: Requirement 4 – tie conditions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求4 - 平局条件
- en: The only thing missing is how to tackle the draw result.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的是如何处理平局结果。
- en: The result is a draw when all the boxes are filled.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有方框都填满时，结果是平局。
- en: Test – handling a tie situation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 - 处理平局情况
- en: 'We can test the draw result by filling all the board''s boxes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过填满棋盘上的所有方框来测试平局结果：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Implementation
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'Checking whether it''s a draw is fairly straightforward. All we have to do
    is check whether all the board''s boxes are filled. We can do that by iterating
    through the board array:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否为平局非常简单。我们只需要检查棋盘上的所有方框是否都填满了。我们可以通过遍历棋盘数组来做到这一点：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Refactoring
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'Even though the `isWin` method is not the scope of the last test, it can still
    be refactored even more. For once, we don''t need to check all the combinations,
    but only those related to the position of the last piece played. The final version
    could look like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`isWin`方法不是最后一个测试的范围，但它仍然可以进行更多的重构。首先，我们不需要检查所有的组合，而只需要检查与最后一个放置的棋子位置相关的组合。最终版本可能如下所示：
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Refactoring can be done on any part of the code at any time, as long as all
    the tests are successful. While it's often easiest and fastest to refactor the
    code that was just written, going back to something that was written the other
    day, previous month, or even years ago, is more than welcome. The best time to
    refactor something is when someone sees an opportunity to make it better. It doesn't
    matter who wrote it or when; making the code better is always a good thing to
    do.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重构可以在任何时候的代码的任何部分进行，只要所有测试都成功。虽然通常最容易和最快的是重构刚刚编写的代码，但是回到前天、上个月甚至几年前编写的代码也是非常受欢迎的。重构的最佳时机是当有人看到使其更好的机会时。不管是谁编写的或者何时编写的，使代码更好总是一件好事。
- en: The source code can be found in the `04-draw` branch of the `tdd-java-ch03-tic-tac-toe`
    Git repository at [https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/04-draw](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/04-draw).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在`04-draw` Git存储库的`tdd-java-ch03-tic-tac-toe`分支中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/04-draw](https://bitbucket.org/vfarcic/tdd-java-ch03-tic-tac-toe/branch/04-draw)。
- en: More exercises
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多练习
- en: We just developed one (most commonly used) variation of the Tic-Tac-Toe game.
    As an additional exercise, pick one or more variations from Wikipedia ([http://en.wikipedia.org/wiki/Tic-tac-toe](http://en.wikipedia.org/wiki/Tic-tac-toe))
    and implement it using the Red-Green-Refactor procedure. When finished, implement
    a kind of AI that would play `O`'s turns. Since Tic-Tac-Toe usually leads to a
    draw, AI can be considered finished when it successfully reaches a draw for any
    combination of `X`'s moves.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开发了一个（最常用的）井字棋游戏变体。作为额外的练习，从维基百科（[http://en.wikipedia.org/wiki/Tic-tac-toe](http://en.wikipedia.org/wiki/Tic-tac-toe)）中选择一个或多个变体，并使用红-绿-重构程序实现它。完成后，实现一种能够玩`O`的回合的人工智能。由于井字棋通常导致平局，当AI成功达到任何`X`的移动组合时，可以认为AI已经完成。
- en: While working on those exercises, remember to be fast and play ping pong. Also,
    most of all, remember to use the Red-Green-Refactor procedure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这些练习时，记得要快速并进行乒乓对打。最重要的是，记得要使用红-绿-重构程序。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We managed to finish our Tic-Tac-Toe game using the Red-Green-Refactor process.
    The examples themselves were simple and you probably didn't have a problem following
    them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地使用红-绿-重构过程完成了我们的井字棋游戏。这些例子本身很简单，你可能没有问题跟随它们。
- en: The objective of this chapter was not to dive into something complicated (that
    comes later), but to get into the habit of using the short and repetitive cycle
    called Red-Green-Refactor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是深入研究复杂的东西（这将在后面进行），而是养成使用称为红-绿-重构的短而重复的循环习惯。
- en: We learned that the easiest way to develop something is by splitting it into
    very small chunks. The design was emerging from tests instead of using a big upfront
    approach. No line of the implementation code was written without writing a test
    first and seeing it fail. By confirming that the last test fails, we are confirming
    that it is valid (it's easy to make a mistake and write a test that is always
    successful) and the feature we are about to implement does not exist. After the
    test failed, we wrote the implementation of that test. While writing the implementation,
    we tried to make it a minimal one with the objective being to make the test pass,
    not to make the solution final. We repeated this process until we felt that there
    was a need to refactor the code. Refactoring did not introduce any new functionality
    (we did not change what the application does), but made the code more optimal
    and easier to read and maintain.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了开发某物最简单的方法是将其分解成非常小的块。设计是从测试中出现的，而不是采用大量的前期方法。没有一行实现代码是在没有先编写测试并看到它失败的情况下编写的。通过确认最后一个测试失败，我们确认它是有效的（很容易出错并编写一个始终成功的测试），并且我们即将实现的功能不存在。测试失败后，我们编写了该测试的实现。在编写实现时，我们试图使其尽可能简化，目标是使测试通过，而不是使解决方案最终化。我们重复这个过程，直到我们感到有必要重构代码。重构不会引入任何新功能（我们没有改变应用程序的功能），但会使代码更加优化，更易于阅读和维护。
- en: In the next chapter, we'll elaborate in more detail about what constitutes a
    unit within the context of TDD and how to approach the creation of tests based
    on those units.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地阐述在TDD环境中什么构成了一个单元，以及如何根据这些单元的创建测试。
