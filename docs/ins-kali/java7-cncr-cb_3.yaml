- en: Chapter 3. Thread Synchronization Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。线程同步工具
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Controlling concurrent access to a resource
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对资源的并发访问
- en: Controlling concurrent access to multiple copies of a resource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对多个资源副本的并发访问
- en: Waiting for multiple concurrent events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待多个并发事件
- en: Synchronizing tasks in a common point
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个公共点同步任务
- en: Running concurrent phased tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并发分阶段任务
- en: Controlling phase change in concurrent phased tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制并发分阶段任务中的阶段变化
- en: Changing data between concurrent tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发任务之间交换数据
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In [Chapter 2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic
    thread synchronization*, we learned the concepts of synchronization and critical
    section. Basically, we talk about synchronization when more than one concurrent
    task shares a resource, for example, an object or an attribute of an object. The
    blocks of code that access this shared resource are called critical sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本线程同步")，*基本线程同步*，我们学习了同步和关键部分的概念。基本上，当多个并发任务共享一个资源时，例如一个对象或对象的属性时，我们谈论同步。访问这个共享资源的代码块被称为关键部分。
- en: If you don't use the appropriate mechanisms, you can have the wrong results,
    data inconsistency, or error conditions, so we have to adopt one of the synchronization
    mechanisms provided by the Java language to avoid all these problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用适当的机制，可能会出现错误的结果、数据不一致或错误条件，因此我们必须采用Java语言提供的同步机制之一来避免所有这些问题。
- en: '[Chapter 2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic thread
    synchronization*, taught us about the following basic synchronization mechanisms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。基本线程同步")，*基本线程同步*，教会了我们以下基本同步机制：'
- en: The `synchronized` keyword
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`同步`关键字'
- en: 'The `Lock` interface and its implementation classes: `ReentrantLock`, `ReentrantReadWriteLock.ReadLock`,
    and `ReentrantReadWriteLock.WriteLock`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口及其实现类：`ReentrantLock`、`ReentrantReadWriteLock.ReadLock`和`ReentrantReadWriteLock.WriteLock`'
- en: 'In this chapter, we will learn how to use high-level mechanisms to get the
    synchronization of multiple threads. These high-level mechanisms are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用高级机制来实现多个线程的同步。这些高级机制如下：
- en: '**Semaphores**: A semaphore is a counter that controls the access to one or
    more shared resources. This mechanism is one of the basic tools of concurrent
    programming and is provided by most of the programming languages.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：信号量是控制对一个或多个共享资源的访问的计数器。这种机制是并发编程的基本工具之一，并且大多数编程语言都提供了它。'
- en: '**CountDownLatch**: The `CountDownLatch` class is a mechanism provided by the
    Java language that allows a thread to wait for the finalization of multiple operations.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CountDownLatch**：`CountDownLatch`类是Java语言提供的一种机制，允许线程等待多个操作的完成。'
- en: '**CyclicBarrier**: The `CyclicBarrier` class is another mechanism provided
    by the Java language that allows the synchronization of multiple threads in a
    common point.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CyclicBarrier**：`CyclicBarrier`类是Java语言提供的另一种机制，允许多个线程在一个公共点同步。'
- en: '**Phaser**: The `Phaser` class is another mechanism provided by the Java language
    that controls the execution of concurrent tasks divided in phases. All the threads
    must finish one phase before they can continue with the next one. This is a new
    feature of the Java 7 API.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Phaser**：`Phaser`类是Java语言提供的另一种机制，用于控制分阶段并发任务的执行。所有线程必须在继续下一个阶段之前完成一个阶段。这是Java
    7 API的一个新特性。'
- en: '**Exchanger**: The `Exchanger` class is another mechanism provided by the Java
    language that provides a point of data interchange between two threads.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exchanger**：`Exchanger`类是Java语言提供的另一种机制，提供了两个线程之间的数据交换点。'
- en: Semaphores are a generic synchronization mechanism that you can use to protect
    any critical section in any problem. The other mechanisms are thought to be used
    in applications with specific features as it was described previously. Be sure
    to select the appropriate mechanism according to the characteristics of your application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一种通用的同步机制，您可以用它来保护任何问题中的关键部分。其他机制被认为是用于具有特定特征的应用程序，正如之前所描述的。请根据您的应用程序的特点选择适当的机制。
- en: This chapter presents seven recipes that show you how to use the mechanisms
    described.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了七个示例，展示了如何使用所描述的机制。
- en: Controlling concurrent access to a resource
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对资源的并发访问
- en: In this recipe, you will learn how to use the semaphore mechanism provided by
    the Java language. A semaphore is a counter that protects the access to one or
    more shared resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用Java语言提供的信号量机制。信号量是保护对一个或多个共享资源的访问的计数器。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was
    used for the first time in the THEOS operating system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的概念是由Edsger Dijkstra于1965年引入的，并且首次在THEOS操作系统中使用。
- en: When a thread wants to access one of these shared resources, first, it must
    acquire the semaphore. If the internal counter of the semaphore is greater than
    `0`, the semaphore decrements the counter and allows access to the shared resource.
    A counter bigger than `0` means there are free resources that can be used, so
    the thread can access and use one of them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程想要访问其中一个共享资源时，首先必须获取信号量。如果信号量的内部计数器大于`0`，则信号量会减少计数器并允许访问共享资源。计数器大于`0`意味着有空闲资源可以使用，因此线程可以访问并使用其中一个。
- en: Otherwise, if the counter of the semaphore is `0`, the semaphore puts the thread
    to sleep until the counter is greater than `0`. A value of `0` in the counter
    means all the shared resources are used by other threads, so the thread that wants
    to use one of them must wait until one is free.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果信号量的计数器为`0`，则信号量将线程置于休眠状态，直到计数器大于`0`。计数器为`0`表示所有共享资源都被其他线程使用，因此想要使用其中一个的线程必须等待直到有一个空闲。
- en: When the thread has finished the use of the shared resource, it must release
    the semaphore so that the other thread can access the shared resource. That operation
    increases the internal counter of the semaphore.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程完成对共享资源的使用时，它必须释放信号量，以便其他线程可以访问共享资源。这个操作会增加信号量的内部计数器。
- en: In this recipe, you will learn how to use the `Semaphore` class to implement
    special kinds of semaphores called **binary semaphores** . These kinds of semaphores
    protect the access to a unique shared resource, so the internal counter of the
    semaphore can only take the values `1` or `0`. To show how to use it, you are
    going to implement a print queue that can be used by concurrent tasks to print
    their jobs. This print queue will be protected by a binary semaphore, so only
    one thread can print at a time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`Semaphore`类来实现特殊类型的信号量，称为**二进制信号量**。这些类型的信号量保护对唯一共享资源的访问，因此信号量的内部计数器只能取值`1`或`0`。为了演示如何使用它，您将实现一个打印队列，可以供并发任务使用来打印它们的作业。这个打印队列将受到二进制信号量的保护，因此一次只能有一个线程打印。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `PrintQueue` that will implement the print queue.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrintQueue`的类，它将实现打印队列。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declare a `Semaphore` object. Call it `semaphore`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Semaphore`对象。将其命名为`semaphore`。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the constructor of the class. It initializes the `semaphore` object
    that will protect the access from the print queue.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化了将保护对打印队列的访问的`semaphore`对象。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement the `printJob()` method that will simulate the printing of a document.
    It receives `Object` called `document` as a parameter.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`printJob()`方法来模拟打印文档。它接收名为`document`的`Object`作为参数。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the method, first of all, you must acquire the semaphore calling the
    `acquire()` method. This method can throw an `InterruptedException` exception,
    so you must include some code to process it.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，首先必须调用`acquire()`方法来获取信号量。这个方法可能会抛出`InterruptedException`异常，所以您必须包含一些代码来处理它。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, implement the lines that simulate the printing of a document waiting for
    a random period of time.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现模拟打印文档并等待随机时间段的行。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, free the semaphore by calling the `release()` method of the semaphore.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用信号量的`release()`方法释放信号量。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a class called `Job` and specify that it implements the `Runnable` interface.
    This class implements a job that sends a document to the printer.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Job`的类，并指定它实现`Runnable`接口。这个类实现了向打印机发送文档的作业。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Declare a `PrintQueue` object. Call it `printQueue`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`PrintQueue`对象。将其命名为`printQueue`。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implement the constructor of the class. It initializes the `PrintQueue` object
    declared in the class.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化了类中声明的`PrintQueue`对象。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the `run()` method.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, the method writes a message to the console that shows that the job has
    started its execution.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该方法向控制台写入一条消息，显示作业已经开始执行。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, it calls the `printJob()` method of the `PrintQueue` object.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`PrintQueue`对象的`printJob()`方法。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, the method writes a message to the console that shows that it has finished
    its execution.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，该方法向控制台写入一条消息，显示它已经完成了执行。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a `PrintQueue` object named `printQueue`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`printQueue`的`PrintQueue`对象。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create 10 threads. Each one of those threads will execute a `Job` object that
    will send a document to the print queue.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个线程。这些线程中的每一个都将执行一个`Job`对象，该对象将向打印队列发送一个文档。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, start the 10 threads.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动10个线程。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key to this example is in the `printJob()` method of the `PrintQueue` class.
    This method shows the three steps you must follow when you use a semaphore to
    implement a critical section, and protect the access to a shared resource:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的关键在`PrintQueue`类的`printJob()`方法中。这个方法展示了在使用信号量实现临界区并保护对共享资源访问时，您必须遵循的三个步骤：
- en: First, you acquire the semaphore, with the `acquire()` method.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`acquire()`方法获取信号量。
- en: Then, you do the necessary operations with the shared resource.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行与共享资源的必要操作。
- en: Finally, release the semaphore with the `release()` method.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`release()`方法释放信号量。
- en: Another important point in this example is the constructor of the `PrintQueue`
    class and the initialization of the `Semaphore` object. You pass the value `1`
    as the parameter of this constructor, so you are creating a binary semaphore.
    The initial value of the internal counter is `1`, so you will protect the access
    to one shared resource, in this case, the print queue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的另一个重要点是`PrintQueue`类的构造函数和`Semaphore`对象的初始化。您将`1`作为这个构造函数的参数传递，因此您正在创建一个二进制信号量。内部计数器的初始值为`1`，因此您将保护对一个共享资源的访问，即打印队列。
- en: When you start the 10 threads, the first one acquires the semaphore and gets
    the access to the critical section. The rest are blocked by the semaphore until
    the thread that has acquired it, releases it. When this occurs, the semaphore
    selects one of the waiting threads and gives it the access to the critical section.
    All the jobs print their documents, but one by one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动10个线程时，第一个线程会获取信号量并获得对临界区的访问。其余线程被信号量阻塞，直到已经获取信号量的线程释放它。当这种情况发生时，信号量会选择一个等待的线程并允许其访问临界区。所有的作业都会打印它们的文档，但是一个接一个地进行。
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Semaphore` class has two additional versions of the `acquire()` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Semaphore`类有两个额外版本的`acquire()`方法：'
- en: '`acquireUninterruptibly()`: The `acquire()` method; when the internal counter
    of the semaphore is `0`, blocks the thread until the semaphore is released. During
    this blocked time, the thread may be interrupted and then this method throws an
    `InterruptedException` exception. This version of the acquire operation ignores
    the interruption of the thread and doesn''t throw any exceptions.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquireUninterruptibly()`: `acquire()`方法；当信号量的内部计数器为`0`时，阻塞线程直到信号量被释放。在此阻塞时间内，线程可能会被中断，然后此方法抛出`InterruptedException`异常。此版本的获取操作忽略线程的中断，并且不会抛出任何异常。'
- en: '`tryAcquire()`: This method tries to acquire the semaphore. If it can, the
    method returns the `true` value. But if it can''t, the method returns the `false`
    value instead of being blocked and waits for the release of the semaphore. It''s
    your responsibility to take the correct action based on the `return` value.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryAcquire()`: 此方法尝试获取信号量。如果可以，该方法返回`true`值。但是如果不能，该方法返回`false`值，而不是被阻塞并等待信号量的释放。根据`return`值，您有责任采取正确的操作。'
- en: Fairness in semaphores
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号量中的公平性
- en: The concept of fairness is used by the Java language in all classes that can
    have various threads blocked waiting for the release of a synchronization resource
    (for example, a semaphore). The default mode is called the **non-fair mode** .
    In this mode, when the synchronization resource is released, one of the waiting
    threads is selected to get this resource, but it's selected without any criteria.
    The **fair mode** changes this behavior and forces to select the thread that has
    been waiting for more time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 公平性的概念被Java语言用于所有可以有各种线程阻塞等待同步资源释放的类（例如信号量）。默认模式称为**非公平模式**。在这种模式下，当同步资源被释放时，会选择等待的线程中的一个来获取此资源，但是选择是没有任何标准的。**公平模式**改变了这种行为，并强制选择等待时间更长的线程。
- en: As occurs with other classes, the `Semaphore` class admits a second parameter
    in its constructor. This parameter must take a `Boolean` value. If you give it
    the `false` value, you are creating a semaphore that will work in non-fair mode.
    You will get the same behavior if you don't use this parameter. If you give it
    the `true` value, you are creating a semaphore that will work in fair mode.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类一样，`Semaphore`类在其构造函数中接受第二个参数。此参数必须采用`Boolean`值。如果给定`false`值，则创建一个将以非公平模式工作的信号量。如果不使用此参数，将获得相同的行为。如果给定`true`值，则创建一个将以公平模式工作的信号量。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试并发应用程序")中的*监视锁接口*配方，*测试并发应用程序*'
- en: The *Modifying Lock fairness* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。基本线程同步")中的*修改锁公平性*配方，*基本线程同步*'
- en: Controlling concurrent access to multiple copies of a resource
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对资源的多个副本的并发访问
- en: In the *Controlling concurrent access to a resource* recipe, you learned the
    basis of semaphores.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*控制对资源的并发访问*配方中，您学习了信号量的基础知识。
- en: In that recipe, you implemented an example using binary semaphores. These kinds
    of semaphores are used to protect the access to one shared resource, or to a critical
    section that can only be executed by one thread at a time. But semaphores can
    also be used when you need to protect various copies of a resource, or when you
    have a critical section that can be executed by more than one thread at the same
    time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个配方中，您使用了二进制信号量来实现一个示例。这些类型的信号量用于保护对一个共享资源的访问，或者只能由一个线程执行的临界区。但是当您需要保护资源的多个副本时，或者当您有一个可以同时由多个线程执行的临界区时，也可以使用信号量。
- en: In this recipe, you will learn how to use a semaphore to protect more than one
    copy of a resource. You are going to implement an example, which has one print
    queue that can print documents in three different printers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何使用信号量来保护多个资源的副本。您将实现一个示例，其中有一个打印队列，可以在三台不同的打印机上打印文档。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: Implement the example described in the *Controlling concurrent access to a resource*
    recipe in this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中实现*控制对资源的并发访问*配方中描述的示例。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: As we mentioned earlier, you are going to modify the print queue example implemented
    with semaphores. Open the `PrintQueue` class and declare a `boolean` array called
    `freePrinters`. This array stores printers that are free to print a job and printers
    that are printing a document.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您将修改使用信号量实现的打印队列示例。打开`PrintQueue`类并声明一个名为`freePrinters`的`boolean`数组。该数组存储可以打印作业的空闲打印机和正在打印文档的打印机。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, declare a `Lock` object named `lockPrinters`. You will use this object
    to protect the access to the `freePrinters` array.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要声明一个名为`lockPrinters`的`Lock`对象。您将使用此对象来保护对`freePrinters`数组的访问。
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Modify the constructor of the class to initialize the new declared objects.
    The `freePrinters` array has three elements, all initialized to the `true` value.
    The semaphore has `3` as its initial value.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的构造函数以初始化新声明的对象。`freePrinters`数组有三个元素，全部初始化为`true`值。信号量的初始值为`3`。
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Modify also the `printJob()` method. It receives an `Object` called `document`
    as the unique parameter.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要修改`printJob()`方法。它接收一个名为`document`的`Object`作为唯一参数。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First of all, the method calls the `acquire()` method to acquire the access
    to the semaphore. As this method can throw an `InterruptedException` exception,
    you must include the code to process it.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该方法调用`acquire()`方法来获取对信号量的访问。由于此方法可能会抛出`InterruptedException`异常，因此必须包含处理它的代码。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then you get the number of the printer assigned to print this job using the
    private method `getPrinter()`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用私有方法`getPrinter()`获取分配打印此作业的打印机的编号。
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, implement the lines that simulate the printing of a document waiting for
    a random period of time.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现模拟打印文档并等待随机时间段的行。
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, release the semaphore calling the `release()` method and mark the printer
    used as free, assigning `true` to the corresponding index in the `freePrinters`
    array.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`release()`方法释放信号量，并将使用的打印机标记为自由，将`true`分配给`freePrinters`数组中的相应索引。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implement the `getPrinter()` method. It's a private method that returns an `int`
    value and it has no parameters.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getPrinter()`方法。这是一个返回`int`值的私有方法，没有参数。
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First of all, declare an `int` variable to store the index of the printer.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个`int`变量来存储打印机的索引。
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, get the access to the `lockPrinters` object.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，获取`lockPrinters`对象的访问权限。
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, find the first `true` value in the `freePrinters` array and save its index
    in a variable. Modify this value to `false`, because this printer will be busy.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`freePrinters`数组中找到第一个`true`值，并将其索引保存在一个变量中。修改此值为`false`，因为这台打印机将忙碌。
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, free the `lockPrinters` object and return the index of the `true` value.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放`lockPrinters`对象并返回`true`值的索引。
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Job` and `Core` classes have no modifications.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Job`和`Core`类没有修改。'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of this example is in the `PrintQueue` class. The `Semaphore` object
    is created using `3` as the parameter of the constructor. The first three threads
    that call the `acquire()` method will get the access to the critical section of
    this example, while the rest will be blocked. When a thread finishes the critical
    section and releases the semaphore, another thread will acquire it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键在于`PrintQueue`类。使用`3`作为构造函数的参数创建`Semaphore`对象。调用`acquire()`方法的前三个线程将获得对这个例子的关键部分的访问，而其余的线程将被阻塞。当一个线程完成关键部分并释放信号量时，另一个线程将获取它。
- en: In this critical section, the thread gets the index of the printer assigned
    to print this job. This part of the example is used to give more realism to the
    example, but it doesn't use any code related with semaphores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关键部分，线程获取分配打印此作业的打印机的索引。这个例子的这一部分用于使例子更加真实，但它不使用与信号量相关的任何代码。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例的执行输出：
- en: '![How it works...](img/7881_03_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_03_01.jpg)'
- en: Each document is printed in one of the printers. The first one is free.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档都在其中一个打印机上打印。第一个是空闲的。
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `acquire()`, `acquireUninterruptibly()`, `tryAcquire()`, and `release()`
    methods have an additional version which has an `int` parameter. This parameter
    represents the number of permits that the thread that uses them wants to acquire
    or release, so as to say, the number of units that this thread wants to delete
    or to add to the internal counter of the semaphore. In the case of the `acquire()`,
    `acquireUninterruptibly()`, and `tryAcquire()` methods, if the value of this counter
    is less than this value, the thread will be blocked until the counter gets this
    value or a greater one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`、`acquireUninterruptibly()`、`tryAcquire()`和`release()`方法有一个额外的版本，它们有一个`int`参数。这个参数表示使用它们的线程想要获取或释放的许可数，也就是说，这个线程想要删除或添加到信号量的内部计数器的单位数。在`acquire()`、`acquireUninterruptibly()`和`tryAcquire()`方法的情况下，如果这个计数器的值小于这个值，线程将被阻塞，直到计数器达到这个值或更大的值。'
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Controlling concurrent access to a resource* recipe in [Chapter 3](ch03.html
    "Chapter 3. Thread Synchronization Utilities"), *Thread Synchronization Utilities*
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。线程同步工具")中的*控制对资源的并发访问*食谱，*线程同步工具*'
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。测试并发应用")中的*监视锁接口*食谱，*测试并发应用*'
- en: The *Modifying lock fairness* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。基本线程同步")中的*修改锁公平性*食谱，*基本线程同步*'
- en: Waiting for multiple concurrent events
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待多个并发事件
- en: The Java concurrency API provides a class that allows one or more threads to
    wait until a set of operations are made. It's the `CountDownLatch` class . This
    class is initialized with an integer number, which is the number of operations
    the threads are going to wait for. When a thread wants to wait for the execution
    of these operations, it uses the `await()` method. This method puts the thread
    to sleep until the operations are completed. When one of these operations finishes,
    it uses the `countDown()` method to decrement the internal counter of the `CountDownLatch`
    class. When the counter arrives to `0`, the class wakes up all the threads that
    were sleeping in the `await()` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了一个类，允许一个或多个线程等待一组操作完成。这就是`CountDownLatch`类。这个类用一个整数数初始化，这个整数是线程要等待的操作数。当一个线程想要等待这些操作的执行时，它使用`await()`方法。这个方法使线程进入睡眠状态，直到操作完成。当其中一个操作完成时，它使用`countDown()`方法来减少`CountDownLatch`类的内部计数器。当计数器到达`0`时，类唤醒所有在`await()`方法中睡眠的线程。
- en: In this recipe, you will learn how to use the `CountDownLatch` class implementing
    a video-conference system. The video-conference system will wait for the arrival
    of all the participants before it begins.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用`CountDownLatch`类实现视频会议系统。视频会议系统将等待所有参与者到达后才开始。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的例子是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Videoconference` and specify that it implements the `Runnable`
    interface. This class will implement the video-conference system.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Videoconference`的类，并指定其实现`Runnable`接口。该类将实现视频会议系统。
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Declare a `CountDownLatch` object named `controller`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`controller`的`CountDownLatch`对象。
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implement the constructor of the class that initializes the `CountDownLatch`
    attribute. The `Videoconference` class will wait for the arrival of the number
    of participants received as a parameter.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化`CountDownLatch`属性的类的构造函数。`Videoconference`类将等待作为参数接收到的参与者数量的到达。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implement the `arrive()` method. This method will be called each time a participant
    arrives to the video conference. It receives a `String` type named `name` as the
    parameter.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`arrive()`方法。每次参与者到达视频会议时，将调用此方法。它接收一个名为`name`的`String`类型的参数。
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, it writes a message with the parameter it has received.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用接收到的参数编写一条消息。
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then, it calls the `countDown()` method of the `CountDownLatch` object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`CountDownLatch`对象的`countDown()`方法。
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, it writes another message with the number of participants, whose arrival
    is pending using the `getCount()` method of the `CountDownLatch` object.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`CountDownLatch`对象的`getCount()`方法编写另一条消息，指示到达的参与者数量。
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implement the main method of the video-conference system. It's the `run()` method
    that every `Runnable` object must have.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现视频会议系统的主方法。这是每个`Runnable`对象必须具有的`run()`方法。
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, use the `getCount()` method to write a message with the number of participants
    in the video conference.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`getCount()`方法编写一条消息，指示视频会议中的参与者数量。
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, use the `await()` method to wait for all the participants. As this method
    can throw an `InterruptedException` exception, you must include the code to process
    it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`await()`方法等待所有参与者。由于此方法可能引发`InterruptedException`异常，因此必须包含处理它的代码。
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, write a message to indicate that all the participants have arrived.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写一条消息，指示所有参与者都已到达。
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create the `Participant` class and specify that it implements the `Runnable`
    interface. This class represents each participant in the video conference.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Participant`类并指定其实现`Runnable`接口。该类代表视频会议中的每个参与者。
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Declare a private `Videoconference` attribute named `conference`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`conference`的私有`Videoconference`属性。
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Declare a private `String` attribute named `name`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性。
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implement the constructor of the class that initializes both attributes.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化两个属性的类的构造函数。
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Implement the `run()` method of the participants.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现参与者的`run()`方法。
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, put the thread to sleep for a random period of time.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让线程休眠一段随机时间。
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Then, use the `arrive()` method of the `Videoconference` object to indicate
    the arrival of this participant.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`Videoconference`对象的`arrive()`方法指示该参与者的到达。
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a `Videoconference` object named `conference` that waits for 10 participants.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`conference`的`Videoconference`对象，等待10个参与者。
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Create `Thread` to run this `Videoconference` object and start it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Thread`来运行此`Videoconference`对象并启动它。
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create 10 `Participant` objects, a `Thread` object to run each of them, and
    start all the threads.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个`Participant`对象，一个`Thread`对象来运行每个参与者，并启动所有线程。
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'The `CountDownLatch` class has three basic elements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类有三个基本元素：'
- en: The initialization value that determines how many events the `CountDownLatch`
    class waits for
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定`CountDownLatch`类等待多少个事件的初始化值
- en: The `await()` method, called by the threads that wait for the finalization of
    all the events
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await()`方法由等待所有事件完成的线程调用'
- en: The `countDown()` method, called by the events when they finish their execution
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countDown()`方法由事件在完成执行时调用'
- en: When you create a `CountDownLatch` object, the object uses the constructor's
    parameter to initialize an internal counter. Every time a thread calls the `countDown()`
    method, the `CountDownLatch` object decrements the internal counter in one unit.
    When the internal counter arrives to `0`, the `CountDownLatch` object wakes up
    all the threads that were waiting in the `await()` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个`CountDownLatch`对象时，对象使用构造函数的参数来初始化内部计数器。每次线程调用`countDown()`方法时，`CountDownLatch`对象将内部计数器减少一个单位。当内部计数器达到`0`时，`CountDownLatch`对象唤醒所有在`await()`方法中等待的线程。
- en: There's no way to re-initialize the internal counter of the `CountDownLatch`
    object or to modify its value. Once the counter is initialized, the only method
    you can use to modify its value is the `countDown()` method explained earlier.
    When the counter arrives to `0`, all the calls to the `await()` method return
    immediately and all subsequent calls to the `countDown()` method have no effect.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 无法重新初始化`CountDownLatch`对象的内部计数器或修改其值。一旦计数器被初始化，您可以使用的唯一方法来修改其值是前面解释的`countDown()`方法。当计数器达到`0`时，对`await()`方法的所有调用立即返回，并且对`countDown()`方法的所有后续调用都没有效果。
- en: 'There are some differences with respect to other synchronization methods, which
    are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他同步方法相比，有一些不同之处，如下所示：
- en: The `CountDownLatch` mechanism is not used to protect a shared resource or a
    critical section. It is used to synchronize one or more threads with the execution
    of various tasks.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`机制不用于保护共享资源或临界区。它用于将一个或多个线程与执行各种任务同步。'
- en: It only admits one use. As we explained earlier, once the counter of `CountDownLatch`
    arrives at `0`, all the calls to its methods have no effect. You have to create
    a new object if you want to do the same synchronization again.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只允许一次使用。正如我们之前解释的，一旦`CountDownLatch`的计数器达到`0`，对其方法的所有调用都没有效果。如果要再次进行相同的同步，必须创建一个新对象。
- en: 'The following screenshot shows the output of an execution of the example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了示例执行的输出：
- en: '![How it works...](img/7881_03_02.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_03_02.jpg)'
- en: You can see how the last participants arrive and, once the internal counter
    arrives to `0`, the `CountDownLatch` object wakes up the `Videoconference` object
    that writes the messages indicating that the video conference should start.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到最后的参与者到达，一旦内部计数器到达`0`，`CountDownLatch`对象会唤醒`Videoconference`对象，写入指示视频会议应该开始的消息。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CountDownLatch` class has another version of the `await()` method, which
    is given as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类有另一个版本的`await()`方法，如下所示：'
- en: '`await`(`long``time,``TimeUnit``unit`): The thread will be sleeping until it''s
    interrupted; the internal counter of `CountDownLatch` arrives to `0` or specified
    time passes. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await`(`long``time,``TimeUnit``unit`): 线程将睡眠，直到被中断；`CountDownLatch`的内部计数器到达`0`或指定的时间过去。`TimeUnit`类是一个枚举，包含以下常量：`DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, 和 `SECONDS`。'
- en: Synchronizing tasks in a common point
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个共同点同步任务
- en: The Java concurrency API provides a synchronizing utility that allows the synchronization
    of two or more threads in a determined point. It's the `CyclicBarrier` class.
    This class is similar to the `CountDownLatch` class explained in the *Waiting
    for multiple concurrent events* recipe in this chapter, but presents some differences
    that make them a more powerful class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了一个同步工具，允许在确定点同步两个或多个线程。这就是`CyclicBarrier`类。这个类类似于本章中*等待多个并发事件*一节中解释的`CountDownLatch`类，但有一些不同之处，使它成为一个更强大的类。
- en: The `CyclicBarrier` class is initialized with an integer number, which is the
    number of threads that will be synchronized in a determined point. When one of
    those threads arrives to the determined point, it calls the `await()` method to
    wait for the other threads. When the thread calls that method, the `CyclicBarrier`
    class blocks the thread that is sleeping until the other threads arrive. When
    the last thread calls the `await()` method of the `CyclicBarrier` class, it wakes
    up all the threads that were waiting and continues with its job.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类用一个整数初始化，这个整数是将在确定点同步的线程数。当其中一个线程到达确定点时，它调用`await()`方法等待其他线程。当线程调用该方法时，`CyclicBarrier`类会阻塞正在睡眠的线程，直到其他线程到达。当最后一个线程调用`CyclicBarrier`类的`await()`方法时，它会唤醒所有等待的线程并继续执行任务。'
- en: One interesting advantage of the `CyclicBarrier` class is that you can pass
    an additional `Runnable` object as an initialization parameter, and the `CyclicBarrier`
    class executes this object as a thread when all the threads have arrived to the
    common point. This characteristic makes this class adequate for the parallelization
    of tasks using the divide and conquer programming technique.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类的一个有趣的优势是，您可以将一个额外的`Runnable`对象作为初始化参数传递给它，当所有线程到达共同点时，`CyclicBarrier`类会执行这个对象作为一个线程。这个特性使得这个类适合使用分治编程技术并行化任务。'
- en: In this recipe, you will learn how to use the `CyclicBarrier` class to synchronize
    a set of threads in a determined point. You will also use a `Runnable` object
    that will execute after all the threads have arrived to that point. In the example,
    you will look for a number in a matrix of numbers. The matrix will be divided
    in subsets (using the divide and conquer technique), so each thread will look
    for the number in one subset. Once all the threads have finished their job, a
    final task will unify the results of them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`CyclicBarrier`类来同步一组线程到一个确定的点。您还将使用一个`Runnable`对象，在所有线程到达该点后执行。在这个示例中，您将在一个数字矩阵中查找一个数字。矩阵将被分成子集（使用分治技术），因此每个线程将在一个子集中查找数字。一旦所有线程完成了它们的工作，最终任务将统一它们的结果。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经在Eclipse IDE中实现。如果您使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: We're going to start the example by implementing two auxiliary classes. First,
    create a class named `MatrixMock`. This class will generate a random matrix of
    numbers between one and 10 where the threads are going to look for a number.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过实现两个辅助类来开始这个示例。首先，创建一个名为`MatrixMock`的类。这个类将生成一个随机的数字矩阵，数字在1到10之间，线程将在其中查找一个数字。
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Declare a `private``int` matrix named `data`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`data`的`private``int`矩阵。
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Implement the constructor of the class. This constructor will receive the number
    of rows of the matrix, the length of each row, and the number we are going to
    look for as parameters. All the three parameters are of type `int`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。这个构造函数将接收矩阵的行数、每行的长度和要查找的数字作为参数。所有三个参数的类型都是`int`。
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Initialize the variables and objects used in the constructor.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化构造函数中使用的变量和对象。
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Fill the matrix with random numbers. Each time you generate a number, compare
    it with the number you are going to look for. If they are equal, increment the
    counter.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用随机数填充矩阵。每次生成一个数字，都要与要查找的数字进行比较。如果它们相等，就增加计数器。
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, print a message in the console, which shows the number of occurrences
    of the number you are going to look for in the generated matrix. This message
    will be used to check that the threads get the correct result.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在控制台打印一条消息，显示在生成的矩阵中要查找的数字的出现次数。这条消息将用于检查线程是否得到了正确的结果。
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Implement the `getRow()` method. This method receives an `int` parameter with
    the number of a row in the matrix and returns the row if it exists, and returns
    `null` if it doesn't exist.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getRow()`方法。这个方法接收一个矩阵中的行号，并返回该行（如果存在），如果不存在则返回`null`。
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, implement a class named `Results`. This class will store, in an array,
    the number of occurrences of the searched number in each row of the matrix.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个名为`Results`的类。这个类将在一个数组中存储矩阵每一行中搜索到的数字的出现次数。
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Declare a private `int` array named `data`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`data`的私有`int`数组。
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Implement the constructor of the class. This constructor receives an integer
    parameter with the number of elements of the array.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。这个构造函数接收一个整数参数，表示数组的元素个数。
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Implement the `setData()` method. This method receives a position in the array
    and a value as parameters, and establishes the value of that position in the array.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`setData()`方法。这个方法接收一个数组中的位置和一个值作为参数，并确定数组中该位置的值。
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Implement the `getData()` method. This method returns the array with the array
    of the results.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getData()`方法。这个方法返回结果数组的数组。
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that you have the auxiliary classes, it's time to implement the threads.
    First, implement the `Searcher` class. This class will look for a number in determined
    rows of the matrix of random numbers. Create a class named `Searcher` and specify
    that it implements the `Runnable` interface.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了辅助类，是时候实现线程了。首先，实现`Searcher`类。这个类将在随机数字矩阵的确定行中查找一个数字。创建一个名为`Searcher`的类，并指定它实现`Runnable`接口。
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Declare two private `int` attributes named `firstRow` and `lastRow`. These two
    attributes will determine the subset of rows where this object will look for.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`int`属性，名为`firstRow`和`lastRow`。这两个属性将确定这个对象将在哪些行中查找。
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Declare a private `MatrixMock` attribute named `mock`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`mock`的私有`MatrixMock`属性。
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Declare a private `Results` attribute named `results`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`results`的私有`Results`属性。
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Declare a private `int` attribute named `number` that will store the number
    we are going to look for.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`number`的私有`int`属性，将存储我们要查找的数字。
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Declare a `CyclicBarrier` object named `barrier`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`barrier`的`CyclicBarrier`对象。
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implement the constructor of the class that initializes all the attributes declared
    before.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化之前声明的所有属性。
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Implement the `run()` method that will search for the number. It uses an internal
    variable called `counter` that will store the number of occurrences of the number
    in each row.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法，用于搜索数字。它使用一个名为`counter`的内部变量，用于存储每一行中数字的出现次数。
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Print a message in the console with the rows assigned to this object.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印一个消息，指定给这个对象分配的行。
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Process all the rows assigned to this thread. For each row, count the number
    of occurrences of the number you are searching for and store this number in the
    corresponding position of the `Results` object.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理分配给这个线程的所有行。对于每一行，计算你要搜索的数字出现的次数，并将这个数字存储在`Results`对象的相应位置。
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Print a message in the console to indicate that this object has finished searching.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印一条消息，指示这个对象已经完成了搜索。
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Call the `await()` method of the `CyclicBarrier` object and add the necessary
    code to process the `InterruptedException` and `BrokenBarrierException` exceptions
    that this method can throw.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`CyclicBarrier`对象的`await()`方法，并添加必要的代码来处理这个方法可能抛出的`InterruptedException`和`BrokenBarrierException`异常。
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, implement the class that calculates the total number of occurrences of
    the number in the matrix. It uses the `Results` object that stores the number
    of appearances of the number in each row of the matrix to make the calculation.
    Create a class named `Grouper` and specify that it implements the `Runnable` interface.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现计算矩阵中数字总出现次数的类。它使用存储矩阵每一行中数字出现次数的`Results`对象来进行计算。创建一个名为`Grouper`的类，并指定它实现`Runnable`接口。
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Declare a private `Results` attribute named `results`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`results`的私有`Results`属性。
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Implement the constructor of the class that initializes the `Results` attribute.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化`Results`属性。
- en: '[PRE79]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Implement the `run()` method that will calculate the total number of occurrences
    of the number in the array of results.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法，该方法将计算结果数组中数字的总出现次数。
- en: '[PRE80]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Declare an `int` variable and write a message to the console to indicate the
    start of the process.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`变量，并在控制台中写入一条消息，指示进程的开始。
- en: '[PRE81]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Get the number of occurrences of the number in each row using the `getData()`
    method of the `results` object. Then, process all the elements of the array and
    add their value to the `finalResult` variable.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`results`对象的`getData()`方法获取每一行中数字的出现次数。然后，处理数组的所有元素，并将它们的值加到`finalResult`变量中。
- en: '[PRE82]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Print the result in the console.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印结果。
- en: '[PRE83]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类。
- en: '[PRE84]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Declare and initialize five constants to store the parameters of the application.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化五个常量，用于存储应用程序的参数。
- en: '[PRE85]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Create a `MatrixMock` object named `mock`. It will have 10,000 rows of 1000
    elements. Now, you are going to search for the number five.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mock`的`MatrixMock`对象。它将有10000行，每行1000个元素。现在，你要搜索数字5。
- en: '[PRE86]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Create a `Results` object named `results`. It will have 10,000 elements.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`results`的`Results`对象。它将有10000个元素。
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Create a `Grouper` object named `grouper`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`grouper`的`Grouper`对象。
- en: '[PRE88]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Create a `CyclicBarrier` object called `barrier`. This object will wait for
    five threads. When this thread finishes, it will execute the `Grouper` object
    created previously.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`barrier`的`CyclicBarrier`对象。这个对象将等待五个线程。当这个线程完成时，它将执行之前创建的`Grouper`对象。
- en: '[PRE89]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Create five `Searcher` objects, five threads to execute them, and start the
    five threads.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Searcher`对象，五个线程来执行它们，并启动这五个线程。
- en: '[PRE90]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the results of an execution of this example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例执行的结果：
- en: '![How it works...](img/7881_03_03.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_03_03.jpg)'
- en: The problem resolved in the example is simple. We have a big matrix of random
    integer numbers and you want to know the total number of occurrences of a number
    in this matrix. To get a better performance, we use the divide and conquer technique.
    We divide the matrix in five subsets and use a thread to look for the number in
    each subset. These threads are objects of the `Searcher` class.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中解决的问题很简单。我们有一个随机整数数字的大矩阵，你想知道这个矩阵中某个数字出现的总次数。为了获得更好的性能，我们使用分而治之的技术。我们将矩阵分成五个子集，并使用一个线程在每个子集中查找数字。这些线程是`Searcher`类的对象。
- en: We use a `CyclicBarrier` object to synchronize the completion of the five threads
    and to execute the `Grouper` task to process the partial results, and calculate
    the final one.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CyclicBarrier`对象来同步五个线程的完成，并执行`Grouper`任务来处理部分结果，并计算最终结果。
- en: As we mentioned earlier, the `CyclicBarrier` class has an internal counter to
    control how many threads have to arrive to the synchronization point. Each time
    a thread arrives to the synchronization point, it calls the `await()` method to
    notify the `CyclicBarrier` object that has arrived to its synchronization point.
    `CyclicBarrier` puts the thread to sleep until all the threads arrive to their
    synchronization point.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`CyclicBarrier`类有一个内部计数器来控制有多少线程必须到达同步点。每当一个线程到达同步点时，它调用`await()`方法来通知`CyclicBarrier`对象已经到达了同步点。`CyclicBarrier`会让线程休眠，直到所有线程都到达同步点。
- en: When all the threads have arrived to their synchronization point, the `CyclicBarrier`
    object wakes up all the threads that were waiting in the `await()` method and,
    optionally, creates a new thread that executes a `Runnable` object passed as the
    parameter in the construction of `CyclicBarrier` (in our case, a `Grouper` object)
    to do additional tasks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有线程都到达同步点时，`CyclicBarrier`对象会唤醒所有在`await()`方法中等待的线程，并且可以创建一个新的线程来执行在`CyclicBarrier`构造函数中传递的`Runnable`对象（在我们的例子中是`Grouper`对象）来执行额外的任务。
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CyclicBarrier` class has another version of the `await()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类还有另一个版本的`await()`方法：'
- en: '`await`(`long``time,``TimeUnit``unit`): The thread will be sleeping until it''s
    interrupted; the internal counter of `CyclicBarrier` arrives to `0` or specified
    time passes. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await`(`long``time,``TimeUnit``unit`)：线程将休眠，直到被中断；`CyclicBarrier`的内部计数器到达`0`或指定的时间过去。`TimeUnit`类是一个枚举，包含以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: This class also provides the `getNumberWaiting()` method that returns the number
    of threads that are blocked in the `await()` method, and the `getParties()` method
    that returns the number of tasks that are going to be synchronized with `CyclicBarrier`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还提供了`getNumberWaiting()`方法，返回在`await()`方法中被阻塞的线程数，以及`getParties()`方法，返回将与`CyclicBarrier`同步的任务数。
- en: Resetting a CyclicBarrier object
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置CyclicBarrier对象
- en: The `CyclicBarrier` class has some points in common with the `CountDownLatch`
    class, but they also have some differences. One of the most important differences
    is that a `CyclicBarrier` object can be reset to its initial state, assigning
    to its internal counter the value with which it was initialized.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类与`CountDownLatch`类有一些共同点，但也有一些不同之处。其中最重要的一个区别是`CyclicBarrier`对象可以重置为其初始状态，将其内部计数器分配给其初始化时的值。'
- en: This reset operation can be done using the `reset()` method of the `CyclicBarrier`
    class. When this occurs, all the threads that were waiting in the `await()` method
    receive a `BrokenBarrierException` exception. This exception was processed in
    the example presented in this recipe by printing the stack trace, but in a more
    complex application, it could perform some other operation, such as restarting
    their execution or recovering their operation at the point it was interrupted.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`CyclicBarrier`类的`reset()`方法来执行此重置操作。当发生这种情况时，所有在`await()`方法中等待的线程都会收到`BrokenBarrierException`异常。在本配方中的示例中，这个异常通过打印堆栈跟踪来处理，但在更复杂的应用程序中，它可能执行其他操作，比如重新启动它们的执行或在中断点恢复它们的操作。
- en: Broken CyclicBarrier objects
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破碎的CyclicBarrier对象
- en: A `CyclicBarrier` object can be in a special state denoted by **broken**. When
    there are various threads waiting in the `await()` method and one of them is interrupted,
    this thread receives an `InterruptedException` exception, but the other threads
    that were waiting receive a `BrokenBarrierException` exception and `CyclicBarrier`
    is placed in the broken state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`对象可以处于特殊状态，用**broken**表示。当有多个线程在`await()`方法中等待，其中一个被中断时，这个线程会收到`InterruptedException`异常，但其他等待的线程会收到`BrokenBarrierException`异常，`CyclicBarrier`会处于破碎状态。'
- en: The `CyclicBarrier` class provides the `isBroken()` method, then returns `true`
    if the object is in the broken state; otherwise it returns `false`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类提供了`isBroken()`方法，如果对象处于破碎状态，则返回`true`；否则返回`false`。'
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Waiting for multiple concurrent events* recipe in [Chapter 3](ch03.html
    "Chapter 3. Thread Synchronization Utilities"), *Thread Synchronization Utilities*
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 线程同步工具")的*等待多个并发事件*配方中，*线程同步工具*
- en: Running concurrent phased tasks
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行并发分阶段任务
- en: One of the most complex and powerful functionalities offered by the Java concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class
    . This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides us with the mechanism to synchronize the threads at
    the end of each step, so no thread starts its second step until all the threads
    have finished the first one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的最复杂和强大的功能之一是使用`Phaser`类执行并发分阶段任务的能力。当我们有一些并发任务分为步骤时，这种机制非常有用。`Phaser`类为我们提供了在每个步骤结束时同步线程的机制，因此在所有线程完成第一步之前，没有线程开始第二步。
- en: As with other synchronization utilities, we have to initialize the `Phaser`
    class with the number of tasks that participate in the synchronization operation,
    but we can dynamically modify this number by increasing or decreasing it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他同步工具一样，我们必须使用参与同步操作的任务数量初始化`Phaser`类，但是我们可以通过增加或减少这个数量来动态修改它。
- en: 'In this recipe, you will learn how to use the `Phaser` class to synchronize
    three concurrent tasks. The three tasks look for files with the extension `.log`
    modified in the last 24 hours in three different folders and their subfolders.
    This task is divided into three steps:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何使用`Phaser`类来同步三个并发任务。这三个任务分别在三个不同的文件夹及其子文件夹中寻找最近24小时内修改的扩展名为`.log`的文件。这个任务分为三个步骤：
- en: Get a list of the files with the extension `.log` in the assigned folder and
    its subfolders.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取分配文件夹及其子文件夹中扩展名为`.log`的文件列表。
- en: Filter the list created in the first step by deleting the files modified more
    than 24 hours ago.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过删除24小时前修改的文件来过滤第一步创建的列表。
- en: Print the results in the console.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印结果。
- en: At the end of the steps 1 and 2 we check if the list has any elements or not.
    If it hasn't any element, the thread ends its execution and is eliminated from
    the the `phaser` class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1和2结束时，我们检查列表是否有任何元素。如果没有任何元素，线程将结束执行并从`phaser`类中被删除。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE like NetBeans, open it and create a new Java project.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果你使用Eclipse或其他类似NetBeans的IDE，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the operation of searching for files with a determined
    extension modified in the last 24 hours in a folder and its subfolders.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FileSearch`的类，并指定它实现`Runnable`接口。这个类实现了在文件夹及其子文件夹中搜索特定扩展名的文件，并且这些文件在最近24小时内被修改的操作。
- en: '[PRE91]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Declare a private `String` attribute to store the folder in which the search
    operation will begin.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性来存储搜索操作将开始的文件夹。
- en: '[PRE92]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Declare another private `String` attribute to store the extension of the files
    we are going to look for.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明另一个私有的`String`属性来存储我们要查找的文件的扩展名。
- en: '[PRE93]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Declare a private `List` attribute to store the full path of the files we will
    find with the desired characteristics.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`List`属性来存储具有所需特征的文件的完整路径。
- en: '[PRE94]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Finally, declare a private `Phaser` attribute to control the synchronization
    of the different phases of the task.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明一个私有的`Phaser`属性来控制任务不同阶段的同步。
- en: '[PRE95]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Implement the constructor of the class that will initialize the attributes of
    the class. It receives as parameters the full path of the initial folder, the
    extension of the files, and the phaser.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化类的属性。它的参数是初始文件夹的完整路径、文件的扩展名和phaser。
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, you have to implement some auxiliary methods that will be used by the
    `run()` method. The first one is the `directoryProcess()` method. It receives
    a `File` object as a parameter and it processes all its files and subfolders.
    For each folder, the method will make a recursive call passing the folder as a
    parameter. For each file, the method will call the `fileProcess()` method:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要实现一些辅助方法，这些方法将被`run()`方法使用。第一个是`directoryProcess()`方法。它接收一个`File`对象作为参数，并处理它的所有文件和子文件夹。对于每个文件夹，该方法将通过传递文件夹作为参数进行递归调用。对于每个文件，该方法将调用`fileProcess()`方法：
- en: '[PRE97]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now, implement the `fileProcess()` method. It receives a `File` object as parameter
    and checks if its extension is equal to the one we are looking for. If they are
    equal, this method adds the absolute path of the file to the list of results.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现`fileProcess()`方法。它接收一个`File`对象作为参数，并检查它的扩展名是否与我们要查找的扩展名相等。如果相等，这个方法将文件的绝对路径添加到结果列表中。
- en: '[PRE98]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now, implement the `filterResults()` method. It doesn't receive any parameter,
    and filters the list of files obtained in the first phase, deleting the files
    that were modified more than 24 hours ago. First, create a new empty list and
    get the actual date.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现`filterResults()`方法。它不接收任何参数，并过滤在第一阶段获取的文件列表，删除修改时间超过24小时的文件。首先，创建一个新的空列表并获取当前日期。
- en: '[PRE99]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Then, go through all the elements of the results list. For each path in the
    list of results, create a `File` object for that file and get the last modified
    date for it.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，遍历结果列表的所有元素。对于结果列表中的每个路径，为该文件创建一个`File`对象，并获取它的最后修改日期。
- en: '[PRE100]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Then, compare that date with the actual date and, if the difference is less
    than one day, add the full path of the file to the new list of results.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将该日期与当前日期进行比较，如果差值小于一天，则将文件的完整路径添加到新的结果列表中。
- en: '[PRE101]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Finally, change the old results list for the new one.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将旧的结果列表更改为新的列表。
- en: '[PRE102]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now, implement the `checkResults()` method. This method will be called at the
    end of the first and the second phase and it will check if the results list is
    empty or not. This method doesn't have any parameters.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现`checkResults()`方法。这个方法将在第一阶段和第二阶段结束时被调用，它将检查结果列表是否为空。这个方法没有任何参数。
- en: '[PRE103]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: First, check the size of the results list. If it's `0`, the object writes a
    message to the console indicating this circumstance and then, calls the `arriveAndDeregister()`
    method of the `Phaser` object to notify it that this thread has finished the actual
    phase, and it leaves the phased operation.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查结果列表的大小。如果为`0`，对象会向控制台写入一条消息，指示这种情况，然后调用`Phaser`对象的`arriveAndDeregister()`方法，通知它该线程已完成当前阶段，并离开阶段操作。
- en: '[PRE104]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Otherwise, if the results list has elements, the object writes a message to
    the console indicating this circumstance and then, calls the `arriveAndAwaitAdvance()`
    method of the `Phaser` object to notify it that this thread has finished the actual
    phase and it wants to be blocked until all the participant threads in the phased
    operation finish the actual phase.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果结果列表有元素，对象会向控制台写入一条消息，指示这种情况，然后调用`Phaser`对象的`arriveAndAwaitAdvance()`方法，通知它该线程已完成当前阶段，并希望被阻塞，直到所有参与的线程完成当前阶段。
- en: '[PRE105]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The last auxiliary method is the `showInfo()` method that prints to the console
    the elements of the results list.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个辅助方法是`showInfo()`方法，它将结果列表的元素打印到控制台。
- en: '[PRE106]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now, it's time to implement the `run()` method that executes the operation using
    the auxiliary methods described earlier and the `Phaser` object to control the
    change between phases. First, call the `arriveAndAwaitAdvance()` method of the
    `phaser` object. The search won't begin until all the threads have been created.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现`run()`方法了，该方法使用前面描述的辅助方法和`Phaser`对象来控制阶段之间的变化。首先，调用`phaser`对象的`arriveAndAwaitAdvance()`方法。在创建所有线程之前，搜索不会开始。
- en: '[PRE107]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Then, write a message to the console indicating the start of the search task.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向控制台写入一条消息，指示搜索任务的开始。
- en: '[PRE108]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Check that the `initPath` attribute stores the name of a folder and use the
    `directoryProcess()` method to find the files with the specified extension in
    that folder and all its subfolders.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`initPath`属性是否存储了一个文件夹的名称，并使用`directoryProcess()`方法在该文件夹及其所有子文件夹中查找指定扩展名的文件。
- en: '[PRE109]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Check if there are any results using the `checkResults()` method. If there are
    no results, finish the execution of the thread with the `return` keyword.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`checkResults()`方法检查是否有任何结果。如果没有结果，则使用`return`关键字结束线程的执行。
- en: '[PRE110]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Filter the list of results using the `filterResults()` method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filterResults()`方法过滤结果列表。
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Check again if there are any results using the `checkResults()` method. If there
    are no results, finish the execution of the thread with the `return` keyword.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`checkResults()`方法检查是否有任何结果。如果没有结果，则使用`return`关键字结束线程的执行。
- en: '[PRE112]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Print the final list of results to the console with the `showInfo()` method,
    deregister the thread, and print a message indicating the finalization of the
    thread.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`showInfo()`方法将最终的结果列表打印到控制台，注销线程，并打印一条指示线程最终化的消息。
- en: '[PRE113]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Now, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE114]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Create a `Phaser` object with three participants.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有三个参与者的`Phaser`对象。
- en: '[PRE115]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Create three `FileSearch` objects with a different initial folder for each one.
    Look for the files with the `.log` extension.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三个不同的初始文件夹创建三个`FileSearch`对象。查找扩展名为`.log`的文件。
- en: '[PRE116]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Create and start a thread to execute the first `FileSearch` object.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第一个`FileSearch`对象。
- en: '[PRE117]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Create and start a thread to execute the second `FileSearch` object.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第二个`FileSearch`对象。
- en: '[PRE118]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Create and start a thread to execute the third `FileSearch` object.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个线程来执行第三个`FileSearch`对象。
- en: '[PRE119]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Wait for the finalization of the three threads.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待三个线程的最终化。
- en: '[PRE120]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Write the value of the finalized flag of the `Phaser` object using the `isFinalized()`
    method.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`isFinalized()`方法写入`Phaser`对象的最终化标志的值。
- en: '[PRE121]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The program starts creating a `Phaser` object that will control the synchronization
    of the threads at the end of each phase. The constructor of `Phaser` receives
    the number of participants as a parameter. In our case, `Phaser` has three participants.
    This number indicates to `Phaser` the number of threads that have to execute an
    `arriveAndAwaitAdvance()` method before `Phaser` changes the phase and wakes up
    the threads that were sleeping.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始创建一个`Phaser`对象，该对象将控制每个阶段结束时线程的同步。`Phaser`的构造函数接收参与者的数量作为参数。在我们的例子中，`Phaser`有三个参与者。这个数字告诉`Phaser`在`Phaser`改变阶段并唤醒正在睡眠的线程之前，有多少个线程必须执行`arriveAndAwaitAdvance()`方法。
- en: Once `Phaser` has been created, we launch three threads that execute three different
    `FileSearch` objects.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`Phaser`，我们启动三个线程，执行三个不同的`FileSearch`对象。
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we use paths of the Windows operating system. If you work with
    another operating system, modify the paths to adapt them to existing paths in
    your environment.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用Windows操作系统的路径。如果您使用另一个操作系统，请修改路径以适应您环境中现有的路径。
- en: The first instruction in the `run()` method of this `FileSearch` object is a
    call to the `arriveAndAwaitAdvance()` method of the `Phaser` object. As we mentioned
    earlier, the `Phaser` knows the number of threads that we want to synchronize.
    When a thread calls this method, `Phaser` decreases the number of threads that
    have to finalize the actual phase and puts this thread to sleep until all the
    remaining threads finish this phase. Calling this method at the beginning of the
    `run()` method makes none of the `FileSearch` threads begin their job until all
    the threads have been created.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FileSearch`对象的`run()`方法中的第一条指令是调用`Phaser`对象的`arriveAndAwaitAdvance()`方法。正如我们之前提到的，`Phaser`知道我们想要同步的线程数量。当一个线程调用这个方法时，`Phaser`减少了必须完成当前阶段的线程数量，并将该线程置于睡眠状态，直到所有剩余的线程完成此阶段。在`run()`方法的开始调用这个方法，使得`FileSearch`线程中的任何一个都不会开始工作，直到所有线程都被创建。
- en: At the end of phase one and phase two, we check if the phase has generated results
    and the list with the results has elements, or otherwise the phase hasn't generated
    results and the list is empty. In the first case, the `checkResults()` method
    calls `arriveAndAwaitAdvance()` as explained earlier. In the second case, if the
    list is empty, there's no point in the thread continuing with its execution, so
    it returns. But you have to notify the phaser that there will be one less participant.
    For this, we used `arriveAndDeregister()`. This notifies the phaser that this
    thread has finished the actual phase, but it won't participate in the future phases,
    so the phaser won't have to wait for it to continue.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段和第二阶段结束时，我们检查阶段是否生成了结果，结果列表是否有元素，否则阶段没有生成结果，列表为空。在第一种情况下，`checkResults()`方法调用`arriveAndAwaitAdvance()`，如前所述。在第二种情况下，如果列表为空，线程没有继续执行的意义，所以返回。但是你必须通知屏障将会少一个参与者。为此，我们使用了`arriveAndDeregister()`。这通知屏障，这个线程已经完成了当前阶段，但不会参与未来的阶段，所以屏障不需要等待它继续。
- en: At the end of the phase three implemented in the `showInfo()` method, there
    is a call to the `arriveAndAwaitAdvance()` method of the phaser. With this call,
    we guarantee that all the threads finish at the same time. When this method ends
    its execution, there is a call to the `arriveAndDeregister()` method of the phaser.
    With this call, we deregister the threads of the phaser as we explained before,
    so when all the threads finish, the phaser will have zero participants.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在`showInfo()`方法中实现的第三阶段结束时，调用了屏障的`arriveAndAwaitAdvance()`方法。通过这个调用，我们保证所有线程同时结束。当这个方法执行结束时，会调用屏障的`arriveAndDeregister()`方法。通过这个调用，我们取消注册屏障的线程，因此当所有线程结束时，屏障将没有参与者。
- en: Finally, the `main()` method waits for the completion of the three threads and
    calls the `isTerminated()` method of the phaser. When a phaser has zero participants,
    it enters the so called termination state and this method returns `true`. As we
    deregister all the threads of the phaser, it will be in the termination state
    and this call will print `true` to the console.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()`方法等待三个线程的完成，并调用屏障的`isTerminated()`方法。当一个屏障没有参与者时，它进入所谓的终止状态，这个方法返回`true`。由于我们取消注册了屏障的所有线程，它将处于终止状态，这个调用将在控制台上打印`true`。
- en: 'A `Phaser` object can be in two states:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`对象可以处于两种状态：'
- en: '**Active**: `Phaser`enters this state when it accepts the registration of new
    participants and its synchronization at the end of each phase. In this state,
    `Phaser` works as it has been explained in this recipe. This state is not mentioned
    in the Java concurrency API.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃**：当`Phaser`接受新参与者的注册并在每个阶段结束时进行同步时，`Phaser`进入这个状态。在这个状态下，`Phaser`的工作方式如本文所述。这个状态在Java并发API中没有提到。'
- en: '**Termination**: By default,`Phaser` enters in this state when all the participants
    in `Phaser` have been deregistered, so `Phaser` has zero participants. More in
    detail, `Phaser` is in the termination state when the method `onAdvance()` returns
    the `true` value. If you override that method, you can change the default behavior.
    When `Phaser` is on this state, the synchronization method `arriveAndAwaitAdvance()`
    returns immediately without doing any synchronization operation.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：默认情况下，当所有`Phaser`的参与者都被取消注册时，`Phaser`进入这个状态，所以`Phaser`没有参与者。更详细地说，当`onAdvance()`方法返回`true`值时，`Phaser`处于终止状态。如果你重写了这个方法，你可以改变默认行为。当`Phaser`处于这个状态时，同步方法`arriveAndAwaitAdvance()`会立即返回，不执行任何同步操作。'
- en: A notable feature of the `Phaser` class is that you haven't had to control any
    exception from the methods related with the phaser. Unlike other synchronization
    utilities, threads that are sleeping in a phaser don't respond to interruption
    events and don't throw an `InterruptedException` exception. There is only one
    exception that is explained in the *There's more* section below.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类的一个显著特点是，你不需要控制与屏障相关的方法中的任何异常。与其他同步工具不同，处于屏障中休眠的线程不会响应中断事件，也不会抛出`InterruptedException`异常。下面的*还有更多*部分中只有一个例外情况。'
- en: 'The following screenshot shows the results of one execution of the example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了示例执行的结果：
- en: '![How it works...](img/7881_03_04.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_03_04.jpg)'
- en: It shows the first two phases of the execution. You can see how the **Apps**
    thread finishes its execution in phase two because its results list is empty.
    When you execute the example, you will see how some threads finish a phase before
    the rest, but they wait until all have finished one phase before continuing with
    the rest.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了执行的前两个阶段。你可以看到**Apps**线程在第二阶段结束时结束了执行，因为它的结果列表为空。当你执行示例时，你会看到一些线程在其他线程之前完成了一个阶段，但它们会等待所有线程完成一个阶段后才继续执行。
- en: There's more...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Phaser` class provides other methods related to the change of phase. These
    methods are as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了与阶段变化相关的其他方法。这些方法如下：'
- en: '`arrive()`: This method notifies the phaser that one participant has finished
    the actual phase, but it should not wait for the rest of the participants to continue
    with its execution. Be careful with the utilization of this method, because it
    doesn''t synchronize with other threads.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrive()`: 此方法通知屏障，一个参与者已经完成了当前阶段，但不需要等待其他参与者继续执行。要小心使用此方法，因为它不会与其他线程同步。'
- en: '`awaitAdvance(int``phase)`: This method puts the current thread to sleep until
    all the participants of the phaser have finished the current phase of the phaser,
    if the number we pass as the parameter is equal to the actual phase of the phaser.
    If the parameter and the actual phase of the phaser aren''t equal, the method
    returns immediately.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitAdvance(int``phase)`: 此方法将当前线程休眠，直到屏障的所有参与者完成屏障的当前阶段，如果我们传递的参数等于屏障的实际阶段。如果参数和屏障的实际阶段不相等，方法会立即返回。'
- en: '`awaitAdvanceInterruptibly(int``phaser)`: This method is equal to the method
    explained earlier, but it throws an `InterruptedException` exception if the thread
    that is sleeping in this method is interrupted.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitAdvanceInterruptibly(int phaser)`: 此方法与前面解释的方法相同，但如果在此方法中休眠的线程被中断，则会抛出`InterruptedException`异常。'
- en: Registering participants in the Phaser
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Phaser中注册参与者
- en: 'When you create a `Phaser` object, you indicate how many participants will
    have that phaser. But the `Phaser` class has two methods to increment the number
    of participants of a phaser. These methods are as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建`Phaser`对象时，您会指示该phaser将有多少参与者。但是`Phaser`类有两种方法来增加phaser的参与者数量。这些方法如下：
- en: '`register()`: This method adds a new participant to `Phaser`. This new participant
    will be considered as unarrived to the actual phase.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register()`: 此方法向`Phaser`添加一个新的参与者。这个新的参与者将被视为未到达当前阶段。'
- en: '`bulkRegister(int``Parties)`: This method adds the specified number of participants
    to the phaser. These new participants will be considered as unarrived to the actual
    phase.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bulkRegister(int Parties)`: 此方法向phaser添加指定数量的参与者。这些新参与者将被视为未到达当前阶段。'
- en: The only method provided by the `Phaser` class to decrement the number of participants
    is the `arriveAndDeregister()` method that notifies the phaser that the thread
    has finished the actual phase, and it doesn't want to continue with the phased
    operation.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供的唯一方法来减少参与者数量是`arriveAndDeregister()`方法，该方法通知phaser线程已完成当前阶段，并且不希望继续进行分阶段操作。'
- en: Forcing the termination of a Phaser
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制终止Phaser
- en: When a phaser has zero participants, it enters a state denoted by **Termination**.
    The `Phaser` class provides `forceTermination()` to change the status of the phaser
    and makes it enter in the Termination state independently of the number of participants
    registered in the phaser. This mechanism may be useful when one of the participants
    has an error situation, to force the termination of the phaser.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当phaser没有参与者时，它进入由**终止**表示的状态。`Phaser`类提供了`forceTermination()`来改变phaser的状态，并使其独立于phaser中注册的参与者数量进入终止状态。当参与者中有一个出现错误情况时，强制终止phaser可能会有用。
- en: When a phaser is in the Termination state, the `awaitAdvance()` and `arriveAndAwaitAdvance()`
    methods immediately return a negative number, instead of a positive one that returns
    normally. If you know that your phaser could be terminated, you should verify
    the return value of those methods to know if the phaser has been terminated.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当phaser处于终止状态时，`awaitAdvance()`和`arriveAndAwaitAdvance()`方法立即返回一个负数，而不是通常返回的正数。如果您知道您的phaser可能被终止，您应该验证这些方法的返回值，以了解phaser是否已终止。
- en: See also
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Monitoring a Phaser* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第8章](ch08.html "第8章。测试并发应用程序")中的*监视Phaser*示例，*测试并发应用程序*'
- en: Controlling phase change in concurrent phased tasks
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制并发分阶段任务中的相位变化
- en: 'The `Phaser` class provides a method that is executed each time the phaser
    changes the phase. It''s the `onAdvance()` method. It receives two parameters:
    the number of the current phase and the number of registered participants; it
    returns a `Boolean` value, `false` if the phaser continues its execution, or `true`
    if the phaser has finished and has to enter into the termination state.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了一个在phaser改变相位时执行的方法。这是`onAdvance()`方法。它接收两个参数：当前相位的编号和注册参与者的数量；它返回一个`Boolean`值，如果phaser继续执行，则返回`false`，如果phaser已完成并且必须进入终止状态，则返回`true`。'
- en: The default implementation of this method returns `true` if the number of registered
    participants is zero, and `false` otherwise. But you can modify this behavior
    if you extend the `Phaser` class and you override this method. Normally, you will
    be interested in doing this when you have to execute some actions when you advance
    from one phase to the next one.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的默认实现在注册的参与者数量为零时返回`true`，否则返回`false`。但是，如果您扩展`Phaser`类并覆盖此方法，则可以修改此行为。通常，当您必须在从一个阶段前进到下一个阶段时执行一些操作时，您会对此感兴趣。
- en: In this recipe, you will learn how to control the phase change in a phaser that
    is implementing your own version of the `Phaser` class that overrides the `onAdvance()`
    method to execute some actions in every phase change. You are going to implement
    a simulation of an exam, where there will be some students who have to do three
    exercises. All the students have to finish one exercise before they can proceed
    with the next one.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何控制实现自己版本的`Phaser`类中的相位变化，该类覆盖了`onAdvance()`方法以在每个相位变化时执行一些操作。您将实现一个考试的模拟，其中将有一些学生需要完成三个练习。所有学生都必须在进行下一个练习之前完成一个练习。
- en: Getting ready
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `MyPhaser` and specify that it extends from the `Phaser`
    class.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyPhaser`的类，并指定它从`Phaser`类扩展。
- en: '[PRE122]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Override the `onAdvance()` method. According to the value of the phase attribute,
    we call a different auxiliary method. If the phase is equal to zero, you have
    to call the `studentsArrived()` method. If the phase is equal to one, you have
    to call the `finishFirstExercise()` method. If the phase is equal to two, you
    have to call the `finishSecondExercise()` method, and if the phase is equal to
    three, you have to call the `finishExam()` method. Otherwise, we return the `true`
    value to indicate that the phaser has terminated.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`onAdvance()`方法。根据阶段属性的值，我们调用不同的辅助方法。如果阶段等于零，你必须调用`studentsArrived()`方法。如果阶段等于一，你必须调用`finishFirstExercise()`方法。如果阶段等于二，你必须调用`finishSecondExercise()`方法，如果阶段等于三，你必须调用`finishExam()`方法。否则，我们返回`true`值以指示phaser已经终止。
- en: '[PRE123]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Implement the auxiliary method `studentsArrived()`. It writes two log messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`studentsArrived()`。它在控制台上写入两条日志消息，并返回`false`值以指示phaser继续执行。
- en: '[PRE124]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Implement the auxiliary method `finishFirstExercise()`. It writes two messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishFirstExercise()`。它在控制台上写入两条消息，并返回`false`值以指示phaser继续执行。
- en: '[PRE125]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Implement the auxiliary method `finishSecondExercise()`. It writes two messages
    to the console and returns the `false` value to indicate that the phaser continues
    with its execution.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishSecondExercise()`。它在控制台上写入两条消息，并返回`false`值以指示phaser继续执行。
- en: '[PRE126]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Implement the auxiliary method `finishExam()`. It writes two messages to the
    console and returns the `true` value to indicate that the phaser has finished
    its work.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`finishExam()`。它在控制台上写入两条消息，并返回`true`值以指示phaser已经完成了它的工作。
- en: '[PRE127]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Create a class named `Student` and specify that it implements the `Runnable`
    interface. This class will simulate the students of the exam.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Student`的类，并指定它实现`Runnable`接口。这个类将模拟考试的学生。
- en: '[PRE128]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Declare a `Phaser` object named `phaser`.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`phaser`的`Phaser`对象。
- en: '[PRE129]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Implement the constructor of the class that initializes the `Phaser` object.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化`Phaser`对象的类的构造函数。
- en: '[PRE130]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Implement the `run()` method that will simulate the realization of the exam.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将模拟考试的`run()`方法。
- en: '[PRE131]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: First, the method writes a message in the console to indicate that this student
    has arrived to the exam and calls the `arriveAndAwaitAdvance()` method of the
    phaser to wait for the rest of the threads.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该方法在控制台中写入一条消息，指示该学生已经到达考试，并调用phaser的`arriveAndAwaitAdvance()`方法等待其他线程完成第一个练习。
- en: '[PRE132]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Then, write a message to the console, call the private `doExercise1()` method
    that simulates the realization of the first exercise of the exam, write another
    message to the console and the `arriveAndAwaitAdvance()` method of the phaser
    to wait for the rest of the students to finish the first exercise.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在控制台上写一条消息，调用私有的`doExercise1()`方法来模拟考试的第一个练习，再在控制台上写一条消息，并调用phaser的`arriveAndAwaitAdvance()`方法等待其他学生完成第一个练习。
- en: '[PRE133]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Implement the same code for second exercise and third execise.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第二个练习和第三个练习实现相同的代码。
- en: '[PRE134]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Implement the auxiliary method `doExercise1()`. This method puts the thread
    to sleep for a random period of time.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise1()`。这个方法让线程睡眠一段随机时间。
- en: '[PRE135]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Implement the auxiliary method `doExercise2()`. This method puts the thread
    to sleep for a random period of time.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise2()`。这个方法让线程睡眠一段随机时间。
- en: '[PRE136]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Implement the auxiliary method `doExercise3()`. This method puts the thread
    to sleep for a random period of time.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现辅助方法`doExercise3()`。这个方法让线程睡眠一段随机时间。
- en: '[PRE137]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE138]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Create a `MyPhaser` object.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyPhaser`对象。
- en: '[PRE139]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Create five `Student` objects and register them in the phaser using the `register()`
    method.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Student`对象，并使用`register()`方法在phaser中注册它们。
- en: '[PRE140]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Create five threads to run `students` and start them.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个线程来运行`students`并启动它们。
- en: '[PRE141]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Wait for the finalization of the five threads.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待五个线程的完成。
- en: '[PRE142]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Write a message to show that the phaser is in the termination state using the
    `isTerminated()` method.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息来显示phaser处于终止状态，使用`isTerminated()`方法。
- en: '[PRE143]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: How it works...
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This exercise simulates the realization of an exam that has three exercises.
    All the students have to finish one exercise before they can start the next one.
    To implement this synchronization requirement, we use the `Phaser` class, but
    you have implemented your own phaser extending the original class to override
    the `onAdvance()` method.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习模拟了一个有三个练习的考试的实现。所有学生都必须在开始下一个练习之前完成一个练习。为了实现这个同步要求，我们使用了`Phaser`类，但你已经实现了自己的phaser，扩展了原始类以覆盖`onAdvance()`方法。
- en: This method is called by the phaser before making a phase change and before
    waking up all the threads that were sleeping in the `arriveAndAwaitAdvance()`
    method. This method receives as parameters the number of the actual phase, where
    `0` is the number of the first phase and the number of registered participants.
    The most useful parameter is the actual phase. If you execute a different operation
    depending on the actual phase, you have to use an alternative structure (`if`/`else`
    or `switch`) to select the operation you want to execute. In the example, we used
    a `switch` structure to select a different method for each change of phase.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在phaser在进行阶段改变之前和在唤醒所有在`arriveAndAwaitAdvance()`方法中睡眠的线程之前被phaser调用。这个方法接收实际阶段的编号作为参数，其中`0`是第一个阶段的编号，注册参与者的数量。最有用的参数是实际阶段。如果根据实际阶段执行不同的操作，你必须使用一个替代结构（`if`/`else`或`switch`）来选择你想要执行的操作。在这个例子中，我们使用了一个`switch`结构来选择每个阶段变化的不同方法。
- en: The `onAdvance()` method returns a `Boolean` value that indicates if the phaser
    has terminated or not. If the phaser returns a `false` value, it indicates that
    it hasn't terminated, so the threads will continue with the execution of other
    phases. If the phaser returns a `true` value, then the phaser still wakes up the
    pending threads, but moves the phaser to the terminated state, so all the future
    calls to any method of the phaser will return immediately, and the `isTerminated()`
    method returns the `true` value.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAdvance()`方法返回一个`Boolean`值，指示phaser是否已终止。如果phaser返回`false`值，则表示它尚未终止，因此线程将继续执行其他阶段。如果phaser返回`true`值，则phaser仍然唤醒挂起的线程，但将phaser移动到终止状态，因此对phaser的任何方法的未来调用都将立即返回，并且`isTerminated()`方法返回`true`值。'
- en: In the `Core` class, when you created the `MyPhaser` object, you didn't specify
    the number of participants in the phaser. You made a call to the `register()`
    method for every `Student` object created to register a participant in the phaser.
    This calling doesn't establish a relation between the `Student` object or the
    thread that executes it and the phaser. Really, the number of participants in
    a phaser is only a number. There is no relationship between the phaser and the
    participants.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Core`类中，当您创建`MyPhaser`对象时，您没有指定phaser中参与者的数量。您为每个创建的`Student`对象调用`register()`方法来注册phaser中的参与者。这种调用并不建立`Student`对象或执行它的线程与phaser之间的关系。实际上，phaser中的参与者数量只是一个数字。phaser和参与者之间没有关系。
- en: 'The following screenshot shows the results of an execution of this example:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例的执行结果：
- en: '![How it works...](img/7881_03_05.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_03_05.jpg)'
- en: You can see how the students finish the first exercise at different times. When
    all have finished that exercise, the phaser calls the `onAdvance()` method that
    writes the log messages in the console and then all the students start the second
    exercise at the same time.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到学生们在不同时间完成第一个练习。当所有人都完成了那个练习时，phaser调用`onAdvance()`方法在控制台中写入日志消息，然后所有学生同时开始第二个练习。
- en: See also
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Running concurrent phased tasks* recipe in [Chapter 3](ch03.html "Chapter 3. Thread
    Synchronization Utilities"), *Thread Synchronization Utilities*
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 线程同步实用程序")中的*运行并发分阶段任务*食谱，*线程同步实用程序*'
- en: The *Monitoring a Phaser* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 测试并发应用程序")中的*监视Phaser*食谱，*测试并发应用程序*'
- en: Changing data between concurrent tasks
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并发任务之间交换数据
- en: The Java concurrency API provides a synchronization utility that allows the
    interchange of data between two concurrent tasks. In more detail, the `Exchanger`
    class allows the definition of a synchronization point between two threads. When
    the two threads arrive to this point, they interchange a data structure so the
    data structure of the first thread goes to the second one and the data structure
    of the second thread goes to the first one.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了一个同步实用程序，允许在两个并发任务之间交换数据。更详细地说，`Exchanger`类允许在两个线程之间定义同步点。当两个线程到达此点时，它们交换一个数据结构，因此第一个线程的数据结构传递给第二个线程，第二个线程的数据结构传递给第一个线程。
- en: This class may be very useful in a situation similar to the producer-consumer
    problem. This is a classic concurrent problem where you have a common buffer of
    data, one or more producers of data, and one or more consumers of data. As the
    `Exchanger` class only synchronizes two threads, you can use it if you have a
    producer-consumer problem with one producer and one consumer.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在类似生产者-消费者问题的情况下可能非常有用。这是一个经典的并发问题，其中有一个共同的数据缓冲区，一个或多个数据生产者和一个或多个数据消费者。由于`Exchanger`类只同步两个线程，所以如果你有一个只有一个生产者和一个消费者的生产者-消费者问题，你可以使用它。
- en: In this recipe, you will learn how to use the `Exchanger` class to solve the
    producer-consumer problem with one producer and one consumer.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`Exchanger`类来解决只有一个生产者和一个消费者的生产者-消费者问题。
- en: Getting ready
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE like NetBeans, open it and create a new Java project.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他类似NetBeans的IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, let's begin by implementing the producer. Create a class named `Producer`
    and specify that it implements the `Runnable` interface.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们开始实现生产者。创建一个名为`Producer`的类，并指定它实现`Runnable`接口。
- en: '[PRE144]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Declare a `List<String>` object named `buffer`. This will be the data structure
    that the producer will interchange with the consumer.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`buffer`的`List<String>`对象。这将是生产者与消费者进行交换的数据结构。
- en: '[PRE145]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Declare an `Exchanger<List<String>>` object named `exchanger`. This will be
    the exchanger object that will be used to synchronize producer and consumer.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`exchanger`的`Exchanger<List<String>>`对象。这将是用于同步生产者和消费者的交换对象。
- en: '[PRE146]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Implement the constructor of the class that initializes the two attributes.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化两个属性的类的构造函数。
- en: '[PRE147]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Implement the `run()` method. Inside it, implement 10 cycles of interchange.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。在其中，实现10个交换周期。
- en: '[PRE148]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: In each cycle, add 10 strings to the buffer.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环中，向缓冲区添加10个字符串。
- en: '[PRE149]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Call the `exchange()` method to interchange data with the consumer. As this
    method can throw an `InterruptedException` exception, you have to add the code
    to process it.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`exchange()`方法与消费者交换数据。由于这个方法可能抛出`InterruptedException`异常，你必须添加处理它的代码。
- en: '[PRE150]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Now, let's implement the consumer. Create a class named `Consumer` and specify
    that it implements the `Runnable` interface.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现消费者。创建一个名为`Consumer`的类，并指定它实现`Runnable`接口。
- en: '[PRE151]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Declare a `List<String>` object named `buffer`. This will be the data structure
    that the producer will interchange with the consumer.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`buffer`的`List<String>`对象。这将是生产者与消费者进行交换的数据结构。
- en: '[PRE152]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Declare an `Exchanger<List<String>>` object named `exchanger`. This will be
    the exchanger object that will be used to synchronize producer and consumer.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`exchanger`的`Exchanger<List<String>>`对象。这将是用于同步生产者和消费者的交换对象。
- en: '[PRE153]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Implement the constructor of the class that initializes the two attributes.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现初始化两个属性的类的构造函数。
- en: '[PRE154]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Implement the `run()` method. Inside it, implement 10 cycles of interchange.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。在其中，实现10个交换周期。
- en: '[PRE155]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In each cycle, begin with a call to the `exchange()` method to synchronize with
    the producer. The consumer needs data to consume. As this method can throw an
    `InterruptedException` exception, you have to add the code to process it.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个周期中，首先调用`exchange()`方法与生产者同步。消费者需要数据来消费。由于此方法可能抛出`InterruptedException`异常，因此您必须添加处理它的代码。
- en: '[PRE156]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Write the 10 strings the producer sent in its buffer to the console and delete
    them from the buffer, to leave it empty.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生产者发送到其缓冲区的10个字符串写入控制台并从缓冲区中删除它们，使其保持为空。
- en: '[PRE157]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Now, implement the main class of the example by creating a class named `Core`
    and add the `main()` method to it.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为`Core`的类并为其添加`main()`方法来实现示例的主类。
- en: '[PRE158]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Create the two buffers that will be used by the producer and the consumer.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建生产者和消费者将使用的两个缓冲区。
- en: '[PRE159]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Create the `Exchanger` object that will be used to synchronize the producer
    and the consumer.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Exchanger`对象，用于同步生产者和消费者。
- en: '[PRE160]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Create the `Producer` object and the `Consumer` object.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Producer`对象和`Consumer`对象。
- en: '[PRE161]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Create the threads to execute the producer and the consumer and start the threads.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建线程来执行生产者和消费者，并启动线程。
- en: '[PRE162]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: How it works...
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The consumer begins with an empty buffer and calls `Exchanger` to synchronize
    with the producer. It needs data to consume. The producer begins its execution
    with an empty buffer. It creates 10 strings, stores it in the buffer, and uses
    the exchanger to synchronize withthe consumer.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者从一个空缓冲区开始，并调用`Exchanger`与生产者同步。它需要数据来消费。生产者从一个空缓冲区开始执行。它创建10个字符串，将其存储在缓冲区中，并使用交换器与消费者同步。
- en: At this point, both threads (producer and consumer) are in `Exchanger` and it
    changes the data structures, so when the consumer returns from the `exchange()`
    method, it will have a buffer with 10 strings. When the producer returns from
    the `exchange()` method, it will have an empty buffer to fill again. This operation
    will be repeated 10 times.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，生产者和消费者两个线程都在`Exchanger`中，并且它会更改数据结构，因此当消费者从`exchange()`方法返回时，它将拥有一个包含10个字符串的缓冲区。当生产者从`exchange()`方法返回时，它将有一个空的缓冲区再次填充。这个操作将重复10次。
- en: If you execute the example, you will see how producer and consumer do their
    jobs concurrently and how the two objects interchange their buffers in every step.
    As it occurs with other synchronization utilities, the first thread that calls
    the `exchange()` method was put to sleep until the other threads arrived.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行示例，您将看到生产者和消费者如何同时执行其工作，以及两个对象如何在每一步中交换它们的缓冲区。与其他同步工具一样，调用`exchange()`方法的第一个线程将被放到睡眠状态，直到其他线程到达。
- en: There's more...
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Exchanger` class has another version of the exchange method: `exchange(V`
    `data,` `long` `time,` `TimeUnit` `unit)` where `V` is the type used as a parameter
    in the declaration of `Phaser` (`List<String>` in our case). The thread will be
    sleeping until it''s interrupted, the other thread arrives, or the specified time
    passes. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exchanger`类有另一个版本的交换方法：`exchange(V data, long time, TimeUnit unit)`，其中`V`是在`Phaser`声明中使用的类型（在我们的例子中是`List<String>`）。线程将休眠，直到被中断，另一个线程到达，或者指定的时间过去。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`，`HOURS`，`MICROSECONDS`，`MILLISECONDS`，`MINUTES`，`NANOSECONDS`和`SECONDS`。'
