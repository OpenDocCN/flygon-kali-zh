- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Blazor WebAssembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly
- en: In this chapter, you will learn how to implement a presentation layer with Blazor
    WebAssembly. Blazor WebAssembly applications are C# applications that can run
    in any browser that supports the WebAssembly technology. They can be accessed
    by navigating to a specific URL and are downloaded in the browser as standard
    static content, made of HTML pages and downloadable files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Blazor WebAssembly实现演示层。Blazor WebAssembly应用程序是C#应用程序，可以在支持WebAssembly技术的任何浏览器中运行。它们可以通过导航到特定的URL进行访问，并以标准静态内容的形式在浏览器中下载，由HTML页面和可下载文件组成。
- en: Blazor applications use many technologies we already analyzed in *Chapter 15*,
    *Presenting ASP.NET Core MVC*, such as dependency injection and Razor. Therefore,
    we strongly recommend studying *Chapter 15*, *Presenting ASP.NET Core MVC*, before
    reading this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序使用了我们在第15章《介绍ASP.NET Core MVC》中已经分析过的许多技术，比如依赖注入和Razor。因此，我们强烈建议在阅读本章之前先学习第15章《介绍ASP.NET
    Core MVC》。
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，您将学习以下主题：
- en: Blazor WebAssembly architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor WebAssembly架构
- en: Blazor pages and components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor页面和组件
- en: Blazor forms and validation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor表单和验证
- en: Blazor advanced features, such as globalization, authentication, and JavaScript
    interoperability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor高级特性，如全球化、身份验证和JavaScript互操作性
- en: Third-party tools for Blazor WebAssembly
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor WebAssembly的第三方工具
- en: 'Use case: implementing a simple application in Blazor WebAssembly'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例：在Blazor WebAssembly中实现一个简单的应用程序
- en: While there is also server-side Blazor, which runs on the server like ASP.NET
    Core MVC, this chapter discusses just Blazor WebAssembly, which runs entirely
    in the user's browser, since the main purpose of the chapter is to furnish a relevant
    example of how to implement a presentation layer with client-side technology.
    Moreover, as a server-side technology, Blazor can't furnish a performance that
    is comparable with other server-side technologies like ASP.NET Core MVC, which
    we already analyzed in *Chapter 15*, *Presenting ASP.NET Core MVC*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然也有运行在服务器上的Blazor，就像ASP.NET Core MVC一样，但本章仅讨论Blazor WebAssembly，它完全在用户的浏览器中运行，因为本章的主要目的是提供一个相关的示例，展示如何使用客户端技术实现演示层。此外，作为一种服务器端技术，Blazor无法提供与其他服务器端技术（如ASP.NET
    Core MVC）相媲美的性能，我们已经在第15章《介绍ASP.NET Core MVC》中进行了分析。
- en: The first section gives a sketch of the general Blazor WebAssembly architecture,
    while the remaining sections describe specific features. When needed, concepts
    are clarified by analyzing and modifying the example code that Visual Studio generates
    automatically when one selects the Blazor WebAssembly project template. The last
    section shows how to use all the concepts learned in practice with the implementation
    of a simple application based on the WWTravelClub book use case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一节概述了Blazor WebAssembly的总体架构，而其余部分描述了具体特性。在需要时，通过分析和修改Visual Studio在选择Blazor
    WebAssembly项目模板时自动生成的示例代码来澄清概念。最后一节展示了如何将学到的所有概念应用到实践中，实现一个基于WWTravelClub书籍用例的简单应用程序。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all database tools installed. All concepts are clarified with a simple example
    application, based on the WWTravelClub book use case. The code for this chapter
    is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费的Visual Studio 2019社区版或更高版本，并安装了所有数据库工具。所有概念都将通过一个简单的示例应用程序进行澄清，该应用程序基于WWTravelClub书籍用例。本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)上找到。
- en: Blazor WebAssembly architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly架构
- en: Blazor WebAssembly exploits the new WebAssembly browser feature to execute the
    .NET runtime in the browser. This way, it enables all developers to use the whole
    .NET code base and ecosystem in the implementation of applications capable of
    running in any WebAssembly compliant browser. WebAssembly was conceived as a high-performance
    alternative to JavaScript. It is an assembly capable of running in a browser and
    obeying the same limitations as JavaScript code. This means that WebAssembly code,
    like JavaScript code, runs in an isolated execution environment that has very
    limited access to all machine resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly利用了新的WebAssembly浏览器功能，在浏览器中执行.NET运行时。这样，它使所有开发人员都能够在任何支持WebAssembly的浏览器中运行的应用程序的实现中使用整个.NET代码库和生态系统。WebAssembly被构想为JavaScript的高性能替代品。它是一种能够在浏览器中运行并遵守与JavaScript代码相同限制的汇编。这意味着WebAssembly代码，就像JavaScript代码一样，运行在一个具有非常有限访问所有机器资源的隔离执行环境中。
- en: WebAssembly differs from similar options of the past, like Flash and Silverlight,
    since it is an official W3C standard. More specifically, it became an official
    standard on December 5, 2019, so it is expected to have a long life. As a matter
    of fact, all mainstream browsers already support it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly与过去的类似选项（如Flash和Silverlight）不同，因为它是W3C的官方标准。更具体地说，它于2019年12月5日成为官方标准，因此预计将有很长的寿命。事实上，所有主流浏览器已经支持它。
- en: However, WebAssembly doesn't bring just performance with it! It also creates
    the opportunity to run whole code bases associated with modern and advanced object-oriented
    languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in
    browsers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WebAssembly不仅带来了性能！它还为现代和先进的面向对象语言（如C++（直接编译）、Java（字节码）和C#（.NET））在浏览器中运行整个代码库创造了机会。
- en: Microsoft advises running .NET code in the browser with the Unity 3D graphic
    framework and Blazor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议使用Unity 3D图形框架和Blazor在浏览器中运行.NET代码。
- en: Before WebAssembly, presentation layers running in a browser could be implemented
    only in JavaScript, with all the problems implied by the maintenance of big code
    bases the language brings with it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebAssembly之前，浏览器中运行的演示层只能用JavaScript实现，这带来了语言维护所带来的所有问题。
- en: Now, with Blazor we can implement complex applications in the modern and advanced
    C#, with all the comforts offered to this language by the C# compiler and Visual
    Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Blazor，我们可以使用现代和先进的C#来实现复杂的应用程序，利用C#编译器和Visual Studio为这种语言提供的所有便利。
- en: Moreover, with Blazor, all .NET developers can use the full power of the .NET
    framework to implement presentation layers that run in the browser and that share
    libraries and classes with all other layers that run on the server side.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用Blazor，所有.NET开发人员都可以利用.NET框架的全部功能来实现在浏览器中运行的表示层，并与在服务器端运行的所有其他层共享库和类。
- en: The subsections that follow describe the overall Blazor architectures. The first
    subsection explores the general concept of a Single-Page Application, pointing
    out Blazor peculiarities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节描述了Blazor架构的整体情况。第一小节探讨了单页应用程序的一般概念，并指出了Blazor的特点。
- en: What is a Single-Page Application?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是单页应用程序？
- en: A **Single-Page Application** (**SPA**) is an HTML-based application, where
    the HTML is changed by code that runs in the browser itself instead of issuing
    a new request to the server and rendering a new HTML page from scratch. SPAs are
    able to simulate a multi-page experience by replacing complete page areas with
    new HTML.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）是一个基于HTML的应用程序，其中HTML由在浏览器中运行的代码更改，而不是向服务器发出新请求并从头开始呈现新的HTML页面。SPA能够通过用新的HTML替换完整的页面区域来模拟多页面体验。'
- en: SPA frameworks are frameworks explicitly designed for implementing SPAs. Before
    WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based
    SPA frameworks are Angular, React.js, and Vue.js.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SPA框架是专门设计用于实现单页应用程序的框架。在WebAssembly出现之前，所有的SPA框架都是基于JavaScript的。最著名的基于JavaScript的SPA框架是Angular、React.js和Vue.js。
- en: All SPA frameworks furnish ways to transform data into HTML to show to the user
    and rely on a module called *router* to simulate page changes. Typically, data
    fills in the placeholders of HTML templates and selects which parts of a template
    to render (if-like constructs), and how many times to render it (for-like constructs).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的SPA框架都提供了将数据转换为HTML以显示给用户的方法，并依赖一个称为*router*的模块来模拟页面更改。通常，数据填充到HTML模板的占位符中，并选择要呈现的模板部分（类似if的结构），以及呈现的次数（类似for的结构）。
- en: The Blazor template language is Razor, which we already described in *Chapter
    15*, *Presenting ASP.NET Core MVC*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor的模板语言是Razor，我们已经在*第15章*中描述过。
- en: In order to increase modularity, code is organized into components that are
    a kind of virtual HTML tag that, once rendered, generates actual HTML markup.
    Like HTML tags, components have their attributes, which are usually called parameters,
    and their custom events. It is up to the developer to ensure that each component
    uses its parameters to create proper HTML and to ensure that it generates adequate
    events. Components can be used inside other components in a hierarchical fashion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加模块化，代码被组织成组件，这些组件是一种虚拟的HTML标记，一旦呈现，就会生成实际的HTML标记。像HTML标记一样，组件有它们的属性，通常被称为参数，以及它们的自定义事件。开发人员需要确保每个组件使用它的参数来创建适当的HTML，并确保它生成足够的事件。组件可以以分层的方式嵌套在其他组件中。
- en: The application router performs its job by selecting components, acting as pages,
    and placing them in predefined areas. Each page component has a web address path
    that is somehow associated with it. This path concatenated with the web application
    domain becomes a URL that univocally identifies the page. As in usual web applications,
    page URLs are used to communicate to the router which page to load, either with
    usual links or with routing methods/functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序路由器通过选择组件来执行其工作，充当页面，并将它们放置在预定义的区域。每个页面组件都有一个与之相关联的Web地址路径。这个路径与Web应用程序域连接在一起，成为一个唯一标识页面的URL。与通常的Web应用程序一样，页面URL用于与路由器通信，以确定要加载哪个页面，可以使用常规链接或路由方法/函数。
- en: Some SPA frameworks also furnish a predefined dependency injection engine in
    order to ensure better separation between components from one side and general-purpose
    services plus business code that runs in the browser on the other side. Among
    the frameworks listed in this subsection, only Blazor and Angular have an out-of-the-box
    dependency injection engine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些SPA框架还提供了预定义的依赖注入引擎，以确保组件与在浏览器中运行的通用服务和业务代码之间有更好的分离。在本小节列出的框架中，只有Blazor和Angular具有开箱即用的依赖注入引擎。
- en: SPA frameworks based on JavaScript usually compile all JavaScript code in a
    few JavaScript files and then perform so-called tree-shaking, that is, the removal
    of all unused code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基于JavaScript的SPA框架通常会将所有JavaScript代码编译成几个JavaScript文件，然后执行所谓的摇树操作，即删除所有未使用的代码。
- en: At the moment, instead, Blazor keeps all DLLs referenced by the main application
    separate, and performs tree-shaking on each of them separately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Blazor将主应用程序引用的所有DLL分开，并对每个DLL执行摇树操作。
- en: The next subsection starts to describe the Blazor architecture. You are encouraged
    to create a Blazor WebAssembly project called `BlazorReview`, so you can inspect
    the code and the constructs explained throughout the chapter. Please select **Individual
    User Accounts** as authentication, and **ASP.NET Core hosted**. This way, Visual
    Studio will also create an ASP.NET Core project that communicates with the Blazor
    client application, with all the authentication and authorization logic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节开始描述Blazor架构。鼓励您创建一个名为`BlazorReview`的Blazor WebAssembly项目，这样您就可以检查整个章节中解释的代码和构造。请选择**个人用户帐户**作为身份验证，以及**ASP.NET
    Core hosted**。这样，Visual Studio还将创建一个与Blazor客户端应用程序通信的ASP.NET Core项目，其中包含所有身份验证和授权逻辑。
- en: '![](img/B16756_16_01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_16_01.png)'
- en: 'Figure 16.1: Creating the BlazorReview application'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：创建BlazorReview应用程序
- en: If you start the application and try to log in or try to access a page that
    requires login, an error should appear saying database migrations have not been
    applied. It should be enough to click the link next to the message to apply the
    pending migrations. Otherwise, as explained in the *Entity Framework Core migrations*
    section of *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*,
    go to the Visual Studio Package Manager Console and run the `Update-Database`
    command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动应用程序并尝试登录或尝试访问需要登录的页面，则应该出现一个错误，指出数据库迁移尚未应用。只需单击消息旁边的链接即可应用待处理的迁移。否则，如*第8章*的*使用C#与数据交互-Entity
    Framework Core*部分中所解释的那样，转到Visual Studio包管理器控制台并运行`Update-Database`命令。
- en: Loading and starting the application
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和启动应用程序
- en: The URL of a Blazor WebAssembly application always includes an `index.html`
    static HTML page. In our `BlazorReview` project, `index.html` is in `BlazorReview.Client->wwwroot->index.html`.
    This page is the container where the Blazor application will create its HTML.
    It contains an HTML header with a `viewport meta` declaration, title, and the
    overall application's CSS. The Visual Studio default project template adds an
    application-specific CSS file and Bootstrap CSS, with a neutral style. You can
    replace the default Bootstrap CSS either with Bootstrap CSS with a customized
    style or with a completely different CSS framework.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly应用程序的URL始终包括一个`index.html`静态HTML页面。在我们的`BlazorReview`项目中，`index.html`位于`BlazorReview.Client->wwwroot->index.html`。此页面是Blazor应用程序将创建其HTML的容器。它包含一个带有`viewport
    meta`声明、标题和整个应用程序CSS的HTML头。Visual Studio默认项目模板添加了一个特定于应用程序的CSS文件和Bootstrap CSS，具有中性样式。您可以使用具有自定义样式的默认Bootstrap
    CSS或完全不同的CSS框架来替换默认的Bootstrap CSS。
- en: 'The body contains the code that follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正文包含以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The initial `div` is where the application will place the code it generates.
    Any markup placed inside this `div` will appear just while the Blazor application
    is loading and starting, then it will be replaced by the application-generated
    HTML. The second `div` is normally invisible and appears only when Blazor intercepts
    an unhandled exception.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`div`是应用程序将放置其生成的代码的地方。放置在此`div`中的任何标记都将在Blazor应用程序加载和启动时出现，然后将被应用程序生成的HTML替换。第二个`div`通常是不可见的，只有在Blazor拦截到未处理的异常时才会出现。
- en: '`blazor.webassembly.js` contains the JavaScript part of the Blazor framework.
    Among other things, it takes care of downloading the .NET runtime, together with
    all application DLLs. More specifically, `blazor.webassembly.js` downloads the
    `blazor.boot.json` file that lists all application files with their hashes. Then,
    `blazor.webassembly.js` downloads all resources listed in this file and verifies
    their hashes. All resources downloaded by `blazor.webassembly.js` are created
    when the application is built or published.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`blazor.webassembly.js`包含Blazor框架的JavaScript部分。除其他外，它负责下载.NET运行时以及所有应用程序DLL。更具体地说，`blazor.webassembly.js`下载列出所有应用程序文件及其哈希值的`blazor.boot.json`文件。然后，`blazor.webassembly.js`下载此文件中列出的所有资源并验证它们的哈希值。`blazor.webassembly.js`下载的所有资源都是在构建或发布应用程序时创建的。'
- en: '`AuthenticationService.js` is added only when the project enables authentication
    and takes care of the `OpenID Connect` protocol used by Blazor to exploit other
    authentication credentials like cookies to get bearer tokens, which are the preferred
    authentication credentials for clients that interact with a server through Web
    APIs. Authentication is discussed in more detail in the *Authentication and authorization*
    subsection later on in this chapter, while bearer tokens are discussed in the
    *REST services authorization and authentication* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在项目启用身份验证时才会添加`AuthenticationService.js`，它负责Blazor利用其他身份验证凭据（如cookie）来获取承载令牌的`OpenID
    Connect`协议。承载令牌是客户端通过Web API与服务器交互的首选身份验证凭据。身份验证将在本章后面的*身份验证和授权*子章节中更详细地讨论，而承载令牌将在*第14章*的*应用Service-Oriented
    Architectures with .NET Core*部分中讨论。
- en: 'The Blazor application entry point is in the `BlazorReview.Client->Program.cs`
    file. It has the following structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序的入口点在`BlazorReview.Client->Program.cs`文件中。它具有以下结构：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`WebAssemblyHostBuilder` is a builder for creating a `WebAssemblyHost`, which
    is a WebAssembly-specific implementation of the generic host discussed in the
    *Using generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application* (you are encouraged to review that subsection).
    The first builder configuration instruction declares the Blazor root component
    (`App`), which will contain the whole components tree, and in which HTML tag of
    the `Index.html` page to place it (`#app`). More specifically, `RootComponents.Add`
    adds a hosted service that takes care of handling the whole Blazor components
    tree. We can run several Blazor WebAssembly user interfaces in the same HTML page
    by calling `RootComponents.Add` several times, each time with a different HTML
    tag reference.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssemblyHostBuilder`是用于创建`WebAssemblyHost`的构建器，它是在*第5章*的*将微服务架构应用于企业应用程序*中讨论的通用主机的WebAssembly特定实现（鼓励您查看该子章节）。第一个构建器配置指令声明了Blazor根组件（`App`），它将包含整个组件树，并在`Index.html`页面的哪个HTML标记中放置它（`#app`）。更具体地说，`RootComponents.Add`添加了一个托管服务，负责处理整个Blazor组件树。我们可以通过多次调用`RootComponents.Add`在同一个HTML页面中运行多个Blazor
    WebAssembly用户界面，每次使用不同的HTML标记引用。'
- en: '`builder.Services` contains all the usual methods and extension methods to
    add services to the Blazor application dependency engine: `AddScoped`, `AddTransient`,
    `AddSingleton`, and so on. Like in ASP.NET Core MVC applications (*Chapter 15*,
    *Presenting ASP.NET Core MVC*), services are the preferred places to implement
    business logic and to store shared state. While in ASP.NET Core MVC, services
    were usually passed to controllers, in Blazor WebAssembly, they are injected into
    components.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder.Services`包含了所有通常的方法和扩展方法，用于向Blazor应用程序的依赖引擎添加服务：`AddScoped`、`AddTransient`、`AddSingleton`等等。就像在ASP.NET
    Core MVC应用程序中一样（*第15章*，*介绍ASP.NET Core MVC*），服务是实现业务逻辑和存储共享状态的首选位置。在ASP.NET Core
    MVC中，服务通常传递给控制器，而在Blazor WebAssembly中，它们被注入到组件中。'
- en: The next subsection explains how the root `App` component simulates page changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将解释根`App`组件如何模拟页面更改。
- en: Routing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'The root `App` class referenced by the host building code is defined in the
    `BlazorReview.Client->App.razor` file. `App` is a Blazor component, and like all
    Blazor components, it is defined in a file with a `.razor` extension and uses
    Razor syntax enriched with component notation, that is, with HTML-like tags that
    represent other Blazor components. It contains the whole logic for handling application
    pages:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由主机构建代码引用的根`App`类在`BlazorReview.Client->App.razor`文件中定义。`App`是一个Blazor组件，像所有Blazor组件一样，它是在具有`.razor`扩展名的文件中定义的，并且使用富有组件标记的Razor语法，即用表示其他Blazor组件的类似HTML的标签。它包含了处理应用程序页面的全部逻辑：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All tags in the preceding code represent either components or particular component
    parameters, called templates. Components will be discussed in detail throughout
    the chapter. For the moment, imagine them as a kind of custom HTML tag that we
    can define somehow with C# and Razor code. Templates, instead, are parameters
    that accept Razor markup as values. Templates are discussed in the *Templates
    and cascading parameters* subsection later on in this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的所有标记都代表组件或特定的组件参数，称为模板。组件将在本章中详细讨论。暂时想象它们是一种我们可以用C#和Razor代码定义的自定义HTML标记。模板则是接受Razor标记作为值的参数。模板将在本节的*模板和级联参数*小节中讨论。
- en: The `CascadingAuthenticationState` component has the only function of passing
    authentication and authorization information to all components of the component
    tree that is inside of it. Visual Studio generates it only if one chooses to add
    authorization during project creation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingAuthenticationState`组件的唯一功能是将身份验证和授权信息传递给其内部组件树中的所有组件。只有在项目创建过程中选择添加授权时，Visual
    Studio才会生成它。'
- en: The `Router` component is the actual application router. It scans the assembly
    passed in the `AppAssembly` parameter looking for components containing routing
    information, that is, for components that can work as pages. Visual studio passes
    it the assembly that contains the `Program` class, that is, the main application.
    Pages contained in other assemblies can be added through the `AdditionalAssemblies`
    parameter, which accepts an `IEnumerable` of assemblies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`组件是实际的应用程序路由器。它扫描`AppAssembly`参数中传递的程序集，寻找包含路由信息的组件，即可以作为页面工作的组件。Visual
    Studio将包含`Program`类的程序集传递给它，即主应用程序。其他程序集中包含的页面可以通过`AdditionalAssemblies`参数添加，该参数接受一个程序集的`IEnumerable`。'
- en: After that, the router intercepts all page changes performed either by code
    or through the usual `<a>` HTML tags that point to an address inside of the application
    base address. Navigation can be handled by code by requiring a `NavigationManager`
    instance from dependency injection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，路由器拦截所有通过代码或通过通常的`<a>` HTML标签执行的页面更改，这些标签指向应用程序基地址内的地址。导航可以通过代码处理，通过从依赖注入中要求`NavigationManager`实例来处理。
- en: 'The `Router` component has two templates, one for the case where a page for
    the requested URI is found (`Found`), and the other for the case where it is not
    found (`NotFound`). When the application uses authorization, the `Found` template
    consists of the `AuthorizeRouteView` components, which further distinguish whether
    the user is authorized to access the selected page or not. When the application
    doesn''t use authorization, the `Found` template consists of the `RouteView` component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`组件有两个模板，一个用于找到请求的URI的页面（`Found`），另一个用于找不到请求的页面（`NotFound`）。当应用程序使用授权时，`Found`模板由`AuthorizeRouteView`组件组成，进一步区分用户是否有权访问所选页面。当应用程序不使用授权时，`Found`模板由`RouteView`组件组成：'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`RouteView` takes the selected page and renders it inside the layout page specified
    by the `DefaultLayout` parameter. This specification acts just as a default since
    each page can override it by specifying a different layout page. Blazor layout
    pages work similarly to ASP.NET Core MVC layout pages described in the *Reusing
    view code* subsection of *Chapter 15*, *Presenting ASP.NET Core MVC*, the only
    difference being that the place to add the page markup is specified with `@Body`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteView`接受所选页面，并在由`DefaultLayout`参数指定的布局页面内呈现它。这个规范只是一个默认值，因为每个页面都可以通过指定不同的布局页面来覆盖它。Blazor布局页面的工作方式类似于*第15章*，*介绍ASP.NET
    Core MVC*中描述的ASP.NET Core MVC布局页面，唯一的区别是指定页面标记的位置是用`@Body`指定的：'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the Visual Studio template, the default layout page is in the `BlazorReview.Client->Shared->MainLayout.razor`
    file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio模板中，默认的布局页面位于`BlazorReview.Client->Shared->MainLayout.razor`文件中。
- en: 'If the application uses authorization, `AuthorizeRouteView` works like `RouteView`,
    but it also allows the specification of a template for a case where the user is
    not authorized:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用授权，`AuthorizeRouteView`的工作方式类似于`RouteView`，但它还允许指定一个用户未经授权的情况下的模板：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the user is not authenticated, the `RedirectToLogin` component uses a `NavigationManager`
    instance to move to the login logic page, otherwise, it informs the user they
    haven't got enough privileges to access the selected page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未经过身份验证，`RedirectToLogin`组件将使用`NavigationManager`实例来转到登录逻辑页面，否则，它会通知用户他们没有足够的权限来访问所选页面。
- en: Blazor WebAssembly also allows assemblies lazy loading to reduce the initial
    application loading time, but we will not discuss it here for lack of space. The
    *Further reading* section contains references to the official Blazor documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly还允许程序集延迟加载以减少初始应用程序加载时间，但由于篇幅有限，我们将不在此讨论。*进一步阅读*部分包含了官方Blazor文档的参考资料。
- en: Blazor pages and components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor页面和组件
- en: In this section, you will learn the basics of Blazor components, how to define
    a component, its structure, how to attach events to HTML tags, how to define their
    attributes, and how to use other components inside your components. We have organized
    all content into different subsections. The first subsection describes the basics
    of component structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习Blazor组件的基础知识，如何定义组件，其结构，如何将事件附加到HTML标记，如何定义它们的属性，以及如何在组件内部使用其他组件。我们已将所有内容组织成不同的子节。第一个子节描述了组件结构的基础知识。
- en: Component structure
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件结构
- en: Components are defined in files with a `.razor` extension. Once compiled, they
    become classes that inherit from `ComponentBase`. Like all other Visual Studio
    project elements, Blazor components are available through the **add new item**
    menu. Usually, components to be used as pages are defined in the `Pages` folder,
    or in its subfolders, while other components are organized in different folders.
    Default Blazor projects add all their non-page components inside the `Shared`
    folder, but you can organize them differently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是在扩展名为`.razor`的文件中定义的。一旦编译，它们就变成了从`ComponentBase`继承的类。与所有其他Visual Studio项目元素一样，Blazor组件可以通过**添加新项**菜单获得。通常，要用作页面的组件是在`Pages`文件夹中定义的，或者在其子文件夹中定义，而其他组件则组织在不同的文件夹中。默认的Blazor项目将所有非页面组件添加到`Shared`文件夹中，但您可以以不同的方式组织它们。
- en: 'By default, pages are assigned a namespace that corresponds to the path of
    the folder they are in. Thus, for instance, in our example project, all pages
    that are in the `BlazorReview.Client->Pages` path are assigned to the `BlazorReview.Client.Pages`
    namespace. However, you can change this default namespace with an `@namespace`
    declaration placed in the declaration area that is at the top of the file. This
    area may also contain other important declarations. Following is an example that
    shows all declarations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，页面被分配一个与它们所在文件夹的路径相对应的命名空间。因此，例如，在我们的示例项目中，所有在`BlazorReview.Client->Pages`路径中的页面都被分配到`BlazorReview.Client.Pages`命名空间。但是，您可以通过在文件顶部的声明区域中放置一个`@namespace`声明来更改此默认命名空间。此区域还可以包含其他重要的声明。以下是一个显示所有声明的示例：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first two directives make sense only for components that must work as pages.
    More specifically, the `@layout` directive overrides the default layout page with
    another component, while the `@page` directive defines the path of the page (**route**)
    within the application base URL. Thus, for instance, if our application runs at
    `https://localhost:5001`, then the URL of the above page will be `https://localhost:5001/counter`.
    Page routes can also contain parameters like in this example: `/orderitem/{customer}/{order}`.
    Parameter names must match public properties defined as parameters by the components.
    The match is case-insensitive, and parameters will be explained later on in this
    subsection.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个指令只对必须作为页面工作的组件有意义。更具体地说，`@layout`指令用另一个组件覆盖默认的布局页面，而`@page`指令定义了页面的路径（**路由**）在应用程序的基本URL内。因此，例如，如果我们的应用程序在`https://localhost:5001`上运行，那么上述页面的URL将是`https://localhost:5001/counter`。页面路由也可以包含参数，就像在这个例子中一样：`/orderitem/{customer}/{order}`。参数名称必须与组件定义的参数的公共属性匹配。匹配不区分大小写，并且参数将在本小节后面进行解释。
- en: 'The string that instantiates each parameter is converted into the parameter
    type and if this conversion fails an exception is thrown. This behavior can be
    prevented by associating a type with each parameter, in which case, if the conversion
    to the specified type fails, the match with the page URL fails. Only elementary
    types are supported: `/orderitem/{customer:int}/{order:int}`. Parameters are obligatory,
    that is, if they are not found, the match fails and the router tries other pages.
    However, you can make a parameter optional by specifying two `@page` directives,
    one with the parameter, and the other without the parameter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化每个参数的字符串被转换为参数类型，如果此转换失败，则会抛出异常。可以通过将每个参数与类型关联来防止这种行为，在这种情况下，如果转换为指定类型失败，则与页面URL的匹配失败。只支持基本类型：`/orderitem/{customer:int}/{order:int}`。参数是强制性的，也就是说，如果找不到它们，匹配失败，路由器会尝试其他页面。但是，您可以通过指定两个`@page`指令使参数变为可选，一个带参数，另一个不带参数。
- en: '`@namespace` overrides the default namespace of the component, while `@using`
    is equivalent to the usual C# `using`. `@using` declared in the special `{project
    folder}->_Imports.razor` folder is automatically applied to all components.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`@namespace`覆盖了组件的默认命名空间，而`@using`等同于通常的C# `using`。在特殊的`{project folder}->_Imports.razor`文件夹中声明的`@using`会自动应用于所有组件。'
- en: '`@inherits` declares that the component is a subclass of another component,
    while `@implements` declares it implements an interface.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inherits`声明组件是另一个组件的子类，而`@implements`声明它实现了一个接口。'
- en: '`@typeparam` is used if the component is a generic class, and declares the
    name of the generic parameter, while `@attribute` declares any attribute applied
    to the component class. Property-level attributes are applied directly to properties
    defined in the code area, so they don''t need special notation. The `[Authorize]`
    attribute, applied to a component class used as a page, prevents unauthorized
    users from accessing the page. It works exactly in the same way as when it is
    applied to a controller or to an action method in ASP.NET Core MVC.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是一个泛型类，则使用`@typeparam`，并声明泛型参数的名称，而`@attribute`声明应用于组件类的任何属性。属性级别的属性直接应用于代码区域中定义的属性，因此它们不需要特殊的标记。`[Authorize]`属性应用于作为页面使用的组件类，防止未经授权的用户访问页面。它的工作方式与在ASP.NET
    Core MVC中应用于控制器或操作方法时完全相同。
- en: Finally, the `@inject` directive requires a type instance to the dependency
    injection engine and inserts it in the field declared after the type name; in
    the previous example, in the `navigation` parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`@inject`指令需要一个类型实例来注入依赖注入引擎，并将其插入到类型名称后声明的字段中；在前面的示例中，在`navigation`参数中。
- en: The middle part of the component file contains the HTML that will be rendered
    by the component with Razor markup, enriched with the possible invocation of children
    components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 组件文件的中间部分包含了将由Razor标记呈现的HTML，其中可能包含对子组件的调用。
- en: 'The bottom part of the file is enclosed by an `@code` construct and contains
    fields, properties, and methods of the class that implements the component:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的底部由`@code`构造包围，并包含实现组件的类的字段、属性和方法：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Public properties decorated with the `[Parameter]` attribute work as component
    parameters; that is, when the component is instantiated into another component,
    they are used to pass values to the decorated properties, like values are passed
    to HTML elements in HTML markup:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用`[Parameter]`属性修饰的公共属性作为组件参数工作；也就是说，当组件实例化到另一个组件中时，它们用于将值传递给修饰的属性，就像在HTML标记中将值传递给HTML元素一样：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Values can also be passed to component parameters by page route parameters
    that match the property name in a case invariant match:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以通过页面路由参数传递给组件参数，这些参数与属性名称进行不区分大小写的匹配：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Component parameters can also accept complex types and functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 组件参数也可以接受复杂类型和函数：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If components are generic, they must be passed type values for each generic
    parameter declared with `typeparam`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件是通用的，它们必须为每个使用`typeparam`声明的通用参数传递类型值：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, often, the compiler is able to infer generic types from the type of
    other parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常编译器能够从其他参数的类型中推断出通用类型。
- en: 'Finally, the code enclosed in the `@code` directive can be also declared in
    a partial class with the same name and namespace as the component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`@code`指令包围的代码也可以在与组件相同的名称和命名空间的部分类中声明：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, these partial classes are declared in the same folder of the component
    and with a filename equal to the component file name with a `.cs` postfix added.
    Thus, for instance, the partial class associated with the `counter.razor` component
    will be `counter.razor.cs`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些部分类被声明在与组件相同的文件夹中，并且文件名等于组件文件名加上`.cs`后缀。因此，例如，与`counter.razor`组件关联的部分类将是`counter.razor.cs`。
- en: Each component may also have an associated CSS file, whose name must be the
    name of the component file plus the `.css` postfix. Thus, for instance, the CSS
    file associated with the `counter.razor` component will be `counter.razor.css`.
    The CSS contained in this file is applied only to the component and has no effect
    on the remainder of the page. This is called CSS isolation, and at the moment,
    it is implemented by adding a unique attribute to all component HTML roots. Then,
    all selectors of the component CSS file are scoped to this attribute, so that
    they can't affect other HTML.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件也可以有一个关联的CSS文件，其名称必须是组件文件名加上`.css`后缀。因此，例如，与`counter.razor`组件关联的CSS文件将是`counter.razor.css`。此文件中包含的CSS仅应用于该组件，对页面的其余部分没有影响。这称为CSS隔离，目前是通过向所有组件HTML根添加唯一属性来实现的。然后，组件CSS文件的所有选择器都被限定为此属性，以便它们不能影响其他HTML。
- en: Whenever a component decorates an `IDictionary<string, object>` parameter with
    `[Parameter(CaptureUnmatchedValues = true)]`, then all unmatched parameters inserted
    into the tag, that is, all parameters without a matching component property, are
    added to the `IDictionary` as key-value pairs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个组件用`[Parameter(CaptureUnmatchedValues = true)]`修饰一个`IDictionary<string,
    object>`参数时，那么所有未匹配的参数插入到标签中，也就是所有没有匹配组件属性的参数，都会作为键值对添加到`IDictionary`中。
- en: 'This feature furnishes an easy way to forward parameters to HTML elements or
    ­other children components contained in the component markup. For instance, if
    we have a `Detail` component that displays a detail view of the object passed
    in its `Value` parameter, we can use this feature to forward all usual HTML attributes
    to the root HTML tag of the component, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能提供了一种简单的方法，将参数转发给组件标记中包含的HTML元素或其他子组件。例如，如果我们有一个`Detail`组件，它显示传递给其`Value`参数的对象的详细视图，我们可以使用此功能将所有常规HTML属性转发到组件的根HTML标记，如下例所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This way, usual HTML attributes added to the component tag such as, for instance,
    class, are forwarded to the root `div` of the components and somehow used to style
    the component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，添加到组件标记的常规HTML属性，例如class，将被转发到组件的根`div`，并以某种方式用于样式化组件：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next subsection explains how to pass markup generating functions to components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节解释了如何将生成标记的函数传递给组件。
- en: Templates and cascading parameters
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板和级联参数
- en: Blazor works by building a data structure called a **render tree**, which is
    updated as the UI changes. At each change, Blazor locates the part of the HTML
    that must be rendered and uses the information contained in the **render tree**
    to update it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor通过构建称为**渲染树**的数据结构来工作，该结构在UI更改时进行更新。在每次更改时，Blazor会定位必须呈现的HTML部分，并使用**渲染树**中包含的信息来更新它。
- en: The `RenderFragment` delegate defines a function that is able to add further
    markup to a specific position of the **render tree**. There is also a `RenderFragment<T>`
    that accepts a further argument you can use to drive the markup generation. For
    instance, you can pass a `Customer` object to a `RenderFragment<T>` so that it
    can render all the data for that specific customer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderFragment`委托定义了一个能够向**渲染树**的特定位置添加更多标记的函数。还有一个`RenderFragment<T>`，它接受一个进一步的参数，您可以使用它来驱动标记生成。例如，您可以将`Customer`对象传递给`RenderFragment<T>`，以便它可以呈现该特定客户的所有数据。'
- en: 'You can define a `RenderFragment` or a `RenderFragment<T>` with C# code, but
    the simplest way is to define it in your components with Razor markup. The Razor
    compiler will take care of generating the proper C# code for you:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用C#代码定义`RenderFragment`或`RenderFragment<T>`，但最简单的方法是在组件中使用Razor标记进行定义。Razor编译器将负责为您生成适当的C#代码：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The information on the location to add the markup is passed in the `RenderTreeBuilder`
    argument it receives as an argument. You can use a `RenderFragment` in your component
    Razor markup by simply invoking it as shown in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关添加标记的位置的信息是通过其接收的`RenderTreeBuilder`参数传递的。您可以通过简单调用它来在组件Razor标记中使用`RenderFragment`，如下例所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The position where you invoke the `RenderFragment` defines the location where
    it will add its markup, since the component compiler is able to generate the right
    `RenderTreeBuilder` argument to pass to it. `RenderFragment<T>` delegates are
    invoked as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`RenderFragment`的位置定义了它将添加其标记的位置，因为组件编译器能够生成正确的`RenderTreeBuilder`参数传递给它。`RenderFragment<T>`委托的调用如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Being functions, render fragments can be passed to component parameters like
    all other types. However, Blazor has a specific syntax to make it easier to simultaneously
    define and pass render fragments to components, the **template** syntax. First,
    you define the parameters in your component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数，渲染片段可以像所有其他类型一样传递给组件参数。但是，Blazor有一种特定的语法，使同时定义和传递渲染片段到组件变得更容易，即**模板**语法。首先，在组件中定义参数：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, when you call the customer, you can do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您调用客户时，可以执行以下操作：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each render fragment parameter is represented by a tag with the same name as
    the parameter. You can place the markup that defines the render fragment inside
    of it. For the `CustomerTemplate` that has a parameter, the `Context` keyword
    defines the parameter name inside the markup. In our example, the chosen parameter
    name is `customer`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个渲染片段参数都由与参数同名的标记表示。您可以将定义渲染片段的标记放在其中。对于具有参数的`CustomerTemplate`，`Context`关键字在标记内定义了参数名称。在我们的示例中，选择的参数名称是`customer`。
- en: 'When a component has just one render fragment parameter, if it is named `ChildContent`,
    the template markup can be enclosed directly between the open and end tag of the
    component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件只有一个渲染片段参数时，如果它的名称为`ChildContent`，则模板标记可以直接封闭在组件的开始和结束标记之间：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order to familiarize ourselves with component templates, let's modify the
    `Pages->FetchData.razor` page so that, instead of using a `foreach`, it uses a
    `Repeater` component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉组件模板，让我们修改`Pages->FetchData.razor`页面，以便不再使用`foreach`，而是使用`Repeater`组件。
- en: 'Let''s right-click on the `Shared` folder, select **Add**, then **Razor Component**,
    and add a new **Repeater.razor** component. Then, replace the existing code with
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们右键单击`Shared`文件夹，选择**添加**，然后**Razor组件**，并添加一个新的**Repeater.razor**组件。然后，用以下内容替换现有代码：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The component is defined with a generic parameter so that it can be used with
    any `IEnumerable`. Now let''s replace the markup in the `tbody` of the **FetchData.razor**
    component with this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件使用泛型参数进行定义，以便可以与任何`IEnumerable`一起使用。现在让我们用这个替换**FetchData.razor**组件的`tbody`中的标记：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the `Repeater` component has just one template, and since we named it
    `ChildContent`, we can place our template markup directly within the component
    open and close tags. Run it and verify that the page works properly. You have
    learned how to use templates, and that markup placed inside a component defines
    a template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Repeater`组件只有一个模板，并且我们将其命名为`ChildContent`，因此我们可以直接在组件的开始和结束标记中放置我们的模板标记。运行它并验证页面是否正常工作。您已经学会了如何使用模板，以及放置在组件内部的标记定义了一个模板。
- en: 'An important predefined templated Blazor component is the `CascadingValue`
    component. It renders the content placed inside of it with no changes, but passes
    a type instance to all its descendant components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的预定义模板化Blazor组件是`CascadingValue`组件。它以不进行任何更改地呈现放置在其中的内容，但将类型实例传递给其所有后代组件：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All components placed inside of the `CascadingValue` tag and all their descendant
    components can now capture the instance of `MyOptionsInstance` passed in the `CascadingValueValue`
    parameter. It is enough that the component declares a public or private property
    with a type that is compatible with `MyOptionsInstance` and that decorates it
    with the `CascadingParameter` attribute:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，放置在`CascadingValue`标记内以及所有后代组件中的所有组件都可以捕获传递给`CascadingValueValue`参数的`MyOptionsInstance`实例。只需组件声明一个与`MyOptionsInstance`兼容的类型的公共或私有属性，并使用`CascadingParameter`属性进行修饰即可：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Matching is performed by type compatibility. In case of ambiguity with other
    cascaded parameters with a compatible type, we can specify the `Name` optional
    parameter of the `CascadingValue` component and pass the same name to the `CascadingParameter`
    attribute: `[CascadingParameter("myUnique name")]`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是通过类型兼容性执行的。在与其他具有兼容类型的级联参数存在歧义的情况下，我们可以指定`CascadingValue`组件的`Name`可选参数，并将相同的名称传递给`CascadingParameter`属性：`[CascadingParameter("myUnique
    name")]`。
- en: The `CascadingValue` tag also has an `IsFixed` parameter that should be set
    to `true` whenever possible for performance reasons. In fact, propagating cascading
    values is very useful for passing options and settings, but it has a very high
    computational cost.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingValue`标签还有一个`IsFixed`参数，出于性能原因，应尽可能设置为`true`。实际上，传播级联值非常有用，用于传递选项和设置，但计算成本非常高。'
- en: When `IsFixed` is set to `true`, propagation is performed just once, the first
    time that each piece of involved content is rendered, and then no attempt is made
    to update the cascaded value during the content's lifetime. Thus, `IsFixed` can
    be used whenever the pointer of the cascaded object is not changed during the
    content's lifetime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当`IsFixed`设置为`true`时，传播仅在每个涉及内容的第一次呈现时执行，然后在内容的生命周期内不尝试更新级联值。因此，只要级联对象的指针在内容的生命周期内没有更改，就可以使用`IsFixed`。
- en: An example of a cascading value is the `CascadingAuthenticationState` component
    we encountered in the *Routing* subsection, which cascades authentications and
    authorization information to all rendered components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 级联值的一个例子是我们在*路由*小节中遇到的`CascadingAuthenticationState`组件，它将认证和授权信息级联到所有渲染的组件中。
- en: Events
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Both HTML tags and Blazor components use attributes/parameters to get input.
    HTML tags provide output to the remainder of the page through events, and Blazor
    allows C# functions to be attached to HTML `on{event name}` attributes. The syntax
    is shown in the `Pages->Counter.razor` component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标记和Blazor组件都使用属性/参数来获取输入。HTML标记通过事件向页面的其余部分提供输出，Blazor允许将C#函数附加到HTML的`on{event
    name}`属性。语法显示在`Pages->Counter.razor`组件中：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function can also be passed inline as a lambda. Moreover, it accepts the
    C# equivalent of the usual `event` argument. The *Further reading* section contains
    a link to the Blazor official documentation page that lists all supported events
    and their arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数也可以作为lambda内联传递。此外，它接受通常的`event`参数的C#等价物。*进一步阅读*部分包含了指向Blazor官方文档页面的链接，列出了所有支持的事件及其参数。
- en: 'Blazor also allows events in components, so they can return output, too. Component
    events are parameters whose type is either `EventCallBack` or `EventCallBack<T>`.
    `EventCallBack` is the type of component event with no arguments while `EventCallBack<T>`
    is the type of component event with an argument of type `T`. In order to trigger
    an event, say `MyEvent`, the component calls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor还允许组件中的事件，因此它们也可以返回输出。组件事件是类型为`EventCallBack`或`EventCallBack<T>`的参数。`EventCallBack`是没有参数的组件事件类型，而`EventCallBack<T>`是带有类型为`T`的参数的组件事件类型。为了触发一个事件，比如`MyEvent`，组件调用：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These calls execute the handlers bound to the events or do nothing if no handler
    has been bound.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用执行与事件绑定的处理程序，如果没有绑定处理程序，则不执行任何操作。
- en: 'Once defined, component events can be used exactly in the same way as HTML
    element events, the only difference being that there is no need to prefix the
    event name with an `@`, since `@` in HTML events is needed to distinguish between
    the HTML attribute and the Blazor-added parameter with the same name:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，组件事件可以与HTML元素事件完全相同的方式使用，唯一的区别在于不需要使用`@`前缀来命名事件，因为在HTML事件中，`@`是需要区分HTML属性和Blazor添加的具有相同名称的参数之间的区别：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Actually, HTML element events are also `EventCallBack<T>`, that is why both
    event types behave in exactly the same way. `EventCallBack` and `EventCallBack<T>`
    are structs, not delegates, since they contain a delegate, together with a pointer
    to the entity that must be notified that the event has been triggered. Formally,
    this entity is represented by a `Microsoft.AspNetCore.Components.IHandleEvent`
    interface. Needless to say, all components implement this interface. The notification
    informs `IHandleEvent` that a state change took place. State changes play a fundamental
    role in the way Blazor updates the page HTML. We will analyze them in detail in
    the next subsection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，HTML元素事件也是`EventCallBack<T>`，这就是为什么这两种事件类型的行为完全相同。`EventCallBack`和`EventCallBack<T>`都是结构体，而不是委托，因为它们包含一个委托，以及一个指向必须被通知事件已被触发的实体的指针。从形式上讲，这个实体由`Microsoft.AspNetCore.Components.IHandleEvent`接口表示。不用说，所有组件都实现了这个接口。通知`IHandleEvent`发生了状态变化。状态变化在Blazor更新页面HTML的方式中起着基本作用。我们将在下一小节中详细分析它们。
- en: 'For HTML elements, Blazor also provides the possibility to stop the event''s
    default action and the event bubbling by adding the `:preventDefault` and `:stopPropagation`
    directives to the attribute that specifies the event, like in these examples:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML元素，Blazor还提供了通过向指定事件的属性添加`:preventDefault`和`:stopPropagation`指令来阻止事件的默认操作和事件冒泡的可能性，就像这些例子中一样：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Bindings
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: Often a component parameter value must be kept synchronized with an external
    variable, property, or field. The typical application of this kind of synchronization
    is an object property being edited in an input component or HTML tag. Whenever
    the user changes the input value, the object property must be updated coherently,
    and vice versa. The object property value must be copied into the component as
    soon as the component is rendered so that the user can edit it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组件参数值必须与外部变量、属性或字段保持同步。这种同步的典型应用是在输入组件或HTML标记中编辑的对象属性。每当用户更改输入值时，对象属性必须一致更新，反之亦然。对象属性值必须在组件渲染时立即复制到组件中，以便用户可以编辑它。
- en: Similar scenarios are handled by parameter-event pairs. More specifically, from
    one side, the property is copied in the input component parameter. From the other
    side, each time the input changes value, a component event that updates the property
    is triggered. This way, property and input values are kept synchronized.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况由参数-事件对处理。具体来说，一方面，属性被复制到输入组件参数中。另一方面，每当输入更改值时，都会触发一个更新属性的组件事件。这样，属性和输入值保持同步。
- en: This scenario is so common and useful that Blazor has a specific syntax for
    simultaneously defining the event and the copying of the property value into the
    parameter. This simplified syntax requires that the event has the same name as
    the parameter involved in the interaction but with a `Changed` postfix.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常常见和有用，以至于Blazor有一个特定的语法，可以同时定义事件和将属性值复制到参数中。这种简化的语法要求事件与交互中涉及的参数具有相同的名称，但带有`Changed`后缀。
- en: 'Suppose, for instance, that a component has a `Value` parameter. Then the corresponding
    event must be `ValueChanged`. Moreover, each time the user changes the component
    value, the component must invoke the `ValueChanged` event by calling `await ValueChanged.InvokeAsync(arg)`.
    With this in place, a property `MyObject.MyProperty` can be synchronized with
    the `Value` property with the syntax shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个组件有一个`Value`参数。那么相应的事件必须是`ValueChanged`。此外，每当用户更改组件值时，组件必须通过调用`await
    ValueChanged.InvokeAsync(arg)`来调用`ValueChanged`事件。有了这个设置，可以使用这里显示的语法将属性`MyObject.MyProperty`与`Value`属性同步：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding syntax is called **binding**. Blazor takes care of automatically
    attaching an event handler that updated the `MyObject.MyProperty` property to
    the `ValueChanged` event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法称为**绑定**。Blazor会自动附加一个更新`MyObject.MyProperty`属性的事件处理程序到`ValueChanged`事件。
- en: 'Bindings of HTML elements work in a similar way, but since the developer can''t
    decide the names of parameters and events, a slightly different convention must
    be used. First of all, there is no need to specify the parameter name in the binding,
    since it is always the HTML input `value` attribute. Therefore, the binding is
    written simply as `@bind="object.MyProperty"`. By default, the object property
    is updated on the `change` event, but you can specify a different event by adding
    the `@bind-event: @bind-event="oninput"` attribute.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTML元素的绑定方式类似，但由于开发人员无法决定参数和事件的名称，因此必须使用略有不同的约定。首先，无需在绑定中指定参数名称，因为它始终是HTML输入`value`属性。因此，绑定简单地写为`@bind="object.MyProperty"`。默认情况下，对象属性在`change`事件上更新，但您可以通过添加`@bind-event:
    @bind-event="oninput"`属性来指定不同的事件。'
- en: Moreover, bindings of HTML inputs try to automatically convert the input string
    into the target type. If the conversion fails, the input reverts to its initial
    value. This behavior is quite primitive since, in the event of errors, no error
    message is provided to the user, and the culture settings are not taken into account
    properly (HTML5 inputs use invariant culture but text input must use the current
    culture). We advise binding inputs only to string target types. Blazor has specific
    components for handling dates and numbers that should be used whenever the target
    type is not a string. We will describe them in the *Blazor forms and validation*
    section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTML输入的绑定尝试自动将输入字符串转换为目标类型。如果转换失败，输入将恢复到其初始值。这种行为相当原始，因为在出现错误时，不会向用户提供错误消息，并且文化设置没有得到正确的考虑（HTML5输入使用不变的文化，但文本输入必须使用当前文化）。我们建议只将输入绑定到字符串目标类型。Blazor具有专门用于处理日期和数字的组件，应该在目标类型不是字符串时使用。我们将在*Blazor表单和验证*部分中对它们进行描述。
- en: 'In order to familiarize ourselves with events, let''s write a component that
    synchronizes the content of an input type text when the user clicks a confirmation
    button. Let''s right-click on the `Shared` folder and add a new **ConfirmedText.razor**
    component. Then replace its code with this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉事件，让我们编写一个组件，当用户单击确认按钮时，同步输入文本类型的内容。右键单击`Shared`文件夹，然后添加一个新的**ConfirmedText.razor**组件。然后用以下代码替换其代码：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ConfirmedText` component exploits the button-click event to trigger the
    `ValueChanged` event. Moreover, the component itself uses `@bind` to synchronize
    its `Value` parameter with the HTML input. It is worth pointing out that the component
    uses `CaptureUnmatchedValues` to forward all HTML attributes applied to its tag
    to the HTML input. This way, users of the `ConfirmedText` component can style
    the input field by simply adding `class` and/or `style` attributes to the component
    tag.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmedText`组件利用按钮点击事件来触发`ValueChanged`事件。此外，组件本身使用`@bind`将其`Value`参数与HTML输入同步。值得指出的是，组件使用`CaptureUnmatchedValues`将应用于其标记的所有HTML属性转发到HTML输入。这样，`ConfirmedText`组件的用户可以通过简单地向组件标记添加`class`和/或`style`属性来设置输入字段的样式。'
- en: 'Now let''s use this component in the `Pages->Index.razor` page by placing the
    following code at the end of `Index.razor`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`Pages->Index.razor`页面中使用此组件，方法是将以下代码放在`Index.razor`的末尾：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you run the project and play with the input and its **Confirm** button, you
    will see that each time the **Confirm** button is clicked, not only are the input
    values copied in the `textValue` page property but also the content of the paragraph
    that is behind the component is coherently updated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行项目并与输入及其**确认**按钮进行交互，您会发现每次单击**确认**按钮时，不仅会将输入值复制到`textValue`页面属性中，而且组件后面段落的内容也会得到一致的更新。
- en: We explicitly synchronized `textValue` with the component with `@bind-Value`,
    but who takes care of keeping `textValue` synchronized with the content of the
    paragraph? The answer is in the next subsection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确使用`@bind-Value`将`textValue`与组件同步，但是谁负责保持`textValue`与段落内容同步？答案在下一小节中。
- en: How Blazor updates HTML
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor如何更新HTML
- en: When we write the content of a variable, property, or field in Razor markup
    with something like `@model.property`, Blazor, not only renders the actual value
    of the variable, property, or field when the component is rendered but tries also
    to update the HTML each time that this value changes, with a process called **change
    detection**. Change detection is a feature of all main SPA frameworks, but the
    way Blazor implements it is very simple and elegant.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Razor标记中写入变量、属性或字段的内容时，例如`@model.property`，Blazor不仅在组件呈现时呈现变量、属性或字段的实际值，而且还尝试在该值每次更改时更新HTML，这个过程称为**变更检测**。变更检测是所有主要SPA框架的特性，但Blazor实现它的方式非常简单和优雅。
- en: The basic idea is that, once all HTML has been rendered, changes may occur only
    because of code executed inside of events. That is why `EventCallBack` and `EventCallBack<T>`
    contain a reference to an `IHandleEvent`. When a component binds a handler to
    an event, the Razor compiler creates an `EventCallBack`or`EventCallBack<T>` passing
    in its `struct` constructor the function bound to the event, and the component
    where the function was defined (`IHandleEvent`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，一旦所有HTML都被呈现，更改只能因为在事件内执行的代码而发生。这就是为什么`EventCallBack`和`EventCallBack<T>`包含对`IHandleEvent`的引用。当组件将处理程序绑定到事件时，Razor编译器创建一个`EventCallBack`或`EventCallBack<T>`，并在其`struct`构造函数中传递绑定到事件的函数以及定义该函数的组件（`IHandleEvent`）。
- en: Once the code of the handler has been executed, the Blazor runtime is notified
    that the `IHandleEvent` might have changed. In fact, the handler code can only
    change the values of variables, properties, or fields of the component where the
    handler was defined. In turn, this triggers a change detection rooted in the component.
    Blazor verifies which variables, properties, or fields used in the component Razor
    markup changed and updates the associated HTML.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的代码执行后，Blazor运行时会通知`IHandleEvent`可能已更改。实际上，处理程序代码只能更改组件中定义处理程序的变量、属性或字段的值。反过来，这会触发组件中的变更检测。Blazor验证了组件Razor标记中使用的变量、属性或字段的更改，并更新相关的HTML。
- en: If a changed variable, property, or field is an input parameter of another component,
    then, the HTML generated by that component might also need updates. Accordingly,
    another change-detection process rooted in that component is recursively triggered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改的变量、属性或字段是另一个组件的输入参数，则该组件生成的HTML可能也需要更新。因此，会递归触发另一个根据该组件触发的变更检测过程。
- en: 'The algorithm sketched previously discovers all relevant changes only if the
    following conditions listed are met:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 先前概述的算法仅在满足以下列出的条件时才发现所有相关更改：
- en: No component references data structures belonging to other components in an
    event handler.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件处理程序中，没有组件引用其他组件的数据结构。
- en: All inputs to a component arrive through its parameters and not through method
    calls or other public members.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有组件的输入都通过其参数而不是通过方法调用或其他公共成员到达。
- en: When there is a change that is not detected because of the failure of one of
    the preceding conditions, the developer must manually declare the possible change
    of the component. This can be done by calling the `StateHasChanged()` component
    method. Since this call might result in changes to the page HTML, its execution
    cannot take place asynchronously but must be queued in the HTML page UI thread.
    This is done by passing the function to be executed to the `InvokeAsync` component
    method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于前述条件之一的失败而未检测到更改，则开发人员必须手动声明组件可能的更改。这可以通过调用`StateHasChanged()`组件方法来实现。由于此调用可能会导致页面HTML的更改，因此其执行不能异步进行，而必须在HTML页面UI线程中排队。这是通过将要执行的函数传递给`InvokeAsync`组件方法来完成的。
- en: Summing up, the instruction to execute is `await InvokeAsync(StateHasChanged)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，要执行的指令是`await InvokeAsync(StateHasChanged)`。
- en: The next subsection concludes the description of components with an analysis
    of their lifecycle and of the associated lifecycle methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节总结了组件的生命周期及相关的生命周期方法的描述。
- en: Component lifecycle
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Each component lifecycle event has an associated method. Some methods have both
    synchronous and asynchronous versions, some have just an asynchronous version,
    and some others have just a synchronous version.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件生命周期事件都有一个关联的方法。一些方法既有同步版本又有异步版本，有些只有异步版本，而有些只有同步版本。
- en: 'The component lifecycle starts with parameters passed to the component being
    copied in the associated component properties. You can customize this step by
    overriding the following method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 组件生命周期始于传递给组件的参数被复制到相关的组件属性中。您可以通过覆盖以下方法来自定义此步骤：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Typically, customization consists of the modification of additional data structures,
    so the base method is called to also perform the default action of copying parameters
    in the associated properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，定制包括修改其他数据结构，因此调用基本方法也执行将参数复制到相关属性的默认操作。
- en: 'After that, there is the component initialization that is associated with the
    two methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，与这两种方法相关联的组件初始化如下：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: They are called once in the component lifetime, immediately after the component
    has been created and added to the render tree. Please place any initialization
    code there, and not in the component constructor because this will improve component
    testability, because, there, you have all parameters set, and because future Blazor
    versions might pool and reuse component instances.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在组件生命周期中只被调用一次，即在组件创建并添加到渲染树后立即调用。请将任何初始化代码放在那里，而不是在组件构造函数中，因为这将提高组件的可测试性，因为在那里，您已经设置了所有参数，并且未来的Blazor版本可能会池化和重用组件实例。
- en: If the initialization code subscribes to some events or performs actions that
    need a cleanup when the component is destroyed, implement `IDisposable`, and place
    all cleanup code in its `Dispose` method. In fact, whenever a component implements
    `IDisposable`, Blazor calls its `Dispose` method before destroying it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始化代码订阅了某些事件或执行需要在组件销毁时进行清理的操作，请实现`IDisposable`，并将所有清理代码放在其`Dispose`方法中。实际上，每当组件实现`IDisposable`时，Blazor在销毁组件之前都会调用其`Dispose`方法。
- en: 'After the component has been initialized and each time a component parameter
    changes, the following two methods are called:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 组件初始化后，每次组件参数更改时，都会调用以下两种方法：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: They are the right place to update data structures that depend on the values
    of the component parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是更新依赖于组件参数值的数据结构的正确位置。
- en: 'After that, the component is rendered or re-rendered. You can prevent component
    re-rendering after an update by overriding the `ShouldRender` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，组件被渲染或重新渲染。您可以通过覆盖`ShouldRender`方法来防止更新后组件重新渲染：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Letting a component re-render only if you are sure its HTML code will change
    is an advanced optimization technique used in the implementation of component
    libraries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在确定其HTML代码将更改时，才让组件重新渲染是一种高级优化技术，用于组件库的实现中。
- en: 'The component rendering stage also involves the invocation of its children
    components. Therefore, component rendering is considered complete only after all
    its descendant components have completed their rendering, too. When rendering
    is complete, the following methods are called:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 组件渲染阶段还涉及调用其子组件。因此，只有在所有后代组件完成渲染后，组件渲染才被认为是完整的。渲染完成后，将调用以下方法：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since when the preceding methods are called, all component HTML has been updated
    and all children components have executed all their lifetime methods, the preceding
    methods are the right places for performing the following operations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在调用上述方法时，所有组件HTML都已更新，并且所有子组件都已执行完其生命周期方法，因此上述方法是执行以下操作的正确位置：
- en: Calling JavaScript functions that manipulate the generated HTML. JavaScript
    calls are described in the *JavaScript interoperability* subsection.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用操纵生成的HTML的JavaScript函数。JavaScript调用在*JavaScript互操作性*子部分中描述。
- en: Processing information attached to parameters or cascaded parameters by descendant
    components. In fact, Tabs-like components and other components might have the
    need to register some of their subparts in the root component, so the root component
    typically cascades a data structure where some children components can register.
    Code written in `AfterRender` and `AfterRenderAsync` can rely on the fact that
    all subparts have completed their registration.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理附加到参数或级联参数的信息由后代组件。事实上，类似标签的组件和其他组件可能需要在根组件中注册一些子部件，因此根组件通常会级联一个数据结构，其中一些子组件可以注册。在`AfterRender`和`AfterRenderAsync`中编写的代码可以依赖于所有子部件已完成其注册的事实。
- en: The next section describes Blazor tools for collecting user input.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节描述了Blazor用于收集用户输入的工具。
- en: Blazor forms and validation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor表单和验证
- en: Similar to all major SPA frameworks, Blazor also offers specific tools for processing
    user input while providing valid feedback to the user with error messages and
    immediate visual clues. The whole toolset is known as **Blazor Forms** and consists
    of a form component called `EditForm`, various input components, a data annotation
    validator, a validation error summary, and validation error labels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有主要的SPA框架类似，Blazor还提供了特定的工具来处理用户输入，同时通过错误消息和即时视觉提示向用户提供有效的反馈。整个工具集被称为**Blazor
    Forms**，包括一个名为`EditForm`的表单组件，各种输入组件，数据注释验证器，验证错误摘要和验证错误标签。
- en: '`EditForm` takes care of orchestrating the state of all input components, through
    an instance of the `EditContext` class that is cascaded inside of the form. The
    orchestration comes from the interaction of both input components and the data
    annotation validator with this `EditContext` instance. A validation summary and
    error message labels don''t take part in the orchestration but register to some
    `EditContext` events to be informed about errors.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm`负责编排所有输入组件的状态，通过表单内级联的`EditContext`类的实例。编排来自输入组件和数据注释验证器与此`EditContext`实例的交互。验证摘要和错误消息标签不参与编排，但会注册一些`EditContext`事件以便了解错误。'
- en: '`EditForm` must be passed the object whose properties must be rendered in its
    `Model` parameter. It is worth pointing out that input components bound to nested
    properties are not validated, so `EditForm` must be passed a flattened ViewModel.
    `EditForm` creates a new `EditContext` instance, passes the object received in
    its `Model` parameter in its constructor, and cascades it so it can interact with
    the form content.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditForm`必须在其`Model`参数中传递其属性必须呈现的对象。值得指出的是，绑定到嵌套属性的输入组件不会被验证，因此`EditForm`必须传递一个扁平化的ViewModel。`EditForm`创建一个新的`EditContext`实例，将其接收到的对象传递给其构造函数中的`Model`参数，并级联它以便它可以与表单内容交互。'
- en: You can also directly pass an `EditContext` custom instance in the `EditContext`
    parameter of `EditForm` instead of passing the object in its `Model` parameter,
    in which case `EditForm` will use your custom copy instead of creating a new instance.
    Typically, you do this when you need to subscribe to the `EditContextOnValidationStateChanged`
    and `OnFieldChanged` events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接在`EditForm`的`EditContext`参数中传递一个`EditContext`自定义实例，而不是在其`Model`参数中传递对象，这种情况下，`EditForm`将使用您的自定义副本而不是创建一个新实例。通常，当您需要订阅`EditContextOnValidationStateChanged`和`OnFieldChanged`事件时，可以这样做。
- en: When `EditForm` is submitted with a **Submit** button and there are no errors,
    the form invokes its `OnValidSubmit` callback, where you can place the code that
    uses and processes the user input. If instead, there are validation errors, they
    are shown, and the form invokes its `OnInvalidSubmit` callback.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**提交**按钮提交`EditForm`且没有错误时，表单会调用其`OnValidSubmit`回调，在这里您可以放置使用和处理用户输入的代码。如果有验证错误，表单会调用其`OnInvalidSubmit`回调。
- en: 'The state of each input is reflected in some CSS classes that are automatically
    added to them, namely: `valid`, `invalid`, and `modified`. You can use these classes
    to furnish adequate visual feedback to the user. The default Blazor Visual Studio
    template already furnishes some CSS for them.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入的状态反映在自动添加到其中的一些CSS类中，即：`valid`，`invalid`和`modified`。您可以使用这些类为用户提供适当的视觉反馈。默认的Blazor
    Visual Studio模板已经为它们提供了一些CSS。
- en: 'Following is a typical form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的表单：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The label is a standard HTML label, while `InputNumber` is a Blazor-specific
    component for number properties. `ValidationMessage` is the error label that appears
    only in the event of a validation error. As a default, it is rendered with a `validation-message`
    CSS class. The property associated with the error message is passed in the `for`
    parameter with a parameterless lambda as shown in the example.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是标准的HTML标签，而`InputNumber`是一个专门用于数字属性的Blazor组件。`ValidationMessage`是仅在验证错误发生时出现的错误标签。默认情况下，它以`validation-message`
    CSS类呈现。与错误消息相关联的属性通过无参数的lambda传递给`for`参数，如示例所示。
- en: The `DataAnnotationsValidator` component adds a validation based on the usual
    .NET validation attributes, such as `RangeAttribute`, `RequiredAttribute`, and
    so on. You can also write your custom validation attributes by inheriting from
    the `ValidationAttribute` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataAnnotationsValidator`组件基于通常的.NET验证属性（如`RangeAttribute`，`RequiredAttribute`等）添加了验证。您还可以通过继承`ValidationAttribute`类来编写自定义验证属性。'
- en: You can provide custom error messages in the validation attributes. If they
    contain a `{0}` placeholder, this will be filled with the property display name
    declared in a `DisplayAttribute`, if one is found, otherwise with the property
    name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在验证属性中提供自定义错误消息。如果它们包含`{0}`占位符，如果找到`DisplayAttribute`，则将填充为属性显示名称，否则将填充为属性名称。
- en: Together with the `InputNumber` component, Blazor also supports an `InputText`
    component for `string` properties, an `InputTextArea` component for `string` properties
    to be edited in an HTML `textarea`, an `InputCheckbox` component for `bool` properties,
    and an `InputDate` component that renders `DateTime` and `DateTimeOffset` as dates.
    They all work in exactly the same way as the `InputNumber` component. No component
    is available for other HTML5 input types. In particular, no component is available
    for rendering time or date and time, or for rendering numbers with a `range` widget.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`InputNumber`组件外，Blazor还支持用于`string`属性的`InputText`组件，用于在HTML`textarea`中编辑`string`属性的`InputTextArea`组件，用于`bool`属性的`InputCheckbox`组件，以及用于呈现`DateTime`和`DateTimeOffset`的`InputDate`组件。它们的工作方式与`InputNumber`组件完全相同。没有其他HTML5输入类型的组件可用。特别是，没有用于呈现时间或日期和时间，或用于使用`range`小部件呈现数字的组件。
- en: 'You can implement rendering time or date and time by inheriting from the `InputBase<TValue>`
    class and overriding the `BuildRenderTree`, `FormatValueAsString`, and `TryParseValueFromString`
    methods. The sources of the `InputNumber` component show how to do it: [https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/We).
    You can also use the third-party libraries described in the *Third-party tools
    for Blazor WebAssembly* section.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过继承`InputBase<TValue>`类并重写`BuildRenderTree`、`FormatValueAsString`和`TryParseValueFromString`方法来实现渲染时间或日期和时间。`InputNumber`组件的源代码显示了如何做到这一点：[https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/We)。您还可以使用*Blazor
    WebAssembly的第三方工具*部分中描述的第三方库。
- en: 'Blazor also has a specific component for rendering a `select`, which works
    as in the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor还有一个专门用于呈现`select`的组件，其工作方式如下例所示：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also render enumerations with a radio group thanks to the `InputRadioGroup`
    and `InputRadio` components, as shown in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`InputRadioGroup`和`InputRadio`组件将枚举呈现为单选按钮组，如下例所示：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, Blazor also offers an `InputFile` component together with all the tools
    for processing and uploading the file. We will not cover this here, but the *Further
    reading* section contains links to the official documentation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Blazor还提供了一个`InputFile`组件以及处理和上传文件的所有工具。我们不会在这里介绍，但*进一步阅读*部分包含指向官方文档的链接。
- en: This subsection finishes the description of Blazor basics; the next section
    analyzes some advanced features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节结束了对Blazor基础知识的描述；下一节将分析一些高级功能。
- en: Blazor advanced features
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor高级功能
- en: This section collects short descriptions of various Blazor advanced features
    organized in subsections. For lack of space, we can't give all the details of
    each feature, but the lacking details are covered by links in the *Further reading*
    section. We start with how to reference components and HTML elements defined in
    Razor markup.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本节收集了各种Blazor高级功能的简短描述，分为子节。由于篇幅有限，我们无法提供每个功能的所有细节，但缺少的细节在*进一步阅读*部分的链接中有所涵盖。我们从如何引用Razor标记中定义的组件和HTML元素开始。
- en: References to components and HTML elements
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件和HTML元素的引用
- en: 'Sometimes we might need a reference to a component in order to call some of
    its methods. This is the case, for instance, for a component that implements a
    modal window:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要引用组件以便调用其一些方法。例如，对于实现模态窗口的组件就是这种情况：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As the preceding example shows, references are captured with the `@ref` directive.
    The same `@ref` directive can also be used to capture references to HTML elements.
    HTML references have an `ElementReference` type and are typically used to call
    JavaScript functions on HTML elements, as explained in the next subsection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，引用是使用`@ref`指令捕获的。相同的`@ref`指令也可以用于捕获对HTML元素的引用。HTML引用具有`ElementReference`类型，并且通常用于在HTML元素上调用JavaScript函数，如下一小节所述。
- en: JavaScript interoperability
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript互操作性
- en: Since Blazor doesn't expose all JavaScript features to C# code, and since it
    is convenient to take advantage of the huge JavaScript code base available, sometimes
    it is necessary to invoke JavaScript functions. Blazor allows this through the
    `IJSRuntime` interface that can be injected into a component via dependency injection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Blazor不会将所有JavaScript功能暴露给C#代码，并且由于方便利用可用的大量JavaScript代码库，有时需要调用JavaScript函数。Blazor通过`IJSRuntime`接口允许这样做，该接口可以通过依赖注入注入到组件中。
- en: 'Once one has an `IJSRuntime` instance, a JavaScript function that returns a
    value can be called as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了`IJSRuntime`实例，就可以调用返回值的JavaScript函数，如下所示：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Functions that do not return any argument can be invoked as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回任何参数的函数可以像这样被调用：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Arguments can be either basic types or objects that can be serialized in JSON,
    while the name of the JavaScript function is a string that can contain dots that
    represent access to properties, sub-properties, and method names, like, for instance,
    the `"myJavaScriptObject.myProperty.myMethod"` string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是基本类型或可以在JSON中序列化的对象，而JavaScript函数的名称是一个字符串，可以包含表示属性、子属性和方法名称的点，例如`"myJavaScriptObject.myProperty.myMethod"`字符串。
- en: Arguments can also be `ElementReference` instances captured with the `@ref`
    directive, in which case they are received as HTML elements on the JavaScript
    side.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 参数也可以是使用`@ref`指令捕获的`ElementReference`实例，在这种情况下，它们在JavaScript端作为HTML元素接收。
- en: The JavaScript functions invoked must be defined either in the `Index.html`
    file or in JavaScript files referenced in `Index.html`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的JavaScript函数必须在`Index.html`文件中定义，或者在`Index.html`中引用的JavaScript文件中定义。
- en: 'If you are writing a component library with a Razor library project, JavaScript
    files can be embedded together with CSS files as resources in the DLL library.
    It is enough to add a `wwwroot` folder in the project root and to place the needed
    CSS and JavaScript files in that folder or in some subfolder of it. After that,
    these files can be referenced as:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个带有Razor库项目的组件库，JavaScript文件可以作为DLL库中的资源与CSS文件一起嵌入。只需在项目根目录中添加一个`wwwroot`文件夹，并将所需的CSS和JavaScript文件放在该文件夹或其子文件夹中。之后，这些文件可以被引用为：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Accordingly, if the filename is `myJsFile.js`, the dll name is `MyCompany.MyLibrary`,
    and the file is placed in the `js` folder inside `wwwroot`, then its reference
    will be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果文件名为`myJsFile.js`，dll名称为`MyCompany.MyLibrary`，并且文件放在`wwwroot`内的`js`文件夹中，则其引用将是：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If your JavaScript files are organized as ES6 modules, you can avoid referencing
    them in `Index.html`, and can load the modules directly as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的JavaScript文件组织为ES6模块，您可以避免在`Index.html`中引用它们，并可以直接加载模块，如下所示：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In addition, instance methods of C# objects can be called from JavaScript code,
    taking the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以从JavaScript代码中调用C#对象的实例方法，采取以下步骤：
- en: Say the C# method is called `MyMethod`. Decorate the `MyMethod` method with
    the `[JSInvokable]` attribute.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设C#方法名为`MyMethod`。请使用`[JSInvokable]`属性装饰`MyMethod`方法。
- en: 'Enclose the C# object in a `DotNetObjectReference` instance and pass it to
    JavaScript with a JavaScript call:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C#对象封装在`DotNetObjectReference`实例中，并通过JavaScript调用将其传递给JavaScript：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On the JavaScript side, say the C# object is in a variable called `dotnetObject`.
    Then it is enough to invoke:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript方面，假设C#对象在名为`dotnetObject`的变量中。然后只需调用：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next section explains how to handle contents and number/date localization.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何处理内容和数字/日期本地化。
- en: Globalization and localization
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球化和本地化
- en: As soon as the Blazor application starts, both the application culture and the
    application UI culture are set to the browser culture. However, the developer
    can change both of them by assigning the chosen cultures to `CultureInfo.DefaultThreadCurrentCulture`
    and `CultureInfo.DefaultThreadCurrentUICulture`. Typically, the application lets
    the user choose one of its supported cultures, or it accepts the browser culture
    only if it is supported, otherwise, it falls back to a supported culture. In fact,
    it is possible to support just a reasonable number of cultures because all application
    strings must be translated in all supported cultures.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Blazor应用程序启动，应用程序文化和应用程序UI文化都将设置为浏览器文化。但是，开发人员可以通过将所选文化分配给`CultureInfo.DefaultThreadCurrentCulture`和`CultureInfo.DefaultThreadCurrentUICulture`来更改它们。通常，应用程序允许用户选择其支持的文化之一，或者仅在支持的情况下接受浏览器文化，否则将回退到支持的文化。实际上，只能支持合理数量的文化，因为所有应用程序字符串必须在所有支持的文化中进行翻译。
- en: Once the `CurrentCulture` is set, dates and numbers are automatically formatted
    according to the conventions of the chosen culture. For the UI culture, the developer
    must manually provide resource files with the translations of all application
    strings in all supported cultures.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`CurrentCulture`，日期和数字将根据所选文化的惯例自动格式化。对于UI文化，开发人员必须手动提供包含所有支持的文化中所有应用程序字符串翻译的资源文件。
- en: 'There are two ways to use resource files. With the first option, you create
    a resource file, say, `myResource.resx`, and then add all language-specific files:
    `myResource.it.resx`, `myResource.pt.resx`, and so on. In this case, Visual Studio
    creates a static class named `myResource` whose static properties are the keys
    of each resource file. These properties will automatically contain the localized
    strings corresponding to the current UI culture. You can use these static properties
    wherever you like, and you can use pairs composed of a resource type and a resource
    name to set the `ErrorMessageResourceType` and the `ErrorMessageResourceName`
    properties of validation attributes or similar properties of other attributes.
    This way, the attributes will use an automatically localized string.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种使用资源文件的方法。使用第一种选项，您创建一个资源文件，比如`myResource.resx`，然后添加所有特定语言的文件：`myResource.it.resx`，`myResource.pt.resx`等。在这种情况下，Visual
    Studio会创建一个名为`myResource`的静态类，其静态属性是每个资源文件的键。这些属性将自动包含与当前UI文化对应的本地化字符串。您可以在任何地方使用这些静态属性，并且您可以使用由资源类型和资源名称组成的对来设置验证属性的`ErrorMessageResourceType`和`ErrorMessageResourceName`属性，或其他属性的类似属性。这样，属性将使用自动本地化的字符串。
- en: With the second option, you add only language-specific resource files (`myResource.it.resx`,
    `myResource.pt.resx`, and so on). In this case, Visual Studio doesn't create any
    class associated with the resource file, and you can use resource files together
    with `IStringLocalizer` and `IStringLocalizer<T>` injected in components as you
    use them in ASP.NET Core MVC views (see the *ASP.NET Core globalization* section
    of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种选项，您只添加特定语言的资源文件（`myResource.it.resx`，`myResource.pt.resx`等）。在这种情况下，Visual
    Studio不会创建与资源文件关联的任何类，您可以将资源文件与在组件中注入的`IStringLocalizer`和`IStringLocalizer<T>`一起使用，就像在ASP.NET
    Core MVC视图中使用它们一样（请参阅*第15章*的*ASP.NET Core全球化*部分，*展示ASP.NET Core MVC*）。
- en: Authentication and authorization
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和授权
- en: In the *Routing* subsection, we sketched how the `CascadingAuthenticationState`
    and `AuthorizeRouteView` components prevent unauthorized users from accessing
    pages protected with an `[Authorize]` attribute. Let's go deeper into the details
    of how page authorization works.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Routing*子部分中，我们概述了`CascadingAuthenticationState`和`AuthorizeRouteView`组件如何阻止未经授权的用户访问受`[Authorize]`属性保护的页面。让我们深入了解页面授权的工作原理。
- en: In .NET applications, authentication and authorization information is usually
    contained in a `ClaimsPrincipal` instance. In server applications, this instance
    is built when the user logs in, taking the required information from a database.
    In Blazor WebAssembly, such information must be provided by some remote server
    that takes care of SPA authentication, too. Since there are several ways to provide
    authentication and authorization to a Blazor WebAssembly application, Blazor defines
    the `AuthenticationStateProvider` abstraction.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET应用程序中，身份验证和授权信息通常包含在`ClaimsPrincipal`实例中。在服务器应用程序中，当用户登录时，将构建此实例，并从数据库中获取所需的信息。在Blazor
    WebAssembly中，此类信息必须由负责SPA身份验证的远程服务器提供。由于有几种方法可以为Blazor WebAssembly应用程序提供身份验证和授权，因此Blazor定义了`AuthenticationStateProvider`抽象。
- en: Authentication and authorization providers inherit from the `AuthenticationStateProvider`
    abstract class and override its `GetAuthenticationStateAsync` method, which returns
    a `Task<AuthenticationState>`, where the `AuthenticationState` contains the authentication
    and authorization information. Actually, `AuthenticationState` contains just a
    `User` property with a `ClaimsPrincipal`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权提供程序继承自`AuthenticationStateProvider`抽象类，并覆盖其`GetAuthenticationStateAsync`方法，该方法返回一个`Task<AuthenticationState>`，其中`AuthenticationState`包含身份验证和授权信息。实际上，`AuthenticationState`只包含一个具有`ClaimsPrincipal`的`User`属性。
- en: 'Once we''ve defined a concrete implementation of `AuthenticationStateProvider`,
    we must register it in the dependency engine container in the application `program.cs`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`AuthenticationStateProvider`的具体实现，我们必须在应用程序的`program.cs`文件中将其注册到依赖引擎容器中。
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will return to the predefined implementations of `AuthenticationStateProvider`
    offered by Blazor after having described how Blazor uses authentication and authorization
    information furnished by a registered `AuthenticationStateProvider`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了Blazor如何使用由注册的`AuthenticationStateProvider`提供的身份验证和授权信息后，我们将回到Blazor提供的`AuthenticationStateProvider`的预定义实现。
- en: 'The `CascadingAuthenticationState` component calls the `GetAuthenticationStateAsync`
    method of the registered `AuthenticationStateProvider` and cascades the returned
    `Task<AuthenticationState>`. You can intercept this cascading value with a `[CascadingParameter]`
    defined as follows in your components:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadingAuthenticationState`组件调用注册的`AuthenticationStateProvider`的`GetAuthenticationStateAsync`方法，并级联返回的`Task<AuthenticationState>`。您可以使用以下方式在组件中定义`[CascadingParameter]`来拦截此级联值：'
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, Blazor applications typically use `AuthorizeRouteView` and `AuthorizeView`
    components to control user access to content.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Blazor应用程序通常使用`AuthorizeRouteView`和`AuthorizeView`组件来控制用户对内容的访问。
- en: '`AuthorizeRouteView` prevents access to pages if the user doesn''t satisfy
    the prescriptions of the page `[Authorize]` attribute, otherwise, the content
    in the `NotAuthorized` template is rendered. `AuthorizeRouteView` also has an
    `Authorizing` template that is shown while user information is being retrieved.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeRouteView`如果用户不满足页面`[Authorize]`属性的要求，则阻止访问页面，否则将呈现`NotAuthorized`模板中的内容。`AuthorizeRouteView`还有一个`Authorizing`模板，当正在检索用户信息时会显示该模板。'
- en: '`AuthorizeView` can be used within components to show the markup it encloses
    only to authorized users. It contains the same `Roles` and `Policy` parameters
    of the `[Authorize]` attribute that you can use to specify the constraints the
    user must satisfy to access the content:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeView`可以在组件内部使用，仅向经过授权的用户显示其包含的标记。它包含与`[Authorize]`属性相同的`Roles`和`Policy`参数，您可以使用这些参数来指定用户必须满足的约束以访问内容。'
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`AuthorizeView` can also specify `NotAuthorized` and an `Authorizing` template:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizeView`还可以指定`NotAuthorized`和`Authorizing`模板：'
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If one adds authorization while creating a Blazor WebAssembly project, the
    following method call is added to the application dependency engine:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建Blazor WebAssembly项目时添加了授权，将向应用程序的依赖引擎添加以下方法调用：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This method adds an `AuthenticationStateProvider` that extracts the user information
    from the usual ASP.NET Core authentication cookie. Since authentication cookies
    are encrypted, this operation must be performed by contacting an endpoint exposed
    by the server. The operation is performed with the help of the `AuthenticationService.js`
    JavaScript file we saw in the *Loading and starting the application* subsection
    of this chapter. The server endpoint returns user information in the form of a
    bearer token that can be used also to authenticate communications with the server's
    WEB API. Bearer tokens are described in detail in the *REST services authorization
    and authentication* and *ASP.NET Core service authorization* sections of *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*. Blazor WebAssembly
    communication is described in the next subsection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法添加了一个`AuthenticationStateProvider`，该提取用户信息的方式是从通常的ASP.NET Core身份验证cookie中提取。由于身份验证cookie是加密的，因此必须通过联系服务器公开的端点来执行此操作。此操作是通过本章的*加载和启动应用程序*子章节中看到的`AuthenticationService.js`
    JavaScript文件来执行的。服务器端点以bearer token的形式返回用户信息，该token也可用于验证与服务器的WEB API的通信。有关bearer
    token的详细信息，请参见*第14章*，*使用.NET Core应用服务导向架构*中的*REST服务授权和身份验证*和*ASP.NET Core服务授权*部分。Blazor
    WebAssembly通信将在下一子章节中描述。
- en: 'If no valid authentication cookie is found, the provider creates an unauthenticated
    `ClaimsPrincipal`. This way, when the user tries to access a page that is protected
    by an `[Authorize]` attribute, the `AuthorizeRouteView` component invokes the
    `RedirectToLogin` component, which, in turn, navigates to the `Authentication.razor`
    page, passing it a login request in its `action` route parameter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到有效的身份验证cookie，提供程序将创建一个未经身份验证的`ClaimsPrincipal`。这样，当用户尝试访问由`[Authorize]`属性保护的页面时，`AuthorizeRouteView`组件会调用`RedirectToLogin`组件，后者又会导航到`Authentication.razor`页面，并在其`action`路由参数中传递一个登录请求。
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `RemoteAuthenticatorView` acts as an interface with the usual ASP.NET Core
    user login/registration system, and whenever it receives an "action" to perform
    redirects the user from the Blazor application to the proper ASP.NET Core server
    page (login, registration, logout, user profile).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteAuthenticatorView`充当与通常的ASP.NET Core用户登录/注册系统的接口，每当它接收要执行的“操作”时，都会将用户从Blazor应用程序重定向到适当的ASP.NET
    Core服务器页面（登录、注册、注销、用户资料）。'
- en: All information needed to communicate with the server is based on name conventions,
    but they can be customized with the `options` argument of the `AddApiAuthorization`
    method. There, for instance, you can change the URL where the user can register,
    and also the address of the endpoint contacted by Blazor to collect information
    on the server settings. This endpoint is in the `BlazorReview.Server->Controller->OidcConfigurationController.cs`
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器通信所需的所有信息都基于名称约定，但可以使用`AddApiAuthorization`方法的`options`参数进行自定义。例如，在那里，您可以更改用户可以注册的URL，以及Blazor用于收集有关服务器设置的端点的地址。此端点位于`BlazorReview.Server->Controller->OidcConfigurationController.cs`文件中。
- en: Once the user logs in, they are redirected to the Blazor application page that
    caused the login request. The redirect URL is computed by the `BlazorReview.Client->Shared->RedirectToLogin.razor`
    component, which extracts it from the `NavigationManager` and passes it to the
    `RemoteAuthenticatorView` component. This time, the `AuthenticationStateProvider`
    is able to get the user information from the authentication cookie that has been
    created by the login operation.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，将被重定向到引起登录请求的Blazor应用程序页面。重定向URL由`BlazorReview.Client->Shared->RedirectToLogin.razor`组件计算，该组件从`NavigationManager`中提取URL并将其传递给`RemoteAuthenticatorView`组件。这次，`AuthenticationStateProvider`能够从登录操作创建的身份验证cookie中获取用户信息。
- en: More details on the authentication process are available in the official documentation
    reference in the *Further reading* section
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关身份验证过程的更多详细信息，请参阅*Further reading*部分中的官方文档参考。
- en: The next subsection describes a Blazor WebAssembly-specific implementation of
    the `HttpClient` class and related types.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节描述了`HttpClient`类和相关类型的Blazor WebAssembly特定实现。
- en: Communication with the server
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与服务器的通信
- en: Blazor WebAssembly supports the same .NET `HttpClient` and `HttpClientFactory`
    classes described in the *.NET Core HTTP clients* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*. However, due to the communication
    limitations of browsers, their implementations are different and rely on the browser
    **fetch API**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly支持与*第14章*，*应用.NET Core的面向服务的架构*中描述的相同的.NET `HttpClient`和`HttpClientFactory`类。但是，由于浏览器的通信限制，它们的实现是不同的，并依赖于浏览器的**fetch
    API**。
- en: In *Chapter 14*, *Applying Service-Oriented Architectures with .NET Core*, we
    analyzed how to take advantage of `HttpClientFactory` to define typed clients.
    You can also define typed clients in Blazor with exactly the same syntax.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第14章*，*应用.NET Core的面向服务的架构*中，我们分析了如何利用`HttpClientFactory`来定义类型化的客户端。您也可以使用完全相同的语法在Blazor中定义类型化的客户端。
- en: 'However, since Blazor needs to send the bearer token created during the authentication
    process in each request to the application server, it is common to define a named
    client as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于Blazor需要在每个请求中发送在身份验证过程中创建的令牌到应用程序服务器，因此通常会定义一个命名客户端，如下所示：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`AddHttpMessageHandler` adds a `DelegatingHandler`, that is, a subclass of
    the `DelegatingHandler` abstract class. Implementations of `DelegatingHandler`
    override its `SendAsync` method in order to process each request and each relative
    response:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddHttpMessageHandler`添加了一个`DelegatingHandler`，即`DelegatingHandler`抽象类的子类。`DelegatingHandler`的实现重写了其`SendAsync`方法，以处理每个请求和每个相关响应：'
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`BaseAddressAuthorizationMessageHandler` is added to the dependency injection
    engine by the `AddApiAuthorization` call we saw in the previous section. It adds
    the bearer token produced by the authorization process to each request addressed
    to the application server domain. If either this bearer token is expired or is
    not found at all, it tries to get a new bearer token from the user authentication
    cookie. If this attempt also fails, an `AccessTokenNotAvailableException` is thrown.
    Typically, similar exceptions are captured and trigger a redirection to the login
    page (as the default, to `/authentication/{action}`):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAddressAuthorizationMessageHandler`是通过我们在前一节中看到的`AddApiAuthorization`调用添加到依赖注入引擎中的。它将由授权过程生成的令牌添加到每个发送到应用程序服务器域的请求中。如果此令牌已过期或根本找不到，则它会尝试从用户身份验证cookie中获取新的令牌。如果此尝试也失败，则会抛出`AccessTokenNotAvailableException`。通常，类似的异常会被捕获并触发重定向到登录页面（默认情况下为`/authentication/{action}`）：'
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since most requests are directed to the application server, and just a few
    calls might contact other servers with CORS, the `BlazorReview.ServerAPI` named
    `client` is also defined to be the default `HttpClient` instance:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数请求都是针对应用程序服务器的，并且只有少数调用可能会与CORS联系其他服务器，因此`BlazorReview.ServerAPI`命名为`client`也被定义为默认的`HttpClient`实例：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The default client can be obtained by requiring an `HttpClient` instance to
    the dependency injection engine. CORS requests to other servers can be handled
    by defining other named clients that use other bearer tokens. One can get a named
    client by first getting an `IHttpClientFactory` instance from dependency injection,
    and then calling its `CreateClient("<named client name>")` method. Blazor offers
    packages for getting bearer tokens and connecting with well-known services. They
    are described in the authorization documentation referenced in the *Further reading*
    section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向依赖注入引擎请求`HttpClient`实例来获取默认客户端。可以通过定义使用其他令牌的其他命名客户端来处理对其他服务器的CORS请求。可以通过首先从依赖注入中获取`IHttpClientFactory`实例，然后调用其`CreateClient("<named
    client name>")`方法来获取命名客户端。Blazor提供了用于获取令牌和连接到知名服务的包。它们在*Further reading*部分中的授权文档中有描述。
- en: The next section briefly discusses some of the most relevant third-party tools
    and libraries that complete Blazor's official features, and help increase productivity
    in Blazor projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分简要讨论了一些最相关的第三方工具和库，这些工具和库完善了Blazor的官方功能，并帮助提高Blazor项目的生产力。
- en: Third-party tools for Blazor WebAssembly
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blazor WebAssembly的第三方工具
- en: Notwithstanding Blazor is a young product, its third-party tool and product
    ecosystem is already quite rich. Among the open source, free products, it is worth
    mentioning the **Blazorise** project ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)),
    which contains various free basic Blazor components (inputs, tabs, modals, and
    so on) that can be styled with various CSS frameworks, such as Bootstrap and Material.
    It also contains a simple editable grid and a simple tree view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Blazor是一个年轻的产品，但其第三方工具和产品生态系统已经相当丰富。在开源、免费产品中，值得一提的是**Blazorise**项目（[https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)），其中包含各种免费的基本Blazor组件（输入、选项卡、模态框等），可以使用各种CSS框架（如Bootstrap和Material）进行样式设置。它还包含一个简单的可编辑网格和一个简单的树视图。
- en: Also worth mentioning is **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)),
    which contains pure Blazor implementations of all Bootstrap 4 components and widgets.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 另外值得一提的是**BlazorStrap**（[https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)），其中包含了所有Bootstrap
    4组件和小部件的纯Blazor实现。
- en: Among all the commercial products, it is worth mentioning **Blazor Controls
    Toolkit** ([http://blazor.mvc-controls.com/](http://blazor.mvc-controls.com/)),
    which is a complete toolset for implementing commercial applications. It contains
    all input types with their fallbacks in case they are not supported by the browser;
    all Bootstrap components; other basic components; and a complete, advanced drag-and-drop
    framework; advanced customizable and editable components, like detail views, detail
    lists, grids, a tree-repeater (a generalization of the tree-view). All components
    are based on a sophisticated metadata representation system that enables the user
    to design the markup in a declarative way using data annotations and inline Razor
    declarations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有商业产品中，值得一提的是**Blazor Controls Toolkit**（[http://blazor.mvc-controls.com/](http://blazor.mvc-controls.com/)），这是一个用于实现商业应用程序的完整工具集。它包含了所有输入类型及其在浏览器不支持时的回退；所有Bootstrap组件；其他基本组件；以及一个完整的、高级的拖放框架；高级可定制和可编辑的组件，如详细视图、详细列表、网格、树重复器（树视图的泛化）。所有组件都基于一个复杂的元数据表示系统，使用户能够使用数据注释和内联Razor声明以声明方式设计标记。
- en: Moreover, it contains additional sophisticated validation attributes, tools
    for undoing user input, tools for computing changes to send to the server, sophisticated
    client-side and server-side query tools based on the OData protocol, and tools
    to maintain and save the whole application state.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还包含了额外复杂的验证属性，撤消用户输入的工具，计算发送到服务器的更改的工具，基于OData协议的复杂客户端和服务器端查询工具，以及用于维护和保存整个应用程序状态的工具。
- en: It is worth also mentioning the **bUnit** open source project ([https://github.com/egil/bUnit](https://github.com/egil/bUnit)),
    which furnishes all tools for testing Blazor components.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是**bUnit**开源项目（[https://github.com/egil/bUnit](https://github.com/egil/bUnit)），它提供了测试Blazor组件的所有工具。
- en: The next section shows how to put into practice what you have learned by implementing
    a simple application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示如何将所学知识付诸实践，实现一个简单的应用程序。
- en: Use case – implementing a simple application in Blazor WebAssembly
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 在Blazor WebAssembly中实现一个简单的应用程序
- en: In this section, we will implement a package search application for the *WWTravelClub*
    book use case. The first subsection explains how to set up the solution exploiting
    the domain layer and data layer we already implemented in *Chapter 15*, *Presenting*
    *ASP.NET* *Core MVC*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为*WWTravelClub*书籍使用案例实现一个包搜索应用程序。第一小节解释了如何利用我们在*第15章* *介绍ASP.NET Core
    MVC*中已经实现的域层和数据层来设置解决方案。
- en: Preparing the solution
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备解决方案
- en: First of all, create a copy of the **PackagesManagement** solution folder we
    created in *Chapter 15*, *Presenting ASP.NET Core MVC*, and rename it **PackagesManagementBlazor**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个**PackagesManagement**解决方案文件夹的副本，我们在*第15章* *介绍ASP.NET Core MVC*中创建，并将其重命名为**PackagesManagementBlazor**。
- en: Open the solution, right-click on the Web project (the one named **PackagesManagement**)
    and remove it. Then, go to the solution folder and delete the whole Web project
    folder (the one named **PackagesManagement**).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 打开解决方案，右键单击Web项目（名为**PackagesManagement**）并删除它。然后，转到解决方案文件夹并删除整个Web项目文件夹（名为**PackagesManagement**）。
- en: Now right-click on the solution and select **Add New project**. Add a new Blazor
    WebAssembly project called **PackagesManagementBlazor**. Select **no authentication**
    and **ASP.NET Core hosted**. We don't need authentication since the search-by-location
    feature we are going to implement must also be available to unregistered users.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键单击解决方案，然后选择**添加新项目**。添加一个名为**PackagesManagementBlazor**的新的Blazor WebAssembly项目。选择**无身份验证**和**ASP.NET
    Core托管**。我们不需要身份验证，因为我们将要实现的按位置搜索功能也必须对未注册用户可用。
- en: Ensure that the **PackagesManagementBlazor.Server** project is the start project
    (its name should be in bold). If it is not, right-click on it and click on **Set
    as Start Project**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保**PackagesManagementBlazor.Server**项目是启动项目（其名称应为粗体）。如果不是，请右键单击它，然后单击**设置为启动项目**。
- en: The server project needs to reference both the data (**PackagesManagementDB**)
    and the domain (**PackagesManagementDomain**) projects, so please add them as
    references.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器项目需要引用数据（**PackagesManagementDB**）和域（**PackagesManagementDomain**）项目，请将它们添加为引用。
- en: 'Let''s also copy the same connection string of the old web project into the
    `PackagesManagementBlazor.Serverappsettings.json` file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将旧Web项目的相同连接字符串复制到`PackagesManagementBlazor.Serverappsettings.json`文件中：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This way, we can reuse the database we already created. We also need to add
    the same DDD tools we added to the old web project. Add a folder named `Tools`
    in the project root and copy the content of the `ch12->ApplicationLayer` folder
    of the GitHub repository associated with the book there.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以重用我们已经创建的数据库。我们还需要添加与旧Web项目添加的相同的DDD工具。在项目根目录中添加一个名为`Tools`的文件夹，并将与该书籍关联的GitHub存储库的`ch12->ApplicationLayer`文件夹的内容复制到其中。
- en: 'In order to finish the solution setup, we just need to connect **PackagesManagementBlazor.Server**
    with the domain layer by adding the following code at the end of the `ConfigureServices`
    method in the `Startup.cs` file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成解决方案设置，我们只需要通过在`Startup.cs`文件的`ConfigureServices`方法的末尾添加以下代码来将**PackagesManagementBlazor.Server**与域层连接起来：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It is the same method we added to the old Web project. Finally, we can also
    add the `AddAllQueries` extension method, which discovers all queries in the Web
    project:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在旧的Web项目中添加的相同方法。最后，我们还可以添加`AddAllQueries`扩展方法，它会发现Web项目中的所有查询：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We don't need other automatic discovery tools since this is a query-only application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个仅查询的应用程序，我们不需要其他自动发现工具。
- en: The next subsection explains how to design the server-side REST API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将解释如何设计服务器端的REST API。
- en: Implementing the required ASP.NET Core REST APIs
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现所需的ASP.NET Core REST API
- en: As the first step, let's define the ViewModels used in the communication between
    the server and the client applications. They must be defined in the **PackagesManagementBlazor.Shared**
    project that is referenced by both applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们定义在服务器和客户端应用程序之间通信中使用的ViewModels。它们必须在被两个应用程序引用的**PackagesManagementBlazor.Shared**项目中定义。
- en: 'Let''s start with the `PackageInfosViewModel` ViewModel:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PackageInfosViewModel` ViewModel开始：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, add also the ViewModel that encloses all packages to return to the Blazor
    application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还要添加一个ViewModel，它包含要返回给Blazor应用程序的所有软件包：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can also add our query that searches packages by location. Let''s add
    a `Queries` folder in the root of the **PackagesManagementBlazor.Server** project,
    and then add the interface that defines our query, `IPackagesListByLocationQuery`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还可以添加我们的查询，通过位置搜索软件包。让我们在**PackagesManagementBlazor.Server**项目的根目录中添加一个`Queries`文件夹，然后添加定义我们查询的接口`IPackagesListByLocationQuery`：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, let''s also add the query implementation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也添加查询实现：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We are finally ready to define our `PackagesController`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好定义我们的`PackagesController`：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The server-side code is finished! Let's move on to the definition of the Blazor
    service that communicates with the server.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码已经完成！让我们继续定义与服务器通信的Blazor服务。
- en: Implementing the business logic in a service
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务中实现业务逻辑
- en: 'Let''s add a `ViewModels` and a `Services` folder to the **PackagesManagementBlazor.Client**
    project. Most of the ViewModels we need were already defined in the **PackagesManagementBlazor.Shared**
    project. We only need a ViewModel for the search form. Let''s add it to the `ViewModels`
    folder:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**PackagesManagementBlazor.Client**项目中添加一个`ViewModels`和一个`Services`文件夹。我们需要的大多数ViewModel已经在**PackagesManagementBlazor.Shared**项目中定义。我们只需要一个用于搜索表单的ViewModel。让我们将其添加到`ViewModels`文件夹中：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s call our service `PackagesClient`, and let''s add it to the `Services`
    folder:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的服务为`PackagesClient`，并将其添加到`Services`文件夹中：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The code is straightforward! The `Uri.EscapeDataString` method url-encodes the
    parameter so it can be safely appended to the URL.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单！`Uri.EscapeDataString`方法对参数进行url编码，以便可以安全地附加到URL上。
- en: 'Finally, let''s register the service in the dependency injection:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在依赖注入中注册服务：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is worth pointing out that in a commercial application, we should have registered
    the service through an `IPackagesClient` interface, in order to be able to mock
    it in the tests (`.AddScoped<IPackagesClient, PackagesClient>()`).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，在商业应用程序中，我们应该通过`IPackagesClient`接口注册服务，以便能够在测试中模拟它（`.AddScoped<IPackagesClient,
    PackagesClient>()`）。
- en: Everything is in place; we just need to build the UI.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪；我们只需要构建UI。
- en: Implementing the user interface
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用户界面
- en: As the first step, let's delete application pages we don't need, namely, `Pages->Counter.razor`
    and `Pages->FetchData.razor`. Let's also remove their links from the side menu
    in `Shared->NavMenu.razor`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们删除我们不需要的应用页面，即`Pages->Counter.razor`和`Pages->FetchData.razor`。让我们还从`Shared->NavMenu.razor`中的侧边菜单中删除它们的链接。
- en: 'We will put our code in the `Pages->Index.razor` page. Let''s replace the code
    of this page with this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的代码放在`Pages->Index.razor`页面中。让我们用以下代码替换此页面的代码：
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code adds the needed `@using`, injects our `PackagesClient` service
    in the page, and defines the search form. When the form is successfully submitted,
    it invokes the `Search` callback where we will place the code that retrieves all
    the results.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码添加了所需的`@using`，在页面中注入了我们的`PackagesClient`服务，并定义了搜索表单。当表单成功提交时，它会调用`Search`回调，我们将在其中放置检索所有结果的代码。
- en: 'It is time to add the logic to display all the results and to complete the
    `@code` block. The following code must be placed immediately after the search
    form:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加显示所有结果的逻辑并完成`@code`块了。以下代码必须立即放在搜索表单之后：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The omitted code in the `if` block is responsible for rendering a table with
    all the results. We will show it after having commented the preceding code.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`块中省略的代码负责渲染带有所有结果的表格。在注释了前面的代码之后，我们将显示它。'
- en: Before retrieving the results with the `PackagesClient` service, we remove all
    previous results and set the `loading` field, so the Razor code selects the `else
    if` path that replaces the previous table with a loading message. Once we've set
    these variables, we are forced to call `StateHasChanged` to trigger change detection
    and to refresh the page. After all the results have been retrieved and the callback
    returns, there is no need to call `StateHasChanged` again because the termination
    of the callback itself triggers change detection and causes the required page
    refresh.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`PackagesClient`服务检索结果之前，我们删除所有先前的结果并设置`loading`字段，因此Razor代码选择`else if`路径，用加载消息替换先前的表。一旦我们设置了这些变量，就必须调用`StateHasChanged`来触发变化检测并刷新页面。在检索到所有结果并且回调返回后，不需要再次调用`StateHasChanged`，因为回调本身的终止会触发变化检测并导致所需的页面刷新。
- en: 'Following is the code that renders the table with all the results:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是呈现包含所有结果的表的代码：
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Run the project and write the initial characters of Florence. Since in previous
    chapters, we inserted Florence as a location in the database, some results should
    appear!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并编写Florence的初始字符。由于在之前的章节中，我们在数据库中插入了Florence作为一个位置，所以应该会出现一些结果！
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned what a SPA is and learned how to build a SPA based
    on the Blazor WebAssembly framework. The first part of the chapter described Blazor
    WebAssembly architecture, and then the chapter explained how to exchange input/output
    with Blazor components, and the concept of binding.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了SPA是什么，并学习了如何基于Blazor WebAssembly框架构建SPA。本章的第一部分描述了Blazor WebAssembly架构，然后解释了如何与Blazor组件交换输入/输出以及绑定的概念。
- en: After having explained Blazor's general principles, the chapter focused on how
    to get user input while furnishing the user with adequate feedback and visual
    clues in the event of errors. Then, the chapter furnished a short description
    of advanced features, such as JavaScript interoperability, globalization, authentication
    with authorization, and client-server communication.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了Blazor的一般原则之后，本章重点介绍了如何在提供用户输入的同时，在出现错误时为用户提供足够的反馈和视觉线索。然后，本章简要介绍了高级功能，如JavaScript互操作性，全球化，授权认证和客户端-服务器通信。
- en: Finally, a practical example taken from the book user case shows how to use
    Blazor in practice to implement a simple touristic package search application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从书中用户案例中提取的实际示例展示了如何在实践中使用Blazor来实现一个简单的旅游套餐搜索应用程序。
- en: Questions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is WebAssembly?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebAssembly是什么？
- en: What is an SPA?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SPA是什么？
- en: What is the purpose of the Blazor `router` component?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blazor `router`组件的目的是什么？
- en: What is a Blazor page?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blazor页面是什么？
- en: What is the purpose of the `@namespace` directive?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@namespace`指令的目的是什么？'
- en: What is an `EditContext`?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EditContext`是什么？'
- en: What is the right place to initialize a component?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化组件的正确位置是什么？
- en: What is the right place to process the user input?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理用户输入的正确位置是什么？
- en: What is the `IJSRuntime` interface?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IJSRuntime`接口是什么？'
- en: What is the purpose of `@ref`?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@ref`的目的是什么？'
- en: Further reading
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Blazor official documentation is available at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor官方文档可在此处找到：[https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies)。
- en: 'Assemblies'' lazy loading is described at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关程序集的延迟加载的描述在此处：[https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies)。
- en: 'All HTML events supported by Blazor together with their event arguments are
    listed at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types](https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types).'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor支持的所有HTML事件及其事件参数均列在：[https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types](https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types)。
- en: 'Blazor supports the same validation attributes as ASP.NET MVC, with the exception
    of the `RemoteAttribute`: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes).'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor支持与ASP.NET MVC相同的验证属性，但不包括`RemoteAttribute`：[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes)。
- en: 'A description of the `InputFile` component, and how to use it, can be found
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads).'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputFile`组件的描述以及如何使用它可以在这里找到：[https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads)。'
- en: 'More details on Blazor localization and globalization are available here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization).'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Blazor本地化和全球化的更多详细信息可在此处找到：[https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization)。
- en: 'More details on Blazor authentication are available here, and on all its related
    URLs: [https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/).'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Blazor身份验证的更多详细信息可在此处找到，以及所有相关URL：[https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/)。
