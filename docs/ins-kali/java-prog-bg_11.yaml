- en: XML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML
- en: Say we would like to store information that has a structure that is meaningful
    to our program. Also, we would like this information to be human-readable to some
    degree and sometimes even human-editable. To accomplish this, we very often turn
    to XML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要存储具有对我们程序有意义的结构的信息。此外，我们希望这些信息在某种程度上是可读的，有时甚至是可编辑的。为了实现这一点，我们经常转向XML。
- en: Java provides us with powerful tools for manipulating, reading, and writing
    XML raw text and files. However, as is the case with many powerful tools, there's
    a bit of a knowledge overhead for us to learn how to use them. In this chapter,
    we'll first look at how to use Java to load an XML file into a Java object. Next,
    we'll walk through how to parse XML data using Java. Finally, we'll see the Java
    code to write and modify XML data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java为我们提供了强大的工具，用于操作、读取和编写XML原始文本和文件。然而，与许多强大的工具一样，我们需要学习如何使用它们。在本章中，我们首先将看看如何使用Java将XML文件加载到Java对象中。接下来，我们将逐步介绍如何使用Java解析XML数据。最后，我们将看到用于编写和修改XML数据的Java代码。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Java code for reading XML data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读取XML数据的Java代码
- en: Parsing XML data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析XML数据
- en: Writing and modifying XML data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和修改XML数据
- en: Reading XML data
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取XML数据
- en: 'In this section, we''ll accomplish a very simple task to get ourselves started
    on the road to learning how Java interacts with XML. We''ll use the XML information
    from the `cars.xml` file, provided in the code file of the book. This file should
    be stored in the current directory of our Java project, so when we run our Java
    program, it will be able to access `cars.xml` without any additional pathing required.
    We''ll edit the following Java program to load the `cars.xml` file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成一个非常简单的任务，以便开始学习Java如何与XML交互的道路。我们将使用代码文件中提供的`cars.xml`文件中的XML信息。这个文件应该存储在我们Java项目的当前目录中，所以当我们运行我们的Java程序时，它将能够访问`cars.xml`而不需要任何额外的路径。我们将编辑以下Java程序以加载`cars.xml`文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before we get started, notice that there's a whole lot of imports necessary
    for this program. The `transform` classes we have imported are not necessary for
    anything we're going to write; I've written a function called `PrintXmlDocument()`,
    which will print our XML document to the console window if we successfully load
    it. If you're following along the code in this section, I'd recommend that you
    first import these `transform` classes from the start. Then, as you use additional
    functionality, go ahead and use NetBeans' Fix Imports functionality to see exactly
    from where the libraries, that the tools were utilizing, are coming from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请注意这个程序需要大量的导入。我们导入的`transform`类对我们将要编写的任何内容都不是必需的；我已经编写了一个名为`PrintXmlDocument()`的函数，如果我们成功加载它，它将把我们的XML文档打印到控制台窗口。如果您在本节中跟着代码，我建议您首先从一开始导入这些`transform`类。然后，当您使用额外的功能时，继续使用NetBeans的“修复导入”功能，以确切地看到工具所使用的库来自哪里。
- en: So let's get started. Our end goal here is to have an object of the `Document`
    class that contains the information in our `cars.xml` file. Once we have this
    `Document` object, all we would need to do to see the information in our console
    window is to call the `PrintXmlDocument()` function on the `Document` instance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们的最终目标是拥有一个`Document`类的对象，其中包含我们`cars.xml`文件中的信息。一旦我们有了这个`Document`对象，我们只需要调用`Document`实例上的`PrintXmlDocument()`函数，就可以在我们的控制台窗口中看到信息。
- en: 'Unfortunately, creating this `Document` object is not as simple as saying the `Document
    dom = new Document();` statement. Rather, we need to create it in a structured
    and procedural manner that will properly preserve the parsable nature of our XML
    file. To do this, we''ll make use of two additional classes: the `DocumentBuilder` and `DocumentBuilderFactory`
    classes.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，创建这个`Document`对象并不像说`Document dom = new Document();`那样简单。相反，我们需要以一种结构化和程序化的方式创建它，以正确地保留我们的XML文件的可解析性。为此，我们将使用另外两个类：`DocumentBuilder`和`DocumentBuilderFactory`类。
- en: 'The `DocumentBuilder` class, believe it or not, will take care of the responsibility
    of actually building the document for us. The `DocumentBuilder` class exists as
    a separate entity from the `Document` object so that we, as programmers, can logically
    separate the methodology we can perform on the document itself and the additional
    range of methodology needed to create that document in the first place. Similar
    to the `Document` class, we can''t just instantiate the `DocumentBuilder` class.
    Instead, there''s a third class we''ll utilize to get `DocumentBuilder`, the `DocumentBuilderFactory`
    class. I have divided the code required to create a `Document` object, which stores
    our XML file, into three parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentBuilder`类，信不信由你，将负责实际为我们构建文档。`DocumentBuilder`类作为一个独立的实体存在，与`Document`对象分开，这样我们作为程序员可以在逻辑上分开我们可以对文档本身执行的方法和创建该文档所需的附加方法的范围。与`Document`类类似，我们不能只是实例化`DocumentBuilder`类。相反，有一个第三个类我们将利用来获取`DocumentBuilder`，即`DocumentBuilderFactory`类。我已经将创建`Document`对象所需的代码分为三部分：'
- en: 'The `DocumentBuilderFactory` class contains a static method called `newInstance()`.
    Let''s add the following method call to our first `try` block in the `main()`
    method. This will instantiate `DocumentBuilderFactory` for us to work from:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DocumentBuilderFactory`类包含一个名为`newInstance()`的静态方法。让我们在`main()`方法的第一个`try`块中添加以下方法调用。这将为我们实例化`DocumentBuilderFactory`以便我们可以使用它：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have `DocumentBuilderFactory`, we can acquire for ourselves a new `DocumentBuilder`
    object. To do this, we''re going to call the factory''s `newDocumentBuilder()`
    method. Let''s add it to our try block:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了`DocumentBuilderFactory`，我们就可以为自己获取一个新的`DocumentBuilder`对象。为此，我们将调用工厂的`newDocumentBuilder()`方法。让我们把它添加到我们的try块中：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we need to instruct `DocumentBuilder` to build us a `Document` object
    and that this object should mirror the structure of our `cars.xml` file. We''ll
    simply instantiate our `Document` object with a value in our `try` block. We''ll
    acquire this value from the `parse()` method of `builder`. One of this method''s
    parameters is a string that references a filename. If we had a referenced file
    object in our Java program, we could also use that:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要指示`DocumentBuilder`构建一个`Document`对象，并且该对象应该反映我们的`cars.xml`文件的结构。我们将在我们的`try`块中简单地用一个值实例化我们的`Document`对象。我们将从`builder`的`parse()`方法中获取这个值。这个方法的一个参数是一个引用文件名的字符串。如果我们在我们的Java程序中有一个引用文件对象，我们也可以使用它：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So now our `main()` method looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`main()`方法看起来如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it''s time to check whether our code works. We acquired the `DocumentBuilderFactory` object
    using the static method of the `DocumentBuilderFactory` class, and this creates
    a brand new instance. With `DocumentBuilderFactory`, we created a new `DocumentBuilder`
    object, which will be able to intelligently parse our XML file. In parsing our
    XML file, the `DocumentBuilder` object understands the nature of the information
    contained within and is able to store it in our XML document or the `Document`
    object model element. When we run this program, we get the raw text view of the
    original XML document as output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查我们的代码是否有效了。我们使用`DocumentBuilderFactory`类的静态方法获取了`DocumentBuilderFactory`对象，并创建了一个全新的实例。通过`DocumentBuilderFactory`，我们创建了一个新的`DocumentBuilder`对象，它将能够智能地解析我们的XML文件。在解析我们的XML文件时，`DocumentBuilder`对象了解其中包含的信息的性质，并能够将其存储在我们的XML文档或`Document`对象模型元素中。当我们运行这个程序时，我们会得到原始XML文档的文本视图作为输出：
- en: '![](img/96ce926c-1c7d-4208-8372-e8f3e4917da1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96ce926c-1c7d-4208-8372-e8f3e4917da1.png)'
- en: Because there are so many steps to loading an XML file like this, I wanted to
    put it in its own section. This is so that down the road, when we, as programmers,
    learn about manipulating and reading valuable information from XML, we'll not
    be bogged down by all of the syntax we've seen here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加载这样的XML文件有很多步骤，我想将其放在自己的部分中。这样，当我们作为程序员学习如何从XML中操作和读取有价值的信息时，我们不会被我们在这里看到的所有语法所困扰。
- en: Parsing XML data
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析XML数据
- en: 'The `Document` class provides an easy way for us to store formatted information
    in an object. In the preceding section''s program, we read in information from
    a `cars.xml` file into our Java `Document` object. Here''s what the `cars.xml`
    file looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document`类为我们提供了一种简单的方法来在对象中存储格式化的信息。在前面部分的程序中，我们从`cars.xml`文件中读取信息到我们的Java
    `Document`对象中。`cars.xml`文件如下所示：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The root node of this file is the `cars` node and contained within this node
    are two `owner` nodes, namely Billy and Jane, each of which has a number of `car`
    nodes within them. The information stored within these `car` elements is mirrored
    by the information that can be stored by the preceding Java class we have.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的根节点是`cars`节点，这个节点中包含两个`owner`节点，即Billy和Jane，每个节点中都有一些`car`节点。这些`car`元素中存储的信息与我们之前的Java类中可以存储的信息相对应。
- en: Our goal in this section is to take the car information from `cars.xml` for
    only a specific owner-in this case, Jane-and store this information in our custom
    `Car` class so that we can utilize the `Car` class's `toString()` override to
    print all of Jane's cars to our console in a nicely formatted manner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是从`cars.xml`中获取特定所有者（在本例中是Jane）的汽车信息，并将这些信息存储在我们自定义的`Car`类中，以便我们可以利用`Car`类的`toString()`重写以以良好格式的方式将Jane的所有汽车打印到我们的控制台上。
- en: 'With the code we have already set up, our `Document` object `dom` mirrors the
    information stored in `cars.xml` in the same format, so we simply need to figure
    out how to ask this `Document` object this question: what cars does Jane own?
    In order to figure out how to write the code, you''d need to know a little bit
    about XML terminology. We''re going to be dealing with the terms "element" and
    "node" throughout this section.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们已经设置的代码，我们的`Document`对象`dom`以相同的格式反映了`cars.xml`中存储的信息，所以我们只需要弄清楚如何询问这个`Document`对象这个问题：Jane拥有什么车？为了弄清楚如何编写代码，你需要了解一些关于XML术语的知识。在本节中，我们将处理术语“元素”和“节点”。
- en: In XML, an **element** is an entity that has a start and end tag, and it also
    contains all of the information within it. When our `Document` object returns
    information, it will often return the information in terms of nodes. **Nodes**
    are the building blocks of XML documents, and we can almost think of them as an
    inheritance relationship, where all the elements are nodes, but not all nodes
    are elements. Nodes can be much simpler and smaller than an entire XML element.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中，**元素**是一个具有开始和结束标记的实体，它还包含其中的所有信息。当我们的`Document`对象返回信息时，通常会以节点的形式返回信息。**节点**是XML文档的构建块，我们几乎可以将它们视为继承关系，其中所有元素都是节点，但并非所有节点都是元素。节点可以比整个XML元素简单得多。
- en: Accessing Jane's XML element
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Jane的XML元素
- en: 'This section will help us access the information about the cars owned by Jane,
    using the following code. I have divided the code to be added to our `main()`
    function in six parts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助我们访问关于Jane拥有的汽车的信息，使用以下代码。我已将要添加到我们的`main()`函数中的代码分为六部分：
- en: So, in the pursuit of finding all the cars owned by Jane, let's see what functionality
    our XML document provides for us right off the bat. If we take a look at code
    completion to quickly scan through our list of methods, we can call `dom` from
    our `Document` instance. We're going to see the `getDocumentElement()` method return
    an element for us:![](img/3e2462a0-5917-4b88-93da-b4d3a49a4e49.png)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在寻找Jane拥有的所有汽车的过程中，让我们看看我们的XML文档在一开始为我们提供了哪些功能。如果我们通过代码补全快速扫描我们的方法列表，我们可以从我们的`Document`实例中调用`dom`。我们将看到`getDocumentElement()`方法为我们返回一个元素：![](img/3e2462a0-5917-4b88-93da-b4d3a49a4e49.png)
- en: 'This is probably a good way to start. This method returns the top-level element
    in our XML; in this case, we''re going to get the `cars` element, which contains
    all of the information that we''re going to need. It also contains some information
    we don''t need, such as Billy''s cars, but we''ll parse that out after we''ve
    accessed it. Once we''ve imported the right libraries, we can directly reference
    the concept of an XML element within our code using the `Element` class. We can
    create a new `Element` object and assign its value to the root element of our
    XML document:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个很好的开始方式。这个方法返回我们的XML中的顶层元素；在这种情况下，我们将得到`cars`元素，其中包含了我们需要的所有信息。它还包含一些我们不需要的信息，比如Billy的车，但在我们访问之后我们会解析出来。一旦我们导入了正确的库，我们就可以直接在我们的代码中引用XML元素的概念，使用`Element`类。我们可以创建一个新的`Element`对象，并将其值分配给我们的XML文档的根元素：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, we need to go deeper. The root level of our XML document `cars` is
    not directly useful to us; we need the information contained within it. We only
    really want the information from one `owner` node (containing information about
    Jane's cars). But because of the way XML parsing works, it probably makes sense
    for us to first acquire both of these owner nodes and then find the one that we're
    really interested in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要更深入。我们的XML文档`cars`的根级别对我们来说并不直接有用；我们需要其中包含的信息。我们只真正想要一个`owner`节点的信息（包含关于Jane的车的信息）。但由于XML解析的方式，我们可能最好先获取这两个所有者节点，然后找到我们真正感兴趣的那个。
- en: To acquire both of these nodes, we can call a method on the root XML element
    we've just created and stored in `doc`. XML elements can contain other elements
    within them; in this case, our root element contains a number of `owner` elements.
    The `getElementsByTagName()` method allows us to collect a number of these inner
    elements. The tag name of an XML element is just what you would expect; it is
    the name we gave to that particular element of our XML. In this case, if we ask
    for all the elements with the tag name `owner` contained within our document's
    root element, we're going to further narrow down the amount of XML we're working
    with, getting closer to the small section we desire.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这两个节点，我们可以在我们刚刚创建并存储在`doc`中的根XML元素上调用一个方法。XML元素可以包含其中的其他元素；在这种情况下，我们的根元素包含了许多`owner`元素。`getElementsByTagName()`方法允许我们收集这些内部元素的数量。XML元素的标签名就是你所期望的；它是我们给我们的XML的特定元素的名称。在这种情况下，如果我们要求在我们文档的根元素中包含的所有标签名为`owner`的元素，我们将进一步缩小我们正在处理的XML的数量，接近我们所需的小节。
- en: 'What''s returned by the `getElementsByTagName()`method is not a single element
    though. There are two distinct elements in this section even at the highest level,
    two owners: `Billy` and `Jane`. So, the `getElementsByTagLineName()` method doesn''t
    return a single element; instead, it returns a `NodeList` object, which is a collection
    of XML nodes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByTagName()`方法返回的不是单个元素。即使在最高级别的这一部分中也有两个不同的元素，即两个所有者：`Billy`和`Jane`。因此，`getElementsByTagLineName()`方法不返回单个元素；而是返回一个`NodeList`对象，它是XML节点的集合。'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we''re no longer dealing with our root node at all; we only have its contents.
    It''s time for us to really narrow down our search. Our `NodeList` object contains
    multiple owners, but we only want an owner if the attribute name associated with
    that owner happens to be `Jane`. In order to find this particular element, if
    it exists, we''re simply going to loop through `NodeList`, checking the attributes
    of each element it contains. Note that `ownersList` is not a traditional array.
    It''s a `NodeList` object, its own kind of object. So, we can''t use normal array
    syntax on it. Fortunately, it exposes methods to us that mimic normal array syntax.
    For example, the `getLength()` method will tell us how many objects are in `ownersList`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们根本不再处理我们的根节点；我们只有它的内容。是时候真正地缩小我们的搜索范围了。我们的`NodeList`对象包含多个所有者，但我们只想要一个所有者，如果与该所有者相关联的属性名称恰好是`Jane`。为了找到这个特定的元素（如果存在的话），我们只需循环遍历`NodeList`，检查它包含的每个元素的属性。请注意，`ownersList`不是传统数组。它是一个`NodeList`对象，是它自己的一种对象。因此，我们不能在其上使用正常的数组语法。幸运的是，它向我们提供了模仿正常数组语法的方法。例如，`getLength()`方法将告诉我们`ownersList`中有多少个对象：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similarly, when we attempt to create a new `Element` object and assign that
    value to the currently looped-through portion of `ownersList`, we're not going
    to be able to use the normal syntax we would for an array. Once again though,
    `ownersList` provides us a method to do the same thing. The `item()` method provides,
    or asks for, an index as input.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，当我们尝试创建一个新的`Element`对象并将该值分配给当前循环遍历的`ownersList`部分时，我们将无法使用数组的正常语法。不过，`ownersList`再次为我们提供了一个执行相同操作的方法。`item()`方法提供或要求一个索引作为输入。
- en: 'Note that `ownersList` is `NodeList`, but while elements are nodes, not all
    nodes are elements, so we need to make a decision here. We could check the nature
    of the objects that are returned by this function and assure ourselves that they
    are, in fact, XML elements. But to keep things moving, we''re just going to assume
    that our XML was properly formatted, and we''re simply going to let Java know
    that the node returned by the `item()` method is in fact an element; that is,
    it has a start tag and a closing tag and can contain other elements and nodes
    within it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ownersList`是`NodeList`，但是元素是节点，不是所有节点都是元素，因此我们需要在这里做出决定。我们可以检查此函数返回的对象的性质，并确保它们实际上是XML元素。但为了保持事情的进行，我们只是假设我们的XML格式正确，并且我们只是让Java知道`item()`方法返回的节点实际上是一个元素；也就是说，它有一个开始标签和一个结束标签，并且可以包含其他元素和节点：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we've successfully accessed an element from our list of owners, it's time
    to check and see whether this is the owner that we're looking for; therefore,
    we're going to need a conditional statement. XML elements expose to us the `getAttribute()`
    method, and the attribute that we're interested in is the `name` attribute. So,
    the following bit of code right here will ask the current `owner`, "What is the
    value of your `name` attribute?" If that value is equal to `Jane`, then we know
    we have accessed the right XML element.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功地从所有者列表中访问了一个元素，现在是时候检查并看看这是否是我们正在寻找的所有者；因此，我们将需要一个条件语句。XML元素向我们公开了`getAttribute()`方法，我们感兴趣的属性是`name`属性。因此，这里的代码将询问当前的`owner`，“你的`name`属性的值是多少？”如果该值等于`Jane`，那么我们知道我们已经访问了正确的XML元素。
- en: 'Within Jane''s XML element, now we only have a number of `car` elements. So,
    once again, it''s time to create `NodeList` and populate it with these `car` elements.
    We now need to call the `getElementByTagName()` method on `Jane`, our current
    owner. If we were to use the top-level document to call this function, we would
    get all the `car` elements in the document, even Billy''s:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在简的XML元素中，我们只有一些`car`元素。所以，再次是时候创建`NodeList`并用这些`car`元素填充它。我们现在需要在我们当前的所有者简上调用`getElementByTagName()`方法。如果我们使用顶层文档来调用这个函数，我们将得到文档中的所有`car`元素，甚至是比利的：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This `main()` method is getting a little intense; this is how far I''m willing
    to go in one method. We''re already a couple of levels deep in our code, and it''s
    not exactly simple code we''ve been writing. I think it''s time for us to parse
    out the next bit into its own method. Let''s simply declare that we''re going
    to have a `PrintCars()` method, and this function will take `NodeList` of the
    `car` elements to print the car nodes:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`main()`方法变得有点复杂；这是我愿意在一个方法中做到的极限。我们的代码已经深入了几个层次，我们写的代码并不简单。我认为是时候将下一部分解析成自己的方法了。让我们简单地声明我们将要有一个`PrintCars()`方法，这个函数将接受`car`元素的`NodeList`来打印汽车节点：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our `main` method now looks as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`方法现在如下所示：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Printing Jane's car details
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印简的汽车详情
- en: 'Now, leaving our `main()` method, we''ll define our new `PrintCars()` method.
    I have divided the definition of the `PrintCars()` function into eight parts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，离开我们的`main()`方法，我们将定义我们的新的`PrintCars()`方法。我已经将`PrintCars()`函数的定义分成了八个部分：
- en: 'Because we''re in the entry class of our program and the `PrintCars()` method
    is being called by the static `main()` method, it should probably be a `static`
    function. All it''s going to do is print to our console, so `void` is an appropriate
    return type. We already know it''s going to take `NodeList` of cars as input:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们在程序的入口类中，`PrintCars()`方法是由静态的`main()`方法调用的，它可能应该是一个`static`函数。它将只是打印到我们的控制台，所以`void`是一个合适的返回类型。我们已经知道它将接受汽车的`NodeList`作为输入：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we''ve entered this function, we know we have a list of `car` XML elements
    at our disposal. But in order to print each one out, we''re going to have to loop
    through them. We''ve already looped through XML `NodeList` in our program already,
    so we''re going to be using some very similar syntax. Let''s take a look at what
    needs to change for this new code. Well, we''re no longer looping through `ownersList`;
    we have a new `NodeList` object to loop through the `NodeList` of `cars`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们进入了这个函数，我们知道我们可以使用`car` XML元素的列表。但为了打印出每一个，我们需要循环遍历它们。我们已经在程序中循环遍历了XML的`NodeList`，所以我们将使用一些非常相似的语法。让我们看看这个新代码需要改变什么。好吧，我们不再循环遍历`ownersList`；我们有一个新的`NodeList`对象来循环遍历`cars`的`NodeList`：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We know that cars are still `Element` instances, so our casting a shortcut
    here is still appropriate, but we probably want to rename the variable we''re
    using for each `car` we loop through to something like `carNode`. Each time we
    loop through a car, we''re going to create a new `Car` object and store the information
    in that car''s XML in this actual Java object:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道汽车仍然是`Element`实例，所以我们的强制转换仍然是合适的，但我们可能想要将我们用于循环遍历每辆汽车的变量重命名为类似`carNode`的东西。每次我们循环遍历一辆车时，我们将创建一个新的`Car`对象，并将该车的XML中的信息存储在这个实际的Java对象中：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, in addition to accessing the `car` XML, let''s also declare a `Car` object
    and just instantiate it to be a new `Car` object:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，除了访问`car` XML，让我们也声明一个`Car`对象，并将其实例化为一个新的`Car`对象：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we''re going to build up the values stored within `carObj` by reading them
    from `carNode`. If we jump back to the XML file quickly and take a look at the
    information stored in the `car` element, we''ll see that it stores `make`, `model`,
    `year`, and `color` as XML nodes. The vehicle identification number `vin` is actually
    an attribute. Let''s take a brief look at our `Car.java` class:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将通过从`carNode`中读取它们来构建存储在`carObj`中的值。如果我们快速跳回XML文件并查看存储在`car`元素中的信息，我们将看到它存储了`make`，`model`，`year`和`color`作为XML节点。车辆识别号`vin`实际上是一个属性。让我们简要看一下我们的`Car.java`类：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's start with the easy pieces first; so, `make`, `model`, and `color` are
    all strings stored in the `Car` class and they all happen to be nodes within the
    `car` element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从简单的部分开始；所以，`make`，`model`和`color`都是存储在`Car`类中的字符串，它们恰好都是`car`元素内的节点。
- en: Back to our `PrintCars()` function, we already know how to access nodes within
    an element. We're simply going to use `carNode` and the `getElementsByTagName()`
    function again. If we get all the elements with the tag name of `color`, we should
    get back a list that contains only a single element-the element we're interested
    in, which tells us the color of our car. Unfortunately, we do have a list here,
    so we can't manipulate that element directly until we pull it from the list. Once
    again though, we know how to do this. If we're confident that our XML is properly
    formatted, we know we'll achieve a list with exactly one item in it. Therefore,
    if we get the item at the 0th index of that list, that will be the XML element
    that we're looking for.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`PrintCars()`函数，我们已经知道如何访问元素内的节点。我们只需要再次使用`carNode`和`getElementsByTagName()`函数。如果我们获取所有标签名为`color`的元素，我们应该会得到一个只包含一个元素的列表，这个元素就是我们感兴趣的，告诉我们汽车颜色的元素。不幸的是，我们在这里有一个列表，所以我们不能直接操作该元素，直到我们从列表中取出它。不过，我们知道如何做到这一点。如果我们确信我们的XML格式正确，我们知道我们将获得一个只包含一个项目的列表。因此，如果我们获取该列表的第0个索引处的项目，那将是我们要找的XML元素。
- en: Color information stored in this XML element isn't an attribute though; it's
    inner text. So, we're going to take a look at what methods the XML element exposes
    and see whether there's an appropriate one to acquire the inner text. There is
    the `getTextContent()` function that will give us all of the inner text that's
    not actually part of the XML element tags. In this case, it's going to give us
    the color of our cars.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在这个XML元素中的颜色信息不是一个属性，而是内部文本。因此，我们将查看XML元素公开的方法，看看是否有一个合适的方法来获取内部文本。有一个`getTextContent()`函数，它将给我们所有的内部文本，这些文本实际上不是XML元素标签的一部分。在这种情况下，它将给我们我们汽车的颜色。
- en: 'It''s not enough just to acquire this information; we need to store it. Fortunately,
    all of the attributes of `carObj` are public, so we can freely assign them with
    values after we''ve created our `car` object. If these were private fields without
    setters, we''d probably have to do this information before constructing `carObj`
    and then passing them through to a constructor that it would hopefully have:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些信息还不够；我们需要存储它。幸运的是，`carObj`的所有属性都是公共的，所以我们可以在创建`car`对象后自由地为它们赋值。如果这些是私有字段而没有setter，我们可能需要在构造`carObj`之前进行这些信息，然后通过它们传递给它希望有的构造函数。
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''re going to do pretty much the exact same thing for `make` and `model`.
    The only thing we''re going to have to change is the keyword we provide when looking
    for the elements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`make`和`model`做几乎完全相同的事情。我们唯一需要改变的是我们在查找元素时提供的关键字。
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can continue using the same general strategy for our car''s `year`,
    but we should note that as far as `carObj` is concerned, `year` is an integer.
    As far as our XML element is concerned, `year`, just like anything else, is a
    `TextContent` string. Fortunately, converting a `string` into an `integer`, as
    long as it''s well formed, which is an assumption that we''ll make here, isn''t
    too difficult. We''re simply going to use the `Integer` class and call its `parseInt()`
    method. This will do its best to convert a string value into an integer. We''ll
    assign it to the `year` field of `carObj`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用相同的一般策略来处理我们车辆的`year`，但是我们应该注意，就`carObj`而言，`year`是一个整数。就我们的XML元素而言，`year`，就像其他任何东西一样，是一个`TextContent`字符串。幸运的是，将一个`string`转换为一个`integer`，只要它格式良好，这是一个我们在这里将做出的假设，不是太困难。我们只需要使用`Integer`类并调用它的`parseInt()`方法。这将尽力将一个字符串值转换为一个整数。我们将把它赋给`carObj`的`year`字段。
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This leaves only one more field for us. Note that `carObj` has a vehicle identification
    number field. This field is not actually an integer; vehicle identification numbers
    can contain letters, so this value is stored as a string. It''s going to be a
    little different for us to get though because rather than being an inner element,
    it''s actually an attribute of the `car` element itself. Once again, we know how
    to acquire an attribute from `carNode`; we''re simply going to get the attribute
    with the name `vin` and assign it to `carObj`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样我们就只剩下一个字段了。注意`carObj`有一个车辆识别号字段。这个字段实际上不是一个整数；车辆识别号可以包含字母，所以这个值被存储为一个字符串。我们获取它会有一点不同，因为它不是一个内部元素，而是`car`元素本身的一个属性。我们再次知道如何从`carNode`获取属性；我们只是要获取名称为`vin`的属性并将其赋给`carObj`。
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With all of this done, our `carObj` object should be fully built with reasonable
    values in all of its members. Now it''s time to use `carObj` for the reason it
    exists: to override the `toString()` function. For each car we loop through, let''s
    call the `toString()` function of `carObj` and print that result to our console:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们的`carObj`对象应该在所有成员中具有合理的值。现在是时候使用`carObj`存在的原因了：重写`toString()`函数。对于我们循环遍历的每辆车，让我们调用`carObj`的`toString()`函数，并将结果打印到控制台上。
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `PrintCars()` function will now look as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PrintCars()`函数现在将如下所示：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We should be good to compile our program. Now when we run it, hopefully it''ll
    print out all of Jane''s cars, making use of the overridden `toString()` method
    of `carObj`, to nicely format the output. When we run this program, we get two
    cars printed as output, and if we go to our XML and take a look at the cars assigned
    to Jane, we''ll see that this information does indeed match the information stored
    in these cars:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该可以编译我们的程序了。现在当我们运行它时，希望它会打印出简的所有汽车，利用`carObj`的重写`toString()`方法，来很好地格式化输出。当我们运行这个程序时，我们得到两辆汽车作为输出，如果我们去我们的XML并查看分配给简的汽车，我们会看到这些信息确实与存储在这些汽车中的信息相匹配。
- en: '![](img/4d51007d-148e-44a8-a834-c655dd9fa7aa.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d51007d-148e-44a8-a834-c655dd9fa7aa.png)'
- en: The XML and Java combination is really powerful. XML is human-readable. We can
    understand it and even make modifications to it as people, but it also contains
    really valuable information in terms of how it is structured. This is something
    that programming languages, such as Java, can understand as well. The program
    we've written here-while it does have its quirks and requires a certain amount
    of knowledge to write it-is much easier to write and far easier for a programmer
    to understand and maintain than a similar program from a raw text file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: XML和Java的组合真的非常强大。XML是人类可读的。我们可以理解它，甚至可以对其进行修改，但它也包含了非常有价值的结构化信息。这是编程语言（如Java）也能理解的东西。我们在这里编写的程序虽然有其特点，并且需要一定的知识来编写，但比起从原始文本文件中编写类似程序，它要容易得多，程序员也更容易理解和维护。
- en: Writing XML data
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写XML数据
- en: 'Being able to read XML information is all well and good, but for the language
    to be truly useful to us, our Java programs probably need to be able to write
    out XML information as well. The following program is a bare bones model of a
    program that both reads from and writes to the same XML file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 能够读取XML信息当然很好，但是为了使语言对我们真正有用，我们的Java程序可能也需要能够写出XML信息。以下程序是一个从同一XML文件中读取和写入的程序的基本模型：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Its `main()` method is extremely simple. It takes a file and then reads XML
    from that file storing it in an XML document's tree object. Then, this program
    calls `WriteXMLDocument()` to write the XML back to the same file. Currently,
    the method that reads in the XML has been implemented for us (`LoadXMLDocument()`);
    however, the method to write out the XML is not yet complete. Let's see what needs
    to happen for us to write XML information to a document. I have divided the code
    for the `WriteXMLDocument()` function into four parts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它的`main()`方法非常简单。它接受一个文件，然后从该文件中读取XML，将其存储在XML文档的树对象中。然后，该程序调用`WriteXMLDocument()`将XML写回同一文件。目前，用于读取XML的方法已经为我们实现（`LoadXMLDocument()`）；然而，用于写出XML的方法尚未完成。让我们看看我们需要为我们写入XML信息到文档发生什么。我已将`WriteXMLDocument()`函数的代码分为四个部分。
- en: Java code to write XML data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于编写XML数据的Java代码
- en: 'The following are the steps to be performed for writing XML data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写XML数据需要执行以下步骤：
- en: 'Because of the way an XML document is stored, we need to convert it into a
    different format before it''s really feasible for us to print it out to a file
    in the same format in which we got the original XML. To do this, we''re going
    to make use of an XML-specific class called `Transformer`. As with a number of
    the classes we deal with when dealing with XML in the document model, `Transformer`
    instances are best created using a factory. In this case, the factory is called
    `TransformerFactory`, and like many factories, it exposes the `newInstance()`
    method, allowing us to create one when we need it. To get our new `Transformer`
    object, which will allow us to convert our `Document` object into something streamable
    that we can send to a file, we''re simply going to call the `newTransformer()`
    method of `TransformerFactory`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于XML文档的存储方式，我们需要将其转换为不同的格式，然后才能真正将其以与原始XML相同的格式打印到文件中。为此，我们将使用一个名为`Transformer`的专用于XML的类。与处理文档模型中的许多类一样，最好使用工厂来创建`Transformer`实例。在这种情况下，工厂称为`TransformerFactory`，像许多工厂一样，它公开了`newInstance()`方法，允许我们在需要时创建一个。要获取我们的新`Transformer`对象，它将允许我们将我们的`Document`对象转换为可发送到文件的流的东西，我们只需调用`TransformerFactory`的`newTransformer()`方法：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, before `Transformer` can transform our XML document into something else,
    it''s going to need to know what we would like it to convert our XML document''s
    information into. This class is the `StreamResult` class; it''s the target for
    the information stored within our current `Document` object. The stream is a raw
    binary information pump that can be sent to any number of targets. In this case,
    our target is going to be the destination file provided to the `StreamResult`
    constructor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Transformer`可以将我们的XML文档转换为其他内容之前，它需要知道我们希望它将我们当前`Document`对象的信息转换为什么。这个类就是`StreamResult`类；它是存储在我们当前`Document`对象中的信息的目标。流是一个原始的二进制信息泵，可以发送到任意数量的目标。在这种情况下，我们的目标将是提供给`StreamResult`构造函数的目标文件：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our `Transformer` object though is not automatically linked to our XML document,
    and it expects us to reference our XML document in a unique manner: as a `DOMSource`
    object. Notice that our `source` object (defined next) is being paired with the
    `result` object. The `Transformer` object, when we provide it both these objects,
    will know how to convert one to another. Now, to create our `DOMSource` object,
    we simply need to pass in our XML document:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Transformer`对象并不会自动链接到我们的XML文档，它希望我们以唯一的方式引用我们的XML文档：作为`DOMSource`对象。请注意，我们的`source`对象（接下来定义）正在与`result`对象配对。当我们向`Transformer`对象提供这两个对象时，它将知道如何将一个转换为另一个。现在，要创建我们的`DOMSource`对象，我们只需要传入我们的XML文档：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, when all of that setup is complete, we can execute the functional
    piece of the code. Let''s grab our `Transformer` object and ask it to transform
    our source, that is, the `DOMSource` object, to a streamable result targeted at
    our destination file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当所有设置完成后，我们可以执行代码的功能部分。让我们获取我们的`Transformer`对象，并要求它将我们的源（即`DOMSource`对象）转换为一个流式结果，目标是我们的目标文件：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following becomes our `WriteXMLDocument()` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`WriteXMLDocument()`函数：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we run this program, we''ll get some XML in our file, but you''ll have
    to trust me when I say this: this is the same XML we had before, which is expected
    as we read in the XML first and then print it back as a result.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们将在文件中得到一些XML，但是当我说这是我们之前拥有的相同的XML时，你必须相信我，因为我们首先读取XML，然后将其作为结果打印回去。
- en: To really test whether our program is working, we're going to need to make some
    changes to our `Document` object within the Java code and then see whether we
    can print those changes out to this file. Let's change the names of the cars'
    owners. Let's transfer the deals of all the cars to an owner called Mike.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正测试我们的程序是否工作，我们需要在Java代码中对我们的`Document`对象进行一些更改，然后看看我们是否可以将这些更改打印到这个文件中。让我们改变汽车所有者的名字。让我们将所有汽车的交易转移到一个名叫Mike的所有者名下。
- en: Modifying XML data
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改XML数据
- en: 'The power of the XML I/O system is that in between loading and writing our
    XML document, we can freely modify the `Document` object `dom` stored in memory.
    Also, the changes we make to the object in Java memory will then be written to
    our permanent XML file. So let''s begin by making some changes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: XML I/O系统的强大之处在于在加载和写入XML文档之间，我们可以自由修改存储在内存中的`Document`对象`dom`。而且，我们在Java内存中对对象所做的更改将被写入我们的永久XML文件。所以让我们开始做一些更改：
- en: 'We''re going to use `getElementsByTagName()` to get all the `owner` elements
    in our XML document. This will return a `NodeList` object and we''ll call it `owners`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`getElementsByTagName()`来获取我们的XML文档中的所有`owner`元素。这将返回一个`NodeList`对象，我们将称之为`owners`：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To convert the names of all of these owners to `Mike`, we're going to have to
    loop through this list. As a refresher, we can get the number of items in the
    list by calling the `getLength()` function of `owners`, that is, our `NodeList`
    object. To access the item that we're currently iterating through, we'll use the
    `item()` function of `owners` and pass in our iterating variable `i` to get the
    item at that index. Let's store this value in a variable so that we can use it
    easily; once again, we'll just assume that our XML is well formatted and inform
    Java that we are, in fact, dealing with a fully fledged XML element at this point.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将所有这些所有者的名字转换为`Mike`，我们需要遍历这个列表。作为复习，我们可以通过调用`owners`的`getLength()`函数来获取列表中的项目数，也就是我们的`NodeList`对象。要访问我们当前正在迭代的项目，我们将使用`owners`的`item()`函数，并传入我们的迭代变量`i`来获取该索引处的项目。让我们将这个值存储在一个变量中，以便我们可以轻松使用它；再次，我们将假设我们的XML格式良好，并告诉Java，事实上，我们正在处理一个完全成熟的XML元素。
- en: 'Next, XML elements expose a number of methods that allow us to modify them.
    One of these elements is the `setAttribute()` method, and that''s what we''ll
    be using here. Note that `setAttribute()` takes two strings as input. First, it
    wants to know what attribute we''d like to modify. We''re going to be modifying
    the `name` attribute (it''s the only attribute available to us here), and we''re
    going to assign its value to `Mike`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，XML元素公开了许多允许我们修改它们的方法。其中一个元素是`setAttribute()`方法，这就是我们将要使用的方法。请注意，`setAttribute()`需要两个字符串作为输入。首先，它想知道我们想要修改哪个属性。我们将要修改`name`属性（这是我们这里唯一可用的属性），并且我们将把它的值赋给`Mike`：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now our `main()` method will look as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`main()`方法将如下所示：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run our program and check our XML file, we''ll see that `Mike` is now
    the owner of all these cars as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序并检查我们的XML文件时，我们将看到`Mike`现在是所有这些汽车的所有者，如下面的截图所示：
- en: '![](img/fe46f87a-5603-44b1-89f4-7c2826e14c0a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe46f87a-5603-44b1-89f4-7c2826e14c0a.png)'
- en: Now it might make sense to combine these two XML elements so that `Mike` is
    only a single owner, not split it into two. That's a little bit out of the scope
    for this section, but it's an interesting question and one I want to encourage
    you to reflect on and maybe take a shot at right now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能有意义将这两个XML元素合并，使`Mike`只是一个所有者，而不是分成两个。这有点超出了本节的范围，但这是一个有趣的问题，我鼓励你反思一下，也许现在就试一试。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw the Java code to read an XML file into a `Document`
    object. We also saw how to parse XML data using Java. Finally, we saw how to write
    and modify XML data in Java.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了将XML文件读入`Document`对象的Java代码。我们还看到了如何使用Java解析XML数据。最后，我们看到了如何在Java中编写和修改XML数据。
- en: Congratulations! You are now a Java programmer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在是一个Java程序员。
