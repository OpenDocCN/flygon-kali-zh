- en: Chapter 2. Managing Lots of Threads – Executors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。管理大量线程-执行程序
- en: 'When you implement a simple concurrent application, you create and execute
    a thread per concurrent task. This approach can have some important issues. Since
    **Java version 5**, the Java concurrency API includes the **executor framework**
    to improve the performance of concurrent applications with a lot of concurrent
    tasks. In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当您实现简单的并发应用程序时，您会为每个并发任务创建和执行一个线程。这种方法可能会有一些重要问题。自**Java版本5**以来，Java并发API包括**执行程序框架**，以提高具有大量并发任务的并发应用程序的性能。在本章中，我们将介绍以下内容：
- en: An introduction to executors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行程序介绍
- en: The first example – the k-nearest neighbors algorithm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个示例- k最近邻算法
- en: The second example – concurrency in a client/server environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个示例-客户端/服务器环境中的并发性
- en: An introduction to executors
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行程序介绍
- en: 'The basic mechanism to implement a concurrent application in Java is:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现并发应用程序的基本机制是：
- en: '**A class that implements the Runnable interface**: This is the code you want
    to implement in a concurrent way'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现Runnable接口的类**：这是您想以并发方式实现的代码'
- en: '**An instance of the Thread class**: This is the thread that is going to execute
    the code in a concurrent way'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thread类的实例**：这是将以并发方式执行代码的线程'
- en: With this approach, you're responsible for creating and manning the `Thread`
    objects and implementing the mechanisms of synchronization between the threads.
    However, it can have some problems, especially with those applications with a
    lot of concurrent tasks. If you create too many threads, you can degrade the performance
    of your application or even hang the entire system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，您负责创建和管理`Thread`对象，并实现线程之间的同步机制。但是，它可能会有一些问题，特别是对于具有大量并发任务的应用程序。如果创建了太多的线程，可能会降低应用程序的性能，甚至挂起整个系统。
- en: Java 5 included the executor framework, to solve these problems and provide
    an efficient solution, which would be easier for the programmers to use than the
    traditional concurrency mechanisms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5包括执行程序框架，以解决这些问题并提供有效的解决方案，这将比传统的并发机制更容易供程序员使用。
- en: 'In this chapter, we will introduce the basic characteristics of the executor
    framework by implementing the following two examples using that framework:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用执行程序框架实现以下两个示例来介绍执行程序框架的基本特性：
- en: '**The k-nearest neighbors algorithm**: This is a basic **machine-learning**
    algorithm used in classification. It determines the tag of a test example based
    on the tag of the *k* most similar examples in the train dataset.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**k最近邻算法**：这是一种基本的**机器学习**算法，用于分类。它根据训练数据集中*k*个最相似示例的标签确定测试示例的标签。'
- en: '**Concurrency in a client/server environment**: Applications that serve information
    to thousands or millions of clients are critical nowadays. It is essential to
    implement the server side of the system in an optimal way.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端/服务器环境中的并发性**：为数千或数百万客户端提供信息的应用程序现在至关重要。在最佳方式下实现系统的服务器端是至关重要的。'
- en: In [Chapter 3](part0028_split_000.html#QMFO1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 3. Getting the Maximum from Executors"), *Getting the Maximum from Executors*,
    and [Chapter 4](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 4. Getting Data from the Tasks – The Callable and Future Interfaces"),
    *Getting Data from the Tasks – The Callable and Future Interfaces*, we will introduce
    more advanced aspects of executors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0028_split_000.html#QMFO1-2fff3d3b99304faa8fa9b27f1b5053ba "第3章。从执行程序中获取最大值")中，*从执行程序中获取最大值*，和[第4章](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第4章。从任务中获取数据- Callable和Future接口")中，*从任务中获取数据- Callable和Future接口*，我们将介绍执行程序的更高级方面。
- en: Basic characteristics of executors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行程序的基本特性
- en: 'The main characteristics of executors are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序的主要特点是：
- en: You don't need to create any `Thread` object. If you want to execute a concurrent
    task, you only create an instance of the task (for example, a class that implements
    the `Runnable` interface) and send it to the executor. It will manage the thread
    that will execute the task.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要创建任何`Thread`对象。如果要执行并发任务，只需创建任务的实例（例如，实现`Runnable`接口的类），并将其发送到执行程序。它将管理执行任务的线程。
- en: Executors reduce the overhead introduced by thread creation reusing the threads.
    Internally, it manages a pool of threads named **worker-threads**. If you send
    a task to the executor and a worker-thread is idle, the executor uses that thread
    to execute the task.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行程序通过重用线程来减少线程创建引入的开销。在内部，它管理一个名为**worker-threads**的线程池。如果您将任务发送到执行程序并且有一个空闲的worker-thread，执行程序将使用该线程来执行任务。
- en: It's easy to control the resources used by the executor. You can limit the maximum
    number of worker-threads of your executor. If you send more tasks than worker-threads,
    the executor stores them in a queue. When a worker-thread finishes the execution
    of a task, it takes another from the queue.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易控制执行程序使用的资源。您可以限制执行程序的worker-threads的最大数量。如果发送的任务多于worker-threads，执行程序会将它们存储在队列中。当worker-thread完成任务的执行时，它会从队列中取出另一个任务。
- en: You have to finish the execution of an executor explicitly. You have to indicate
    to the executor that it has to finish its execution and kill the created threads.
    If you don't do this, it won't finish its execution and your application won't
    end.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须显式完成执行程序的执行。您必须指示执行程序完成其执行并终止创建的线程。如果不这样做，它将无法完成其执行，您的应用程序也将无法结束。
- en: Executors have more interesting characteristics that make them very powerful
    and flexible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序具有更多有趣的特性，使其非常强大和灵活。
- en: Basic components of the executor framework
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行程序框架的基本组件
- en: 'The executor framework has various interfaces and classes that implement all
    the functionality provided by executors. The basic components of the framework
    are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序框架具有各种接口和类，实现了执行程序提供的所有功能。框架的基本组件包括：
- en: '**The Executor interface**: This is the basic interface of the executor framework.
    It only defines a method that allows the programmer to send a `Runnable` object
    to an executor.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Executor接口**：这是执行器框架的基本接口。它只定义了一个允许程序员将`Runnable`对象发送到执行器的方法。'
- en: '**The ExecutorService interface**: This interface extends the `Executor` interface
    and includes more methods to increase the functionality of the framework, such
    as the following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExecutorService接口**：这个接口扩展了`Executor`接口，并包括更多的方法来增加框架的功能，例如：'
- en: 'Execute tasks that return a result: The `run()` method provided by the `Runnable`
    interface doesn''t return a result, but with executors, you can have tasks that
    return a result'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行返回结果的任务：`Runnable`接口提供的`run()`方法不返回结果，但使用执行器，你可以有返回结果的任务。
- en: Execute a list of tasks with a single method call
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个方法调用执行任务列表
- en: Finish the execution of an executor and wait for its termination
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成执行器的执行并等待其终止
- en: '**The ThreadPoolExecutor class**: This class implements the `Executor` and
    `ExecutorService` interfaces. In addition, it includes some additional methods
    to get the status of the executor (number of worker-threads, number of executed
    tasks, and so on), methods to establish the parameters of the executor (minimum
    and maximum number or worker-threads, time that idle threads will wait for new
    tasks, and so on) and methods that allow programmers to extends and adapt its
    functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ThreadPoolExecutor类**：这个类实现了`Executor`和`ExecutorService`接口。此外，它包括一些额外的方法来获取执行器的状态（工作线程数、执行任务数等），建立执行器的参数（最小和最大工作线程数、空闲线程等待新任务的时间等），以及允许程序员扩展和调整其功能的方法。'
- en: '**The Executors class**: This class provides utility methods to create `Executor`
    objects and other related classes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Executors类**：这个类提供了创建`Executor`对象和其他相关类的实用方法。'
- en: First example – the k-nearest neighbors algorithm
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个例子 - k最近邻算法
- en: 'The k-nearest neighbors algorithm is a simple machine-learning algorithm used
    for supervised classification. The main components of this algorithm are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: k最近邻算法是一种简单的用于监督分类的机器学习算法。该算法的主要组成部分是：
- en: '**A train dataset**: This dataset is formed by instances with one or more attributes
    that define every instance and a special attribute that determines the example
    or label of the instance'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个训练数据集**：这个数据集由一个或多个属性定义每个实例以及一个特殊属性组成，该属性确定实例的示例或标签'
- en: '**A distance metric**: This metric is used to determine the distance (or similarity)
    between the instances of the train dataset and the new instances you want to classify'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个距离度量标准**：这个度量标准用于确定训练数据集的实例与你想要分类的新实例之间的距离（或相似性）'
- en: '**A test dataset**: This dataset is used to measure the behavior of the algorithm'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个测试数据集**：这个数据集用于衡量算法的行为'
- en: When it has to classify an instance, it calculates the distance against this
    instance and all the instances of the train dataset. Then, it takes the k-nearest
    instances and looks at the tag of those instances. The tag with the most instances
    is the tag assigned to the input instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当它必须对一个实例进行分类时，它会计算与这个实例和训练数据集中所有实例的距离。然后，它会取最近的k个实例，并查看这些实例的标签。具有最多实例的标签将被分配给输入实例。
- en: 'In this chapter, we are going to work with the **Bank Marketing** dataset of
    the **UCI Machine Learning Repository**, which you can download from [http://archive.ics.uci.edu/ml/datasets/Bank+Marketing](http://archive.ics.uci.edu/ml/datasets/Bank+Marketing).
    To measure the distance between instances, we are going to use the **Euclidean
    distance**. With this metric, all the attributes of our instances must have numerical
    values. Some of the attributes of the Bank Marketing dataset are categorical (that
    is to say, they can take one of some predefined values), so we can''t use the
    Euclidean distance directly with this dataset. It''s possible to assign ordinal
    numbers to each categorical value; for example, for marital status, 0 would be
    *single*, 1 would be *married*, and 2 would be *divorced*. However, this would
    imply that the *divorced* person is closer to *married* than to *single*, which
    is disputable. To make all the categorical values equally distant, we create separate
    attributes such as *married*, *single*, and *divorced*, which have only two values:
    0 (*no*) and 1 (*yes*).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**UCI机器学习库**的**银行营销**数据集，你可以从[http://archive.ics.uci.edu/ml/datasets/Bank+Marketing](http://archive.ics.uci.edu/ml/datasets/Bank+Marketing)下载。为了衡量实例之间的距离，我们将使用**欧几里得距离**。使用这个度量标准，我们实例的所有属性必须具有数值。银行营销数据集的一些属性是分类的（也就是说，它们可以取一些预定义的值），所以我们不能直接使用欧几里得距离。可以为每个分类值分配有序数；例如，对于婚姻状况，0表示*单身*，1表示*已婚*，2表示*离婚*。然而，这将意味着*离婚*的人比*已婚*更接近*单身*，这是值得商榷的。为了使所有分类值等距离，我们创建单独的属性，如*已婚*、*单身*和*离婚*，它们只有两个值：0（*否*）和1（*是*）。
- en: 'Our dataset has 66 attributes and two possible tags: *yes* and *no*. We also
    divided the data in two subsets:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集有66个属性和两个可能的标签：*是*和*否*。我们还将数据分成了两个子集：
- en: '**The train dataset**: With 39,129 instances'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**训练数据集**：有39,129个实例'
- en: '**The test dataset**: With 2,059 instances'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试数据集**：有2,059个实例'
- en: As we explained in [Chapter 1](part0014_split_000.html#DB7S2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 1. The First Step – Concurrency Design Principles"), *The First Step
    – Concurrency Design Principles*, we first implemented a serial version of the
    algorithm. Then, we looked for the parts of the algorithm that could be parallelized,
    and we used the executor framework to execute the concurrent tasks. In the following
    sections, we explain the serial implementation of the k-nearest neighbors algorithm
    and two different concurrent versions. The first one has a concurrency with very
    fine-grained granularity, whereas the second one has coarse-grained granularity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0014_split_000.html#DB7S2-2fff3d3b99304faa8fa9b27f1b5053ba "第1章。第一步
    - 并发设计原则")中解释的那样，*第一步 - 并发设计原则*，我们首先实现了算法的串行版本。然后，我们寻找可以并行化的算法部分，并使用执行器框架来执行并发任务。在接下来的章节中，我们将解释k最近邻算法的串行实现和两个不同的并发版本。第一个版本具有非常细粒度的并发性，而第二个版本具有粗粒度的并发性。
- en: K-nearest neighbors – serial version
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K最近邻 - 串行版本
- en: 'We have implemented the serial version of the algorithm in the `KnnClassifier`
    class. Internally, this class stores the train dataset and the number `k` (the
    number of examples that we will use to determine the tag of an instance):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`KnnClassifier`类中实现了算法的串行版本。在内部，这个类存储了训练数据集和数字`k`（我们将用来确定实例标签的示例数量）：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `KnnClassifier` class only implements a method named `classify` that receives
    an `Sample` object with the instance we want to classify, and it returns a string
    with the tag assigned to that instance:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`KnnClassifier`类只实现了一个名为`classify`的方法，该方法接收一个`Sample`对象，其中包含我们要分类的实例，并返回一个分配给该实例的标签的字符串：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method has three main parts—first, we calculate the distances between
    the input example and all the examples of the train dataset:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有三个主要部分 - 首先，我们计算输入示例与训练数据集中所有示例之间的距离：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we sort the examples from lower to higher distance, using the `Arrays.sort()`
    method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Arrays.sort()`方法将示例按距离从低到高排序：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we count the tag with most instances in the k-nearest examples:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们统计k个最近示例中出现最多的标签：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To calculate the distance between two examples, we can use the Euclidean distance
    implemented in an auxiliary class. This is the code of that class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算两个示例之间的距离，我们可以使用一个辅助类中实现的欧几里得距离。这是该类的代码：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have also used the `Distance` class to store the distance between the `Sample`
    input and an instance of the train dataset. It only has two attributes: the index
    of the example of the train dataset and the distance to the input example. In
    addition, it implements the `Comparable` interface to use the `Arrays.sort()`
    method. Finally, the `Sample` class stores an instance. It only has an array of
    doubles and a string with the tag of that instance.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`Distance`类来存储`Sample`输入和训练数据集实例之间的距离。它只有两个属性：训练数据集示例的索引和输入示例的距离。此外，它实现了`Comparable`接口以使用`Arrays.sort()`方法。最后，`Sample`类存储一个实例。它只有一个双精度数组和一个包含该实例标签的字符串。
- en: K-nearest neighbors – a fine-grained concurrent version
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K最近邻 - 细粒度并发版本
- en: 'If you analyze the serial version of the k-nearest neighbors algorithm, you
    can find the following two points where you can parallelize the algorithm:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析k最近邻算法的串行版本，你会发现以下两个点可以并行化算法：
- en: '**The computation of the distances**: Every loop iteration that calculates
    the distance between the input example and one of the examples of the train dataset
    is independent of the others'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离的计算**：计算输入示例与训练数据集中一个示例之间的距离的每次循环迭代都是独立的'
- en: '**The sort of the distances**: Java 8 has included the `parallelSort()` method
    in the `Arrays` class to sort arrays in a concurrent way'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离的排序**：Java 8在`Arrays`类中包含了`parallelSort()`方法，以并发方式对数组进行排序。'
- en: In the first concurrent version of the algorithm, we are going to create a task
    per distance between examples that we're going to calculate. We are also going
    to make it possible to produce a concurrent sort of array of distances. We have
    implemented this version of the algorithm in a class named `KnnClassifierParrallelIndividual`.
    It stores the train dataset, the `k` parameter, the `ThreadPoolExecutor` object
    to execute the parallel tasks, an attribute to store the number of worker-threads
    we want to have in the executor, and an attribute to store if we want to make
    a parallel sort.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第一个并发版本中，我们将为我们要计算的示例之间的每个距离创建一个任务。我们还将使并发排序数组的产生成为可能。我们在一个名为`KnnClassifierParrallelIndividual`的类中实现了这个算法的版本。它存储了训练数据集、`k`参数、`ThreadPoolExecutor`对象来执行并行任务、一个属性来存储我们想要在执行器中拥有的工作线程数量，以及一个属性来存储我们是否想要进行并行排序。
- en: 'We are going to create an executor with a fixed number of threads so that we
    can control the resources of the system that this executor is going to use. This
    number will be the number of processors available in the system we obtain with
    the `availableProcessors()` method of the `Runtime` class multiplied by the value
    of a parameter of the constructor named `factor`. Its value will be the number
    of threads you will have from the processor. We will always use the value `1`,
    but you can test with other values and compare the results. This is the constructor
    of the classification:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有固定线程数的执行器，以便我们可以控制此执行器将使用的系统资源。这个数字将是系统中可用处理器的数量，我们使用`Runtime`类的`availableProcessors()`方法获得，乘以构造函数中名为`factor`的参数的值。它的值将是从处理器获得的线程数。我们将始终使用值`1`，但您可以尝试其他值并比较结果。这是分类的构造函数：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To create the executor, we have used the `Executors` utility class and its `newFixedThreadPool()`
    method. This method receives the number of worker-threads you want to have in
    the executor. The executor will never have more worker-threads than the number
    you specified in the constructor. This method returns an `ExecutorService` object,
    but we cast it to a `ThreadPoolExecutor` object to have access to methods provided
    but the class and not included in the interface.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建执行程序，我们使用了`Executors`实用类及其`newFixedThreadPool()`方法。此方法接收您希望在执行程序中拥有的工作线程数。执行程序的工作线程数永远不会超过您在构造函数中指定的数量。此方法返回一个`ExecutorService`对象，但我们将其转换为`ThreadPoolExecutor`对象，以便访问类提供的方法，而这些方法不包含在接口中。
- en: This class also implements the `classify()` method that receives an example
    and returns a string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还实现了`classify()`方法，该方法接收一个示例并返回一个字符串。
- en: 'First, we create a task for every distance we need to calculate and send them
    to the executor. Then, the main thread has to wait for the end of the execution
    of those tasks. To control that finalization, we have used a synchronization mechanism
    provided by the Java concurrency API: the `CountDownLatch` class. This class allows
    a thread to wait until other threads have arrived at a determined point of their
    code. It''s initialized with the number of threads you want to wait for. It implements
    two methods:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为需要计算的每个距离创建一个任务并将它们发送到执行程序。然后，主线程必须等待这些任务的执行结束。为了控制最终化，我们使用了Java并发API提供的同步机制：`CountDownLatch`类。该类允许一个线程等待，直到其他线程到达其代码的确定点。它使用两种方法：
- en: '`getDown()`: This method decreases the number of threads you have to wait for'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDown()`:此方法减少您必须等待的线程数。'
- en: '`await()`: This method suspends the thread that calls it until the counter
    reaches zero'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await()`:此方法挂起调用它的线程，直到计数器达到零'
- en: 'In this case, we initialize the `CountDownLatch` class with the number of tasks
    we are going to execute in the executor. The main thread calls the `await()` method
    and calls the `getDown()` method for every task, when it finishes its calculation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用任务数初始化`CountDownLatch`类。主线程调用`await()`方法，并在完成计算时为每个任务调用`getDown()`方法：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, depending on the value of the `parallelSort` attribute, we call the `Arrays.sort()`
    or `Arrays.parallelSort()` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据`parallelSort`属性的值，我们调用`Arrays.sort()`或`Arrays.parallelSort()`方法。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we calculate the tag assigned to the input examples. This code is the
    same as in the serial version.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算分配给输入示例的标签。此代码与串行版本相同。
- en: 'The `KnnClassifierParallelIndividual` class also includes a method to shutdown
    the executor calling its `shutdown()` method. It you don''t call this method,
    your application will never end because threads created by the executor are still
    alive and waiting for the new tasks to do. Previously submitted tasks are executed,
    and newly submitted tasks are rejected. The method doesn''t wait for the finalization
    of the executor, it returns immediately:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`KnnClassifierParallelIndividual`类还包括一个调用其`shutdown()`方法关闭执行程序的方法。如果不调用此方法，您的应用程序将永远不会结束，因为执行程序创建的线程仍然活着，等待执行新任务。先前提交的任务将被执行，并且新提交的任务将被拒绝。该方法不会等待执行程序的完成，它会立即返回：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A critical part of this example is the `IndividualDistanceTask` class. This
    is the class that calculates the distance between the input example and an example
    of the train dataset as a concurrent task. It stores the full array of distances
    (we are going to establish the value of one of its positions only), the index
    of the example of the train dataset, both examples, and the `CountDownLatch` object
    used to control the end of the tasks. It implements the `Runnable` interface,
    so it can be executed in the executor. This is the constructor of the class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的一个关键部分是`IndividualDistanceTask`类。这是一个计算输入示例与训练数据集示例之间距离的类。它存储完整的距离数组（我们将仅为其之一的位置设置值），训练数据集示例的索引，两个示例和用于控制任务结束的`CountDownLatch`对象。它实现了`Runnable`接口，因此可以在执行程序中执行。这是该类的构造函数：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `run()` method calculates the distance between the two examples using the
    `EuclideanDistanceCalculator` class explained before and stores the result in
    the corresponding position of the distances:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法使用之前解释的`EuclideanDistanceCalculator`类计算两个示例之间的距离，并将结果存储在距离的相应位置：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that although all the tasks share the array of distances, we don't need
    to use any synchronization mechanism because each task will modify a different
    position of the array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管所有任务共享距离数组，但我们不需要使用任何同步机制，因为每个任务将修改数组的不同位置。
- en: K-nearest neighbors – a coarse-grained concurrent version
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K最近邻 - 粗粒度并发版本
- en: The concurrent solution presented in the previous section may have a problem.
    You are executing too many tasks. If you stop to think, in this case, we have
    more than 29,000 train examples, so you're going to launch 29,000 tasks per example
    you want to classify. On the other hand, we have created an executor with a maximum
    of `numThreads` worker-threads, so another option is to launch only `numThreads`
    tasks and split the train dataset in `numThreads` groups. We executed the examples
    with a quad-core processor, so each task will calculate the distances between
    the input example and approximately 7,000 train examples.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中介绍的并发解决方案可能存在问题。您正在执行太多任务。如果停下来想一想，在这种情况下，我们有超过29,000个训练示例，因此您将为每个要分类的示例启动29,000个任务。另一方面，我们已经创建了一个最大具有`numThreads`工作线程的执行程序，因此另一个选项是仅启动`numThreads`个任务并将训练数据集分成`numThreads`组。我们使用四核处理器执行示例，因此每个任务将计算输入示例与大约7,000个训练示例之间的距离。
- en: 'We have implemented this solution in the `KnnClassifierParallelGroup` class.
    It''s very similar to the `KnnClassifierParallelIndividual` class with two main
    differences. First, the first part of the `classify()` method. Now, we will only
    have `numThreads` tasks, and we have to split the train dataset in `numThreads`
    subsets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`KnnClassifierParallelGroup`类中实现了这个解决方案。它与`KnnClassifierParallelIndividual`类非常相似，但有两个主要区别。首先是`classify()`方法的第一部分。现在，我们只有`numThreads`个任务，我们必须将训练数据集分成`numThreads`个子集：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We calculate the number of samples per task in the length variable. Then, we
    assign to each thread the start and end indexes of the samples they have to process.
    For all the threads except the last one, we add the length value to the start
    index to calculate the end index. For the last one, the last index is the size
    of the dataset.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在长度变量中计算每个任务的样本数量。然后，我们为每个线程分配它们需要处理的样本的起始和结束索引。对于除最后一个线程之外的所有线程，我们将长度值添加到起始索引以计算结束索引。对于最后一个线程，最后一个索引是数据集的大小。
- en: 'Second, this class uses `GroupDistanceTask` instead of `IndividualDistanceTask`.
    The main difference between those classes is that the first one processes a subset
    of the train dataset, so it stores the full train dataset and the first and last
    positions of the dataset it has to process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个类使用`GroupDistanceTask`而不是`IndividualDistanceTask`。这两个类之间的主要区别是第一个处理训练数据集的子集，因此它存储了完整的训练数据集以及它需要处理的数据集的第一个和最后一个位置：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `run()` method processes a set of examples instead of only one example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法处理一组示例而不仅仅是一个示例：'
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Comparing the solutions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较解决方案
- en: 'Let''s compare the different versions of the k-nearest neighbors algorithms
    we have implemented. We have the following five different versions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较我们实现的k最近邻算法的不同版本。我们有以下五个不同的版本：
- en: The serial version
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行版本
- en: The fine-grained concurrent version with serial sorting
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有串行排序的细粒度并发版本
- en: The fine-grained concurrent version with concurrent sorting
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有并发排序的细粒度并发版本
- en: The coarse-grained concurrent version with serial sorting
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有串行排序的粗粒度并发版本
- en: The coarse-grained concurrent version with concurrent sorting
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有并发排序的粗粒度并发版本
- en: 'To test the algorithm, we have used 2,059 test instances, which we take from
    the Bank Marketing dataset. We have classified all those examples using the five
    versions of the algorithm using the values of k as 10, 30, and 50, and measured
    their execution time. We have used the **JMH framework** ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))
    which allows you to implement microbenchmarks in Java. Using a framework for benchmarking
    is a better solution that simply measures time using the `currentTimeMillis()`
    or `nanoTime()` methods. These are the results:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试算法，我们使用了2,059个测试实例，这些实例来自银行营销数据集。我们使用k的值为10、30和50，对所有这些示例使用了算法的五个版本进行分类，并测量它们的执行时间。我们使用了**JMH框架**（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)），它允许您在Java中实现微基准测试。使用基准测试框架比简单地使用`currentTimeMillis()`或`nanoTime()`方法来测量时间更好。以下是结果：
- en: '| Algorithm | K | Execution time (seconds) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | K | 执行时间（秒） |'
- en: '| --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Serial | 10 | 100.296 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 串行 | 10 | 100.296 |'
- en: '| 30 | 99.218 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 99.218 |'
- en: '| 50 | 99.458 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 99.458 |'
- en: '| Fine-grained serial sort | 10 | 108.150 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 细粒度串行排序 | 10 | 108.150 |'
- en: '| 30 | 105.196 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 105.196 |'
- en: '| 50 | 109.797 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 109.797 |'
- en: '| Fine-grained concurrent sort | 10 | 84.663 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 细粒度并发排序 | 10 | 84.663 |'
- en: '| 30 | 85,392 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 85,392 |'
- en: '| 50 | 83.373 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 83.373 |'
- en: '| Coarse-grained serial sort | 10 | 78.328 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 粗粒度串行排序 | 10 | 78.328 |'
- en: '| 30 | 77.041 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 77.041 |'
- en: '| 50 | 76.549 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 76.549 |'
- en: '| Coarse-grained concurrent sort | 10 | 54,017 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 粗粒度并发排序 | 10 | 54,017 |'
- en: '| 30 | 53.473 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 53.473 |'
- en: '| 50 | 53.255 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 50 | 53.255 |'
- en: 'We can draw the following conclusions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: The selected values of the K parameter (10, 30, and 50) don't affect the execution
    time of the algorithm. The five versions present similar results for the three
    values.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所选的K参数值（10、30和50）不影响算法的执行时间。这五个版本对于这三个值呈现出类似的结果。
- en: As it was expected, the use of the concurrent sort with the `Arrays.parallelSort()`
    method gives a great improvement in performance in the fine-grained and the coarse-grained
    concurrent versions of the algorithms.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如预期的那样，使用`Arrays.parallelSort()`方法的并发排序在算法的细粒度和粗粒度并发版本中都大大提高了性能。
- en: The fine-grained version of the algorithm gives the same or slightly worse results
    than the serial algorithm. The overhead introduced by the creation and management
    of concurrent tasks provokes these results. We execute too many tasks.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的细粒度版本与串行算法给出了相同或略差的结果。并发任务的创建和管理引入的开销导致了这些结果。我们执行了太多的任务。
- en: The coarse-grained version, on the other hand, offers a great improvement of
    performance, with serial or parallel sorting.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，粗粒度版本提供了很大的性能改进，无论是串行还是并行排序。
- en: 'So, the best version of the algorithm is the coarse-grained solution using
    parallel sorting. If we compare it with the serial version calculating the speedup:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法的最佳版本是使用并行排序的粗粒度解决方案。如果我们将其与计算加速度的串行版本进行比较：
- en: '![Comparing the solutions](img/00007.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![比较解决方案](img/00007.jpeg)'
- en: This example shows how a good election of a concurrent solution can give us
    a great improvement, and a bad election can give us a bad performance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子显示了一个并发解决方案的良好选择如何给我们带来巨大的改进，而糟糕的选择会给我们带来糟糕的性能。
- en: The second example – concurrency in a client/server environment
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个例子 - 客户端/服务器环境中的并发性
- en: 'The **client/server model** is a software architecture in which applications
    are split into two parts: the server part that provides resources (data, operations,
    printer, storage, and so on) and the client part that uses the resources provided
    by the server. Traditionally, this architecture was used in the enterprise world,
    but with the boom of the Internet, it is still an actual topic. You can see a
    web application as a client/server application where the server part is the backend
    part of the application that is executed in a web server and the web navigator
    executes the client part of the application. **SOA** (short for **Service-Oriented
    Architecture**) is an other example of client/server architecture where the web
    services exposed are the server part and the different clients that consume them
    are the client part.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端/服务器模型**是一种软件架构，将应用程序分为两部分：提供资源（数据、操作、打印机、存储等）的服务器部分和使用服务器提供的资源的客户端部分。传统上，这种架构在企业世界中使用，但随着互联网的兴起，它仍然是一个实际的话题。您可以将
    Web 应用程序视为客户端/服务器应用程序，其中服务器部分是在 Web 服务器中执行的应用程序的后端部分，Web 浏览器执行应用程序的客户端部分。**SOA**（**面向服务的架构**的缩写）是客户端/服务器架构的另一个例子，其中公开的
    Web 服务是服务器部分，而消费这些服务的不同客户端是客户端部分。'
- en: In a client/server environment, we usually have one server and a lot of clients
    that use the services provided by the server, so the performance of the server
    is a critical aspect when you have to design one of these systems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端/服务器环境中，通常有一个服务器和许多客户端使用服务器提供的服务，因此服务器的性能是设计这些系统时的关键方面之一。
- en: 'In this section, we will implement a simple client/server application. It will
    make a search of data over the **World Development Indicators** of the **World
    Bank**, which you can download from here: [http://data.worldbank.org/data-catalog/world-development-indicators](http://data.worldbank.org/data-catalog/world-development-indicators).
    This data contains the values of different indicators over all the countries in
    the world from 1960 to 2014.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个简单的客户端/服务器应用程序。它将对**世界银行**的**世界发展指标**进行数据搜索，您可以从这里下载：[http://data.worldbank.org/data-catalog/world-development-indicators](http://data.worldbank.org/data-catalog/world-development-indicators)。这些数据包含了1960年至2014年间世界各国不同指标的数值。
- en: 'The main characteristics of our server will be:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器的主要特点将是：
- en: The client and the server will connect using sockets
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器将使用套接字连接
- en: The client will send its queries in a string, and the server will respond to
    the results in another string
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将以字符串形式发送其查询，服务器将以另一个字符串形式回复结果
- en: 'The server can respond with three different queries:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可以用三种不同的查询进行回复：
- en: '**Query**: The format of this query is `q;codCountry;codIndicator;year` where
    `codCountry` is the code of the country, `codIndicator` is the code of the indicator,
    and `year` is an optional parameter with the year you want to query. The server
    will respond with the information in a single string.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：此查询的格式为 `q;codCountry;codIndicator;year`，其中 `codCountry` 是国家的代码，`codIndicator`
    是指标的代码，`year` 是一个可选参数，表示您要查询的年份。服务器将以单个字符串形式回复信息。'
- en: '**Report**: The format of this query is `r;codIndicator` where `codIndicator`
    is the code of the indicator you want to report. The server will respond with
    the mean value of that indicator for all countries over the years in a single
    string.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告**：此查询的格式为 `r;codIndicator`，其中 `codIndicator` 是您想要报告的指标的代码。服务器将以单个字符串形式回复所有国家在多年间该指标的平均值。'
- en: '**Stop**: The format of this query is `z;`. The server stops its execution
    when it receives this command.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：此查询的格式为 `z;`。服务器在收到此命令时停止执行。'
- en: In other cases, the server returns an error message.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他情况下，服务器会返回错误消息。
- en: As in the previous example, we will show you how to implement a serial version
    of this client/server application. Then, we will show you how to implement a concurrent
    version using an executor. Finally, we will compare the two solutions to view
    the advantages of the use of concurrency in this case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将向您展示如何实现此客户端/服务器应用程序的串行版本。然后，我们将向您展示如何使用执行器实现并发版本。最后，我们将比较这两种解决方案，以查看在这种情况下使用并发的优势。
- en: Client/server – serial version
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器 - 串行版本
- en: 'The serial version of our server application has three main parts:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器应用程序的串行版本有三个主要部分：
- en: The **DAO** (short for **Data Access Object**) part, responsible for access
    to the data and obtaining the results of the query
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DAO**（**数据访问对象**的缩写）部分，负责访问数据并获取查询结果'
- en: The command part, formed by a command per kind of query
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令部分，由每种查询类型的命令组成
- en: The server part, which receives the queries, calls the corresponding command,
    and returns the results to the client
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器部分，接收查询，调用相应的命令，并将结果返回给客户端
- en: Let's see in detail each of these parts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些部分。
- en: The DAO part
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DAO 部分
- en: As we mentioned before, the server will make a search of data over the world
    development indicators of the World Bank. This data is in a CSV file. The DAO
    component in the application loads the entire file into a `List` object in memory.
    It implements a method per query it will attend that goes over the list looking
    for the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，服务器将对世界银行的世界发展指标进行数据搜索。这些数据在一个 CSV 文件中。应用程序中的 DAO 组件将整个文件加载到内存中的 `List`
    对象中。它实现了一个方法来处理它将处理的每个查询，以便查找数据。
- en: We don't include the code of this class here because it's simple to implement
    and it's not the main purpose of this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在此处包含此类的代码，因为它很容易实现，而且不是本书的主要目的。
- en: The command part
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令部分
- en: 'The command part is an intermediary between the DAO and the server parts. We
    have implemented a base abstract `Command` class to be the base class of all the
    commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 命令部分是 DAO 和服务器部分之间的中介。我们实现了一个基本的抽象 `Command` 类，作为所有命令的基类：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we have implemented a command for each query. The query is implemented
    in the `QueryCommand` class. The `execute()` method is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个查询实现了一个命令。查询在 `QueryCommand` 类中实现。`execute()` 方法如下：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The report is implemented in `ReportCommand`. The `execute()` method is as
    follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 报告是在`ReportCommand`中实现的。`execute()`方法如下：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The stop query is implemented in the `StopCommand` class. Its `execute()` method
    is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 停止查询是在`StopCommand`类中实现的。其`execute()`方法如下：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the error situations are processed by the `ErrorCommand` class. Its
    `execute()` method is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，错误情况由`ErrorCommand`类处理。其`execute()`方法如下：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The server part
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器部分
- en: 'Finally, the server part is implemented in the `SerialServer` class. First
    of all, it initializes the DAO calling the `getDAO()` method. The main objective
    is that the DAO loads all the data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务器部分是在`SerialServer`类中实现的。首先，它通过调用`getDAO()`方法来初始化DAO。主要目标是DAO加载所有数据：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this, we have a loop that will be executed until the server receives
    a stop query. This loop does the following four steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个循环，直到服务器接收到停止查询才会执行。这个循环执行以下四个步骤：
- en: Receives a query for a client
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收来自客户端的查询
- en: Parses and splits the elements of the query
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析和拆分查询的元素
- en: Calls the corresponding command
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用相应的命令
- en: Returns the results to the client
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果返回给客户端
- en: 'These four steps are shown in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个步骤显示在以下代码片段中：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Client/server – parallel version
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器-并行版本
- en: The serial version of the server has a very important limitation. While it is
    processing one query, it can't attend to other queries. If the server needs an
    important amount of time to respond to every request, or to certain requests,
    the performance of the server will be very low.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的串行版本有一个非常重要的限制。在处理一个查询时，它无法处理其他查询。如果服务器需要大量时间来响应每个请求，或者某些请求，服务器的性能将非常低。
- en: We can obtain a better performance using concurrency. If the server creates
    a thread when it receives a request, it can delegate to the thread all the processes
    of the query and it can attend new request. This approach can also have some problems.
    If we receive a high number of queries, we can saturate the system creating too
    many threads. But if we use an executor with a fixed number of threads, we can
    control the resources used by our server and obtain a better performance than
    the serial version.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并发可以获得更好的性能。如果服务器在收到请求时创建一个线程，它可以将所有查询的处理委托给线程，并且可以处理新的请求。这种方法也可能存在一些问题。如果我们收到大量查询，我们可能会通过创建太多线程来饱和系统。但是，如果我们使用具有固定线程数的执行程序，我们可以控制服务器使用的资源，并获得比串行版本更好的性能。
- en: To convert our serial server to a concurrent one using an executor, we have
    to modify the server part. The DAO part is the same, and we have changed the names
    of the classes that implement the command part, but their implementation is almost
    the same. Only the stop query changes because now it has more responsibilities.
    Let's see the details of the implementation of the concurrent server part.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的串行服务器转换为使用执行程序的并发服务器，我们必须修改服务器部分。DAO部分是相同的，我们已更改实现命令部分的类的名称，但它们的实现几乎相同。只有停止查询发生了变化，因为现在它有更多的责任。让我们看看并发服务器部分的实现细节。
- en: The server part
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器部分
- en: 'The concurrent server part is implemented in the `ConcurrentServer` part. We
    have added two elements not included in the serial server: a cache system, implemented
    in the `ParallelCache` class and a log system, implemented in the `Logger` class.
    First of all, it initializes the DAO part calling the `getDAO()` method. The main
    objective is that the DAO loads all the data and creates a `ThreadPoolExecutor`
    object using the `newFixedThreadPool()` method of the `Executors` class. This
    method receives the maximum number of worker-threads we want in our server. The
    executor will never have more than those worker-threads. To get the number of
    worker-threads, we get the number of cores of our system using the `availableProcessors()`
    method of the `Runtime` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 并发服务器部分是在`ConcurrentServer`部分实现的。我们添加了两个在串行服务器中未包括的元素：一个缓存系统，实现在`ParallelCache`类中，以及一个日志系统，实现在`Logger`类中。首先，它通过调用`getDAO()`方法来初始化DAO部分。主要目标是DAO加载所有数据并使用`Executors`类的`newFixedThreadPool()`方法创建`ThreadPoolExecutor`对象。此方法接收我们服务器中要使用的最大工作线程数。执行程序永远不会有超过这些工作线程。要获取工作线程数，我们使用`Runtime`类的`availableProcessors()`方法获取系统的核心数：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `stopped` Boolean variable is declared as volatile because it will be changed
    from another thread. The `volatile` keyword ensures that when the `stopped` variable
    is set to `true` by another thread, this change will be visible in the main method.
    Without the `volatile` keyword, the change cannot be visible due to CPU caching
    or compiler optimizations. Then, we initialize `ServerSocket` to listen for the
    requests:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopped`布尔变量声明为volatile，因为它将从另一个线程更改。`volatile`关键字确保当`stopped`变量被另一个线程设置为`true`时，这种更改将在主方法中可见。没有`volatile`关键字，由于CPU缓存或编译器优化，更改可能不可见。然后，我们初始化`ServerSocket`以侦听请求：'
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can't use a try-with-resources statement to manage the server socket. When
    we receive a `stop` command, we need to shut down the server, but the server is
    waiting in the `accept()` method of the `serverSocket` object. To force the server
    to leave that method, we need to explicitly close the server (we'll do that in
    the `shutdown()` method), so we can't leave the try-with-resources statement close
    the socket for us.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用try-with-resources语句来管理服务器套接字。当我们收到`stop`命令时，我们需要关闭服务器，但服务器正在`serverSocket`对象的`accept()`方法中等待。为了强制服务器离开该方法，我们需要显式关闭服务器（我们将在`shutdown()`方法中执行），因此我们不能让try-with-resources语句为我们关闭套接字。
- en: 'After this, we have a loop that will be executed until the server receives
    a stop query. This loop does three steps, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个循环，直到服务器接收到停止查询才会执行。这个循环有三个步骤，如下所示：
- en: Receives a query for a client
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收来自客户端的查询
- en: Creates a task to process that query
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个处理该查询的任务
- en: Sends the task to the executor
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务发送给执行程序
- en: 'These three steps are shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤显示在以下代码片段中：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, once the server has finished its execution (leaving the loop), we
    have to wait for the finalization of the executor using the `awaitTermination()`
    method. This method will block the main thread until the executor has finished
    its `execution()` method. Then, we shut down the cache system and wait for a message
    to indicate the end of the execution of the server, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦服务器完成了执行（退出循环），我们必须等待执行器的完成，使用 `awaitTermination()` 方法。这个方法将阻塞主线程，直到执行器完成其
    `execution()` 方法。然后，我们关闭缓存系统，并等待一条消息来指示服务器执行的结束，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have added two additional methods: the `getExecutor()` method, which returns
    the `ThreadPoolExecutor` object that is used to execute the concurrent tasks,
    and the `shutdown()` method, which is used to finish in an ordered way the executor
    of the server. It calls the `shutdown()` method of the executor and closes `ServerSocket`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个额外的方法：`getExecutor()` 方法，返回用于执行并发任务的 `ThreadPoolExecutor` 对象，以及 `shutdown()`
    方法，用于有序地结束服务器的执行器。它调用执行器的 `shutdown()` 方法，并关闭 `ServerSocket`：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the concurrent server, there is an essential part: the `RequestTask` class
    which processes every request of the clients. This class implements the `Runnable`
    interface, so it can be executed in an executor in a concurrent way. Its constructor
    receives the `Socket` parameter which will be used to communicate to the client:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发服务器中，有一个重要的部分：`RequestTask` 类，它处理客户端的每个请求。这个类实现了 `Runnable` 接口，因此可以以并发方式在执行器中执行。它的构造函数接收
    `Socket` 参数，用于与客户端通信。
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `run()` method does the same things that are done by the serial server
    to respond to every requests:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法做了与串行服务器相同的事情来响应每个请求：'
- en: Receives a query for a client
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收客户端的查询
- en: Parses and splits the elements of the query
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析和拆分查询的元素
- en: Calls the corresponding command
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用相应的命令
- en: Returns the results to the client
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果返回给客户端
- en: 'The following is its code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的代码片段：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The command part
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令部分
- en: 'In the command part, we have renamed all the classes as you can see in the
    previous fragment of code. The implementation is the same except in the `ConcurrentStopCommand`
    class. Now, it calls the `shutdown()` method of the `ConcurrentServer` class to
    terminate the execution of the server in an ordered way. This is the `execute()`
    method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令部分，我们已经重命名了所有的类，就像你在前面的代码片段中看到的那样。实现是一样的，除了 `ConcurrentStopCommand` 类。现在，它调用
    `ConcurrentServer` 类的 `shutdown()` 方法，以有序地终止服务器的执行。这是 `execute()` 方法：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, now the `Command` class contains a new `isCacheable()` Boolean method
    that returns `true` if the command result is stored in the cache and `false` otherwise.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在 `Command` 类包含一个新的 `isCacheable()` 布尔方法，如果命令结果存储在缓存中则返回 `true`，否则返回 `false`。
- en: Extra components of the concurrent server
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发服务器的额外组件
- en: 'We have implemented some extra components in the concurrent server: a new command
    to return information about the status of the server, a cache system to store
    the results of the commands, time saving when a request is repeated, and a log
    system to write error and debug information. The following sections describe each
    of these components.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在并发服务器中实现了一些额外的组件：一个新的命令来返回有关服务器状态的信息，一个缓存系统来存储命令的结果，当请求重复时节省时间，以及一个日志系统来写入错误和调试信息。以下各节描述了这些组件的每个部分。
- en: The status command
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态命令
- en: 'First of all, we have a new possible query. It has the format `s;` and is processed
    by the `ConcurrentStatusCommand` class. It gets `ThreadPoolExecutor` used by the
    server and obtains information about the status of the executor:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个新的可能的查询。它的格式是 `s;`，由 `ConcurrentStatusCommand` 类处理。它获取服务器使用的 `ThreadPoolExecutor`，并获取有关执行器状态的信息：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The information we obtain from the server is:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从服务器获取的信息是：
- en: '`getActiveCount()`: This returns the approximate number of tasks that execute
    our concurrent tasks. There can be more threads in the pool, but they can be idle.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 这返回了执行我们并发任务的近似任务数量。池子中可能有更多的线程，但它们可能是空闲的。'
- en: '`getMaximumPoolSize()`: This returns the maximum number of worker-threads the
    executor can have.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMaximumPoolSize()`: 这返回了执行器可以拥有的最大工作线程数。'
- en: '`getCorePoolSize()`: This returns the core number of worker-threads the executor
    will have. This number determines the minimum number of threads the pool will
    have.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCorePoolSize()`: 这返回了执行器将拥有的核心工作线程数。这个数字决定了池子将拥有的最小线程数。'
- en: '`getPoolSize()`: This returns the current number of threads in the pool.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 这返回了池子中当前的线程数。'
- en: '`getLargestPoolSize()`: This returns the maximum number of threads of the pool
    during its execution.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLargestPoolSize()`: 这返回了池子在执行期间的最大线程数。'
- en: '`getCompletedTaskCount()`: This returns the number of tasks the executor has
    executed.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 这返回了执行器已执行的任务数量。'
- en: '`getTaskCount()`: This returns the approximate number of tasks that have ever
    been scheduled for execution.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTaskCount()`: 这返回了曾被调度执行的任务的近似数量。'
- en: '`getQueue().size()`: This returns the number of tasks that are waiting in the
    queue of tasks.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueue().size()`: 这返回了等待在任务队列中的任务数量。'
- en: As we have created our executor using the `newFixedThreadPool()` method of the
    `Executor` class, our executor will have the same maximum and core worker-threads.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 `Executor` 类的 `newFixedThreadPool()` 方法创建了我们的执行器，因此我们的执行器将具有相同的最大和核心工作线程数。
- en: The cache system
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存系统
- en: 'We have included a cache system in our parallel server to avoid the data search
    that has recently been made. Our cache system has three elements:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在并行服务器中加入了一个缓存系统，以避免最近进行的数据搜索。我们的缓存系统有三个元素：
- en: '**The CacheItem class**: This class represents every element stored in the
    cache. It has four attributes:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CacheItem 类**：这个类代表缓存中存储的每个元素。它有四个属性：'
- en: The command stored in the cache. We will store the `query` and `report` commands
    in the cache.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存中存储的命令。我们将把 `query` 和 `report` 命令存储在缓存中。
- en: The response generated by that command.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由该命令生成的响应。
- en: The creation date of the item in the cache.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存中该项的创建日期。
- en: The last time this item was accessed in the cache.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存中该项上次被访问的时间。
- en: '**The CleanCacheTask class**: If we store all the commands in the cache but
    never delete the elements stored in it, the cache will increase its size indefinitely.
    To avoid this situation, we can have a task that deletes elements in the cache.
    We are going to implement this task as a `Thread` object. There are two options:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CleanCacheTask类**：如果我们将所有命令存储在缓存中，但从未删除其中存储的元素，缓存的大小将无限增加。为了避免这种情况，我们可以有一个删除缓存中元素的任务。我们将实现这个任务作为一个`Thread`对象。有两个选项：'
- en: You can have the maximum size in the cache. If the cache has more elements than
    the maximum size, you can delete the elements that have been accessed less recently.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在缓存中设置最大大小。如果缓存中的元素多于最大大小，可以删除最近访问次数较少的元素。
- en: You can delete from the cache the elements that haven't been accessed in a predefined
    period of time. We are going to use this approach.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从缓存中删除在预定义时间段内未被访问的元素。我们将使用这种方法。
- en: '**The ParallelCache class**: This class implements the operations to store
    and retrieve elements in the cache. To store the data in the cache, we have used
    a `ConcurrentHashMap` data structure. As the cache will be shared between all
    the tasks of the server, we have to use a synchronization mechanism to protect
    the access to the cache avoiding data race conditions. We have three options:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ParallelCache类**：这个类实现了在缓存中存储和检索元素的操作。为了将数据存储在缓存中，我们使用了`ConcurrentHashMap`数据结构。由于缓存将在服务器的所有任务之间共享，我们必须使用同步机制来保护对缓存的访问，避免数据竞争条件。我们有三个选项：'
- en: We can use a non-synchronized data structure (for example, a `HashMap`) and
    add the necessary code to synchronize the types of access to this data structure,
    for example, with a lock. You can also convert a `HashMap` into a synchronized
    structure using the `synchronizedMap()` method of the `Collections` class.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一个非同步的数据结构（例如`HashMap`），并添加必要的代码来同步对这个数据结构的访问类型，例如使用锁。您还可以使用`Collections`类的`synchronizedMap()`方法将`HashMap`转换为同步结构。
- en: Use a synchronized data structure, for example, `Hashtable`. In this case, we
    don't have data race conditions, but the performance can be better.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步数据结构，例如`Hashtable`。在这种情况下，我们没有数据竞争条件，但性能可能会更好。
- en: Use a concurrent data structure, for example, a `ConcurrentHashMap` class, which
    eliminates the possibility of data race conditions and it's optimized to work
    in a high concurrent environment. This is the option we're going to implement
    using an object of the `ConcurrentHashMap` class.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发数据结构，例如`ConcurrentHashMap`类，它消除了数据竞争条件的可能性，并且在高并发环境中进行了优化。这是我们将使用`ConcurrentHashMap`类的对象来实现的选项。
- en: 'The code of the `CleanCacheTask` class is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`CleanCacheTask`类的代码如下：'
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The class has a `ParallelCache` object. Every 10 seconds, it executes the `cleanCache()`
    method of the `ParallelCache` instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一个`ParallelCache`对象。每隔10秒，它执行`ParallelCache`实例的`cleanCache()`方法。
- en: 'The `ParallelCache` class has five different methods. First, the constructor
    of the class that initializes the elements of the cache. It creates the `ConcurrentHashMap`
    object and starts a thread that will execute the `CleanCacheTask` class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelCache`类有五种不同的方法。首先是类的构造函数，它初始化缓存的元素。它创建`ConcurrentHashMap`对象并启动一个将执行`CleanCacheTask`类的线程：'
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, there are two methods to store and retrieve an element in the cache.
    We use the `put()` method to insert the element in the `HashMap` and the `get()`
    method to retrieve the element from the `HashMap`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两种方法来存储和检索缓存中的元素。我们使用`put()`方法将元素插入`HashMap`中，使用`get()`方法从`HashMap`中检索元素：
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, the method to clean the cache used by the `CleanCacheTask` class is:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`CleanCacheTask`类使用的清除缓存的方法是：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, the method to shut down the cache that interrupts the thread executing
    the `CleanCacheTask` class and the method that returns the number of elements
    stored in the cache is:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭缓存的方法中断执行`CleanCacheTask`类的线程，并返回缓存中存储的元素数量的方法是：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The log system
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志系统
- en: 'In all the examples of this chapter, we write information in the console using
    the `System.out.println()` method. When you implement an enterprise application
    that is going to execute in a production environment, it''s a better idea to use
    a log system to write debug and error information. In Java, `log4j` is the most
    popular log system. In this example, we are going to implement our own log system
    implementing the producer/consumer concurrency design pattern. The tasks that
    will use our log system will be the producer, and a special task (executed as
    a thread) that will write the log information into a file will be the consumer.
    The components of this log system are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有示例中，我们使用`System.out.println()`方法在控制台中写入信息。当您实现一个将在生产环境中执行的企业应用程序时，最好使用日志系统来写入调试和错误信息。在Java中，`log4j`是最流行的日志系统。在这个例子中，我们将实现我们自己的日志系统，实现生产者/消费者并发设计模式。将使用我们的日志系统的任务将是生产者，而将日志信息写入文件的特殊任务（作为线程执行）将是消费者。这个日志系统的组件有：
- en: '**LogTask**: This class implements the log consumer that after every 10 seconds
    reads the log messages stored in the queue and writes them to a file. It will
    be executed by a `Thread` object.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogTask**：这个类实现了日志消费者，每隔10秒读取队列中存储的日志消息并将其写入文件。它将由一个`Thread`对象执行。'
- en: '**Logger**: This is the main class of our log system. It has a queue where
    the producer will store the information and the consumer will read it. It also
    includes the method to add a message into the queue and a method to get all the
    messages stored in the queue and write them to disk.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Logger**：这是我们日志系统的主要类。它有一个队列，生产者将在其中存储信息，消费者将读取信息。它还包括将消息添加到队列中的方法以及获取队列中存储的所有消息并将它们写入磁盘的方法。'
- en: 'To implement the queue, as happens with the cache system, we need a concurrent
    data structure to avoid any data inconsistency errors. We have two options:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现队列，就像缓存系统一样，我们需要一个并发数据结构来避免任何数据不一致的错误。我们有两个选择：
- en: Use a **blocking data structure**, which blocks the thread when the queue is
    full (in our case, it will never be full) or empty
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**阻塞数据结构**，当队列满时会阻塞线程（在我们的情况下，它永远不会满）或为空时
- en: Use a **non-blocking data structure**, which returns a special value if the
    queue is full or empty
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**非阻塞数据结构**，如果队列满或为空，则返回一个特殊值
- en: We have chosen a non-blocking data structure, the `ConcurrentLinkedQueue` class,
    which implements the `Queue` interface. We use the `offer()` method to insert
    elements in the queue and the `poll()` method to get elements from it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个非阻塞数据结构，`ConcurrentLinkedQueue`类，它实现了`Queue`接口。我们使用`offer()`方法向队列中插入元素，使用`poll()`方法从中获取元素。
- en: 'The `LogTask` class code is very simple:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogTask`类的代码非常简单：'
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The class implements the `Runnable` interface and, in the `run()` method, calls
    the `writeLogs()` method of the `Logger` class every 10 seconds.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该类实现了`Runnable`接口，在`run()`方法中调用`Logger`类的`writeLogs()`方法，每10秒执行一次。
- en: 'The `Logger` class has five different static methods. First of all, a static
    block of code that initializes and starts a thread that executes the `LogTask`
    and creates the `ConcurrentLinkedQueue` class used to store the log data:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`类有五种不同的静态方法。首先是一个静态代码块，用于初始化和启动执行`LogTask`的线程，并创建用于存储日志数据的`ConcurrentLinkedQueue`类：'
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, there is a `sendMessage()` method that receives a string as a parameter
    and stores that message in the queue. To store the message, it uses the `offer()`
    method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一个`sendMessage()`方法，它接收一个字符串作为参数，并将该消息存储在队列中。为了存储消息，它使用`offer()`方法：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A critical method of this class is the `writeLogs()` class. It obtains and
    deletes all the log messages stored in the queue using the `poll()` method of
    the `ConcurrentLinkedQueue` class and writes them to a file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的一个关键方法是`writeLogs()`方法。它使用`ConcurrentLinkedQueue`类的`poll()`方法获取并删除队列中存储的所有日志消息，并将它们写入文件：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, two methods: one to truncate the log file and another to finish the
    executor of the log system, which interrupts the thread that is executing `LogTask`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两种方法：一种是截断日志文件，另一种是完成日志系统的执行器，中断正在执行“LogTask”的线程：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Comparing the two solutions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较两种解决方案
- en: 'Now it''s time to test the serial and concurrent servers and see which has
    a better performance. We have automatized the tests implementing four classes
    that make queries to the servers. These classes are:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试串行和并发服务器，看看哪个性能更好了。我们已经实现了四个类来自动化测试，这些类向服务器发出查询。这些类是：
- en: '`SerialClient`: This implements a possible client of the serial server. It
    makes nine requests using the query message and a query using the report message.
    It repeats the process 10 times, so it request 90 queries and 10 reports.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerialClient`：这个类实现了一个可能的串行服务器客户端。它使用查询消息进行九次请求，并使用报告消息进行一次查询。它重复这个过程10次，因此它请求了90个查询和10个报告。'
- en: '`MultipleSerialClients`: This class simulates the existence of several clients
    at the same time. For this, we create a thread per `SerialClient` and execute
    them at the same time to see the performance of the server. We have tested from
    one to five concurrent clients.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleSerialClients`：这个类模拟了同时存在多个客户端的情况。为此，我们为每个`SerialClient`创建一个线程，并同时执行它们，以查看服务器的性能。我们已经测试了从一个到五个并发客户端。'
- en: '`ConcurrentClient`: It is analogue to the `SerialClient` class, but it calls
    the concurrent server instead of the serial one.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentClient`：这个类类似于`SerialClient`类，但它调用的是并发服务器，而不是串行服务器。'
- en: '`MultipleConcurrentClients`: It is analogue to the `MultipleSerialClients`
    class, but it calls the concurrent server instead of the serial one.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleConcurrentClients`：这个类类似于`MultipleSerialClients`类，但它调用的是并发服务器，而不是串行服务器。'
- en: 'To test the serial server, you can follow these steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试串行服务器，可以按照以下步骤进行：
- en: Launch the serial server and wait for its initialization.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动串行服务器并等待其初始化。
- en: Launch the `MultipleSerialClients` class, which launches one, then two, three,
    four, and finally, five `SerialClient` classes.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`MultipleSerialClients`类，它启动一个、两个、三个、四个，最后是五个`SerialClient`类。
- en: 'You can follow a similar process with the concurrent server:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的过程来测试并发服务器：
- en: Launch the concurrent server and wait for its initialization.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动并等待并发服务器的初始化。
- en: Launch the `MultipleConcurrentClients` class, which launches one, two, three,
    four, and finally, five `ConcurrentClient` classes.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`MultipleConcurrentClients`类，它启动一个、两个、三个、四个，最后是五个`ConcurrentClient`类。
- en: To compare the execution times of both versions, we have implemented a microbenchmark
    using the JMH framework ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)).
    We have implemented two executions based in the `SerialClient` and `ConcurrentClient`
    tasks. We have repeated this process 10 times calculating the mean time per number
    of concurrent clients. We launched the tests in a computer with a processor with
    four cores, so it can execute four parallel tasks at the same time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两个版本的执行时间，我们使用JMH框架（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)）实现了一个微基准测试。我们基于`SerialClient`和`ConcurrentClient`任务实现了两次执行。我们重复这个过程10次，计算每个并发客户端的平均时间。我们在一个具有四个核心处理器的计算机上进行了测试，因此它可以同时执行四个并行任务。
- en: 'These are the results of all these executions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些执行的结果如下：
- en: '| Concurrent clients | Serial server | Concurrent server | Speedup |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 并发客户端 | 串行服务器 | 并发服务器 | 加速比 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 7.404 | 5.144 | 1.43 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7.404 | 5.144 | 1.43 |'
- en: '| 2 | 9.344 | 4.491 | 2.08 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9.344 | 4.491 | 2.08 |'
- en: '| 3 | 19.641 | 9.308 | 2.11 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 19.641 | 9.308 | 2.11 |'
- en: '| 4 | 29.180 | 12.842 | 2.27 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 29.180 | 12.842 | 2.27 |'
- en: '| 5 | 30.542 | 16.322 | 1.87 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 30.542 | 16.322 | 1.87 |'
- en: 'The contents of the cells are the mean time of each client in seconds. We can
    draw the following conclusions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的内容是每个客户端的平均时间（以秒为单位）。我们可以得出以下结论：
- en: The performance of both kinds of servers is affected by the number of concurrent
    clients that send requests to our server
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种类型服务器的性能都受到并发客户端发送请求的数量的影响
- en: In all cases, the execution times of the concurrent version are much lower than
    the execution times of the serial one
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有情况下，并发版本的执行时间远远低于串行版本的执行时间
- en: Other methods of interest
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有趣的方法
- en: Throughout the pages of this chapter, we have used some classes of the Java
    concurrency API to implement basic functionalities of the executor framework.
    These classes also have other interesting methods. In this section, we collate
    some of them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的页面中，我们使用了Java并发API的一些类来实现执行程序框架的基本功能。这些类还有其他有趣的方法。在本节中，我们整理了其中一些。
- en: 'The `Executors` class provides other methods to create `ThreadPoolExecutor`
    objects. These methods are:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors`类提供其他方法来创建`ThreadPoolExecutor`对象。这些方法是：'
- en: '`newCachedThreadPool()`: This method creates a `ThreadPoolExecutor` object
    that reuses a worker-thread if it''s idle, but it creates a new one if it''s necessary.
    There is no maximum number of worker-threads.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 此方法创建一个`ThreadPoolExecutor`对象，如果空闲，则重用工作线程，但如果有必要，则创建一个新线程。没有工作线程的最大数量。'
- en: '`newSingleThreadExecutor()`: This method creates a `ThreadPoolExecutor` object
    that uses only a single worker-thread. The tasks you send to the executor are
    stored in a queue until the worker-thread can execute them.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 此方法创建一个只使用单个工作线程的`ThreadPoolExecutor`对象。您发送到执行程序的任务将存储在队列中，直到工作线程可以执行它们。'
- en: 'The `CountDownLatch` class provides the following additional methods:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类提供以下附加方法：'
- en: '`await(long timeout, TimeUnit unit)`: It waits till the internal counter arrives
    to zero of pass the time specified in the parameters. If the time passes, the
    method returns the `false` value.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await(long timeout, TimeUnit unit)`: 它等待直到内部计数器到达零或者经过参数中指定的时间。如果时间过去，方法返回`false`值。'
- en: '`getCount()`: This method returns the actual value of the internal counter.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCount()`: 此方法返回内部计数器的实际值。'
- en: 'There are two types of concurrent data structures in Java:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有两种类型的并发数据结构：
- en: '**Blocking data structures**: When you call a method and the library can''t
    do that operation (for example, you try to obtain an element, and the data structure
    is empty), they block the thread until the operation can be done.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞数据结构**：当您调用一个方法并且库无法执行该操作（例如，尝试获取一个元素，而数据结构为空），它们会阻塞线程，直到操作可以完成。'
- en: '**Non-blocking data structures**: When you call a method and the library can''t
    do that operation (because the structure is empty or full), the method returns
    a special value or throws an exception.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞数据结构**：当您调用一个方法并且库无法执行该操作（因为结构为空或已满）时，该方法会返回一个特殊值或抛出异常。'
- en: There are data structures that implement both behaviors and data structures
    that implement only one. Usually, blocking data structures also implement the
    methods with non-blocking behavior, and non-blocking data structures don't implement
    the blocking methods.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有些数据结构同时实现了这两种行为，有些数据结构只实现了其中一种。通常，阻塞数据结构也实现了具有非阻塞行为的方法，而非阻塞数据结构不实现阻塞方法。
- en: 'The methods that implement the blocking operations are:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实现阻塞操作的方法有：
- en: '`put()`, `putFirst()`, `putLast()`: These insert an element in the data structure.
    If it''s full, it blocks the thread until there is space.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`, `putFirst()`, `putLast()`: 这些在数据结构中插入一个元素。如果已满，它会阻塞线程，直到有空间。'
- en: '`take()`, `takeFirst()`, `takeLast()`: These return and remove an element of
    the data structure. If it''s empty, it blocks the thread until there is an element
    in it.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`, `takeFirst()`, `takeLast()`: 这些返回并移除数据结构的一个元素。如果为空，它会阻塞线程，直到有元素。'
- en: 'The methods that implement the non-blocking operations are:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非阻塞操作的方法有：
- en: '`add()`, `addFirst()`, `addLast()`: These insert an element in the data structure.
    If it''s full, the method throws an `IllegalStateException` exception.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`, `addFirst()`, `addLast()`: 这些在数据结构中插入一个元素。如果已满，方法会抛出`IllegalStateException`异常。'
- en: '`remove()`, `removeFirst()`, `removeLast()`: These return and remove an element
    from the data structure. If it''s empty, the method throws an `IllegalStateException`
    exception.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`, `removeFirst()`, `removeLast()`: 这些方法从数据结构中返回并移除一个元素。如果为空，方法会抛出`IllegalStateException`异常。'
- en: '`element()`, `getFirst()`, `getLast()`: These return but don''t remove an element
    from the data structure. If it''s empty, the method throws an `IllegalStateException`
    exception.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element()`, `getFirst()`, `getLast()`: 这些从数据结构中返回但不移除一个元素。如果为空，方法会抛出`IllegalStateException`异常。'
- en: '`offer()`, `offerFirst()`, `offerLast()`: These insert an element value in
    the data structure. If it''s full, they return the `false` Boolean value.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offer()`, `offerFirst()`, `offerLast()`: 这些在数据结构中插入一个元素值。如果已满，它们返回`false`布尔值。'
- en: '`poll()`, `pollFirst()`, `pollLast()`: These return and remove an element from
    the data structure. If it''s empty, they return the null value.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`, `pollFirst()`, `pollLast()`: 这些从数据结构中返回并移除一个元素。如果为空，它们返回null值。'
- en: '`peek()`, `peekFirst()`, `peekLast()`: These return but don''t remove an element
    from the data structure. If it''s empty, they return the null value.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`, `peekFirst()`, `peekLast()`: 这些从数据结构中返回但不移除一个元素。如果为空，它们返回null值。'
- en: In [Chapter 9](part0056_split_000.html#1LCVG2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 9. Diving into Concurrent Data Structures and Synchronization Utilities"),
    *Diving into Concurrent Data Structures and Synchronization Utilities*, we will
    describe concurrent data structures in more detail.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0056_split_000.html#1LCVG2-2fff3d3b99304faa8fa9b27f1b5053ba "第9章。深入并发数据结构和同步工具")中，*深入并发数据结构和同步工具*，我们将更详细地描述并发数据结构。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In simple concurrent applications, we execute concurrent tasks using the `Runnable`
    interface and the `Thread` class. We create and manage the threads and control
    their execution. We can't follow this approach in big concurrent applications
    because it can cause us many problems. For these cases, the Java concurrency API
    has introduced the executor framework. In this chapter, we presented the basic
    characteristics and components that form this framework. First of all, the `Executor`
    interface, which defines the basic method to send a `Runnable` task to an executor.
    This interface has a subinterface, the `ExecutorService` interface, which includes
    methods to send to the executor tasks that return a result (these tasks implement
    the `Callable` interface, as we will see in [Chapter 4](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 4. Getting Data from the Tasks – The Callable and Future Interfaces"),
    *Getting Data from the Tasks – The Callable and Future Interfaces*) and a list
    of tasks.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的并发应用程序中，我们使用`Runnable`接口和`Thread`类执行并发任务。我们创建和管理线程并控制它们的执行。在大型并发应用程序中，我们不能采用这种方法，因为它可能会给我们带来许多问题。对于这些情况，Java并发API引入了执行器框架。在本章中，我们介绍了构成此框架的基本特征和组件。首先是`Executor`接口，它定义了将`Runnable`任务发送到执行器的基本方法。该接口有一个子接口，即`ExecutorService`接口，该接口包括将返回结果的任务发送到执行器的方法（这些任务实现了`Callable`接口，正如我们将在[第4章](part0033_split_000.html#VF2I1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第4章。从任务中获取数据-Callable和Future接口")中看到的，*从任务中获取数据-Callable和Future接口*）以及任务列表。
- en: 'The `ThreadPoolExecutor` class is the basic implementation of both interfaces:
    adding additional methods to get information about the status of the executor
    and the number of threads or tasks that are executing. The easiest way to create
    an object of this class is by using the `Executors` utility class, which includes
    methods to create different kinds of executors.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类是这两个接口的基本实现：添加额外的方法来获取有关执行器状态和正在执行的线程或任务数量的信息。创建此类的对象的最简单方法是使用`Executors`实用程序类，该类包括创建不同类型的执行器的方法。'
- en: We showed you how to use executors and convert serial algorithms to concurrent
    ones using executors implementing two real-world examples. The first example is
    the k-nearest neighbors algorithm, applying it to the Bank Marketing dataset of
    the UCI machine learning repository. The second example is a client/server application
    to make queries over the World Development Indicators of the World Bank.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了如何使用执行器，并使用执行器实现了两个真实世界的例子，将串行算法转换为并发算法。第一个例子是k最近邻算法，将其应用于UCI机器学习存储库的银行营销数据集。第二个例子是一个客户端/服务器应用程序，用于查询世界银行的世界发展指标。
- en: In both cases, the use of executors gave us a great improvement of performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，使用执行器都为我们带来了很大的性能改进。
- en: In the next chapter, we will describe how to implement advanced techniques with
    executors. We are going to complete our client/server application adding the possibility
    of cancelling and executing tasks with higher priority before the tasks with a
    lower priority. We will also show you how to implement tasks that will execute
    periodically, implementing an RSS news reader.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述如何使用执行器实现高级技术。我们将完成我们的客户端/服务器应用程序，添加取消任务和在低优先级任务之前执行具有更高优先级的任务的可能性。我们还将向您展示如何实现定期执行任务，实现一个RSS新闻阅读器。
