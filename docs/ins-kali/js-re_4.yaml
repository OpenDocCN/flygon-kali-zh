- en: Chapter 4. Regex in Practice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。实践中的正则表达式
- en: In the previous two chapters, we covered Regex's syntax in depth, and at this
    point, have all the pieces required to build a real-world project, which will
    be the goal of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们深入讨论了正则表达式的语法，并且在这一点上，我们已经具备了构建真实项目所需的所有要素，这将是本章的目标。
- en: Knowing Regex's syntax allows you to model text patterns, but sometimes coming
    up with a good reliable pattern can be more difficult, so taking a look at some
    actual use cases can really help you learn some common design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正则表达式的语法允许您对文本模式进行建模，但有时提出一个好的可靠模式可能更困难，因此查看一些实际用例可以帮助您学习一些常见的设计模式。
- en: 'So, in this chapter, we will develop a form, and we will explore the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将开发一个表单，并探讨以下主题：
- en: Validating a name
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证姓名
- en: Validating e-mails
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证电子邮件
- en: Validating a Twitter username
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Twitter用户名
- en: Validating passwords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证密码
- en: Validating URLs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证URL
- en: Manipulating text
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文本
- en: Regular expressions and form validation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式和表单验证
- en: By far, one of the most common uses for regular expressions on the frontend
    is for use with user submitted forms, so this is what we will be building. The
    form we will be building will have all the common fields, such as name, e-mail,
    website, and so on, but we will also experiment with some text processing besides
    all the validations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在前端上，正则表达式最常见的用途之一是与用户提交的表单一起使用，因此这就是我们将要构建的内容。我们将构建的表单将包含所有常见字段，如姓名、电子邮件、网站等，但除了所有验证之外，我们还将尝试一些文本处理。
- en: 'In real-world applications, you usually are not going to implement the parsing
    and validation code manually. You can create a regular expression and rely on
    some JavaScript libraries, such as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常不会手动实现解析和验证代码。您可以创建一个正则表达式，并依赖于一些JavaScript库，例如：
- en: '**jQuery validation**: Refer to [http://jqueryvalidation.org/](http://jqueryvalidation.org/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery验证**：参见[http://jqueryvalidation.org/](http://jqueryvalidation.org/)'
- en: '**Parsely.js**: Refer to [http://parsleyjs.org/](http://parsleyjs.org/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parsely.js**：参见[http://parsleyjs.org/](http://parsleyjs.org/)'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even the most popular frameworks support the usage of regular expressions with
    its native validation engine, such as **AngularJS** (refer to [http://www.ng-newsletter.com/posts/validations.html](http://www.ng-newsletter.com/posts/validations.html)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最流行的框架也支持使用正则表达式进行本地验证引擎，例如**AngularJS**（参见[http://www.ng-newsletter.com/posts/validations.html](http://www.ng-newsletter.com/posts/validations.html)）。
- en: Setting up the form
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置表单
- en: This demo will be for a site that allows users to create an online bio, and
    as such, consists of different types of fields. However, before we get into this
    (since we won't be building a backend to handle the form), we are going to setup
    some HTML and JavaScript code to catch the form submission and extract/validate
    the data entered in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示将是一个允许用户创建在线简介的网站，因此包含不同类型的字段。然而，在我们进入这个之前（因为我们不会构建一个处理表单的后端），我们将设置一些HTML和JavaScript代码来捕获表单提交并提取/验证其中输入的数据。
- en: To keep the code neat, we will create an array with all the validation functions,
    and a data object where all the final data will be kept.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码整洁，我们将创建一个包含所有验证函数的数组，以及一个数据对象，其中将保存所有最终数据。
- en: 'Here is a basic outline of the HTML code for which we begin by adding fields:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们开始添加字段的HTML代码的基本大纲：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to write some JavaScript to catch the form and run through the
    list of functions that we will be writing. If a function returns false, it means
    that the verification did not pass and we will stop processing the form. In the
    event where we get through the entire list of functions and no problems arise,
    we will log out of the console and data object, which contain all the fields we
    extracted:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一些JavaScript来捕获表单并运行我们将要编写的函数列表。如果一个函数返回false，这意味着验证未通过，我们将停止处理表单。如果我们通过整个函数列表并且没有出现问题，我们将在控制台和包含我们提取的所有字段的数据对象中注销：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The JavaScript starts by creating the two variables I mentioned previously,
    we then pull the form's object from the DOM and set the submit handler. The `submit`
    handler begins by preventing a page from actually submitting, (as we don't have
    any backend code in this example) and then we go through the list of functions
    running them one by one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript首先创建了我之前提到的两个变量，然后从DOM中提取表单对象并设置提交处理程序。`submit`处理程序首先通过阻止页面实际提交（因为在这个例子中我们没有任何后端代码），然后我们逐个运行函数列表中的函数。
- en: Validating fields
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证字段
- en: In this section, we will explore how to validate different types of fields manually,
    such as name, e-mail, website URL, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何手动验证不同类型的字段，如姓名、电子邮件、网站URL等。
- en: Matching a complete name
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配完整姓名
- en: 'To get our feet wet, let''s begin with a simple name field. It''s something
    we have gone through briefly in the past, so it should give you an idea of how
    our system will work. The following code goes inside the script tags, but only
    after everything we have written so far:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从一个简单的姓名字段开始。这是我们之前简要介绍过的内容，所以它应该给您一个关于我们的系统将如何工作的想法。以下代码放在脚本标签内，但是在我们迄今为止写的所有内容之后：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We get the name field in a similar way to how we got the form, then, we extract
    the value and test it against a pattern to match a full name. If the name doesn't
    match the pattern, we simply alert the user and return `false` to let the form
    handler know that the validations have failed. If the name field is in the correct
    format, we set the corresponding fields on the data object (remember, the middle
    name is optional here). The last line just adds this function to the array of
    functions, so it will be called when the form is submitted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似于获取表单的方式获取姓名字段，然后提取值并根据模式匹配完整姓名。如果姓名不匹配模式，我们只是警告用户并返回`false`，以让表单处理程序知道验证失败。如果姓名字段格式正确，我们在数据对象上设置相应的字段（请记住，中间名在这里是可选的）。最后一行只是将此函数添加到函数数组中，因此在提交表单时将调用它。
- en: 'The last thing required to get this working is to add HTML for this form field,
    so inside the form tags (right before the submit button), you can add this text
    input:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使其正常工作所需的最后一件事是为此表单字段添加HTML，因此在表单标签内（提交按钮右边），您可以添加此文本输入：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Opening this page in your browser, you should be able to test it out by entering
    different values into the **Name** box. If you enter a valid name, you should
    get the data object printed out with the correct parameters, otherwise you should
    be able to see this alert message:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开此页面，您应该能够通过在**名称**框中输入不同的值来测试它。如果您输入一个有效的名称，您应该能够打印出具有正确参数的数据对象，否则您应该能够看到此警报消息：
- en: '![Matching a complete name](img/2258OS_04_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![匹配完整名称](img/2258OS_04_01.jpg)'
- en: Understanding the complete name Regex
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解完整名称正则表达式
- en: 'Let''s go back to the regular expression used to match the name entered by
    a user:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用于匹配用户输入的名称的正则表达式：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is a brief explanation of the Regex:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对正则表达式的简要解释：
- en: The `^` character asserts its position at the beginning of a string
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 字符断言其位置在字符串的开头'
- en: The first capturing group `(\S+)`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个捕获组`(\S+)`
- en: '`\S+` matches a non-white space character [`^\r\n\t\f`]'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S+` 匹配一个非空格字符 [`^\r\n\t\f`]'
- en: The `+` quantifier between one and unlimited times
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词一次或多次'
- en: The second capturing group `(\S*)`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个捕获组`(\S*)`
- en: '`\S*` matches any non-whitespace character [`^\r\n\t\f`]'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S*` 匹配任何非空白字符 [`^\r\n\t\f`]'
- en: The `*` quantifier between zero and unlimited times
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 量词零次或多次'
- en: '`" ?"` matches the whitespace character'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`" ?"` 匹配空格字符'
- en: The `?` quantifier between zero and one time
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词零次或一次'
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b` 断言其位置在（`^\w|\w$|\W\w|\w\W`）单词边界'
- en: The third capturing group `(\S+)`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个捕获组`(\S+)`
- en: '`\S+` matches a non-whitespace character [`^\r\n\t\f`]'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S+` 匹配一个非空白字符 [`^\r\n\t\f`]'
- en: The `+` quantifier between one and unlimited times
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词一次或多次'
- en: '`$` asserts its position at the end of a string'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 断言其位置在字符串的末尾'
- en: Matching an e-mail with Regex
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配电子邮件
- en: The next type of field we may want to add is an e-mail field. E-mails may look
    pretty simple at first glance, but there are a large variety of e-mails out there.
    You may just think of creating a `word@word.word` pattern, but the first section
    can contain many additional characters besides just letters, the domain can be
    a subdomain, or the suffix could have multiple parts (such as `.co.uk` for the
    UK).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要添加的下一个字段类型是电子邮件字段。电子邮件乍看起来可能很简单，但实际上有各种各样的电子邮件。你可能只想创建一个`word@word.word`的模式，但第一部分除了字母之外还可以包含许多其他字符，域可以是子域，或者后缀可以有多个部分（比如`.co.uk`代表英国）。
- en: 'Our pattern will simply look for a group of characters that are not spaces
    or instances where the `@` symbol has been used in the first section. We will
    then want an `@` symbol, followed by another set of characters that have at least
    one period, followed by the suffix, which in itself could contain another suffix.
    So, this can be accomplished in the following manner:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式将简单地寻找一组不是空格或在第一部分中使用了`@`符号的字符。然后我们希望有一个`@`符号，后面跟着另一组至少有一个句点的字符，然后是后缀，后缀本身可能包含另一个后缀。因此，可以以以下方式完成：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pattern of our example is very simple and will not match every valid e-mail
    address. There is an official standard for an e-mail address's regular expressions
    called **RFC 5322**. For more information, please read [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例模式非常简单，不会匹配每个有效的电子邮件地址。有一个官方标准用于电子邮件地址的正则表达式，称为**RFC 5322**。有关更多信息，请阅读[http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html)。
- en: 'So, let''s add the field to our page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将该字段添加到我们的页面上：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then add this function to verify it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以添加这个函数来验证它：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is an HTML5 field type specifically designed for e-mails, but here we
    are verifying manually, as this is a Regex book. For more information, please
    refer to [http://www.w3.org/TR/html-markup/input.email.html](http://www.w3.org/TR/html-markup/input.email.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个专门设计用于电子邮件的HTML5字段类型，但这里我们正在手动验证，因为这是一本正则表达式书。有关更多信息，请参阅[http://www.w3.org/TR/html-markup/input.email.html](http://www.w3.org/TR/html-markup/input.email.html)。
- en: Understanding the e-mail Regex
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解电子邮件正则表达式
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用于匹配用户输入的名称的正则表达式：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Following is a brief explanation of the Regex:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对正则表达式的简要解释：
- en: '`^` asserts a position at the beginning of the string'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 断言其位置在字符串的开头'
- en: '`[^\s@]+` matches a single character that is not present in the following list:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s@]+` 匹配不在以下列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词一次或多次'
- en: '`\s` matches any white space character [`\r\n\t\f` ]'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何空白字符 [`\r\n\t\f`]'
- en: '`@` matches the `@` literal character'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 匹配 `@` 字面字符'
- en: '`[^\s@.]+` matches a single character that is not present in the following
    list:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s@.]+` 匹配不在以下列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词一次或多次'
- en: '`\s` matches a [`\r\n\t\f`] whitespace character'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配一个 [`\r\n\t\f`] 空白字符'
- en: '`@.` is a single character in the `@.` list, literally'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@.` 是 `@.` 列表中的单个字符'
- en: '`\.` matches the `.` character literally'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\.` 字符匹配`.`字符'
- en: '`[^\s@]+` match a single character that is not present in the following list:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s@]+` 匹配不在以下列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词一次或多次'
- en: '`\s` matches [`\r\n\t\f`] a whitespace character'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配 [`\r\n\t\f`] 空白字符'
- en: '`@` is the `@` literal character'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 是 `@` 字面字符'
- en: '`$` asserts its position at end of a string'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 断言其位置在字符串的末尾'
- en: Matching a Twitter name
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配Twitter名称
- en: The next field we are going to add is a field for a Twitter username. For the
    unfamiliar, a Twitter username is in the `@username` format, but when people enter
    this in, they sometimes include the preceding `@` symbol and on other occasions,
    they only write the username by itself. Obviously, internally we would like everything
    to be stored uniformly, so we will need to extract the username, regardless of
    the `@` symbol, and then manually prepend it with one, so regardless of whether
    it was there or not, the end result will look the same.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的下一个字段是 Twitter 用户名的字段。对于不熟悉的人来说，Twitter 用户名是以 `@username` 格式的，但当人们输入时，他们有时会包括前置的
    `@` 符号，而在其他情况下，他们只会写用户名本身。显然，内部我们希望一切都以统一的方式存储，所以我们需要提取用户名，无论 `@` 符号是否存在，然后手动添加一个，所以无论它是否存在，最终结果看起来都是一样的。
- en: 'So again, let''s add a field for this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们再次为此添加一个字段：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s write the function to handle it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写处理它的函数：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a user inputs the `@` symbol, it will be ignored, as we will add it manually
    after checking the username.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入 `@` 符号，它将被忽略，因为在检查用户名后，我们将手动添加它。
- en: Understanding the twitter username Regex
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Twitter 用户名的正则表达式
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用于匹配用户输入的名称的正则表达式：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a brief explanation of the Regex:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正则表达式的简要解释：
- en: '`^` asserts its position at start of the string'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 断言它的位置在字符串的开头'
- en: '`@?` matches the `@` character, literally'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@?` 匹配 `@` 字符，字面上'
- en: The `?` quantifier between zero and one time
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词表示出现零次或一次'
- en: First capturing group `(\w+)`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个捕获组 `(\w+)`
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w+` 匹配一个 [`a-zA-Z0-9_`] 的单词字符'
- en: The `+` quantifier between one and unlimited times
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词表示出现一次或多次'
- en: '`$` asserts its position at end of a string'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 断言它的位置在字符串的末尾'
- en: Matching passwords
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配密码
- en: Another popular field, which can have some unique constraints, is a password
    field. Now, not every password field is interesting; you may just allow just about
    anything as a password, as long as the field isn't left blank. However, there
    are sites where you need to have at least one letter from each case, a number,
    and at least one other character. Considering all the ways these can be combined,
    creating a pattern that can validate this could be quite complex. A much better
    solution for this, and one that allows us to be a bit more verbose with our error
    messages, is to create four separate patterns and make sure the password matches
    each of them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的字段，可能有一些独特的约束条件，是密码字段。现在，并不是每个密码字段都有趣；你可能只允许几乎任何东西作为密码，只要字段不为空就可以。然而，有些网站需要至少包含一个大写字母、一个小写字母、一个数字和至少一个其他字符。考虑到这些可以组合的方式，创建一个可以验证这一点的模式可能会非常复杂。对于这个问题，一个更好的解决方案，也可以让我们在错误消息上更加详细，是创建四个单独的模式，并确保密码与每个模式匹配。
- en: 'For the input, it''s almost identical:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入，它几乎是相同的：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `process_password` function is not very different from the previous example
    as we can see its code as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_password` 函数与前面的例子并没有太大的不同，我们可以看到它的代码如下：'
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All in all, you may say that this is a pretty basic validation and something
    we have already covered, but I think it's a great example of working smart as
    opposed to working hard. Sure, we probably could have created one long pattern
    that would check everything together, but it would be less clear and less flexible.
    So, by breaking it into smaller and more manageable validations, we were able
    to make clear patterns, and at the same time, improve their usability with more
    helpful alert messages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，你可能会说这是一个非常基本的验证，而且我们已经涵盖过了，但我认为这是一个很好的例子，展示了工作聪明而不是努力。当然，我们可能可以创建一个长模式，一次性检查所有内容，但那样会更不清晰，也更不灵活。因此，通过将其分解为更小、更易管理的验证，我们能够创建清晰的模式，并同时通过更有帮助的警报消息来提高其可用性。
- en: Matching URLs
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配 URL
- en: 'Next, let''s create a field for the user''s website; the HTML for this field
    is:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为用户的网站创建一个字段；这个字段的 HTML 如下：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A URL can have many different protocols, but for this example, let's restrict
    it to only http or https links. Next, we have the domain name with an optional
    subdomain, and we need to end it with a suffix. The suffix itself can be a single
    word, such as .com or it can have multiple segments, such as.co.uk.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 URL 可以有许多不同的协议，但在这个例子中，让我们将其限制为只有 http 或 https 链接。接下来，我们有一个带有可选子域的域名，我们需要以后缀结束。后缀本身可以是一个单词，比如
    .com，也可以有多个段，比如 .co.uk。
- en: 'All in all, our pattern looks similar to this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们的模式看起来类似于这样：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are using multiple noncapture groups, both for when sections are optional
    and for when we want to repeat a segment. You may have also noticed that we are
    using the case insensitive flag (`/i`) at the end of the regular expression, as
    links can be written in lowercase or uppercase.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了多个非捕获组，用于可选的部分和重复一个段的情况。你可能还注意到，我们在正则表达式的末尾使用了不区分大小写的标志 (`/i`)，因为链接可以以小写或大写字母写入。
- en: 'Now, we''ll implement the actual function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现实际的函数：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, you should be pretty familiar with the process of adding fields
    to our form and adding a function to validate them. So, for our remaining examples
    let's shift our focus a bit from validating inputs to manipulating data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该对向我们的表单添加字段和添加函数来验证它们的过程非常熟悉了。因此，对于我们剩下的例子，让我们把重点从验证输入转移到操作数据上。
- en: Understanding the URL Regex
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 URL 的正则表达式
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用于匹配用户输入的名称的正则表达式：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a brief explanation of the Regex:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正则表达式的简要解释：
- en: '`^` asserts its position at start of a string'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 断言它的位置在字符串的开头'
- en: '`(?:https?:\/\/)?` is anon-capturing group'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:https?:\/\/)?` 是一个非捕获组'
- en: The `?` quantifier between zero and one time
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词表示出现零次或一次'
- en: '`http` matches the http characters literally (case-insensitive)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http` 字符串匹配 http 字符（不区分大小写）'
- en: '`s?` matches the `s` character literally (case-insensitive)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s?` 匹配 `s` 字符（不区分大小写）'
- en: The `?` quantifier between zero and one time
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词匹配零次或一次'
- en: '`:` matches the `:` character literally'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:` 字符与 `:` 匹配'
- en: '`\/` matches the `/` character literally'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\/` 字符与 `/` 匹配'
- en: '`\/` matches the `/` character literally'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\/` 字符与 `/` 匹配'
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w+` 匹配一个 [`a-zA-Z0-9_]` 单词字符'
- en: The `+` quantifier between one and unlimited times
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词匹配一次或多次'
- en: '`(?:\.\w+)?` is a non-capturing group'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:\.\w+)?` 是一个非捕获组'
- en: The `?` quantifier between zero and one time
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词匹配零次或一次'
- en: '`\.` matches the `.` character literally'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\.` 字符与 `.` 匹配'
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w+` 匹配一个 [`a-zA-Z0-9_]` 单词字符'
- en: The `+` quantifier between one and unlimited times
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词匹配一次或多次'
- en: '`(?:\.[A-Z]{2,3})+` is a non-capturing group'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:\.[A-Z]{2,3})+` 是一个非捕获组'
- en: The `+` quantifier between one and unlimited times
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词匹配一次或多次'
- en: '`\.` matches the `.` character literally'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\.` 字符与 `.` 匹配'
- en: '`[A-Z]{2,3}` matches a single character present in this list'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[A-Z]{2,3}` 匹配列表中的单个字符'
- en: The `{2,3}` quantifier between`2` and `3` times
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{2,3}` 量词匹配`2`到`3`次'
- en: '`A-Z` is a single character in the range between A and Z (case insensitive)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A-Z` 是在A和Z之间的单个字符（不区分大小写）'
- en: '`$` asserts its position at end of a string'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 断言它的位置在字符串的末尾'
- en: '`i` modifier: insensitive. Case insensitive letters, meaning it will match
    a-z and A-Z.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 修饰符：不区分大小写。不区分大小写的字母，意味着它将匹配a-z和A-Z。'
- en: Manipulating data
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数据
- en: We are going to add one more input to our form, which will be for the user's
    description. In the description, we will parse for things, such as e-mails, and
    then create both a plain text and HTML version of the user's description.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的表单中再添加一个输入，用于用户的描述。在描述中，我们将解析一些东西，比如电子邮件，然后创建用户描述的纯文本和HTML版本。
- en: 'The HTML for this form is pretty straightforward; we will be using a standard
    textbox and give it an appropriate field:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单的HTML非常简单；我们将使用一个标准的文本框，并给它一个适当的字段：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let''s start with the bare scaffold needed to begin processing the form
    data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从处理表单数据所需的基本结构开始：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code gets the text from the textbox on the page and then saves both a plain
    text version and an HTML version of it. At this stage, the HTML version is simply
    the plain text version wrapped between a pair of paragraph tags, but this is what
    we will be working on now. The first thing I want to do is split between paragraphs,
    in a text area the user may have different split-ups—lines and paragraphs. For
    our example, let's say the user just entered a single new line character, then
    we will add a `<br />` tag and if there is more than one character, we will create
    a new paragraph using the `<p>` tag.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从页面上的文本框中获取文本，然后保存它的纯文本版本和HTML版本。在这个阶段，HTML版本只是简单地将纯文本版本包裹在一对段落标签之间，但这是我们现在要处理的内容。我想要做的第一件事是在段落之间分割，在文本区域中，用户可能有不同的分割方式——行和段落。对于我们的例子，假设用户只输入了一个换行符，那么我们将添加一个
    `<br />` 标签，如果有多于一个字符，我们将使用 `<p>` 标签创建一个新的段落。
- en: Using the String.replace method
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用String.replace方法
- en: We are going to use JavaScript's replace method on the string object This function
    can accept a Regex pattern as its first parameter, and a function as its second;
    each time it finds the pattern it will call the function and anything returned
    by the function will be inserted in place of the matched text.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在字符串对象上使用JavaScript的replace方法。这个函数可以接受一个正则表达式模式作为它的第一个参数，以及一个函数作为它的第二个参数；每当它找到模式时，它将调用该函数，函数返回的任何东西都将被插入到匹配的文本的位置。
- en: 'So, for our example, we will be looking for new line characters, and in the
    function, we will decide if we want to replace the new line with a break line
    tag or an actual new paragraph, based on how many new line characters it was able
    to pick up:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于我们的例子，我们将寻找换行符，并在函数中决定是否要用换行标签替换换行，或者根据它能够捕获到多少个换行符来创建一个实际的新段落：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first thing you may notice is that we need to use the `g` flag in the pattern,
    so that it will look for all possible matches as opposed to only the first. Besides
    this, the rest is pretty straightforward. Consider this form:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的第一件事是，我们需要在模式中使用 `g` 标志，这样它将寻找所有可能的匹配，而不仅仅是第一个。除此之外，其余的都很简单。考虑这个表单：
- en: '![Using the String.replace method](img/2258OS_04_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![使用String.replace方法](img/2258OS_04_02.jpg)'
- en: 'If you take a look at the output from the console of the preceding code, you
    should get something similar to this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下前面代码的控制台输出，你应该会得到类似这样的东西：
- en: '![Using the String.replace method](img/2258OS_04_03.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用String.replace方法](img/2258OS_04_03.jpg)'
- en: Matching a description field
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配一个描述字段
- en: The next thing we need to do is try and extract e-mails from the text and automatically
    wrap them in a link tag. We have already covered a Regexp pattern to capture e-mails,
    but we will need to modify it slightly, as our previous pattern expects that an
    e-mail is the only thing present in the text. In this situation, we are interested
    in all the e-mails included in a large body of text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是尝试从文本中提取电子邮件，并自动将它们包装在链接标签中。我们已经介绍了一个正则表达式模式来捕获电子邮件，但我们需要稍微修改它，因为我们先前的模式期望电子邮件是文本中唯一存在的东西。在这种情况下，我们对包含在大段文本中的所有电子邮件感兴趣。
- en: If you were simply looking for a word, you would be able to use the `\b` matcher,
    which matches any boundary (that can be the end of a word/the end of a sentence),
    so instead of the dollar sign, which we used before to denote the end of a string,
    we would place the boundary character to denote the end of a word. However, in
    our case it isn't quite good enough, as there are boundary characters that are
    valid e-mail characters, for example, the period character is valid. To get around
    this, we can use the boundary character in conjunction with a lookahead group
    and say we want it to end with a word boundary, but only if it is followed by
    a space or end of a sentence/string. This will ensure we aren't cutting off a
    subdomain or a part of a domain, if there is some invalid information mid-way
    through the address.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是在寻找一个单词，您可以使用 `\b` 匹配器，它匹配任何边界（可以是单词的结尾/句子的结尾），所以我们不再使用之前用来表示字符串结尾的美元符号，而是将边界字符放在那里，以表示单词的结尾。然而，在我们的情况下，这还不够好，因为有一些边界字符是有效的电子邮件字符，例如句号字符是有效的。为了解决这个问题，我们可以将边界字符与一个先行断言组合使用，并且说我们希望它以一个单词边界结束，但只有在后面跟着一个空格或句子/字符串的结尾时才会结束。这将确保我们不会截断子域或域的一部分，如果地址中间有一些无效的信息。
- en: Now, we aren't creating something that will try and parse e-mails no matter
    how they are entered; the point of creating validators and patterns is to force
    the user to enter something logical. That said, we assume that if the user wrote
    an e-mail address and then a period, that he/she didn't enter an invalid address,
    rather, he/she entered an address and then ended a sentence (the period is not
    part of the address).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再创建一个会尝试解析电子邮件的东西，无论用户如何输入；创建验证器和模式的目的是强制用户输入一些逻辑的内容。也就是说，我们假设如果用户写了一个电子邮件地址，然后是一个句号，那么他/她并没有输入一个无效的地址，而是输入了一个地址，然后结束了一个句子（句号不是地址的一部分）。
- en: In our code, we assume that to the end an address, the user is either going
    to have a space after, such as some kind of punctuation, or that he/she is ending
    the string`/`line. We no longer have to deal with lines because we converted them
    to HTML, but we do have to worry that our pattern doesn't pick up an HTML tag
    in the process.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们假设在地址的末尾，用户要么会在后面加上一个空格，比如某种标点符号，要么会结束字符串/行。我们不再需要处理行，因为我们已经将它们转换为
    HTML，但我们确实需要担心我们的模式在过程中不会捕获到 HTML 标签。
- en: 'At the end of this, our pattern will look similar to this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，我们的模式将类似于这样：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We start off with a word boundary, then, we look for the pattern we had before.
    I added both the (`>`) greater-than and the (`<`) less-than characters to the
    group of disallowed characters, so that it will not pick up any HTML tags. At
    the end of the pattern, you can see that we want to end on a word boundary, but
    only if it is followed by a space, an HTML tag, or the end of a string. The complete
    function, which does all the matching, is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个单词边界开始，然后寻找之前的模式。我将大于号 (`>`) 和小于号 (`<`) 字符都添加到不允许的字符组中，这样就不会捕获任何 HTML 标签。在模式的末尾，您可以看到我们希望在单词边界结束，但只有在后面跟着一个空格、一个
    HTML 标签或字符串的结尾时才会结束。完成所有匹配的完整函数如下：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can continue to add fields, but I think the point has been understood. You
    have a pattern that matches what you want, and with the extracted data, you are
    able to extract and manipulate the data into any format you may need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续添加字段，但我认为重点已经被理解了。您有一个匹配您想要的模式，并且使用提取的数据，您能够提取和操作数据以满足您可能需要的任何格式。
- en: Understanding the description Regex
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解描述正则表达式
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到用于匹配用户输入的名称的正则表达式：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a brief explanation of the Regex:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正则表达式的简要解释：
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b` 断言其位置在 (`^\w|\w$|\W\w|\w\W`) 单词边界处'
- en: '`[^\s<>@]+` matches a single character not present in the list:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s<>@]+` 匹配不在列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词，出现一次或无限次'
- en: '`\s` matches a [`\r\n\t\f` ] whitespace character'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配一个 [`\r\n\t\f` ] 空白字符'
- en: '`<>@` is a single character in the `<>@` list (case-sensitive)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<>@` 是 `<>@` 列表中的一个字符（区分大小写）'
- en: '`@` matches the `@` character literally'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 字符串匹配字符 `@`'
- en: '`[^\s<>@.]+` matches a single character not present in this list:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s<>@.]+` 匹配不在此列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词，出现一次或无限次'
- en: '`\s` matches any [`\r\n\t\f`] whitespace character'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何 [`\r\n\t\f`] 空白字符'
- en: '`<>@.` is a single character in the `<>@.` list literally (case sensitive)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<>@.` 是 `<>@.` 列表中的一个字符（区分大小写）'
- en: '`\.` matches the `.` character literally'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\.` 字符串匹配字符 `.` '
- en: '`[^\s<>@]+` matches a single character not present in this the list:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^\s<>@]+` 匹配不在此列表中的单个字符：'
- en: The `+` quantifier between one and unlimited times
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 量词，出现一次或无限次'
- en: '`\s` matches a [`\r\n\t\f` ] whitespace character'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配一个 [`\r\n\t\f` ] 空白字符'
- en: '`<>@` isa single character in the `<>@` list literally (case sensitive)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<>@` 是 `<>@` 列表中的一个字符（区分大小写）'
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b` 断言其位置在 (`^\w|\w$|\W\w|\w\W`) 单词边界处'
- en: '`(?=.?(?:\s|<|$))` Positive lookahead - Assert that the Regex below can be
    matched'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?=.?(?:\s|<|$))` 正向先行断言 - 断言正则表达式可以匹配下面的内容'
- en: '`.?` matches any character (except new line)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.?` 匹配任何字符（除了换行符）'
- en: The `?` quantifier between zero and one time
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 量词，出现零次或一次'
- en: '`(?:\s|<|$)` is a non-capturing group:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(?:\s|<|$)` 是一个非捕获组：'
- en: 'First alternative: `\s` matches any white space character [`\r\n\t\f`]'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种选择：`\s` 匹配任何空白字符 [`\r\n\t\f`]
- en: 'Second alternative: `<` matches the character `<` literally'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择：`<` 字符串匹配字符 `<`
- en: 'Third alternative: `$` assert position at end of the string'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种选择：`$` 断言字符串的结束位置
- en: 'The `g` modifier: global match. Returns all matches of the regular expression,
    not only the first one'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g` 修饰符：全局匹配。返回正则表达式的所有匹配项，而不仅仅是第一个'
- en: Explaining a Markdown example
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释一个 Markdown 示例
- en: 'More examples of regular expressions can be seen with the popular **Markdown**
    syntax (refer to [http://en.wikipedia.org/wiki/Markdown](http://en.wikipedia.org/wiki/Markdown)).
    This is a situation where a user is forced to write things in a custom format,
    although it''s still a format, which saves typing and is easier to understand.
    For example, to create a link in Markdown, you would type something similar to
    this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 更多正则表达式的示例可以在流行的**Markdown**语法中看到（参考[http://en.wikipedia.org/wiki/Markdown](http://en.wikipedia.org/wiki/Markdown)）。这是一个用户被迫以自定义格式编写东西的情况，尽管它仍然是一个格式，可以节省输入并且更容易理解。例如，在Markdown中创建一个链接，你会输入类似于这样的内容：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This would then be converted to:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会转换为：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Disregarding any validation on the URL itself, this can easily be achieved
    using this pattern:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略URL本身的任何验证，可以很容易地通过以下模式实现：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks a little complex, because both the square brackets and parenthesis
    are both special characters that need to be escaped. Basically, what we are saying
    is that we want an open square bracket, anything up to the closing square bracket,
    then we want an open parenthesis, and again, anything until the closing parenthesis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来有点复杂，因为方括号和括号都是需要转义的特殊字符。基本上，我们想要一个开放的方括号，直到闭合的方括号，然后我们想要一个开放的括号，再次，直到闭合的括号。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A good website to write markdown documents is [http://dillinger.io/](http://dillinger.io/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的网站来写markdown文档是[http://dillinger.io/](http://dillinger.io/)。
- en: 'Since we wrapped each section into its own capture group, we can write this
    function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将每个部分都包装到自己的捕获组中，我们可以编写这个函数：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We haven't been using capture groups in our manipulation examples, but if you
    use them, then the first parameter to the callback is the entire match (similar
    to the ones we have been working with) and then all the individual groups are
    passed as subsequent parameters, in the order that they appear in the pattern.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的操作示例中，我们没有使用捕获组，但如果使用它们，那么回调的第一个参数将是整个匹配（类似于我们一直在使用的那些），然后所有单独的组将作为后续参数传递，按照它们在模式中出现的顺序。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a couple of examples that showed us how to both
    validate user inputs as well as manipulate them. We also took a look at some common
    design patterns and saw how it's sometimes better to simplify the problem instead
    of using brute force in one pattern for the purpose of creating validations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一些示例，向我们展示了如何验证用户输入以及如何操作它们。我们还看了一些常见的设计模式，并且看到有时候简化问题而不是在一个模式中使用蛮力来创建验证更好。
- en: In the next chapter, we will continue exploring some real-world problems by
    developing an application with **Node.js**, which can be used to read a file and
    extract its information, displaying it in a more user friendly manner.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过使用**Node.js**开发一个应用程序来探索一些真实世界的问题，该应用程序可以用于读取文件并提取其信息，以更加用户友好的方式显示出来。
