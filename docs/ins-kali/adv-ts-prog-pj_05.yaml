- en: Angular ToDo App with GraphQL and Apollo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有GraphQL和Apollo的Angular ToDo应用程序
- en: There are many different ways to communicate data backward and forward from
    the client to the server. In this chapter, we are going to look at how we can
    use GraphQL to pick data from a server, and then send and mutate data back from
    an Angular client. We will also look at how we can leverage calculated values
    from GraphQL. Building on the content of the previous chapter, we will once again
    be using Angular Material for our user interface to see how we can work with Angular
    routing to serve up different content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端到服务器之间有许多不同的通信数据的方式。在本章中，我们将看看如何使用GraphQL从服务器中提取数据，然后从Angular客户端发送和改变数据。我们还将看看如何利用GraphQL中的计算值。在上一章的内容基础上，我们将再次使用Angular
    Material作为用户界面，以了解如何使用Angular路由来提供不同的内容。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the GraphQL-to-REST relationship
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GraphQL与REST的关系
- en: Creating a reusable database class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的数据库类
- en: Prefilling data and using singletons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据预填和使用单例
- en: Creating a GraphQL schema
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GraphQL模式
- en: Setting up GraphQL types using `type-graphql`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type-graphql`设置GraphQL类型
- en: Creating a GraphQL resolver with queries and mutations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询和变更创建GraphQL解析器
- en: Using Apollo Server as our application server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Apollo Server用作我们的应用程序服务器
- en: Creating a GraphQL Angular client application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GraphQL Angular客户端应用程序
- en: Adding Apollo support to the client
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户端添加Apollo支持
- en: Using routing in Angular
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用路由
- en: Controlling input with Angular validation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular验证控制输入
- en: Sending GraphQL mutations from the client to the server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送GraphQL变更
- en: Sending GraphQL queries from the client to the server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端向服务器发送GraphQL查询
- en: Switching between read-only and editable templates
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在只读和可编辑模板之间切换
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter05)下载。
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下载项目后，您将需要使用`npm install`命令安装软件包要求。
- en: Understanding the GraphQL-to-REST relationship
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GraphQL与REST的关系
- en: 'One of the great things about web-based technologies is the number of ways
    you can solve common problems that crop up. With REST, we used a simple, but powerful,
    way to communicate from the client to the server; however, that''s not the only
    way that we can do this. REST solved a set of problems, but also introduced new
    problems that newer techniques have come to the fore to fix. The three problems
    that need to be solved are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络技术的一大优点是解决常见问题的多种方式。在REST中，我们使用了一种简单但强大的方式从客户端到服务器进行通信；然而，这并不是我们可以做到的唯一方式。REST解决了一系列问题，但也引入了新问题，新技术已经出现来解决这些问题。需要解决的三个问题如下：
- en: In order to build up complex information, we may end up having to make multiple
    REST calls to the REST server. For a shopping application, for instance, we may
    use one REST call to pick up a person's name and another REST call to pick up
    their address, with a third call being needed to get their shopping basket details.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了构建复杂的信息，我们可能需要对REST服务器进行多次调用。例如，对于购物应用程序，我们可能使用一个REST调用来获取一个人的姓名，另一个REST调用来获取他们的地址，还需要第三个调用来获取他们的购物篮详情。
- en: Over time, we may go through multiple versions of our REST API. Having our clients
    keep track of the versioning can be restrictive, which means that, right at the
    start of our API, we also have to define what our versioning experience is going
    to be like. Unless our APIs follow the same versioning standards, this can lead
    to confusing code.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们可能会经历多个版本的REST API。让我们的客户端跟踪版本可能会有限制，这意味着在API的最开始，我们还必须定义我们的版本体验将会是什么样子。除非我们的API遵循相同的版本标准，否则这可能会导致混乱的代码。
- en: These REST calls could end up bringing far more information than we actually
    need. So, while we are making these detailed calls, we only actually need three
    or four items of information out of maybe 20 or 30 fields.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些REST调用最终可能会带来比我们实际需要的信息更多。因此，当我们进行这些详细的调用时，我们实际上只需要20或30个字段中的三四个信息。
- en: One of the things to understand about REST is that it isn't actually a technology.
    A good way to think about REST is that it's more of an agreed architectural standard
    that can use pretty much any transport mechanism as a means of communication.
    Okay, to clarify, while I said it was a standard, in practical terms, very few
    people actually follow the original concept of REST, which means that we also
    need to understand the intent of the developers. For instance, when we issue an
    update over REST, are we using the `PUT HTTP` verb or the `POST` verb? Knowing
    this level of detail is vital if we want to consume a third-party API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST的一件事是要理解它实际上并不是一种技术。理解REST的一个好方法是，它更像是一个约定的架构标准，可以使用几乎任何传输机制作为通信手段。好吧，澄清一下，虽然我说它是一个标准，但实际上很少有人真正遵循REST的原始概念，这意味着我们也需要理解开发人员的意图。例如，当我们通过REST发出更新时，我们是使用`PUT
    HTTP`动词还是`POST`动词？如果我们想要使用第三方API，了解这个细节是至关重要的。
- en: Originally developed by Facebook, but now maintained by the GraphQL foundation
    ([https://foundation.graphql.org/](https://foundation.graphql.org/)), GraphQL
    is a great mechanism to use to address issues like these. Unlike pure REST, GraphQL
    is simply a query language with tooling support. GraphQL revolves around the idea
    that our code will interact with fields, and as long as there is a definition
    of how to get these fields, we can write arbitrarily complex queries to retrieve
    data from multiple locations in one hit, or mutate the data to update it. A properly
    designed GraphQL system takes care of versioning requirements as well as fields,
    which can be added and deprecated on demand.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL最初由Facebook开发，但现在由GraphQL基金会维护（[https://foundation.graphql.org/](https://foundation.graphql.org/)），GraphQL是解决这些问题的好机制。与纯REST不同，GraphQL只是一个带有工具支持的查询语言。GraphQL围绕着我们的代码与字段交互的想法，只要有获取这些字段的定义，我们就可以编写任意复杂的查询，以一次获取多个位置的数据，或者对数据进行变异以更新它。一个设计良好的GraphQL系统可以处理版本需求以及可以根据需要添加和弃用的字段。
- en: With GraphQL, we can only retrieve the information that we need with a query.
    This saves us from oversubscribing for information at the client level. Similarly,
    our query can patch the result together from multiple locations for us so that
    we don't have to perform multiple round trips. We send our query from our client
    and let our GraphQL server retrieve the relevant data items. We also don't have
    to worry about REST endpoints in our client code. We simply communicate with our
    GraphQL server, letting the query take care of the data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GraphQL，我们只能通过查询检索我们需要的信息。这样可以避免我们在客户端级别过度订阅信息。同样，我们的查询可以为我们从多个位置拼接结果，这样我们就不必执行多次往返。我们从客户端发送查询，让我们的GraphQL服务器检索相关的数据项。我们也不必担心客户端代码中的REST端点。我们只需与我们的GraphQL服务器通信，让查询处理数据。
- en: In this chapter, we are going to look at how we can use the Apollo GraphQL engine
    ([https://www.apollographql.com/](https://www.apollographql.com/)) and the incredibly
    useful `TypeGraphQL` library ([https://typegraphql.ml/](https://typegraphql.ml/)),
    which provides a convenient way to target GraphQL from TypeScript. With Apollo,
    we have a complete front-to-back infrastructure to completely manage our GraphQL
    behaviors. As well as providing client-side libraries, we can use Apollo on our
    servers, as well as for iOS and Android applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何使用Apollo GraphQL引擎（[https://www.apollographql.com/](https://www.apollographql.com/)）和非常有用的`TypeGraphQL`库（[https://typegraphql.ml/](https://typegraphql.ml/)），它提供了一种方便的方式来从TypeScript中针对GraphQL。使用Apollo，我们有一个完整的前后端基础设施来完全管理我们的GraphQL行为。除了提供客户端库外，我们还可以在服务器上使用Apollo，以及用于iOS和Android应用程序。
- en: Note that GraphQL is not intended to completely replace RESTful services. There
    are many cases where we would want REST and GraphQL to work together, side by
    side. It could be that we have a REST service that communicates with our GraphQL
    implementation and caches information for us, for example. For the purposes of
    this chapter, however, we are going to be concentrating purely on creating a GraphQL
    implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GraphQL并不打算完全取代RESTful服务。有许多情况下，我们希望REST和GraphQL并存。例如，我们可能有一个与我们的GraphQL实现通信并为我们缓存信息的REST服务。但是，在本章中，我们将专注于纯粹创建GraphQL实现。
- en: Project overview
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, our project is going to introduce us to writing GraphQL applications,
    both on the server side and the client side. We are also going to start investigating
    features that were introduced in TypeScript 3 to create a ToDo application. We
    will be expanding on the Angular concepts from the previous chapter to introduce
    client-side routing, which will allow us to show different content and effectively
    navigate between pages. We will also introduce Angular validation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的项目将向我们介绍如何编写GraphQL应用程序，包括服务器端和客户端。我们还将开始研究TypeScript 3中引入的功能，以创建一个ToDo应用程序。我们将扩展上一章的Angular概念，引入客户端路由，这将允许我们显示不同的内容并有效地在页面之间导航。我们还将介绍Angular验证。
- en: Working alongside the GitHub code, the task in this chapter should take about
    four hours to complete.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与GitHub代码一起工作，本章的任务应该需要大约四个小时才能完成。
- en: 'When completed, the application should look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，应用程序应如下所示：
- en: '![](assets/afdfcce2-295e-4a37-9db3-bd1916ce19a9.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/afdfcce2-295e-4a37-9db3-bd1916ce19a9.png)'
- en: Getting started with the project
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: 'Just like in the previous chapter, this chapter will use Node.js (available
    from [https://nodejs.org](https://nodejs.org)). We will also be using the following
    components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章一样，本章将使用Node.js（可从[https://nodejs.org](https://nodejs.org)获取）。我们还将使用以下组件：
- en: The Angular CLI (I'm using version 7.2.2)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CLI（我使用的版本是7.2.2）
- en: '`express` (version 4.16.4 or greater)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express`（版本4.16.4或更高）'
- en: '`mongoose` (version 5.4.8 or greater)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoose`（版本5.4.8或更高）'
- en: '`@types/cors` (version 2.8.4 or greater)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/cors`（版本2.8.4或更高）'
- en: '`@types/body-parser` (version 1.17.0 or greater)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/body-parser`（版本1.17.0或更高）'
- en: '`@types/express` (version 4.16.0 or greater)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/express`（版本4.16.0或更高）'
- en: '`@types/mongodb` (version 3.1.19 or greater)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/mongodb`（版本3.1.19或更高）'
- en: '`@types/mongoose` (version 5.3.11 or greater)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/mongoose`（版本5.3.11或更高）'
- en: '`type-graphql` (version 0.16.0 or greater)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type-graphql`（版本0.16.0或更高）'
- en: '`@types/graphql` (version 14.0.7 or greater)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/graphql`（版本14.0.7或更高）'
- en: '`apollo-server` (version 2.4.0 or greater)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-server`（版本2.4.0或更高）'
- en: '`apollo-server-express` (version 2.4.0 or greater)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-server-express`（版本2.4.0或更高）'
- en: '`guid-typescript` (version 1.0.9 or greater)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guid-typescript`（版本1.0.9或更高）'
- en: '`reflect-metadata` (version 0.1.13 or greater)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect-metadata`（版本0.1.13或更高）'
- en: '`graphql` (version 14.1.1 or greater)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql`（版本14.1.1或更高）'
- en: '`apollo-angular` (version 1.5.0 or greater)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-angular`（版本1.5.0或更高）'
- en: '`apollo-angular-link-http` (version 1.5.0 or greater)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-angular-link-http`（版本1.5.0或更高）'
- en: '`apollo-cache-inmemory` (version 1.4.3 or greater)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-cache-inmemory`（版本1.4.3或更高）'
- en: '`apollo-client` (version 2.4.13 or greater)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apollo-client`（版本2.4.13或更高）'
- en: '`graphql` (version 14.1.1 or greater)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql`（版本14.1.1或更高）'
- en: '`graphql-tag` (version 2.10.1 or greater)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-tag`（版本2.10.1或更高版本）'
- en: As well as using MongoDB, we will be using Apollo to serve up our GraphQL data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用MongoDB，我们还将使用Apollo来提供GraphQL数据。
- en: Creating a ToDo application with GraphQL and Angular
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraphQL和Angular创建ToDo应用程序
- en: 'As is our custom now, we are going to start off by defining the requirements:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 像现在一样，我们将从定义需求开始：
- en: A user must be able to add a ToDo task consisting of a title, a description,
    and the date the task is due
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够添加由标题、描述和任务到期日期组成的ToDo任务
- en: Validation will ensure that these items are always set and that the due date
    cannot be before today
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证将确保这些项目始终设置，并且到期日期不能早于今天
- en: The user will be able to see a list of all tasks
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够查看所有任务的列表
- en: The user will be able to delete a task
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够删除任务
- en: The user will be able to see overdue tasks (where an overdue task is one that
    has not been completed and the due date has passed)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够查看过期任务（过期任务是指尚未完成且到期日期已过的任务）
- en: The user will be able to edit a task
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够编辑任务
- en: Data is transferred to the server, or from the server, using GraphQL
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraphQL传输数据到服务器，或从服务器传输数据
- en: Transferred data will be saved to a MongoDB database
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输的数据将保存到MongoDB数据库中
- en: Creating our application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: For our ToDo application, we are going to start off with the server implementation.
    As in the previous chapter, we are going to create a separate client and server
    folder structure, with the Node.js code being added to the server code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的ToDo应用程序，我们将从服务器实现开始。与上一章一样，我们将创建一个单独的客户端和服务器文件夹结构，将Node.js代码添加到服务器代码中。
- en: 'We''re going to start our journey into creating a GraphQL server with the database
    code. All the data for our client is going to come from the database, so it makes
    sense for us to put everything we need in place. As in the previous chapter, we
    are going to install the `mongoose` packages that we need to work with MongoDB:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建一个GraphQL服务器与数据库代码的旅程。我们客户端的所有数据都将来自数据库，因此我们需要将我们需要的一切放在适当的位置。与上一章一样，我们将安装我们需要与MongoDB一起工作的`mongoose`软件包：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Something to bear in mind when choosing which command to use to install packages
    relates to the use of `--save` versus `--save-dev`. These are both used to install
    packages, but there is a practical difference between them and how we would expect
    the application to be deployed based on them. When we use `--save`, we are stating
    that this package must be downloaded for the application to run, even if we install
    the application on another computer. This can be wasteful if we intend to deploy
    our application to a machine that already has the correct version of the package
    installed globally. The alternative case is to use `--save-dev` to download and
    install the package as something called a development dependency. In other words,
    the package is installed locally for the developer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择安装软件包的命令时要记住的一点是与`--save`与`--save-dev`的使用有关。这两者都用于安装软件包，但它们之间有一个实际的区别，以及我们根据它们期望应用程序部署的方式。当我们使用`--save`时，我们声明这个软件包必须下载才能使应用程序运行，即使我们在另一台计算机上安装应用程序。如果我们打算将应用程序部署到已经全局安装了正确版本软件包的计算机上，这可能是浪费的。另一种情况是使用`--save-dev`将软件包下载并安装为所谓的开发依赖。换句话说，该软件包是为开发人员本地安装的。
- en: With this in place, we are going to start writing a variation of the `Mongo`
    class we introduced in the previous chapter. The reason that we aren't going to
    reuse that implementation is because we are going to start introducing TypeScript
    3-specific features before we move on to adding a generic database framework.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基础，我们将开始编写我们在上一章中介绍的`Mongo`类的变体。我们不会重用该实现的原因是因为我们将开始引入特定于TypeScript 3的功能，然后再添加通用数据库框架。
- en: 'The big change to our class is that we are going to change the signature to
    our `mongoose.connect` method. One of the changes tells Mongoose to use a new
    format URL parser, but the other change ties into the signature of the event that
    we use as a callback:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的重大变化是，我们将改变`mongoose.connect`方法的签名。其中一个变化告诉Mongoose使用新格式的URL解析器，但另一个变化与我们用作回调的事件的签名相关联：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the previous chapter, we should remember that our callback had a signature
    of `e:any`. Now, we are changing it to use `e:unknown` instead. This is a new
    type—introduced to TypeScript 3—that allows us to add an extra level of type safety.
    To a large extent, we can think of the `unknown` type as being similar to `any`
    in that we can assign any type to it. What we can't do, however, is assign it
    to another type without a type assertion. We are going to start moving `any` types
    to `unknown` throughout our code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们应该记住我们的回调的签名是`e:any`。现在，我们将其更改为使用`e:unknown`。这是一种新类型——在TypeScript 3中引入的——它允许我们添加额外的类型安全性。在很大程度上，我们可以将`unknown`类型视为类似于`any`，因为我们可以将任何类型分配给它。但是，我们不能在没有类型断言的情况下将其分配给另一种类型。我们将开始在整个代码中将`any`类型移动到`unknown`。
- en: 'So far, we have been using a lot of interfaces to provide the shapes of types.
    We can apply the same technique to Mongo schemas as well so that we can describe
    the shape of our ToDo schema as a standard TypeScript interface, and then map
    it to a schema. Our interface is going to be straightforward:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用许多接口来提供类型的形状。我们也可以将相同的技术应用于Mongo模式，以便我们可以描述我们的ToDo模式的形状作为标准的TypeScript接口，然后将其映射到模式。我们的接口将是直接的：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are going to create a `mongoose` schema that will be mapped into the database.
    A schema simply states what information will be stored using types that MongoDB
    expects. For instance, our `ITodoSchema` exposes `Id` as `string`, but this is
    not the type that MongoDB would expect; instead, it expects to see `String`. Knowing
    this, it''s simple enough to create a mapping from `ITodoSchema` to `TodoSchema`, as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`mongoose`模式，它将映射到数据库中。一个模式简单地说明了将使用MongoDB期望的类型存储的信息。例如，我们的`ITodoSchema`将`Id`公开为`string`，但这不是MongoDB期望的类型；相反，它期望看到`String`。知道这一点，从`ITodoSchema`到`TodoSchema`的映射就很简单了，如下所示：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have a schema model that we can use to query, update, and more. Of course,
    Mongo doesn't limit us to just one schema. If we wanted to use more, there would
    be nothing stopping us from doing so.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以用来查询、更新等的模式模型。当然，Mongo并不限制我们只使用一个模式。如果我们想使用更多，没有什么能阻止我们这样做。
- en: A note about what our schema is going to contain—the `Title` and `Description`
    fields are fairly straightforward in that they contain details about what our
    todo item is about. `DueDate` simply tells us when our item is due and `CreationDate`
    tells us when we created this record. We have a `Completed` flag that the user
    will trigger to say when they have completed the task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的模式将包含什么的说明——`Title`和`Description`字段相当直接，它们包含了有关我们待办事项的详细信息。`DueDate`简单地告诉我们项目何时到期，`CreationDate`告诉我们我们创建这条记录的时间。我们有一个`Completed`标志，用户将触发它来表示他们何时完成了任务。
- en: The interesting field is the `Id` field. This field differs from the Mongo `Id`
    field, which will still be internally generated. The schema `Id` field is assigned
    something called a **Globally Unique IDentifier** (**GUID**), which is a unique
    string identifier. The reason that we want the UI to add this field is because
    we are going to use it as a known field in our database queries, and we want the
    client to know the value of the `Id` before it needs to perform any round trips.
    When we cover the Angular side, we will see how this field gets populated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的字段是`Id`字段。这个字段不同于Mongo的`Id`字段，后者仍然是内部生成的。模式`Id`字段被分配了一个叫做**全局唯一标识符**（**GUID**）的东西，它是一个唯一的字符串标识符。我们希望UI添加这个字段的原因是因为我们将在数据库查询中使用它作为一个已知的字段，并且我们希望客户端在执行任何往返之前知道`Id`的值。当我们涉及Angular方面时，我们将看到这个字段是如何被填充的。
- en: 'We need to create a database model that maps the `mongoose.Document` instance
    of our `ITodoSchema` to our `TodoSchema`. This is a straightforward task when
    using `mongoose.model`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个数据库模型，将我们的`ITodoSchema`的`mongoose.Document`实例映射到我们的`TodoSchema`。当使用`mongoose.model`时，这是一项直接的任务：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Case is very important when we create our `mongoose.model`. As well as `mongoose.model`,
    we also have `mongoose.Model` available, which we would have to instantiate with
    a `new` statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的`mongoose.model`时，大小写非常重要。除了`mongoose.model`，我们还有`mongoose.Model`可用，我们需要用`new`语句来实例化。
- en: We are now in a position to write a relatively generic database class. We do,
    however, have a constraint—we are expecting our schema to have an `Id` field.
    This constraint is purely a convenience to let us concentrate on the logic for
    our demonstration application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个相对通用的数据库类。然而，我们有一个约束——我们期望我们的模式有一个`Id`字段。这个约束纯粹是为了让我们专注于我们演示应用程序的逻辑。
- en: 'The first thing we are going to do is create a generic base class that accepts `mongoose.Document`
    as the type. It will probably not come as a surprise to realize that the type
    we will ultimately use against this is `ITodoSchema`. The constructor is going
    to accept a model that we can use for our various database operations. Again,
    we have already created the model that we are going to use as `TodoModel`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个接受`mongoose.Document`作为类型的通用基类。毫无疑问，我们最终将针对这个类型使用的是`ITodoSchema`。构造函数将接受一个我们可以用于各种数据库操作的模型。同样，我们已经创建了我们将用作`TodoModel`的模型：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our concrete implementation of this class is very straightforward:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个类的具体实现非常简单：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now going to start adding features to `DataAccessBase`. We will start
    off with a method to get all the records that match our schema. We should be happy
    enough with promises at this stage, so it should be natural for us to return a
    `Promise` type. In this case, the `Promise` type will be an array of `T`, which
    we know maps onto `ITodoSchema`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要开始向`DataAccessBase`添加功能。我们将从一个获取与我们的模式匹配的所有记录的方法开始。在这个阶段，我们应该对promises感到满意，所以我们应该自然地返回一个`Promise`类型。在这种情况下，`Promise`类型将是一个`T`数组，我们知道它映射到`ITodoSchema`。
- en: 'Internally, we call the `find` method on our model to retrieve all records
    and once the find completes, we call back the result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们调用我们的模型的`find`方法来检索所有记录，一旦查找完成，我们回调结果：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Adding a record is just as simple. The only real differences are that we call
    the `model.create` method and return a `boolean` value to indicate that we succeeded:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加记录同样简单。唯一的真正区别是我们调用`model.create`方法并返回一个`boolean`值来指示我们成功了：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As well as retrieving all records, we could choose to retrieve a single one.
    The big change between this and the `GetAll` method is that the `find` method
    is using search criteria:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检索所有记录，我们还可以选择检索单个记录。这与`GetAll`方法之间的主要区别在于`find`方法使用了搜索条件：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we have the ability to remove or update records. These are very similar
    in the way we write them:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了删除或更新记录的能力。它们在写法上非常相似：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the actual database code in place, we can now turn our attention to accessing
    the database. Something that we are going to consider is that we may end up having
    a significant number of todo items building up over time and, if we attempt to
    read them from the database every time we need them, we are going to slow the
    system down as we add more and more todos. To this end, we are going to create
    a basic caching mechanism that will be populated as soon as the database finishes
    loading during the server startup process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有了实际的数据库代码，我们现在可以转向访问数据库。我们要考虑的一件事是，随着时间的推移，我们可能会有大量的待办事项积累起来，如果我们每次需要时都尝试从数据库中读取它们，随着我们添加更多的待办事项，系统会变得越来越慢。为此，我们将创建一个基本的缓存机制，在服务器启动过程中数据库加载完成后立即填充。
- en: Since the cache is going to be pre-populated, we want to use the same instance
    of our class from GraphQL and from our server, so we are going to create something
    called a **singleton**. A singleton is just another way of saying that we will
    have only one instance of a class present in memory and each class will use the
    same instance. To prevent other classes from being able to create their own instances,
    we will make use of a couple of tricks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存将被预先填充，我们希望在GraphQL和服务器中使用我们类的相同实例，因此我们将创建一个称为**单例**的东西。单例只是另一种说法，即我们在内存中只有一个类的实例，并且每个类将使用相同的实例。为了防止其他类能够创建自己的实例，我们将利用一些技巧。
- en: 'The first thing we are going to do is create our class with a private constructor.
    A private constructor means that the only place we can instantiate our class from
    is inside the class itself:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个带有私有构造函数的类。私有构造函数意味着我们只能在类内部实例化我们的类：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It might seem counter-intuitive that we can only create the class from itself.
    After all, if we cannot instantiate the class, how can we access any members?
    The trick to this is to add a field to hold a reference to the class instance,
    and then offer a public static property to access that instance. The public property
    will take care to instantiate the class if it''s not already available, so we
    will always be able to access an instance of the class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些反直觉，我们只能从类本身创建类。毕竟，如果我们不能实例化类，我们怎么访问任何成员呢？这个技巧是添加一个字段来保存对类实例的引用，然后提供一个公共静态属性来访问该实例。公共属性将负责实例化类，如果它尚不可用，我们将始终能够访问类的实例：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now have a way to access the methods we are going to write, so let''s start
    off by creating a method to populate a list of the available items. Since this
    could be a long-running operation, we are going to make it asynchronous:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了访问我们将要编写的方法的方法，让我们开始创建一个方法来填充可用项目的列表。由于这可能是一个长时间运行的操作，我们将使其异步：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method works by calling `GetAll` to retrieve all the records from our MongoDB
    database. Once we have the records, we are going to iterate over them and create
    copies of them to push into our array.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过调用`GetAll`来从我们的MongoDB数据库中检索所有记录。一旦我们有了记录，我们将遍历它们并创建它们的副本推入我们的数组。
- en: The `TodoItem` class is a special class that we are going to use to map types
    to GraphQL. We will look at this class shortly when we start writing our GraphQL
    server functionality.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItem`类是一个特殊的类，我们将使用它来将类型映射到GraphQL。当我们开始编写我们的GraphQL服务器功能时，我们将很快看到这个类。'
- en: 'It''s all very well populating the array of items, but if there is no way to
    access the items elsewhere in the code, this class would not be much help. Fortunately,
    accessing the elements is as simple as adding an `Items` property:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 填充项目数组很好，但如果没有办法在代码的其他地方访问这些项目，这个类将没有太大帮助。幸运的是，访问这些元素就像添加一个`Items`属性一样简单：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating our GraphQL schema
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的GraphQL模式
- en: 'With our database code in place, we are now ready to turn our attention to
    writing our GraphQL server. One of the earliest decisions I took when writing
    the sample code for this chapter was that we would simplify the process of writing
    our code as much as possible. If we look at a reference sample that Facebook posted,
    we will find that the code can be tediously long-winded:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的数据库代码，我们现在准备转向编写我们的GraphQL服务器。在编写本章示例代码时，我最早做出的决定之一是尽可能简化编写代码的过程。如果我们查看Facebook发布的参考示例，我们会发现代码可能会非常冗长：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example is from [https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js).
    We can see that we have a lot of reliance on special types that don't map one
    to one onto TypeScript types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子来自[https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)。我们可以看到我们对特殊类型有很多依赖，这些类型不能一对一地映射到TypeScript类型。
- en: 'Since we want to make our code that bit more TypeScript-friendly, we are going
    to use `type-graphql`. We will install it via `npm`, along with the `graphql`
    type definitions and `reflect-metadata`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望使我们的代码更符合TypeScript的要求，我们将使用`type-graphql`。我们将通过`npm`安装它，以及`graphql`类型定义和`reflect-metadata`：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this stage, we should also set our `tsconfig` file up to look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们还应该设置我们的`tsconfig`文件如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main thing worth mentioning in this `tsconfig` file relates to the fact
    that `type-graphql` uses features that are only found in ES7, so we need to use
    ES2016 in the lib (ES7 maps onto ES2016).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`tsconfig`文件中值得一提的主要是`type-graphql`使用的功能只能在ES7中找到，所以我们需要在lib（ES7映射到ES2016）中使用ES2016。
- en: Setting up our GraphQL types
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的GraphQL类型
- en: As we just saw, GraphQL types can be a little bit complicated to set up. With
    the aid of `type-graphql` and some handy decorators, we are going to create a
    schema to represent a single item.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，设置GraphQL类型可能有点复杂。借助`type-graphql`和一些方便的装饰器，我们将创建一个表示单个项目的模式。
- en: 'We don''t need to worry about creating a type to represent multiple items just
    yet. Our item will consist of the following fields:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不需要担心创建一个表示多个项目的类型。我们的项目将包括以下字段：
- en: '`Id` (defaulted to an empty string)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`（默认为空字符串）'
- en: '`Title`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Title`'
- en: '`Description` (we are going to set this up as a nullable value for the moment.
    When we create the UI, we are going to add validation to make sure that we always
    supply a description.)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`（我们暂时将其设置为可空值。当我们创建UI时，我们将添加验证，以确保我们始终提供描述。）'
- en: The date the task is due (again, this is nullable)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务到期的日期（同样，这是可空的）
- en: When the task was created
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务创建时
- en: The number of days since the task was created (this will be automatically calculated
    when we query the data)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务创建后的天数（当我们查询数据时，这将自动计算）
- en: Whether or not the task has been completed
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务是否已完成
- en: If we pay attention, we will see that the fields here map very closely to the
    ones we defined in our MongoDB schema. This is because we will be populating our
    GraphQL type from the database, as well as updating the database directly from
    these types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，我们会发现这里的字段与我们在MongoDB模式中定义的字段非常相似。这是因为我们将从数据库中填充我们的GraphQL类型，以及直接从这些类型更新数据库。
- en: 'As we are used to doing now, we are going to start off with a simple class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们现在习惯的一样，我们将从一个简单的类开始：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I mentioned that we are going to use decorators with this class. We are going
    to decorate the class definition with `@ObjectType`, which gives us the ability
    to create complex types. Being good developers, we will also supply a description
    so that consumers of our type have documentation about what it represents. Right
    now, our class definition looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到我们将在这个类中使用装饰器。我们将用`@ObjectType`装饰类定义，这使我们能够创建复杂类型。作为优秀的开发者，我们还将提供描述，以便我们类型的使用者了解它代表什么。现在，我们的类定义如下：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to add the fields to our type, one step at a time. First, we are
    going to add the `Id` field, which matches the `Id` field in the database:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步一步地向我们的类型添加字段。首先，我们将添加`Id`字段，它与数据库中的`Id`字段匹配：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, we have supplied a decorator to this field, which will tell `type-graphql`
    how to transform our class into a GraphQL type. By applying `type=>ID`, we are
    using the special GraphQL `ID` type. This type is a string that maps to a unique
    value. It is an identity field, after all, and convention states that identity
    fields must be unique.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们为这个字段提供了一个装饰器，它将告诉`type-graphql`如何将我们的类转换为GraphQL类型。通过应用`type=>ID`，我们使用了特殊的GraphQL
    `ID`类型。这种类型是一个映射到唯一值的字符串。毕竟，它是一个标识字段，惯例规定标识字段必须是唯一的。
- en: 'We are going to add three nullable fields next—the `Description`, `DueDate`,
    and `CreationDate` fields. We aren''t really going to be allowing null values
    in these, as we will see when we start adding Angular validation later on in this
    chapter, but it''s important for us to see how we can add nullable types for any
    future GraphQL types that we create:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加三个可空字段——`Description`、`DueDate`和`CreationDate`字段。实际上，我们并不打算允许这些字段的空值，因为当我们在本章后面开始添加Angular验证时，我们会看到，但对于我们来说，重要的是要看到我们如何为我们创建的任何未来的GraphQL类型添加可空类型：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We do have some more simple fields that we are going to make available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些更简单的字段要提供：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our `TodoItem`, which represents the schema that makes up the entirety of our
    query type, now looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TodoItem`现在看起来像这样，它代表了构成我们查询类型的模式的全部内容：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As well as having a class for the query, we also need one to represent the data
    that we are going to use to mutate the state for subsequent queries, as well as
    for updating the database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有一个用于查询的类之外，我们还需要一个类来表示我们将用于变异状态的数据，以及用于更新数据库的数据。
- en: When we mutate state, we are changing it. We want those changes to be persisted
    across server restarts so they will update both the database and the state we
    are going to cache at runtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们改变状态时，我们正在改变它。我们希望这些更改能够在服务器重新启动时持久化，因此它们将更新数据库和我们将在运行时缓存的状态。
- en: 'The class we are going to use for the mutation looks very similar to our `TodoItem`
    class. The key differences are that we use `@InputType` in place of `@ObjectType`
    and the class implements a generic `Partial` type of `TodoItem`. The other difference
    is that this class does not have the `DaysCreated` field because that is going
    to be calculated by our query, so we don''t have to add any values to hold it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于mutation的类看起来与我们的`TodoItem`类非常相似。主要区别在于我们使用`@InputType`代替`@ObjectType`，并且该类实现了`TodoItem`的通用`Partial`类型。另一个区别是这个类没有`DaysCreated`字段，因为这将由我们的查询计算，所以我们不必添加任何值来保存它：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you don't know what `Partial` does, it simply makes all the properties of
    `TodoItem` optional. This lets us tie our new mutation class back to our old class
    without having to supply every property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道`Partial`的作用，它只是使`TodoItem`的所有属性变成可选的。这样我们就可以将我们的新mutation类与旧类联系起来，而不必提供每个属性。
- en: Creating our GraphQL resolver
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的GraphQL解析器
- en: The `TodoItem` and `TodoItemInput` classes were aimed at giving us schemas that
    describe the fields, types, and arguments. While they are an important part of
    our GraphQL jigsaw, we have a missing piece—the ability to execute functions against
    our GraphQL server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItem`和`TodoItemInput`类的目的是为我们提供描述字段、类型和参数的模式。虽然它们是我们GraphQL拼图的重要部分，但我们缺少一个部分——执行函数来针对我们的GraphQL服务器。'
- en: We need a way to resolve the fields of our types. With GraphQL, a resolver is
    something that represents a single field. It fetches the data that we need, effectively
    giving the GraphQL server detailed instructions on how to convert queries into
    data items (we can think of this as one of the reasons why we have separate schemas
    for mutating data over querying data—we cannot mutate fields using the same logic
    as querying fields). From this, we can work out that there is a one-to-one mapping
    between fields and resolvers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来解析我们类型的字段。在GraphQL中，解析器代表一个单一字段。它获取我们需要的数据，有效地向GraphQL服务器提供了详细的指令，告诉它如何将查询转换为数据项（我们可以将这视为我们为变异数据和查询数据分别使用不同的逻辑的原因之一）。由此，我们可以得出字段和解析器之间存在一对一的映射。
- en: With `type-graphql`, we can create complex resolver relationships and operations
    with ease. We are going to start off by defining our class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type-graphql`，我们可以轻松创建复杂的解析器关系和操作。我们将从定义我们的类开始。
- en: 'The `@Resolver` decorator tells us that this class behaves in the same way
    that a controller class would in a REST type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Resolver`装饰器告诉我们，这个类的行为与REST类型的控制器类相同：'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Strictly speaking, `ResolverInterface` is not necessary for our class, but we
    will be using it as a safety net when we add a field resolver to our `DaysCreated`
    field. This field is going to return the difference between today's date and the
    day the task was created. Since we are creating a field resolver, `ResolverInterface`
    checks that our field has the  `@Root` decorator of the object type as a parameter
    and that the return type is the correct type.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`ResolverInterface`对于我们的类并不是必需的，但是当我们向`DaysCreated`字段添加字段解析器时，我们将使用它作为一个安全网。这个字段将返回今天的日期和任务创建日期之间的差异。由于我们正在创建一个字段解析器，`ResolverInterface`检查我们的字段是否具有对象类型的`@Root`装饰器作为参数，并且返回类型是正确的类型。
- en: 'Our `DaysCreated` field resolver is decorated with `@FieldResolver` and looks
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DaysCreated`字段解析器装饰有`@FieldResolver`，看起来像这样：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While these methods look complicated, they are actually very simple. Our `DaysCreated`
    method receives the current `TodoItem` and works out the difference between today
    and the `CreationDate` value using `GetDateDifference`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法看起来复杂，但实际上它们非常简单。我们的`DaysCreated`方法接收当前的`TodoItem`，并使用`GetDateDifference`计算出今天和`CreationDate`值之间的差异。
- en: 'Our `type-graphql` resolver can also define the queries and mutations that
    we want to perform. What would be useful for us to define is a means to retrieve
    all the todo items. We will create a method decorated with `@Query` to identify
    that this will be a query operation. Since our query has the potential to return
    multiple items, we tell the resolver that the return type is an array of `TodoItem` types.
    Just like we did the hard work of creating our `Prefill` class earlier on, our
    method is as simple as this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`type-graphql`解析器还可以定义我们想要执行的查询和变异。对我们来说，定义一种检索所有待办事项的方法将非常有用。我们将创建一个使用`@Query`装饰的方法，以标识这将是一个查询操作。由于我们的查询有可能返回多个项目，我们告诉解析器返回类型是`TodoItem`类型的数组。就像我们之前创建`Prefill`类的辛苦工作一样，我们的方法就是这么简单：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'One of the operations that we want to allow our users to do is only query the
    records that are overdue. We can leverage largely similar logic to the last query,
    but we are going to filter on those uncompleted records that have gone past their
    due date:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要允许用户执行的操作之一是只查询逾期的记录。我们可以利用与上次查询类似的逻辑，但我们将筛选那些未完成的记录，这些记录已经超过了他们的截止日期：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Strictly speaking, for an operation that was shaping data like this, I would
    normally delegate the filtering logic to the data layer so that it only returned
    appropriate records. In this case, I decided to filter in the resolver so that
    we could see that the same source of data could be shaped in whatever way we needed.
    After all, we might have retrieved this data from a source that wouldn't let us
    shape it in a suitable way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，对于像这样塑造数据的操作，我通常会将过滤逻辑委托给数据层，以便它只返回适当的记录。在这种情况下，我决定在解析器中进行过滤，以便我们可以看到相同的数据源可以以我们需要的任何方式进行塑造。毕竟，我们可能已经从一个不允许我们以适当方式塑造它的源中检索到这些数据。
- en: One thing I must emphasize is that we must import reflect-metadata before we
    attempt to execute any queries or mutations. This has to happen because of the
    reliance of reflection when working with the decorators. Without reflect-metadata,
    we will not be able to use the decorators since they use reflection internally.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须强调的一点是，在尝试执行任何查询或变异之前，我们必须导入reflect-metadata。这是因为在使用装饰器时依赖反射。没有reflect-metadata，我们将无法使用装饰器，因为它们在内部使用反射。
- en: It's all very well having the ability to query data, but resolvers should also
    be able to perform mutations on the data. To this end, we are going to add resolvers
    to add, update, and remove new todo items, as well as set the `Completed` flag
    when the user decides that the task is complete. We're going to start off with
    the `Add` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有查询数据的能力是很好的，但解析器还应该能够对数据执行变异。为此，我们将添加解析器来添加、更新和删除新的待办事项，以及在用户决定任务完成时设置`Completed`标志。我们将从`Add`方法开始。
- en: 'Since this is a mutation, `type-graphql` provides the `@Mutation` decorator.
    Our method will accept a `TodoItemInput` parameter. This is passed in with a matching
    `@Arg` decorator. The reason that we need to supply this explicit `@Arg` is because
    GraphQL expects mutations to have parameters as arguments. By using `@Arg`, we
    provide them with the needed context. While supplying the mutation, we have an
    expectation that we will also be supplying a return type, so it is important to
    get the mapping between the mutation and the actual return type of the method
    correct:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个变异，`type-graphql`提供了`@Mutation`装饰器。我们的方法将接受一个`TodoItemInput`参数。这是通过匹配的`@Arg`装饰器传递的。我们需要提供这个显式的`@Arg`是因为GraphQL期望变异有参数作为参数。通过使用`@Arg`，我们为它们提供了所需的上下文。在提供变异的同时，我们期望我们也将提供一个返回类型，因此正确地映射变异和方法的实际返回类型非常重要：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One of the features of our mutation methods is that, as well as updating the
    `Prefill` items, we are also going to be updating the database, meaning that we
    have to convert the input in our method into our `ITodoSchema` type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们变异方法的一个特点是，除了更新`Prefill`项目，我们还将更新数据库，这意味着我们必须将我们方法中的输入转换为我们的`ITodoSchema`类型。
- en: 'To help us, we are going to use the following simple method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们，我们将使用以下简单的方法：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We accept both `TodoItem` and `TodoItemInput` because we are going to use the
    same method to create a record that will be acceptable to our database layer.
    Since the source of that record could come from either finding a particular record
    from the `Prefill` items, or having been passed over from our UI, we need to make
    sure that we can handle both cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受`TodoItem`和`TodoItemInput`，因为我们将使用相同的方法来创建一个可接受我们数据库层的记录。由于该记录的来源可以是从`Prefill`项目中找到特定记录，也可以是从我们的UI传递过来，我们需要确保我们可以处理这两种情况。
- en: 'The first part of our `Add` method involves creating a `TodoItem` item that
    will be stored in our `Prefill` collection. Once we have added the item to the
    collection, we are going to add the record to the database. Our full `Add` method
    looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Add`方法的第一部分涉及创建一个将存储在我们的`Prefill`集合中的`TodoItem`项目。一旦我们将项目添加到集合中，我们将把记录添加到数据库中。我们的完整的`Add`方法看起来像这样：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we know how to add a record, we can turn our attention to using a
    mutation to update the record. We already have most of the code infrastructure
    in place, so the update becomes a lot more straightforward to code. The `Update`
    method starts off by retrieving the entry that is already cached by searching
    for the item with the matching `Id` we have amended. If we find this record, we
    update it with the related `Title`, `Description`, and `DueDate` before we update
    the matching database record:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何添加记录，我们可以把注意力转向使用变异来更新记录。我们已经有了大部分的代码基础，所以更新变得更加简单。`Update`方法首先通过检索已经缓存的条目来开始，通过搜索具有匹配的`Id`的项目。如果我们找到这条记录，我们在更新与相关的`Title`、`Description`和`DueDate`之前更新匹配的数据库记录：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Removing a record is no more complicated than the `Update` method. In order
    to remove the record, we only need to supply the `Id` value so our method signature
    moves from having a complex type as an input to having a simple type—in this case,
    a string. We search through the cached entries to find the index of the record
    that matches the `Id` and, when found, we remove the cached entry by using the
    splice method. When we use splice on an array, we are really saying remove the
    entry that starts at the relevant index and remove the number of entries we choose.
    So, to remove `1` record, we supply `1` as the second parameter to this method.
    We need to make sure that our database is consistent, so we remove the database
    entry as well:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录并不比`Update`方法复杂。为了删除记录，我们只需要提供`Id`值，因此我们的方法签名从输入一个复杂类型变为输入一个简单类型——在这种情况下是一个字符串。我们通过缓存条目来查找与`Id`匹配的记录的索引，找到后，我们使用splice方法删除缓存条目。当我们在数组上使用splice时，我们实际上是在说删除从相关索引开始的条目，并删除我们选择的条目数。因此，要删除`1`条记录，我们将`1`作为该方法的第二个参数提供。我们需要确保我们的数据库是一致的，所以我们也删除数据库条目：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final mutation that we are interested in is the one that sets the `Completed`
    flag to `true`. This method is largely a combination of the `Remove` and `Update`
    methods in that it follows the same logic to identify a record and update it.
    However, like the `Remove` method, it only needs the `Id` as the input argument.
    As we only intend to update the `Completed` field, that is the only field that
    we are going to touch on in this method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的最终变异是将`Completed`标志设置为`true`的变异。这个方法在很大程度上是`Remove`和`Update`方法的组合，因为它遵循相同的逻辑来识别记录并更新它。然而，像`Remove`方法一样，它只需要`Id`作为输入参数。由于我们只打算更新`Completed`字段，这是我们在这个方法中要处理的唯一字段：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We could have chosen to reuse the `Update` method and set `Completed` to true
    from our client code, but that would have used a more complex call to achieve
    a much simpler end. By using a separate method, we are ensuring that we have code
    that does one thing and one thing only. This keeps us to the principle of single
    responsibility that we are interested in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以选择重用`Update`方法，并从客户端代码将`Completed`设置为true，但这将使用更复杂的调用来实现一个更简单的目标。通过使用单独的方法，我们确保我们有一个只做一件事情的代码。这使我们遵循我们感兴趣的单一责任原则。
- en: With our resolver and schemas in place, we can now turn our attention to adding
    the code to actually serve up our GraphQL server.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的解析器和模式，我们现在可以把注意力转向添加代码来实际提供我们的GraphQL服务器。
- en: Using Apollo Server as our server
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apollo Server作为我们的服务器
- en: We are going to create a new server implementation for this project, rather
    than reusing any of the server infrastructure from the previous chapter. Apollo
    provides its own server implementation (called Apollo Server), which we are going
    to use in place of Express. As usual, we are going to start off by bringing in
    the necessary types, and then we will create our class with the class definition.
    In the constructor, we are going to bring in a reference to our `Mongo` database
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个项目创建一个新的服务器实现，而不是重用上一章的任何服务器基础设施。Apollo提供了自己的服务器实现（称为Apollo Server），我们将在这里使用它来代替Express。和往常一样，我们将首先引入必要的类型，然后创建我们的类定义。在构造函数中，我们将引入对我们的`Mongo`数据库类的引用。
- en: Apollo Server is part of the overall Apollo GraphQL strategy for providing out-of-the-box
    GraphQL support. The server can either stand on its own or work with server frameworks
    such as Express for serving up self-documenting GraphQL data. The reason we are
    going to use Apollo Server is because it has built-in support for working with
    GraphQL schemas. If we were to try and add this support ourselves, we would end
    up redoing what we get for free from Apollo Server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server是Apollo GraphQL策略的一部分，用于提供开箱即用的GraphQL支持。服务器可以独立运行，也可以与Express等服务器框架一起工作，用于提供自描述的GraphQL数据。我们要使用Apollo
    Server的原因是因为它内置了与GraphQL模式一起工作的支持。如果我们试图自己添加这种支持，我们最终会重做我们从Apollo Server中免费获得的内容。
- en: 'First, we are going to import our types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要导入我们的类型：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we are going to write our `server` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写我们的`server`类：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our server is going to expose a `Start` method that will be responsible for
    connecting to the database and starting our Apollo Server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将公开一个`Start`方法，负责连接到数据库并启动我们的Apollo服务器：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When we create our Apollo Server instance, we indicate that we want to use `GraphQLSchema`,
    but we don't define anything about that schema. We use the `buildSchema` function,
    which takes a series of options and uses them to bring in the schema that Apollo
    Server will use. `resolvers` takes an array of GraphQL resolvers, so we are going
    to supply `TodoItemResolver` as the resolver we want to use. The implication here,
    of course, is that we can use multiple resolvers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建Apollo Server实例时，我们指示要使用`GraphQLSchema`，但我们没有定义关于该模式的任何内容。我们使用`buildSchema`函数，它接受一系列选项并使用它们来引入Apollo
    Server将使用的模式。`resolvers`接受一个GraphQL解析器数组，因此我们将`TodoItemResolver`作为我们要使用的解析器提供。当然，这里的含义是我们可以使用多个解析器。
- en: The `validate` flag states whether or not we want to validate objects that are
    passed into resolver parameters. Since we are using simple objects and types,
    we are going to set this to `false`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate`标志表示我们是否要验证传递给解析器参数的对象。由于我们使用简单的对象和类型，我们将其设置为`false`。'
- en: 'Something I like to do to validate the GQL I am creating is to emit the schema
    using `emitSchemaFile`. This uses the path operation to build up a fully qualified
    path name. In this case, we will be resolving to the `dist` folder, where we will
    output the `apolloschema.gql` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢做的一件事是使用`emitSchemaFile`来验证我创建的GQL。这使用路径操作来构建一个完全合格的路径名。在这种情况下，我们将解析到`dist`文件夹，我们将在那里输出`apolloschema.gql`文件：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have finished coding the server side up, we can add `new MyApp().Start();`
    to start and run our application. When we build and run our server side, it will
    start an instance of our Apollo-enabled GraphQL server on `http://localhost:3000`.
    We do have one little surprise left and it''s to do with the last parameter that
    we supply to the Apollo Server options, namely `playground: true`. The playground
    is a visual editor area that lets us run `graphql` queries and see what results
    they bring.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经完成了服务器端的编码，我们可以添加`new MyApp().Start();`来启动和运行我们的应用程序。当我们构建和运行我们的服务器端时，它将在`http://localhost:3000`上启动一个启用Apollo的GraphQL服务器的实例。我们还有一个小小的惊喜，与我们提供给Apollo
    Server选项的最后一个参数有关，即`playground: true`。游乐场是一个可视化编辑区域，让我们运行`graphql`查询并查看它们带来的结果。'
- en: I would recommend switching the playground off in production code. For testing
    purposes, however, it is an invaluable aid for trying out queries.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在生产代码中关闭游乐场。然而，对于测试目的，它是一个无价的辅助工具，可以尝试查询。
- en: 'In order to check that we have everything wired up correctly, try entering
    a GraphQL query into the query window. While entering the query, remember that
    just because there is a superficial resemblance to a JavaScript object, there
    is no need to use separate entries. Here''s a sample query to get started with.
    This query exercises the `TodoItems` query we created in `TodoItemResolver`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们是否正确连接了所有内容，请尝试在查询窗口中输入GraphQL查询。在输入查询时，请记住，只因为它与JavaScript对象有表面上的相似之处，并不意味着需要使用单独的条目。以下是一个开始的示例查询。此查询使用我们在`TodoItemResolver`中创建的`TodoItems`查询：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The GraphQL Angular client
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL Angular客户端
- en: 'Just like we did in the previous chapter, we are going to create an Angular
    client that uses Angular Material as its UI. Again, we are going to use the `ng
    new` command to create a new application, and we will set the prefix to `atp`.
    Since we want to add support for routing to our application, we are going to add
    an extra `--routing` parameter to our command line. We are doing this because
    it adds the necessary `AppRoutingModule` entries to `app.module.ts` and creates
    the `app-routing.module.ts` routing file for us:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中所做的那样，我们将创建一个使用Angular Material作为其UI的Angular客户端。同样，我们将使用`ng new`命令创建一个新的应用程序，并将前缀设置为`atp`。由于我们想要为我们的应用程序添加路由支持，我们将在命令行中添加额外的`--routing`参数。我们这样做是因为它会向`app.module.ts`添加必要的`AppRoutingModule`条目，并为我们创建`app-routing.module.ts`路由文件：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the previous chapter, even though we used Material, we didn''t take advantage
    of routing with it. We are going to use Material one last time before we get back
    to using Bootstrap for the rest of this book, so we need to add support for Material
    to our application (don''t forget to accept adding support for browser animations
    when prompted):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，即使我们使用了Material，我们也没有利用它的路由。在我们回到本书的其余部分使用Bootstrap之前，我们将再次使用Material一次，因此我们需要为我们的应用程序添加Material支持（不要忘记在提示时接受添加对浏览器动画的支持）：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this stage, our `app.module.ts` file should look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的`app.module.ts`文件应该是这样的：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We need to add the Material module imports to our `imports` array:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将Material模块导入到我们的`imports`数组中：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We add `MatNativeDateModule` alongside `MatDatepickerModule` because of the
    way that the Material date-picker was built. It does not provide any hard assumptions
    about the way that dates will be implemented, so we need to import an appropriate
    date representation. While we could write our own date handling module implementation,
    we are going to have real success by bringing in `MatNativeDateModule`. If we
    failed to do this, we would end up with a runtime error telling us `No provider
    found for DateAdapter`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`MatNativeDateModule`与`MatDatepickerModule`一起添加，因为Material日期选择器的构建方式。它不提供关于日期实现方式的任何硬性假设，因此我们需要导入适当的日期表示。虽然我们可以编写自己的日期处理模块实现，但通过引入`MatNativeDateModule`，我们将取得真正的成功。如果我们没有这样做，我们将得到一个运行时错误，告诉我们`未找到DateAdapter的提供程序`。
- en: Adding client-side Apollo support
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加客户端Apollo支持
- en: 'Before we get around to creating our user interface, we are going to set up
    the client side of our Apollo integration. While we could install all the individual
    parts of Apollo using `npm`, we are going to use the power of `ng` again:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建用户界面之前，我们将设置Apollo集成的客户端部分。虽然我们可以使用`npm`安装Apollo的所有单独部分，但我们将再次使用`ng`的强大功能：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Going back to `AppModule`, we are going to set up Apollo to interact with the
    server. The `AppModule` constructor is the perfect place for us to inject Apollo
    to create the connection to our server. Our constructor starts off looking like
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`AppModule`，我们将设置Apollo与服务器进行交互。`AppModule`的构造函数是我们注入Apollo创建与服务器连接的完美位置。我们的构造函数一开始看起来像这样：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The way that we create the connection to the server is through the `apollo.create`
    command. This accepts a number of options, but we''re just going to concentrate
    on three of them. We need a link, which establishes the link to our server; a
    cache, if we want to cache the results of our interactions; and an override of
    the default Apollo options where we set up the watch query to always fetch from
    the network. If we don''t fetch from the network, we can encounter issues where
    cached data becomes stale until a refresh:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接到服务器的方式是通过`apollo.create`命令。这个命令接受许多选项，但我们只关注其中的三个。我们需要一个链接，用于建立与服务器的连接；一个缓存，如果我们想要缓存我们的交互结果；以及一个覆盖默认Apollo选项的选项，我们在这里设置了观察查询始终从网络获取。如果我们不从网络获取，就会遇到缓存数据变得陈旧直到刷新的问题：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Don't forget that injecting components requires us to add the relevant modules
    to the `imports` section of the `@NgModule` module. In this case, we need to add
    `HttpLinkModule` and `ApolloModule` if we want to be able to automatically use
    these elsewhere.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，注入组件需要我们将相关模块添加到`@NgModule`模块的`imports`部分。在这种情况下，如果我们想要能够在其他地方自动使用这些，我们需要添加`HttpLinkModule`和`ApolloModule`。
- en: That is all the code that we need to put in place to have our client side communicate
    with a working Apollo Server. Of course, in a production system, we would pick
    up the address of the server elsewhere and use that instead of the hardcoded localhost.
    But for our example, this is all we need. We can now get on with the task of adding
    the screens and the ability to navigate to them using routing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要放置的所有代码，以便我们的客户端与工作的Apollo服务器进行通信。当然，在生产系统中，我们会从其他地方获取服务器的地址并使用它，而不是硬编码的localhost。但对于我们的示例，这就是我们需要的。现在我们可以继续添加屏幕和使用路由导航到它们的任务。
- en: Adding routing support
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由支持
- en: 'The requirements that we have set for our application are such that we will
    have three main screens. Our main screen will show all todo tasks, including whether
    they have been completed or not. The second will show overdue tasks, and the last
    will let our users add new tasks. Each of these will be created as separate components.
    For now, we are going to add dummy implementations of them, which will allow us
    to set up our routing:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为应用程序设置的要求是我们将有三个主要屏幕。我们的主屏幕将显示所有待办任务，包括它们是否已完成。第二个将显示过期任务，最后一个将让我们的用户添加新任务。每个都将创建为单独的组件。现在，我们将添加它们的虚拟实现，这将允许我们设置我们的路由：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our routing is configured and controlled from the `app-routing.module.ts` file. Here, we
    are going to define a set of rules that we expect Angular to follow.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由是从`app-routing.module.ts`文件配置和控制的。在这里，我们将定义一组规则，我们期望Angular遵循。
- en: Before we start adding routes, we should actually work out what the term routing
    means here. The simple way to think of routing is to think of the URL. The route
    corresponds to the URL, or rather, to the part of the URL other than the base
    address. Since our page will be running on `localhost:4000`, our full URL is `http://localhost:4000/`.
    Now, if we wanted our `AllTasks` component to map onto `http://localhost:4000/all`,
    we would consider the route to be `all`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始添加路由之前，我们实际上应该弄清楚这里的路由术语是什么意思。想到路由的简单方法是想到URL。路由对应于URL，或者说，对应于URL的基地址之外的部分。由于我们的页面将在`localhost:4000`上运行，我们的完整URL是`http://localhost:4000/`。现在，如果我们希望我们的`AllTasks`组件映射到`http://localhost:4000/all`，我们会认为路由是`all`。
- en: 'Now that we know what a route is, we need to map these three components to
    their own routes. We start off by defining an array of routes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了路由是什么，我们需要将这三个组件映射到它们自己的路由。我们首先通过定义一个路由数组开始：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We associate our routes with our routing module by supplying them in the module
    definition, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在模块定义中提供路由与我们的路由模块相关联，如下所示：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We want to map the `AllTasks` component to `all`, so we add this as an array
    element inside our routes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`AllTasks`组件映射到`all`，因此我们将其添加为路由数组中的一个元素：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At this point, when we start our Angular application, we can show the `all`
    tasks page if we type in `http://localhost:4000/all`. While this is reasonably
    impressive, it''s going to annoy users if we don''t have the concept of a default
    landing page for our site. Our users are generally going to expect that they can
    enter the site without having to know details about any of our page names, and
    they should be able to navigate from there because we will direct them to an appropriate
    page. Fortunately, we can accomplish this really easily. We are going to add another
    route that contains an empty path. When we encounter the empty path, we are going
    to redirect the user to the `all` page:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，当我们启动我们的Angular应用程序时，如果我们在`http://localhost:4000/all`中输入，我们可以显示`all`任务页面。虽然这相当令人印象深刻，但如果我们没有默认的站点着陆页的概念，这将会让用户感到恼火。我们的用户通常会期望他们可以进入站点而不必知道我们任何页面名称的细节，并且他们应该能够从那里导航，因为我们将引导他们到适当的页面。幸运的是，我们可以非常容易地实现这一点。我们将添加另一个包含空路径的路由。当我们遇到空路径时，我们将重定向用户到`all`页面：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, when the user navigates to `http://localhost:4000/`, they are redirected
    to see all of our outstanding tasks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户导航到`http://localhost:4000/`时，他们将被重定向以查看我们所有未完成的任务。
- en: 'We have two more components that we want the user to be able to navigate to:
    our `AddTask` page and our `OverdueTasks` page. Again, we will add support to
    navigate to these pages through new routes. Once we add these routes in, we can
    close this file since we have added all the core routing support that we need:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个组件，我们希望用户能够导航到：我们的`AddTask`页面和我们的`OverdueTasks`页面。同样，我们将添加支持通过新路由导航到这些页面。一旦我们添加了这些路由，我们就可以关闭这个文件，因为我们已经添加了所有我们需要的核心路由支持：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The routing user interface
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由用户界面
- en: 'The final part of adding routing support to our application is to set up the
    contents of `app-component.html`. In here, we are going to add a toolbar that
    will contain links to our pages and a place to show the page components themselves.
    The toolbar simply contains three navigation list items. The interesting part
    of each link is `routerLink`, which ties our link back to the addresses we previously
    added in. Effectively, what this part is doing is telling the code that, when
    we link in that route, we want the content to be rendered into the special `router-outlet`
    tag, which is just a placeholder for the actual component content:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由支持添加到我们应用程序的最后一部分是设置`app-component.html`的内容。在这里，我们将添加一个工具栏，其中包含指向我们页面的链接以及显示页面组件本身的位置。工具栏只包含三个导航列表项。每个链接的有趣部分是`routerLink`，它将我们的链接与之前添加的地址联系起来。实际上，这部分的作用是告诉代码，当我们链接到该路由时，我们希望内容呈现在特殊的`router-outlet`标记中，这只是实际组件内容的占位符。
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, when we run our application, clicking the different links will show the
    appropriate page, albeit with very little actual content in them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的应用程序时，单击不同的链接将显示相应的页面，尽管它们实际上几乎没有任何内容。
- en: Adding content to our page components
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向页面组件添加内容
- en: Now that we have our routing all sorted, we are ready to start adding some functionality
    to our pages. As well as adding content, we are going to start adding some polish
    to our application by making use of Angular validation to provide instant feedback
    to our users. The component that we are going to start with is the `AddTask` component.
    Without the ability to add tasks, we aren't going to be able to display any, so
    let's give ourselves the opportunity to start adding some todo tasks.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了我们的路由，我们准备开始为我们的页面添加一些功能。除了添加内容，我们还将通过使用Angular验证来为我们的应用程序添加一些修饰，以便为用户提供即时反馈。我们要开始的组件是`AddTask`组件。如果没有添加任务的能力，我们将无法显示任何任务，所以让我们给自己一个机会开始添加一些待办任务。
- en: 'Before I start adding in user interface elements, I like to make sure that
    I have as much of the logic in place behind the component as possible. Once this
    is in place, actually adding the user interface becomes straightforward. In some
    cases, this will mean that I have decided on UI constraints before I have even
    considered how the particular piece of display should be shown, or what control
    to use to show it. With this in mind, we know that one of the things that makes
    up our todo item is `DueDate`. If we think about this for a moment, we realize
    that it makes no sense for us to create a task that has a due date that has already
    passed. To that end, we are going to set the earliest date that a task can end
    as being today''s date. This will be used as a constraint against whatever control
    we use to choose the date:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始添加用户界面元素之前，我喜欢确保我尽可能多地放置组件背后的逻辑。一旦这一点到位，实际添加用户界面就变得简单。在某些情况下，这意味着我甚至在考虑如何显示特定的显示部分或使用什么控件来显示它之前，我已经决定了UI约束。考虑到这一点，我们知道我们的待办事项中的一项是`DueDate`。如果我们思考一下，我们意识到创建一个已经过期的截止日期的任务是没有意义的。因此，我们将设置任务的最早截止日期为今天的日期。这将用作我们选择日期的任何控件的约束。
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have three things that we are going to be capturing from the user in order
    to create our todo task. We need to capture the title, the description, and the
    date the task is due. This tells us that we are going to need three items to act
    as our model:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用户那里捕获三件事，以便创建我们的待办任务。我们需要捕获标题、描述和任务到期日期。这告诉我们我们需要三个项目作为我们的模型。
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is all we need on the model side of our add task component, but we are
    missing the ability to actually save anything over to our GraphQL server. Before
    we can start talking to our server, we need to bring support for Apollo into our
    component. This is as simple as adding a reference to it in our constructor:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在添加任务组件的模型方面所需要的一切，但我们缺少实际将任何内容保存到我们的GraphQL服务器的能力。在我们开始与服务器通信之前，我们需要在我们的组件中引入Apollo的支持。这只需要在我们的构造函数中添加一个引用即可。
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The operation we are going to perform must match with what our resolver is
    expecting. This means that types must match exactly and our GraphQL must be well-formed.
    Since the task we are going to perform is an add operation, we are going to call
    the method that we use to add the data, `Add`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要执行的操作必须与我们的解析器期望的相匹配。这意味着类型必须完全匹配，我们的GraphQL必须格式良好。由于我们要执行的任务是添加操作，我们将调用用于添加数据的方法`Add`。
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The add operation is going to trigger the `Add` mutation on the resolver we
    created on the server. We know that this accepts a `TodoItemInput` instance, so
    we need to transform our client-side model into a `TodoItemInput` instance, as
    follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 添加操作将触发服务器上我们创建的解析器上的`Add`变异。我们知道这接受一个`TodoItemInput`实例，因此我们需要将我们的客户端模型转换为`TodoItemInput`实例，如下所示。
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There is a bit in the preceding snippet that is unfamiliar to us, namely the `Guid.create.toString()` call. This
    command is responsible for creating a unique identifier known as a **Globally
    Unique Identifier** (**GUID**). A GUID is a 128-bit number that is externally
    represented in string and number format, which generally looks something like
    this—**a14abe8b-3d9b-4b14-9a66-62ad595d4582**. Since GUIDs are mathematically
    based to guarantee uniqueness, rather than having to call out to a central repository
    to get a unique value, they are quick to generate. Through the use of a GUID,
    we have given our todo item a unique value. We could have done this at the server
    if we needed to, but I chose to generate the entirety of the message on the client.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中有一点对我们来说是陌生的，即`Guid.create.toString()`调用。这个命令负责创建一个称为**全局唯一标识符**（**GUID**）的唯一标识符。GUID是一个128位的数字，以字符串和数字格式外部表示，通常看起来像这样——**a14abe8b-3d9b-4b14-9a66-62ad595d4582**。由于GUID在数学上保证唯一性，而不是必须调用中央存储库来获取唯一值，它们很快就能生成。通过使用GUID，我们为我们的待办事项赋予了一个唯一的值。如果需要的话，我们可以在服务器上完成这个操作，但我选择在客户端生成整个消息。
- en: 'In order to use a GUID, we will use the `guid-typescript` component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用GUID，我们将使用`guid-typescript`组件：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can now put the code in place to transfer the data over to the GraphQL server.
    As I mentioned previously, we are going to be using the `Add` mutation, which
    tells us that we are going to be calling `mutate` on our `apollo` client:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将代码放在适当的位置，将数据传输到GraphQL服务器。正如我之前提到的，我们将使用`Add`变异，这告诉我们我们将在我们的`apollo`客户端上调用`mutate`：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The mutation is a specialist form of string that is covered by `gql`. If we
    can see what the entirety of this code looks like, we will be able to break it
    down immediately after:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 变异是一种特殊的字符串，由`gql`覆盖。如果我们能看到这段代码的全部内容，我们将能够立即分解它：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We already knew that we were going to call a mutation, so our `mutate` method
    accepts a mutation as `MutationOption`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们将要调用一个变异，所以我们的`mutate`方法接受一个变异作为`MutationOption`。
- en: One of the parameters we can supply to `MutationOption` is `FetchPolicy`, which
    we could use to override the default options we set up when we created our Apollo
    link earlier.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向`MutationOption`提供的参数之一是`FetchPolicy`，我们可以用它来覆盖我们在之前创建Apollo链接时设置的默认选项。
- en: 'The mutation uses `gql` to create the specially formatted query. Our query
    is broken down into two parts: the string text that tells us what the query is
    and any variables that we need to apply. The variables section creates an input
    variable that maps onto `TodoItemInput`, which we created previously. This is
    represented by `$` inside our `gql` string, so any variable name must have a matching
    `$variable` in the query. When the mutation has completed, we tell it that we
    want the title back. We don''t actually have to bring any values back, but when
    I was debugging earlier on, I found it useful to use the title to check whether
    we were getting a response from the server.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 变异使用`gql`来创建特殊格式的查询。我们的查询分为两部分：告诉我们查询是什么的字符串文本和我们需要应用的任何变量。变量部分创建一个映射到我们之前创建的`TodoItemInput`的输入变量。这在我们的`gql`字符串内表示为`$`，因此任何变量名必须在查询中有一个匹配的`$variable`。当变异完成时，我们告诉它我们想要标题。实际上我们不必带回任何值，但是在我之前调试时，我发现使用标题来检查我们是否从服务器得到了响应是有用的。
- en: We are using the [PRE62]
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 [PRE62]
- en: 'private Reset(): void {'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'private Reset(): void {'
- en: this.Title = ``;
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: this.Title = ``;
- en: this.Description = ``;
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: this.Description = ``;
- en: this.DueDate = null;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: this.DueDate = null;
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: .centerDiv{
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: .centerDiv{
- en: 'height: 100vh;'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'height: 100vh;'
- en: 'display: flex;'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'display: flex;'
- en: 'justify-content: center;'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'justify-content: center;'
- en: 'align-items: center;'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'align-items: center;'
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: .mat-card {
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: .mat-card {
- en: 'width: 400px;'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'width: 400px;'
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: .mat-form-field {
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: .mat-form-field {
- en: 'display: block;'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'display: block;'
- en: '}'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: textarea {
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: textarea {
- en: 'height: 100px;'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'height: 100px;'
- en: 'resize: vertical;'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'resize: vertical;'
- en: '}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <div class="centerDiv" layout-fill layout="column" layout-align="center none">
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <div class="centerDiv" layout-fill layout="column" layout-align="center none">
- en: '.... content here'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '.... 内容在这里'
- en: </div>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE67]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '<form name="form" (ngSubmit)="f.form.valid && Add()" #f="ngForm">'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '<form name="form" (ngSubmit)="f.form.valid && Add()" #f="ngForm">'
- en: '.... the form content goes here.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '.... 表单内容在这里。'
- en: </form>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: </form>
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <div layout="row" layout-align="center none">
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <div layout="row" layout-align="center none">
- en: <mat-card>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-card>
- en: <mat-card-title>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-card-title>
- en: <span class="mat-headline">Add ToDo</span>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <span class="mat-headline">Add ToDo</span>
- en: </mat-card-title>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-card-title>
- en: <mat-card-content>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-card-content>
- en: '.... content here.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '.... 内容在这里。'
- en: <mat-card-content>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-card-content>
- en: <mat-card-actions>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-card-actions>
- en: <button mat-button class="btn btn-primary">Save</button>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <button mat-button class="btn btn-primary">Save</button>
- en: </mat-card-actions>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-card-actions>
- en: </mat-card>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-card>
- en: </div>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE69]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <mat-form-field>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-form-field>
- en: '<input type="text" matInput placeholder="Title" [(ngModel)]="Title" name="title"
    #title="ngModel" required />'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '<input type="text" matInput placeholder="Title" [(ngModel)]="Title" name="title"
    #title="ngModel" required />'
- en: </mat-form-field>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-form-field>
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
- en: <div *ngIf="title.errors.required">
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.errors.required">
- en: You must add a title.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须添加一个标题。
- en: </div>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE70]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
- en: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '<mat-datepicker #picker></mat-datepicker>'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '<mat-datepicker #picker></mat-datepicker>'
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <mat-form-field>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-form-field>
- en: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <input matInput [min]="EarliestDate" [matDatepicker]="picker" name="datepicker"
    placeholder="Due date"
- en: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '#datepicker="ngModel" required [(ngModel)]="DueDate">'
- en: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
- en: '<mat-datepicker #picker></mat-datepicker>'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '<mat-datepicker #picker></mat-datepicker>'
- en: </mat-form-field>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-form-field>
- en: '[PRE74]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <div *ngIf="datepicker.invalid && (datepicker.dirty || datepicker.touched)"
    class="alert alert-danger">
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="datepicker.invalid && (datepicker.dirty || datepicker.touched)"
    class="alert alert-danger">
- en: <div *ngIf="datepicker.errors.required">
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="datepicker.errors.required">
- en: You must select a due date.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须选择一个截止日期。
- en: </div>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ng g c components/Todo-Card
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ng g c components/Todo-Card
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'EarliestDate: Date;'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'EarliestDate: Date;'
- en: 'constructor(private apollo: Apollo) {'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'constructor(private apollo: Apollo) {'
- en: this.EarliestDate = new Date();
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: this.EarliestDate = new Date();
- en: '}'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '@Input() Todo: ITodoItem;'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() Todo: ITodoItem;'
- en: '[PRE78]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '@Output() deleted: EventEmitter<string> = new EventEmitter<string>();'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '@Output() deleted: EventEmitter<string> = new EventEmitter<string>();'
- en: '[PRE79]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <div fxLayout="row wrap" fxLayout.xs="column" fxLayoutWrap fxLayoutGap="20px
    grid" fxLayoutAlign="left">
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <div fxLayout="row wrap" fxLayout.xs="column" fxLayoutWrap fxLayoutGap="20px
    grid" fxLayoutAlign="left">
- en: <atp-todo-card
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <atp-todo-card
- en: '*ngFor="let todo of todos"'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*ngFor="let todo of todos"'
- en: '[Todo]="todo"'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[Todo]="todo"'
- en: (deleted)="resubscribe($event)"></atp-todo-card>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (deleted)="resubscribe($event)"></atp-todo-card>
- en: </div>
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE80]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'todos: ITodoItem[] = new Array<ITodoItem>();'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'todos: ITodoItem[] = new Array<ITodoItem>();'
- en: 'constructor(private apollo: Apollo) { }'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'constructor(private apollo: Apollo) { }'
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'protected Subscribe<T extends OverdueTodoItemQuery | TodoItemQuery>(gqlQuery:
    unknown): Observable<ApolloQueryResult<T>> {'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'protected Subscribe<T extends OverdueTodoItemQuery | TodoItemQuery>(gqlQuery:
    unknown): Observable<ApolloQueryResult<T>> {'
- en: '}'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE82]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: return this.apollo.query<T>({
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: return this.apollo.query<T>({
- en: 'query: gqlQuery,'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'query: gqlQuery,'
- en: 'fetch-policy: ''no-cache'''
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'fetch-policy: ''no-cache'''
- en: '});'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE83]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'resubscribe = (event: string) => {'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'resubscribe = (event: string) => {'
- en: const index = this.todos.findIndex(x => x.Id === event);
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: const index = this.todos.findIndex(x => x.Id === event);
- en: this.todos.splice(index, 1);
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: this.todos.splice(index, 1);
- en: '}'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ngOnInit() {
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ngOnInit() {
- en: this.Subscribe<OverdueTodoItemQuery>(gql`query ItemsQuery {
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: this.Subscribe<OverdueTodoItemQuery>(gql`query ItemsQuery {
- en: OverdueTodoItems {
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: OverdueTodoItems {
- en: Id,
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Id,
- en: Title,
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 标题，
- en: Description,
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Description,
- en: DaysCreated,
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: DaysCreated,
- en: DueDate,
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: DueDate,
- en: Completed
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Completed
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}`).subscribe(todo => {'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '}).subscribe(todo => {'
- en: this.todos = new Array<ITodoItem>();
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: this.todos = new Array<ITodoItem>();
- en: todo.data.OverdueTodoItems.forEach(x => {
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: todo.data.OverdueTodoItems.forEach(x => {
- en: this.todos.push(x);
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: this.todos.push(x);
- en: '});'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '});'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE85]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <span>{{Todo.Title}}</span>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <span>{{Todo.Title}}</span>
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <mat-form-field>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-form-field>
- en: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
- en: required />
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: required />
- en: </mat-form-field>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-form-field>
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
- en: <div *ngIf="title.errors.required">
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.errors.required">
- en: You must add a title.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: You must add a title.
- en: </div>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE87]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <div *ngIf="!InEdit;else editTitle">
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="!InEdit;else editTitle">
- en: <span>{{Todo.Title}}</span>
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: <span>{{Todo.Title}}</span>
- en: </div>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: '<ng-template #editTitle>'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '<ng-template #editTitle>'
- en: <mat-form-field>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <mat-form-field>
- en: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '<input type="text" name="Title" matInput placeholder="Title" [(ngModel)]="Todo.Title"
    #title="ngModel"'
- en: required />
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: required />
- en: </mat-form-field>
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: </mat-form-field>
- en: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.invalid && (title.dirty || title.touched)" class="alert alert-danger">
- en: <div *ngIf="title.errors.required">
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <div *ngIf="title.errors.required">
- en: You must add a title.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: You must add a title.
- en: </div>
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </ng-template>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: </ng-template>
- en: '[PRE88]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '<p>Due: {{Todo.DueDate | date}}</p>'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '<p>Due: {{Todo.DueDate | date}}</p>'
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Delete() {
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Delete() {
- en: this.apollo.mutate({
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: this.apollo.mutate({
- en: 'mutation: gql`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation: gql`'
- en: 'mutation Remove($Id: String!) {'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation Remove($Id: String!) {'
- en: 'Remove(Id: $Id)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'Remove(Id: $Id)'
- en: '}'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '`, variables: {'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`, variables: {'
- en: 'Id: this.Todo.Id'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: this.Todo.Id'
- en: '}'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}).subscribe();'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '}).subscribe();'
- en: this.deleted.emit(this.Todo.Id);
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: this.deleted.emit(this.Todo.Id);
- en: '}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE90]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Complete() {
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: Complete() {
- en: this.apollo.mutate({
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: this.apollo.mutate({
- en: 'mutation: gql`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation: gql`'
- en: 'mutation Complete($input: String!) {'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation Complete($input: String!) {'
- en: 'Complete(Id: $input)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'Complete(Id: $input)'
- en: '}'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '`, variables: {'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`, variables: {'
- en: 'input: this.Todo.Id'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'input: this.Todo.Id'
- en: '}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}).subscribe();'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '}).subscribe();'
- en: this.Edit(false);
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: this.Edit(false);
- en: this.Todo.Completed = true;
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: this.Todo.Completed = true;
- en: '}'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE91]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Save() {
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Save() {
- en: 'const todo: ITodoItemInput = new TodoItemInput();'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'const todo: ITodoItemInput = new TodoItemInput();'
- en: todo.Completed = false;
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: todo.Completed = false;
- en: todo.CreationDate = new Date();
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: todo.CreationDate = new Date();
- en: todo.Title = this.Todo.Title;
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: todo.Title = this.Todo.Title;
- en: todo.Description = this.Todo.Description;
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: todo.Description = this.Todo.Description;
- en: todo.DueDate = this.Todo.DueDate;
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: todo.DueDate = this.Todo.DueDate;
- en: todo.Id = this.Todo.Id;
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: todo.Id = this.Todo.Id;
- en: this.apollo.mutate({
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: this.apollo.mutate({
- en: 'mutation: gql`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation: gql`'
- en: 'mutation Update($input: TodoItemInput!) {'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 'mutation Update($input: TodoItemInput!) {'
- en: 'Update(TodoItem: $input)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 'Update(TodoItem: $input)'
- en: '}'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '`, variables: {'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`, variables: {'
- en: 'input: todo'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'input: todo'
- en: '}'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}).subscribe();'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '}).subscribe();'
- en: this.Edit(false);
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: this.Edit(false);
- en: '}'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: At this point, we have a fully functioning client- and server-based GraphQL
    system.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们拥有一个完全功能的基于客户端和服务器的GraphQL系统。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: In this chapter, we have investigated the benefits that GraphQL can bring to
    us by viewing it as an alternative to REST services for retrieving and updating
    data. We investigated setting up Apollo as a server-side GraphQL engine and added
    Apollo to an Angular client to interact with the server, as well as look at the
    specialist GQL query language. In order to leverage the full power of TypeScript,
    we brought in the `type-graphql` package to simplify the creation of GraphQL schemas
    and resolvers.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过将其视为检索和更新数据的REST服务的替代品，研究了GraphQL带来的好处。我们调查了将Apollo设置为服务器端GraphQL引擎，并将Apollo添加到Angular客户端以与服务器交互，以及查看专业的GQL查询语言。为了充分利用TypeScript的强大功能，我们引入了`type-graphql`包，以简化GraphQL模式和解析器的创建。
- en: Building on our experiences from the previous chapter, we saw how we could begin
    to build a reusable MongoDB data access layer; while there is some way to go with
    this, we have made a good start with it, leaving room to remove application constraints
    such as needing to use an `Id` to find records.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章的经验中，我们看到了如何开始构建可重用的MongoDB数据访问层；虽然还有一些工作要做，但我们已经很好地开始了，留下了一些空间来消除应用程序约束，比如需要使用`Id`来查找记录。
- en: This chapter also introduced us to Angular routing to serve up different views,
    depending on the route the user chooses. We kept using Material so that we could
    see how we could apply this logic to the navigation content we covered in [Chapter
    4](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml), *The MEAN Stack – Building a Photo
    Gallery*. We also looked at how to prevent the user from making mistakes with
    their input by looking at what Angular provides in terms of validation, and how
    we can use it alongside inline templates to provide consistent feedback to the
    user about any problems.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向我们介绍了Angular路由，以便根据用户选择的路由提供不同的视图。我们继续使用Material，以便了解如何将此逻辑应用于我们在[第4章](23db6d37-1947-4f7b-9b25-3195c2df7274.xhtml)中介绍的导航内容，*MEAN
    Stack - 构建照片库*。我们还看了如何通过查看Angular提供的验证内容以及如何将其与内联模板一起使用，以便向用户提供有关任何问题的一致反馈，以防止用户输入错误。
- en: 'In the next chapter, we are going to look at another way of communicating with
    a server by using Socket.IO to maintain an open connection between the client
    and server. We will build an Angular chat application that will automatically
    forward conversations to all open connections to the application. As an added
    bonus, we will see how we can integrate Bootstrap into Angular in place of Material
    and still use features such as routing. We will also introduce a feature that
    most professional applications rely on: user authentication.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Socket.IO来保持客户端和服务器之间的开放连接，来看另一种与服务器通信的方式。我们将构建一个Angular聊天应用程序，该应用程序将自动将对话转发到应用程序的所有开放连接。作为额外的奖励，我们将看到如何在Angular中集成Bootstrap以替代Material，并仍然使用诸如路由之类的功能。我们还将介绍大多数专业应用程序依赖的功能：用户认证。
- en: Questions
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Does GraphQL intend to fully replace REST clients?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL是否打算完全取代REST客户端？
- en: What purpose do mutations serve in GraphQL? What type of operations would we
    expect to see with them?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GraphQL中，突变有什么作用？我们期望看到什么类型的操作？
- en: How do we pass a parameter into a subcomponent in Angular?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将参数传递给Angular中的子组件？
- en: What is the difference between a schema and a resolver?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式和解析器之间有什么区别？
- en: How do we create a singleton?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个单例？
- en: The complete function does not remove a completed task from the overdue items
    page. Enhance the code to remove the item from the page after the user clicks
    complete.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的函数不会从过期项目页面中删除已完成的任务。增强代码以在用户点击完成后从页面中删除该项目。
- en: Further reading
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: In order to delve further into the mysteries of GraphQL, I would recommend Brian
    Kimokoti's excellent *Beginning GraphQL* ([https://www.packtpub.com/in/application-development/beginning-graphql](https://www.packtpub.com/in/application-development/beginning-graphql)).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更深入地探讨GraphQL的奥秘，我推荐Brian Kimokoti的优秀著作《入门GraphQL》（[https://www.packtpub.com/in/application-development/beginning-graphql](https://www.packtpub.com/in/application-development/beginning-graphql)）。
- en: To see GraphQL in use in React, Sebastian Grebe has written *Hands-on Full-Stack
    Web Development with GraphQL and React* ([https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react](https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react)).
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在React中查看GraphQL的使用，Sebastian Grebe写了《使用GraphQL和React进行全栈Web开发实践》（[https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react](https://www.packtpub.com/in/web-development/hands-full-stack-web-development-graphql-and-react)）。
