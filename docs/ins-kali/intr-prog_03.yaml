- en: Java Language Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语言基础
- en: Now that you have a general idea about Java and its related terms and tools,
    we will start discussing Java as a programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Java及其相关术语和工具有了一个大致的了解，我们将开始讨论Java作为一种编程语言。
- en: This chapter will introduce the basic concepts of Java as an **object-oriented
    programming** (**OOP**) language. You will learn about classes, interfaces, and
    objects, and their relations. You will also learn the concepts and features of
    OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Java作为**面向对象编程**（**OOP**）语言的基本概念。您将了解类、接口和对象及其关系。您还将学习OOP的概念和特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic terms in Java programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编程的基本术语
- en: Classes and objects (instances)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象（实例）
- en: Class (static) and object (instance) members
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类（静态）和对象（实例）成员
- en: Interface, implementation, and inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口、实现和继承
- en: OOP concepts and features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP的概念和特性
- en: Exercise – Interface versus abstract class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-接口与抽象类
- en: We call them basics because they are the founding principles of Java as a language,
    and there is more to learn before you can start programming professionally. For
    those who are learning Java for the first time, learning the basics of Java is
    a steep slope to climb, but the path becomes easier thereafter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称它们为基础，因为它们是Java作为一种语言的基本原则，而在您可以开始专业编程之前还有更多要学习。对于那些第一次学习Java的人来说，学习Java的基础是一个陡峭的斜坡，但之后的道路会变得更容易。
- en: The basic terms of Java programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java编程的基本术语
- en: The notion of Java programming basics has many interpretations. Some tutorials
    assume the basics to be the same for any object-oriented language. Others discuss
    syntax and basic language elements and grammar rules. Yet others reduce the basics
    to the value types, operators, statements, and expressions that allow computations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程基础的概念有很多解释。一些教程假设基础对于任何面向对象的语言都是相同的。其他人讨论语法和基本语言元素和语法规则。还有一些人将基础简化为允许计算的值类型、运算符、语句和表达式。
- en: Our view of Java basics consists of some elements from each of the earlier approaches.
    The only criteria for the selection we used were practicality and a gradual increase
    of complexity. We will start with simple definitions in this section, and then
    dive deeper into them in the subsequent sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Java基础的看法包括了前面各种方法的一些元素。我们选择的唯一标准是实用性和逐渐增加的复杂性。我们将从本节的简单定义开始，然后在后续章节中深入探讨。
- en: Byte code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节码
- en: In the broadest terms, a Java program (or any computer program for that matter)
    means a sequential set of instructions for a computer, that tell it what to do. Before
    executing on a computer, a program must be compiled from a human-readable, high-level
    programming language into a machine-readable binary code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最广泛的意义上，Java程序（或任何计算机程序）意味着一系列顺序指令，告诉计算机该做什么。在计算机上执行之前，程序必须从人类可读的高级编程语言编译成机器可读的二进制代码。
- en: In the case of Java, the human-readable text, called a source code, is stored
    in a `.java` file and can be compiled into byte code by the Java compiler `javac`.
    Java byte code is the instruction set for JVM. The byte code is stored in a `.class`
    file and can be interpreted and compiled into binary code by, JVM or, more specifically,
    by the **Just-In-Time** (**JIT**) compiler used by JVM. The binary code is then
    executed by a microprocessor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的情况下，人类可读的文本，称为源代码，存储在一个`.java`文件中，并可以通过Java编译器`javac`编译成字节码。Java字节码是JVM的指令集。字节码存储在一个`.class`文件中，并可以由JVM或更具体地说是由JVM使用的**即时**（**JIT**）编译器解释和编译成二进制代码。然后由微处理器执行二进制代码。
- en: An important feature of byte code is that it can be copied from one machine
    and executed on another machine's JVM. That is what Java portability means.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码的一个重要特点是它可以从一台机器复制到另一台机器的JVM上执行。这就是Java可移植性的含义。
- en: Defects (bugs) and their severity and priority
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺陷（bug）及其严重程度和优先级
- en: The word *bug*, with the meaning of *little faults and difficulties*, existed
    as early as the 19th century. The origin of this word is unknown, but it looks
    as if the verb *to bug* in a sense *to annoy* comes from that feeling of a pesky
    bothering coming from an insect—a bug—that buzzes around and threatens to bite
    you or something. The word was applied to programming defects as soon as a computer
    was first built.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*bug*这个词，意思是*小故障和困难*，早在19世纪就存在了。这个词的起源是未知的，但看起来好像动词*to bug*的意思是*打扰*，来自于一种讨厌的感觉，来自于一个嗡嗡作响并威胁要咬你或其他东西的昆虫-虫子。这个词在计算机第一次建造时就被用于编程缺陷。'
- en: The defects vary by their severity – the degree of the effect they have on the
    program execution, or its results. Some defects are quite insignificant, like
    a format, in which the data are presented for a human. It would be another matter
    if the same data have to be consumed by some other system that could not process
    data presented in such a format. Then such a defect may be qualified as critical,
    because it would not allow the system to complete the data processing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷的严重程度各不相同-它们对程序执行或结果的影响程度。一些缺陷是相当微不足道的，比如数据以人类可读的格式呈现。如果同样的数据必须由其他无法处理这种格式的系统消耗，那就另当别论了。那么这样的缺陷可能被归类为关键，因为它将不允许系统完成数据处理。
- en: The severity of a defect depends on how it affects the program, not on how difficult
    it is to fix it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷的严重程度取决于它对程序的影响，而不是修复它有多困难。
- en: Some defects may force the program to exit before it has achieved the desired
    result. For example, a defect may lead to the exhaustion of memory or another
    resource, and cause JVM to shut down.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缺陷可能会导致程序在达到期望结果之前退出。例如，一个缺陷可能导致内存或其他资源的耗尽，并导致JVM关闭。
- en: The defect priority, how high the defect is on the to-do list, generally corresponds
    to the severity. But some low severity defects may be prioritized higher because
    of a customer perception. For example, the grammar error on a website, or a typo
    that may be perceived as offensive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷优先级，缺陷在待办事项列表中的高度，通常与严重性相对应。但是，由于客户的感知，一些低严重性的缺陷可能会被优先考虑。例如，网站上的语法错误，或者可能被视为冒犯的拼写错误。
- en: A defect's priority typically corresponds to its severity but sometimes, the
    priority may be increased based on customer perception.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷的优先级通常对应于其严重性，但有时，优先级可能会根据客户的感知而提高。
- en: Java program dependencies
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java程序依赖
- en: We also mentioned that a program may require the use of other programs and procedures
    that are already compiled into bytecodes. For JVM to find them, you must list
    the corresponding `.class` files in the `java` command using the `-classpath` option.
    Several programs and procedures make up a Java application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，程序可能需要使用已编译为字节码的其他程序和过程。为了让JVM找到它们，您必须在`java`命令中使用`-classpath`选项列出相应的`.class`文件。几个程序和过程组成了一个Java应用程序。
- en: The other programs and procedures used by the application for its tasks are
    called application dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序用于其任务的其他程序和过程称为应用程序依赖项。
- en: Notice that JVM does not read a `.class` file until some other class code requests
    it. So, it well may be that some of the `.class` files listed on a classpath are
    never used if the conditions under which they are needed never happen during the
    application's execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JVM在其他类代码请求之前不会读取`.class`文件。因此，如果在应用程序执行期间不发生需要它们的条件，那么类路径上列出的一些`.class`文件可能永远不会被使用。
- en: Statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: A statement is a language construct that can be compiled into a set of instructions
    to a computer. The closest analogy from everyday life to a Java statement is a
    sentence in the English language, a basic unit of language that expresses a complete
    thought. Every statement in Java must end with a `;` (semi-colon).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是一种语言构造，可以编译成一组指令给计算机。与日常生活中的Java语句最接近的类比是英语语句，这是一种表达完整思想的基本语言单位。Java中的每个语句都必须以`;`（分号）结尾。
- en: 'Here is an example of a declaration statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个声明语句的示例：
- en: '```java'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i;
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: int i;
- en: '```'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding statement declares a variable `i` of type `int` which stands for
    *integer* (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句声明了一个`int`类型的变量`i`，代表*整数*（见[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*）。
- en: 'Here is an expression statement:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表达式语句：
- en: '```java'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: i + 2;
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: i + 2;
- en: '```'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding statement adds 2 to the value of the existing variable `i`. When
    declared, an `int` variable is assigned a value of 0 by default, so the result
    of this expression is `2`, but it is not stored. That is why it is often combined
    with declaration and assignment statements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将2添加到现有变量`i`的值中。当声明时，`int`变量默认被赋值为0，因此此表达式的结果为`2`，但未存储。这就是为什么它经常与声明和赋值语句结合使用的原因：
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int j = i + 2;
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: int j = i + 2;
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This tells the processor to create the variable `j` of type `int` and assign
    to it a value that is equal to the current value assigned to the variable `i` increased
    by `2`. In [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, we will discuss statements and expressions in more
    detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉处理器创建一个`int`类型的变量`j`，并为其分配一个值，该值等于变量`i`当前分配的值加2。在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)，*运算符、表达式和语句*中，我们将更详细地讨论语句和表达式。
- en: Methods
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'A Java method is a group of statements that are always executed together with
    the purpose of producing a certain result in response to a certain input.  A method
    has a name, either a set of input parameters or no parameters at all, a body inside
    `{}` brackets, and a return type or `void` keyword that indicates that message
    does not return any value. Here is an example of a method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java方法是一组语句，总是一起执行，目的是对某个输入产生某个结果。方法有一个名称，要么一组输入参数，要么根本没有参数，一个在`{}`括号内的主体，以及一个返回类型或`void`关键字，表示该消息不返回任何值。以下是一个方法的示例：
- en: '```java'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int multiplyByTwo(int i){
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){
- en: int j = i * 2;
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: int j = i * 2;
- en: return j;
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: return j;
- en: '}'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code snippet, the method name is `multiplyByTwo`. It has one
    input parameter of type `int`. The method name and the list of parameter types
    are together called **method signature**.  The number of input parameters is called
    **arity**. Two methods have the same signature if they have the same name, the
    same arity, and the same sequence of types in the list of input parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，方法名为`multiplyByTwo`。它有一个`int`类型的输入参数。方法名和参数类型列表一起称为**方法签名**。输入参数的数量称为**arity**。如果两个方法具有相同的名称、相同的arity和相同的输入参数列表中类型的顺序，则它们具有相同的签名。
- en: 'That was a rewording of the definition of a method signature taken from Java
    Specification, section *8.4.2 Method Signature*. On the other hand, in the same
    specification, one can encounter the phrases such as: *several methods with the
    same name and signature*, *method* `getNumberOfScales` *in class* `Tuna` *has
    a name, signature, and return type*, and similar. So, beware; even the specification''s
    authors sometimes do not include method name into the notion of the method signature,
    and don''t be confused if other programmers follow suit.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从Java规范第*8.4.2节方法签名*中摘取的方法签名定义的另一种措辞。另一方面，在同一规范中，人们可能会遇到诸如：*具有相同名称和签名的多个方法*，*类*`Tuna`*中的方法*`getNumberOfScales`*具有名称、签名和返回类型*等短语。因此，要小心；即使是规范的作者有时也不将方法名包括在方法签名的概念中，如果其他程序员也这样做，不要感到困惑。
- en: 'The same preceding method can be re-written in many styles and with the same
    result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个前面的方法可以用许多风格重写，并且得到相同的结果：
- en: '```java'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int multiplyByTwo(int i){
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){
- en: return i * 2;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2;
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Another style is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种风格如下：
- en: '```java'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int multiplyByTwo(int i){ return i * 2; }
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){ return i * 2; }
- en: '```'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Some programmers prefer the most compact style, to be able to see as much code
    as possible on the screen. But that could decrease another programmer's ability
    to understand the code, which could lead to programming defects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员更喜欢最紧凑的风格，以便能够在屏幕上看到尽可能多的代码。但这可能会降低另一个程序员理解代码的能力，这可能会导致编程缺陷。
- en: 'Another example is a method without input parameters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个没有输入参数的方法：
- en: '```java'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int giveMeFour(){ return 4; }
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: int giveMeFour(){ return 4; }
- en: '```'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is quite useless. In reality, a method without parameters would read data
    from a database, for example, or from another source. We showed this example just
    to demonstrate the syntax.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当无用的。实际上，没有参数的方法会从数据库中读取数据，例如，或者从其他来源读取数据。我们展示这个例子只是为了演示语法。
- en: 'Here is an example of code that does nothing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个什么都不做的代码示例：
- en: '```java'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void multiplyByTwo(){ }
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo(){ }
- en: '```'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding method does nothing and returns nothing. The syntax requires indicating
    the absence of a return value using the keyword `void`. In reality, methods without
    return values are often used to record data to a database or to send something
    to a printer, to an email server, to another application (using web-services,
    for example), and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法什么也不做，也不返回任何东西。语法要求使用关键字`void`来指示没有返回值。实际上，没有返回值的方法通常用于将数据记录到数据库，或者发送数据到打印机、电子邮件服务器、另一个应用程序（例如使用Web服务），等等。
- en: 'And just for a complete overview, here is an example of a method with many
    parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这是一个具有许多参数的方法的示例：
- en: '```java'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String doSomething(int i, String s, double a){
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: String doSomething(int i, String s, double a){
- en: double result = Math.round(Math.sqrt(a)) * i;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: double result = Math.round(Math.sqrt(a)) * i;
- en: return s + Double.toString(result);
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 返回s + Double.toString(result);
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The above method extracts a square root from the third parameter, multiplies
    it to the first parameter, converts the result into a string, and attaches (concatenates)
    the result to the second parameter. The types and methods from the class `Math` used
    will be covered in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*. These calculations do not make much sense and are
    provided just for illustration purposes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法从第三个参数中提取平方根，将其乘以第一个参数，将结果转换为字符串，并将结果附加（连接）到第二个参数。将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中介绍使用的`Math`类的类型和方法，*Java语言元素和类型*。这些计算并没有太多意义，仅供说明目的。
- en: Classes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'All methods in Java are declared inside of structures called **classes**. A
    class has a name and a body in brackets `{}`, where methods are declared:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有方法都声明在称为**类**的结构内。一个类有一个名称和一个用大括号`{}`括起来的主体，在其中声明方法：
- en: '```java'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class MyClass {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类 {
- en: int multiplyByTwo(int i){ return i * 2; }
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){ return i * 2; }
- en: int giveMeFour(){ return 4;}
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: int giveMeFour(){ return 4;}
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Classes also have fields, often called properties; we will talk about them in
    the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类也有字段，通常称为属性；我们将在下一节讨论它们。
- en: The Main class and the main method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主类和主方法
- en: 'One class serves as an entry to a Java application. It has to be specified
    in the `java` command while launching the application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类作为Java应用程序的入口。在启动应用程序时，必须在`java`命令中指定它：
- en: '```java'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp <location of all .class files> MyGreatApplication
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp <所有.class文件的位置> MyGreatApplication
- en: '```'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding command, `MyGreatApplication` is the name of the class that
    serves as the starting point of the application. When JVM finds the file `MyGreatApplication.class`,
    it reads it into the memory and looks in it for a method called `main()`. This
    method has a fixed signature:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，`MyGreatApplication`是作为应用程序起点的类的名称。当JVM找到文件`MyGreatApplication.class`时，它会将其读入内存，并在其中查找名为`main()`的方法。这个方法有一个固定的签名：
- en: '```java'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String[] args) {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: // statements go here
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: // 在这里放语句
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s break the preceding code snippet into pieces:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把前面的代码片段分成几部分：
- en: '`public` means that this method is accessible to any external program (see
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`表示这个方法对任何外部程序都是可访问的（参见[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)，*包和可访问性（可见性）*）'
- en: '`static` means that there is only one copy of the method exists in all the
    memory (see the following section)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`表示该方法在所有内存中只存在一个副本（参见下一节）'
- en: '`void` means it returns nothing'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`表示它不返回任何东西'
- en: '`main` is the method name'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`是方法名'
- en: '`String[] args` means it accepts an array of String values as an input parameter
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String[] args`表示它接受一个String值的数组作为输入参数（参见[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*）'
- en: '`//` means it is a comment, ignored by JVM and placed here only for humans
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`表示这是一个注释，JVM会忽略它，这里只是为了人类（参见[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*）'
- en: The preceding `main()` method does nothing. If run, it will execute successfully
    but produce no result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`main()`方法什么也不做。如果运行，它将成功执行但不会产生结果。
- en: 'You may also see the input parameters written as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到输入参数写成如下形式：
- en: '```java'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String... args) {
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args) {
- en: //body that does something
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: //执行一些操作的主体
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It looks like a different signature, but in fact, it is the same. Since JDK
    5, Java has allowed the *last parameter* of the method signature to be declared
    as a sequence of parameters of the same type of the variable arity. This is called
    **varargs**. Inside the method, one can treat the last input parameter as an array
    `String[]`, whether it was declared as an array explicitly or as a varargs. You will
    be fine if you never use varargs in your life. We are telling you about it just
    so you can avoid confusion while reading other peoples' code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像是不同的签名，但实际上是相同的。自JDK 5以来，Java允许将方法签名的*最后一个参数*声明为相同类型的变量可变性的一系列参数。这被称为**varargs**。在方法内部，可以将最后一个输入参数视为数组`String[]`，无论它是显式声明为数组还是作为可变参数。如果你一生中从未使用过varargs，那么你会没问题。我们告诉你这些只是为了让你在阅读其他人的代码时避免混淆。
- en: 'One last, important feature of the `main()` method is the source of its input
    parameter. There is no other code that calls it. It is called by JVM itself. So,
    where do the parameters come from? One could guess that the command line is the
    source of the parameter values. In the `java` command, so far, we assumed that
    no parameters were passed to the main class. But if the main method expects some
    parameters, we can construct the command line as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main（）`方法的最后一个重要特性是其输入参数的来源。没有其他代码调用它。它是由JVM本身调用的。那么参数是从哪里来的呢？人们可能会猜想命令行是参数值的来源。在`java`命令中，到目前为止，我们假设没有参数传递给主类。但是如果主方法期望一些参数，我们可以构造命令行如下：'
- en: '```java'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp <location of all .class files> MyGreatApplication 1 2
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp <所有.class文件的位置> MyGreatApplication 1 2
- en: '```'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This means that inside the `main()` method, the value of the first element of
    the input array `args[0]` will be `1`, while the value of the second element of
    the input array `args[1]` will be `2`. Yes, you noticed it right, the count of
    the elements in an array starts with `0`. We will discuss this further in [Chapter
    5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements and Types*. The
    result will be the same whether the `main()` method signature is described using
    an array `String[] args` explicitly or by using varargs `String... args`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`main（）`方法中，输入数组`args [0]`的第一个元素的值将是`1`，而输入数组`args [1]`的第二个元素的值将是`2`。是的，你注意到了，数组中元素的计数从`0`开始。我们将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中进一步讨论这个问题，*Java语言元素和类型*。无论是显式地使用数组`String[]
    args`描述`main（）`方法签名，还是使用可变参数`String... args`，结果都是一样的。
- en: The code in the `main()` method then calls methods in the same main `.class`
    file or in the other `.class` files listed with the `-classpath` option. In the
    following section, we will see how such calls can be done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`main（）`方法中的代码调用同一main`.class`文件中的方法或使用`-classpath`选项列出的其他`.class`文件中的方法。在接下来的部分中，我们将看到如何进行这样的调用。
- en: Classes and objects (instances)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象（实例）
- en: A class is used as the template for creating objects. When an object is created,
    all fields and methods declared in the class are copied into an object. The combination
    of field values in an object is called **object state**. The methods provide object
    behavior.  An object is also called an instance of a class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类用作创建对象的模板。创建对象时，类中声明的所有字段和方法都被复制到对象中。对象中字段值的组合称为**对象状态**。方法提供对象行为。对象也称为类的实例。
- en: Each object is created by using the operator `new` and a constructor that looks
    like a special kind of method. The primary duty of a constructor is to set an
    initial object state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都是使用运算符`new`和看起来像一种特殊类型的方法的构造函数创建的。构造函数的主要职责是设置初始对象状态。
- en: Let's us now have a closer look at Java classes and objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看一看Java类和对象。
- en: Java classes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java类
- en: Java classes are stored in `.java` files. Each `.java` file may contain several
    classes. They are compiled by the Java compiler `javac` and stored in `.class` files.
    Each `.class` file contains one compiled class only.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java类存储在`.java`文件中。每个`.java`文件可以包含多个类。它们由Java编译器`javac`编译并存储在`.class`文件中。每个`.class`文件只包含一个已编译的类。
- en: Each `.java` file contains only one `public` class. The keyword `public` in
    front of the class name makes it accessible from the classes in other files. The
    filename must match the public class name. The file can contain other classes
    too, they are compiled into their own `.class` file, but they can be accessed
    only by the public class that gave its name to the `.java` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`.java`文件只包含一个`public`类。类名前的关键字`public`使其可以从其他文件中的类访问。文件名必须与公共类名匹配。文件还可以包含其他类，它们被编译成自己的`.class`文件，但只能被给出其名称的公共类访问`.java`文件。
- en: 'This is what the content of the file `MyClass.java` might look like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是文件`MyClass.java`的内容可能看起来像的样子：
- en: '```java'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public String method1(int i){
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1（int i）{
- en: //statements, including return statement
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private void method2(String s){
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 私有void方法2（字符串s）{
- en: //statements without return statement
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: //没有返回语句的语句
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It has two fields. The keyword `private` makes them accessible only from inside
    the class, from its method. The preceding class has two methods – one public and
    one private. The public method is accessible by any other class, while the private
    method is accessible only from other methods of the same class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个字段。关键字`private`使它们只能从类内部，从它的方法中访问。前面的类有两个方法 - 一个是公共的，一个是私有的。公共方法可以被任何其他类访问，而私有方法只能从同一类的其他方法中访问。
- en: 'This class seems to not have a constructor. So, how are the states of the objects
    based on this class going to be initialized? The answer is that, in fact, each
    class that does not define its constructor explicitly but gets a default one—without
    parameters. And here are two examples of constructors added explicitly—one without
    parameters, another with a parameter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类似乎没有构造函数。那么，基于这个类的对象的状态将如何初始化？答案是，事实上，每个没有显式定义构造函数但获得一个默认构造函数的类。这里有两个显式添加的构造函数的例子，一个没有参数，另一个有参数：
- en: '```java'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SomeClass {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: public class SomeClass {
- en: private int field1;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: public MyClass(){
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(){
- en: this.field1 = 42;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = 42;
- en: '}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other content of the class - methods
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: //... 类的其他内容 - 方法
- en: //    that define object behavior
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: //    定义对象行为
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class MyClass {
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... methods here
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: //... 方法在这里
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code snippet, the keyword `this` indicates the current object.
    Its usage is optional. We could write `field1 = val1;` and achieve the same result.
    But it is a good practice to use the keyword `this` to avoid confusion, especially
    when (and programmers often do this) the name of the parameter is the same as
    the name of the field, such as in the following constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，关键字`this`表示当前对象。它的使用是可选的。我们可以写`field1 = val1;`并获得相同的结果。但是最好使用关键字`this`来避免混淆，特别是当（程序员经常这样做）参数的名称与字段的名称相同时，比如在下面的构造函数中：
- en: '```java'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public MyClass(int field1, String field1){
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int field1, String field1){
- en: field1 = field1;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: field1 = field1;
- en: field2 = field2;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: field2 = field2;
- en: '}'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Adding the keyword `this` makes the code more friendly to human eyes. And sometimes,
    this is needed. We will discuss such cases in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加关键字`this`使代码更友好。有时候，这是必要的。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中讨论这样的情况，*接口、类和对象构造*。
- en: 'A constructor can also call the methods of this or any other accessible class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个构造函数也可以调用这个类或任何其他可访问类的方法：
- en: '```java'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: method1(33);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: method1(33);
- en: method2(val2);
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: method2(val2);
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private void method2(String s){
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: private void method2(String s){
- en: //statements without return statement
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: //没有返回语句的语句
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If a class does not define a constructor explicitly, it gets a default constructor
    from the default base class `java.lang.Object`. We will explain what it means
    in the upcoming *Inheritance* section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类没有显式定义构造函数，它会从默认的基类`java.lang.Object`中获得一个默认构造函数。我们将在即将到来的*继承*部分解释这意味着什么。
- en: 'A class can have several constructors with different signatures that can be
    used to create objects with different states if an application logic requires
    it. Once an explicit constructor with parameters is added to a class, the default
    constructor is not accessible unless it is added explicitly too. To clarify, this
    class has only one—default—constructor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有多个不同签名的构造函数，用于根据应用程序逻辑创建具有不同状态的对象。一旦在类中添加了带参数的显式构造函数，除非也显式添加默认构造函数，否则默认构造函数将不可访问。澄清一下，这个类只有一个默认构造函数：
- en: '```java'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: //... other methods here
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And this class has only one constructor too, but does not have a default one:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也只有一个构造函数，但没有默认构造函数：
- en: '```java'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods here
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This class has two constructors—with and without parameters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个构造函数，一个有参数，一个没有参数：
- en: '```java'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(){ }
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(){ }
- en: public MyClass(int val1, String val2){
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods here
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding constructor without parameters does nothing. It is provided only
    for the convenience of the client code that needs to create an object of this
    class but does not care about the particular initial state of the object. In such
    cases, JVM creates the default initial object state. We will explain what the
    default state is in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的前面构造函数什么也不做。它只是为了方便客户端代码创建这个类的对象，但不关心对象的特定初始状态。在这种情况下，JVM创建默认的初始对象状态。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中解释默认状态，*接口、类和对象构造*。
- en: Each object of the same class, created by any constructor, has the same methods
    (same behavior) even if its state (values assigned to the fields) is different.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个类的每个对象，由任何构造函数创建，都有相同的方法（相同的行为），即使它的状态（分配给字段的值）是不同的。
- en: This information about Java classes is enough for a beginner. Nevertheless,
    we would like to also describe some other classes that can be included in the
    same `.java` file, so that you will recognize them in other people's code. These
    other classes are called **nested classes**. They can be accessed only from the
    classes in the same file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于Java类的信息对于初学者来说已经足够了。尽管如此，我们还想描述一些其他类，这些类可以包含在同一个`.java`文件中，这样你就可以在其他人的代码中识别它们。这些其他类被称为**嵌套类**。它们只能从同一个文件中的类中访问。
- en: 'The class we have previously described – the only one public class in the `.java`
    file – is also called a top-level class. It can include a nested class called
    an inner class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的类-`.java`文件中唯一的一个公共类-也被称为顶级类。它可以包括一个称为内部类的嵌套类：
- en: '```java'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: class MyOtherClass { // inner class
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: class MyOtherClass { //内部类
- en: //inner class content here
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: //内部类内容在这里
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A top-level class can also include a static (more about static members in the
    next section) nested class. A `static` class is not called an inner class, just
    a nested class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级类还可以包括一个静态（关于静态成员的更多信息请参见下一节）嵌套类。`static`类不被称为内部类，只是一个嵌套类：
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: static class MyYetAnotherClass { // nested class
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: static class MyYetAnotherClass { //嵌套类
- en: // nested class content here
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: //嵌套类内容在这里
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Any method can include a class that can be accessed only within the method.
    It is called a local class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以包括一个只能在该方法内部访问的类。它被称为本地类：
- en: '```java'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: void someMethod() {
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）{
- en: class MyInaccessibleAnywhereElseClass { // local class
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: class MyInaccessibleAnywhereElseClass { //本地类
- en: // local class content here
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: //本地类内容在这里
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A local class is not very often used, but not because it is useless. Programmers
    just do not remember how to create a class that is needed inside one method only
    and create an external or inner class instead.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类并不经常使用，但并不是因为它没有用。程序员只是不记得如何创建一个只在一个方法内部需要的类，而是创建一个外部或内部类。
- en: 'The last but not the least kind of a class that can be included in the same
    file as a public class is called an anonymous class. It is a class without a name
    that allows the creation of an object in-place that can override the existing
    method or implement an interface. Let''s us assume that we have the following
    interface, `InterfaceA`, and the class `MyClass`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的一种可以包含在与公共类相同文件中的类是匿名类。它是一个没有名称的类，允许在原地创建一个对象，可以覆盖现有方法或实现一个接口。让我们假设我们有以下接口，`InterfaceA`，和类`MyClass`：
- en: '```java'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface InterfaceA{
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: public interface InterfaceA {
- en: void doSomething();
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: void doSomething（）;
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class MyClass {
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: void someMethod1() {
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod1（）{
- en: System.out.println("1\. Regular is called");
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("1.常规被称为");
- en: '}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void someMethod2(InterfaceA interfaceA) {
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod2（InterfaceA interfaceA）{
- en: interfaceA.doSomething();
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: interfaceA.doSomething（）;
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can execute the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下代码：
- en: '```java'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass myClass = new MyClass();
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass myClass = new MyClass（）;
- en: myClass.someMethod1();
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: myClass.someMethod1（）;
- en: myClass = new MyClass() {     //Anonymous class extends class MyClass
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: myClass = new MyClass（）{ //匿名类扩展类MyClass
- en: public void someMethod1(){              // and overrides someMethod1()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: public void someMethod1（）{ //并覆盖someMethod1（）
- en: System.out.println("2\. Anonymous is called");
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("2.匿名被称为");
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: myClass.someMethod1();
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类。someMethod1（）;
- en: myClass.someMethod2(new InterfaceA() { //Anonymous class implements
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: myClass.someMethod2（new InterfaceA（）{ //匿名类实现
- en: public void doSomething(){     //  InterfaceA
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: public void doSomething（）{ // InterfaceA
- en: System.out.println("3\. Anonymous is called");
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("3.匿名被称为");
- en: '}'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '```'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is going to be:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '```java'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 1\. Regular is called
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 1.常规被称为
- en: 2\. Anonymous is called
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 2.匿名被称为
- en: 3\. Anonymous is called
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 3.匿名被称为
- en: '```'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We do not expect the reader to understand the preceding code in full detail
    yet. We hope that the reader will be able to do it after reading this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望读者完全理解前面的代码。我们希望读者在阅读本书后能够做到这一点。
- en: This was a long section, with a lot of information. Most of it is just for reference,
    so do not feel bad if you do not remember everything. Just revisit this section
    after you have finished the book and acquired some practical experience with Java
    programming.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的部分，包含了很多信息。其中大部分只是供参考，所以如果你记不住所有内容，不要感到难过。在完成本书并获得一些Java编程的实际经验后，再回顾这一部分。
- en: A few more introductory sections follow. Then [Chapter 3](18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml),
    *Your Development Environment Setup,* will lead you through the configuration
    of the development tools on your computer, and in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you will start writing code and execute it - the moment every
    software developer remembers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来还有几个介绍性部分。然后[第3章]（18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml），*您的开发环境设置*，将引导您配置计算机上的开发工具，并且在[第4章]（64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml），*您的第一个Java项目*，您将开始编写代码并执行它-每个软件开发人员都记得的时刻。
- en: A few more steps, and you can call yourself a Java programmer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 再走几步，你就可以称自己为Java程序员了。
- en: Java object (class instance)
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对象（类实例）
- en: One often reads—and Oracle documentation is not an exception—that an object
    is *used to model the real-world objects*. Such a view originates from before
    the days of object-oriented programming. At that time programs had a common or
    global area to store intermediate results. If not carefully managed, different
    subroutines and procedures—that's what methods were called then—modified those
    values, stepping on each other's toes and making it very difficult to trace defects.
    Naturally, programmers tried to regulate the access to the data and to make the
    intermediate results accessible only to certain methods. A bundle of methods and
    the data only they can access started to be known as an object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常阅读-甚至Oracle文档也不例外-对象被*用于模拟现实世界的对象*。这种观点起源于面向对象编程之前的时代。那时，程序有一个用于存储中间结果的公共或全局区域。如果不小心管理，不同的子例程和过程-那时称为方法-修改这些值，互相干扰，使得很难追踪缺陷。自然地，程序员们试图规范对数据的访问，并且使中间结果只能被某些方法访问。一组方法和只有它们可以访问的数据开始被称为对象。
- en: Such constructs were also seen as models of the real-world objects. All the
    objects around us probably have some kind of an inner state, but we do not have
    access to it and know only how the objects behave. That is, we can predict how
    they will react to this or that input.  Creating private fields in a class (object)
    that can be accessed only from the methods of the same class (object) seemed to
    be the solution to the hidden object state. With that, the original idea of modeling
    the real-world objects was carried along.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造也被视为现实世界对象的模型。我们周围的所有对象可能都有某种内在状态，但我们无法访问它，只知道对象的行为。也就是说，我们可以预测它们对这个或那个输入会有什么反应。在类（对象）中创建只能从同一类（对象）的方法中访问的私有字段似乎是隐藏对象状态的解决方案。因此，模拟现实世界对象的原始想法得以延续。
- en: But after the years of object-oriented programming, many programmers realized
    that such a view can be misleading and actually quite harmful when one tries to
    apply it consistently to all kinds of software objects. For example, an object
    can carry values used as the parameters of an algorithm that has nothing to do
    with any real-world object but has everything to do with a computational efficiency.
    Or, as another example, an object that brings back the results of a computation.
    Programmers often call it a **data transfer object** (**DTO**). It has nothing
    to do with a real-world object unless stretches the definition of a real-world
    object, but that would be, well, a stretch.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是经过多年的面向对象编程，许多程序员意识到这样的观点可能会产生误导，并且在试图将其一贯应用于各种软件对象时实际上可能会产生相当大的危害。例如，一个对象可以携带用作算法参数的值，这与任何现实世界的对象无关，但与计算效率有关。或者，另一个例子，一个带回计算结果的对象。程序员通常称之为**数据传输对象**（**DTO**）。除非扩展现实世界对象的定义，否则它与现实世界对象无关，但那将是一个伸展。
- en: 'A software object is simply a data structure in computer memory where the actual
    values are stored. Is memory a real-world object? The physical memory cells are,
    but the information they carry does not represent the cells. It represents the
    values and methods of a software object. And this information about an object
    is not even stored in a continuous memory area: object state is stored in an area
    called heap, while methods are stored in the method area, which, depending on
    the JVM implementation, may or may not be part of the heap.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 软件对象只是计算机内存中的数据结构，实际值存储在其中。内存是一个现实世界的对象吗？物理内存单元是，但它们携带的信息并不代表这些单元。它代表软件对象的值和方法。关于对象的这些信息甚至不是存储在连续的内存区域中：对象状态存储在一个称为堆的区域中，而方法存储在方法区中，具体取决于JVM实现，可能或可能不是堆的一部分。
- en: An object, in our experience, is an integral part of the process of computation,
    which more often than not does not operate on models of real-world objects. An
    object is used to pass around values and methods, which are sometimes related
    and sometimes not. The set of methods and values might be grouped in one class
    for just a convenience or any other consideration.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，对象是计算过程的一个组成部分，通常不是在现实世界对象的模型上运行。对象用于传递值和方法，有时相关，有时不相关。方法和值的集合可能仅仅为了方便或其他考虑而被分组在一个类中。
- en: To be fair, sometimes the software objects do represent models of real-world
    objects. But the point is that it is not always the case. With that, let us not
    consider software objects as models of real-world objects, unless they really
    are. Instead, let us look at how the objects are created and used and how they
    can help us to build a useful functionality – an application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，有时软件对象确实代表现实世界对象的模型。但关键是这并不总是如此。因此，除非真的是这样，让我们不将软件对象视为现实世界对象的模型。相反，让我们看看对象是如何创建和使用的，以及它们如何帮助我们构建有用的功能
    - 应用程序。
- en: 'As we described in the previous section, an object is created based on a class,
    using the keyword `new` and a constructor – either the default or one that is
    declared explicitly. Consider, for example, the following class:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所描述的，对象是基于类创建的，使用关键字`new`和构造函数 - 要么是默认的，要么是显式声明的。例如，考虑以下类：
- en: '```java'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods are here
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we have this class, we can write the following in the method of some other
    class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这个类，我们可以在其他类的方法中写以下内容：
- en: '```java'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public AnotherClass {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: public AnotherClass {
- en: '...'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: public void someMethod(){
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: public void someMethod(){
- en: MyClass myClass = new MyClass(3, "some string");
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass myClass = new MyClass(3, "some string");
- en: String result = myClass.method1(2);
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: String result = myClass.method1(2);
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, the statement `MyClass myClass = new MyClass(3, "some
    string");` creates an object of class `MyClass`, using its constructor and the
    keyword `new`, and assigns the reference of the newly created object to the variable
    `myClass`. We have chosen an identificator of the object reference that matches
    the name of the class with the first letter in a lower case. It is just a convention
    and we could have chosen another identificator (like `boo`, for example) with
    the same result. In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*, we discuss identificators and variables in more
    detail. As you can see in the next line in the preceding example, once a reference
    is created we can use it to access public members of the newly created object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，语句`MyClass myClass = new MyClass(3, "some string");`创建了一个`MyClass`类的对象，使用了它的构造函数和关键字`new`，并将新创建的对象的引用分配给变量`myClass`。我们选择了一个对象引用的标识符，它与类名匹配，第一个字母小写。这只是一个约定，我们也可以选择另一个标识符（比如`boo`），结果是一样的。在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们会更详细地讨论标识符和变量。正如你在前面的例子中看到的，在下一行中，一旦创建了一个引用，我们就可以使用它来访问新创建对象的公共成员。
- en: 'Any Java object is created only one way: by using the keyword (operator) `new` and a
    constructor. This process is also called **class instantiation**. The reference
    to the object can be passed around as any other value (as a variable, parameter,
    or returned value), and every code that has access to the reference can use it
    to access the public members of the object. We will explain what public members
    are in the following section.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Java对象都只能通过使用关键字（运算符）`new`和构造函数来创建。这个过程也被称为**类实例化**。对对象的引用可以像任何其他值一样传递（作为变量、参数或返回值），每个有权访问引用的代码都可以使用它来访问对象的公共成员。我们将在下一节中解释什么是**公共成员**。
- en: Class (static) and object (instance) members
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类（静态）和对象（实例）成员
- en: We have mentioned the term public members in relation to an object. We have
    also used the keyword `static` while talking about the `main()` method. We also
    stated that a member that is declared `static` can have only one copy in JVM memory.
    Now, we are going to define all that, and more.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了与对象相关的公共成员这个术语。在谈到`main()`方法时，我们还使用了关键字`static`。我们还声明了一个被声明为`static`的成员在JVM内存中只能有一个副本。现在，我们将定义所有这些，以及更多。
- en: Private and public
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有和公共
- en: The keywords `private` and `public` are called **access modifiers**. There are
    also default and `protected` access modifiers, but we will talk about them in
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*. They are called access modifiers because they regulate accessibility
    to (sometimes also called visibility of) classes, methods, and fields, from outside
    the class, and also because they modify the declaration of the corresponding class,
    method, or field.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`private`和`public`被称为**访问修饰符**。还有默认和`protected`访问修饰符，但我们将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中讨论它们，*包和可访问性（可见性）*。它们被称为访问修饰符，因为它们调节类、方法和字段的可访问性（有时也被称为可见性），并且它们修改相应的类、方法或字段的声明。
- en: A class can be private when it is a nested class only. In the preceding *Java
    class* section, we did not use an explicit access modifier for nested classes (thus,
    we used the default one), but we could have made them private if we would like
    to allow access to these classes only from the top-level class and siblings.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类只有在它是嵌套类时才能是私有的。在前面的*Java类*部分，我们没有为嵌套类使用显式访问修饰符（因此，我们使用了默认的），但如果我们希望只允许从顶级类和同级访问这些类，我们也可以将它们设为私有。
- en: A private method or private field can be accessed only from within the class
    (object) where it is declared.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法或私有字段只能从声明它的类（对象）中访问。
- en: By contrast, a public class, method, or field can be accessed from any other
    class. Notice that a method or field cannot be public if the enclosing class is
    private. Which makes sense, doesn't it? If the class itself is inaccessible publicly,
    how can its members be public?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，公共类、方法或字段可以从任何其他类中访问。请注意，如果封闭类是私有的，那么方法或字段就不能是公共的。这是有道理的，不是吗？如果类本身在公共上是不可访问的，那么它的成员如何能是公共的呢？
- en: Static members
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态成员
- en: A class can be declared static only when it is a nested class. Class members—methods
    and fields—can be static too, as long as the class is not anonymous or local.
    Any code can access a static member of a class without creating a class instance
    (object). We saw such an example in previous sections when we used the class `Math`
    in one of the code snippets. A static class member is also called a class variable
    in case of the field or a class method in case of a method. Notice that these
    names contain the word `class` as an adjective. That is because a static member
    is associated with a class, not a class instance. It means that there is only
    one copy of a static member that can exist in JVM memory, although many instances
    (objects) of the class can be created and reside there at any moment in time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当类是嵌套类时，才能声明一个类为静态。类成员——方法和字段——也可以是静态的，只要类不是匿名的或本地的。任何代码都可以访问类的静态成员，而不需要创建类实例（对象）。在前面的章节中，我们在一个代码片段中使用了类`Math`，就是这样的一个例子。静态类成员在字段的情况下也被称为类变量，方法的情况下被称为类方法。请注意，这些名称包含`class`这个词作为形容词。这是因为静态成员与类相关联，而不是与类实例相关联。这意味着在JVM内存中只能存在一个静态成员的副本，尽管在任何时刻可以创建和驻留在那里的类的许多实例（对象）。
- en: 'Here is another example. Let''s assume we have the following class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子。假设我们有以下类：
- en: '```java'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类MyClass {
- en: private int field1;
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 私有int字段1;
- en: public static String field2;
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 公共静态字符串字段2;
- en: public MyClass(int val1, String val2){
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void method2(){
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: public static void method2(){
- en: //statements
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: //语句
- en: '}'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods are here
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: //... other methods are here
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'From any method of any other class, the public static members of the preceding
    `MyClass` class can be accessed as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何其他类的任何方法，可以通过以下方式访问前述`MyClass`类的公共静态成员：
- en: '```java'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass.field2 = "any string";
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.field2 = "any string";
- en: String s = MyClass.field2 + " and another string";
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: String s = MyClass.field2 + " and another string";
- en: '```'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result of the preceding operations will be the assigning to the variable
    `s` of the value `any string and another string`. The `String` class will be discussed
    further in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 前述操作的结果将是将变量`s`的值分配为`any string and another string`。`String`类将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中进一步讨论，*Java语言元素和类型*。
- en: 'Similarly, one can access a public static method `method2()` of the class `MyClass`
    as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过以下方式访问类`MyClass`的公共静态方法`method2()`：
- en: '```java'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass.method2();
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.method2();
- en: '```'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The other methods of the class `MyClass` can still be accessed via an instance
    (object):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 类`MyClass`的其他方法仍然可以通过实例（对象）访问：
- en: '```java'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass mc = new MyClass(3, "any string");
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass mc = new MyClass(3, "any string");
- en: String someResult = mc.method1(42);
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: String someResult = mc.method1(42);
- en: '```'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Obviously, there is no need to create an object of class `MyClass` if all its
    members are static.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果所有成员都是静态的，就没有必要创建`MyClass`类的对象。
- en: 'Nevertheless, sometimes it is possible to access a static member using the
    object reference. The following code may work – it depends on the implementation
    of the `javac` compiler. If it works, it produces the same result as the preceding
    code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时可以通过对象引用访问静态成员。以下代码可能有效 - 这取决于`javac`编译器的实现。如果有效，它将产生与前面代码相同的结果：
- en: '```java'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass mc = new MyClass(3, "any string");
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass mc = new MyClass(3, "any string");
- en: mc.field2 = "Some other string";
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: mc.field2 = "Some other string";
- en: mc.method2();
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: mc.method2();
- en: '```'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Some compilers provide a warning saying something like *static member being
    accessed by instance reference*, but they still let you do it. Others produce
    the error *cannot make a static reference to the non-static method/field* and
    force you to correct your code. The Java specification does not regulate such
    a case. But it is not a good practice to access a static class member via a reference
    to an object because it makes the code ambiguous for a human reader. So, you are
    better off avoiding doing that even if your compiler is more forgiving.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有些编译器会提供警告，比如*通过实例引用访问静态成员*，但它们仍然允许你这样做。其他编译器会产生错误*无法使静态引用非静态方法/字段*，并强制你纠正代码。Java规范不规定这种情况。但是，通过对象引用访问静态类成员不是一个好的做法，因为它使得代码对于人类读者来说是模棱两可的。因此，即使你的编译器更宽容，最好还是避免这样做。
- en: Object (instance) members
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象（实例）成员
- en: A non-static class member is also called an instance variable in case of the
    field or an instance method in case of a method. It can be accessed only via reference
    to the object followed by a dot "`.`" We have seen several such examples already.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态类成员在字段的情况下也称为实例变量，或者在方法的情况下称为实例方法。它只能通过对象的引用后跟一个点“。”来访问。我们已经看到了几个这样的例子。
- en: 'In line with the long-established tradition, the fields of an object are usually
    declared private. If necessary, the methods `set()` and/or `get()` are provided
    to access such private values. They are often called setters and getters as they
    set and get values of private fields. Here is an example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 按照长期以来的传统，对象的字段通常声明为私有的。如果必要，提供`set()`和/或`get()`方法来访问这些私有值。它们通常被称为setter和getter，因为它们设置和获取私有字段的值。这是一个例子：
- en: '```java'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public void setField1(String val){
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: public void setField1(String val){
- en: this.field1 = val;
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val;
- en: '}'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getField1(){
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField1(){
- en: return this.field1;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: return this.field1;
- en: '}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void setField2(String val){
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: public void setField2(String val){
- en: this.field2 = val;
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val;
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getField2(){
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField2(){
- en: return this.field2;
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: return this.field2;
- en: '}'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods are here
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: //... other methods are here
- en: '}'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Sometimes, it is necessary to make sure that the object state cannot be changed.
    To support such a case, programmers use a constructor to set the state and remove
    setters:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要确保对象状态不能被改变。为了支持这种情况，程序员使用构造函数来设置状态并删除setter：
- en: '```java'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getField1(){
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField1(){
- en: return this.field1;
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: return this.field1;
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getField2(){
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: public String getField2(){
- en: return this.field2;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: return this.field2;
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other non-setting methods are here
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: //... other non-setting methods are here
- en: '}'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Such an object is called immutable.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的对象称为不可变的。
- en: Method overloading
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'Two methods with the same name but different signatures represent method overloading.
    Here is an example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同名称但不同签名的两个方法代表方法重载。这是一个例子：
- en: '```java'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: public String method(int i){
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(int i){
- en: //statements
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: //statements
- en: '}'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int method(int i, String v){
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: public int method(int i, String v){
- en: //statements
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: //statements
- en: '}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The following is not allowed and will cause a compilation error, because return
    values are not a part of the method signature and cannot be used to distinguish
    one method from another if they have the same signature:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不允许的，会导致编译错误，因为返回值不是方法签名的一部分，如果它们具有相同的签名，则无法用于区分一个方法和另一个方法：
- en: '```java'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: public String method(int i){
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(int i){
- en: //statements
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: //statements
- en: '}'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int method(int i){ //error
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: public int method(int i){ //error
- en: //statements
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: //statements
- en: '}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Yet, this is allowed, because the methods have different signatures:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是允许的，因为这些方法具有不同的签名：
- en: '```java'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public String method(String v, int i){
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(String v, int i){
- en: //statements
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: //statements
- en: '}'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method(int i, String v){
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(int i, String v){
- en: //statements
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: //语句
- en: '}'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Interface, implementation, and inheritance
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口、实现和继承
- en: Now, we are stepping into the most significant area of Java programming – the heavily
    used Java programming terms of interface, implementation, and inheritance.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要进入Java编程的最重要领域——接口、实现和继承这些广泛使用的Java编程术语。
- en: Interface
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In everyday life, the word interface is quite popular. Its meaning is very close
    to the role Java interface plays in programming. It defines the public face of
    an object. It describes how it is possible to interact with the object and what
    can be expected of it. It hides inner class workings and exposes only method signatures
    with return values and access modifiers. An interface cannot be instantiated.
    An object of an interface type can be created only by creating an object of a
    class that implements this interface (interface implementation will be covered
    more thoroughly in the next section).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，“接口”这个词非常流行。它的含义与Java接口在编程中所扮演的角色非常接近。它定义了对象的公共界面。它描述了如何与对象进行交互以及可以期望它具有什么。它隐藏了内部类的工作原理，只公开了具有返回值和访问修饰符的方法签名。接口不能被实例化。接口类型的对象只能通过创建实现该接口的类的对象来创建（接口实现将在下一节中更详细地介绍）。
- en: 'For example, look at the following class:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的类：
- en: '```java'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method(int i){
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: public String method(int i){
- en: //statements
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: //语句
- en: '}'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int method(int i, String v){
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: public int method(int i, String v){
- en: //statements
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: //语句
- en: '}'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Its interface is as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 它的接口如下：
- en: '```java'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface MyClassInterface {
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: public interface MyClassInterface {
- en: String method(int i);
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: String method(int i);
- en: int method(int i, String v);
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: int method(int i, String v);
- en: '}'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: So, we could write `public class MyClass implements MyClassInterface {...}`.
    We will talk about it in the next section.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以写`public class MyClass implements MyClassInterface {...}`。我们将在下一节中讨论它。
- en: Since an interface is a *public* face, the method access modifier `public` is
    assumed by default and can be omitted.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口是*公共*的界面，默认情况下假定方法访问修饰符`public`，可以省略。
- en: An interface does not describe how the object of the class can be created. To
    discover that, one must look at the class and see what the signatures of the constructors
    it has are. One can also check and see if public static class members are present
    that can be accessed without creating an object. So, an interface is only the
    public face of a class *instance*.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不描述如何创建类的对象。要发现这一点，必须查看类并查看它的构造函数的签名。还可以检查并查看是否存在可以在不创建对象的情况下访问的公共静态类成员。因此，接口只是类*实例*的公共界面。
- en: Let's cover the rest of interface capabilities. According to the Java Specification,
    *The body of an interface may declare members of the interface, that is, fields, methods,
    classes, and interfaces.* If you are confused and asking what the difference between
    an interface and a class is, you have a legitimate concern which we are going
    to address now.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看接口的其余功能。根据Java规范，*接口的主体可以声明接口的成员，即字段、方法、类和接口。*如果您感到困惑，并问接口和类之间的区别是什么，您有一个合理的关注，我们现在将解决这个问题。
- en: Fields in the interface are implicitly public, static, and final. The modifier
    `final` means their values cannot be changed. By contrast, in a class, the implicit
    (default) access modifier of a class itself, its fields, methods, and constructors
    is package-private, which means it is visible only within its own package. Packages
    are named groups of related classes. You will learn about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的字段隐式地是公共的、静态的和最终的。修饰符`final`表示它们的值不能被改变。相比之下，在类中，类本身、它的字段、方法和构造函数的默认访问修饰符是包私有的，这意味着它只在自己的包内可见。包是相关类的命名组。您将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中了解它们，*包和可访问性（可见性）*。
- en: A method in the body of an interface may be declared default, static, or private.
    The purpose of the default method will be explained in the next section. A static
    method can be accessed from anywhere via the interface name and the dot "`.`".
    Private methods can be accessed only by other methods inside the same interface.
    By contrast, the default access modifier for the methods in classes is package-private.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 接口主体中的方法可以声明为默认、静态或私有。默认方法的目的将在下一节中解释。静态方法可以通过接口名称和点“`.`”从任何地方访问。私有方法只能被同一接口内的其他方法访问。相比之下，类中方法的默认访问修饰符是包私有的。
- en: As for the classes declared inside an interface, they are implicitly static. They
    are also public and can be accessed without an instance of an interface, which
    is impossible to create anyway. We are not going to talk more about such classes
    because they are used in very particular areas that are beyond the scope of this
    book.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 至于在接口内声明的类，它们隐式地是静态的。它们也是公共的，可以在没有接口实例的情况下访问，而创建接口实例是不可能的。我们不会再多谈论这样的类，因为它们用于超出本书范围的非常特殊的领域。
- en: Similarly to a class, an interface allows the declaration of an inner or nested
    interface inside its body. It can be accessed from outside like any static member,
    using the top-level interface with the dot "`.`". We would like to remind you
    that an interface is public by default and cannot be instantiated, and thus is
    static by default.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 与类类似，接口允许在其内部声明内部接口。可以像任何静态成员一样从外部访问它，使用顶级接口和点“`.`”。我们想提醒您，接口默认是公共的，不能被实例化，因此默认是静态的。
- en: There is one last very important term related to interfaces. A method signature
    listed in the interface without an implementation is called an **abstract method** and
    the interface itself is called **abstraction** because it abstracts, summarizes,
    and removes the signatures from the implementation. An abstraction cannot be instantiated.
    As an example, if you put the keyword `abstract` in front of any class and try
    to create its object, the compiler will throw an error even if all the methods
    in the class are not abstract. In such a case, the class behaves as an interface
    with the default methods only. Yet, there is a significant difference in their
    usage, which you will see after reading the upcoming *Inheritance* section of
    this chapter.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: There is one last very important term related to interfaces. A method signature
    listed in the interface without an implementation is called an **abstract method** and
    the interface itself is called **abstraction** because it abstracts, summarizes,
    and removes the signatures from the implementation. An abstraction cannot be instantiated.
    As an example, if you put the keyword `abstract` in front of any class and try
    to create its object, the compiler will throw an error even if all the methods
    in the class are not abstract. In such a case, the class behaves as an interface
    with the default methods only. Yet, there is a significant difference in their
    usage, which you will see after reading the upcoming *Inheritance* section of
    this chapter.
- en: We will talk more about interfaces in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, and cover their access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: We will talk more about interfaces in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, and cover their access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
- en: Implementation
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Implementation
- en: 'An interface can be implemented by a class, which means that the class has
    a body for each of the abstract methods listed in the interface. Here is an example:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 'An interface can be implemented by a class, which means that the class has
    a body for each of the abstract methods listed in the interface. Here is an example:'
- en: '```java'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface Car {
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: interface Car {
- en: double getWeightInPounds();
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: double getWeightInPounds();
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: double getMaxSpeedInMilesPerHour();
- en: '}'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl implements Car{
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl implements Car{
- en: public double getWeightInPounds(){
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 2000d;
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: return 2000d;
- en: '}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: public double getMaxSpeedInMilesPerHour(){
- en: return 100d;
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: return 100d;
- en: '}'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We named the class `CarImpl` to indicate that it is an implementation of the
    interface `Car`. But we could name it any other way we like.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: We named the class `CarImpl` to indicate that it is an implementation of the
    interface `Car`. But we could name it any other way we like.
- en: 'Both interface and its class implementation can have other methods too without
    causing a compiler error. The only requirement for the extra method in the interface
    is that it has to be default and have a body. Adding any other method to a class
    does not interfere with the interface implementation.  For example:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'Both interface and its class implementation can have other methods too without
    causing a compiler error. The only requirement for the extra method in the interface
    is that it has to be default and have a body. Adding any other method to a class
    does not interfere with the interface implementation.  For example:'
- en: '```java'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface Car {
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: interface Car {
- en: double getWeightInPounds();
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: double getWeightInPounds();
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: double getMaxSpeedInMilesPerHour();
- en: default int getPassengersCount(){
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: default int getPassengersCount(){
- en: return 4;
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl implements Car{
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl implements Car{
- en: private int doors;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: private int doors;
- en: private double weight, speed;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: private double weight, speed;
- en: public CarImpl(double weight, double speed, int doors){
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: public CarImpl(double weight, double speed, int doors){
- en: this.weight = weight;
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: this.weight = weight;
- en: this.speed = speed;
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: this.speed = speed;
- en: this.dooes = doors;
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: this.dooes = doors;
- en: '}'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getWeightInPounds(){
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return this.weight;
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: return this.weight;
- en: '}'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: public double getMaxSpeedInMilesPerHour(){
- en: return this.speed;
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: return this.speed;
- en: '}'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getNumberOfDoors(){
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: public int getNumberOfDoors(){
- en: return this.doors;
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: return this.doors;
- en: '}'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we now create an instance of a class `CarImpl`, we can call all the methods
    we have declared in the class:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we now create an instance of a class `CarImpl`, we can call all the methods
    we have declared in the class:'
- en: '```java'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: CarImpl car = new CarImpl(500d, 50d, 3);
- en: car.getWeightInPounds();         //Will return 500.0
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: car.getWeightInPounds();         //Will return 500.0
- en: car.getMaxSpeedInMilesPerHour(); //Will return 50.0
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: car.getMaxSpeedInMilesPerHour(); //Will return 50.0
- en: car.getNumberOfDoors();          //Will return 3
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: car.getNumberOfDoors();          //Will return 3
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That was not surprising.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: That was not surprising.
- en: 'But, here is something you might not have expected:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 'But, here is something you might not have expected:'
- en: '```java'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: car.getPassengersCount();          //Will return 4
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: car.getPassengersCount();          //Will return 4
- en: '```'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This means that by implementing an interface class acquires all the default
    methods the interface has. That is the purpose of the default methods: to add
    functionality to all classes that implement the interface. Without it, if we add
    an abstract method to an old interface, all current interface implementations
    will trigger a compiler error. But, if we add a new method with the modifier default,
    the existing implementations will continue working as usual.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 'This means that by implementing an interface class acquires all the default
    methods the interface has. That is the purpose of the default methods: to add
    functionality to all classes that implement the interface. Without it, if we add
    an abstract method to an old interface, all current interface implementations
    will trigger a compiler error. But, if we add a new method with the modifier default,
    the existing implementations will continue working as usual.'
- en: 'Now, another nice trick. If a class implements a method with the same signature
    as the default method, it will `override` (a technical term) the behavior of the
    interface. Here is an example:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, another nice trick. If a class implements a method with the same signature
    as the default method, it will `override` (a technical term) the behavior of the
    interface. Here is an example:'
- en: '```java'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface Car {
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: interface Car {
- en: double getWeightInPounds();
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: double getWeightInPounds();
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: double getMaxSpeedInMilesPerHour();
- en: default int getPassengersCount(){
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: default int getPassengersCount(){
- en: return 4;
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl implements Car{
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl implements Car{
- en: private int doors;
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: private int doors;
- en: private double weight, speed;
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: private double weight, speed;
- en: public CarImpl(double weight, double speed, int doors){
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: public CarImpl(double weight, double speed, int doors){
- en: this.weight = weight;
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: this.weight = weight;
- en: this.speed = speed;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: this.speed = speed;
- en: this.dooes = doors;
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: this.dooes = doors;
- en: '}'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getWeightInPounds(){
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return this.weight;
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: return this.weight;
- en: '}'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: public double getMaxSpeedInMilesPerHour(){
- en: return this.speed;
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: return this.speed;
- en: '}'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getNumberOfDoors(){
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: public int getNumberOfDoors(){
- en: return this.doors;
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: return this.doors;
- en: '}'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getPassengersCount(){
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: public int getPassengersCount(){
- en: return 3;
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 3;
- en: '}'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we use the interface and class described in this example, we can write the
    following code:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用本例中描述的接口和类，我们可以编写以下代码：
- en: '```java'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: CarImpl car = new CarImpl(500d, 50d, 3);
- en: car.getPassengersCount();        //Will return 3 now !!!!
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: car.getPassengersCount();        //现在将返回3 !!!!
- en: '```'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If not all of the abstract methods of the interface have been implemented the
    class must be declared abstract, and cannot be instantiated.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口的所有抽象方法都没有被实现，那么类必须声明为抽象类，并且不能被实例化。
- en: 'The purpose of an interface is to represent its implementations – all objects
    of all the classes that have implemented it. For example, we could create another
    class that implements the `Car` interface:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的目的是代表它的实现-所有实现它的类的所有对象。例如，我们可以创建另一个实现`Car`接口的类：
- en: '```java'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class AnotherCarImpl implements Car{
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: public class AnotherCarImpl implements Car{
- en: public double getWeightInPounds(){
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 2d;
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 2d;
- en: '}'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: public double getMaxSpeedInMilesPerHour(){
- en: return 3d;
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 3d;
- en: '}'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getNumberOfDoors(){
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: public int getNumberOfDoors(){
- en: return 4;
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 4;
- en: '}'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getPassengersCount(){
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: public int getPassengersCount(){
- en: return 5;
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: return 5;
- en: '}'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then we can let the `Car` interface represent each of them:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以让`Car`接口代表它们中的每一个：
- en: '```java'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Car car = new CarImpl(500d, 50d, 3);
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Car car = new CarImpl(500d, 50d, 3);
- en: car.getWeightInPounds();          //Will return 500.0
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: car.getWeightInPounds();          //将返回500.0
- en: car.getMaxSpeedInMilesPerHour();  //Will return 50.0
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: car.getMaxSpeedInMilesPerHour();  //将返回50.0
- en: car.getNumberOfDoors();           //Will produce compiler error
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: car.getNumberOfDoors();           //将产生编译器错误
- en: car.getPassengersCount();         //Still returns 3 !!!!
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: car.getPassengersCount();         //仍然返回3 !!!!
- en: car = new AnotherCarImpl();
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: car = new AnotherCarImpl();
- en: car.getWeightInPounds();          //Will return 2.0
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: car.getWeightInPounds();          //将返回2.0
- en: car.getMaxSpeedInMilesPerHour();  //Will return 3.0
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: car.getMaxSpeedInMilesPerHour();  //将返回3.0
- en: car.getNumberOfDoors();           //Will produce compiler error
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: car.getNumberOfDoors();           //将产生编译器错误
- en: car.getPassengersCount();         //Will return 5
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: car.getPassengersCount();         //将返回5
- en: '```'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Several interesting observations can be made from looking at the preceding code
    snippet. First, when the variable `car` is declared as an interface type (not
    a class type as in the previous example), one cannot call a method not declared
    in the interface.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中可以得出一些有趣的观察。首先，当变量`car`声明为接口类型时（而不是类类型，如前面的例子），不能调用接口中未声明的方法。
- en: Second, the `car.getPassengersCount()` method returns `3` the first time. One
    could have expected it to return `4`, because `car` was declared as an interface
    type and one could have expected the default method to work. But, in fact, the
    variable `car` refers the object of class `CarImpl`, and that is why the class
    implementation of the `car.getPassengersCount()` method is executed.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`car.getPassengersCount()`方法第一次返回`3`。人们可能期望它返回`4`，因为`car`被声明为接口类型，人们可能期望默认方法起作用。但实际上，变量`car`指的是`CarImpl`类的对象，这就是为什么执行`car.getPassengersCount()`方法的是类的实现。
- en: Working with an interface, you should remember that the signatures come from
    the interface, but the implementation comes from a class, or from a default interface
    method if the class does not implement it. Here shines another feature of default
    methods. They serve both as a signature that can be implemented and as an implementation
    if the class does not implement it.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口时，应该记住签名来自接口，但实现来自类，或者来自默认接口方法（如果类没有实现它）。这里还有默认方法的另一个特性。它们既可以作为可以实现的签名，也可以作为实现（如果类没有实现它）。
- en: If there are several default methods in an interface, it is possible to create
    private methods accessible only by the default methods of the interface. They
    can be used to contain common functionality instead of repeating it in every default
    method. The private methods cannot be accessed from outside the interface.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口中有几个默认方法，可以创建私有方法，只能由接口的默认方法访问。它们可以用来包含公共功能，而不是在每个默认方法中重复。私有方法无法从接口外部访问。
- en: With that, we can now reach the summit of Java basics complexity. After this,
    and all the way to the end of the book, we will only be adding some details and
    building up your programming skills. It will be a walk on a high altitude plateau
    - the longer you walk, the more comfortable you feel. But, to get to that height,
    we need to climb the last uphill pitch; inheritance.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以达到Java基础知识的高峰。在此之后，直到本书的结尾，我们只会添加一些细节并增强您的编程技能。这将是在高海拔高原上的一次漫步-您走得越久，就会感到越舒适。但是，要到达那个高度，我们需要爬上最后的上坡路；继承。
- en: Inheritance
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'A class can acquire (inherit) all the non-private non-static members, so that
    when we use the object of this class, we cannot have any idea where these members
    actually reside – in this class or in the class from which they were inherited.
    To indicate inheritance, the keyword `extends` is used. For example, consider
    the following classes:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以获取（继承）所有非私有非静态成员，因此当我们使用这个类的对象时，我们无法知道这些成员实际上位于哪里-在这个类中还是在继承它们的类中。为了表示继承，使用关键字`extends`。例如，考虑以下类：
- en: '```java'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A {
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: private void m1(){...}
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: private void m1(){...}
- en: public void m2(){...}
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: public void m2(){...}
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class B extends class A {
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends class A {
- en: public void m3(){...}
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: public void m3(){...}
- en: '}'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class C extends class B {
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: class C extends class B {
- en: '}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this example, the objects of classes `B` and `C` behave as if each of them
    has methods `m2()` and `m3()`. The only limitation is that a class can extend
    one class only. Class `A` is a base (or parent) class for both class `B` and class
    `C`. Class `B` is a base class for class `C` only. And, as we have mentioned already,
    each of them has the default base class `java.lang.Object`. Classes `B` and `C`
    are subclasses of class `A`. Class `C` is also a subclass of class `B`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类`B`和`C`的对象的行为就好像它们各自有方法`m2()`和`m3()`。唯一的限制是一个类只能扩展一个类。类`A`是类`B`和类`C`的基类。类`B`只是类`C`的基类。正如我们已经提到的，它们每个都有默认的基类`java.lang.Object`。类`B`和`C`是类`A`的子类。类`C`也是类`B`的子类。
- en: 'By contrast, an interface can extend to many other interfaces at the same time.
    If `AI`, `BI`, `CI`, `DI`, `EI`, and `FI` are interfaces, then the following is
    allowed:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个接口可以同时扩展许多其他接口。如果`AI`，`BI`，`CI`，`DI`，`EI`和`FI`是接口，那么允许以下操作：
- en: '```java'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface AI extends BI, CI, DI {
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 接口AI扩展BI，CI，DI {
- en: //the interface body
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: //接口主体
- en: '}'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DI extends EI, FI {
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 接口DI扩展EI，FI {
- en: //the interface body
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: //接口主体
- en: '}'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding example, the interface `AI` inherits all the non-private non-static
    signatures of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`, and any other interfaces
    that are base interfaces of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，接口`AI`继承了接口`BI`，`CI`，`DI`，`EI`和`FI`的所有非私有非静态签名，以及任何其他是接口`BI`，`CI`，`DI`，`EI`和`FI`的基接口。
- en: 'Coming back to the topic of the previous section, *Implementation*, a class
    can implement many interfaces:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上一节的话题，*实现*，一个类可以实现多个接口：
- en: '```java'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A extends B implements AI, BI, CI, DI {
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 类A扩展B实现AI，BI，CI，DI {
- en: //the class body
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: //类主体
- en: '}'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This means that class `A` inherits all non-private non-static members of class
    `B` and implements the interfaces `AI`, `BI`, `CI`, and `DI`, as well as their
    base interfaces. The ability to implement multiple interfaces comes from the fact
    that the preceding example would have exactly the same result if re-written like
    this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类`A`继承了类`B`的所有非私有非静态成员，并实现了接口`AI`，`BI`，`CI`和`DI`，以及它们的基接口。实现多个接口的能力来自于前面的例子，如果重写成这样，结果将完全相同：
- en: '```java'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface AI extends BI, CI, DI {
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 接口AI扩展BI，CI，DI {
- en: //the interface body
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: //接口主体
- en: '}'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class A extends B implements AI {
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 类A扩展B实现AI {
- en: //the class body
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: //类主体
- en: '}'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `extended` interface (class) is also called superinterface (superclass)
    or parent interface (parent class). The extending interface (class) is called
    a child interface (child class) or subinterface (subclass).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`扩展`接口（类）也称为超级接口（超类）或父接口（父类）。扩展接口（类）称为子接口（子类）或子接口（子类）。'
- en: 'Let''s illustrate this with examples. We start with an interface inheritance:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用例子来说明这一点。我们从接口继承开始：
- en: '```java'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface Vehicle {
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 接口车辆 {
- en: double getWeightInPounds();
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: double getWeightInPounds();
- en: '}'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface Car extends Vehicle {
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 接口Car扩展车辆 {
- en: int getPassengersCount();
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: int getPassengersCount();
- en: '}'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl implements Car {
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl实现Car {
- en: public double getWeightInPounds(){
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 2000d;
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: return 2000d;
- en: '}'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getPassengersCount(){
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: public int getPassengersCount(){
- en: return 4;
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The class `CarImpl` in the preceding code must implement both signatures (listed
    in the interface `Vehicle` and in the interface `Car`), because from its perspective
    they both belong to the interface `Car`. Otherwise, a compiler will complain,
    or class `CarImpl` has to be declared abstract (and cannot be instantiated).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，类`CarImpl`必须实现两个签名（列在接口`Vehicle`和接口`Car`中），因为从它的角度来看，它们都属于接口`Car`。否则，编译器会抱怨，或者类`CarImpl`必须声明为抽象的（不能被实例化）。
- en: 'Now, let us look at another example:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看另一个例子：
- en: '```java'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface Vehicle {
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 接口车辆 {
- en: double getWeightInPounds();
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: double getWeightInPounds();
- en: '}'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class VehicleImpl implements Vehicle {
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: public class VehicleImpl实现车辆 {
- en: public double getWeightInPounds(){
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 2000d;
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: return 2000d;
- en: '}'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface Car extends Vehicle {
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 接口Car扩展车辆 {
- en: int getPassengersCount();
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: int getPassengersCount();
- en: '}'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl extends VehicleImpl implements Car {
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl扩展VehicleImpl实现Car {
- en: public int getPassengersCount(){
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: public int getPassengersCount(){
- en: return 4;
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this example, the class `CarImpl` does not need to implement the abstract
    method `getWeightInPounds()` because it has inherited the implementation from
    the base class `VehicleImpl`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类`CarImpl`不需要实现`getWeightInPounds()`的抽象方法，因为它已经从基类`VehicleImpl`继承了实现。
- en: 'One consequence of the described class inheritance is usually not intuitive
    for a beginner. To demonstrate it, let us add the method `getWeightInPounds()`
    to the class `CarImpl`:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 所述类继承的一个后果通常对于初学者来说并不直观。为了证明这一点，让我们在类`CarImpl`中添加方法`getWeightInPounds()`：
- en: '```java'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class VehicleImpl {
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: public class VehicleImpl {
- en: public double getWeightInPounds(){
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 2000d;
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: return 2000d;
- en: '}'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class CarImpl extends VehicleImpl {
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: public class CarImpl扩展VehicleImpl {
- en: public double getWeightInPounds(){
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: public double getWeightInPounds(){
- en: return 3000d;
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: return 3000d;
- en: '}'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getPassengersCount(){
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: public int getPassengersCount(){
- en: return 4;
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: return 4;
- en: '}'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In this example, we do not use interfaces, for simplicity. Because the class
    `CarImpl` is a child of the class `VehicleImpl`, it can behave as an object of
    class `VehicleImpl` and this code will compile just fine:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为了简单起见，我们不使用接口。因为类`CarImpl`是类`VehicleImpl`的子类，它可以作为类`VehicleImpl`的对象行为，这段代码将编译得很好：
- en: '```java'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: VehicleImpl vehicle = new CarImpl();
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: VehicleImpl vehicle = new CarImpl();
- en: vehicle.getWeightInPounds();
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: vehicle.getWeightInPounds();
- en: '```'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The question is, what value do you expect to be returned in the second line
    of the preceding snippet? If you guessed 3,000, you are correct. If not, do not
    feel embarrassed. It takes time to get used to it. The rule is that the reference
    of a base class type can refer to an object of any of its children. It is widely
    used for overriding base class behaviors.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，你期望在前面片段的第二行中返回什么值？如果你猜测是3,000，你是正确的。如果不是，不要感到尴尬。习惯需要时间。规则是，基类类型的引用可以引用其任何子类的对象。它被广泛用于覆盖基类行为。
- en: The summit is close. Only one step is left, although it brings something that
    you probably won't have expected if you did not know anything about Java before
    reading this book.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 峰会就在眼前。只剩下一步了，尽管它带来了一些你在读这本书之前可能没有预料到的东西，如果你对Java一无所知。
- en: The java.lang.Object class
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: java.lang.Object类
- en: So, here is a surprise. Each Java class, by default (without an explicit declaration),
    extends the class `Object`. To be precise, it is `java.lang.Object`, but we have
    not introduced packages yet and will only be talking about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages
    and Accessibility (Visibility)*.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里有一个惊喜。每个Java类，默认情况下（没有显式声明），都扩展了`Object`类。准确地说，它是`java.lang.Object`，但我们还没有介绍包，只会在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中讨论它们，*包和可访问性（可见性）*。
- en: 'All Java objects inherit all the methods from it. There are ten of them:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Java对象都继承了它的所有方法。共有十个：
- en: '`public boolean equals (Object obj)`'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean equals (Object obj)`'
- en: '`public int hashCode()`'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int hashCode()`'
- en: '`public Class getClass()`'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Class getClass()`'
- en: '`public String toString()`'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String toString()`'
- en: '`protected Object clone()`'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected Object clone()`'
- en: '`public void wait()`'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait()`'
- en: '`public void wait(long timeout)`'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait(long timeout)`'
- en: '`public void wait(long timeout, int nanos)`'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void wait(long timeout, int nanos)`'
- en: '`public void notify()`'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void notify()`'
- en: '`public void notifyAll()`'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void notifyAll()`'
- en: Let's briefly visit each of these methods.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地访问每个方法。
- en: Before we do that, we would like to mention that you can override their default
    behavior in your classes, and re-implement them any way you need, which programmers
    often do. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们想提一下，你可以在你的类中重写它们的默认行为，并以任何你需要的方式重新实现它们，程序员经常这样做。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中解释如何做到这一点，*接口、类和对象构造*。
- en: The equals() method
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: equals()方法
- en: 'The method `equals()` of the `java.lang.Object` class looks like this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object`类的`equals()`方法看起来是这样的：'
- en: '```java'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean equals(Object obj) {
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object obj) {
- en: //compares references of the current object
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: //比较当前对象的引用
- en: //and the reference obj
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: //和引用对象
- en: '}'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here is an example of its usage:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用示例：
- en: '```java'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Car car1 = new CarImpl();
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: Car car1 = new CarImpl();
- en: Car car2 = car1;
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: Car car2 = car1;
- en: Car car3 = new CarImpl();
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: Car car3 = new CarImpl();
- en: car1.equals(car2);    //returns true
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: car1.equals(car2);    //返回true
- en: car1.equals(car3);    //returns false
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: car1.equals(car3);    //返回false
- en: '```'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see from the preceding example, the implementation of the default
    method `equals()` compares only memory references that point to the addresses
    where the objects are stored. That is why the references `car1` and `car2` are
    equal – because they point to the same object (same area of the memory, same address),
    while the `car3` reference points to another object.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，默认方法`equals()`的实现只比较指向存储对象的地址的内存引用。这就是为什么引用`car1`和`car2`是相等的——因为它们指向同一个对象（内存的相同区域，相同的地址），而`car3`引用指向另一个对象。
- en: A typical re-implementation of the `equals()` method uses an object's state
    for comparison instead. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals()`方法的典型重新实现使用对象的状态进行比较。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中解释如何做到这一点，*接口、类和对象构造*。'
- en: The hashCode() method
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`hashCode()`方法'
- en: 'The `hashCode()` method of the `java.lang.Object` class looks like this:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object`类的`hashCode()`方法看起来是这样的：'
- en: '```java'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public int hashCode(){
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: public int hashCode(){
- en: //returns a hash code value for the object
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: //返回对象的哈希码值
- en: //based on the integer representation of the memory address
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: //基于内存地址的整数表示
- en: '}'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The Oracle documentation states that, if two methods are the same according
    to the default behavior of the `equals()` method described previously, then they
    have the same `hashCode()` return value. Which is great! But unfortunately, the
    same document states that it is possible that two different (according to the
    `equals()` method) objects can have the same `hasCode()` return value. That is
    why programmers prefer to re-implement the `hashCode()` method and use it while
    re-implementing the `equals()` method instead of using the object state. The need
    to do it does not arise very often though, and we are not going into the details
    of such an implementation. If interested, you can find good articles about it
    on the internet.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle文档指出，如果两个方法根据`equals()`方法的默认行为是相同的，那么它们具有相同的`hashCode()`返回值。这很棒！但不幸的是，同一份文档指出，根据`equals()`方法，两个不同的对象可能具有相同的`hasCode()`返回值。这就是为什么程序员更喜欢重新实现`hashCode()`方法，并在重新实现`equals()`方法时使用它，而不是使用对象状态。尽管这种需要并不经常出现，我们不会详细介绍这种实现的细节。如果感兴趣，你可以在互联网上找到很好的文章。
- en: The getClass() method
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getClass()`方法'
- en: 'The `getClass()` method of the `java.lang.Object` class looks like this:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object`类的`getClass()`方法看起来是这样的：'
- en: '```java'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public Class getClass(){
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: public Class getClass(){
- en: //returns object of class Class that has
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: //返回具有的Class类的对象
- en: //many methods that provide useful information
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: //提供有用信息的许多方法
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The most commonly used piece of information from this method is the name of
    the class that was the template for the current object. We will get into why one
    may need it in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction**.* The name of the class can be accessed via
    the object of the class `Class`, returned by this method.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个方法中最常用的信息是作为当前对象模板的类的名称。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中讨论为什么可能需要它，*接口、类和对象构造**.*可以通过这个方法返回的`Class`类的对象来访问类的名称。
- en: The toString() method
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`toString()`方法'
- en: 'The `toString()` method of the `java.lang.Object` class looks like this:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object`类的`toString()`方法看起来像这样：'
- en: '```java'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public String toString(){
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString(){
- en: //return string representation of the object
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: //返回对象的字符串表示
- en: '}'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This method is typically used to print the content of the object. Its default
    implementation looks like this:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法通常用于打印对象的内容。它的默认实现看起来像这样：
- en: '```java'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public String toString() {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return getClass().getName()+"@"+Integer.toHexString(hashCode());
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: return getClass().getName()+"@"+Integer.toHexString(hashCode());
- en: '}'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, it is not very informative, so programmers re-implement it in
    their classes. This is the most commonly re-implemented method of the class `Object`.
    Programmers practically do it for each of their classes. We will explain more
    about the `String` class and its methods in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements.*
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它并不是非常具有信息性，所以程序员们会在他们的类中重新实现它。这是类`Object`中最常重新实现的方法。程序员们几乎为他们的每个类都这样做。我们将在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中更详细地解释`String`类及其方法，*运算符、表达式和语句*。
- en: The clone() method
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`clone()`方法'
- en: 'The `clone()` method of the `java.lang.Object` class looks like this:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object`类的`clone()`方法看起来像这样：'
- en: '```java'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: protected Object clone(){
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: protected Object clone(){
- en: //creates copy of the object
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: //创建对象的副本
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The default result of this method returns a copy of the object fields as-is,
    which is fine if the values are not an object reference. Such values are called
    **primitive type**, which we will define precisely in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types.* But if an object field holds a reference to
    another object, only the reference itself will be copied, not the referred object
    itself. That is why such a copy is called a shallow one. To get a deep copy, one
    has to re-implement the `clone()` method and follow all the references of the
    tree of objects that can be quite a widespread. Fortunately, the `clone()` method
    is not used very often. In fact, you may never encounter a need to use it.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的默认结果返回对象字段的副本，这是可以接受的，如果值不是对象引用。这样的值被称为**原始类型**，我们将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中精确定义，*Java语言元素和类型*。但是，如果对象字段持有对另一个对象的引用，那么只有引用本身会被复制，而不是引用的对象本身。这就是为什么这样的副本被称为浅层副本。要获得深层副本，必须重新实现`clone()`方法，并遵循可能相当广泛的对象树的所有引用。幸运的是，`clone()`方法并不经常使用。事实上，你可能永远不会遇到需要使用它的情况。
- en: While reading this, you may wonder, what happens to an object when it is used
    as a method parameter. Is it passed inside the method as a copy using the `clone()`
    method? If so, is it passed as a shallow or a deep copy? The answer is, neither.
    Only a reference to the object is passed in as the parameter value, so all the
    methods that receive the same object reference can access the same area of the
    memory where the object state is stored.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本文时，你可能会想知道，当对象被用作方法参数时会发生什么。它是使用`clone()`方法作为副本传递到方法中的吗？如果是，它是作为浅层副本还是深层副本传递的？答案是，都不是。只有对象的引用作为参数值传递进来，所以所有接收相同对象引用的方法都可以访问存储对象状态的内存区域。
- en: This presents a potential risk for unexpected data modification and subsequent
    data corruption – bringing them to an inconsistent state. That is why, while passing
    around an object, programmers have to always be aware that they are accessing
    values that may be shared across other methods and classes. We will talk more
    about this in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types* and expand on it in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection* while talking about threads and concurrent processing
    in general.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这为意外数据修改和随后的数据损坏带来了潜在风险，将它们带入不一致的状态。这就是为什么，在传递对象时，程序员必须始终意识到他们正在访问可能在其他方法和类之间共享的值。我们将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中更详细地讨论这一点，并在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)中扩展这一点，*JVM进程和垃圾回收*，在讨论线程和并发处理时。
- en: The wait() and notify() methods
  id: totrans-799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The wait() and notify() methods
- en: The `wait(),` and `notify()` methods and their overloaded versions are used
    for communication between threads—the lightweight processes for concurrent processing. Programmers
    do not re-implement these methods. They just use them to increase the throughput
    and performance of their applications. We will go into more details about the `wait()`
    and `notify()` methods in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml),
    *JVM Processes and Garbage Collection*.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()`和`notify()`方法及其重载版本用于线程之间的通信——轻量级的并发处理进程。程序员们不会重新实现这些方法。他们只是用它们来增加应用程序的吞吐量和性能。我们将在[第11章](e8c37d86-291d-4500-84ea-719683172477.xhtml)中更详细地讨论`wait()`和`notify()`方法，*JVM进程和垃圾回收*。'
- en: Now, congratulations are in order. You have stepped on the summit of Java basics
    complexity and will now continue walking horizontally, adding details and practicing
    the acquired knowledge. You have constructed in your head a framework of Java
    knowledge while reading the first two chapters. Don't feel frustrated if not everything
    is clear of if you forget something. Keep reading, and you will have many opportunities
    to refresh your knowledge, extend it, and retain it for a longer run. It is going
    to be an interesting journey with a nice reward at the final destination.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，恭喜你。你已经踏上了Java基础复杂性的高峰，现在将继续水平前行，添加细节并练习所学知识。在阅读前两章的过程中，你已经在脑海中构建了Java知识的框架。如果有些东西不清楚或者忘记了，不要感到沮丧。继续阅读，你将有很多机会来刷新你的知识，扩展它，并保持更长时间。这将是一段有趣的旅程，最终会有一个不错的奖励。
- en: OOP concepts
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程概念
- en: 'Now, we can talk about concepts that will make more sense to you, compared
    to presenting them before you learned the main terminology and saw the code examples.
    These concepts are:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以谈论一些对你来说更有意义的概念，与在你学习主要术语并看到代码示例之前相比。这些概念包括：
- en: 'Object/class: This keeps the state and behavior together'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象/类：它将状态和行为保持在一起
- en: 'Encapsulation: It hides the state and details of the implementation'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装：它隐藏了状态和实现的细节
- en: 'Inheritance: It propagates behavior/signatures down the chain of class/interface
    extensions'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承：它将行为/签名传播到类/接口扩展链中
- en: 'Interface: It isolates signatures from their implementations'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口：它将签名与实现隔离开来
- en: 'Polymorphism: This allows an object to be represented by multiple implemented
    interfaces and any of the base classes, including `java.lang.Object`.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态：这允许一个对象由多个实现的接口和任何基类表示，包括`java.lang.Object`。
- en: By now, you are familiar with all of the above, so this is going to be mostly
    a summary, adding only a few details. That's how we learn – from observing specific
    facts, building a bigger picture, and improving that picture as new observations
    come in. We do it all the time, don't we?
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经熟悉了上述所有内容，因此这将主要是一个总结，只添加一些细节。这就是我们学习的方式——观察特定事实，构建更大的图景，并随着新的观察不断改进这个图景。我们一直在做这件事，不是吗？
- en: Object/class
  id: totrans-810
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象/类
- en: A Java program and an entire application can be written without creating a single
    object. Just use the `static` keyword in front of every method and every field
    of a class you are creating and call them from the static `main()` method. You
    will be limited in your programming capabilities. You will not be able to create
    an army of objects that can work in parallel doing a similar job on their own
    copy of data, for example. But your application will still work.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java程序和整个应用程序可以在不创建一个对象的情况下编写。只需在你创建的每个类的每个方法和每个字段前面使用`static`关键字，并从静态的`main()`方法中调用它们。你的编程能力将受到限制。你将无法创建一支可以并行工作的对象军队，他们可以在自己的数据副本上做类似的工作。但你的应用程序仍然可以工作。
- en: Besides, in Java 8,  functional programming features were added that allow us
    to pass around functions the same way an object can be passed. So, your object-less
    application could be quite capable. And several languages without object creating
    capabilities were used very effectively. Yet, after object-oriented languages
    proved to be useful and became popular, the first being Smalltalk, several traditionally
    procedural languages—PHP, Perl, Visual Basic, COBOL 2002, Fortran 2003, and Pascal,
    to name a few—added object-oriented capabilities.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Java 8中，添加了函数式编程特性，允许我们像传递对象一样传递函数。因此，你的无对象应用程序可能会非常强大。而且，一些没有对象创建能力的语言被使用得非常有效。然而，在面向对象的语言被证明有用并变得流行之后，第一个是Smalltalk，一些传统的过程式语言，如PHP、Perl、Visual
    Basic、COBOL 2002、Fortran 2003和Pascal等，都添加了面向对象的能力。
- en: As we just mentioned, Java also extended its features into covering functional
    programming, thus blurring the borders between procedural, object-oriented, and
    functional languages. Yet, the presence of classes and the ability to use them
    to create objects is the first of the concepts that a programming language must
    support in order to be classified as object-oriented.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，Java还将其功能扩展到覆盖函数式编程，从而模糊了过程式、面向对象和函数式语言之间的界限。然而，类的存在和使用它们来创建对象的能力是编程语言必须支持的第一个概念，才能被归类为面向对象。
- en: Encapsulation
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation—the ability to make data and functions (methods) inaccessible
    from outside or have controlled access—was one of the primary drivers for creating
    object-oriented languages. Smalltalk was created on the idea of messages passing
    between objects, which is done in both Smalltalk and Java when one object calls
    a method on another object.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 封装——使数据和函数（方法）无法从外部访问或者有受控的访问——是创建面向对象语言的主要驱动因素之一。Smalltalk是基于对象之间的消息传递的想法创建的，当一个对象调用另一个对象的方法时，这在Smalltalk和Java中都是这样做的。
- en: Encapsulation allows invocation of services of an object without knowing how
    those services are implemented. It reduces the software's system complexity and
    increases its maintainability. Each object does its job without the need to coordinate
    the changes in the implementation with its clients, so long as it does not violate
    the contract that is captured in the interface.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 封装允许调用对象的服务，而不知道这些服务是如何实现的。它减少了软件系统的复杂性，增加了可维护性。每个对象都可以独立地完成其工作，而无需与其客户端协调实现的更改，只要它不违反接口中捕获的合同。
- en: We will discuss encapsulation in further detail in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中进一步详细讨论封装，*包和可访问性（可见性）*。
- en: Inheritance
  id: totrans-818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is another OOP concept supported by every object-oriented language.
    It is usually described as the ability to reuse the code, which is a true but
    often misunderstood statement. Some programmers assume that inheritance claims
    to be able to reuse code *between applications*. In our experience, code reusability
    between applications can be accomplished without inheritance and is more dependent
    on the functional similarity between applications than the particular programming
    language feature. It is more related to the skill of the extracting common code
    into a shared reusable library than anything else.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是另一个面向对象编程概念，受到每种面向对象语言的支持。通常被描述为能够重用代码的能力，这是一个真实但经常被误解的说法。一些程序员认为继承能够在应用程序之间实现代码的重用。根据我们的经验，应用程序之间的代码重用可以在没有继承的情况下实现，并且更多地依赖于应用程序之间的功能相似性，而不是特定的编程语言特性。这更多地与将通用代码提取到共享可重用库中的技能有关。
- en: In Java, or any other object-oriented language, inheritance allows the reuse
    of common functionality, implemented in a base class, *across its children*. It
    can be used for bringing modularity and improving code reusability across applications
    by assembling base classes into a common shared library. But in practice, such
    an approach is rarely used because each application usually has such particular
    requirements that a common base class is either too simplistic and effectively
    useless or carries many methods specific to each of the applications. Besides,
    in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces, Classes,
    and Objects Construction*, we will show that reusability is much easier achieved
    using an aggregation, which is based on using independent objects instead of inheritance.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java或任何其他面向对象的语言中，继承允许在基类中实现的公共功能*在其子类中重用*。它可以用于通过将基类组装到一个共享的库中，实现模块化并提高代码的可重用性。但在实践中，这种方法很少被使用，因为每个应用程序通常具有特定的要求，一个共同的基类要么太简单而实际上无用，要么包含许多特定于每个应用程序的方法。此外，在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)《接口、类和对象构造》中，我们将展示，使用聚合更容易实现可重用性，这是基于使用独立对象而不是继承。
- en: Together with an interface, inheritance makes polymorphism possible.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口一起，继承使多态成为可能。
- en: Interface (abstraction)
  id: totrans-822
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口（抽象）
- en: Sometimes OOP concept of an interface is also called abstraction because an
    interface summarizes (abstracts) the public description of an object behavior
    from the details of its implementation and hides (abstracts) it. An interface
    is an integral part of an encapsulation and polymorphism, but important enough
    to be stated as a separate concept. Its significance will become especially apparent
    in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented Design
    (OOD)* *P**rinciples*, when we discuss the transition from a project idea and
    vision to the specific programming solution.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，接口的面向对象编程概念也被称为抽象，因为接口总结（抽象）了对象行为的公共描述，隐藏了其实现的细节。接口是封装和多态的一个组成部分，但足够重要，以至于被作为一个单独的概念来阐述。其重要性将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)《面向对象设计（OOD）原则》中变得特别明显，当我们讨论从项目想法和愿景到具体编程解决方案的过渡时。
- en: Interface and inheritance provide the foundation for polymorphism.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和继承为多态提供了基础。
- en: Polymorphism
  id: totrans-825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: From the code examples we have provided, you have probably already realized
    that an object has all the methods that are listed in the implemented interfaces
    and all the non-private non-static methods of its base classes, including `java.lang.Object`.
    Like a person with many citizenships, it can pass as an object of any of its base
    classes or implemented interfaces. This language capability is called a polymorphism
    (from *poly* – many and *morphos* – form).
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们提供的代码示例中，您可能已经意识到，一个对象具有所有实现的接口中列出的方法和其基类的所有非私有非静态方法，包括`java.lang.Object`。就像一个拥有多重国籍的人一样，它可以被视为其基类或实现的接口的对象。这种语言能力被称为多态（来自*poly*
    - 许多和*morphos* - 形式）。
- en: Please note that in broad terms, method overloading—when a method with the same
    name can have different behavior depending on its signature—exhibits polymorphic
    behavior too.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，广义上讲，方法重载——当具有相同名称的方法根据其签名可以具有不同行为时——也表现出多态行为。
- en: Exercise – Interface versus abstract class
  id: totrans-828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-接口与抽象类
- en: What is the difference between an interface and an abstract class? We did not
    talk about it, so you will need to do some research.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和抽象类之间有什么区别？我们没有讨论过，所以您需要进行一些研究。
- en: After the default methods of interfaces were introduced in Java 8, the difference
    shrunk significantly, and is negligible in many cases.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中引入接口的默认方法后，差异显著缩小，在许多情况下可以忽略不计。
- en: Answer
  id: totrans-831
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: An abstract class can have a constructor, while an interface cannot.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以有构造函数，而接口不能。
- en: An abstract class can have a state, while an interface cannot. The fields of
    an abstract class can be private and protected, while in an interface, fields
    are public, static, and final.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以有状态，而接口不能。抽象类的字段可以是私有的和受保护的，而在接口中，字段是公共的、静态的和最终的。
- en: An abstract class can have method implementation with any access modifiers,
    while implemented default methods in an interface are public only.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以具有任何访问修饰符的方法实现，而接口中实现的默认方法只能是public。
- en: If the class you would like to amend extends to another class already, you cannot
    use an abstract class, but you can implement an interface, because a class can
    extend to only one other class but can implement multiple interfaces.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要修改的类已经扩展到另一个类，您就不能使用抽象类，但是您可以实现一个接口，因为一个类只能扩展到另一个类，但可以实现多个接口。
- en: Summary
  id: totrans-836
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the foundational concepts of Java and of any
    object-oriented programming language. You now have an understanding of classes
    and objects as the basic building blocks of Java, know what static and instance
    members are, and know about interface, implementation, and inheritance. That was
    the most complex and challenging exercise of this beginner chapter, and brought
    the reader to the core of Java language, introducing the language framework we
    are going to use throughout the rest of the book. The exercise allowed the reader
    to get exposure to the discussion about the differences between an interface and
    an abstract class, which has become much narrower after Java 8's release.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了Java和任何面向对象编程语言的基本概念。您现在了解了类和对象作为Java的基本构建模块，知道了静态和实例成员是什么，以及了解了接口、实现和继承。这是本初学者章节中最复杂和具有挑战性的练习，将读者带到了Java语言的核心，介绍了我们将在本书的其余部分中使用的语言框架。这个练习让读者接触到了关于接口和抽象类之间差异的讨论，这在Java
    8发布后变得更加狭窄。
- en: In the next chapter, we will turn to practical matters of programming. The reader
    will be guided through the concrete steps of installing the necessary tools and
    configuring the development environment on their computer. After that, all the
    new ideas and software solutions will be demonstrated, with specific code examples.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向编程的实际问题。读者将被引导完成在他们的计算机上安装必要工具和配置开发环境的具体步骤。之后，所有新的想法和软件解决方案将被演示，包括具体的代码示例。
