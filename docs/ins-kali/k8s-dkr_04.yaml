- en: '*Chapter 3*: Understanding Docker Networking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：理解Docker网络'
- en: So far, we have focused on how to access a container when we are local on the
    host system. There are use cases where local container access is all that may
    be required, but often, you will want to expose your containers to external users
    or systems. Exposing your containers to external users is not always as simple
    as just running a container. You will need to consider various options that Docker
    offers to connect your containers to the network. To avoid frustration, you should
    also understand how systems communicate using IP, including any limitations in
    regard to exposing IP ports.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于在主机系统上本地访问容器的方法。有些情况下，只需要本地容器访问，但通常情况下，您会希望将容器暴露给外部用户或系统。将容器暴露给外部用户并不总是简单地运行一个容器。您需要考虑Docker提供的各种选项，以连接您的容器到网络。为了避免挫折，您还应该了解系统如何使用IP进行通信，包括在暴露IP端口方面的任何限制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring Docker networking
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Docker网络
- en: Creating user-defined bridge networks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户定义的桥接网络
- en: Let's get started!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not have any technical requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有任何技术要求。
- en: If you want to create networks using the examples in this chapter, you can use
    the Docker host that we created in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*. The networks that we'll be using for the examples
    in this chapter are not required for future chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用本章中的示例创建网络，可以使用我们在[*第1章*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018)中创建的Docker主机，*Docker和容器基础*。本章中将使用的网络对于未来的章节并非必需。
- en: 'You can access the code to create a Docker host from [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Containers Essentials* by going to the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[*第1章*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018)中创建Docker主机的代码，*Docker和容器基础*，访问以下GitHub存储库：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: Exploring Docker networking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Docker网络
- en: In this section, we will discuss the networking options that are available in
    Docker and how you can use them to expose your containers to external users and
    systems. Docker includes various networking options to connect containers to your
    network, and if none of the included networking options fit your requirements,
    you can select from a number of third-party networking add-ons that offer features
    that may not be included in the base networking stack. By default, Docker networking
    focuses on a single host, but for more complex use cases, it includes networking
    features to facilitate cross-host networking by using Docker Swarm. Since the
    industry has moved away from using Docker Swarm to other offerings such as Kubernetes,
    this chapter will focus on single-host networking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Docker中可用的网络选项以及如何使用它们将您的容器暴露给外部用户和系统。Docker包括各种网络选项，以连接容器到您的网络，如果没有包括的网络选项符合您的要求，您可以从许多第三方网络附加组件中进行选择，这些组件提供了基本网络堆栈中可能不包括的功能。默认情况下，Docker网络侧重于单个主机，但对于更复杂的用例，它包括网络功能，通过使用Docker
    Swarm来促进跨主机网络。由于行业已经摆脱了使用Docker Swarm转向其他提供，如Kubernetes，本章将专注于单主机网络。
- en: To avoid potential frustration when you expose containers, you should have a
    good understanding of how IP uses ports for communication. Many of you may know
    IP well, but we thought it would be beneficial to provide a short refresher on
    how TCP/IP uses ports to communicate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在暴露容器时可能出现的挫折，您应该对IP如何使用端口进行通信有很好的理解。你们中的许多人可能对IP很了解，但我们认为提供一个关于TCP/IP如何使用端口进行通信的简短复习会很有益处。
- en: A quick TCP/IP port refresher
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速TCP/IP端口复习
- en: We do assume that you have a working knowledge of TCP/IP, but for those of you
    who are new to this, it's important to highlight some networking topics that will
    be referenced in this chapter. Understanding ports is a vital concept to fully
    understand the limitations of exposing services in Docker.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您对TCP/IP有一定的了解，但对于那些对此还不熟悉的人来说，重点介绍一些网络主题是很重要的，因为这些主题将在本章中被引用。理解端口是一个至关重要的概念，以充分了解在Docker中暴露服务的限制。
- en: As you may know, when you configure IP on a system, you assign a unique IP address
    to each network adapter in the system. When an incoming or outgoing connection
    is made, the request includes the IP address and a port between **1** and **65535**.
    You may not always see the port in the request since many applications will automatically
    include it in the default request, based on the protocol being used. When you
    are in a browser and enter a URL, you usually just enter the URL using the protocol
    and hostname. As an example, let's say you want to open the main Kubernetes page,
    so you enter [http://kubernetes.io](http://kubernetes.io) in your browser. What
    is not shown or required is the port. HTTP has a default port of 80, and all browsers
    will default the request to use port **80** – behind the scenes, the browser is
    requesting [http://kubernetes.io:80](http://kubernetes.io:80).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能知道的那样，当您在系统上配置IP时，您会为系统中的每个网络适配器分配一个唯一的IP地址。当进行传入或传出连接时，请求包括IP地址和**1**到**65535**之间的端口。您可能在请求中并不总是看到端口，因为许多应用程序将根据所使用的协议自动包含在默认请求中。当您在浏览器中输入URL时，通常只需使用协议和主机名输入URL。例如，假设您想打开主Kubernetes页面，所以您在浏览器中输入[http://kubernetes.io](http://kubernetes.io)。不显示或不需要的是端口。HTTP的默认端口是80，所有浏览器都会默认请求使用端口**80**
    - 在幕后，浏览器正在请求[http://kubernetes.io:80](http://kubernetes.io:80)。
- en: 'This combination of the IP address and the port is called a socket, represented
    as **<IP address>:<port>** (that is, **192.168.1.1:443**). A socket is required
    for communication that occurs in both directions. When you request a web page,
    your computer will make an outgoing request using a port that is randomly selected
    from between **49152** and **65535**. This can be a little confusing if you are
    new to IP, so the following is an example of a connection from a workstation to
    two different web servers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址和端口的组合称为套接字，表示为**<IP地址>:<端口>**（即**192.168.1.1:443**）。套接字是双向通信所必需的。当您请求一个网页时，您的计算机将使用从**49152**到**65535**之间随机选择的端口进行传出请求。如果您对IP还不熟悉，这可能有点令人困惑，因此以下是一个从工作站到两个不同的Web服务器的连接示例：
- en: '![Figure 3.1 – Socket example'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 套接字示例'
- en: '](image/Fig_3.1_B15514.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.1_B15514.jpg)'
- en: Figure 3.1 – Socket example
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 套接字示例
- en: In *step 1*, a request is sent to a web server running on **192.168.100.10**
    from a workstation. The workstation uses a randomly generated port to initiate
    the outgoing request to the web server on port **80**. Next, in *step 2*, the
    web server replies to the client using the client IP **of 192.168.100.150** on
    port **49160**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，工作站向运行在**192.168.100.10**上的Web服务器发送请求。工作站使用随机生成的端口来启动到端口**80**的Web服务器的传出请求。接下来，在*步骤2*中，Web服务器使用客户端IP
    **192.168.100.150**和端口**49160**回复客户端。
- en: We added *step 3* to show that a simultaneous connection to another web server
    will generate a different outgoing port, targeting a second web server on port
    80.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了*步骤3*，以显示与另一个Web服务器的同时连接将生成不同的出站端口，从而针对端口80上的第二个Web服务器。
- en: Binding a port to a service
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将端口绑定到服务
- en: On the server side, where you may be running a server such as NGINX to host
    a website, you must bind a socket to the web server process. The bound IP address
    can be a single IP, or it can be bound to all the IP addresses by using an address
    of 0.0.0.0, which binds the port to all the available IP addresses on the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您可能正在运行像NGINX这样的服务器来托管网站，您必须将套接字绑定到Web服务器进程。绑定的IP地址可以是单个IP，也可以使用地址0.0.0.0绑定到所有可用的服务器IP地址上的所有IP地址。
- en: As an example, we will use a host with a single network card and a single IP
    address. When you want to bind a port to a process, you configure the process
    so that it uses the IP of the server and an assign a port of **80**. We want to
    highlight a key word in the last sentence, *bind* – by definition, to bind something
    is to tie or fasten tightly. When you bind a port to an IP address, it is exclusively
    bound and cannot be bound to any other running process using that IP address.
    In other words, since the socket has been tied, it cannot be tied to any other
    process on the host.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将使用具有单个网络卡和单个IP地址的主机。当您想要将端口绑定到进程时，您配置该进程以使用服务器的IP并分配端口**80**。我们想要强调上一句中的一个关键词，*绑定*
    - 根据定义，绑定某物是将其紧密地绑定或固定。当您将端口绑定到IP地址时，它是专门绑定的，并且不能绑定到使用该IP地址的任何其他运行中的进程。换句话说，由于套接字已被绑定，它不能绑定到主机上的任何其他进程。
- en: 'If you try to configure a process on a port that has been bound, you will receive
    an error similar to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试配置已绑定的端口上的进程，您将收到类似以下错误的消息：
- en: 'Bind for 192.168.1.1:443 failed: port is already allocated'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到192.168.1.1:443失败：端口已被分配。
- en: If you wanted to run another process on the host, you only need to specify a
    unique port. On the same server running NGINX, you could run a MySQL server running
    on port **3306**. Since the port is different from the web server running on port
    **80**, it creates a unique socket.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在主机上运行另一个进程，您只需要指定一个唯一的端口。在运行NGINX的同一台服务器上，您可以运行在端口**3306**上运行的MySQL服务器。由于该端口与在端口**80**上运行的Web服务器不同，因此它创建了一个唯一的套接字。
- en: How you expose a container using ports differs based on the Docker networking
    driver you are using for the container. In this chapter, we will explain the common
    networking options and how to configure and use each of them on your host. Once
    you understand these options, we will finish this chapter by looking at how to
    expose your containers to users outside the local host system using port assignments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端口公开容器的方式取决于您为容器使用的Docker网络驱动程序。在本章中，我们将解释常见的网络选项以及如何在主机上配置和使用每个选项。一旦您了解了这些选项，我们将通过查看如何使用端口分配将容器暴露给本地主机系统外的用户来完成本章。
- en: To begin, let's start by discussing the various network drivers that Docker
    includes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始讨论Docker包含的各种网络驱动程序。
- en: Docker networking drivers
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker网络驱动程序
- en: The networking system for Docker is modular. A base Docker installation includes
    a few network drivers and if you require a specialized networking driver, there
    are options available from other vendors. For the purpose of this book, we will
    only use the included networking drivers for our networks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的网络系统是模块化的。基本的Docker安装包括一些网络驱动程序，如果您需要专门的网络驱动程序，还可以从其他供应商那里获得选项。对于本书的目的，我们将仅使用网络的包含网络驱动程序。
- en: 'By default, you have the option of using five networking options. In reality,
    you have four options with a fifth option of none; that is, to disable networking.
    The options that are included with Docker are detailed in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您可以选择使用五种网络选项。实际上，您有四种选项，第五种选项是无; 也就是说，禁用网络。Docker包含的选项在下表中详细说明：
- en: '![Figure 3.2 – Docker networking drivers'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - Docker网络驱动程序
- en: '](image/Fig_3.1a_B15514.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.1a_B15514.jpg)'
- en: Figure 3.2 – Docker networking drivers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - Docker网络驱动程序
- en: 'A default Docker installation will include a few preconfigured networks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Docker安装将包括一些预配置的网络：
- en: A default bridge network
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认桥接网络
- en: A default host network
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认主机网络
- en: None
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: Most Docker users simply use the default bridge network, which will work for
    most use cases, but it does have some limitations that need to be considered.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Docker用户只是使用默认的桥接网络，这对大多数用例都有效，但它确实有一些需要考虑的限制。
- en: In this section, we will go over the default bridge network, a custom bridge
    network, and the no networking options. The host networking option is primarily
    used when your host is part of Docker Swarm, but it can be used without Swarm
    if you understand the limits of how ports are exposed when using it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍默认桥接网络、自定义桥接网络和无网络选项。主机网络选项主要用于当您的主机是Docker Swarm的一部分时使用，但如果您了解在使用它时端口暴露的限制，也可以在没有Swarm的情况下使用。
- en: The default bridge network
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认桥接网络
- en: In the preceding table, you learned that a bridge network only provides networking
    to containers running on the same Docker host. Unless you are running multiple
    Docker hosts by using Docker Swarm, you will usually use a bridged network with
    your Docker containers. When you install Docker, it will create what's known as
    the default Docker bridge network. By supplying the default bridge for all installations,
    Docker has made using a network in a container very simple. Many users simply
    start using Docker with the default networking settings and options, thereby starting
    up containers without knowing the limitations and potential security risks of
    the default bridge. Before using a Docker host, you should always consider creating
    a user-defined bridge, or multiple bridges, depending on your requirements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，您了解到桥接网络只为在同一Docker主机上运行的容器提供网络。除非您使用Docker Swarm运行多个Docker主机，否则通常会使用桥接网络与Docker容器一起使用。安装Docker时，它将创建所谓的默认Docker桥接网络。通过为所有安装提供默认桥接，Docker使得在容器中使用网络变得非常简单。许多用户只是开始使用默认的网络设置和选项来使用Docker，从而启动容器而不了解默认桥接的限制和潜在安全风险。在使用Docker主机之前，您应该始终考虑创建用户定义的桥接，或根据您的要求创建多个桥接。
- en: 'Docker includes an easy to use default network, so why should you consider
    creating a user-defined bridge? Since the default bridge maintains backward compatibility,
    many of the bridge features had to be limited. Due to these limitations, the default
    bridge is considered to be inferior compared to a user-defined bridge. While that
    may sound a little harsh, consider the following list, which details items to
    consider when using the default bridge:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker包含一个易于使用的默认网络，那么为什么要考虑创建用户定义的桥接？由于默认桥接保持向后兼容，许多桥接功能必须受到限制。由于这些限制，与用户定义的桥接相比，默认桥接被认为是较差的。虽然这听起来有点苛刻，但请考虑以下清单，其中详细说明了在使用默认桥接时需要考虑的事项：
- en: When a container is started **without** a network specified, it will use the
    default bridge. This means that multiple containers will be able to communicate
    by default, without any consideration being given to the workloads.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动一个容器时，如果没有指定网络，它将使用默认的桥接。这意味着多个容器默认情况下可以通信，而不需要考虑工作负载。
- en: '*Consider*: If you are running multiple containers and you want to isolate
    some containers from others, you may inadvertently allow communications between
    containers since they are using the default bridge.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*考虑*: 如果您运行多个容器，并且希望将某些容器与其他容器隔离开来，您可能会无意中允许容器之间的通信，因为它们使用默认桥接。'
- en: The default bridge limits communications between containers to IP addresses
    only. Containers connected to user-defined bridges can communicate using container
    names or IP addresses. Containers that use a user-defined bridge can communicate
    using IP addresses or host names.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认桥接限制容器之间的通信仅限于IP地址。连接到用户定义的桥接的容器可以使用容器名称或IP地址进行通信。使用用户定义的桥接的容器可以使用IP地址或主机名进行通信。
- en: '*Consider*: When you start up a container, the IP address may be different
    from the last time you ran the image.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*考虑*: 当您启动容器时，IP地址可能与上次运行镜像时不同。'
- en: If you wanted to configure an application that has multiple containers that
    interact, you can use the container names, which will remain constant through
    restarts. If you were using the default bridge, you may need to change the configuration
    files due the containers starting with a different IP address.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想配置一个具有多个相互作用的容器的应用程序，您可以使用容器名称，这些名称将在重新启动时保持不变。如果您使用默认桥接，您可能需要更改配置文件，因为容器以不同的IP地址启动。
- en: Containers that use the default bridge need to be stopped before you can move
    them to a different network. However, on a container using a user-defined switch,
    you can change the network without restarting the container.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认桥接的容器需要在将它们移动到不同网络之前停止。但是，在使用用户定义的桥接的容器上，您可以在不重新启动容器的情况下更改网络。
- en: '*Consider*: Depending on your workloads, you may not be able to stop a running
    container without an agreed maintenance window. While a networking change would
    still require a change request in most companies, it can be done without stopping
    the container if you are using a user-defined bridge. This will limit any potential
    impact to the application and offers a quick failback if something is misconfigured
    on the new network bridge.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*考虑*: 根据您的工作负载，您可能无法在没有约定的维护窗口的情况下停止运行的容器。虽然在大多数公司中，网络更改仍然需要更改请求，但如果您使用用户定义的桥接，则可以在不停止容器的情况下进行更改。这将限制对应用程序的任何潜在影响，并在新的网络桥接上配置错误时提供快速回退。'
- en: Using a single default bridge limits networking options for all containers.
    Since all the containers are on a single network, all networking settings are
    the same for all containers.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个默认桥接会限制所有容器的网络选项。由于所有容器都在单个网络上，所有容器的网络设置都相同。
- en: '*Consider*: You may have a requirement for some containers to run jumbo frames,
    while other containers will use a standard MTU size. If you only used the single
    default bridge, you can only set one MTU size. However, you could create a user-defined
    bridge that sets the MTU to 9000 and another that keeps the default MTU size of
    1500.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*考虑*: 您可能需要一些容器运行巨幅帧的要求，而其他容器将使用标准的MTU大小。如果您只使用单个默认桥接，您只能设置一个MTU大小。但是，您可以创建一个将MTU设置为9000的用户定义的桥接，另一个保持默认MTU大小为1500。'
- en: With this, you can see why we mentioned that the default bridge is inferior
    to a user-defined bridge. Depending on your use case, you may be able to use the
    default bridge for all your needs, and for the purposes of this book, we will
    use the default bridge for our exercises. However, in a production environment
    running Docker, you should **always** create a new user-defined bridge.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你就可以看到为什么我们提到默认桥接比用户定义的桥接差。根据您的用例，您可能可以将默认桥接用于您所有的需求，就本书而言，我们将使用默认桥接进行练习。然而，在运行Docker的生产环境中，您应该**始终**创建一个新的用户定义的桥接。
- en: Now that you know about the various networking options and the pros and cons
    of each type, it's time to dig into managing and creating Docker networks. Before
    we create a network, we'll take a look at the default networks that Docker includes
    by default and how to look at the details of a network using the Docker CLI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了各种网络选项以及每种类型的优缺点，是时候深入了解管理和创建Docker网络了。在创建网络之前，我们将查看Docker默认包含的默认网络以及如何使用Docker
    CLI查看网络的详细信息。
- en: Viewing the available networks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看可用网络
- en: 'To view all the existing networks on a Docker host, we can use the **network**
    management option in the Docker CLI with the **ls** option. When you execute a
    list of Docker networks, your output will look similar to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Docker主机上所有现有的网络，我们可以使用Docker CLI中的**network**管理选项和**ls**选项。当您执行Docker网络列表时，输出将类似于以下内容：
- en: '![Figure 3.3 – Default Docker network list'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 默认Docker网络列表'
- en: '](image/Fig_3.2_B15514.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.2_B15514.jpg)'
- en: Figure 3.3 – Default Docker network list
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 默认Docker网络列表
- en: The preceding list is from a base Docker installation, so only the three default
    networks options are available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的列表来自基本的Docker安装，因此只有三个默认网络选项可用。
- en: The **docker network ls** command does not contain a lot of information; it
    is meant to provide you with a quick summary of the available networks. To dig
    a little deeper into the details of a network, you can ask Docker to inspect the
    network, which will provide all the network settings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker network ls**命令不包含太多信息；它旨在为您提供可用网络的快速摘要。要深入了解网络的详细信息，您可以要求Docker检查网络，这将提供所有网络设置。'
- en: Retrieving details on a network
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索网络的详细信息
- en: 'Once you have created multiple user-defined networks, you may start to lose
    track of the settings for each network, or what containers are running on each
    network. You can look at the details of each network on the host using the **docker
    network inspect <network name>** option. The output from an **inspect** command
    contains detailed information about the network, including the subnet, gateway,
    driver type, and all connected containers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了多个用户定义的网络，您可能会开始迷失每个网络的设置，或者每个网络上运行的容器。您可以使用**docker network inspect <network
    name>**选项在主机上查看每个网络的详细信息。**inspect**命令的输出包含有关网络的详细信息，包括子网、网关、驱动类型以及所有连接的容器：
- en: '![Figure 3.4 – network inspect output'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 网络检查输出'
- en: '](image/Fig_3.3_B15514.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.3_B15514.jpg)'
- en: Figure 3.4 – network inspect output
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 网络检查输出
- en: 'The preceding screenshot shows that the network is a bridge, but we already
    know that from the **"Driver": "bridge"** section of the output. In the containers
    section of the output, you can see that the bridge has two containers attached
    to it. The first container is named **NGINX1** and has an IP address of **192.168.10.3**,
    while the second container is named **frontend** and has an IP address of **192.168.10.2**.
    The **inspect** command also shows the assigned MAC address for each container
    and, if enabled, the IPV6 address.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的截图显示网络是一个桥接网络，但我们已经从输出的**"Driver": "bridge"**部分知道了这一点。在输出的容器部分，您可以看到桥接网络有两个容器连接到它。第一个容器名为**NGINX1**，IP地址为**192.168.10.3**，而第二个容器名为**frontend**，IP地址为**192.168.10.2**。**inspect**命令还显示了每个容器的分配MAC地址，以及（如果启用）IPV6地址。'
- en: Now that you know how to keep track of the networks on the host, let's dive
    into user-defined bridges.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何跟踪主机上的网络了，让我们深入了解用户定义的桥接网络。
- en: Creating user-defined bridge networks
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户定义的桥接网络
- en: When you create a new user-defined network, you can supply most of the standard
    IP options that you would use when creating a new network outside of Docker. You
    can set options for the subnet, IP range, and gateway. Remember that the network
    you define here is only internal to your Docker host and that the IP addresses
    you assign will not be addressable outside the host. To read about more advanced
    options, you can visit the advanced Docker networking page at [https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options](https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新的用户定义网络时，您可以提供大多数标准IP选项，这些选项在Docker之外创建新网络时会使用。您可以为子网、IP范围和网关设置选项。请记住，您在这里定义的网络仅在您的Docker主机内部，并且您分配的IP地址将无法在主机外部寻址。要了解更多高级选项，请访问[https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options](https://docs.docker.com/engine/reference/commandline/network_create/#specify-advanced-options)上的高级Docker网络页面。
- en: 'To create a user-defined network, we use the **network management** option
    in the Docker CLI, along with the **create** option. The syntax is very simple;
    you only need to provide the desired network name for the new network and Docker
    will create the new network. To create a new network called frontend, we simply
    need to execute the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用户定义的网络，我们在Docker CLI中使用**网络管理**选项，以及**创建**选项。语法非常简单；您只需要为新网络提供所需的网络名称，Docker将创建新网络。要创建一个名为frontend的新网络，我们只需要执行以下命令：
- en: '![Figure 3.5 – Output from creating a Docker network'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 创建Docker网络的输出'
- en: '](image/Fig_3.4_B15514.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.4_B15514.jpg)'
- en: Figure 3.5 – Output from creating a Docker network
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 创建Docker网络的输出
- en: 'This will return the network ID. If you list the networks again, you will see
    a new bridge network is available:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回网络ID。如果您再次列出网络，您将看到一个新的桥接网络可用：
- en: '![Figure 3.6 – Docker network list'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – Docker网络列表'
- en: '](image/Fig_3.5_B15514.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.5_B15514.jpg)'
- en: Figure 3.6 – Docker network list
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – Docker网络列表
- en: Since we did not specify any options other than the network name, Docker will
    assign a non-overlapping IP range to the network.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们除了网络名称之外没有指定任何选项，Docker将为网络分配一个不重叠的IP范围。
- en: 'If you wanted to create a second network called backend that used the **192.168.10.0/24**
    subnet using a gateway of **192.168.10.1**, you just need to add **--subnet**
    and **--gateway** to the **docker network create** command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要创建一个名为backend的第二个网络，该网络使用**192.168.10.0/24**子网，网关为**192.168.10.1**，您只需要在**docker
    network create**命令中添加**--subnet**和**--gateway**：
- en: '![Figure 3.7 – Adding options example'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 添加选项示例'
- en: '](image/Fig_3.6_B15514.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.6_B15514.jpg)'
- en: Figure 3.7 – Adding options example
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 添加选项示例
- en: 'When you create a new network, like we did for the backend network example,
    Docker binds a new IP on the host equal to the gateway address we used in the
    **create** command. The following is the output of using **ip addr** on our host:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新网络，就像我们为后端网络示例所做的那样，Docker会在主机上绑定一个新的IP，该IP等于我们在**创建**命令中使用的网关地址。以下是在我们的主机上使用**ip
    addr**的输出：
- en: '![Figure 3.8 – Host IP added after network creation'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 在网络创建后添加主机IP'
- en: '](image/Fig_3.7_B15514.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.7_B15514.jpg)'
- en: Figure 3.8 – Host IP added after network creation
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 主机IP在网络创建后添加
- en: This will allow your host to route network traffic to any container that attaches
    to the switch. Containers can access network resources outside the host by using
    the hosts IP as the default gateway.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您的主机将网络流量路由到任何连接到交换机的容器。容器可以通过使用主机IP作为默认网关来访问主机外部的网络资源。
- en: Now that you have created a user-defined network, let's look at how to assign
    the new network to a container when running an image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个用户定义网络，让我们看看如何在运行镜像时将新网络分配给容器。
- en: Connecting a container to a user-defined network
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器连接到用户定义网络
- en: 'You can connect a container to a specific network when starting the container
    by adding the **--network** option to your **docker run** command. To attach a
    new NGINX container to the frontend network we created earlier, we only need to
    add **--network=frontend** when we start the container:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**docker run**命令中添加**--network**选项来在启动容器时将容器连接到特定网络。要将新的NGINX容器连接到我们之前创建的frontend网络，我们只需要在启动容器时添加**--network=frontend**：
- en: '![Figure 3.9 – Connecting a network at startup'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 在启动时连接网络'
- en: '](image/Fig_3.8_B15514.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.8_B15514.jpg)'
- en: Figure 3.9 – Connecting a network at startup
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 在启动时连接网络
- en: The preceding command will start a new NGINX container named frontend, on the
    user-defined network named **frontend**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在名为frontend的用户定义网络上启动一个新的NGINX容器。
- en: Changing the network on a running container
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改运行中容器的网络
- en: We mentioned that one advantage of using a user-defined network over the default
    network was the ability to change the container's network on the fly, without
    stopping the container.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到使用用户定义网络而不是默认网络的一个优势是能够在不停止容器的情况下随时更改容器的网络。
- en: To change the network of a running container, you can use the Docker network
    options known as **connect** and **disconnect**, along with the network name and
    the container name. When you use the **connect** option, you add a network to
    the container, while if you use the **disconnect** option, you remove a network
    from a container, all without the need to stop the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改运行中容器的网络，您可以使用称为**connect**和**disconnect**的Docker网络选项，以及网络名称和容器名称。当您使用**connect**选项时，您向容器添加一个网络，而如果您使用**disconnect**选项，则从容器中删除一个网络，而无需停止容器。
- en: 'In our NGINX example, we assigned the frontend network, but if we wanted to
    change that to the backend network, we only need to add one network and remove
    the other. The first step would be to attach the backend network using the **docker
    network connect** command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的NGINX示例中，我们分配了frontend网络，但是如果我们想要将其更改为backend网络，我们只需要添加一个网络并删除另一个。第一步是使用**docker
    network connect**命令连接backend网络：
- en: '![Figure 3.10 – Connecting a network'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 - 连接网络'
- en: '](image/Fig_3.9_B15514.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.9_B15514.jpg)'
- en: Figure 3.10 – Connecting a network
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 连接网络
- en: This will connect the network named backend to our container named frontend.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把名为backend的网络连接到我们名为frontend的容器。
- en: 'The second step is to remove the frontend network using the **disconnect**
    option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是使用**disconnect**选项删除frontend网络：
- en: '![Figure 3.11 – Disconnecting a network'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - 断开网络'
- en: '](image/Fig_3.10_B15514.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.10_B15514.jpg)'
- en: Figure 3.11 – Disconnecting a network
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - 断开网络
- en: You may be wondering if you can attach a container to more than one network,
    and the answer is yes. If you had a requirement for a container to access a network
    that requires jumbo frames but it also needs to access a standard network connection,
    you could connect the container to two different user-defined networks. Detailing
    this scenario is out of scope for this book and can become a complex topic since
    it may require custom routing to be created in the container, but it's good to
    know that it can be done and that there are specific use cases for it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道是否可以将容器连接到多个网络，答案是可以的。如果您需要容器访问需要巨幅帧的网络，但它也需要访问标准网络连接，您可以将容器连接到两个不同的用户定义网络。详细说明这种情况超出了本书的范围，并且可能会变成一个复杂的话题，因为它可能需要在容器中创建自定义路由，但知道它是可以做到的，并且有特定的用例。
- en: Removing a network
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除网络
- en: 'If you no longer need a user-defined network, you can delete the network from
    your host using the **docker network rm <network name>** command. To delete the
    frontend network we created earlier, we would execute the **docker network rm**
    command with the network name, **frontend**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不再需要用户定义的网络，可以使用**docker network rm <network name>**命令从主机中删除网络。要删除之前创建的前端网络，我们将使用带有网络名称**frontend**的**docker
    network rm**命令：
- en: '![Figure 3.12 – Removing a network'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - 删除网络'
- en: '](image/Fig_3.11_B15514.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.11_B15514.jpg)'
- en: Figure 3.12 – Removing a network
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - 删除网络
- en: 'If you had multiple networks that you wanted to remove, then you can use the
    **prune** command, which will delete all unused networks on the host. This is
    similar to pruning the unused volumes. You only need to run **docker network prune**
    to remove the unused networks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个要删除的网络，那么可以使用**prune**命令，它将删除主机上所有未使用的网络。这类似于清理未使用的卷。您只需要运行**docker network
    prune**来删除未使用的网络：
- en: '![Figure 3.13 – Pruning a network'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - 清理网络'
- en: '](image/Fig_3.12_B15514.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.12_B15514.jpg)'
- en: Figure 3.13 – Pruning a network
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - 清理网络
- en: Once you've verified you want to continues, Docker will list the networks that
    were removed. In our example, it removed a network called **network4**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确认要继续，Docker将列出已删除的网络。在我们的示例中，它删除了一个名为**network4**的网络。
- en: Just like the **volume prune** command we discussed earlier, **this is a one-way
    process**. When you select yes to prune the networks, there is no undo, so always
    be **100%** sure that you want to delete the networks before verifying the action.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的**volume prune**命令一样，**这是一个单向过程**。当您选择是来清理网络时，就没有撤销操作，所以在确认操作之前一定要**100%**确定您要删除网络。
- en: Running a container without networking
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在没有网络的情况下运行容器
- en: Remember that if you start a container without a network option, it will start
    connected to the default bridge network. You might have a requirement to test
    a container that may contain something suspicious, and having it connected to
    **network** could put the entire network at risk.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您启动一个没有网络选项的容器，它将连接到默认的桥接网络。您可能需要测试一个可能包含可疑内容的容器，并且让它连接到**网络**可能会对整个网络造成风险。
- en: This is no different than the physical world. For example, if you had a machine
    that appeared to be acting in a malicious manner, you would down the network port
    or disconnect the network cable. In the container world, we may be running multiple
    containers on the host and we may not be able to simply pull the cable without
    effecting many workloads. We have two options available, depending on whether
    the container is already running, and if it is, you do not want to lose the running
    state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与现实世界没有什么不同。例如，如果你有一台机器看起来像是恶意行为，你会关闭网络端口或者拔掉网络电缆。在容器世界中，我们可能在主机上运行多个容器，而且可能不能简单地拔掉电缆而不影响许多工作负载。我们有两个选项可用，取决于容器是否已经在运行，如果是的话，你不想丢失运行状态。
- en: If the container is stopped, you could simply start the container without an
    attached network by using the **--network=none** option when you start the container.
    This is the same process that you follow when you start a container with a user-defined
    network, except we specify the network name as **none**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器已经停止，你可以在启动容器时使用**--network=none**选项来简单地启动不附加网络的容器。这与你在启动具有用户定义网络的容器时遵循的相同过程，只是我们将网络名称指定为**none**。
- en: You may not be able to stop the container if you suspect it has something malicious
    running. If you needed to look at the running processes, RAM content, and so on,
    stopping the image would destroy anything running and you may lose valuable information.
    Rather than stopping and restarting the container using the network value of none,
    you could just disconnect the running container from the network. This would limit
    the container's ability to affect anything outside of the local image.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑容器中有恶意运行的东西，你可能无法停止容器。如果你需要查看运行中的进程、RAM内容等，停止镜像会销毁任何正在运行的东西，你可能会丢失宝贵的信息。与其停止并重新启动容器，使用网络值为none，你可以只是将运行中的容器与网络断开连接。这将限制容器影响本地镜像之外的任何东西的能力。
- en: Exposing container services
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露容器服务
- en: Now that you know the networking options available in Docker, the next step
    is to expose any ports you want to accept traffic when you start a container.
    There are two options when it comes to exposing ports. The first is to use the
    **host network** option, while the second is to expose the port(s) on a bridge
    network when the container is started. Using the **host network** option is easier
    since you do not require any manual port mappings, but this makes it a challenge
    to keep track of ports as your number of running containers grows. We only suggest
    using the **host network** option if you plan to run a single container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了Docker中可用的网络选项，下一步是在启动容器时暴露任何想要接受流量的端口。在暴露端口时有两个选项。第一个是使用**主机网络**选项，而第二个是在容器启动时在桥接网络上暴露端口。使用**主机网络**选项更容易，因为你不需要任何手动端口映射，但随着运行容器数量的增加，这会使跟踪端口变得困难。我们建议只在计划运行单个容器时使用**主机网络**选项。
- en: Exposing ports using a host network
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用主机网络暴露端口
- en: As we stated in the table provided earlier in this chapter, *"A container using
    the host network driver will not get an IP address and does not need to expose
    ports to allow incoming traffic."* Since the container will start up directly
    on the host network, bypassing Docker's network stack completely, you do not need
    to expose any ports for the container.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提供的表格中所述，*"使用主机网络驱动程序的容器将不会获得IP地址，也不需要暴露端口来允许传入流量。"*由于容器将直接在主机网络上启动，完全绕过Docker的网络堆栈，你不需要为容器暴露任何端口。
- en: 'As an example, to start a web server running NGINX on the host, using host
    networking, you would run the **docker run** command while providing **host**
    as the network type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在主机上使用主机网络运行NGINX的Web服务器，您将运行**docker run**命令，同时提供**host**作为网络类型：
- en: '![Figure 3.14 – Using the host network option'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 - 使用主机网络选项'
- en: '](image/Fig_3.13_B15514.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.13_B15514.jpg)'
- en: Figure 3.14 – Using the host network option
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - 使用主机网络选项
- en: 'We want to verify the container is running and to look at any ports that may
    be exposed, so we''ll run **docker ps** to list the running containers. The container
    shows as running, but under **PORTS**, we don''t see anything listed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要验证容器是否正在运行，并查看可能暴露的任何端口，因此我们将运行**docker ps**来列出正在运行的容器。容器显示为正在运行，但在**PORTS**下，我们没有看到任何列出的内容：
- en: '![Figure 3.15 – Example port view from a host connection'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 - 从主机连接的示例端口视图'
- en: '](image/Fig_3.14_B15514.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.14_B15514.jpg)'
- en: Figure 3.15 – Example port view from a host connection
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 - 从主机连接的示例端口视图
- en: 'Since the container was started using the **host network** option, we do not
    need to expose any ports. The NGINX container that we have been using runs on
    port **8080**, and since it bypasses Docker networking, the only method to prove
    it''s using port **8080** is to run **netstat** on the host system:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器是使用**主机网络**选项启动的，我们不需要暴露任何端口。我们一直在使用的NGINX容器在端口**8080**上运行，并且由于它绕过了Docker网络，证明它正在使用端口**8080**的唯一方法是在主机系统上运行**netstat**：
- en: '![Figure 3.16 – Host netstat showing port 8080 in use'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 - 主机netstat显示端口8080正在使用'
- en: '](image/Fig_3.15_B15514.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.15_B15514.jpg)'
- en: Figure 3.16 – Host netstat showing port 8080 in use
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 - 主机netstat显示端口8080正在使用
- en: 'It looks like the container is running and listening on port 8080\. From another
    machine on the network, we can open a browser and enter the IP address of the
    Docker host machine and use port 8080:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来容器正在运行并在端口8080上监听。在网络上的另一台机器上，我们可以打开浏览器并输入Docker主机机器的IP地址并使用端口8080：
- en: '![Figure 3.17 – NGINX running on a host network'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 - NGINX在主机网络上运行'
- en: '](image/Fig_3.16_B15514.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.16_B15514.jpg)'
- en: Figure 3.17 – NGINX running on a host network
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 - NGINX在主机网络上运行
- en: Here, we received the welcome page from NGINX, proving that the container is
    running.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们收到了NGINX的欢迎页面，证明容器正在运行。
- en: Since the **docker ps** command did not list the ports that are in use, you
    can see where you may start to lose track of the assigned ports if your host is
    running multiple containers when using the **host network** option. This is why
    we suggest limiting use of the **host network** option, unless you are running
    a single container or a container that requires host networking.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**docker ps**命令未列出正在使用的端口，您可以看到在使用**主机网络**选项时，如果主机运行多个容器，您可能会开始丢失已分配的端口。这就是为什么我们建议限制使用**主机网络**选项，除非您正在运行单个容器或需要主机网络的容器。
- en: Important Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As we have stated, a socket must be unique on the host. In our example, we have
    been using a single NIC and a single IP address, which means a port can only be
    used one on the host. Since a socket is a combination of the IP address and the
    port, you could add a second IP address to the single NIC or add an additional
    NIC with a new IP address to create a new, unique socket. This will allow you
    to create a new binding of an already assigned port to another process since the
    socket will be unique.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所述，主机上的套接字必须是唯一的。在我们的示例中，我们一直在使用单个NIC和单个IP地址，这意味着端口只能在主机上使用一次。由于套接字是IP地址和端口的组合，您可以向单个NIC添加第二个IP地址，或者添加一个带有新IP地址的附加NIC，以创建一个新的唯一套接字。这将允许您将已分配端口的新绑定到另一个进程，因为套接字将是唯一的。
- en: 'Now, let''s stop the NGINX container and look at **netstat** again to show
    that the port is no longer in use. We will use the following commands:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们停止NGINX容器，并再次查看**netstat**，以显示该端口不再被使用。我们将使用以下命令：
- en: '**sudo docker stop nginx**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo docker stop nginx**'
- en: '**sudo docker rm nginx**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo docker rm nginx**'
- en: 'Then, we''ll use netstat to show the active ports:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用netstat来显示活动端口：
- en: '![Figure 3.18 – Host netstat showing port 8080 is not in use'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – 主机netstat显示端口8080未被使用'
- en: '](image/Fig_3.17_B15514.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.17_B15514.jpg)'
- en: Figure 3.18 – Host netstat showing port 8080 is not in use
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 主机netstat显示端口8080未被使用
- en: As you can see, the only port open on the host is SSH; port **8080** has been
    closed since the container has been stopped.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主机上唯一打开的端口是SSH；端口**8080**已经关闭，因为容器已经停止。
- en: Exposing ports using a bridge network
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用桥接网络暴露端口
- en: It may seem that using the **host network** option makes exposing ports easy,
    since you don't need to actually do anything to expose them. This may seem attractive
    initially, but if you were running multiple containers on a host and more than
    one was configured to run on the same port, such as port 8080 for our NGINX container,
    you would be limited to a single container due to the port conflict.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**主机网络**选项似乎使暴露端口变得容易，因为你实际上不需要做任何事情来暴露它们。这一开始可能看起来很吸引人，但如果你在主机上运行多个容器，并且有多个配置为在相同的端口上运行，比如我们的NGINX容器的端口8080，由于端口冲突，你将受限于一个容器。
- en: When an option seems easier, it is usually less robust or configurable, which
    is why it seems easier at the beginning. This is the case when exposing ports
    using host networking versus bridged networking, but once you understand how and
    why we expose ports using bridge networks, you will see why it offers a better
    all-round solution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个选项看起来更容易时，通常意味着它的健壮性或可配置性较差，这就是为什么它一开始看起来更容易。这就是在使用主机网络与桥接网络暴露端口时的情况，但一旦你了解了我们如何以及为什么使用桥接网络暴露端口，你就会明白为什么它提供了更好的全面解决方案。
- en: When you want to expose ports on a container that is using a bridge network,
    you only need to specify the ports you want to open when starting the container.
    If you have more than one bridge, you will need to provide the network name as
    well, but in our example, we will assume you are using the built-in bridge network.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在使用桥接网络的容器上暴露端口时，你只需要在启动容器时指定要打开的端口。如果你有多个桥接网络，你还需要提供网络名称，但在我们的示例中，我们假设你正在使用内置的桥接网络。
- en: When you expose a port in Docker, you need to supply the incoming (Docker host)
    port and the destination (the container) port using the **incoming port:destination
    port** syntax. Often, the numbers will be the same to keep things simple, but
    there will be scenarios where using a different port may be required.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中暴露端口时，你需要使用**incoming port:destination port**的语法来指定传入的（Docker主机）端口和目的地（容器）端口。通常，这些数字会保持一致以保持简单，但也会有一些情况需要使用不同的端口。
- en: If you only supply a port for the destination, a TCP connection will be assumed.
    You may need to expose UDP ports for a container, and to expose the port as a
    UDP port, just add **/udp** to the destination port assignment. So, your syntax
    would become **incoming port:destination port/udp**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只为目的地提供了一个端口，那么将假定为TCP连接。你可能需要为容器暴露UDP端口，为了将端口暴露为UDP端口，只需在目的地端口分配中添加**/udp**。因此，你的语法将变成**incoming
    port:destination port/udp**。
- en: 'Using our example web server, we''ll start the container using the default
    bridge network listening on port **8080** using the **docker run** command with
    the **-p** option for the port; that is, **docker run -p 8080:8080 -p 8443:8443**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例Web服务器，我们将使用默认的桥接网络在端口**8080**上启动容器，使用**docker run**命令和**-p**选项来指定端口；也就是说，**docker
    run -p 8080:8080 -p 8443:8443**：
- en: '![Figure 3.19 – Exposing port 8080'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 暴露端口8080'
- en: '](image/Fig_3.18_B15514.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.18_B15514.jpg)'
- en: Figure 3.19 – Exposing port 8080
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 - 暴露端口8080
- en: 'To verify the container is running, we will use the **docker ps** command and
    take note of the **PORTS** column, which shows the mapped port(s) for the container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证容器正在运行，我们将使用docker ps命令，并注意PORTS列，该列显示了容器的映射端口：
- en: '![Figure 3.20 – docker ps output showing assigned ports'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 - docker ps输出显示分配的端口
- en: '](image/Fig_3.19_B15514.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.19_B15514.jpg)'
- en: Figure 3.20 – docker ps output showing assigned ports
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 - docker ps输出显示分配的端口
- en: Here, we can see that the container is running and that we have mapped the incoming
    host ports **8080** and **8443** to the container ports **8080** and **8443**.
    Any incoming request to the Docker host on **8080** and **8443**, on any interface
    (0.0.0.0), will be forwarded to the container.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到容器正在运行，并且我们已将传入主机端口8080和8443映射到容器端口8080和8443。对Docker主机上8080和8443端口的任何传入请求，无论在任何接口（0.0.0.0）上，都将被转发到容器。
- en: 'Just like when we used the host network, we can see that the host is listening
    on both **8080** and **8443** using netstat:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用主机网络时一样，我们可以看到主机正在使用netstat监听8080和8443端口：
- en: '![Figure 3.21 – Host netstat showing port 8080'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21 - 主机netstat显示端口8080'
- en: '](image/Fig_3.20_B15514.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.20_B15514.jpg)'
- en: Figure 3.21 – Host netstat showing port 8080
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 - 主机netstat显示端口8080
- en: 'Your project now calls for a second web server for another development site,
    and you want to deploy another NGINX container. The image uses ports **8080**
    and **8443** but both of those ports are in use by our first NGINX container.
    Attempting to run another container using **8080** and **8443** on the host will
    result in a port already allocated error:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目现在需要为另一个开发站点部署第二个Web服务器，并且您希望部署另一个NGINX容器。该镜像使用端口8080和8443，但这两个端口都被我们的第一个NGINX容器使用。在主机上尝试使用8080和8443运行另一个容器将导致端口已分配错误：
- en: '![Figure 3.22 – Port conflict example'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 - 端口冲突示例
- en: '](image/Fig_3.21_B15514.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.21_B15514.jpg)'
- en: Figure 3.22 – Port conflict example
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 - 端口冲突示例
- en: 'One solution would be to create another container that listens on different
    ports, such as **8081** and **8444**, but that starts to become difficult to maintain.
    Instead, remember that when you expose a port, you designate the incoming and
    the destination ports. We want to use the same NGINX image, so we can''t change
    the container ports, but we can change the incoming ports on the host. When we
    start our second container, we will increase each port by one to avoid conflicts
    with the existing **8080** and **8443** rules, but we will still forward the ports
    to **8080** and **8433** on the new container. This may sound confusing, so it''s
    easier to see an example **docker run** command; that is, **docker run -p 8081:8080
    -p 80444:8443 –name nginx2 bitnami/nginx:latest**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是创建另一个容器，监听不同的端口，比如8081和8444，但这开始变得难以维护。相反，记住当您暴露一个端口时，您指定了传入和目标端口。我们想使用相同的NGINX镜像，所以我们不能更改容器端口，但我们可以更改主机上的传入端口。当我们启动第二个容器时，我们将每个端口增加一，以避免与现有的8080和8443规则冲突，但我们仍将将端口转发到新容器的8080和8433。这可能听起来很混乱，所以最好看一个示例docker
    run命令；即docker run -p 8081:8080 -p 80444:8443 –name nginx2 bitnami/nginx:latest：
- en: '![Figure 3.23 – Example of assigning ports 8081 and 8443'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23 - 分配端口8081和8443的示例'
- en: '](image/Fig_3.22_B15514.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.22_B15514.jpg)'
- en: Figure 3.23 – Example of assigning ports 8081 and 8443
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 - 分配端口8081和8443的示例
- en: Since Docker returned the new container ID, we can see that, by increasing the
    incoming ports by one, we no longer have any conflicting ports.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker返回了新的容器ID，我们可以看到，通过逐一增加传入端口，我们不再有任何冲突的端口。
- en: 'Listing the currently running containers will show both NGINX containers and
    the port mappings:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列出当前运行的容器将显示两个NGINX容器和端口映射：
- en: '![Figure 3.24 – docker ps showing both running NGINX servers'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24 – 显示运行中的两个NGINX服务器的docker ps'
- en: '](image/Fig_3.23_B15514.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.23_B15514.jpg)'
- en: Figure 3.24 – docker ps showing both running NGINX servers
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 显示运行中的两个NGINX服务器
- en: 'Browsing to the host from another machine on the network on port 8081 will
    show the default NGINX welcome page:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络上的另一台机器浏览到主机的8081端口将显示默认的NGINX欢迎页面：
- en: '![Figure 3.25 – Browsing example to NGINX on port 8081'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25 – 浏览示例到端口8081的NGINX'
- en: '](image/Fig_3.24_B15514.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.24_B15514.jpg)'
- en: Figure 3.25 – Browsing example to NGINX on port 8081
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – 浏览示例到端口8081的NGINX
- en: 'Looking at netstat, we can see that all four ports are listening on the host:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 查看netstat，我们可以看到主机上的所有四个端口都在监听：
- en: '![Figure 3.26 – Host netstat showing the four assigned NGINX ports'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.26 – 主机netstat显示分配的四个NGINX端口'
- en: '](image/Fig_3.25_B15514.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_3.25_B15514.jpg)'
- en: Figure 3.26 – Host netstat showing the four assigned NGINX ports
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 – 主机netstat显示分配的四个NGINX端口
- en: If you needed to run another NGINX container, you would just use another host
    port, potentially **8082** or **8445**. The main takeaway is that the incoming
    port on the host must be unique to avoid port conflicts. The container's port
    can be the same since each container runs in its own namespace and each has its
    own resources and ports.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要运行另一个NGINX容器，您可以使用另一个主机端口，可能是**8082**或**8445**。主要的要点是主机上的传入端口必须是唯一的，以避免端口冲突。容器的端口可以相同，因为每个容器都在自己的命名空间中运行，并且每个容器都有自己的资源和端口。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about IP sockets and how hosts use ports to make
    a connection to a server. You learned that a socket is a combination of an IP
    address and the port and that it must be unique on the host. We then covered each
    networking type provided by Docker and use cases for each one, as well as when
    to use the default bridge network, a custom bridge network, host network, or no
    networking. Finally, you learned how to expose containers to external users.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了IP套接字以及主机如何使用端口与服务器建立连接。您了解到套接字是IP地址和端口的组合，必须在主机上是唯一的。然后，我们介绍了Docker提供的每种网络类型及其各自的用例，以及何时使用默认桥接网络、自定义桥接网络、主机网络或无网络。最后，您学会了如何将容器暴露给外部用户。
- en: In the next chapter, we'll begin to explore Kubernetes by exploring the Kubernetes
    cluster, looking at its control plane, understanding the differences between a
    **kublet** and an API, learning how the worker node functions, and reviewing over
    25 Kubernetes objects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索Kubernetes，通过探索Kubernetes集群，查看其控制平面，了解**kublet**和API之间的区别，学习工作节点的功能，并审查超过25个Kubernetes对象。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Since Docker creates a default bridge network, there is no reason to create
    a custom bridge.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Docker创建了默认的桥接网络，因此没有理由创建自定义桥接。
- en: A. True
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: A. True
- en: B. False
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: B. False
- en: Which of the following is an example of a socket?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是套接字的示例？
- en: A. **http:192.168.100.10**
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: A. **http:192.168.100.10**
- en: B. **192.168.100.10**
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: B. **192.168.100.10**
- en: C. **192.168.100.10:80**
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: C. **192.168.100.10:80**
- en: D. **https://192.168.100.10**
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: D. **https://192.168.100.10**
- en: How would you start a container running a web server on port **8080** named
    **nginx-web** on a host that already has its host port (**8080**) bound to another
    container?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在已将其主机端口（8080）绑定到另一个容器的主机上启动一个名为**nginx-web**的端口为**8080**的Web服务器的容器？
- en: A. **docker run -d nginx-web bitnami/nginx**
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: A. **docker run -d nginx-web bitnami/nginx**
- en: B. **docker run -p 8080:8080 -d nginx-web bitnami/nginx –force**
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: B. **docker run -p 8080:8080 -d nginx-web bitnami/nginx –force**
- en: C. **docker run -p 8081:8080 -d nginx-web bitnami/nginx**
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: C. **docker run -p 8081:8080 -d nginx-web bitnami/nginx**
- en: D. Since port **8080** is bound on the host, you cannot run a container on port
    **8080**
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: D. 由于主机上绑定了端口**8080**，你无法在端口**8080**上运行容器
- en: You suspect an image may contain malware. You need to run the image safely to
    look at its contents. What Docker command will mitigate any network impact?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你怀疑一个镜像可能包含恶意软件。你需要安全地运行这个镜像来查看它的内容。哪个Docker命令可以减轻任何网络影响？
- en: A. **docker run -isolate -it badimage bash**
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: A. **docker run -isolate -it badimage bash**
- en: B. **docker run -p 0:0 -it badimage bash**
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: B. **docker run -p 0:0 -it badimage bash**
- en: C. **docker run -it badimage bash**
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C. **docker run -it badimage bash**
- en: D. **docker run --network=none -it badimage bash**
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: D. **docker run --network=none -it badimage bash**
- en: Once a container is connected to a custom bridge network, you cannot change
    the connected network.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦一个容器连接到自定义桥接网络，你就无法更改连接的网络。
- en: A. True
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: A. True
- en: B. False
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: B. False
- en: What is the highest IP port number you can expose on a container?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在容器上暴露的最高IP端口号是多少？
- en: A. There is no limit
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: A. 没有限制
- en: B. 65535
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: B. 65535
- en: C. 65530
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: C. 65530
- en: D. 65532
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: D. 65532
- en: E. 65435
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: E. 65435
