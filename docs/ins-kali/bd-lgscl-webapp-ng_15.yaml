- en: Angular App Design and Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular应用设计和配方
- en: In this chapter, we will complete the implementation of LemonMart. As part of
    the router-first approach, I will demonstrate the creation of reusable routable components
    that also support data binding - the ability to lay out components using auxiliary
    routes of the router, using resolve guards to reduce boilerplate code and leveraging
    class, interfaces, enums, validators, and pipes to maximize code reuse. In addition,
    we will create multi-step forms and implement data tables with pagination, and
    explore responsive design. Along the way, in this book, we will have touched upon
    most of the major functionality that Angular and Angular Material has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将完成LemonMart的实现。作为路由器优先方法的一部分，我将演示创建可重用的可路由组件，这些组件还支持数据绑定 - 使用路由器的辅助路由来布局组件，使用解析守卫来减少样板代码，并利用类、接口、枚举、验证器和管道来最大程度地重用代码。此外，我们将创建多步表单，并实现带分页的数据表，并探索响应式设计。在这本书中，我们将涉及Angular和Angular
    Material提供的大部分主要功能。
- en: In this chapter, the training wheels are off. I will provide general guidance
    to get you started on an implementation; however, it will be up to you to try
    and complete the implementation on your own. If you need assistance, you may refer
    to the complete source code that is provided with the book or refer to up-to-date
    sample on GitHub at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，训练轮已经卸下。我将提供一般指导，让您开始实施；但是，完成实现将取决于您自己的努力。如果需要帮助，您可以参考本书提供的完整源代码，或者参考GitHub上最新的示例[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习以下主题：
- en: Object-oriented class design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的类设计
- en: Routable reusable components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可路由的可重用组件
- en: Caching service responses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存服务响应
- en: HTTP POST requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP POST请求
- en: Multi-step responsive forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多步响应式表单
- en: Resolve guards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析守卫
- en: Master/detail views using auxiliary routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助路由的主/细节视图
- en: Data tables with pagination
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带分页的数据表
- en: User class and object-oriented programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类和面向对象编程
- en: So far, we have only worked with interfaces to represent data, and we still
    want to continue using interfaces when passing data around various components
    and services. However, there's a need to create a default object to initialize
    a `BehaviorSubject`. In **Object-oriented Programming** (**OOP**), it makes a
    lot of sense for the `User` object to own this functionality instead of a service.
    So, let's implement a `User` class to achieve this goal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用接口来表示数据，并且我们仍然希望在各种组件和服务之间传递数据时继续使用接口。然而，需要创建一个默认对象来初始化`BehaviorSubject`。在**面向对象编程**（**OOP**）中，让`User`对象拥有这个功能而不是一个服务是非常合理的。因此，让我们实现一个`User`类来实现这个目标。
- en: 'Inside the `user/user` folder, define an `IUser` interface and a `User` class
    provided in `UserModule`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user/user`文件夹内，定义`IUser`接口和`User`类，这些类在`UserModule`中提供：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we will need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在构造函数中使用默认值定义所有属性为`public`属性，我们一举两得；否则，我们将需要分别定义属性并初始化它们。这样，我们实现了简洁的实现。
- en: 'You can also implement calculated properties for use in templates, such as
    being able to conveniently display the `fullName` of a user:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为模板实现计算属性，例如能够方便地显示用户的`fullName`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using a `static BuildUser` function, you can quickly hydrate the object with
    data received from the server. You can also implement the `toJSON()` function
    to customize the serialization behavior of your object before sending the data
    up to the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static BuildUser`函数，您可以快速使用从服务器接收的数据填充对象。您还可以实现`toJSON()`函数，以定制对象在发送数据到服务器之前的序列化行为。
- en: Reusing components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用组件
- en: 'We need a component that can display a given user''s information. A natural
    place for this information to be presented is when the user navigates to `/user/profile`.
    You can see the mock-up `User` profile file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够显示特定用户信息的组件。这些信息被呈现的一个自然地方是当用户导航到`/user/profile`时。您可以看到模拟`User`配置文件文件：
- en: '![](Images/eac254e3-0556-42ff-8841-6b44a5020fff.png)User profile mock-up'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/eac254e3-0556-42ff-8841-6b44a5020fff.png)用户配置文件模拟'
- en: 'User information is also displayed mocked up elsewhere in the app, at `/manager/users`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户信息也在应用程序的其他地方进行了模拟，位于`/manager/users`：
- en: '![](Images/b9b855d5-243b-4cc0-b625-511856a1f3b8.png)Manager user management
    mock-up'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b9b855d5-243b-4cc0-b625-511856a1f3b8.png)管理用户管理模拟'
- en: To maximize code reuse, we need to ensure that you design a `User` component
    that can be used in both contexts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地重用代码，我们需要确保您设计一个可以在两个上下文中使用的`User`组件。
- en: As an example, let's complete the implementation of two user profile-related
    screens.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，让我们完成两个与用户配置文件相关的屏幕的实现。
- en: User profile with multi-step auth-enabled responsive forms
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有多步验证启用响应式表单的用户配置文件
- en: Now, let's implement a multi-step input form to capture user profile information.
    We will also make this multi-step form responsive for mobile devices using media
    queries.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个多步输入表单来捕获用户配置文件信息。我们还将使用媒体查询使这个多步表单对移动设备响应。
- en: 'Let''s start with adding some helper data that will help us display an input
    form with options:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加一些辅助数据开始，这些数据将帮助我们显示带有选项的输入表单：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Install a helper library to programmatically access TypeScript enum values
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个辅助库以以编程方式访问TypeScript枚举值
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add new validation rules to `common/validations.ts`
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的验证规则添加到`common/validations.ts`
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now implement `profile.component.ts` as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式实现`profile.component.ts`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Upon load, we request the current user from `userService`, but this will take
    a while, so we must first build an empty form with `this.buildUserForm()`. On
    this function, you can also implement a resolve guard, as discussed in a later
    section, to load a user based on their `userId` provided on a route, and pass
    that data into `buildUserForm(routeUser)` and skip loading `currentUser` to increase
    reusability of this component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 加载时，我们从`userService`请求当前用户，但这将需要一些时间，因此我们必须首先使用`this.buildUserForm()`构建一个空表单。在这个函数中，您还可以实现一个解析守卫，如后面的部分所讨论的那样，根据路由提供的`userId`加载用户，并将该数据传递到`buildUserForm(routeUser)`中，并跳过加载`currentUser`以增加此组件的可重用性。
- en: Form groups
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单组
- en: Our form has many input fields, so we will use a `FormGroup`, created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单有许多输入字段，因此我们将使用`FormGroup`，由`this.formBuilder.group`创建，来容纳我们的各种`FormControl`对象。此外，子`FormGroup`对象将允许我们保持数据结构的正确形状。
- en: 'Start building the `buildUserForm` function, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开始构建`buildUserForm`函数，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`buildUserForm` optionally accepts an `IUser` to prefill the form, otherwise
    all fields are set to their default values. The `userForm` itself is the top-level
    `FormGroup`. Various `FormControls` are added to it, such as `email`, with validators
    attached to them as needed. Note how `name` and `address` are their own `FormGroup`
    objects. This parent-child relationship ensures proper structure of the form data,
    when serialized to JSON, which fits the structure of `IUser`, in a manner that
    the rest of our application and server-side code can utilize.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildUserForm`可选择接受`IUser`以预填表单，否则所有字段都设置为默认值。`userForm`本身是顶级`FormGroup`。各种`FormControls`被添加到其中，例如`email`，并根据需要附加验证器。请注意`name`和`address`是它们自己的`FormGroup`对象。这种父子关系确保了表单数据的正确结构，当序列化为JSON时，它符合`IUser`的结构，以便我们的应用程序和服务器端代码可以利用。'
- en: You will completing the implementation of the `userForm` independently following
    the sample code provided for the chapter and I will be going over sections of
    the code piece by piece over the next few sections to explain certain key capabilities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您将独立完成`userForm`的实现，按照本章提供的示例代码，并在接下来的几节中逐步解释某些关键功能。
- en: Stepper and responsive layout
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步进器和响应式布局
- en: 'Angular Material Stepper ships with the MatStepperModule. The stepper allows
    for form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields all at once. The user can still track their
    place in the process and as a side effect, as the developer we breakup our `<form>`
    implementation and enforce validation rules on a step-by-step basis or create
    optional workflows where certain steps can be skipped or required. As with all
    Material user controls, the stepper has been designed with a responsive UX in
    mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material Stepper随MatStepperModule一起提供。该步进器允许将表单输入分解为多个步骤，以便用户不会一次处理数十个输入字段而感到不知所措。用户仍然可以跟踪他们在流程中的位置，作为开发人员，我们可以分解我们的`<form>`实现并逐步强制执行验证规则，或者创建可选的工作流，其中某些步骤可以被跳过或必需的。与所有Material用户控件一样，步进器是根据响应式UX设计的。在接下来的几节中，我们将实现三个步骤，涵盖流程中的不同表单输入技术：
- en: Account Information
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户信息
- en: Input validation
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Responsive layout with media queries
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式布局与媒体查询
- en: Calculated properties
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: DatePicker
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期选择器
- en: Contact Information
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系信息
- en: Type ahead support
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型前支持
- en: Dynamic form arrays
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: Review
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查
- en: Read-only views
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读视图
- en: Saving and clearing data
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和清除数据
- en: 'Let''s prep the User module for some new Material modules:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一些新的Material模块准备用户模块：
- en: 'Create a `user-material.module` containing the following Material modules:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下Material模块的`user-material.module`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Ensure `user.module` correctly imports:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`user.module`正确导入：
- en: The new `user-material.module`
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`user-material.module`
- en: The baseline  `app-material.module`
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线`app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必需的`FormsModule`，`ReactiveFormsModule`和`FlexLayoutModule`
- en: As we start adding sub material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` inline with how `app-routing.module.ts` is named.
    Going forward, I will be using the latter convention.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始添加子材料模块，将我们的根`material.module.ts`文件重命名为`app-material.modules.ts`是有道理的，与`app-routing.module.ts`的命名方式一致。未来，我将使用后一种约定。
- en: 'Now, start implementing the first row of the Account Information step:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始实现账户信息步骤的第一行：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take care to understand how the stepper and the form configuration works so
    far, you should be seeing the first row render, pulling mock data:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意了解到目前为止步进器和表单配置的工作原理，您应该看到第一行呈现，提取模拟数据：
- en: '![](Images/32843e4b-d12a-4a66-9b97-6c034e13732b.png)Multi-step form - Step
    1'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/32843e4b-d12a-4a66-9b97-6c034e13732b.png)多步骤表单 - 步骤1'
- en: In order to complete the implementation of the form please refer to the sample
    code provided for this chapter or the reference implementation on [GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成表单的实现，请参考本章提供的示例代码或[GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)上的参考实现。
- en: During your implementation, you will notice that the Review step uses a directive
    named `<app-view-user>`. A minimal version of this component is implemented in
    the ViewUser component section below. However, feel free to implement the capability
    inline for now and refactor your code during the Reusable component with binding
    and route data section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的实施过程中，您会注意到审阅步骤使用了一个名为`<app-view-user>`的指令。这个组件的最小版本在下面的ViewUser组件部分中实现。但是，现在可以自由地内联实现这个功能，并在可重用组件与绑定和路由数据部分重构代码。
- en: 'In the following screenshot, you can see what a completed implementation of
    the multi-step form looks like on a desktop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到多步骤表单的完成实现在桌面上是什么样子的：
- en: '![](Images/e9a485ac-1bb5-4881-9c2f-bffcee671f75.png)Multi-step form on desktop'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e9a485ac-1bb5-4881-9c2f-bffcee671f75.png)桌面上的多步骤表单'
- en: 'Note that adding `fxLayout.lt-sm="column"` on a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在具有`fxLayout="row"`的行上添加`fxLayout.lt-sm="column"`可以实现表单的响应式布局，如下所示：
- en: '![](Images/d8d82436-fc54-4675-8091-cf033e2123d3.png)Multi-step form on mobile'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d8d82436-fc54-4675-8091-cf033e2123d3.png)移动设备上的多步骤表单'
- en: Let's see how the Date of Birth field works in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看出生日期字段在下一节中是如何工作的。
- en: Calculated properties and DatePicker
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和日期选择器
- en: 'If you like to display calculated properties based on user input, you can follow
    the pattern shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想根据用户输入显示计算属性，可以按照这里显示的模式进行操作：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The usage of calculated properties in the template looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用计算属性的用法如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here it is in action:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它在操作中是这样的：
- en: '![](Images/8aff43df-f604-43cf-9eed-4fb412b9163d.png)Selecting date with DatePicker'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/8aff43df-f604-43cf-9eed-4fb412b9163d.png)使用日期选择器选择日期'
- en: 'After the date is selected, the calculated age is displayed, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日期后，将显示计算的年龄，如下所示：
- en: '![](Images/65a05b6a-4266-4a78-816f-1749e2a0bab1.png)Calculated age property'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/65a05b6a-4266-4a78-816f-1749e2a0bab1.png)计算的年龄属性'
- en: Now, let's move on to the next step, Contact Information and see how we can
    enable a convenient way to display and input the state portion of the address
    field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行下一步，联系信息，并看看我们如何实现一种方便的方式来显示和输入地址字段的州部分。
- en: Type ahead support
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型前支持
- en: 'In `buildUserForm`, we set a listener on `address.state` to support a type
    ahead filtering drop-down experience:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildUserForm`中，我们设置了一个监听器在`address.state`上，以支持类型前过滤下拉体验：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the template, implement `mat-autocomplete` bound to the filtered states
    array with an `async` pipe:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板上，实现`mat-autocomplete`绑定到过滤后的状态数组，并使用`async`管道：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s how it looks when a user enters the `V` character:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`V`字符时，它看起来是这样的：
- en: '![](Images/efe44748-d14c-4d5e-b990-004fd345bd1f.png)Dropdown with Typeahead
    SupportIn the next section, let''s enable the input of multiple phone numbers.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/efe44748-d14c-4d5e-b990-004fd345bd1f.png)带有类型前支持的下拉菜单在下一节中，让我们启用多个电话号码的输入。'
- en: Dynamic form arrays
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with `this.formBuilder.array` and with
    several helper functions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`phones`是一个数组，可能允许多个输入。我们可以通过使用`this.formBuilder.array`和几个辅助函数来实现这一点：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`BuildPhoneArray` supports initializing a form with a single phone input or
    filling it with the existing data, working in tandem with `BuildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an Add button to create
    a new row for entry:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildPhoneArray`支持使用单个电话输入初始化表单或填充现有数据，与`BuildPhoneFormControl`协同工作。当用户点击添加按钮创建新的输入行时，后者函数非常有用：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary, because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesArray`属性获取器是一种常见模式，使得更容易访问特定的表单属性。然而，在这种情况下，它也是必要的，因为必须将`get(''phones'')`强制转换为`FormArray`，这样我们才能在模板上访问它的`length`属性：'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `remove` function is implemented inline.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数是内联实现的。'
- en: 'Let''s see how it should be working:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它应该如何工作：
- en: '![](Images/3fb49d34-6c03-4edb-86a6-43d3183d8068.png)Multiple inputs using FormArray'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/3fb49d34-6c03-4edb-86a6-43d3183d8068.png)使用FormArray创建多个输入'
- en: Now that we're done with inputing data, we can move on to the last step of the
    stepper, Review. However, as it was mentioned earlier, the Review step uses the `app-view-user`
    directive to display its data. Let's build that view first.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经输入数据，我们可以继续到步进器的最后一步，审查。然而，正如之前提到的，审查步骤使用`app-view-user`指令来显示其数据。让我们首先构建该视图。
- en: ViewUser component
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewUser组件
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the Review step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`<app-view-user>`指令的最小实现，这是审查步骤的先决条件。
- en: 'Create a new `viewUser` component under `user` as shown below:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user`下创建一个新的`viewUser`组件，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The component above uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in `this.user` as an instance of the class `User`
    with  `User.BuildUser` and assign it to `this.currentUser`. The template uses
    this variable, because calculated properties like `currentUser.fullName` will
    only work if the data resides in an instance of the class `User`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的组件使用`@Input`进行输入绑定，以从外部组件获取符合`IUser`接口的用户数据。我们实现了`ngOnChanges`事件，每当绑定的数据发生变化时就会触发。在这个事件中，我们将存储在`this.user`中的简单JSON对象转换为`User`类的实例，并将其分配给`this.currentUser`。模板使用这个变量，因为像`currentUser.fullName`这样的计算属性只有在`User`类的实例中才能工作。
- en: Now, we are ready to complete the multi-step form.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备完成多步表单。
- en: Review component and Save form
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查组件和保存表单
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在多步表单的最后一步，用户应该能够审查并保存表单数据。作为一个良好的实践，成功的`POST`请求将返回保存的数据到浏览器。然后我们可以使用从服务器接收到的信息重新加载表单：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If there are errors, they''ll be set to `userError` to be displayed. Before
    saving, we will present the data in a compact form in a reusable component that
    we can bind the form data to:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，它们将被设置为`userError`以供显示。在保存之前，我们将以一种可重用的组件以紧凑的形式呈现数据，我们可以将表单数据绑定到该组件：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how the final product should look:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终产品应该看起来的样子：
- en: '![](Images/3f8afd93-786d-4ae7-b43b-d665971ae9a6.png)Review stepNote the option
    to reset the form. Adding an alert dialog to confirm resetting of user input data
    would be good UX.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/3f8afd93-786d-4ae7-b43b-d665971ae9a6.png)审查步骤请注意重置表单的选项。添加一个警报对话框来确认重置用户输入数据将是良好的用户体验。'
- en: Now that the user profile input is done, we are about midway into our eventual
    goal of creating a master/detail view where a Manager can click on a user and
    view their profile details. We still have a lot more code to add, and along the
    way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component. In the next section, we will learn about resolve
    guards so that we can simplify our code and reduce boilerplate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户配置文件输入已完成，我们正处于创建主/细节视图的最终目标的中途，其中经理可以单击用户并查看其配置文件详细信息。我们仍然有很多代码要添加，在这个过程中，我们已经陷入了为组件加载必要数据添加大量样板代码的模式。在下一节中，我们将学习解析守卫，以便简化我们的代码并减少样板。
- en: Resolve guard
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析守卫
- en: A resolve guard is a type of a router guard, as mentioned in [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml),* Design
    Authentication and Authorization.* A resolve guard can load necessary data for
    a component by reading record IDs from route parameters, asynchronously load the
    data and have it ready by the time the component activates and initializes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫是一种路由守卫，如[第14章](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml)中所述，*设计身份验证和授权*。解析守卫可以通过从路由参数中读取记录ID异步加载必要的数据，并在组件激活和初始化时准备好数据。
- en: 'The major advantages for a resolve guard includes reusability of loading logic,
    reduction of boilerplate code, and also shedding dependencies, because the component
    can receive the data it needs without having to import any service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫的主要优势包括加载逻辑的可重用性，减少样板代码以及摆脱依赖，因为组件可以接收到它所需的数据而无需导入任何服务：
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个新的`user.resolve.ts`类：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can use a resolve guard as shown:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用解析守卫，如下所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `routerLink` will look like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`routerLink`将如下所示：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On the ` ngOnInit` hook of the target component, you can read the resolved
    user like this:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标组件的`ngOnInit`钩子上，您可以像这样读取已解析的用户：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can observe this behavior in action in the next two sections, after we update `ViewUserComponent` and
    the router to leverage the resolve guard.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新`ViewUserComponent`和路由以利用解析守卫之后，您可以在接下来的两个部分中观察到这种行为。
- en: Reusable component with binding and route data
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用的组件，具有绑定和路由数据
- en: 'Now, let''s refactor the `viewUser` component, so that we can reuse it in multiple
    contexts. One where it can load its own data using a resolve guard, suitable for
    a master/detail view and another, where we can bind the current user to it, as
    we have done in the Review step of the multi-step input form we built in the prior
    section:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`viewUser`组件，以便我们可以在多个上下文中重用它。一个是可以使用解析守卫加载自己的数据，适用于主/细节视图，另一个是可以将当前用户绑定到它上，就像我们在之前部分构建的多步输入表单的Review步骤中所做的那样：
- en: 'Update `viewUser` component with the following changes:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下更改更新`viewUser`组件：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We now have two independent events. One for `ngOnChanges`, which handles what
    value gets assigned to `this.currentUser`, if `this.user` has been bound to. `ngOnInit`
    will only fire once, when the component is first initialized or has been routed
    to. In this case, if any data for the route has been resolved then it'll be assigned
    to `this.currentUser`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个独立的事件。一个是`ngOnChanges`，它处理将什么值分配给`this.currentUser`，如果`this.user`已经被绑定。`ngOnInit`只会在组件首次初始化或路由到达时触发一次。在这种情况下，如果路由的任何数据已经解析，那么它将被分配给`this.currentUser`。
- en: To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在多个惰性加载的模块中使用此组件，我们必须将其包装在自己的模块中。
- en: 'Create a new `shared-components.module.ts` under `app`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`下创建一个新的`shared-components.module.ts`：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ensure that you import `SharedComponentsModule` module into each feature module
    you intended to use `ViewUserComponent` in. In our case, these will be `User`
    and `Manager` modules.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您将`SharedComponentsModule`模块导入到您打算在其中使用`ViewUserComponent`的每个功能模块中。在我们的情况下，这将是`User`和`Manager`模块。
- en: Remove `ViewUserComponent` from the `User` module declarations
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`User`模块的声明中删除`ViewUserComponent`
- en: We now have the key pieces in place to begin the implementation of master/detail
    view.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了开始实现主/详细视图的关键部分。
- en: Master/detail view auxiliary routes
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主/详细视图辅助路由
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器优先架构的真正力量通过使用辅助路由得以实现，我们可以仅通过路由器配置影响组件的布局，从而允许丰富的场景，我们可以将现有组件重新组合成不同的布局。辅助路由是彼此独立的路由，它们可以在标记中定义的命名出口中呈现内容，例如`<router-outlet
    name="master">`或`<router-outlet name="detail">`。此外，辅助路由可以有自己的参数、浏览器历史、子级和嵌套辅助。
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用辅助路由实现基本的主/详细视图：
- en: 'Implement a simple component with two named outlets defined:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个带有两个命名出口的简单组件：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a `userTable` component under `manager`
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager`下创建一个`userTable`组件
- en: 'Update `manager-routing.module` to define the auxiliary routes:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`以定义辅助路由：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the `default` path.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当用户导航到`/manager/users`时，他们将看到`UserTableComponent`，因为它是使用`default`路径实现的。
- en: Provide `UserResolve` in `manager.module` since `viewUser` depends on it
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager.module`中提供`UserResolve`，因为`viewUser`依赖于它
- en: Implement a temporary button in `userTable`
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userTable`中实现一个临时按钮
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Consider that a user clicks on a View detail button like the one defined above,
    then `ViewUserComponent` will be rendered for the user with the given `userId`.
    In the next screenshot, you can see what the View Details button will look like
    after we implement the data table in the next section:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑用户点击上面定义的“查看详情”按钮，然后`ViewUserComponent`将为具有给定`userId`的用户呈现。在下一个截图中，您可以看到在我们在下一节中实现数据表后，“查看详情”按钮将是什么样子：
- en: '![](Images/27e24385-6a13-4375-8905-4e0a4da346c9.png)View Details buttonYou
    can have as many combinations and alternative components defined for master and
    detail, allowing for an infinite possibilities of dynamic layouts. However, setting
    up the `routerLink` can be a frustrating experience. Depending on the exact condition,
    you have to either supply or not supply all or some outlets in the link. For example,
    for the preceding scenario, if the link was `[''/manager/users'', { outlets: {
    master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route will silently
    fail to load. Expect these quirks to be ironed out in future Angular releases.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/27e24385-6a13-4375-8905-4e0a4da346c9.png)查看详情按钮您可以为主和详细定义许多组合和备用组件，从而允许无限的动态布局可能性。但是，设置`routerLink`可能是一种令人沮丧的体验。根据确切的条件，您必须在链接中提供或不提供所有或一些出口。例如，对于前面的情景，如果链接是`[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`，路由将悄无声息地加载失败。预计这些怪癖将在未来的Angular版本中得到解决。'
- en: Now that, we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome Dev Tools to see the data being loaded correctly. Before debugging,
    ensure that the mock server we created in [Chapter 13,](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)
    *Continuous Integration and API Design*, is running.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了对`ViewUserComponent`的解析守卫的实现，您可以使用Chrome Dev Tools来查看数据是否被正确加载。在调试之前，请确保我们在[第13章](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)中创建的模拟服务器正在运行。
- en: Ensure that mock server is running by executing either `docker run -p 3000:3000
    -t duluca/lemon-mart-swagger-server` or `npm run mock:standalone`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`docker run -p 3000:3000 -t duluca/lemon-mart-swagger-server`或`npm run mock:standalone`来确保模拟服务器正在运行。
- en: 'In Chrome Dev Tools, set a break point right after `this.currentUser` is assigned
    to, as shown:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome Dev Tools中，设置一个断点，就在`this.currentUser`被分配之后，如下所示：
- en: '![](Images/6af6ebd9-acd6-4797-acf2-f02135a7c6a9.png)Dev Tools Debugging ViewUserComponent'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6af6ebd9-acd6-4797-acf2-f02135a7c6a9.png)Dev Tools Debugging ViewUserComponent'
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到`this.currentUser`在`ngOnInit`函数内正确设置，而无需任何加载数据的样板代码，显示了解析守卫的真正好处。`ViewUserComponent`是细节视图；现在让我们实现主视图，作为带有分页的数据表。
- en: Data table with pagination
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有分页的数据表
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    like `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user provided `searchText`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了布局主/细节视图的脚手架。在主视图中，我们将有一个用户的分页数据表，因此让我们实现`UserTableComponent`，其中将包含一个名为`dataSource`的`MatTableDataSource`属性。我们需要能够使用标准分页控件（如`pageSize`和`pagesToSkip`）批量获取用户数据，并能够通过用户提供的`searchText`进一步缩小选择范围。
- en: Let's start by adding the necessary functionality to the `UserService`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先向`UserService`添加必要的功能。
- en: Implement a new interface `IUsers` to describe the data structure of paginated
    data
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的接口`IUsers`来描述分页数据的数据结构
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add `getUsers` to `UserService`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`UserService`添加`getUsers`
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置带有分页、排序和过滤功能的`UserTable`：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After initializing the pagination, sorting, and the filter properties, we use
    the `merge` method to listen for changes in all three data streams. If one changes,
    the whole `pipe` is triggered, which contains a call to `this.userService.getUsers`.
    Results are then mapped to the table's `datasource` property, otherwise errors
    are caught and handled.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化分页、排序和过滤属性后，我们使用`merge`方法来监听这三个数据流的变化。如果其中一个发生变化，整个`pipe`就会被触发，其中包含对`this.userService.getUsers`的调用。然后将结果映射到表格的`datasource`属性，否则会捕获和处理错误。
- en: 'Create a `manager-material.module` containing the following Material modules:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下Material模块的`manager-material.module`：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Ensure `manager.module` correctly imports:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`manager.module`正确导入：
- en: The new `manager-material.module`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`manager-material.module`
- en: The baseline  `app-material.module`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线`app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要`FormsModule`、`ReactiveFormsModule`和`FlexLayoutModule`
- en: 'Finally, implement the `userTable` template:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`userTable`模板：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With just the master view, the table looks like this screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 只有主视图时，表格看起来像这样的截图：
- en: '![](Images/b9bdc8f6-da44-4279-bf37-70dcff4e8794.png)UserTable'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b9bdc8f6-da44-4279-bf37-70dcff4e8794.png)UserTable'
- en: 'If you click on the View icon, `ViewUserComponent` will get rendered in the
    detail outlet, as shown:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击查看图标，`ViewUserComponent`将在详细信息中呈现，如下所示：
- en: '![](Images/b31311fa-24cf-44b1-884b-14d612c84a12.png)Master/Detail view'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化`UserTableComponent`的默认数据
- en: You can then wire up the Edit button and pass the `userId` to the `UserProfile` so
    that the data can be edited and updated. Alternatively, you can render the `UserProfile`
    in place in the detail outlet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以连接编辑按钮并将`userId`传递给`UserProfile`，以便可以编辑和更新数据。或者，您可以在详细信息中直接呈现`UserProfile`。
- en: Data table with pagination completes the implementation of LemonMart for the
    purpose of this book. Now let's make sure all our tests our passing, before we
    move on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表格分页完成了LemonMart的实现，以便本书的目的。现在让我们确保在继续之前，所有的测试都通过了。
- en: Updating Unit Tests
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新单元测试
- en: Since we introduced a new `userService`, create a fake implementation for it,
    using the same pattern from `authService` and `commonTestingProviders` with it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们引入了一个新的`userService`，请为其创建一个虚假实现，使用与`authService`和`commonTestingProviders`相同的模式。
- en: Implement `IUserService` interface for `UserService`
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserService`实现`IUserService`接口
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implement the fake user service
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现虚假用户服务
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add the user service fake to `commonTestingProviders`
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户服务虚假添加到`commonTestingProviders`
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add `SharedComponentsModule` to `commonTestingModules`
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SharedComponentsModule`添加到`commonTestingModules`
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Instantiate default data for `UserTableComponent`
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续修复单元测试配置，直到所有测试都通过！
- en: 'After fixing up its providers and imports, you will notice `UserTableComponent`
    is still failing to create. This is because, the component initialization logic
    requires `dataSource` to be defined. If undefined, the component can''t be created.
    However, we can easily modify component properties in the second `beforeEach`
    method, which executes after the `TestBed` has injected real, mocked or fake dependencies
    to the component class. See the changes bolded below for test data setup:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复其提供者和导入之后，您会注意到`UserTableComponent`仍然无法创建。这是因为，组件初始化逻辑需要定义`dataSource`。如果未定义，则无法创建组件。但是，我们可以在第二个`beforeEach`方法中轻松修改组件属性，在此方法中，`TestBed`已经向组件类注入了真实的、模拟的或虚假的依赖项。请参见下面加粗的更改以进行测试数据设置：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By now, you may have noticed that just by updating some of our central configuration
    some tests are passing and the rest of tests can be resolved by applying the various
    patterns we have been using throughout the book. For example `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到，通过更新一些我们的中央配置，一些测试已经通过，其余的测试可以通过应用我们在整本书中一直在使用的各种模式来解决。例如，`user-management.component.spec.ts`使用了我们创建的常用测试模块和提供者：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you are working with providers and fakes, keep in mind what module, component,
    service or class is under test and take care to only provide fakes of dependencies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用提供者和虚假时，请记住正在测试哪个模块、组件、服务或类，并小心只提供依赖项的虚假。
- en: '`ViewUserComponent` is a special case, where we can''t use our common testing
    modules and providers, otherwise we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewUserComponent`是一个特殊情况，我们无法使用我们的常用测试模块和提供者，否则我们将会创建循环依赖。在这种情况下，手动指定需要导入的模块。'
- en: Continue fixing unit test configurations until all of them are passing!
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![](Images/b31311fa-24cf-44b1-884b-14d612c84a12.png)主/详细视图'
- en: In this book, we didn't cover any functional unit testing, where we would test
    some business logic to test its correctness. Instead, we focused on keeping the
    auto-generated tests in working order. I highly recommend implementing unit tests
    to cover key business logic using the excellent framework provided by Angular
    out-of-the-box.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们没有涵盖任何功能单元测试，即测试一些业务逻辑以测试其正确性。相反，我们专注于保持自动生成的测试正常工作。我强烈建议使用Angular开箱即用提供的优秀框架来实现单元测试，以覆盖关键业务逻辑。
- en: You always have the option to write even further elemental unit tests, testing
    classes and functions in isolation using Jasmine. Jasmine has rich test double
    functionality, able to mock and spy on dependencies. It is easier and cheaper
    to write and maintain these kinds of elemental unit tests. However, this topic
    is a deep one in its own right and is beyond the scope of this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以选择进一步编写基本单元测试，使用Jasmine在隔离中测试类和函数。Jasmine具有丰富的测试双功能，能够模拟和监视依赖关系。编写和维护这种基本单元测试更容易、更便宜。但是，这个话题本身就很深入，超出了本书的范围。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed going over all major Angular app design considerations,
    along with recipes, to be able to implement a line-of-business app with ease.
    We talked about applying object-oriented class design to make hydrating or serializing
    data easier. We created reusable components that can be activated by the router
    or embedded within another component with data binding. We showed that you can
    `POST` data to the server and cache responses. We also created a rich multistep
    input forms that is responsive to changing screen sizes. We removed boilerplate
    code from components by leveraging a resolve guard to load user data. We then
    implemented a master/detail view using auxiliary routes and demonstrated how to
    build data tables with pagination.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了所有主要的Angular应用程序设计考虑，以及配方，以便能够轻松实现一款业务应用程序。我们讨论了应用面向对象的类设计，以使数据的填充或序列化更容易。我们创建了可由路由器激活或嵌入到另一个带有数据绑定的组件中的可重用组件。我们展示了您可以将数据“POST”到服务器并缓存响应。我们还创建了一个对不断变化的屏幕尺寸响应的丰富多步输入表单。我们通过利用解析守卫从组件中删除样板代码，以加载用户数据。然后，我们使用辅助路由实现了主/细节视图，并演示了如何构建带有分页的数据表。
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we approached our application's design with a good high-level understanding
    of what we wanted to achieve. Also, by identifying reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time without running the risk of grossly over-engineering our solution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，通过使用路由器优先设计、架构和实现方法，我们以对我们想要实现的内容有很好的高层次理解的方式来处理我们应用程序的设计。此外，通过及早识别重用机会，我们能够优化我们的实现策略，提前实现可重用组件，而不会冒过度设计解决方案的风险。
- en: In the next chapter, we will set up a highly-available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    Blue-Green deployments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在AWS上设置一个高可用的基础架构来托管LemonMart。我们将使用新的脚本更新项目，以实现无停机的蓝绿部署。
