["```ts\n// hot-cold-warm/promise.js\n\nfunction getData() {\n  return new Promise(resolve => {\n    console.log(\"this will be printed straight away\");\n    setTimeout(() => resolve(\"some data\"), 3000); \n  });\n}\n\n// emits 'some data' after 3 seconds\ngetData().then(data => console.log(\"3 seconds later\", data));\n```", "```ts\n// hot-cold-warm/observer.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nfunction getData() {\n  return Rx.Observable(observer => {\n    console.log(\"this won't be printed until a subscriber exists\");\n    setTimeout(() => {\n      observer.next(\"some data\");\n      observer.complete();\n    }, 3000);\n  });\n}\n\n// nothing happens\ngetData();\n```", "```ts\n// hot-cold-warm/observer-with-subscriber\n\nconst Rx = require(\"rxjs/Rx\"); \nfunction getData() {  return Rx.Observable.create(observer => {    console.log(\"this won't be printed until a subscriber exists\");\n\n    setTimeout(() => {      observer.next(\"some data\");\n      observer.complete();\n    }, 3000);\n  });\n}\n\nconst  stream$  =  getData(); stream$.subscribe(data  =>  console.log(\"data from observer\", data));\n```", "```ts\n// hot-cold-warm/cold-observable.js\nconst Rx = require(\"rxjs/Rx\");\n\nconst stream$ = Rx.Observable.interval(1000).take(3);\n\n// subscriber 1 emits 0, 1, 2\nstream$.subscribe(data => console.log(data));\n\n// subscriber 2, emits 0, 1, 2\nstream$.subscribe(data => console.log(data));\n\n// subscriber 3, emits 0, 1, 2, after 2 seconds\nsetTimeout(() => {\n  stream$.subscribe(data => console.log(data)); \n}, 3000);\n```", "```ts\n// hot observable scenario\n\n// subscriber 1 emits 0, 1, 2\nhotStream$.subscribe(data => console.log(data));\n\n// subscriber 2, emits 0, 1, 2\nhotStream$.subscribe(data => console.log(data));\n\n// subscriber 3, emits 2, after 2 seconds\nsetTimeout(() => {\n  hotStream$.subscribe(data => console.log(data)); \n}, 3000);\n```", "```ts\n// hot-cold-warm/hot-observable.js\n\nconst Rx = require(\"rxjs/Rx\"); \nlet  start  =  new  Date(); let  stream  =  Rx.Observable\n  .interval(1000)\n  .take(5)\n  .publish**();** \nsetTimeout(() => {  stream.subscribe(data  => {    console.log(`subscriber 1 ${new  Date() -  start}`, data);\n  });\n}, 2000); \nsetTimeout(() => {  stream.subscribe(data  => {    console.log(`subscriber 2 ${new  Date() -  start}`, data)\n  });\n}, 3000); \nstream.connect**();** stream.subscribe(\n data  =>  console.log(\n `subscriber 0 - I was here first ${new  Date() -  start}`, \n    data\n )\n);\n```", "```ts\n// hot-cold-warm/warm-observer.js\n\nconst Rx = require(\"rxjs/Rx\"); \nlet  warmStream  =  Rx.Observable.interval(1000).take(3).publish()**.**refCount**()**; let  start  =  new  Date(); setTimeout(() => {\n  warmStream.subscribe(data => {    console.log(`subscriber 1 - ${new  Date() -  start}`,data);\n  });\n}, 2000);\n```", "```ts\n// hot-cold-warm/warm-observable-subscribers.js\n\nconst Rx = require(\"rxjs/Rx\"); \nlet  warmStream  =  Rx.Observable.interval(1000).take(3).publish().refCount(); let  start  =  new  Date(); setTimeout(() => {\n  warmStream.subscribe(data => {    console.log(`subscriber 1 - ${new  Date() -  start}`,data);\n  });\n}, 1000); \nsetTimeout(() => {\n  warmStream.subscribe(data => {\n    console.log(`subscriber 2 - ${new Date() - start}`,data);\n  });\n}, 3000);\n```", "```ts\n// hot-cold-warm/warm-observable-share.js\n\nconst Rx = require(\"rxjs/Rx\"); \nlet  stream$  =  Rx.Observable.create((observer) => {  let  i  =  0;\n  let  id  =  setInterval(() => {    observer.next(i++);\n  }, 400); \n  return () => {    clearInterval(id);\n  };\n}).share**()**; \nlet  sub0, sub; \n// first subscription happens immediately\nsub0  =  stream$.subscribe(\n  (data) =>  console.log(\"subscriber 0\", data),\n  err  =>  console.error(err),\n  () =>  console.log(\"completed\"));\n\n// second subscription happens after 1 second\nsetTimeout(() => {  sub  =  stream$.subscribe(\n  (data) =>  console.log(\"subscriber 1\", data),\n  err  =>  console.error(err),\n  () =>  console.log(\"completed\"));\n}, 1000); \n// everything is unscubscribed after 2 seconds\nsetTimeout(() => {  sub0.unsubscribe();\n  sub.unsubscribe(); }, 2000);\n```", "```ts\nlet stream$ = Rx.Observable.create(observer => {\n  observer.next(1);\n  observer.next(2);\n});\n\nstream$.subscribe(data => console.log(data));\n```", "```ts\n// subjects/subject.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet subject = new Rx.Subject();\n\n// emits 1\nsubject.subscribe(data => console.log(data));\n\nsubject.next(1);\n```", "```ts\n// subjects/subjectII.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  subject  =  new  Rx.Subject(); \n// emits 10 and 100 2 seconds after\nsubject.subscribe(data  =>  console.log(data)); subject.next(10); \nsetTimeout(() => {  subject.next(100); }, 2000);\n```", "```ts\n// subjects/cascading.html\n\n<html> <body>\n  <select  id=\"countries\"></select>\n  <select  id=\"cities\"></select>\n  <select  id=\"restaurants\"></select>\n\n  <script  src=\"https://unpkg.com/rxjs/bundles/Rx.min.js\"></script>\n  <script  src=\"cascadingIV.js\"></script> </body> </html>  \n```", "```ts\n// subjects/cascadingI.js\n\nlet countriesElem = document.getElementById(\"countries\");\nlet citiesElem = document.getElementBtyId(\"cities\");\nlet restaurantsElem = document.getElementById(\"restaurants\");\n\n// talk to /cities/country/:country, get us cities by selected country\nlet countriesStream = Rx.Observable.fromEvent(countriesElem, \"select\");\n\n// talk to /restaurants/city/:city, get us restaurants by selected restaurant\nlet citiesStream = Rx.Observable.fromEvent(citiesElem, \"select\");\n\n// talk to /book/restaurant/:restaurant, book selected restaurant\nlet restaurantsElem = Rx.Observable.fromEvent(restaurantsElem, \"select\");\n\n```", "```ts\n// subjects/cascadingII.js\n\nlet countriesElem = document.getElementById(\"countries\");\nlet citiesElem = document.getElementBtyId(\"cities\");\nlet restaurantsElem = document.getElementById(\"restaurants\");\n\nfetchCountries();\n\nfunction  buildList(list, items) {\n  list.innerHTML  =\"\";\n  items.forEach(item  => {    let  elem  =  document.createElement(\"option\");\n    elem.innerHTML  =  item;\n    list.appendChild(elem);\n  });\n}\n\nfunction  fetchCountries() {\n  return  Rx.Observable.ajax(\"countries.json\")\n    .map(r =>  r.response)\n    .subscribe(countries  =>  buildList(countriesElem, countries.data)); }\n\nfunction populateCountries() {\n  fetchCountries()\n    .map(r => r.response)\n    .subscribe(countries => buildDropList(countriesElem, countries));\n}\n\nlet cities$ = new Subject();\ncities$.subscribe(cities => buildList(citiesElem, cities**))**; \nRx.Observable.fromEvent(countriesElem, \"change\")\n  .map(ev => ev.target.value)\n  .do(val => clearSelections())\n  .switchMap(selectedCountry => fetchBy(selectedCountry))\n  .subscribe( cities => cities$.next(cities.data**))**; \nRx.Observable.from(citiesElem, \"select\");\n\nRx.Observable.from(restaurantsElem, \"select\");\n```", "```ts\n// subjects/cascadingIII.js\n\nlet countriesElem = document.getElementById(\"countries\");\nlet citiesElem = document.getElementBtyId(\"cities\");\nlet restaurantsElem = document.getElementById(\"restaurants\");\n\nfetchCountries();\n\nfunction  buildList(list, items) {\n  list.innerHTML  = \"\";\n  items.forEach(item  => {    let  elem  =  document.createElement(\"option\");\n    elem.innerHTML  =  item;\n    list.appendChild(elem);\n  });\n}\n\nfunction  fetchCountries() {\n  return  Rx.Observable.ajax(\"countries.json\")\n    .map(r =>  r.response)\n    .subscribe(countries  =>  buildList(countriesElem, countries.data)); }\n\nfunction populateCountries() {\n  fetchCountries()\n    .map(r => r.response)\n    .subscribe(countries => buildDropList(countriesElem, countries));\n}\n\nlet cities$ = new Subject();\ncities$.subscribe(cities => buildList(citiesElem, cities)); \nlet restaurants$ = new Rx.Subject();\nrestaurants$.subscribe(restaurants => buildList(restaurantsElem, restaurants**));** Rx.Observable.fromEvent(countriesElem, \"change\")\n  .map(ev => ev.target.value)\n  .do( val => clearSelections())\n  .switchMap(selectedCountry => fetchBy(selectedCountry))\n  .subscribe( cities => cities$.next(cities.data)); \nRx.Observable.from(citiesElem, \"select\")\n .map(ev => ev.target.value)\n  .switchMap(selectedCity => fetchBy(selectedCity))\n  .subscribe( restaurants => restaurants$.next(restaurants.data)); // talk to /book/restaurant/:restaurant, book selected restaurant\nRx.Observable.from(restaurantsElem, \"select\");\n```", "```ts\n// subjects/cascadingIV.js\n\nlet  cities$  =  new  Rx.Subject(); cities$.subscribe(cities  =>  buildList(citiesElem, cities)); \nlet  restaurants$  =  new  Rx.Subject(); restaurants$.subscribe(restaurants  =>  buildList(restaurantsElem, restaurants)); \nfunction  buildList(list, items) {\n  list.innerHTML  = \"\"; items.forEach(item  => { let  elem  =  document.createElement(\"option\");\n    elem.innerHTML  =  item;\n    list.appendChild(elem);\n  });\n}\n\nfunction  fetchCountries() {\n  return  Rx.Observable.ajax(\"countries.json\")\n    .map(r =>  r.response)\n    .subscribe(countries  =>  buildList(countriesElem, countries.data)); }\n\nfunction  fetchBy(by) {\n  return  Rx.Observable.ajax(`${by}.json`) .map(r=>  r.response); }\n\nfunction  clearSelections() {\n  citiesElem.innerHTML  = \"\";\n  restaurantsElem.innerHTML  = \"\"; }\n\nlet  countriesElem  =  document.getElementById(\"countries\"); let  citiesElem  =  document.getElementById(\"cities\"); let  restaurantsElem  =  document.getElementById(\"restaurants\"); \nfetchCountries(); \nRx.Observable.fromEvent(countriesElem, \"change\")\n  .map(ev  =>  ev.target.value)\n  .do(val  =>  clearSelections())\n  .switchMap(selectedCountry  =>  fetchBy(selectedCountry))\n  .subscribe(cities  =>  cities$.next(cities.data)); \nRx.Observable.fromEvent(citiesElem, \"change\")\n  .map(ev  =>  ev.target.value) .switchMap(selectedCity  =>  fetchBy(selectedCity)) .subscribe(restaurants  =>  restaurants$.next(restaurants.data)); Rx.Observable.fromEvent(restaurantsElem, \"change\")\n  .map(ev => ev.target.value)\n  .subscribe(selectedRestaurant => console.log(\"selected restaurant\", selectedRestaurant));\n```", "```ts\n// subjects/behavior-subject.js\n\nlet behaviorSubject = new Rx.BehaviorSubject(\"default value\");\n\n// will emit 'default value'\nbehaviorSubject.subscribe(data => console.log(data));\n\n// long running AJAX scenario\nsetTimeout(() => {\n  return Rx.Observable.ajax(\"data.json\")\n    .map(r => r.response)\n    .subscribe(data => behaviorSubject.next(data));\n}, 12000);\n```", "```ts\n// example of emitting values before subscription\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  subject  =  new  Rx.Subject(); subject.next(\"subject first value\");\n\n// emits 'subject second value' subject.subscribe(data  =>  console.log(\"subscribe - subject\", data)); subject.next(\"subject second value\"); \nlet  behaviourSubject  =  new  Rx.BehaviorSubject(\"behaviorsubject initial value\"); behaviourSubject.next(\"behaviorsubject first value\"); behaviourSubject.next(\"behaviorsubject second value\");\n\n// emits 'behaviorsubject second value', 'behaviorsubject third value' behaviourSubject.subscribe(data  =>\n  console.log(\"subscribe - behaviorsubject\", data) );\n\nbehaviourSubject.next(\"behaviorsubject third value\");\n```", "```ts\n// subjects/replay-subject.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  replaySubject  = new Rx.ReplaySubject(2); \nreplaySubject.next(1); replaySubject.next(2); replaySubject.next(3);\n\n// emitting 2 and 3 replaySubject.subscribe(data  =>  console.log(data));\n```", "```ts\n// subjects/replay-subject-window-size.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  replaySubjectWithWindow  =  new  Rx.ReplaySubject(2, 2000); replaySubjectWithWindow.next(1); replaySubjectWithWindow.next(2); replaySubjectWithWindow.next(3); \nsetTimeout(() => {  replaySubjectWithWindow.subscribe(data  =>\n    console.log(\"replay with buffer and window size\", data));\n  }, \n2010);\n```", "```ts\n// subjects/async-subject.js\n\nlet  asyncSubject  =  new  Rx.AsyncSubject(); asyncSubject.next(1); asyncSubject.next(2); asyncSubject.next(3); asyncSubject.next(4); \nasyncSubject.subscribe(data  =>  console.log(data), err  =>  console.error(err));  \n```", "```ts\n// subjects/async-subject-complete.js\n\nlet  asyncSubject  =  new  Rx.AsyncSubject(); asyncSubject.next(1); asyncSubject.next(2); asyncSubject.next(3); asyncSubject.next(4);\n\n// emits 4 asyncSubject.subscribe(data  =>  console.log(data),  err  =>  console.error(err)); asyncSubject.complete();  \n```", "```ts\n// example of a stream with an error\n\nlet stream$ = Rx.Observable.create(observer => {\n  observer.next(1);\n  observer.error('an error is thrown');  \n  observer.next(2);\n});\n\nstream$.subscribe(\n  data => console.log(data), // 1 \n  error => console.error(error) // 'error is thrown'\n);\n```", "```ts\n// error-handling/error-catch.js\nconst Rx = require(\"rxjs/Rx\");\n\nlet  stream$  =  Rx.Observable.create(observer  => {  observer.next(1); observer.error(\"an error is thrown\");\n  observer.next(2); }).catch(err => Rx.Observable.of(err**))**; stream$.subscribe(\n data  =>  console.log(data), // emits 1 and 'error is thrown'\n error  =>  console.error(error)\n);  \n```", "```ts\n// example of merging several streams\n\nlet  merged$  =  Rx.Observable.merge(\n  Rx.Observable.of(1),\n  Rx.Observable.throw(\"err\"),\n  Rx.Observable.of(2) );\n\nmerged$.subscribe(data  =>  console.log(\"merged\", data));\n```", "```ts\n// error-handling/error-merge-catch.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  merged$  =  Rx.Observable.merge(\n  Rx.Observable.of(1),\n  Rx.Observable.throw(\"err\")**.**catch(err => Rx.Observable.of(err**))**,\n  Rx.Observable.of(2) );\n\nmerged$.subscribe(data  =>  console.log(\"merged\", data));\n```", "```ts\n// error-handling/error-ignore.js\nconst Rx = require(\"rxjs/Rx\");\n\nlet  mergedIgnore$  =  Rx.Observable.onErrorResumeNext(\n  Rx.Observable.of(1),\n  Rx.Observable.throw(\"err\"),\n  Rx.Observable.of(2) );\n\nmergedIgnore$.subscribe(data  =>  console.log(\"merge ignore\", data));\n```", "```ts\n// error-handling/error-retry.js\nconst Rx = require(\"rxjs/Rx\");\n\nlet  stream$  =  Rx.Observable.create(observer  => {  observer.next(1);\n  observer.error(\"err\"); })\n.retry(3);\n\n// emits 1 1 1 1 err\nstream$\n  .subscribe(data  =>  console.log(data));\n```", "```ts\n// example of using a retry with AJAX\n\nlet  ajaxStream$  =  Rx.Observable.ajax(\"UK1.json\")   .map(r  =>  r.response)\n  .retry(3); \n```", "```ts\najaxStream$.subscribe(\n  data  =>  console.log(\"ajax result\", data),\n  err  =>  console.error(\"ajax error\", err) );\n```", "```ts\n// retry with a delay\n\nlet  ajaxStream$  =  Rx.Observable.ajax(\"UK1.json\")\n  .do(r  =>  console.log(\"emitted\"))\n  .map(r  =>  r.response)\n  .retryWhen(err  => {    return  err.delay(3000);\n  });\n```", "```ts\n// error-handling/error-retry-advanced.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet  ajaxStream$  =  Rx.Observable.ajax(\"UK1.json\")\n  .do(r  =>  console.log(\"emitted\"))\n  .map(r  =>  r.response)\n  .retryWhen(err  => {    return  err\n    .delay(3000)\n    .take(3); });  \n```", "```ts\n// error-handling/error-retry-advanced-fail.js\n\nlet  ajaxStream$  =  Rx.Observable.ajax(\"UK1.json\")\n  .do(r  =>  console.log(\"emitted\"))\n  .map(r  =>  r.response)\n  .retryWhen(err  => {    return  err\n    .delay(3000)\n    .take(3)\n  .concat(Rx.Observable.throw(\"giving up\")); });\n```", "```ts\n// error-handling/error-retry-errorcodes.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nfunction  isOkError(errorCode) {\n  return  errorCode  >=  400  &&  errorCode  <  500; }\n\nlet  ajaxStream$  =  Rx.Observable.ajax(\"UK1.json\")\n  .do(r  =>  console.log(\"emitted\"))\n  .map(r  =>  r.response)\n  .retryWhen(err  => {    return  err\n      .do(val  => {        if (!isOkError(val.status) ||  timesToRetry  ===  0) {\n          throw  \"give up\";\n        }\n      })\n      .delay(3000);\n  });\n```", "```ts\nng new MarbleTesting\n```", "```ts\ncd MarbleTesting\nnpm install jasmine-marbles --save\n```", "```ts\n// marble-testing\\MarbleTesting\\src\\app\\marble-testing.spec.ts\n\nimport { cold } from  \"jasmine-marbles\"; import  \"rxjs/add/operator/map\"; describe(\"marble tests\", () => {\n  it(\"map - should increase by 1\", () => {    const one$ = cold(\"x-x|\", { x: 1 });    expect(one$.map(x => x +  1)).toBeObservable(cold(\"x-x|\", { x: 2 }));  });\n});\n```", "```ts\nconst stream$ = cold(\"x-x|\", { x: 1 });\n```", "```ts\nexpect(stream$.map(x => x +  1)).toBeObservable(cold(\"x-x|\", { x: 2 }));\n```", "```ts\ncold(\"x-x|\", { x: 2 })\n```", "```ts\nimport { cold } from  \"jasmine-marbles\"; import  \"rxjs/add/operator/map\"; import \"rxjs/add/operator/filter\"**;** \ndescribe(\"marble testing\", () => {  it(\"map - should increase by 1\", () => {    const one$ = cold(\"x-x|\", { x: 1 });    expect(one$.map(x => x +  1)).toBeObservable(cold(\"x-x|\", { x: 2 }));  });\n\n  it(\"filter - should remove values\", () => {\n    const stream$ = cold(\"x-y|\", { x: 1, y: 2 });\n    expect(stream$.filter(x => x > 1)).toBeObservable(cold(\"--y|\", { y: 2 }));\n  });\n});\n```", "```ts\ncold(\"--y|\", { y: 2 })\n```", "```ts\nimport  Rx  from  \"rxjs/Rx\";\n```", "```ts\nimport { Observable } from 'rxjs/Observable';\nimport \"rxjs/add/operator/map\";\nimport \"rxjs/add/operator/take\";\n\nlet stream = Observable.interval(1000)\n  .map(x => x +1)\n  .take(2)\n```", "```ts\nimport \"rxjs/add/operator/map\";\n```", "```ts\nvar  Observable_1  =  require('../../Observable'); var  map_1  =  require('../../operator/map'); Observable_1.Observable.prototype.map  =  map_1.map;\n```", "```ts\nimport { operator } from 'some/path';\n\noperator();\n```", "```ts\nimport  Rx  from  \"rxjs/Rx\"; \nlet  stream  =  Rx.Observable.of(0,1,2); let  addAndFilter  =  obs  =>  obs.map( x =>  x  *  10).filter(x  =>  x  %  10  ===  0); let  sub3  =  obs  =>  obs.map(x  =>  x  -  3); \nstream\n  .let(addAndFilter)\n  .let(sub3)\n  .subscribe(x  =>  console.log('let', x));  \n```", "```ts\nimport { map } from \"rxjs/operators/map\";\nimport { filter } from \"rxjs/operators/filter\";\n```", "```ts\nimport { map } from \"rxjs/operators/map\";\nimport { filter } from \"rxjs/operators\";\nimport { of } from \"rxjs/observable/of\";\nimport { Observable } from \"rxjs/Observable\";\n\nlet stream = of(1,2);\nstream.pipe(\n  map(x => x + 1),\n  filter(x => x > 1)\n)\n.subscribe(x => console.log(\"piped\", x)); // emits 2 and 3\n```"]