- en: Chapter 4. Calling Java Back from Native Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。从本地代码调用Java回调
- en: '*To reach its full potential, JNI allows calling back Java code from C/C++.
    "Back" because native code is first invoked from Java, which in turn calls it
    back. Such calls are performed through a reflective API, which allows doing almost
    anything that can be done directly in Java.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*为了发挥其最大潜力，JNI允许从C/C++回调Java代码。 "回调"是因为首先从Java调用本地代码，然后再次调用它。这些调用是通过反射API执行的，它允许几乎可以直接在Java中完成的任何操作。*'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Another important matter to consider with JNI is threading. Native code can
    be run on a Java thread, managed by the Dalvik VM, and also from a native thread
    created with standard POSIX primitives. Obviously, a native thread cannot call
    JNI code unless it is turned into a managed Java thread! Programming with JNI
    necessitates knowledge of all these subtleties. This chapter will guide you through
    the main ones.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*JNI的另一个重要问题是线程。本地代码可以在由Dalvik VM管理的Java线程上运行，并且还可以从使用标准POSIX原语创建的本地线程上运行。显然，除非将本地线程转换为受管理的Java线程，否则本地线程无法调用JNI代码！使用JNI编程需要了解所有这些微妙之处。本章将指导您了解主要内容。*'
- en: '>'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*The last topic, which is specific to Android and not JNI, other: the Android-specific
    Bitmap API aims at giving full processing power to graphics applications running
    on these tiny (but powerful) devices.*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最后一个主题，这是特定于Android而不是JNI的，其他：Android特定的Bitmap API旨在为在这些微小（但强大）设备上运行的图形应用程序提供完整的处理能力。*'
- en: '>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*The Android NDK also proposes a new API to access natively an important type
    of object: bitmaps. The Bitmap API, which is Android-specific, gives full processing
    power to graphics applications running on these tiny (but powerful) devices.*'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android NDK还提出了一种新的API来本地访问一种重要类型的对象：位图。 Android特定的Bitmap API为在这些微小（但强大）设备上运行的图形应用程序提供了完整的处理能力。*'
- en: The `Store` project we started in the previous chapter is going to be our canvas
    to demonstrate JNI callbacks and synchronization. To illustrate Bitmap processing,
    we are going to create a new project that decodes a device's camera feed inside
    native code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中开始的`Store`项目将成为我们演示JNI回调和同步的画布。为了说明位图处理，我们将创建一个新项目，该项目在本地代码中解码设备的摄像头视频流。
- en: 'To summarize, in this chapter, we are going to learn how to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们将学习如何：
- en: Call Java back from native code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地代码调用Java回调
- en: Attach a native thread to the Dalvik VM and handle synchronization with Java
    threads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地线程附加到Dalvik VM并处理与Java线程的同步
- en: Process Java bitmaps in native code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中处理Java位图
- en: By the end of this chapter, you should be able to make Java and C/C++ communicate
    and synchronize reciprocally.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够使Java和C/C++相互通信和同步。
- en: Calling Java back from native code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地代码调用Java回调
- en: 'In the previous chapter, we discovered how to get a Java class descriptor with
    the JNI method `FindClass()`. However, we can get much more! Actually, if you
    are a regular Java developer, this should remind you of something: the Java Reflection
    API. JNI is similar in that it can modify Java object fields, run Java methods,
    and access static members, but from native code!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了如何使用JNI方法`FindClass()`获取Java类描述符。但是，我们可以得到更多！实际上，如果您是一名常规的Java开发人员，这应该让您想起一些事情：Java反射API。
    JNI类似于它可以修改Java对象字段，运行Java方法并访问静态成员，但是从本地代码！
- en: For this last part with the `Store` project, let's enhance our store application
    so that it notifies Java when an entry has been successfully inserted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Store`项目的最后一部分，让我们增强我们的商店应用程序，以便在成功插入条目时通知Java。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part10`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '生成的项目将在本书中以`Store_Part10`的名称提供。 '
- en: Time for action – determining JNI method signatures
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-确定JNI方法签名
- en: 'Let''s define a Java interface that native C/C++ code will call back through
    JNI:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个Java接口，本地C/C++代码将通过JNI回调：
- en: 'Create a `StoreListener.java`, which contains an interface defining a few callbacks,
    one for integers, one for strings, and one for colors, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`StoreListener.java`，其中包含一个定义几个回调的接口，一个用于整数，一个用于字符串，一个用于颜色，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open `Store.java` and make a few changes.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Store.java`并进行一些更改。
- en: Declare a member delegate `StoreListener`, to which success callbacks are sent
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个成员委托`StoreListener`，成功回调将发送到该委托
- en: Change the `Store` constructor to inject the delegate listener, which is going
    to be `StoreActivity`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`Store`构造函数以注入委托监听器，该监听器将是`StoreActivity`
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, implement the `StoreListener` interface and its corresponding methods,
    which simply forwards calls to the delegate:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现`StoreListener`接口及其相应的方法，简单地将调用转发给委托：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open `StoreActivity.java` and implement the `StoreListener` interface in `PlaceholderFragment`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreActivity.java`并在`PlaceholderFragment`中实现`StoreListener`接口。
- en: 'Also, change the `Store` construction accordingly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还要相应地更改`Store`构造：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a success callback is received, a simple toast message is raised:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 收到成功回调时，会弹出一个简单的提示消息：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open a terminal in the `Store` project's directory and run the `javap` command
    to determine method signatures.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store`项目目录中打开终端并运行`javap`命令以确定方法签名。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Time for action – determining JNI method signatures](img/9645_04_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-确定JNI方法签名](img/9645_04_01.jpg)'
- en: '*What just happened?*'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Calling back Java methods with the JNI API requires **descriptors**, as we will
    see in the next part. To determine a Java method descriptor, we need a **signature**.
    Indeed, methods in Java can be **overloaded**, which means that there can be two
    methods with the same name but different parameters. This is why a signature is
    required.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JNI API调用Java方法需要**描述符**，我们将在下一部分中看到。要确定Java方法描述符，我们需要一个**签名**。实际上，Java中的方法可以**重载**，这意味着可以有两个具有相同名称但不同参数的方法。这就是为什么需要签名。
- en: 'We can determine a method''s signature with `javap`, a JDK utility to disassemble
    `.class` files. This signature can then be given to the JNI Reflection API. Formally
    speaking, a signature is declared in the following way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`javap`确定方法的签名，这是一个用于反汇编`.class`文件的JDK实用程序。然后可以将此签名提供给JNI Reflection API。严格来说，签名是以以下方式声明的：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For example, the signature for the method `boolean myFunction(android.view.View
    pView, int pIndex)` would be `(Landroid/view/View;I)Z`. Another example, `(I)V`,
    means an integer is expected and a void is returned. A last example, `(Ljava/lang/String;)V`,
    means a String is passed in parameter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，方法`boolean myFunction(android.view.View pView, int pIndex)`的签名将是`(Landroid/view/View;I)Z`。另一个例子，`(I)V`表示期望一个整数并返回一个void。最后一个例子，`(Ljava/lang/String;)V`表示传递了一个String参数。
- en: 'The following table summarizes the various types available in JNI with their
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了JNI中可用的各种类型及其代码：
- en: '| Java type | Native type | Native array type | Type code | Array type code
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Java类型 | 本机类型 | 本机数组类型 | 类型代码 | 数组类型代码 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |'
- en: '| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |'
- en: '| `char` | `jchar` | `jcharArray` | `C` | `[C` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `jchar` | `jcharArray` | `C` | `[C` |'
- en: '| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |'
- en: '| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |'
- en: '| `int` | `jint` | `jintArray` | `I` | `[I` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `jint` | `jintArray` | `I` | `[I` |'
- en: '| `long` | `jlong` | `jlongArray` | `J` | `[J` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `jlong` | `jlongArray` | `J` | `[J` |'
- en: '| `Short` | `jshort` | `jshortArray` | `S` | `[S` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | `jshort` | `jshortArray` | `S` | `[S` |'
- en: '| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |'
- en: '| `String` | `jstring` | `N/A` | `L` | `[L` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `jstring` | `N/A` | `L` | `[L` |'
- en: '| `Class` | `jclass` | `N/A` | `L` | `[L` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Class` | `jclass` | `N/A` | `L` | `[L` |'
- en: '| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |'
- en: '| `void` | `void` | `N/A` | `V` | `N/A` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `void` | `N/A` | `V` | `N/A` |'
- en: All these values correspond to the one dumped by `javap`. For more information
    about descriptors and signatures, have a look at the Oracle documentation at [http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都对应于`javap`转储的值。有关描述符和签名的更多信息，请参阅Oracle文档[http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3)。
- en: Now that we have the proper signature, we can start calling Java from C/C++.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正确的签名，我们可以开始从C/C++调用Java。
- en: Time for action – calling back Java from native code
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-从本机代码回调Java
- en: 'Let''s continue our `Store` by calling back the interface we defined from native
    code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过从本机代码调用定义的接口来回调我们的`Store`：
- en: 'In `com_packtpub_store_Store.cpp`, declare method descriptors with type `jmethodID`
    for each callback, which is going to be cached:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com_packtpub_store_Store.cpp`中，为每个回调声明类型为`jmethodID`的方法描述符，这些描述符将被缓存：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, cache all the callback descriptors in `JNI_OnLoad()`. This can be done
    in two main steps:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`JNI_OnLoad()`中缓存所有回调描述符。这可以通过两个主要步骤完成：
- en: 'Getting a Class descriptor with the JNI method `FindClass()`. One can find
    a class descriptor, thanks to its absolute package path, here: `com./packtpub/store/Store`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JNI方法`FindClass()`获取类描述符。可以通过其绝对包路径找到类描述符，例如：`com./packtpub/store/Store`。
- en: 'Retrieving a method descriptor from the class descriptor with `GetMethodID()`.
    To differentiate several overloaded methods, the signatures retrieved earlier
    with `javap` must be specified:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GetMethodID()`从类描述符中检索方法描述符。为了区分几个重载的方法，必须指定先前使用`javap`检索到的签名：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notify the Java Store (that is, `pThis`) when an integer is successfully inserted
    in `setInteger()`. To invoke a Java method on a Java object, simply use `CallVoidMethod()`
    (which means that the called Java method returns void). To do so, we need:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当成功将整数插入`setInteger()`时，通知Java Store（即`pThis`）。要在Java对象上调用Java方法，只需使用`CallVoidMethod()`（这意味着被调用的Java方法返回void）。为此，我们需要：
- en: An object instance
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象实例
- en: A method signature
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名
- en: Effective parameters to pass, if applicable (here, an integer value)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的有效参数（如果适用）（这里是整数值）
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Repeat the operation for strings. There is no need to generate a Global reference
    when allocating the returned Java string as it is used immediately in the Java
    callback. We can also destroy the Local reference to this string right after usage,
    but JNI will take care of that when returning from the native callback:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复字符串的操作。在分配返回的Java字符串时，无需生成全局引用，因为它立即在Java回调中使用。我们还可以在使用后立即销毁对此字符串的本地引用，但是当从本机回调返回时，JNI会处理这一点：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, repeat the operation for colors:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为颜色重复操作：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*What just happened?*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Launch the application and insert an integer, a string, or color entry. A successful
    message is displayed with the inserted value. The native code called the Java
    side thanks to the JNI Reflection API. This API is not only useful to execute
    a Java method, it is also the only way to process `jobject` parameters passed
    to a native method. However, if calling C/C++ code from Java is rather easy, performing
    Java operations from C/C++ is a bit more involving!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并插入整数、字符串或颜色条目。成功消息将显示插入的值。本机代码通过JNI Reflection API调用了Java端。这个API不仅对执行Java方法有用，它也是处理传递给本机方法的`jobject`参数的唯一方法。但是，如果从Java调用C/C++代码相当容易，从C/C++执行Java操作就需要更多的投入！
- en: 'Although a bit repetitive and verbose, calling any Java method should always
    be as trivial as this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有点重复和啰嗦，但调用任何Java方法应始终像这样简单：
- en: 'Retrieve the class descriptor from those we want to call methods (here, the
    `Store` Java object):'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们想要调用方法的类描述符中检索类描述符（这里是`Store` Java对象）：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Retrieve the method descriptors for the callback we want to call (such as the
    `Method` class in Java). These method descriptors are retrieved from the class
    descriptor, which owns it (like a `Class` in Java):'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索我们想要调用的回调的方法描述符（例如 Java 中的 `Method` 类）。这些方法描述符是从拥有它的类描述符中检索的（就像 Java 中的 `Class`）：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Optionally, cache the descriptors so that they can be used immediately in future
    native calls. Again, `JNI_OnLoad()` makes it easy to cache JNI descriptors before
    any native call is made. Descriptors whose names end with `Id`, such as `jmethodID`,
    can be freely cached. They are not references that can be leaked, or have to be
    made global on the opposite to `jclass` descriptors.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选择地缓存描述符，以便它们可以立即在将来的本机调用中使用。同样，`JNI_OnLoad()` 使得在进行任何本机调用之前缓存 JNI 描述符变得容易。以
    `Id` 结尾的描述符，如 `jmethodID`，可以自由缓存。它们不是可以泄漏的引用，也不需要与 `jclass` 描述符相反地全局化。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Caching descriptors is definitely good practice, as retrieving Fields or Methods
    through the JNI reflection may cause some overhead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存描述符绝对是一个好的做法，因为通过 JNI 反射检索字段或方法可能会导致一些开销。
- en: 'Invoke methods with the necessary parameters on an object. The same method
    descriptor can be reused on any object instance of the corresponding class:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象上调用具有必要参数的方法。相同的方法描述符可以在相应类的任何对象实例上重复使用：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whatever method you need to call on a Java object, the same process always applies.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您需要在 Java 对象上调用什么方法，都是同样的过程。
- en: More on the JNI Reflection API
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于 JNI 反射 API 的信息
- en: 'Once you know the Reflection API, you know most of the JNI. Here are some of
    the provided methods that may be useful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了 Reflection API，您就了解了大部分 JNI。以下是一些可能有用的提供的方法：
- en: '`FindClass()` retrieves a (Local) reference to a `Class` descriptor object
    according to its absolute path:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindClass()` 根据其绝对路径检索 `Class` 描述符对象的（本地）引用：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`GetObjectClass()` has the same purpose, except that `FindClass()` finds class
    definitions according to their absolute path, whereas the other finds the class
    directly from an object instance (such as `getClass()` in Java):'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetObjectClass()` 具有相同的目的，只是 `FindClass()` 根据其绝对路径查找类定义，而另一个是直接从对象实例中查找类（例如
    Java 中的 `getClass()`）：'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following methods allow you to retrieve JNI descriptors for methods and
    fields, and either static or instance members. These descriptors are IDs and not
    references to Java objects. There is no need to turn them into Global references.
    These methods require the method or field name and a signature to differentiate
    overloads. Constructor descriptors are retrieved in the same way as methods, except
    that their name is always `<init>` and they have a void return value:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下方法允许您检索方法和字段的 JNI 描述符，以及静态或实例成员。这些描述符是 ID，而不是对 Java 对象的引用。无需将它们转换为全局引用。这些方法需要方法或字段名称和签名以区分重载。构造函数描述符的检索方式与方法相同，只是它们的名称始终为
    `<init>`，并且具有 void 返回值：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a second set of methods to retrieve field values using their corresponding
    descriptors. There is one getter and one setter method per primitive type, plus
    another for objects:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有第二组方法用于使用相应的描述符检索字段值。每种原始类型都有一个 getter 和一个 setter 方法，另外还有一个用于对象的方法：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same goes for methods according to their return values:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于根据其返回值的方法也是一样的：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Variants of these methods exist with an `A` and `V` postfix. The behavior is
    identical, except that arguments are specified respectively using a `va_list`
    (that is, variable argument list) or `jvalue` array (`jvalue` being a union of
    all JNI types):'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法的变体带有 `A` 和 `V` 后缀。行为是相同的，只是参数分别使用 `va_list`（即可变参数列表）或 `jvalue` 数组来指定（`jvalue`
    是所有 JNI 类型的联合体）：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Have a look at `jni.h` in the Android NDK `include` directory to see all the
    possibilities by the JNI reflective API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Android NDK `include` 目录中的 `jni.h`，以查看 JNI 反射 API 提供的所有可能性。
- en: Debugging JNI
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 JNI
- en: The goal of JNI calls is often performance. Thus, JNI does not perform advanced
    checking when its API methods are invoked. Hopefully, there exists an **extended
    checking** mode, which performs advanced checks and gives feedback in the Android
    Logcat.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 调用的目标通常是性能。因此，当调用其 API 方法时，JNI 不执行高级检查。希望存在一个**扩展检查**模式，它执行高级检查并在 Android
    Logcat 中提供反馈。
- en: 'To activate it, run the following command from a command prompt:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活它，请从命令提示符中运行以下命令：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The extended checking mode is available for applications started after this
    flag is set, until it is set to `0`, or until the device is rebooted. For rooted
    devices, the whole device can be started with this mode with the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此标志后启动的应用程序可用扩展检查模式，直到它设置为 `0`，或者直到设备重新启动。对于 root 设备，可以使用以下命令以此模式启动整个设备：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If everything works properly, a message **Late-enabling – Xcheck:jni** appears
    in the Logcat when your application starts. Then, check the Logcat regularly to
    find its JNI warning or error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，当您的应用程序启动时，Logcat 中会出现消息 **Late-enabling – Xcheck:jni**。然后，定期检查 Logcat
    以查找其 JNI 警告或错误。
- en: '![Debugging JNI](img/9645_04_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![调试 JNI](img/9645_04_04.jpg)'
- en: Synchronizing Java and native threads
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步 Java 和本机线程
- en: Parallel programming is a mainstream subject nowadays. Android makes no exception
    since the introduction of multicore processors. You can do the threading entirely
    on the Java side (with the Java Thread and Concurrency APIs), on the native side
    (with the **POSIX PThread** API, which is provided by the NDK), and, more interestingly,
    between the Java and native side using JNI.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程是当今的主流话题。自多核处理器引入以来，Android 也不例外。您可以完全在 Java 端进行线程处理（使用 Java 线程和并发 API），在本机端进行线程处理（使用
    NDK 提供的 **POSIX PThread** API），更有趣的是，在 Java 和本机端之间使用 JNI 进行线程处理。
- en: In this part, we will create a background thread, the watcher, which keeps a
    constant eye on what is inside the data store. It iterates through all entries
    and then sleeps for a fixed amount of time. When the watcher thread finds a key
    of a specific type predefined in the code, it acts accordingly. For this first
    part, we are just going to clip integer values to a predefined range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将创建一个后台线程，观察者，它会不断关注数据存储中的内容。它会遍历所有条目，然后休眠一段固定的时间。当观察者线程发现代码中预定义类型的键时，它会相应地采取行动。在这第一部分中，我们只会将整数值剪切到预定义的范围。
- en: Of course, threads need synchronization. The native thread is going to access
    and update the store only when a user understands the UI thread, and does not
    modify it. The native thread is created in C/C++ but the UI thread is a Java thread.
    We are going to use JNI monitors to synchronize both of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，线程需要同步。当用户了解UI线程并且不修改它时，本地线程才能访问和更新存储。本地线程是在C/C++中创建的，但UI线程是一个Java线程。我们将使用JNI监视器来同步它们。
- en: Time for action – allocating an object with JNI
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-使用JNI分配对象
- en: 'Let''s define a background Watcher that will use an object shared between Java
    and C/C++ as a lock:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个后台观察者，它将使用在Java和C/C++之间共享的对象作为锁：
- en: 'In `Store.java`, add two new methods to start and stop a watcher thread. These
    methods respectively return and take a `long` as parameter. This value helps us
    hold a native pointer on the Java side:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store.java`中，添加两个新方法来启动和停止观察者线程。这些方法分别返回和接受一个`long`作为参数。这个值帮助我们在Java端保存一个本机指针：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new file, `StoreThreadSafe.java`. The `StoreThreadSafe` class inherits
    from the `Store` class and aims at making the `Store` instances thread-safe using
    `synchronized` Java blocks. Declare a static member field `LOCK` of type `Object`
    and define a default constructor:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`StoreThreadSafe.java`。`StoreThreadSafe`类继承自`Store`类，旨在使用`synchronized`
    Java块使`Store`实例线程安全。声明一个类型为`Object`的静态成员字段`LOCK`并定义一个默认构造函数：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Override the `Store` methods, such as `getCount()`, `getInteger()`, and `setInteger()`
    using Java blocks synchronized with the `LOCK` object:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java块覆盖`Store`方法，如`getCount()`，`getInteger()`和`setInteger()`，并与`LOCK`对象同步：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Do the same for all other methods, such as `getString()`, `setString()`, `getColor()`,
    `setColor()`, etc., and the `stopWatcher()` method. Do not override the `onSuccess`
    callbacks and the `startWatcher()` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有其他方法执行相同的操作，比如`getString()`，`setString()`，`getColor()`，`setColor()`等，以及`stopWatcher()`方法。不要覆盖`onSuccess`回调和`startWatcher()`方法：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do *not* override the `onSuccess` callbacks and the `startWatcher()` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要*覆盖`onSuccess`回调和`startWatcher()`方法。'
- en: 'Open `StoreActivity.java` and replace the previous `Store` instance with an
    instance of `StoreThreadSafe`. Also, create a member field of type `long` to hold
    a native pointer to the watcher thread. When the fragment is resumed, start the
    watcher thread and save its pointer. When the fragment is paused, stop the watcher
    thread with the previously saved pointer:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreActivity.java`并用`StoreThreadSafe`的实例替换先前的`Store`实例。此外，创建一个类型为`long`的成员字段，用于保存观察者线程的本机指针。当片段恢复时，启动观察者线程并保存其指针。当片段暂停时，使用先前保存的指针停止观察者线程：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Edit `jni/Store.h` and include a new header `pthread.h`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/Store.h`并包含一个新的头文件`pthread.h`：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The watcher works on a `Store` instance updated at regular intervals of time.
    It needs:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者在固定时间间隔内更新的`Store`实例上工作。它需要：
- en: The instance of the `Store` structure it watches
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它观察的`Store`结构的实例
- en: A `JavaVM`, which is the only object safely shareable among threads and from
    which `JNIEnv` can be safely retrieved
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`JavaVM`，这是唯一可以在线程之间安全共享的对象，可以从中安全地检索`JNIEnv`
- en: A Java object to synchronize on (corresponding to the `LOCK` object we defined
    on the Java side)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Java对象进行同步（对应于我们在Java端定义的`LOCK`对象）
- en: A `pthread` variable dedicated to native thread management
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专门用于本地线程管理的`pthread`变量
- en: An indicator to stop the watcher thread
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示器，用于停止观察者线程
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, define three methods to start and stop the watcher thread, run its
    main loop, and process an entry:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义三个方法来启动和停止观察者线程，运行其主循环，并处理一个条目：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. You should
    see two new methods, `Java_com_packtpub_store_Store_startWatcher()` and `Java_com_packtpub_store_Store_stopWatcher()`,
    in it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javah`刷新JNI头文件`jni/com_packtpub_Store.h`。你应该在其中看到两个新方法，`Java_com_packtpub_store_Store_startWatcher()`和`Java_com_packtpub_store_Store_stopWatcher()`。
- en: In `com_packtpub_store_Store.cpp`, create a new static variable `gLock` that
    is going to hold the Java synchronization object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`com_packtpub_store_Store.cpp`中，创建一个新的静态变量`gLock`，它将保存Java同步对象。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create an instance of the `Object` class in `JNI_OnLoad()` using the JNI Reflection
    API:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`JNI_OnLoad()`中使用JNI反射API创建`Object`类的实例：
- en: First, find its `Object` constructor with `GetMethodID()`. Constructors in JNI
    are named `<init>` and have no result.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用`GetMethodID()`找到它的`Object`构造函数。JNI中的构造函数命名为`<init>`，没有结果。
- en: Then, invoke the constructor to create an instance and make it global.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，调用构造函数创建一个实例并使其全局。
- en: 'Finally, remove local references when they become useless:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当它们变得无用时，删除本地引用：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save the created `Object` instance in the `StoreThreadSafe.LOCK` field. This
    object is going to be used during the lifetime of the application to synchronize:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的`Object`实例保存在`StoreThreadSafe.LOCK`字段中。这个对象将在应用程序的生命周期中用于同步：
- en: First, retrieve the `StoreThreadSafe` class and its `LOCK` field using the JNI
    Reflection methods `FindClass()` and `GetStaticFieldId()`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用JNI反射方法`FindClass()`和`GetStaticFieldId()`检索`StoreThreadSafe`类及其`LOCK`字段
- en: Then, save the value into the `LOCK` static field with the JNI method `SetStaticObjectField()`,
    which requires a field signature (such as methods)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用JNI方法`SetStaticObjectField()`将值保存到`LOCK`静态字段中，该方法需要字段签名（如方法）
- en: 'Finally, remove the local reference to the `StoreThreadSafe` class when it
    becomes useless:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当`StoreThreadSafe`类变得无用时，删除对`StoreThreadSafe`类的本地引用：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement `startWatcher()`, which calls the corresponding method defined earlier.
    It requires `JavaVM`, which can be retrieved from the `JNIEnv` object with `GetJavaVM()`.
    The pointer (that is, the memory address) to the created `Store` is returned as
    a `long` value to the Java side, which can then store it for alter use:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`startWatcher()`，调用之前定义的相应方法。它需要`JavaVM`，可以从`JNIEnv`对象中使用`GetJavaVM()`获取。创建的`Store`的指针（即内存地址）以`long`值的形式返回给Java端，然后可以存储以备后用：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Terminate by implementing `stopWatcher()`, which casts the given `long` value
    back to a native pointer. Pass it to the corresponding method:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现`stopWatcher()`来终止，将给定的`long`值转换回本地指针。将其传递给相应的方法：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*What just happened?*'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We used JNI to allocate a Java object from native code and save it in a static
    Java field. This example shows the power of the JNI Reflection API; almost anything
    that can be done in Java, can be done from native code with JNI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JNI从本地代码中分配Java对象并将其保存在静态Java字段中。这个例子展示了JNI Reflection API的强大之处；几乎任何可以在Java中完成的事情，都可以通过JNI从本地代码中完成。
- en: 'To allocate Java objects, JNI provides the following methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配Java对象，JNI提供了以下方法：
- en: '`NewObject()` to instantiate a Java object using the specified constructor
    method:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewObject()`使用指定的构造方法实例化Java对象：'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Variants of this method exist with an `A` and `V` postfix. Behavior is identical,
    except that arguments are specified respectively using a `va_list` or a `jvalue`
    array:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的变体带有`A`和`V`后缀。行为是相同的，只是参数分别使用`va_list`或`jvalue`数组指定：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`AllocObject()` allocates a new object but does not invoke its constructor.
    A possible usage would be the allocation of many of the objects, which does not
    require initialization to get some performance gains. Use it only if you know
    what you are doing:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllocObject()`分配一个新对象，但不调用其构造函数。可能的用法是分配许多对象，这不需要初始化以获得一些性能提升。只有在您知道自己在做什么时才使用它：'
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous chapter, we used static variables for the native store because
    its life cycle was tied to the application. We want to remember values until the
    application exits. If a user leaves the activity and comes back to it later, values
    are still available while the process remains alive.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为本地存储使用了静态变量，因为它的生命周期与应用程序绑定。我们希望在应用程序退出之前记住值。如果用户离开活动并稍后回到它，只要进程保持活动状态，值仍然可用。
- en: For the watcher thread we used a different strategy because its life cycle is
    tied to the activity. When the activity gains focus, the thread is created and
    started. When activity loses focus, the thread is stopped and destroyed. Since
    this thread may need time to stop, several occurrences may run temporarily at
    the same time (if you turn the screen quickly multiple times in the `Store` example).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于观察者线程，我们使用了不同的策略，因为它的生命周期与活动相关联。当活动获得焦点时，线程被创建并启动。当活动失去焦点时，线程被停止和销毁。由于这个线程可能需要时间来停止，多次发生可能会在同一时间暂时运行（例如在`Store`示例中快速多次转动屏幕）。
- en: Thus, it is not safe to use static variables as it could be concurrently overwritten
    (leading to a memory leak), or, even worse, released (leading to memory corruption).
    These kind of problems can also arise when an activity starts another one. In
    that case, `onStop()` and `onDestroy()` of the first activity occurs after `onCreate()`
    and `onStart()` of the second activity, as defined in the Android Activity life
    cycle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用静态变量并不安全，因为它可能会被同时覆盖（导致内存泄漏），甚至更糟的是被释放（导致内存损坏）。当一个活动启动另一个活动时，也可能出现这种问题。在这种情况下，第一个活动的`onStop()`和`onDestroy()`会在第二个活动的`onCreate()`和`onStart()`之后发生，这是在Android活动生命周期中定义的。
- en: Instead, a better solution to handle this situation is to allow the Java side
    to manage the native memory. In our example, a pointer to a native structure allocated
    on the native side is returned to the Java side as a `long` value. Any further
    JNI calls must be performed with this pointer as a parameter. This pointer can
    then be given back to the native side when the life cycle of this piece of data
    ends.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，处理这种情况的更好解决方案是允许Java端管理本地内存。在我们的示例中，从本地端返回到Java端的是一个在本地端分配的本地结构的指针，以`long`值的形式。任何进一步的JNI调用必须使用这个指针作为参数进行。当这段数据的生命周期结束时，这个指针可以被还给本地端。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The use of a `long` value (represented on 64-bit) to save a native pointer is
    necessary in order to remain compatible with 64-bit versions of Android (with
    64-bit memory addresses) that arrived with Android Lollipop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`long`值（在64位上表示）保存本地指针是必要的，以便与Android的64位版本保持兼容（具有64位内存地址），这是在Android棒棒糖版本中引入的。
- en: To summarize, use native static variables with care. If your variables are tied
    to the application life cycle, static variables are fine. If your variables are
    tied to the activity lifecycle, you should allocate an instance of them in your
    activity and manage them from there to avoid problems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，要谨慎使用本地静态变量。如果您的变量与应用程序生命周期相关联，静态变量是可以的。如果您的变量与活动生命周期相关联，您应该在活动中分配一个实例，并从那里管理它们以避免问题。
- en: Now that we have a shared lock between the Java and the native side, let's continue
    our example by implementing the Watcher thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在Java和本地端之间有了共享锁，让我们通过实现Watcher线程来继续我们的示例。
- en: Time for action – running and synchronizing a thread
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-运行和同步线程
- en: 'Let''s create a native thread using the POSIX PThread API and attach it to
    the VM:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用POSIX PThread API创建一个本地线程，并将其附加到VM：
- en: 'In `Store.cpp`, include `unistd.h`, which gives access to the `sleep()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store.cpp`中，包括`unistd.h`，它可以访问`sleep()`函数：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implement `startWatcher()`. This method is executed from the UI thread. To do
    so, first instantiate and initialize a `StoreWatcher` structure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`startWatcher()`。这个方法是从UI线程执行的。为此，首先实例化和初始化一个`StoreWatcher`结构。
- en: 'Then, initialize and launch a native thread with the `pthread` POSIX API:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`pthread` POSIX API初始化和启动本地线程：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, initialize and launch a native thread with the PThread POSIX API:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用PThread POSIX API初始化和启动本地线程：
- en: '`pthread_attr_init()` initializes the necessary data structure'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_attr_init()`初始化必要的数据结构'
- en: '`pthread_create()` starts the thread'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_create()`启动线程'
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement `stopWatcher()`, which turns off the running indicator to request
    the watcher thread to stop:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`stopWatcher()`，它关闭运行指示器以请求观察者线程停止：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Implement the thread's main loop in `runWatcher()`. Here, we are not on the
    UI thread anymore, but on the watcher thread.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`runWatcher()`中实现线程的主循环。在这里，我们不再在UI线程上，而是在观察者线程上。
- en: So first, attach the thread as a daemon to the Dalvik VM using `AttachCurrentThreadAsDaemon()`.
    This operation returns `JNIEnv` from the given `JavaVM`. This gives us direct
    access to the Java side from this new thread. Remember that `JNIEnv` is thread-specific
    and cannot be shared between threads directly.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，首先使用`AttachCurrentThreadAsDaemon()`将线程作为守护程序附加到Dalvik VM。此操作从给定的`JavaVM`返回`JNIEnv`。这使我们可以直接从这个新线程访问Java端。请记住，`JNIEnv`是特定于线程的，不能直接在线程之间共享。
- en: 'Then, make this thread loop and take a nap for a few seconds during each iteration
    using `sleep()`:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使此线程循环，并在每次迭代期间休眠几秒钟使用`sleep()`：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While in a loop iteration, delimit a critical section (where only one thread
    can go at the same time) with JNI methods `MonitorEnter()` and `MonitorExit()`.
    These methods require an object to synchronize on (like a `synchronized` block
    in Java).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环迭代期间，使用JNI方法`MonitorEnter()`和`MonitorExit()`限定临界区域（在同一时间只能有一个线程进入的区域）。这些方法需要一个对象进行同步（就像Java中的`synchronized`块一样）。
- en: 'Then, you can safely:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以安全地：
- en: Check whether the thread should be stopped, and leave the loop in that case
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查线程是否应该停止，并在这种情况下离开循环
- en: Process each entry from the store
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理存储中的每个条目
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Before exiting, detach the thread when it is going to end and exit. It is very
    important to always detach an attached thread so that the Dalvik or ART VM stop
    managing it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出之前，当线程即将结束并退出时，分离线程是非常重要的。始终分离已附加的线程，以便Dalvik或ART VM停止管理它。
- en: 'Finally, terminate the thread using the `pthread_exit()` API method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`pthread_exit()` API方法终止线程：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, write the `processEntry()` method, which does nothing more than check
    the boundaries of integer entries and limit them to the arbitrary range `[-100000,100000]`.
    You can also process any of the other entries you wish:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写`processEntry()`方法，它只是检查整数条目的边界并将它们限制在任意范围`[-100000,100000]`内。您还可以处理任何其他条目：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Compile and run the application in Debug mode using the Eclipse Java debugger
    (not the native one). When the application starts, a native background thread
    is created and attached to the Dalvik VM. You can see it in the **Debug** view.
    Then, the UI thread and the native background thread are synchronized together
    with the JNI Monitor API to handle concurrency issues properly. Finally, when
    leaving the application, the background thread is detached and destroyed. Thus,
    it disappears from the **Debug** view:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse Java调试器中以调试模式编译和运行应用程序（而不是本机调试器）。应用程序启动时，会创建一个本机后台线程并将其附加到Dalvik VM。您可以在**调试**视图中看到它。然后，UI线程和本机后台线程使用JNI
    Monitor API进行同步，以正确处理并发问题。最后，在离开应用程序时，后台线程将被分离和销毁。因此，它将从**调试**视图中消失：
- en: '![What just happened?](img/9645_04_02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_04_02.jpg)'
- en: Now, from the `Store` interface on your Android device, define a key and enter
    an integer value greater than `100,000`. Wait a few seconds and retrieve the value
    using the same key. It should appear clamped to `100,000` by the Watcher thread.
    This Watcher looks for each value in the store and changes it if needed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从Android设备上的`Store`接口中，定义一个键并输入一个大于`100,000`的整数值。等待几秒钟，然后使用相同的键检索该值。它应该被观察者线程夹紧到`100,000`。这个观察者在存储中查找每个值，并在需要时更改它。
- en: The Watcher is running on a native thread (that is, not created directly by
    the Java VM). The NDK allows creating native threads using the PThread POSIX API.
    This API is a standard used commonly on Unix systems for multithreading. It defines
    a set of functions and data structures, all prefixed with `pthread_`, to create
    not only threads, but also **Mutexes** (which stands for Mutual Exclusion) or
    **Condition** **variables** (to make a thread wait for a specific condition).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者在本机线程上运行（即不是直接由Java VM创建）。NDK允许使用PThread POSIX API创建本机线程。该API是Unix系统上常用的用于多线程的标准。它定义了一组函数和数据结构，所有这些函数和数据结构都以`pthread_`为前缀，不仅可以创建线程，还可以创建**Mutexes**（代表互斥）或**Condition**
    **variables**（使线程等待特定条件）。
- en: The PThread API is a whole subject in itself and is outside the scope of this
    book. You will need to know it to master native multithreading on Android. For
    more information on this subject, have a look at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)
    and [http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: PThread API本身是一个完整的主题，超出了本书的范围。您需要了解它才能掌握Android上的本机多线程。有关此主题的更多信息，请参阅[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)和[http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/)。
- en: Synchronizing Java and C/C++ with JNI Monitors
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JNI监视器同步Java和C/C++
- en: 'On the Java side, we synchronize threads using `synchronized` blocks with an
    arbitrary lock object. Java also allows methods, whether native or not, to be
    `synchronized`. The lock object, in that case, is implicitly the one on which
    native methods are defined. For example, we could define a native method as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java端，我们使用带有任意锁对象的`synchronized`块来同步线程。Java还允许方法（无论是本机的还是不是）是`synchronized`的。在这种情况下，锁对象隐式地是定义本机方法的对象。例如，我们可以定义一个本机方法如下：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This would not have worked in our case, since there is a single static instance
    of the store on the native side. We need a single static instance of our lock
    object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这不起作用，因为本机端有一个静态实例的存储。我们需要一个锁对象的单个静态实例。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the pattern used here, that is, making `StoreThreadSafe` inherit
    from the `Store` class, override its methods and use static variables, should
    not be considered specifically as the best practice. It has been used for simplicity
    purposes in this book because the `Store` and the `lock` object are static.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用的模式，即使`StoreThreadSafe`从`Store`类继承，覆盖其方法并使用静态变量，也不应被特别视为最佳实践。在本书中，它被用于简化目的，因为`Store`和`lock`对象是静态的。
- en: 'On the native side, synchronization is performed with a JNI monitor, which
    is equivalent to the `synchronized` keyword in Java:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本机端，使用JNI监视器执行同步，这相当于Java中的`synchronized`关键字：
- en: '`MonitorEnter()` delimits the start of a critical section. The monitor is associated
    with an object, which can be considered as a kind of identifier. Only one thread
    at a time can go inside the section defined by this object:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorEnter()`标志着临界区的开始。监视器与一个对象关联，可以被视为一种标识符。只有一个线程可以进入由该对象定义的部分：'
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`MonitorExit()` delimits the end of a critical section. It must be called,
    along with `MonitorEnter()`, to ensure the monitor is released and other threads
    can go:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorExit()`标志着临界区的结束。必须调用它，以及`MonitorEnter()`，以确保监视器被释放，其他线程可以继续：'
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because Java threads are based on POSIX primitives internally, it is also possible
    to implement thread synchronization entirely natively with the POSIX API. You
    can find more information about it at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Java线程在内部基于POSIX原语，所以也可以完全使用POSIX API在本机实现线程同步。您可以在[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)找到更多信息。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java and C/C++ are different languages with similar, but somewhat different
    semantics. Thus, always be careful not to expect C/C++ to behave like Java. As
    an example, the volatile has a different semantic in Java and C/C++, since both
    follow a different memory model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C/C++是不同的语言，具有类似但略有不同的语义。因此，一定要小心，不要期望C/C++的行为像Java一样。例如，volatile在Java和C/C++中的语义不同，因为两者遵循不同的内存模型。
- en: Attaching and detaching native threads
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加和分离本机线程
- en: 'By default, the Dalvik VM is unaware of the native threads that run in the
    same process. In return, the native threads cannot access the VM either... unless
    it is attached to it. The attachment is handled in JNI with the following methods:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Dalvik虚拟机不知道在同一进程中运行的本机线程。反过来，本机线程也无法访问虚拟机...除非它附加到虚拟机。在JNI中处理附加的方法如下：
- en: '`AttachCurrentThread()` to tell the VM to manage the current thread. Once attached,
    a pointer to the `JNIEnv` for the current thread is returned at the specified
    location:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttachCurrentThread()`告诉虚拟机管理当前线程。一旦附加，当前线程的`JNIEnv`指针将返回到指定的位置：'
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`AttachCurrentThreadAsDaemon()` to attach a thread as a daemon. Java specification
    defines that the JVM does not have to wait for a daemon thread to exit before
    leaving, the opposite to normal threads. This distinction has no real meaning
    on Android, since an application can be killed at any time by the system:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttachCurrentThreadAsDaemon()`将线程附加为守护线程。Java规范定义了JVM在离开之前不必等待守护线程退出，与普通线程相反。在Android上，这种区别没有实际意义，因为应用程序可以随时被系统杀死：'
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`DetachCurrentThread()` indicates to the VM that a thread does not need to
    be managed anymore. An attached thread like the Watcher thread must be eventually
    unattached before exiting. Dalvik detects threads that are not detached and reacts
    by aborting and leaving a dirty crash dump in your logs! When getting detached,
    any monitor held is released, and any waiting thread is notified:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetachCurrentThread()`指示虚拟机不再需要管理线程。像Watcher线程这样的附加线程在退出之前必须最终被取消附加。Dalvik检测到未分离的线程并通过中止来做出反应，并在日志中留下脏的崩溃转储！在分离时，任何持有的监视器都会被释放，并且任何等待的线程都会被通知：'
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since Android 2.0, a technique to make sure a thread is systematically detached
    is to bind a destructor callback to the native thread with `pthread_key_create()`
    and call `DetachCurrentThread()` in it. A `JNIEnv` instance can be saved into
    thread local storage with `pthread_setspecific()` to pass it as an argument to
    the destructor.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 2.0以来，确保线程被系统分离的一种技术是使用`pthread_key_create()`将析构函数回调绑定到本机线程，并在其中调用`DetachCurrentThread()`。可以使用`pthread_setspecific()`将`JNIEnv`实例保存到线程本地存储中，以将其作为参数传递给析构函数。
- en: After a thread is attached, the **ClassLoader** JNI uses Java classes to correspond
    to the first object it finds on the call stack. For purely native threads, no
    `ClassLoader` might be found. In that case, JNI uses the system `ClassLoader`,
    which might not be able to find your own application classes, that is, `FindClass()`
    fails. In that case, either cache the necessary JNI elements globally in `JNI_OnLoad()`
    or share an application class loader with the needing thread.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线程附加后，**ClassLoader** JNI使用Java类来对应于在调用堆栈上找到的第一个对象。对于纯本机线程，可能找不到`ClassLoader`。在这种情况下，JNI使用系统`ClassLoader`，可能无法找到您自己的应用程序类，即`FindClass()`失败。在这种情况下，要么在`JNI_OnLoad()`中全局缓存必要的JNI元素，要么与需要的线程共享应用程序类加载器。
- en: Processing bitmaps natively
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地处理位图
- en: The Android NDK proposes an API dedicated to bitmap processing, which gives
    direct access to the surface of Android bitmaps. This API is specific to Android
    and is not related to the JNI specification. However, bitmaps are Java objects
    and will need to be treated as such in native code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK提出了一个专门用于位图处理的API，可以直接访问Android位图的表面。这个API是特定于Android的，与JNI规范无关。但是，位图是Java对象，在本机代码中需要像处理Java对象一样处理。
- en: To see more concretely how bitmaps can be modified from native code, let's try
    to decode a camera feed from native code. Raw video frames recorded on Android
    are generally encoded in a specific format, **YUV**, which is not compatible with
    classic RGB images. This is a situation where native code comes to the rescue
    to help us decode such images. In the following example, we are going to extract
    each color component (that is, red, green, and blue) into a separate bitmap.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体地了解位图如何从本地代码修改，让我们尝试从本地代码解码相机视频流。在Android上记录的原始视频帧通常以特定格式**YUV**编码，这与经典的RGB图像不兼容。这是本地代码帮助我们解码这些图像的情况。在下面的示例中，我们将把每个颜色分量（即红色、绿色和蓝色）提取到单独的位图中。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `LiveCamera`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目名称为`LiveCamera`。
- en: Time for action – decoding a camera's feed
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-解码相机的视频流
- en: 'Let''s write the necessary Java code to record and display pictures in a fresh
    new project:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写必要的Java代码来记录和显示新项目中的图片：
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[第2章](ch02.html "第2章。开始一个本地Android项目")中所示创建一个新的混合Java/C++项目，*开始一个本地Android项目*：
- en: Name it `LiveCamera`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名为`LiveCamera`
- en: The main package is `com.packtpub.livecamera`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要包是`com.packtpub.livecamera`
- en: The main activity is `LiveCameraActivity`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要活动是`LiveCameraActivity`
- en: The main activity layout name is `activity_livecamera`
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主活动布局名称是`activity_livecamera`
- en: Use the **Blank Activity** template
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**空白活动**模板
- en: 'Once created, turn the project into a native project as already seen. In the
    `AndroidManifest.xml` file, request access permission to the camera. Then, set
    the activity style to `fullscreen` and its orientation to `landscape`. Landscape
    orientation avoids most camera orientation problems that are met on Android devices:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，将项目转换为本机项目，如已经看到的。在`AndroidManifest.xml`文件中，请求访问相机的权限。然后，将活动样式设置为`全屏`，将其方向设置为`横向`。横向方向可以避免在Android设备上遇到的大多数相机方向问题：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define the `activity_livecamera.xml` layout as follows. It represents a 2x2
    grid containing one `TextureView` and three `ImageView` elements:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`activity_livecamera.xml`布局定义如下。它表示一个包含一个`TextureView`和三个`ImageView`元素的2x2网格：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open `LiveCameraActivity.java` and implement it as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LiveCameraActivity.java`并实现如下：
- en: First, extend `SurfaceTextureListener`, which is going to help us initialize
    and close the camera feed
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，扩展`SurfaceTextureListener`，这将帮助我们初始化和关闭相机视频流
- en: Then, extend the `PreviewCallback` interface to listen for new camera frames
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，扩展`PreviewCallback`接口以监听新的相机帧
- en: 'Do not forget to load the native static library, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记加载本地静态库，如下所示：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a few member variables:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些成员变量：
- en: '`mCamera` is the Android camera API'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCamera`是Android相机API'
- en: '`mTextureView` displays the raw camera feed'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTextureView`显示原始相机视频'
- en: '`mVideoSource` captures camera frames into a byte buffer'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mVideoSource`捕获相机帧到字节缓冲区'
- en: '`mImageViewR`, `G`, and `B` display processed images, one for each color component'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImageViewR`，`G`和`B`显示处理后的图像，每个颜色分量一个'
- en: '`mImageR`, `G`, and `B` are the bitmaps backing the `ImageView` (the "back
    buffers")'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImageR`，`G`和`B`是支持`ImageView`（“后备缓冲区”）的位图'
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `onCreate()`, specify the layout defined in the previous step.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`中，指定在上一步中定义的布局。
- en: Then, retrieve the views to show images.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检索用于显示图像的视图。
- en: 'Finally, listen for `TextureView` events with `setSurfaceTextureListener()`.
    You can ignore some of the callbacks that are not necessary in this example:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`setSurfaceTextureListener()`监听`TextureView`事件。您可以忽略在此示例中不必要的一些回调：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `onSurfaceTextureAvailable()` callback in `LiveCameraActivity.java` is triggered
    after the `TextureView` surface is created. This is the place where surface dimensions
    and pixel formats get known.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LiveCameraActivity.java`中的`onSurfaceTextureAvailable()`回调在`TextureView`表面创建后触发。这是表面尺寸和像素格式已知的地方。
- en: 'So, open the Android camera and set up `TextureView` as its preview target.
    Listen for new camera frames with `setPreviewCallbackWithBuffer()`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开Android相机，并将`TextureView`设置为其预览目标。使用`setPreviewCallbackWithBuffer()`监听新的相机帧：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, call `findBestResolution()`, which we will implement next to find a suitable
    resolution for the camera feed. Set up the latter accordingly with the `YCbCr_420_SP`
    format (which should be the default on Android).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`findBestResolution()`，我们将在下一步实现，以找到相机视频流的合适分辨率。相应地设置后者的格式为`YCbCr_420_SP`（这应该是Android上的默认格式）。
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After that, set up the video buffer and the bitmaps that display camera frames:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，设置视频缓冲区和显示相机帧的位图：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, enqueue the video frame buffer and start the camera preview:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将视频帧缓冲区入队并启动相机预览：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Still in `LiveCameraActivity.java`, implement `findBestResolution()`. An Android
    camera can support various resolutions, which are highly dependent on the device.
    As there is no rule on what could be the default resolution, we need to look for
    a suitable one. Here, we select the biggest resolution that fits the display surface,
    or the default one if none can be found.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`LiveCameraActivity.java`中，实现`findBestResolution()`。Android相机可以支持各种分辨率，这些分辨率高度依赖于设备。由于没有规定默认分辨率是什么，我们需要寻找一个合适的分辨率。在这里，我们选择适合显示表面的最大分辨率，或者如果找不到任何分辨率，则选择默认分辨率。
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Release the camera when the `TextureView` surface is destroyed in `onSurfaceTextureDestroyed()`,
    as it is a shared resource. Bitmap buffers can also be recycled and nullified
    to ease garbage collector work.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSurfaceTextureDestroyed()`中释放相机，因为它是一个共享资源。位图缓冲区也可以被回收和置空，以便减轻垃圾收集器的工作。
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, decode raw video frames in `onPreviewFrame()`. This handler is triggered
    by the `Camera` class each time a new frame is ready.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onPreviewFrame()`中解码原始视频帧。每当新帧准备就绪时，此处理程序都会由`Camera`类触发。
- en: Raw video bytes are passed to the native method `decode()`, along with the backing
    bitmap, and a filter to select each color component.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 原始视频字节传递给本地方法`decode()`，以及支持位图和选择每个颜色分量的过滤器。
- en: Once decoded, invalidate the surface to redraw it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后，使表面无效以重新绘制它。
- en: Finally, "re-enqueue" the raw video buffer to request the capture of a new video
    frame.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，“重新排队”原始视频缓冲区以请求捕获新的视频帧。
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*What just happened?*'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We captured live images from our device's camera thanks to the Android Camera
    API. After setting up the camera capture format and definition, we created all
    the necessary capture buffer and output images to display onscreen. Captures are
    saved in a buffer enqueued by the application when it requires a new frame. Then,
    this buffer is given with a bitmap to a native method, which we will write in
    the next section. Finally, the output image is displayed onscreen.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Android摄像头API从设备的摄像头捕获实时图像。设置摄像头捕获格式和定义后，我们创建了所有必要的捕获缓冲区和输出图像以在屏幕上显示。当应用程序需要新的帧时，捕获保存在一个缓冲区中。然后，将此缓冲区与位图一起传递给本地方法，我们将在下一节中编写。最后，输出图像显示在屏幕上。
- en: The video feed is encoded in the YUV NV21 format. YUV is a color format originally
    invented in the old days of electronics to make black and white video receivers
    compatible with color transmissions and is still commonly used nowadays. The default
    frame format is guaranteed by the Android specification to be **YCbCr 420 SP**
    (or **NV21**) on Android.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 视频源以YUV NV21格式编码。 YUV是一种最初在电子旧时代发明的颜色格式，用于使黑白视频接收器与彩色传输兼容，现在仍然常用。 Android规范保证的默认帧格式是YCbCr
    420 SP（或NV21）。
- en: Tip
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although YCbCr 420 SP is the default video format on Android, the emulator only
    supports YCbCr 422 SP. This defect should not cause much trouble as it basically
    swaps colors. This problem should not occur on real devices.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管YCbCr 420 SP是Android上的默认视频格式，但模拟器仅支持YCbCr 422 SP。这个缺陷不应该引起太多麻烦，因为它基本上只是交换颜色。这个问题不应该在真实设备上出现。
- en: Now that our live image is captured, let's process it on the native side.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的实时图像已捕获，让我们在本地端处理它。
- en: Time for action – processing pictures with the Bitmap API
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bitmap API处理图片的时间
- en: 'Let''s continue our application by decoding and filtering images on the native
    side by the color channel:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过颜色通道在本地端解码和过滤图像继续我们的应用程序：
- en: Create native C source, `jni/CameraDecoder.c` (not a C++ file, so that we can
    see the difference with JNI code written in C++).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地C源码，`jni/CameraDecoder.c`（不是C++文件，这样我们可以看到与C++中编写的JNI代码的区别）。
- en: 'Include `android/bitmap.h`, which defines the NDK bitmap processing API and
    `stdlib.h` (not `cstdlib` as this file is written in C):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`android/bitmap.h`，它定义了NDK位图处理API和`stdlib.h`（不是`cstdlib`，因为这个文件是用C编写的）：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Write a few utility macros to help decode a video.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些实用宏来帮助解码视频。
- en: '`toInt()` converts a jbyte to an integer, erasing all useless bits with a mask'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toInt()`将jbyte转换为整数，使用掩码擦除所有无用位'
- en: '`max()` gets the maximum between two values'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`获取两个值之间的最大值'
- en: '`clamp()` clamps a value inside a defined interval'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clamp()`将值夹在定义的区间内'
- en: '`color()` builds an ARGB color from each color component'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color()`从每个颜色分量构建ARGB颜色'
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Implement the native method `decode()`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现本地方法`decode()`。
- en: First, retrieve bitmap information and check whether its pixel format is a 32-bit
    RGBA. Then, lock it to allow drawing operations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检索位图信息并检查其像素格式是否为32位RGBA。然后，锁定它以允许绘图操作。
- en: 'After this, gain access to the input video frame content passed as a Java byte
    array with `GetPrimitiveArrayCritical()`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过`GetPrimitiveArrayCritical()`获得作为Java字节数组传递的输入视频帧内容的访问权限：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Decode the raw video frame into the output bitmap. The video frame is encoded
    in the YUV format, which is quite different from RGB. The YUV format encodes a
    color in three components:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始视频帧解码为输出位图。视频帧以YUV格式编码，与RGB格式有很大不同。 YUV格式将颜色编码为三个分量：
- en: One luminance component, that is, the grayscale representation of a color.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个亮度分量，即颜色的灰度表示。
- en: Two chrominance components, which encode the color information (also called
    **Cb** and **Cr** as they represent the blue-difference and red-difference).
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个色度分量，编码颜色信息（也称为**Cb**和**Cr**，因为它们代表蓝差和红差）。
- en: 'There are many frame formats based on YUV colors. Here, we convert frames by
    following the YCbCr 420 SP (or NV21) format. This kind of image frame is composed
    of a buffer of 8-bit Y luminance samples, followed by a second buffer of interleaved
    8-bit V and U chrominance samples. The VU buffer is subsampled, which means that
    there are less U and V samples compared to Y samples (1 U sample and 1 V sample
    for 4 Y samples). The following algorithm processes each pixel and converts each
    YUV pixel to RGB using the appropriate formula (see `http://www.fourcecc.org/fccyvrgb.php`
    for more information):'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于YUV颜色的许多帧格式。在这里，我们按照YCbCr 420 SP（或NV21）格式转换帧。这种图像帧由一个8位Y亮度样本缓冲区组成，后面是一个交错的8位V和U色度样本缓冲区。
    VU缓冲区是被子采样的，这意味着与Y样本相比，U和V样本更少（4个Y样本对应1个U样本和1个V样本）。以下算法处理每个像素，并使用适当的公式将每个YUV像素转换为RGB（有关更多信息，请参见`http://www.fourcecc.org/fccyvrgb.php`）：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To finish, release the Java byte buffer acquired earlier and unlock the backing
    bitmap.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，释放先前获取的Java字节缓冲区并解锁支持位图。
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Instead of relying on a naming convention to find native methods, JNI allows
    native methods to be registered manually in `JNI_OnLoad()`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JNI允许手动注册本地方法，而不是依赖命名约定来查找本地方法。
- en: So, define a table that describes the native methods to register their name,
    signature, and address. Here, only `decode()` needs to be specified.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义一个表，描述要注册其名称、签名和地址的本地方法。在这里，只需要指定`decode()`。
- en: 'Then, in `JNI_OnLoad()`, find the Java on which the native method `decode()`
    is declared (here, `LiveCameraActivity`), and tell JNI which method to use with
    `RegisterNatives()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`JNI_OnLoad()`中，找到声明本地方法`decode()`的Java（这里是`LiveCameraActivity`），并告诉JNI要使用`RegisterNatives()`注册哪个方法：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Write the `Application.mk` makefile as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`Application.mk` makefile如下：
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Write the `Android.mk` makefile as follows (link it to the `jnigraphics` module,
    which defines the Android Bitmap API):'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`Android.mk` makefile如下（将其链接到定义了Android位图API的`jnigraphics`模块）：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*What just happened?*'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Compile and run the application. The raw video feed is displayed in the top-left
    corner without any transformation. The raw video frame is decoded in native code
    and each color channel is extracted into three Java bitmaps. These bitmaps are
    displayed inside three `ImageView` elements in each of the corners of the screen.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。原始视频源以原始形式显示在左上角，没有任何转换。原始视频帧在本地代码中被解码，并且每个颜色通道被提取到三个Java位图中。这些位图在屏幕的每个角落的三个`ImageView`元素中显示。
- en: '![What just happened?](img/9645_04_03.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_04_03.jpg)'
- en: The algorithm used to decode the YUV frame originates from the Ketai open source
    project, an image and sensor processing library for Android. See [http://ketai.googlecode.com/](http://ketai.googlecode.com/)
    for more information. Beware that YUV to RGB is an expensive operation that is
    likely to remain a point of contention in your program (**RenderScript**, which
    we will discover in [Chapter 10](ch10.html "Chapter 10. Intensive Computing with
    RenderScript"), *Intensive Computing with RenderScript*, can help in that task).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 解码YUV帧所使用的算法源自Ketai开源项目，这是一个用于Android的图像和传感器处理库。有关更多信息，请参阅[http://ketai.googlecode.com/](http://ketai.googlecode.com/)。请注意，YUV转RGB是一个昂贵的操作，很可能会在程序中保持争议点（**RenderScript**，我们将在[第10章](ch10.html
    "第10章. 使用RenderScript进行密集计算") *使用RenderScript进行密集计算*中发现，可以帮助完成这项任务）。
- en: The code presented here is far from being optimal (the decoding algorithm can
    be optimized, the video frames, captured with multiple buffers, memory accesses
    can be reduced, and code can be multithreaded) but it gives an overview of how
    bitmap can be processed natively with the NDK.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现的代码远非最佳（解码算法可以优化，使用多个缓冲区捕获的视频帧，内存访问可以减少，并且可以进行多线程编码），但它概述了如何使用NDK在本地处理位图。
- en: 'Native code is given direct access to the bitmap surface thanks to the Android
    NDK Bitmap API defined in the `jnigraphics` module. This API, which can be considered
    as an Android specific extension to JNI, defines the following methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android NDK位图API在`jnigraphics`模块中定义，本地代码可以直接访问位图表面。这个API可以被视为JNI的Android特定扩展，定义了以下方法：
- en: '`AndroidBitmap_getInfo()` to retrieve bitmap information. The returned value
    is negative when a problem occurs, or else `0`:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_getInfo()`用于检索位图信息。当出现问题时，返回值为负数，否则为`0`：'
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Bitmap information is retrieved in the `AndroidBitmapInfo` structure, which
    is defined as follows:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图信息是通过`AndroidBitmapInfo`结构检索的，其定义如下：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`AndroidBitmap_lockPixels()` gives exclusive access to the bitmap while processing
    it. The returned value is negative when a problem occurs, or else `0`:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_lockPixels()`在处理位图时提供独占访问权限。当出现问题时，返回值为负数，否则为`0`：'
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`AndroidBitmap_unlockPixels()` releases the exclusive lock on the bitmap. The
    returned value is negative when a problem occurs, or else `0`:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_unlockPixels()`释放对位图的独占锁定。当出现问题时，返回值为负数，否则为`0`：'
- en: '[PRE76]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Drawing operations on any bitmap occurs systematically in three main steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何位图的绘制操作都是按照三个主要步骤系统地进行的：
- en: First, the bitmap surface is acquired.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取位图表面。
- en: Then, bitmap pixels are modified. Here, video pixels are converted to RGB and
    written to the bitmap surface.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，位图像素被修改。在这里，视频像素被转换为RGB并写入位图表面。
- en: Finally, the bitmap surface is released.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，位图表面被释放。
- en: Bitmaps must be systematically locked and then unlocked when accessed natively.
    Drawing operations must occur imperatively between a lock/unlock pair. Have a
    look at the `bitmap.h` header file for more information.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 位图在本地访问时必须被系统地锁定，然后解锁。绘制操作必须在锁定/解锁对之间进行。查看`bitmap.h`头文件以获取更多信息。
- en: Registering native methods manually
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动注册本地方法
- en: In our store example, native method prototypes have been generated automatically
    by `Javah` using a specific name and parameter convention. The Dalvik VM can then
    load them at runtime by "guessing" their names. However, this convention is easy
    to break and has no runtime flexibility. Hopefully, JNI lets you manually register
    native methods that are going to be called from Java. And what better place than
    `JNI_OnLoad()` to do that?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的商店示例中，本地方法原型已经通过`Javah`自动生成，使用了特定的名称和参数约定。Dalvik VM可以通过“猜测”它们的名称在运行时加载它们。然而，这种约定很容易被打破，并且没有运行时的灵活性。幸运的是，JNI允许您手动注册从Java调用的本地方法。而`JNI_OnLoad()`没有比这更好的地方来做这件事了。
- en: 'Registration is performed with the following JNI method:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注册是通过以下JNI方法执行的：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`jclass` is a reference to the Java class hosting the native method. We will
    see more about it through this chapter and the next one.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jclass`是引用托管本地方法的Java类。我们将在本章和下一章中更多地了解它。'
- en: '`methods` is an array of `JNINativeMethod`, a structure describing the native
    methods to register.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`是`JNINativeMethod`的数组，描述了要注册的本地方法。'
- en: '`nMethods` indicates how many methods are described inside the `methods` array.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nMethods`指示`methods`数组中描述了多少个方法。'
- en: 'The `JNINativeMethod` structure is defined as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNINativeMethod`结构定义如下：'
- en: '[PRE78]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The first and second elements are `name` and `signature` of the corresponding
    Java method, and the third parameter `fnPtr`, is a pointer to the corresponding
    method on the native side. That way, you can get rid of `javah` and its annoying
    naming convention and choose at runtime which method to call.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个元素是相应Java方法的`name`和`signature`，第三个参数`fnPtr`是指向本地端相应方法的指针。这样，你可以摆脱`javah`及其令人讨厌的命名约定，并在运行时选择调用哪个方法。
- en: JNI in C versus JNI in C++
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C中的JNI与C++中的JNI
- en: The NDK allows writing applications in either C (like our `LiveCamera` example)
    or C++ (like our `Store` example). So does JNI.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: NDK允许使用C（如我们的`LiveCamera`示例）或C++（如我们的`Store`示例）编写应用程序。JNI也是如此。
- en: 'C is not an object-oriented language but C++ is. This is why you do not write
    JNI in C like in C++. In C, `JNIEnv` is in fact a structure containing function
    pointers. Of course, when `JNIEnv` is given to you, all these pointers are initialized
    so that you can call them a bit like an object. However, this parameter, which
    is implicit in an object-oriented language, is given as the first parameter in
    C (`env` in the following code). Also, `JNIEnv` needs to be dereferenced the first
    time to run a method:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: C不是面向对象的语言，但C++是。这就是为什么你不像在C++中那样在C中编写JNI。在C中，`JNIEnv`实际上是一个包含函数指针的结构。当然，当`JNIEnv`被给予你时，所有这些指针都被初始化，以便你可以像操作对象一样调用它们。然而，在面向对象的语言中，这个参数是隐式的，在C中作为第一个参数给出（在下面的代码中是`env`）。此外，`JNIEnv`需要在第一次运行方法时进行解引用：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The C++ code is more natural and simple. This parameter is implicit, and there
    is no need to dereference `JNIEnv`, as methods are not declared as function pointers
    anymore, but as real member methods:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码更自然和简单。这个参数是隐式的，不需要解引用`JNIEnv`，因为方法不再声明为函数指针，而是作为真正的成员方法：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Thus, despite being really similar, you do not write JNI code in C in exactly
    the same way you write it in C++.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管非常相似，但你在C中编写JNI代码的方式与在C++中编写的方式并不完全相同。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Thanks to JNI, Java and C/C++ can be tightly integrated together. Android is
    now fully bilingual! Java can call C/C++ code with any type of data or object,
    and native code can call Java back.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JNI，Java和C/C++可以紧密集成在一起。Android现在是完全双语的！Java可以调用任何类型的数据或对象的C/C++代码，本地代码也可以调用Java。
- en: We also discovered how to call Java code from native code with the JNI Reflection
    API. Practically any Java operation can be performed from native code thanks to
    it. However, for best performance, class, method, or field descriptors must be
    cached.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了如何使用JNI反射API从本地代码调用Java代码。几乎可以通过它从本地代码执行任何Java操作。然而，为了获得最佳性能，类、方法或字段描述符必须被缓存。
- en: We also saw how to attach and detach a thread to the VM and synchronize Java
    and native threads together with JNI monitors. Multithreaded code is probably
    one of the most difficult subjects in programming. Do it with care!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何将线程附加和分离到VM，并使用JNI监视器将Java和本地线程同步。多线程代码可能是编程中最困难的主题之一。要小心处理！
- en: Finally, we also natively processed bitmaps thanks to JNI, and decoded a video
    feed by hand. However, an expensive conversion is needed from the default YUV
    format (which should be supported on every device according to Android specifications)
    to RGB.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还通过JNI本地处理了位图，并手动解码了视频源。然而，从默认的YUV格式（根据Android规范应该在每台设备上都支持）到RGB需要进行昂贵的转换。
- en: When dealing with native code on Android, JNI is almost always in the way. It
    is a verbose and very technical API, not to mention cumbersome, which requires
    care. Its subtleties would require a whole book for an in-depth understanding.
    Instead, this chapter has given you the essential knowledge to integrate your
    own C/C++ module in your own Java application.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Android上的本地代码时，JNI几乎总是在路上。它是一个冗长且非常技术性的API，更不用说繁琐了，需要小心处理。要深入理解其微妙之处，需要一本专门的书。相反，本章为您提供了将自己的C/C++模块集成到自己的Java应用程序中所需的基本知识。
- en: In the next chapter, we will see how to create a fully native application, which
    completely gets rid of JNI.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何创建一个完全本地化的应用程序，完全摆脱JNI。
