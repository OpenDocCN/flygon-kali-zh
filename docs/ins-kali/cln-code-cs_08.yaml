- en: Threading and Concurrency
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和并发
- en: A process is essentially a program that is executing on an operating system.
    This process is made up of more than one thread of execution. A thread of execution
    is a set of commands issued by a process. The ability to execute more than one
    thread at a time is known as **multi-threading**. In this chapter, we are going
    to look at multi-threading and concurrency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程本质上是在操作系统上执行的程序。这个进程由多个执行线程组成。执行线程是由进程发出的一组命令。能够同时执行多个线程的能力称为**多线程**。在本章中，我们将研究多线程和并发。
- en: Multiple threads are allotted a set amount of time to execute, and each thread
    is executed on a rotational basis by a thread scheduler. The thread scheduler
    schedules the threads using a technique called **time slicing** and then passes
    each thread to the CPU to be executed at the scheduled time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程被分配一定的执行时间，并且每个线程都由线程调度程序按轮换方式执行。线程调度程序使用一种称为**时间片分配**的技术来调度线程，然后在预定的时间将每个线程传递给CPU执行。
- en: '**Concurrency** is the ability to run more than one thread at exactly the same
    time. This can be accomplished on computers with more than one processor core.
    The more processor cores a computer has, the more threads of execution can be
    executed concurrently.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是能够同时运行多个线程的能力。这可以在具有多个处理器核心的计算机上实现。计算机的处理器核心越多，就可以同时执行更多的执行线程。'
- en: As we look at concurrency and threading in this chapter, we will encounter the
    problems of blocking, deadlocks, and race conditions. You will see how we can
    overcome these problems using clean coding techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章中研究并发和线程时，我们将遇到阻塞、死锁和竞争条件的问题。您将看到我们如何使用清晰的编码技术来克服这些问题。
- en: 'In the course of this chapter, we will cover each of the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下每个主题：
- en: Understanding the thread life cycle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程生命周期
- en: Adding thread parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加线程参数
- en: Using a thread pool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池
- en: Using a mutual exclusion object with synchronous threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥对象与同步线程
- en: Working with parallel threads using semaphores
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量处理并行线程
- en: Limiting the number of processors and threads in the thread pool
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制线程池中的处理器和线程数量
- en: Preventing deadlocks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止死锁
- en: Preventing race conditions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止竞争条件
- en: Understanding static constructors and methods
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法
- en: Mutability, immutability, and thread safety
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性、不可变性和线程安全
- en: Synchronized method dependencies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步方法依赖
- en: Using the `Interlocked` class for simple state changes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Interlocked`类进行简单状态更改
- en: General recommendations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般建议
- en: 'After working through this chapter and developing your threading and concurrency
    skills, you will have acquired the following skills:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习本章并发编程技能，您将获得以下技能：
- en: The ability to understand and discuss the thread life cycle
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和讨论线程生命周期的能力
- en: An understanding of and ability to use foreground and background threads
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用前台和后台线程的能力
- en: The ability to throttle threads and set the number of processors to use concurrently
    using a thread pool
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过线程池限制线程数量和设置并发使用的处理器数量的能力
- en: The ability to understand the effects of static constructors and methods in
    relation to multi-threading and concurrency
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法对多线程和并发的影响
- en: The ability to take into account mutability and immutability and their impact
    on thread safety
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑可变性和不可变性及其对线程安全的影响的能力
- en: The ability to understand what causes race conditions and how to avoid them
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解竞争条件的原因以及如何避免它们的能力
- en: The ability to understand what causes deadlocks and how to avoid them
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解死锁的原因以及如何避免它们的能力
- en: The ability to perform simple state changes using the `Interlocked` class
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Interlocked`类执行简单的状态更改的能力
- en: To run through the code in this chapter, you will need a .NET Framework console
    application. Unless otherwise stated, all code will be placed in the `Program`
    class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您需要一个.NET Framework控制台应用程序。除非另有说明，所有代码将放在`Program`类中。
- en: Understanding the thread life cycle
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程生命周期
- en: 'Threads in C# have an associated life cycle. The life cycle for threads is
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的线程有一个相关的生命周期。线程的生命周期如下：
- en: '![](img/9f574fc2-1ade-4f26-9ecf-52f3cecde092.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f574fc2-1ade-4f26-9ecf-52f3cecde092.png)'
- en: When a thread starts, it enters the **running** state. When running, the thread
    can enter a **wait**, **sleep**, **join**, **stop**, or **suspended **state. Threads
    can also be aborted. Aborted threads enter the stop state. You can suspend and
    resume a thread by calling the `Suspend()` and `Resume()` methods, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程启动时，它进入**运行**状态。在运行时，线程可以进入**等待**、**睡眠**、**加入**、**停止**或**挂起**状态。线程也可以被中止。中止的线程进入停止状态。您可以通过分别调用`Suspend()`和`Resume()`方法来挂起和恢复线程。
- en: A thread will enter the wait state when the `Monitor.Wait(object obj)` method
    is called. The thread will then continue when the `Monitor.Pulse(object obj)`
    method is called. Threads enter sleep mode by calling the `Thread.Sleep(int millisecondsTimeout)`
    method. Once the elapsed time has passed, the thread returns to the running state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Monitor.Wait(object obj)`方法时，线程将进入等待状态。然后当调用`Monitor.Pulse(object obj)`方法时，线程将继续。通过调用`Thread.Sleep(int
    millisecondsTimeout)`方法，线程进入睡眠模式。一旦经过了经过的时间，线程就会返回到运行状态。
- en: The `Thread.Join()` method causes a thread to enter the wait state. A joined
    thread will remain in the wait state until all dependent threads have finished
    running, upon which it will enter the running state. However, if any dependent
    threads are aborted, then this thread is also aborted and enters the stop state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Join()`方法使线程进入等待状态。加入的线程将保持在等待状态，直到所有依赖线程都完成运行，然后它将进入运行状态。但是，如果任何依赖线程被中止，那么这个线程也会被中止并进入停止状态。'
- en: Threads that have completed or have been aborted cannot be restarted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 已完成或已中止的线程无法重新启动。
- en: 'Threads can run in the foreground or the background. Let''s look at both foreground
    and background threads, starting with foreground threads:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以在前台或后台运行。让我们先看看前台和后台线程，从前台线程开始：
- en: '**Foreground threads**: By default, threads run in the foreground. A process
    will continue to run while at least one foreground thread is currently running.
    Even if `Main()` completes but a foreground thread is running, the application
    process will remain active until the foreground thread terminates. Creating a
    foreground thread is really simple, as the following code shows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台线程**：默认情况下，线程在前台运行。只要至少有一个前台线程正在运行，进程就会继续运行。即使`Main()`完成了，但前台线程正在运行，应用程序进程仍将保持活动状态，直到前台线程终止。创建前台线程非常简单，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Background threads**: You create a background thread in the same way that
    you create foreground threads, except that you also have to explicitly set a thread
    to run in the background, as shown:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台线程**：创建后台线程的方式与创建前台线程的方式相同，只是您还必须显式地将线程设置为后台运行，如下所示：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Background threads are used to carry out background tasks and keep the user
    interface responsive to the user. When the main process terminates, any background
    threads that are executing are also terminated. However, even if the main process
    terminates, any foreground threads that are running will run to completion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 后台线程用于执行后台任务并保持用户界面对用户的响应。当主进程终止时，任何正在执行的后台线程也将被终止。但是，即使主进程终止，任何正在运行的前台线程也将运行到完成。
- en: In the next section, we will look at thread parameters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下线程参数。
- en: Adding thread parameters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加线程参数
- en: Methods that run in threads often have parameters. So, when executing a method
    within a thread, it is useful to know how to pass the method parameters into the
    thread.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程中运行的方法通常具有参数。因此，在线程中执行方法时，了解如何将方法参数传递到线程中是有用的。
- en: 'Let''s say that we have the following method, which adds two integers together
    and returns a result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下方法，它将两个整数相加并返回结果：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the method is simple. There are two parameters called `a` and
    `b`. These two parameters will need to be passed into the thread for the `Add()`
    method to run properly. We will add an example method that will do just that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该方法很简单。有两个名为`a`和`b`的参数。这两个参数将需要传递到线程中，以便`Add()`方法能够正确运行。我们将添加一个示例方法来实现这一点：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this method, we declare an integer with an initial value of `0`. We then
    create a new thread that calls the `Add()` method with the `1` and `2` parameter
    values, and then assign the result to the integer variable. The thread then starts
    and we wait for it to finish executing by calling the `Join()` method. Finally,
    we print the result to the console window.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们声明一个初始值为`0`的整数。然后我们创建一个调用带有`1`和`2`参数值的`Add()`方法的新线程，然后将结果赋给整数变量。然后线程开始，我们等待它通过调用`Join()`方法执行完毕。最后，我们将结果打印到控制台窗口。
- en: 'Let''s add our `Message()` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的`Message()`方法：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Message()` method simply takes a string and outputs it to the console
    window. All we have to do now is update the `Main()` method, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message()`方法只是接受一个字符串并将其输出到控制台窗口。现在我们只需要更新`Main()`方法，如下所示：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our `Main()` method, we call our example method and then wait for the user
    to press any key before exiting. You should see the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Main()`方法中，我们调用我们的示例方法，然后等待用户按任意键退出。您应该看到以下输出：
- en: '![](img/4d13b988-cbf1-4b6f-a5f1-8e5ecabdb34b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d13b988-cbf1-4b6f-a5f1-8e5ecabdb34b.png)'
- en: As you can see, `1` and `2` were the method parameters passed into the addition
    method, and `3` was the value returned by the thread. The next topic we will look
    at is using a thread pool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`1`和`2`是传递给加法方法的方法参数，`3`是线程返回的值。我们将要看的下一个主题是使用线程池。
- en: Using a thread pool
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池
- en: A thread pool improves performance by creating a collection of threads during
    application initialization. When a thread is required, it is assigned a single
    task. That task will be executed. Once executed, the thread is returned to the
    thread pool to be reused.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池通过在应用程序初始化期间创建一组线程来提高性能。当需要线程时，它被分配一个单独的任务。该任务将被执行。执行完毕后，线程将返回到线程池以便重用。
- en: Since thread creation is expensive in .NET, we can improve performance by using
    a thread pool. Each process has a fixed number of threads based on the system
    resources available, such as memory and the CPU. However, we can increase or decrease
    the number of threads used by the thread pool. It is normally best to let the
    thread pool take care of how many threads to use, rather than manually setting
    these values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在.NET中创建线程是昂贵的，我们可以通过使用线程池来提高性能。每个进程都有一定数量的线程，这取决于可用的系统资源，如内存和CPU。但是，我们可以增加或减少线程池使用的线程数量。通常最好让线程池负责使用多少线程，而不是手动设置这些值。
- en: 'The different ways to create a thread pool are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程池的不同方法如下：
- en: Using the **Task Parallel Library** (**TPL**) (on .NET Framework 4.0 and higher)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**任务并行库**（**TPL**）（在.NET Framework 4.0及更高版本）
- en: Using `ThreadPool.QueueUserWorkItem()`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ThreadPool.QueueUserWorkItem()`
- en: Using asynchronous delegates
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步委托
- en: Using `BackgroundWorker`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`
- en: As a rule of thumb, you should only use a thread pool for server-side applications.
    For client-side applications, use foreground and background threads, as necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，您应该只在服务器端应用程序中使用线程池。对于客户端应用程序，根据需要使用前台和后台线程。
- en: In this book, we will just look at the **TPL** and the `QueueUserWorkItem()`
    method. You can check out how to use the other two methods at [http://www.albahari.com/threading/](http://www.albahari.com/threading/).
    We'll look at the TPL next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只会看一下**TPL**和`QueueUserWorkItem()`方法。您可以在[http://www.albahari.com/threading/](http://www.albahari.com/threading/)上查看如何使用其他两种方法。我们接下来将看一下TPL。
- en: Task Parallel Library
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务并行库
- en: An asynchronous operation in C# is represented by a task. A task in C# is represented
    by the `Task` class in the TPL. As you will gather from the name, task parallelism
    enables multiple tasks to be executed concurrently, which we will learn about
    in the following subsections. The first `Parallel` class method we will look at
    is the `Invoke()` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的异步操作由任务表示。C#中的任务由TPL中的`Task`类表示。正如你从名称中可以得知的那样，任务并行使多个任务能够同时执行，我们将在接下来的小节中学习。我们将首先看一下`Parallel`类的`Invoke()`方法。
- en: Parallel.Invoke()
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.Invoke()
- en: 'In our first example, we will invoke three separate methods using `Parallel.Invoke()`.
    Add the following three methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将使用`Parallel.Invoke()`来调用三个单独的方法。添加以下三个方法：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, these three methods are almost identical, apart from their
    names and the message printed to the console window via the `Message()` method
    we wrote earlier. Now, we''ll add the `UsingTaskParallelLibrary()` method to execute
    these three methods in parallel:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这三个方法几乎是相同的，除了它们的名称和通过我们之前编写的`Message()`方法打印到控制台窗口的消息。现在，我们将添加`UsingTaskParallelLibrary()`方法来并行执行这三个方法：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this method, we write a message to the console window indicating the start
    of the method. We then invoke the `MethodOne`, `MethodTwo`, and `MethodThree` methods in
    parallel. Then, we write a message to the console window indicating that the method
    has reached its end, and then we wait for a key to be pressed before exiting the
    method. Run the code and you should see the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们向控制台窗口写入一条消息，指示方法的开始。然后，我们并行调用`MethodOne`、`MethodTwo`和`MethodThree`方法。然后，我们向控制台窗口写入一条消息，指示方法已经到达结束，然后我们等待按键退出方法。运行代码，你应该看到以下输出：
- en: '![](img/320d0805-ddc4-4c24-a70d-3faea45cafd6.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/320d0805-ddc4-4c24-a70d-3faea45cafd6.png)'
- en: In the preceding screenshot, you can see that thread one is reused. Let's now
    move on to the `Parallel.For()` loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到线程一被重用。现在让我们转到`Parallel.For()`循环。
- en: Parallel.For()
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.For()
- en: 'In our next TPL example, we will look at a simple `Parallel.For()` loop. Add
    the following method to the `Program` class of a new .NET Framework console application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一个TPL示例中，我们将看一个简单的`Parallel.For()`循环。将以下方法添加到新的.NET Framework控制台应用程序的`Program`类中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All this method does is output a string to the console window. We''ll now create
    the method that executes the `Parallel.For()` loop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是在控制台窗口输出一个字符串。现在，我们将创建执行`Parallel.For()`循环的方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this method, we loop through `0` to `1000`, calling `Method()`. You will
    see how the threads are reused with the different method calls, as in the following
    screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们循环从`0`到`1000`，调用`Method()`。你将看到线程如何在不同的方法调用中被重用，如下面的截图所示：
- en: '![](img/b4ae2005-16d0-422a-81aa-00d07a93a8db.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4ae2005-16d0-422a-81aa-00d07a93a8db.png)'
- en: Now, we will look at using the `ThreadPool.QueueUserWorkItem()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用`ThreadPool.QueueUserWorkItem()`方法。
- en: ThreadPool.QueueUserWorkItem()
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadPool.QueueUserWorkItem()
- en: 'The `ThreadPool.QueueUserWorkItem()` method accepts a `WaitCallback` method
    and queues it ready for execution. `WaitCallback` is a delegate that represents
    a callback method to be executed by a thread pool thread. When a thread becomes
    available, the method is executed. Let''s add a simple example. We''ll start by
    adding `WaitCallbackMethod`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool.QueueUserWorkItem()`方法接受`WaitCallback`方法并将其排队准备执行。`WaitCallback`是一个代表回调方法的委托，将由线程池线程执行。当线程可用时，该方法将被执行。让我们添加一个简单的例子。我们将首先添加`WaitCallbackMethod`：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method accepts a type of object. However, since the parameter will be
    unused, we use the discard variable (`_`). A message is printed to the console
    window. Now, all we need is the code to call the method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个对象类型。然而，由于参数将不被使用，我们使用丢弃变量（`_`）。一条消息被打印到控制台窗口。现在，我们只需要调用这个方法的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we use the `ThreadPool` class to queue `WaitCallbackMethod()` in
    the thread pool via the call to the `QueueUserWorkItem()` method. We then do some
    work on the main thread. The main thread then goes to sleep. A thread becomes
    available from the thread pool and `WaitCallBackMethod()` is executed. The thread
    is then returned back to the thread pool to be reused. Execution returns to the
    main thread, which then completes and terminates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`ThreadPool`类通过调用`QueueUserWorkItem()`方法将`WaitCallbackMethod()`排队到线程池中。然后我们在主线程上做一些工作。主线程然后进入睡眠状态。一个线程从线程池中可用，`WaitCallBackMethod()`被执行。然后线程被返回到线程池中以便重用。执行返回到主线程，然后完成并终止。
- en: In the next section, we will discuss thread-locking objects, known as **Mutual
    Exclusion Objects **(**m****utexes**).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论线程锁定对象，即**互斥对象**（**mutexes**）。
- en: Using a mutex with synchronous threads
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥体与同步线程
- en: In C#, a mutex is a thread-locking object that works across multiple processes.
    Only a process that can request or release a resource can modify the mutex. When
    a mutex is locked, the process will have to wait in a queue. When the mutex is
    unlocked, then it can be accessed. Multiple threads can use the same mutex, but
    only in a synchronous manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，互斥体是一个跨多个进程工作的线程锁定对象。只有能够请求或释放资源的进程才能修改互斥体。当互斥体被锁定时，进程将不得不在队列中等待。当互斥体被解锁时，它就可以被访问。多个线程可以以同步的方式使用相同的互斥体。
- en: The benefits of using a mutex are that a mutex is a simple lock obtained before
    entering a critical piece of code. That lock is released when the critical piece
    of code is exited. Because only a single thread is in the critical piece of code
    at any one time, the data will remain in a consistent state as there will be no
    race conditions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥体的好处是，互斥体是在进入关键代码之前获取的简单锁。当关键代码退出时，该锁将被释放。因为在任何时候只有一个线程在关键代码中，数据将保持一致状态，因为不会出现竞争条件。
- en: 'There are several disadvantages to using a mutex:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥体有一些缺点：
- en: Thread starvation occurs when a thread is unable to move forward as an existing
    thread has obtained a lock and has either gone to sleep or is pre-empted (prevented
    from completing its task).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当现有线程获得锁并且要么进入睡眠状态要么被抢占（无法完成任务）时，线程饥饿就会发生。
- en: When a mutex is locked, only the thread that obtained the lock can unlock it.
    No other thread can lock or unlock it.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当互斥体被锁定时，只有获得锁的线程才能解锁它。没有其他线程可以锁定或解锁它。
- en: Only one thread at a time is allowed to enter the critical piece of code. CPU
    time can be wasted as the normal implementation of a mutex may lead to a *busy
    waiting* state.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只允许一个线程进入关键代码段。CPU时间可能会被浪费，因为互斥体的正常实现可能导致*忙等待*状态。
- en: 'We will now write a program that demonstrates the use of a mutex. Start a new
    .NET Framework console application. Add the following line to the top of the class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个演示互斥体使用的程序。启动一个新的.NET Framework控制台应用程序。将以下行添加到类的顶部：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have declared a primitive called `_mutex`, which we will use for inter-process
    synchronization. Now, add a method to demonstrate thread synchronization using
    a mutex:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`_mutex`的原始类型，我们将使用它进行进程间同步。现在，添加一个方法来演示使用互斥体进行线程同步：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this method, the current thread is blocked until the current wait handle
    receives a signal. Then, when the signal is given, it is safe for the next thread
    to enter. Upon completion, other threads are unblocked from trying to gain ownership
    of the mutex. Next, add the `MutexExample()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，当前线程被阻塞，直到当前等待句柄接收到信号。然后，当给出信号时，下一个线程可以安全地进入。完成后，其他线程将被解除阻塞，以尝试获得互斥体的所有权。接下来，添加`MutexExample()`方法：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this method, we create 10 threads and start them. Each thread executes the
    `ThreadSynchronisationUsingMutex()` method. Now, finally, update the `Main()`
    method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建10个线程并启动它们。每个线程执行`ThreadSynchronisationUsingMutex()`方法。现在，最后更新`Main()`方法：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Main()` method runs our mutex example. The output should be similar to
    the one in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main()`方法运行我们的互斥体示例。输出应该类似于以下截图中的输出：'
- en: '![](img/cb8cc4bd-8486-4e2d-b085-c4d9f0915b5b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb8cc4bd-8486-4e2d-b085-c4d9f0915b5b.png)'
- en: Run the example again and you may end up with different thread numbers. If they
    are the same numbers, then they may be in different orders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行示例，可能会得到不同的线程编号。如果它们是相同的数字，则它们可能以不同的顺序排列。
- en: Now that we have looked at mutexes, let's look at semaphores.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过互斥体，让我们看看信号量。
- en: Working with parallel threads using semaphores
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号量处理并行线程
- en: In multi-threaded applications, a non-negative number, known as a **semaphore**,
    is shared between threads that have a number of `1` or `2`. In terms of synchronization, `1`
    specifies *wait* and `2` specifies *signal*.We can associate a semaphore with
    a number of buffers, which can each be worked on simultaneously by different processes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，一个非负数，称为**信号量**，在具有`1`或`2`的线程之间共享。在同步方面，`1`指定*等待*，`2`指定*信号*。我们可以将信号量与一些缓冲区相关联，每个缓冲区可以由不同的进程同时处理。
- en: So, essentially, semaphores are signaling mechanisms of the integer and binary
    primitive types that can be modified by wait and signal operations. If there are
    no free resources, then processes that require a resource should execute the wait
    operation until the semaphore value is *greater than 0*. Semaphores can have multiple
    program threads and they can be changed by any object, obtaining a resource or
    releasing it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，信号量是可以通过等待和信号操作来修改的整数和二进制原始类型的信号机制。如果没有空闲资源，那么需要资源的进程应执行等待操作，直到信号量值大于0。信号量可以有多个程序线程，并且可以被任何对象更改，获取资源或释放资源。
- en: The advantages of using semaphores are down to the fact that more than one thread
    can access the critical piece of code. A semaphore is executed in the kernel and
    is machine-independent. The critical piece of code is protected from multiple
    processes if you use semaphores. Unlike a mutex, a semaphore never wastes processing
    time and resources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号量的优势在于多个线程可以访问关键代码段。信号量在内核中执行，并且与机器无关。如果使用信号量，关键代码段将受到多个进程的保护。与互斥体不同，信号量永远不会浪费处理时间和资源。
- en: Just like a mutex, semaphores also have their own set of disadvantages. Priority
    inversion is one of the biggest disadvantages and occurs when a high-priority
    thread is forced to wait for a semaphore to be released by its low-priority owning
    thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与互斥体一样，信号量也有自己的一系列缺点。优先级反转是最大的缺点之一，当高优先级线程被迫等待低优先级拥有线程释放信号量时就会发生。
- en: This can be further compounded if the low-priority thread is prevented from
    completing by mid-priority threads prior to their release. This is known as **unbounded
    priority inversion** because we can no longer predict the delay to the high-priority
    thread. With semaphores, the operating system must keep track of all wait and
    signal calls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果低优先级线程在释放之前被中优先级线程阻止完成，这种情况会更加复杂。这被称为**无界优先级反转**，因为我们无法预测高优先级线程的延迟。使用信号量时，操作系统必须跟踪所有等待和信号调用。
- en: Semaphores are used by convention, but they are not forced. You need to execute
    wait and signal operations in the correct order; otherwise, you risk deadlocks
    in your code. Because of the complexity of using semaphores, there may be times
    when a mutual exclusion cannot be obtained. Loss of modularity in large systems
    is also another drawback and semaphores are prone to programming errors that result
    in deadlocks and mutual exclusion violation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是按照惯例使用的，但并非强制。您需要按正确的顺序执行等待和信号操作；否则，您的代码可能会出现死锁。由于使用信号量的复杂性，有时可能无法获得互斥体。在大型系统中失去模块化也是另一个缺点，信号量容易出现编程错误，导致死锁和互斥体违规。
- en: 'We''re going to write a program now that demonstrates the use of semaphores:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个演示使用信号量的程序：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have added a new semaphore variable. The first parameter states the initial
    number of requests for the semaphore that can be granted concurrently. The second
    parameter states the maximum number of requests for the semaphore that can be
    granted concurrently. Add the `StartSemaphore()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的信号量变量。第一个参数表示可以同时授予的信号量的初始请求数。第二个参数表示可以同时授予的信号量的最大请求数。添加`StartSemaphore()`方法：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released and the count
    returns to the previous count. Now, add the `SemaphoreExample()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程被阻塞，直到当前等待句柄接收到一个信号。然后线程可以执行它的工作。最后，信号量被释放，计数返回到之前的计数。现在，添加`SemaphoreExample()`方法：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This example generates 10 threads, which execute the `StartSemaphore()` method.
    Let''s update the `Main()` method to run the code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子生成10个线程，这些线程执行`StartSemaphore()`方法。让我们更新`Main()`方法来运行这段代码：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Main()` method calls `SemaphoreExample()` and then waits for a user keypress
    to exit. You should see the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main()`方法调用`SemaphoreExample()`，然后等待用户按键退出。你应该看到以下输出：'
- en: '![](img/33cf6f91-f372-464f-b382-81a7646148a4.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33cf6f91-f372-464f-b382-81a7646148a4.png)'
- en: Let's move on to look at how we limit the number of processors and threads in
    the thread pool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看如何限制线程池中处理器和线程的数量。
- en: Limiting the number of processors and threads in the thread pool
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制线程池中处理器和线程的数量
- en: There may be times when you need to limit the number of processors and threads
    used by your computer program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要限制计算机程序使用的处理器和线程的数量。
- en: 'To reduce the number of processors that your program uses, you obtain the current
    process and set its processor affinity value. For example, say that we have a
    four-core computer and we want to limit our usage to the first two cores. The
    binary value for the first two cores is `11`, which is `3` in integer form. Now,
    let''s add a method to a new .NET Framework console application and call it `AssignCores()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少程序使用的处理器数量，你获取当前进程并设置它的处理器亲和性值。例如，假设我们有一台四核计算机，我们想将使用限制在前两个核心上。前两个核心的二进制值是`11`，在整数形式中是`3`。现在，让我们添加一个方法到一个新的.NET
    Framework控制台应用程序，并称其为`AssignCores()`：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We pass in an integer to the method. This integer value will be converted into
    a binary value by .NET Framework. That binary value will use the processors identified
    by the value of `1`. For binary values of `0`, the processors will not be used.
    So, since machine code is represented by binary numbers, `0110` (`6`) will use
    cores `2` and `3`, `1100` (`3`) will use cores `1` and `2`, and `0011` (`12`)
    will use cores `3` and `4`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向方法传递一个整数。这个整数值将被.NET Framework转换为一个二进制值。这个二进制值将使用由`1`值确定的处理器。对于二进制值为`0`，处理器将不会被使用。因此，由二进制数表示的机器码，`0110`（`6`）将使用核心`2`和`3`，`1100`（`3`）将使用核心`1`和`2`，`0011`（`12`）将使用核心`3`和`4`。
- en: If you want a refresher on binary, refer to [https://www.computerhope.com/jargon/b/binary.htm](https://www.computerhope.com/jargon/b/binary.htm).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于二进制的复习，请参考[https://www.computerhope.com/jargon/b/binary.htm](https://www.computerhope.com/jargon/b/binary.htm)。
- en: 'Now, to set the maximum number of threads, we call the `SetMaxThreads()` method
    on the `ThreadPool` class. This method takes two parameters, which are both integers.
    The first parameter is the maximum number of worker threads in the thread pool
    and the second parameter is the maximum number of asynchronous I/O threads in
    the thread pool. We''ll now add our method to set the maximum number of threads:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了设置最大线程数，我们在`ThreadPool`类上调用`SetMaxThreads()`方法。这个方法接受两个参数，都是整数。第一个参数是线程池中工作线程的最大数量，第二个参数是线程池中异步I/O线程的最大数量。现在，我们将添加我们的方法来设置最大线程数：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, it is pretty straightforward to set thread maximums and processors
    in your programs. Most of the time, you will not have to do this in your programs.
    The main reason for manually setting the number of threads and/or processors to
    use in your program is for if your programs run into performance issues. If your
    program does not experience performance issues, then it is best not to set the
    number of threads or the number of processors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，设置程序中线程的最大数量和处理器是非常简单的。大多数情况下，你不需要在程序中这样做。手动设置线程和/或处理器数量的主要原因是如果你的程序遇到性能问题。如果你的程序没有遇到性能问题，最好不要设置线程或处理器的数量。
- en: The next topic we will look at is deadlocks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将要看的主题是死锁。
- en: Preventing deadlocks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止死锁
- en: A **deadlock** occurs when two or more threads are executed and are waiting
    for each other to finish. This problem manifests in computer programs when they
    hang. For the end user, this can be very bad and can result in the loss or corruption
    of data. An example of this is executing two batches of data input that crash
    halfway through a transaction and cannot be rolled back. This is not good; let
    me explain why with an example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**发生在两个或更多线程执行并且互相等待对方完成时。当计算机程序出现这个问题时，会出现挂起的情况。对于最终用户来说，这可能非常糟糕，并且可能导致数据的丢失或损坏。一个例子是执行两批数据输入，其中一半事务崩溃并且无法回滚。这是不好的；让我用一个例子来解释为什么。'
- en: Consider a major banking transaction that will take £1 million out of a customer's
    business bank account to pay their **Her Majesty's Revenue and Customs** (**HMRC**)
    tax bill. The money is taken from the business account, but before the money is
    deposited in the HMRC bank account, a deadlock occurs. There is no recovery option
    and so the application has to be terminated and restarted. As a result, the business
    bank account is reduced by £1 million but the HMRC tax bill has not been paid.
    The customer is still liable to pay the tax bill. But what happens to the money
    that has been taken out of the account? So, you can see the importance of removing
    the possibility of deadlocks occurring due to the problems they can cause.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个重大的银行交易，将100万英镑从客户的企业银行账户中取出，用于支付**女王陛下的税务和海关**（HMRC）的税单。资金从企业账户中取出，但在将资金存入HMRC银行账户之前，发生了死锁。没有恢复选项，因此必须终止并重新启动应用程序。因此，企业银行账户减少了100万英镑，但HMRC税单尚未支付。客户仍然有责任支付税单。但已从账户中取出的资金会发生什么？因此，您可以看到由于可能引起的问题，消除死锁发生的可能性的重要性。
- en: 'To keep things simple, we will deal with two threads, shown in the following
    diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将处理两个线程，如下图所示：
- en: '![](img/c6547929-7a72-40da-817a-87481d5face9.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6547929-7a72-40da-817a-87481d5face9.png)'
- en: We will call our threads Thread 1 and Thread 2 and our resources Resource 1 and Resource
    2\. Thread 1 obtains a lock on **Resource 1**. **Thread 2** obtains a lock on **Resource
    2**. **Thread 1** requires access to **Resource 2** but has to wait because **Thread
    2** has locked **Resource 2**. **Thread 2** requires access to **Resource 1** but
    has to wait because **Thread 1** has locked **Resource 1**. This results in both **Thread
    1** and **Thread 2** being in a wait state. Since neither thread can continue
    until the other thread releases its resource, both threads are in a **deadlock
    situation**. When a computer program is in a deadlock situation, it *hangs*, forcing
    you to terminate the program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称我们的线程为Thread 1和Thread 2，我们的资源为Resource 1和Resource 2。Thread 1在Resource 1上获取锁。Thread
    2在Resource 2上获取锁。Thread 1需要访问Resource 2，但必须等待，因为Thread 2已锁定Resource 2。Thread 2需要访问Resource
    1，但必须等待，因为Thread 1已锁定Resource 1。这导致Thread 1和Thread 2都处于等待状态。由于没有线程可以继续，直到另一个线程释放其资源，因此两个线程都处于死锁状态。当计算机程序处于死锁状态时，它会*挂起*，强制您*终止*该程序。
- en: A code example of a deadlock will be a nice way to illustrate this, and so in
    the next section, we will code a deadlock example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁的代码示例将是说明这一点的好方法，因此在下一节中，我们将编写一个死锁示例。
- en: Coding a deadlock example
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写死锁示例
- en: The best way to understand this is with a working example. We are going to write
    some code consisting of two methods that have two different locks each. They will
    both lock objects that the other method needs. Because each thread locks the resources
    that the other thread needs, they will both enter a deadlock state. Once we have
    our example working, we will then modify it so that our code recovers from the
    deadlock situation and is able to continue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点的最好方法是通过一个工作示例。我们将编写一些代码，其中包含两个具有两个不同锁的方法。它们将锁定彼此方法需要的对象。因为每个线程锁定了另一个线程需要的资源，所以它们都将进入死锁状态。一旦我们的示例工作正常，我们将修改代码，使我们的代码能够从死锁情况中恢复并继续。
- en: 'Create a new .NET Framework console application and call it `CH08_Deadlocks`.
    We will need two objects as member variables, so let''s add them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的.NET Framework控制台应用程序，并将其命名为`CH08_Deadlocks`。我们将需要两个对象作为成员变量，因此让我们添加它们：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These objects will be used as our lock objects. We will have two threads, and
    each thread will execute its own method. Now, add `Thread1Method()` to your code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象将用作我们的锁对象。我们将有两个线程，每个线程将执行自己的方法。现在，在您的代码中添加`Thread1Method()`：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Thread1Method()` obtains a lock on `_object1`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object2`. The method then exits both locks
    and terminates.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread1Method()`在`_object1`上获取锁。然后休眠1秒。醒来时，在`_object2`上获得锁。然后该方法退出两个锁并终止。'
- en: '`Thread2Method()` obtains a lock on `_object2`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object1`. The method then exits both locks
    and terminates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread2Method()`在`_object2`上获取锁。然后休眠1秒。醒来时，在`_object1`上获得锁。然后该方法退出两个锁并终止：'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Well, we now have our two methods in place to demonstrate a deadlock. We just
    need the code to call them in a way that will cause a deadlock. Let''s add the `DeadlockNoRecovery()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们现在已经有了两种方法来演示死锁。我们只需要编写调用它们的代码，以一种会导致死锁的方式。让我们添加`DeadlockNoRecovery()`方法：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `DeadlockNoRecovery()` method, we create two threads. Each thread is
    assigned a different method. Then, each thread is started. The program is then
    paused until the user presses a key. Now, update the `Main()` method and run your
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DeadlockNoRecovery()`方法中，我们创建两个线程。每个线程分配一个不同的方法。然后启动每个线程。然后，程序暂停，直到用户按下键。现在，更新`Main()`方法并运行您的代码：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run your program, you should see the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，您应该看到以下输出：
- en: '![](img/3cc47b74-1c00-4540-b392-39a9b241a776.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cc47b74-1c00-4540-b392-39a9b241a776.png)'
- en: As you can see, because `thread1` has locked `_object1`, `thread2` is blocked
    from obtaining a lock on `_object1`. Also, because `thread2` has locked `_object2`,
    `thread1` is blocked from obtaining a lock on `_object2`. So, both threads are
    in deadlock and the program hangs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，因为`thread1`已锁定`_object1`，所以`thread2`无法获取`_object1`的锁。同样，因为`thread2`已锁定`_object2`，所以`thread1`无法获取`_object2`的锁。因此，两个线程都处于死锁状态，程序挂起。
- en: We will now write some code that demonstrates how to avoid this deadlock situation
    from occurring. We will be using the `Monitor.TryLock()` method to try and obtain
    a lock within a certain number of milliseconds. We will then exit a successful
    lock with `Monitor.Exit()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一些代码，演示如何避免发生这种死锁情况。我们将使用`Monitor.TryLock()`方法尝试在一定毫秒数内获得锁。然后我们将使用`Monitor.Exit()`退出成功的锁。
- en: 'Now, add the `DeadlockWithRecovery()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`DeadlockWithRecovery()`方法：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `DeadlockWithRecovery()` method creates two foreground threads. It then
    starts the threads, prints a message to the console, and waits for the user to
    press a key before exiting. We will now add the code for `Thread4Method()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeadlockWithRecovery()`方法创建两个前台线程。然后启动线程，在控制台打印一条消息，并等待用户按键退出。现在我们将为`Thread4Method()`添加代码：'
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Thread4Method()` sleeps for 1 second. It then tries to get a lock on `_object1`.
    If it fails to get a lock on `_object1`, it returns from the method. If a lock
    on `_object1` is obtained, then it tries to get a lock on `_object2`. If a lock
    on `_object2` can''t be obtained, then it returns from the method. If a lock is
    obtained on `_object2`, then it performs the necessary work on `_object2`. The
    lock on `_object2` is then released, and then the lock on `_object1` is released.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread4Method()`休眠1秒。然后尝试锁定`_object1`。如果无法锁定`_object1`，则从方法返回。如果成功锁定`_object1`，则尝试锁定`_object2`。如果无法锁定`_object2`，则从方法返回。如果成功锁定`_object2`，则对`_object2`执行必要的工作。然后释放`_object2`的锁，然后释放`_object1`的锁。'
- en: 'Our `Thread5Method()` method does exactly the same thing, except the objects—`_object1`
    and `_object2`—are locked in reverse order:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Thread5Method()`方法做的事情完全相同，只是对象`_object1`和`_object2`以相反的顺序被锁定：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, add the `DeadlockWithRecovery()` method call to your `Main()` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`DeadlockWithRecovery()`方法调用添加到你的`Main()`方法中：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, run your code a few times. The majority of the time, you will see what
    is in the following screenshot, where all the locks have been successfully obtained:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行你的代码几次。大多数情况下，你会看到以下截图中的情况，所有锁都已成功获取：
- en: '![](img/fa0d5689-7404-4341-9bb8-880b35507571.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa0d5689-7404-4341-9bb8-880b35507571.png)'
- en: Then, press any key and the program will exit. If you keep running the program,
    you will eventually find a lock that fails. The program failed to get a lock on `_object2` in `Thread5Method()`.
    However, if you press any key, the program will exit. As you can see, by using
    `Monitor.TryEnter()`, you can try and lock an object. But if the lock is not obtained,
    then you are able to take another action without your program hanging.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按任意键，程序将退出。如果继续运行程序，最终会发现一个锁定失败。程序在`Thread5Method()`中无法获取`_object2`的锁。但是，如果按任意键，程序将退出。如你所见，通过使用`Monitor.TryEnter()`，你可以尝试锁定一个对象。但如果未获得锁定，则可以在程序挂起的情况下采取其他操作。
- en: In the next section, we look at preventing race conditions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何防止竞争条件。
- en: Preventing race conditions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止竞争条件
- en: When multiple threads using the same resource produce different outcomes due
    to the timings of each thread, this is known as a **race condition**. We will
    demonstrate this in action now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程使用相同的资源产生不同的结果，这是由于每个线程的时间安排不同，这被称为**竞争条件**。我们现在将演示这一点。
- en: In our demonstration, we will have two threads. Each thread will call a method
    to print the alphabet. One method will print the alphabet using *uppercase letters*.
    The second method will print the alphabet using *lowercase letters*. From the
    demonstration, we'll see how the output is wrong, and every time the program is
    run, the output will be wrong.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，将有两个线程。每个线程将调用一个打印字母的方法。一个方法将使用*大写字母*打印字母表。第二个方法将使用*小写字母*打印字母表。从演示中，我们将看到输出是错误的，每次运行程序时，输出都将是错误的。
- en: 'First, add the `ThreadingRaceCondition()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加`ThreadingRaceCondition()`方法：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ThreadingRaceCondition()` produces two threads and starts them. It also references
    two methods. `Method1()` prints out the alphabet in uppercase and `Method2()` prints
    out the alphabet in lowercase. Let''s add `Method1()` and `Method2()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadingRaceCondition()`产生两个线程并启动它们。它还引用两个方法。`Method1()`以大写字母打印字母表，`Method2()`以小写字母打印字母表。让我们添加`Method1()`和`Method2()`：'
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both `Method1()` and `Method2()` reference the `_alphabetCharacter` variable.
    So, add the member to the top of the class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Method1()`和`Method2()`都引用`_alphabetCharacter`变量。因此，在类的顶部添加该成员：'
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, update `MainMethod()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`MainMethod()`：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now have our code in place to demonstrate the race condition. If you run
    the program multiple times, you will see that the results are not what we expect.
    You should even see characters that are not part of the alphabet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好演示竞争条件的代码。如果多次运行程序，你会发现结果不是我们期望的。甚至会看到不属于字母表的字符：
- en: '![](img/0c017737-c3f3-4839-b064-e30731c5db83.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c017737-c3f3-4839-b064-e30731c5db83.png)'
- en: Not exactly what we were expecting, is it?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是我们期望的，是吗？
- en: We are going to solve this problem by using the TPL. The aim of the TPL is to
    simplify **parallelism** and **concurrency**. As most computers today have two
    or more processors, the TPL will scale the degree of concurrency dynamically to
    make the most efficient use of all the available processors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TPL来解决这个问题。TPL的目标是简化**并行性**和**并发性**。由于今天大多数计算机都有两个或更多处理器，TPL将动态地扩展并发度，以充分利用所有可用的处理器。
- en: The partitioning of work, the scheduling of threads in the thread pool, cancellation
    support, state management, and so on are also carried out by the TPL. A link to
    the official Microsoft TPL documentation can be found in the *Further reading* section
    of this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TPL还执行工作分区、线程池中的线程调度、取消支持、状态管理等。本章的*进一步阅读*部分中可以找到官方Microsoft TPL文档的链接。
- en: 'You will see just how simple the solution to the aforementioned problem can
    be. We have a task that runs `Method1()`. The task then continues with `Method2()`.
    We then call `Wait()` to wait for the task to complete execution. Now, add the
    `ThreadingRaceConditionFixed()` method to your source code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到上述问题的解决方案是多么简单。我们有一个运行`Method1()`的任务。任务然后继续执行`Method2()`。然后我们调用`Wait()`等待任务完成执行。现在，在你的源代码中添加`ThreadingRaceConditionFixed()`方法：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify your `Main()` method, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的`Main()`方法如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the code now. If you run it multiple times, you will see that the output
    is always the same, as in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码。如果多次运行，你会发现输出总是相同的，如下截图所示：
- en: '![](img/0cf0ae1c-9d51-4196-9316-36317f555b56.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf0ae1c-9d51-4196-9316-36317f555b56.png)'
- en: So far, we have seen what a thread is and how to use them in the foreground
    and background. We have also looked at deadlocks and how to solve them with `Monitor.TryEnter()`.
    Finally, we looked at what race conditions are and how to solve them using the
    TPL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了线程是什么以及如何在前台和后台使用它们。我们还看了死锁以及如何使用`Monitor.TryEnter()`解决它们。最后，我们看了什么是竞争条件以及如何使用TPL解决它们。
- en: Now, we will move on to looking at static constructors and methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续查看静态构造函数和方法。
- en: Understanding static constructors and methods
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法
- en: If multiple classes require access to a property instance simultaneously, then
    one of the threads will be requested to run the **static constructor** (also known
    as the **type initializer**). While waiting for the type initializer to run, all
    the other threads will be locked. Once the type initializer has run, the locked
    threads are unlocked and are able to access the `Instance` property.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个类需要同时访问一个属性实例，则其中一个线程将被要求运行**静态构造函数**（也称为**类型初始化程序**）。在等待类型初始化程序运行时，所有其他线程将被锁定。一旦类型初始化程序运行，被锁定的线程将被解锁，并能够访问`Instance`属性。
- en: Static constructors are thread-safe as they are guaranteed to run only once
    per application domain. They are executed before accessing any static members
    and before any class instantiation is performed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数是线程安全的，因为它们保证每个应用程序域只运行一次。它们在访问任何静态成员和执行任何类实例化之前执行。
- en: Should an exception be raised in and escape from a static constructor, then
    `TypeInitializationException` is generated, which causes the CLR to exit your
    program.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态构造函数中引发异常并且逃逸，那么将生成`TypeInitializationException`，这会导致CLR退出您的程序。
- en: Before any threads can access a class, static initializers and static constructors
    must finish executing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何线程可以访问一个类之前，静态初始化程序和静态构造函数必须执行完成。
- en: '**Static methods** only keep a single copy of the method and its data at the
    type level. This means that the same method and its data will be shared between
    different instances. Each thread in an application has its own stack. Value types
    passed into static methods are created on the calling thread''s stack, and so
    they are thread-safe. This means that if two threads call the same code and pass
    the same value in, there will be two copies of that value—one on each thread''s
    stack. So, multiple threads will not affect each other.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态方法**只在类型级别保留方法及其数据的单个副本。这意味着相同的方法及其数据将在不同实例之间共享。应用程序中的每个线程都有自己的堆栈。传递给静态方法的值类型是在调用线程的堆栈上创建的，因此它们是线程安全的。这意味着如果两个线程调用相同的代码并传递相同的值，那么该值将有两个副本，分别在每个线程的堆栈上。因此，多个线程不会相互影响。'
- en: However, if you have a static method that accesses a member variable, then it
    is not thread-safe. Two different threads call the same method and so both will have
    access to the member variable. A process or context-switching occurs between threads;
    each thread will access and modify the member variable. This leads to race conditions,
    as you saw earlier in this chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您有一个访问成员变量的静态方法，那么它就不是线程安全的。两个不同的线程调用相同的方法，因此两者都将访问成员变量。在线程之间发生进程或上下文切换；每个线程将访问并修改成员变量。这会导致竞争条件，正如您在本章前面看到的那样。
- en: You also run into problems if you pass reference types into a static method,
    as different threads will have access to the same reference type. This also causes
    a race condition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将引用类型传递给静态方法，也会遇到问题，因为不同的线程将可以访问相同的引用类型。这也会导致竞争条件。
- en: When working with static methods that will be used across threads, avoid member
    variable access and do not pass reference types in. Static methods are thread-safe
    as long as you pass in primitive types and don't modify the state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用将在多个线程之间使用的静态方法时，避免访问成员变量并且不要传递引用类型。只要传递原始类型并且不修改状态，静态方法就是线程安全的。
- en: Now that we've discussed static constructors and methods, we will run through
    some example code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了静态构造函数和方法，我们将运行一些示例代码。
- en: Adding static constructors to our sample code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的示例代码添加静态构造函数
- en: 'Start a new .NET Framework console application. Add a class called `StaticConstructorTestClass`
    to the project. Then, add a read-only static string variable called `_message`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的.NET Framework控制台应用程序。向项目添加一个名为`StaticConstructorTestClass`的类。然后，添加一个名为`_message`的只读静态字符串变量：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `_message` variable is returned to the caller by the `Message()` method.
    Let''s write the `Message()` method now:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message()`方法通过`_message`变量将消息返回给调用者。现在让我们编写`Message()`方法：'
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method returns the message stored in the `_message` variable. Now, we
    need to write our constructor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回存储在`_message`变量中的消息。现在，我们需要编写我们的构造函数：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In our constructor, we write a message to the screen. We then set the member
    variable and let the thread sleep for a second. Then, we set the message again
    and write another message to the console. Now, in the `Program` class, update
    the `Main()` method, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们向屏幕写入一条消息。然后，我们设置成员变量并让线程休眠一秒钟。然后，我们再次设置消息并向控制台写入另一条消息。现在，在`Program`类中，更新`Main()`方法如下：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our `Main()` method instantiates the `Program` class. The `StaticConstructorExample()`
    method is then called. When the program halts and we can see the result, we join
    threads. You can see the output in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main()`方法实例化`Program`类。然后调用`StaticConstructorExample()`方法。当程序停止并且我们可以看到结果时，我们加入线程。您可以在以下截图中看到输出：
- en: '![](img/d79fb288-6c27-4ef6-8c6d-8cfa2aa74ac3.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d79fb288-6c27-4ef6-8c6d-8cfa2aa74ac3.png)'
- en: We'll now take a look at examples of static methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一些静态方法的示例。
- en: Adding static methods to our sample code
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的示例代码添加静态方法
- en: 'We are now going to look at thread-safe static methods and non-thread-safe
    methods in action. Add a new class called `StaticExampleClass` to a new .NET Framework
    console application. Then, add the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看看线程安全的静态方法和非线程安全的方法是如何运作的。向新的.NET Framework控制台应用程序添加一个名为`StaticExampleClass`的新类。然后，添加以下代码：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the top of our class, we add three integers—`_x`, `_y`, and `_z`—with values
    of `1`, `2`, and `3`, respectively. These variables can be modified between threads.
    Now, we will add a static constructor to print out the values of these variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类顶部，我们添加了三个整数——`_x`、`_y`和`_z`——分别为`1`、`2`和`3`。这些变量可以在线程之间修改。现在，我们将添加一个静态构造函数来打印这些变量的值：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, the static constructor simply prints out the values of the
    variables to the console window. Our first method will be a thread-safe method
    called `ThreadSafeMethod()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，静态构造函数只是将变量的值打印到控制台窗口。我们的第一个方法将是一个名为`ThreadSafeMethod()`的线程安全方法：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This method is thread-safe because it only operates on by value parameters.
    It does not interact with the member variables and does not include any by reference
    values. So, no matter what values are passed in, you will always get the expected
    result.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是线程安全的，因为它只对值参数进行操作。它不与成员变量交互，也不包括任何引用值。因此，无论传入什么值，您都将获得预期的结果。
- en: 'This means that regardless of whether only a single thread or even millions
    of threads are accessing the method, the output for each thread will be what you
    expect when you pass in the input values, even despite context switching. The
    following screenshot shows the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论是单个线程还是数百万个线程访问该方法，每个线程的输出都将是您期望的，即使发生上下文切换。以下截图显示了输出：
- en: '![](img/014d5718-ac04-4629-92ea-2e7e0405cc34.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/014d5718-ac04-4629-92ea-2e7e0405cc34.png)'
- en: Now that we have looked at thread-safe methods, it is only right that we look
    at non-thread-safe methods. By now, you know that a static method that operates
    on by reference values or static member variables is not thread-safe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看过了线程安全的方法，现在我们应该看看非线程安全的方法。到目前为止，您已经知道操作引用值或静态成员变量的静态方法是不线程安全的。
- en: 'In our next example, we will use a method with the same three parameters as
    `ThreadSafeMethod()`, but this time, we will set the member variables, output
    a message, go to sleep for a while, and then awake to print the values out again.
    Add the following `NotThreadSafeMethod()` method to `StaticExampleClass`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将使用一个与`ThreadSafeMethod()`具有相同三个参数的方法，但这次我们将设置成员变量，输出一条消息，睡一会儿，然后醒来再次打印出值。将以下`NotThreadSafeMethod()`方法添加到`StaticExampleClass`中：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this method, we set the member variables to the values passed into the method.
    We then output those values to the console windows and go to sleep for 300 milliseconds.
    Then, upon waking from our sleep, we print the values out again. In the `Program`
    class, update the `Main()` method, as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将成员变量设置为传入方法的值。然后，我们将这些值输出到控制台窗口，并睡眠300毫秒。然后，在醒来后，我们再次打印出这些值。在`Program`类中，更新`Main()`方法如下：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `Main()` method, we instantiate the program class, call `ThreadUnsafeMethodCall()`,
    and then wait for the user to press a key before exiting. So, let''s add `ThreadUnsafeMethodCall()`
    to the `Program` class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main()`方法中，我们实例化程序类，调用`ThreadUnsafeMethodCall()`，然后等待用户按键退出。因此，让我们将`ThreadUnsafeMethodCall()`添加到`Program`类中：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method produces 10 threads that call `NotThreadSafeMethod()` of `StaticExampleClass`.
    If you run the code, you will see an output similar to that in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法产生10个调用`StaticExampleClass`的`NotThreadSafeMethod()`的线程。如果运行代码，您将看到类似于以下截图的输出：
- en: '![](img/37710a9d-f8db-4e4d-9cb1-6bb2e7a4b3ec.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37710a9d-f8db-4e4d-9cb1-6bb2e7a4b3ec.png)'
- en: As you can see, the output is not what we would expect. This is because of the
    pollution from different threads. This leads us nicely to the next section on
    mutability, immutability, and thread safety.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出不是我们所期望的。这是由于来自不同线程的污染。这很好地引出了下一节关于可变性、不可变性和线程安全性。
- en: Mutability, immutability, and thread safety
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性、不可变性和线程安全
- en: '**Mutability** is a source of bugs in multi-threaded applications. A mutable
    bug is normally a data bug caused by values being updated and shared between threads.
    To remove the risk of mutability bugs, it is best to use **immutable types**.
    The guaranteed safe execution of a body of code by multiple threads at the same
    time is called **thread safety**. When working with multi-threaded programs, it
    is important that your code is thread-safe. Your code is thread-safe if it removes
    race conditions and deadlocks, along with problems caused by mutability.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变性**是多线程应用程序中错误的来源。可变bug通常是由值被更新并在线程之间共享引起的数据bug。为了消除可变性bug的风险，最好使用**不可变类型**。多个线程同时对一段代码的安全执行称为**线程安全**。在处理多线程程序时，重要的是您的代码是线程安全的。如果您的代码消除了竞态条件、死锁以及可变性引起的问题，那么您的代码就是线程安全的。'
- en: An object that cannot be modified after it has been created is an **immutable
    object**. Once created, if passed between threads using correct thread synchronization,
    all threads will see the same valid state of an object. Immutable objects allow
    you to share data safely between threads.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不可修改的对象在创建后无法修改。一旦创建，如果使用正确的线程同步在线程之间传递，所有线程将看到对象的相同有效状态。不可变对象允许您在线程之间安全地共享数据。
- en: An object that can be modified after it has been created is a mutable object.
    Mutable objects can have their data values changed between threads. This can lead
    to some serious data corruption. So, even if the program does not crash, it can
    leave the data in an invalid state. Therefore, when working with multiple threads
    of execution, it is important that your objects are immutable. In [Chapter 3](3d63c927-7dd3-4985-b50d-64d98c108a46.xhtml), *Classes,
    Objects, and Data Structures,* we went through creating and using immutable data
    structures for your immutable objects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可修改的对象在创建后可以修改。可变对象的数据值可以在线程之间更改。这可能导致严重的数据损坏。因此，即使程序不崩溃，也可能使数据处于无效状态。因此，在处理多个执行线程时，重要的是您的对象是不可变的。在[第3章](3d63c927-7dd3-4985-b50d-64d98c108a46.xhtml)中，*类、对象和数据结构*，我们介绍了为不可变对象创建和使用不可变数据结构。
- en: To ensure thread safety, do not use mutable objects, pass parameters by reference,
    or modify member variables—only pass parameters by value and only operate on parameter
    variables. Do not access member variables. Immutable structures are a good and
    thread-safe way to pass data between objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保线程安全，不要使用可变对象，通过引用传递参数，或修改成员变量——只通过值传递参数，只操作参数变量。不要访问成员变量。不可变结构是在对象之间传递数据的一种良好且线程安全的方式。
- en: We will take a brief look at mutability, immutability, and thread safety with
    the following examples. We'll start with mutability in terms of thread safety.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍可变性、不可变性和线程安全，以下是一些示例。我们将从线程安全的可变性开始。
- en: Writing code that is mutable and not thread-safe
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可变且非线程安全的代码
- en: 'To demonstrate mutability within a multi-threaded application, we will write
    a new .NET Framework console application. Add a new class to the application called
    `MutableClass` with the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 展示多线程应用程序中的可变性，我们将编写一个新的.NET Framework控制台应用程序。在应用程序中添加一个名为`MutableClass`的新类，其中包含以下代码：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In our `MutableClass` class, we have a constructor that takes an integer array
    as an argument. A member integer array is then assigned the array passed into
    the constructor. The `GetIntArray()` method returns the integer array member variable.
    If you look at this class, you would not think it is mutable because once the
    array is passed into the constructor, the class provides no way to modify it.
    Yet, the integer array passed into the constructor is mutable. The `GetIntArray()`
    method returns a reference to the mutable array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MutableClass`类中，我们有一个以整数数组作为参数的构造函数。然后，将成员整数数组分配给传递到构造函数的数组。`GetIntArray()`方法返回整数数组成员变量。如果您查看这个类，您可能不会认为它是可变的，因为一旦数组传递到构造函数中，类就没有提供修改它的方法。然而，传递到构造函数的整数数组是可变的。`GetIntArray()`方法返回对可变数组的引用。
- en: 'In our `Program` class, we will add the `MutableExample()` method to show that
    the integer array is mutable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Program`类中，我们将添加`MutableExample()`方法来展示整数数组是可变的：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our `MutableExample()` method, we have declared and initiated an integer
    array of items from `0` to `9`. We then declare a new instance of `MutableClass`
    and pass in the integer array. Next, we print out the contents of the initial
    array before it is modified. Then, we loop nine times. For each iteration, we
    increase the array at the index specified by the current loop count value of `x` so
    that it equals `x + 1`. After that, we start the thread. Now, update the `Main()`
    method, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MutableExample()`方法中，我们声明并初始化了一个从`0`到`9`的整数数组。然后，我们声明了`MutableClass`的一个新实例，并传入整数数组。接下来，我们打印出修改前的初始数组内容。然后，我们循环九次。对于每次迭代，我们增加由当前循环计数值`x`指定的数组的索引，使其等于`x
    + 1`。之后，我们启动线程。现在，更新`Main()`方法，如下所示：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our `Main()` method simply calls `MutableExample()` and then waits for a keypress.
    Run the code and you should see something as in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main()`方法只是调用`MutableExample()`，然后等待按键。运行代码，您应该看到以下截图中的内容：
- en: '![](img/56fe7d8d-f687-47a3-86f6-909b4dfad3f1.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56fe7d8d-f687-47a3-86f6-909b4dfad3f1.png)'
- en: As you can see, even though we only created one instance of `MutableClass` before
    creating and running our threads, changing the local array modifies the array
    in the instance of `MutableClass`. This proves that the arrays are mutable, and
    so they are not thread-safe.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使在创建和运行线程之前我们只创建了一个`MutableClass`的实例，改变本地数组也会修改`MutableClass`实例中的数组。这证明了数组是可变的，因此它们不是线程安全的。
- en: We will now look at immutability in terms of thread safety.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从线程安全的不可变性开始。
- en: Writing code that is immutable and thread-safe
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写不可变且线程安全的代码
- en: 'In our immutability example, we will again create a .NET Framework console
    application and we''ll use the same array. Add a class called `ImmutableStruct`
    and modify the code, as shown:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的不可变性示例中，我们将再次创建一个.NET Framework控制台应用程序，并使用相同的数组。添加一个名为`ImmutableStruct`的类，并修改代码，如下所示：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Instead of using a normal integer array, we employ `ImmutableArray`. An immutable
    array is passed into the constructor and assigned to the `_immutableArray` member
    variable. Our `GetIntArray()` method returns the immutable array as a normal integer
    array.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ImmutableArray`而不是普通的整数数组。一个不可变数组被传递到构造函数，并赋值给`_immutableArray`成员变量。我们的`GetIntArray()`方法将不可变数组作为普通整数数组返回。
- en: 'Add the `ImmutableExample()` array to the `Program` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program`类中添加`ImmutableExample()`数组：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In our `ImmutableExample()` method, we create an array of integers that we pass
    into the constructor of `ImmutableStruct` as an immutable array. We then print
    the content of the local array before modification. Then, we loop nine times.
    In each iteration, we access the location of the count of the current iteration in
    the array and add the count of the current iteration plus one to the variable
    at that position in the array.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ImmutableExample()`方法中，我们创建一个整数数组，将其作为不可变数组传递给`ImmutableStruct`的构造函数。然后，我们打印修改前的本地数组内容。然后，我们循环九次。在每次迭代中，我们访问数组中当前迭代计数的位置，并将当前迭代计数加一的值添加到数组中该位置的变量中。
- en: 'We then assign a copy of the `immutableStruct` array to a local variable via
    a call to `GetIntArray()`. Then, we proceed to print out the values of the returned
    array. Finally, we start the thread. Call the `ImmutableExample()` method from
    your `Main()` method and then run the code. You should see the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`GetIntArray()`将`immutableStruct`数组的副本赋给一个本地变量。然后，我们继续打印返回数组的值。最后，我们启动线程。从您的`Main()`方法中调用`ImmutableExample()`方法，然后运行代码。您应该看到以下输出：
- en: '![](img/4d54dd02-cdb2-4612-aba5-e67a652dbd9b.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d54dd02-cdb2-4612-aba5-e67a652dbd9b.png)'
- en: As you can see, the array's content is not modified by updating the local array.
    This version of our program shows that our program is thread-safe.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过更新本地数组，数组的内容并未被修改。我们的程序的这个版本表明我们的程序是线程安全的。
- en: Let's briefly run through what we've learned about thread safety so far in the
    next section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下我们在下一节中学到的关于线程安全的知识。
- en: Understanding thread safety
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解线程安全
- en: As you saw in the previous two sections, it is very important to be careful
    when writing multi-threaded code. Writing thread-safe code can be very difficult,
    especially in larger projects. You have to be particularly careful with collections,
    passing parameters by reference, and when accessing member variables within static
    classes. The best practices for multi-threaded applications are to only pass immutable
    types, not to access static member variables, and if any code that is not thread-safe
    must be executed, then to lock the code using a lock, mutex, or semaphore. Although
    you have already seen code like this in action in this chapter, we will quickly
    refresh our memory on this with some code snippets.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前两节中看到的，编写多线程代码时非常重要要小心。编写线程安全的代码可能非常困难，特别是在较大的项目中。您必须特别小心处理集合、通过引用传递参数以及在静态类中访问成员变量。多线程应用程序的最佳实践是仅传递不可变类型，不要访问静态成员变量，如果必须执行任何不是线程安全的代码，则使用锁定、互斥体或信号量锁定代码。尽管您在本章中已经看到了这样的代码，我们将通过一些代码片段快速回顾一下。
- en: 'The following code snippet shows how to write an immutable type using `readonly
    struct`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用`readonly struct`编写不可变类型：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In our `ImmutablePerson` structure, we have a public constructor that takes
    an integer for the ID and strings for the first and last name. We assign the `id`,
    `firstName`, and `lastName` parameters to member read-only variables. The only
    access to the data is via read-only properties. This means that there is no way
    to modify the data. Since the data cannot be modified once it has been created,
    it is classed as thread-safe. Because it is thread-safe, it cannot be modified
    by different threads. The only way to modify the data would be to create a new
    struct with the new data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ImmutablePerson`结构中，我们有一个公共构造函数，它接受一个整数作为ID，以及名字和姓氏的字符串。我们将`id`、`firstName`和`lastName`参数分配给成员只读变量。对数据的唯一访问是通过只读属性。这意味着没有办法修改数据。由于数据一旦创建就无法修改，因此被归类为线程安全。因为它是线程安全的，所以不能被不同的线程修改。修改数据的唯一方法是创建一个包含新数据的新结构。
- en: Structs can be mutable, just like classes. However, to pass data around that
    you don't want to be modified, then read-only structs are a good, lightweight
    choice. They are faster to create and destroy than classes as they are added to
    the stack—that is, unless they are part of a class that is added to the heap.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体可以是可变的，就像类一样。但是，为了传递不希望被修改的数据，只读结构体是一个很好的、轻量级的选择。它们比类更快地创建和销毁，因为它们被添加到堆栈中，除非它们是堆中的类的一部分。
- en: 'Earlier on, we saw how collections are mutable. However, there is also a namespace
    of immutable collections called `System.Collections.Namespace`. The following
    table lists various items from this namespace:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，我们看到了集合是可变的。但是，还有一个名为`System.Collections.Immutable`的不可变集合的命名空间。以下表列出了此命名空间中的各种项目：
- en: '![](img/ef71435c-f95c-44b7-b5ee-f046b7e1be1e.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef71435c-f95c-44b7-b5ee-f046b7e1be1e.png)'
- en: The `System.Collections.Immutable` namespace contains a number of immutable
    collections that you can use safely between threads. Refer to [https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) for
    more details.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Immutable`命名空间包含许多不可变集合，您可以在线程之间安全使用。有关更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1)。'
- en: 'Using a lock object in C# is really straightforward, as the following code
    snippet shows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中使用锁对象非常简单，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We create and instantiate the `_lock` member variable. Then, when it comes to
    executing code that is not thread-safe, we wrap the code in the lock and pass
    in the `_lock` variable to use as the lock object. When a thread enters the lock,
    all other threads are barred from executing the code until the thread leaves the
    lock. One problem with using this code is that threads can enter a deadlock situation.
    One way around this is to use a mutex.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并实例化了`_lock`成员变量。然后，在执行不是线程安全的代码时，我们将代码包装在锁中，并传入`_lock`变量作为锁对象。当线程进入锁时，所有其他线程都被禁止执行代码，直到线程离开锁。使用此代码的一个问题是线程可能进入死锁状态。解决这个问题的一种方法是使用互斥体。
- en: 'You can use a synchronization primitive for interprocess synchronization. Start
    by adding the following code to the top of the class that has code that needs
    protection:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用同步原语进行进程间同步。首先，在需要保护的代码所在的类顶部添加以下代码：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, to use the mutex, you will need to wrap the code that needs protection
    with the following `try/catch` block:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用互斥体，您需要使用以下`try/catch`块包装需要保护的代码：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, the `WaitOne()` method blocks the current thread until
    the wait handle receives a signal. As soon as the mutex is signaled, the `WaitOne()`
    method returns `true`. The calling thread then assumes ownership of the mutex.
    Protected resources can then be accessed by the calling thread. When the work
    is finished on the protected resource, the mutex is released by calling `ReleaseMutex()`. `ReleaseMutex()`
    is called in the `finally` block because you don't want a thread to keep a resource
    locked if it raises an exception for whatever reason. So, always release a mutex
    in a `finally` block.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`WaitOne()`方法会阻塞当前线程，直到等待句柄接收到信号。一旦互斥体被发出信号，`WaitOne()`方法将返回`true`。调用线程然后拥有互斥体。然后，调用线程可以访问受保护的资源。在受保护资源上完成工作后，通过调用`ReleaseMutex()`释放互斥体。`ReleaseMutex()`在`finally`块中调用，因为您不希望线程因任何原因引发异常而保持资源被锁定。因此，始终在`finally`块中释放互斥体。
- en: 'Another mechanism for protecting access to resources is using a semaphore.
    Semaphores are coded much like a mutex and they perform the same role of protecting
    resources. The main difference between a semaphore and a mutex is that a mutex
    is a locking mechanism and a semaphore is a signaling mechanism. To use semaphores
    instead of locks and mutexes, add the following line to the top of a class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 保护资源访问的另一种机制是使用信号量。信号量的编码方式与互斥体非常相似，它们执行保护资源的相同角色。信号量和互斥体之间的主要区别在于互斥体是一种锁定机制，而信号量是一种信号机制。要使用信号量而不是锁和互斥体，请在类的顶部添加以下行：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have now added a new semaphore variable. The first parameter states the
    initial number of requests for the semaphore that can be granted concurrently.
    The second parameter states the maximum number of requests for the semaphore that
    can be granted concurrently. You will then protect access to a resource in your
    methods, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加了一个新的信号量变量。第一个参数表示可以同时授予的信号量的初始请求数。第二个参数表示可以同时授予的信号量的最大请求数。然后您将保护对资源的访问，如下所示：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程被阻塞，直到当前等待句柄接收到信号。然后线程可以执行其工作。最后，信号量被释放。
- en: You have seen, in this chapter, how to use locks, mutexes, and semaphores to
    lock code that is not thread-safe. Also remember that background threads terminate
    when the process completes and terminates, whereas foreground threads will continue
    executing until completion. If you have any code that must run to completion without
    the thread being terminated halfway through what it is doing, then you are better
    off using foreground threads over background threads.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到如何使用锁定、互斥体和信号量来锁定不是线程安全的代码。还要记住，后台线程在进程完成和终止时终止，而前台线程将继续执行直到完成。如果您有任何必须在不被终止的线程中途运行完成的代码，那么最好使用前台线程而不是后台线程。
- en: The next section covers synchronized method dependencies.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节涵盖了同步方法依赖关系。
- en: Synchronized method dependencies
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步方法依赖关系
- en: To synchronize your code, use a lock statement as we did previously. You can
    also reference the `System.Runtime.CompilerServices` namespace in your projects.
    Then, you can add the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    to methods and properties.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要同步您的代码，使用锁定语句，就像我们之前所做的那样。您还可以在项目中引用`System.Runtime.CompilerServices`命名空间。然后，您可以在方法和属性中添加`[MethodImpl(MethodImplOptions.Synchronized)]`注释。
- en: 'Here is an example of the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    applied to a method:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用于方法的`[MethodImpl(MethodImplOptions.Synchronized)]`注释的示例：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is an example of using `[MethodImpl(MethodImplOptions.Synchronized)]` with
    a property:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`[MethodImpl(MethodImplOptions.Synchronized)]`与属性的示例：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, it is easy to encounter a deadlock or a race condition, but
    it is just as easy to overcome deadlocks by using `Monitor.TryEnter()` and race
    conditions with `Task.ContinueWith()`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，很容易遇到死锁或竞争条件，但使用`Monitor.TryEnter()`和`Task.ContinueWith()`同样容易克服死锁和竞争条件。
- en: In the next section, we look at the `Interlocked` class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看Interlocked类。
- en: Using the Interlocked class
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Interlocked类
- en: In multi-threaded applications, errors can creep in during the thread scheduler
    context-switching process. One of the main problems that arises is the update
    of the same variables by different threads. The methods of the `System.Threading.Interlocked`
    class in the `mscorlib` assembly help to protect against these kinds of errors.
    The methods of the `Interlocked` class do not throw exceptions, and so they are
    very helpful in applying simple state changes in a more performant way than using
    the `lock` statement that we've seen previously.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，在线程调度程序上下文切换过程中可能会出现错误。一个主要的问题是不同线程更新相同变量。`mscorlib`程序集中`System.Threading.Interlocked`类的方法有助于防止这类错误。`Interlocked`类的方法不会抛出异常，因此在应用简单状态更改时比使用之前看到的`lock`语句更有效。
- en: 'The methods available in the `Interlocked` class are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Interlocked类中可用的方法如下：
- en: '`CompareExchange`: Compares two variables and stores the results in a different
    variable'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompareExchange`：比较两个变量并将结果存储在不同的变量中'
- en: '**`Add`**: Adds two `Int32` or `Int64` integer variables together and stores
    the result in the first integer'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Add`**：将两个`Int32`或`Int64`整数变量相加，并将结果存储在第一个整数中'
- en: '`Decrement`: Decrements the `Int32` and `Int64` integer variable values and
    stores their results'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decrement`：减少`Int32`和`Int64`整数变量的值并存储它们的结果'
- en: '`Increment`:Increments the `Int32` and `Int64` integer variable values and
    stores their results'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Increment`：增加`Int32`和`Int64`整数变量的值并存储它们的结果'
- en: '`Read`: Reads integer variables of the `Int64` type'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`：读取`Int64`类型的整数变量'
- en: '`Exchange`:Exchanges values between variables'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange`：在变量之间交换值'
- en: 'We are now going to write a simple console application that demonstrates these
    methods. Start by creating a new .NET Framework console application. Add the following
    lines to the top of the `Program` class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个简单的控制台应用程序来演示这些方法。首先创建一个新的.NET Framework控制台应用程序。将以下行添加到`Program`类的顶部：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `_value` variable will be used to demonstrate the update of variables using
    the interlocking methods. The `_resourceInUse` variable is used to indicate whether
    a resource is in use. Add the `CompareExchangeVariables()` method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`_value`变量将用于演示使用互锁方法更新变量。`_resourceInUse`变量用于指示资源是否正在使用。添加`CompareExchangeVariables()`方法：'
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In our `CompareExchangeVariables()` method, we call the `CompareExchange()`
    method to compare `_value` with `long.MaxValue`. If the two values are equal,
    then `_value` is replaced with the value of `123`. We''ll now add our `AddVariables()`
    method:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CompareExchangeVariables()`方法中，我们调用`CompareExchange()`方法来比较`_value`和`long.MaxValue`。如果两个值相等，则用`123`的值替换`_value`。现在我们将添加我们的`AddVariables()`方法：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `AddVariables()` method calls the `Add()` method to access the `_value`
    member variable and update it with the value of `_value` plus `321`. Next, we''ll
    add our `DecrementVariable()` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddVariables()`方法调用`Add()`方法来访问`_value`成员变量，并将其更新为`_value`加`321`的值。接下来，我们将添加`DecrementVariable()`方法：'
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This method calls the `Decrement()` method, which decrements the `_value` member
    variable by 1\. Our next method is `IncrementValue()`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用`Decrement()`方法，该方法将`_value`成员变量减1。我们的下一个方法是`IncrementValue()`：
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In our `IncrementVariable()` method, we increment the `_value` member variable
    by calling the `Increment()` method. The next method we will write is the `ReadVariable()`
    method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`IncrementVariable()`方法中，我们通过调用`Increment()`方法来增加`_value`成员变量。接下来我们将编写的方法是`ReadVariable()`方法：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since 64-bit read operations are atomic, calling the `Interlocked.Read()` method
    is unnecessary. However, on 32-bit systems, for 64-bit reads to be atomic, you
    need to call the `Interlocked.Read()` method. Add the `PerformUnsafeCodeSafely()`
    method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于64位读操作是原子的，调用`Interlocked.Read()`方法是不必要的。但是，在32位系统上，为了使64位读操作是原子的，你需要调用`Interlocked.Read()`方法。添加`PerformUnsafeCodeSafely()`方法：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `PerformUnsafeCodeSafely()` method loops five times. Each iteration of
    the loop calls the `UseResource()` method, and then the thread goes to sleep for
    1 second. Now, we''ll add the `UseResource()` method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerformUnsafeCodeSafely()`方法循环五次。循环的每次迭代调用`UseResource()`方法，然后线程休眠1秒。现在，我们将添加`UseResource()`方法：'
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `UseResource()` method prevents a lock from being obtained if the resource
    is in use, as identified by the `_resourceInUse` variable. We start by setting
    the `_resourceInUse` member variable value to `1` by calling the `Exchange()`
    method. The `Exchange()` method returns an integer, which we compare against `0`.
    If the value returned by `Exchange()` is `0`, then the method is not in use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseResource()`方法防止在资源正在使用时获取锁，这由`_resourceInUse`变量标识。我们首先通过调用`Exchange()`方法将`_resourceInUse`成员变量的值设置为`1`。`Exchange()`方法返回一个整数，我们将其与`0`进行比较。如果`Exchange()`返回的值是`0`，那么该方法没有在使用中。'
- en: If the method is in use, then we output a message informing the user that the
    current thread was denied the lock.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法正在使用中，那么我们输出一条消息，通知用户当前线程被拒绝了锁。
- en: If the method is not in use, then we output a message informing the user that
    the current thread has obtained a lock. We then call the `NonThreadSafeResourceAccess()`
    method and then send the thread to sleep for half a second to simulate work.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法没有在使用中，那么我们输出一条消息，通知用户当前线程已获得锁。然后我们调用`NonThreadSafeResourceAccess()`方法，然后让线程休眠半秒，模拟工作。
- en: 'When the thread awakes, we output a message informing the user that the current
    thread has exited the lock. Then, we release the lock by calling the `Exchange()`
    method and setting the value of `_resourceInUse` to `0`. Add the `NonThreadSafeResourceAccess()`
    method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程唤醒时，我们输出一条消息，通知用户当前线程已退出锁。然后，我们通过调用`Exchange()`方法释放锁，并将`_resourceInUse`的值设置为`0`。添加`NonThreadSafeResourceAccess()`方法：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`NonThreadSafeResourceAccess()` is where non-thread-safe code is executed in
    the safety of the lock. In our method, we simply inform the user with a message.
    The last job to do before we run our code is to update our `Main()` method, as
    follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`NonThreadSafeResourceAccess()`是在锁的安全性中执行非线程安全代码的地方。在我们的方法中，我们只是用一条消息通知用户。在运行代码之前，我们要做的最后一件事是更新我们的`Main()`方法，如下所示：'
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Our `Main()` method calls the methods that test the `Interlocked` methods.
    Run the code and you should see something similar to the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main()`方法调用测试`Interlocked`方法的方法。运行代码，你应该看到类似以下的东西：
- en: '![](img/a355f2b5-6574-4bd0-8168-9f276553d81d.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a355f2b5-6574-4bd0-8168-9f276553d81d.png)'
- en: We'll now go over some general recommendations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论一些一般性建议。
- en: General recommendations
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般建议
- en: 'In this final section, we will look at some general recommendations from Microsoft
    for working on multi-threaded applications. They include the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一节中，我们将看一下微软针对多线程应用的一些一般性建议。它们包括以下内容：
- en: Avoid using `Thread.Abort` to terminate other threads.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`Thread.Abort`来终止其他线程。
- en: Use a mutex, `ManualResetEvent`, `AutoResetEvent`, and `Monitor` to synchronize
    activities between multiple threads.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥体、`ManualResetEvent`、`AutoResetEvent`和`Monitor`来同步多个线程之间的活动。
- en: Where possible, use a thread pool for your worker threads.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，为你的工作线程使用线程池。
- en: If you have any worker threads that gets blocked, then use `Monitor.PulseAll`
    to notify all the threads of a change in the worker thread's state.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何工作线程被阻塞，那么使用`Monitor.PulseAll`来通知所有线程工作线程状态的改变。
- en: Avoid using this, type instances, and string instances including string literals
    as `lock` objects. Avoid using types of the `lock` objects.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用这个，类型实例和字符串实例，包括字符串字面量作为`lock`对象。避免使用`lock`对象的类型。
- en: Instance locks can result in deadlocks, so exercise caution when using them.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例锁可能导致死锁，因此在使用时要小心。
- en: Use the `try/finally` block with threads that enter a monitor so that in the
    `finally` block, you ensure that the thread leaves the monitor by calling `Monitor.Exit()`.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于进入监视器的线程，使用`try/finally`块，以便在`finally`块中，通过调用`Monitor.Exit()`确保线程离开监视器。
- en: Use different threads for different resources.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的资源使用不同的线程。
- en: Avoid assigning multiple threads to the same resource.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将多个线程分配给同一资源。
- en: I/O tasks should have their own thread as they block when performing I/O operations.
    This way, you allow other threads to run.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O任务应该有自己的线程，因为它们在执行I/O操作时会阻塞。这样，你可以让其他线程运行。
- en: User input should have its own dedicated thread.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入应该有自己专用的线程。
- en: Improve performance for simple state changes by using the methods of the `System.Threading.Interlocked`
    class instead of the lock statement.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`System.Threading.Interlocked`类的方法来改进简单状态改变的性能，而不是使用锁语句。
- en: For heavily used code, avoid synchronization as it can lead to deadlocks and
    race conditions.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于频繁使用的代码，避免同步，因为它可能导致死锁和竞争条件。
- en: Make static data thread-safe by default.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，使静态数据线程安全。
- en: Instance data must not be thread-safe by default; otherwise, you decrease performance,
    increase lock contention, and introduce the possibility of race conditions and
    deadlocks occurring.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例数据默认情况下不是线程安全的；否则，会降低性能，增加锁竞争，并引入可能发生竞争条件和死锁的可能性。
- en: Avoid using static methods that alter state as they lead to threading bugs.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用会改变状态的静态方法，因为它们会导致线程错误。
- en: That concludes our look at threading and concurrency. Let's run through a summary
    of what we have learned.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对线程和并发性的探讨。让我们总结一下我们学到的内容。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered what threading is and how to use it. We looked at
    the problems of deadlocks and race conditions in action, and we saw how to prevent
    these exceptional circumstances using a lock statement and the TPL library. We
    also discussed the thread safety of static constructors, static methods, immutable
    objects, and mutable objects. We saw why using immutable objects is a thread-safe
    way of transferring data between threads, and we reviewed some general recommendations
    for working with threads.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了什么是线程以及如何使用它。我们看到了死锁和竞争条件问题的实际情况，并了解了如何使用锁语句和TPL库来防止这些特殊情况。我们还讨论了静态构造函数、静态方法、不可变对象和可变对象的线程安全性。我们看到了为什么使用不可变对象是在线程之间传输数据的线程安全方式，并回顾了一些与线程工作相关的一般建议。
- en: We also saw how making your code thread-safe can have a lot of benefits. In
    the next chapter, we will look at designing effective APIs. But for now, you can
    test your knowledge by answering the following questions and you can further your
    reading by referring to the links provided.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了使代码线程安全可以带来很多好处。在下一章中，我们将看一下设计有效的API。但现在，您可以通过回答以下问题来测试自己的知识，并通过参考提供的链接来进一步阅读。
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a thread?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: How many threads are there in a single-threaded application?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单线程应用中有多少个线程？
- en: What types of threads are there?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些类型的线程？
- en: What thread terminates as soon as the program is exited?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个线程会在程序退出时立即终止？
- en: What thread continues through to completion, even if the program is exited?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个线程会一直运行直到完成，即使程序退出了？
- en: What code makes a thread sleep for half a millisecond?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么代码可以让线程休眠半毫秒？
- en: How do you instantiate a thread that calls a method named `Method1`?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何实例化一个调用名为`Method1`的方法的线程？
- en: How do you make a thread a background thread?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将线程设置为后台线程？
- en: What is a deadlock?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是死锁？
- en: How do you exit a lock obtained using `Monitor.TryEnter(objectName)`?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何退出使用`Monitor.TryEnter(objectName)`获取的锁？
- en: How can you recover from a deadlock?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从死锁中恢复？
- en: What is a race condition?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: What is one way to prevent race conditions?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止竞争条件的一种方法是什么？
- en: What makes static methods unsafe?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么使得静态方法不安全？
- en: Are static constructors thread-safe?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态构造函数是否线程安全？
- en: What is responsible for managing groups of threads?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁负责管理一组线程？
- en: What is an immutable object?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是不可变对象？
- en: Why are immutable objects preferred to mutable objects in threaded applications?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在线程应用中更喜欢不可变对象而不是可变对象？
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread](https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread) provides
    examples of using a mutex and a semaphore.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread](https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread)
    提供了使用互斥体和信号量的示例。'
- en: '[https://www.guru99.com/mutex-vs-semaphore.html](https://www.guru99.com/mutex-vs-semaphore.html) explains
    the differences between a mutex and a semaphore.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.guru99.com/mutex-vs-semaphore.html](https://www.guru99.com/mutex-vs-semaphore.html)
    解释了互斥体和信号量之间的区别。'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors) is
    the official Microsoft documentation on static constructors.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors)
    是官方的微软静态构造函数文档。'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices) is
    the official Microsoft guidance on Microsoft''s managed threading best practices.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)
    是微软官方关于托管线程最佳实践的指南。'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl) is
    the official Microsoft API documentation for the TPL.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)
    是TPL的官方微软API文档。'
- en: '[https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/](https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/) covers
    the Interlocked class in C# threading.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/](https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/)
    讲解了C#线程中的Interlocked类。'
- en: '[http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx](http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx) provides
    a discussion on `System.Threading.Interlocked` with examples.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx](http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx)
    提供了关于`System.Threading.Interlocked`的讨论和示例。'
- en: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/) is
    a link to a free eBook by Joseph Albahari about threading in C#.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/) 是Joseph
    Albahari关于C#中线程的免费电子书的链接。'
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) is
    the official Microsoft documentation on the immutable collections available in
    the `System.Collections.Immutable` namespace.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1)
    是微软官方文档，介绍了`System.Collections.Immutable`命名空间中可用的不可变集合。'
