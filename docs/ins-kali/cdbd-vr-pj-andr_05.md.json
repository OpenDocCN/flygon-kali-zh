["```kt\n    public class MainActivity extends CardboardActivity {\n        private static final String TAG = \"RenderBoxDemo\";\n```", "```kt\npublic class RenderBox implements CardboardView.StereoRenderer {\n    private static final String TAG = \"RenderBox\";\n\n    public static RenderBox instance;\n    public Activity mainActivity;\n    IRenderBox callbacks;\n\n    public RenderBox(Activity mainActivity, IRenderBox callbacks){\n        instance = this;\n        this.mainActivity = mainActivity;\n        this.callbacks = callbacks;\n    }\n}\n```", "```kt\n    @Override\n    public void onNewFrame(HeadTransform headTransform) {\n    }\n\n    @Override\n    public void onDrawEye(Eye eye) {\n    }\n\n    @Override\n    public void onFinishFrame(Viewport viewport) {\n    }\n\n    @Override\n    public void onSurfaceChanged(int i, int i1) {\n    }\n\n    @Override\n    public void onSurfaceCreated(EGLConfig eglConfig) {\n    }\n\n    @Override\n    public void onRendererShutdown() {\n    }\n```", "```kt\n    /**\n     * Checks if we've had an error inside of OpenGL ES, and if so what that error is.\n     * @param label Label to report in case of error.\n     */\n    public static void checkGLError(String label) {\n        int error;\n        while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            String errorText = String.format(\"%s: glError %d, %s\", label, error, GLU.gluErrorString(error));\n            Log.e(TAG, errorText);\n            throw new RuntimeException(errorText);\n        }\n    }\n```", "```kt\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        CardboardView cardboardView = (CardboardView) findViewById(R.id.cardboard_view);\n        cardboardView.setRenderer(new RenderBox(this,this));\n        setCardboardView(cardboardView);\n    }\n```", "```kt\npublic interface IRenderBox {\n    public void setup();\n    public void preDraw();\n    public void postDraw();\n}\n```", "```kt\npublic class MainActivity extends CardboardActivity implements IRenderBox {\n```", "```kt\n    @Override\n    public void setup() {\n\n    }\n\n    @Override\n    public void preDraw() {\n\n    }\n\n    @Override\n    public void postDraw() {\n\n    }\n```", "```kt\npublic abstract class Material {\n    private static final String TAG = \"RenderBox.Material\";\n\n    protected static final float[] modelView = new float[16];\n    protected static final float[] modelViewProjection = new float[16];\n\n    public static int createProgram(int vertexShaderResource, int fragmentShaderResource){\n        int vertexShader = loadGLShader(GLES20.GL_VERTEX_SHADER, vertexShaderResource);\n        int passthroughShader = loadGLShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderResource);\n\n        int program = GLES20.glCreateProgram();\n        GLES20.glAttachShader(program, vertexShader);\n        GLES20.glAttachShader(program, passthroughShader);\n        GLES20.glLinkProgram(program);\n        GLES20.glUseProgram(program);\n\n        RenderBox.checkGLError(\"Material.createProgram\");\n        return program;\n    }\n\n    public abstract void draw(float[] view, float[] perspective);\n}\n```", "```kt\n    /**\n     * Converts a raw text file, saved as a resource, into an OpenGL ES shader.\n     *\n     * @param type The type of shader we will be creating.\n     * @param resId The resource ID of the raw text file about to be turned into a shader.\n     * @return The shader object handler.\n     */\n    public static int loadGLShader(int type, int resId) {\n        String code = readRawTextFile(resId);\n        int shader = GLES20.glCreateShader(type);\n        GLES20.glShaderSource(shader, code);\n        GLES20.glCompileShader(shader);\n\n        // Get the compilation status.\n        final int[] compileStatus = new int[1];\n        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compileStatus, 0);\n\n        // If the compilation failed, delete the shader.\n        if (compileStatus[0] == 0) {\n            Log.e(TAG, \"Error compiling shader: \" + GLES20.glGetShaderInfoLog(shader));\n            GLES20.glDeleteShader(shader);\n            shader = 0;\n        }\n\n        if (shader == 0) {\n            throw new RuntimeException(\"Error creating shader.\");\n        }\n\n        return shader;\n    }\n\n    /**\n     * Converts a raw text file into a string.\n     *\n     * @param resId The resource ID of the raw text file about to be turned into a shader.\n     * @return The context of the text file, or null in case of error.\n     */\n    private static String readRawTextFile(int resId) {\n        InputStream inputStream = RenderBox.instance.mainActivity.getResources().openRawResource(resId);\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            reader.close();\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```", "```kt\n// File: renderbox/math/MathUtils.java\npublic class MathUtils {\n    static public final float PI = 3.1415927f;\n    static public final float PI2 = PI * 2;\n    static public final float degreesToRadians = PI / 180;\n    static public final float radiansToDegrees = 180f / PI;\n}\n```", "```kt\n// File: renderbox/math/Matrix4.java\npublic class Matrix4{\n    public final float[] val = new float[16];\n    public Matrix4()\n    public Matrix4 toIdentity()\n\n    public static Matrix4 TRS(Vector3 position, Vector3 rotation, Vector3 scale)\n    public Matrix4 translate(Vector3 position)\n    public Matrix4 rotate(Vector3 rotation)\n    public Matrix4 scale(Vector3 scale)\n    public Vector3 multiplyPoint3x4(Vector3 v)\n    public Matrix4 multiply(Matrix4 matrix)\n    public Matrix4 multiply(float[] matrix)\n```", "```kt\n// File: renderbox/math/Quaternion.java\npublic class Quaternion {\n    public float x,y,z,w;\n    public Quaternion()\n    public Quaternion(Quaternion quat)\n\n    public Quaternion setEulerAngles (float pitch, float yaw, float roll) public Quaternion setEulerAnglesRad (float pitch, float yaw, float roll) \n    public Quaternion conjugate ()\n    public Quaternion multiply(final Quaternion other)\n    public float[] toMatrix4()\n    public String toString()\n```", "```kt\n// File: renderbox/math/Vector2.java\npublic class Vector2 {\n    public float x;\n    public float y;\n\n    public static final Vector2 zero = new Vector2(0, 0);\n    public static final Vector2 up = new Vector2(0, 1);\n    public static final Vector2 down = new Vector2(0, -1);\n    public static final Vector2 left = new Vector2(-1, 0);\n    public static final Vector2 right = new Vector2(1, 0);\n\n    public Vector2()\n\n    public Vector2(float xValue, float yValue)\n    public Vector2(Vector2 other)\n    public Vector2(float[] vec)\n\n    public final Vector2 add(Vector2 other)\n    public final Vector2 add(float otherX, float otherY, float otherZ)\n    public final Vector2 subtract(Vector2 other)\n    public final Vector2 multiply(float magnitude)\n    public final Vector2 multiply(Vector2 other)\n    public final Vector2 divide(float magnitude)\n    public final Vector2 set(Vector2 other)\n    public final Vector2 set(float xValue, float yValue)\n    public final Vector2 scale(float xValue, float yValue)\n    public final Vector2 scale(Vector2 scale)\n    public final float dot(Vector2 other)\n    public final float length2()\n    public final float distance2(Vector2 other)\n    public Vector2 normalize()\n    public final Vector2 zero()\n    public float[] toFloat3()\n    public float[] toFloat4()\n    public float[] toFloat4(float w)\n    public String toString()\n```", "```kt\n// File: renderbox/math/Vector3.java\npublic final class Vector3 {\n    public float x;\n    public float y;\n    public float z;\n\n    public static final Vector3 zero = new Vector3(0, 0, 0);\n    public static final Vector3 up = new Vector3(0, 1, 0);\n    public static final Vector3 down = new Vector3(0, -1, 0);\n    public static final Vector3 left = new Vector3(-1, 0, 0);\n    public static final Vector3 right = new Vector3(1, 0, 0);\n    public static final Vector3 forward = new Vector3(0, 0, 1);\n    public static final Vector3 backward = new Vector3(0, 0, -1);\n\n    public Vector3()\n    public Vector3(float xValue, float yValue, float zValue)\n    public Vector3(Vector3 other)\n    public Vector3(float[] vec)\n\n    public final Vector3 add(Vector3 other)\n    public final Vector3 add(float otherX, float otherY, float otherZ)\n    public final Vector3 subtract(Vector3 other)\n    public final Vector3 multiply(float magnitude)\n    public final Vector3 multiply(Vector3 other)\n    public final Vector3 divide(float magnitude)\n    public final Vector3 set(Vector3 other)\n    public final Vector3 set(float xValue, float yValue, float zValue)\n    public final Vector3 scale(float xValue, float yValue, float zValue)\n    public final Vector3 scale(Vector3 scale)\n    public final float dot(Vector3 other)\n    public final float length()\n    public final float length2()\n    public final float distance2(Vector3 other)\n    public Vector3 normalize()\n    public final Vector3 zero()\n    public float[] toFloat3()\n    public float[] toFloat4()\n    public float[] toFloat4(float w)\n    public String toString()\n```", "```kt\npublic class Transform {\n    private static final String TAG = \"RenderBox.Transform\";\n\n    List<Component> components = new ArrayList<Component>();\n\n     public Transform() {}\n\n    public Transform addComponent(Component component){\n        component.transform = this;\n        return this;\n    }\n    public List<Component> getComponents(){\n        return components;\n    }\n}\n```", "```kt\n    private Vector3 localPosition = new Vector3(0,0,0);\n    private Quaternion localRotation = new Quaternion();\n    private Vector3 localScale = new Vector3(1,1,1);\n\n    private Transform parent = null;\n```", "```kt\n    public Transform setParent(Transform Parent){\n        setParent(parent, true);\n        return this;\n    }\n\n    public Transform setParent(Transform parent, boolean updatePosition){\n        if(this.parent == parent)\n        //Early-out if setting same parent--don't do anything\n            return this;\n        if(parent == null){\n            unParent(updatePosition);\n            return this;\n        }\n\n        if(updatePosition){\n            Vector3 tmp_position = getPosition();\n            this.parent = parent;\n            setPosition(tmp_position);\n        } else {\n            this.parent = parent;\n        }\n        return this;\n    }\n\n    public Transform upParent(){\n        unParent(true);\n        return this;\n    }\n\n    public Transform unParent(boolean updatePosition){\n        if(parent == null)\n        //Early out--we already have no parent\n            return this;\n        if(updatePosition){\n            localPosition = getPosition();\n        }\n        parent = null;\n        return this;\n    }\n```", "```kt\n    public Transform setPosition(float x, float y, float z){\n        if(parent != null){\n            localPosition = new Vector3(x,y,z).subtract(parent.getPosition());\n        } else {\n            localPosition = new Vector3(x, y, z);\n        }\n        return this;\n    }\n\n    public Transform setPosition(Vector3 position){\n        if(parent != null){\n            localPosition = new Vector3(position).subtract(parent.getPosition());\n        } else {\n            localPosition = position;\n        }\n        return this;\n    }\n\n    public Vector3 getPosition(){\n        if(parent != null){\n            return Matrix4.TRS(parent.getPosition(), parent.getRotation(), parent.getScale()).multiplyPoint3x4(localPosition);\n        }\n        return localPosition;\n    }\n\n    public Transform setLocalPosition(float x, float y, float z){\n        localPosition = new Vector3(x, y, z);\n        return this;\n    }\n\n    public Transform setLocalPosition(Vector3 position){\n        localPosition = position;\n        return this;\n    }\n\n    public Vector3 getLocalPosition(){\n        return localPosition;\n    }\n```", "```kt\n    public Transform setRotation(float pitch, float yaw, float roll){\n        if(parent != null){\n            localRotation = new Quaternion(parent.getRotation()).multiply(new Quaternion().setEulerAngles(pitch, yaw, roll).conjugate()).conjugate();\n        } else {\n            localRotation = new Quaternion().setEulerAngles(pitch, yaw, roll);\n        }\n        return this;\n    }\n\n    /**\n     * Set the rotation of the object in global space\n     * Note: if this object has a parent, setRoation modifies the input rotation!\n     * @param rotation\n     */\n    public Transform setRotation(Quaternion rotation){\n        if(parent != null){\n            localRotation = new Quaternion(parent.getRotation()).multiply(rotation.conjugate()).conjugate();\n        } else {\n            localRotation = rotation;\n        }\n        return this;\n    }\n\n    public Quaternion getRotation(){\n        if(parent != null){\n            return new Quaternion(parent.getRotation()).multiply(localRotation);\n        }\n        return localRotation;\n    }\n\n    public Transform setLocalRotation(float pitch, float yaw, float roll){\n        localRotation = new Quaternion().setEulerAngles(pitch, yaw, roll);\n        return this;\n    }\n\n    public Transform setLocalRotation(Quaternion rotation){\n        localRotation = rotation;\n        return this;\n    }\n\n    public Quaternion getLocalRotation(){\n        return localRotation;\n    }\n\n    public Transform rotate(float pitch, float yaw, float roll){\n        localRotation.multiply(new Quaternion().setEulerAngles(pitch, yaw, roll));\n        return this;\n    }\n```", "```kt\n    public Vector3 getScale(){\n        if(parent != null){\n            Matrix4 result = new Matrix4();\n            result.setRotate(localRotation);\n            return new Vector3(parent.getScale())\n                .scale(localScale);\n        }\n        return localScale;\n    }\n\n    public Transform setLocalScale(float x, float y, float z){\n        localScale = new Vector3(x,y,z);\n        return this;\n    }\n\n    public Transform setLocalScale(Vector3 scale){\n        localScale = scale;\n        return this;\n    }\n\n    public Vector3 getLocalScale(){\n        return localScale;\n    }\n\n    public Transform scale(float x, float y, float z){\n        localScale.scale(x, y, z);\n        return this;\n    }\n```", "```kt\n    public float[] toFloatMatrix(){\n        return Matrix4.TRS(getPosition(), getRotation(), getScale()).val;\n    }\n\n    public float[] toLightMatrix(){\n        return Matrix4.TR(getPosition(), getRotation()).val;\n    }\n\n    /**\n     * Set up the lighting model and model matrices for a draw call\n     * Since the lighting model is an intermediate step, it makes sense to combine this call\n     */\n    public void drawMatrices() {\n        Matrix4 modelMatrix = Matrix4.TR(getPosition(), getRotation());\n        RenderObject.lightingModel = modelMatrix.val;\n        modelMatrix = new Matrix4(modelMatrix);\n        RenderObject.model = modelMatrix.scale(getScale()).val;\n    }\n```", "```kt\npublic class Component {\n    public Transform transform;\n\n    public boolean enabled = true;\n}\n```", "```kt\npublic abstract class RenderObject extends Component {\n    private static final String TAG = \"RenderObject\";\n\n    public RenderObject(){\n        super();\n        RenderBox.instance.renderObjects.add(this);\n    }\n}\n```", "```kt\npublic class RenderBox implements CardboardView.StereoRenderer {\n\n    public List<RenderObject> renderObjects = new ArrayList<RenderObject>();\n```", "```kt\npublic abstract class RenderObject extends Component {\n       ...\n    protected static FloatBuffer allocateFloatBuffer(float[] data){\n        ByteBuffer bbVertices = ByteBuffer.allocateDirect(data.length * 4);\n        bbVertices.order(ByteOrder.nativeOrder());\n        FloatBuffer buffer = bbVertices.asFloatBuffer();\n        buffer.put(data);\n        buffer.position(0);\n        return buffer;\n    }\n\n    protected static ShortBuffer allocateShortBuffer(short[] data){\n        ByteBuffer bbVertices = ByteBuffer.allocateDirect(data.length * 2);\n        bbVertices.order(ByteOrder.nativeOrder());\n        ShortBuffer buffer = bbVertices.asShortBuffer();\n        buffer.put(data);\n        buffer.position(0);\n        return buffer;\n    }\n}\n```", "```kt\n    protected Material material;\n    public static float[] model;\n    public static float[] lightingModel;\n\n    public Material getMaterial(){\n        return material;\n    }\n    public RenderObject setMaterial(Material material){\n        this.material = material;\n        return this;\n    }\n\n    public void draw(float[] view, float[] perspective){\n        if(!enabled)\n            return;\n        //Compute position every frame in case it changed\n        transform.drawMatrices();\n        material.draw(view, perspective);\n    }\n```", "```kt\n// File: renderbox/components/Cube.java\npublic class Cube {\n    public static final float[] CUBE_COORDS = new float[] {\n            // Front face\n            -1.0f, 1.0f, 1.0f,\n            -1.0f, -1.0f, 1.0f,\n            1.0f, 1.0f, 1.0f,\n            -1.0f, -1.0f, 1.0f,\n            1.0f, -1.0f, 1.0f,\n            1.0f, 1.0f, 1.0f,\n\n            // Right face\n            1.0f, 1.0f, 1.0f,\n            1.0f, -1.0f, 1.0f,\n            1.0f, 1.0f, -1.0f,\n            1.0f, -1.0f, 1.0f,\n            1.0f, -1.0f, -1.0f,\n            1.0f, 1.0f, -1.0f,\n\n            // Back face\n            1.0f, 1.0f, -1.0f,\n            1.0f, -1.0f, -1.0f,\n            -1.0f, 1.0f, -1.0f,\n            1.0f, -1.0f, -1.0f,\n            -1.0f, -1.0f, -1.0f,\n            -1.0f, 1.0f, -1.0f,\n\n            // Left face\n            -1.0f, 1.0f, -1.0f,\n            -1.0f, -1.0f, -1.0f,\n            -1.0f, 1.0f, 1.0f,\n            -1.0f, -1.0f, -1.0f,\n            -1.0f, -1.0f, 1.0f,\n            -1.0f, 1.0f, 1.0f,\n\n            // Top face\n            -1.0f, 1.0f, -1.0f,\n            -1.0f, 1.0f, 1.0f,\n            1.0f, 1.0f, -1.0f,\n            -1.0f, 1.0f, 1.0f,\n            1.0f, 1.0f, 1.0f,\n            1.0f, 1.0f, -1.0f,\n\n            // Bottom face\n            1.0f, -1.0f, -1.0f,\n            1.0f, -1.0f, 1.0f,\n            -1.0f, -1.0f, -1.0f,\n            1.0f, -1.0f, 1.0f,\n            -1.0f, -1.0f, 1.0f,\n            -1.0f, -1.0f, -1.0f,\n    };\n\n    public static final float[] CUBE_COLORS_FACES = new float[] {\n            // Front, green\n            0f, 0.53f, 0.27f, 1.0f,\n            // Right, blue\n            0.0f, 0.34f, 0.90f, 1.0f,\n            // Back, also green\n            0f, 0.53f, 0.27f, 1.0f,\n            // Left, also blue\n            0.0f, 0.34f, 0.90f, 1.0f,\n            // Top, red\n            0.84f,  0.18f,  0.13f, 1.0f,\n            // Bottom, also red\n            0.84f,  0.18f,  0.13f, 1.0f\n    };\n\n    /**\n     * Utility method for generating float arrays for cube faces\n     *\n     * @param model - float[] array of values per face.\n     * @param coords_per_vertex - int number of coordinates per vertex.\n     * @return - Returns float array of coordinates for triangulated cube faces.\n     *               6 faces X 6 points X coords_per_vertex\n     */\n    public static float[] cubeFacesToArray(float[] model, int coords_per_vertex) {\n        float coords[] = new float[6 * 6 * coords_per_vertex];\n        int index = 0;\n        for (int iFace=0; iFace < 6; iFace++) {\n            for (int iVertex=0; iVertex < 6; iVertex++) {\n                for (int iCoord=0; iCoord < coords_per_vertex; iCoord++) {\n                    coords[index] = model[iFace*coords_per_vertex + iCoord];\n                    index++;\n                }\n            }\n        }\n        return coords;\n    }\n}\n```", "```kt\npublic class Cube extends RenderObject {\n```", "```kt\n    public static FloatBuffer vertexBuffer;\n    public static FloatBuffer colorBuffer;\n    public static final int numIndices = 36;\n\n    public Cube(){\n        super();\n        allocateBuffers();\n        createMaterial();\n    }\n\n    public static void allocateBuffers(){\n        //Already setup?\n        if (vertexBuffer != null) return;\n        vertexBuffer = allocateFloatBuffer(CUBE_COORDS);\n        colorBuffer = allocateFloatBuffer(cubeFacesToArray(CUBE_COLORS_FACES, 4));\n    }\n\n    public void createMaterial(){\n        VertexColorMaterial mat = new VertexColorMaterial();\n        mat.setBuffers(vertexBuffer, colorBuffer, numIndices);\n        material = mat;\n    }\n```", "```kt\n// File:res/raw/vertex_color_vertex.shader\nuniform mat4 u_Model;\nuniform mat4 u_MVP;\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\n\nvarying vec4 v_Color;\n\nvoid main() {\n   v_Color = a_Color;\n   gl_Position = u_MVP * a_Position;\n}\n```", "```kt\n//File: res/raw/vertex_color_fragment.shader\nprecision mediump float;\nvarying vec4 v_Color;\n\nvoid main() {\n    gl_FragColor = v_Color;\n}\n```", "```kt\npublic class VertexColorMaterial extends Material {\n```", "```kt\npublic class VertexColorMaterial extends Material {\n    static int program = -1;\n\n    static int positionParam;\n    static int colorParam;\n    static int modelParam;\n    static int MVPParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer colorBuffer;\n    int numIndices;\n\n    public VertexColorMaterial(){\n        super();\n        setupProgram();\n    }\n\n    public static void setupProgram(){\n        //Already setup?\n\t\tif (program != -1) return;\n        //Create shader program\n        program = createProgram(R.raw.vertex_color_vertex, R.raw.vertex_color_fragment);\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        colorParam = GLES20.glGetAttribLocation(program, \"a_Color\");\n\n        //Enable vertex attribute parameters\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(colorParam);\n\n        //Shader-specific parameters\n        modelParam = GLES20.glGetUniformLocation(program, \"u_Model\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n\n        RenderBox.checkGLError(\"Solid Color Lighting params\");\n    }\n\n    public void setBuffers(FloatBuffer vertexBuffer,  FloatBuffer colorBuffer, int numIndices){\n        this.vertexBuffer = vertexBuffer;\n        this.colorBuffer = colorBuffer;\n        this.numIndices = numIndices;\n    }\n\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n\n        GLES20.glUseProgram(program);\n\n        // Set the Model in the shader, used to calculate lighting\n        GLES20.glUniformMatrix4fv(modelParam, 1, false, RenderObject.model, 0);\n\n        // Set the position of the cube\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n\n        // Set the ModelViewProjection matrix in the shader.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        // Set the normal positions of the cube, again for shading\n        GLES20.glVertexAttribPointer(colorParam, 4, GLES20.GL_FLOAT, false, 0, colorBuffer);\n\n        // Set the ModelViewProjection matrix in the shader.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, numIndices);\n    }\n\n    public static void destroy(){\n        program = -1;\n    }\n}\n```", "```kt\npublic class Camera extends Component {\n    private static final String TAG = \"renderbox.Camera\";\n\n    private static final float Z_NEAR = .1f;\n    public static final float Z_FAR = 1000f;\n\n    private final float[] camera = new float[16];\n    private final float[] view = new float[16];\n    public Transform getTransform(){return transform;}\n\n    public Camera(){\n        //The camera breaks pattern and creates its own Transform\n        transform = new Transform();\n    }\n\n    public void onNewFrame(){\n        // Build the camera matrix and apply it to the ModelView.\n        Vector3 position = transform.getPosition();\n        Matrix.setLookAtM(camera, 0, position.x, position.y, position.z + Z_NEAR, position.x, position.y, position.z, 0.0f, 1.0f, 0.0f);\n\n        RenderBox.checkGLError(\"onNewFrame\");\n    }\n\n    public void onDrawEye(Eye eye) {\n        GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n\n        RenderBox.checkGLError(\"glClear\");\n\n        // Apply the eye transformation to the camera.\n        Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);\n\n        // Build the ModelView and ModelViewProjection matrices\n        float[] perspective = eye.getPerspective(Z_NEAR, Z_FAR);\n\n        for(RenderObject obj : RenderBox.instance.renderObjects) {\n            obj.draw(view, perspective);\n        }\n        RenderBox.checkGLError(\"Drawing complete\");\n    }\n}\n```", "```kt\n    public static Camera mainCamera;\n```", "```kt\n    public void onSurfaceCreated(EGLConfig eglConfig) {\n        RenderBox.reset();\n        GLES20.glClearColor(0.1f, 0.1f, 0.1f, 0.5f);\n\n        mainCamera = new Camera();\n\n        checkGLError(\"onSurfaceCreated\");\n        callbacks.setup();\n    }\n```", "```kt\n    /**\n     * Used to \"clean up\" compiled shaders, which have to be recompiled for a \"fresh\" activity\n     */\n    public static void reset(){\n        VertexColorMaterial.destroy();\n    }\n```", "```kt\n    public static final float[] headView = new float[16];\n    public static final float[] headAngles = new float[3];\n\n    public void onNewFrame(HeadTransform headTransform) {\n        headTransform.getHeadView(headView, 0);\n        headTransform.getEulerAngles(headAngles, 0);\n        mainCamera.onNewFrame();\n        callbacks.preDraw();\n    }\n```", "```kt\n    public void onDrawEye(Eye eye) {\n        mainCamera.onDrawEye(eye);\n    }\n```", "```kt\n    public void onFinishFrame(Viewport viewport) {\n        callbacks.postDraw();\n    }\n```", "```kt\n    Transform cube;\n\n        @Override\n    public void setup() {\n        cube = new Transform();\n        cube.addComponent(new Cube());\n        cube.setLocalPosition(2.0f, -2.f, -5.0f);\n    }\n```", "```kt\n    public static final float[] CUBE_NORMALS_FACES = new float[] {\n            // Front face\n            0.0f, 0.0f, 1.0f,\n            // Right face    \n            1.0f, 0.0f, 0.0f,\n            // Back face\n            0.0f, 0.0f, -1.0f,\n            // Left face\n            -1.0f, 0.0f, 0.0f,\n            // Top face\n            0.0f, 1.0f, 0.0f,\n            // Bottom face\n            0.0f, -1.0f, 0.0f,\n    };\n```", "```kt\n\npublic static FloatBuffer normalBuffer;\n    ...\n\n    public static void allocateBuffers(){\n        ...\n\nnormalBuffer = allocateFloatBuffer( cubeFacesToArray(CUBE_NORMALS_FACES, 3) );\n    }\n```", "```kt\n    public Cube createMaterial(boolean lighting){\n if(lighting){\n VertexColorLightingMaterial mat = new VertexColorLightingMaterial();\n mat.setBuffers(vertexBuffer, colorBuffer, normalBuffer, 36);\n material = mat;\n } else {\n            VertexColorMaterial mat = new VertexColorMaterial();\n            mat.setBuffers(vertexBuffer, colorBuffer, numIndices);\n            material = mat;\n }\n        return this;\n    }\n```", "```kt\n    public Cube(){\n        super();\n        allocateBuffers();\n    }\n\n    public Cube(boolean lighting){\n        super();\n        allocateBuffers();\n        createMaterial(lighting);\n    }\n```", "```kt\npublic class Light extends Component {\n    private static final String TAG = \"RenderBox.Light\";\n\n    public final float[] lightPosInEyeSpace = new float[4];\n    public float[] color = new float[]{1,1,1,1};\n\n    public void onDraw(float[] view){\n        Matrix.multiplyMV(lightPosInEyeSpace, 0, view, 0, transform.getPosition().toFloat4(), 0);\n    }\n}\n```", "```kt\n    public Light mainLight;\n```", "```kt\n    public void onSurfaceCreated(EGLConfig eglConfig) {\n        ...\n mainLight = new Light();\n new Transform().addComponent(mainLight);\n        mainCamera = new Camera();\n        ...\n    }\n```", "```kt\n    public void onDrawEye(Eye eye) {\n        ...\n        // Apply the eye transformation to the camera.\n        Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);\n\n// Compute lighting position\n\nRenderBox.instance.mainLight.onDraw(view);\n```", "```kt\nuniform mat4 u_Model;\nuniform mat4 u_MVP;\nuniform mat4 u_MVMatrix;\nuniform vec3 u_LightPos;\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec3 a_Normal;\n\nvarying vec4 v_Color;\n\nconst float ONE = 1.0;\nconst float COEFF = 0.00001;\n\nvoid main() {\n    vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);\n    vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));\n\n    float distance = length(u_LightPos - modelViewVertex);\n    vec3 lightVector = normalize(u_LightPos - modelViewVertex);\n    float diffuse = max(dot(modelViewNormal, lightVector), 0.5);\n\n    diffuse = diffuse * (ONE / (ONE + (COEFF * distance * distance)));\n    v_Color = a_Color * diffuse;\n    gl_Position = u_MVP * a_Position;\n}\n```", "```kt\n// File: res/raw/vertex_color_lighting_fragment.shader\nprecision mediump float;\nvarying vec4 v_Color;\n\nvoid main() {\n    gl_FragColor = v_Color;\n}\n```", "```kt\npublic class VertexColorLightingMaterial extends Material {\n    private static final String TAG = \"vertexcollight\";\n    static int program = -1;\n    //Initialize to a totally invalid value for setup state\n\n    static int positionParam;\n    static int colorParam;\n    static int normalParam;\n    static int MVParam;\n    static int MVPParam;\n    static int lightPosParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer normalBuffer;\n    FloatBuffer colorBuffer;\n    int numIndices;\n\n    public VertexColorLightingMaterial(){\n        super();\n        setupProgram();\n    }\n\n    public static void setupProgram(){\n        //Already setup?\n\t\tif (program != -1) return;\n        //Create shader program\n        program = createProgram(R.raw.vertex_color_lighting_vertex, R.raw.vertex_color_lighting_fragment);\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        normalParam = GLES20.glGetAttribLocation(program, \"a_Normal\");\n        colorParam = GLES20.glGetAttribLocation(program, \"a_Color\");\n\n        //Enable vertex attribute parameters\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(normalParam);\n        GLES20.glEnableVertexAttribArray(colorParam);\n\n        //Shader-specific parameteters\n        MVParam = GLES20.glGetUniformLocation(program, \"u_MVMatrix\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n        lightPosParam = GLES20.glGetUniformLocation(program, \"u_LightPos\");\n\n        RenderBox.checkGLError(\"Solid Color Lighting params\");\n    }\n    public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer colorBuffer, FloatBuffer normalBuffer, int numIndices){\n        this.vertexBuffer = vertexBuffer;\n        this.normalBuffer = normalBuffer;\n        this.colorBuffer = colorBuffer;\n        this.numIndices = numIndices;\n    }\n\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        GLES20.glUseProgram(program);\n\n        GLES20.glUniform3fv(lightPosParam, 1, RenderBox.instance.mainLight.lightPosInEyeSpace, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.lightingModel, 0);\n\n        // Set the ModelView in the shader, used to calculate // lighting\n        GLES20.glUniformMatrix4fv(MVParam, 1, false, modelView, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n        // Set the ModelViewProjection matrix in the shader.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        // Set the normal positions of the cube, again for shading\n        GLES20.glVertexAttribPointer(normalParam, 3, GLES20.GL_FLOAT, false, 0, normalBuffer);\n        GLES20.glVertexAttribPointer(colorParam, 4, GLES20.GL_FLOAT, false, 0, colorBuffer);\n\n        // Set the position of the cube\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, numIndices);\n    }\n\n    public static void destroy(){\n        program = -1;\n    }\n}\n```", "```kt\n    public static void reset(){\n        VertexColorMaterial.destroy();\n VertexColorLightingMaterial.destroy();\n    }\n```", "```kt\n    public void setup() {\n        cube = new Transform();\n        cube.addComponent(new Cube(true));\n        cube.setLocalPosition(2.0f, -2.f, -5.0f);\n    }\n```", "```kt\npublic final class Time {\n    private Time(){}\n    static long startTime;\n    static long lastFrame;\n    static long deltaTime;\n    static int frameCount;\n\n    protected static void start(){\n        frameCount = 0;\n        startTime = System.currentTimeMillis();\n        lastFrame = startTime;\n    }\n    protected static void update(){\n        long current =System.currentTimeMillis();\n        frameCount++;\n        deltaTime = current - lastFrame;\n        lastFrame = current;\n    }\n\n    public static int getFrameCount(){return frameCount;}\n\n    public static float getTime(){\n        return (float)(System.currentTimeMillis() - startTime) / 1000;\n    }\n\n    public static float getDeltaTime(){\n        return deltaTime * 0.001f;\n    }\n}\n```", "```kt\n    public RenderBox(Activity mainActivity, IRenderBox callbacks){\n        ...\n Time.start();\n    }\n```", "```kt\n    public void onNewFrame(HeadTransform headTransform) {\n Time.update();\n        ...\n}\n```", "```kt\n    public void preDraw() {\n        float dt = Time.getDeltaTime();\n        cube.rotate(dt * 5, dt * 10, dt * 7.5f);\n    }\n```", "```kt\n    public boolean isLooking;\n    private static final float YAW_LIMIT = 0.15f;\n    private static final float PITCH_LIMIT = 0.15f;\n    final float[] modelView = new float[16];\n```", "```kt\n    private boolean isLookingAtObject() {\n        float[] initVec = { 0, 0, 0, 1.0f };\n        float[] objPositionVec = new float[4];\n\n        // Convert object space to camera space. Use the headView // from onNewFrame.\n        Matrix.multiplyMM(modelView, 0, RenderBox.headView, 0, model, 0);\n        Matrix.multiplyMV(objPositionVec, 0, modelView, 0, initVec, 0);\n\n        float pitch = (float) Math.atan2(objPositionVec[1], -objPositionVec[2]);\n        float yaw = (float) Math.atan2(objPositionVec[0], -objPositionVec[2]);\n\n        return Math.abs(pitch) < PITCH_LIMIT && Math.abs(yaw) < YAW_LIMIT;\n    }\n```", "```kt\n    public void draw(float[] view, float[] perspective){\n        . . . \n isLooking = isLookingAtObject();\n    }\n```", "```kt\n    Cube cubeObject;\n\n    public void setup() {\n        cube = new Transform();\n        cubeObject = new Cube(true);\n        cube.addComponent(cubeObject);\n        cube.setLocalPosition(2.0f, -2.f, -5.0f);\n    }\n```", "```kt\n    public void postDraw() {\n        if (cubeObject.isLooking) {\n            Log.d(TAG, \"isLooking at Cube\");\n        }\n    }\n```"]