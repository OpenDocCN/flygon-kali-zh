- en: '6: Images'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6：镜像
- en: In this chapter we’ll dive into Docker images. The aim of the game is to give
    you a **solid understanding** of what Docker images are, and how to perform basic
    operations. In a later chapter we’ll see how to build new images with our own
    applications inside of them (containerizing an app).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Docker镜像。游戏的目标是让您对Docker镜像有一个**扎实的理解**，以及如何执行基本操作。在后面的章节中，我们将看到如何在其中构建包含我们自己应用程序的新镜像（容器化应用程序）。
- en: 'We’ll split this chapter into the usual three parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章分为通常的三个部分：
- en: The TLDR
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLDR
- en: The deep dive
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解
- en: The commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Let’s go and learn about images!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去学习关于镜像的知识吧！
- en: Docker images - The TLDR
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker镜像- TLDR
- en: If you’re a former VM admin you can think of Docker images as being like VM
    templates. A VM template is like a stopped VM — a Docker image is like a stopped
    container. If you’re a developer you can think of them as being similar to *classes*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经是虚拟机管理员，您可以将Docker镜像视为类似于VM模板。VM模板就像是一个停止的VM- Docker镜像就像是一个停止的容器。如果您是开发人员，您可以将它们视为类似于*类*。
- en: You start by *pulling* images from an image registry. The most popular registry
    is [Docker Hub](https://hub.docker.com), but others do exist. The *pull* operation
    downloads the image to your local Docker host where you can use it to start one
    or more Docker containers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从镜像注册表中*拉取*镜像开始。最受欢迎的注册表是[Docker Hub](https://hub.docker.com)，但也存在其他注册表。*拉取*操作会将镜像下载到本地Docker主机，您可以在其中使用它来启动一个或多个Docker容器。
- en: Images are made up of multiple layers that get stacked on top of each other
    and represented as a single object. Inside of the image is a cut-down operating
    system (OS) and all of the files and dependencies required to run an application.
    Because containers are intended to be fast and lightweight, images tend to be
    small.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像由多个层组成，这些层堆叠在一起并表示为单个对象。镜像中包含一个精简的操作系统（OS）以及运行应用程序所需的所有文件和依赖项。由于容器旨在快速和轻量级，因此镜像往往很小。
- en: Congrats! You’ve now got half a clue what a Docker image is :-D Now it’s time
    to blow your mind!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在对Docker镜像有了一点概念 :-D 现在是时候让您大开眼界了！
- en: Docker images - The deep dive
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker镜像-深入了解
- en: We’ve mentioned a couple of times already that **images** are like stopped containers
    (or **classes** if you’re a developer). In fact, you can stop a container and
    create a new image from it. With this in mind, images are considered *build-time*
    constructs, whereas containers are *run-time* constructs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到**镜像**就像是停止的容器（或者如果您是开发人员，就像是**类**）。事实上，您可以停止一个容器并从中创建一个新的镜像。考虑到这一点，镜像被认为是*构建时*构造，而容器是*运行时*构造。
- en: '![Figure 6.1](images/figure6-1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1](images/figure6-1.png)'
- en: Figure 6.1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1
- en: Images and containers
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜像和容器
- en: 'Figure 6.1 shows high-level view of the relationship between images and containers.
    We use the `docker container run` and `docker service create` commands to start
    one or more containers from a single image. However, once you’ve started a container
    from an image, the two constructs become dependent on each other and you cannot
    delete the image until the last container using it has been stopped and destroyed.
    Attempting to delete an image without stopping and destroying all containers using
    it will result in the following error:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1显示了镜像和容器之间关系的高层视图。我们使用`docker container run`和`docker service create`命令从单个镜像启动一个或多个容器。但是，一旦您从镜像启动了一个容器，这两个构造就会相互依赖，直到最后一个使用它的容器停止和销毁之前，您不能删除该镜像。尝试删除一个正在使用的镜像而不停止和销毁所有使用它的容器将导致以下错误：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`#### Images are usually small'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`#### 镜像通常很小'
- en: The whole purpose of a container is to run an application or service. This means
    that the image a container is created from must contain all OS and application
    files required to run the app/service. However, containers are all about being
    fast and lightweight. This means that the images they’re built from are usually
    small and stripped of all non-essential parts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的整个目的是运行应用程序或服务。这意味着容器创建的镜像必须包含运行应用程序/服务所需的所有操作系统和应用程序文件。但是，容器的全部意义在于快速和轻量级。这意味着它们构建的镜像通常很小，并且剥离了所有非必要的部分。
- en: For example, Docker images do not ship with 6 different shells for you to choose
    from — they usually ship with a single minimalist shell, or no shell at all. They
    also don’t contain a kernel — all containers running on a Docker host share access
    to the host’s kernel. For these reasons, we sometimes say images contain *just
    enough operating system* (usually just OS-related files and filesystem objects).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Docker镜像不会为您提供6种不同的shell供您选择 - 它们通常只提供一个最小化的shell，或者根本不提供shell。它们也不包含内核 -
    在Docker主机上运行的所有容器共享对主机内核的访问。因此，我们有时会说镜像包含*足够的操作系统*（通常只有与操作系统相关的文件和文件系统对象）。
- en: '**Note:** Hyper-V containers run inside of a dedicated lightweight VM and leverage
    the kernel of the OS running inside the VM.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** Hyper-V容器在专用的轻量级虚拟机内运行，并利用虚拟机内运行的操作系统的内核。'
- en: The official *Alpine Linux* Docker image is about 4MB in size and is an extreme
    example of how small Docker images can be. That’s not a typo! It really is about
    4 megabytes! However, a more typical example might be something like the official
    Ubuntu Docker image which is currently about 110MB. These are clearly stripped
    of most non-essential parts!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的*Alpine Linux* Docker镜像大约为4MB，是Docker镜像可以有多小的一个极端示例。这不是打字错误！它确实大约为4兆字节！然而，一个更典型的例子可能是官方的Ubuntu
    Docker镜像，目前大约为110MB。这些显然剥离了大多数非必要的部分！
- en: Windows-based images tend to be bigger than Linux-based images because of the
    way that the Windows OS works. For example, the latest Microsoft .NET image (`microsoft/dotnet:latest`)
    is over 1.7GB when pulled an uncompressed. The Windows Server 2016 Nano Server
    image (`microsoft/nanoserver:latest`) is slightly over 1GB when pulled and uncompressed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Windows的镜像往往比基于Linux的镜像大，这是因为Windows操作系统的工作方式。例如，最新的Microsoft .NET镜像（`microsoft/dotnet:latest`）在拉取和解压缩时超过1.7GB。Windows
    Server 2016 Nano Server镜像（`microsoft/nanoserver:latest`）在拉取和解压缩时略大于1GB。
- en: Pulling images
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拉取镜像
- en: A cleanly installed Docker host has no images in its local repository.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 干净安装的Docker主机在其本地存储库中没有任何镜像。
- en: The local image repository on a Linux-based Docker host is usually located at
    `/var/lib/docker/<storage-driver>`. On Windows-based Docker hosts this is `C:\
    ProgramData\docker\windowsfilter`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Linux的Docker主机上的本地镜像存储库通常位于`/var/lib/docker/<storage-driver>`。在基于Windows的Docker主机上，这是`C:\
    ProgramData\docker\windowsfilter`。
- en: You can check if your Docker host has any images in its local repository with
    the following command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查您的Docker主机是否在其本地存储库中有任何镜像。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`The process of getting images onto a Docker host is called *pulling*. So,
    if you want the latest Ubuntu image on your Docker host, you’d have to *pull*
    it. Use the following commands to *pull* some images and then check their sizes.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像放入Docker主机的过程称为*拉取*。因此，如果您想要在Docker主机上获取最新的Ubuntu镜像，您需要*拉取*它。使用以下命令*拉取*一些镜像，然后检查它们的大小。
- en: If you are following along on Linux and haven’t added your user account to the
    local `docker` Unix group, you may need to add `sudo` to the beginning of all
    the following commands.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您在Linux上进行操作，并且尚未将您的用户帐户添加到本地`docker` Unix组中，则可能需要在所有以下命令的开头添加`sudo`。
- en: 'Linux example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux示例：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Windows example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Windows示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`As you can see, the images just pulled are now present in the Docker host’s
    local repository. You can also see that the Windows images are a lot larger and
    comprise a lot more layers.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，刚刚拉取的镜像现在存在于Docker主机的本地存储库中。你还可以看到Windows镜像要大得多，并且包含了更多的层。
- en: Image naming
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜像命名
- en: As part of each command, we had to specify which image to pull. So let’s take
    a minute to look at image naming. To do that we need a bit of background on how
    we store images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命令的一部分，我们必须指定要拉取的镜像。所以让我们花点时间来看看镜像命名。为此，我们需要了解一些关于如何存储镜像的背景知识。
- en: Image registries
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜像注册表
- en: Docker images are stored in *image registries*. The most common registry is
    Docker Hub (https://hub.docker.com). Other registries exist, including 3rd party
    registries and secure on-premises registries. However, the Docker client is opinionated
    and defaults to using Docker Hub. We’ll be using Docker Hub for the rest of the
    book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像存储在*镜像注册表*中。最常见的注册表是Docker Hub（https://hub.docker.com）。还有其他注册表，包括第三方注册表和安全的本地注册表。然而，Docker客户端有自己的偏好，并默认使用Docker
    Hub。我们将在本书的其余部分使用Docker Hub。
- en: Image registries contain multiple *image repositories*. In turn, image repositories
    can contain multiple images. That might be a bit confusing, so Figure 6.2 shows
    a picture of an image registry containing 3 repositories, and each repository
    contains one or more images.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像注册表包含多个*镜像存储库*。反过来，镜像存储库可以包含多个镜像。这可能有点令人困惑，因此图6.2显示了一个包含3个存储库的镜像注册表的图片，每个存储库包含一个或多个镜像。
- en: '![Figure 6.2](images/figure6-2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2](images/figure6-2.png)'
- en: Figure 6.2
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2
- en: Official and unofficial repositories
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 官方和非官方存储库
- en: Docker Hub also has the concept of *official repositories* and *unofficial repositories*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub还有*官方存储库*和*非官方存储库*的概念。
- en: As the name suggests, *official repositories* contain images that have been
    vetted by Docker, Inc. This means they should contain up-to-date, high-quality
    code, that is secure, well-documented, and in-line with best practices (please
    can I have an award for using five hyphens in a single sentence).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，*官方存储库*包含了经过Docker, Inc.审核的镜像。这意味着它们应该包含最新的、高质量的代码，安全、有良好的文档，并符合最佳实践（请问我能否因在一个句子中使用了五个连字符而获得奖励）。
- en: '*Unofficial repositories* can be like the wild-west — you should not *expect*
    them to be safe, well-documented or built according to best practices. That’s
    not saying everything in *unofficial repositories* is bad! There’s some **brilliant**
    stuff in *unofficial repositories*. You just need to be very careful before trusting
    code from them. To be honest, you should always be careful when getting software
    from the internet — even images from *official repositories!*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*非官方存储库*可能像是荒野——你不应该*期望*它们是安全的、有良好的文档或者按照最佳实践构建的。这并不是说*非官方存储库*中的所有东西都是坏的！*非官方存储库*中有一些**精彩**的东西。你只需要在信任它们的代码之前非常小心。老实说，当从互联网获取软件时，你应该始终小心——甚至是从*官方存储库*获取的镜像！'
- en: 'Most of the popular operating systems and applications have their own *official
    repositories* on Docker Hub. They’re easy to spot because they live at the top
    level of the Docker Hub namespace. The following list contains a few of the *official
    repositories*, and shows their URLs that exist at the top-level of the Docker
    Hub namespace:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的操作系统和应用程序在Docker Hub上都有自己的*官方存储库*。它们很容易识别，因为它们位于Docker Hub命名空间的顶层。以下列表包含了一些*官方存储库*，并显示了它们在Docker
    Hub命名空间顶层存在的URL：
- en: '**nginx:** https://hub.docker.com/_/nginx/'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nginx:** https://hub.docker.com/_/nginx/'
- en: '**busybox:** https://hub.docker.com/_/busybox/'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**busybox:** https://hub.docker.com/_/busybox/'
- en: '**redis:** https://hub.docker.com/_/redis/'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**redis:** https://hub.docker.com/_/redis/'
- en: '**mongo:** https://hub.docker.com/_/mongo/'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mongo:** https://hub.docker.com/_/mongo/'
- en: 'On the other hand, my own personal images live in the wild west of *unofficial
    repositories* and should **not** be trusted! Here are some examples of images
    in my repositories:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我的个人图像存储在*非官方存储库*的荒野中，不应该被信任！以下是我存储库中图像的一些示例：
- en: nigelpoulton/tu-demo
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nigelpoulton/tu-demo
- en: https://hub.docker.com/r/nigelpoulton/tu-demo/
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: https://hub.docker.com/r/nigelpoulton/tu-demo/
- en: nigelpoulton/pluralsight-docker-ci
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nigelpoulton/pluralsight-docker-ci
- en: https://hub.docker.com/r/nigelpoulton/pluralsight-docker-ci/
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: https://hub.docker.com/r/nigelpoulton/pluralsight-docker-ci/
- en: Not only are images in my repositories **not** vetted, **not** kept up-to-date,
    **not** secure, and **not** well documented… you should also notice that they
    don’t live at the top-level of the Docker Hub namespace. My repositories all live
    within a second-level namespace called `nigelpoulton`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我的存储库中的图像不仅没有经过审查，也没有及时更新，不安全，文档也不完善... 你还应该注意到它们并不位于Docker Hub命名空间的顶层。我的存储库都位于一个名为`nigelpoulton`的二级命名空间中。
- en: You’ll probably notice that the Microsoft images we’ve used do not exist at
    the top-level of the Docker Hub namespace. At the time of writing, they exist
    under the `microsoft` second-level namespace.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们使用的Microsoft图像并不位于Docker Hub命名空间的顶层。在撰写本文时，它们存在于`microsoft`的二级命名空间下。
- en: After all of that, we can finally look at how we address images on the Docker
    command line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些之后，我们终于可以看一下如何在Docker命令行中处理图像。
- en: Image naming and tagging
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图像命名和标记
- en: 'Addressing images from official repositories is as simple as giving the repository
    name and tag separated by a colon (`:`). The format for `docker image pull`, when
    working with an image from an official repository is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方存储库中寻址图像就像简单地给出存储库名称和标签，用冒号（`:`）分隔。当使用来自官方存储库的图像时，`docker image pull`的格式为：
- en: '`docker image pull <repository>:<tag>`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image pull <repository>:<tag>`'
- en: 'In the Linux examples from earlier, we pulled an Alpine and an Ubuntu images
    with the following two commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Linux示例中，我们使用以下两个命令拉取了Alpine和Ubuntu图像：
- en: '`docker image pull alpine:latest` and `docker image pull ubuntu:latest`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image pull alpine:latest` 和 `docker image pull ubuntu:latest`'
- en: These two commands pull the images tagged as “latest” from the “alpine” and
    “ubuntu” repositories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令从“alpine”和“ubuntu”存储库中拉取标记为“latest”的图像。
- en: 'The following examples show how to pull various different images from *official
    repositories*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何从*官方存储库*中拉取不同的图像：
- en: '[PRE4]`3`.3.11[PRE5]mongo[PRE6]latest[PRE7]redis[PRE8]latest[PRE9]alpine[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]`3`.3.11[PRE5]mongo[PRE6]latest[PRE7]redis[PRE8]latest[PRE9]alpine[PRE10]'
- en: '`A couple of points about those commands.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`关于这些命令的一些要点。'
- en: First, if you **do not** specify an image tag after the repository name, Docker
    will assume you are referring to the image tagged as `latest`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果在存储库名称后**没有**指定图像标签，Docker将假定你指的是标记为`latest`的图像。
- en: Second, the `latest` tag doesn’t have any magical powers! Just because an image
    is tagged as `latest` does not guarantee it is the most recent image in a repository!
    For example, the most recent image in the `alpine` repository is usually tagged
    as `edge`. Moral of the story — take care when using the `latest` tag!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`latest`标签并没有任何神奇的功能！仅仅因为一个图像被标记为`latest`并不意味着它是存储库中最新的图像！例如，`alpine`存储库中最新的图像通常被标记为`edge`。故事的寓意是——在使用`latest`标签时要小心！
- en: Pulling images from an *unofficial repository* is essentially the same — you
    just need to prepend the repository name with a Docker Hub username or organization
    name. The following example shows how to pull the `v2` image from the `tu-demo`
    repository owned by a not-to-be-trusted person whose Docker Hub account name is
    `nigelpoulton`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从*非官方仓库*中拉取图像本质上是一样的——你只需要在仓库名称前加上一个Docker Hub用户名或组织名称。下面的例子展示了如何从一个不可信任的人拥有的Docker
    Hub帐户名为`nigelpoulton`的`tu-demo`仓库中拉取`v2`图像。
- en: '[PRE11]v2[PRE12]tu-demo[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]v2[PRE12]tu-demo[PRE13]'
- en: '`In our earlier Windows examples, we pulled a PowerShell and a .NET image with
    the following two commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`在我们之前的Windows示例中，我们用以下两个命令拉取了一个PowerShell和一个.NET图像：'
- en: '`> docker image pull microsoft/powershell:nanoserver`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker image pull microsoft/powershell:nanoserver`'
- en: '`> docker image pull microsoft/dotnet:latest`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`> docker image pull microsoft/dotnet:latest`'
- en: The first command pulls the image tagged as `nanoserver` from the `microsoft/powershell`
    repository. The second command pulls the image tagged as `latest` from the `microsoft/dotnet`
    repository.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令从`microsoft/powershell`仓库中拉取标记为`nanoserver`的图像。第二个命令从`microsoft/dotnet`仓库中拉取标记为`latest`的图像。
- en: If you want to pull images from 3rd party registries (not Docker Hub), you need
    to prepend the repository name with the DNS name of the registry. For example,
    if the image in the example above was in the Google Container Registry (GCR) you’d
    need to add `gcr.io` before the repository name as follows — `docker pull gcr.io/nigelpoulton/tu-demo:v2`
    (no such repository and image exists).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从第三方注册表（而不是Docker Hub）中拉取图像，你需要在仓库名称前加上注册表的DNS名称。例如，如果上面的例子中的图像在Google容器注册表（GCR）中，你需要在仓库名称前添加`gcr.io`，如下所示——`docker
    pull gcr.io/nigelpoulton/tu-demo:v2`（没有这样的仓库和图像存在）。
- en: You may need to have an account on 3rd party registries and be logged into them
    before you can pull images from them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要在从第三方注册表中拉取图像之前在其上拥有一个帐户并登录。
- en: Images with multiple tags
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有多个标签的图像
- en: One final word about image tags… A single image can have as many tags as you
    want. This is because tags are arbitrary alpha-numeric values that are stored
    as metadata alongside the image. Let’s look at an example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图像标签的最后一句话…… 一个单独的图像可以有任意多个标签。这是因为标签是存储在图像旁边的元数据的任意字母数字值。让我们来看一个例子。
- en: Pull all of the images in a repository by adding the `-a` flag to them `docker
    image pull` command. Then run `docker image ls` to look at the images pulled.
    If you are following along with Windows you can pull from the `microsoft/nanoserver`
    repository instead of `nigelpoulton/tu-demo`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`docker image pull`命令中添加`-a`标志来拉取仓库中的所有图像。然后运行`docker image ls`来查看拉取的图像。如果你正在使用Windows，你可以从`microsoft/nanoserver`仓库中拉取，而不是`nigelpoulton/tu-demo`。
- en: '**Note:** If the repository you are pulling from contains images for multiple
    architectures and platforms, such as Linux **and** Windows, the command is likely
    to fail.'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**如果你从中拉取的仓库包含多个架构和平台的图像，比如Linux **和** Windows，该命令可能会失败。'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`A couple of things about what just happened:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于刚刚发生的一些事情：
- en: 'First. the command pulled three images from the `nigelpoulton/tu-demo` repository:
    `latest`, `v1`, and `v2`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该命令从`nigelpoulton/tu-demo`仓库中拉取了三个图像：`latest`、`v1`和`v2`。
- en: Second. Look closely at the `IMAGE ID` column in the output of the `docker image
    ls` command. You’ll see that there are only two unique image IDs. This is because
    only two images were actually downloaded. This is because two of the tags refer
    to the same image. Put another way… one of the images has two tags. If you look
    closely you’ll see that the `v1` and `latest` tags have the same `IMAGE ID`. This
    means they’re two tags of the **same image**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，请仔细查看“docker image ls”命令的输出中的“IMAGE ID”列。您会发现只有两个唯一的图像ID。这是因为实际上只有两个图像被下载。这是因为两个标签指向相同的图像。换句话说...其中一个图像有两个标签。如果您仔细观察，您会发现“v1”和“latest”标签具有相同的“IMAGE
    ID”。这意味着它们是**同一图像**的两个标签。
- en: This is a perfect example of the warning issued earlier about the `latest` tag.
    In this example, the `latest` tag refers to the same image as the `v1` tag. This
    means it’s pointing to the older of the two images — not the newest! `latest`
    is an arbitrary tag and is not guaranteed to point to the newest image in a repository!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于“latest”标签的警告的完美例子。在这个例子中，“latest”标签指的是与“v1”标签相同的图像。这意味着它指向两个图像中较旧的一个，而不是最新的一个！“latest”是一个任意的标签，并不能保证指向存储库中最新的图像！
- en: Filtering the output of `docker image ls`
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤“docker image ls”的输出
- en: Docker provides the `--filter` flag to filter the list of images returned by
    `docker image ls`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了“--filter”标志来过滤由“docker image ls”返回的图像列表。
- en: The following example will only return dangling images.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将仅返回悬空图像。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`A dangling image is an image that is no longer tagged, and appears in listings
    as `<none>:<none>`. A common way they occur is when building a new image and tagging
    it with an existing tag. When this happens, Docker will build the new image, notice
    that an existing image has a matching tag, remove the tag from the existing image,
    give the tag to the new image. For example, you build a new image based on `alpine:3.4`
    and tag it as `dodge:challenger`. Then you update the Dockerfile to replace `alpine:3.4`
    with `alpine:3.5` and run the exact same `docker image build` command. The build
    will create a new image tagged as `dodge:challenger` and remove the tags from
    the older image. The old image will become a dangling image.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 悬空图像是不再标记的图像，并在列表中显示为`<none>:<none>`。它们出现的常见方式是在构建新图像并使用现有标签对其进行标记时。当这种情况发生时，Docker将构建新图像，注意到现有图像具有匹配的标签，从现有图像中删除标签，并将标签赋予新图像。例如，您基于`alpine:3.4`构建了一个新图像，并将其标记为`dodge:challenger`。然后，您更新Dockerfile以将`alpine:3.4`替换为`alpine:3.5`，并运行完全相同的`docker
    image build`命令。构建将创建一个新图像，标记为`dodge:challenger`，并从旧图像中删除标签。旧图像将变成悬空图像。
- en: You can delete all dangling images on a system with the `docker image prune`
    command. If you add the `-a` flag, Docker will also remove all unused images (those
    not in use by any containers).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用“docker image prune”命令删除系统上的所有悬空图像。如果添加“-a”标志，Docker还将删除所有未使用的图像（即任何容器未使用的图像）。
- en: 'Docker currently supports the following filters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Docker目前支持以下过滤器：
- en: '`dangling:` Accepts `true` or `false`, and returns only dangling images (true),
    or non-dangling images (false).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dangling:`接受“true”或“false”，并仅返回悬空图像（true）或非悬空图像（false）。'
- en: '`before:` Requires an image name or ID as argument, and returns all images
    created before it.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before:`需要一个图像名称或ID作为参数，并返回在其之前创建的所有图像。'
- en: '`since:` Same as above, but returns images created after the specified image.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`since:`与上述相同，但返回在指定图像之后创建的图像。'
- en: '`label:` Filters images based on the presence of a label or label and value.
    The `docker image ls` command does not display labels in its output.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label:`根据标签或标签和值的存在来过滤图像。`docker image ls`命令不会在其输出中显示标签。'
- en: For all other filtering you can use `reference`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他过滤，您可以使用“reference”。
- en: Here’s an example using `reference` to display only images tagged as “latest”.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用“reference”来仅显示标记为“latest”的图像的例子。
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`You can also use the `--format` flag to format output using Go templates.
    For example, the following command will only return the size property of images
    on a Docker host.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`您还可以使用`--format`标志使用Go模板格式化输出。例如，以下命令将仅返回Docker主机上图像的大小属性。'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Use the following command to return all images, but only display repo, tag
    and size.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`使用以下命令返回所有图像，但仅显示存储库、标签和大小。'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`If you need more powerful filtering, you can always use the tools provided
    by your OS and shell such as `grep` and `awk`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`如果您需要更强大的过滤功能，您可以随时使用操作系统和shell提供的工具，如`grep`和`awk`。'
- en: Searching Docker Hub from the CLI
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从CLI搜索Docker Hub
- en: The `docker search` command lets you search Docker Hub from the CLI. You can
    pattern match against strings in the “NAME” field, and filter output based on
    any of the returned columns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker search`命令允许您从CLI搜索Docker Hub。您可以针对“NAME”字段中的字符串进行模式匹配，并根据返回的任何列来过滤输出。'
- en: In its simplest form, it searches for all repos containing a certain string
    in the “NAME” field. For example, the following command searches for all repos
    with “nigelpoulton” in the “NAME” field.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，它搜索包含在“NAME”字段中的特定字符串的所有存储库。例如，以下命令搜索所有在“NAME”字段中包含“nigelpoulton”的存储库。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`The “NAME” field is the repository name, and includes the Docker ID, or organization
    name, for unofficial repositories. For example, the following command will list
    all repositories that include the string “alpine” in the name.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “NAME”字段是存储库名称，并包括非官方存储库的Docker ID或组织名称。例如，以下命令将列出所有包含名称中包含“alpine”的存储库。
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Notice how some of the repositories returned are official and some are unofficial.
    You can use `--filter "is-official=true"` so that only official repos are displayed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`注意一下，返回的一些存储库是官方的，一些是非官方的。您可以使用`--filter "is-official=true"`，这样只有官方存储库才会显示。'
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`You can do the same again, but this time only show repos with automated builds.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`您可以再次执行相同的操作，但这次只显示具有自动构建的存储库。'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`One last thing about `docker search`. By default, Docker will only display
    25 lines of results. However, you can use the `--limit` flag to increase that
    to a maximum of 100.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`关于`docker search`的最后一件事。默认情况下，Docker只会显示25行结果。但是，您可以使用`--limit`标志将其增加到最多100行。'
- en: Images and layers
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图像和层
- en: A Docker image is just a bunch of loosely-connected read-only layers. This is
    shown in Figure 6.3.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Docker图像只是一堆松散连接的只读层。这在图6.3中显示出来。
- en: '![Figure 6.3](images/figure6-3.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3](images/figure6-3.png)'
- en: Figure 6.3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3
- en: Docker takes care of stacking these layers and representing them as a single
    unified object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Docker负责堆叠这些层并将它们表示为单个统一的对象。
- en: 'There are a few ways to see and inspect the layers that make up an image, and
    we’ve already seen one of them. Let’s take a second look at the output of the
    `docker image pull ubuntu:latest` command from earlier:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以查看和检查构成图像的层，我们已经看到其中一种。让我们再次看一下之前`docker image pull ubuntu:latest`命令的输出：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Each line in the output above that ends with “Pull complete” represents a
    layer in the image that was pulled. As we can see, this image has 5 layers. Figure
    6.4 shows this in picture form, displaying layer IDs.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`上面输出中以“Pull complete”结尾的每一行代表了被拉取的图像中的一个层。正如我们所看到的，这个图像有5个层。图6.4以图片形式显示了这一点，显示了层ID。'
- en: '![Figure 6.4](images/figure6-4.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4](images/figure6-4.png)'
- en: Figure 6.4
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4
- en: Another way to see the layers of an image is to inspect the image with the `docker
    image inspect` command. The following example inspects the same `ubuntu:latest`
    image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图像的层的另一种方法是使用`docker image inspect`命令检查图像。以下示例检查了相同的`ubuntu:latest`图像。
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`The trimmed output shows 5 layers again. Only this time they’re shown using
    their SHA256 hashes. However, both commands show that the image has 5 layers.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪后的输出再次显示了5个图层。只是这一次它们使用它们的SHA256哈希值显示。然而，两个命令都显示该图像有5个图层。
- en: '**Note:** The `docker history` command shows the build history of an image
    and is **not** a strict list of layers in the image. For example, some Dockerfile
    instructions used to build an image do not result in layers being created. These
    include; “ENV”, “EXPOSE”, “CMD”, and “ENTRYPOINT”. Instead of these creating new
    layers, they add metadata to the image.'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**`docker history`命令显示图像的构建历史，**不是**图像中图层的严格列表。例如，用于构建图像的一些Dockerfile指令不会创建图层。这些指令包括：“ENV”、“EXPOSE”、“CMD”和“ENTRYPOINT”。这些指令不会创建新的图层，而是向图像添加元数据。'
- en: All Docker images start with a base layer, and as changes are made and new content
    is added, new layers are added on top.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Docker图像都以一个基本图层开始，随着更改和新内容的添加，新的图层会被添加到顶部。
- en: As an over-simplified example, you might create a new image based off Ubuntu
    Linux 16.04\. This would be your image’s first layer. If you later add the Python
    package, this would be added as a second layer on top of the base layer. If you
    then added a security patch, this would be added as a third layer at the top.
    Your image would now have three layers as shown in Figure 6.5 (remember this is
    an over-simplified example for demonstration purposes).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个过度简化的例子，你可能会创建一个基于Ubuntu Linux 16.04的新图像。这将是你的图像的第一层。如果你稍后添加Python包，这将作为第二层添加到基本图层之上。如果你随后添加了一个安全补丁，这将作为第三层添加到顶部。你的图像现在有三个图层，如图6.5所示（请记住，这只是一个为了演示目的而过度简化的例子）。
- en: '![Figure 6.5](images/figure6-5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5](images/figure6-5.png)'
- en: Figure 6.5
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5
- en: It’s important to understand that as additional layers are added, the *image*
    is always the combination of all layers. Take a simple example of two layers as
    shown in Figure 6.6\. Each *layer* has 3 files, but the overall *image* has 6
    files as it is the combination of both layers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，随着添加额外的图层，*图像*始终是所有图层的组合。以图6.6中显示的两个图层为例。每个*图层*有3个文件，但整体*图像*有6个文件，因为它是两个图层的组合。
- en: '![Figure 6.6](images/figure6-6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6](images/figure6-6.png)'
- en: Figure 6.6
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6
- en: '**Note:** We’ve shown the image layers in Figure 6.6 in a slightly different
    way to previous figures. This is just to make showing the files easier.'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**我们在图6.6中以略有不同的方式显示了图像图层，这只是为了更容易地显示文件。'
- en: In the slightly more complex example of the three-layered image in Figure 6.7,
    the overall image only presents 6 files in the unified view. This is because file
    7 in the top layer is an updated version of file 5 directly below (inline). In
    this situation, the file in the higher layer obscures the file directly below
    it. This allows updated versions of files to be added as new layers to the image.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.7中更复杂的三层图像的例子中，统一视图中的整体图像只呈现了6个文件。这是因为顶层的文件7是直接下方文件5的更新版本（内联）。在这种情况下，更高层的文件遮盖了直接下方的文件。这允许将文件的更新版本作为图像的新图层添加。
- en: '![Figure 6.7](images/figure6-7.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7](images/figure6-7.png)'
- en: Figure 6.7
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7
- en: Docker employs a storage driver (snapshotter in newer versions) that is responsible
    for stacking layers and presenting them as a single unified filesystem. Examples
    of storage drivers on Linux include `AUFS`, `overlay2`, `devicemapper`, `btrfs`
    and `zfs`. As their names suggest, each one is based on a Linux filesystem or
    block-device technology, and each has its own unique performance characteristics.
    The only driver supported by Docker on Windows is `windowsfilter`, which implements
    layering and CoW on top of NTFS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用存储驱动程序（较新版本中的快照程序）负责堆叠图层并将它们呈现为单一的统一文件系统。Linux上的存储驱动程序示例包括`AUFS`、`overlay2`、`devicemapper`、`btrfs`和`zfs`。正如它们的名称所暗示的那样，每个驱动程序都基于Linux文件系统或块设备技术，并且每个驱动程序都具有其独特的性能特征。Windows上Docker支持的唯一驱动程序是`windowsfilter`，它在NTFS之上实现了分层和写时复制（CoW）。
- en: Figure 6.8 shows the same 3-layer image as it will appear to the system. I.e.
    all three layers stacked and merged, giving a single unified view.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8显示了与系统中将显示的相同的3层图像。即所有三个图层堆叠和合并，形成单一的统一视图。
- en: '![Figure 6.8](images/figure6-8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8](images/figure6-8.png)'
- en: Figure 6.8
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8
- en: Sharing image layers
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享图像层
- en: Multiple images can, and do, share layers. This leads to efficiencies in space
    and performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 多个图像可以共享图层，这导致了空间和性能的效率。
- en: Let’s take a second look at the `docker image pull` command with the `-a` flag
    that we ran previously to pull all tagged images in the `nigelpoulton/tu-demo`
    repository.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们之前使用`docker image pull`命令和`-a`标志来拉取`nigelpoulton/tu-demo`存储库中的所有标记图像。
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Notice the lines ending in `Already exists`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以`已存在`结尾的行。
- en: These lines tell us that Docker is smart enough recognize when it’s being asked
    to pull an image layer that it already has a copy of. In this example, Docker
    pulled the image tagged as `latest` first. Then, when it pulled the `v1` and `v2`
    images, it noticed that it already had some of the layers that make up those images.
    This happens because the three images in this repository are almost identical,
    and therefore share many layers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行告诉我们，Docker足够聪明，能够识别当被要求拉取已经存在副本的图像层时。在这个例子中，Docker首先拉取了标记为`latest`的图像。然后，当它拉取`v1`和`v2`图像时，它注意到它已经有了组成这些图像的一些图层。这是因为该存储库中的三个图像几乎是相同的，因此共享许多图层。
- en: As mentioned previously, Docker on Linux supports many storage drivers (snapshotters).
    Each is free to implement image layering, layer sharing, and copy-on-write (CoW)
    behaviour in its own way. However, the overall result and user experience is essentially
    the same. Although Windows only supports a single storage driver, that driver
    provides the same experience as Linux.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Linux上的Docker支持许多存储驱动程序（快照程序）。每个都可以自由地以自己的方式实现图像分层、图层共享和写时复制（CoW）行为。然而，总体结果和用户体验基本相同。尽管Windows只支持单个存储驱动程序，但该驱动程序提供与Linux相同的体验。
- en: Pulling images by digest
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过摘要拉取图像
- en: So far, we’ve shown you how to pull images by tag, and this is by far the most
    common way. But it has a problem — tags are mutable! This means it’s possible
    to accidentally tag an image with the wrong tag. Sometimes it’s even possible
    to tag an image with the same tag as an existing, but different, image. This can
    cause problems!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向您展示了如何按标记拉取图像，这绝对是最常见的方式。但是它有一个问题——标记是可变的！这意味着有可能意外地使用错误的标记标记图像。有时甚至可能使用与现有但不同的图像相同的标记标记图像。这可能会引起问题！
- en: As an example, imagine that you’ve got an image called `golftrack:1.5` and it
    has a known bug. You pull the image, apply a fix, and push the updated image back
    to its repository using the **same tag**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个名为`golftrack:1.5`的图像，并且它有一个已知的错误。您拉取图像，应用修复，并使用**相同的标记**将更新后的图像推送回其存储库。
- en: Take a second to understand what just happened there… You have an image called
    `golftrack:1.5` that has a bug. That image is being used in your production environment.
    You create a new version of the image that includes a fix. Then comes the mistake…
    you build and push the fixed image back to its repository with the **same tag
    as the vulnerable image!**. This overwrites the original image and leaves without
    a great way of knowing which of your production containers are running from the
    vulnerable image and which are running from the fixed image? Both images have
    the same tag!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间理解刚刚发生的事情...您有一个名为`golftrack:1.5`的镜像存在漏洞。该镜像正在您的生产环境中使用。您创建了一个包含修复的新版本的镜像。然后出现了错误...您构建并将修复后的镜像推送回其存储库，**与易受攻击的镜像使用相同的标签！**这将覆盖原始镜像，并且无法很好地知道哪些生产容器是从易受攻击的镜像运行的，哪些是从修复的镜像运行的？两个镜像都具有相同的标签！
- en: This is where *image digests* come to the rescue.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*镜像摘要*发挥作用的地方。
- en: Docker 1.10 introduced a new content addressable storage model. As part of this
    new model, all images now get a cryptographic content hash. For the purposes of
    this discussion, we’ll refer to this hash as the *digest*. Because the digest
    is a hash of the contents of the image, it is not possible to change the contents
    of the image without the digest also changing. This means digests are immutable.
    This helps avoid the problem we just talked about.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 1.10引入了一种新的内容可寻址存储模型。作为这种新模型的一部分，现在所有镜像都会获得一个加密的内容哈希。在本讨论中，我们将把这个哈希称为*摘要*。因为摘要是镜像内容的哈希，所以不可能更改镜像的内容而不更改摘要。这意味着摘要是不可变的。这有助于避免我们刚刚谈到的问题。
- en: Every time you pull an image, the `docker image pull` command will include the
    image’s digest as part of the return code. You can also view the digests of images
    in your Docker host’s local repository by adding the `--digests` flag to the `docker
    image ls` command. These are both shown in the following example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每次拉取镜像时，`docker image pull`命令将包括镜像的摘要作为返回代码的一部分。您还可以通过在`docker image ls`命令中添加`--digests`标志来查看Docker主机本地存储库中镜像的摘要。这两者都在以下示例中显示。
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`The snipped output above shows the digest for the `alpine` image as -'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`上面的输出显示了`alpine`镜像的摘要为 -'
- en: '`sha256:3dcdb92d7432d56604d...6d99b889d0626de158f73a`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`sha256:3dcdb92d7432d56604d...6d99b889d0626de158f73a`'
- en: Now that we know the digest of the image, we can use it when pulling the image
    again. This will ensure that we get **exactly the image we expect!**
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道镜像的摘要，我们可以在再次拉取镜像时使用它。这将确保我们得到**完全符合我们期望的镜像！**
- en: At the time of writing, there is no native Docker command that will retrieve
    the digest of an image from a remote registry such as Docker Hub. This means the
    only way to determine the digest of an image is to pull it by tag and then make
    a note of its digest. This will no doubt change in the future.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，没有原生的Docker命令可以从Docker Hub等远程注册表中检索镜像的摘要。这意味着确定镜像的摘要的唯一方法是按标签拉取它，然后记下其摘要。这无疑将在未来发生变化。
- en: The following example deletes the `alpine:latest` image from your Docker host
    and then shows how to pull it again using its digest instead of its tag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例从Docker主机中删除`alpine:latest`镜像，然后演示如何使用其摘要而不是标签再次拉取它。
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`#### A little bit more about image hashes (digests)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 关于镜像哈希（摘要）的更多信息'
- en: Since Docker version 1.10, an image is a very loose collection of independent
    layers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker版本1.10以来，镜像是一个非常松散的独立层集合。
- en: The *image* itself is really just a configuration object that lists the layers
    and some metadata.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*镜像*本身实际上只是一个列出层和一些元数据的配置对象。'
- en: The *layers* are where the data lives (files etc.). Each one is fully independent,
    and has no concept of being part of a collective image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*层*是数据所在的地方（文件等）。每个层都是完全独立的，没有成为集体镜像的概念。'
- en: Each image is identified by a crypto ID that is a hash of the config object.
    Each layer is identified by a crypto ID that is a hash of the content it contains.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像由一个加密ID标识，这是配置对象的哈希值。每个图层由一个加密ID标识，这是其包含内容的哈希值。
- en: This means that changing the contents of the image, or any of its layers, will
    cause the associated crypto hashes to change. As a result, images and layers are
    immutable, and we can easily identify any changes made to either.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着更改图像的内容或任何图层都将导致相关的加密哈希值发生变化。因此，图像和图层是不可变的，我们可以轻松地识别对它们所做的任何更改。
- en: We call these hashes **content hashes**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这些哈希值为**内容哈希值**。
- en: So far, things are pretty simple. But they’re about to get a bit more complicated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情还相当简单。但它们即将变得更加复杂。
- en: When we push and pull images, we compress their layers to save bandwidth, as
    well as space in the Registry’s blob store.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推送和拉取图像时，我们会压缩它们的图层以节省带宽，以及注册表的blob存储空间。
- en: Cool, but compressing a layer changes its content! This means that its content
    hash will no longer match after the push or pull operation! This is obviously
    a problem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，但压缩图层会改变其内容！这意味着在推送或拉取操作后，其内容哈希将不再匹配！这显然是一个问题。
- en: For example, when you push an image layer to Docker Hub, Docker Hub will attempt
    to verify that the image arrived without being tampered with en-route. To do this,
    it runs a hash against the layer and checks to see if it matches the hash that
    was sent. Because the layer was compressed (changed) the hash verification will
    fail.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你将图像图层推送到Docker Hub时，Docker Hub将尝试验证图像是否在传输过程中未被篡改。为了做到这一点，它会对图层运行一个哈希，并检查是否与发送的哈希匹配。因为图层被压缩（改变）了，哈希验证将失败。
- en: To get around this, each layer also gets something called a *distribution hash*.
    This is a hash of the compressed version of the layer. When a layer is pushed
    and pulled from the registry, its distribution hash is included, and this is what
    is used to verify that the layer arrived without being tampered with.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，每个图层还会得到一个叫做*分发哈希*的东西。这是对图层压缩版本的哈希。当图层从注册表中推送和拉取时，它的分发哈希被包括在内，这就是用来验证图层是否在传输过程中被篡改的方法。
- en: This content-addressable storage model vastly improves security by giving us
    a way to verify image and layer data after push and pull operations. It also avoids
    ID collisions that could occur if image and layer IDs were randomly generated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内容寻址存储模型通过在推送和拉取操作后提供一种验证图像和图层数据的方式，大大提高了安全性。它还避免了如果图像和图层ID是随机生成的可能发生的ID冲突。
- en: Multi-architecture images
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多架构图像
- en: One of the best things about Docker is how simple it is to use. For example,
    running an application is as simple as pulling the image and running a container.
    No need to worry about setup, dependencies, or config. It just works.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Docker最好的一点是它的简单易用。例如，运行一个应用程序就像拉取图像并运行一个容器一样简单。不需要担心设置、依赖项或配置。它就能运行。
- en: However, as Docker grew, things started getting complex — especially when new
    platforms and architectures, such as Windows, ARM, and s390x were added. All of
    a sudden we have to think about whether the image we’re pulling is built for the
    architecture we’re running on. This breaks the smooth experience.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Docker的发展，事情开始变得复杂 - 尤其是当新的平台和架构，如Windows、ARM和s390x被添加进来时。突然间，我们不得不考虑我们正在拉取的图像是否是为我们正在运行的架构构建的。这破坏了流畅的体验。
- en: Multi-architecture images to the rescue!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 多架构图像来拯救！
- en: Docker (image and registry specs) now supports multi-architecture images. This
    means a single image (`repository:tag`) *can* have an image for Linux on x64,
    Linux on PowerPC, Windows x64, ARM etc. Let me be clear, we’re talking about a
    single image tag supporting multiple platforms and architectures. We’ll see it
    in action in a second.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（镜像和注册表规范）现在支持多架构镜像。这意味着单个镜像（`repository:tag`）*可以*在x64架构的Linux上，PowerPC架构的Linux上，Windows
    x64上，ARM等上都有镜像。让我明确一点，我们说的是一个单一镜像标签支持多个平台和架构。我们马上就会看到它的实际应用。
- en: 'To make this happen, the Registry API supports two important constructs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，注册表API支持两个重要的构造：
- en: '**manifest lists** (new)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单列表（新）
- en: '**manifests**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**'
- en: 'The **manifest list** is exactly what it sounds like: a list of architectures
    supported by a particular image tag. Each supported architecture then has its
    own **manifest* detailing the layers it’s composed from.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: “清单列表”就是它听起来的样子：一个特定镜像标签支持的架构列表。然后，每个支持的架构都有自己的**清单**，详细说明了它由哪些层组成。
- en: Figure 6.9 uses the official `golang` image as an example. On the left is the
    **manifest list** with entries for each architecture the image supports. The arrows
    show that each entry in the **manifest list** points to a **manifest** containing
    image config and layer data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9以官方的`golang`镜像为例。左边是**清单列表**，列出了镜像支持的每种架构。箭头显示，**清单列表**中的每个条目指向一个包含镜像配置和层数据的**清单**。
- en: '![Figure 6.9](images/figure6-9.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9](images/figure6-9.png)'
- en: Figure 6.9
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9
- en: Let’s look at the theory before seeing it in action.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实际操作之前先看看理论。
- en: Assume you are running Docker on a Raspberry Pi (Linux running on ARM architecture).
    When you pull an image, your Docker client makes the relevant calls to the Docker
    Registry API running on Docker Hub. If a **manifest list** exists for the image,
    it will be parsed to see if an entry exists for Linux on ARM. If an ARM entry
    exists, the **manifest** for that image is retrieved and parsed for the crypto
    ID’s of the layers that make up the image. Each layer is then pulled from Docker
    Hub’s blob store.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在树莓派上运行Docker（在ARM架构上运行的Linux）。当你拉取一个镜像时，你的Docker客户端会对运行在Docker Hub上的Docker
    Registry API进行相关调用。如果镜像存在**清单列表**，则会解析它以查看是否存在ARM架构的Linux的条目。如果存在ARM条目，则会检索该镜像的**清单**并解析出构成镜像的层的加密ID。然后，每个层都会从Docker
    Hub的blob存储中拉取。
- en: The following examples show how this works by pulling the official `golang`
    image (which supports multiple architectures) and running a simple command to
    show the version of Go along with the CPU architecture of the host. The thing
    to note, is that both examples use the exact same `docker container run` command.
    We do not have to tell Docker that we need the Linux x64 or Windows x64 versions
    of the image. We just run normal commands and let Docker take care of getting
    the right image for the platform and architecture we are running!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了拉取官方的`golang`镜像（支持多种架构）并运行一个简单命令来显示Go的版本以及主机的CPU架构。需要注意的是，这两个示例使用了完全相同的`docker
    container run`命令。我们不需要告诉Docker我们需要Linux x64或Windows x64版本的镜像。我们只需运行普通命令，让Docker负责获取适合我们正在运行的平台和架构的正确镜像！
- en: 'Linux on x64 example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Linux x64示例：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Windows on x64 example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Windows x64示例：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`The previous operations pull the `golang` image from Docker Hub, start a container
    from it, execute the `go version` command, and output the version of Go and the
    OS/CPU architecture of the host system. The last line of each example shows the
    output of each `go version` command. See that both examples used exactly the same
    command, but the Linux example pulled the `linux/amd64` image, and the Windows
    example pulled the `windows/amd64` image.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`前面的操作从Docker Hub拉取`golang`图像，从中启动一个容器，执行`go version`命令，并输出主机系统的Go和OS/CPU架构的版本。每个示例的最后一行显示了每个`go
    version`命令的输出。请注意，这两个示例使用完全相同的命令，但Linux示例拉取了`linux/amd64`图像，而Windows示例拉取了`windows/amd64`图像。'
- en: At the time of writing, all *official images* have manifest lists. However,
    support for all architectures is an ongoing process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，所有*官方图像*都有清单列表。但是，支持所有架构是一个持续的过程。
- en: Creating images that run on multiple architectures requires additional effort
    from the image publisher. Also, some software is not cross-platform. With this
    in mind, **manifest lists** are optional — if one doesn’t exist for an image,
    the Registry will return the normal **manifest**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建在多个架构上运行的图像需要图像发布者额外的工作。此外，一些软件不是跨平台的。考虑到这一点，**清单列表**是可选的 - 如果图像不存在清单列表，注册表将返回正常的**清单**。
- en: Deleting Images
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除图像
- en: When you no longer need an image, you can delete it from your Docker host with
    the `docker image rm` command. `rm` is short for remove.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不再需要图像时，可以使用`docker image rm`命令从Docker主机中删除它。`rm`是删除的缩写。
- en: Deleting an image will remove the image and all of its layers from your Docker
    host. This means it will no longer show up in `docker image ls` commands, and
    all directories on the Docker host containing the layer data will be deleted.
    However, if an image layer is shared by more than one image, that layer will not
    be deleted until all images that reference it have been deleted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 删除图像将从Docker主机中删除图像及其所有层。这意味着它将不再显示在`docker image ls`命令中，并且包含层数据的Docker主机上的所有目录都将被删除。但是，如果一个图像层被多个图像共享，直到引用它的所有图像都被删除之前，该层将不会被删除。
- en: Delete the images pulled in the previous steps with the `docker image rm` command.
    The following example deletes an image by its ID, this might be different on your
    system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker image rm`命令删除在上一步中拉取的图像。以下示例通过其ID删除图像，这可能与您的系统不同。
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`If the image you are trying to delete is in use by a running container you
    will not be able to delete it. Stop and delete any containers before trying the
    delete operation again.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`如果您要删除的图像正在运行的容器中使用，则无法删除它。在尝试再次删除操作之前，请停止并删除任何容器。'
- en: A handy shortcut for **deleting all images** on a Docker host is to run the
    `docker image rm` command and pass it a list of all image IDs on the system by
    calling `docker image ls` with the `-q` flag. This is shown next.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker主机上**删除所有图像**的一个方便的快捷方式是运行`docker image rm`命令，并通过调用带有`-q`标志的`docker image
    ls`传递系统上所有图像ID的列表。如下所示。
- en: If you are performing the following command on a Windows system, it will only
    work in a PowerShell terminal. It will not work on a CMD prompt.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows系统上执行以下命令，它只能在PowerShell终端中工作。它在CMD提示符上不起作用。
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`To understand how this works, download a couple of images and then run `docker
    image ls -q`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`要了解这是如何工作的，请下载一些图像，然后运行`docker image ls -q`。'
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`See how `docker image ls -q` returns a list containing just the image IDs
    of all images pulled locally on the system. Passing this list to `docker image
    rm` will delete all images on the system as shown next.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`看看`docker image ls -q`如何返回一个只包含系统上本地拉取的所有图像的图像ID的列表。将此列表传递给`docker image rm`将删除系统上的所有图像，如下所示。'
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Let’s remind ourselves of the major commands we use to work with Docker images.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`让我们提醒自己我们用来处理Docker图像的主要命令。`'
- en: Images - The commands
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像 - 命令
- en: '`docker image pull` is the command to download images. We pull images from
    repositories inside of remote registries. By default, images will be pulled from
    repositories on Docker Hub. This command will pull the image tagged as `latest`
    from the `alpine` repository on Docker Hub `docker image pull alpine:latest`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image pull` 是下载镜像的命令。我们从远程仓库中的存储库中拉取镜像。默认情况下，镜像将从Docker Hub上的存储库中拉取。这个命令将从Docker
    Hub上的 `alpine` 存储库中拉取标记为 `latest` 的镜像 `docker image pull alpine:latest`。'
- en: '`docker image ls` lists all of the images stored in your Docker host’s local
    cache. To see the SHA256 digests of images add the `--digests` flag.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image ls` 列出了存储在Docker主机本地缓存中的所有镜像。要查看镜像的SHA256摘要，请添加 `--digests` 标志。'
- en: '`docker image inspect` is a thing of beauty! It gives you all of the glorious
    details of an image — layer data and metadata.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image inspect` 是一件美妙的事情！它为你提供了镜像的所有细节 — 层数据和元数据。'
- en: '`docker image rm` is the command to delete images. This command shows how to
    delete the `alpine:latest` image — `docker image rm alpine:latest`. You cannot
    delete an image that is associated with a container in the running (Up) or stopped
    (Exited) states.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image rm` 是删除镜像的命令。这个命令展示了如何删除 `alpine:latest` 镜像 — `docker image rm
    alpine:latest`。你不能删除与正在运行（Up）或停止（Exited）状态的容器相关联的镜像。'
- en: Chapter summary
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we learned about Docker images. We learned that they are like
    virtual machine templates and are used to start containers. Under the hood they
    are made up one or more read-only layers, that when stacked together, make up
    the overall image.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Docker镜像。我们了解到它们就像虚拟机模板，用于启动容器。在底层，它们由一个或多个只读层组成，当堆叠在一起时，构成了整个镜像。
- en: We used the `docker image pull` command to pull some images into our Docker
    host’s local registry.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `docker image pull` 命令将一些镜像拉取到我们的Docker主机本地注册表中。
- en: We covered image naming, official and unofficial repos, layering, sharing, and
    crypto IDs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了镜像命名、官方和非官方仓库、分层、共享和加密ID。
- en: We looked at how Docker supports multi-architecture and multi-platform images,
    and we finished off by looking at some of the most common commands used to work
    with images.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一下Docker如何支持多架构和多平台镜像，最后看了一些用于处理镜像的最常用命令。
- en: In the next chapter we’ll take a similar tour of containers — the runtime cousin
    of images.[PRE34]`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将对容器进行类似的介绍 — 镜像的运行时表亲。
