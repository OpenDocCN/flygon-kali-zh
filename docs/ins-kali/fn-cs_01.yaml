- en: Chapter 1. Tasting Functional Style in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 在C#中品尝函数式风格
- en: Functional programming is a style of constructing the elements and structure
    of computer program which treats computations like evaluations in mathematical
    functions. Although there are some specifically designed languages for creating
    functional programming, such as Haskell or Scala, we can also use C# to accomplish
    designing functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种构建计算机程序元素和结构的风格，它将计算视为数学函数中的评估。虽然有一些专门设计的语言用于创建函数式编程，比如Haskell或Scala，但我们也可以使用C#来实现函数式编程的设计。
- en: 'In the first chapter of this book, we are going to explore the functional programming
    by testing it. We will use the power of C# to construct some functional code.
    We will also deal with the features in C# that are mostly used in developing functional
    programs. By the end of this chapter, we will have an idea of what the functional
    approach in C# will be like. Here are the topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们将通过测试来探索函数式编程。我们将利用C#的功能来构建一些函数式代码。我们还将处理在开发函数式程序中经常使用的C#中的特性。在本章结束时，我们将对C#中的函数式方法有一个概念。以下是本章我们将涵盖的主题：
- en: Introduction to functional programming concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程概念介绍
- en: Comparison between the functional and imperative approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式和命令式方法的比较
- en: The concepts of functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的概念
- en: Using the mathematical approach to understand functional programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数学方法理解函数式编程
- en: Refactoring imperative code to functional code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令式代码重构为函数式代码
- en: The advantages and disadvantages of functional programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的优缺点
- en: Introducing functional programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数式编程
- en: In functional programming, we write functions without side effects the way we
    write in Mathematics. The variable in the code function represents the value of
    the function parameter, and it similar to the mathematical function. The idea
    is that a programmer defines the functions that contain the expression, definition,
    and the parameters that can be expressed by a variable in order to solve problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们像在数学中写函数一样写函数，没有副作用。代码函数中的变量表示函数参数的值，它类似于数学函数。这个想法是程序员定义包含表达式、定义和可以用变量表示的参数的函数，以解决问题。
- en: After a programmer builds the function and sends the function to the computer,
    it's the computer's turn to do its job. In general, the role of the computer is
    to evaluate the expression in the function and return the result. We can imagine
    that the computer acts like a calculator since it will analyze the expression
    from the function and yield the result to the user in a printed format. The calculator
    will evaluate a function which are composed of variables passed as parameters
    and expressions which form the body of the function. Variables are substituted
    by their values in the expression. We can give simple expression and compound
    expressions using algebraic operators. Since expressions without assignments never
    alter the value, sub expressions needs to be evaluated only once.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员构建函数并将函数发送到计算机后，就轮到计算机发挥作用了。一般来说，计算机的作用是评估函数中的表达式并返回结果。我们可以想象计算机就像一个计算器，因为它会分析函数中的表达式并以打印格式将结果返回给用户。计算器将评估由作为参数传递的变量和构成函数主体的表达式组成的函数。变量在表达式中被其值替换。我们可以使用代数运算符给出简单表达式和复合表达式。由于没有赋值的表达式永远不会改变值，子表达式只需要评估一次。
- en: Suppose we have the expression `3 + 5` inside a function. The computer will
    definitely return `8` as the result right after it completely evaluates it. However,
    this is just a simple example of how the computer acts in evaluating an expression.
    In fact, a programmer can increase the ability of the computer by creating a complex
    definition and expression inside the function. Not only can the computer evaluate
    the simple expression, but it can also evaluate the complex calculation and expression.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一个函数中有表达式`3 + 5`。计算机在完全评估完它之后肯定会返回`8`作为结果。然而，这只是计算机在评估表达式时的简单示例。事实上，程序员可以通过在函数内创建复杂的定义和表达式来增强计算机的能力。计算机不仅可以评估简单的表达式，还可以评估复杂的计算和表达式。
- en: Understanding definitions, scripts, and sessions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解定义、脚本和会话
- en: 'As we discussed earlier about a calculator that will analyze the expression
    from the function, let''s imagine we have a calculator that has a console panel
    like a computer does. The difference between that and a conventional calculator
    is that we have to press ***Enter*** instead of ***=*** (equal to) in order to
    run the evaluation process of the expression. Here, we can type the expression
    and then press ***Enter*** . Now, imagine that we type the following expression:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的关于计算器会分析函数中的表达式，让我们想象一下我们有一个计算器，它有一个像计算机一样的控制台面板。与传统计算器的区别在于，我们必须按下***Enter***键而不是***=***（等于号）来运行表达式的评估过程。在这里，我们可以输入表达式，然后按下***Enter***。现在，想象一下我们输入以下表达式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Immediately after pressing ***Enter*** , the computer will print `27` in the
    console, and that''s what we are expecting. The computer has done a great job
    of evaluating the expression we gave. Now, let''s move to analyzing the following
    definitions. Imagine that we type them on our functional calculator:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下***Enter***键后，计算机将在控制台中打印`27`，这正是我们期望的。计算机已经很好地评估了我们给出的表达式。现在，让我们来分析以下定义。想象一下我们在我们的函数式计算器上输入它们：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have defined the two definitions, `square` and `max` . We can call the list
    of definitions script. By calling the `square` function followed by any number
    representing variable `a` , we will be given the square of that number. Also,
    in the `max` definition, we serve two numbers to represent variables `a` and `b`
    , and then the computer will evaluate this expression to find out the biggest
    number between the variables.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两个定义，`square`和`max`。我们可以称定义列表为脚本。通过调用`square`函数，后跟代表变量`a`的任何数字，我们将得到该数字的平方。同样，在`max`定义中，我们提供两个数字来代表变量`a`和`b`，然后计算机将评估这个表达式以找出变量之间的最大数。
- en: 'By defining these two definitions, we can use them as a function, which we
    can call session, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义这两个定义，我们可以将它们用作函数，我们可以称之为会话，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The computer will definitely print `9` after evaluating the preceding function.
    The computer will also be able to evaluate the following function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在评估前述函数后肯定会打印`9`。计算机还能够评估以下函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will return `2` as the result based on the definition we defined earlier.
    This is also possible if we provide the following expression:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前定义的定义，它将返回`2`作为结果。如果我们提供以下表达式，这也是可能的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, `25` will be displayed in our calculator console panel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的计算器控制台面板上将显示`25`。
- en: 'We can also modify a definition using the previous definition. Suppose we want
    to quadruple an integer number and take advantage of the definition of the `square`
    function; here is what we can send to our calculator:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用先前的定义修改定义。假设我们想要对整数进行四倍化，并利用`square`函数的定义；这是我们可以发送给计算器的内容：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line of the preceding expression is a definition of the `quad` function.
    In the second line, we call that function, and we will be provided with `10000`
    as the result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前述表达式的第一行是`quad`函数的定义。在第二行，我们调用该函数，我们将得到`10000`作为结果。
- en: 'The script can define the variable value; for instance, take a look at the
    following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以定义变量值；例如，看一下以下内容：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, we should expect the computer to be able to evaluate the following definition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该期望计算机能够评估以下定义：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using substitution and simplification to evaluate the expression
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用替换和简化来评估表达式
- en: 'Using a mathematical method called **reduction** , we can evaluate expressions
    by substitution variables or expressions to simplify the expressions until no
    more substitution on reduction is possible. Let''s take our preceding expression,
    `square (1 + 2)` , and look at the following reduction process:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种称为**规约**的数学方法，我们可以通过替换变量或表达式来简化表达式，直到不能再进行规约为止。让我们看看我们前面的表达式`square (1 +
    2)`，并看看以下规约过程：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we have the symbol `->` to indicate the reduction. From the sequence,
    we can discover the reduction process-in other words, the evaluation process.
    In the first line, the computer will run the `1 + 2` expression and substitute
    it with `3` in order to reduce the expression. Then, it will reduce the expression
    in the second line by simplifying `square 3` to `3 x 3` expressions. Lastly, it
    will simplify `3 x 3` and substitute it with `9` , which is the result of that
    expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有符号`->`来表示规约。从这个序列中，我们可以发现规约过程-换句话说，评估过程。在第一行，计算机将运行`1 + 2`表达式，并用`3`替换它以减少表达式。然后，它将通过简化`square
    3`为`3 x 3`表达式来减少第二行的表达式。最后，它将简化`3 x 3`并用`9`替换它，这是该表达式的结果。
- en: 'Actually, an expression can have more than one possibility in the reduction.
    The preceding reduction process is one of the possibilities of a reduction process.
    We can also create other possibilities, like the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个表达式在规约中可能有多种可能性。前面的规约过程是规约过程的一种可能性。我们还可以创建其他可能性，比如以下内容：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding sequence, firstly, we can see that the rule for a square is
    applied. The computer then substitutes `1 + 2` in line 2 and line 3\. Lastly,
    it multiplies the number in the expression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的序列中，首先可以看到正方形的规则被应用。然后，计算机在第2行和第3行中替换`1 + 2`。最后，它将乘以表达式中的数字。
- en: From the preceding two examples, we can conclude that the expression can be
    evaluated using simple substitution and simplification, the basic rule of mathematics.
    We can also see that the expression is a representation of the value, not the
    value itself. However, the expression will be in the normal form if it can't be
    reduced anymore.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的两个例子中，我们可以得出结论，表达式可以使用简单的替换和简化来进行评估，这是数学的基本规则。我们还可以看到，表达式是值的表示，而不是值本身。但是，如果表达式不能再被规约，它将处于正常形式。
- en: Understanding the functions used for functional programming
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解函数式编程中使用的函数
- en: 'Functional programming uses a technique of emphasizing functions and their
    application instead of commands and their execution. Most values in functional
    programming are function values. Let''s take a look at the following mathematical
    notation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程使用一种强调函数及其应用而不是命令及其执行的技术。函数式编程中的大多数值都是函数值。让我们看一下以下数学符号：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding notation, we can say that function `f` is a relation of each
    element stated there, which is `A` and `B` . We call `A` , the source type, and
    `B` , the target type. In other words, the notation of `A -> B` states that `A`
    is an argument where we have to input the value, and `B` is a return value or
    the output of the function evaluation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述符号中，我们可以说函数`f`是其中列出的每个元素的关系，即`A`和`B`。我们称`A`为源类型，`B`为目标类型。换句话说，`A -> B`的符号表示`A`是一个参数，我们必须输入值，而`B`是返回值或函数评估的输出。
- en: 'Consider that `x` denotes an element of `A` and `x + 2` denotes an element
    of `B` , so we can create the mathematical notation as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`x`表示`A`的一个元素，`x + 2`表示`B`的一个元素，因此我们可以创建以下数学符号：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In mathematics, we use `f(x)` to denote a functional application. In functional
    programming, the function will be passed as an argument and will return the result
    after the evaluation of the expression.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，我们使用 `f(x)` 来表示函数的应用。在函数式编程中，函数将作为参数传递，并在表达式评估后返回结果。
- en: 'We can construct many definitions for one and the same function. The following
    two definitions are similar and will triple the input passed as an argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为同一个函数构造许多定义。以下两个定义类似，都会将作为参数传递的输入值乘以三：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, `triple` and `triple'` have different expressions. However, they
    are the same functions, so we can say that `triple` = `triple'` . Although we
    have many definitions to express one function, we will find that there is only
    one definition that will prove to be the most efficient in the procedure of evaluation
    in the sense of the reducing the expression we discussed previously. Unfortunately,
    we cannot determine which one is the most efficient from our preceding two definitions
    since that depends on the characteristic of the evaluation mechanism.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`triple` 和 `triple'` 有不同的表达式。然而，它们是相同的函数，所以我们可以说 `triple` = `triple'`。尽管我们有许多定义来表达一个函数，但我们会发现，在评估过程中只有一个定义是最有效的，因为它能够在我们之前讨论的表达式简化过程中证明。不幸的是，我们无法确定哪一个是最有效的，因为这取决于评估机制的特性。
- en: Forming the definition
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形成定义
- en: 'Now, let''s go back to our discussion on definitions at the beginning of this
    chapter. We have the following definition in order to retrieve the value from
    the case analysis:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到本章开头关于定义的讨论。我们有以下定义，以便从案例分析中检索值：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are two expressions in this definition, distinguished by a Boolean-value
    expression. This distinguisher is called guards, and we use them to evaluate the
    value of `True` or `False` . The first line is one of the alternative result values
    for this function. It states that the return value will be `a` if the expression
    `a >= b` is `True` . In contrast, the function will return value `b` if the expression
    `b >= a` is `True` . Using these two cases, `a >= b` and `b >= a` , the `max`
    value depends on the value of `a` and `b` . The order of the cases doesn''t matter.
    We can also define the `max` function using the special word `otherwise` . This
    word ensures that the otherwise case will be executed if no expression results
    in a True value. Here, we will refactor our max function using the word `otherwise`
    :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中有两个表达式，由布尔值表达式区分。这个区分器称为保护，并且我们使用它们来评估 `True` 或 `False` 的值。第一行是这个函数的另一个结果值。它说明，如果表达式
    `a >= b` 是 `True`，则返回值将是 `a`。相反，如果表达式 `b >= a` 是 `True`，则函数将返回值 `b`。使用这两种情况，`a
    >= b` 和 `b >= a`，`max` 值取决于 `a` 和 `b` 的值。案例的顺序并不重要。我们还可以使用特殊词 `otherwise` 来定义
    `max` 函数。这个词确保如果没有表达式结果为 True 值，否则情况将被执行。在这里，我们将使用 `otherwise` 重新构造我们的 max 函数：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the preceding function definition, we can see that if the first expression
    is `False` , the function will return `b` immediately without performing any evaluation.
    In other words, the otherwise case will always return `True` if all previous guards
    return `False` .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的函数定义中，我们可以看到，如果第一个表达式是 `False`，函数将立即返回 `b`，而不执行任何评估。换句话说，否则情况将始终返回 `True`，如果所有先前的保护都返回
    `False`。
- en: 'Another special word usually used in mathematical notations is `where` . This
    word is used to set the local definition for the expression of the function. Let''s
    take a look at the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数学符号中通常使用的另一个特殊词是 `where`。这个词用于为函数的表达式设置局部定义。让我们看看以下例子：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we have a function `f` with variable `z` , whose
    value is determined by `x` and `y` . There, we introduce a local `z` definition
    to the function. This local definition can also be used along with the case analysis
    we have discussed earlier. Here is an example of the conjunction local definition
    with the case analysis:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个带有变量 `z` 的函数 `f`，其值由 `x` 和 `y` 确定。在那里，我们引入了一个局部 `z` 定义到函数中。这个局部定义也可以与我们之前讨论过的案例分析一起使用。以下是一个带有案例分析的连接局部定义的例子：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding function, there is a local `z` definition, which qualifies
    for both `x + z` and `x - z` expressions. As we discussed earlier, although the
    function has two equal to (`=` ) signs, only one expression will return the value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，有一个局部 `z` 定义，适用于 `x + z` 和 `x - z` 表达式。正如我们之前讨论的，尽管函数有两个等于 (`=`) 符号，只有一个表达式会返回值。
- en: Currying
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Currying is a simple technique of changing structure arguments by sequence.
    It will transform a n-ary function into n unary function. It is a technique which
    was created to circumvent limitations of Lambda functions which are unary functions.
    Let''s go back to our max function again and get the following definition:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一种简单的技术，通过顺序改变结构参数。它将把一个 n 元函数转换为 n 个一元函数。这是一种旨在规避 Lambda 函数限制的技术，Lambda
    函数是一元函数。让我们再回到我们的 max 函数，并得到以下定义：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see that there is no bracket in the `max a b` function name. Also, there
    is no comma-separated `a` and `b` in the function name. We can add a bracket and
    a comma to the function definition, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `max a b` 函数名中没有括号。函数名中也没有逗号分隔的 `a` 和 `b`。我们可以向函数定义中添加括号和逗号，如下所示：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At first glance, we find the two functions to be the same since they have the
    same expression. However, they are different because of their different types.
    The `max''` function has a single argument, which consists of a pair of numbers.
    The type of `max''` function can be written as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们发现这两个函数是相同的，因为它们有相同的表达式。然而，它们是不同的，因为它们有不同的类型。`max'` 函数有一个参数，由一对数字组成。`max'`
    函数的类型可以写成如下形式：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the other hand, the `max` function has two arguments. The type of this function
    can be written as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`max` 函数有两个参数。这个函数的类型可以写成如下形式：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The max function will take a number and then return a function from single number
    to many numbers. From the preceding max function, we pass the variable `a` to
    the `max` function, which returns a value. Then, that value is compared to variable
    `b` in order to find the maximum number.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: max函数将接受一个数字，然后返回一个从单个数字到多个数字的函数。从前面的max函数中，我们将变量`a`传递给`max`函数，它返回一个值。然后，将该值与变量`b`进行比较，以找到最大的数字。
- en: Comparison between functional and imperative programming
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程和命令式编程的比较
- en: The main difference between functional and imperative programming is that imperative
    programming produces side effects while functional programming doesn't. In imperative
    programming, the expressions are evaluated and its resulting value is assigned
    to variables. So, when we group series of expressions into a function, the resulting
    value depends upon the state of variables at that point in time. This is called
    side effects. Because of the continuous changes in state, the order of evaluation
    matters. In functional programming world, destructive assignment is forbidden
    and each time an assignment happens a new variable is induced.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程和命令式编程的主要区别在于，命令式编程会产生副作用，而函数式编程不会。在命令式编程中，表达式被评估并且其结果值被赋给变量。因此，当我们将一系列表达式分组到一个函数中时，结果值取决于那个时间点变量的状态。这就是副作用。由于状态不断变化，评估的顺序很重要。在函数式编程世界中，破坏性赋值是被禁止的，每次赋值发生时都会引入一个新变量。
- en: Preparing the C# compiler
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备C#编译器
- en: For the rest of the discussion in this chapter, we are going to create some
    code in C#. In order we have the same environment, let's define what we will use
    in configuration settings. We will use Visual Studio 2015 Community Edition and
    .NET Framework 4.6.2 in all of the source code we discuss in this book. We will
    also choose the console application project in order to ease the development of
    our code since it doesn't need many changes to the settings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论中，我们将使用C#创建一些代码。为了保持相同的环境，让我们定义一下我们将在配置设置中使用的内容。我们将在本书中讨论的所有源代码中使用Visual
    Studio 2015 Community Edition和.NET Framework 4.6.2。我们还将选择控制台应用程序项目，以便简化我们的代码开发，因为它不需要太多的设置更改。
- en: 'Here is the screenshot of the setting in creating Visual Studio projects we
    will use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的创建Visual Studio项目的设置的截图：
- en: '![Preparing the C# compiler](img/Image00001.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![准备C#编译器](img/Image00001.jpg)'
- en: 'When we are discussing a source code that has a `csproj` filename-for instance,
    `FuncObject.csproj` -we can find it in one of solution files provided in the sample
    code. It will be in the `Program.cs` file. The following is a screenshot of the
    structure of the project in Visual Studio:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论一个以`csproj`为文件名的源代码时，比如`FuncObject.csproj`，我们可以在示例代码提供的解决方案文件中找到它。它将在`Program.cs`文件中。以下是在Visual
    Studio中项目结构的截图：
- en: '![Preparing the C# compiler](img/Image00002.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![准备C#编译器](img/Image00002.jpg)'
- en: 'However, sometimes, we have more than one `.cs` file inside the project file.
    In this case, we can find the code we are discussing in one of the `.cs` files
    inside the project file. For instance, we have a project file named `FunctionalCode.csproj`
    . So, when we discuss any source code related to this project file, we can find
    it from the `.cs` files inside the project file. The structure of a project file
    consisting of more than one `.cs` files is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时在项目文件中有多个`.cs`文件。在这种情况下，我们可以在项目文件中的一个`.cs`文件中找到我们正在讨论的代码。例如，我们有一个名为`FunctionalCode.csproj`的项目文件。因此，当我们讨论与此项目文件相关的任何源代码时，我们可以从项目文件中的`.cs`文件中找到它。包含多个`.cs`文件的项目文件的结构如下：
- en: '![Preparing the C# compiler](img/Image00003.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备C#编译器](img/Image00003.jpg)'
- en: As we can see, inside the `FunctionalCode.csproj` file, not only do we have
    the `Program.cs` file, but also `Disposable.cs` , `FunctionalExtension.cs` , `StringBuilderExtension.cs`
    , and `Utility.cs` .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在`FunctionalCode.csproj`文件中，我们不仅有`Program.cs`文件，还有`Disposable.cs`，`FunctionalExtension.cs`，`StringBuilderExtension.cs`和`Utility.cs`。
- en: We will also find the `partial` keyword to the classes name in most of our code
    even though we write the classes in the same file. The purpose is to make the
    code snippet in this book easy to find in the sample code. By knowing the class
    name, it will be easier to find the source code in the file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会在大部分代码的类名中找到`partial`关键字，即使我们将类写在同一个文件中。目的是为了使本书中的代码片段在示例代码中更容易找到。通过知道类名，可以更容易地在文件中找到源代码。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We also need to install Visual Studio Community 2017 RC since we will use a
    new feature of C# 7 in [Chapter 9](text00057.html#ch09 "Chapter 9. Working with
    Pattern") , *Working with Pattern* .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装Visual Studio Community 2017 RC，因为我们将在[第9章](text00057.html#ch09 "第9章。使用模式")中使用C#
    7的新功能，*使用模式*。
- en: Concepts of functional programming
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的概念
- en: We can also distinguish functional programming from imperative programming by
    the concepts. The core ideas of functional programming are encapsulated in the
    constructs such as first class functions, higher order functions, purity, recursion
    over loops, and partial functions. We will discuss the concepts in this topic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过概念来区分函数式编程和命令式编程。函数式编程的核心思想被封装在构造中，比如一等函数、高阶函数、纯度、递归而不是循环以及部分函数。我们将在这个主题中讨论这些概念。
- en: First-class and higher-order functions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等函数和高阶函数
- en: In imperative programming, the given data is more important and are passed through
    series of functions (with side effects). Functions are special constructs with
    their own semantics. In effect, functions do not have the same place as variables
    and constants. Since a function cannot be passed as a parameter or returned as
    a result, they are regarded as second class citizens of the programming world.
    In the functional programming world, we can pass a function as a parameter and
    return function as a result. They obey the same semantics as variables and their
    values. Thus, they are first class citizens. We can also create function of functions
    called second order function through composition. There is no limit imposed on
    the composability of functions and they are called higher order functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，给定的数据更重要，并且通过一系列函数（带有副作用）传递。函数是具有自己语义的特殊构造。实际上，函数与变量和常量的地位不同。由于函数不能作为参数传递或作为结果返回，它们被视为编程世界的二等公民。在函数式编程世界中，我们可以将函数作为参数传递并将函数作为结果返回。它们遵守与变量及其值相同的语义。因此，它们是一等公民。我们还可以通过组合创建函数的函数，称为二阶函数。对函数的组合性没有限制，它们被称为高阶函数。
- en: 'Fortunately, the C# language supports these two concepts since it has a feature
    called function object, which has types and values. To discuss more details about
    the function object, let''s take a look at the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#语言支持这两个概念，因为它具有称为函数对象的功能，它具有类型和值。要讨论有关函数对象的更多细节，请看以下代码：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can find the code in `FuncObject.csproj` , and if we run it, it will display
    the following output on the console screen:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`FuncObject.csproj`中找到代码，如果我们运行它，它将在控制台屏幕上显示以下输出：
- en: '![First-class and higher-order functions](img/Image00004.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![一等和高阶函数](img/Image00004.jpg)'
- en: Why do we display it? Let's continue the discussion on function types and function
    values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要显示它？让我们继续讨论函数类型和函数值。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Hit ***Ctrl*** + ***F5*** instead of ***F5*** in order to run the code in debug
    mode but without the debugger. It's useful to stop the console from closing on
    the exit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按下***Ctrl*** + ***F5***而不是***F5***以在调试模式下运行代码但不使用调试器。这对于阻止控制台在退出时关闭很有用。
- en: Function types
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'As with other objects in C#, function objects have a type as well. We can initialize
    the types in the function declaration. Here is the syntax to declare function
    objects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#中的其他对象一样，函数对象也有类型。我们可以在函数声明中初始化类型。以下是声明函数对象的语法：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that we have `T1` until `T16` , which are the types that correspond to
    input parameters, and `TResult` is a type that corresponds to the return type.
    If we need to convert our previous mathematical function, `f(x) = x + 2` , we
    can write it as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有`T1`到`T16`，它们是对应输入参数的类型，`TResult`是对应返回类型的类型。如果我们需要转换我们之前的数学函数，`f(x) =
    x + 2`，我们可以将其写成如下形式：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now have a function `f` , which has one argument-typed integer and the integer
    return type as well. Here, we use a lambda expression to define a delegate to
    be assigned to the object named `f` with the `Func` type. Don't worry if you are
    not familiar with delegate and lambda expressions yet. We will discuss them further
    in our next chapters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数`f`，它具有一个参数类型为整数和整数返回类型。在这里，我们使用lambda表达式定义一个委托，以赋给名为`f`的对象，其类型为`Func`。如果您对委托和lambda表达式不熟悉，不要担心。我们将在下一章中进一步讨论它们。
- en: Function values
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数值
- en: 'To assign a value to function variable, there are the following possibilities:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数变量分配一个值，有以下可能性：
- en: 'A function variable can be assigned to an existing method inside a class by
    its name using a reference. We can use delegate as reference. Let''s take a look
    at the following code snippet:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数变量可以通过引用使用类中的现有方法的名称进行分配。我们可以使用委托作为引用。让我们看一下以下代码片段：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see in the preceding code, we assign `da` variable to existing `Double()`
    method using `delegate` .
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在上面的代码中所看到的，我们使用`delegate`将`da`变量分配给现有的`Double()`方法。
- en: 'A function variable can be assigned to an anonymous function using a lambda
    expression. Let''s look at the following code snippet:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用lambda表达式将函数变量分配给匿名函数。让我们看一下以下代码片段：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, the `da` variable is assigned using lambda expression and we
    can use the `da` variable like we use in previous code snippet.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在上面的代码中所看到的，`da`变量是使用lambda表达式分配的，我们可以像在以前的代码片段中一样使用`da`变量。
- en: 'Now we have a function variable and can assign a variable-integer-typed variable,
    for instance, to this function variable, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数变量，可以将一个变量-整数类型的变量分配给这个函数变量，例如：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After executing the preceding code, the value of variable `i` will be `3` since
    we pass `1` as the argument, and it will return `1 + 2` . We can also assign the
    function variable with another function, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，变量`i`的值将为`3`，因为我们将`1`作为参数传递，它将返回`1 + 2`。我们还可以将函数变量分配给另一个函数，如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We assign a new function, `2 * x + 1` , to variable `f` , so we will retrieve
    `3` if we run the preceding code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个新函数`2 * x + 1`分配给变量`f`，因此如果我们运行上述代码，我们将得到`3`。
- en: Pure functions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'In the functional programming, most of the functions do not have side effects.
    In other words, the function doesn''t change any variables outside the function
    itself. Also, it is consistent, which means that it always returns the same value
    for the same input data. The following are example actions that will generate
    side effects in programming:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，大多数函数都没有副作用。换句话说，函数不会改变函数本身之外的任何变量。而且它是一致的，这意味着它总是为相同的输入数据返回相同的值。以下是在编程中会产生副作用的示例操作：
- en: Modifying a global variable or static variable since it will make a function
    interact with the outside world.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改全局变量或静态变量，因为这将使函数与外部世界交互。
- en: Modifying the argument in a function. This usually happens if we pass a parameter
    as a reference.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改函数中的参数。如果我们将参数作为引用传递，通常会发生这种情况。
- en: Raising an exception.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发异常。
- en: Taking input and output outside-for instance, get a keystroke from the keyboard
    or write data to the screen.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入和输出移到外部-例如，从键盘获取按键或将数据写入屏幕。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it does not satisfy the rule of a pure function, we will use many `Console.WriteLine()`
    methods in our program in order to ease our understanding in the code sample.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不满足纯函数的规则，但我们将在程序中使用许多`Console.WriteLine（）`方法，以便在代码示例中更容易理解。
- en: 'The following is the sample non-pure function that we can find in `NonPureFunction1.csproj`
    :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以在`NonPureFunction1.csproj`中找到的非纯函数示例：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run the preceding code, as expected, the following result will be displayed
    on the console:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，预期将在控制台上显示以下结果：
- en: '![Pure functions](img/Image00005.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![纯函数](img/Image00005.jpg)'
- en: In this code, we modify the `strValue` global variable inside the `AddSpace`
    function. Since it modifies the variable outside, it's not considered a pure function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们修改了`AddSpace`函数内的`strValue`全局变量。由于它修改了外部变量，因此不被视为纯函数。
- en: 'Let''s take a look at another non-pure function example in `NonPureFunction2.csproj`
    :'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`NonPureFunction2.csproj`中的另一个非纯函数示例：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We see the `AddSpace` function again but this time with the addition of an argument-typed
    `StringBuilder` argument. In the function, we modify the `sb` argument with `hyphen`
    and `str` . Since we pass the `sb` variable by reference, it also modifies the
    `sb1` variable in the `Main` function. Note that it will display the same output
    as `NonPureFunction2.csproj` .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到`AddSpace`函数，但这次添加了一个参数类型为`StringBuilder`的参数。在函数中，我们使用`hyphen`和`str`修改`sb`参数。由于我们通过引用传递了`sb`变量，它也修改了`Main`函数中的`sb1`变量。请注意，它将显示与`NonPureFunction2.csproj`相同的输出。
- en: 'To convert the preceding two examples of non-pure function code into pure function
    code, we can refactor the code to be the following. This code can be found at
    `PureFunction.csproj` :'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将前面两个非纯函数代码示例转换为纯函数代码，我们可以重构代码如下。此代码可以在`PureFunction.csproj`中找到：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running `PureFunction.csproj` , we will get the same output compared to the
    two previous non-pure function code. However, in this pure function code, we have
    three variables in the `Main` function. This is because in functional programming,
    we cannot modify the variable we have initialized earlier. In the `AddSpace` function,
    instead of modifying the global variable or argument, it now returns a string
    value to satisfy the the functional rule.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`PureFunction.csproj`，我们将获得与前两个非纯函数代码相同的输出。但是，在此纯函数代码中，`Main`函数中有三个变量。这是因为在函数式编程中，我们不能修改我们之前初始化的变量。在`AddSpace`函数中，现在不是修改全局变量或参数，而是返回一个字符串值以满足函数规则。
- en: 'The following are the advantages we will have if we implement the pure function
    in our code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码中实现纯函数，我们将获得以下优势：
- en: Our code will be easy to be read and maintain because the function does not
    depend on external state and variables. It is also designed to perform specific
    tasks that increase maintainability.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码将更易于阅读和维护，因为函数不依赖于外部状态和变量。它还旨在执行增加可维护性的特定任务。
- en: The design will be easier to be changed since it is easier to refactor.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计将更容易更改，因为重构更容易。
- en: Testing and debugging will be easier since it's quite easy to isolate the pure
    function.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试将更容易，因为很容易隔离纯函数。
- en: Recursive functions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: In an imperative programming world, we have got destructive assignments to mutate
    the state if a variable. By using loops, one can change multiple variables to
    achieve the computational objective. In the functional programming world, since
    variables cannot be destructively assigned, we need a recursive function call
    to achieve the objective of looping.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程世界中，我们有破坏性赋值来改变变量的状态。通过使用循环，可以更改多个变量以实现计算目标。在函数式编程世界中，由于变量不能被破坏性地分配，我们需要递归函数调用来实现循环的目标。
- en: 'Let''s create a factorial function. In mathematical terms, the factorial of
    the nonnegative integer `N` is the multiplication of all positive integers less
    than or equal to `N` . This is usually denoted by `N!` . We can denote the factorial
    of `7` as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个阶乘函数。在数学术语中，非负整数`N`的阶乘是小于或等于`N`的所有正整数的乘积。这通常用`N！`表示。我们可以将`7`的阶乘表示如下：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we look deeper at the preceding formula, we will discover that the pattern
    of the formula is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更深入地研究前面的公式，我们将发现公式的模式如下：
- en: '*N! = N * (N-1) * (N-2) * (N-3) * (N-4) * (N-5) ...*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: N！= N *（N-1）*（N-2）*（N-3）*（N-4）*（N-5）...
- en: 'Now, let''s take a look at the following factorial function in C#. It''s an
    imperative approach and can be found in the `RecursiveImperative.csproj` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下C#中的以下阶乘函数。这是一种命令式方法，可以在`RecursiveImperative.csproj`文件中找到：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, we invoke the `GetFactorial()` function from the `GetFactorial()`
    function itself. This is what we call a recursive function. We can use this function
    by creating a `Main()` method containing the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们从`GetFactorial（）`函数中调用`GetFactorial（）`函数本身。这就是我们所说的递归函数。我们可以通过创建包含以下代码的`Main（）`方法来使用此函数：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We invoke the `GetFactorial()` method and pass our desired number to the argument.
    The method will then multiply our number with what's returned by the `GetFactorial()`
    method, in which the argument has been subtracted by 1\. The iteration will last
    until `intNumber - 1` is equal to 0, which will return 1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`GetFactorial（）`方法并将我们想要的数字传递给参数。然后，该方法将我们的数字与`GetFactorial（）`方法返回的结果相乘，其中参数已减去1。迭代将持续到`intNumber-1`等于0，然后返回1。
- en: 'Now, let''s compare the preceding recursive function in the imperative approach
    with one in the functional approach. We will use the power of the `Aggregate`
    operator in the LINQ feature to achieve this goal. We can find the code in the
    `RecursiveFunctional.csproj` file. The code will look like what is shown in the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将命令式方法中的前面递归函数与函数式方法中的递归函数进行比较。我们将使用LINQ功能中的`Aggregate`运算符的功能来实现这个目标。我们可以在`RecursiveFunctional.csproj`文件中找到代码。代码将如下所示：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We initialize the `ints` variable, which contains a value from 1 to our desired
    integer number in the preceding code, and then we iterate `ints` using the `Aggregate`
    operator. The output of `RecursiveFunctional.csproj` will be completely the same
    compared to the output of `RecursiveImperative.csproj` . However, we use the functional
    approach in the code in `RecursiveFunctional.csproj` .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化`ints`变量，其中包含从1到我们所需的整数的值，然后我们使用`Aggregate`运算符迭代`ints`。`RecursiveFunctional.csproj`的输出与`RecursiveImperative.csproj`的输出完全相同。然而，我们在`RecursiveFunctional.csproj`中使用了函数式方法。
- en: Feeling functional in C#
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中感受函数式
- en: This section will discuss about functional programming in C#. We will be discussing
    both the conceptual aspects of functional programming and write code in C#, as
    well. We will be kick-starting the discussion by discussing about currying, pipelining,
    and method chaining.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论C#中的函数式编程。我们将讨论函数式编程的概念方面，并在C#中编写代码。我们将通过讨论柯里化、管道化和方法链接来开始讨论。
- en: Using mathematical concept to understand functional approach
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数学概念理解函数式方法
- en: 'In functional programming, functions behave the way a mathematical function
    behaves by returning the same value for a given argument regardless of the context
    in which it is invoked. This is called **Referential Transparency** . To understand
    this in more detail, consider that we have the following mathematical function
    notation, and we want to turn it into functional programming in C#:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数的行为方式类似数学函数，无论在何种上下文中调用，对于给定的参数都会返回相同的值。这被称为**引用透明性**。为了更详细地理解这一点，考虑我们有以下数学函数表示，并且我们想将其转换为C#中的函数式编程：
- en: '*f(x) = 4x² -14x-8*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(x) = 4x² -14x-8*'
- en: 'The functional programming in C# is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的函数式编程如下：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From the preceding function, which we can find in the `FunctionF.csproj` file,
    if `x` is 5, we will obtain `f` of 5, which is 22\. The notation will be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的函数中，我们可以在`FunctionF.csproj`文件中找到，如果`x`为5，我们将得到5的`f`，即22。表示如下：
- en: '*f(5) = 22*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(5) = 22*'
- en: 'We can also invoke the `f` function in C#, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在C#中调用`f`函数，如下所示：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Every time we run the function with 5 as the argument, which means that `x`
    is equal to 5, we always receive 22 as the return value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们以5作为参数运行函数时，也就是`x`等于5时，我们总是得到22作为返回值。
- en: 'Now, compare this with the imperative approach. Let''s take a look at the following
    code, which will be stored in the `ImperativeApproach.csproj` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其与命令式方法进行比较。让我们看一下以下代码，它将存储在`ImperativeApproach.csproj`文件中：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We describe the following code in the `Main()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Main()`方法中描述以下代码：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run `ImperativeApproach.csproj` , the console screen should be like what
    is shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`ImperativeApproach.csproj`，控制台屏幕应该如下截图所示：
- en: '![Using mathematical concept to understand functional approach](img/Image00006.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用数学概念理解函数式方法](img/Image00006.jpg)'
- en: In the preceding imperative approach code, we will get the different `i` output
    in every invocation of `increment` or `set` although we pass the identical argument.
    Here, we find the so-called side effect problem of the imperative approach. The
    `increment` or `set` functions are said to have a side effect since they modify
    the state of `i` and interact with the outside world.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令式方法代码中，无论我们传入相同的参数，每次调用`increment`或`set`时都会得到不同的`i`输出。在这里，我们发现了命令式方法的所谓副作用问题。`increment`或`set`函数被称为具有副作用，因为它们修改了`i`的状态并与外部世界交互。
- en: 'That was about side effects, and now, we have the following code in C#:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于副作用的问题，现在我们在C#中有以下代码：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code is statement style code, and we can find it in the `StatementStyle.csproj`
    file. It is an imperative programming technique that defines actions rather than
    producing results. We tell the computer what to do. We ask the computer to compare
    the value of the `value` variable with zero and then assign the `posOrNeg` variable
    to the associated value. We can try the preceding function by adding the following
    code to the project:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是语句样式代码，我们可以在`StatementStyle.csproj`文件中找到。这是一种命令式编程技术，它定义动作而不是产生结果。我们告诉计算机要做什么。我们要求计算机比较`value`变量的值与零，然后将`posOrNeg`变量分配给相关值。我们可以通过将以下代码添加到项目中来尝试前面的函数：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output in the console will be as follow:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的输出将如下所示：
- en: '![Using mathematical concept to understand functional approach](img/Image00007.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用数学概念理解函数式方法](img/Image00007.jpg)'
- en: And it agrees with our preceding discussion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的讨论一致。
- en: 'We can turn it into a functional approach by modifying it to expression style
    code. In C#, we can use the conditional operator to achieve this goal. The following
    is the code we have refactored from the `StatementStyle.csproj` code, and we can
    find it in the `ExpressionStyle.csproj` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其修改为表达式样式代码来将其转换为函数式方法。在C#中，我们可以使用条件运算符来实现这个目标。以下是我们从`StatementStyle.csproj`代码重构的代码，我们可以在`ExpressionStyle.csproj`文件中找到：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we have compact code that has the same behavior as our preceding many lines
    of code. However, as we discussed previously, the preceding code has no side-effect
    since it only returns the string value with no need to prepare the variable first.
    While in the statement style approach, we have to assign the `posOrNeg` variable
    twice. In other words, we can say that the functional approach will produce a
    side-effect-free function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了紧凑的代码，它具有与我们之前的许多行代码相同的行为。然而，正如我们之前讨论的，前面的代码没有副作用，因为它只返回字符串值，无需先准备变量。而在语句风格方法中，我们必须两次分配`posOrNeg`变量。换句话说，我们可以说函数式方法将产生一个无副作用的函数。
- en: 'In contrast to imperative programming, in functional programming, we describe
    what we want as the result rather than specifying how to receive the result. Suppose
    we have a list of data and want to create a new list containing the *Nth* element
    from the source list. The imperative approach to achieve this is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式编程相比，在函数式编程中，我们描述我们想要的结果，而不是指定如何获得结果。假设我们有一组数据，并且想要创建一个新列表，其中包含源列表中的第N个元素。实现这一目标的命令式方法如下：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code can be found in the `NthElementImperative.csproj` file.
    As we can see, to retrieve the Nth element from the list in C#, we have to initialize
    the first element so that we define `i` as `0` . We then iterate through the list
    element and decide whether the current element is the Nth element. If so, we add
    `newList` the new data from the source list. Here, we find that the preceding
    source code is not a functional approach because the `newList` variable is assigned
    more than once when adding the new data. It also contains the loop process, which
    the functional approach doesn''t have. However, we can turn the code into a functional
    approach as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以在`NthElementImperative.csproj`文件中找到。正如我们所看到的，在C#中检索列表中的第N个元素，我们必须初始化第一个元素，以便将`i`定义为`0`。然后我们遍历列表元素，并决定当前元素是否为第N个元素。如果是，我们将从源列表中添加新数据到`newList`中。在这里，我们发现前面的源代码不是一种函数式方法，因为在添加新数据时`newList`变量被赋值了多次。它还包含了循环过程，而函数式方法则没有。然而，我们可以将代码转换为函数式方法，如下所示：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Again, we have compact code in the functional approach since we are using the
    power of the LINQ feature. If we want to try the preceding two functions, we can
    inset the following code to the `Main()` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于我们使用了LINQ功能的强大功能，我们在函数式方法中有紧凑的代码。如果我们想要尝试前面的两个函数，我们可以将以下代码插入到`Main()`函数中：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the `PrintIntList()` method, the implementation is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`PrintIntList()`方法，实现如下：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Although we run the two functions with different approaches, we are still given
    the same output, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用不同的方法运行了这两个函数，但我们仍然得到了相同的输出，如下所示：
- en: '![Using mathematical concept to understand functional approach](img/Image00008.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用数学概念理解函数式方法](img/Image00008.jpg)'
- en: Applying tuple for functional C#
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用元组进行函数式C#
- en: 'In .NET Framework 4, Tuples is introduced as a new set of generic classes to
    store a set of different typed elements. Tuples is immutable so it can be applied
    to functional programming. It is used to represent a data structure when we need
    the different data type in an object. Here is the available syntax to declare
    tuple objects:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework 4中，元组被引入为一组新的通用类，用于存储一组不同类型的元素。元组是不可变的，因此可以应用于函数式编程。当我们需要对象中的不同数据类型时，它用于表示数据结构。以下是声明元组对象的可用语法：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can see in the preceding syntaxes, we can create a tuple with a maximum
    eight item type (`T1` , `T2` , and so on). `Tuple` has read-only properties that’s
    why it’s immutable. Let’s look at the following code snippet we can find in `Tuple.csproj`
    project:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的语法中所看到的，我们可以创建一个最多包含八个项目类型（`T1`，`T2`等）的元组。`Tuple`具有只读属性，因此它是不可变的。让我们看一下在`Tuple.csproj`项目中可以找到的以下代码片段：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To create Tuple, we have two different ways based on the preceding code. The
    former, we instantiate a new Tuple to a variable. The latter, we use `Tuple.Create()`
    . To consume the Tuple data, we can use its Item like the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建元组，我们有两种不同的方法，基于前面的代码。前者，我们将一个新的元组实例化为一个变量。后者，我们使用`Tuple.Create()`。要使用元组数据，我们可以像以下代码片段中那样使用它的项目：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we run `ConsumeTuple()` method above, we will get the following on the console:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上面的`ConsumeTuple()`方法，我们将在控制台上得到以下输出：
- en: '![Applying tuple for functional C#](img/Image00009.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![应用元组进行函数式C#](img/Image00009.jpg)'
- en: 'We can also return a tuple data type like we do in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像以下代码片段中所做的那样返回一个元组数据类型：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As we can see, `GetSize()` method will return Tuple data type. We can add the
    following `ReturnTuple()` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`GetSize()`方法将返回元组数据类型。我们可以添加以下`ReturnTuple()`方法：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And if we run `ReturnTuple()` method above, we will be displayed exactly same
    output as `ConsumeTuple()` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上面的`ReturnTuple()`方法，我们将会得到与`ConsumeTuple()`方法完全相同的输出。
- en: 'Fortunately, in C# 7, we can return Tuple data type without having to state
    the Tuple like the following code snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在C# 7中，我们可以返回元组数据类型，而无需声明元组，如以下代码片段所示：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And if we want to name all items in the Tuple, we can now do it in C# 7 by
    using the technique like the following code snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为元组中的所有项目命名，我们现在可以在C# 7中使用以下代码片段中的技术来实现：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And now it will be clearer when we access the Tuple items like the following
    code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们像以下代码一样访问元组项目时，它将更清晰：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We no longer call the `Item1` and `Item2` , instead we call the x and y name.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再调用`Item1`和`Item2`，而是调用x和y名称。
- en: In order to gain all new feature of Tuple in C# 7, we have to download `System.ValueTuple`
     NuGet package from [https://www.nuget.org/packages/System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple)
    .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得C# 7中元组的所有新功能，我们必须从[https://www.nuget.org/packages/System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple)下载`System.ValueTuple`
    NuGet包。
- en: Currying in C#
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的柯里化
- en: 'We have theoretically discussed currying at the beginning of this chapter.
    We apply currying when we split a function that takes multiple arguments into
    a sequence of functions that occupy part of the argument. In other words, when
    we pass fewer arguments into a function, it will expect that we get back another
    function to complete the original function using the sequence of functions. Let''s
    take a look at the following code from the `NonCurriedMethod.csproj` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们已经从理论上讨论了柯里化。当我们将一个接受多个参数的函数分割成一系列占据部分参数的函数时，我们就应用了柯里化。换句话说，当我们将较少的参数传递给一个函数时，它将期望我们返回另一个函数，以使用函数序列完成原始函数。让我们看一下`NonCurriedMethod.csproj`文件中的以下代码：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding function will add the `a` and `b` arguments and then return the
    result. The usage of this function is commonly used in our daily programming;
    for instance, take a look at the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将添加`a`和`b`参数，然后返回结果。这个函数的用法在我们日常编程中很常见；例如，看一下以下代码片段：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s move on to the curried method. The code will be found in the `CurriedMethod.csproj`
    file, and the function declaration will be as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论柯里化方法。代码将在`CurriedMethod.csproj`文件中找到，函数声明如下：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We use the `Func<>` delegate to create the `CurriedAdd()` method. We can invoke
    the preceding method in two ways, and the first is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Func<>`委托来创建`CurriedAdd()`方法。我们可以以两种方式调用前面的方法，第一种如下：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding invocation of the `CurriedAdd()` method, we pass the argument
    with two brackets, which it might not be familiar with. In fact, we can also curry
    our `CurriedAdd()` method by passing one argument only. The code will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurriedAdd()`方法的前面调用中，我们用两个括号传递参数，这可能不太熟悉。实际上，我们也可以只传递一个参数来对`CurriedAdd()`方法进行柯里化。代码如下：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'From the preceding code, we supply one argument to the `CurriedAdd()` method
    in the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们向`CurriedAdd()`方法提供了一个参数：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, it waits for the other `addition` expression, which we provide in the
    following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它等待另一个`addition`表达式，我们在以下代码中提供：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The result of the preceding code will be completely the same as the `NonCurried()`
    method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的结果将与`NonCurried()`方法完全相同。
- en: Pipelining
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: 'Pipelining is a technique used to pass the output of one function as an input
    to the next function. The data in the operation will flow like the flow of water
    in a pipe. We usually find this technique in command-line interfaces. Let''s take
    a look at the following command line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 管道技术是一种将一个函数的输出作为下一个函数的输入传递的技术。操作中的数据将像管道中的水流一样流动。我们通常在命令行界面中找到这种技术。让我们看一下以下命令行：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding command line will pass the output of the `dir` command to the
    input of the `more` command. Now, let''s take a look at the following C# code
    that we can find in the `NestedMethodCalls.csproj` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令行将`dir`命令的输出传递给`more`命令的输入。现在，让我们看一下以下C#代码，我们可以在`NestedMethodCalls.csproj`文件中找到：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the previous code, we used the nested method calls technique to write `pipelining`
    in console screen. If we want to refactor it to the pipelining approach, we can
    take a look at the following code that we can find in the `Pipelining.csproj`
    file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了嵌套方法调用技术来在控制台屏幕上编写`管道`。如果我们想要将其重构为管道方法，我们可以看一下以下代码，我们可以在`Pipelining.csproj`文件中找到它：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If run the preceding code, we will get exactly the same pipelining output, but
    this time, it will be in the pipelining style.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，我们将得到完全相同的管道输出，但这次将以管道方式呈现。
- en: Method chaining
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链接
- en: 'Method chaining is process of chaining multiple methods in one code line. The
    return from one method will be the input of the next method, and so on. Using
    method chaining, we don''t need to declare many variables to store every method
    return. Instead, the return of the method will be passed to the next method argument.
    The following is the traditional method, which doesn''t apply method chaining,
    and we can find the code at `TraditionalMethod.csproj` :'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链接是在一行代码中链接多个方法的过程。一个方法的返回值将成为下一个方法的输入，依此类推。使用方法链接，我们不需要声明许多变量来存储每个方法的返回值。相反，方法的返回值将传递给下一个方法的参数。以下是不应用方法链接的传统方法，我们可以在`TraditionalMethod.csproj`中找到该代码：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'There are five methods of `StringBuilder` invoked inside the `Main` function
    and two variables: `sb` is used to initialize `StringBuilder` and `str` is used
    to store `StringBuilder` in the string format. Unfortunately, the five methods
    we invoked there modify the `sb` variable. We can refactor the code to apply method
    chaining in order to make it functional. The following is the functional code,
    and we can find it at `ChainingMethod.csproj` :'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`函数中调用了`StringBuilder`的五种方法和两个变量：`sb`用于初始化`StringBuilder`，`str`用于以字符串格式存储`StringBuilder`。不幸的是，我们在那里调用的五种方法修改了`sb`变量。我们可以重构代码以应用方法链接，以使其成为函数式。以下是函数式代码，我们可以在`ChainingMethod.csproj`中找到它：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The same output will be displayed if we run both types of code. However, we
    now have functional code by chaining all the invoking methods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行两种类型的代码，将显示相同的输出。但是，现在我们通过链接所有调用方法得到了函数式代码。
- en: Transforming imperative code to functional code
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将命令式代码转换为函数式代码
- en: 'In this section, we will transform imperative code to functional code by leveraging
    method chaining. Suppose we want to create an HTML-ordered list containing the
    list of the planets in our solar system; the HTML will look as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过利用方法链接将命令式代码转换为函数式代码。假设我们想要创建一个包含太阳系行星列表的HTML有序列表；HTML将如下所示：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The imperative code approach
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式代码方法
- en: 'We are going to list the name of planets, including the Sun. We will also mark
    the order of the planets with the value attribute in each `li` element. The preceding
    HTML code will be displayed in the console. We will create the list in `ImperativeCode.csproj`
    ; here you go:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列出行星的名称，包括太阳。我们还将使用每个`li`元素中的value属性标记行星的顺序。前面的HTML代码将显示在控制台中。我们将在`ImperativeCode.csproj`中创建列表；请看下面：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `Main()` method, we create a byte array, buffer, containing the planet
    stream we generate in other classes. The code snippet is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main()`方法中，我们创建一个名为buffer的字节数组，其中包含我们在其他类中生成的行星流。代码片段如下：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can see that there is a class named `Utility` , containing the `GeneratePlanetStream()`
    method. This method is used to generate the list of planets in the solar system
    in a stream format. Let''s take a look at the following code in order to find
    what is inside the method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个名为`Utility`的类，其中包含`GeneratePlanetStream()`方法。这个方法用于以流格式生成太阳系中行星的列表。让我们看一下以下代码，以找出方法内部的内容：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Firstly, it creates a variable named `planets` , containing eight planets named
    separately on a new line. We get the bytes of the ASCII using the `GetBytes` method,
    and then it is converted into a stream. This stream will be returned to the caller
    function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它创建一个名为`planets`的变量，其中包含八个行星的名称，分别在新行上。我们使用`GetBytes`方法获取ASCII的字节，然后将其转换为流。这个流将返回给调用者函数。
- en: 'In the `main` function, we also have variable options, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们还有变量options，如下所示：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will create a dictionary-typed variable, which contains the name of the
    planet and its order in the solar system. We use LINQ here, but we will discuss
    it deeper in the next chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含行星名称和其在太阳系中顺序的字典类型变量。我们在这里使用LINQ，但我们将在下一章中更深入地讨论它。
- en: 'Then, we invoke the `GenerateOrderedList()` method inside the `Utility` class.
    This method is used to generate an HTML-ordered list containing the order of the
    planets in the solar system. The code snippet is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Utility`类中调用`GenerateOrderedList()`方法。这个方法用于生成一个包含太阳系中行星顺序的HTML有序列表。代码片段如下：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we take a look at the `GenerateOrderedList()` method, we will find the following
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`GenerateOrderedList()`方法，我们会发现以下代码：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'First, in this method, we create a `StringBuilder` function named `html` and
    add an opening `ol` tag, which means an *ordered list* . The code snippet is as
    follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在这个方法中，我们创建一个名为html的`StringBuilder`函数，并添加一个开放的`ol`标签，表示*有序列表*。代码片段如下：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also have Boolean variable, `includeSun` , to define whether we need to
    include Sun in the list. We get the value of this variable from the argument of
    the method. After that, we iterate the content of the dictionary we get from argument.
    This dictionary is generated by LINQ in the `Main()` method. We list the content
    by adding the `li` tag. The `foreach` keyword is used to achieve this goal. Here
    is the code snippet:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个布尔变量`includeSun`，用于定义我们是否需要在列表中包含太阳。我们从方法的参数中获取这个变量的值。之后，我们迭代从参数中获取的字典的内容。这个字典是由`Main()`方法中的LINQ生成的。我们通过添加`li`标签来列出内容。我们使用`foreach`关键字来实现这个目标。以下是代码片段：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We can see that `AppendFormat` in the `StringBuilder` class is similar to `String.Format`
    , and we can pass `Key` and `Value` from dictionary. Do not forget to insert a
    new line for each `li` tag using the `AppendLine` method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`StringBuilder`类中的`AppendFormat`与`String.Format`类似，我们可以从字典中传递`Key`和`Value`。不要忘记使用`AppendLine`方法为每个`li`标签插入新行。
- en: 'Lastly, we close the `ol` tag with the `</ol>` tag, which we define in the
    following snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码关闭`ol`标签，该标签在以下代码片段中定义：
- en: '[PRE75]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Then, we invoke the `ToString()` method to get a bunch of strings from `StringBuilder`
    . Now if we run the code, we will get the output on the console screen, as we
    discussed earlier.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`ToString()`方法从`StringBuilder`中获取一堆字符串。现在，如果我们运行代码，我们将在控制台屏幕上得到输出，就像我们之前讨论的那样。
- en: The functional code approach
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能代码方法
- en: We have already developed imperative code in order to construct an HTML-ordered
    list of planet names, as discussed earlier. Now, from this imperative code, we
    are going to refactor it to functional code using method chaining. The functional
    code we build will be at `FunctionalCode.csproj` .
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了命令式代码，以构建一个行星名称的HTML有序列表，就像我们之前讨论的那样。现在，从这个命令式代码中，我们将重构为使用方法链接的功能代码。我们构建的功能代码将在`FunctionalCode.csproj`中。
- en: The GenerateOrderedList() method
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GenerateOrderedList()方法
- en: 'We start with the `GenerateOrderedList()` method since we will modify its first
    three lines. It looks like the following in `ImperativeCode.csproj` :'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`GenerateOrderedList()`方法开始，因为我们将修改它的前三行。在`ImperativeCode.csproj`中，它看起来像下面这样：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can refactor the preceding code to this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码重构为这样：
- en: '[PRE77]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The code becomes more natural now since it applies method chaining. However,
    we are still able to join the `AppendFormat()` method with the `AppendLine()`
    method in order to make it simple. To achieve this goal, we need help from method
    extension. We can create a method extension for `StringBuilder` as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码变得更加自然，因为它应用了方法链接。然而，我们仍然能够将`AppendFormat()`方法与`AppendLine()`方法结合起来，以使其变得简单。为了实现这个目标，我们需要方法扩展的帮助。我们可以创建一个`StringBuilder`的方法扩展，如下所示：
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, because we have the `AppendFormattedLine()` method in the `StringBuilder`
    class, we can refactor our previous code snippet to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们在`StringBuilder`类中有`AppendFormattedLine()`方法，我们可以将之前的代码片段重构为以下内容：
- en: '[PRE79]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The code snippet becomes much simpler than earlier. We also have the invocation
    of `AppendFormat()` following `AppendLine()` inside the `foreach` loop, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段变得比以前简单得多。我们还在`foreach`循环内部的`AppendFormat()`后面调用了`AppendLine()`，如下所示：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Therefore, we can also refactor the preceding code snippet using the `AppendFormattedLine()`
    function we added inside the `StringBuilder` class, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还可以使用我们在`StringBuilder`类中添加的`AppendFormattedLine()`函数重构前面的代码片段，如下所示：
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we have `AppendLine()` inside the conditional keyword `if` . We also
    need to refactor it to apply method chaining using the extension method. We can
    create the extension method for `StringBuilder` named `AppendLineWhen()` . The
    use of this method is to compare the condition we provide, and then it should
    decide whether or not it needs to be written. The extension method will be as
    follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在条件关键字`if`内部有`AppendLine()`。我们还需要重构它，以使用扩展方法进行方法链接。我们可以为`StringBuilder`创建名为`AppendLineWhen()`的扩展方法。使用这种方法是为了比较我们提供的条件，然后它应该决定是否需要被写入。扩展方法将如下所示：
- en: '[PRE82]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Since we now have the `AppendLineWhen()` method, we can chain it to the previous
    code snippet, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了`AppendLineWhen()`方法，我们可以将其链接到前面的代码片段，如下所示：
- en: '[PRE83]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Thus, we are now confident about removing the following code from the `GenerateOrderedList()`
    method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有信心从`GenerateOrderedList()`方法中删除以下代码：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We are also able to make the `AppendLineWhen()` method more general so that
    it not only accepts a string, but also takes a function as an argument. Let''s
    modify the `AppendLineWhen()` method to the `AppendWhen()` method, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使`AppendLineWhen()`方法更通用，使其不仅接受字符串，还接受函数作为参数。让我们将`AppendLineWhen()`方法修改为`AppendWhen()`方法，如下所示：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As we can see, the function now takes `Func<StringBuilder, StringBuilder> fn`
    as an argument to replace the string value. So, it now uses the function to decide
    the conditional with `fn(@this)` . We can refactor `var html` again with our new
    method, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该函数现在将`Func<StringBuilder, StringBuilder> fn`作为参数，以替换字符串值。因此，它现在使用该函数来决定`fn(@this)`的条件。我们可以再次使用我们的新方法重构`var
    html`，如下所示：
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have chained two methods so far; they are `AppendFormattedLine()` and `AppendWhen()`
    methods. The remaining function we have is `foreach` loop that we need to chain
    to the `StringBuilder` object named `html` . For this purpose, we create an extension
    method to a `StringBuilder` named `AppendSequence()` again, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经链接了两种方法，它们是`AppendFormattedLine()`和`AppendWhen()`方法。我们剩下的函数是`foreach`循环，我们需要将其链接到名为`html`的`StringBuilder`对象。为此，我们再次创建一个名为`AppendSequence()`的`StringBuilder`的扩展方法，如下所示：
- en: '[PRE87]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We use the `IEnumerable` interface to make this function iterate over the sequence.
    It also invokes the `Aggregate` method in `IEnumerable` as an accumulator that
    counts the increasing sequence.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`IEnumerable`接口使该函数在序列上进行迭代。它还调用`IEnumerable`中的`Aggregate`方法作为一个累加器，计算递增序列。
- en: 'Now, using `AppendSequence()` , we can refactor the `foreach` loop and chain
    the methods to `var html` , as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`AppendSequence()`，我们可以重构`foreach`循环并将方法链接到`var html`，如下所示：
- en: '[PRE88]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `AppendSequence()` method we add takes the options variable as the dictionary
    input and function of `sb` and `opt` . This method will iterate the dictionary
    content and then append the formatted string into `StringBuilder sb` . Now, the
    following `foreach` loop can be removed from the code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的`AppendSequence()`方法以选项变量作为字典输入和`sb`和`opt`的函数。此方法将迭代字典内容，然后将格式化的字符串附加到`StringBuilder
    sb`中。现在，以下`foreach`循环可以从代码中删除：
- en: '[PRE89]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next is the `html.AppendLine("</ol>")`  function invocation we want to chain
    to the `var html`  variable. This is quite simple because we just need to chain
    it without making many changes. Now let''s take a look at a change in the `var
    html` assignment:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们想要链接到`var html`变量的`html.AppendLine("</ol>")`函数调用。这相当简单，因为我们只需要链式调用它而不需要做太多更改。现在让我们看一下`var
    html`赋值中的变化：
- en: '[PRE90]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As we can see in the preceding code, we refactor the `AppendLine()` method,
    so it is now chained to the `StringBuilder` declaration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们重构了`AppendLine()`方法，所以现在它链接到`StringBuilder`声明。
- en: 'In the `GenerateOrderedList()` method, we have the following line of code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GenerateOrderedList()`方法中，我们有以下代码行：
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can also refactor the line so that it will be chained to the `StringBuilder`
    declaration in `var html` . If we chain it, we will have the following `var html`
    initialization:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重构该行，使其链接到`var html`中的`StringBuilder`声明。如果我们链接它，我们将得到以下`var html`初始化：
- en: '[PRE92]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Unfortunately, if we compile the code now, it will yield the *CS0161* error
    with the following explanation:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们现在编译代码，它将产生*CS0161*错误，错误解释如下：
- en: '[PRE93]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The error occurs because the method doesn''t return any value when it''s expected
    to return a string value. However, since it is functional programming, we can
    refactor this method in an expression member. The complete `GenerateOrderedList()`
    method will be as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为该方法在预期返回字符串值时没有返回任何值。但是，由于它是函数式编程，我们可以将这个方法重构为表达式成员。完整的`GenerateOrderedList()`方法将如下所示：
- en: '[PRE94]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We have removed the `return` keyword from the preceding code. We have also removed
    the `html` variable. We now have a function that has bodies as lambda-like expressions
    instead of statement blocks. This feature was announced in .NET Framework 4.6.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面的代码中删除了`return`关键字。我们还删除了`html`变量。我们现在有一个函数，其主体是类似lambda表达式而不是语句块。这个特性是在.NET
    Framework 4.6中宣布的。
- en: The Main() method
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Main()`方法'
- en: 'The `Main()` method in `FunctionalCode.csproj` is a typical method we usually
    face when programming in C#. The method flow is as follows: it reads data from
    the stream into the byte array and then converts those bytes into strings. After
    that, it performs a transformation to modify that string before passing it to
    the `GenerateOrderedList()` method.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionalCode.csproj`中的`Main()`方法是我们在C#编程中通常遇到的典型方法。方法流程如下：它从流中读取数据到字节数组，然后将这些字节转换为字符串。之后，它执行转换以修改该字符串，然后将其传递给`GenerateOrderedList()`方法。'
- en: 'If we look at the starting code lines, we get the following code snippet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下起始代码行，我们会得到以下代码片段：
- en: '[PRE95]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We need to refactor the preceding code to be able to be chained. For this purpose,
    we create a new class named `Disposable` , containing the `Using()` method. The
    `Using()` method inside the `Disposable` class is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重构前面的代码以便进行链接。为此，我们创建一个名为`Disposable`的新类，其中包含`Using()`方法。`Disposable`类中的`Using()`方法如下：
- en: '[PRE96]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the preceding `Using()` method, we take two arguments: `factory` and `fn`
    . The function to which the `IDisposable` interface applies is `factory` , and
    `fn` is the function that will be executed after declaring the `factory` function.
    Now we can refactor the starting lines in the `Main()` method as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Using()`方法中，我们接受两个参数：`factory`和`fn`。`IDisposable`接口适用的函数是`factory`，而`fn`是在声明`factory`函数后将要执行的函数。现在，我们可以重构`Main()`方法的起始行如下：
- en: '[PRE97]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Compared to imperative code, we have now refactored the code that reads the
    stream and stores it in a byte array with the help of the `Dispose.Using()` method.
    We ask the lambda stream function to return the buff content. Now, we have a buffer
    variable to be passed to the next phase, which is the `UTF8.GetString(buffer)`
    method. What we actually do in the `GetString(buffer)` method is transforming
    and then mapping the buffer to a string. In order to chain this method, we need
    to create the `Map` method extension. The method will look as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式代码相比，我们现在已经重构了使用`Dispose.Using()`方法将流读取并存储到字节数组中的代码。我们要求lambda流函数返回buff内容。现在，我们有一个缓冲变量要传递到下一个阶段，即`UTF8.GetString(buffer)`方法。我们在`GetString(buffer)`方法中实际上做的是将缓冲区转换并映射为字符串。为了链接这个方法，我们需要创建`Map`方法扩展。该方法将如下所示：
- en: '[PRE98]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Since we need to make it a general method, we use a generic type in the arguments
    of the method. We also use a generic type in the returning value so that it won''t
    return only the string value. Using the generic types, this `Map` extension method
    will be able to transform any static type value into another static type value.
    We need to use an expression body member for this method, so we use the lambda
    expression here. Now we can use this `Map` method for the `UTF8.GetString()` method.
    The `var buffer` initialization will be as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将其作为通用方法，我们在方法的参数中使用了一个通用类型。我们还在返回值中使用了一个通用类型，这样它就不会只返回字符串值。使用通用类型，这个`Map`扩展方法将能够将任何静态类型值转换为另一个静态类型值。我们需要为这个方法使用表达式主体成员，所以我们在这里使用了lambda表达式。现在我们可以将这个`Map`方法用于`UTF8.GetString()`方法。`var
    buffer`的初始化将如下所示：
- en: '[PRE99]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'By applying the `Map` method like the preceding code snippet, we don''t need
    the following code anymore:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用`Map`方法，就像前面的代码片段一样，我们不再需要以下代码：
- en: '[PRE100]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'However, the problem occurs since the next code needs variable options as arguments
    to the `GenerateOrderedList()` method, which we can see in following code snippet:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题出现了，因为下一个代码需要将变量选项作为`GenerateOrderedList()`方法的参数，我们可以在以下代码片段中看到：
- en: '[PRE101]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To solve this problem, we can use the `Map` methods as well to chain the `GenerateOrderedList()`
    method to the buffer variable initialization so that we can remove the `orderedList`
    variable. Now, the code will be look like what is shown in the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们也可以使用`Map`方法将`GenerateOrderedList()`方法链接到缓冲变量初始化，这样我们就可以删除`orderedList`变量。现在，代码将如下所示：
- en: '[PRE102]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Since the last line of code is the `Console.WriteLine()` method, which takes
    the `orderedList` variable as an argument, we can modify the buffer variable to
    `orderedList` . The change will be as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码的最后一行是`Console.WriteLine()`方法，它以`orderedList`变量作为参数，我们可以将缓冲变量修改为`orderedList`。更改将如下所示：
- en: '[PRE103]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The last line in the `GenerateOrderedList()` method is the `Console.WriteLine()`
    method. We will also chain this method to the `orderedList` variable. For this
    purpose, we need to extend a method called `Tee` , containing the pipelining technique
    we discussed earlier. Let''s take a look at the following `Tee` method extension:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateOrderedList()`方法中的最后一行是`Console.WriteLine()`方法。我们还将这个方法链接到`orderedList`变量上。为此，我们需要扩展一个名为`Tee`的方法，其中包含我们之前讨论过的流水线技术。让我们来看一下下面的`Tee`方法扩展：'
- en: '[PRE104]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'From the preceding code, we can see that the output of `Tee` will be passed
    to the input of the `Action` function. Then, we can chain the last line using
    `Tee` , as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`Tee`的输出将传递给`Action`函数的输入。然后，我们可以使用`Tee`链接最后一行，如下所示：
- en: '[PRE105]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`Tee` can return the HTML generated by the `GenerateOrderedList()` method so
    that we can remove the `orderedList` variable from the code.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tee`可以返回由`GenerateOrderedList()`方法生成的HTML，这样我们就可以从代码中删除`orderedList`变量。'
- en: 'We can also implement the `Tee` method to the lambda expression in the preceding
    code. We will refactor the following code snippet using `Tee` :'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`Tee`方法实现到前面代码中的lambda表达式中。我们将使用`Tee`来重构以下代码片段：
- en: '[PRE106]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s understand what the preceding code snippet is actually doing. First,
    we initialize the byte array variable `buff` to store as many bytes as the length
    of the stream. It then populates this byte array using the `stream.Read` method
    before returning the byte array. We can also ask the `Tee` method to do this job.
    The code will be as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下前面的代码片段实际上在做什么。首先，我们初始化了一个名为`buff`的字节数组变量，以存储与流的长度相同的字节数。然后使用`stream.Read`方法填充这个字节数组，然后返回字节数组。我们也可以要求`Tee`方法来做这个工作。代码将如下所示：
- en: '[PRE107]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now, we have a new `Main()` method, applying method chaining to approach functional
    programming.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新的`Main()`方法，应用了方法链接来实现函数式编程。
- en: The advantages and disadvantages of functional programming
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的优缺点
- en: 'So far, we have had to deal with functional programming by creating code using
    functional approach. Now, we can look at the advantages of the functional approach,
    such as the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过使用函数式方法来创建代码来处理函数式编程。现在，我们可以看一下函数式方法的优势，例如以下内容：
- en: The order of execution doesn't matter since it is handled by the system to compute
    the value we have given rather than the one defined by programmer. In other words,
    the declarative of the expressions will become unique. Because functional programs
    have an approach toward mathematical concepts, the system will be designed with
    the notation as close as possible to the mathematical way of concept.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行顺序并不重要，因为它是由系统处理的，计算的值是我们给定的，而不是程序员定义的值。换句话说，表达式的声明将变得唯一。因为函数式程序对数学概念有一种方法，系统将被设计成尽可能接近数学概念的表示方式。
- en: Variables can be replaced by their value since the evaluation of expression
    can be done any time. The functional code is then more mathematically traceable
    because the program is allowed to be manipulated or transformed by substituting
    equals with equals. This feature is called referential transparency.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的值可以被其值替换，因为表达式的求值可以随时进行。因此，函数式代码在数学上更容易追踪，因为程序允许通过等号替换等号来进行操作或转换。这个特性被称为引用透明性。
- en: Immutability makes the functional code free of side effects. A shared variable,
    which is an example of a side effect, is a serious obstacle for creating parallel
    code and result in non-deterministic execution. By removing the side effect, we
    can have a good coding approach.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性使函数式代码不受副作用的影响。共享变量是副作用的一个例子，它是创建并行代码的严重障碍，并导致非确定性执行。通过消除副作用，我们可以有一个良好的编码方法。
- en: The power of lazy evaluation will make the program run faster because it only
    provides what we really required for the queries result. Suppose we have a large
    amount of data and want to filter it by a specific condition, such as showing
    only the data that contains the word Name. In imperative programming, we will
    have to evaluate each operation of all the data. The problem is that when the
    operation takes a long time, the program will need more time to run as well. Fortunately,
    the functional programming that applies LINQ will perform the filtering operation
    only when it is needed. That's why functional programming will save much of our
    time using lazy evaluation.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值的力量将使程序运行得更快，因为它只提供了我们真正需要的查询结果。假设我们有大量数据，并且想要根据特定条件进行过滤，比如只显示包含单词“Name”的数据。在命令式编程中，我们将不得不评估所有数据的每个操作。问题在于当操作花费很长时间时，程序也需要更多时间来运行。幸运的是，应用LINQ的函数式编程只在需要时执行过滤操作。这就是为什么函数式编程将节省我们大量时间使用惰性求值。
- en: We have a solution for complex problems using composability. It is a rule principle
    that manages a problem by dividing it, and it gives pieces of the problem to several
    functions. The concept is similar to a situation when we organize an event and
    ask different people to take up a particular responsibility. By doing this, we
    can ensure that everything will done properly by each person.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个使用可组合性解决复杂问题的方法。这是一个通过将问题分解来管理问题的原则，并将问题的部分交给几个函数。这个概念类似于我们组织活动并要求不同的人承担特定的责任的情况。通过这样做，我们可以确保每个人都会正确地完成所有事情。
- en: 'Beside the advantages of functional programming, there are several disadvantages
    as well. Here are some of them:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数式编程的优点之外，还有一些缺点。以下是其中一些：
- en: Since there's no state and no update of variables is allowed, loss of performance
    will take place. The problem occurs when we deal with a large data structure and
    it needs to perform a duplication of any data even though it only changes a small
    part of the data.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有状态，也不允许更新变量，性能损失将会发生。当我们处理大型数据结构并且需要对任何数据执行复制时，即使只改变了一小部分数据，问题也会发生。
- en: Compared to imperative programming, much garbage will be generated in functional
    programming due to the concept of immutability, which needs more variables to
    handle specific assignments. Because we cannot control the garbage collection,
    the performance will decrease as well.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令式编程相比，函数式编程会产生更多的垃圾，因为不可变性的概念需要更多的变量来处理特定的赋值。因为我们无法控制垃圾收集，性能也会下降。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So far, we have been acquainted with the functional approach by discussing the
    introduction of functional programming. We also have compared the functional approach
    to the mathematical concept when we create functional program. It's now clear
    that the functional approach uses the mathematical approach to compose a functional
    program.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过讨论函数式编程的介绍来了解函数式方法。我们还将函数式方法与数学概念进行了比较，当我们创建函数式程序时。现在清楚了，函数式方法使用数学方法来组成函数式程序。
- en: There are three important points in constructing the function; they are definition,
    script, and session. The definition is the equation between particular expressions
    that describe the mathematical function. Script is a collection of definitions
    that are supplied by the programmer. Session is a situation where the program
    submits the expressions that can contain references to the function defined in
    the script to the computer for evaluation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 构建函数有三个重要的要点；它们是定义、脚本和会话。定义是描述数学函数的特定表达式之间的等式。脚本是程序员提供的一组定义。会话是程序将包含对脚本中定义的函数的引用的表达式提交给计算机进行评估的情况。
- en: The comparison between functional and imperative programming also led us to
    the important point of distinguishing the two. It's now clear that in functional
    programming, the programmer focuses on the kind of desired information and the
    kind of required transformation, while in the imperative approach, the programmer
    focuses on the way of performing the task and tracking changes in the state.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式和命令式编程的比较也引出了区分两者的重要观点。现在清楚了，在函数式编程中，程序员关注所需信息的类型和所需转换的类型，而在命令式方法中，程序员关注执行任务的方式和跟踪状态的变化。
- en: 'We also explored several concepts of functional programming, such as first-class
    and higher-order functions, pure functions, and recursive functions. The first-class
    and higher-order functions concept treats the functions as values so that we can
    assign it to a variable and pass it to the argument of the function. The pure
    functions concept makes the function have no side-effect. Recursive functions
    help us iterate the function itself with the power of aggregate in LINQ. Also,
    functions in functional programming have several characteristics that we need
    to know, such as the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了函数式编程的几个概念，如头等和高阶函数、纯函数和递归函数。头等和高阶函数的概念将函数视为值，因此我们可以将其分配给变量并将其传递给函数的参数。纯函数的概念使函数没有副作用。递归函数帮助我们使用LINQ中的聚合功能迭代函数本身的能力。此外，函数式编程中的函数具有我们需要了解的几个特征，例如以下内容：
- en: It always returns the same value every time it is given the same set of inputs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 每次给定相同的输入集时，它总是返回相同的值。
- en: It never references a variable defined outside the function.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 它从不引用函数外定义的变量。
- en: It cannot change the value of the variable since it applies the immutable concept.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 它不能改变变量的值，因为它应用了不可变的概念。
- en: It doesn't contain any I/O, such as a fancy output or a keyboard stroke, since
    no side-effect occurrence is allowed.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 它不包含任何I/O，例如花哨的输出或键盘输入，因为不允许发生副作用。
- en: When we test functional program in C#, we take the mathematical approach to
    find out how to compose a function in C# from a mathematical function. We learn
    how to curry the curried function to pass the second argument after we assign
    the first argument alone. Also, we now know how to make the program functional
    using pipelining and the method chaining technique.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中测试函数式程序时，我们采用数学方法来找出如何从数学函数中组合一个C#函数。我们学会了如何对柯里化函数进行柯里化，以便在分配第一个参数后传递第二个参数。此外，我们现在知道如何使用管道和方法链接技术使程序具有函数式。
- en: After finishing with learning the techniques for creating functional programming,
    we translate the imperative approach code into the functional approach code. Here,
    we compose the imperative code from scratch and then refactor it into functional
    code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习创建函数式编程的技术后，我们将命令式方法代码转换为函数式方法代码。在这里，我们从头开始组合命令式代码，然后将其重构为函数式代码。
- en: Lastly, after we become more familiar with functional programming, we can grasp
    the advantages and disadvantages of functional programming itself. This will be
    the reason why we need to learn functional programming.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们对函数式编程更加熟悉时，我们可以掌握函数式编程本身的优缺点。这将是我们需要学习函数式编程的原因。
- en: In the next chapter, we will talk about delegate data type to encapsulates a
    method that has particular parameters and return type. It is useful when we need
    create a cleaner and an easier function pointer.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论委托数据类型，以封装具有特定参数和返回类型的方法。当我们需要创建一个更清晰、更简单的函数指针时，这是非常有用的。
