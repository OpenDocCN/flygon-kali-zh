- en: Chapter 4. Managing Files and Directories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。管理文件和目录
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下内容：
- en: Creating files and directories
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件和目录
- en: Controlling how a file is copied
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制文件复制方式
- en: Managing temporary files and directories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理临时文件和目录
- en: Setting time-related attributes of a file or directory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件或目录的时间相关属性
- en: Managing file ownership
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件所有权
- en: Managing ACL file permissions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理ACL文件权限
- en: Managing POSIX attributes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理POSIX属性
- en: Moving a file or directory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动文件或目录
- en: Deleting files and directories
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件和目录
- en: Managing symbolic links
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理符号链接
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: It is often necessary to perform file manipulations such as creating files,
    manipulating their attributes and contents, or removing them from the filesystem.
    The addition of the `java.lang.object.Files` class in Java 7 simplifies this process.
    This class relies heavily on the use of the new `java.nio.file.Path` interface,
    which is discussed in depth in [Chapter 2](ch02.html "Chapter 2. Locating Files
    and Directories Using Paths"), *Locating Files and Directories Using Paths*. The
    methods of the class are all static in nature, and generally assign the actual
    file manipulation operations to the underlying filesystem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要执行文件操作，如创建文件，操作它们的属性和内容，或从文件系统中删除它们。Java 7中`java.lang.object.Files`类的添加简化了这个过程。这个类在很大程度上依赖于新的`java.nio.file.Path`接口的使用，这在[第2章](ch02.html
    "第2章。使用路径定位文件和目录")中深入讨论，*使用路径定位文件和目录*。该类的方法在本质上都是静态的，并且通常将实际的文件操作分配给底层文件系统。
- en: Many of the operations described in this chapter are atomic in nature, such
    as those used to create and delete files or directories. Atomic operations will
    either execute successfully to completion or fail and result in an effective cancellation
    of the operation. During execution, they are not interrupted from the standpoint
    of a filesystem. Other concurrent file operations will not impact the operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的许多操作在本质上是原子的，例如用于创建和删除文件或目录的操作。原子操作要么成功执行完成，要么失败并导致操作的有效取消。在执行过程中，它们不会从文件系统的角度受到干扰。其他并发文件操作不会影响该操作。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To execute many of the examples in this chapter, the application needs to run
    as administrator. To run an application as administrator under Windows, right-click
    on the **Command Prompt** menu and choose **Run as administrator**. Then navigate
    to the appropriate directory and execute using the `java.exe` command. To run
    as administrator on a UNIX system, use the `sudo` command in a terminal window
    followed by the `java` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章中的许多示例，应用程序需要以管理员身份运行。在Windows下以管理员身份运行应用程序，右键单击**命令提示符**菜单，选择**以管理员身份运行**。然后导航到适当的目录并使用`java.exe`命令执行。在UNIX系统上以管理员身份运行，使用终端窗口中的`sudo`命令，然后是`java`命令。
- en: Basic file management is covered in this chapter. The methods required for the
    creation of files and directories are covered in the *Creating Files and Directories*
    recipe. This recipe focuses on normal files. The creation of temporary files and
    directories is covered in the *Managing temporary files and directories* recipe,
    and the creation of linked files is covered in the *Managing symbolic links* recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了基本的文件管理。创建文件和目录所需的方法在*创建文件和目录*教程中介绍。该教程侧重于普通文件。临时文件和目录的创建在*管理临时文件和目录*教程中介绍，链接文件的创建在*管理符号链接*教程中介绍。
- en: The options available for copying files and directories are found in the *Controlling
    how a file is copied* recipe. The techniques illustrated there provide a powerful
    way of dealing with file replication. Moving and deleting files and directories
    are covered in the *Moving a file or directory* and *Deleting files and directories*
    recipes, respectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件和目录的可用选项在*控制文件复制方式*教程中找到。那里展示的技术提供了处理文件复制的强大方式。移动和删除文件和目录分别在*移动文件或目录*和*删除文件或目录*教程中介绍。
- en: 'The *Setting time-related attributes of a file or directory* recipe illustrates
    how to assign time attributes to a file. Related to this effort are other attributes,
    such as file ownership and permissions. File ownership is addressed in the *Managing
    file ownership* recipe. File permissions are discussed in two recipes: *Managing
    ACL file permissions* and *Managing POSIX file permissions*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置文件或目录的时间相关属性*教程说明了如何为文件分配时间属性。与此相关的还有其他属性，如文件所有权和权限。文件所有权在*管理文件所有权*教程中讨论。文件权限在两个教程中讨论：*管理ACL文件权限*和*管理POSIX文件权限*。'
- en: Creating files and directories
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件和目录
- en: The process of creating new files and directories is greatly simplified in Java
    7\. The methods implemented by the `Files` class are relatively intuitive and
    easy to incorporate into your code. In this recipe, we will cover how to create
    new files and directories using the `createFile` and `createDirectory` methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，创建新文件和目录的过程大大简化。`Files`类实现的方法相对直观，易于整合到您的代码中。在本教程中，我们将介绍如何使用`createFile`和`createDirectory`方法创建新文件和目录。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In our example, we are going to use several different methods to create a `Path`
    object that represents a file or directory. We will do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用几种不同的方法来创建代表文件或目录的`Path`对象。我们将执行以下操作：
- en: Create a `Path` object.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Path`对象。
- en: Create a directory using the `Files` class' `createDirectory` method.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Files`类的`createDirectory`方法创建目录。
- en: Create a file using the `Files` class' `createFile` method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Files`类的`createFile`方法创建文件。
- en: The `FileSystem` class' `getPath` method can be used to create a `Path` object
    as can the `Paths` class' `get` method. The `Paths` class' static `get` method
    returns an instance of a `Path` based on a string sequence or a `URI` object.
    The `FileSystem` class' `getPath` method also returns a `Path` object, but only
    uses a string sequence to identify the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystem`类的`getPath`方法可用于创建`Path`对象，`Paths`类的`get`方法也可以。`Paths`类的静态`get`方法基于字符串序列或`URI`对象返回`Path`的实例。`FileSystem`类的`getPath`方法也返回`Path`对象，但只使用字符串序列来标识文件。'
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code that creates a `Path` object for the directory `/home/test`
    in the `C` directory. Within a try block, invoke the `createDirectory` method
    with your `Path` object as the parameter. This method will throw an `IOException`
    if the path is invalid. Next, create a `Path` object for the file `newFile.txt`
    using the `createFile` method on this `Path` object, again catching the `IOException`
    as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`main`方法的控制台应用程序。在`main`方法中，添加以下代码，为`C`目录中的`/home/test`目录创建一个`Path`对象。在try块内，使用您的`Path`对象作为参数调用`createDirectory`方法。如果路径无效，此方法将抛出`IOException`。接下来，使用此`Path`对象上的`createFile`方法创建文件`newFile.txt`，再次捕获`IOException`如下：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the program. Your output should appear as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。您的输出应如下所示：
- en: '**Directory created successfully!**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录创建成功！**'
- en: '**File created successfully!**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件创建成功！**'
- en: Verify that the new file and directory exists in your filesystem. Next, add
    a catch block prior to the `IOException` after both methods, and catch a `FileAlreadyExistsException:`
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证新文件和目录是否存在于您的文件系统中。接下来，在两个方法之后添加一个`IOException`之前的catch块，并捕获`FileAlreadyExistsException`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you execute the program again, your output should appear as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您再次执行程序时，您的输出应如下所示：
- en: '**File or directory already exists!**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件或目录已存在！**'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first `Path` object was created and then used by the `createDirectory` method
    to create a new directory. After the second `Path` object was created, the `createFile`
    method was used to create a file within the directory, which had just been created.
    It is important to note that the `Path` object used in the file creation could
    not be instantiated before the directory was created, because it would have referenced
    an invalid path. This would have resulted in an `IOException`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Path`对象被创建，然后被`createDirectory`方法用于创建一个新目录。创建第二个`Path`对象后，使用`createFile`方法在刚刚创建的目录中创建了一个文件。重要的是要注意，在创建目录之前无法实例化用于文件创建的`Path`对象，因为它将引用无效的路径。这将导致`IOException`。
- en: When the `createDirectory` method is invoked, the system is directed to check
    for the existence of the directory first, and if it does not exist, create it.
    The `createFile` method works in a similar fashion. The method fails if the file
    already exists. We saw this when we caught the `FileAlreadyExistsException`. Had
    we not caught that exception, an `IOException` would have been thrown. Either
    way, the existing file would not be overwritten.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`createDirectory`方法时，系统首先检查目录是否存在，如果不存在，则创建。`createFile`方法的工作方式类似。如果文件已经存在，该方法将失败。当我们捕获`FileAlreadyExistsException`时，我们看到了这一点。如果我们没有捕获该异常，将抛出`IOException`。无论哪种方式，现有文件都不会被覆盖。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `createFile` and `createDirectory` methods are atomic in nature. The `createDirectories`
    method is available to create directories as discussed next. All three methods
    provide the option to pass file attribute parameters for more specific file creation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFile`和`createDirectory`方法在本质上是原子的。`createDirectories`方法可用于创建目录，如下所述。这三种方法都提供了传递文件属性参数以进行更具体文件创建的选项。'
- en: Using the createDirectories method to create a hierarchy of directories
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`createDirectories`方法创建目录层次结构
- en: 'The `createDirectories` method is used to create a directory and potentially
    other intermediate directories. In this example, we build upon the previous directory
    structure by adding a `subtest` and a `subsubtest` directory to the `test` directory.
    Comment out the previous code that created the directory and file and add the
    following code sequence:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDirectories`方法用于创建目录和可能的其他中间目录。在此示例中，我们通过向`test`目录添加`subtest`和`subsubtest`目录来构建先前的目录结构。注释掉之前创建目录和文件的代码，并添加以下代码序列：'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Verify that the operation succeeded by examining the resulting directory structure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查生成的目录结构来验证操作是否成功。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Creating temporary files and directories is covered in the *Managing temporary
    files and directories* recipe. The creation of symbolic files is illustrated in
    the *Managing symbolic links* recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建临时文件和目录在*管理临时文件和目录*中有所涉及。符号文件的创建在*管理符号链接*中有所说明。
- en: Controlling how a file is copied
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制文件复制的方式
- en: The process of copying files is also simplified in Java 7, and allows for control
    over the manner in which they are copied. The `Files` class' `copy` method supports
    this operation and is overloaded providing three techniques for copying which
    differ by their source or destination.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，文件复制的过程也变得更加简化，并允许控制复制的方式。`Files`类的`copy`方法支持此操作，并提供了三种不同的复制技术。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In our example, we are going to create a new file and then copy it to another
    target file. This process involves:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个新文件，然后将其复制到另一个目标文件。这个过程涉及：
- en: Creating a new file using the `createFile` method.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createFile`方法创建一个新文件。
- en: Creating a path for the destination file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为目标文件创建一个路径。
- en: Copying the file using the `copy` method.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`copy`方法复制文件。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence to create a new file. Specify two `Path` objects,
    one for your initial file and one for the location where it will be copied. Then
    add the `copy` method to copy that file to the destination location as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`main`方法的控制台应用程序。在`main`方法中，添加以下代码序列来创建一个新文件。指定两个`Path`对象，一个用于您的初始文件，另一个用于将其复制的位置。然后添加`copy`方法将该文件复制到目标位置，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execute the program. Your output should appear as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。您的输出应如下所示：
- en: '**File created successfully!**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件创建成功！**'
- en: '**File copied successfully!**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件复制成功！**'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `createFile` method created your initial file, and the `copy` method copied
    that file to the location specified by the `copiedFile` variable. If you were
    to attempt to run that code sequence twice in a row, you would have encountered
    an `IOException`, because the `copy` method will not, by default, replace an existing
    file. The `copy` method is overloaded. Use the copy method with the `java.lang.enum.StandardCopyOption`
    enumeration value of `REPLACE_EXISTING` to allow the file to be replaced, as shown
    below.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFile`方法创建了您的初始文件，`copy`方法将该文件复制到`copiedFile`变量指定的位置。如果您尝试连续两次运行该代码序列，您将遇到`IOException`，因为`copy`方法默认情况下不会替换现有文件。`copy`方法是重载的。使用带有`java.lang.enum.StandardCopyOption`枚举值`REPLACE_EXISTING`的`copy`方法，允许替换文件，如下所示。'
- en: 'The three enumeration values for `StandardCopyOption` are listed in the following
    table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardCopyOption`的三个枚举值列在下表中：'
- en: '| Value | Meaning |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ATOMIC_MOVE` | Perform the copy operation atomically |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `ATOMIC_MOVE` | 原子性地执行复制操作 |'
- en: '| `COPY_ATTRIBUTES` | Copy the source file attributes to the destination file
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `COPY_ATTRIBUTES` | 将源文件属性复制到目标文件 |'
- en: '| `REPLACE_EXISTING` | Replace the existing file if it already exists |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `REPLACE_EXISTING` | 如果已存在，则替换现有文件 |'
- en: 'Replace the `copy` method call in the previous example with the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码序列执行前面的示例中的`copy`方法调用替换：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the code executes, the file should be replaced. Another example of the
    use of the copy options is found in the *There's more..*. section of the *Moving
    a file and directory* recipe.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，文件应该被替换。在*还有更多..*部分的*移动文件和目录*配方中还有另一个使用复制选项的示例。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the source file and the destination file are the same, then the method completes,
    but no copy actually occurs. The `copy` method is not atomic in nature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源文件和目标文件相同，则该方法会完成，但实际上不会发生复制。`copy`方法不是原子的。
- en: 'There are two other overloaded `copy` methods. One copies a `java.io.InputStream`
    to a file and the other copies a file to a `java.io.OutputStream`. In this section,
    we will examine, in more depth, the processes of:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个重载的`copy`方法。一个是将`java.io.InputStream`复制到文件，另一个是将文件复制到`java.io.OutputStream`。在本节中，我们将更深入地研究以下过程：
- en: Copying a symbolic link file
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制符号链接文件
- en: Copying a directory
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制目录
- en: Copying an input stream to a file
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入流复制到文件
- en: Copying a file to an output stream
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件复制到输出流
- en: Copying a symbolic link file
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制符号链接文件
- en: When a symbolic link file is copied, the target of the symbolic link is copied.
    To illustrate this, create a symbolic link file called `users.txt` in the `music`
    directory to the `users.txt` file in the `docs` directory. This can be done either
    by using the process described in the *Managing symbolic links* recipe in [Chapter
    2](ch02.html "Chapter 2. Locating Files and Directories Using Paths"), *Locating
    Files and Directories Using Paths*, or using the methods illustrated in the *Managing
    symbolic links* recipe in this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当复制符号链接文件时，会复制符号链接的目标。为了说明这一点，在`music`目录中创建一个名为`users.txt`的符号链接文件，指向`docs`目录中的`users.txt`文件。可以通过使用[第2章](ch02.html
    "第2章。使用路径定位文件和目录")中描述的*管理符号链接*配方中的过程，即*使用路径定位文件和目录*，或者使用本章中所示的*管理符号链接*配方中的方法来完成。
- en: 'Use the following code sequence to perform the copy operation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码序列执行复制操作：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the code. You should get the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码。您应该得到以下输出：
- en: '**Symbolic link file copied successfully!**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号链接文件复制成功！**'
- en: Examine the resulting `music` directory structure. The `user2.txt` file has
    been added and is not connected to either the linked file or the original target
    file. Modification of the `user2.txt` does not affect the contents of the other
    two files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的`music`目录结构。`user2.txt`文件已添加，并且与链接文件或原始目标文件没有连接。修改`user2.txt`不会影响其他两个文件的内容。
- en: Copying a directory
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制目录
- en: 'When a directory is copied, an empty directory is created. The files in the
    original directory are not copied. The following code sequence illustrates this
    process:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当复制目录时，会创建一个空目录。原始目录中的文件不会被复制。以下代码序列说明了这个过程：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When this sequence is executed, you should get the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此序列时，您应该得到以下输出：
- en: '**Directory copied successfully!**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录复制成功！**'
- en: Examine the `tmp` directory. It should be empty as any files in the source directory
    are not copied.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`tmp`目录。它应该是空的，因为源目录中的任何文件都没有被复制。
- en: Copying an input stream to a file
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将输入流复制到文件
- en: The `copy` method has a convenient overloaded version that permits the creation
    of a new file based on the input from an `InputStream`. The first argument of
    this method differs from the original `copy` method, in that it is an instance
    of an `InputStream`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`方法有一个方便的重载版本，允许基于`InputStream`的输入创建新文件。该方法的第一个参数与原始`copy`方法不同，因为它是`InputStream`的实例。'
- en: 'The following example uses this method to copy the `jdk7.java.net` website
    to a file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用此方法将`jdk7.java.net`网站复制到文件中：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the code executes, you should get the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，您应该得到以下输出：
- en: '**Site copied successfully!**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点复制成功！**'
- en: A `java.lang.Object.URI` object was created to represent the website. Using
    the `URI` object instead of a `java.lang.Object.URL` object immediately avoids
    having to create a separate try-catch block to handle the `MalformedURLException`
    exception.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`java.lang.Object.URI`对象来表示网站。使用`URI`对象而不是`java.lang.Object.URL`对象立即避免了创建一个单独的try-catch块来处理`MalformedURLException`异常。
- en: The `URL` class' `openStream` method returns an `InputStream` which is used
    as the first parameter of the `copy` method. Notice the use of the try-with-resource
    block. This try block is new to Java 7 and is illustrated in the *Using the try-with-resource
    block to improve exception handling code* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL`类的`openStream`方法返回一个`InputStream`，该流作为`copy`方法的第一个参数使用。请注意使用try-with-resource块。这个try块是Java
    7中的新功能，并在[第1章](ch01.html "第1章。Java语言改进")的*使用try-with-resource块改进异常处理代码*中有详细说明，*Java语言改进*。'
- en: The `copy` method was then executed. The new file can now be opened with a browser
    or otherwise can be processed as needed. Notice that the method returns a long
    value representing the number of bytes written.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行了`copy`方法。现在可以使用浏览器打开新文件，或者根据需要进行处理。请注意，该方法返回一个表示写入的字节数的长整型值。
- en: Copying a file to an output stream
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文件复制到输出流
- en: 'The third overloaded version of the `copy` method will open a file and write
    its contents to an `OutputStream`. This can be useful when the content of a file
    needs to be copied to a non-file object such as a `PipedOutputStream`. It can
    also be useful when communicating to other threads or writing to an array of bytes
    as illustrated here. In this example, the content of the `users.txt` file is copied
    to an instance of a `ByteArrayOutputStream`. Its `toByteArray` method is then
    used to populate an array as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`方法的第三个重载版本将打开一个文件并将其内容写入`OutputStream`。当需要将文件的内容复制到非文件对象（如`PipedOutputStream`）时，这可能很有用。当与其他线程通信或写入字节数组时，这也可能很有用，如本例所示。在这个例子中，`users.txt`文件的内容被复制到一个`ByteArrayOutputStream`的实例中。然后使用它的`toByteArray`方法来填充一个数组，如下所示：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute this sequence. The output will depend on the contents of your file,
    but should be similar to the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个序列。输出将取决于您的文件内容，但应该类似于以下内容：
- en: '**The contents of users.txt**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**users.txt的内容**'
- en: '**Bob**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bob**'
- en: '**Jennifer**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jennifer**'
- en: '**Sally**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sally**'
- en: '**Tom**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tom**'
- en: '**Ted**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ted**'
- en: Notice the use of the try-with-resources block that handles the opening and
    closing of the file. It is always a good idea to close the `OutputStream` when
    the copy operation is complete or exceptions occur. The try-with-resources block
    handles this nicely. The method may block until the operation is complete in certain
    situations. Much of its behavior is implementation-specific. Also, the output
    stream may need to be flushed since it implements the `Flushable` interface. Notice
    that the method returns a long value representing the number of bytes written.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用try-with-resources块来处理文件的打开和关闭。在复制操作完成或发生异常时关闭`OutputStream`总是一个好主意。try-with-resources块很好地处理了这个问题。在某些情况下，该方法可能会阻塞，直到操作完成。它的行为大部分是特定于实现的。此外，输出流可能需要刷新，因为它实现了`Flushable`接口。请注意，该方法返回一个表示写入的字节数的长整型值。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Managing symbolic links* recipe for more details on working with symbolic
    links.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用符号链接的更多详细信息，请参阅*管理符号链接*食谱。
- en: Managing temporary files and directories
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理临时文件和目录
- en: The process of creating temporary files and directories can be an essential
    part of many applications. Temporary files may be used for intermediate data or
    as a temporary store to be cleaned up later. The process of managing temporary
    files and directories can be accomplished simply via the `Files` class. In this
    recipe, we will cover how to create temporary files and directories using the
    `createTempDirectory` and `createTempFile` methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建临时文件和目录的过程可能是许多应用程序的重要部分。临时文件可以用于中间数据或作为稍后清理的临时存储。通过`Files`类可以简单地完成管理临时文件和目录的过程。在本食谱中，我们将介绍如何使用`createTempDirectory`和`createTempFile`方法创建临时文件和目录。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In our example, we are going to create a temporary directory and then create
    a temporary file within the directory as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个临时目录，然后在目录中创建一个临时文件，如下所示：
- en: Create `Path` objects representing the temporary file and directory.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建代表临时文件和目录的`Path`对象。
- en: Create a temporary directory using the `createTempDirectory` method.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createTempDirectory`方法创建一个临时目录。
- en: Create a temporary file using the `createTempFile` method.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createTempFile`方法创建一个临时文件。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application with a `main` method. In the `main` method, create
    a `Path` object `rootDirectory` using the `getPath` method. Invoke the `createTempDirectory`
    method using `rootDirectory` as the first argument, and an empty string as the
    second argument. Then use the `toString` method to convert the returning `Path`
    object `dirPath` to a `String` and print it to the screen. Next, add the `createTempFile`
    method using `dirPath` as the first argument with empty strings as the second
    and third arguments. Use the `toString` method again to print out this resulting
    path as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`main`方法的控制台应用程序。在`main`方法中，使用`getPath`方法创建一个`Path`对象`rootDirectory`。使用`rootDirectory`作为第一个参数，空字符串作为第二个参数调用`createTempDirectory`方法。然后使用`toString`方法将返回的`Path`对象`dirPath`转换为`String`并打印到屏幕上。接下来，使用`dirPath`作为第一个参数，空字符串作为第二和第三个参数添加`createTempFile`方法。再次使用`toString`方法打印出这个结果路径，如下所示：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code sequence will result in an output similar to the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码序列将产生类似于以下内容的输出：
- en: '**Temporary directory created successfully!**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时目录创建成功！**'
- en: '**C:\home\docs\7087436262102989339**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**C:\home\docs\7087436262102989339**'
- en: '**Temporary file created successfully!**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时文件创建成功！**'
- en: '**C:\home\docs\7087436262102989339\3473887367961760381**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**C:\home\docs\7087436262102989339\3473887367961760381**'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `createTempDirectory` method creates an empty directory and returns a `Path`
    object representing the location of this new directory. Likewise, the `createTempFile`
    method creates an empty file and returns a `Path` object representing this new
    file. In our previous example, we used the `toString` method to see the path where
    our directory and file were created. The previous numeric directory and filenames
    are assigned by the system and are platform-specific.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTempDirectory`方法创建一个空目录并返回代表这个新目录位置的`Path`对象。同样，`createTempFile`方法创建一个空文件并返回代表这个新文件的`Path`对象。在我们之前的例子中，我们使用`toString`方法来查看我们的目录和文件创建的路径。之前的数字目录和文件名由系统分配，并且是特定于平台的。'
- en: This `createTempDirectory` method requires at least two parameters, namely,
    the `Path` object directing the location for the new directory, and a `String`
    variable specifying the directory prefix. In our previous example, we left the
    prefix blank. However, if we had wanted to specify text to precede the filename
    assigned by the system, the second variable could have been populated with this
    prefix string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`createTempDirectory`方法至少需要两个参数，即指向新目录位置的`Path`对象和指定目录前缀的`String`变量。在我们之前的例子中，我们留空了前缀。但是，如果我们想要指定文本以在系统分配的文件名之前出现，第二个变量可以用这个前缀字符串填充。
- en: The `createTempFile` method works in a similar manner as the `createTempDirectory`
    method, and had we wanted to assign a prefix to our temporary file, we could have
    used the second parameter to specify the string. The third parameter of this method
    could have also been used to specify a suffix, or file type, for our file, such
    as `.txt`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTempFile`方法的工作方式与`createTempDirectory`方法类似，如果我们想要为临时文件分配一个前缀，我们可以使用第二个参数来指定字符串。此方法的第三个参数也可以用来指定文件的后缀或类型，例如`.txt`。'
- en: It is important to note that, although in our example we specified the `Path`
    in which we wanted our directory and file created, there is another version of
    each method in which the initial argument, the `Path` object, could be omitted,
    and the directory and/or file would be created in the system's default temporary
    directory. Additionally, these methods do not check for the file or directory's
    existence before creating them, and will overwrite any existing file or directory
    with the same temporary, system-assigned name.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管在我们的例子中我们指定了我们想要创建目录和文件的`Path`，但每种方法还有另一个版本，其中初始参数，`Path`对象，可以被省略，目录和/或文件将被创建在系统的默认临时目录中。此外，这些方法在创建文件或目录之前不会检查文件或目录的存在，并且会覆盖具有相同临时、系统分配名称的任何现有文件或目录。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: File attribute names can also be passed to the overloaded `createTempDirectory`
    or `createTempFile` methods. These attributes are optional, but can be used to
    specify how the temporary files will be handled, such as whether the file should
    be deleted upon closing. The creation of a file attribute is described in the
    *There's more..*. section of the *Managing POSIX file permissions* recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 文件属性名称也可以传递给重载的`createTempDirectory`或`createTempFile`方法。这些属性是可选的，但可以用来指定临时文件的处理方式，例如文件是否应在关闭时被删除。文件属性的创建在*更多内容*的*管理POSIX文件权限*配方的部分中描述。
- en: The `createTempDirectory` and the `createTempFile` methods are intended to have
    a limited existence. If it is desirable to delete these files or directories automatically,
    a shutdown hook or the `java.io.File` class' `deleteOnExit` method can be used.
    These two techniques will result in the deletion of the element when the application
    or the JVM terminates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTempDirectory`和`createTempFile`方法的存在是有限的。如果希望自动删除这些文件或目录，可以使用关闭挂钩或`java.io.File`类的`deleteOnExit`方法。这两种技术将导致在应用程序或JVM终止时删除元素。'
- en: Setting time-related attributes of a file or directory
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文件或目录的与时间相关的属性
- en: The timestamp for a file can be critical for some applications. For example,
    the order in which operations execute may be dependent on the time a file was
    last updated. There are three dates supported by the `BasicFileAttributeView:`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的时间戳对于某些应用程序可能至关重要。例如，操作执行的顺序可能取决于文件的最后更新时间。`BasicFileAttributeView`支持三种日期：
- en: The last modified time
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后修改时间
- en: The last access time
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后访问时间
- en: The creation time
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时间
- en: They can be set using the `BasicFileAttributeView` interface's `setTimes` method.
    As we will see in the *There's more..*. section, the `Files` class can be used
    to set or get only the last modified time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以使用`BasicFileAttributeView`接口的`setTimes`方法进行设置。正如我们将在*更多内容*部分看到的，`Files`类可以用来设置或仅获取最后修改时间。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to set the times using the `setTimes` method. We need to do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`setTimes`方法设置时间，我们需要做以下操作：
- en: Obtain a `Path` object, which represents the file of interest.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取代表感兴趣文件的`Path`对象。
- en: Obtain a `BasicFileAttributeView` object.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`BasicFileAttributeView`对象。
- en: Create `FileTime` objects for the times needed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所需的时间创建`FileTime`对象。
- en: Use these `FileTime` objects as arguments of the `setTimes` method.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些`FileTime`对象作为`setTimes`方法的参数。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application using the following `main` method. We will
    update the last modified time of our favorite file `users.txt` to the current
    time:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`main`方法创建一个新的控制台应用程序。我们将更新我们最喜欢的文件`users.txt`的最后修改时间为当前时间：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute the application. Unless you have access to a time machine, or have
    otherwise manipulated your system''s clock, your output should reflect a time
    later than the time shown as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。除非您有时间机器的访问权限，或者以其他方式操纵了系统的时钟，否则您的输出应该反映出比以下显示的时间更晚的时间：
- en: '**2011-09-24T21:34:55.012Z**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**2011-09-24T21:34:55.012Z**'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Path` was first created for the `users.txt` file. Next, an instance of the
    `BasicFileAttributeView` interface was obtained using the `getFileAttributeView`
    method. A try block was used to catch any `IOExceptions` that might be thrown
    by the `readAttributes` or `setTimes` methods.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为 `users.txt` 文件创建了一个 `Path`。接下来，使用 `getFileAttributeView` 方法获得了 `BasicFileAttributeView`
    接口的一个实例。使用 try 块来捕获 `readAttributes` 或 `setTimes` 方法可能抛出的任何 `IOExceptions`。
- en: Within the try block, `FileTime` objects were created for each of the three
    types of time. The `lastModifedTime` and `createTime` times were not changed for
    the file. These were obtained using the corresponding methods of the `BasicFileAttributes`
    class, which was obtained using the `view` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 try 块中，为三种类型的时间创建了 `FileTime` 对象。文件的 `lastModifedTime` 和 `createTime` 时间没有改变。这些是使用
    `BasicFileAttributes` 类的相应方法获得的，该类是使用 `view` 方法获得的。
- en: The `currentTime` long variable was assigned the current time expressed in milliseconds.
    Its value was obtained using the `getTimeInMillis` method executed against an
    instance of the `Calendar` class. The three `FileTime` objects were then used
    as arguments to the `setTimes` method, effectively setting these time values.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTime` 长变量被赋予以毫秒表示的当前时间。它的值是使用 `Calendar` 类的实例执行 `getTimeInMillis` 方法获得的。然后，三个
    `FileTime` 对象被用作 `setTimes` 方法的参数，有效地设置了这些时间值。'
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is more to the use of the `FileTime` class than presented so far. In
    addition, the `Files` class provides alternative approaches for maintaining times.
    Here we will further explore the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileTime` 类的使用还不止以上所述。此外，`Files` 类提供了维护时间的替代方法。在这里，我们将进一步探讨以下内容： '
- en: Understanding the `FileTime` class
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `FileTime` 类
- en: Using the `Files` class' `setLastModifiedTime` to maintain the last modified
    time
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Files` 类的 `setLastModifiedTime` 来维护最后修改时间
- en: Using the `Files` class' `setAttribute` method to set individual attributes
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Files` 类的 `setAttribute` 方法来设置单个属性
- en: Understanding the FileTime class
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 `FileTime` 类
- en: 'The `java.nio.file.attribute.FileTime` class represents the time for use with
    several of the `java.nio` package methods. To create a `FileTime` object, we need
    to use either of the following two static `FileTime` methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.attribute.FileTime` 类表示用于 `java.nio` 包方法的时间。要创建一个 `FileTime`
    对象，我们需要使用以下两个静态 `FileTime` 方法之一：'
- en: The `from` method, which accepts a long number representing a duration and a
    `TimeUnit` object representing a unit of time measurement
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from` 方法，接受一个表示持续时间的长数字和一个表示时间测量单位的 `TimeUnit` 对象'
- en: The `fromMillis` method, which accepts a long argument representing the number
    of milliseconds based on the epoch
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromMillis` 方法，接受一个基于纪元的毫秒数的长参数'
- en: '`TimeUnit` is an enumeration found in the `java.util.concurrent` package. It
    represents a time duration as defined in the following table. It is used in conjunction
    with another parameter whose combination represents a time duration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeUnit` 是 `java.util.concurrent` 包中的一个枚举。它表示如下表中定义的时间持续时间。它与另一个参数结合使用，其组合表示时间持续时间：'
- en: '| Enumeration Value | Meaning |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 枚举值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| NANOSECONDS | One thousandth of a microsecond |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 纳秒 | 千分之一微秒 |'
- en: '| MICROSECONDS | One thousandth of a millisecond |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 微秒 | 千分之一毫秒 |'
- en: '| MILLISECONDS | One thousandth of a second |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 毫秒 | 千分之一秒 |'
- en: '| SECONDS | A second |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 秒 | 一秒 |'
- en: '| MINUTES | Sixty seconds |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 | 六十秒 |'
- en: '| HOURS | Sixty minutes |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 小时 | 六十分钟 |'
- en: '| DAYS | Twenty four hours |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 天 | 二十四小时 |'
- en: The `from` method returns a `TimeUnit` object. Its value is computed by adding
    the first long argument, whose unit of measure is specified by the second `TimeUnit`
    argument, to the epoch.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`from` 方法返回一个 `TimeUnit` 对象。它的值是通过将第一个长参数（其度量单位由第二个 `TimeUnit` 参数指定）加到纪元得到的。'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The epoch is 1970-01-01T00:00:00Z, which is the base time used for specifying
    time on most computers. This base time represents midnight, **Coordinate Universal
    Time** on January 1, 1970.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 纪元是1970-01-01T00:00:00Z，这是大多数计算机上用于指定时间的基本时间。这个基本时间代表1970年1月1日的**协调世界时**午夜。
- en: 'For example, the `from` method can be used to present a point in time, which
    is 1000 days from the epoch using the following code sequence:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`from` 方法可以用来表示一个时间点，即从纪元开始的1000天，使用以下代码序列：
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When executed you should get the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时应该得到以下输出：
- en: '**1972-09-27T00:00:00Z**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**1972-09-27T00:00:00Z**'
- en: 'The `fromMillis` method is used to create a `FileTime` object, whose time is
    represented by adding its argument to the epoch where the argument is a long number
    representing a value in milliseconds. If we used the following `fromMillis` method
    instead of the `from` method as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromMillis` 方法用于创建一个 `FileTime` 对象，其时间是通过将其参数加到纪元得到的，其中参数是以毫秒表示的长数字。如果我们使用以下
    `fromMillis` 方法而不是如下所示的 `from` 方法：'
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will get the same results. Notice that the first argument is a long literal,
    which forces the result of the expression to be a long number. If we did not promote
    our results to be long values, we would have received an integer value, which
    would have resulted in overflow and an incorrect date. The first argument of either
    method can be negative.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到相同的结果。注意，第一个参数是一个长整型字面量，这迫使表达式的结果为长整数。如果我们没有将结果提升为长整数值，我们将得到一个整数值，这将导致溢出和错误的日期。任何方法的第一个参数都可以是负数。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details regarding the use of time in Java, see [http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html](http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Java中使用时间的更多细节，请参阅[http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html](http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html)。
- en: Using the Files class' setLastModifiedTime to maintain the last modified time
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `Files` 类的 `setLastModifiedTime` 来维护最后修改时间
- en: 'The `Files` class'' `getLastModifiedTime` and `setLastModifiedTime` methods
    provide an alternative approach for setting the last modified attribute of a file.
    In the following code sequence, the `setLastModifiedTime` method uses the `lastModifedTime`
    object to set the time as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的`getLastModifiedTime`和`setLastModifiedTime`方法提供了设置文件最后修改属性的另一种方法。在下面的代码序列中，`setLastModifiedTime`方法使用`lastModifedTime`对象来设置时间，如下所示：'
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Files` class'' `getLastModifiedTime` returns a `FileTime` object. We could
    have this method to assign a value to the `lastModifedTime` variable as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的`getLastModifiedTime`返回一个`FileTime`对象。我们可以使用这个方法将一个值赋给`lastModifedTime`变量，如下所示：'
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The method has an optional `LinkOption` argument that indicates whether symbolic
    links should be followed or not.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法有一个可选的`LinkOption`参数，指示是否应该跟随符号链接。
- en: Using the Files class' setAttribute method to set individual attributes
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Files类的setAttribute方法来设置单个属性
- en: 'The `setAttribute` method provides a flexible and dynamic approach for setting
    certain file attributes. To set the last modified time, we could have used the
    following code sequence:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAttribute`方法提供了一种灵活和动态的方法来设置某些文件属性。要设置最后修改时间，我们可以使用以下代码序列：'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The *Obtaining a single attribute at a time using the getAttribute method* recipe
    in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*, details the other attributes that
    can be set.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 获取文件和目录信息")中的*使用getAttribute方法逐个获取属性*配方详细介绍了可以设置的其他属性。'
- en: See also
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Managing symbolic links* recipe discusses the use of symbolic links.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理符号链接*配方讨论了符号链接的使用。'
- en: Managing file ownership
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件所有权
- en: The owner of a file or directory can be modified after the file has been created.
    This is accomplished by using the `java.nio.file.attribute.FileOwnerAttributeView`
    interface's `setOwner` method, which can be useful when ownerships change and
    need to be controlled programmatically.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 文件或目录的所有者可以在文件创建后进行修改。这是通过使用`java.nio.file.attribute.FileOwnerAttributeView`接口的`setOwner`方法来实现的，当所有权发生变化并需要以编程方式进行控制时，这将非常有用。
- en: A `java.nio.file.attribute.UserPrincipal` object is used to represent a user.
    A `Path` object is used to represent a file or directory. Using these two objects
    with the `Files` class' `setOwner` method enables us to maintain file ownerships.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.nio.file.attribute.UserPrincipal`对象表示一个用户。使用`Path`对象表示一个文件或目录。将这两个对象与`Files`类的`setOwner`方法一起使用，可以维护文件的所有权。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to change the owner of a file or directory:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改文件或目录的所有者：
- en: Obtain a `Path` object, which represents the file or directory.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个代表文件或目录的`Path`对象。
- en: Use the `Path` as the argument to the `getFileAttributeView` method.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Path`作为`getFileAttributeView`方法的参数。
- en: Create a `UserPrincipal` object representing the new owner.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表新所有者的`UserPrincipal`对象。
- en: Use the `FileOwnerAttributeView` interface's `setOwner` method to change the
    file's owner.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FileOwnerAttributeView`接口的`setOwner`方法来更改文件的所有者。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we will assume that the current owner of the `users.txt` file
    is `richard`. We will change the owner to a user called `jennifer`. To do this,
    create a new user on your system called `jennifer`. Create a new console application
    with the following `main` method. In the method, we will use the `FileOwnerAttributeView`
    and a `UserPrincipal` object to change the owner as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将假设`users.txt`文件的当前所有者是`richard`。我们将把所有者更改为一个名为`jennifer`的用户。为此，在系统上创建一个名为`jennifer`的新用户。创建一个包含以下`main`方法的新控制台应用程序。在该方法中，我们将使用`FileOwnerAttributeView`和`UserPrincipal`对象来更改所有者，如下所示：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to modify the ownership of a file, we must have appropriate privileges.
    The introduction to this chapter explains how to get administrator privileges.
    When the application is executed using Windows 7, the output should reflect the
    PC name and the file''s owners shown as follows. The PC name is separated from
    the owner with a backslash:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修改文件的所有权，我们必须拥有适当的权限。本章的介绍解释了如何获取管理员权限。当应用程序在Windows 7上执行时，输出应该反映出PC名称和文件所有者，如下所示。PC名称与所有者之间用反斜杠分隔：
- en: '**Owner: Richard-PC\Richard**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有者：Richard-PC\Richard**'
- en: '**Owner: Richard-PC\Jennifer**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有者：Richard-PC\Jennifer**'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Path` was first created for the `users.txt` file. Next, an instance of the
    `FileOwnerAttributeView` interface was obtained using the `getFileAttributeView`
    method. Within the try block, a `UserPrincipalLookupService` object was created
    using the default `FileSystem` class' `getUserPrincipalLookupService` method.
    The `lookupPrincipalByName` method was passed the string `jennifer`, which returned
    a `UserPrincipal` object representing that user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为`users.txt`文件创建了一个`Path`。接下来，使用`getFileAttributeView`方法获取了`FileOwnerAttributeView`接口的一个实例。在try块内，使用默认的`FileSystem`类的`getUserPrincipalLookupService`方法创建了一个`UserPrincipalLookupService`对象。`lookupPrincipalByName`方法传递了字符串`jennifer`，返回了代表该用户的`UserPrincipal`对象。
- en: The last step was to pass the `UserPrincipal` object to the `setOwner` method.
    It then used the `getOwner` method to retrieve the current owner verifying the
    change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将`UserPrincipal`对象传递给`setOwner`方法。然后使用`getOwner`方法检索当前所有者以验证更改。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Any interface derived from `FileOwnerAttributeView` can use the `getOwner` or
    `setOwner` methods. These include the `AclFileAttributeView` and `PosixFileAttributeView`
    interfaces. In addition, the `Files` class' `setOwner` method can also be used
    to change ownership of a file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从`FileOwnerAttributeView`派生的任何接口都可以使用`getOwner`或`setOwner`方法。这些包括`AclFileAttributeView`和`PosixFileAttributeView`接口。此外，`Files`类的`setOwner`方法也可以用于更改文件的所有权。
- en: Using the Files class' setOwner method
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Files类的setOwner方法
- en: The `Files` class' `setOwner` method works in the same way as the `FileOwnerAttributeView`
    interfaces' `setOwner` method. It differs in that it has two arguments, a `Path`
    object representing the file and a `UserPrincipal` object. The following sequence
    illustrates the process of setting the owner of the `users.txt` file to `jennifer:`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的`setOwner`方法与`FileOwnerAttributeView`接口的`setOwner`方法相同。不同之处在于它有两个参数，一个表示文件的`Path`对象和一个`UserPrincipal`对象。以下序列说明了将`users.txt`文件的所有者设置为`jennifer`的过程：'
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Managing ACL file permissions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理ACL文件权限
- en: In this recipe, we will examine how ACL permissions can be set. The ability
    to set these permissions is important for many applications. For example, when
    we need to control who can modify or execute a file, we can affect this change
    programmatically. What we can change is indicated by the `AclEntryPermission`
    enumeration values listed later.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将研究如何设置ACL权限。设置这些权限的能力对许多应用程序很重要。例如，当我们需要控制谁可以修改或执行文件时，我们可以通过编程方式影响这种变化。我们可以改变的内容由稍后列出的`AclEntryPermission`枚举值表示。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To set a new ACL permission for a file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为文件设置新的ACL权限：
- en: Create a `Path` object for the file whose attributes we want to change.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要更改其属性的文件创建`Path`对象。
- en: Obtain an `AclFileAttributeView` for that file.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取该文件的`AclFileAttributeView`。
- en: Obtain a `UserPrincipal` object for the user.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户获取一个`UserPrincipal`对象。
- en: Obtain a list of ACL entries currently assigned to the file.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前分配给文件的ACL条目列表。
- en: Create a new `AclEntry.Builder` object holding the permission that we want to
    add.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个持有我们要添加的权限的新`AclEntry.Builder`对象。
- en: Add the permission to the ACL list.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将权限添加到ACL列表中。
- en: Use the `setAcl` method to replace the current ACL list with a new one.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setAcl`方法用新的ACL列表替换当前的ACL列表。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new console application with the following `main` method. In this
    method, we will initially simply display the current ACL list for the file `users.txt`
    as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`main`方法创建一个新的控制台应用程序。在这个方法中，我们将首先简单地显示文件`users.txt`的当前ACL列表，如下所示：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To illustrate the process of adding and deleting ACL attributes, we will use
    a series of helper methods:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明添加和删除ACL属性的过程，我们将使用一系列辅助方法：
- en: '`displayAclEntries:` This displays the principal and entry type and then calls
    the other two helper methods'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayAclEntries:` 显示主体和条目类型，然后调用其他两个辅助方法'
- en: '`displayEntryFlags:` This displays the entry flags if present'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayEntryFlags:` 如果存在，显示条目标志'
- en: '`displayPermissions:` This displays the entry permissions if any'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`displayPermissions:` 如果有的话，显示条目权限'
- en: 'Add the methods as shown in the following code to your application:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码向应用程序添加方法：
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The ACL list contains the ACL entries for a file. When the `displayAclEntries`
    method is executed, it will display the number of entries as a convenience and
    then each entry will be separated by a blank line. The following illustrates a
    possible list for the `users.txt` file:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ACL列表包含文件的ACL条目。当执行`displayAclEntries`方法时，它将方便地显示条目数量，然后每个条目将用空行分隔。以下是`users.txt`文件可能的列表：
- en: '**Owner: Richard-PC\Richard**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者：Richard-PC\Richard
- en: '**ACL Entry List size: 4**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ACL条目列表大小：4
- en: '**User Principal Name: BUILTIN\Administrators**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主体名称：BUILTIN\Administrators
- en: '**ACL Entry Type: ALLOW**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ACL条目类型：允许
- en: '**No ACL Entry Flags present**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ACL条目标志
- en: '**Permissions**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 权限
- en: '**READ_DATA DELETE READ_NAMED_ATTRS READ_ATTRIBUTES WRITE_OWNER DELETE_CHILD
    WRITE_DATA APPEND_DATA SYNCHRONIZE EXECUTE WRITE_ATTRIBUTES WRITE_ACL WRITE_NAMED_ATTRS
    READ_ACL**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据 删除 读取命名属性 读取属性 写入所有者 删除子项 写入数据 追加数据 同步 执行 写入属性 写入ACL 写入命名属性 读取ACL
- en: '**User Principal Name: NT AUTHORITY\SYSTEM**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主体名称：NT AUTHORITY\SYSTEM
- en: '**ACL Entry Type: ALLOW**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ACL条目类型：允许
- en: '**No ACL Entry Flags present**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ACL条目标志
- en: '**Permissions**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 权限
- en: '**READ_DATA DELETE READ_NAMED_ATTRS READ_ATTRIBUTES WRITE_OWNER DELETE_CHILD
    WRITE_DATA APPEND_DATA SYNCHRONIZE EXECUTE WRITE_ATTRIBUTES WRITE_ACL WRITE_NAMED_ATTRS
    READ_ACL**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据 删除 读取命名属性 读取属性 写入所有者 删除子项 写入数据 追加数据 同步 执行 写入属性 写入ACL 写入命名属性 读取ACL
- en: '**User Principal Name: BUILTIN\Users**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主体名称：BUILTIN\用户
- en: '**ACL Entry Type: ALLOW**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ACL条目类型：允许
- en: '**No ACL Entry Flags present**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ACL条目标志
- en: '**Permissions**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 权限
- en: '**READ_DATA SYNCHRONIZE EXECUTE READ_NAMED_ATTRS READ_ATTRIBUTES READ_ACL**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据 同步 执行 读取命名属性 读取属性 读取ACL
- en: '**User Principal Name: NT AUTHORITY\Authenticated Users**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主体名称：NT AUTHORITY\已验证用户
- en: '**ACL Entry Type: ALLOW**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ACL条目类型：允许
- en: '**No ACL Entry Flags present**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 没有ACL条目标志
- en: '**Permissions**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 权限
- en: '**APPEND_DATA READ_DATA DELETE SYNCHRONIZE EXECUTE READ_NAMED_ATTRS READ_ATTRIBUTES
    WRITE_ATTRIBUTES WRITE_NAMED_ATTRS READ_ACL WRITE_DATA**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 追加数据 读取数据 删除 同步 执行 读取命名属性 读取属性 写入属性 写入命名属性 读取ACL 写入数据
- en: 'Next, use the `UserPrincipalLookupService` class'' `lookupService` method to
    return an instance of the `UserPrincipalLookupService` class. Use its `lookupPrincipalByName`
    method to return a `UserPrincipal` object based on a user''s name. Add the following
    code after the `displayAclEntries` method is called:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`UserPrincipalLookupService`类的`lookupService`方法返回`UserPrincipalLookupService`类的实例。使用它的`lookupPrincipalByName`方法根据用户名称返回一个`UserPrincipal`对象。在调用`displayAclEntries`方法之后添加以下代码：
- en: '[PRE20]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, add the following code to create and set up an `AclEntry.Builder` object.
    This will be used to add `WRITE_ACL and DELETE` permissions for the user. Add
    the entry to the ACL list and use the `setAcl` method to attach it to the current
    file as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码来创建和设置一个`AclEntry.Builder`对象。这将用于为用户添加`WRITE_ACL和DELETE`权限。将条目添加到ACL列表，并使用`setAcl`方法将其附加到当前文件，如下所示：
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the application. In order to modify some ACL attributes of a file,
    we must have the appropriate privileges. The introduction to this chapter gives
    the details of how to run the application as the administrator. Next, comment
    out the code that adds the ACL entry and verify that the ACL entry has been made.
    You should see the following entry added to the list:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。为了修改文件的一些ACL属性，我们必须具有适当的权限。本章的介绍详细介绍了如何以管理员身份运行应用程序的细节。接下来，注释掉添加ACL条目的代码，并验证是否已添加ACL条目。您应该看到以下条目添加到列表中：
- en: '**ACL Entry List size: 5**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACL条目列表大小：5**'
- en: '**User Principal Name: BUILTIN\Users**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户主体名称：BUILTIN\Users**'
- en: '**ACL Entry Type: ALLOW**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACL条目类型：允许**'
- en: '**No ACL Entry Flags present**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有ACL条目标志存在**'
- en: '**Permissions**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限**'
- en: '**WRITE_ACL DELETE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**WRITE_ACL DELETE**'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` method, we created the `Path` object, and then used it to obtain
    an instance of the `java.nio.file.attribute.AclFileAttributeView` interface. The
    file represented by the `Path` object was the `users.txt` file. The `AclFileAttributeView`
    object can be used for several purposes. Here, we were only interested in using
    its `getAcl` method to return a list of the ACL attributes associated with the
    file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们创建了`Path`对象，然后使用它来获取`java.nio.file.attribute.AclFileAttributeView`接口的实例。`Path`对象表示的文件是`users.txt`文件。`AclFileAttributeView`对象可以用于多种目的。在这里，我们只对使用其`getAcl`方法返回与文件关联的ACL属性列表感兴趣。
- en: We displayed the list of current ACLs only to see what they were, and to eventually
    verify that the attributes for the file have been changed. ACL attributes are
    associated with a user. In this example, we created a `UserPrincipal` object that
    represented users.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只显示当前ACL的列表，以查看它们是什么，并最终验证文件的属性是否已更改。ACL属性与用户关联。在这个例子中，我们创建了一个代表用户的`UserPrincipal`对象。
- en: 'A new ACL entry can be created using the `build` method of the `java.nio.file.attribute.AclEntry.Builder`
    class. The static `newBuilder` method created an instance of an `AclEntry.Builder`
    class. The `setPrincipal` method was executed to set users as the principal for
    the attribute. The `setPermissions` method takes either a set of `AclEntryPermission`
    objects or a variable number of `AclEntryPermission` objects. In this example,
    we used a list consisting of two permissions separated by a comma: `AclEntryPermission.WRITE_ACL`
    and `AclEntryPermission.DELETE`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`java.nio.file.attribute.AclEntry.Builder`类的`build`方法创建新的ACL条目。静态的`newBuilder`方法创建了`AclEntry.Builder`类的一个实例。执行`setPrincipal`方法将用户设置为属性的主体。`setPermissions`方法接受一组`AclEntryPermission`对象或可变数量的`AclEntryPermission`对象。在这个例子中，我们使用了一个由逗号分隔的两个权限组成的列表：`AclEntryPermission.WRITE_ACL`和`AclEntryPermission.DELETE`。
- en: The `AclEntry.Builder` object was then added to the existing ACL for the file.
    The entry was added at the beginning of the list. The last step was to use the
    `setAcl` method to replace the old ACL list with this new one.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`AclEntry.Builder`对象添加到文件的现有ACL中。条目被添加到列表的开头。最后一步是使用`setAcl`方法用新的ACL列表替换旧的ACL列表。
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To remove an ACL attribute, we need to obtain the current list and then identify
    the position of the attribute that we want to remove. We can use the `java.util.List`
    interface's `remove` method to remove that item. The `setAcl` method can then
    be used to replace the old list with the new one.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除ACL属性，我们需要获取当前列表，然后确定要删除的属性的位置。我们可以使用`java.util.List`接口的`remove`方法来删除该项。然后可以使用`setAcl`方法用新列表替换旧列表。
- en: 'ACL attributes are explained in more detail in the **RFC 3530: Network File
    System (NFS) version 4 Protocol**. The following tables provide additional information
    and insight into the ACL permissions that are available. The enumeration `AclEntryType`
    has the following values:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'ACL属性在**RFC 3530: Network File System (NFS) version 4 Protocol**中有更详细的解释。以下表格提供了有关可用ACL权限的附加信息和见解。枚举`AclEntryType`具有以下值：'
- en: '| Value | Meaning |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ALARM` | Results in an alarm being generated in a system-specific manner,
    when an attempt is made to access the attributes specified |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `ALARM` | 在尝试访问指定属性时，以系统特定的方式生成警报 |'
- en: '| `ALLOW` | Grants permissions |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `ALLOW` | 授予权限 |'
- en: '| `AUDIT` | Logs the access requested in a system-dependent way, when an attempt
    is made to access the attributes specified |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `AUDIT` | 在尝试访问指定属性时，以系统相关的方式记录所请求的访问 |'
- en: '| `DENY` | Denies access |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `DENY` | 拒绝访问 |'
- en: 'The `AclEntryPermission` enumeration values are summarized in the table that
    follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`AclEntryPermission`枚举值总结如下表所示：'
- en: '| Value | Meaning |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `APPEND_DATA` | Ability to append data to a file |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `APPEND_DATA` | 能够向文件追加数据 |'
- en: '| `DELETE` | Ability to delete the file |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 能够删除文件 |'
- en: '| `DELETE_CHILD` | Ability to delete a file or directory within a directory
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE_CHILD` | 能够删除目录中的文件或目录 |'
- en: '| `EXECUTE` | Ability to execute a file |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `EXECUTE` | 能够执行文件 |'
- en: '| `READ_ACL` | Ability to read the ACL attribute |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `READ_ACL` | 能够读取ACL属性 |'
- en: '| `READ_ATTRIBUTES` | Ability to read (non-ACL) file attributes |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `READ_ATTRIBUTES` | 能够读取（非ACL）文件属性 |'
- en: '| `READ_DATA` | Ability to read the data of the file |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `READ_DATA` | 能够读取文件的数据 |'
- en: '| `READ_NAMED_ATTRS` | Ability to read the named attributes of a file |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `READ_NAMED_ATTRS` | 能够读取文件的命名属性 |'
- en: '| `SYNCHRONIZE` | Ability to access files locally at the server with synchronous
    reads and writes |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `SYNCHRONIZE` | 能够在服务器上本地访问文件，进行同步读写 |'
- en: '| `WRITE_ACL` | Ability to write the ACL attribute |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE_ACL` | 能够写入ACL属性 |'
- en: '| `WRITE_ATTRIBUTES` | Ability to write (non-ACL) file attributes |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE_ATTRIBUTES` | 能够写入（非ACL）文件属性 |'
- en: '| `WRITE_DATA` | Ability to modify the file''s data |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE_DATA` | 能够修改文件的数据 |'
- en: '| `WRITE_NAMED_ATTRS` | Ability to write the named attributes of a file |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE_NAMED_ATTRS` | 能够写入文件的命名属性 |'
- en: '| `WRITE_OWNER` | Ability to change the owner |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE_OWNER` | 能够更改所有者 |'
- en: 'The `AclEntryFlag` enumeration is applied to directory entries. There are four
    values summarized as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`AclEntryFlag`枚举适用于目录条目。总结为四个值如下：'
- en: '| Value | Meaning |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DIRECTORY_INHERIT` | The ACL entry should be added to each new directory
    created |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `DIRECTORY_INHERIT` | ACL条目应添加到每个新创建的目录 |'
- en: '| `FILE_INHERIT` | The ACL entry should be added to each new non-directory
    file created |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_INHERIT` | ACL条目应添加到每个新创建的非目录文件 |'
- en: '| `INHERIT_ONLY` | The ACL entry should be added to each new file or directory
    created |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `INHERIT_ONLY` | ACL条目应添加到每个新创建的文件或目录 |'
- en: '| `NO_PROPAGATE_INHERIT` | The ACL entry should not be placed on the newly
    created directory, which is inheritable by subdirectories of the created directory
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `NO_PROPAGATE_INHERIT` | ACL条目不应放置在新创建的目录上，该目录可被创建目录的子目录继承 |'
- en: Currently, there are no flags associated with the `AclEntryType.AUDIT` or `AclEntryType.ALARM`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`AclEntryType.AUDIT`或`AclEntryType.ALARM`没有与之关联的标志。
- en: Managing POSIX attributes
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理POSIX属性
- en: The POSIX attributes available include a group owner, a user owner, and a set
    of permissions. In this recipe, we will investigate how to maintain these attributes.
    The management of these attributes makes it easier to develop applications designed
    to execute on multiple operating systems. While the number of attributes is limited,
    they may be sufficient for many applications.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的POSIX属性包括组所有者、用户所有者和一组权限。在本示例中，我们将研究如何维护这些属性。管理这些属性使得开发应用程序在多个操作系统上执行更加容易。虽然属性的数量有限，但对于许多应用程序来说可能已经足够了。
- en: 'There are three approaches that can be used to manage POSIX attributes:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以用来管理POSIX属性：
- en: The `java.nio.file.attribute.PosixFileAttributeView` interface
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.attribute.PosixFileAttributeView`接口'
- en: The `Files` class' set/get POSIX file permission methods
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Files`类的设置/获取POSIX文件权限方法'
- en: The `Files` class' `setAttribute` method
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Files`类的`setAttribute`方法'
- en: The approach used to gain access to the `PosixFileAttributes` object using the
    `PosixFileAttributeView` interface is detailed in the [Chapter 3](ch03.html "Chapter 3. Obtaining
    File and Directory Information") recipe *Using the PosixFileAttributeView to maintain
    POSIX file attributes*. Here, we will illustrate how to use the `PosixFileAttributeView`
    interface approach first, and demonstrate the last two approaches in the *There's
    more..*. section of this recipe.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PosixFileAttributeView`接口获取`PosixFileAttributes`对象的方法在[第3章](ch03.html "第3章。获取文件和目录信息")的*使用PosixFileAttributeView维护POSIX文件属性*中有详细说明。在这里，我们将首先说明如何使用`PosixFileAttributeView`接口方法，并在本示例的*还有更多..*部分演示最后两种方法。
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To maintain POSIX permission attributes for a file we need to:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要维护文件的POSIX权限属性，我们需要：
- en: Create a `Path` object representing the file or directory of interest.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示感兴趣的文件或目录的`Path`对象。
- en: Obtain a `PosixFileAttributes` object for that file.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取该文件的`PosixFileAttributes`对象。
- en: Get a set of permissions for that file using the permissions method.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`permissions`方法获取该文件的一组权限。
- en: Modify the set of permissions.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改权限集。
- en: Replace the permission using the `setPermissions` method.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setPermissions`方法替换权限。
- en: How to do it...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create an application that obtains a `PosixFileAttributes` object and
    uses it to display the current permissions set for the `users.txt` file, and then
    add the `PosixFilePermission.OTHERS_WRITE` permission to the file. Create a new
    console application and add the following `main` method:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，获取`PosixFileAttributes`对象并使用它来显示`users.txt`文件的当前权限集，然后向文件添加`PosixFilePermission.OTHERS_WRITE`权限。创建一个新的控制台应用程序，并添加以下`main`方法：
- en: '[PRE22]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the application on a system that supports POSIX. When executed under
    **Ubuntu 11.04** you should get results similar to the following:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持POSIX的系统上执行应用程序。在**Ubuntu 11.04**下执行时，应该会得到类似以下的结果：
- en: '**Permissions: GROUP_READ OWNER_WRITE OTHERS_READ OWNER_READ**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限：GROUP_READ OWNER_WRITE OTHERS_READ OWNER_READ**'
- en: '**Permissions: GROUP_READ OWNER_WRITE OTHERS_WRITE OTHERS_READ OWNER_READ**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限：GROUP_READ OWNER_WRITE OTHERS_WRITE OTHERS_READ OWNER_READ**'
- en: How it works...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` method, we obtained a `Path` for the `users.txt` file and then
    used the `getFileAttributeView` method to get an instance of the `PosixFileAttributeView`.
    The `readAttributes` method was then used to obtain an instance of the `PosixFileAttributes`
    object representing the file's POSIX attributes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们获取了`users.txt`文件的`Path`，然后使用`getFileAttributeView`方法获取了`PosixFileAttributeView`的实例。然后使用`readAttributes`方法获取了表示文件POSIX属性的`PosixFileAttributes`对象的实例。
- en: The `listPermissions` method was used to list the permissions for the file.
    This method was executed once before and once after the new permission was added
    to the file. We did this simply to show the change in permissions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`listPermissions`方法列出文件的权限。在添加新权限到文件之前和之后各执行一次此方法。我们这样做只是为了显示权限的变化。
- en: 'The `PosixFilePermission.OTHERS_WRITE` permission was added to the permission
    set using the `add` method. The following table lists the `PosixFilePermission`
    enumeration values:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add`方法将`PosixFilePermission.OTHERS_WRITE`权限添加到权限集中。以下表列出了`PosixFilePermission`枚举值：
- en: '| Value | Level | Permission Granted |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 级别 | 授予权限 |'
- en: '| --- | --- | --- |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GROUP_EXECUTE` | Group | Execute and search |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `GROUP_EXECUTE` | 组 | 执行和搜索 |'
- en: '| `GROUP_READ` |   | Read |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `GROUP_READ` |   | 读取 |'
- en: '| `GROUP_WRITE` |   | Write |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `GROUP_WRITE` |   | 写入 |'
- en: '| `OTHERS_EXECUTE` | Others | Execute and search |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `OTHERS_EXECUTE` | 其他人 | 执行和搜索 |'
- en: '| `OTHERS_READ` |   | Read |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `OTHERS_READ` |   | 读取 |'
- en: '| `OTHERS_WRITE` |   | Write |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `OTHERS_WRITE` |   | 写入 |'
- en: '| `OWNER_EXECUTE` | Owner | Execute and search |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `OWNER_EXECUTE` | 拥有者 | 执行和搜索 |'
- en: '| `OWNER_READ` |   | Read |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `OWNER_READ` |   | 读取 |'
- en: '| `OWNER_WRITE` |   | Write |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `OWNER_WRITE` |   | 写入 |'
- en: In this example, we added a `PosixFilePermission.OTHERS_WRITE` permission. In
    the next section, we will illustrate how to remove a permission.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了一个`PosixFilePermission.OTHERS_WRITE`权限。在下一节中，我们将说明如何删除权限。
- en: There's more...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several other operations of interest including:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个感兴趣的操作，包括：
- en: Removing a file permission
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件权限
- en: Modifying the POSIX ownership of a file
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改文件的POSIX所有权
- en: Using the `Files` class' `set/get` POSIX file permission methods
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Files`类的`set/get` POSIX文件权限方法
- en: Using the `Files` class' `setAttribute` method
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Files`类的`setAttribute`方法
- en: Using the `PosixFilePermissions` class to create `PosixFilePermissions`
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PosixFilePermissions`类创建`PosixFilePermissions`
- en: Removing a file permission
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文件权限
- en: 'Removing a permission is simply a matter of:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 删除权限只是一个简单的事情：
- en: Obtaining a set of permissions for the file
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件的一组权限
- en: Using the `Set` interface's `remove` method to remove the permission
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Set`接口的`remove`方法来删除权限
- en: Reassigning the set to the file
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合重新分配给文件
- en: 'This is illustrated in the following code sequence, where the `PosixFilePermission.OTHERS_WRITE`
    permission is removed:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码序列中有所体现，其中删除了`PosixFilePermission.OTHERS_WRITE`权限：
- en: '[PRE23]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Modifying the POSIX ownership of a file
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改文件的POSIX所有权
- en: The POSIX owners are specified at the group and user level. The `PosixFileAttributes`
    method's group and owner will return objects representing the group and user owners
    of the file. The `setGroup` and `setOwner` methods will set the corresponding
    memberships.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX所有者在组和用户级别指定。`PosixFileAttributes`方法的组和所有者将返回表示文件的组和用户所有者的对象。`setGroup`和`setOwner`方法将设置相应的成员资格。
- en: 'In the example that follows, the owners for the `users.txt` file are displayed
    and then changed. The `UserPrincipal` objects are created to support the `set`
    methods:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，将显示`users.txt`文件的所有者，然后进行更改。创建`UserPrincipal`对象以支持`set`方法：
- en: '[PRE24]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When executed your output should appear as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，输出应如下所示：
- en: '**Setting owner for users.txt**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**为users.txt设置所有者**'
- en: '**Old Group: richard**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧组：richard**'
- en: '**Old Owner: richard**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧所有者：richard**'
- en: '**New Group: jennifer**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**新组：jennifer**'
- en: '**New Owner: jennifer**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**新所有者：jennifer**'
- en: You may need to execute the code as an administrator, as detailed in the introduction.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要以管理员身份执行代码，详细信息请参见介绍。
- en: Using the Files class' set/get POSIX file permission methods
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Files类的set/get POSIX文件权限方法
- en: 'This approach uses the `Files` class'' `setPosixFilePermissions` and `getPosixFilePermissions`
    methods. The `getPosixFilePermissions` method returns a set of `PosixFilePermissions`
    for the file specified by its first argument. Its second argument is a `LinkOption`,
    which is used to determine how symbolic link files are handled. Links are not
    normally followed, unless the `LinkOption.NOFOLLOW_LINKS` is used. We could use
    the following code sequence to list the permissions associated with a file:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`Files`类的`setPosixFilePermissions`和`getPosixFilePermissions`方法。`getPosixFilePermissions`方法返回指定其第一个参数的文件的`PosixFilePermissions`集合。它的第二个参数是`LinkOption`，用于确定如何处理符号链接文件。通常不会跟随链接，除非使用`LinkOption.NOFOLLOW_LINKS`。我们可以使用以下代码序列列出与文件关联的权限：
- en: '[PRE25]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `setPermissions` method takes a `Path` object representing the file and
    a set of `PosixFilePermission`. Instead of using the previous method:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPermissions`方法接受表示文件的`Path`对象和一组`PosixFilePermission`。而不是使用以前的方法：'
- en: '[PRE26]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can use the `Files` class'' `setPosixFilePermissions` method:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Files`类的`setPosixFilePermissions`方法：
- en: '[PRE27]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The use of the `Files` class simplifies the process by avoiding the creation
    of a `PosixFileAttributes` object.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Files`类简化了该过程，避免了创建`PosixFileAttributes`对象。
- en: Using the Files class' setAttribute method
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Files类的setAttribute方法
- en: 'The `Files` class'' `getAttribute` method is detailed in the *Obtaining a single
    attribute at a time using the getAttribute method* recipe found in [Chapter 3](ch03.html
    "Chapter 3. Obtaining File and Directory Information"). The `setAttribute` method
    will set an attribute and has the following four arguments:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的`getAttribute`方法在[第3章](ch03.html "第3章.获取文件和目录信息")中详细介绍了*使用getAttribute方法逐个获取属性*配方。`setAttribute`方法将设置一个属性，并具有以下四个参数：'
- en: A `Path` object representing the file
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示文件的`Path`对象
- en: A `String` containing the attribute to be set
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含要设置的属性的`String`
- en: An object representing the value of the attribute
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示属性值的对象
- en: An optional `LinkOption` value specifying how symbolic links are handled
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定符号链接的可选`LinkOption`值
- en: 'The following illustrates adding the `PosixFilePermission.OTHERS_WRITE` permission
    to the `users.txt` file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了向`users.txt`文件添加`PosixFilePermission.OTHERS_WRITE`权限：
- en: '[PRE28]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `LinkOption` value was not used in this example.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中未使用`LinkOption`值。
- en: Using the PosixFilePermissions class to create PosixFilePermissions
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PosixFilePermissions类创建PosixFilePermissions
- en: 'The `PosixFilePermissions` class possesses three methods:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`PosixFilePermissions`类拥有三种方法：'
- en: '`asFileAttribute`, which returns a `FileAttribute` object that contains a set
    of `PosixFilePermissions`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asFileAttribute`，返回一个包含一组`PosixFilePermissions`的`FileAttribute`对象'
- en: '`fromString`, which also returns a set of `PosixFilePermissions` based on a
    `String` argument'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromString`，也返回一个基于`String`参数的`PosixFilePermissions`集合'
- en: '`toString`, which performs the inverse operation of the `fromString` method'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString`，执行`fromString`方法的逆操作'
- en: All three methods are static. The first method returns a `FileAttribute` object,
    which can be used with the `createFile` or `createDirectory` method as discussed
    in the *Creating files and directories* recipe.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都是静态的。第一种方法返回一个`FileAttribute`对象，可以与*创建文件和目录*配方中讨论的`createFile`或`createDirectory`方法一起使用。
- en: On Unix systems, file permissions are frequently expressed as a nine-character
    string. The string is grouped in three character groups. The first set represents
    permission of the user, the second represents permission of the group, and the
    last set represents the permission of all others. Each of the three character
    groups represent the read, write, or execute permissions granted for that set.
    An `r` in the first position grants read permission, a `w` in the second position
    indicates write permission, and an `x` in the last position grants execute permission.
    A `-` in any of these positions means that the permission is not set.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统上，文件权限经常表示为一个九个字符的字符串。这个字符串分为三个字符组。第一组表示用户的权限，第二组表示组的权限，最后一组表示其他所有人的权限。这三个字符组中的每一个表示为该组授予的读、写或执行权限。在第一个位置的`r`表示读权限，第二个位置的`w`表示写权限，最后一个位置的`x`表示执行权限。在任何这些位置上的`-`表示权限未设置。
- en: 'To illustrate these methods, execute the following code sequence:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些方法，执行以下代码序列：
- en: '[PRE29]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Your output should be similar to the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该类似于以下内容：
- en: '**OTHERS_READ OWNER_READ GROUP_READ OWNER_WRITE**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**OTHERS_READ OWNER_READ GROUP_READ OWNER_WRITE**'
- en: '**OTHERS_READ OWNER_READ OWNER_WRITE GROUP_READ**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**OTHERS_READ OWNER_READ OWNER_WRITE GROUP_READ**'
- en: '**rw-r--r--**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw-r--r--**'
- en: '**OWNER_READ OWNER_WRITE GROUP_READ GROUP_WRITE OTHERS_READ**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**OWNER_READ OWNER_WRITE GROUP_READ GROUP_WRITE OTHERS_READ**'
- en: The first section of the code obtains a set of permissions for the `users.txt`
    file as detailed earlier in this recipe. The permissions were then displayed.
    Next, the `asFileAttribute` method was executed to return the `FileAttribute`
    for the file. The `value` method was used to obtain a set of the attributes, which
    were then displayed. The two sets of permissions were displayed but in a different
    order.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分获取了`users.txt`文件的权限集，就像在本食谱中早些时候详细介绍的那样。然后显示了权限。接下来，执行了`asFileAttribute`方法，返回了文件的`FileAttribute`。使用`value`方法获取了一组属性，然后显示了这些属性。两组权限被显示，但顺序不同。
- en: Next, the `toString` method was used to display this same set of permissions
    as a string. Notice each character reflects a permission granted for the `users.txt`
    file.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`toString`方法将这组权限显示为字符串。注意每个字符反映了对`users.txt`文件授予的权限。
- en: The last code segment created a new set of permissions using the `fromString`
    method. These permissions were then displayed to verify the conversion.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码段使用`fromString`方法创建了一个新的权限集。然后显示这些权限以验证转换。
- en: Moving a file and a directory
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动文件和目录
- en: Moving a file or directory can be useful when reorganizing the structure of
    a user space. This operation is supported by the `Files` class' `move` method.
    When moving a file or directory there are several factors to consider. These include
    whether the symbolic link files are present, whether the `move` should replace
    existing files, and whether the move should be atomic.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 移动文件或目录在重新组织用户空间结构时非常有用。这个操作由`Files`类的`move`方法支持。在移动文件或目录时，有几个因素需要考虑。这些包括符号链接文件是否存在，`move`是否应该替换现有文件，以及移动是否应该是原子的。
- en: A move may result in the renaming of the resource if the move occurs on the
    same file store. The use of this method will sometimes use the `Path` interface's
    `resolveSibling` method. This method will replace the last part of a path with
    its argument. This is useful when renaming files. The `resolveSibling` method
    is detailed in the *There's more..*. section of the *Combining paths using path
    resolution* recipe in [Chapter 2](ch02.html "Chapter 2. Locating Files and Directories
    Using Paths"), *Locating Files and Directories Using Paths*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动发生在相同的文件存储上，移动可能会导致资源的重命名。使用这个方法有时会使用`Path`接口的`resolveSibling`方法。这个方法将用它的参数替换路径的最后一部分。这在重命名文件时很有用。`resolveSibling`方法在[第2章](ch02.html
    "第2章. 使用路径定位文件和目录")的*使用路径解析合并路径*食谱的*还有更多..*部分中有详细介绍。
- en: Getting ready
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'In order to move a file or directory:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动文件或目录：
- en: Obtain a `Path` object, which represents the file or directory to move.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个`Path`对象，表示要移动的文件或目录。
- en: Obtain a `Path` object, which represents the destination of the move.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个`Path`对象，表示移动的目的地。
- en: Determine the copy options to control the move.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定复制选项以控制移动。
- en: Execute the `move` method.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`move`方法。
- en: How to do it...
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new console application using the following `main` method. We will
    move the `users.txt` file to the `music` directory:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`main`方法创建一个新的控制台应用程序。我们将把`users.txt`文件移动到`music`目录：
- en: '[PRE30]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Execute the application. Examine the contents of the `docs` and `music` directories.
    The `users.txt` file should be absent from the `docs` directory, but present in
    the `music` directory.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。检查`docs`和`music`目录的内容。`users.txt`文件应该不在`docs`目录中，但在`music`目录中。
- en: How it works...
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `move` method used these two `Path` objects and did not use a third optional
    argument. This argument is used to determine how the copy operation works. When
    it is not used, the file copy operation defaults to a simple copy.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`方法使用这两个`Path`对象，并且没有使用第三个可选参数。这个参数用于确定复制操作的工作方式。当它没有被使用时，文件复制操作默认为简单复制。'
- en: 'The `StandardCopyOption` enumeration implements the `CopyOption` interface
    and defines the types of copy operation supported. The `CopyOption` interface
    is used with the `Files` class'' `copy` and `move` methods. The following table
    lists these options. These options are explained in more detail in the *There''s
    more..*. section:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardCopyOption`枚举实现了`CopyOption`接口，并定义了支持的复制操作类型。`CopyOption`接口与`Files`类的`copy`和`move`方法一起使用。下表列出了这些选项。这些选项在*还有更多..*部分中有更详细的解释：'
- en: '| Value | Meaning |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 含义 |'
- en: '| --- | --- |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ATOMIC_MOVE` | The move operation is atomic in nature |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `ATOMIC_MOVE` | 移动操作是原子的 |'
- en: '| `COPY_ATTRIBUTES` | The source file attributes are copied to the new file
    |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `COPY_ATTRIBUTES` | 源文件属性被复制到新文件 |'
- en: '| `REPLACE_EXISTING` | The destination file is replaced if it exists |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `REPLACE_EXISTING` | 如果目标文件存在，则替换目标文件 |'
- en: If the destination file already exists, then the `FileAlreadyExistsException`
    exception is thrown. However, if the `CopyOption.REPLACE_EXISTING` is used as
    the third argument of the `move` method, the exception is not thrown. When the
    source is a symbolic link, the link is copied and not the target of the link.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标文件已经存在，则会抛出`FileAlreadyExistsException`异常。但是，如果`CopyOption.REPLACE_EXISTING`作为`move`方法的第三个参数使用，则不会抛出异常。当源是符号链接时，将复制链接而不是链接的目标。
- en: There's more...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several variations and issues that need to be covered. These include:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个需要涵盖的变化和问题。这些包括：
- en: Trivial uses of the `move` method
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动方法的琐碎用法
- en: The meaning of the `StandardCopyOption` enumeration values
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准复制选项枚举值的含义
- en: Using the `resolveSibling` method with the `move` method to affect a rename
    operation
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`resolveSibling`方法与`move`方法影响重命名操作
- en: Moving a directory
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动目录
- en: Trivial uses of the move method
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动方法的琐碎用法
- en: 'If the source file and the destination files are the same, the method will
    not have any effect. The following code sequence will have no effect:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源文件和目标文件相同，则该方法不会产生任何效果。以下代码序列将不会产生任何效果：
- en: '[PRE31]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: No exception will be thrown and the file will not be moved.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不会抛出异常，文件也不会被移动。
- en: The meaning of the StandardCopyOption enumeration values
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准复制选项枚举值的含义
- en: The `StandardCopyOption` enumeration values require a bit more explanation.
    A value of the `StandardCopyOption.REPLACE_EXISTING` will replace the existing
    file if present. If the file is a symbolic link, then only the symbolic link file
    is replaced, not its target.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 标准复制选项枚举值需要更多的解释。`StandardCopyOption.REPLACE_EXISTING`的值将替换已存在的文件。如果文件是符号链接，则只替换符号链接文件，而不是其目标。
- en: A value of `StandardCopyOption.COPY_ATTRIBUTES` will copy all of the attributes
    of the file. A value of `StandardCopyOption.ATOMIC_MOVE` specifies that the move
    operation is to be performed in an atomic fashion. All other enumeration values
    are ignored. However, if the destination file already exists, then either the
    file will be replaced or an `IOException` will be thrown. The result is implementation-dependent.
    If the move cannot be performed in an atomic fashion, then an `AtomicMoveNotSupportedException`
    is thrown. An atomic move may fail due to differences in the file store of the
    source and destination files.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardCopyOption.COPY_ATTRIBUTES`的值将复制文件的所有属性。`StandardCopyOption.ATOMIC_MOVE`的值指定移动操作要以原子方式执行。所有其他枚举值都将被忽略。但是，如果目标文件已经存在，则要么替换文件，要么抛出`IOException`。结果取决于实现。如果无法以原子方式执行移动操作，则会抛出`AtomicMoveNotSupportedException`。原子移动可能由于源文件和目标文件的文件存储器的差异而失败。'
- en: 'If the following code sequence is executed on Windows 7:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Windows 7上执行以下代码序列：
- en: '[PRE32]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then an `AccessDeniedException` exception is thrown if the destination file
    already exists. If the file does not exist, its execution will result in the following
    error message:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标文件已经存在，则会抛出`AccessDeniedException`异常。如果文件不存在，其执行将导致以下错误消息：
- en: '**java.nio.file.AtomicMoveNotSupportedException: C:\home\docs\users.txt ->
    E:\home\music\users.txt: The system cannot move the file to a different disk drive**'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.AtomicMoveNotSupportedException: C:\home\docs\users.txt ->
    E:\home\music\users.txt: 系统无法将文件移动到不同的磁盘驱动器**'
- en: Using the resolveSibling method with the move method to affect a rename operation
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`resolveSibling`方法与`move`方法影响重命名操作
- en: 'The `resolveSibling` method will replace the last part of a path with a different
    string. This can be used to affect a rename operation when using the `move` method.
    In the following sequence, the `users.txt` file is effectively renamed:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolveSibling`方法将用不同的字符串替换路径的最后一部分。这可以用于在使用`move`方法时影响重命名操作。在以下序列中，`users.txt`文件被有效地重命名：'
- en: '[PRE33]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The file has been renamed to `users.txt.bak`. Notice that the source file path
    was used twice. To rename the file and replace its extension, we can use an explicit
    name as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已重命名为`users.txt.bak`。请注意，源文件路径被使用了两次。要重命名文件并替换其扩展名，可以使用显式名称，如下所示：
- en: '[PRE34]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A more sophisticated approach might use the following sequence:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的方法可能使用以下序列：
- en: '[PRE35]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `substring` method returned a new filename starting with the first character
    and ending with the character immediately preceding the period.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring`方法返回一个以第一个字符开头，以紧接着句号之前的字符结尾的新文件名。'
- en: Moving a directory
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动目录
- en: 'When a directory is moved on the same file store, then the directory and subdirectories
    are moved. The following will move the `docs` directory, its files, and its subdirectories
    to the `music` directory as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一文件存储器上移动目录时，目录和子目录也会被移动。以下将把`docs`目录、其文件和子目录移动到`music`目录中：
- en: '[PRE36]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, executing this code sequence, where the `docs` directory is to be
    moved to a similar file structure on the `E` drive will result in a `DirectoryNotEmptyException`
    exception:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，执行此代码序列，其中`docs`目录将被移动到`E`驱动器上类似的文件结构，将导致`DirectoryNotEmptyException`异常：
- en: '[PRE37]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Moving a directory across file stores will result in an exception if the directory
    is not empty. If the `docs` directory had been empty in the previous example,
    the `move` method would have executed successfully. If you need to move a non-empty
    directory across file stores, then this will normally involve a copy operation
    followed by a delete operation.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同文件存储器之间移动目录将导致异常，如果目录不为空。如果在前面的例子中`docs`目录是空的，`move`方法将成功执行。如果需要在不同文件存储器之间移动非空目录，通常需要进行复制操作，然后进行删除操作。
- en: Deleting files or directories
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件或目录
- en: 'Deleting files or directories when they are no longer needed is a common operation.
    It will save space on a system and result in a cleaner filesystem. There are two
    methods of the `Files` class that can be used to delete a file or directory: `delete`
    and `deleteIfExists`. They both take a `Path` object as their argument and may
    throw an `IOException`.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件或目录当它们不再需要时是一个常见的操作。它将节省系统空间并导致更干净的文件系统。`Files`类有两种方法可以用来删除文件或目录：`delete`和`deleteIfExists`。它们都以`Path`对象作为参数，并可能抛出`IOException`。
- en: Getting ready
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To delete a file or directory, the following needs to be done:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除文件或目录，需要执行以下操作：
- en: Obtain a `Path` object, which represents the file or directory.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个代表文件或目录的`Path`对象。
- en: Use either the `delete` or `deleteIfExists` methods to delete the element.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`delete`或`deleteIfExists`方法来删除元素。
- en: How to do it...
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and use the following `main` method:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并使用以下`main`方法：
- en: '[PRE38]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Execute the application. If the `users.txt` file existed in the directory when
    the program ran, it should not be there after the program executes. If the file
    did not exist, then your program output should appear similar to the following:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。如果`users.txt`文件在程序运行时存在于目录中，那么在程序执行后它就不应该存在。如果文件不存在，那么你的程序输出应该类似于以下内容：
- en: '**java.nio.file.NoSuchFileException: C:\home\docs\users.txt**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.NoSuchFileException: C:\home\docs\users.txt**'
- en: How it works...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This method is simple to use. We created a `Path` object representing the `users.txt`
    method. We then used it as an argument to the `delete` method. Since `delete`
    method may throw an `IOException`, the code was enclosed in a try-catch block.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很简单。我们创建了一个代表`users.txt`方法的`Path`对象。然后我们将它作为`delete`方法的参数。由于`delete`方法可能会抛出`IOException`，所以代码被包含在try-catch块中。
- en: 'To avoid an exception that would be thrown if the file did not exist, we could
    have used the `deleteIfExists` method instead. Replace the `delete` method invocation
    with the following:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免如果文件不存在会抛出异常，我们可以使用`deleteIfExists`方法。用以下内容替换`delete`方法的调用：
- en: '[PRE39]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Make sure that the file does not exist and then execute this code. The program
    should terminate normally without any exceptions being thrown.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件不存在，然后执行此代码。程序应该正常终止，不会抛出任何异常。
- en: There's more...
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we try to delete a directory, the directory must first be empty. If the
    directory is not empty, then a `DirectoryNotEmptyException` exception will be
    thrown. Execute the following code sequence in lieu of the previous example:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试删除一个目录，那么该目录必须首先为空。如果目录不为空，则会抛出`DirectoryNotEmptyException`异常。执行以下代码序列来代替前面的示例：
- en: '[PRE40]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Assuming that the `docs` directory is not empty, the application should throw
    a `DirectoryNotEmptyException` exception.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`docs`目录不为空，应用程序应该抛出`DirectoryNotEmptyException`异常。
- en: The definition of an empty directory is dependent on the filesystem implementation.
    On some systems where the directory only contains special files or symbolic links,
    the directory may be considered to be empty.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 空目录的定义取决于文件系统的实现。在一些系统中，如果目录只包含特殊文件或符号链接，该目录可能被认为是空的。
- en: If a directory is not empty and needs to be deleted, then it will be necessary
    to delete its entries first using the `walkFileTree` method as illustrated in
    the *Using the SimpleFileVisitor class to traverse file systems* recipe in [Chapter
    5](ch05.html "Chapter 5. Managing Filesystems"), *Managing File Systems*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个目录不为空并且需要被删除，那么需要首先使用`walkFileTree`方法删除它的条目，就像在[第5章](ch05.html "第5章。管理文件系统")的*使用SimpleFileVisitor类遍历文件系统*中所示的那样，*管理文件系统*。
- en: Note
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the file to be deleted is a symbolic link, only the link is deleted, not
    the target of the link. Also, it may not be possible to delete a file if the file
    is open or in use by other applications.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除的文件是一个符号链接，只有链接被删除，而不是链接的目标。此外，如果文件被其他应用程序打开或正在使用中，可能无法删除文件。
- en: Managing symbolic links
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理符号链接
- en: Symbolic links are files, which are not real files, but rather links to or points
    to the real file typically called the target file. These are useful when it is
    desirable to have a file appearing to be in more than one directory without actually
    having to duplicate the file. This saves space and keeps all of the updates isolated
    to a single file.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是文件，它们不是真正的文件，而是指向真正文件的链接，通常称为目标文件。当希望一个文件出现在多个目录中而不必实际复制文件时，这些链接是有用的。这样可以节省空间，并且所有更新都被隔离到一个单独的文件中。
- en: 'The `Files` class possesses the following three methods for working with symbolic
    links:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类具有以下三种方法来处理符号链接：'
- en: The `createSymbolicLink` method, which creates a symbolic link to a target file
    that may not exist
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createSymbolicLink`方法，用于创建到可能不存在的目标文件的符号链接'
- en: The `createLink` method creates a hard link to an existing file
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createLink`方法创建一个到现有文件的硬链接'
- en: The `readSymbolicLink` retrieves a `Path` to the target file
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readSymbolicLink`检索到目标文件的`Path`'
- en: Links are typically transparent to the users of the file. Any access to the
    symbolic link is redirected to the referenced file. Hard links are similar to
    symbolic links, but have more restrictions. These types of links are discussed
    in more detail in the *There's more..*. section of this recipe.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 链接通常对文件的用户是透明的。对符号链接的任何访问都会被重定向到引用的文件。硬链接类似于符号链接，但有更多的限制。这些类型的链接在本食谱的*还有更多..*部分中有更详细的讨论。
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to create a symbolic link to a file:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个符号链接到一个文件：
- en: Obtain a `Path` object, which represents the link.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个代表链接的`Path`对象。
- en: Obtain a `Path` object, which represents the target file.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个代表目标文件的`Path`对象。
- en: Use these paths as the argument to the `createSymbolicLink` method.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些路径作为`createSymbolicLink`方法的参数。
- en: How to do it...
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application. Add the following `main` method to the application.
    In this application, we will create a symbolic link in the `music` directory to
    the actual `users.txt` file in the `docs` directory.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。将以下`main`方法添加到应用程序中。在这个应用程序中，我们将在`music`目录中创建一个符号链接，指向`docs`目录中的实际`users.txt`文件。
- en: '[PRE41]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Execute the application. If the application does not have sufficient privileges,
    then an exception will be thrown. An example of this when executed on Windows
    7 is shown as follows:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。如果应用程序没有足够的权限，那么将抛出异常。在Windows 7上执行时的示例如下：
- en: '**java.nio.file.FileSystemException: C:\home\music\users.txt: A required privilege
    is not held by the client.**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.FileSystemException: C:\home\music\users.txt: A required privilege
    is not held by the client.**'
- en: 'Verify that a new file called `users.txt` exists in the `music` directory.
    Check the properties of the file to verify that it is a symbolic link. On Windows
    7, right-click on the filename and select **Properties**. Next, select the **Shortcut**
    tab. It should appear as shown in the following screenshot:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`music`目录中是否存在一个名为`users.txt`的新文件。检查文件的属性，以验证它是否是一个符号链接。在Windows 7上，右键单击文件名，然后选择**属性**。接下来，选择**快捷方式**选项卡。它应该显示如下截图所示：
- en: '![How to do it...](img/5627_04_01.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/5627_04_01.jpg)'
- en: Notice that the target specified is the `users.txt` file in the `docs` directory.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 注意指定的目标是`docs`目录中的`users.txt`文件。
- en: How it works...
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created two `Path` objects. The first represented the target file in the
    `docs` directory. The second represented the link file to be created in the `music`
    directory. Next, we used the `createSymbolicLink` method to actually create the
    symbolic link. The entire code sequence was enclosed in a try block to catch any
    `IOExceptions` that may be thrown.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个`Path`对象。第一个代表`docs`目录中的目标文件。第二个代表要在`music`目录中创建的链接文件。接下来，我们使用`createSymbolicLink`方法来实际创建符号链接。整个代码序列被包含在try块中，以捕获可能抛出的任何`IOExceptions`。
- en: The third argument of the `createSymbolicLink` method can be one or more `FileAttribute`
    values. These are intended to be used to set attributes of the link file when
    it is created. However, it is currently not fully supported. Future versions of
    Java will enhance this capability. A `FileAttribute` can be created as detailed
    in the *There's more..*. section of the *Managing POSIX file permissions* recipe.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSymbolicLink`方法的第三个参数可以是一个或多个`FileAttribute`值。这些值用于在创建链接文件时设置其属性。然而，目前它还没有得到完全支持。未来的Java版本将增强这一功能。`FileAttribute`可以按照*还有更多..*部分中*管理POSIX文件权限*配方中的详细说明来创建。'
- en: There's more...
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here we will look more carefully at the following issues:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将更仔细地研究以下问题：
- en: Creating a hard link
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建硬链接
- en: Creating a symbolic link to a directory
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对目录的符号链接
- en: Determining the target of a link file
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定链接文件的目标
- en: Creating a hard link
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建硬链接
- en: 'Hard links have more restrictions placed upon them as opposed to symbolic links.
    These restrictions include the following:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 与符号链接相比，硬链接有更多的限制。这些限制包括以下内容：
- en: The target must exist. If not, an exception is thrown.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标必须存在。如果不存在，就会抛出异常。
- en: A hard link cannot be made to a directory.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能对目录创建硬链接。
- en: Hard links can only be established within a single filesystem.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接只能在单个文件系统内建立。
- en: Hard links behave like a regular file. There are no overt properties of the
    file that indicate that it is a link file, as opposed to a symbolic link file
    which has a shortcut tab. All of the attributes of the hard link are identical
    to that of the target file.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接的行为就像普通文件。文件没有明显的属性表明它是一个链接文件，而不是一个具有快捷方式选项卡的符号链接文件。硬链接的所有属性与目标文件的属性相同。
- en: 'Hard links are not used as frequently as soft links. `Path` class methods work
    with hard links and do not require any special considerations. A hard link is
    created using the `createLink` method. It accepts two arguments: a `Path` object
    for the link file and for the target file. In the following example, we create
    a hard link in the `music` directory instead of a symbolic link:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接不像软链接那样经常使用。`Path`类的方法可以处理硬链接，不需要任何特殊考虑。使用`createLink`方法创建硬链接。它接受两个参数：链接文件的`Path`对象和目标文件的`Path`对象。在下面的示例中，我们在`music`目录中创建了一个硬链接，而不是一个符号链接：
- en: '[PRE42]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Execute the application. If you examine the properties of the link file, you
    observe that it is not displayed as a symbolic link. However, modifying the contents
    of either file will cause the other file to be modified also. They are effectively
    one and the same.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应用程序。如果您检查链接文件的属性，您会发现它不显示为符号链接。但是，修改任一文件的内容将导致另一个文件也被修改。它们实际上是一样的。
- en: Creating a symbolic link to a directory
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对目录的符号链接
- en: 'Creating a symbolic link to a directory uses the same methods as it did for
    files. In the following example, a new directory `tmp` is created, which is a
    symbolic link to the `docs` directory:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对目录的符号链接使用与文件相同的方法。在下面的示例中，创建了一个新目录`tmp`，它是`docs`目录的符号链接：
- en: '[PRE43]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All of the files in the `tmp` directory are effectively the symbolic links to
    the corresponding files in the `docs` directory.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmp`目录中的所有文件实际上都是指向`docs`目录中相应文件的符号链接。'
- en: Determining the target of a link file
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定链接文件的目标
- en: The `isSymbolicLink` method, as discussed in the *Managing symbolic links* recipe
    in [Chapter 2](ch02.html "Chapter 2. Locating Files and Directories Using Paths"),
    *Locating Files and Directories Using Paths* determines whether a file is a symbolic
    link or not. The `readSymbolicLink` method accepts a `Path` object representing
    the link file and returns a `Path` object representing the target of the link.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSymbolicLink`方法，如[第2章](ch02.html "第2章. 使用路径定位文件和目录") *使用路径定位文件和目录*中*管理符号链接*配方中所讨论的，用于确定文件是否是符号链接。`readSymbolicLink`方法接受一个代表链接文件的`Path`对象，并返回一个代表链接目标的`Path`对象。'
- en: 'The following code sequence illustrates this, where the `users.txt` file in
    the `music` directory is a symbolic link:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列说明了这一点，在`music`目录中的`users.txt`文件是一个符号链接：
- en: '[PRE44]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, if the `users.txt` link file is a hard link, as created with the `createLink`
    method, we get the following exception when the code is executed:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`users.txt`链接文件是一个硬链接，就像使用`createLink`方法创建的那样，当执行代码时会得到以下异常：
- en: '**java.nio.file.NotLinkException: The file or directory is not a reparse point**.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.NotLinkException: 文件或目录不是一个重解析点**。'
- en: Note
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A reparse point is an **NTFS** filesystem object that associates specific data
    to an application with a file or directory. A filesystem filter can be associated
    with the reparse point type. When the filesystem opens the file, it will pass
    this information to the filesystem filter for processing. This approach is a way
    of extending the functionality of the filesystem.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 重解析点是一个**NTFS**文件系统对象，它将特定数据与文件或目录关联起来。文件系统过滤器可以与重解析点类型关联。当文件系统打开文件时，它将传递这些信息给文件系统过滤器进行处理。这种方法是扩展文件系统功能的一种方式。
