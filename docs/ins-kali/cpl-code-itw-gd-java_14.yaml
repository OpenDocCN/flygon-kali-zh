- en: '*Chapter 11*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第11章*：'
- en: Linked Lists and Maps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表和映射
- en: This chapter covers the most popular coding challenges involving maps and linked
    lists that you will encounter in coding interviews. Since singly linked lists
    are preferred in technical interviews, most of the problems in this chapter will
    exploit them. However, you can challenge yourself and try to solve each such problem
    in the context of a doubly linked list as well. Commonly, the problems become
    easier to solve for a doubly linked list because a doubly linked list maintains
    two pointers for each node and allows us to navigate back and forth within the
    list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在编码面试中遇到的涉及映射和链表的最受欢迎的编码挑战。由于在技术面试中更喜欢使用单向链表，本章中的大多数问题将利用它们。但是，您可以挑战自己，尝试在双向链表的情况下解决每个问题。通常，对于双向链表来说，问题变得更容易解决，因为双向链表为每个节点维护两个指针，并允许我们在列表内前后导航。
- en: 'By the end of this chapter, you''ll know all of the popular problems involving
    linked lists and maps, and you''ll have enough knowledge and understanding of
    numerous techniques to help you to tackle any other problem in this category.
    Our agenda is quite simple; we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解涉及链表和映射的所有热门问题，并且将具有足够的知识和理解各种技术，以帮助您解决此类问题。我们的议程非常简单；我们将涵盖以下主题：
- en: Linked lists in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表简介
- en: Maps in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射简介
- en: Coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code files in this chapter are available on GitHub and can be accessed
    at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码文件都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter11)。
- en: However, before going into the coding challenges, let's first learn about linked
    lists and maps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但在进行编码挑战之前，让我们先了解一下链表和映射。
- en: Linked lists in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表简介
- en: 'A linked list is a linear data structure that represents a sequence of nodes.
    The first node is commonly referred to as the **head**, while the last node is
    commonly referred to as the **tail**. When each node points to the next node,
    we have a *singly linked list*, as shown in the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是表示节点序列的线性数据结构。第一个节点通常被称为**头部**，而最后一个节点通常被称为**尾部**。当每个节点指向下一个节点时，我们有一个*单向链表*，如下图所示：
- en: '![11.1: A singly linked list'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.1：单向链表'
- en: '](img/Figure_11.1_B15403.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B15403.jpg)'
- en: Figure 11.1 – A singly linked list
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 单向链表
- en: 'When each node points to the next node and to the previous node, we have a
    *doubly linked list*, as shown in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个节点指向下一个节点和前一个节点时，我们有一个*双向链表*，如下图所示：
- en: '![11.2: A doubly linked list'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.2：双向链表'
- en: '](img/Figure_11.2_B15403.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B15403.jpg)'
- en: Figure 11.2 – A doubly linked list
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 双向链表
- en: Let's consider a singly linked list. If the tail points to the head, then we
    have a *circular singly linked list*. Alternatively, let's consider a doubly linked
    list. If the tail points to the head and the head points to the tail, then we
    have a *circular doubly linked list*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个单向链表。如果尾部指向头部，那么我们有一个*循环单向链表*。或者，让我们考虑一个双向链表。如果尾部指向头部，头部指向尾部，那么我们有一个*循环双向链表*。
- en: 'In a singly linked list, a node holds the data (for example, an integer or
    an object) and the pointer to the next node. The following code represents the
    node of a singly linked list:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在单向链表中，一个节点保存数据（例如，整数或对象）和指向下一个节点的指针。以下代码表示单向链表的节点：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A doubly linked list also requires the pointer to the previous node:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表还需要指向前一个节点的指针：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unlike an array, a linked list doesn't provide constant time to access the *n*th
    element. We have to iterate *n*-1 elements to obtain the *n*th element. We can
    insert, remove, and update nodes in constant time from the beginning of a linked
    list (singly and doubly). If our implementation manages the tail of the doubly
    linked list (known as a two-head doubly linked list), then we can insert, remove,
    and update nodes in constant time from the end of the linked list as well; otherwise,
    we need to iterate the linked list until the last node. If our implementation
    manages the tail of the singly linked list (known as a two-head singly linked
    list), then we can insert nodes in constant time at the end of the linked list;
    otherwise, we need to iterate the linked list until the last node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，链表不提供访问第n个元素的常数时间。我们必须迭代n-1个元素才能获得第n个元素。我们可以在常数时间内从链表（单向和双向）的开头插入，删除和更新节点。如果我们的实现管理双向链表的尾部（称为双头双向链表），那么我们也可以在常数时间内从链表的末尾插入，删除和更新节点；否则，我们需要迭代链表直到最后一个节点。如果我们的实现管理单向链表的尾部（称为双头单向链表），那么我们可以在常数时间内在链表的末尾插入节点；否则，我们需要迭代链表直到最后一个节点。
- en: 'The code bundle for this book comes with the following applications (each application
    exposes the `insertFirst()`, `insertLast()`, `insertAt()`, `delete()`, `deleteByIndex()`,
    and `print()` methods):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码包包括以下应用程序（每个应用程序都公开`insertFirst()`、`insertLast()`、`insertAt()`、`delete()`、`deleteByIndex()`和`print()`方法）：
- en: '*SinglyLinkedList*: Implementation of a two-head singly linked list'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SinglyLinkedList*：双头单向链表的实现'
- en: '*SinglyLinkedListOneHead*: Implementation of a single-head singly linked list'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SinglyLinkedListOneHead*：单头单向链表的实现'
- en: '*DoublyLinkedList*: Implementation of a two-head doubly linked list'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DoublyLinkedList*：双头双向链表的实现'
- en: '*DoublyLinkedListOneHead*: Implementation of a single-head doubly linked list'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DoublyLinkedListOneHead*：单头双向链表的实现'
- en: It is highly recommended that you dissect, to the bone, each of these applications
    on your own. Each of them is heavily commented to help you to understand each
    step. The following coding challenges rely on these linked list implementations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己彻底分析这些应用程序。每个应用程序都有大量注释，以帮助您理解每个步骤。以下编码挑战依赖于这些链表实现。
- en: Maps in a nutshell
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，地图
- en: Imagine that you are looking for a word in a dictionary. The word itself is
    unique and can be considered a *key*. The meaning of this word can be considered
    the *value*. Therefore, the word and its meaning form a *key-value pair*. Similarly,
    in computing, a key-value pair accommodates a piece of data in which the value
    can be found by searching with the key. In other words, we know the key and we
    can use it to find the value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在字典中查找一个单词。这个单词本身是唯一的，可以被视为*键*。这个单词的意思可以被视为*值*。因此，这个单词及其意思形成了一个*键值对*。同样，在计算中，键值对容纳了一段数据，可以通过键来查找值。换句话说，我们知道键，我们可以用它来找到值。
- en: 'A map is an **Abstract Data Type** (**ADT**) that manages key-value pairs (known
    as entries) via an array. The characteristics of a map include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是一个**抽象数据类型**（**ADT**），通过数组管理键值对（称为条目）。地图的特征包括以下内容：
- en: Keys are unique (that is, no duplicate keys are allowed).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键是唯一的（即，不允许重复键）。
- en: We can view the list of keys, the list of values, or both.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以查看键的列表，值的列表，或两者。
- en: The most common methods to work with a map are `get()`, `put()`, and `remove()`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理地图的最常见方法是`get()`，`put()`和`remove()`。
- en: Now that we've briefly overviewed the notions of linked lists and maps, let's
    begin our coding challenges.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要概述了链表和地图的概念，让我们开始我们的编码挑战。
- en: Coding challenges
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: 'In the following 17 coding challenges, we will cover a number of problems involving
    maps and linked lists. Since linked lists are a more popular topic in technical
    interviews, we will allocate a higher number of problems to them. However, to
    master the concept of map data structures, especially built-in Java map implementations,
    I strongly recommend that you buy the book *Java Coding Problems*, which is also
    published by Packt Publishing ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    Besides being an awesome companion to this book, *Java Coding Problems* contains
    the following problems with maps (note that this is not a complete list):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的17个编码挑战中，我们将涵盖涉及地图和链表的许多问题。由于链表是技术面试中更受欢迎的话题，我们将为它们分配更多的问题。然而，为了掌握地图数据结构的概念，特别是内置的Java地图实现，我强烈建议您购买Packt
    Publishing出版的书籍*Java编码问题*（[https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)）。除了是本书的绝佳伴侣外，*Java编码问题*还包含以下地图问题（请注意，这不是完整的列表）：
- en: Creating unmodifiable/immutable collections
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不可修改/不可变集合
- en: Mapping a default value
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射默认值
- en: Computing whether a value is absent/present in a `Map`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算`Map`中值的存在/不存在
- en: Removal from a `Map`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Map`中删除
- en: Replacing entries from a `Map`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换`Map`中的条目
- en: Comparing two maps
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个地图
- en: Sorting a `Map`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`Map`进行排序
- en: Copying a `HashMap`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制`HashMap`
- en: Merging two maps
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并两个地图
- en: Removing all the elements of a collection that match a predicate
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除与谓词匹配的集合的所有元素
- en: Now that we have a basic idea of what linked lists and maps are, let's take
    a look at the most popular problems in interviews to do with maps and linked lists.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对链表和地图有了基本的了解，让我们来看看与地图和链表相关的面试中最常见的问题。
- en: Coding challenge 1 – Map put, get, and remove
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - Map put，get和remove
- en: '`put(K k, V v)`, one method named `get(K k)`, and one method named `remove(K
    k)`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`put(K k, V v)`，一个名为`get(K k)`的方法，和一个名为`remove(K k)`的方法。'
- en: '**Solution**: As you know, a map is a key-value pair data structure. Each key-value
    pair is an entry to the map. Therefore, we cannot implement a map''s functionalities
    until we materialize an entry. Since an entry holds two pieces of information,
    we need to define a class that wraps the key and the value in a generic approach.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：正如您所知，地图是一个键值对数据结构。每个键值对都是地图的一个条目。因此，我们无法实现地图的功能，直到我们实现一个条目。由于一个条目包含两个信息，我们需要定义一个类来以通用的方式包装键和值。'
- en: 'The code is quite simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have an entry, we can declare a map. A map is managed via an array
    of entries that have a default size, which is known as the map capacity. A map
    with an initial capacity of 16 elements is declared as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个条目，我们可以声明一个地图。地图通过具有默认大小的条目数组来管理，这个默认大小称为地图容量。具有16个元素的初始容量的地图声明如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we can focus on working with this array to act as a map for the client.
    Putting an entry into the map can only be done if the entry''s key is unique across
    the map. If the given key exists, then we just update its value. In addition to
    this, we can add an entry as long as we haven''t exceeded the map capacity. The
    typical approach in such a case is to double the size of the map. The code based
    on these statements is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以专注于使用这个数组作为客户端的地图。只有在条目的键在地图中是唯一的情况下，才能将条目放入地图中。如果给定的键存在，则只需更新其值。除此之外，只要我们没有超出地图的容量，就可以添加一个条目。在这种情况下的典型方法是将地图的大小加倍。基于这些语句的代码如下：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following helper method is used to double the capacity of the map. Since
    a Java array cannot be resized, we need to tackle this issue by creating a copy
    of the initial array, but with a double the size of the initial array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下辅助方法用于将地图的容量加倍。由于Java数组无法调整大小，我们需要通过创建初始数组的副本，但大小加倍来解决这个问题：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Getting a value is done using the key. If the given key is not found, then
    we return `null`. Getting a value doesn''t remove the entry from the map. Let''s
    take a look at the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键来获取值。如果找不到给定的键，则返回`null`。获取值不会从地图中删除条目。让我们看一下代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we need to remove an entry using the key. Removing an element from
    an array involves shifting the remaining elements by one position. After the elements
    are shifted, the penultimate and last elements are equal. You can avoid memory
    leaks by nullifying the last element of the array. It is a common mistake to forget
    this step:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用键来删除一个条目。从数组中删除一个元素涉及将剩余的元素向前移动一个位置。元素移动后，倒数第二个和最后一个元素相等。通过将数组的最后一个元素置空，可以避免内存泄漏。忘记这一步是一个常见的错误：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The production implementation of a map is much more complicated than the one
    exposed here (for example, a map uses buckets). However, most probably, you won't
    need to know more than this implementation in an interview. Nevertheless, it is
    a good idea to mention this to the interviewer. That way, you can show them you
    understand the complexity of the problem and that you are aware of it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的生产实现比这里展示的要复杂得多（例如，地图使用桶）。然而，很可能在面试中你不需要了解比这个实现更多的内容。尽管如此，向面试官提到这一点是个好主意。这样，你可以向他们展示你理解问题的复杂性，并且你意识到了这一点。
- en: Done! The complete application is named *Map*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序名为*Map*。
- en: Coding challenge 2 – Map the key set and values
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 映射键集和值
- en: '`keySet()`) and a method that returns a collection of values (`values()`).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`keySet()`）和一个返回值集合的方法（`values()`）。'
- en: '`Set`. The following code speaks for itself:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`。以下代码不言自明：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To return a collection of values, we loop the map and add the values, one by
    one, to a `List`. We use a `List` since values can contain duplicates:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回一个值的集合，我们循环遍历映射并将值逐个添加到`List`中。我们使用`List`，因为值可能包含重复项：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Done! This was simple; a map implemented for production is far more complex
    than what is shown here. For example, the values are cached instead of being extracted
    every time. Mention this to the interviewer so she/he can see that you are aware
    of how a production map works. Take your time and check the Java built-in `Map`
    and `HashMap` source code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！这很简单；生产中实现的地图比这里展示的要复杂得多。例如，值被缓存而不是每次都被提取。向面试官提到这一点，让他/她看到你知道生产地图是如何工作的。花点时间检查Java内置的`Map`和`HashMap`源代码。
- en: The complete application is named *Map*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*Map*。
- en: Coding challenge 3 – Nuts and bolts
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 螺母和螺栓
- en: '**Google**, **Adobe**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**Adobe**'
- en: '**Problem**: Given *n* nuts and *n* bolts, consider a one-to-one mapping between
    them. Write a snippet of code that finds all matches between the nuts and bolts
    with the minimum number of iterations.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：给定*n*个螺母和*n*个螺栓，考虑它们之间的一一对应关系。编写一小段代码，找出螺母和螺栓之间的所有匹配项，使迭代次数最少。'
- en: '**Solution**: Let''s consider that the nuts and bolts are represented by the
    following two arrays:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设螺母和螺栓分别由以下两个数组表示：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The most intuitive solution relies on a brute-force approach. We can choose
    a nut and iterate the bolts to find its mate. For example, if we choose `nuts[0]`,
    we can find its mate with `bolts[3]`. Additionally, we can take `nuts[1]` and
    find its mate with `bolts[0]`. This algorithm is very simple to implement via
    two `for` statements and has a complexity time of O(n2).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观的解决方案依赖于蛮力方法。我们可以选择一个螺母，并迭代螺栓以找到它的配偶。例如，如果我们选择`nuts[0]`，我们可以用`bolts[3]`找到它的配偶。此外，我们可以取`nuts[1]`，并用`bolts[0]`找到它的配偶。这个算法非常简单，可以通过两个`for`语句来实现，并且具有O(n2)的时间复杂度。
- en: Alternatively, we can consider sorting the nuts and bolts. This way, the matches
    between the nuts and bolts will automatically align. This will also work, but
    it will not include the minimum number of iterations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以考虑对螺母和螺栓进行排序。这样，螺母和螺栓之间的匹配将自动对齐。这也可以工作，但不会包括最少的迭代次数。
- en: 'In order to obtain a minimum number of iterations, we can use a hash map. In
    this hash map, first, we put each nut as a key and its position in the given array
    of nuts as a value. Next, we iterate the bolts, and we check whether the hash
    map contains each bolt as a key. If the hash map contains a key for the current
    bolt, then we have found a match (a pair); otherwise, there is no match for this
    bolt. Let''s take a look at the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最少的迭代次数，我们可以使用哈希映射。在这个哈希映射中，首先，我们将每个螺母作为一个键，将其在给定螺母数组中的位置作为一个值。接下来，我们迭代螺栓，并检查哈希映射是否包含每个螺栓作为一个键。如果哈希映射包含当前螺栓的键，那么我们找到了一个匹配（一对）；否则，这个螺栓没有匹配。让我们看一下代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The runtime for this code is O(n). The complete code is named *NutsAndBolts*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。完整的代码名为*NutsAndBolts*。
- en: Coding challenge 4 – Remove duplicates
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - 删除重复项
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**'
- en: '**Problem**: Consider an unsorted singly linked list of integers. Write a snippet
    of code that removes duplicates.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个未排序的整数单向链表。编写一小段代码来删除重复项。'
- en: '`Set<Integer>`. However, before adding the data of the current node into the
    `Set`, we check the data against the current contents of the `Set`. If the `Set`
    already contains that data, we remove the node from the linked list; otherwise,
    we just add its data to the `Set`. Removing a node from a singly linked list can
    be done by linking the previous node to the next node of the current node.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set<Integer>`。然而，在将当前节点的数据添加到`Set`之前，我们检查数据是否与`Set`的当前内容相匹配。如果`Set`已经包含该数据，我们就从链表中删除节点；否则，我们只是将其数据添加到`Set`中。从单向链表中删除节点可以通过将前一个节点链接到当前节点的下一个节点来完成。'
- en: 'The following diagram illustrates this statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这个陈述：
- en: '![11.3: Removing a node from a singly linked list'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.3: 从单向链表中删除节点'
- en: '](img/Figure_11.3_B15403.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B15403.jpg)'
- en: Figure 11.3 – Removing a node from a singly linked list
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 从单向链表中删除节点
- en: 'Since a singly linked list holds a pointer to only the next node, we cannot
    know the node previous to the current node. The trick is to track two consecutive
    nodes starting with the current node as the linked list head and the previous
    node as `null`. When the current node advances to the next node, the previous
    node advances to the current node. Let''s look at the code that glues these statements
    together:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单链表只保存指向下一个节点的指针，我们无法知道当前节点之前的节点。技巧是跟踪两个连续的节点，从当前节点作为链表头部和前一个节点作为`null`开始。当当前节点前进到下一个节点时，前一个节点前进到当前节点。让我们看一下将这些语句组合在一起的代码：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This solution works in the time and space complexity of O(n), where *n* is
    the number of nodes in the linked list. We can try another approach that reduces
    space complexity to O(1). First, let''s consider the following diagram as a guide
    for the next steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的时间和空间复杂度为O(n)，其中*n*是链表中的节点数。我们可以尝试另一种方法，将空间复杂度降低到O(1)。首先，让我们将以下图表作为下一步的指南：
- en: '![11.4: Removing a node from a singly linked list'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.4：从单链表中移除节点'
- en: '](img/Figure_11.4_B15403.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B15403.jpg)'
- en: Figure 11.4 – Removing a node from a singly linked list
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 从单链表中移除节点
- en: 'This approach uses two pointers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用两个指针：
- en: The current node, which starts from the head of the linked list and traverses
    the linked list, node by node, until it reaches the tail (for example, in the
    preceding diagram, the current node is the second node).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前节点从链表的头部开始遍历链表，直到到达尾部（例如，在前面的图表中，当前节点是第二个节点）。
- en: The runner node, which starts from the same place as the current node, that
    is, the head of the linked list.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奔跑者节点，从与当前节点相同的位置开始，即链表的头部。
- en: Additionally, the runner node iterates through the linked list and checks whether
    the data of each node is equal to the data of the current node. While the runner
    code iterates through the linked list, the current node's position remains fixed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，奔跑者节点遍历链表，并检查每个节点的数据是否等于当前节点的数据。当奔跑者节点遍历链表时，当前节点的位置保持不变。
- en: 'If the runner node detects a duplicate, then it removes it from the linked
    list. When the runner node reaches the tail of the linked list, the current node
    advances to the next node, and the runner node iterates through the linked list
    again starting from the current node. So, this is an O(n2) time complexity algorithm,
    but with an O(1) space complexity. Let''s take a look at the code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果奔跑者节点检测到重复，那么它会将其从链表中移除。当奔跑者节点到达链表的尾部时，当前节点前进到下一个节点，奔跑者节点再次从当前节点开始遍历链表。因此，这是一个O(n2)时间复杂度的算法，但空间复杂度为O(1)。让我们看一下代码：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The complete code is named *LinkedListRemoveDuplicates*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码名为*LinkedListRemoveDuplicates*。
- en: Coding challenge 5 – Rearranging linked lists
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - 重新排列链表
- en: '**Adobe**, **Flipkart**, **Amazon**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**，**Amazon**'
- en: '**Problem**: Consider an unsorted singly linked list of integers and a given
    integer, *n*. Write a snippet of code that rearranges the nodes around *n*. In
    other words, by the end, the linked list will contain all of the values that are
    less than *n* followed by all of the nodes that are larger than *n*. The order
    of the nodes can be altered and *n* itself can be anywhere between the values
    that are larger than *n*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个未排序的整数单链表和一个给定的整数*n*。编写一小段代码，围绕*n*重新排列节点。换句话说，最后，链表将包含所有小于*n*的值，后面跟着所有大于*n*的节点。节点的顺序可以改变，*n*本身可以位于大于*n*的值之间的任何位置。'
- en: '**Solution**: Consider that the given linked list is 1 → 5 → 4 → 3 → 2 → 7
    → null, and *n*=3\. So, 3 is our pivot. The rest of the nodes should be rearranged
    around this pivot conforming to the problem requirement. One solution to this
    problem is to iterate the linked list node by node and each node that is smaller
    than the pivot is put at the head, while each node that is larger than the pivot
    is put at the tail. The following diagram helps us to visualize this solution:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的链表是1→5→4→3→2→7→null，*n*=3。所以，3是我们的枢轴。其余的节点应该围绕这个枢轴重新排列，符合问题的要求。解决这个问题的一个方法是逐个遍历链表节点，并将小于枢轴的每个节点放在头部，而大于枢轴的每个节点放在尾部。以下图表帮助我们可视化这个解决方案：'
- en: '![11.5: Linked list rearranging'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.5：链表重新排列'
- en: '](img/Figure_11.5_B15403.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.5_B15403.jpg)'
- en: Figure 11.5 – Linked list rearranging
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 链表重新排列
- en: 'So, the nodes with the values of 5, 4, and 3 are moved to the tail, while the
    node with the value of 2 is moved to the head. By the end, all values smaller
    than 3 are on the left side of the dashed line, while all values larger than 3
    are on the right side of the dashed line. We can put this algorithm into code
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，值为5、4和3的节点被移动到尾部，而值为2的节点被移动到头部。最后，所有小于3的值都在虚线的左侧，而所有大于3的值都在虚线的右侧。我们可以将此算法编写成以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The complete application is named *LinkedListRearranging*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListRearranging*。
- en: Coding challenge 6 – The nth to last node
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 倒数第n个节点
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**，**Amazon**，**Google**，**Microsoft**'
- en: '**Problem**: Consider a singly linked list of integers and a given integer,
    *n*. Write a snippet of code that returns the value of the *n*th to last node.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个整数单链表和一个给定的整数*n*。编写一小段代码，返回倒数第n个节点的值。'
- en: '**Solution**: We have a bunch of nodes and we have to find the *n*th node that
    satisfies a given constraint. Based on our experience from [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161),
    *Recursion and Dynamic Programming*, we can intuit that this problem has a solution
    involving recursion. But we can also solve it via an iterative solution. Since
    the iterative solution is more interesting, I will present it here, while the
    recursive solution is available in the bundled code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们有一堆节点，我们必须找到满足给定约束的第*n*个节点。根据我们从[*第8章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)的经验，*递归和动态规划*，我们可以直觉地认为这个问题有一个涉及递归的解决方案。但我们也可以通过迭代解决它。由于迭代解决方案更有趣，我将在这里介绍它，而递归解决方案在捆绑代码中可用。'
- en: 'Let''s use the following diagram to present the algorithm (follow the diagram
    from top to bottom):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下图表来呈现算法（按照从上到下的顺序遵循图表）：
- en: '![11.6: The nth to last node'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.6: The nth to last node'
- en: '](img/Figure_11.6_B15403.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.6_B15403.jpg)'
- en: Figure 11.6 – The nth to last node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 最后第n个节点
- en: 'So, we are given a linked list, 2 → 1 → 5 → 9 → 8 → 3 → 7 → null, and we want
    to find the fifth to last node value, which is 5 (you can see this at the top
    of the preceding diagram). The iterative solution uses two pointers; let''s denote
    them as *runner1* and *runner2*. Initially, both of them point to the head of
    the linked list. In step 1 (the middle of the preceding diagram), we move the
    *runner1* from the head to the 5th to head (or *n*th to head) node. This is easy
    to accomplish in a `for` loop from 0 to 5 (or *n*). In step 2 (the bottom of the
    preceding diagram), we move *runner1* and *runner2* simultaneously until *runner1*
    is `null`. When *runner1* is `null`, *runner2* will point to the fifth from the
    head to last node (or *n*th from the head to last). In code lines, we do it as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个链表，2 → 1 → 5 → 9 → 8 → 3 → 7 → null，并且我们想要找到第五个到最后一个节点值，即5（您可以在前面的图表顶部看到）。迭代解决方案使用两个指针；让我们将它们表示为*runner1*和*runner2*。最初，它们都指向链表的头部。在步骤1（前面图表的中间），我们将*runner1*从头移动到第5个到头（或*n*到头）节点。这在`for`循环中从0到5（或*n*）中很容易实现。在步骤2（前面图表的底部），我们同时移动*runner1*和*runner2*，直到*runner1*为`null`。当*runner1*为`null`时，*runner2*将指向距离头部第五个到最后一个节点（或*n*到最后一个）节点。在代码行中，我们可以这样做：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete application is named *LinkedListNthToLastNode*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListNthToLastNode*。
- en: Coding challenge 7 – Loop start detection
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 - 循环开始检测
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**，**Amazon**，**Google**，**Microsoft**'
- en: '**Problem**: Consider a singly linked list of integers that contains a loop.
    In other words, the tail of the linked list points to one of the previous nodes
    defining a loop or a circularity. Write a snippet of code that detects the first
    node of the loop (that is, the node from which the loop starts).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个包含循环的整数单链表。换句话说，链表的尾部指向之前的一个节点，定义了一个循环或循环。编写一小段代码来检测循环的第一个节点（即循环开始的节点）。'
- en: '`tail.next`. If we don''t manage the tail, then we can search for the node
    that has two nodes pointing to it. This is also quite easy to implement. If we
    know the size of the linked list, then we can iterate from 0 to size, and the
    last `node.next` points to the node that marks the loop start.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail.next`. 如果我们不管理尾部，那么我们可以搜索具有两个指向它的节点的节点。这也很容易实现。如果我们知道链表的大小，那么我们可以从0到大小进行迭代，最后一个`node.next`指向标记循环开始的节点。'
- en: The Fast Runner/Slow Runner approach
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快跑者/慢跑者方法
- en: However, let's try another algorithm that requires more imagination. This approach
    is called the Fast Runner/Slow Runner approach. It is important because it can
    be used in certain problems involving linked lists.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们尝试另一种需要更多想象力的算法。这种方法称为快跑者/慢跑者方法。它很重要，因为它可以用于涉及链表的某些问题。
- en: 'Primarily, the Fast Runner/Slow Runner approach involves using two pointers
    that start from the head of the linked list and iterate through the list simultaneously
    until a certain condition(s) is met. One pointer is named **Slow Runner** (**SR**)
    because it iterates through the list node by node. The other pointer is named
    **Fast Runner** (**FR**) because it iterates through the list by jumping over
    the next node at every move. The following diagram is an example of four moves:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的快跑者/慢跑者方法涉及使用两个指针，它们从链表的头部开始，并同时遍历列表，直到满足某些条件。一个指针被命名为**慢跑者**（**SR**），因为它逐个节点地遍历列表。另一个指针被命名为**快跑者**（**FR**），因为它在每次移动时跳过下一个节点来遍历列表。以下图表是四个移动的示例：
- en: '![11.7: Fast Runner/Slow Runner example](img/Figure_11.7_B15403.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![11.7: Fast Runner/Slow Runner example](img/Figure_11.7_B15403.jpg)'
- en: Figure 11.7 – Fast Runner/Slow Runner example
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 快跑者/慢跑者示例
- en: So, at the first move, *FR* and *SR* are pointing to the *head*. At the second
    move, *SR* points to the *head.next* node with value 1, while *FR* points to the
    *head.next.next* node with value 4\. The moves continue following this pattern.
    When *FR* reaches the tail of the linked list, *SR* is pointing to the middle
    node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一步移动时，*FR*和*SR*指向*head*。在第二步移动时，*SR*指向值为1的*head.next*节点，而*FR*指向值为4的*head.next.next*节点。移动继续遵循这种模式。当*FR*到达链表的尾部时，*SR*指向中间节点。
- en: As you will see in the next coding challenge, the Fast Runner/Slow Runner approach
    can be used to detect whether a linked list is a palindrome. However, for now,
    let's resume our problem. So, can we use this approach to detect whether a linked
    list has a loop and to find the start node of this loop? This question generates
    another question. If we apply the Fast Runner/Slow Runner approach to a linked
    list having a loop, do the *FR* and *SR* pointers collide or meet? The answer
    is yes, they will collide.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在下一个编码挑战中看到的，快跑者/慢跑者方法可以用于检测链表是否是回文。但是，现在让我们恢复我们的问题。那么，我们可以使用这种方法来检测链表是否有循环，并找到此循环的起始节点吗？这个问题引发了另一个问题。如果我们将快跑者/慢跑者方法应用于具有循环的链表，*FR*和*SR*指针会相撞或相遇吗？答案是肯定的，它们会相撞。
- en: 'To explain this, let''s assume that before starting the loop, we have *q* preceding
    nodes (these are the nodes that are outside the loop). For every *q* nodes traversed
    by *SR*, *FR* has traversed 2**q* nodes (this is obvious since *FR* jumps over
    a node at every move). Therefore, when *SR* enters the loop (reaches the loop
    start node), *FR* has traversed 2**q* nodes. In other words, *FR* is at 2**q-q*
    nodes in the loop portion; therefore, it is at *q* nodes in the loop portion.
    Let''s visualize this via the following test case:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解释一下，假设在开始循环之前，我们有*q*个先行节点（这些节点在循环外）。对于*SR*遍历的每个*q*个节点，*FR*已经遍历了2**q*个节点（这是显而易见的，因为*FR*在每次移动时都会跳过一个节点）。因此，当*SR*进入循环（到达循环起始节点）时，*FR*已经遍历了2**q*个节点。换句话说，*FR*在循环部分的2**q-q*节点处；因此，它在循环部分的*q*个节点处。让我们通过以下测试案例来形象化这一点：
- en: '![11.8: Linked list with a loop'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.8: 带有循环的链表'
- en: '](img/Figure_11.8_B15403.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.8_B15403.jpg)'
- en: Figure 11.8 – Linked list with a loop
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 带有循环的链表
- en: So, when *SR* enters the loop (reaches the fourth node), *FR* reaches the fourth
    node into the loop. Of course, we need to consider that *q* (the number of preceding
    non-loop nodes) might be much larger than the loop length; therefore, we should
    express 2**q-q* as *Q=modulo(q, LOOP_SIZE)*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当*SR*进入循环（到达第四个节点）时，*FR*也到达了循环的第四个节点。当然，我们需要考虑到*q*（先行非循环节点的数量）可能比循环长度要大得多；因此，我们应该将2**q-q*表示为*Q=modulo(q,
    LOOP_SIZE)*。
- en: For example, consider *Q = modulo*(3, 8) =3, where we have three non-loop nodes
    (*q*=3) and the loop size is eight (*LOOP_SIZE=*8). In this case, we can apply
    2**q-q* as well since 2*3-3=3\. Hence, we can conclude that *SR* is at three nodes
    from the start of the list and *FR* is at three nodes from the start of the loop.
    However, if the linked list has 25 nodes that precede a loop of 7 nodes, then
    *Q = modulo* (25, 7) = 4 nodes, while 2*25-25=25, which is wrong.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑*Q = modulo*(3, 8) =3，其中我们有三个非循环节点（*q*=3），循环大小为八（*LOOP_SIZE*=8）。在这种情况下，我们也可以应用2**q-q*，因为2*3-3=3。因此，我们可以得出*SR*距离列表开头三个节点，*FR*距离循环开头三个节点。然而，如果链表前面有25个节点，后面有7个节点的循环，那么*Q
    = modulo* (25, 7) = 4个节点，而2*25-25=25，这是错误的。
- en: 'In addition to this, *FR* and *SR* are moving inside the loop. Since they are
    moving in a circle, it means that when *FR* moves away from *SR*, it also moves
    closer to *SR* and vice versa. The following diagram isolates the loop and shows
    how it continues moving *FR* and *SR* until they collide:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，*FR*和*SR*在循环内移动。由于它们在一个圆圈内移动，这意味着当*FR*远离*SR*时，它也在向*SR*靠近，反之亦然。下图将循环隔离出来，并展示了它们如何继续移动*FR*和*SR*直到它们相撞：
- en: '![11.9: FR and SR collision](img/Figure_11.9_B15403.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![11.9: FR and SR collision](img/Figure_11.9_B15403.png)'
- en: Figure 11.9 – FR and SR collision
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - FR和SR碰撞
- en: Take your time tracking *SR* and *FR* until they reach the meet point. We know
    that *FR* is at *LOOP_SIZE – Q* nodes behind *FR* and that *SR* is *Q* nodes behind
    *FR*. In our test case, *FR* is 8-3=5 nodes behind *SR*, and *SR* is 3 nodes behind
    *FR*. By continuing to move *SR* and *FR*, we can see that *FR* catches up at
    a rate of 1 step per move.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间追踪*SR*和*FR*直到它们到达相遇点。我们知道*FR*比*FR*落后*LOOP_SIZE - Q*个节点，*SR*比*FR*落后*Q*个节点。在我们的测试案例中，*FR*比*SR*落后8-3=5个节点，*SR*比*FR*落后3个节点。继续移动*SR*和*FR*，我们可以看到*FR*以每次移动1步的速度追上了。
- en: So, where do they meet? Well, if *FR* catches up at a rate of 1 step per move
    and *FR* is *LOOP_SIZE – Q* nodes behind *SR*, then they will meet *Q* steps before
    the head of the loop. In our test case, they will meet 3 steps before the head
    of the loop at the node with a value of 8.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它们在哪里相遇呢？如果*FR*以每次移动1步的速度追上，*FR*比*SR*落后*LOOP_SIZE - Q*个节点，那么它们将在离循环头部*Q*步的地方相遇。在我们的测试案例中，它们将在距离循环头部3步的地方相遇，节点值为8。
- en: 'If the meet point is at *Q* nodes from the head of the loop, we can continue
    by recalling that the meet point is at *q* nodes from the head of the loop as
    well, since *Q=modulo(q, LOOP_SIZE)*. This means that we can develop the following
    four-step algorithm:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相遇点距离循环头部的节点数为*Q*，我们可以继续回想相遇点距离循环头部的节点数也为*q*，因为*Q=modulo(q, LOOP_SIZE)*。这意味着我们可以制定以下四步算法：
- en: Start with *FR* and *SR* from the head of the linked list.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从链表的头部开始*FR*和*SR*。
- en: Move *SR* at a rate of 1 node and *FR* at a rate of 2 nodes.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*SR*以1个节点的速度移动，*FR*以2个节点的速度移动。
- en: When they collide (at the meet point), move *SR* to the head of the linked list
    and keep *FR* where it is.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它们相撞（在相遇点），将*SR*移动到链表的头部，保持*FR*在原地。
- en: Move *SR* and *FR* at a rate of 1 node until they collide (this is the node
    representing the head of the loop).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*SR*和*FR*以1个节点的速度移动，直到它们相撞（这是代表循环头部的节点）。
- en: 'Let''s put this into code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这写成代码：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As a quick note, don't expect that *FR* can jump over *SR*, so they will not
    meet. This scenario is not possible. Imagine that *FR* has jumped over *SR* and
    it is at node *a*, then *SR* must be at node *a*-1\. This means that, at the previous
    step, *FR* was at node *a*-2 and *SR* was at node (*a*-1)-1=*a*-2; therefore,
    they have collided.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的提示，不要期望*FR*能够跳过*SR*，所以它们不会相遇。这种情况是不可能的。想象一下，*FR*已经跳过了*SR*，它在节点*a*，那么*SR*必须在节点*a*-1。这意味着，在上一步中，*FR*在节点*a*-2，*SR*在节点(*a*-1)-1=*a*-2；因此，它们已经相撞了。
- en: The complete application is named *LinkedListLoopDetection*. In this code, you'll
    find a method named `generateLoop()`. This method is called to generate random
    linked lists with loops.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListLoopDetection*。在这段代码中，你会找到一个名为`generateLoop()`的方法。调用这个方法可以生成带有循环的随机链表。
- en: Coding challenge 8 – Palindromes
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8 - 回文
- en: '**Adobe**, **Flipkart**, **Amazon**, **Google**, **Microsoft**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe，Flipkart，Amazon，Google，Microsoft
- en: '`true` if the linked list is a palindrome. The solution should involve the
    Fast Runner/Slow Runner approach (this approach was detailed in the previous coding
    challenge).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链表是回文的，则返回`true`。解决方案应该涉及快速运行者/慢速运行者方法（这种方法在先前的编码挑战中有详细介绍）。
- en: '**Solution**: Just as a quick reminder, a palindrome (whether a string, a number,
    or a linked list) looks unchanged when it''s reversed. This means that processing
    (reading) a palindrome can be done from both directions and the same result will
    be obtained (for example, the number 12321 is a palindrome, while the number 12322
    is not).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：只是一个快速提醒，回文（无论是字符串、数字还是链表）在翻转时看起来没有变化。这意味着处理（读取）回文可以从两个方向进行，得到的结果是相同的（例如，数字12321是一个回文，而数字12322不是）。'
- en: We can intuit a solution that involves the Fast Runner/Slow Runner approach
    by thinking that when *FR* reaches the end of the linked list, *SR* is in the
    middle of the linked list.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过思考，当*FR*到达链表的末尾时，*SR*正好在链表的中间，来直观地得出使用快慢指针方法的解决方案。
- en: 'If the first half of the linked list is the reverse of the second half, then
    the linked list is a palindrome. So, if, in a stack, we store all of the nodes
    traversed by *SR* until *FR* reaches the end of the linked list, the resulting
    stack will contain the first half of the linked list in reverse order. Let''s
    visualize this via the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链表的前半部分是后半部分的倒序，那么链表就是一个回文。因此，如果我们在栈中存储*FR*到达链表末尾之前*SR*遍历的所有节点，那么结果栈将包含链表前半部分的倒序。让我们通过以下图表来可视化这一点：
- en: '![11.10: Linked list palindrome using the Fast Runner/Slow Runner approach'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.10：使用快慢指针方法的链表回文'
- en: '](img/Figure_11.10_B15403.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.10_B15403.jpg)'
- en: Figure 11.10 – Linked list palindrome using the Fast Runner/Slow Runner approach
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 - 使用快慢指针方法的链表回文
- en: 'So, when *FR* has reached the end of the linked list and *SR* has reached the
    fourth node (the middle of the linked list), the stack contains the values of
    2, 1, and 4\. Next, we can continue to move *SR* at a rate of 1 node until the
    end of the linked list. At each move, we pop a value from the stack, and we compare
    it with the current node value. If we find a mismatch, then the linked list is
    not a palindrome. In the code, we have the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当*FR*到达链表的末尾，*SR*到达第四个节点（链表的中间）时，栈包含值2、1和4。接下来，我们可以继续以1个节点的速度移动*SR*，直到链表的末尾。在每次移动时，我们从栈中弹出一个值，并将其与当前节点的值进行比较。如果我们发现不匹配，那么链表就不是回文。在代码中，我们有以下内容：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete application is named *LinkedListPalindrome*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListPalindrome*。
- en: Coding challenge 9 – Sum two linked lists
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9 - 两个链表相加
- en: '**Adobe**, **Flipkart**, **Microsoft**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**，**Microsoft**'
- en: '**Problem**: Consider two positive integers and two singly linked lists. The
    first integer is stored in the first linked list digit by digit (the first digit
    is the head of the first linked list). The second integer is stored in the second
    linked list digit by digit (the first digit is the head of the second linked list).
    Write a snippet of code that adds the two numbers and returns the sum as a linked
    list having one digit per node.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正整数和两个单链表。第一个整数按位存储在第一个链表中（第一个数字是第一个链表的头）。第二个整数按位存储在第二个链表中（第一个数字是第二个链表的头）。编写一小段代码，将这两个数字相加，并将和作为一个链表返回，每个节点一个数字。'
- en: '**Solution**: Let''s start with a visualization of a test case:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们从一个测试案例的可视化开始：'
- en: '![11.11: Summing two numbers as linked lists'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.11：将两个数字作为链表相加'
- en: '](img/Figure_11.11_B15403.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B15403.jpg)'
- en: Figure 11.11 – Summing two numbers as linked lists
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 - 将两个数字作为链表相加
- en: 'If we compute the sum from the preceding diagram step by step, we obtain the
    following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们逐步计算前面图表的总和，我们得到以下结果：
- en: 'We add 7 + 7 = 14, so we write down 4 and carry 1:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加7 + 7 = 14，所以我们写下4并携带1：
- en: The resulting linked list is 4 → ?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 →？
- en: 'We add 3 + 9 + 1 = 13, so we write down 3 and carry 1:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加3 + 9 + 1 = 13，所以我们写下3并携带1：
- en: The resulting linked list is 4 → 3 → ?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 →？
- en: 'We add 8 + 8 + 1 = 17, so we write down 7 and carry 1:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加8 + 8 + 1 = 17，所以我们写下7并携带1：
- en: The resulting linked list is 4 → 3 → 7 → ?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 → 7 →？
- en: We add 9 + 4 + 1 = 14, so we write down 4 and carry 1
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加9 + 4 + 1 = 14，所以我们写下4并携带1
- en: The resulting linked list is 4 → 3 → 7 → 4 → ?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 → 7 → 4 →？
- en: 'We add 4 + 1 = 5, so we write down 5 and carry nothing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加4 + 1 = 5，所以我们写下5并携带无：
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → ?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 → 7 → 4 → 5 →？
- en: 'We add 1 + 0 = 1, so we write down 1 and carry nothing:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加1 + 0 = 1，所以我们写下1并携带无：
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → 1 → ?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 → 7 → 4 → 5 → 1 →？
- en: 'We add 2 + 0 = 2, so we write down 2 and carry nothing:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加2 + 0 = 2，所以我们写下2并携带无：
- en: The resulting linked list is 4 → 3 → 7 → 4 → 5 → 1 → 2
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果链表是4 → 3 → 7 → 4 → 5 → 1 → 2
- en: 'If we write the resulting linked list as a number, we obtain 4374512; therefore,
    we need to reverse it to 2154734\. While the method for reversing the resulting
    linked list (which can be considered a coding challenge itself) can be found in
    the bundled code, the following method applies the preceding steps in a recursive
    approach (if you are not skilled in recursion problems, don''t forget to cover
    [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161), *Recursion and
    Dynamic Programming*). Essentially, the following recursion works by adding data
    node by node, carrying over any excess data to the next node:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将结果链表写成一个数字，我们得到4374512；因此，我们需要将其反转为2154734。虽然反转结果链表的方法（可以被视为一个编码挑战）可以在捆绑代码中找到，但以下方法以递归的方式应用了前面的步骤（如果你不擅长递归问题，请不要忘记阅读[*第8章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)，*递归和动态规划*）。基本上，以下递归通过逐个节点添加数据，将任何多余的数据传递到下一个节点：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete application is named *LinkedListSum*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListSum*。
- en: Coding challenge 10 – Linked lists intersection
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 - 链表交集
- en: '**Adobe**, **Flipkart**, **Google**, **Microsoft**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**，**Google**，**Microsoft**'
- en: '**Problem**: Consider two singly linked lists. Write a snippet of code that
    checks whether the two lists intersect. The intersection is based on reference,
    not on value, but you should return the value of the intersection node. So, check
    the intersection by reference and return the value.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个单链表。编写一小段代码，检查这两个列表是否相交。交集是基于引用的，而不是基于值的，但是你应该返回交集节点的值。因此，通过引用检查交集并返回值。'
- en: '**Solution**: If you are not sure what the *intersection of two linked lists*
    means, then we recommended that you sketch a test case and discuss the details
    with the interviewer. The following diagram shows such a case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如果你不确定*两个链表的交集*是什么意思，那么我们建议你勾画一个测试用例，并与面试官讨论细节。下面的图表展示了这样一个情况：'
- en: '![11.12: The intersection of two lists'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.12: 两个列表的交集'
- en: '](img/Figure_11.12_B15403.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.12_B15403.jpg)'
- en: Figure 11.12 – The intersection of two lists
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 两个列表的交集
- en: In this diagram, we have two lists that intersect at the node with value 8\.
    Because we are talking about an intersection by reference, this means that the
    nodes with the value of 9, and value of 4, point to the memory address of the
    node with the value of 8.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们有两个相交的列表，它们在值为8的节点处相交。因为我们谈论的是引用交集，这意味着值为9和值为4的节点指向值为8的节点的内存地址。
- en: 'The main issue is that the lists are not of the same size. If their sizes were
    equal, we could traverse both of them, node by node, from head to tail until they
    collide (until *node_list_1.next= node_list_2.next*). If we could skip the nodes
    with values of 2 and 1, our lists will be the same size (refer to the next diagram;
    since the first list is longer than the second list, we should start iterating
    from the node marked *virtual head*):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是列表的大小不同。如果它们的大小相等，我们可以从头到尾遍历它们，逐个节点，直到它们相撞（直到*node_list_1.next= node_list_2.next*）。如果我们能跳过值为2和1的节点，我们的列表将是相同大小的（参考下一个图表；因为第一个列表比第二个列表长，我们应该从标记为*虚拟头*的节点开始迭代）：
- en: '![11.13: Removing the first two nodes of the top list'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.13: Removing the first two nodes of the top list'
- en: '](img/Figure_11.13_B15403.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.13_B15403.jpg)'
- en: Figure 11.13 – Removing the first two nodes of the top list
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 移除顶部列表的前两个节点
- en: 'Keeping this statement in mind, we can deduce the following algorithm:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个陈述，我们可以推导出以下算法：
- en: Determine the sizes of the lists.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定列表的大小。
- en: If the first list (let's denote it as *l1*) is longer than the second one (let's
    denote it as *l2*), then move the pointer of the first list to (*l1-l2*).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第一个列表（我们将其表示为*l1*）比第二个列表（我们将其表示为*l2*）长，那么将第一个列表的指针移动到（*l1-l2*）。
- en: If the first list is shorter than the second one, then move the pointer of the
    second list to (*l2-l1*).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第一个列表比第二个列表短，那么将第二个列表的指针移动到（*l2-l1*）。
- en: Move both pointers, node by node, until you reach the end or until they collide.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个移动两个指针，直到达到末尾或者它们相撞为止。
- en: 'Putting these steps into code is straightforward:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤转化为代码是直接的：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is named *LinkedListsIntersection*. In the code, you
    will see a helper method named `generateTwoLinkedListWithInterection()`. This
    is used to generate random lists with an intersection point.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListsIntersection*。在代码中，你会看到一个名为`generateTwoLinkedListWithInterection()`的辅助方法。这用于生成具有交集点的随机列表。
- en: Coding challenge 11 – Swap adjacent nodes
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 – 交换相邻节点
- en: '**Amazon**, **Google**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Consider a singly linked list. Write a snippet of code that swaps
    the adjacent nodes so that a list such as 1 → 2 → 3 → 4 → null becomes 2 → 1 →
    4 → 3 → null. Consider swapping the adjacent nodes, not their values!'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个单链表。编写一小段代码，交换相邻的节点，使得一个列表，比如1 → 2 → 3 → 4 → null，变成2 → 1 → 4 →
    3 → null。考虑交换相邻的节点，而不是它们的值！'
- en: '**Solution**: We can reduce the problem of finding a solution to swap two consecutive
    nodes, *n1* and *n2*. A well-known technique to swap two values (for example,
    two integers, *v1* and *v2*) relies on an auxiliary variable and can be written
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以将交换两个相邻节点*n1*和*n2*的问题简化为找到解决方案。交换两个值（例如，两个整数*v1*和*v2*）的一个众所周知的技巧依赖于一个辅助变量，并且可以写成如下形式：'
- en: '*aux = v1; v1 = v2; v2 = aux;*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*aux = v1; v1 = v2; v2 = aux;*'
- en: 'However, we cannot apply this plain approach to nodes because we have to deal
    with their links. It is not enough to write the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能对节点应用这种简单的方法，因为我们必须处理它们的链接。仅仅写下面这样是不够的：
- en: '*aux = n1; n1 = n2; n2 = aux;*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*aux = n1; n1 = n2; n2 = aux;*'
- en: 'If we rely on this plain approach to swap *n1* with *n2*, then we will obtain
    something similar to the following diagram (notice that after swapping *n1* with
    *n2*, we have *n1.next* = *n3* and *n2.next* = *n1*, which is totally wrong):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们依赖这种简单的方法来交换*n1*和*n2*，那么我们将得到类似于以下图表的东西（注意，在交换*n1*和*n2*之后，我们有*n1.next* =
    *n3*和*n2.next* = *n1*，这是完全错误的）：
- en: '![11.14: Plain swapping with broken links (1)](img/Figure_11.14_B15403.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![11.14: Plain swapping with broken links (1)](img/Figure_11.14_B15403.jpg)'
- en: Figure 11.14 – Plain swapping with broken links (1)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 交换破损链接（1）
- en: 'But we can fix the links, right? Well, we can explicitly set *n1.next* to point
    to *n2*, and set *n2.next* to point to *n3*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以修复链接，对吧？嗯，我们可以明确地设置*n1.next*指向*n2*，并设置*n2.next*指向*n3*：
- en: '*n1.next = n2*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*n1.next = n2*'
- en: '*n2.next = n3*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*n2.next = n3*'
- en: 'Now it should be good! We can swap two consecutive nodes. However, when we
    swap a pair of nodes, we also break the links between two consecutive pairs of
    nodes. The following diagram illustrates this issue (we swap and fix the links
    for the *n1-n2* pair and the *n3-n4* pair):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该没问题了！我们可以交换两个相邻的节点。然而，当我们交换一对节点时，我们也会破坏两对相邻节点之间的链接。下面的图表说明了这个问题（我们交换并修复了*n1-n2*对和*n3-n4*对的链接）：
- en: '![11.15: Plain swapping with broken links (2)](img/Figure_11.15_B15403.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![11.15: Plain swapping with broken links (2)](img/Figure_11.15_B15403.jpg)'
- en: Figure 11.15 – Plain swapping with broken links (2)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 – 交换破损链接（2）
- en: 'Notice that after swapping these two pairs, *n2.next* points to *n4*, which
    is wrong. Hence, we must fix this link as well. For this, we can store *n2*, and,
    after swapping *n3-n4*, we can repair the link by setting *n2.next=n3*. Now, everything
    looks good and we can put it into code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在交换这两对之后，*n2.next*指向了* n4*，这是错误的。因此，我们必须修复这个链接。为此，我们可以存储*n2*，在交换*n3-n4*之后，我们可以通过设置*n2.next=n3*来修复链接。现在，一切看起来都很好，我们可以将其放入代码中：
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is named *LinkedListPairwiseSwap*. Consider challenging
    yourself to swap sequences of *n* nodes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListPairwiseSwap*。考虑挑战自己交换*n*个节点的序列。
- en: Coding challenge 12 – Merge two sorted linked lists
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 合并两个排序的链表
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider two sorted singly linked lists. Write a snippet of code
    that merges these two lists without extra space.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个排序的单链表。编写一小段代码，将这两个列表合并而不使用额外空间。'
- en: '**Solution**: So, we have two sorted lists, *list1*: 4 → 7 → 8 → 10 → null
    and *list2*: 5 → 9 → 11 → null, and we want to obtain the result, 4 → 5 → 7 →
    8 → 9 → 10 → 11 → null. Moreover, we want to obtain this result without allocating
    new nodes.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：所以，我们有两个排序的列表，*list1*：4 → 7 → 8 → 10 → null和*list2*：5 → 9 → 11 → null，我们希望得到结果，4
    → 5 → 7 → 8 → 9 → 10 → 11 → null。此外，我们希望在不分配新节点的情况下获得这个结果。'
- en: Since we cannot allocate new nodes, we have to choose one of these lists to
    become the final result or the merged linked list. In other words, we can start
    with *list1* as the merged linked list and add nodes from *list2* at the appropriate
    place in *list1*. After processing each comparison, we move the pointer (*list1*)
    to the last node in the merged list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能分配新节点，我们必须选择其中一个列表成为最终结果或合并的链表。换句话说，我们可以从*list1*开始作为合并的链表，并在*list1*的适当位置添加*list2*的节点。在处理每次比较后，我们将指针（*list1*）移动到合并列表的最后一个节点。
- en: 'For example, we start by comparing the heads of these two lists. If the head
    of *list1* is smaller than the head of *list2*, we choose the head of *list1*
    as the head of the merged list. Otherwise, if the head of *list1* is bigger than
    the head of *list2*, we swap the heads. The following diagram illustrates this
    step:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们首先比较这两个列表的头部。如果*list1*的头部小于*list2*的头部，我们选择*list1*的头部作为合并列表的头部。否则，如果*list1*的头部大于*list2*的头部，我们交换头部。以下图表说明了这一步骤：
- en: '![Figure 11.16 – Merging two sorted linked lists (step 1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16 - 合并两个排序的链表（步骤1）'
- en: '](img/Figure_11.16_B15403.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.16_B15403.jpg)'
- en: Figure 11.16 – Merging two sorted linked lists (step 1)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 - 合并两个排序的链表（步骤1）
- en: 'Since the head of *list1* is less than the head of *list2* (4 < 5), it becomes
    the head of the merged list. We said that *list1* will point to the last node
    of the merged list; therefore, the next node to compare should be *list1.next*
    (the node with value 7) and *list2* (the node with value 5). The following diagram
    reveals the result of this comparison:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*list1*的头部小于*list2*的头部（4 < 5），它成为了合并列表的头部。我们说*list1*将指向合并列表的最后一个节点；因此，下一个要比较的节点应该是*list1.next*（值为7的节点）和*list2*（值为5的节点）。以下图表显示了这个比较的结果：
- en: '![Figure 11.17 – Merging two sorted linked lists (step 2)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17 - 合并两个排序的链表（步骤2）'
- en: '](img/Figure_11.17_B15403.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.17_B15403.jpg)'
- en: Figure 11.17 – Merging two sorted linked lists (step 2)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 - 合并两个排序的链表（步骤2）
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 5, but we cannot do it directly. If we say
    *list1.next=list2*, then we lose the rest of *list1*. Therefore, we have to perform
    a swap, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*list1*跟随合并后的列表（最终结果），我们必须将*list1.next*移动到值为5的节点，但我们不能直接这样做。如果我们说*list1.next=list2*，那么我们就会失去*list1*的其余部分。因此，我们必须执行一次交换，如下所示：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we move *list1* to *list1.next*, which is the node with value 9\. We
    compare *list.next* with *list2*; therefore, we compare 9 with 7\. The following
    diagram reveals the result of this comparison:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将*list1*移动到*list1.next*，也就是值为9的节点。我们将*list.next*与*list2*进行比较；因此，我们将9与7进行比较。以下图表显示了这个比较的结果：
- en: '![Figure 11.18 – Merging two sorted linked lists (step 3)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18 - 合并两个排序的链表（步骤3）'
- en: '](img/Figure_11.18_B15403.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.18_B15403.jpg)'
- en: Figure 11.18 – Merging two sorted linked lists (step 3)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 - 合并两个排序的链表（步骤3）
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 7 (since 7 < 9), and we do it using the swap
    that we discussed earlier. Next, we move *list1* to *list1.next*, which is the
    node with value 8\. We compare *list.next* with *list2*; therefore, we compare
    8 with 9\. The following diagram reveals the result of this comparison:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*list1*跟随合并后的列表（最终结果），我们必须将*list1.next*移动到值为7的节点（因为7 < 9），我们使用之前讨论过的交换来完成。接下来，我们将*list1*移动到*list1.next*，也就是值为8的节点。我们将*list.next*与*list2*进行比较；因此，我们将8与9进行比较。以下图表显示了这个比较的结果：
- en: '![Figure 11.19 – Merging two sorted linked lists (step 4)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19 - 合并两个排序的链表（步骤4）'
- en: '](img/Figure_11.19_B15403.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.19_B15403.jpg)'
- en: Figure 11.19 – Merging two sorted linked lists (step 4)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 - 合并两个排序的链表（步骤4）
- en: 'Since 8 < 9, no swap is needed. We move *list1.next* to the next node (the
    node with value 10) and compare 10 with 9\. The next diagram reveals the result
    of this comparison:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于8 < 9，不需要交换。我们将*list1.next*移动到下一个节点（值为10的节点）并将10与9进行比较。下一个图表显示了这个比较的结果：
- en: '![Figure 11.20 – Merging two sorted linked lists (step 5)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20 - 合并两个排序的链表（步骤5）'
- en: '](img/Figure_11.20_B15403.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.20_B15403.jpg)'
- en: Figure 11.20 – Merging two sorted linked lists (step 5)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 - 合并两个排序的链表（步骤5）
- en: 'As *list1* follows the merged list (the final result), we have to move *list1.next*
    to the node with value 9 (since 9 < 10), and we do it using the swap that we discussed
    earlier. Next, we move *list1* to *list1.next*, which is the node with value 11\.
    We compare *list.next* with *list2*; therefore, we compare 11 with 10\. The next
    diagram reveals the result of this comparison:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*list1*跟随合并后的列表（最终结果），我们必须将*list1.next*移动到值为9的节点（因为9 < 10），我们使用之前讨论过的交换来完成。接下来，我们将*list1*移动到*list1.next*，这是值为11的节点。我们将*list.next*与*list2*进行比较；因此，我们将11与10进行比较。下一个图表显示了这个比较的结果：
- en: '![11.21: Merging two sorted linked lists (step 6)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.21：合并两个排序的链表（第6步）'
- en: '](img/Figure_11.21_B15403.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.21_B15403.jpg)'
- en: Figure 11.21 – Merging two sorted linked lists (step 6)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 - 合并两个排序的链表（第6步）
- en: 'Because *list1* follows the merged list (the final result), we have to move
    *list1.next* to the node with value 10 (since 10 < 11), and we do it using the
    swap that we discussed earlier. Next, we move *list1* to *list1.next*, which is
    `null`; therefore, we copy the remaining part from *list2*. The next diagram reveals
    the result of this comparison:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*list1*跟随合并后的列表（最终结果），我们必须将*list1.next*移动到值为10的节点（因为10 < 11），我们使用之前讨论过的交换来完成。接下来，我们将*list1*移动到*list1.next*，这是`null`；因此，我们从*list2*中复制剩余部分。下一个图表显示了这个比较的结果：
- en: '![11.22: Merging two sorted linked lists (last step)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.22：合并两个排序的链表（最后一步）'
- en: '](img/Figure_11.22_B15403.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.22_B15403.jpg)'
- en: Figure 11.22 – Merging two sorted linked lists (last step)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 - 合并两个排序的链表（最后一步）
- en: 'At this point, the merged linked list is complete. It is time to reveal the
    code (this method is added to the well-known `SinglyLinkedList`):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，合并后的链表已经完成。现在是时候揭示代码了（这个方法被添加到了著名的`SinglyLinkedList`中）：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete application is named *LinkedListMergeTwoSorted*. A similar problem
    may require you to merge two sorted linked lists via recursion. While you can
    find this application named as *LinkedListMergeTwoSortedRecursion,* I advise you
    to challenge yourself to try an implementation. Additionally, based on this recursive
    implementation, challenge yourself to merge *n*-linked lists. The complete application
    is named *LinkedListMergeNSortedRecursion.*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListMergeTwoSorted*。类似的问题可能要求您通过递归合并两个排序的链表。虽然您可以找到名为*LinkedListMergeTwoSortedRecursion*的应用程序，但我建议您挑战自己尝试一种实现。此外，基于这种递归实现，挑战自己合并*n*个链表。完整的应用程序名为*LinkedListMergeNSortedRecursion*。
- en: Coding challenge 13 – Remove the redundant path
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 去除多余路径
- en: '**Problem**: Consider a singly linked list storing a path in a matrix. The
    data of a node is of type (*row, column*) or, in short, (*r, c*). The path can
    only be either horizontal (by *column*) or vertical (by *row*). The complete path
    is given by the end points of all of the horizontal and vertical paths; therefore,
    the middle points (or points in between) are redundant. Write a snippet of code
    that removes the redundant path.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个存储矩阵中路径的单链表。节点的数据类型为(*行，列*)或简写为(*r，c*)。路径只能是水平（按*列*）或垂直（按*行*）。完整路径由所有水平和垂直路径的终点给出；因此，中间点（或中间的点）是多余的。编写一小段代码，删除多余的路径。'
- en: '**Solution**: Let''s consider a linked list containing the following path:
    (0, 0) → (0, 1) → (0, 2) → (1, 2) → (2, 2) → (3, 2) → (3, 3) → (3, 4) → null.
    The redundant path includes the following nodes: (0, 1), (1, 2), (2, 2), and (3,
    3). So, after removing the redundant path, we should remain with a list that contains
    four nodes: (0, 0) → (0, 2) → (3, 2) → (3, 4) → null. The following diagram represents
    the redundant path:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑一个包含以下路径的链表：(0, 0) → (0, 1) → (0, 2) → (1, 2) → (2, 2) → (3,
    2) → (3, 3) → (3, 4) → null。多余的路径包括以下节点：(0, 1)，(1, 2)，(2, 2)和(3, 3)。因此，在移除多余路径后，我们应该保留一个包含四个节点的列表：(0,
    0) → (0, 2) → (3, 2) → (3, 4) → null。下一个图表表示了多余的路径：'
- en: '![11.23: The redundant path'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.23：多余的路径'
- en: '](img/Figure_11.23_B15403.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.23_B15403.jpg)'
- en: Figure 11.23 – The redundant path
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 - 多余的路径
- en: 'After removing the redundant path, we obtain the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 去除多余路径后，我们得到以下图表：
- en: '![11.24: The remaining path after removing the redundancy'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.24：去除冗余后的剩余路径'
- en: '](img/Figure_11.24_B15403.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.24_B15403.jpg)'
- en: Figure 11.24 – The remaining path after removing the redundancy
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 - 去除冗余后的剩余路径
- en: 'The preceding diagrams should suggest a solution to this problem. Notice that
    the nodes that define a vertical path have the same column since we move only
    down/up on the rows, while the nodes that define a horizontal path have the same
    row since we move only left/right on the columns. This means that if we consider
    three consecutive nodes having the same value for the column or the row, then
    we can remove the middle node. Repeating this process for adjacent triplets will
    remove all redundant nodes. The code should be quite simple to follow:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表应该提供了这个问题的解决方案。请注意，定义垂直路径的节点具有相同的列，因为我们只在行上下移动，而定义水平路径的节点具有相同的行，因为我们只在列左右移动。这意味着，如果我们考虑具有相同列或行的值的三个连续节点，那么我们可以移除中间节点。对相邻三元组重复此过程将移除所有多余节点。代码应该非常简单易懂：
- en: '[PRE23]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The complete application is named *LinkedListRemoveRedundantPath*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListRemoveRedundantPath*。
- en: Coding challenge 14 – Move the last node to the front
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - 将最后一个节点移到最前面
- en: '**Problem**: Consider a singly linked list. Write a snippet of code that moves
    the last node to the front via two approaches. So, the last node of the linked
    list becomes its head.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个单链表。编写一小段代码，通过两种方法将最后一个节点移到最前面。因此，链表的最后一个节点变为头节点。'
- en: '**Solution**: This is the kind of problem that sounds simple, and it is simple.
    The first approach will follow these steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这是一个听起来简单并且确实简单的问题。第一种方法将遵循以下步骤：'
- en: Move a pointer to the second to last node (let's denote it as *currentNode*).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指针移动到倒数第二个节点（我们将其表示为*currentNode*）。
- en: Store the *currentNode.next* (let's denote it as *nextNode* – this is the last
    node).
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储*currentNode.next*（我们将其表示为*nextNode* - 这是最后一个节点）。
- en: Set `cu`*rrentNode.next* to `null` (so, the last node becomes the tail).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`cu`*rrentNode.next*设置为`null`（因此，最后一个节点变为尾部）。
- en: Set the new head as the stored node (so, the head becomes *nextNode*).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的头部设置为存储的节点（因此，头部变为*nextNode*）。
- en: 'In code lines, we have the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，我们有以下内容：
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second approach can be performed with the following steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可以通过以下步骤执行：
- en: Move a pointer to the second to last node (let's denote it as *currentNode*).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指针移动到倒数第二个节点（我们将其表示为*currentNode*）。
- en: Convert the linked list into a circular list (link *currentNode.next.next* to
    the head).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将链表转换为循环列表（将*currentNode.next.next*链接到头部）。
- en: Set the new head as *currentNode.next*.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的头部设置为*currentNode.next*。
- en: Break the circularity by setting *currentNode.next* to `null`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将*currentNode.next*设置为`null`来打破循环性。
- en: 'In code lines, we have the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，我们有以下内容：
- en: '[PRE25]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete application is named *LinkedListMoveLastToFront*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LinkedListMoveLastToFront*。
- en: Coding challenge 15 – Reverse a singly linked list in groups of k
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 - 以k组反转单链表
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**，**Google**，**Adobe**，**Microsoft**'
- en: '**Problem**: Consider a singly linked list and an integer, *k*. Write a snippet
    of code that reverses the linked list''s nodes in *k* groups.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个单链表和一个整数*k*。编写一小段代码，以*k*组反转链表的节点。'
- en: '**Solution**: Let''s consider that the given linked list is 7 → 4 → 3 → 1 →
    8 → 2 → 9 → 0 → null and *k*=3\. The result should be 3 → 4 → 7 → 2 → 8 → 1 →
    0 → 9 → null.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的链表是7 → 4 → 3 → 1 → 8 → 2 → 9 → 0 → null，*k*=3。结果应为3 → 4 → 7 →
    2 → 8 → 1 → 0 → 9 → null。'
- en: Let's consider that the given *k* is equal to the size of the linked list. In
    this case, we reduced the problem to reversing the given linked list. For example,
    if the given list is 7 → 4 → 3 → null and *k*=3, then the result should be 3 →
    4 → 7 → null. So, how can we obtain this result?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑给定的*k*等于链表的大小。在这种情况下，我们将问题简化为反转给定的链表。例如，如果给定的列表是7 → 4 → 3 → null，*k*=3，则结果应为3
    → 4 → 7 → null。那么，我们如何获得这个结果呢？
- en: 'In order to reverse the nodes, we need the current node (*current*), the node
    next to the current node (*next*), and the node previous to the current node (*previous*),
    and we apply the following algorithm representing the rearrangement of nodes:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反转节点，我们需要当前节点（*current*）、当前节点旁边的节点（*next*）和当前节点之前的节点（*previous*），并且我们应用以下代表节点重新排列的算法：
- en: Start with a counter from 0.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0开始计数。
- en: 'As the *current* node (initially the head) is not `null` and we haven''t reached
    the given *k*, the following occurs:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为*当前*节点（最初是头节点）不是`null`，并且我们还没有达到给定的*k*，发生以下情况：
- en: a. The *next* node (initially `null`) becomes the node next to the *current*
    node (initially the head).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: a. *next*节点（最初为`null`）变为*current*节点旁边的节点（最初是头节点）。
- en: b. The node next to the *current* node (initially the head) becomes the *previous*
    node (initially `null`).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: b. *current*节点（最初是头节点）旁边的节点变为*previous*节点（最初为`null`）。
- en: c. The *previous* node becomes the *current* node (initially the head).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: c. *previous*节点变为*current*节点（最初是头节点）。
- en: d. The *current* node becomes the *next* node (the node from *step 2a*).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: d. *current*节点变为*next*节点（*步骤2a*的节点）。
- en: e. Increment the counter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: e. 增加计数器。
- en: 'So, if we apply this algorithm, we can reverse the whole list. But we need
    to reverse it in the groups; therefore, we must solve the *k* subproblems of what
    we''ve done. If this sounds like recursion to you, then you are right. At the
    end of the preceding algorithm, the node set at *step 2a* (*next*) points to the
    node where the counter is pointing as well. We can say that we''ve reversed the
    first *k* nodes. Next, we continue with the next group of *k* nodes via recursion
    starting from the *next* node. The following diagram illustrates this idea:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们应用此算法，我们可以反转整个列表。但是我们需要按组反转它；因此，我们必须解决我们所做的*k*个子问题。如果这对你来说听起来像递归，那么你是对的。在前述算法的末尾，设置为*步骤2a*（*next*）的节点指向计数器所指向的节点。我们可以说我们已经反转了前*k*个节点。接下来，我们通过递归从*next*节点开始继续下一组*k*节点。以下图表说明了这个想法：
- en: '![11.25: Reversing the list in k groups (k=3)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![11.25：以k组（k=3）反转列表'
- en: '](img/Figure_11.25_B15403.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.25_B15403.jpg)'
- en: Figure 11.25 – Reversing the list in k groups (k=3)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 - 以k组（k=3）反转列表
- en: 'And the following code implements this idea:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了这个想法：
- en: '[PRE26]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code runs in O(n), where *n* is the number of nodes in the given list.
    The complete application is named *ReverseLinkedListInGroups*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(n)，其中*n*是给定列表中的节点数。完整的应用程序名为*ReverseLinkedListInGroups*。
- en: Coding challenge 16 – Reverse a doubly linked list
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16 - 反转双向链表
- en: '**Microsoft**, **Flipkart**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft**，**Flipkart**'
- en: '**Problem**: Consider a doubly linked list. Write a snippet of code that reverses
    its nodes.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个双向链表。编写一小段代码来反转它的节点。'
- en: '**Solution**: Reversing a doubly linked list can take advantage of the fact
    that a doubly linked list maintains the link to the previous node. This means
    that we can simply swap the previous pointers and the next pointers for each node,
    as shown in the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：反转双向链表可以利用双向链表维护到前一个节点的链接的事实。这意味着我们可以简单地交换每个节点的前指针和后指针，如下面的代码所示：'
- en: '[PRE27]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete application is named *DoublyLinkedListReverse*. To sort a singly
    and doubly linked list, please refer to [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340),
    *Sorting and Searching*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*DoublyLinkedListReverse*。要对单链表和双链表进行排序，请参考[*第14章*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)，*排序和搜索*。
- en: Coding challenge 17 – LRU cache
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战17 - LRU缓存
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**，**Google**，**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Write a snippet of code to implement a fixed-size LRU cache. LRU
    cache stands for Least Recently Used Cache. This means that, when the cache is
    full, adding a new entry will instruct the cache to automatically evict the least
    recently used entry.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：编写一小段代码来实现固定大小的LRU缓存。LRU缓存代表最近最少使用的缓存。这意味着，当缓存已满时，添加新条目将指示缓存自动驱逐最近最少使用的条目。'
- en: '**Solution**: Any cache implementation must provide a fast and efficient way
    of retrieving data. This means that our implementation must respect the following
    constraints:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：任何缓存实现必须提供一种快速有效的检索数据的方式。这意味着我们的实现必须遵守以下约束：'
- en: '**Fixed size**: The cache must use a limited amount of memory. Therefore, it
    needs to have some bounds (for example, a fixed size).'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定大小**：缓存必须使用有限的内存。因此，它需要一些限制（例如，固定大小）。'
- en: '**Fast access to data**: Inserting and searching operations should be fast;
    preferably, O(1) complexity time.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速访问数据**：插入和搜索操作应该快速；最好是O(1)复杂度时间。'
- en: '**Fast eviction of data**: When the cache is full (it has reached its allocated
    bounds), the cache should empower an efficient algorithm to evict an entry.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速驱逐数据**：当缓存已满（达到其分配的限制）时，缓存应该提供一个有效的算法来驱逐条目。'
- en: In the context of the last bullet point, eviction from an LRU cache means evicting
    the least recently used data. To accomplish this, we have to keep track of the
    recently used entries and of the entries that have not been used for a long time.
    Moreover, we have to ensure O(1) complexity time for inserting and searching operations.
    There is no built-in data structure in Java that can give us this cache out of
    the box.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个要点的背景下，从LRU缓存中驱逐意味着驱逐最近最少使用的数据。为了实现这一点，我们必须跟踪最近使用的条目和长时间未使用的条目。此外，我们必须确保插入和搜索操作的O(1)复杂度时间。在Java中没有内置的数据结构可以直接给我们提供这样的缓存。
- en: But we can start with a `HashMap` data structure. In Java, a `HashMap` allows
    us to insert and search (lookup) data by key in O(1) time. So, using a `HashMap`
    solves half of the problem. The other half, that is, keeping track of the recently
    used entries and of the entries that have not been used for a long time, cannot
    be accomplished with a `HashMap`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以从`HashMap`数据结构开始。在Java中，`HashMap`允许我们在O(1)时间内按键插入和搜索（查找）数据。因此，使用`HashMap`解决了问题的一半。另一半，即跟踪最近使用的条目和长时间未使用的条目，无法通过`HashMap`完成。
- en: However, if we imagine a data structure that provides fast insertions, updates,
    and deletions, then we have to think of a doubly linked list. Essentially, if
    we know the address of a node in a doubly linked list, then inserting, updating,
    and deleting can be performed in O(1).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想象一个提供快速插入、更新和删除的数据结构，那么我们必须考虑双向链表。基本上，如果我们知道双向链表中节点的地址，那么插入、更新和删除可以在O(1)时间内完成。
- en: 'This means that we can provide an implementation that relies on the symbiosis
    between a `HashMap` and a doubly linked list. Essentially, for each entry (key-value
    pair) in the LRU cache, we can store the key of the entry and the address of the
    associated linked list''s node in the `HashMap`, while this node will store the
    value of the entry. The following diagram is a visual representation of this statement:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以提供一个实现，它依赖于`HashMap`和双向链表之间的共生关系。基本上，对于LRU缓存中的每个条目（键值对），我们可以在`HashMap`中存储条目的键和关联链表节点的地址，而这个节点将存储条目的值。以下图表是对这一陈述的可视化表示：
- en: '![11.26: An LRU cache using a HashMap and doubly linked list](img/Figure_11.26_B15403.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![11.26：使用HashMap和双向链表的LRU缓存](img/Figure_11.26_B15403.jpg)'
- en: Figure 11.26 – An LRU cache using a HashMap and doubly linked list
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 - 使用HashMap和双向链表的LRU缓存
- en: 'But how does the doubly linked list help us to track the recently used entries?
    The secret relies on the following points:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 但是双向链表如何帮助我们跟踪最近使用的条目呢？秘密在于以下几点：
- en: Inserting a new entry in the cache will result in adding the corresponding node
    to the head of the linked list (so, the head of the linked list holds the most
    recently used value).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缓存中插入新条目将导致将相应的节点添加到双向链表的头部（因此，双向链表的头部保存了最近使用的值）。
- en: When an entry is accessed, we move its corresponding node to the head of the
    linked list.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问一个条目时，我们将其对应的节点移动到双向链表的头部。
- en: When we need to evict an entry, we evict the tail of the linked list (so, the
    tail of the linked list holds the least recently used value).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要驱逐一个条目时，我们驱逐双向链表的尾部（因此，双向链表的尾部保存了最近最少使用的值）。
- en: 'Well, based on these statements, we can provide the following straightforward
    implementation:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些陈述，我们可以提供以下直接的实现：
- en: '[PRE28]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The complete application is named *LRUCache*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LRUCache*。
- en: Well, this was the last coding challenge of the chapter. It's time to summarize
    the chapter!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这是本章的最后一个编码挑战。是时候总结本章了！
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter brought your attention to the most common problems involving linked
    lists and maps. Among these problems, the ones that involve singly linked lists
    are preferred; therefore, this chapter was primarily focused on this category
    of coding challenges.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引起了您对涉及链表和映射的最常见问题的注意。在这些问题中，首选涉及单向链表的问题；因此，本章主要关注了这一类编码挑战。
- en: In the next chapter, we will tackle coding challenges related to stacks and
    queues.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决与堆栈和队列相关的编码挑战。
