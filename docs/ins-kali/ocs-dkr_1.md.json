["```\n**$ sudo apt-get update**\n**$ sudo apt-get -y install docker.io**\n\n```", "```\n$ sudo ln -s /usr/bin/docker.io /usr/local/bin/docker\n$ sudo sed -i '$acomplete -F _docker docker' \\> /etc/bash_completion.d/docker.io\n```", "```\n**$ sudo apt-get update**\n**$ sudo apt-get -y install linux-image-generic-lts-raring linux-headers-generic-lts-raring**\n**$ sudo reboot**\n\n```", "```\n**$ curl -s https://get.docker.io/ubuntu/ | sudo sh**\n\n```", "```\n    **# Check that HTTPS transport is available to APT**\n    **if [ ! -e /usr/lib/apt/methods/https ]; then  apt-get update  apt-get install -y apt-transport-https**\n    **fi**\n\n    ```", "```\n    **$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9**\n\n    ```", "```\n    **$ sudo sh -c \"echo deb https://get.docker.io/ubuntu docker main\\**\n    **> /etc/apt/sources.list.d/docker.list\"**\n    **$ sudo apt-get update**\n    **$ sudo apt-get install lxc-docker**\n\n    ```", "```\n**$ boot2docker init # First run**\n**$ boot2docker start**\n**$ export DOCKER_HOST=tcp://$(boot2docker ip 2>/dev/null):2375**\n\n```", "```` or `$()`. These will be evaluated first and the result will be substituted in the outer commands.\n\nIf you are the kind that loves to poke around, the Boot2Docker default user is `docker` and the password is `tcuser`.\n\nThe boot2Docker management tool provides several commands:\n\n```", "```\n\nWhen using boot2Docker, the `DOCKER_HOST` environment variable has to be available in the terminal session for Docker commands to work. So, if you are getting the `Post http:///var/run/docker.sock/v1.12/containers/create: dial unix /var/run/docker.sock: no such file or directory` error, it means that the environment variable is not assigned. It is easy to forget to set this environment variable when you open a new terminal. For OSX users, to make things easy, add the following line to your `.bashrc` or `.bash_profile` shells:\n\n```", "```\n\nNow, whenever you open a new terminal or get the above error, just run the following command:\n\n```", "```\n\n![Mac OSX and Windows](graphics/4787_01_02_revised.jpg)\n\nThis image shows how the terminal screen will look like when you have logged into the Boot2Docker VM.\n\n### Upgrading Boot2Docker\n\n1.  Download the latest release of the Boot2Docker Installer for OSX from [http://boot2docker.io/](http://boot2docker.io/).\n2.  Run the installer, which will update VirtualBox and the Boot2Docker management tool.\n\nTo upgrade your existing virtual machine, open a terminal and run the following commands:\n\n```", "```\n\n# OpenStack\n\n**OpenStack** is a piece of free and open source software that allows you to set up a cloud. It is primarily used to deploy public and private **Infrastructure** **as** **a** **Service** (**IaaS**) solutions. It consists of a pool of interrelated projects for the different components of a cloud setup such as compute schedulers, keychain managers, network managers, storage managers, dashboards, and so on.\n\nDocker can act as a hypervisor driver for OpenStack Nova Compute. Docker support for OpenStack was introduced with the **Havana** release.\n\nBut... how?\n\nNova's Docker driver embeds a tiny HTTP server that talks to the Docker Engine's internal **Representational** **State** **Transfer** (**REST**) API (you will learn more on this later) through a **UNIX** **TCP** socket.\n\nDocker has its own image repository system called Docker-Registry, which can be embedded into Glance (OpenStack's image repository) to push and pull Docker images. Docker-Registry can be run either as a `docker` container or in a standalone mode.\n\n## Installation with DevStack\n\nIf you are just setting up OpenStack and taking up the DevStack route, configuring the setup to use Docker is pretty easy.\n\nBefore running the DevStack route's `stack.sh` script, configure the **virtual** **driver** option in the `localrc` file to use Docker:\n\n```", "```\n\nThen run the Docker installation script from the `devstack` directory. The `socat` utility is needed for this script (usually installed by the `stack.sh` script). If you don't have the `socat` utility installed, run the following:\n\n```", "```\n\nFinally, run the `stack.sh` script from the `devstack` directory:\n\n```", "```\n\n## Installing Docker for OpenStack manually\n\nDocker can also be installed manually if you already have OpenStack set up or in case the DevStack method doesn't work out:\n\n1.  Firstly, install Docker according to one of the Docker installation procedures.\n\n    If you are co-locating the `docker` registry alongside the Glance service, run the following command:\n\n    ```", "```\n\n    In the `/etc/sysconfig/docker-registry` folder, set the `REGISTRY_PORT` and `SETTINGS_FLAVOR` registries as follows:\n\n    ```", "```\n\n    In the `docker` registry file, you will also need to specify the OpenStack authentication variables. The following commands accomplish this:\n\n    ```", "```\n\n    By default, `/etc/docker-registry.yml` sets the local or alternate `storage_path` path for the openstack configuration under `/tmp`. You may want to alter the path to a more permanent location:\n\n    ```", "```\n\n2.  In order for **Nova** to communicate with Docker over its local socket, add `nova` to the `docker` group and restart the `compute` service to pick up the change:\n\n    ```", "```\n\n3.  Start Redis (used by the Docker Registry), if it wasn't started already:\n\n    ```", "```\n\n4.  Finally, start the registry:\n\n    ```", "```\n\n## Nova configuration\n\nNova needs to be configured to use the `virt` Docker driver.\n\nEdit the `/etc/nova/nova.conf` configuration file according to the following options:\n\n```", "```\n\nAlternatively, if you want to use your own Docker-Registry, which listens on a port different than 5042, you can override the following option:\n\n```", "```\n\n## Glance configuration\n\nGlance needs to be configured to support the Docker container format. Just add Docker to the list of container formats in the Glance configuration file:\n\n```", "```\n\n### Tip\n\nLeave the default formats in order to not break an existing glance installation.\n\n## Docker-OpenStack flow\n\nOnce you configured Nova to use the `docker` driver, the flow is the same as that in any other driver:\n\n```", "```\n\nThen tag the image with the Docker-Registry location and push it:\n\n```", "```\n\nThe push refers to a repository:\n\n```", "```\n\nIn this case, the Docker-Registry (running in a docker container with a port mapped on 5042) will push the images to Glance. From there, Nova can reach them and you can verify the images with the Glance **Command**-**Line** **Interface** (**CLI**):\n\n```", "```\n\n### Note\n\nOnly images with a docker container format will be bootable. The image basically contains a tarball of the container filesystem.\n\nYou can boot instances with the `nova` `boot` command:\n\n```", "```\n\n### Tip\n\nThe command used will be the one configured in the image. Each container image can have a command configured for the run. The driver does not override this command.\n\nOnce the instance is booted, it will be listed in `nova` `list`:\n\n```", "```\n\nYou can also see the corresponding container in Docker:\n\n```", "```\n\n# Inception: Build Docker in Docker\n\nThough installing from standard repositories is easier, they usually contain older versions, which means that you might miss critical updates or features. The best way to remain updated is to regularly get the latest version from the public `GitHub` repository. Traditionally, building software from a source has been painful and done only by people who actually work on the project. This is not so with Docker. From Docker 0.6, it has been possible to build Docker in Docker. This means that upgrading Docker is as simple as building a new version in Docker itself and replacing the binary. Let's see how this is done.\n\n## Dependencies\n\nYou need to have the following tools installed in a 64-bit Linux machine (VM or bare-metal) to build Docker:\n\n*   **Git**\n*   **Make**\n\n**Git** is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It is used here to clone the Docker public source code repository. Check out [git-scm.org](http://git-scm.org) for more details.\n\nThe `make` utility is a software engineering tool used to manage and maintain computer programs. **Make** provides most help when the program consists of many component files. A `Makefile` file is used here to kick off the Docker containers in a repeatable and consistent way.\n\n## Building Docker from source\n\nTo build Docker in Docker, we will first fetch the source code and then run a few `make` commands that will, in the end, create a `docker` binary, which will replace the current binary in the Docker installation path.\n\nRun the following command in your terminal:\n\n```", "```\n\nThis command clones the official Docker source code repository from the `Github` repository into a directory named `docker`:\n\n```", "```\n\nThis will prepare the development environment and install all the dependencies required to create the binary. This might take some time on the first run, so you can go and have a cup of coffee.\n\n### Tip\n\nIf you encounter any errors that you find difficult to debug, you can always go to `#docker` on freenode IRC. The developers and the Docker community are very helpful.\n\nNow we are ready to compile that binary:\n\n```", "```\n\nThis will compile a binary and place it in the `./bundles/<version>-dev/binary/` directory. And voila! You have a fresh version of Docker ready.\n\nBefore replacing your existing binary though, run the tests:\n\n```", "```\n\nIf the tests pass, then it is safe to replace your current binary with the one you've just compiled. Stop the `docker` service, create a backup of the existing binary, and then copy the freshly baked binary in its place:\n\n```", "```\n\nCongratulations! You now have the up-to-date version of Docker running.\n\n### Tip\n\nOSX and Windows users can follow the same procedures as SSH in the boot2Docker VM.\n\n# Verifying Installation\n\nTo verify that your installation is successful, run the following command in your terminal console:\n\n```", "```\n\nThe `docker` `run` command starts a container with the `ubuntu` base image. Since this is the first time you are starting an `ubuntu` container, the output of the container will be something like this:\n\n```", "```\n\nWhen you issue the `docker` `run` `ubuntu` command, Docker looks for the `ubuntu` image locally, and it's not found, it will download the `ubuntu` image from the public `docker` registry. You will also see it say **Pulling** **dependent layers**.\n\nThis means that it is downloading filesystem layers. By default, Docker uses AUFS, a layered copy-on-write filesystem, which means that the container image's filesystem is a culmination of multiple read-only filesystem layers. And these layers are shared between running containers. If you initiate an action that will write to this filesystem, it will create a new layer that will be the difference of the underlying layers and the new data. Sharing of common layers means that only the first container will take up a considerable amount of memory and subsequent containers will take up an insignificant amount of memory as they will be sharing the read-only layers. This means that you can run hundreds of containers even on a relatively low-powered laptop.\n\n![Verifying Installation](graphics/4787_01_03.jpg)\n\nOnce the image has been completely downloaded, it will start the container and echo `Hello` `World!` in your console. This is another salient feature of the Docker containers. Every container is associated with a command and it should run that command. Remember that the Docker containers are unlike VMs in that they do not virtualize the entire operating system. Each `docker` container accepts only a single command and runs it in a sandboxed process that lives in an isolated environment.\n\n# Useful tips\n\nThe following are two useful tips that might save you a lot of trouble later on. The first shows how to give the docker client non-root access, and the second shows how to configure the Ubuntu firewall rules to enable forwarding network traffic.\n\n### Note\n\nYou do not need to follow these if you are using Boot2Docker.\n\n## Giving non-root access\n\nCreate a group called `docker` and add your user to that group to avoid having to add the `sudo` prefix to every `docker` command. The reason you need to run a `docker` command with the `sudo` prefix by default is that the `docker` daemon needs to run with `root` privileges, but the docker client (the commands you run) doesn't. So, by creating a `docker` group, you can run all the client commands without using the `sudo` prefix, whereas the daemon runs with the `root` privileges:\n\n```", "```\n\nYou might need to log out and log in again for the changes to take effect.\n\n## UFW settings\n\nDocker uses a bridge to manage network in the container. **Uncomplicated** **Firewall** (**UFW**) is the default firewall tool in Ubuntu. It drops all forwarding traffic. You will need to enable forwarding like this:\n\n```", "```\n\nReload the firewall by running the following command:\n\n```", "```\n\nAlternatively, if you want to be able to reach your containers from other hosts, then you should enable incoming connections on the docker port (`default` `2375`):\n\n```"]