["```java\npublic class ProductLoader {\n    public static Product load(Path path) {\n        try (BufferedReader reader = Files.newBufferedReader(path)) {\n            Product product=new Product();\n            String line=reader.readLine();\n            product.setId(line.split(\":\")[1]);\n            line=reader.readLine();\n            product.setAsin(line.split(\":\")[1]);\n            line=reader.readLine();\n            product.setTitle(line.substring (line.indexOf(':')+1));\n            line=reader.readLine();\n            product.setGroup(line.split(\":\")[1]);\n            line=reader.readLine();\n            product.setSalesrank(Long.parseLong (line.split(\":\")[1]));\n            line=reader.readLine();\n            product.setSimilar(line.split(\":\")[1]);\n            line=reader.readLine();\n\n            int numItems=Integer.parseInt(line.split(\":\")[1]);\n\n            for (int i=0; i<numItems; i++) {\n                line=reader.readLine();\n                product.addCategory(line.split(\":\")[1]);\n            }\n\n            line=reader.readLine();\n            numItems=Integer.parseInt(line.split(\":\")[1]);\n            for (int i=0; i<numItems; i++) {\n                line=reader.readLine();\n                String tokens[]=line.split(\":\");\n                Review review=new Review();\n                review.setUser(tokens[1]);\n                review.setValue(Short.parseShort(tokens[2]));\n                product.addReview(review);\n            }\n            return product;\n        } catch (IOException x) {\n            throw newe UncheckedIOException(x);\n        } \n\n    }\n}\n```", "```java\npublic class ConcurrentMainBasicSearch {\n\n    public static void main(String args[]) {\n        String query = args[0];\n        Path file = Paths.get(\"data\");\n```", "```java\n        try {\n            Date start, end;\n            start = new Date();\n            ConcurrentLinkedDeque<String> results = Files\n                    .walk(file, FileVisitOption.FOLLOW_LINKS)\n                    .parallel()\n                    .filter(f -> f.toString().endsWith(\".txt\"))\n                    .collect(ArrayList<String>::new,\n                            new ConcurrentStringAccumulator (query),\n                            List::addAll);\n            end = new Date();\n```", "```java\n            System.out.println(\"Results for Query: \"+query);\n            System.out.println(\"*************\");\n            results.forEach(System.out::println);\n            System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\npublic class ConcurrentStringAccumulator implements BiConsumer<List<String>, Path> {\n```", "```java\n    private String word;\n\n    public ConcurrentStringAccumulator (String word) {\n        this.word=word.toLowerCase();\n    }\n```", "```java\n    @Override\n    public void accept(List<String> list, Path path) {\n        boolean result;\n\ntry (Stream<String> lines = Files.lines(path)) {\n            result = lines\n                    .parallel()\n                    .map(l -> l.split(\":\")[1].toLowerCase())\n                    .anyMatch(l -> l.contains(word))\n```", "```java\n            if (counter>0) {\n                list.add(path.toString());\n            }\n        } catch (Exception e) {\n            System.out.println(path);\n            e.printStackTrace();\n        }\n    }\n\n}\n```", "```java\npublic class ConcurrentMainSearch {\n    public static void main(String args[]) {\n        String query = args[0];\n        Path file = Paths.get(\"data\");\n```", "```java\n        try {\n            Date start, end;\n            start=new Date();\n            ConcurrentLinkedDeque<Product> results = Files\n                    .walk(file, FileVisitOption.FOLLOW_LINKS)\n                    .parallel()\n                    .filter(f -> f.toString().endsWith(\".txt\"))\n                    .collect(ArrayList<Product>::new,\n                            new ConcurrentObjectAccumulator (query),\n                            List::addAll);\n            end=new Date();\n```", "```java\n            System.out.println(\"Results\");\n            System.out.println(\"*************\");\n            results.forEach(p -> System.out.println(p.getTitle()));\n            System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\npublic class ConcurrentObjectAccumulator implements\n        BiConsumer<List<Product>, Path> {\n\n    private String word;\n\n    public ConcurrentObjectAccumulator(String word) {\n        this.word = word;\n    }\n```", "```java\n    @Override\n    public void accept(List<Product> list, Path path) {\n\n        Product product=ProductLoader.load(path);\n\n        if (product.getTitle().toLowerCase().contains (word.toLowerCase())) {\n            list.add(product);\n        }\n\n    }\n\n}\n```", "```java\n    public static void main(String[] args) {\n        String user = args[0];\n        Path file = Paths.get(\"data\");\n        try {\n            Date start, end;\n            start=new Date();\n```", "```java\n            List<Product> productList = Files\n                .walk(file, FileVisitOption.FOLLOW_LINKS)\n                .parallel()\n                .filter(f -> f.toString().endsWith(\".txt\"))\n                .collect(ConcurrentLinkedDeque<Product>::new\n                 ,new ConcurrentLoaderAccumulator(), ConcurrentLinkedDeque::addAll);\n```", "```java\n        Map<String, List<ProductReview>> productsByBuyer=productList\n                .parallelStream()\n                .<ProductReview>flatMap(p -> p.getReviews().stream().map(r -> new ProductReview(p, r.getUser(), r.getValue())))\n                .collect(Collectors.groupingByConcurrent( p -> p.getBuyer()));\n```", "```java\n            Map<String,List<ProductReview>> recommendedProducts=productsByBuyer.get(user)\n                    .parallelStream()\n                    .map(p -> p.getReviews())\n                    .flatMap(Collection::stream)\n                    .map(r -> r.getUser())\n                    .distinct()\n                    .map(productsByBuyer::get)\n                    .flatMap(Collection::stream)\n                    .collect(Collectors.groupingByConcurrent(p -> p.getTitle()));\n```", "```java\n        List<ProductRecommendation> recommendations = recommendedProducts\n                    .entrySet()\n                    .parallelStream()\n                    .map(entry -> new\n                     ProductRecommendation(\n                         entry.getKey(),\n                         entry.getValue().stream().mapToInt(p -> p.getValue()).average().getAsDouble()))\n                    .sorted()\n                    .collect(Collectors.toList());\n            end=new Date();\n         recommendations. forEach(pr -> System.out.println (pr.getTitle()+\": \"+pr.getValue()));\n\n            System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\npublic class ConcurrentLoaderAccumulator implements\n        BiConsumer<ConcurrentLinkedDeque<Product>, Path> {\n\n    @Override\n    public void accept(ConcurrentLinkedDeque<Product> list, Path path) {\n\n        Product product=ProductLoader.load(path);\n        list.add(product);\n\n    }\n}\n```", "```java\nA-B,C,D,\nB-A,C,D,E,\nC-A,B,D,E,\nD-A,B,C,E,\nE-B,C,D,\n```", "```java\nA-B-B,C,D\nA-C-B,C,D\nA-D-B,C,D\n```", "```java\nA-B-A,C,D,E\nB-C-A,C,D,E\nB-D-A,C,D,E\nB-E-A,C,D,E\n```", "```java\nA-B-(B,C,D),(A,C,D,E)\n```", "```java\nUser-C1,C2,C3...CN\n```", "```java\npublic class CommonPersonMapper implements Function<Person, List<PersonPair>> {\n\n    @Override\n    public List<PersonPair> apply(Person person) {\n\n        List<PersonPair> ret=new ArrayList<>();\n\n        List<String> contacts=person.getContacts();\n        Collections.sort(contacts);\n```", "```java\n        for (String contact : contacts) {\n            PersonPair personExt=new PersonPair();\n            if (person.getId().compareTo(contact) < 0) {\n                personExt.setId(person.getId());\n                personExt.setOtherId(contact);\n            } else {\n                personExt.setId(contact);\n                personExt.setOtherId(person.getId());\n            }\n```", "```java\n            personExt.setContacts(contacts);\n            ret.add(personExt);\n        }\n        return ret;\n    }\n}\n```", "```java\npublic class ConcurrentSocialNetwork {\n\n    public static List<PersonPair> bidirectionalCommonContacts(\n            List<Person> people) {\n\n        Map<String, List<PersonPair>> group = people.parallelStream()\n                .map(new CommonPersonMapper())\n                .flatMap(Collection::stream)\n                .collect(Collectors.groupingByConcurrent (PersonPair::getFullId));\n```", "```java\n        Collector<Collection<String>, AtomicReference<Collection<String>>, Collection<String>> intersecting = Collector.of(\n                () -> new AtomicReference<>(null), (acc, list) -> {\n                  acc.updateAndGet(set -> set == null ? new ConcurrentLinkedQueue<>(list) : set).retainAll(list);\n                }, (acc1, acc2) -> {\n                  if (acc1.get() == null)\n                    return acc2;\n                  if (acc2.get() == null)\n                    return acc1;\n                  acc1.get().retainAll(acc2.get());\n                  return acc1;\n                }, (acc) -> acc.get() == null ? Collections.emptySet() : acc.get(), Collector.Characteristics.CONCURRENT, Collector.Characteristics.UNORDERED);\n```", "```java\n() -> new AtomicReference<>(null),\n```", "```java\n(acc, list) -> {\n      acc.updateAndGet(set -> set == null ? new ConcurrentLinkedQueue<>(list) : set).retainAll(list);\n                },\n```", "```java\n   (acc1, acc2) -> {\n      if (acc1.get() == null)\n        return acc2;\n       if (acc2.get() == null)\n        return acc1;\n      acc1.get().retainAll(acc2.get());\n      return acc1;\n    },\n```", "```java\n(acc) -> acc.get() == null ? Collections.emptySet() : acc.get(),\n```", "```java\n        List<PersonPair> peopleCommonContacts = group.entrySet()\n                  .parallelStream()\n                  .map((entry) -> {\n                    Collection<String> commonContacts =  \n                      entry.getValue()\n                        .parallelStream()\n                        .map(p -> p.getContacts())\n                        .collect(intersecting);\n                    PersonPair person = new PersonPair();\n                    person.setId(entry.getKey().split(\",\")[0]);\n                    person.setOtherId(entry.getKey().split (\",\")[1]);\n                    person.setContacts(new ArrayList<String> (commonContacts));\n                    return person;\n                  }).collect(Collectors.toList());\n\n        return peopleCommonContacts;\n    }\n}\n```", "```java\npublic class ConcurrentMain {\n\n    public static void main(String[] args) {\n\n        Date start, end;\n        System.out.println(\"Concurrent Main Bidirectional - Test\");\n        List<Person> people=DataLoader.load(\"data\",\"test.txt\");\n        start=new Date();\n        List<PersonPair> peopleCommonContacts= ConcurrentSocialNetwork.bidirectionalCommonContacts (people);\n        end=new Date();\n        peopleCommonContacts.forEach(p -> System.out.println (p.getFullId()+\": \"+getContacts(p.getContacts())));\n        System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n\n        System.out.println(\"Concurrent Main Bidirectional - Facebook\");\n        people=DataLoader.load(\"data\",\"facebook_contacts.txt\");\n        start=new Date();\n        peopleCommonContacts= ConcurrentSocialNetwork.bidirectionalCommonContacts (people);\n        end=new Date();\n        peopleCommonContacts.forEach(p -> System.out.println (p.getFullId()+\": \"+getContacts(p.getContacts())));\n        System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n\n    }\n\n    private static String formatContacts(List<String> contacts) {\n        StringBuffer buffer=new StringBuffer();\n        for (String contact: contacts) {\n            buffer.append(contact+\",\");\n        }\n        return buffer.toString();\n    }\n}\n```"]