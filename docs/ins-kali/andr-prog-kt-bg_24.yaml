- en: Chapter 24. Design Patterns, Multiple Layouts, and Fragments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章。设计模式、多个布局和片段
- en: We have come a long way since the start, when we were just setting up Android
    Studio. Back then, we went through everything step by step, but as we have proceeded,
    we have tried to show you not just how to add *x* to *y* or feature A to app B,
    but to enable you to use what you have learned in your own way in order to bring
    your own ideas to life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路，从最开始设置Android Studio的时候。那时，我们一步一步地进行了一切，但随着我们的进展，我们试图向你展示的不仅仅是如何将*x*添加到*y*或将特性A添加到应用程序B，而是让你能够以自己的方式使用所学的知识，以便将自己的想法变为现实。
- en: This chapter is more focused on your future apps than any other chapter in this
    book has been so far. We will look at a few features of Kotlin and Android that
    you can use as a framework or template to make even more exciting and complex
    apps while keeping the code manageable. Furthermore, I will suggest areas of further
    study that are barely touched on in this book, given its limited scope.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章更加关注你未来的应用程序，而不是这本书中迄今为止的任何其他章节。我们将看一下Kotlin和Android的一些特性，你可以将其用作框架或模板，以制作更加令人兴奋和复杂的应用程序，同时保持代码的可管理性。此外，我将建议进一步学习的领域，这些领域在本书中几乎没有涉及，因为它的范围有限。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Patterns and the model-view-controller
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和模型-视图-控制器
- en: Android design guidelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android设计指南
- en: Getting started with real-world designs and handling multiple different devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始真实世界设计和处理多个不同设备
- en: An introduction to fragments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段简介
- en: Let's get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Introducing the model-view-controller pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模型-视图-控制器模式
- en: '**The phrases model, view**, and **controller** reflect the separation of the
    different parts of our app into distinct sections, called **layers**. Android
    apps commonly use the model-view-controller **pattern**. A pattern is simply a
    recognized way to structure code and other application resources, such as layout
    files, images, and databases.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**短语模型、视图**和**控制器**反映了我们应用程序的不同部分分为不同的部分，称为**层**。Android应用程序通常使用模型-视图-控制器**模式**。模式只是一种公认的结构代码和其他应用程序资源的方式，例如布局文件、图像和数据库。'
- en: Patterns are useful to us because, by conforming to a pattern, we can be more
    confident that we are doing things right, and will be less likely to have to undo
    lots of hard work because we have coded ourselves into an awkward situation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模式对我们很有用，因为通过遵循模式，我们可以更有信心地做正确的事情，并且不太可能因为将自己编码到尴尬的境地而不得不撤销大量的辛苦工作。
- en: There are many patterns in computer science, but just an understanding of the
    MVC pattern will be enough to create some professionally built Android apps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中有许多模式，但只要理解MVC模式就足以创建一些专业构建的Android应用程序。
- en: We have been partly using MVC already, so let's look at each of the three layers
    in turn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经部分使用了MVC，所以让我们依次看看这三个层。
- en: Model
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The model refers to the data that drives our app and any logic/code that specifically
    manages it and makes it available to the other layers. For example, in our Note
    to self app, the `Note` class, along with its JSON code, was the data and logic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模型指的是驱动我们应用程序的数据以及专门管理它并使其可用于其他层的逻辑/代码。例如，在我们的自我备忘录应用程序中，`Note`类及其JSON代码就是数据和逻辑。
- en: View
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The view of the Note to self app was all the widgets in all the different layouts.
    Anything the user can see or interact with on the screen is typically part of
    the view. You probably also remember that the widgets came from the `View` class
    hierarchy of the Android API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自我备忘录应用程序的视图是所有不同布局中的所有小部件。用户在屏幕上可以看到或与之交互的任何内容通常都是视图的一部分。你可能还记得小部件来自Android
    API的`View`类层次结构。
- en: Controller
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: The controller is the bit between the view and the model. It interacts with
    both and keeps them separate. It contains what is known as the **application logic**.
    If a user taps a button, the application layer decides what to do about it. When
    the user clicks **OK** to add a new note, the application layer listens for the
    interaction on the view layer. It captures the data contained in the view and
    passes it to the model layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是视图和模型之间的部分。它与两者交互并使它们分开。它包含所谓的**应用逻辑**。如果用户点击按钮，应用程序层决定如何处理它。当用户点击**确定**以添加新的备忘录时，应用程序层会监听视图层上的交互。它捕获视图中包含的数据，并将其传递给模型层。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Design patterns are a huge topic. There are many different design patterns,
    and if you want a beginner-friendly introduction to the topic in general, I would
    recommend *Head First Design Patterns*. Even though this book''s examples are
    described in another language, Java, it will still be very useful to you. If you
    want to really dive into the world of design patterns, then you can try *Design
    Patterns: Elements of Reusable Object-Oriented Software*, which is recognized
    as a kind of design pattern oracle, but is a much harder read.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '设计模式是一个庞大的主题。有许多不同的设计模式，如果你想对这个主题有一个友好的入门，我会推荐*Head First Design Patterns*。即使这本书的例子是用另一种语言Java描述的，它对你仍然非常有用。如果你想真正深入设计模式的世界，那么你可以尝试*Design
    Patterns: Elements of Reusable Object-Oriented Software*，它被认为是一种设计模式的权威，但阅读起来要困难得多。'
- en: As this book progresses, we will also begin to utilize more of the object-oriented
    programming features we have discussed but not fully benefited from so far. We
    will do so step by step.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的进展，我们还将开始利用我们已经讨论过但迄今为止尚未充分利用的面向对象编程特性。我们将逐步做到这一点。
- en: Android design guidelines
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android设计指南
- en: App design is a vast topic – so vast that it could only begin to be taught in
    a book dedicated solely to the topic. Also, like programming, you can only start
    to get good at app design with constant practice, review, and improvement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设计是一个广阔的主题——如此广阔，以至于只能在专门致力于该主题的书中开始教授。而且，就像编程一样，只有通过不断的练习、复习和改进，才能开始擅长应用程序设计。
- en: So, what exactly do I mean by design? I am talking about where you put the widgets
    on the screen, which widgets, what color they should be, how big they should be,
    how to transition between screens, the best way to scroll a page, when and which
    animation interpolators to use, what screens your app should be divided into,
    and much more besides this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我所说的设计到底是什么？我说的是屏幕上放置小部件的位置，使用哪些小部件，它们应该是什么颜色，多大，如何在屏幕之间过渡，滚动页面的最佳方式，何时以及使用哪些动画插值器，你的应用应该分成哪些屏幕，以及更多其他方面。
- en: This book will hopefully leave you well-qualified to be able to *implement*
    all your chosen answers to these questions and many more besides. Unfortunately,
    it does not have the space, and the author probably doesn't have the skill to
    teach you how to *make* those choices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书希望能让你有能力*实现*你选择的答案，以及更多其他问题的答案。不幸的是，它没有足够的空间，作者可能也没有技能来教你如何*做出*这些选择。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering, "What should I do?". Keep making apps and don't let
    a lack of design experience and knowledge stop you! Even release your apps to
    the app store. Keep in mind, however, that there is a whole other topic—design—that
    needs some attention if your apps are going to truly be world class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“我该怎么办？”继续制作应用，不要让缺乏设计经验和知识阻止你！甚至将你的应用发布到应用商店。然而，请记住，还有一个完全不同的话题——设计——如果你的应用真的要成为世界级的话，这需要一些关注。
- en: In even medium-sized development companies, the designer is rarely also the
    programmer, and even very small companies will often outsource the design of their
    app (or designers might outsource the coding).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在中等规模的开发公司中，设计师很少也是程序员，即使是非常小的公司也经常外包他们的应用设计（或设计师可能外包编码）。
- en: Designing is both an art and a science, and Google has demonstrated that it
    recognizes this with high-quality support for both existing and aspiring designers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设计既是一门艺术，也是一门科学，Google已经证明它认识到这一点，为现有和有抱负的设计师提供了高质量的支持。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I highly recommend you visit and bookmark the web page [https://developer.android.com/design/](https://developer.android.com/design/).
    It is quite detailed and comprehensive, is totally Android focused, and has a
    ton of digital resources in the form of images, color palettes, and guidelines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你访问并收藏网页[https://developer.android.com/design/](https://developer.android.com/design/)。它非常详细和全面，完全专注于Android，并提供了大量的数字资源，如图像、调色板和指南。
- en: Make understanding design principles a short-term goal. Make improving your
    actual design skills an ongoing task. Visit and read design-focused websites and
    try and implement the ideas that you find exciting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将理解设计原则作为短期目标。将提高你的实际设计技能作为一个持续的任务。访问并阅读以设计为重点的网站，并尝试实现你发现令人兴奋的想法。
- en: Most important of all, however, don't wait until you are a design expert before
    you start to make apps. Keep bringing your ideas to life and publishing them.
    Make a point of making the design of each app a little better than the last.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，不要等到你成为设计专家才开始制作应用。继续将你的想法付诸实践并发布它们。要求每个应用的设计都比上一个稍微好一点。
- en: We will see in the up coming chapters, and have seen to a certain extent already,
    that the Android API makes a whole bunch of super-stylish UIs available to us
    that we can then take advantage of with very little code or design skill. These
    UIs go a long way to making your apps look like they have been designed by a professional.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到，而且已经在一定程度上看到，Android API为我们提供了一整套超时尚的UI，我们可以用非常少的代码或设计技能来利用这些UI。这些UI在很大程度上使你的应用看起来像是由专业人员设计的。
- en: Real-world apps
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的应用
- en: So far, we have built a dozen or more apps of various complexity. Most were
    designed and tested on a phone.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了十几个或更多不同复杂度的应用。大多数是在手机上设计和测试的。
- en: Of course, in the real world, our apps need to work well on any device, and
    must be able to handle what happens when in either portrait or landscape view
    (on all devices).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中，我们的应用需要在任何设备上都能良好运行，并且必须能够处理在横向或纵向视图（在所有设备上）时发生的情况。
- en: Furthermore, it is often not enough for our apps to just work and look "OK"
    on different devices. Often, our apps will need to behave differently and appear
    with a significantly different UI based on whether the device is a phone, a tablet,
    or has landscape/portrait orientation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的应用通常不能只是在不同设备上正常工作并看起来“还行”。通常情况下，我们的应用需要根据设备是手机、平板还是横向/纵向方向，以不同的方式运行并呈现出显著不同的UI。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android supports apps for large screen TVs, smart watches via the wear API,
    virtual and augmented reality, and "things" for the internet of things. We will
    not be covering the latter two aspects in this book, but by the end of it, it
    is the author's hope that you will be sufficiently prepared to venture into these
    topics should you choose to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持大屏电视、智能手表、虚拟和增强现实以及物联网的应用。本书不涉及后两个方面，但作者希望在书的结尾，你将有足够的准备去涉足这些话题。
- en: 'Look at the following screenshot of the BBC News app running on an Android
    phone in portrait orientation. Look at the basic layout, but also note that the
    categories of news (**Top Stories**, **World**, **UK**) are all visible and allow
    the user to scroll to see more categories or to swipe left and right between the
    stories within each category:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下BBC新闻应用在Android手机上纵向运行的屏幕截图。看基本布局，但也注意新闻的类别（**头条新闻**，**世界**，**英国**）都是可见的，并允许用户滚动查看更多类别或在每个类别的故事之间左右滑动：
- en: '![Real-world apps](img/B12806_24_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![真实世界的应用](img/B12806_24_01.jpg)'
- en: 'We will see how we can implement a swiping/paging UI using the `ImagePager`
    and `FragmentPager` classes in the next chapter, but before we can do that, we
    need to understand some more fundamentals, which we will explore in this chapter.
    For now, the purpose of the previous screenshot is not so much to show you the
    specific UI features, but to allow you to compare it to the following screenshot.
    Look at the exact same app running on a tablet in landscape orientation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到如何使用`ImagePager`和`FragmentPager`类实现滑动/分页UI，但在此之前，我们需要了解更多的基础知识，我们将在本章中探讨。目前，上一个截图的目的不是向您展示特定的UI功能，而是让您将其与以下截图进行比较。看看在平板电脑上横向方向上运行的完全相同的应用程序：
- en: '![Real-world apps](img/B12806_24_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![真实世界的应用程序](img/B12806_24_02.jpg)'
- en: Note that the stories (the data layer) are identical, but that the layout (the
    view layer) is very different. The user is not only given the option to select
    categories from a menu of tabs at the top of the app, but they are also invited
    to add their own tabs through the **Add Topics** option.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，故事（数据层）是相同的，但布局（视图层）却非常不同。用户不仅可以从应用程序顶部的选项卡菜单中选择类别，还可以通过“添加主题”选项添加自己的选项卡。
- en: Again, the point of this image is to show you not so much the specific UI, or
    even how we might implement one like it, but that they are so different that they
    could easily be mistaken for totally different apps.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这张图片的重点不是向您展示特定的UI，甚至不是我们如何实现类似的UI，而是它们是如此不同，以至于它们很容易被误认为是完全不同的应用程序。
- en: Android allows us to design real-world apps like this where not only the layout
    is different for varying device types/orientations/sizes, but so is the behavior,
    that is, the application layer. Android's secret weapon that makes this possible
    is the `Fragment` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Android允许我们设计真实世界的应用程序，不仅布局因设备类型/方向/大小而异，行为也是如此，即应用程序层。Android实现这一点的秘密武器是`Fragment`类。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Google says:**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google说：**'
- en: '*"A Fragment represents a behavior or a portion of user interface in an Activity.
    You can combine multiple fragments in a single activity to build a multi-pane
    UI and reuse a fragment in multiple activities.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “片段代表活动中的行为或用户界面的一部分。您可以在单个活动中组合多个片段，构建多窗格UI，并在多个活动中重用片段。”
- en: '*You can think of a fragment as a modular section of an activity, which has
    its own lifecycle, receives its own input events, and which you can add or remove
    while the activity is running (sort of like a "sub activity" that you can reuse
    in different activities).*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将片段视为活动的模块化部分，它具有自己的生命周期，接收自己的输入事件，并且您可以在活动运行时添加或删除它（有点像可以在不同活动中重用的“子活动”）。
- en: '*A fragment must always be embedded in an activity, and the fragment''s lifecycle
    is directly affected by the host activity''s lifecycle."*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “片段必须始终嵌入在活动中，并且片段的生命周期直接受到宿主活动生命周期的影响。”
- en: We can design multiple different layouts in different XML files, and will do
    so soon. We can also detect things such as device orientation and screen resolution
    in code so that we can then make decisions about layout dynamically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不同的XML文件中设计多个不同的布局，并很快就会这样做。我们还可以在代码中检测设备方向和屏幕分辨率，以便我们可以动态地对布局做出决策。
- en: Let's try this out using device detection, and then we will have our first look
    at fragments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用设备检测，然后我们将首次查看片段。
- en: Device detection mini app
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备检测迷你应用
- en: 'The best way to learn about detecting and responding to devices and their varying
    attributes (screens, orientations, and so on) is to make a simple app. Let''s
    do this by going through the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 了解检测和响应设备及其不同属性（屏幕、方向等）的最佳方法是制作一个简单的应用程序。让我们通过以下步骤来做到这一点：
- en: Create a new **Empty Activity** project and call it `Device Detection`. Leave
    all the other settings as their defaults.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**空活动**项目，并将其命名为`设备检测`。将所有其他设置保留为默认设置。
- en: Open the `activity_main.xml` file in the **Design** tab and delete the default
    **Hello world!** `TextView`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设计**选项卡中打开`activity_main.xml`文件，并删除默认的**Hello world!** `TextView`。
- en: Drag a **Button** to the top of the screen and set its **onClick** property
    to `detectDevice`. We will code this function in a minute.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**按钮**拖放到屏幕顶部，并将其**onClick**属性设置为`detectDevice`。我们将在一分钟内编写此功能。
- en: Drag two **TextView** widgets onto the layout, one below the other, and set
    their **id** properties to `txtOrientation` and `txtResolution`, respectively.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个**TextView**小部件拖放到布局中，一个放在另一个下面，并将它们的**id**属性分别设置为`txtOrientation`和`txtResolution`。
- en: 'Check that you have a layout that looks something like the following screenshot:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您是否有一个类似以下截图的布局：
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I have stretched my widgets (mainly horizontally) and increased the `textSize`
    attributes to `24sp` to make them clearer on the screen, but this is not required
    for the app to work correctly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经拉伸了我的小部件（主要是水平方向），并将`textSize`属性增加到`24sp`，以使它们在屏幕上更清晰，但这并不是应用程序正常工作所必需的。
- en: '![Device detection mini app](img/B12806_24_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_03.jpg)'
- en: Click the **Infer Constraints** button to secure the positions of the UI elements.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**推断约束**按钮以确保UI元素的位置。
- en: 'Now, we will do something new: we will build a layout specifically for landscape
    orientation.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将做一些新的事情：我们将专门为横向方向构建一个布局。
- en: 'In Android Studio, make sure that the `activity_main.xml` file is selected
    in the editor and locate the **Orientation for preview** button, as shown in the
    following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，确保在编辑器中选择了`activity_main.xml`文件，并找到**预览方向**按钮，如下截图所示：
- en: '![Device detection mini app](img/B12806_24_12.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_12.jpg)'
- en: Click it and then select **Create landscape variation**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单击它，然后选择**创建横向变化**。
- en: 'You now have a new layout XML file with the same name, but orientated in landscape
    mode. The layout appears blank in the editor, but as we will see, this is not
    the case. Look at the `layout` folder in the project explorer and note that there
    are indeed two files named `activity_main`, and one of them (the new one we just
    created) is postfixed with **(land)**. This is shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个新的布局XML文件，名称相同，但是是横向布局。在编辑器中，布局看起来是空白的，但正如我们将看到的那样，情况并非如此。查看项目资源管理器中的`layout`文件夹，注意确实有两个名为`activity_main`的文件，其中一个（我们刚刚创建的新文件）以**（land）**结尾。如下截图所示：
- en: '![Device detection mini app](img/B12806_24_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_09.jpg)'
- en: 'Select this new file (the one postfixed with **(land)**) and now look at the
    component tree. It is shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个新文件（以**（land）**结尾的文件），现在看组件树。如下截图所示：
- en: '![Device detection mini app](img/B12806_24_13.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_13.jpg)'
- en: It would appear that the layout already contains all our widgets—we just cannot
    see them in the design view. The reason for this anomaly is that when we created
    the landscape layout, Android Studio copied the portrait layout, including all
    the constraints. The portrait constraints rarely match the landscape constraints.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来布局已经包含了所有我们的小部件，只是在设计视图中看不到它们。这种异常的原因是，当我们创建横向布局时，Android Studio复制了纵向布局，包括所有约束。纵向约束很少与横向约束匹配。
- en: 'To solve this problem, click the **Remove all constraints** button; it''s the
    button to the left of the **Infer constraints** button. The UI is now unconstrained.
    This is what mine looks like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，点击**删除所有约束**按钮；它是**推断约束**按钮左边的按钮。现在UI没有约束了。我的界面是这样的：
- en: '![Device detection mini app](img/B12806_24_10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_10.jpg)'
- en: 'The layout is a bit jumbled up, but at least we can see it now. Rearrange it
    to make it look neat and tidy. This is how I rearranged mine:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 布局有点混乱，但至少我们现在可以看到它。重新排列它使其看起来整洁。这是我重新排列的方式：
- en: '![Device detection mini app](img/B12806_24_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![设备检测迷你应用](img/B12806_24_11.jpg)'
- en: Click the **Infer constraints** button to lock the layout in the new positions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**推断约束**按钮以锁定布局在新位置。
- en: Now that we have a basic layout for two different orientations, we can turn
    our attention to our Kotlin code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为两种不同方向的基本布局，我们可以把注意力转向我们的Kotlin代码。
- en: Coding the MainActivity class
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity类
- en: 'We already have a mechanism that calls a function called `detectDevice`, and
    all we need to do to make this demo app is code that function. After the `onCreate`
    function in the `MainActivity` class, add the function that handles our button
    click and runs our detection code, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个调用名为`detectDevice`的函数的机制，我们只需要编写这个演示应用的函数。在`MainActivity`类的`onCreate`函数之后，添加处理按钮点击并运行检测代码的函数，如下所示：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Import the following three classes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 导入以下三个类：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code works by declaring and initializing an object of the `Display` type
    called `display`. This object (`display`) now holds a whole bunch of data about
    the specific display properties of the device.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过声明和初始化一个名为`display`的`Display`类型的对象来工作。这个对象（`display`）现在包含了关于设备特定显示属性的大量数据。
- en: The value stored in the `rotation` property is output into the top `TextView`
    widget.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`rotation`属性中的值将输出到顶部的`TextView`小部件中。
- en: The code then initializes an object of the `Point` type called `xy`. The `getSize`
    function then loads up the screen resolution into `xy`. The results are then used
    to output the horizontal (`xy.x`) and vertical (`xy.y`) resolution into the `TextView`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码初始化了一个名为`xy`的`Point`类型的对象。`getSize`函数将屏幕分辨率加载到`xy`中。然后将结果用于将水平（`xy.x`）和垂直（`xy.y`）分辨率输出到`TextView`中。
- en: Each time the button is clicked, the two `TextView` widgets will be updated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击按钮，两个`TextView`小部件都将被更新。
- en: Unlocking the screen orientation
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解锁屏幕方向
- en: 'Before we run the app, we want to make sure that the device isn''t locked in
    portrait mode (most new phones are, by default). From the app drawer of the emulator
    (or the device you will be using), tap the **Settings** app and choose **Display**,
    and then use the switch to set **Auto-rotate screen** to on. I have shown this
    setting in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用之前，我们要确保设备没有被锁定在纵向模式（大多数新手机默认是这样）。从模拟器的应用抽屉（或者你将要使用的设备）中，点击**设置**应用，选择**显示**，然后使用开关将**自动旋转屏幕**设置为开启。我在下图中展示了这个设置：
- en: '![Unlocking the screen orientation](img/B12806_24_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![解锁屏幕方向](img/B12806_24_08.jpg)'
- en: Running the app
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用
- en: 'Now, you can run the app and click the button, as shown in the following image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用并点击按钮，如下图所示：
- en: '![Running the app](img/B12806_24_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用](img/B12806_24_04.jpg)'
- en: 'Rotate the device using one of the rotate buttons on the emulator control panel
    to landscape, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟器控制面板上的旋转按钮之一将设备旋转到横向，如下截图所示：
- en: '![Running the app](img/B12806_24_14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用](img/B12806_24_14.jpg)'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use *CTRL* + *F11* on a PC, or *CTRL* + *FN* + *F11* on a macOS
    device.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在PC上使用*CTRL* + *F11*，或者在macOS设备上使用*CTRL* + *FN* + *F11*。
- en: 'Now, click the button again and you will see the landscape layout in action,
    as shown in the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次点击按钮，你将看到横向布局的效果，如下图所示：
- en: '![Running the app](img/B12806_24_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用](img/B12806_24_05.jpg)'
- en: The first thing you will probably notice is that when you rotate the screen,
    it briefly goes blank. This is the activity restarting and going through `onCreate`
    again. This is just what we need. It calls `setContentView` on the landscape version
    of the layout, and the code in `MainActivity` refers to widgets with the same
    ID, so the exact same code works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到的第一件事是，当你旋转屏幕时，屏幕会短暂变空白。这是活动重新启动并再次执行`onCreate`。这正是我们需要的。它在横向布局上调用`setContentView`，`MainActivity`中的代码引用具有相同ID的小部件，因此完全相同的代码可以工作。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just for a moment, consider how we might handle things if we needed different
    behavior as well as layouts between the two orientations. Don't spend too long
    pondering this because we will discuss it later on in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时考虑一下，如果我们需要在两个方向之间需要不同的行为和布局，我们该如何处理。不要花太长时间思考这个问题，因为我们将在本章后面讨论这个问题。
- en: If the `0` and `1` results are less than obvious to you, they refer to `public
    const` variables of the `Surface` class, where `Surface.ROTATION_0` equals zero
    and `Surface.ROTATION_180` equals one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`0`和`1`的结果对您来说不太明显，它们指的是`Surface`类的`public const`变量，其中`Surface.ROTATION_0`等于零，`Surface.ROTATION_180`等于一。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you rotated the screen to the left, then your value will be `1`,
    the same as mine, but if you rotated it to the right, you would have seen the
    value `3`. If you rotate the device to portrait mode (upside down), you will get
    the value `4`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您将屏幕向左旋转，那么您的值将是`1`，与我的相同，但如果您将其向右旋转，您将看到值为`3`。如果您将设备旋转到纵向模式（倒置），您将得到值`4`。
- en: We could use a `when` block and execute different code based on the results
    of these detection tests and load up different layouts. But as we have just seen,
    Android makes things simpler than this by allowing us to add specific layouts
    to folders with configuration qualifiers, such as **land**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`when`块并根据这些检测测试的结果执行不同的代码并加载不同的布局。但正如我们刚才看到的，Android使事情变得比这更简单，它允许我们将特定布局添加到具有配置限定符的文件夹中，比如**land**。
- en: Configuration qualifiers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置限定符
- en: We have already seen configuration qualifiers, such as `layout-large` or `layout-xhdpi`,
    in [Chapter 3](ch03.html "Chapter 3. Exploring Android Studio and the Project
    Structure") , *Exploring Android Studio and the Project Structure*. Here, we will
    refresh and expand our understanding of them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](ch03.html "第3章。探索Android Studio和项目结构")中看到了配置限定符，比如`layout-large`或`layout-xhdpi`，*探索Android
    Studio和项目结构*。在这里，我们将刷新并扩展对它们的理解。
- en: We can begin by alleviating our reliance on the controller layer to influence
    app layout by using configuration qualifiers. There are configuration qualifiers
    for size, orientation, and pixel density. To take advantage of a configuration
    qualifier, we simply design a layout in the usual way, optimized for our preferred
    configuration, and then place that layout in a folder with a name that Android
    recognizes as being for that particular configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用配置限定符来减轻我们对控制器层的依赖，以影响应用程序布局。有关大小、方向和像素密度的配置限定符。要利用配置限定符，我们只需按照通常的方式设计一个针对我们首选配置进行优化的布局，然后将该布局放入Android识别为特定配置的文件夹中。
- en: For example, in the previous app, putting a layout in the `land` folder tells
    Android to use that layout when the device is in landscape orientation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在先前的应用程序中，将布局放在`land`文件夹中告诉Android在设备处于横向方向时使用该布局。
- en: 'It is likely that the preceding statement seems slightly ambiguous. This is
    because the Android Studio project explorer window shows us a file and folder
    structure that doesn''t exactly correspond to reality—it is trying to simplify
    things and "help" us. If you select the **Project Files** option from the drop-down
    list at the top of the project explorer window and then examine the project''s
    contents, you will indeed see that there is a layout and `layout-land` folder,
    as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的陈述可能显得有些模糊。这是因为Android Studio项目资源管理器窗口显示了一个文件和文件夹结构，它并不完全对应现实——它试图简化事情并“帮助”我们。如果您从项目资源管理器窗口顶部的下拉列表中选择**项目文件**选项，然后检查项目的内容，您确实会看到有一个布局和`layout-land`文件夹，如下面的屏幕截图所示：
- en: '![Configuration qualifiers](img/B12806_24_15.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![配置限定符](img/B12806_24_15.jpg)'
- en: Switch back to the **Android** layout or leave it on the **Project Files** view,
    whichever you prefer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Android**布局或保持在**项目文件**视图上，以您喜欢的方式。
- en: If we want to have a different layout for landscape and portrait, we can create
    a folder called `layout-land` in the `res` folder (or use the shortcut we used
    in the previous app) and place our specially designed layout within it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要横向和纵向有不同的布局，我们可以在`res`文件夹中创建一个名为`layout-land`的文件夹（或者使用我们在先前应用程序中使用的快捷方式），并在其中放置我们专门设计的布局。
- en: When the device is in portrait orientation, the regular layout from the `layout`
    folder will be used, and when it is in landscape orientation, the layout from
    the `layout-land` folder will be used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备处于纵向方向时，将使用`layout`文件夹中的常规布局，当设备处于横向方向时，将使用`layout-land`文件夹中的布局。
- en: 'If we are designing for different sizes of screen, we place layouts into folders
    with the following names:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为不同尺寸的屏幕设计，我们将布局放入以下名称的文件夹中：
- en: '`layout-small`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-small`'
- en: '`layout-normal`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-normal`'
- en: '`layout-large`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-large`'
- en: '`layout-xlarge`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xlarge`'
- en: 'If we are designing for screens with different pixel densities, we can place
    XML layouts into folders with names such as these:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为不同像素密度的屏幕设计，我们可以将XML布局放入名称为这些的文件夹中：
- en: '`layout-ldpi` for low-DPI devices'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-ldpi` 用于低DPI设备'
- en: '`layout-mdpi` for medium-DPI devices'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-mdpi` 用于中等DPI设备'
- en: '`layout-hdpi` for high-DPI devices'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-hdpi` 用于高DPI设备'
- en: '`layout-xhdpi` for extra-high-DPI devices'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xhdpi` 用于超高DPI设备'
- en: '`layout-xxhdpi` for extra-extra-high-DPI devices'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xxhdpi` 用于超超高DPI设备'
- en: '`layout-xxxhdpi` for extra-extra-extra-high-DPI devices'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xxxhdpi` 用于超超超高DPI设备'
- en: '`layout-nodpi` for devices with a DPI you have not otherwise catered for'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-nodpi` 用于其他情况下未考虑的DPI设备'
- en: '`layout-tvdpi` for TVs'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-tvdpi` 用于电视'
- en: What exactly qualifies as low, high, or extra-high DPI and so on can be found
    at the link in the following information box. The point being made here is simply
    where to store the layouts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 低、高或超高DPI等的具体资格可以在以下信息框中的链接中找到。这里要说明的是布局存储的位置。
- en: It is worth mentioning that what we have just discussed is a long way from the
    whole story regarding configuration qualifiers, and that, as with design, it is
    worth putting this on your list of things to study further.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们刚刚讨论的远远不是关于配置限定符的整个故事，就像设计一样，值得将其列入进一步学习的清单。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As is so often the case, the Android developer site has lots of detailed information
    on handling layouts for different devices. Go to [https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support)
    for more information.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如经常发生的那样，Android开发者网站上有大量关于处理不同设备布局的详细信息。请访问[https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support)获取更多信息。
- en: The limitation of configuration qualifiers
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置限定符的限制
- en: What the previous app and our discussion on configuration qualifiers have shown
    us is certainly very useful in a number of situations. Unfortunately, however,
    configuration qualifiers and detecting attributes in code only solves the problem
    in the view layer of our MVC pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的应用程序和我们对配置限定符的讨论向我们展示了在许多情况下肯定非常有用。然而，不幸的是，配置限定符和在代码中检测属性只解决了我们MVC模式的视图层中的问题。
- en: As we've discussed, our apps sometimes need to have different *behaviors*, as
    well as layouts. This perhaps implies multiple branches of our Kotlin code in
    the controller layer (`MainActivity`, in our previous app) and might summon nightmarish
    visions of having huge great `if` or `when` blocks with specific code for each
    different scenario.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，我们的应用程序有时需要具有不同的*行为*，以及布局。这可能意味着我们的Kotlin代码在控制器层（在我们以前的应用程序中是`MainActivity`）中可能有多个分支，并且可能召唤出对每种不同情况具体代码的巨大的`if`或`when`块的可怕愿景。
- en: Fortunately, this is not how it's done. For such situations—in fact, for most
    apps—Android has **fragments**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不是这样做的方式。对于这种情况——事实上，对于大多数应用程序——Android都有**片段**。
- en: Fragments
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段
- en: Fragments will likely become a staple of almost every app you make. They are
    so useful, there are so many reasons to use them, and—once you get used to them—they
    are so simple, that there is almost no reason not to use them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 片段很可能会成为您制作的几乎每个应用程序的基本组成部分。它们非常有用，有很多使用它们的理由，而且一旦您习惯了它们，它们就变得非常简单，几乎没有理由不使用它们。
- en: Fragments are reusable elements of an app, just like any class, but, as we mentioned
    previously, they have special features—such as the ability to load their own view/layout,
    as well as their very own lifecycle functions—which make them perfect for achieving
    the goals we discussed in the Real-world apps section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是应用程序的可重用元素，就像任何类一样，但正如我们之前提到的，它们具有特殊功能，例如能够加载自己的视图/布局，以及它们自己的生命周期函数，这使它们非常适合实现我们在真实世界应用程序部分讨论的目标。
- en: Let's dig a bit deeper into fragments, one feature at a time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解片段，一次一个特性。
- en: Fragments have a life cycle too
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 片段也有生命周期
- en: We can set up and control fragments, very much like we do with activities, by
    overriding the appropriate lifecycle functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过覆盖适当的生命周期函数来设置和控制片段，就像我们对活动所做的那样。
- en: The onCreate function
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onCreate函数
- en: In the `onCreate` function, we can initialize variables and do almost all the
    things we typically do in the `Activity onCreate` function. The big exception
    to this is initializing our UI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中，我们可以初始化变量并几乎做所有我们通常在`Activity onCreate`函数中做的事情。这个例外是初始化我们的UI。
- en: The onCreateView function
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onCreateView函数
- en: In the `onCreateView` function, we will, as the name suggests, get a reference
    to any of our UI widgets, set up lambdas to listen for clicks, and more besides,
    as we will soon see.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateView`函数中，我们将像其名称所示的那样，获取对我们任何UI小部件的引用，设置lambda以监听点击，以及更多，正如我们很快将看到的那样。
- en: The onAttach and onDetach functions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onAttach和onDetach函数
- en: The `onAttach` and `onDetach` functions are called just before the `Fragment`
    instance is put into use/taken out of use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAttach`和`onDetach`函数在`Fragment`实例被投入使用/停止使用之前调用。'
- en: The onStart, onPause, and onStop functions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onStart，onPause和onStop函数
- en: In the `onStart`, `onPause`, and `onStop` functions, we can take certain actions,
    such as creating or deleting objects or saving data, just like we did with their
    activity-based counterparts.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onStart`，`onPause`和`onStop`函数中，我们可以执行某些操作，例如创建或删除对象或保存数据，就像我们在它们基于活动的对应函数中所做的那样。
- en: There are other fragment lifecycle functions as well, but we know enough to
    start using fragments already. If you want to study the details of the fragment
    lifecycle, you can do so on the Android developer website at [https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他片段生命周期函数，但我们已经了解足够开始使用片段了。如果您想学习片段生命周期的详细信息，可以在Android开发者网站上进行学习[https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments)。
- en: This is all fine, but we need a way to create our fragments in the first place
    and configure them to respond to these functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这都很好，但我们需要一种方法来首先创建我们的片段，并配置它们以响应这些函数。
- en: Managing fragments with FragmentManager
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FragmentManager管理片段
- en: The `FragmentManager` class is part of the `Activity` class. We use it to initialize
    a `Fragment` instance, add `Fragment` instances to the layout, and end a `Fragment`.
    We briefly saw `FragmentManager` before when we initialized our `FragmentDialog`
    instances in the Note to self app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`类是`Activity`类的一部分。我们使用它来初始化`Fragment`实例，将`Fragment`实例添加到布局中，并结束`Fragment`。我们在以前的“Note
    to self”应用程序中初始化`FragmentDialog`实例时曾简要看到`FragmentManager`。'
- en: It is very hard to learn much about Android without bumping into the `Fragment`
    class, just as it is tough to learn much about Kotlin without constantly bumping
    into OOP, classes, and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Android很难不碰到`Fragment`类，就像学习Kotlin很难不断碰到OOP、类等一样。
- en: 'The highlighted code in the following code snippet is a reminder of how we
    used the `FragmentManager` (which is already a part of the `Activity` class) that''s
    being passed in as an argument to create the pop-up dialog:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的突出显示的代码是提醒我们如何使用传递给弹出对话框的参数 `FragmentManager`（它已经是 `Activity` 类的一部分）：
- en: '[PRE2]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the time, I asked you not to concern yourself with the arguments of the function
    call. The second argument of the call is an ID for the `Fragment`. We will soon
    see how we can use `FragmentManager` and the `Fragment` ID more extensively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我要求您不要关心函数调用的参数。调用的第二个参数是 `Fragment` 的 ID。我们很快将看到如何更广泛地使用 `FragmentManager`
    和 `Fragment` ID。
- en: The `FragmentManager` does exactly what its name suggests. What is important
    here is that an `Activity` only has one `FragmentManager`, but it can take care
    of many `Fragment` instances. This is just what we need in order to have multiple
    behaviors and layouts within a single app.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager` 正是其名称所暗示的。这里重要的是，一个 `Activity` 只有一个 `FragmentManager`，但它可以管理多个
    `Fragment` 实例。这正是我们需要的，以便在单个应用程序中具有多个行为和布局。'
- en: The `FragmentManager` also calls the various lifecycle functions of the fragments
    it is responsible for. This is distinct from the `Activity` lifecycle functions,
    which are called by Android, yet it is also closely related because the `FragmentManager`
    calls many of the `Fragment` lifecycle functions *in response to* the `Activity`
    lifecycle functions being called. As usual, we don't need to worry too much about
    when and how it does this, provided we respond appropriately in each situation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager` 还调用它负责的各个片段的各种生命周期函数。这与 `Activity` 的生命周期函数是不同的，后者是由 Android
    调用的，但它也与 `FragmentManager` 密切相关，因为 `FragmentManager` 调用许多 `Fragment` 生命周期函数是作为对
    `Activity` 生命周期函数的响应。通常情况下，我们不需要太担心它是何时以及如何做到这一点，只要我们在每种情况下做出适当的响应即可。'
- en: Our first fragment app
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个片段应用
- en: Let's build a fragment in its simplest possible form so that we can understand
    what is going on, before we start producing `Fragment` objects all over the place
    that are of genuine use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个尽可能简单的片段，以便我们可以理解发生了什么，然后我们开始在各个地方生成真正有用的 `Fragment` 对象。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I urge all readers to go through and build this project. There is a lot of jumping
    around from file to file, and just reading the instructions alone can make it
    seem more complex than it really is. Certainly, you can copy and paste the code
    from the download bundle, but please also follow the steps, and create your own
    projects and classes. Fragments are not too tough, but their implementation, like
    their name suggests, is a little fragmented.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我敦促所有读者去完成并构建这个项目。从一个文件跳到另一个文件，仅仅阅读说明就会使它看起来比实际复杂得多。当然，您可以从下载包中复制并粘贴代码，但也请按照步骤进行，并创建自己的项目和类。片段并不太难，但它们的实现，就像它们的名称所暗示的那样，有点分散。
- en: Create a new project called `Simple Fragment` using the **Empty Activity** template
    and leave the rest of the settings at their defaults.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Empty Activity** 模板创建一个名为 `Simple Fragment` 的新项目，并将其余设置保持默认。
- en: Note that there is the option to create a project with a fragment, but we will
    learn more by doing things ourselves from scratch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有选项可以创建一个带有片段的项目，但是通过自己从头开始做事情，我们会学到更多。
- en: Switch to `activity_main.xml` and delete the default **Hello world!** `TextView`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `activity_main.xml` 并删除默认的 **Hello world!** `TextView`。
- en: Now, make sure that the root `ConstraintLayout` is selected by left-clicking
    it in the **Component tree** window, and then change its **id** property to `fragmentHolder`.
    We will now be able to get a reference to this layout in our Kotlin code, and,
    as the **id** property implies, we will be adding a fragment to it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在 **Component tree** 窗口中左键单击选择根 `ConstraintLayout`，然后将其 **id** 属性更改为 `fragmentHolder`。现在我们将能够在我们的
    Kotlin 代码中引用此布局，并且正如 **id** 属性所暗示的那样，我们将向其中添加一个片段。
- en: Now, we will create a layout that will define our fragment's appearance. Right-click
    the `layout` folder and choose **New | Layout resource file**. In the **File name:**
    field, type `fragment_layout` and left-click **OK**. We have just created a new
    layout of the `LinearLayout` type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个布局，该布局将定义我们片段的外观。右键单击 `layout` 文件夹，然后选择 **New | Layout resource file**。在
    **File name:** 字段中，键入 `fragment_layout`，然后左键单击 **OK**。我们刚刚创建了一个 `LinearLayout`
    类型的新布局。
- en: Add a single **Button** widget anywhere on the layout and make its **id** property
    `button`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局的任何位置添加一个单独的 **Button** 小部件，并将其 **id** 属性设置为 `button`。
- en: Now that we have a simple layout for our fragment to use, let's write some Kotlin
    code to make the actual fragment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个供我们的片段使用的简单布局，让我们编写一些 Kotlin 代码来创建实际的片段。
- en: Note that you can create a `Fragment` instance by simply dragging and dropping
    one from the palette, but doing things that way is much less flexible and controllable,
    and flexibility and control are the big benefits of using fragments, as we will
    see throughout this and the next three chapters. By creating a class that extends
    `Fragment`, we can make as many fragments from it as we like.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过从调色板中简单地拖放一个 `Fragment` 实例来创建一个 `Fragment` 实例，但以这种方式做事情的灵活性和可控性要少得多，而灵活性和可控性是使用片段的重要好处，正如我们将在本章和接下来的三章中看到的那样。通过创建一个扩展
    `Fragment` 的类，我们可以从中制作出许多片段。
- en: In the project explorer, right-click the folder that contains the `MainActivity`
    file. From the context menu, create a new Kotlin class called `SimpleFragment`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，右键单击包含 `MainActivity` 文件的文件夹。从上下文菜单中，创建一个名为 `SimpleFragment` 的新 Kotlin
    类。
- en: 'In our new `SimpleFragment` class, change the code to inherit from `Fragment`.
    As you type the code, you will be asked to choose the specific `Fragment` class
    to import, as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新 `SimpleFragment` 类中，将代码更改为继承自 `Fragment`。在输入代码时，将要求您选择要导入的特定 `Fragment`
    类，如下面的屏幕截图所示：
- en: '![Our first fragment app](img/B12806_24_06.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个片段应用](img/B12806_24_06.jpg)'
- en: Choose the top option (as shown in the preceding screenshot), which is the regular
    `Fragment` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 选择顶部选项（如前面的屏幕截图所示），即常规的 `Fragment` 类。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will need all of the following import statements in this class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个类中需要以下所有的导入语句：
- en: '[PRE3]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is what the code looks like at this stage:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此时代码如下所示：
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add a single `String` property called `myString` and initialize it, as
    shown in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`myString`的`String`属性并初始化它，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When using `Fragment`, we need to handle the layout in the `onCreateView` function.
    Let's override that now and learn how we can set the view and get a reference
    to our `Button`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Fragment`时，我们需要在`onCreateView`函数中处理布局。现在让我们重写它，学习如何设置视图并获取对我们的`Button`的引用。
- en: 'Add the following code to the `SimpleFragment` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`SimpleFragment`类中：
- en: '[PRE6]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To understand the previous block of code, we must first look at the `onCreateView`
    signature. Note that in the first instance, the signature states that it must
    return an object of the `View` type, as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解上一段代码，我们首先必须查看`onCreateView`的签名。请注意，在第一个实例中，签名说明它必须返回一个`View`类型的对象，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we have the three parameters. Let''s look at the first two:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有三个参数。让我们先看前两个：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need a `LayoutInflater`, as we cannot call `setContentView` because `Fragment`
    provides no such function. In the body of `onCreateView`, we use the `inflate`
    function of `inflater` to inflate our layout contained in `fragment_layout.xml`
    and initialize `view` (an object of the `View type`) with the result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`LayoutInflater`，因为我们不能调用`setContentView`，因为`Fragment`没有提供这样的函数。在`onCreateView`的主体中，我们使用`inflater`的`inflate`函数来膨胀我们在`fragment_layout.xml`中包含的布局，并用结果初始化`view`（`View`类型的对象）。
- en: We use `container`, which was passed into `onCreateView`, as an argument in
    the `inflate` function as well. The `container` variable is a reference to the
    layout in `activity_main.xml`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`inflate`函数中也使用了传入`onCreateView`的`container`作为参数。`container`变量是对`activity_main.xml`中的布局的引用。
- en: It might seem obvious that `activity_main.xml` is the containing layout, but,
    as we will see later in this chapter, the `ViewGroup container` argument allows
    *any* `Activity` with *any* layout to be the container for our fragment. This
    is exceptionally flexible and makes our `Fragment` code reusable to a significant
    extent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`activity_main.xml`是包含布局可能看起来很明显，但是正如我们将在本章后面看到的那样，`ViewGroup container`参数允许*任何*`Activity`与*任何*布局成为我们的fragment的容器。这是非常灵活的，并且在很大程度上使我们的`Fragment`代码可重用。'
- en: The third argument we pass into `inflate` is `false`, which means that we don't
    want our layout added immediately to the containing layout. We will do this ourselves
    soon from another part of the code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`inflate`的第三个参数是`false`，这意味着我们不希望我们的布局立即添加到包含的布局中。我们很快将从代码的另一个部分自己完成这个步骤。
- en: The third parameter of `onCreateView` is `Bundle savedInstanceState`, which
    is there to help us maintain the data that our fragments hold.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateView`的第三个参数是`Bundle savedInstanceState`，它可以帮助我们维护我们的fragment持有的数据。'
- en: Now that we have an inflated layout contained in `view`, we can use this to
    get a reference to our `Button` widget from the layout and listen for clicks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包含在`view`中的膨胀布局，我们可以使用它来从布局中获取对我们的`Button`小部件的引用并监听点击。
- en: 'Finally, we use `view` as the return value to the calling code, as required.
    We can set this up as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`view`用作调用代码的返回值，如下所示：
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can add a lambda to listen for clicks on our button in the usual manner.
    In the `onClick` function, we display a pop-up `Toast` message to demonstrate
    that everything is working as expected.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照通常的方式为按钮添加lambda来监听点击。在`onClick`函数中，我们显示一个弹出的`Toast`消息，以演示一切都按预期工作。
- en: 'Add this code just before the `return` statement in `onCreateView`, as shown
    in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`onCreateView`中的`return`语句之前，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the use of the `activity` property in `makeText`, which is a reference
    to the `Activity` that contains the `Fragment`. This is required to display a
    `Toast` message.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`makeText`中使用的`activity`属性是对包含`Fragment`的`Activity`的引用。这是为了显示`Toast`消息而需要的。
- en: We can't run our app just yet; it will not work because there is one more step
    required. We need to create an instance of `SimpleFragment` and initialize it
    appropriately. This is where `FragmentManager` will get introduced.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还不能运行我们的应用程序；它不会工作，因为还需要一步。我们需要创建一个`SimpleFragment`的实例并适当地初始化它。这就是`FragmentManager`将被介绍的地方。
- en: The following code uses the `supportFragmentManager` property of `Activity`.
    It creates a new `Fragment`, based on our `SimpleFragment` class, using the `findFragmentByID`
    function, and passes in the ID of the layout (within the `Activity`) that will
    hold it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`Activity`的`supportFragmentManager`属性。它基于我们的`SimpleFragment`类创建一个新的`Fragment`，使用`findFragmentByID`函数，并传入将容纳它的布局（在`Activity`内部）的ID。
- en: 'Add this code to the `onCreate` function of `MainActivity.kt`, just after the
    call to `setContentView`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到`MainActivity.kt`的`onCreate`函数中，在调用`setContentView`之后：
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, run the app and gaze in wonder at our clickable button that displays a
    message with the `Toast` class, and which took two layouts and two whole classes
    to create:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，惊叹于我们可点击的按钮，它显示了一个使用`Toast`类的消息，并且创建它需要两个布局和两个完整的类：
- en: '![Our first fragment app](img/B12806_24_07.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个fragment应用](img/B12806_24_07.jpg)'
- en: If you remember doing this way back in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, and with far less
    code, then it is clear that we need a fragment reality check to answer the question,
    "Why?"!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得在[第2章](ch02.html "第2章. Kotlin, XML和UI设计师")中以这种方式做过，*Kotlin, XML和UI设计师*，并且代码要少得多，那么很明显我们需要一个fragment现实检查来回答“为什么？”的问题！
- en: Fragment reality check
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fragment现实检查
- en: So, what does this fragment stuff really do for us? Our first fragment mini-app
    would have the same appearance and functionality had we not bothered with the
    fragment at all.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个fragment到底对我们有什么作用呢？如果我们根本不去理会fragment，我们的第一个fragment迷你应用程序的外观和功能将是一样的。
- en: In fact, using the fragment has made the whole thing more complicated! Why would
    we want to do this?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用片段使整个事情变得更加复杂！为什么我们要这样做呢？
- en: We kind of know the answer to this already; it just isn't especially clear based
    on what we have seen so far. We know that a fragment, or fragments, can be added
    to the layout of an activity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有点知道这个问题的答案；只是根据我们目前所见，它并不是特别清楚。我们知道一个片段或多个片段可以添加到活动的布局中。
- en: We know that a fragment not only contains its own layout (view), but also its
    very own code (controller), which, although hosted by an activity, is virtually
    independent.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道一个片段不仅包含自己的布局（视图），还包含自己的代码（控制器），虽然由一个活动托管，但实际上是相对独立的。
- en: Our quick app only showed one fragment in action, but we could have an activity
    that hosts two or more fragments. We then effectively have two almost independent
    controllers displayed on a single screen. This sounds like it could be useful.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的快速应用程序只显示了一个片段的操作，但我们可以有一个托管两个或更多片段的活动。然后我们在单个屏幕上有效地显示了两个几乎独立的控制器。这听起来可能很有用。
- en: What is most useful about this, however, is that when the activity starts, we
    can detect attributes of the device our app is running on, perhaps a phone or
    tablet, in portrait or landscape mode. We can then use this information to decide
    to display either just one or two of our fragments simultaneously.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最有用的是，当活动启动时，我们可以检测我们的应用程序运行的设备的属性，也许是手机或平板电脑，是纵向还是横向模式。然后我们可以使用这些信息来决定同时显示一个或两个片段。
- en: This not only helps us achieve the kind of functionality we discussed in the
    Real- world apps section, at the start of this chapter, but it also allows us
    to do so using the exact same fragment code for both possible scenarios!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅帮助我们实现了我们在本章开头讨论的真实应用部分中讨论的功能，而且还允许我们在两种可能的情况下使用完全相同的片段代码！
- en: This really is the essence of fragments. We create a whole app by pairing up
    both functionality (controller) and appearance (view) into a bunch of fragments
    that we can reuse in different ways, almost without a care.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是片段的本质。我们通过将功能（控制器）和外观（视图）配对成一堆片段来创建一个完整的应用程序，我们可以以几乎不用担心的方式以不同的方式重复使用它们。
- en: The missing link is that if all these fragments are fully-functioning, independent
    controllers, then we need to learn a bit more about how we can implement our model
    layer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的环节是，如果所有这些片段都是完全功能的独立控制器，那么我们需要更多地了解如何实现我们的模型层。
- en: It is, of course, possible to foresee a few stumbling blocks, so take a look
    at the following frequently asked question.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以预见到一些障碍，所以看一下以下经常问的问题。
- en: Frequently asked question
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常问的问题
- en: Q) If we simply have an `ArrayList`, as we did with the Note to self app, where
    will it go? How would we share it between fragments (assuming both/all fragments
    need access to the same data)?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Q）如果我们只有一个`ArrayList`，就像我们在“Note to self”应用程序中一样，它将去哪里？我们如何在片段之间共享它（假设所有片段都需要访问相同的数据）？
- en: A) There is an entirely more elegant solution we can use to create a model layer
    (both the data itself and the code to maintain the data). We will see this when
    we explore `NavigationDrawer` in [Chapter 26](ch26.html "Chapter 26. Advanced
    UI with Navigation Drawer and Fragment"), *Advanced UI with Navigation Drawer
    and Fragments*, and Android databases in [Chapter 27](ch27.html "Chapter 27. Android
    Databases"), *Android Databases*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: A）我们可以使用一种更加优雅的解决方案来创建一个模型层（数据本身和维护数据的代码）。当我们探索“NavigationDrawer”时，我们将看到这一点[第26章](ch26.html
    "第26章。使用导航抽屉和片段的高级UI")，“使用导航抽屉和片段的高级UI”，以及Android数据库[第27章](ch27.html "第27章。Android数据库")，“Android数据库”。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have a broad understanding of what fragments are meant for and how
    we can begin to use them, we can start to go deeper into how they are used. In
    the next chapter, we will make a couple of apps that use multiple fragments in
    different ways.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对片段的用途有了广泛的了解，以及如何开始使用它们，我们可以开始深入了解它们的使用。在下一章中，我们将制作一些以不同方式使用多个片段的应用程序。
