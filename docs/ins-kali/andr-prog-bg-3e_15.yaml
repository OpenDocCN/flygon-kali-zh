- en: '*Chapter 15*: Arrays, Maps, and Random Numbers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：数组、映射和随机数'
- en: In this chapter, we will learn about Java arrays, which allow us to manipulate
    a potentially huge amount of data in an organized and efficient manner. We will
    also use a close Java relation to arrays, `ArrayList`, and look at the differences
    between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java数组，它允许我们以有组织和高效的方式操纵大量数据。我们还将使用与数组有密切关系的Java类`ArrayList`，并研究它们之间的区别。
- en: Once we are comfortable handling substantial amounts of data, we will see what
    the Android API has to offer to help us easily connect our newfound data-handling
    skills to the user interface without breaking a sweat.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉处理大量数据，我们将看看Android API提供了什么帮助，让我们轻松地将我们新发现的数据处理技能与用户界面连接起来，而不费吹灰之力。
- en: 'The topics in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括以下内容：
- en: The `Random` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Random`类'
- en: Handling data with arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组处理数据
- en: Arrays mini-app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组小应用程序
- en: Dynamic arrays including a mini-app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一个小型应用程序的动态数组
- en: Multidimensional arrays including a mini-app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一个小型应用程序的多维数组
- en: The `ArrayList` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`类'
- en: The enhanced `for` loop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强型`for`循环
- en: The Java HashMap
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java HashMap
- en: First, let's learn about the `Random` class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下`Random`类。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2015)。
- en: A random diversion
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个随机的转移
- en: Sometimes in our apps we will want a random number, and Java provides us with
    the `Random` class for these occasions. There are many possible uses for this
    class. For instance, maybe our app wants to show a random tip of the day, or is
    a game that has to choose between scenarios, or is a quiz that asks random questions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在我们的应用程序中，我们会需要一个随机数，而Java为我们提供了`Random`类来满足这些需求。这个类有许多可能的用途。例如，也许我们的应用程序想要显示每日随机提示，或者是一个需要在不同情景之间选择的游戏，或者是一个随机提问的测验。
- en: The `Random` class is part of the Java API and is fully compatible with our
    Android apps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random`类是Java API的一部分，完全兼容我们的Android应用程序。'
- en: 'Let''s have a look at how we can create random numbers, and later in the chapter
    we will put it to practical use. All the hard work is done for us by the `Random`
    class. First, we need to create an object of type `Random`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建随机数，然后在本章中我们将把它应用到实际中。所有的工作都由`Random`类为我们完成。首先，我们需要创建一个`Random`类型的对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we use our new object''s `nextInt` method to generate a random number
    in a certain range. This next line of code generates the random number using our
    `Random` object and stores the result in the `ourRandomNumber` variable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用我们新对象的`nextInt`方法在一定范围内生成一个随机数。下一行代码使用我们的`Random`对象生成随机数，并将结果存储在`ourRandomNumber`变量中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The number that we enter for the range starts from zero. So, the preceding
    line will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just do this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的范围开始于零。因此，前一行将生成一个介于0和9之间的随机数。如果我们想要一个介于1和10之间的随机数，我们只需这样做：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also use the `Random` object to get other types of random numbers using
    the `nextLong`, `nextFloat`, and `nextDouble` methods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Random`对象使用`nextLong`、`nextFloat`和`nextDouble`方法获取其他类型的随机数。
- en: We will put the `Random` class to practical use later in the chapter with a
    quick geography quiz app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面用一个快速地理测验应用程序实际使用`Random`类。
- en: Handling large amounts of data with arrays
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组处理大量数据
- en: 'You might be wondering what happens when we have an app with lots of variables
    to keep track of. What about our Note to Self app with 100 notes or a high score
    table in a game with the top 100 scores? We could declare and initialize 100 separate
    variables like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会想知道当我们有很多变量需要跟踪时会发生什么。我们的自我备忘录应用程序有100条备忘录，或者游戏中有前100名得分的高分表怎么办？我们可以像这样声明和初始化100个单独的变量：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or we could do this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样做：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Straight away, this might seem unwieldy, but what about when someone gets a
    new top score or we want to let our users sort the order that their notes are
    displayed in? Using the high scores scenario, we must shift the scores in every
    variable down one place. A nightmare begins:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，这可能看起来笨拙，但是当有人获得新的最高分或者我们想让用户对他们的笔记显示顺序进行排序时怎么办？使用高分情景，我们必须将每个变量中的分数下移一个位置。噩梦开始了：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There must be a better way. When we have a whole array of variables, what we
    need is a Java array. An array is a reference variable that holds up to a pre-determined,
    fixed maximum number of elements. Each element is a variable with a consistent
    type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一定有更好的方法。当我们有一整个数组的变量时，我们需要的是一个Java数组。数组是一个引用变量，最多可以容纳预先确定的固定数量的元素。每个元素都是一个具有一致类型的变量。
- en: 'The following code declares an array that can hold `int` type variables, perhaps
    a high score table or a series of exam grades:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了一个可以容纳`int`类型变量的数组，可能是一个高分表或一系列考试成绩：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could also declare arrays of other types, including classes such as `Note`,
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明其他类型的数组，包括`Note`等类，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it was used. Just like other objects, we must initialize arrays
    before we use them:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，这些数组中的每一个都需要分配固定的最大存储空间。就像其他对象一样，我们必须在使用数组之前对其进行初始化：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code allocates up to a maximum of 100 `int`-sized storage spaces.
    Think of a long aisle of 100 consecutive storage spaces in our memory warehouse
    analogy. The spaces would probably be labeled `intArray[0]`, `intArray[1]`, `intArray[2]`,
    and so on, with each space holding a single `int` value. Perhaps the slightly
    surprising thing here is that the storage spaces start off at zero, not 1\. Therefore,
    in a 100-*wide* array, the storage spaces would run from 0 to 99\.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码分配了最多100个`int`大小的存储空间。想象一下我们的内存仓库中有100个连续的存储空间。这些空间可能被标记为`intArray[0]`，`intArray[1]`，`intArray[2]`等等，每个空间都保存一个单独的`int`值。也许稍微令人惊讶的是，存储空间从零开始，而不是1。因此，在一个100宽的数组中，存储空间将从0到99。
- en: 'We could initialize the values in some of these storage spaces like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样初始化一些存储空间中的值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But note that we can only ever put the pre-declared type into an array, and
    the type that an array holds can never change:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，我们只能将预先声明的类型放入数组中，数组保存的类型永远不会改变：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, when we have an array of `int` types, what are each of these `int` variables
    called? What are the names of these variables and how do we access the values
    stored in them? The array notation syntax replaces the variable names. And we
    can do anything with a variable in an array that we could do with a regular variable
    with a name:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们有一个`int`类型的数组时，每个这些`int`变量被称为什么？这些变量的名称是什么，我们如何访问其中存储的值？数组表示法语法替换了变量名称。我们可以对数组中的变量进行与常规变量相同的操作：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code assigns the value `123` into the fourth position of `intArray`.
    Here is another example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将值`123`分配给`intArray`的第四个位置。这里是另一个例子：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code subtracts the value in the fifth position of `intArray`
    from the value in the tenth position and stores the answer in the eleventh position.
    We can also assign the value from an array to a regular variable of the same type,
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码从`intArray`的第五个位置减去第十个位置的值，并将答案存储在第十一个位置。我们还可以将数组中的值分配给相同类型的常规变量，如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable
    and any changes to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is unconnected to the array. To be more
    specific, the array is on the heap and the `int` variable is on the stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，`myNamedInt`是一个单独且独立的原始变量，对它的任何更改都不会影响存储在`intArray`引用中的值。它在仓库中有自己的空间，并且与数组没有关联。更具体地说，数组在堆上，而`int`变量在栈上。
- en: Arrays are objects
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是对象
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So, `someArray[0]`, `someArray[1]`, and
    so on are the aisle numbers followed by the position number in the aisle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过数组是引用变量。将数组变量视为给定类型的一组变量的地址。也许，使用仓库的类比，`someArray`是一个过道编号。因此，`someArray[0]`，`someArray[1]`等等是过道编号，后面是过道中的位置编号。
- en: 'Arrays are also objects; that is, they have methods and properties that we
    can use. See this, for example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也是对象；也就是说，它们有我们可以使用的方法和属性。例如：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we assigned the length of `someArray` to the `int` variable
    called `lengthOfSomeArray`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将`someArray`的长度分配给名为`lengthOfSomeArray`的`int`变量。
- en: 'We can even declare an array of arrays. This is an array where in each of its
    elements lurks another array, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以声明一个数组的数组。这是一个数组，其中每个元素中都隐藏着另一个数组，如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array crazy just yet, though. Just remember that an array holds
    up to a pre-determined number of variables of any pre-determined type, and those
    values are accessed using this syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，我们可以在每个国家中保存一个城市列表。不过，现在先不要疯狂地使用数组。只需记住，数组最多可以容纳预定数量的任意类型的变量，并且可以使用以下语法访问这些值：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's use some arrays in a real app to try and get an understanding of how to
    use them in real code and what we might use them for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个真实的应用程序中使用一些数组，试着理解如何在真实代码中使用它们以及我们可能用它们做什么。
- en: Simple array example mini-app
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单数组示例迷你应用程序
- en: Let's make a simple working array example. You can get the completed code for
    this example in the downloadable code bundle. It's at [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Simple
    Array Example/MainActivity.java`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个简单的工作数组示例。您可以在可下载的代码包中找到此示例的完整代码。它在[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Simple
    Array Example/MainActivity.java`。
- en: Create a project using the Empty Activity template and call it `Simple Array
    Example`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空活动模板创建一个项目，并将其命名为`Simple Array Example`。
- en: 'First, we declare our array, allocate five spaces, and initialize values for
    each of the elements. Then we output each of the values to the logcat console.
    Add this code to the `onCreate` method just after the call to `setContentView`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的数组，分配五个空间，并为每个元素初始化值。然后我们将每个值输出到logcat控制台。将此代码添加到`onCreate`方法中，就在调用`setContentView`之后：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we add each of the elements of the array together, just as we could regular
    `int` type variables. Notice that when we add the array elements together, we
    are doing so over multiple lines. This is fine as we have omitted a semicolon
    until the last operation, so the Java compiler treats the lines as one statement.
    Add the code we have just discussed to `MainActivity.java`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将数组的每个元素相加，就像我们可以对常规的`int`类型变量一样。请注意，当我们将数组元素相加时，我们是在多行上这样做的。这没问题，因为我们省略了分号，直到最后一个操作，所以Java编译器将这些行视为一个语句。将我们刚刚讨论的代码添加到`MainActivity.java`：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the example and see the output in the logcat window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例并在logcat窗口中查看输出。
- en: 'Remember that nothing will happen on the emulator display as all the output
    will be sent to our logcat console window in Android Studio. Here is the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，模拟器显示不会发生任何事情，因为所有输出都将发送到我们在Android Studio中的logcat控制台窗口。这是输出：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We declared an array called `ourArray` to hold `int` variables, then allocated
    space for up to five of that type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`ourArray`的数组来保存`int`变量，然后为该类型的最多五个变量分配了空间。
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为数组中的五个空间分配了一个值。请记住，第一个空间是`ourArray[0]`，最后一个空间是`ourArray[4]`。
- en: Next, we simply printed the value in each array location to the console, and
    from the output, we can see they hold the values we initialized them to be in
    the previous step. Then we added together each of the elements in `ourArray` and
    initialized their values to the `answer` variable. We then printed `answer` to
    the console and we can see that indeed all the values were added together, just
    as if they were plain old `int` types, which they are, just stored and accessed
    in a different manner.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地将每个数组位置的值打印到控制台上，从输出中我们可以看到它们保存了我们在上一步中初始化的值。然后我们将`ourArray`中的每个元素相加，并将它们的值初始化为`answer`变量。然后我们将`answer`打印到控制台上，我们可以看到确实所有的值都被相加了，就像它们是普通的`int`类型一样，它们确实是，只是以不同的方式存储和访问。
- en: Getting dynamic with arrays
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组进行动态处理
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit to an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在所有这些数组内容开始时讨论的，如果我们需要单独声明和初始化数组的每个元素，那么数组与常规变量相比并没有太大的好处。让我们看一个动态声明和初始化数组的例子。
- en: Dynamic array example
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态数组示例
- en: Let's make a simple dynamic array example. You can get the working project for
    this example in the download bundle. It is at [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Dynamic
    Array Example/MainActivity.java`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的动态数组示例。您可以在下载包中找到此示例的工作项目。它在[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Dynamic
    Array Example/MainActivity.java`中。
- en: Create a project using the Empty Activity template and call it `Dynamic Array
    Example`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空活动模板创建一个项目，并将其命名为“动态数组示例”。
- en: 'Type the following code just after the call to the `setContentView` method
    in the `onCreate` method. See whether you can work out what the output will be
    before we discuss it and analyze the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的`setContentView`方法调用之后，输入以下代码。在我们讨论和分析代码之前，看看您能否猜出输出会是什么：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the example app, remembering that nothing will happen on the screen as
    all the output will be sent to our logcat console window in Android Studio. Here
    is the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例应用程序，记住屏幕上不会发生任何事情，因为所有输出都将发送到我们在Android Studio中的logcat控制台窗口。以下是输出：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we declared and allocated an array called `ourArray` to hold up to 1,000
    `int` values. Notice that this time we did the two steps in one line of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明并分配了一个名为`ourArray`的数组，用于保存最多1,000个`int`值。请注意，这次我们在一行代码中完成了两个步骤：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用了一个设置为循环1,000次的`for`循环：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We initialized the spaces in the array, from 0 through to 999, with the value
    of `i` multiplied by 5, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用值为`i`乘以5来初始化数组中的空间，从0到999，就像这样：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, to demonstrate the value of `i` and the value held in each position of
    the array, we output the value of `i` followed by the value held in the corresponding
    position in the array, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了演示`i`的值以及数组中每个位置保存的值，我们输出了`i`的值，然后是数组中相应位置保存的值，就像这样：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And all this happened 1,000 times, producing the output we have seen. Of course,
    we have yet to use this technique in a real-world app, but we will use it soon
    to make our Note to Self app hold an almost infinite number of notes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生了1,000次，产生了我们所看到的输出。当然，我们还没有在真实世界的应用程序中使用这种技术，但我们很快将使用它来使我们的“备忘录”应用程序保存几乎无限数量的备忘录。
- en: Entering the nth dimension with arrays
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组进入n维
- en: We very briefly mentioned that an array can even hold other arrays at each position.
    But if an array holds lots of arrays that hold lots of some other type, how do
    we access the values in the contained arrays? And why would we ever need this
    anyway? Look at this next example of where multidimensional arrays can be useful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常简要地提到了数组甚至可以在每个位置上保存其他数组。但是，如果一个数组保存了很多保存了其他某种类型的数组的数组，我们如何访问包含数组中的值呢？无论如何，我们为什么需要这个呢？看看下一个示例，多维数组在哪里可以派上用场。
- en: Multidimensional array mini-app
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组迷你应用程序
- en: Let's make a simple multidimensional array example. You can get the working
    project for this example in the download bundle. It is in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Multidimensional
    Array Example/MainActivity.java`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个简单的多维数组示例。您可以在下载包中找到此示例的工作项目。它在[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)`/Multidimensional
    Array Example/MainActivity.java`中。
- en: Create a project using the Empty Activity template and call it `Multidimensional
    Array Example`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空活动模板创建一个项目，并将其命名为“多维数组示例”。
- en: 'After the call to `setContentView` in `onCreate`, add the following code, including
    declaring and initializing a two-dimensional array (highlighted):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中的`setContentView`调用之后，添加以下代码，包括声明和初始化一个二维数组（已突出显示）：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we output the contents of the array using a `for` loop and our `Random`
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer. Add the following code after the previous code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`for`循环和我们的`Random`对象输出数组的内容。请注意，尽管问题是随机的，但我们始终可以选择正确的答案。在上一个代码之后添加以下代码：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the example, remembering that nothing will happen on the screen as all
    the output will be sent to our logcat console window in Android Studio. Here is
    the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例，记住屏幕上不会发生任何事情，因为所有输出都将发送到我们在Android Studio中的logcat控制台窗口。以下是输出：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What just happened? Let's go through this chunk by chunk so we know exactly
    what is going on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才发生了什么？让我们一块一块地过一遍，这样我们就知道到底发生了什么。
- en: 'We make a new object of type `Random` called `randInt`, ready to generate random
    numbers later in the program:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`randInt`的`Random`类型的新对象，准备在程序后面生成随机数：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There''s a simple `int` variable to hold a question number:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的`int`变量来保存一个问题编号：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here we declare our array of arrays called `countriesAndCities`. The outer
    array holds arrays:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们声明了一个名为`countriesAndCities`的数组数组。外部数组保存数组：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we allocate space within our arrays. The first outer array will now be
    able to hold five arrays and each of the inner arrays will be able to hold two
    strings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在数组中分配空间。第一个外部数组现在可以保存五个数组，每个内部数组可以保存两个字符串：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we initialize our arrays to hold countries and their corresponding capital
    cities. Notice with each pair of initializations that the outer array number stays
    the same, indicating that each country/capital pair is within one inner array,
    a `String` array. And of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们初始化我们的数组来保存国家和它们对应的首都。注意到每一对初始化的外部数组编号保持不变，表明每个国家/首都对在一个内部数组中，一个`String`数组。当然，每个内部数组都保存在外部数组的一个元素中（保存数组的数组）：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are at position `1`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使即将到来的`for`循环更清晰，我们声明和初始化`int`变量来表示我们数组中的国家和首都。如果你回顾一下数组初始化，所有的国家都保存在内部数组的位置`0`，所有对应的首都都在位置`1`：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we set up a `for` loop to run three times. Note that this does not simply
    access the first three elements of our array; it just determines the number of
    times we go through the loop. We could make it loop one time or a thousand times;
    the example would still work:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置一个`for`循环运行三次。请注意，这不仅仅是访问我们数组的前三个元素；它只是确定我们循环的次数。我们可以让它循环一次或一千次；示例仍然有效：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we determine which question to ask – or more specifically, which element
    of our outer array. Remember that `randInt.nextInt(5)` returns a number between
    0 and 4 – just what we need, as we have an outer array with five elements, 0 through
    4:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定要提问的问题 - 或者更具体地说，我们的外部数组的哪个元素。记住，`randInt.nextInt(5)`返回一个0到4之间的数字 -
    这正是我们需要的，因为我们有一个包含五个元素的外部数组，从0到4：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过输出内部数组中保存的字符串来提问，而这些内部数组又是由前一行随机生成的外部数组保存的：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So, if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist, what they can do,
    and you can revisit them if necessary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在本书的其余部分我们将不再使用多维数组。所以，如果对这些数组内部的数组还有一点模糊，那没关系。你知道它们存在，知道它们能做什么，如果有必要的话可以重新学习。
- en: Array-out-of-bounds exceptions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组越界异常
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Sometimes the compiler will catch it for us to
    prevent the error going into a working app. For example, see this code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个不存在的数组元素时，就会发生数组越界异常。有时编译器会为我们捕捉到它，以防止错误进入工作中的应用程序。例如，看看这段代码：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But what if we do something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们做这样的事情呢：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The only way we can avoid this problem is to know the rule: the rule that arrays
    start at zero and go up to their length – 1\. We can also use clear, readable
    code where it is easy to evaluate what we have done and spot problems more easily.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一能避免这个问题的方法是知道这个规则：数组从零开始，到它们的长度-1。我们还可以使用清晰、可读的代码，在这种代码中更容易评估我们所做的事情，并更容易发现问题。
- en: ArrayList
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ArrayList`'
- en: '`ArrayList` is like a regular Java array on steroids. It overcomes some of
    the shortfalls of arrays, such as having to predetermine the size. It adds some
    useful methods to make its data easy to manage and it uses an enhanced version
    of a `for` loop that is clearer to use than a regular `for` loop.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList` 就像是一个增强版的普通Java数组。它克服了数组的一些缺点，比如需要预先确定大小。它添加了一些有用的方法来使数据易于管理，并且使用了一个更清晰的增强版`for`循环，比普通的`for`循环更容易使用。'
- en: 'Let''s look at some code that uses an `ArrayList` instance:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用`ArrayList`实例的代码：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the previous code, we declared and initialized a new `ArrayList` called
    `myList`. We can also do this in a single step like this code shows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明并初始化了一个名为`myList`的新`ArrayList`。我们也可以像这段代码所示的那样一步完成：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Nothing especially interesting so far, so let''s take a look at what we can
    actually do with `ArrayList`. Let''s use a `String ArrayList` instance this time:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止还没有特别有趣的东西，所以让我们看看我们实际上可以用`ArrayList`做些什么。这次我们使用一个`String ArrayList`实例：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the previous code, we saw that we can use some really useful methods of
    the `ArrayList` class on our `ArrayList` object; those methods are listed as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到我们可以在`ArrayList`对象上使用`ArrayList`类的一些非常有用的方法；这些方法列在下面：
- en: We can add an item (`myList.add`).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个项目（`myList.add`）。
- en: Add at a specific location (`myList.add(x, value)`).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定位置添加（`myList.add(x, value)`）。
- en: Check whether `ArrayList` is empty (`myList.isEmpty`).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`ArrayList`是否为空（`myList.isEmpty`）。
- en: See how many elements it has (`myList.size()`).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看它有多少元素（`myList.size()`）。
- en: Get the current position of a given item (`myList.indexOf`).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定项目的当前位置（`myList.indexOf`）。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are even more methods in the `ArrayList` class and you can read about
    them here: http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html.
    What we have seen so far is enough to complete this book, however.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类中甚至还有更多的方法，你可以在这里阅读：http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html。到目前为止，我们已经看到的足以完成本书。 '
- en: With all this functionality, all we need now is a way to handle `ArrayList`
    instances dynamically.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些功能，我们现在只需要一种方法来动态处理`ArrayList`实例。
- en: The enhanced for loop
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强型for循环
- en: 'This is what the condition of an enhanced `for` loop looks like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是增强型`for`循环的条件：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The previous example would iterate (step through) all of the items in `myList`
    one at a time. At each step, `s` would hold the current `String` value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子会逐个遍历`myList`中的所有项目。在每一步中，`s`会保存当前的`String`值。
- en: 'So, this code would print to the console all of our eminent programmers from
    the previous section''s `ArrayList` code sample:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码将在控制台上打印出我们上一节`ArrayList`代码示例中的所有杰出程序员：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can also use the enhanced `for` loop with regular arrays too:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用增强型`for`循环来处理常规数组：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's another incoming news flash!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个即将到来的新闻快讯！
- en: Arrays and ArrayList instances are polymorphic
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和ArrayList实例是多态的
- en: We already know that we can put objects into arrays and `ArrayList`. But being
    polymorphic means they can handle objects of multiple distinct types as long as
    they have a common parent type all within the same array or `ArrayList`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以将对象放入数组和`ArrayList`中。但是多态意味着它们可以处理多个不同类型的对象，只要它们有一个共同的父类型，都可以放在同一个数组或`ArrayList`中。
- en: In [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented
    Programming*, we learned that polymorphism means *different forms*. But what does
    it mean to us in the context of arrays and `ArrayList`?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*中，我们学到多态意味着*不同的形式*。但在数组和`ArrayList`的上下文中，这对我们意味着什么呢？
- en: 'Boiled down to its simplest: any subclass can be used as part of the code that
    uses the superclass.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 简化到最简单的形式：任何子类都可以作为使用超类的代码的一部分。
- en: For example, if we have an array of `Animal` instances, we could put any object
    that is a type that is a subclass of `Animal` in the `Animal` array – perhaps
    `Cat` and `Dog` instances.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个`Animal`实例的数组，我们可以将任何一个是`Animal`子类的对象放入`Animal`数组中 - 也许是`Cat`和`Dog`实例。
- en: 'This means we can write code that is simpler and easier to understand, and
    easier to change:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写更简单、更易理解、更易更改的代码：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, we can write code for the superclass and rely on the fact that no matter
    how many times it is sub-classed, within certain parameters the code will still
    work. Let''s continue our previous example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以为超类编写代码，并依赖于这样一个事实，即使它被子类化多少次，在一定的参数范围内，代码仍然可以工作。让我们继续我们之前的例子：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But when we remove an object from a polymorphic array, we must remember to
    cast it to the type we want:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们从多态数组中移除一个对象时，我们必须记得将其转换为我们想要的类型：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All we have just discussed is true for `ArrayList` as well. Armed with this
    new tool kit of arrays, `ArrayList`, and the fact that they are polymorphic, we
    can move on to learn about some more Android classes that we will soon use to
    enhance our Note to Self app.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的对`ArrayList`也适用。有了这些新的工具包，包括数组、`ArrayList`，以及它们的多态性，我们可以继续学习一些更多的Android类，这些类很快就会用到我们的Note
    to Self应用程序中。
- en: More Java collections – meet the Java HashMap
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的Java集合 - 了解Java HashMap
- en: The Java `HashMap` is neat. It's part of the Java collections framework and
    a kind of cousin of the `ArrayList` class that we will use in the Note to Self
    project in the next chapter. They basically encapsulate useful data storage techniques
    that would otherwise be quite technical for us to code successfully for ourselves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`HashMap`很棒。它是Java集合框架的一部分，也是我们在下一章中将在Note to Self项目中使用的`ArrayList`类的一种近亲。它们基本上封装了一些有用的数据存储技术，否则对我们来说可能会相当技术性。
- en: I thought it would be worth taking a first look at `HashMap` on its own. Suppose
    we want to store the data of lots of characters from a role-playing game and each
    different character is represented by an object of type `Character`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得值得先看一下`HashMap`。假设我们想要存储角色扮演游戏中许多角色的数据，每个不同的角色都由`Character`类型的对象表示。
- en: We could use some of the Java tools we already know about, such as arrays or
    `ArrayList`. The Java `HashMap` is also like these things, but with `HashMap`
    we can give a unique key/identifier to each `Character` object and access any
    such object using that key/identifier.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些我们已经了解的Java工具，比如数组或`ArrayList`。Java的`HashMap`也类似于这些东西，但是使用`HashMap`，我们可以为每个`Character`对象提供一个唯一的键/标识符，并使用该键/标识符访问任何这样的对象。
- en: The term hash comes from the process of turning our chosen key/identifier into
    something used internally by the `HashMap` class. The process is called hashing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希术语来自于将我们选择的键/标识符转换为`HashMap`类内部使用的东西的过程。这个过程被称为哈希。
- en: Any of our `Character` instances can then be accessed with our chosen key/identifier.
    A good candidate for a key/identifier in the `Character` class scenario would
    be the character's name.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的键/标识符可以访问任何我们的`Character`实例。在`Character`类的情况下，一个好的键/标识符候选者可能是角色的名字。
- en: Each key/identifier has a corresponding object; in this case, it is of type
    `Character`. This is known as a key-value pair.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键/标识符都有一个相应的对象；在这种情况下，它是`Character`类型的。这被称为键值对。
- en: We just give `HashMap` a key and it gives us the corresponding object. No need
    to worry about in which index we stored our characters, whether it's Geralt, Ciri,
    or Triss; just pass the name to `HashMap` and it will do the work for us.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需给`HashMap`一个键，它就会给我们相应的对象。不需要担心我们存储角色的索引是哪个，无论是Geralt、Ciri还是Triss；只需将名字传递给`HashMap`，它就会为我们完成工作。
- en: Let's look at some examples. You don't need to type any of this code – just
    get familiar with how it works.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。你不需要输入任何代码 - 只需熟悉它的工作原理。
- en: 'We can declare a new `HashMap` to hold keys and `Character` instances like
    this code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个新的`HashMap`来保存键和`Character`实例，就像这样的代码：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The previous code assumes we have coded a class called `Character`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码假设我们已经编写了一个名为`Character`的类。
- en: 'We can initialize `HashMap` like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样初始化`HashMap`：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can add a new key and its associated object like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样添加一个新的键和其关联的对象：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also use this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And we can use this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the example code assumes that we can somehow give the `Character` instances
    their unique properties to reflect their internal differences elsewhere.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例代码都假设我们可以在其他地方赋予`Character`实例它们独特的属性，以反映它们的内部差异。
- en: 'We can then retrieve an entry from `HashMap` like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样从`HashMap`中检索条目：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or perhaps we can use the `Character` class''s methods directly like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以直接使用`Character`类的方法，就像这样：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The previous code calls the hypothetical `drawSilverSword` and `openFastTravelPortal`
    methods on the `Character` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码调用了假设的`Character`类上的`drawSilverSword`和`openFastTravelPortal`方法。
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `HashMap` class also has lots of useful methods, such as `ArrayList`. See
    the official Java page for `HashMap` here: [https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html](https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap`类也有很多有用的方法，就像`ArrayList`一样。在这里查看`HashMap`的官方Java页面：[https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html](https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html)。'
- en: Let's talk about the Note to Self app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈“Note to Self”应用程序。
- en: The Note to Self app
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “Note to Self”应用程序
- en: Despite all we have learned, we are not quite ready to apply a solution to the
    Note to Self app. We could update our code to store lots of notes in an `ArrayList`
    instance, but before we do, we also need a way to display the contents of `ArrayList`
    in the UI. It wouldn't look good to throw the whole `ArrayList` contents into
    a `TextView` widget, for example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们学到了很多，但我们还没有准备好为“Note to Self”应用程序应用解决方案。我们可以更新我们的代码，将大量的笔记存储在`ArrayList`实例中，但在这之前，我们还需要一种方法来在UI中显示`ArrayList`的内容。例如，将整个`ArrayList`的内容放入`TextView`小部件中看起来并不好。
- en: The solution is adapters and a special UI layout called `RecyclerView`. We will
    get to them in the next chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是适配器和一个名为`RecyclerView`的特殊UI布局。我们将在下一章中介绍它们。
- en: Frequently asked questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: How does a computer that can only make *real* calculations possibly generate
    a genuinely random number?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个只能进行*真实*计算的计算机如何可能生成真正的随机数？
- en: 'In reality, a computer cannot create a number that is truly random, but the
    `Random` class uses a seed that produces a number that would stand up as genuinely
    random under close statistical scrutiny. To find out more about seeds and generating
    random numbers, look at this article: [https://en.wikipedia.org/wiki/Random_number_generation](https://en.wikipedia.org/wiki/Random_number_generation).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，计算机无法创建真正随机的数字，但`Random`类使用一个种子来产生一个在严格的统计检验下会被认为是真正随机的数字。要了解更多关于种子和生成随机数的信息，请查看这篇文章：[https://en.wikipedia.org/wiki/Random_number_generation](https://en.wikipedia.org/wiki/Random_number_generation)。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to use simple Java arrays to store substantial
    amounts of data provided it is of the same type. We also used the `ArrayList`
    class, which is like an array with loads of extra features. Furthermore, we found
    out that both arrays and `ArrayList` instances are polymorphic, which means that
    a single array (or `ArrayList`) can hold multiple different objects as long as
    they are all derived from the same parent class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何使用简单的Java数组来存储大量数据，只要它们是相同类型的。我们还使用了`ArrayList`类，它类似于一个带有大量额外功能的数组。此外，我们发现数组和`ArrayList`实例都是多态的，这意味着一个数组（或`ArrayList`）可以容纳多个不同的对象，只要它们都是从同一个父类派生的。
- en: In addition, we learned about the `HashMap` class, which is also a data storage
    solution but allows access in different ways.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还了解了`HashMap`类，它也是一种数据存储解决方案，但允许以不同的方式访问。
- en: In the next chapter, we will learn about the `Adapter` and `RecyclerView` classes
    to put our theory into practice and enhance the Note to Self app.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习`Adapter`和`RecyclerView`类，将我们的理论付诸实践，并增强“Note to Self”应用程序。
