- en: Sharing Images with Docker Registries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker注册表共享镜像
- en: Shipping applications is an integral part of the Docker platform. The Docker
    Engine can download images from a central location to run containers from them,
    and can also upload images which were built locally to a central location. These
    shared image stores are called **registries**, and in this chapter we'll look
    more closely at how image registries work and the types of registries that are
    available to you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 发布应用程序是Docker平台的一个重要部分。Docker引擎可以从中央位置下载镜像以从中运行容器，并且还可以上传本地构建的镜像到中央位置。这些共享的镜像存储被称为**注册表**，在本章中，我们将更仔细地看一下镜像注册表的工作原理以及可用于您的注册表的类型。
- en: The primary image registry is Docker Hub, which is a free online service and
    is the default location for the Docker service to work with images. Docker Hub
    is a great place for the community to share images which are built to package
    open source software and are free to redistribute. Docker Hub has been hugely
    successful. At the time of writing this book, there are hundreds of thousands
    of images available on it, with billions of downloads every year.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的镜像注册表是Docker Hub，这是一个免费的在线服务，也是Docker服务默认的工作位置。Docker Hub是一个很好的地方，社区可以分享构建的用于打包开源软件并且可以自由重新分发的镜像。Docker
    Hub取得了巨大的成功。在撰写本书时，上面有数十万个可用的镜像，每年下载量达数十亿次。
- en: A public registry may not be suitable for your own applications. Docker Hub
    also offers a commercial plan so that you can host private images (in a similar
    way to how GitHub lets you host public and private source code repositories),
    and there are other commercial registries that add features like security scanning.
    You can also run your own registry server in your environment by using an open
    source registry implementation which is freely available.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 公共注册表可能不适合您自己的应用程序。Docker Hub还提供商业计划，以便您可以托管私有镜像（类似于GitHub允许您托管公共和私有源代码仓库的方式），还有其他商业注册表添加了诸如安全扫描之类的功能。您还可以通过使用免费提供的开源注册表实现在您的环境中运行自己的注册表服务器。
- en: 'In this chapter I''ll show you how to use those registries, and I''ll cover
    the finer details of tagging images – which is how you can version your Docker
    images – and working with images from different registries. We''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何使用这些注册表，并且我将介绍标记镜像的细节 - 这是您可以对Docker镜像进行版本控制的方法 - 以及如何使用来自不同注册表的镜像。我们将涵盖：
- en: Understanding registries and repositories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解注册表和仓库
- en: Running a local image registry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行本地镜像注册表
- en: Pushing and pulling images with a local registry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地注册表推送和拉取镜像
- en: Using a commercial registry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用商业注册表
- en: Understanding registries and repositories
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解注册表和仓库
- en: You download an image from a registry using the `docker image pull` command.
    When you run the command, the Docker Engine connects to the registry, authenticates
    – if it needs to – and pulls the image down. The pull process downloads all the
    image layers and stores them in the local image cache on the machine. Containers
    can only be run from images which are available in the local image cache, so unless
    they're built locally, they need to be pulled first.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker image pull`命令从注册表下载镜像。运行该命令时，Docker引擎连接到注册表，进行身份验证 - 如果需要的话 - 并下载镜像。拉取过程会下载所有镜像层并将它们存储在本地镜像缓存中。容器只能从本地镜像缓存中可用的镜像运行，因此除非它们是本地构建的，否则需要先拉取。
- en: 'One of the earliest commands you run when you get started with Docker on Windows
    will be something simple, like this example from [Chapter 2](5b6871d5-15a7-4dc2-9b7e-29a802491f24.xhtml),
    *Packaging and Running Applications as Docker Containers*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上开始使用Docker时，您运行的最早的命令之一可能是一些简单的命令，就像来自[第2章](5b6871d5-15a7-4dc2-9b7e-29a802491f24.xhtml)的这个例子，*将应用程序打包并作为Docker容器运行*。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will work even if you don't have the image in your local cache, because
    Docker can pull it from the default registry – Docker Hub. If you try to run a
    container from an image that you don't have stored locally, Docker will automatically
    pull it before creating the container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将起作用，即使您在本地缓存中没有该镜像，因为Docker可以从默认注册表Docker Hub中拉取它。如果您尝试从本地没有存储的镜像运行容器，Docker将在创建容器之前自动拉取它。
- en: In this example I haven't given Docker much information to go on – just the
    image name, `dockeronwindows/ch02-powershell-env:2e`. That detail is enough for
    Docker to find the right image in the registry, because Docker fills in some of
    the missing details with default values. The name of the repository is `dockeronwindows/ch02-powershell-env`
    a repository is a storage unit that can contain many versions of a Docker image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我没有给Docker太多信息——只是镜像名称，`dockeronwindows/ch02-powershell-env:2e`。这个细节足以让Docker在注册表中找到正确的镜像，因为Docker会用默认值填充一些缺失的细节。仓库的名称是`dockeronwindows/ch02-powershell-env`，仓库是一个可以包含多个Docker镜像版本的存储单元。
- en: Examining image repository names
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查镜像仓库名称
- en: 'Repositories have a fixed naming scheme: `{registry-domain}/{account-id}/{repository-name}:{tag}`.
    All parts are required, but Docker assumes defaults for some values. So `dockeronwindows/ch02-powershell-env:2e`
    is actually a short form of the full repository name, `docker.io/dockeronwindows/ch02-powershell-env:2e`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库有一个固定的命名方案：`{registry-domain}/{account-id}/{repository-name}:{tag}`。所有部分都是必需的，但Docker会假设一些值的默认值。所以`dockeronwindows/ch02-powershell-env:2e`实际上是完整仓库名称的简写形式，即`docker.io/dockeronwindows/ch02-powershell-env:2e`：
- en: '`registry-domain` is the domain name or IP address of the registry that stores
    the image. Docker Hub is the default registry, so you can omit the registry domain
    when you''re using images from Hub. Docker will use `docker.io` as the registry
    if you don''t specify one.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry-domain`是存储镜像的注册表的域名或IP地址。Docker Hub是默认的注册表，所以在使用来自Hub的镜像时，可以省略注册表域。如果不指定注册表，Docker将使用`docker.io`作为注册表。'
- en: '`account-id` is the name of the account or organization which owns the image
    on the registry. On Docker Hub the account name is mandatory. My own account ID
    is `sixeyed`, and the organization account ID for the images that accompany this
    book is `dockeronwindows`. On other registries, the account ID may not be needed.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account-id`是在注册表上拥有镜像的帐户或组织的名称。在Docker Hub上，帐户名称是强制的。我的帐户ID是`sixeyed`，伴随本书的图像的组织帐户ID是`dockeronwindows`。在其他注册表上，可能不需要帐户ID。'
- en: '`repository-name` is the name you want to give your image to uniquely identify
    the application, within all the repositories for your account on the registry.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repository-name`是您想要为镜像指定的名称，以在注册表上的您的所有仓库中唯一标识应用程序。'
- en: '`tag` is how you distinguish between different image variations in the repository.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`是用来区分仓库中不同镜像变体的方式。'
- en: You use the tag for versioning your applications or to identify variants. If
    you don't specify a tag when you build or pull images, Docker uses the default
    tag  `latest`. When you start with Docker you will use Docker Hub and the `latest`
    tag, which are the defaults that Docker provides to hide some of the complexity
    until you're ready to dig deeper. As you continue with Docker, you'll use tags
    to make clear distinctions between different versions of your application package.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标签对应用程序进行版本控制或识别变体。如果在构建或拉取镜像时未指定标签，Docker将使用默认标签`latest`。当您开始使用Docker时，您将使用Docker
    Hub和`latest`标签，这是Docker提供的默认值，以隐藏一些复杂性，直到您准备深入挖掘。随着您继续使用Docker，您将使用标签来清楚地区分应用程序包的不同版本。
- en: A good example of this is Microsoft's .NET Core base image, which is on Docker
    Hub in the `microsoft/dotnet` repository. .NET Core is a cross-platform application
    stack which runs on Linux and Windows. You can only run Linux containers on Linux-based
    Docker hosts, and you can only run Windows containers on Windows-based Docker
    hosts, so Microsoft includes the operating system in the tag name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是微软的.NET Core基础图像，它位于Docker Hub的`microsoft/dotnet`存储库中。 .NET Core是一个在Linux和Windows上运行的跨平台应用程序堆栈。您只能在基于Linux的Docker主机上运行Linux容器，并且只能在基于Windows的Docker主机上运行Windows容器，因此Microsoft在标签名称中包含了操作系统。
- en: 'At the time of writing, Microsoft has dozens of versions of the .NET Core image
    available for use in the `microsoft/dotnet` repository, identified with different
    tags. These are just some of the tags:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Microsoft在`microsoft/dotnet`存储库中提供了数十个版本的.NET Core图像可供使用，并使用不同的标签进行标识。以下只是一些标签：
- en: '`2.2-runtime-bionic` a Linux image based on Ubuntu version 18.04 which has
    the .NET Core 2.2 runtime installed'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.2-runtime-bionic`是基于Ubuntu 18.04版本的Linux图像，其中安装了.NET Core 2.2运行时'
- en: '`2.2-runtime-nanoserver-1809` a Nano Server version 1809 image which has the
    .NET Core 2.2 runtime installed'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.2-runtime-nanoserver-1809`是一个Nano Server 1809版本的图像，其中安装了.NET Core 2.2运行时'
- en: '`2.2-sdk-bionic` a Linux image based on Debian which has the .NET Core 2.2
    runtime and SDK installed'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.2-sdk-bionic`是基于Debian的Linux图像，其中安装了.NET Core 2.2运行时和SDK'
- en: '`2.2-sdk-nanoserver-1809` a Nano Server image which has the .NET Core 2.2 runtime
    and SDK installed'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.2-sdk-nanoserver-1809`是一个Nano Server图像，其中安装了.NET Core 2.2运行时和SDK'
- en: The tags make it clear what each image contains, but they are all fundamentally
    similar – they are all variations of `microsoft/dotnet`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签清楚地表明了每个图像包含的内容，但它们在根本上都是相似的 - 它们都是`microsoft/dotnet`的变体。
- en: Docker also supports multi-arch images, where a single image tag is used as
    an umbrella for many variations. There could be image variations based on Linux
    and Windows OS, or Intel and **Advanced RISC Machines** (**ARM**) processors.
    They all use the same image name, and when you run `docker image pull`, Docker
    pulls the matching image for your host's operating system and CPU architecture.
    .NET Core images do this – `docker image pull microsoft/dotnet:2.2-sdk` will download
    the Linux image on Linux machines, and the Windows image on Windows machines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还支持多架构图像，其中单个图像标签用作许多变体的总称。可以基于Linux和Windows操作系统，或英特尔和**高级RISC机器**（**ARM**）处理器的图像变体。它们都使用相同的图像名称，当您运行`docker
    image pull`时，Docker会为您的主机操作系统和CPU架构拉取匹配的图像。 .NET Core图像可以做到这一点 - `docker image
    pull microsoft/dotnet:2.2-sdk`将在Linux机器上下载Linux图像，在Windows机器上下载Windows图像。
- en: If you publish a cross-platform app to Docker Hub and you want to make it as
    easy as possible for consumers to use it, you should publish it as a multi-arch
    image. In your own development, it's better to be explicit and specify the exact
    `FROM` image in your Dockerfiles, otherwise your app will build differently on
    different operating systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将跨平台应用程序发布到Docker Hub，并且希望尽可能地让消费者使用它，您应该将其发布为多架构图像。在您自己的开发中，最好是明确地在Dockerfiles中指定确切的`FROM`图像，否则您的应用程序将在不同的操作系统上构建不同。
- en: Building, tagging, and versioning images
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、标记和版本化图像
- en: 'You tag images when you first build them, but you can also explicitly add tags
    to an image with the `docker image tag` command. This is very useful in versioning
    mature applications, so users can choose which versioning level they want to work
    with. If you were to run the following commands, you would build an image with
    five tags, with ascending levels of precision for the application version:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次构建图像时，您会对图像进行标记，但您也可以使用`docker image tag`命令显式地向图像添加标签。这在对成熟应用程序进行版本控制时非常有用，因此用户可以选择要使用的版本级别。如果您运行以下命令，您将构建一个具有五个标签的图像，其中包含应用程序版本的不同精度级别：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The initial `docker image build` command doesn't specify a tag, so the new image
    will default to `myapp:latest`. Each subsequent `docker image tag` command adds
    a new tag to the same image. Tagging doesn't copy the image, so there's no data
    duplication – you just have one image which can be referred to with several tags.
    By adding all of these tags, you give consumers the choice of which image to use,
    or to base their own image on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的 `docker image build` 命令没有指定标记，因此新图像将默认为 `myapp:latest`。每个后续的 `docker image
    tag` 命令都会向同一图像添加一个新标记。标记不会复制图像，因此没有数据重复 - 您只有一个图像，可以用多个标记引用。通过添加所有这些标记，您为消费者提供了选择使用哪个图像，或者以其为基础构建自己的图像。
- en: This example application uses semantic versioning. The final tag could be the
    ID of the source code commit that triggered the build; this might be used internally
    but not made public. `5.1.6` is the patch version, `5.1` is the minor version
    number, and `5` is the major version number.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序使用语义化版本。最终标记可以是触发构建的源代码提交的 ID；这可能在内部使用，但不公开。`5.1.6` 是补丁版本，`5.1` 是次要版本号，`5`
    是主要版本号。
- en: Users can explicitly use `myapp:5.1.6`, which is the most specific version number,
    knowing that the tag won't change at that level and the image will always be the
    same. The next release will have the tag `5.1.7`, but that will be a different
    image with a different application version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以明确使用 `myapp:5.1.6`，这是最具体的版本号，知道该标记不会在该级别更改，图像将始终相同。下一个发布将具有标记 `5.1.7`，但那将是一个具有不同应用程序版本的不同图像。
- en: '`myapp:5.1` will change with each patch release – the next build, `5.1` will
    be a tagged alias of `5.1.7` – but users can be confident there won''t be any
    breaking changes. `myapp:5` will change with each minor release – next month,
    it could be an alias of `myapp:5.2`. Users can choose the major version if they
    always want the latest release for version 5, or they could use the latest if
    they always want the latest version, and can accept the possibility of breaking
    changes.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`myapp:5.1` 将随着每个补丁版本的发布而更改 - 下一个构建，`5.1` 将是 `5.1.7` 的标记别名 - 但用户可以放心，不会有任何破坏性的更改。`myapp:5`
    将随着每个次要版本的发布而更改 - 下个月，它可能是 `myapp:5.2` 的别名。用户可以选择主要版本，如果他们总是想要版本 5 的最新发布，或者他们可以使用最新版本，可以接受可能的破坏性更改。'
- en: 'As the producer of images, you can decide how to support versioning in your
    image tags. As the consumer, you should favor being more specific – especially
    with images you use as the `FROM` image for your own builds. If you''re packaging
    a .NET Core application, you will have problems if you start your Dockerfile like
    this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图像的生产者，您可以决定如何支持图像标记中的版本控制。作为消费者，您应该更加具体 - 尤其是对于您用作自己构建的 `FROM` 图像。如果您正在打包
    .NET Core 应用程序，如果您的 Dockerfile 像这样开始：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the time of writing, this image has version 2.2.103 of the .NET Core SDK
    installed. If your application targets version 2.2, then that's fine; the image
    will build and your application will run correctly in a container. But when .NET
    Core 2.3 or 3.0 is released, the generic `:sdk` tag will be applied to the new
    image, which may not support targeting 2.2 applications. When you use the exact
    same Dockerfile after that release, it will use a different base image – your
    image build could fail, or it could complete only for the application to fail
    at runtime if there are breaking changes in the .NET Core update.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此图像已安装了 .NET Core SDK 的 2.2.103 版本。如果您的应用程序针对 2.2 版本，那就没问题；图像将构建，您的应用程序将在容器中正确运行。但是，当
    .NET Core 2.3 或 3.0 发布时，新图像将应用通用的 `:sdk` 标记，这可能不支持针对 2.2 应用程序的目标。在该发布之后使用完全相同的
    Dockerfile 时，它将使用不同的基础图像 - 您的图像构建可能会失败，或者它可能仅在应用程序运行时失败，如果 .NET Core 更新中存在破坏性更改。
- en: 'Instead, you should consider using a tag for the minor version of the application
    framework you''re using, and explicitly stating the operating system and CPU architecture
    if it''s a multi-arch image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您应该考虑使用应用程序框架的次要版本的标签，并明确说明操作系统和CPU架构（如果是多架构图片）：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, you'll benefit from any patch releases to the image, but you'll always
    be using the 2.2 release of .NET Core, so your application will always have a
    matching host platform in the base image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您将受益于图像的任何补丁版本，但您将始终使用.NET Core的2.2版本，因此您的应用程序将始终在基础图像中具有匹配的主机平台。
- en: You can tag any image you have in your local cache – not just images you build
    yourself. This is useful if you want to re-tag a public image and add it to an
    approved set of base images in your local, private registry.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以标记您本地缓存中的任何图像，而不仅仅是您自己构建的图像。如果您想要重新标记一个公共图像并将其添加到本地私有注册表中的批准基础图像集中，这将非常有用。
- en: Pushing images to a registry
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像推送到注册表
- en: Building and tagging images are local operations. The end result of `docker
    image build` and `docker image tag` is a change to the image cache on the Docker
    Engine where you run the commands. Images need to be explicitly shared to a registry
    with the `docker image push` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和标记图像是本地操作。`docker image build`和`docker image tag`的最终结果是对您运行命令的Docker Engine上的图像缓存的更改。需要使用`docker
    image push`命令将图像明确共享到注册表中。
- en: 'Docker Hub is available for use without authenticating to pull public images,
    but to upload images (or pull private images), you need to register for an account.
    Registration is free at [https://hub.docker.com/](https://hub.docker.com/), which
    is where you can create a Docker ID that you can use on Docker Hub and other Docker
    services. Your Docker ID is how you authenticate with the Docker service to access
    Docker Hub. This is done through the `docker login` command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub可供使用，无需进行身份验证即可拉取公共图像，但是要上传图像（或拉取私有图像），您需要注册一个账户。您可以在[https://hub.docker.com/](https://hub.docker.com/)免费注册，这是您可以在Docker
    Hub和其他Docker服务上使用的Docker ID的地方。您的Docker ID是您用来验证访问Docker Hub的Docker服务的方式。这是通过`docker
    login`命令完成的：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To push images to Docker Hub, the repository name must contain your Docker ID
    as the account ID. You can tag an image locally using any account ID – like `microsoft/my-app` – but
    you can't push it to Microsoft's organization on the registry. The Docker ID you
    are logged in with needs to have permission to push to the account on the registry.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片推送到Docker Hub，仓库名称必须包含您的Docker ID作为账户ID。您可以使用任何账户ID在本地标记一个图片，比如`microsoft/my-app`，但是您不能将其推送到注册表上的Microsoft组织。您登录的Docker
    ID需要有权限将图片推送到注册表上的账户。
- en: 'When I publish images to go along with this book, I build them with `dockeronwindows`
    as the account name in the repository. That''s an organization on Docker Hub and
    my own user account, `sixeyed`, has access to push images to that organization.
    When I am logged in as `sixeyed`, I can push images to repositories belonging
    to `sixeyed` or `dockeronwindows`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发布图片以配合这本书时，我会使用`dockeronwindows`作为仓库中的账户名来构建它们。这是Docker Hub上的一个组织，而我的用户账户`sixeyed`有权限将图片推送到该组织。当我以`sixeyed`登录时，我可以将图片推送到属于`sixeyed`或`dockeronwindows`的仓库：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output from the Docker CLI shows how the image is split into layers, and
    it tells you the upload status for each layer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI的输出显示了图像如何分成层，并告诉您每个层的上传状态：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This image uses Windows Server Core as the base image. That image is not publicly
    redistributable – it's listed on Docker Hub, and free to download from the Microsoft
    Container Registry, but it is not licensed to be stored on other public image
    registries. That's why we can see the lines stating *Skipped foreign layer* – Docker
    will not push layers containing the Windows OS to Docker Hub.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像使用Windows Server Core作为基本图像。该图像不是公开可再分发的 - 它在Docker Hub上列出，并且可以从Microsoft容器注册表免费下载，但未经许可不得存储在其他公共图像注册表上。这就是为什么我们可以看到标有*跳过外部层*的行
    - Docker不会将包含Windows OS的层推送到Docker Hub。
- en: 'You can''t publish to another user''s account, but you can tag another user''s
    images with your own account name. This is a perfectly valid set of commands,
    which I could run if I wanted to download a specific version of the Windows Server
    Core image, give it a friendlier name, and make it available on the Hub under
    that new name in my account:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法发布到另一个用户的帐户，但可以使用您自己的帐户名称标记另一个用户的图像。这是一组完全有效的命令，如果我想要下载特定版本的Windows Server
    Core图像，给它一个更友好的名称，并在我的帐户下使用该新名称在Hub上提供它，我可以运行这些命令：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Microsoft have used different tagging schemes for their images at different
    times. Windows Server 2016 images use the full Windows version number, like `10.0.14393.2608`.
    Windows Server 2019 images use the release name followed by the KB identifier
    for the most recent Windows update included in the image, like `1809_KB4480116`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft在不同的时间使用了不同的标记方案来标记他们的图像。Windows Server 2016图像使用完整的Windows版本号，如`10.0.14393.2608`。Windows
    Server 2019图像使用发布名称，后跟图像中包含的最新Windows更新的KB标识符，如`1809_KB4480116`。
- en: Pushing images to a registry doesn't get any more complex than that for the
    user, although, under the hood, Docker runs some smart logic. Image layering applies
    to registries as well as to the local image cache on the Docker host. When you
    push an image based on Windows Server Core to the Hub, Docker doesn't upload the
    4 GB base image – it knows that the base layer already exists on MCR, and it will
    only upload the layers that are missing on the target registry.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，将图像推送到注册表并不比这更复杂，尽管在幕后，Docker运行一些智能逻辑。图像分层也适用于注册表，就像适用于Docker主机上的本地图像缓存一样。当您将基于Windows
    Server Core的图像推送到Hub时，Docker不会上传4GB的基本图像 - 它知道基本层已经存在于MCR上，并且只会上传目标注册表上缺少的层。
- en: The last example of tagging a public image and pushing it to the public Hub
    is valid but unlikely – you're much more likely to tag and push images to your
    own private registry.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将公共图像标记并推送到公共Hub的最后一个示例是有效的，但不太可能发生 - 您更有可能将图像标记并推送到您自己的私有注册表。
- en: Running a local image registry
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行本地图像注册表
- en: The Docker platform is portable because it's written in Go, which is a cross-platform
    language. Go applications can be compiled into native binaries, so Docker can
    run on Linux or Windows without users having to install Go. On Docker Hub there
    is an official  image which contains a registry server written in Go, so you can
    host your own image registry by running a Docker container from that image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台是可移植的，因为它是用Go语言编写的，这是一种跨平台语言。Go应用程序可以编译成本地二进制文件，因此Docker可以在Linux或Windows上运行，而无需用户安装Go。在Docker
    Hub上有一个包含用Go编写的注册表服务器的官方图像，因此您可以通过从该图像运行Docker容器来托管自己的图像注册表。
- en: '`registry` is an official repository which is maintained by the Docker team,
    but at the time of writing it only has images available for Linux. It''s likely
    that a Windows version of the registry will be published soon, but in this chapter
    I will walk you through building your own registry image, as it demonstrates some
    common Docker usage patterns.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`registry`是由Docker团队维护的官方存储库，但在撰写本文时，它只有适用于Linux的图像。很可能很快就会发布注册表的Windows版本，但在本章中，我将向您介绍如何构建自己的注册表图像，因为它展示了一些常见的Docker使用模式。'
- en: '*Official repositories* are available on Docker Hub like other public images,
    but they have been curated by Docker, Inc. and are maintained either by Docker
    themselves or by the application owners. You can rely on them containing correctly
    packaged and up-to-date software. The majority of official images have Linux variants,
    but the number of Windows-based official images is growing.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*官方存储库*就像其他公共镜像一样在Docker Hub上可用，但它们经过Docker, Inc.的策划，并由Docker自己或应用程序所有者维护。您可以依赖它们包含正确打包和最新软件。大多数官方镜像都有Linux变体，但Windows官方镜像的数量正在增加。'
- en: Building the registry image
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建注册表镜像
- en: 'Docker''s registry server is a fully functional image registry, but it''s just
    the API server – it doesn''t have a Web UI like Docker Hub. It''s an open source
    application hosted on GitHub in the `docker/distribution` repository. To build
    the application locally, you would need to install the Go SDK first. If you''ve
    done that, you can run a simple command to compile the application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的注册服务器是一个完全功能的镜像注册表，但它只是API服务器 - 它没有像Docker Hub那样的Web UI。它是一个开源应用程序，托管在GitHub的`docker/distribution`存储库中。要在本地构建该应用程序，您首先需要安装Go
    SDK。如果您已经这样做了，可以运行一个简单的命令来编译该应用程序：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But if you're not a regular Go developer, you don't want the overhead of installing
    and maintaining the Go tools on your local machine just so you can build the registry
    server when you want to update it. It would be better to package the Go tools
    into a Docker image and set up the image so that when you run a container, it
    builds the registry server for you. You can do this with the same multi-stage
    build approach I demonstrated in [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml),
    *Developing Dockerized .NET Framework and .NET Core Applications*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您不是经常使用Go开发人员，您不希望在本地机器上安装和维护Go工具的开销，只是为了在需要更新时构建注册服务器。最好将Go工具打包到一个Docker镜像中，并设置该镜像，以便在运行容器时为您构建注册服务器。您可以使用我在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中演示的相同的多阶段构建方法，*开发Docker化的.NET
    Framework和.NET Core应用程序*。
- en: The multi-stage pattern has a lot of advantages. First, it means that your application
    image can be kept as lightweight as possible – you don't need to package the build
    tools along with the runtime. Secondly, it means that your build agent is encapsulated
    in a Docker image so that you don't need to install those tools on your build
    server. Third, it means that developers can use exactly the same build process
    that the build server uses, so you avoid a situation where developer machines
    and the build server have different toolsets installed, with the risk of them
    drifting and causing build issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段模式有很多优势。首先，这意味着您的应用程序镜像可以尽可能地保持轻量级 - 您不需要将构建工具与运行时一起打包。其次，这意味着您的构建代理被封装在一个Docker镜像中，因此您不需要在构建服务器上安装这些工具。第三，这意味着开发人员可以使用与构建服务器相同的构建过程，因此您避免了开发人员机器和构建服务器安装了不同的工具集的情况，这可能导致构建问题。
- en: 'The Dockerfile for `dockeronwindows/ch04-registry:2e` uses the official Go
    image, which has a Windows Server Core variant on Docker Hub. The builder stage
    uses that image to compile the registry application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockeronwindows/ch04-registry:2e`的Dockerfile使用官方的Go镜像，在Docker Hub上有一个Windows
    Server Core变体。构建阶段使用该镜像来编译注册表应用程序：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I'm using an `ARG` instruction to specify the version of the source code to
    build – the GitHub repository has tags for each released version, and I'm defaulting
    to version 2.6.2\. Then I use `git` to clone the source code and switch to the
    labelled version of the code, and use `go build` to compile the application. The
    Git client and the Go tools are all in the base `golang` image. The output will
    be `registry.exe`, a native Windows executable which doesn't need Go installed
    to run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`ARG`指令来指定要构建的源代码版本——GitHub存储库为每个发布的版本都有标签，我默认使用版本2.6.2。然后我使用`git`来克隆源代码并切换到标记版本的代码，并使用`go
    build`来编译应用程序。Git客户端和Go工具都在基本的`golang`映像中。输出将是`registry.exe`，这是一个本地的Windows可执行文件，不需要安装Go就可以运行。
- en: 'The final stage of the Dockerfile uses Nano Server as the base, which can run
    the Go application just fine. Here''s the whole application stage:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的最后阶段使用Nano Server作为基础，可以很好地运行Go应用程序。以下是整个应用程序阶段：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s nothing complicated in this stage. It begins by setting up the image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段没有什么复杂的。它从设置图像开始：
- en: '`REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY` is an environment variable that
    the registry uses as the base path to store data.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY`是注册表使用的环境变量，作为存储数据的基本路径。'
- en: A `VOLUME` is created for the registry data by using the path that was captured
    in the environment variable.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用环境变量中捕获的路径创建了一个`VOLUME`，用于注册表数据。
- en: Port `5000` is exposed, which is the conventional port to use for Docker registries.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露端口`5000`，这是Docker注册表的常规端口。
- en: The remainder of the Dockerfile sets up the entrypoint for containers and copies
    the compiled binary and the default configuration file from the builder stage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的其余部分设置了容器的入口点，并从构建阶段复制了编译的二进制文件和默认配置文件。
- en: 'Docker containers in Windows Server 2016 had a different implementation of
    volumes – the target directory inside the container was actually a symbolic link
    rather than a normal directory. That caused issues with Go, Java, and other languages.
    There was a workaround that was made possible by using mapped drives, but that''s
    no longer needed. If you see any Dockerfiles that use a G: drive, they''re based
    on Windows Server 2016 and can be simplified for Windows Server 2019 just by using
    the C: drive.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Server 2016中的Docker容器有一个不同的卷实现——容器内的目标目录实际上是一个符号链接，而不是一个普通目录。这导致了Go、Java和其他语言的问题。通过使用映射驱动器，可以实现一种解决方法，但现在不再需要。如果您看到任何使用G:驱动器的Dockerfile，它们是基于Windows
    Server 2016的，可以通过使用C:驱动器简化为Windows Server 2019。
- en: Building the registry image is the same as any other image, but when you use
    it to run your own registry, there are some important factors to consider.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 构建注册表映像与构建任何其他映像相同，但当您使用它来运行自己的注册表时，有一些重要因素需要考虑。
- en: Running a registry container
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行注册表容器
- en: 'Running your own registry lets you share images between team members and store
    the output of all your application builds using the fast local network instead
    of an internet connection. You would typically run the registry container on a
    server that can be widely accessed in a configuration like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行自己的注册表可以让您在团队成员之间共享图像，并使用快速本地网络而不是互联网连接存储所有应用程序构建的输出。您通常会在可以广泛访问的服务器上运行注册表容器，配置如下：
- en: '![](Images/7c1703fa-380c-4361-949b-90883f08e110.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7c1703fa-380c-4361-949b-90883f08e110.png)'
- en: The registry is running in a container (1) on a server (2). The client machines
    (3) are connected to the server so that they can use the registry on the local
    network to push and pull private images.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表在服务器上的容器（1）上运行。客户端机器（3）连接到服务器，以便它们可以使用本地网络上的注册表来推送和拉取私有图像。
- en: To make the registry container accessible, you need to publish port `5000` from
    the container to port `5000` on the host. Registry users can access the container
    using the host server's IP address or hostname, and that will be the registry
    domain you use in image names. You'll also want to mount a volume from the host
    to store the image data in a known location. When you replace the container with
    a new version, it will still be available using the host's domain name, and it
    will still have all the image layers stored by the previous container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使注册表容器可访问，您需要将容器的端口`5000`发布到主机上的端口`5000`。注册表用户可以使用主机服务器的IP地址或主机名访问容器，这将是您在镜像名称中使用的注册表域。您还需要挂载一个卷从主机存储图像数据在一个已知的位置。当您用新版本替换容器时，它仍然可以使用主机的域名，并且仍然具有之前容器存储的所有图像层。
- en: 'On my host server I have a RAID array configured as disk `E:`, which I use
    for my registry data so that I can run my registry container mounting that volume
    for the data path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的主机服务器上，我配置了一个作为磁盘`E:`的RAID阵列，我用它来存储我的注册表数据，以便我可以运行我的注册表容器挂载该卷作为数据路径：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In my network I'll be running the container on a physical machine with the IP
    address `192.168.2.146`. I could use `192.168.2.146:5000` as the registry domain
    to tag images, but that isn't very flexible. It's better to use the domain name
    of the host so that I can point that to a different physical server if I need
    to without having to re-tag all my images.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的网络中，我将在具有IP地址`192.168.2.146`的物理机器上运行容器。我可以使用`192.168.2.146:5000`作为注册表域来标记图像，但这并不是很灵活。最好使用主机的域名，这样我可以在需要时将其指向不同的物理服务器，而无需重新标记所有图像。
- en: 'For the hostname you can use your network''s **Domain Name System** (**DNS**)
    service, or a **Canonical Name** (**CNAME**) if you''re running a public server.
    Alternatively you could add an entry to the hosts file on the client machines
    and use a custom domain name. This is the PowerShell command I use to add the
    hostname entry for `registry.local`, pointing to my Docker server:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主机名，您可以使用您网络的**域名系统**（**DNS**）服务，或者如果您运行公共服务器，可以使用**规范名称**（**CNAME**）。或者，您可以在客户机上的hosts文件中添加一个条目，并使用自定义域名。这是我用来为`registry.local`添加指向我的Docker服务器的主机名条目的PowerShell命令：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now my server is running a registry server in a container with reliable storage,
    and my client is set up to access the registry host using a friendly domain name.
    I can start pushing and pulling private images from my own registry, which is
    only available to users on my network.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的服务器正在运行一个具有可靠存储的容器中的注册表服务器，并且我的客户端已设置好以使用友好的域名访问注册表主机。我可以开始从自己的注册表推送和拉取私有镜像，这仅对我的网络上的用户可用。
- en: Pushing and pulling images with a local registry
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地注册表推送和拉取镜像
- en: 'You can only push images to a registry if the image tag matches the registry
    domain. The process for tagging and pushing is the same as with Docker Hub, but
    you need to explicitly include the local registry domain in the new tag. These
    commands pull my registry server image from Docker Hub and add a new tag, making
    it suitable to be pushed to the local registry:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当镜像标签与注册表域匹配时，才能将镜像推送到注册表。标记和推送的过程与Docker Hub相同，但您需要明确包含本地注册表域在新标记中。这些命令从Docker
    Hub拉取我的注册表服务器镜像，并添加一个新标记，使其适合推送到本地注册表：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `docker image tag` command specifies the source tag first, and then the
    target tag. You can change every part of the image name for the new target tag.
    I''ve used the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image tag`命令首先指定源标记，然后指定目标标记。您可以更改新目标标记的镜像名称的每个部分。我使用了以下内容：'
- en: '`registry.local:5000` is the registry domain. The original image name had an
    implied domain of `docker.io`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry.local:5000`是注册表域。原始镜像名称隐含的域为`docker.io`。'
- en: '`infrastructure` is the account name. The original account name was `dockeronwindows`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`infrastructure`是帐户名称。原始帐户名称是`dockeronwindows`。'
- en: '`registry` is the repository name. The original was `ch04-registry`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry`是存储库名称。原始名称是`ch04-registry`。'
- en: '`v2.6.2` is the image tag. The original tag was `2e`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2.6.2`是图像标记。原始标记是`2e`。'
- en: If you're wondering why all of the images for this book have the `2e` tag, it's
    because I've used that to identify them as working with the second edition of
    this book. I didn't use tags for images in the first edition, so they all have
    the implied tag of `latest`. They still exist on Docker Hub, but by tagging the
    new versions as `2e`, I can publish images to the same repositories without breaking
    the code samples for readers of the first edition.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么本书的所有图像都有`2e`标记，那是因为我用它来标识它们与本书的第二版一起使用。我没有在第一版中为图像使用标记，因此它们都具有隐含的`latest`标记。它们仍然存在于Docker
    Hub上，但通过将新版本标记为`2e`，我可以将图像发布到相同的存储库，而不会破坏第一版读者的代码示例。
- en: 'I can try to push the new tagged image to the local registry, but Docker won''t
    let me use the registry yet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以尝试将新标记的映像推送到本地注册表，但Docker还不允许我使用注册表：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Docker platform is secure by default, and the same principle extends to
    image registries. The Docker Engine expects to use HTTPS to communicate with registries
    so that the traffic is encrypted. My simple registry installation uses plaintext
    HTTP, so I get an error saying Docker tried to use an encrypted transport for
    the registry but only an unencrypted transport was available.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台默认是安全的，相同的原则也适用于映像注册表。Docker引擎期望使用HTTPS与注册表通信，以便流量被加密。我的简单注册表安装使用明文HTTP，因此我收到了一个错误，说Docker尝试使用加密传输进行注册表，但只有未加密传输可用。
- en: There are two options for setting up Docker to use the local registry. The first
    is to extend the registry server to secure the communication – the registry server
    image can run over HTTPS if you supply it with an SSL certificate. That's what
    I would do in a production environment, but to start out I can use the other option
    and make an exception in the Docker configuration. The Docker Engine will allow
    a HTTP registry to be used if it's explicitly named in an allowed list of insecure
    registries.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Docker使用本地注册表有两个选项。第一个是扩展注册表服务器以保护通信-如果您提供SSL证书，注册表服务器映像可以在HTTPS上运行。这是我在生产环境中会做的事情，但是为了开始，我可以使用另一个选项并在Docker配置中做一个例外。如果在允许的不安全注册表列表中明确命名，Docker引擎将允许使用HTTP注册表。
- en: You can run the registry image with HTTPS using your company's SSL certificate
    or a self-signed certificate, which means that you don't need to configure the
    Docker Engine to allow insecure registries. There is a Windows registry walkthrough
    in Docker's lab repository on GitHub, `docker/labs`, which explains how to do
    that.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用公司的SSL证书或自签名证书在HTTPS下运行注册表映像，这意味着您无需配置Docker引擎以允许不安全的注册表。GitHub上的Docker实验室存储库`docker/labs`中有一个Windows注册表演练，解释了如何做到这一点。
- en: Configuring Docker to allow insecure registries
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker以允许不安全的注册表
- en: The Docker Engine can use a JSON configuration file to change settings, including
    the list of insecure registries that the engine will allow. Any registry domains
    in that list can use HTTP rather than HTTPS, so this is not something you should
    do for a registry that's hosted on a public network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎可以使用JSON配置文件来更改设置，包括引擎允许的不安全注册表列表。该列表中的任何注册表域都可以使用HTTP而不是HTTPS，因此这不是您应该为托管在公共网络上的注册表执行的操作。
- en: 'Docker''s configuration file is located at `%programdata%\docker\config\daemon.json`
    (**daemon** is Linux terminology for a background service, so this is the name
    of the Docker Engine configuration file). You can manually edit it to add the
    local registry as a secure option and then restart the Docker Windows service.
    This configuration allows Docker to use the local registry with HTTP:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的配置文件位于`％programdata％\docker\config\daemon.json`（**daemon**是Linux术语，表示后台服务，因此这是Docker引擎配置文件的名称）。您可以手动编辑它，将本地注册表添加为安全选项，然后重新启动Docker
    Windows服务。此配置允许Docker使用HTTP访问本地注册表：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you''re using Docker Desktop on Windows 10, the UI has a nice configuration
    window that takes care of this for you. Instead of editing the file manually,
    just right-click on the Docker logo in the status bar, select Settings*,* navigate
    to the Daemon page, and add an entry to the Insecure registries list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows 10上使用Docker Desktop，则UI具有一个很好的配置窗口，可以为您处理这些问题。只需右键单击状态栏中的Docker标志，选择“设置”，导航到“守护程序”页面，并将条目添加到不安全的注册表列表中：
- en: '![](Images/500523ff-3838-4543-8104-c4342100969a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/500523ff-3838-4543-8104-c4342100969a.png)'
- en: 'With the local registry domain added to my insecure list, I can use it to push
    and pull images:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地注册表域添加到我的不安全列表后，我可以使用它来推送和拉取镜像：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Any users with network access to my Docker server can use images stored in
    the local registry with the `docker image pull` or `docker container run` commands.
    You can also use local images as the base images in other Dockerfiles by specifying
    the name with the registry domain, the repository name, and the tag in the `FROM`
    instruction:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有对我的Docker服务器的网络访问权限的用户都可以使用存储在本地注册表中的镜像，使用`docker image pull`或`docker container
    run`命令。您还可以通过在`FROM`指令中指定名称与注册表域、存储库名称和标签，将本地镜像用作其他Dockerfile中的基本镜像：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is no way to override the default registry, so you can't set your local
    registry as the default when a domain isn't specified – the default is always
    Docker Hub. If you want to use a different registry for images, the registry domain
    always has to be specified in the image name. Any image names you use without
    a registry address will be assumed to refer to images from `docker.io`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法覆盖默认注册表，因此当未指定域时，无法将本地注册表设置为默认值 - 默认值始终为Docker Hub。如果要为镜像使用不同的注册表，注册表域必须始终在镜像名称中指定。任何不带注册表地址的镜像名称都将被假定为指向`docker.io`的镜像。
- en: Storing Windows image layers in a local registry
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Windows镜像层存储在本地注册表中
- en: You are not allowed to publicly redistribute the base layers for Microsoft images,
    but you are allowed to store them in a private registry. This is particularly
    useful for the Windows Server Core image. The compressed size of that image is
    2 GB, and Microsoft release a new version of the image every month, listed on
    Docker Hub, with the latest security patches.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许公开重新分发Microsoft镜像的基本层，但允许将它们存储在私有注册表中。这对于Windows Server Core镜像特别有用。该镜像的压缩大小为2GB，Microsoft每个月在Docker
    Hub上发布一个新版本的镜像，带有最新的安全补丁。
- en: The updates usually only add one new layer to the image, but that layer could
    be a 300 MB download. If you have many users working with Windows images, they
    will all need to download those layers, and that's a lot of bandwidth and a lot
    of time. If you run a local registry server, you can pull those layers once from
    Docker Hub, and push them to your local registry. Every other user then pulls
    from the local registry, downloading them from the fast local network rather than
    from the internet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更新通常只会向镜像添加一个新层，但该层可能是300MB的下载。如果有许多用户使用Windows镜像，他们都需要下载这些层，这需要大量的带宽和时间。如果运行本地注册表服务器，可以从Docker
    Hub一次拉取这些层，并将它们推送到本地注册表。然后，其他用户从本地注册表中拉取，从快速本地网络而不是从互联网上下载。
- en: 'You need to enable this feature for specific registries in the Docker configuration
    file by using the `allow-nondistributable-artifacts` field:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Docker配置文件中为特定注册表启用此功能，使用`allow-nondistributable-artifacts`字段：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This setting isn''t exposed directly in the Docker for Windows UI, but you
    can set it in the Advanced mode of the Settings screen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置在Docker for Windows UI中没有直接暴露，但你可以在设置屏幕的高级模式中设置它：
- en: '![](Images/7fe10262-09e8-4ea1-90b6-01d668a719bf.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7fe10262-09e8-4ea1-90b6-01d668a719bf.png)'
- en: 'Now, I can push the Windows *foreign layers* to my local registry. I can tag
    the latest Nano Server image with my own registry domain and push the image there:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以将Windows *foreign layers*推送到我的本地注册表。我可以使用自己的注册表域标记最新的Nano Server图像，并将图像推送到那里：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you store the Windows base image layers in your own registry, the layer
    IDs will be different from the original layer IDs on MCR. That has an impact on
    Docker's image cache. You can pull your own Nano Server image on a clean machine
    using the full tag `registry.local:5000/microsoft/nanoserver:1809`. Then if you
    pull the official Microsoft image, the layers will be downloaded again. They have
    the same content but different IDs, so Docker doesn't recognize them as a cache
    hit.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Windows基础镜像层存储在自己的注册表中时，层ID将与MCR上的原始层ID不同。这对Docker的图像缓存产生影响。您可以使用完整标签`registry.local:5000/microsoft/nanoserver:1809`在干净的机器上拉取自己的Nano
    Server图像。然后，如果您拉取官方的Microsoft图像，层将再次被下载。它们具有相同的内容但不同的ID，因此Docker不会将它们识别为缓存命中。
- en: If you're going to store your own versions of base images for Windows, make
    sure you're consistent and only use those images in your Dockerfiles. That also
    applies to images that build from the Windows image – so if you want to use .NET,
    you'll need to build your own SDK image using your Windows image as the base.
    There's an overhead to this, but lots of large organizations prefer the approach
    because it gives them fine control over their base images.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要存储Windows的基础图像的自己的版本，请确保您是一致的，并且只在您的Dockerfile中使用这些图像。这也适用于从Windows图像构建的图像-因此，如果您想要使用.NET，您需要使用您的Windows图像作为基础构建自己的SDK图像。这会增加一些额外的开销，但许多大型组织更喜欢这种方法，因为它可以让他们对基础图像有更好的控制。
- en: Using a commercial registry
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用商业注册表
- en: Running your own registry is not the only way to have a secure, private store
    for image repositories – there are several third-party offerings you can use.
    In practice, they all work in the same way – you need to tag your images with
    the registry domain and authenticate with the registry server. There are several
    options available, and the most comprehensive ones come from Docker, Inc., which
    has different products available for different levels of service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行自己的注册表不是拥有安全的私有图像存储库的唯一方法-您可以使用几种第三方提供的选择。在实践中，它们都以相同的方式工作-您需要使用注册表域标记您的图像，并与注册表服务器进行身份验证。有几种可用的选项，最全面的选项来自Docker，Inc.，他们为不同的服务级别提供了不同的产品。
- en: Docker Hub
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub
- en: Docker Hub is the most widely used public container registry, averaging over
    one billion image pulls per month at the time of writing. You can host unlimited
    public repositories on the Hub and pay a subscription to host multiple private
    repositories.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是最广泛使用的公共容器注册表，在撰写本文时，平均每月超过10亿次图像拉取。您可以在Hub上托管无限数量的公共存储库，并支付订阅费以托管多个私有存储库。
- en: Docker Hub has an automated build system, so you can link image repositories
    to source code repositories in GitHub or Bitbucket, and Docker's servers will
    build an image from the Dockerfile in the repository whenever you push changes
    – it's a simple and effective hosted **Continuous Integration** (**CI**) solution,
    especially if you are using portable, multi-stage Dockerfiles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub具有自动构建系统，因此您可以将镜像存储库链接到GitHub或Bitbucket中的源代码存储库，Docker的服务器将根据存储库中的Dockerfile构建镜像，每当您推送更改时
    - 这是一个简单而有效的托管**持续集成**（**CI**）解决方案，特别是如果您使用可移植的多阶段Dockerfile。
- en: A Hub subscription is suitable for smaller projects or teams with multiple users
    working on the same applications. It has an authorization framework where users
    can create an organization, which becomes the account name in the repository rather
    than an individual user's account name. Many users can be given access to the
    organization's repositories, which allows multiple users to push images.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Hub订阅适用于较小的项目或多个用户共同开发同一应用程序的团队。它具有授权框架，用户可以创建一个组织，该组织成为存储库中的帐户名，而不是个人用户的帐户名。可以授予多个用户对组织存储库的访问权限，这允许多个用户推送镜像。
- en: Docker Hub is also a registry for commercial software distribution. It's like
    an app store for server-side applications. If your company produces commercial
    software, Docker Hub could be a good choice for distributing it. You build and
    push images in exactly the same way, but your source can be kept private – only
    the packaged application is publicly available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub也是用于商业软件分发的注册表。它就像是面向服务器端应用程序的应用商店。如果您的公司生产商业软件，Docker Hub可能是分发的一个不错选择。您可以以完全相同的方式构建和推送镜像，但您的源代码可以保持私有
    - 只有打包的应用程序是公开可用的。
- en: 'You can register with Docker as a Verified Publisher to identify that there''s
    a commercial entity maintaining the images. Docker Hub lets you filter on Verified
    Publishers, so this is a good way to get visibility for your apps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Docker上注册为已验证的发布者，以确定有一个商业实体在维护这些镜像。Docker Hub允许您筛选已验证的发布者，因此这是一个让您的应用程序获得可见性的好方法：
- en: '![](Images/d6a7c495-7147-4b6d-86cd-3c79835f0983.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d6a7c495-7147-4b6d-86cd-3c79835f0983.png)'
- en: There is also a certification process you can go through for images which are
    hosted on Docker Hub. Docker certification applies across software images and
    hardware stacks. If your image is certified, it's guaranteed to work on **Docker
    Enterprise** on any certified hardware. Docker tests all of these combinations
    in the certification process, and that end-to-end guarantee is very attractive
    to large enterprises.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub还有一个认证流程，适用于托管在Docker Hub上的镜像。Docker认证适用于软件镜像和硬件堆栈。如果您的镜像经过认证，它将保证在任何经过认证的硬件上都可以在Docker
    Enterprise上运行。Docker在认证过程中测试所有这些组合，这种端到端的保证对大型企业非常有吸引力。
- en: Docker Trusted Registry
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Trusted Registry
- en: '**Docker Trusted Registry** (**DTR**) is part of the Docker Enterprise suite,
    the enterprise-grade **Containers-as-a-Service** (**CaaS**) platform from Docker,
    Inc.. It''s aimed at enterprises running a cluster of Docker hosts in their own
    data centers or in any cloud. Docker Enterprise comes with a comprehensive management
    suite called **Universal Control Plane** (**UCP**), which provides an interface
    to administer all the resources in your Docker cluster – the host servers, images,
    containers, networks, volumes, and everything else. Docker Enterprise also provides
    DTR, which is a secure, scalable image registry.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Trusted Registry**（**DTR**）是Docker Enterprise套件的一部分，这是Docker公司提供的企业级**容器即服务**（**CaaS**）平台。它旨在为在其自己的数据中心或任何云中运行Docker主机集群的企业提供服务。Docker
    Enterprise配备了一个名为**Universal Control Plane**（**UCP**）的全面管理套件，该套件提供了一个界面，用于管理Docker集群中的所有资源
    - 主机服务器、镜像、容器、网络、卷以及其他所有内容。Docker Enterprise还提供了DTR，这是一个安全、可扩展的镜像注册表。'
- en: DTR runs over HTTPS and is a clustered service, so you can deploy multiple registry
    servers across your cluster for scalability and failover. You can use local storage
    or cloud storage for DTR, so if you run in Azure the images can be persisted in
    Azure storage with practically unlimited capacity. Like Docker Hub you can create
    organizations for shared repositories, but with DTR, you manage authentication
    by creating your own user accounts or by plugging into a **Lightweight Directory
    Access Protocol** (**LDAP**) service (like Active Directory). Then you can configure
    role-based access control for fine-grained permissions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: DTR通过HTTPS运行，并且是一个集群化服务，因此您可以在集群中部署多个注册表服务器以实现可伸缩性和故障转移。您可以使用本地存储或云存储来存储DTR，因此如果在Azure中运行，则可以将图像持久保存在具有实际无限容量的Azure存储中。与Docker
    Hub一样，您可以为共享存储库创建组织，但是使用DTR，您可以通过创建自己的用户帐户或插入到**轻量级目录访问协议**（**LDAP**）服务（如Active
    Directory）来管理身份验证。然后，您可以为细粒度权限配置基于角色的访问控制。
- en: 'Security scanning is also available in DTR, a feature that scans the binaries
    inside your images to check for known vulnerabilities. You can configure scans
    to run whenever an image is pushed, or build a schedule. Scheduled scans can alert
    you when a new vulnerability is found in one of the dependencies for an old image.
    The DTR UI lets you drill down into the details of the vulnerability and see the
    exact file and the exact exploit:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: DTR还提供安全扫描功能，该功能扫描图像内部的二进制文件，以检查已知的漏洞。您可以配置扫描以在推送图像时运行，或构建一个计划。计划扫描可以在发现旧图像的依赖项中发现新漏洞时向您发出警报。DTR
    UI允许您深入了解漏洞的详细信息，并查看确切的文件和确切的利用方式。
- en: '![](Images/57b74dfa-9361-4b46-ac45-baa91cefca64.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/57b74dfa-9361-4b46-ac45-baa91cefca64.png)'
- en: There is one other major security feature that is only available in Docker Enterprise,
    **content trust**. Docker content trust lets users digitally sign images to capture
    an approval workflow – so QA and security teams can run an image version through
    their test suites and sign it to confirm that they approve a release candidate
    for production. Those signatures are stored in DTR. UCP can be configured to only
    run images which have been signed by certain teams, so you get close control over
    what software your cluster will run, together with an audit trail proving who
    built and approved the software.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise还有一个主要的安全功能，**内容信任**，这仅在Docker Enterprise中可用。Docker内容信任允许用户对图像进行数字签名，以捕获批准工作流程
    - 因此QA和安全团队可以通过他们的测试套件运行图像版本并对其进行签名，以确认他们批准了用于生产的发布候选版本。这些签名存储在DTR中。UCP可以配置为仅运行由某些团队签名的图像，因此您可以对集群将运行的软件进行严格控制，并提供证明谁构建和批准软件的审计跟踪。
- en: Docker Enterprise has a rich suite of features which can be accessed through
    friendly web UIs, as well as through the usual Docker command line. Security,
    reliability, and scalability are major factors in the feature set, which makes
    it a good choice for enterprise users looking for a standard way to manage images,
    containers, and Docker hosts. I will cover UCP in [Chapter 8](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml),
    *Administering and Monitoring Dockerized Solutions*, and DTR in [Chapter 9](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml),
    *Understanding the Security Risks and Benefits of Docker*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise具有丰富的功能套件，可以通过友好的Web UI以及通常的Docker命令行访问。安全性，可靠性和可扩展性是功能集中的主要因素，这使其成为企业用户寻找管理图像，容器和Docker主机的标准方式的不错选择。我将在[第8章](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml)中介绍UCP，*管理和监控Docker化解决方案*，以及在[第9章](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml)中介绍DTR，*了解Docker的安全风险和好处*。
- en: If you want to try out Docker Enterprise in a sandbox environment with no setup
    requirements, browse to [http://trial.docker.com](http://trial.docker.com) for
    a hosted trial that you can use for 12 hours.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在无需设置要求的沙箱环境中尝试Docker Enterprise，请浏览[http://trial.docker.com](http://trial.docker.com)以获取一个可用于12小时的托管试用版。
- en: Other registries
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他注册表
- en: Docker is now so popular that many third-party services have added an image
    registry to their existing offerings. On the cloud, you have the **EC2 Container
    Registry** (**ECR**) from **Amazon Web Services** (**AWS**), Azure Container Registry
    from Microsoft, and Container Registry on Google Cloud Platform. All of these
    offerings integrate with the standard Docker command line and with the other products
    in each respective platform, so they can be good options if you are heavily invested
    in one cloud service provider.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Docker现在非常受欢迎，许多第三方服务已经将图像注册表添加到其现有的服务中。在云端，您可以使用来自亚马逊网络服务（AWS）的EC2容器注册表（ECR），微软的Azure容器注册表，以及谷歌云平台上的容器注册表。所有这些服务都与标准的Docker命令行和各自平台的其他产品集成，因此如果您在某个云服务提供商中有大量投资，它们可能是很好的选择。
- en: There are also standalone registry offerings, including Artifactory from JFrog,
    and Quay.io, which are hosted services. Having a hosted registry removes the management
    overhead of running your own registry server, and if you are already using services
    from a provider who also offers a registry, it makes sense to evaluate that option.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些独立的注册表服务，包括JFrog的Artifactory和Quay.io，这些都是托管服务。使用托管注册表可以减少运行自己的注册表服务器的管理开销，如果您已经在使用来自提供商的服务，并且该提供商还提供注册表，则评估该选项是有意义的。
- en: All of the registry providers have different feature sets and service levels
    – you should compare their offerings and, most importantly, check the level of
    Windows support. Most of the existing platforms were originally built to support
    Linux images and Linux clients, and there may not be feature parity for Windows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的注册表提供商都有不同的功能集和服务水平 - 您应该比较它们的服务，并且最重要的是，检查Windows支持的水平。大多数现有的平台最初是为了支持Linux图像和Linux客户端而构建的，对于Windows可能没有功能平衡。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you've learned what an image registry does and how to work with
    it using Docker. I covered repository names and image tagging to identify application
    versions or platform variations, and how to run and use a local registry server
    – by running one in a container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了图像注册表的功能以及如何使用Docker与之配合工作。我介绍了仓库名称和图像标记，以识别应用程序版本或平台变化，以及如何运行和使用本地注册表服务器
    - 通过在容器中运行一个。
- en: Using a private registry is something you're likely to do quite early in your
    Docker journey. As you start to Dockerize existing applications and experiment
    with new software stacks, it may be useful to push and pull images across the
    fast local network – or use the cloud if local storage space is an issue. As you
    use Docker more and progress to production implementation, you may have a roadmap
    to upgrade to DTR for a supported registry with rich security features.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker的旅程中，您很可能会很早就开始使用私有注册表。当您开始将现有应用程序Docker化并尝试新的软件堆栈时，通过快速的本地网络推送和拉取图像可能会很有用
    - 或者如果本地存储空间有问题，可以使用云服务。随着您对Docker的使用越来越多，并逐步实施生产，您可能会计划升级到具有丰富安全功能的受支持的注册表DTR。
- en: Now that you have a good understanding of how to share images and use images
    which have been shared by other people, you can look at bringing tried and trusted
    software components into our own applications with a container-first solution
    design.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经很好地了解了如何共享图像并使用其他人共享的图像，您可以考虑使用容器优先的解决方案设计，将经过验证和可信赖的软件组件引入我们自己的应用程序中。
