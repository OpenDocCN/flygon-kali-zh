["```cs\n    Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Scope CurrentUser \n    ```", "```cs\nprotected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()\nprotected override async Task RunAsync(CancellationToken cancellationToken) \n```", "```cs\nprotected override IEnumerable< ServiceInstanceListener > CreateServiceInstanceListeners()\nprotected override async Task RunAsync(CancellationToken cancellationToken) \n```", "```cs\n<ClusterConnectionParameters \n    ConnectionEndpoint=\"<cluster name>.<location \n    code>.cloudapp.azure.com:19000\"\n    X509Credential=\"true\"\n    ServerCertThumbprint=\"<server certificate thumbprint>\"\n    FindType=\"FindByThumbprint\"\n    FindValue=\"<client certificate thumbprint>\"\n    StoreLocation=\"CurrentUser\"\n    StoreName=\"My\" /> \n```", "```cs\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<Settings xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n          xmlns=\"http://schemas.microsoft.com/2011/01/fabric\">\n<!-- This is used by the StateManager's replicator. -->\n<Section Name=\"ReplicatorConfig\">\n<Parameter Name=\"ReplicatorEndpoint\" Value=\"ReplicatorEndpoint\" />\n</Section>\n<!-- This is used for securing StateManager's replication traffic. -->\n<Section Name=\"ReplicatorSecurityConfig\" />\n<!-- Below the new Section to add -->\n<Section Name=\"Timing\">\n<Parameter Name=\"MessageMaxDelaySeconds\" Value=\"\" />\n</Section>\n</Settings> \n```", "```cs\n<Endpoint Name=\"<endpoint name>\" PathSuffix=\"<the path of the endpoint URI>\" Protocol=\"<a protcol like Tcp, http, https, etc.>\" Port=\"the exposed port\" Type=\"<Internal or Input>\"/> \n```", "```cs\n    <Parameter Name=\"<parameter name>\" DefaultValue=\"<parameter definition>\" /> \n    ```", "```cs\n    <UniformInt64Partition PartitionCount=\"[LogStore_PartitionCount]\" LowKey=\"0\" HighKey=\"1000\" /> \n    ```", "```cs\n<Parameter Name=\"LogStore_MinReplicaSetSize\" DefaultValue=\"1\" />\n<Parameter Name=\"LogStore_PartitionCount\" DefaultValue=\"2\" />\n<Parameter Name=\"LogStore_TargetReplicaSetSize\" DefaultValue=\"1\" /> \n```", "```cs\n<Service Name=\"LogStore\" ServicePackageActivationMode=\"ExclusiveProcess\">\n<StatefulService ServiceTypeName=\"LogStoreType\" \n    TargetReplicaSetSize=\n    \"[LogStore_TargetReplicaSetSize]\" \n    MinReplicaSetSize=\"[LogStore_MinReplicaSetSize]\">\n<UniformInt64Partition PartitionCount=\"\n        [LogStore_PartitionCount]\" \n        LowKey=\"0\" HighKey=\"1000\" />\n</StatefulService>\n</Service> \n```", "```cs\n    <ClusterConnectionParameters \n        ConnectionEndpoint=\"<cluster name>.<location \n        code>.cloudapp.azure.com:19000\"\n        X509Credential=\"true\"\n        ServerCertThumbprint=\"<server certificate thumbprint>\"\n        FindType=\"FindByThumbprint\"\n        FindValue=\"<client certificate thumbprint>\"\n        StoreLocation=\"CurrentUser\"\n        StoreName=\"My\" /> \n    ```", "```cs\nusing System;\nusing System.Runtime.Serialization;\nnamespace IdempotencyTools\n{\n    [DataContract]\n    public class IdempotentMessage<T>\n    {\n        [DataMember]\n        public T Value { get; protected set; }\n        [DataMember]\n        public DateTimeOffset Time { get; protected set; }\n        [DataMember]\n        public Guid Id { get; protected set; }\n        public IdempotentMessage(T originalMessage)\n        {\n            Value = originalMessage;\n            Time = DateTimeOffset.Now;\n            Id = Guid.NewGuid();\n        }\n    }\n} \n```", "```cs\npublic class IdempotencyFilter\n{\n    protected IReliableDictionary<Guid, DateTimeOffset> dictionary;\n    protected int maxDelaySeconds;\n    protected DateTimeOffset lastClear;\n    protected IReliableStateManager sm;\n    protected IdempotencyFilter() { }\n    public static async Task<IdempotencyFilter> NewIdempotencyFilter(\n        string name, \n        int maxDelaySeconds, \n        IReliableStateManager sm)\n    {\n        return new IdempotencyFilter()\n            {\n                dictionary = await\n                sm.GetOrAddAsync<IReliableDictionary<Guid,\n                DateTimeOffset>>(name),\n                maxDelaySeconds = maxDelaySeconds,\n                lastClear = DateTimeOffset.UtcNow,\n                sm = sm,\n            };\n}\n...\n... \n```", "```cs\npublic async Task<T> NewMessage<T>(IdempotentMessage<T> message)\n{\n    DateTimeOffset now = DateTimeOffset.Now;\n    if ((now - lastClear).TotalSeconds > 1.5 * maxDelaySeconds)\n    {\n        await Clear();\n    }\n    if ((now - message.Time).TotalSeconds > maxDelaySeconds)\n        return default(T);\n    using (var tx = this.sm.CreateTransaction())\n    {\n        ...\n        ...\n    }\n } \n```", "```cs\nusing (ITransaction tx = this.sm.CreateTransaction())\n{\n    if (await dictionary.TryAddAsync(tx, message.Id, message.Time))\n    {\n         await tx.CommitAsync();\n         return message.Value;\n    }\n    else\n    {\n         return default;\n    }\n} \n```", "```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading.Tasks;\nusing IdempotencyTools;\nusing Microsoft.ServiceFabric.Services.Remoting;\nnamespace Interactions\n{\n    public interface ILogStore: IService\n    {\n        Task<bool> LogPurchase(IdempotentMessage<PurchaseInfo>\n        idempotentMessage);\n    }\n} \n```", "```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization;\nusing System.Text;\nnamespace Interactions\n{\n    [DataContract]\n    public class PurchaseInfo\n    {\n        [DataMember]\n        public string Location { get; set; }\n        [DataMember]\n        public decimal Cost { get; set; }\n        [DataMember]\n        public DateTimeOffset Time { get; set; }\n    }\n} \n```", "```cs\ninternal sealed class LogStore : StatefulService, ILogStore\n...\n...\nprivate IReliableQueue<IdempotentMessage<PurchaseInfo>> LogQueue;\npublic async Task<bool>\n    LogPurchase(IdempotentMessage<PurchaseInfo> idempotentMessage)\n{\n    if (LogQueue == null) return false;\n    using (ITransaction tx = this.StateManager.CreateTransaction())\n    {\n        await LogQueue.EnqueueAsync(tx, idempotentMessage);\n        await tx.CommitAsync();\n        return true;\n    }\n} \n```", "```cs\nprotected override IEnumerable<ServiceReplicaListener>\n    CreateServiceReplicaListeners()\n{\n    return this.CreateServiceRemotingReplicaListeners<LogStore>();\n} \n```", "```cs\nreturn new ServiceReplicaListener[]\n{\n    new ServiceReplicaListener(context =>\n    new MyCustomHttpListener(context, \"<endpoint name>\"),\n    \"CustomWriteUpdateListener\", true),\n    new ServiceReplicaListener(serviceContext =>\n    new KestrelCommunicationListener(serviceContext, \"<endpoint name>\",\n    (url, listener) =>\n        {\n           ...\n        })\n        \"HttpReadOnlyListener\",\n    true)\n}; \n```", "```cs\nnew ServiceReplicaListener(serviceContext =>\nnew KestrelCommunicationListener(serviceContext, \"<endpoint name>\", (url, listener) =>\n{\n    return new WebHostBuilder()\n    .UseKestrel()\n    .ConfigureServices(\n        services => services\n        .AddSingleton<StatefulServiceContext>(serviceContext)\n        .AddSingleton<IReliableStateManager>(this.StateManager))\n    .UseContentRoot(Directory.GetCurrentDirectory())\n    .UseStartup<Startup>()\n    .UseServiceFabricIntegration(listener, \n    ServiceFabricIntegrationOptions.UseUniqueServiceUrl)\n    .UseUrls(url)\n    .Build();\n})\n\"HttpReadOnlyListener\",\ntrue) \n```", "```cs\nnamespace LogStore\n{\n    public class RunningTotal\n    {\n        public DateTime Day { get; set; }\n        public decimal Count { get; set; }\n        public RunningTotal \n                Update(DateTimeOffset time, decimal value)\n        {\n            ...\n        }\n    }\n} \n```", "```cs\npublic RunningTotal Update(DateTimeOffset time, decimal value)\n        {\n            var normalizedTime = time.ToUniversalTime();\n            var newDay = normalizedTime.Date;           \n           ... \n           ...\n        } \n```", "```cs\npublic RunningTotal Update(DateTimeOffset time, decimal value)\n{\n    ...\n    ...\n    var result = newDay > Day && Day != DateTime.MinValue ? \n    new RunningTotal\n    {\n        Day=Day,\n        Count=Count\n    } \n    : null;\n    if(newDay > Day) Day = newDay;\n    if (result != null) Count = value;\n    else Count += value;\n    return result;\n} \n```", "```cs\nnamespace LogStore\n{\n    public class ComputeStatistics : BackgroundService\n    {\n        IReliableQueue<IdempotentMessage<PurchaseInfo>> queue;\n        IReliableStateManager stateManager;\n        ConfigurationPackage configurationPackage;\n        public ComputeStatistics(\n            IReliableQueue<IdempotentMessage<PurchaseInfo>> queue,\n            IReliableStateManager stateManager,\n            ConfigurationPackage configurationPackage)\n        {\n            this.queue = queue;\n            this.stateManager = stateManager;\n            this.configurationPackage = configurationPackage;\n        } \n```", "```cs\nprotected async override Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    bool queueEmpty = false;\n    var delayString=configurationPackage.Settings.Sections[\"Timing\"]\n        .Parameters[\"MessageMaxDelaySeconds\"].Value;\n    var delay = int.Parse(delayString);\n    var filter = await IdempotencyFilter.NewIdempotencyFilterAsync(\n        \"logMessages\", delay, stateManager);\n    var store = await\n        stateManager.GetOrAddAsync<IReliableDictionary<string, RunningTotal>>(\"partialCount\");\n....\n... \n```", "```cs\n<ServiceManifestImport>\n<ServiceManifestRef ServiceManifestName=\"LogStorePkg\" ServiceManifestVersion=\"1.0.0\" />\n<!--code to add start -->\n<ConfigOverrides>\n<ConfigOverride Name=\"Config\">\n<Settings>\n<Section Name=\"Timing\">\n<Parameter Name=\"MessageMaxDelaySeconds\" Value=\"[MessageMaxDelaySeconds]\" />\n</Section>\n</Settings>\n</ConfigOverride>\n</ConfigOverrides>\n<!--code to add end-->\n</ServiceManifestImport> \n```", "```cs\nwhile (!stoppingToken.IsCancellationRequested)\n    {\n        while (!queueEmpty && !stoppingToken.IsCancellationRequested)\n        {\n            RunningTotal total = null;\n            using (ITransaction tx = stateManager.CreateTransaction())\n            {\n                ...\n                ... \n                ...\n            }\n        }\n        await Task.Delay(100, stoppingToken);\n        queueEmpty = false;\n    }\n} \n```", "```cs\nRunningTotal finalDayTotal = null;\nusing (ITransaction tx = stateManager.CreateTransaction())\n{\n    var result = await queue.TryDequeueAsync(tx);\n    if (!result.HasValue) queueEmpty = true;\n    else\n    {\n        var item = await filter.NewMessage<PurchaseInfo>(result.Value);\n        if(item != null)\n        {\n            var counter = await store.TryGetValueAsync(tx, \n            item.Location);\n            //counter update\n            ...\n        }\n        ...\n        ...\n    }\n} \n```", "```cs\n //counter update    \n    var newCounter = counter.HasValue ? \n    new RunningTotal\n    {\n        Count=counter.Value.Count,\n        Day= counter.Value.Day\n    }\n    : new RunningTotal();\n    finalDayTotal = newCounter.Update(item.Time, item.Cost);\n    if (counter.HasValue)\n        await store.TryUpdateAsync(tx, item.Location, \n        newCounter, counter.Value);\n    else\n        await store.TryAddAsync(tx, item.Location, newCounter); \n```", "```cs\nif(item != null)\n{\n  ...\n  ...\n}\nawait tx.CommitAsync();\nif(finalDayTotal != null)\n{\n    await SendTotal(finalDayTotal, item.Location);\n} \n```", "```cs\nprotected async Task SendTotal(RunningTotal total, string location)\n{\n   //Empty, actual application would send data to a service \n   //that exposes daily statistics through a public Http endpoint\n} \n```", "```cs\nprotected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    LogQueue = await \n        this.StateManager\n        .GetOrAddAsync<IReliableQueue\n<IdempotentMessage<PurchaseInfo>>>(\"logQueue\");\n    var configurationPackage = Context\n        .CodePackageActivationContext\n        .GetConfigurationPackageObject(\"Config\");\n    ...\n    ... \n```", "```cs\nvar host = new HostBuilder()\n    .ConfigureServices((hostContext, services) =>\n    {\n        services.AddSingleton(this.StateManager);\n        services.AddSingleton(this.LogQueue);\n        services.AddSingleton(configurationPackage);\n        services.AddHostedService<ComputeStatistics>();\n    })\n    .Build();\nawait host.RunAsync(cancellationToken); \n```", "```cs\n<Parameter Name=\"FakeSource_InstanceCount\" DefaultValue=\"2\" /> \n```", "```cs\nstring[] locations = new string[] { \"Florence\", \"London\", \"New York\", \"Paris\" };\nprotected override async Task RunAsync(CancellationToken cancellationToken)\n{\n    Random random = new Random();\n    while (true)\n    {\n        cancellationToken.ThrowIfCancellationRequested();\n        PurchaseInfo message = new PurchaseInfo\n        {\n            Time = DateTimeOffset.UtcNow,\n            Location= locations[random.Next(0, locations.Length)],\n            Cost= 200m*random.Next(1, 4)\n        };\n        //Send message to counting microservices \n        ...\n        ...\n        await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);\n    }\n} \n```", "```cs\n//Send message to counting microservices \nvar partition = new ServicePartitionKey(Math.Abs(message.Location.GetHashCode()) % 1000);\nvar client = ServiceProxy.Create<ILogStore>(\n    new Uri(\"fabric:/PurchaseLogging/LogStore\"), partition);\ntry\n{\n    while (!await client.LogPurchase(new  \n    IdempotentMessage<PurchaseInfo>(message)))\n    {\n        await Task.Delay(TimeSpan.FromMilliseconds(100),\n        cancellationToken);\n    }\n}\ncatch\n{\n} \n```", "```cs\nServicePartitionResolver resolver = ServicePartitionResolver.GetDefault();\nResolvedServicePartition partition =     \nawait resolver.ResolveAsync(new Uri(\"fabric:/MyApp/MyService\"), \n    new ServicePartitionKey(.....), cancellationToken);\n//look for a primary service only endpoint\nvar finalURI= partition.Endpoints.First(p =>\n    p.Role == ServiceEndpointRole.StatefulPrimary).Address; \n```", "```cs\ntotal = newCounter.Update(item.Time, item.Cost);\nif (counter.HasValue)...//put breakpoint on this line \n```"]