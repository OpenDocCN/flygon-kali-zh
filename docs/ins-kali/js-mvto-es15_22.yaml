- en: Chapter 9. Web Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Web模式
- en: The rise of Node.js has proven that JavaScript has a place on web servers, even
    very high throughput servers. There is no denying that JavaScript's pedigree remains
    in the browser for client side programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的崛起证明了JavaScript在Web服务器上有一席之地，甚至是非常高吞吐量的服务器。毋庸置疑，JavaScript的传统仍然在客户端编程的浏览器中。
- en: In this chapter we're going to look at a number of patterns to improve the performance
    and usefulness of JavaScript on the client. I'm not sure that all of these can
    be thought of as patterns in the strictest sense. They are, however, important
    and worth mentioning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些模式，以改善客户端JavaScript的性能和实用性。我不确定所有这些是否都可以被认为是最严格意义上的模式。然而，它们是重要的，值得一提。
- en: 'The concepts we''ll examine in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论的概念如下：
- en: Sending JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送JavaScript
- en: Plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Multithreading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Circuit breaker pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Back-off
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退避
- en: Promises
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Sending JavaScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送JavaScript
- en: 'Communicating JavaScript to the client seems to be a simple proposition: so
    long as you can get the code to the client it doesn''t matter how that happens,
    right? Well not exactly. There are actually a number of things that need to be
    considered when sending JavaScript to the browser.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript发送到客户端似乎是一个简单的命题：只要能将代码发送到客户端，那么发送方式并不重要，对吗？嗯，不完全是这样。实际上，在将JavaScript发送到浏览器时需要考虑一些事情。
- en: Combining files
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并文件
- en: Way back in [Chapter 2](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435
    "Chapter 2. Organizing Code"), *Organizing Code*, we looked at how to build objects
    using JavaScript, although opinions on this vary. I consider it to be good form
    to have a one-class-to-one-file organization of my JavaScript or really any of
    my object oriented code. By doing this, it makes finding code easy. Nobody needs
    to hunt through a 9000 line long JavaScript file to locate that one method. It
    also allows for a hierarchy to be established again allowing for good code organization.
    However, good organization for a developer is not necessarily good organization
    for a computer. In our case having a lot of small files is actually highly detrimental.
    To understand why, you need to know a little bit about how browsers ask for and
    receive content.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435 "第2章。组织代码")中，*组织代码*，我们讨论了如何使用JavaScript构建对象，尽管对此的看法有所不同。我认为，将我的JavaScript或任何面向对象的代码组织成一个类对应一个文件是一个很好的形式。这样做可以方便查找代码。没有人需要在一个9000行长的JavaScript文件中寻找一个方法。它还允许建立一个层次结构，从而实现良好的代码组织。然而，对于计算机来说，开发者的良好组织并不一定是良好的组织。在我们的情况下，拥有大量小文件实际上是非常不利的。要理解为什么，你需要了解一些关于浏览器请求和接收内容的知识。
- en: 'When you type a URL into the address bar of a browser and hit *Enter*, a cascading
    series of events happens. The first thing is that the browser will ask the operating
    system to resolve the website name to an IP address. On both Windows and Linux
    (and OSX) the standard C library function `gethostbyname` is used. This function
    will check the local DNS cache to see if the mapping from name to address is already
    known. If it is, then that information is returned. If not, then the computer
    makes a request to the DNS server one step up from it. Typically, this is the
    DNS server provided by the ISP but on a larger network it could also be a local
    DNS server. The path of a query between DNS servers can be seen here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器的地址栏中输入URL并按下*Enter*时，一系列级联事件发生。首先，浏览器会要求操作系统将网站名称解析为IP地址。在Windows和Linux（以及OSX）上，使用标准C库函数`gethostbyname`。这个函数将检查本地DNS缓存，看看从名称到地址的映射是否已知。如果是，那么返回该信息。如果不是，那么计算机会向比它高一级的DNS服务器发出请求。通常，这是由ISP提供的DNS服务器，但在较大的网络上，它也可以是本地DNS服务器。DNS服务器之间的查询路径可以在这里看到：
- en: '![Combining files](img/00075.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![合并文件](img/00075.jpeg)'
- en: If a record doesn't exist on that server then the request is propagated up a
    chain of DNS servers in an attempt to find one that knows about the domain. Eventually
    the propagation stops at the root servers. These root servers are the stopping
    point for queries – if they don't know who is responsible for DNS information
    for a domain then the lookup is deemed to have failed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上不存在记录，那么请求将被传播到一系列DNS服务器，以尝试找到一个知道该域的服务器。最终，传播会停在根服务器那里。这些根服务器是查询的终点 -
    如果它们不知道谁负责域的DNS信息，那么查找将被视为失败。
- en: Once the browser has an address for the site it opens up a connection and sends
    a request for the document. If no document is provided, then a */* is sent. Should
    the connection be a secure one, then negotiation of SSL/TSL is performed at this
    time. There is some computational expense to setting up an encrypted connection
    but this is slowly being fixed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器有了站点的地址，它就会打开一个连接并发送文档的请求。如果没有提供文档，那么将发送一个*/*。如果连接是安全的，那么此时将执行SSL/TSL的协商。建立加密连接会有一些计算开销，但这正在慢慢得到解决。
- en: 'The server will respond with a blob of HTML. As the browser receives this HTML
    it starts to process it; the browser does not wait for the entire HTML document
    to be downloaded before it goes to work. If the browser encounters a resource
    that is external to the HTML it will kick off a new request to open another connection
    to the web server and download that resource. The maximum number of connections
    to a single domain is limited so that the web server isn''t flooded. It should
    also be mentioned that setting up a new connection to the web server carries overhead.
    The flow of data between a web client and server can be seen in this illustration:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将以一大块HTML作出响应。当浏览器接收到这个HTML时，它开始处理它；浏览器在下载完整的HTML文档之前并不会等待。如果浏览器遇到一个在HTML之外的资源，它将启动一个新的请求，打开另一个连接到Web服务器并下载该资源。对单个域的最大连接数是有限制的，以防止Web服务器被淹没。还应该提到，建立到Web服务器的新连接会带来开销。Web客户端和服务器之间的数据流可以在这个插图中看到：
- en: '![Combining files](img/00076.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![合并文件](img/00076.jpeg)'
- en: 'Connections to the web server should be limited to avoid paying the connection
    setup costs repeatedly. This brings us to our first concept: combining files.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复支付连接设置成本，与Web服务器的连接应该受到限制。这带我们来到我们的第一个概念：合并文件。
- en: If you've followed the advice to leverage namespaces and classes in your JavaScript,
    then putting all of your JavaScript together in a single file is a trivial step.
    One need only concatenate the files together and everything should continue to
    work as normal. Some minor care and attention may need to be paid to the order
    of inclusion, but not typically.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了在JavaScript中利用命名空间和类的建议，那么将所有JavaScript放在一个文件中就是一个微不足道的步骤。只需将文件连接在一起，一切应该继续正常工作。可能需要对包含的顺序进行一些小心和注意，但通常不需要。
- en: 'The previous code we''ve written has been pretty much one file per pattern.
    If there is a need for multiple patterns to be used, then we could simply concatenate
    the files together. For instance, the combined builder and factory method patterns
    might look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的代码基本上是每个模式一个文件。如果需要使用多个模式，那么我们可以简单地将文件连接在一起。例如，组合的生成器和工厂方法模式可能看起来像下面这样：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The question may arise as to how much of your JavaScript should be combined
    and loaded at once. It is a surprisingly difficult question to answer. On one
    hand it is desirable to front load all the JavaScript for the entire site when
    users first arrive at the site. This means that users will pay a price initially
    but will not have to download any additional JavaScript as they travel about the
    site. This is because the browser will cache the script and reuse it instead of
    downloading it from the server again. However, if users only visit a small subset
    of the pages on the site then they will have loaded a great deal of JavaScript
    that was not needed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现一个问题，即应该一次加载多少JavaScript。这是一个令人惊讶地难以回答的问题。一方面，希望在用户首次访问网站时一次性加载整个网站的JavaScript。这意味着用户最初会付出代价，但在网站上移动时不必下载任何额外的JavaScript。这是因为浏览器会缓存脚本并重复使用它，而不是再次从服务器下载。然而，如果用户只访问网站上的一小部分页面，那么他们将加载许多不需要的JavaScript。
- en: On the other hand, splitting up the JavaScript means that additional page visits
    incur a penalty for retrieving additional JavaScript files. There is a sweet spot
    somewhere in the middle of these two approaches. Script can be organized into
    blocks that map to different sections of the website. This can be a place where
    using proper name spacing will come in handy once again. Each namespace can be
    combined into a single file and then loaded as users visit that part of the site.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，拆分JavaScript意味着额外的页面访问会因检索额外的JavaScript文件而产生惩罚。这两种方法之间存在一个甜蜜点。脚本可以被组织成映射到网站不同部分的块。这可能是再次使用适当的命名空间的地方。每个命名空间可以合并成一个文件，然后在用户访问网站的那部分时加载。
- en: In the end, the only approach that makes sense is to maintain statistics about
    how users move about the site. Based on this information an optimal strategy for
    finding the sweet spot can be established.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，唯一有意义的方法是维护关于用户在网站上移动的统计信息。根据这些信息，可以建立一个找到最佳策略的甜蜜点。
- en: Minification
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩小化
- en: Combining JavaScript into a single file solves the problem of limiting the number
    of requests. However, each request may still be large. Again we come to a schism
    between what makes code fast and readable by humans and what makes it fast and
    readable by computers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript合并成一个文件可以解决限制请求数量的问题。然而，每个请求可能仍然很大。再次，我们面临着代码快速和可读性之间的分歧，一方面是对人类友好的，另一方面是对计算机友好的。
- en: We humans like descriptive variable names, bountiful whitespace, and proper
    indentation. Computers don't care about descriptive names, whitespace, or proper
    indentation. In fact, these things increase the size of the file and thus decrease
    the speed at which the code can be read.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类喜欢描述性的变量名，丰富的空格和适当的缩进。计算机不在乎描述性的名称，空格或适当的缩进。事实上，这些东西会增加文件的大小，从而降低代码的阅读速度。
- en: Minification is a compile step that transforms the human readable code into
    smaller, but equivalent, code. External variables' names remain the same, as the
    minifier has no way to know what other code may be relying on the variable names
    remaining unchanged.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小化是一个编译步骤，它将人类可读的代码转换为更小但等效的代码。外部变量的名称保持不变，因为缩小器无法知道其他代码可能依赖于变量名称保持不变。
- en: 'As an example, if we start with the composite code from [Chapter 4](part0102_split_000.html#318PC1-015e68c68a464f18a9559f448be84435
    "Chapter 4. Structural Patterns"), *Structural Patterns*, the minified code looks
    like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们从[第4章](part0102_split_000.html#318PC1-015e68c68a464f18a9559f448be84435
    "第4章 结构模式")的组合代码开始，*结构模式*，缩小化的代码看起来像下面这样：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll notice that all the spacing has been removed and that any internal variables
    have been replaced with smaller versions. At the same time, you can spot some
    well-known variable names have remained unchanged.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到所有的空格都被移除了，任何内部变量都被替换为更小的版本。与此同时，您可以发现一些众所周知的变量名称保持不变。
- en: Minification saved this particular piece of code 40%. Compressing the content
    stream from the server using gzip, a popular approach, is lossless compression.
    That means that there is a perfect bijection between compressed and uncompressed.
    Minification, on the other hand, is a lossy compression. There is no way to get
    back to the unminified code from just the minified code once it has been minified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小化使这段特定的代码减少了40%。使用流行的gzip对服务器的内容流进行压缩是无损压缩。这意味着压缩和未压缩之间存在完美的双射。另一方面，缩小化是一种有损压缩。一旦进行了缩小化，就无法仅从缩小化的代码返回到未缩小化的代码。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about gzip compression at [http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/](http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/](http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/)阅读更多关于gzip压缩的信息。
- en: If there is a need to return to the original code, then source maps can be used.
    A source map is a file that provides a translation from one format of code to
    another. It can be loaded by the debugging tools in modern browsers to allow you
    to debug the original code instead of unintelligible minified code. Multiple source
    maps can be combine to allow for translation from, say, minified code to unminified
    JavaScript to TypeScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要返回到原始代码，则可以使用源映射。源映射是提供代码格式转换的文件。它可以被现代浏览器中的调试工具加载，允许您调试原始代码而不是难以理解的压缩代码。多个源映射可以组合在一起，允许从压缩代码到未压缩JavaScript到TypeScript的转换。
- en: There are numerous tools which can be used to construct minified and combined
    JavaScript. Gulp and Grunt are JavaScript-based tools for building a pipeline
    which manages JavaScript assets. Both these tools call out to external tools such
    as Uglify to do the actual work. Gulp and Grunt are the equivalent to GNU Make
    or Ant.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于构建压缩和合并的JavaScript。Gulp和Grunt是基于JavaScript的工具，用于构建管理JavaScript资产的管道。这些工具都调用外部工具，如Uglify来执行实际工作。Gulp和Grunt相当于GNU
    Make或Ant。
- en: Content Delivery Networks
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容交付网络
- en: The final delivery trick is to make use of **Content Delivery Networks** (**CDNs**).
    CDNs are distributed networks of hosts whose only purpose is to serve out static
    content. In much the same way that the browser will cache JavaScript between pages
    on the site, it will also cache JavaScript that is shared between multiple web
    servers. Thus, if your site makes use of jQuery, pulling jQuery from a well-known
    CDN such as [https://code.jquery.com/](https://code.jquery.com/) or Microsoft's
    ASP.net CDN may be faster as it is already cached. Pulling from a CDN also means
    that the content is coming from a different domain and doesn't count against the
    limited connections to your server. Referencing a CDN is as simple as setting
    the source of the script tag to point at the CDN.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的交付技巧是利用**内容交付网络**（**CDN**）。CDN是分布式主机网络，其唯一目的是提供静态内容。就像浏览器在网站页面之间缓存JavaScript一样，它也会缓存在多个Web服务器之间共享的JavaScript。因此，如果您的网站使用jQuery，从知名CDN（如[https://code.jquery.com/](https://code.jquery.com/)或Microsoft的ASP.net
    CDN）获取jQuery可能会更快，因为它已经被缓存。从CDN获取还意味着内容来自不同的域，并且不会计入对服务器的有限连接。引用CDN就像将脚本标签的源设置为指向CDN一样简单。
- en: Once again, some metrics will need to be gathered to see whether it is better
    to use a CDN or simply roll libraries into the JavaScript bundle. Examples of
    such metrics may include the added time to perform additional DNS lookup and the
    difference in the download sizes. The best approach is to use the timing APIs
    in the browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，需要收集一些指标，以确定是更好使用CDN还是将库简单地合并到JavaScript包中。这些指标的示例可能包括执行额外DNS查找所需的时间以及下载大小的差异。最佳方法是使用浏览器中的定时API。
- en: The long and short of distributing JavaScript to the browser is that experimentation
    is required. Testing a number of approaches and measuring the results will give
    the best result for end users.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript分发到浏览器的长短实验是必需的。测试多种方法并测量结果将为最终用户带来最佳结果。
- en: Plugins
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: There are a great number of really impressive JavaScript libraries in the wild.
    For me the library that changed how I look at JavaScript was jQuery. For others
    it may have been one of the other popular libraries such as MooTool, Dojo, Prototype,
    or YUI. However, jQuery has exploded in popularity and has, at the time of writing,
    won the JavaScript library wars. 78.5% of the top ten thousand websites, by traffic,
    on the internet make use of some version of jQuery. None of the rest of the libraries
    even breaks 1%.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外有许多令人印象深刻的JavaScript库。对我来说，改变我对JavaScript看法的库是jQuery。对于其他人来说，可能是其他流行的库之一，如MooTool、Dojo、Prototype或YUI。然而，jQuery在流行度上爆炸，并且在撰写本文时，已经赢得了JavaScript库之争。互联网上前一万个网站中有78.5%使用了某个版本的jQuery。其他库中没有一个甚至超过1%。
- en: Many developers have seen fit to implement their own libraries on top of these
    foundational libraries in the form of plugins. A plugin typically modifies the
    prototype exposed by the library and adds additional functionality. The syntax
    is such that, to the end developer, it appears to be part of the core library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员已经实施了自己的库，作为插件的基础库。插件通常修改库公开的原型并添加附加功能。语法是这样的，对于最终开发人员来说，它似乎是核心库的一部分。
- en: How plugins are built varies depending on the library you're trying to extend.
    Nonetheless, let's take a look at how we can build a plugin for jQuery and then
    for one of my favourite libraries, d3\. We'll see if we can extract some commonalities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构建插件的方式因要扩展的库而异。尽管如此，让我们看看如何为jQuery构建插件，然后为我最喜欢的库之一d3构建插件。我们将看看是否可以提取一些共同点。
- en: jQuery
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: 'At jQuery''s core is the CSS selector library called `sizzle.js`. It is sizzle
    that is responsible for all the really nifty ways jQuery can select items on a
    page using CSS3 selectors. Use jQuery to select elements on a page like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的核心是名为`sizzle.js`的CSS选择器库。它是sizzle负责使用CSS3选择器在页面上选择项目的所有非常聪明的方式。使用jQuery在页面上选择元素如下：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, a jQuery object is returned. The jQuery object acts a lot like, although
    not completely like, an array. This is achieved by creating a series of keys on
    the jQuery object numbered 0 through to n-1 where n is the number of elements
    matched by the selector. This is actually pretty smart as it enables array like
    accessors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，返回了一个jQuery对象。jQuery对象的行为很像数组，尽管不完全相同。这是通过在jQuery对象上创建一系列键来实现的，这些键从0到n-1编号，其中n是选择器匹配的元素数量。这实际上非常聪明，因为它实现了类似数组的访问器：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While providing a bunch of additional functions, the items at the indices are
    plain HTML Elements and not wrapped with jQuery, hence the use of the second `$()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然提供了一堆额外的函数，但索引处的项目是普通的HTML元素，而不是用jQuery包装的，因此需要使用第二个`$()`。
- en: 'For jQuery plugins, we typically want to make our plugins extend this jQuery
    object. Because it is dynamically created every time the selector is fired we
    actually extend an object called `$.fn`. This object is used as the basis for
    creating all jQuery objects. Thus creating a plugin that transforms all the text
    in inputs on the page into uppercase is nominally as simple as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于jQuery插件，我们通常希望使我们的插件扩展这个jQuery对象。因为它是每次选择器被触发时动态创建的，所以我们实际上扩展了一个名为`$.fn`的对象。这个对象被用作创建所有jQuery对象的基础。因此，创建一个将页面上所有输入框中的文本转换为大写的插件名义上就像下面这样简单：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This plugin is particularly useful for posting to bulletin boards and for whenever
    my boss fills in a form. The plugin iterates over all the objects selected by
    the selector and converts their content to uppercase. It also returns this. By
    doing so we allow for chaining of additional functions. You can use the function
    like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件特别适用于发布到公告板，以及每当我的老板填写表格时。该插件遍历选择器选择的所有对象，并将它们的内容转换为大写。它还返回这个。通过这样做，我们允许链接额外的函数。您可以像这样使用该函数：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It does rather depend on the `$` variable being assigned to jQuery. This isn't
    always the case as `$` is a popular variable in JavaScript libraries, likely because
    it is the only character that isn't a letter or a number and doesn't already have
    special meaning.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`$`变量被分配给jQuery的情况下才能实现。这并不总是这样，因为`$`是JavaScript库中一个常用的变量，可能是因为它是唯一一个既不是字母也不是数字，也没有特殊含义的字符。
- en: 'To combat this, we can use an immediately evaluated function in much the same
    way we did way back in [Chapter 2](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435
    "Chapter 2. Organizing Code"), *Organizing Code*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这一点，我们可以使用立即评估的函数，就像我们在[第2章](part0086_split_000.html#2I0GC1-015e68c68a464f18a9559f448be84435
    "第2章。组织代码") *组织代码*中所做的那样：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The added advantage here is that, should our code require helper functions or
    private variables, they can be set inside the same function. You can also pass
    in any options required. jQuery provides a very helpful `$.extend` function that
    copies properties between objects, making it ideal for extending a set of default
    options with those passed in. We looked at this in some detail in a previous chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的额外优势是，如果我们的代码需要辅助函数或私有变量，它们可以在同一个函数内设置。您还可以传入所需的任何选项。jQuery提供了一个非常有用的`$.extend`函数，它可以在对象之间复制属性，使其非常适合使用一组默认选项来扩展传入的选项。我们在之前的章节中详细讨论过这一点。
- en: 'The jQuery plugin documentation recommends that the jQuery object be polluted
    as little as possible with plugins. This is to avoid conflicts between multiple
    plugins that want to use the same names. Their solution is to have a single function
    that has different behaviours depending on the parameters passed in. For instance,
    the jQuery UI plugin uses this approach for dialog:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery插件文档建议尽量减少对jQuery对象的污染。这是为了避免多个插件之间想要使用相同名称而发生冲突。他们的解决方案是有一个单一的函数，根据传入的参数有不同的行为。例如，jQuery
    UI插件就使用了这种方法来创建对话框：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I would much rather call these like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我更愿意这样调用：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With dynamic languages there really isn't a great deal of difference but I would
    much rather have well named functions that can be discovered by tooling than magic
    strings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态语言来说，实际上并没有太大的区别，但我更愿意有一个命名良好的函数，可以被工具发现，而不是魔术字符串。
- en: d3
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: d3
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The core of `d3` is the `d3` object. Off that object hang a number of namespaces
    for layouts, scales, geometry, and numerous others. As well as whole namespaces,
    there are functions for doing array manipulation and loading data from external
    sources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3`的核心是`d3`对象。在该对象之外，还有许多用于布局、比例尺、几何和其他许多命名空间。除了整个命名空间，还有用于进行数组操作和从外部来源加载数据的函数。'
- en: 'Creating a plugin for `d3` starts with deciding where we''re going to plug
    into the code. Let''s build a plugin that creates a new color scale. A color scale
    is used to map a domain of values to a range of colors. For instance, we might
    wish to map the domain of the following four values onto a range of four colors:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为`d3`创建一个插件始于决定我们要插入代码的位置。让我们构建一个创建新颜色比例尺的插件。颜色比例尺用于将一系列值映射到一系列颜色。例如，我们可能希望将以下四个值的范围映射到四种颜色：
- en: '![d3](img/00078.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![d3](img/00078.jpeg)'
- en: 'Let''s plug in a function to provide a new color scale, in this case one that
    supports grouping elements. A scale is a function that maps a domain to a range.
    For a color scale, the range is a set of colors. An example might be a function
    that maps all even numbers to red and all odd to white. Using this scale on a
    table would result in zebra striping:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们插入一个函数来提供一个新的颜色比例尺，这种情况下支持分组元素。比例尺是一个将域映射到范围的函数。对于颜色比例尺，范围是一组颜色。一个例子可能是一个函数，将所有偶数映射到红色，所有奇数映射到白色。在表格上使用这个比例尺将产生斑马条纹：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We simply attach this plugin to the existing `d3.scale` object. This can be
    used by simply giving an array of arrays as a domain and an array as a range:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将这个插件附加到现有的`d3.scale`对象上。这可以通过简单地给出一个数组作为域和一个数组作为范围来使用：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This simple plugin extends the functionality of d3's scale. We could have replaced
    existing functionality or even wrapped it such that calls into existing functionality
    would be proxied through our plugin.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的插件扩展了d3的比例尺功能。我们可以替换现有功能，甚至包装它，以便对现有功能的调用将通过我们的插件进行代理。
- en: Plugins are generally not that difficult to build but they do vary from library
    to library. It is important to keep an eye on the existing variable names in libraries
    so we don't end up clobbering them or even clobbering functionality provided by
    other plugins. Some suggest prefixing functions with a string to avoid clobbering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 插件通常并不难构建，但它们在库之间有所不同。重要的是要注意库中现有变量名，以免覆盖它们或甚至覆盖其他插件提供的功能。一些建议使用字符串为函数添加前缀，以避免覆盖。
- en: If the library has been designed with it in mind there may be additional places
    into which we can hook. A popular approach is to provide an options object that
    contains optional fields for hooking in our own functions as event handlers. If
    nothing is provided the function continues as normal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库是为此设计的，可能会有其他地方可以连接。一种流行的方法是提供一个包含可选字段的选项对象，用于将我们自己的函数作为事件处理程序连接进去。如果没有提供任何内容，函数将继续正常运行。
- en: Doing two things at once – multithreading
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时进行两件事情-多线程
- en: Doing two things at once is hard. For many years the solution in the computer
    world was to use either multiple processes or multiple threads. The difference
    between the two is fuzzy due to implementation differences on different operating
    systems but threads are typically lighter-weight versions of processes. JavaScript
    on the browser supports neither of these approaches.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同时进行两件事情很难。多年来，计算机世界的解决方案是使用多个进程或多个线程。由于不同操作系统上的实现差异，两者之间的区别模糊，但线程通常是进程的轻量级版本。浏览器上的JavaScript不支持这两种方法。
- en: Historically, there has been no real need for multithreading on a browser. JavaScript
    was used to manipulate the user interface. When manipulating a UI, even in other
    languages and windowing environments, only one thread is permitted to act at a
    time. This avoids race conditions that would be very obvious to users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，在浏览器上并没有真正需要多线程。JavaScript用于操作用户界面。即使在其他语言和窗口环境中操作UI，也只允许一个线程同时操作。这避免了对用户非常明显的竞争条件。
- en: However, as JavaScript grows in popularity, more and more complicated software
    is being written to run inside the browser. Sometimes that software could really
    benefit from performing complex calculations in the background.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着JavaScript的流行，越来越复杂的软件被编写以在浏览器内运行。有时，该软件可能真的会受益于在后台执行复杂的计算。
- en: Web workers provide a mechanism for doing two things at once in a browser. Although
    a fairly recent innovation, web workers now have good support in mainstream browsers.
    In effect a worker is a background thread that can communicate with the main thread
    using messages. Web workers must be self-contained in a single JavaScript file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Web workers提供了在浏览器中同时进行两件事情的机制。虽然这是一个相当新的创新，但web workers现在在主流浏览器中得到了很好的支持。实际上，worker是一个可以使用消息与主线程通信的后台线程。Web
    workers必须在单个JavaScript文件中自包含。
- en: 'To make use of web workers is fairly easy. We''ll revisit our example from
    a few chapters ago when we looked at the fibonacci sequence. The worker process
    listens for messages like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 利用web workers相当容易。我们将重新访问一下之前几章中的示例，当时我们看过斐波那契数列。工作进程监听消息如下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we start a new instance of `fib` any time we get a `startCalculation` message.
    `fib` is simply the naive implementation from earlier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当收到“startCalculation”消息时，我们都会启动一个新的`fib`实例。`fib`只是之前的朴素实现。
- en: 'The main thread loads the worker process from its external file and attaches
    a number of listeners:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程从外部文件加载工作进程并附加多个监听器：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to start the calculation, all that is needed is to send a command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始计算，只需要发送一个命令：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we pass the number of the term in the sequence we want to calculate. While
    the calculation is running in the background the main thread is free to do whatever
    it likes. When the message is received back from the worker it is placed in the
    normal event loop to be processed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递要计算的序列中的项的编号。在后台运行计算时，主线程可以自由进行任何操作。当从worker那里收到消息时，它将被放入正常的事件循环中进行处理。
- en: '![Doing two things at once – multithreading](img/00079.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![同时进行两件事情-多线程](img/00079.jpeg)'
- en: Web workers may be useful to you if you have to do any time consuming calculations
    in JavaScript.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在JavaScript中进行耗时的计算，web workers可能对您有用。
- en: If you're making use of server-side JavaScript through the use of Node.js then
    there is a different approach to doing more than one thing at a time. Node.js
    offers the ability to fork child processes and provides an interface not dissimilar
    to the web worker one to communicate between the child and parent processes. This
    method forks an entire process though, which is much more resource intensive than
    using lightweight threads.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Node.js通过服务器端JavaScript，则有一种不同的方法可以同时执行多个任务。Node.js提供了分叉子进程的能力，并提供了一个与web
    worker类似的接口，用于在子进程和父进程之间通信。这种方法分叉整个进程，比使用轻量级线程更消耗资源。
- en: Some other tools exist that create lighter-weight background workers in Node.js.
    These are probably a closer parallel to what exists on the web side than forking
    a child process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中存在一些其他工具，可以创建轻量级的后台工作进程。这些可能更接近于Web端存在的情况，而不是分叉子进程。
- en: Circuit breaker pattern
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Systems, even the best designed systems, fail. The larger and more distributed
    a system, the higher the probability of failure. Many large systems such as Netflix
    or Google have extensive built-in redundancies. The redundancies don't decrease
    the chance of a failure of a component but they do provide a backup. Switching
    to the backup is frequently transparent to the end user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 系统，即使是设计最好的系统，也会失败。系统越大、分布越广，组件失败的概率就越高。许多大型系统，如Netflix或Google，都具有广泛的内置冗余。冗余并不会减少组件失败的机会，但它们提供了备份。切换到备份通常对最终用户是透明的。
- en: The circuit breaker pattern is a common component of a system that provides
    this sort of redundancy. Let's say that your application queries an external data
    source every five seconds, perhaps you're polling for some data that you're expecting
    to change. What happens when this polling fails? In many cases the failure is
    simply ignored and the polling continues. This is actually a pretty good behaviour
    on the client side as data updates are not always crucial. In some cases, a failure
    will cause the application to retry the request immediately. Retrying server requests
    in a tight loop can be problematic for both the client and the server. The client
    may become unresponsive as it spends more time in a loop requesting data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式是提供这种冗余的系统的常见组件。比如，你的应用程序每五秒查询一次外部数据源，也许你正在轮询一些预计会发生变化的数据。当这种轮询失败时会发生什么？在许多情况下，失败会被简单地忽略，轮询会继续进行。这实际上是客户端的一个相当好的行为，因为数据更新并不总是至关重要。在某些情况下，失败会导致应用程序立即重试请求。在紧密的循环中重试服务器请求对客户端和服务器都可能有问题。客户端可能会变得无响应，因为它花费更多的时间在循环请求数据上。
- en: On the server side, a system that is attempting to recover from a failure is
    being slammed every five seconds by what could be thousands of clients. If the
    failure is due to the system being overloaded, then continuing to query it will
    only make matters worse.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，一个试图从失败中恢复的系统每五秒就会受到可能是成千上万的客户端的冲击。如果失败是由系统过载造成的，那么继续查询只会使情况变得更糟。
- en: 'The circuit breaker pattern stops attempting to communicate with a system that
    is failing once a certain number of failures have been reached. Basically, repeated
    failures result in the circuit being broken and the application ceasing to query.
    You can see the general pattern of a circuit breaker in this illustration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式在达到一定数量的失败后停止尝试与失败的系统通信。基本上，重复的失败导致断路器被打开，应用程序停止查询。你可以在这个插图中看到断路器的一般模式：
- en: '![Circuit breaker pattern](img/00080.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![断路器模式](img/00080.jpeg)'
- en: For the server, having the number of clients drop off as failures pile up allows
    for some breathing room to recover. The chances of a storm of requests coming
    in and keeping the system down is minimized.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，随着失败的积累，客户端数量的减少为恢复提供了一些喘息空间。请求风暴进来并使系统崩溃的可能性被最小化。
- en: Of course we would like the circuit breaker to reset at some point so that service
    can be restored. The two approaches for this are that, either the client polls
    periodically (less frequently than before) and resets the breaker, or that the
    external system communicates back to its clients that service has been restored.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望断路器在某个时候重置，以便服务可以恢复。对此有两种方法，一种是客户端定期轮询（频率低于以前）并重置断路器，另一种是外部系统向其客户端通知服务已恢复。
- en: Back-off
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退避
- en: A variation on the circuit breaker pattern is to use some form of back-off instead
    of cutting out communication to the server completely. This is an approach that
    is suggested by many database vendors and cloud providers. If our original polling
    was at five second intervals, then when a failure is detected change the interval
    to every 10 seconds. Repeat this process using longer and longer intervals.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式的一个变种是使用某种形式的退避，而不是完全切断与服务器的通信。这是许多数据库供应商和云提供商建议的一种方法。如果我们最初的轮询间隔是五秒，那么当检测到故障时，将间隔更改为每10秒一次。重复这个过程，使用越来越长的间隔。
- en: When requests start to work again then the pattern of changing the time interval
    is reversed. Requests are sent closer and closer together until the original polling
    interval is resumed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求再次开始工作时，改变时间间隔的模式会被逆转。请求会越来越接近，直到恢复原始的轮询间隔。
- en: Monitoring the status of the external resource availability is a perfect place
    to use background worker roles. The work is not complex but it is totally detached
    from the main event loop.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 监视外部资源可用性的状态是使用后台工作角色的理想场所。这项工作并不复杂，但完全脱离了主事件循环。
- en: Again this reduces the load on the external resource giving it more breathing
    room. It also keeps the clients unburdened by too much polling.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以减少对外部资源的负荷，给它更多的喘息空间。同时也可以避免客户端过多的轮询。
- en: 'An example using jQuery''s `ajax` function looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery的`ajax`函数的示例如下：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that the highlighted section retries the query.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到高亮部分重试了查询。
- en: This style of back-off is actually used in Ethernet to avoid repeated packet
    collisions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退避方式实际上在以太网中用于避免重复的数据包碰撞。
- en: Degraded application behavior
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降级应用行为
- en: There is likely a very good reason that your application is calling out to external
    resources. Backing off and not querying the data source is perfectly reasonable
    but it is still desirable that users have some ability to interact with the site.
    One solution to this problem is to degrade the behavior of the application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序很可能有很好的理由调用外部资源。退避并不查询数据源是完全合理的，但仍然希望用户能够与网站进行交互。解决这个问题的一个方法是降低应用程序的行为。
- en: For instance, if your application shows real-time stock quote information, but
    the system for delivering stock information is broken, then a less than real time
    service could be swapped in. Modern browsers have a whole raft of different technologies
    that allow for storing small quantities of data on the client computer. This storage
    space is ideal for caching old versions of some data should the latest versions
    be unavailable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的应用程序显示实时股票报价信息，但提供股票信息的系统出现故障，那么可以切换到不太实时的服务。现代浏览器有许多不同的技术，允许在客户端计算机上存储少量数据。这个存储空间非常适合缓存一些旧版本的数据，以防最新版本不可用。
- en: Even in cases where the application is sending data to the server, it is possible
    to degrade behaviour. Saving the data updates locally and then sending them altogether
    when the service is restored is generally acceptable. Of course, once a user leaves
    a page, then any background works will terminate. If the user never again returns
    to the site, then whatever updates they had queued to send to the server will
    be lost.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在应用程序向服务器发送数据的情况下，也可以降级行为。在服务恢复时，保存数据更新本地，然后一次性发送它们通常是可以接受的。当然，一旦用户离开页面，任何后台工作都将终止。如果用户再也不返回网站，那么他们排队发送到服务器的任何更新都将丢失。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of warning: if this is an approach you take it might be best to warn
    users that their data is old, especially if your application is a stock trading
    application.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：如果你采取这种方法，最好警告用户他们的数据已经过时，特别是如果你的应用是股票交易应用。
- en: Promise pattern
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺模式
- en: I said earlier that JavaScript is single threaded. This is not entirely accurate.
    There is a single event loop in JavaScript. Blocking this event loop with a long
    running process is considered to be bad form. Nothing else can happen while your
    greedy algorithm is taking up all the CPU cycles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过JavaScript是单线程的。这并不完全准确。JavaScript中有一个单一的事件循环。用一个长时间运行的进程阻塞这个事件循环被认为是不好的形式。当你的贪婪算法占用所有CPU周期时，其他事情都无法发生。
- en: 'When you launch an asynchronous function in JavaScript, such as fetching data
    from a remote server, then much of this activity happens in a different thread.
    The success or failure handler functions are executed in the main event thread.
    This is part of the reason that success handlers are written as functions: it
    allows them to be easily passed back and forth between contexts.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JavaScript中启动一个异步函数，比如从远程服务器获取数据，那么很多这种活动都是在不同的线程中进行的。成功或失败的处理函数是在主事件线程中执行的。这也是成功处理程序被编写为函数的部分原因：它允许它们在不同的上下文之间轻松传递。
- en: Thus there are activities which truly do happen in an asynchronous, parallel
    fashion. When the `async` method has completed then the result is passed into
    the handler we provided and the handler is put into the event queue to be picked
    up next time the event loop repeats. Typically, the event loop runs many hundreds
    or thousands of times a second, depending on how much work there is to do on each
    iteration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一些活动确实是以异步、并行的方式发生的。当`async`方法完成时，结果被传递到我们提供的处理程序中，并且处理程序被放入事件队列中，在事件循环重复时被接收。通常，事件循环每秒运行数百次或数千次，具体取决于每次迭代需要做多少工作。
- en: 'Syntactically, we write the message handlers as functions and hook them up:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，我们将消息处理程序写成函数并将它们挂钩起来：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is reasonable if the situation is simple. However, if you would like to
    perform some additional asynchronous actions with the results of the callback
    then you end up with nested callbacks. If you need to add error handling that
    too is done using callbacks. The complexity of waiting for multiple callbacks
    to return and orchestrating your response rises quickly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况很简单，这是合理的。然而，如果你想对回调的结果执行一些额外的异步操作，那么你最终会得到嵌套的回调。如果需要添加错误处理，也是使用回调来完成的。等待多个回调返回并协调你的响应的复杂性会迅速上升。
- en: 'The promise pattern provides some syntactic help to clean up the asynchronous
    difficulties. If we take a common asynchronous operation such as retrieving data
    over XMLHttp Request using jQuery, then the code takes both an error and a success
    function. It might look something like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺模式提供了一些语法帮助，以清理异步困难。如果我们以使用jQuery通过XMLHttp请求检索数据的常见异步操作为例，那么代码同时需要一个错误和一个成功函数。它可能看起来像下面这样：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using a promise instead would transform the code to look more like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺而不是回调会使代码看起来更像下面这样：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case the `$.ajax` method returns a promise object that contains a value
    and a state. The value is populated when the async call completes. The status
    provides some information about the current state of the request: has it completed,
    was it successful?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`$.ajax`方法返回一个包含值和状态的承诺对象。当异步调用完成时，该值被填充。状态提供了关于请求当前状态的一些信息：它是否已完成，是否成功？
- en: The promise also has a number of functions called on it. The `then()` function
    takes a success and an error function and it returns an additional promise. Should
    the success function run synchronously, then the promise returns as already fulfilled.
    Otherwise it remains in a working state, known as pending, until the asynchronous
    success has fired.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺还有一些在其上调用的函数。`then()`函数接受一个成功和一个错误函数，并返回一个额外的承诺。如果成功函数同步运行，那么承诺将作为已经实现返回。否则，它将保持在一个工作状态，称为待定状态，直到异步成功触发。
- en: 'In my mind, the method in which jQuery implements promises is not ideal. Their
    error handing doesn''t properly distinguish between a promise that has failed
    to be fulfilled and a promise that has failed but has been handled. This renders
    jQuery promises incompatible with the general idea of promises. For instance,
    it is not possible to do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，jQuery实现承诺的方法并不理想。他们的错误处理没有正确区分一个未能实现的承诺和一个失败但已经处理的承诺。这使得jQuery的承诺与承诺的一般理念不兼容。例如，无法执行以下操作：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Even though the error has been handed and a new promise returned, processing
    will discontinue. It would be much better if the function could be written as
    the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使错误已经被处理并返回了一个新的承诺，处理也将终止。如果函数可以写成以下形式，那将会更好：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There has been much discussion about the implementation of promises in jQuery
    and other libraries. As a result of this discussion the current proposed promise
    specification is different from jQuery's promises and is incompatible. Promises/A+
    are the certification that is met by numerous promise libraries such as `when.js`
    and Q. It also forms the foundation of the promises specification that came with
    ECMAScript-2015.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在jQuery和其他库中实现承诺的讨论很多。由于这些讨论，当前提出的承诺规范与jQuery的承诺不同，并且不兼容。Promises/A+是许多承诺库（如`when.js`和Q）满足的认证。它也构成了随ECMAScript-2015一起提出的承诺规范的基础。
- en: Promises provide a bridge between synchronous and asynchronous functions, in
    effect turning the asynchronous functions into something that can be manipulated
    as if it were synchronous.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺提供了同步和异步函数之间的桥梁，实际上将异步函数转换为可以像同步函数一样操作的东西。
- en: 'If promise sounds a lot like the lazy evaluation pattern we saw some chapters
    ago then you''re exactly correct. Promises are constructed using lazy evaluation,
    the actions called on them are queued inside the object rather than being evaluated
    at once. This is a wonderful application of a functional pattern and even enables
    scenarios like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果承诺听起来很像我们几章前看到的惰性评估模式，那么你是完全正确的。承诺是使用惰性评估构建的，对它们调用的操作被排队在对象内部，而不是立即评估。这是函数模式的一个很好的应用，甚至可以实现以下场景：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Promises greatly simplify asynchronous programming in JavaScript and should
    certainly be considered for any project that is heavily asynchronous in nature.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺极大地简化了JavaScript中的异步编程，并且应该在任何涉及大量异步操作的项目中予以考虑。
- en: Hints and tips
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: ECMAScript 2015 promises are well supported on most browsers. Should you need
    to support an older browser then there are some great shims out there that can
    add the functionality with a minimum of overhead.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015的承诺在大多数浏览器上得到了很好的支持。如果需要支持旧版浏览器，那么有一些很棒的shim可以添加功能而不会增加太多开销。
- en: When examining the performance of retrieving JavaScript from a remote server,
    there are tools provided in most modern browsers for viewing a timeline of resource
    loading. This timeline will show when the browser is waiting for scripts to be
    downloaded and when it is parsing the scripts. Using this timeline allows for
    experimenting to find the best way to load a script or series of scripts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查从远程服务器检索JavaScript的性能时，大多数现代浏览器都提供了工具来查看资源加载的时间轴。这个时间轴将显示浏览器何时在等待脚本下载，以及何时在解析脚本。使用这个时间轴可以进行实验，找到加载脚本或一系列脚本的最佳方法。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at a number of patterns or approaches that improve
    the experience of developing JavaScript. We looked at a number of concerns around
    delivery to the browser. We also looked at how to implement plugins against a
    couple of libraries and extrapolated general practices. Next we took a look at
    how to work with background processes in JavaScript. Circuit breakers were suggested
    as a method of keeping remote resource-fetching sane. Finally, we examined how
    promises can improve the writing of asynchronous code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些改进JavaScript开发体验的模式或方法。我们关注了一些关于传递到浏览器的问题。我们还看了如何针对一些库实现插件并推断出一般的做法。接下来，我们看了如何在JavaScript中处理后台进程。断路器被建议作为保持远程资源获取正常的方法。最后，我们研究了承诺如何改进异步代码的编写。
- en: In the next chapter we'll spend quite a bit more time looking at messaging patterns.
    We saw a little about messing with web workers but we'll expand quite heavily
    on them in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将花费更多的时间研究消息传递模式。我们对使用web workers有所了解，但在下一节中我们将大大扩展它们。
