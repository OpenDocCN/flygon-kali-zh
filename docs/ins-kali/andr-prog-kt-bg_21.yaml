- en: Chapter 21. Threads and Starting the Live Drawing App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。线程和启动实时绘图应用程序
- en: In this chapter, we will get started on our next app. This app will be a kid's-style
    drawing app where the user can draw on the screen using their finger. The drawing
    app that we create will be slightly different, however. The lines that the user
    draws will be comprised of particle systems that explode into thousands of pieces.
    We will call the project *Live Drawing*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始我们的下一个应用程序。这个应用程序将是一个儿童风格的绘图应用程序，用户可以使用手指在屏幕上绘图。然而，我们创建的绘图应用程序将略有不同。用户绘制的线条将由粒子系统组成，这些粒子系统会爆炸成成千上万的碎片。我们将把项目称为*实时绘图*。
- en: 'To achieve this, we will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在本章中涵盖以下主题：
- en: Getting started with the Live Drawing app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用实时绘图应用程序
- en: Learning about real-time interaction, sometimes referred to as a **game loop**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习实时交互，有时被称为游戏循环
- en: Learning about **threads**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于线程
- en: Coding a real-time system that is ready to draw in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个准备好进行绘制的实时系统
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the Live Drawing project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实时绘图项目
- en: To get started, create a new project in Android Studio and call it `Live Drawing`.
    Use the **Empty Activity** project and leave the rest of the settings at their
    defaults.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，可以在Android Studio中创建一个名为`Live Drawing`的新项目。使用**空活动**项目，并将其余设置保持默认。
- en: Similar to the two drawing apps from the previous chapter, this app consists
    of Kotlin files only, and no layout files. The Kotlin files and all the code up
    to the end of this chapter can all be found in the `Chapter21` folder of the download
    bundle. The complete project can be found in the `Chapter22` folder of the download
    bundle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的两个绘图应用程序类似，这个应用程序只包含Kotlin文件，没有布局文件。到本章结束为止的所有Kotlin文件和代码都可以在下载包的`Chapter21`文件夹中找到。完整的项目可以在下载包的`Chapter22`文件夹中找到。
- en: Next, we will create empty classes that we will code throughout the project
    over the next two chapters. Create a new class called `LiveDrawingView`, a new
    class called `ParticleSystem,` and a new class called `Particle`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些空的类，这些类将在接下来的两章中进行编码。创建一个名为`LiveDrawingView`的新类，一个名为`ParticleSystem`的新类，以及一个名为`Particle`的新类。
- en: Looking ahead at the Live Drawing app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望实时绘图应用程序
- en: As this app is more in-depth and needs to respond in real time, it is necessary
    to use a slightly more in-depth structure. At first, this may seem like a complication,
    but in the long run, it will make our code simpler and easier to understand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序更加深入，需要实时响应，因此需要使用稍微更深入的结构。起初，这可能看起来有些复杂，但从长远来看，这将使我们的代码更简单，更容易理解。
- en: 'We will have four classes in the Live Drawing app, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时绘图应用程序中，我们将有四个类，如下：
- en: '`MainActivity`: The `Activity` class provided by the Android API is the class
    that interacts with the **operating system** (**OS**). We have already seen how
    the OS interacts with `onCreate` when the player clicks on the app icon to start
    an app. Rather than have the `MainActivity` class that does everything, this `Activity`-based
    class will just handle the startup and shutdown of our app, and offer some assistance
    with initialization by calculating the screen resolution. It makes sense that
    this class will be of the `Activity` type and not `AppCompatActivity`. However,
    as you will soon see, we will delegate interaction through touches to another
    class, that is, the same class that will also handle almost every aspect of the
    app. This will introduce us to a number of new and interesting concepts.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity`：Android API提供的`Activity`类是与操作系统（OS）交互的类。我们已经看到了当用户点击应用程序图标启动应用程序时，操作系统如何与`onCreate`交互。与其让`MainActivity`类做所有事情，这个基于`Activity`的类将只处理应用程序的启动和关闭，并通过计算屏幕分辨率来提供一些初始化的帮助。这个类将是`Activity`类型而不是`AppCompatActivity`是有道理的。然而，很快你会看到，我们将通过触摸委托交互给另一个类，也就是将处理几乎每个方面的同一个类。这将为我们介绍一些新的有趣的概念。'
- en: '`LiveDrawingView`: This is the class that will be responsible for doing the
    drawing and creating the real-time environment that allows the user to interact
    at the same time as their creations are moving and evolving.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveDrawingView`：这个类将负责绘图，并创建允许用户在其创作移动和发展的同时进行交互的实时环境。'
- en: '`ParticleSystem`: This is the class that will manage up to thousands of instances
    of the `Particle` class.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem`：这是一个类，将管理多达数千个`Particle`类的实例。'
- en: '`Particle`: This class will be the simplest of them all; it will have a location
    on screen and a heading. It will update itself about 60 times per second when
    prompted to by the `LiveDrawingView` class.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle`：这个类将是最简单的类；它将在屏幕上具有位置和方向。当由`LiveDrawingView`类提示时，它将每秒更新自己大约60次。'
- en: Now, we can start coding.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编码。
- en: Coding the MainActivity class
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写MainActivity类
- en: Let's get started with coding the `Activity`-based class. As usual, the class
    is called `MainActivity`, and it was autogenerated for us when we created the
    project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写基于`Activity`的类。通常情况下，这个类被称为`MainActivity`，当我们创建项目时，它是自动生成的。
- en: 'Edit the class declaration and add the first part of the code for the `MainActivity`
    class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑类声明并添加`MainActivity`类的代码的第一部分：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code shows several errors that we will talk about shortly. The
    first thing to note is that we are declaring an instance of our `LiveDrawingView`
    class. Currently, this is an empty class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们将很快讨论的几个错误。首先要注意的是，我们正在声明`LiveDrawingView`类的一个实例。目前，这是一个空类：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next code gets the number of pixels (horizontally and vertically) for the
    device in the following way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码以以下方式获取设备的像素数（水平和垂直）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create an object of the `Display` type, called `display`, and initialize
    it with `windowManager.defaultDisplay`, which is part of the `Activity` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`display`的`Display`类型的对象，并用`windowManager.defaultDisplay`进行初始化，这是`Activity`类的一部分。
- en: Then, we create a new object, called `size`, of the `Point` type. We send `size`
    as an argument to the `display.getSize` function. The `Point` type has an `x`
    and `y` property and, therefore, so does the `size` object, which, after the third
    line of code, now holds the width and height (in pixels) of the display. Now,
    we have the screen resolution in the `x` and `y` properties tucked away in the
    `size` object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`size`的`Point`类型的新对象。我们将`size`作为参数发送到`display.getSize`函数。`Point`类型有`x`和`y`属性，因此`size`对象也有这些属性，在第三行代码之后，`size`现在保存了显示的宽度和高度（以像素为单位）。现在，我们在`size`对象的`x`和`y`属性中有了屏幕分辨率。
- en: 'Next, in `onCreate`, we initialize `liveDrawingView` as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`onCreate`中，我们初始化`liveDrawingView`如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What we are doing is passing two arguments to the `LiveDrawingView` constructor.
    We have obviously not coded a constructor yet and, as we know, the default constructor
    takes zero arguments. Therefore, this line will cause an error until we fix this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向`LiveDrawingView`构造函数传递两个参数。显然，我们还没有编写构造函数，而且我们知道，默认构造函数不带参数。因此，在我们解决这个问题之前，这行代码将导致错误。
- en: The arguments that are passed in are interesting. First, `this`, which is a
    reference to `MainActivity`. The `LiveDrawingView` class will need to perform
    actions (use some functions) that it needs this reference for.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的参数很有趣。首先是`this`，它是对`MainActivity`的引用。`LiveDrawingView`类将需要执行一些操作（使用一些函数），它需要这个引用。
- en: The second argument is the horizontal screen resolution. It makes sense that
    our app will need these to perform tasks, such as scaling the other drawing objects
    to an appropriate size. We will discuss these arguments further when we get to
    coding the `LiveDrawingView` constructor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是水平屏幕分辨率。我们的应用程序需要这些参数来执行任务，例如将其他绘图对象缩放到适当的大小。当我们开始编写`LiveDrawingView`的构造函数时，我们将进一步讨论这些参数。
- en: 'Now, take a look at the even stranger line that follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下接下来的更奇怪的一行：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is where, in the Canvas Demo app, we set `ImageView` as the content for
    the app. Remember that the `Activity` class's `setContentView` function must take
    a `View` object, and `ImageView` is a `View` object. This preceding line of code
    seems to be suggesting that we will use our `LiveDrawingView` class as the visible
    content for the app? But `LiveDrawingView`, despite its name, isn't a `View` object.
    That is, at least not yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Canvas Demo应用程序中，我们将`ImageView`设置为应用程序的内容。请记住，`Activity`类的`setContentView`函数必须接受一个`View`对象，而`ImageView`是一个`View`对象。前面的代码似乎在暗示我们将使用`LiveDrawingView`类作为应用程序的可见内容？但是`LiveDrawingView`，尽管名字是这样，却不是一个`View`对象。至少目前还不是。
- en: We will fix the constructor and the not-a-`View` problem after we add a few
    more lines of code to `MainActivity`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向`MainActivity`添加几行代码之后，我们将解决构造函数和不是`View`类型的问题。
- en: 'Add these two overridden functions and then we will talk about them. Add them
    underneath the closing curly brace of `onCreate`, but before the closing curl
    `MainActivity`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两个重写的函数，然后我们将讨论它们。将它们添加到`onCreate`的闭合大括号下面，但在`MainActivity`的闭合大括号之前：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have done here is override two more of the functions of the `Activity`
    class. We will see why we need to do this and what we will do inside these functions.
    The point to note is that by adding these overridden functions, we are giving
    the OS the opportunity to notify us of the user's intentions in two more situations,
    in the same way as we did when saving and loading our data in the Note to self
    app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是重写`Activity`类的另外两个函数。我们将看到为什么需要这样做以及我们将在这些函数中做什么。需要注意的是，通过添加这些重写的函数，我们给了操作系统在两种情况下通知我们用户意图的机会，就像我们在Note
    to self应用程序中保存和加载数据时所做的那样。
- en: It makes sense at this point to move on to the `LiveDrawingView` class, which
    is the most significant class of this app. We will `MainActivity` toward the end
    of the chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，继续前进到这个应用程序最重要的类`LiveDrawingView`。我们将在本章末尾讨论`MainActivity`。
- en: Coding the LiveDrawingView class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写LiveDrawingView类
- en: 'The first thing we will do is solve the problem of our `LiveDrawingView` class
    not being of the `View` type and having the wrong constructor. Update the class
    declaration as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是解决`LiveDrawingView`类不是`View`类型并且具有错误构造函数的问题。更新类声明如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will be prompted to import the `android.view.SurfaceView` class, as shown
    in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示导入`android.view.SurfaceView`类，如下截图所示：
- en: '![Coding the LiveDrawingView class](img/B12806_21_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![编写LiveDrawingView类](img/B12806_21_01.jpg)'
- en: Click on **OK** to confirm.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**以确认。
- en: '`SurfaceView` is a descendant of `View` and now `LiveDrawingView` is, by inheritance,
    also a type of `View`. Look at the `import` statement that has been added. This
    relationship is made clear, as highlighted in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceView`是`View`的后代，现在`LiveDrawingView`也是`View`的一种类型，通过继承。看一下已添加的`import`语句。这种关系在下面的代码中得到了明确的说明：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that it is because of polymorphism that we can send descendants of
    `View` to the `setContentView` function in the `MainActivity` class, and that
    it is because of inheritance that `LiveDrawingView` is now a type of `SurfaceView`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正是由于多态性，我们可以将`View`的后代发送到`MainActivity`类的`setContentView`函数中，而正是由于继承，`LiveDrawingView`现在是`SurfaceView`的一种类型。
- en: There are quite a few descendants of `View` that we could have extended to fix
    this initial problem, but we will see as we continue that `SurfaceView` has some
    very specific features that are perfect for real-time interactive apps and make
    this the right choice for us. We have also provided a constructor that matches
    the arguments called from `MainActivity`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多`View`的后代可以扩展以解决这个初始问题，但是随着我们的继续，我们将看到`SurfaceView`具有一些非常特定的功能，非常适合实时交互应用程序，并且这对我们来说是正确的选择。我们还提供了一个与从`MainActivity`调用的参数匹配的构造函数。
- en: 'To import the `Context` class, follow these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入`Context`类，请按照以下步骤操作：
- en: Place the mouse cursor on the red-colored `Context` text in the new constructor's
    signature.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标光标放在新构造函数签名中红色的`Context`文本上。
- en: Hold the *Alt* key and tap the *Enter* key. Choose **Import Class** from the
    pop-up options.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Alt*键并点击*Enter*键。从弹出选项中选择**导入类**。
- en: The previous steps will import the `Context` class. Now, we have no errors in
    our `LiveDrawingView` class or the `MainActivity` class that initializes it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤将导入`Context`类。现在，我们的`LiveDrawingView`类或初始化它的`MainActivity`类中都没有错误。
- en: At this stage, we could run the app and see that using `LiveDrawingView` as
    the `View` argument in `setContentView` has worked and that we have a beautiful
    blank screen, which is ready to draw our particle systems on. You can try this
    if you wish to, but we will be coding the `LiveDrawingView` class so that it does
    something next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以运行应用程序，看看使用`LiveDrawingView`作为`setContentView`中的`View`参数是否有效，并且我们有一个美丽的空白屏幕，准备在上面绘制我们的粒子系统。如果你愿意，你可以尝试一下，但我们将编写`LiveDrawingView`类，以便它接下来会做一些事情。
- en: Remember that `LiveDrawingView` cannot see the variables in `MainActivity`.
    By using the constructor, `MainActivity` is providing `LiveDrawingView` with a
    reference to itself (`this`) as well as the screen resolution in pixels contained
    in `size.x`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`LiveDrawingView`无法看到`MainActivity`中的变量。通过构造函数，`MainActivity`提供了一个对自身（`this`）的引用以及包含在`size.x`中的像素屏幕分辨率给`LiveDrawingView`。
- en: We will be returning to this class constantly over the course of this project.
    What we will do right now is get the fundamentals set up ready to add the `ParticleSystem`
    instances after we have coded them in the next chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的过程中，我们将不断回到这个类。我们现在要做的是准备好设置基础，以便在下一章编写`ParticleSystem`实例后添加它们。
- en: To achieve this, we will first add a number of properties. Following this, we
    will get to code the `draw` function, which will reveal the new steps that we
    need to take to draw on the screen 60 times per second. Additionally, we will
    see some familiar code that uses our old friends, `Canvas`, `Paint`, and `drawText`,
    from the previous chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先会添加一些属性。之后，我们将编写`draw`函数，它将揭示我们需要在屏幕上每秒绘制60次的新步骤。此外，我们将看到一些使用我们上一章的老朋友`Canvas`、`Paint`和`drawText`的熟悉代码。
- en: At this point, we will need to discuss some more theory; items such as how we
    will time the animations of the particles, and how we can lock these timings without
    interfering with the smooth running of Android. These last two topics, that is,
    the **game loop** and **threads,** will then allow us to add the final code of
    the chapter and witness our particle system painting app in action, albeit with
    just a bit of text.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要讨论一些更多的理论；例如，我们将如何计时粒子的动画，以及如何在不干扰Android的平稳运行的情况下锁定这些时间。这最后两个主题，即**游戏循环**和**线程**，将允许我们在添加本章的最终代码并观察我们的粒子系统绘画应用程序的同时，尽管只有一点点文本。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A game loop is a concept that describes allowing virtual systems to update and
    draw themselves at the same time as allowing them to be altered and interacted
    with by the user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是一个描述允许虚拟系统同时更新和绘制自身的概念，同时允许用户对其进行修改和交互。
- en: Adding the properties
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加属性
- en: 'Add the properties after the `LiveDrawingView` declaration and constructor
    that we have coded, as demonstrated in the following code block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写的`LiveDrawingView`声明和构造函数之后添加属性，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure that you study the code, and then we will talk about it. Notice that
    all the properties are declared `private`. You can happily delete all the `private`
    access specifiers and the code will still work but, as we have no need to access
    any of these properties from outside of this class, it is sensible to guarantee
    that this can never happen by declaring them `private`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你学习了代码，然后我们会讨论它。注意所有的属性都声明为`private`。你可以愉快地删除所有的`private`访问修饰符，代码仍然可以正常工作，但是，由于我们不需要从这个类的外部访问任何这些属性，所以通过声明它们为`private`来保证这永远不会发生是明智的。
- en: The first property is `debugging`. We will use this so that we can manually
    switch between printing debugging information and not printing debugging information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性是`debugging`。我们将使用它来手动切换打印调试信息和不打印调试信息。
- en: 'The following two classes that we declared instances of will handle the drawing
    on the screen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的两个类实例将处理屏幕上的绘制：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following two properties will give us a bit of insight into what we need
    to achieve our smooth and consistent animation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个属性将为我们提供一些关于我们需要实现平滑和一致动画的见解：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both properties are of the `long` type because they will be holding a large
    number that we will use to measure time. Computers measure time based on the number
    of milliseconds since 1970\. We will discuss this more when we learn about the
    game loop; however, for now, we need to know that monitoring and measuring the
    speed of each frame of animation is how we will make sure that the particles move
    exactly as they should.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性都是`long`类型，因为它们将保存一个我们将用来测量时间的大数字。计算机根据自1970年以来的毫秒数来测量时间。我们将在学习游戏循环时更多地讨论这个问题；然而，现在，我们需要知道监视和测量每一帧动画的速度是如何确保粒子移动正如它们应该的。
- en: The first variable, `fps`, will be reinitialized in every frame of animation
    at approximately 60 times per second. It will be passed into each of the `ParticleSystem`
    objects (every frame of animation) so that they know how much time has elapsed,
    and can then calculate how far to move or not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量`fps`将在每一帧动画中重新初始化，大约每秒60次。它将被传递到每个`ParticleSystem`对象（每一帧动画）中，以便它们知道经过了多少时间，然后可以计算应该移动多远或不移动。
- en: The `millisInSecond` variable is initialized to `1000`. There are indeed `1000`
    milliseconds in a second. We will use this variable in calculations as it will
    make our code clearer than if we used the literal value, 1,000\.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`millisInSecond`变量初始化为`1000`。一秒钟确实有`1000`毫秒。我们将在计算中使用这个变量，因为它会使我们的代码比使用字面值1,000更清晰。'
- en: 'The next part of the code that we just added is shown here for convenience:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码的下一部分如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `fontSize` and `marginSize` properties will be initialized, based on the
    screen resolution in pixels that were passed in through the constructor (`screenX`).
    They will hold a value in pixels to make the formatting of our text neat and more
    concise, rather than constantly doing calculations for each bit of text.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontSize`和`marginSize`属性将根据通过构造函数传入的像素屏幕分辨率（`screenX`）进行初始化。它们将保存以像素为单位的值，以使我们的文本格式整洁而简洁，而不是为每个文本部分不断进行计算。'
- en: 'Before we move on, we should make clear that these are the `import` statements
    that you should currently have at the top of the `LiveDrawingView.kt` code file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该明确一下，这些是您目前应该在`LiveDrawingView.kt`代码文件顶部拥有的`import`语句：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's get ready to draw.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备好绘制。
- en: Coding the draw function
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写draw函数
- en: 'Add the `draw` function immediately after the properties that we just added.
    There will be a couple of errors in the code. We will deal with them first, and
    then we will go into detail about how the `draw` function will work in relation
    to `SurfaceView` because there are a number of alien-looking lines of code in
    there, as well as some familiar ones. Add the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的属性之后立即添加`draw`函数。代码中会有一些错误。我们将首先处理它们，然后我们将详细讨论`draw`函数与`SurfaceView`的关系，因为其中有一些看起来很陌生的代码行，以及一些熟悉的代码行。添加以下代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have two errors – one error is that the `Color` class needs importing. You
    can fix this in the usual way or add the next line of code manually. Whatever
    method you choose, the following extra line needs to be added to the code at the
    top of the file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个错误 - 一个错误是需要导入`Color`类。您可以按照通常的方式修复这个问题，或者手动添加下一行代码。无论您选择哪种方法，以下额外的行需要添加到文件顶部的代码中：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's now deal with the other error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理另一个错误。
- en: Adding the printDebuggingText function
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加printDebuggingText函数
- en: 'The second error is the call to `printDebuggingText`. The function doesn''t
    exist yet; so, let''s add that now. Add the code after the `draw` function, as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误是调用`printDebuggingText`。该函数尚不存在，所以现在让我们添加它。按照以下方式在`draw`函数之后添加代码：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code uses the local `debugSize` variable to hold a value that is
    half that of the `fontSize` property. This means that as `fontSize` (which is
    used for the **HUD**) is initialized dynamically based on the screen resolution,
    `debugSize` will always be half of that.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码使用本地的`debugSize`变量来保存`fontSize`属性值的一半。这意味着，由于`fontSize`（用于**HUD**）是根据屏幕分辨率动态初始化的，`debugSize`将始终是其一半。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: HUD stands for Heads Up Display and is a fancy way of referring to the buttons
    and text that overlays the other objects in the app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HUD代表抬头显示，是指覆盖应用程序中其他对象的按钮和文本的一种花哨方式。
- en: The `debugSize` variable is then used to set the size of the font before we
    start drawing the text. The `debugStart` variable is a guess at a tidy vertical
    position to start printing the debugging text with a bit of padding so that it
    isn't squashed too close to the edge of the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`debugSize`变量来设置字体的大小，然后开始绘制文本。`debugStart`变量是一个整洁的垂直位置的猜测，用于开始打印调试文本，并留有一些填充，以免它被挤得太靠近屏幕边缘。
- en: These two values are then used to position a line of text on the screen that
    shows the current frames per second. As this function is called from `draw`, which,
    in turn, will be called from the game loop, this line of text will be constantly
    refreshed up to 60 times per second.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这两个值来定位屏幕上显示当前每秒帧数的一行文本。由于此函数是从`draw`调用的，而`draw`又将从游戏循环中调用，因此这行文本将每秒刷新多达60次。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible that on very high- or very low-resolution screens, you might
    need to experiment with this value to find something that works for your screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高或非常低分辨率屏幕上，您可能需要尝试不同的值，以找到适合您屏幕的值。
- en: Let's explore these new lines of code in the `draw` function and examine exactly
    how we can use `SurfaceView`, from which our `LiveDrawingView` class is derived,
    to handle all our drawing requirements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`draw`函数中的这些新代码行，并确切地检查我们如何使用`SurfaceView`来处理所有绘图需求，从而处理我们的`LiveDrawingView`类的派生。
- en: Understanding the draw function and the SurfaceView class
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解draw函数和SurfaceView类
- en: 'Starting in the middle of the function and working outward for a change, we
    have a few familiar things, such as the calls to `drawColor`, and then we set
    the color and text size as we have before. We can also see the comment that indicates
    where we will eventually add the code to draw the particle systems and the HUD:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数的中间开始，向外工作，我们有一些熟悉的东西，比如调用`drawColor`，然后我们像以前一样设置颜色和文本大小。我们还可以看到注释，指示我们最终将添加绘制粒子系统和HUD的代码的位置：
- en: The `drawColor` code clears the screen with a solid color.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawColor`代码用纯色清除屏幕。'
- en: The `textSize` property of `paint` sets the size of the text for drawing the
    HUD.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paint`的`textSize`属性设置了绘制HUD的文本大小。'
- en: We will code the process of drawing the HUD once we have explored particle systems
    a little more. We will let the player know how many particles and systems their
    drawing is comprised of.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们更深入地探索了粒子系统，我们将编写绘制HUD的过程。我们将让玩家知道他们的绘图由多少个粒子和系统组成。
- en: 'What is completely new, however, is the code at the very start of the `draw`
    function, as shown in the following code block:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完全新的是`draw`函数开头的代码，如下面的代码块所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `if` condition is `holder.surface.isValid`. If this line returns true, it
    confirms that the area of memory that we want to manipulate to represent our frame
    of drawing is available, and then the code continues inside the `if` statement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件是`holder.surface.isValid`。如果这行返回true，则确认我们要操作的内存区域以表示我们的绘图帧是可用的，然后代码继续在`if`语句内部。'
- en: This is necessary because all our drawing and other processing (such as moving
    the objects) will take place asynchronously with the code that detects the user
    input and listens to the OS for messages. This wasn't an issue in the previous
    project because our code simply sat there waiting for input, drew a single frame,
    and then sat there waiting again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们所有的绘图和其他处理（比如移动对象）都将异步进行，而代码则会检测用户输入并监听操作系统的消息。这在以前的项目中不是问题，因为我们的代码只是坐在那里等待输入，绘制一个帧，然后再次坐在那里等待。
- en: Now that we want to continuously execute the code 60 times per second, we are
    going to need to confirm that we have access to the memory where the graphics
    are drawn to, before we access it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要每秒连续执行60次代码，我们需要确认我们能够访问绘图的内存，然后再访问它。
- en: This raises another question about how this code runs asynchronously. But that
    will be answered when we discuss threads shortly. For now, just know that the
    line of code checks whether another part of our code, or Android itself, is currently
    using the required portion of memory. If it is free, then the code inside the
    `if` statement executes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了另一个关于这段代码如何异步运行的问题。但这将在我们不久后讨论线程时得到解答。现在，只需知道这行代码检查另一部分我们的代码或Android本身是否正在使用所需的内存部分。如果空闲，那么`if`语句内的代码将执行。
- en: Furthermore, the first line of code to execute inside the `if` statement calls
    `lockCanvas`, so that if another part of the code tries to access the memory while
    our code is accessing it, it won't be able to – and then we do all our drawing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`if`语句内执行的第一行代码调用`lockCanvas`，这样如果代码的另一部分在我们访问内存时尝试访问内存，它将无法访问 - 然后我们进行所有的绘制。
- en: 'Finally, in the `draw` function, the following line of code (plus comments)
    appears right at the end:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`draw`函数中，以下代码（加上注释）出现在最后：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `unlockCanvasAndPost` function sends our newly decorated `Canvas` object
    (`canvas`) for drawing to the screen and releases the lock so that other areas
    of code can use it, albeit very briefly, before the whole process starts again.
    This process happens for every single frame of animation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`unlockCanvasAndPost`函数将我们新装饰的`Canvas`对象（`canvas`）发送到屏幕上进行绘制，并释放锁定，以便其他代码区域可以使用它，尽管非常短暂，在整个过程开始之前。这个过程发生在每一帧动画中。'
- en: We now understand the code in the `draw` function. However, we still don't have
    the mechanism that calls the `draw` function over and over. In fact, we don't
    even call the `draw` function once. Next, we will discuss game loops and threads.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了`draw`函数中的代码。然而，我们仍然没有调用`draw`函数的机制。事实上，我们甚至没有调用`draw`函数一次。接下来，我们将讨论游戏循环和线程。
- en: The game loop
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: So, what is a game loop anyway? Almost every live drawing, graphics-based app,
    and game has a game loop. Even games that you might not expect, such as turn-based
    games, still need to synchronize player input with drawing and AI, while following
    the rules of the underlying OS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，游戏循环到底是什么？几乎每个实时绘图、基于图形的应用程序和游戏都有一个游戏循环。甚至你可能没有想到的游戏，比如回合制游戏，仍然需要将玩家输入与绘图和人工智能同步，同时遵循底层操作系统的规则。
- en: 'There is a constant need to update the objects in the app, such as by moving
    them and drawing everything in its current position while simultaneously responding
    to user input:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的对象需要不断更新，比如移动它们并在当前位置绘制所有内容，同时响应用户输入：
- en: '![The game loop](img/B12806_21_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环](img/B12806_21_03.jpg)'
- en: 'Our game loop comprises three main phases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环包括三个主要阶段：
- en: Update all game and drawing objects by moving them, detecting collisions, and
    processing the AI, such as particle movements and state changes
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过移动它们、检测碰撞和处理人工智能（如粒子运动和状态变化）来更新所有游戏和绘图对象
- en: Based on the data that has just been updated, draw the frame of animation in
    its latest state
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据刚刚更新的数据，绘制动画的最新状态帧
- en: Respond to screen touches from the user
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应用户的屏幕触摸
- en: We already have a `draw` function for handling this part of the loop. This suggests
    that we will have a function to do all the updating as well. We will soon code
    the outline of an `update` function. In addition, we know that we can respond
    to screen touches, although we will need to adapt slightly from all the previous
    projects because we are no longer working inside an `Activity` class or using
    conventional UI widgets from a layout.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个`draw`函数来处理循环的这一部分。这表明我们将有一个函数来进行所有的更新。我们很快将编写一个`update`函数的大纲。此外，我们知道我们可以响应屏幕触摸，尽管我们需要稍微调整之前所有项目的方式，因为我们不再在`Activity`类内部工作，也不再使用布局中的传统UI小部件。
- en: There is a further issue in that (as I briefly mentioned) all the updating and
    drawing happens asynchronously to detect screen touches and listen to the OS.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题，就是（我简要提到过的）所有的更新和绘制都是异步进行的，以便检测屏幕触摸并监听操作系统。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just to be clear, asynchronous means that it does not occur at the same time.
    Our code will work by sharing execution time with Android and the UI. The CPU
    will very quickly switch back and forth between our code and Android or user input.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了明确，异步意味着它不会同时发生。我们的代码将通过与Android和UI共享执行时间来工作。CPU将在我们的代码、Android或用户输入之间非常快速地来回切换。
- en: But how exactly will these three phases be looped through? How will we code
    this asynchronous system, from which `update` and `draw` can be called, and how
    will we make the loop run at the correct speed (or frame rate)?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但这三个阶段将如何循环？我们将如何编写这个异步系统，从中可以调用`update`和`draw`，并且如何使循环以正确的速度（或帧率）运行？
- en: As you can probably guess, writing an efficient game loop is not as simple as
    a `while` loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，编写一个高效的游戏循环并不像一个`while`循环那样简单。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our game loop will, however, also contain a `while` loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的游戏循环也将包含一个`while`循环。
- en: We need to consider timing, starting, and stopping the loop, in addition to
    not causing the OS to become unresponsive because we are monopolizing the entire
    CPU within our single loop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑时间、开始和停止循环，以及不会导致操作系统变得无响应，因为我们正在独占整个CPU在我们的单个循环中。
- en: 'But when and how do we call our `draw` function? How do we measure and keep
    track of the frame rate? With these things in mind, our finished game loop is
    probably better represented by the following diagram – notice the introduction
    to the concept of **threads**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们何时以及如何调用我们的`draw`函数？我们如何测量和跟踪帧速率？考虑到这些问题，我们完成的游戏循环可能更好地由以下图表表示——注意引入**线程**的概念：
- en: '![The game loop](img/B12806_21_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环](img/B12806_21_04.jpg)'
- en: Now that we know what we want to achieve, let's learn about threads.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们想要实现什么，那么让我们学习一下线程。
- en: Threads
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: So, what is a thread? You can think of threads in programming in the same way
    as you do threads in a story. In one thread of a story, we might have the primary
    character battling the enemy on the frontline, while in another thread, the soldier's
    family are living, day to day. Of course, a story doesn't have to have only two
    threads – we could introduce a third thread. For instance, the story also tells
    of the politicians and military commanders making decisions, and these decisions
    then subtly, or not so subtly, affect what happens in the other threads.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是线程？你可以把编程中的线程看作是故事中的线程。在故事的一个线程中，我们可能有主要角色在前线与敌人作战，而在另一个线程中，士兵的家人正在过着日常生活。当然，一个故事不一定只有两个线程——我们可以引入第三个线程。例如，故事还讲述了政治家和军事指挥官做出决策，这些决策会以微妙或不那么微妙的方式影响其他线程中发生的事情。
- en: 'Programming threads are just like this. We create parts or threads in our program
    that control different aspects for us. In Android, threads are especially useful
    when we need to ensure that a task does not interfere with the main (UI) thread
    of the app, or if we have a background task that takes a long time to complete
    and must not interrupt the main thread of execution. We introduce threads to represent
    these different aspects for the following reasons:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编程线程就像这样。我们在程序中创建部分或线程来控制不同的方面。在Android中，当我们需要确保一个任务不会干扰应用程序的主（UI）线程时，或者当我们有一个需要很长时间才能完成并且不能中断主线程执行的后台任务时，线程尤其有用。我们引入线程来代表这些不同的方面，原因如下：
- en: They make sense from an organizational point of view
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组织的角度来看，这是有道理的
- en: They are a proven way of structuring a program that works
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一种经过验证的构建程序的方法。
- en: The nature of the system we are working on forces us to use them anyway
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在处理的系统的性质迫使我们无论如何都要使用它们
- en: In Android, we use threads for all three reasons simultaneously – because it
    makes sense, it works, and we must use threads since the design of the Android
    system requires it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们同时出于这三个原因使用线程——因为这是有道理的，它有效，而且我们必须使用线程，因为Android系统的设计要求如此。
- en: Often, we use threads without knowing it. This happens because we use classes
    that use threads on our behalf. All the animations that we coded in [Chapter 19](ch19.html
    "Chapter 19. Animations and Interpolations"), *Animations and Interpolations*,
    were all running in threads. Another such example in Android is the `SoundPool`
    class, which loads sound in a thread. We will see, or rather hear, `SoundPool`
    in action in [Chapter 23](ch23.html "Chapter 23. Android Sound Effects and the
    Spinner Widget"), *Android Sound Effects and the Spinner Widget*. We will see
    again that our code doesn't have to handle the aspects of threads that we are
    about to learn about because it is all handled internally by the class. In this
    project, however, we need to get a bit more involved.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在不知情的情况下使用线程。这是因为我们使用的类会代表我们使用线程。我们在[第19章](ch19.html "第19章。动画和插值")中编写的所有动画，*动画和插值*，都在线程中运行。在Android中的另一个例子是`SoundPool`类，它在一个线程中加载声音。我们将在[第23章](ch23.html
    "第23章。Android音效和Spinner小部件")中看到，或者说听到，`SoundPool`的作用，*Android音效和Spinner小部件*。我们将再次看到，我们的代码不必处理我们即将学习的线程方面，因为这一切都由类内部处理。然而，在这个项目中，我们需要更多地参与其中。
- en: In real-time systems, think about a thread that is receiving the player's button
    taps for moving left and right at the same time as listening for messages from
    the OS, such as calling `onCreate` (and other functions that we will see later)
    as one thread, and another thread that draws all the graphics and calculates all
    the movements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时系统中，想象一下一个线程同时接收玩家的左右移动按钮点击，同时监听来自操作系统的消息，比如调用`onCreate`（以及我们稍后将看到的其他函数）的一个线程，以及另一个线程绘制所有图形并计算所有移动。
- en: Problems with threads
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程的问题
- en: Programs with multiple threads can have problems associated with them, such
    as the threads of a story; if proper synchronization does not occur, then things
    can go wrong. What if our soldier went into battle before the battle or the war
    even existed?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个线程的程序可能会出现与之相关的问题，就像故事的线程一样；如果适当的同步没有发生，那么事情可能会出错。如果我们的士兵在战斗甚至战争之前就进入了战斗，会发生什么？
- en: Consider that we have a variable, `Int x`, that represents a key piece of data
    that three threads of our program use. What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness** caused by multiple threads racing to completion
    while remaining oblivious – because, after all, they are just dumb code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个变量，`Int x`，代表我们程序的三个线程使用的一个关键数据。如果一个线程稍微超前于自己，并使数据对其他两个线程来说“错误”会发生什么？这个问题是由多个线程竞争完成而保持无视而引起的**正确性**问题——因为毕竟，它们只是愚蠢的代码。
- en: The problem of correctness can be solved by close oversight of the threads and
    locking. **Locking** means temporarily preventing execution in one thread to make
    sure that things are working in a synchronized manner; this is similar to preventing
    a soldier from boarding a ship to war until the ship has docked and the gangplank
    has been lowered, thereby avoiding an embarrassing splash.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性问题可以通过对线程和锁定的密切监督来解决。**锁定**意味着暂时阻止一个线程的执行，以确保事情以同步的方式工作；这类似于防止士兵在战船靠岸并放下舷梯之前登船，从而避免尴尬的溅水。
- en: The other problem with programs with multiple threads is the problem of **deadlock**.
    Here, one or more threads become locked, waiting for the "right" moment to access
    `Int x`; however, that moment never comes and, eventually, the entire program
    grinds to a halt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序的另一个问题是**死锁**问题。在这种情况下，一个或多个线程被锁定，等待“正确”的时刻来访问`Int x`；然而，那个时刻永远不会到来，最终整个程序都会停滞不前。
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，第一个问题（正确性）的解决方案是第二个问题（死锁）的原因。
- en: Fortunately, the problem has been solved for us. In the same way that we use
    the `Activity` class and override `onCreate` to know exactly when we need to create
    our app, we can also use other classes to create and manage our threads. For example,
    with `Activity,` we only need to know how to use them, not how they work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题已经为我们解决了。就像我们使用`Activity`类并重写`onCreate`来知道何时需要创建我们的应用程序一样，我们也可以使用其他类来创建和管理我们的线程。例如，对于`Activity`，我们只需要知道如何使用它们，而不需要知道它们是如何工作的。
- en: 'So, why did I tell you about threads when you don''t need to know about them,
    you rightly ask? This is simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We can then achieve the following goals:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当你不需要了解它们时，我为什么要告诉你关于线程呢？这只是因为我们将编写看起来不同并且结构不熟悉的代码。我们可以实现以下目标：
- en: Understand the general concept of a thread in that it is the same as a story
    thread that happens almost simultaneously
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程的一般概念，它与几乎同时发生的故事线程相同
- en: Learn the few rules of using a thread
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用线程的几条规则
- en: By doing so, we will have no difficulty in writing our Kotlin code to create
    and work within our threads. There are a few different Android classes that handle
    threads, and different thread classes work best in different situations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将毫无困难地编写我们的Kotlin代码来创建和在我们的线程中工作。Android有几个不同的类来处理线程，不同的线程类在不同的情况下效果最好。
- en: All we need to remember is that we will be writing parts of our program that
    run at *almost* the same time as each other.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的是，我们将编写程序的部分，它们几乎同时运行。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What do you mean by almost? What is happening is that the CPU switches between
    threads in turn/asynchronously. However, this happens so fast that we will not
    be able to perceive anything but simultaneity/synchrony. Of course, in the story
    thread analogy, people do act entirely synchronously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎是什么意思？发生的是CPU在线程之间轮换/异步地。然而，这发生得如此之快，以至于我们除了同时性/同步性之外无法感知任何东西。当然，在故事线程的类比中，人们确实是完全同步地行动。
- en: 'Let''s take a glimpse of what our thread code will look like. Don''t add any
    code to the project just yet. We can then declare an object of the `Thread` type,
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的线程代码将是什么样子。现在先不要向项目添加任何代码。我们可以声明一个`Thread`类型的对象，如下所示：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can then initialize and start it as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以按以下方式初始化并启动它：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is one more conundrum to threads; take another look at the constructor
    that initializes the thread. Here is the line of code again for your convenience:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 线程还有一个谜团；再看一下初始化线程的构造函数。以下是代码行，以方便你查看：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Take a look at the argument that is passed to the constructor; we pass in `this`.
    Remember that the code is going inside the `LiveDrawingView` class, not `MainActivity`.
    We can, therefore, surmise that `this` is a reference to a `LiveDrawingView` class
    (which extends `SurfaceView`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下传递给构造函数的参数；我们传入了`this`。请记住，代码是放在`LiveDrawingView`类中的，而不是`MainActivity`。因此，我们可以推断`this`是对`LiveDrawingView`类（它扩展了`SurfaceView`）的引用。
- en: It seems very unlikely that when the engineers at Android HQ wrote the `Thread`
    class, they would have been aware that one day, we would be writing our `LiveDrawingView`
    class. So, how can this work?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android总部的工程师编写`Thread`类时，他们很可能不会意识到有一天我们会编写我们的`LiveDrawingView`类。那么，这怎么可能呢？
- en: The `Thread` class needs an entirely different type to be passed into its constructor.
    The `Thread` constructor needs a `Runnable` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类需要传入一个完全不同的类型到它的构造函数。`Thread`构造函数需要一个`Runnable`对象。'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can confirm this fact by referring to the `Thread` class on the Android
    developer''s website here: [https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看Android开发者网站上的`Thread`类来确认这一事实：[https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable))。
- en: Do you recall that we discussed interfaces in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*?
    As a reminder, we can implement an interface by adding the interface name after
    the class declaration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和空值")中讨论过接口吗，*将我们的Kotlin连接到UI和空值*？作为提醒，我们可以通过在类声明后添加接口名称来实现接口。
- en: We must then implement the abstract functions of the interface. `Runnable` has
    just one; it is the `run` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须实现接口的抽象函数。`Runnable`只有一个函数，就是`run`函数。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can confirm this preceding fact by looking at the `Runnable` interface
    on the Android developer''s website here: [https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看Android开发者网站上的`Runnable`接口来确认这个事实：[https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html)。
- en: 'We can then use the `override` keyword to change what happens when the OS allows
    our thread object to run its code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`override`关键字来改变当操作系统允许我们的线程对象运行其代码时发生的情况：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Within the overridden `run` function, we will call two functions, one that
    we have started already, `draw`, and the other is `update`. The `update` function
    is where all our calculations and AI will go. The code will be similar to the
    following block, but don''t add it yet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写的“run”函数中，我们将调用两个函数，一个是我们已经开始的“draw”，另一个是“update”。 “update”函数是我们所有计算和人工智能的地方。代码将类似于以下代码块，但现在不要添加：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When appropriate, we can also stop our thread as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的时候，我们也可以停止我们的线程，如下所示：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, everything that is in the `run` function is executing in a separate thread,
    leaving the default or UI thread to listen for touches and system events. We will
    see how the two threads communicate with each other in the drawing project shortly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“run”函数中的所有内容都在一个单独的线程中执行，使默认或UI线程监听触摸和系统事件。我们很快将看到这两个线程如何相互通信在绘图项目中。
- en: Note that precisely where all these parts of the code will go in our app has
    not been explained, but it is so much easier to show you in the real project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的应用程序中所有这些代码的确切位置尚未解释，但在真实项目中向您展示会更容易。
- en: Implementing the game loop with a thread
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程实现游戏循环
- en: Now that we have learned about the game loop and threads, we can put it all
    together to implement our game loop in the Living Drawing project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了游戏循环和线程，我们可以将它们全部整合到Living Drawing项目中来实现我们的游戏循环。
- en: We will add the entire code for the game loop, including writing code in two
    functions in the `MainActivity` class to start and stop the thread that will control
    the loop.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加整个游戏循环的代码，包括在“MainActivity”类中编写两个函数的代码，以启动和停止控制循环的线程。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Reader challenge**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者挑战**'
- en: Can you work out for yourself how the `Activity`-based class will start and
    stop the thread in the `LiveDrawingView` class?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您能自己想出“Activity”-based类将如何在“LiveDrawingView”类中启动和停止线程吗？
- en: Implementing Runnable and providing the run function
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Runnable并提供run函数
- en: 'Update the class declaration by implementing `Runnable`, as shown in the following
    highlighted code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现“Runnable”来更新类声明，如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we have a new error in the code. Hover the mouse cursor over the
    word `Runnable`, and you will see a message informing you that we need to implement
    the `run` function just as we discussed during the discussion on interfaces and
    threads in the previous section. Add the empty `run` function, including the `override`
    label.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中出现了一个新错误。将鼠标光标悬停在“Runnable”一词上，您将看到一条消息，告诉您我们需要实现“run”函数，就像我们在上一节关于接口和线程的讨论中讨论的那样。添加空的“run”函数，包括“override”标签。
- en: 'It doesn''t matter where you add it, provided that it is within the `LiveDrawingView`
    class''s curly braces and not inside another function. Add the empty `run` function,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在何处添加它，只要在“LiveDrawingView”类的大括号内而不是在另一个函数内。添加空的“run”函数，如下所示：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The error is gone and now we can declare and initialize a `Thread` object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 错误已经消失，现在我们可以声明和初始化一个“Thread”对象了。
- en: Coding the thread
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写线程
- en: 'Declare some variables and instances underneath all our other members in the
    `LiveDrawingView` class, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在“LiveDrawingView”类的所有其他成员下面声明一些变量和实例，如下所示：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we can start and stop the thread – take a moment to think about where we
    might do this. Remember that the app needs to respond to the OS that is starting
    and stopping the app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动和停止线程了-花点时间考虑我们可能在哪里这样做。请记住，应用程序需要响应启动和停止应用程序的操作系统。
- en: Starting and stopping the thread
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止线程
- en: 'Now, we need to start and stop the thread. We have seen the code that we need,
    but when and where should we do it? Let''s add code to two functions – one to
    start and one to stop – and then we can consider when and where to call these
    functions. Add these two functions inside the `LiveDrawingView` class. If their
    names sound familiar, it is not by chance:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要启动和停止线程。我们已经看到了我们需要的代码，但是何时何地应该这样做呢？让我们添加两个函数的代码-一个用于启动，一个用于停止-然后我们可以考虑何时何地调用这些函数。在“LiveDrawingView”类中添加这两个函数。如果它们的名称听起来很熟悉，那并非偶然：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What is happening is slightly given away by the comments. We now have a `pause`
    and `resume` function that stop and start the `Thread` object using the same code
    we discussed previously.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注释略微透露了发生的事情。现在我们有一个“pause”和“resume”函数，使用我们之前讨论过的相同代码来停止和启动“Thread”对象。
- en: Notice that the new functions are `public`, and therefore, they are accessible
    from outside the class to any other class that has an instance of `LiveDrawingView`.
    Remember that `MainActivity` holds the fully declared and initialized instance
    of `LiveDrawingView`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新函数是“public”的，因此它们可以从类外部访问，任何具有“LiveDrawingView”实例的其他类都可以访问。请记住，“MainActivity”保存了完全声明和初始化的“LiveDrawingView”实例。
- en: Let's use the Android Activity lifecycle to call these two new functions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Android Activity生命周期来调用这两个新函数。
- en: Using the Activity lifecycle to start and stop the thread
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Activity生命周期来启动和停止线程
- en: 'Update the overridden `onResume` and `onPause` functions in `MainActivity`,
    as shown in the following highlighted lines of code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更新“MainActivity”中重写的“onResume”和“onPause”函数，如下所示：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, our thread will be started and stopped when the OS is resuming and pausing
    our app. Remember that `onResume` is called after `onCreate` the first time that
    an app is started, not just after resuming from a pause. The code inside `onResume`
    and `onPause` uses the `liveDrawingView` object to call its `resume` and `pause`
    functions, which, in turn, has the code to start and stop the thread. This code
    then triggers the thread's `run` function to execute. It is in this `run` function
    (in `LiveDrawingView`) that we will code our game loop. Let's do that now.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的线程将在操作系统恢复和暂停我们的应用程序时启动和停止。请记住，“onResume”在应用程序首次启动时（不仅是从暂停恢复时）调用，而不仅仅是在从暂停恢复后调用。在“onResume”和“onPause”中的代码使用“liveDrawingView”对象调用其“resume”和“pause”函数，这些函数又调用启动和停止线程的代码。然后触发线程的“run”函数执行。就是在这个“run”函数（在“LiveDrawingView”中）中，我们将编写我们的游戏循环。现在让我们来做这个。
- en: Coding the run function
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写run函数
- en: 'Although our thread is set up and ready to go, nothing happens because the
    `run` function is empty. Code the `run` function, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的线程已经设置好并准备就绪，但由于`run`函数为空，所以什么也不会发生。编写`run`函数，如下所示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that there are two errors in Android Studio. This is because we have
    not written the `update` function yet. Let''s quickly add an empty function (with
    a comment) for it; I added mine after the `run` function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Android Studio中有两个错误。这是因为我们还没有编写`update`函数。让我们快速添加一个空函数（带有注释）；我在`run`函数后面添加了我的：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's discuss in detail how the code in the `run` function achieves the
    aims of our game loop by looking at the entire thing one step at a time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步详细讨论`run`函数中的代码如何通过一步一步的方式实现游戏循环的目标。
- en: 'This first part initiates a `while` loop with the `drawing` condition, and
    then wraps the rest of the code inside `run` so that the thread will need to be
    started (for `run` to be called) and `drawing` will need to be true for the `while`
    loop to execute:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一部分启动了一个`while`循环，条件是`drawing`，然后将代码的其余部分包装在`run`中，以便线程需要启动（调用`run`）并且`drawing`需要为`true`才能执行`while`循环：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first line of code inside the `while` loop declares and initializes a local
    variable, `frameStartTime`, with whatever the current time is. The `currentTimeMillis`
    function of the `System` class returns this value. If we later want to measure
    how long a frame has taken, then we need to know what time it started:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环内的第一行代码声明并初始化了一个名为`frameStartTime`的局部变量，其值为当前时间。`System`类的`currentTimeMillis`函数返回此值。如果以后我们想要测量一帧花费了多长时间，那么我们需要知道它开始的时间：'
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, still inside the `while` loop, we check whether the app is paused, and
    only if the app is not paused does this next code get executed. If the logic allows
    execution inside this block, then `update` is called:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`while`循环中，我们检查应用程序是否暂停，只有在应用程序没有暂停的情况下，才会执行下一段代码。如果逻辑允许在此块内执行，则调用`update`：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Outside of the previous `if` statement, the `draw` function is called to draw
    all the objects in the just-updated positions. At this point, another local variable
    is declared and initialized with the length of time that it took to complete the
    entire frame (updating and drawing). This value is calculated by getting the current
    time, once again with `currentTimeMillis`, and subtracting `frameStartTime` from
    it, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个`if`语句之外，调用`draw`函数以绘制所有对象的最新位置。此时，另一个局部变量被声明并初始化为完成整个帧（更新和绘制）所花费的时间长度。这个值是通过获取当前时间（再次使用`currentTimeMillis`）并从中减去`frameStartTime`来计算的，如下所示：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The next `if` statement detects whether `timeThisFrame` is greater than zero.
    It is possible for the value to be zero if the thread runs before the objects
    are initialized. If you look at the code inside the `if` statement, it calculates
    the frame rate by dividing the elapsed time by `millisInSecond`. If you divide
    by zero, the app will crash, which is why we perform the check.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`语句检测`timeThisFrame`是否大于零。如果线程在对象初始化之前运行，该值可能为零。如果您查看`if`语句内的代码，它通过将经过的时间除以`millisInSecond`来计算帧速率。如果除以零，应用程序将崩溃，这就是我们进行检查的原因。
- en: 'Once `fps` gets the value assigned to it, we can use it in the next frame to
    pass to the `update` function, which updates all the particles that we will code
    in the next chapter. They will use the value to make sure that they move by precisely
    the correct amount based on their target speed and the length of time the frame
    of animation that has just ended has taken:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`fps`获得了分配给它的值，我们可以在下一帧中使用它传递给`update`函数，该函数将更新我们将在下一章中编写的所有粒子。它们将使用该值来确保它们根据其目标速度和刚刚结束的动画帧的长度移动了精确的数量：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result of the calculation that initializes `fps` in each frame is that `fps`
    will hold a fraction of one. As the frame rate fluctuates, `fps` will hold a different
    value and supply the particle systems with the appropriate number to calculate
    each move.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中初始化`fps`的计算结果是，`fps`将保存一个分数。随着帧速率的波动，`fps`将保存不同的值，并为粒子系统提供适当的数量来计算每次移动。
- en: Running the app
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Click on the play button in Android Studio and the hard work and theory of
    the chapter will come to life:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中单击播放按钮，本章的辛勤工作和理论将变为现实：
- en: '![Running the app](img/B12806_21_05.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B12806_21_05.jpg)'
- en: You can see that we now have a real-time system created with our game loop and
    a thread. If you run this on a real device, you will easily achieve 60 frames
    per second at this stage.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们现在使用我们的游戏循环和线程创建了一个实时系统。如果您在真实设备上运行此应用程序，您将很容易在此阶段实现每秒60帧。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was probably the most technical chapter so far. We explored threads, game
    loops, timing, using interfaces, and the `Activity` lifecycle – it's a very long
    list of topics to cram in.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是迄今为止最技术性的一章。我们探讨了线程、游戏循环、定时、使用接口和`Activity`生命周期 - 这是一个非常长的主题列表。
- en: If the exact interrelationship between these things is still not entirely clear,
    it is not a problem. All you need to know is that when the user starts and stops
    the app, the `MainActivity` class will handle starting and stopping the thread
    by calling the `LiveDrawingView` class's `pause` and `resume` functions. It achieves
    this through the overridden `onPause` and `onResume` functions, which are called
    by the OS.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些事物之间的确切相互关系仍然不是很清楚，那也没关系。您只需要知道，当用户启动和停止应用程序时，`MainActivity`类将通过调用`LiveDrawingView`类的`pause`和`resume`函数来处理启动和停止线程。它通过重写的`onPause`和`onResume`函数来实现，这些函数由操作系统调用。
- en: Once the thread is running, the code inside the `run` function executes alongside
    the UI thread that is listening for user input. As we call the `update` and `draw`
    functions from the `run` function at the same time as keeping track of how long
    each frame is taking, our app is ready to rock and roll.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程运行，`run`函数内的代码将与监听用户输入的UI线程一起执行。通过同时从`run`函数调用`update`和`draw`函数，并跟踪每帧花费的时间，我们的应用程序已经准备就绪。
- en: We just need to allow the user to add some particles to their artwork, which
    we can then update in each call to `update` and draw in each call to `draw`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要允许用户向他们的艺术作品添加一些粒子，然后我们可以在每次调用“update”时更新它们，并在每次调用“draw”时绘制它们。
- en: In the next chapter, we will be coding, updating, and drawing both the `Particle`
    and `ParticleSytem` classes. In addition, we will be writing code for the user
    to interact (do some drawing) with the app.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写、更新和绘制“Particle”和“ParticleSystem”类。此外，我们还将为用户编写代码，使其能够与应用程序进行交互（进行一些绘图）。
