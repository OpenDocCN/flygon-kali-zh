- en: Chapter 4. Getting Data from the Tasks – The Callable and Future Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。从任务中获取数据 - Callable和Future接口
- en: 'In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors,* and [Chapter 3](part0028_split_000.html#QMFO1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 3. Getting the Maximum from Executors"), *Getting the Maximum from Executors*,
    we introduced the executor framework to improve the performance of concurrent
    applications and showed you how to implement advanced characteristics to adapt
    this framework to your needs. In these chapters, all the tasks executed by the
    executor were based on the `Runnable` interface and its `run()` method that doesn''t
    return a value. However, the executor framework allows us to execute other kind
    of tasks that return a result based on the `Callable` and `Future` interfaces.
    In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba "第2章。管理大量线程
    - 执行程序")，*管理大量线程 - 执行程序*，和[第3章](part0028_split_000.html#QMFO1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第3章。从执行程序中获得最大效益")，*从执行程序中获得最大效益*，我们介绍了执行程序框架，以提高并发应用程序的性能，并向您展示了如何实现高级特性以使该框架适应您的需求。在这些章节中，执行程序执行的所有任务都基于`Runnable`接口及其不返回值的`run()`方法。然而，执行程序框架允许我们执行基于`Callable`和`Future`接口的返回结果的其他类型的任务。在本章中，我们将涵盖以下主题：
- en: An introduction to the `Callable` and `Future` interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Callable和Future接口介绍
- en: First example – a best-matching algorithm for words
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个例子 - 用于单词的最佳匹配算法
- en: Second example – building an inverted index of a collection of documents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个例子 - 构建文档集合的倒排索引
- en: Introducing the Callable and Future interfaces
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Callable和Future接口
- en: The executor framework allows programmers to execute concurrent tasks without
    creating and managing threads. You create tasks and send them to the executor.
    It creates and manages the necessary threads.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序框架允许程序员在不创建和管理线程的情况下执行并发任务。您创建任务并将它们发送到执行程序。它会创建和管理必要的线程。
- en: 'In an executor, you can execute two kinds of tasks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序中，您可以执行两种类型的任务：
- en: '**Tasks based on the Runnable interface**: These tasks implement the `run()`
    method that doesn''t return any result.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Runnable接口的任务**：这些任务实现了不返回任何结果的`run()`方法。'
- en: '**Tasks based on the Callable interface**: These tasks implement the `call()`
    interface that returns an object as a result. The concrete type that will be returned
    by the `call()` method is specified by the generic type parameter of the `Callable`
    interface. To get the result returned by the task, the executor will return you
    an implementation of the `Future` interface for every task.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Callable接口的任务**：这些任务实现了`call()`接口，返回一个对象作为结果。`call()`方法返回的具体类型由`Callable`接口的泛型类型参数指定。为了获取任务返回的结果，执行程序将为每个任务返回一个`Future`接口的实现。'
- en: In previous chapters, you learned how to create executors, send tasks based
    on the `Runnable` interface to it, and personalize the executor to adapt it to
    your needs. In this chapter, you will learn how to work with tasks based on the
    `Callable` and `Future` interfaces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了如何创建执行程序，将基于`Runnable`接口的任务发送到其中，并个性化执行程序以适应您的需求。在本章中，您将学习如何处理基于`Callable`和`Future`接口的任务。
- en: The Callable interface
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Callable接口
- en: 'The `Callable` interface is very similar to the `Runnable` interface. The main
    characteristics of this interface are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`接口与`Runnable`接口非常相似。该接口的主要特点是：'
- en: It's a generic interface. It has a single type parameter that corresponds to
    the return type of the `call()` method.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个泛型接口。它有一个单一类型参数，对应于`call()`方法的返回类型。
- en: It declares the `call()` method. This method will be executed by the executor
    when it runs the task. It must return an object of the type specified in the declaration.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了`call()`方法。当执行程序运行任务时，该方法将被执行。它必须返回声明中指定类型的对象。
- en: The `call()` method can throw any checked exception. You can process the exceptions
    implementing your own executor and overriding the `afterExecute()` method.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call()`方法可以抛出任何已检查异常。您可以通过实现自己的执行程序并覆盖`afterExecute()`方法来处理异常。'
- en: The Future interface
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Future接口
- en: 'When you send a `Callable` task to an executor, it will return you an implementation
    of the `Future` interface that allows you to control the execution and the status
    of the task and to get the result. The main characteristics of this interface
    are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一个`Callable`任务发送到执行程序时，它将返回一个`Future`接口的实现，允许您控制任务的执行和状态，并获取结果。该接口的主要特点是：
- en: You can cancel the execution of the task using the `cancel()` method. This method
    has a `boolean` parameter to specify whether you want to interrupt the task if
    it's running or not.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`cancel()`方法取消任务的执行。该方法有一个`boolean`参数，用于指定是否要在任务运行时中断任务。
- en: You can check whether the task has been cancelled (with the `isCancelled()`
    method) or it has finished (with the `isDone()` method).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过`isCancelled()`方法检查任务是否已被取消，或者通过`isDone()`方法检查任务是否已完成。
- en: 'You can get the value returned by the task using the `get()` method. There
    are two variants of this method. The first one doesn''t have parameters and returns
    the value returned by the task if it has finished its execution. If the task hasn''t
    finished its execution, it suspends the execution thread until the tasks finish.
    The second variant admits two parameters: a period of time and `TimeUnit` of that
    period. The main difference with the first one is that the thread waits for the
    period of time passed as a parameter. If the period ends and the task hasn''t
    finished its execution, the method throws a `TimeoutException` exception.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`get()`方法获取任务返回的值。此方法有两个变体。第一个没有参数，并返回任务执行完成后的返回值。如果任务尚未执行完成，它会挂起执行线程，直到任务完成。第二个变体接受两个参数：一段时间和该时间段的`TimeUnit`。与第一个的主要区别在于线程等待作为参数传递的时间段。如果时间段结束，任务尚未执行完成，该方法会抛出`TimeoutException`异常。
- en: First example – a best-matching algorithm for words
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个示例-用于单词的最佳匹配算法
- en: 'The main objective of a **best-matching algorithm** for words is to find the
    words most similar to a string passed as a parameter. To implement one of these
    algorithms you need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单词的**最佳匹配算法**的主要目标是找到与作为参数传递的字符串最相似的单词。要实现这些算法之一，您需要以下内容：
- en: '**A list of words**: In our case, we have used the **UK Advanced Cryptics Dictionary**
    (**UKACD**) that is a word list compiled for the crossword community. It has 250,353
    words and idioms. It can be downloaded for free from [http://www.crosswordman.com/wordlist.html](http://www.crosswordman.com/wordlist.html).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单词列表**：在我们的案例中，我们使用了为填字游戏社区编制的**英国高级谜语词典**（**UKACD**）。它有250,353个单词和习语。可以从[http://www.crosswordman.com/wordlist.html](http://www.crosswordman.com/wordlist.html)免费下载。'
- en: '**A metric to measure the similarity between two words**: We have used the
    Levenshtein distance that is used to measure the difference between two sequences
    of **chars**. The **Levenshtein distance** is the minimal number of insertions,
    deletions, or substitutions, which is necessary to transform the first string
    into the second string. You can find a brief description of this metric in [https://en.wikipedia.org/wiki/Levenshtein_distance](https://en.wikipedia.org/wiki/Levenshtein_distance).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**衡量两个单词相似性的度量标准**：我们使用了Levenshtein距离，用于衡量两个**字符**序列之间的差异。**Levenshtein距离**是将第一个字符串转换为第二个字符串所需的最小插入、删除或替换次数。您可以在[https://en.wikipedia.org/wiki/Levenshtein_distance](https://en.wikipedia.org/wiki/Levenshtein_distance)中找到对此度量标准的简要描述。'
- en: 'In our example, you will implement two operations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，您将实现两个操作：
- en: The first operation returns a list of the most similar words to a **char sequence**
    using the Levenshtein distance.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个操作使用Levenshtein距离返回与**字符序列**最相似的单词列表。
- en: The second operation determines if a char sequence exists in our dictionary
    using the Levenshtein distance. It would be faster if we use the `equals()` method,
    but our version is a more interesting option for the objectives of the book.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个操作使用Levenshtein距离确定字符序列是否存在于我们的字典中。如果使用`equals()`方法会更快，但我们的版本对于本书的目标来说是一个更有趣的选择。
- en: You will implement serial and concurrent versions of these operations to verify
    that concurrency can help us in this case.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现这些操作的串行和并发版本，以验证并发在这种情况下是否有帮助。
- en: The common classes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见类
- en: 'In all the tasks implemented in this example, you will use the following three
    basic classes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中实现的所有任务中，您将使用以下三个基本类：
- en: The `WordsLoader` class that loads the list of words into a list of `String`
    objects.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WordsLoader`类将单词列表加载到`String`对象列表中。'
- en: The `LevenshteinDistance` class that calculates the Levenshtein distance between
    two strings.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LevenshteinDistance`类计算两个字符串之间的Levenshtein距离。'
- en: The `BestMatchingData` class that stores the results of the best-matching algorithms.
    It stores a list of words and the distance of these words with the input string.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingData`类存储最佳匹配算法的结果。它存储单词列表以及这些单词与输入字符串的距离。'
- en: The UKACD is in a file with a word per line, so the `WordsLoader` class implements
    the `load()` static method that receives the path of the file that contains the
    list of words and returns a list of string objects with the 250,353 words.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: UKACD在一个文件中，每行一个单词，因此`WordsLoader`类实现了`load()`静态方法，该方法接收包含单词列表的文件的路径，并返回一个包含250,353个单词的字符串对象列表。
- en: 'The `LevenshteinDistance` class implements the `calculate()` method that receives
    two string objects as parameters and returns an `int` value with the distance
    between these two words. This is the code for this classification:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevenshteinDistance`类实现了`calculate()`方法，该方法接收两个字符串对象作为参数，并返回这两个单词之间的距离的`int`值。这是这个分类的代码：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `BestMatchingData` class has only two attributes: a list of string objects
    to store a list of words and an integer attribute named distance to store the
    distance of these words with the input string.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`BestMatchingData`类只有两个属性：一个字符串对象列表，用于存储单词列表，以及一个名为距离的整数属性，用于存储这些单词与输入字符串的距离。'
- en: A best-matching algorithm – the serial version
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳匹配算法-串行版本
- en: First, we are going to implement the serial version of the best-matching algorithm.
    We are going to use this version as the starting point for the concurrent one
    and then we will compare the execution times of both versions to verify that concurrency
    help us to get better performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现最佳匹配算法的串行版本。我们将使用此版本作为并发版本的起点，然后我们将比较两个版本的执行时间，以验证并发是否有助于提高性能。
- en: 'We have implemented the serial version of the best-matching algorithm in the
    following two classes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在以下两个类中实现了最佳匹配算法的串行版本：
- en: The `BestMatchingSerialCalculation` class that calculates the list of most similar
    words to the input string
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingSerialCalculation`类计算与输入字符串最相似的单词列表'
- en: The `BestMatchingSerialMain` that includes the `main()` method that executes
    the algorithm, measures the execution time, and shows the results in the console
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingSerialMain`包括`main()`方法，执行算法，测量执行时间，并在控制台中显示结果'
- en: Let's analyze the source code of both classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这两个类的源代码。
- en: The BestMatchingSerialCalculation class
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BestMatchingSerialCalculation`类'
- en: 'This class has only one method named `getBestMatchingWords`() that receives
    two parameters: a string with the sequence we take as a reference and the list
    of string objects with all the words of the dictionary. It returns a `BestMatchingData`
    object with the results of the algorithm:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个名为`getBestMatchingWords`()的方法，它接收两个参数：一个带有我们作为参考的序列的字符串，以及包含字典中所有单词的字符串对象列表。它返回一个`BestMatchingData`对象，其中包含算法的结果：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the initialization of the internal variables, the algorithm processes
    all the words in the dictionary calculating the Levenshtein distance between these
    words and the string of reference. If the calculated distance for a word is less
    than the actual minimum distance, we clear the list of results and store the actual
    word into the list. If the calculated distance for a word is equal to the actual
    minimum distance, we add that word to the list of results:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部变量初始化之后，算法处理字典中的所有单词，计算这些单词与参考字符串之间的Levenshtein距离。如果一个单词的计算距离小于实际最小距离，我们清除结果列表并将实际单词存储到列表中。如果一个单词的计算距离等于实际最小距离，我们将该单词添加到结果列表中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we create the `BestMatchingData` object to return the results of the
    algorithm:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`BestMatchingData`对象来返回算法的结果：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The BestMachingSerialMain class
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BestMachingSerialMain`类'
- en: This is the main class of the example. It loads the UKACD file, calls `getBestMatchingWords()`
    with the string received as a parameter, and shows the results in the console
    including the execution time of the algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例的主要类。它加载UKACD文件，使用作为参数接收的字符串调用`getBestMatchingWords()`，并在控制台中显示结果，包括算法的执行时间。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we used a new Java 8 language construct named **method reference** and
    a new `List.forEach()` method to output the result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个名为**方法引用**的新的Java 8语言构造和一个新的`List.forEach()`方法来输出结果。
- en: A best-matching algorithm – the first concurrent version
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳匹配算法 - 第一个并发版本
- en: We have implemented two different concurrent versions of the best-matching algorithm.
    The first one is based on the `Callable` interface and the `submit()` method defined
    in the `AbstractExecutorService` interface.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了两个不同的并发版本的最佳匹配算法。第一个是基于`Callable`接口和`AbstractExecutorService`接口中定义的`submit()`方法。
- en: 'We have implemented this version of the algorithm using the following three
    classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下三个类来实现算法的这个版本：
- en: The `BestMatchingBasicTask` class that implements the tasks that implement the
    `Callable` interface and will be executed in the executor
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingBasicTask`类实现了实现`Callable`接口的任务，并将在执行器中执行'
- en: The `BestMatchingBasicConcurrentCalculation` class that creates the executor
    and necessary tasks and sends them to the executor
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingBasicConcurrentCalculation`类创建执行器和必要的任务，并将它们发送到执行器'
- en: The `BestMatchingConcurrentMain` class that implements the `main()` method to
    execute the algorithm and shows the results in the console
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BestMatchingConcurrentMain`类实现了`main()`方法，用于执行算法并在控制台中显示结果'
- en: Let's see the source code of these classes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类的源代码。
- en: The BestMatchingBasicTask class
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BestMatchingBasicTask`类'
- en: As we mentioned before, this class will implement the tasks that will obtain
    the list of best-matching words. This task will implement the `Callable` interface
    parameterized with the `BestMatchingData` class. This means that this class will
    implement the `call()` method, and this method will return a `BestMatchingData`
    object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个类将实现将获得最佳匹配单词列表的任务。这个任务将实现参数化为`BestMatchingData`类的`Callable`接口。这意味着这个类将实现`call()`方法，而这个方法将返回一个`BestMatchingData`对象。
- en: 'Each task will process a part of the dictionary and will return the results
    obtained for that part. We have used four internal attributes as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务将处理字典的一部分，并返回该部分获得的结果。我们使用了四个内部属性，如下所示：
- en: The first position (inclusive) of the dictionary it will analyze
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典的第一个位置（包括）
- en: The last position (exclusive) of the dictionary it will analyze
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将分析的字典的最后位置（不包括）
- en: The dictionary as a list of string objects
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为字符串对象列表的字典
- en: The reference input string
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考输入字符串
- en: 'The code for this is the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `call()` method processes all the words between the `startIndex` and `endIndex`
    attributes and calculates the Levenshtein distance between those words and the
    input string. It will return only the nearest words to the input string. If during
    the process it finds a word nearer than the previous ones, it clears the result
    list and adds the new word to that list. If it finds a word that is at the same
    distance than the results found until now, it adds the word to the result list
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`方法处理`startIndex`和`endIndex`属性之间的所有单词，并计算这些单词与输入字符串之间的Levenshtein距离。它只会返回距离输入字符串最近的单词。如果在过程中找到比之前更接近的单词，它会清除结果列表并将新单词添加到该列表中。如果找到一个与目前找到的结果距离相同的单词，它会将该单词添加到结果列表中，如下所示：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the end, we create a `BestMatchingData` object with the list of words we
    have found and their distance to the input string and return that object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个`BestMatchingData`对象，其中包含我们找到的单词列表及其与输入字符串的距离，并返回该对象。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main difference with the tasks based on the `Runnable` interface is the
    return sentence included in the last line of the method. The `run()` method doesn't
    return a value, so those tasks cannot return a result. The `call()` method, on
    the other hand, returns an object (the class of that object is defined in the
    implements sentence), so this kind of tasks can return a result.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`Runnable`接口的任务与`run()`方法中包含的返回语句的主要区别。`run()`方法不返回值，因此这些任务无法返回结果。另一方面，`call()`方法返回一个对象（该对象的类在实现语句中定义），因此这种类型的任务可以返回结果。
- en: The BestMatchingBasicConcurrentCalculation class
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BestMatchingBasicConcurrentCalculation类
- en: This class is responsible for the creation of the necessary tasks to process
    the complete dictionary, the executor to execute those tasks, and to control the
    execution of the tasks in the executor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责创建处理完整字典所需的任务，执行器来执行这些任务，并控制执行器中任务的执行。
- en: 'It only has one method, `getBestMatchingWords()`, that receives two input parameters:
    the dictionary with the complete list of words and the reference string. It returns
    a `BestMatchingData` object with the results of the algorithm. First, we have
    created and initialized the executor. We have used the number of cores of the
    machine as the maximum number of threads we want to use on it.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有一个方法`getBestMatchingWords()`，接收两个输入参数：完整单词列表的字典和参考字符串。它返回一个包含算法结果的`BestMatchingData`对象。首先，我们创建并初始化了执行器。我们使用机器的核心数作为我们想要在其上使用的最大线程数。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we calculate the size of the parts of the dictionary each task will process
    and creates a list of `Future` objects to store the results of the tasks. When
    you send a task based on the `Callable` interface to an executor, you will get
    an implementation of the `Future` interface. You can use that object to:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算每个任务将处理的字典部分的大小，并创建一个`Future`对象的列表来存储任务的结果。当您将基于`Callable`接口的任务发送到执行器时，您将获得`Future`接口的实现。您可以使用该对象来：
- en: Know whether the task has been executed
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道任务是否已执行
- en: Get the result of the execution of the task (the object returned by the `call()`
    method)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取任务执行的结果（`call()`方法返回的对象）
- en: Cancel the execution of the tasks
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消任务的执行
- en: 'The code for this is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we create the tasks, send them to the executor using the `submit()` method,
    and add the `Future` object that method returns to the list of `Future` objects.
    The `submit()` method returns immediately. It doesn''t wait until the task is
    executed. We have the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建任务，使用`submit()`方法将它们发送到执行器，并将该方法返回的`Future`对象添加到`Future`对象的列表中。`submit()`方法立即返回。它不会等待任务执行。我们有以下代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we have sent the tasks to the executor, we call the `shutdown()` method
    of the executor to finish its execution and iterate over the list of `Future`
    objects to get the results of each task. We have used the `get()` method without
    any parameter. This method returns the object returned by the `call()` method
    if the task has finished its execution. If the task is not finished, the method
    puts the current thread to sleep the calling thread until the task has finished
    and the results are available.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将任务发送到执行器，我们调用执行器的`shutdown()`方法来结束其执行，并迭代`Future`对象的列表以获取每个任务的结果。我们使用不带任何参数的`get()`方法。如果任务已经完成执行，该方法将返回`call()`方法返回的对象。如果任务尚未完成，该方法将使当前线程休眠，直到任务完成并且结果可用。
- en: 'We compose a result list with the results of the tasks, so we will only return
    the list with the words nearest to the reference string as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用任务的结果组成一个结果列表，因此我们将只返回与参考字符串最接近的单词列表如下：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we create and return a `BestMatchingData` object with the results
    of the algorithm:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建并返回一个`BestMatchingData`对象，其中包含算法的结果：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `BestMatchingConcurrentMain` class is very similar to `BestMatchingSerialMain`
    presented before. The only difference is the class used (`BestMatchingBasicConcurrentCalculation`
    instead of `BestMatchingSerialCalculation`), so we don't include the source code
    here. Note that we used neither thread-safe data structures nor synchronization
    as our concurrent tasks worked on independent pieces of data, and the final results
    were merged in a sequential manner after the concurrent tasks were terminated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`BestMatchingConcurrentMain`类与之前介绍的`BestMatchingSerialMain`非常相似。唯一的区别是使用的类（`BestMatchingBasicConcurrentCalculation`而不是`BestMatchingSerialCalculation`），因此我们不在这里包含源代码。请注意，我们既没有使用线程安全的数据结构，也没有同步，因为我们的并发任务在独立的数据片段上工作，并且在并发任务终止后，最终结果是以顺序方式合并的。'
- en: A best-matching algorithm – the second concurrent version
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳匹配算法 - 第二个并发版本
- en: We have implemented the second version of the best-matching algorithm using
    the `invokeAll()` method of the `AbstractExecutorService` (implemented in the
    `ThreadPoolExecutorClass`). In the previous version, we have used the `submit()`
    method that receives a `Callable` object and returns a `Future` object. The `invokeAll()`
    method receives a `List` of `Callable` objects as a parameter and returns a `List`
    of `Future` ones. The first `Future` is associated with the first `Callable` and
    so on. There is another important difference between these two methods. Although
    the `submit()` method returns immediately, the `invokeAll()` method returns when
    all the `Callable` tasks have ended their execution. This means that all the `Future`
    objects returned will return `true` if you call their `isDone()` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AbstractExecutorService`的`invokeAll()`方法（在`ThreadPoolExecutorClass`中实现）实现了最佳匹配算法的第二个版本。在之前的版本中，我们使用了接收`Callable`对象并返回`Future`对象的`submit()`方法。`invokeAll()`方法接收`Callable`对象的`List`作为参数，并返回`Future`对象的`List`。第一个`Future`与第一个`Callable`相关联，依此类推。这两种方法之间还有另一个重要的区别。虽然`submit()`方法立即返回，但`invokeAll()`方法在所有`Callable`任务结束执行时返回。这意味着所有返回的`Future`对象在调用它们的`isDone()`方法时都将返回`true`。
- en: 'To implement this version, we have used the `BestMatchingBasicTask` class implemented
    in the previous example and have implemented the `BestMatchingAdvancedConcurrentCalculation`
    class. The differences with the `BestMatchingBasicConcurrentCalculation` class
    are in the creation of the tasks and in the process of the results. In the creation
    of tasks, now we create a list and store it on the tasks we want to execute:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个版本，我们使用了前面示例中实现的`BestMatchingBasicTask`类，并实现了`BestMatchingAdvancedConcurrentCalculation`类。与`BestMatchingBasicConcurrentCalculation`类的区别在于任务的创建和结果的处理。在任务的创建中，现在我们创建一个列表并将其存储在我们要执行的任务上：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To process the results, we call the `invokeAll()` method and then go over the
    list of `Future` objects returned:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理结果，我们调用`invokeAll()`方法，然后遍历返回的`Future`对象列表：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To execute this version, we have implemented `BestMatchingConcurrentAdvancedMain`.
    Its source code is very similar to the previous ones, so it's not included.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个版本，我们实现了`BestMatchingConcurrentAdvancedMain`。它的源代码与之前的类非常相似，因此不包括在内。
- en: The word exists algorithm – a serial version
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词存在算法-串行版本
- en: As part of this example, we have implemented another operation to check whether
    a string exists in our list of words. To check whether the word exists or not,
    we use the Levenshtein distance again. We consider that a word exists if it has
    a distance of `0` with a word of the list. It would be faster if we make the comparison
    using the `equals()` or `equalsIgnoreCase()` methods or reading the input words
    into a `HashSet` and using the `contains()` method (much more efficient than our
    version), but we consider that our version will be more useful for the purposes
    of the book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个示例的一部分，我们实现了另一个操作，用于检查一个字符串是否存在于我们的单词列表中。为了检查单词是否存在，我们再次使用Levenshtein距离。如果一个单词与列表中的一个单词的距离为`0`，我们认为这个单词存在。如果我们使用`equals()`或`equalsIgnoreCase()`方法进行比较，或者将输入单词读入`HashSet`并使用`contains()`方法进行比较（比我们的版本更有效），会更快，但我们认为我们的版本对于本书的目的更有用。
- en: As in previous examples, first, we have implemented the serial version of the
    operation to use it as a base to implement the concurrent one and compare the
    execution times of both versions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，首先我们实现了操作的串行版本，以便将其作为实现并发版本的基础，并比较两个版本的执行时间。
- en: 'To implement the serial version, we have used two classes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现串行版本，我们使用了两个类：
- en: The `ExistSerialCalculation` class, which implements the `existWord()` method
    that compare the input string with all the words in the dictionary until it finds
    it
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExistSerialCalculation`类实现了`existWord()`方法，将输入字符串与字典中的所有单词进行比较，直到找到它'
- en: The `ExistSerialMain` class, which launches the examples and measure the execution
    time
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExistSerialMain`类，启动示例并测量执行时间'
- en: Let's analyze the source code of both the classes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这两个类的源代码。
- en: The ExistSerialCalculation class
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ExistSerialCalculation`类'
- en: 'This class has only one method, that is, the `existWord()` method. It receives
    two parameters: the word we are looking for and the complete list of words. It
    goes over the full list, which calculates the Levenshtein distance between the
    input word and the words in the list until it finds the word (the distance is
    `0`), in which case it returns the `true` value, or it finishes the list of words
    without finding the word, in which case it returns the `false` value.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个方法，即`existWord()`方法。它接收两个参数：我们要查找的单词和完整的单词列表。它遍历整个列表，计算输入单词与列表中的单词之间的Levenshtein距离，直到找到单词（距离为`0`）为止，此时返回`true`值，或者在没有找到单词的情况下完成单词列表，此时返回`false`值。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The ExistSerialMain class
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ExistSerialMain`类'
- en: 'This class implements the `main()` method to call the `exist()` method. It
    gets the first parameter of the main method as the word we want to look for and
    calls that method. It measures its execution time and shows the results in the
    console. We have the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`main()`方法来调用`exist()`方法。它将主方法的第一个参数作为我们要查找的单词，并调用该方法。它测量其执行时间并在控制台中显示结果。我们有以下代码：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The word exists algorithm – the concurrent version
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词存在算法-并发版本
- en: To implement the concurrent version of this operation, we have to take into
    account its most important characteristic. We don't need to process the whole
    list of words. When we find the word, we can finish the process of the list and
    return the result. This operation which does not process the whole input data
    and stops when some condition is fulfilled is called a **short-circuit operation**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个操作的并发版本，我们必须考虑它最重要的特点。我们不需要处理整个单词列表。当我们找到单词时，我们可以结束列表的处理并返回结果。这种不处理整个输入数据并在满足某些条件时停止的操作称为**短路操作**。
- en: The `AbstractExecutorService` interface defines an operation (implemented in
    the `ThreadPoolExecutor` class) that fits perfectly with this idea. Its the `invokeAny()`
    method. This method sends to the executor the list of `Callable` tasks that receives
    as a parameter and returns the result of the first task that has finished its
    execution without throwing an exception. If all the tasks throw an exception,
    this method throws an `ExecutionException` exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractExecutorService`接口定义了一个操作（在`ThreadPoolExecutor`类中实现），与这个想法完美契合。它是`invokeAny()`方法。这个方法将`Callable`任务列表发送到执行器，并返回第一个完成执行而不抛出异常的任务的结果。如果所有任务都抛出异常，这个方法会抛出`ExecutionException`异常。'
- en: 'As in previous examples, we have implemented different classes to implement
    this version of the algorithm:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们实现了不同的类来实现这个算法的版本：
- en: The `ExistBasicTask` class that implements the tasks we are going to execute
    in the executor
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExistBasicTask`类实现了我们将在执行器中执行的任务'
- en: The `ExistBasicConcurrentCalculation` class that creates the executor and the
    tasks, and send the tasks to the executor
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExistBasicConcurrentCalculation`类创建执行器和任务，并将任务发送到执行器。'
- en: The `ExistBasicConcurrentMain` class that executes the examples measuring its
    running time
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExistBasicConcurrentMain`类执行示例并测量其运行时间'
- en: The ExistBasicTasks class
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExistBasicTasks类
- en: 'This class implements the tasks that are going to search for the word. It implements
    the `Callable` interface parameterized with the `Boolean` class. The `call()`
    method will return the `true` value if the task finds the word. It uses four internal
    attributes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了将要搜索这个单词的任务。它实现了参数化为`Boolean`类的`Callable`接口。如果任务找到单词，`call()`方法将返回`true`值。它使用四个内部属性：
- en: The complete list of words
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的单词列表
- en: The first word (included) in the list the task will process
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中任务将处理的第一个单词（包括）
- en: The last word (excluded) in the list the task will process
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务将处理的列表中的最后一个单词（不包括）
- en: The word the task will look for
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务将要查找的单词
- en: 'We have the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下代码：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `call` method will traverse the part of the list assigned to this task.
    It calculates the Levenshtein distance between the input word and the words of
    the list. If it finds the word, it will return the `true` value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`方法将遍历分配给该任务的列表部分。它计算输入单词与列表中单词之间的Levenshtein距离。如果找到单词，它将返回`true`值。'
- en: If the tasks process all its words and it doesn't find the word, it will throw
    an exception to adapt to the behavior of the `invokeAny()` method. If the task
    returns the `false` value in this case, the `invokeAny()` method will return the
    `false` value without waiting for the rest of the tasks. Maybe another task will
    find the word.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务处理了所有的单词但没有找到这个单词，它将抛出一个异常以适应`invokeAny()`方法的行为。如果任务在这种情况下返回`false`值，`invokeAny()`方法将立即返回`false`值，而不会等待其他任务。也许另一个任务会找到这个单词。
- en: 'We have the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下代码：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The ExistBasicConcurrentCalculation class
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExistBasicConcurrentCalculation类
- en: This class will execute the search of the input word in the full list of words
    creating and executing the necessary tasks. It only implements one method named
    `existWord()`. It receives two parameters, the input string and the complete list
    of words, and returns a Boolean value indicating whether the word exists or not.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将在完整的单词列表中执行输入单词的搜索，创建并执行必要的任务。它只实现了一个名为`existWord()`的方法。它接收两个参数，输入字符串和完整的单词列表，并返回一个布尔值，指示单词是否存在。
- en: 'First, we create the executor to execute the tasks. We use the `Executor` class
    and create a `ThreadPoolExecutor` class with a maximum of threads determined by
    the number of available hardware threads of the machine as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建执行任务的执行器。我们使用`Executor`类，并创建一个`ThreadPoolExecutor`类，最大线程数由机器的可用硬件线程数确定，如下所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we create the same number of tasks as the threads are running in the
    executor. Each task will process an equal part of the list of words. We create
    the tasks and store them in a list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建与执行器中运行的线程数相同数量的任务。每个任务将处理单词列表的一个相等部分。我们创建任务并将它们存储在一个列表中：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we use the `invokeAny()` method to execute the tasks in the executor.
    If the methods return a Boolean value, the word exists. We return that value.
    If the method throws an exception, the word doesn''t exist. We print the exception
    in the console and return the `false` value. In both cases, we call the `shutdown()`
    method of the executor to terminate its execution as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`invokeAny()`方法在执行器中执行任务。如果方法返回布尔值，则单词存在。我们返回该值。如果方法抛出异常，则单词不存在。我们在控制台打印异常并返回`false`值。在这两种情况下，我们调用执行器的`shutdown()`方法来终止其执行，如下所示：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The ExistBasicConcurrentMain class
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExistBasicConcurrentMain类
- en: This class implements the `main()` method of this example. It's equal to the
    `ExistSerialMain` class with one difference that uses the `ExistBasicConcurrentCalculation`
    class instead of the `ExistSerialCalculation`, so its source code is not included.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了这个示例的`main()`方法。它与`ExistSerialMain`类相同，唯一的区别是它使用`ExistBasicConcurrentCalculation`类而不是`ExistSerialCalculation`，因此它的源代码没有包含。
- en: Comparing the solutions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较解决方案
- en: Let's compare the different solutions (serial and concurrent) of the two operations
    we have implemented in this section. To test the algorithm, we have executed the
    examples using the JMH framework ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))
    that allows you to implement micro benchmarks in Java. Using a framework for benchmarking
    is a better solution that simply measures time using methods as `currentTimeMillis()`
    or `nanoTime()`. We have executed them 10 times in a computer with a four-core
    processor and calculated the medium execution time of those 10 times. Let's analyze
    the results of the executions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较我们在本节中实现的两个操作的不同解决方案（串行和并发）。为了测试算法，我们使用了JMH框架（[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)），它允许您在Java中实现微基准测试。使用基准测试框架比简单地使用`currentTimeMillis()`或`nanoTime()`方法来测量时间更好。我们在一个四核处理器的计算机上执行了10次，并计算了这10次的中等执行时间。让我们分析执行结果。
- en: Best-matching algorithms
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳匹配算法
- en: 'In this case, we have implemented three versions of the algorithm:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实现了算法的三个版本：
- en: The serial version
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行版本
- en: The concurrent version, sending a task once at a time
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发版本，一次发送一个任务
- en: The concurrent version, using the `invokeAll()` method
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发版本，使用`invokeAll()`方法
- en: 'To test the algorithms, we have used three different strings that doesn''t
    exist in the list of words:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试算法，我们使用了三个不在单词列表中的不同字符串：
- en: '`Stitter`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stitter`'
- en: '`Abicus`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abicus`'
- en: '`Lonx`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lonx`'
- en: 'These are the words returned by the best-matching algorithm for each word:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最佳匹配算法对每个单词返回的单词：
- en: '`Stitter`: `sitter`, `skitter`, `slitter`, `spitter`, `stilter`, `stinter`,
    `stotter`, `stutter`, and `titter`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stitter`：`sitter`、`skitter`、`slitter`、`spitter`、`stilter`、`stinter`、`stotter`、`stutter`和`titter`'
- en: '`Abicus`: `abacus` and `amicus`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abicus`：`abacus`和`amicus`'
- en: '`Lonx`: `lanx`, `lone`, `long`, `lox`, and `lynx`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lonx`：`lanx`、`lone`、`long`、`lox`和`lynx`'
- en: 'The medium execution times and their standard deviation in milliseconds are
    discussed in the following table:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下表讨论了中等执行时间及其毫秒标准偏差：
- en: '| Algorithm | Stitter | Abicus | lonx |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | Stitter | Abicus | lonx |'
- en: '| --- | --- | --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Serial | 467.01 ± 23.40 | 408.03 ± 14.66 | 317.60 ± 28.78 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 串行 | 467.01 ± 23.40 | 408.03 ± 14.66 | 317.60 ± 28.78 |'
- en: '| Concurrent: `submit()` method | 209.72 ± 74.79 | 184.10 ± 90.47 | 155.61
    ± 65.43 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 并发：`submit()`方法 | 209.72 ± 74.79 | 184.10 ± 90.47 | 155.61 ± 65.43 |'
- en: '| Concurrent: `invokeAll()` method | 217.66 ± 65.46 | 188.28 ± 81.28 | 160.43
    ± 65.14 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 并发：`invokeAll()`方法 | 217.66 ± 65.46 | 188.28 ± 81.28 | 160.43 ± 65.14 |'
- en: 'We can draw the following conclusions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: The concurrent versions of the algorithm get a better performance than the serial
    one.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的并发版本比串行版本获得更好的性能。
- en: The concurrent versions of the algorithm obtain similar results between them.
    All the concurrent versions have very high standard deviation values high. We
    can compare the concurrent version method with the serial version using the speed-up
    for the word `lonx` to see how concurrency improves the performance of our algorithm:![Best-matching
    algorithms](img/00011.jpeg)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的并发版本之间获得了类似的结果。所有并发版本的标准偏差值都非常高。我们可以使用单词`lonx`的加速度比来比较并发版本方法和串行版本，以了解并发如何提高算法的性能：![最佳匹配算法](img/00011.jpeg)
- en: Exist algorithms
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存在的算法
- en: 'In this case, we have implemented two versions of the algorithms:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实现了两个版本的算法：
- en: The serial version
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行版本
- en: The concurrent version, using the `invokeAny()` method
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`invokeAny()`方法的并发版本
- en: 'To test the algorithm, we have used some strings:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试算法，我们使用了一些字符串：
- en: The string `xyzt` that doesn't exist in the list of words
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词列表中不存在的单词`xyzt`
- en: The string `stutter` that exists in the list of words near the end of the list
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词列表的末尾附近存在的单词`stutter`
- en: The string `abacus` that exists in the list of words very close to the start
    of the list
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词列表的开始附近存在的单词`abacus`
- en: The string `lynx` that exists in the list of words just after the second half
    of the list
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词列表的后半部分之后存在的单词`lynx`
- en: 'The medium execution times in milliseconds and their standard deviations are
    shown in the following table:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒中的中等执行时间和它们的标准偏差显示在下表中：
- en: '| Algorithm | Word | Execution time (milliseconds) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 单词 | 执行时间（毫秒） |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Serial | `abacus` | 50.70 ± 13.95 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 串行 | `abacus` | 50.70 ± 13.95 |'
- en: '|   | `lynx` | 194.41 ± 26.02 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|   | `lynx` | 194.41 ± 26.02 |'
- en: '| `stutter` | 398.11 ± 23.4 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `stutter` | 398.11 ± 23.4 |'
- en: '| `xyzt` | 315.62 ± 28.7 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `xyzt` | 315.62 ± 28.7 |'
- en: '| Concurrent | `abacus` | 50.72 ± 7.17 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 并发 | `abacus` | 50.72 ± 7.17 |'
- en: '|   | `lynx` | 69.15 ± 62.5 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|   | `lynx` | 69.15 ± 62.5 |'
- en: '| `stutter` | 126.74 ± 104.52 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `stutter` | 126.74 ± 104.52 |'
- en: '| `xyzt` | 203.37 ± 76.67 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `xyzt` | 203.37 ± 76.67 |'
- en: 'We can draw the following conclusions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: In general, the concurrent version of the algorithm provides better performance
    than the serial one.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，并发版本的算法比串行版本提供更好的性能。
- en: The position of a word in the list is a critical factor. With the `abacus` word,
    which appears at the beginning of the list, both algorithms give similar execution
    times, but with the `stutter` word, the difference is very big.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词在列表中的位置是一个关键因素。对于单词`abacus`，它出现在列表的开头，两种算法给出了类似的执行时间，但对于单词`stutter`，差异非常大。
- en: The standard deviation in the concurrent case is very big.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发情况下的标准偏差非常大。
- en: 'If we compare the concurrent version with the serial one for the word `lynx`
    using the speed-up, the result is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用加速度比较并发版本和串行版本的单词`lynx`，结果是：
- en: '![Exist algorithms](img/00012.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![存在的算法](img/00012.jpeg)'
- en: The second example – creating an inverted index for a collection of documents
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个例子 - 为文档集合创建倒排索引
- en: In the **information retrieval** world, an **inverted index** is a common data
    structure used to speed up the searches of text in a collection of documents.
    It stores all the words of the document collection and a list of the documents
    that contains that word.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在**信息检索**领域，**倒排索引**是一种常用的数据结构，用于加速对文档集合中文本的搜索。它存储文档集合的所有单词以及包含该单词的文档列表。
- en: To construct the index, we have to parse all the documents of the collection
    and construct the index in an incremental way. For every document, we extract
    the significant words of that document (deleting the most common words, also called
    stop words and maybe applying a stemming algorithm) and then add those words to
    the index. If a word exists in the index, we add the document to the list of documents
    associated with that word. If a word doesn't exist, add the word to the list of
    words of the index and associate the document to that word. You can add parameters
    to the association, as the **term frequency** of the word in the document that
    provides you more information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建索引，我们必须解析集合中的所有文档，并以增量方式构建索引。对于每个文档，我们提取该文档的重要单词（删除最常见的单词，也称为停用词，可能应用词干算法），然后将这些单词添加到索引中。如果单词存在于索引中，我们将文档添加到与该单词关联的文档列表中。如果单词不存在，则将单词添加到索引的单词列表中，并将文档与该单词关联。您可以添加参数到关联中，如单词在文档中的**词频**，这将为您提供更多信息。
- en: When you make a search of a word or a list of words in the document collection,
    you use the inverted index to obtain the list of documents associated with each
    word and create a unique list with the results of the search.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在文档集合中搜索一个单词或一组单词时，您使用倒排索引来获取与每个单词关联的文档列表，并创建一个包含搜索结果的唯一列表。
- en: In this section, you will learn how to use Java concurrency utilities to construct
    an inverted index file for a collection of documents. As the document collection,
    we have taken the Wikipedia pages with information about movies to construct a
    set of 100,673 documents. We have converted each Wikipedia page into a text file.
    You can download this document collection with all the information about the book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Java并发工具来为文档集合构建倒排索引文件。作为文档集合，我们已经获取了包含有关电影信息的维基百科页面，以构建一组100,673个文档。我们已经将每个维基百科页面转换为文本文件。您可以下载包含有关该书的所有信息的文档集合。
- en: To construct the inverted index, we don't delete any word and don't use any
    stemming algorithm too. We want to keep the algorithm as simple as possible to
    focus attention in the concurrency utilities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建倒排索引，我们不删除任何单词，也不使用任何词干算法。我们希望尽可能简单地保持算法，以便将注意力集中在并发工具上。
- en: The same principles explained here can be used to obtain other information about
    a document collection, for example, a vector representation of every document
    that can be used as an input for a **clustering algorithm**, as you will learn
    in [Chapter 6](part0041_split_000.html#173722-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 6. Optimizing Divide and Conquer Solutions – The Fork/Join Framework"),
    *Optimizing Divide and Conquer Solutions – The Fork/Join Framework*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释的相同原则可以用于获取关于文档集合的其他信息，例如，每个文档的向量表示，可以作为**聚类算法**的输入，正如您将在[第6章](part0041_split_000.html#173722-2fff3d3b99304faa8fa9b27f1b5053ba
    "第6章。优化分治解决方案 - 分叉/加入框架")中学到的，*优化分治解决方案 - 分叉/加入框架*。
- en: As with other examples, you will implement serial and concurrent versions of
    these operations to verify that concurrency can help us in this case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，您将实现这些操作的串行和并发版本，以验证并发在这种情况下是否有帮助。
- en: Common classes
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用类
- en: 'Both versions, serial and concurrent, have in common the classes to load the
    document collection into a Java object. We have used the following two classes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 串行和并发版本都共同使用类将文档集合加载到Java对象中。我们使用了以下两个类：
- en: The `Document` class that stores the list of words contained in the document
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在文档中的单词列表的`Document`类
- en: The `DocumentParse` class that converts a document stored in a file in a document
    object
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocumentParse`类将存储在文件中的文档转换为文档对象'
- en: Let's analyze the source code of both the classes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这两个类的源代码。
- en: The Document class
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Document类
- en: 'The `Document` class is very simple. It has only two attributes and the methods
    to get and set the values of those attributes. These attributes are:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document`类非常简单。它只有两个属性和用于获取和设置这些属性值的方法。这些属性是：'
- en: The name of the file, as a string.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名，作为字符串。
- en: The vocabulary (that is, the list of words used in the document) as a `HashMap`.
    The **key** are the **words** and the values are the number of times the word
    appears in the document.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词汇表（即文档中使用的单词列表）作为`HashMap`。**键**是**单词**，值是单词在文档中出现的次数。
- en: The DocumentParser class
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DocumentParser类
- en: 'As we mentioned earlier, this class converts a document stored in a file in
    a document in a `Document` object. It splits this word into three methods. The
    first one is the `parse()` method that receives the path to the file as a parameter
    and returns a `HashMap` with the vocabulary of that document. This method reads
    the file line by line and uses the `parseLine()` method to convert each line in
    a list of words and add them to the vocabulary as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类将存储在文件中的文档转换为`Document`对象。它将这个单词分成三个方法。第一个是`parse()`方法，它接收文件路径作为参数，并返回该文档的词汇`HashMap`。这个方法逐行读取文件，并使用`parseLine()`方法将每一行转换为一个单词列表，并将它们添加到词汇中，如下所示：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `parseLine()` method processes the line extracting its words. We consider
    that a word is a sequence of alphabetical characters to continue with the simplicity
    of this example. We have used the `Pattern` class to extract the words and the
    `Normalizer` class to convert the words to lower case and delete the accents of
    the vowels as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseLine()`方法处理提取其单词的行。我们认为一个单词是一个字母序列，以便继续这个例子的简单性。我们已经使用了`Pattern`类来提取单词，使用`Normalizer`类将单词转换为小写并删除元音的重音，如下所示：'
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The serial version
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行版本
- en: The serial version of this example is implemented in the `SerialIndexing` class.
    This class has the `main()` method that reads all the documents, gets its vocabulary,
    and constructs the inverted index in an incremental way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的串行版本是在`SerialIndexing`类中实现的。这个类有一个`main()`方法，它读取所有文档，获取其词汇，并以增量方式构建倒排索引。
- en: 'First, we initialize the necessary variables. The collection of documents is
    stored in the data directory, so we store all the documents in an array of `File`
    objects. We also initialize the `invertedIndex` object. We use a `HashMap` where
    the keys are the words and the values are a list of string objects with the name
    of the files that contain the word as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化必要的变量。文档集合存储在数据目录中，因此我们将所有文档存储在`File`对象的数组中。我们还初始化了`invertedIndex`对象。我们使用`HashMap`，其中键是单词，值是包含该单词的文件名的字符串对象列表，如下所示：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we parse all the documents using the `DocumentParse` class and use the
    `updateInvertedIndex()` method to add the vocabulary obtained from each document
    into the inverted index. We measure the execution time of all the process. We
    have the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`DocumentParse`类解析所有文档，并使用`updateInvertedIndex()`方法将从每个文档获得的词汇添加到倒排索引中。我们测量整个过程的执行时间。我们有以下代码：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we show the results of the execution in the console:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在控制台上显示执行结果：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `updateInvertedIndex()` method adds the vocabulary of a document into the
    inverted index structure. It processes all the words that form the vocabulary.
    If the word exists in the inverted index, we add the name of the document to the
    list of documents associated with that word. If the word doesn''t exists, we add
    the word and associate the document with that word as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateInvertedIndex()`方法将文档的词汇添加到倒排索引结构中。它处理构成词汇的所有单词。如果单词存在于倒排索引中，我们将文档的名称添加到与该单词关联的文档列表中。如果单词不存在，我们将单词添加并将文档与该单词关联，如下所示：'
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first concurrent version – a task per document
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个并发版本 - 每个文档一个任务
- en: Now it's time to implement the concurrent version of the text indexing algorithm.
    Clearly, we can parallelize the process of every document. This includes reading
    the document from the file and processing every line to get the vocabulary of
    the document. The tasks can return that vocabulary as their result, so we can
    implement tasks based in the `Callable` interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现文本索引算法的并发版本了。显然，我们可以并行处理每个文档的过程。这包括从文件中读取文档并处理每一行以获取文档的词汇表。任务可以将该词汇表作为它们的结果返回，因此我们可以基于`Callable`接口实现任务。
- en: 'In the previous example, we have used three methods to send `Callable` tasks
    to the executor:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了三种方法将`Callable`任务发送到执行程序：
- en: '`submit()`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交()
- en: '`invokeAll()`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用所有()
- en: '`invokeAny()`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用任意()
- en: 'We have to process all the documents, so we have to discard the `invokeAny()`
    method. The other two methods are inconvenient. If we use the `submit()` method,
    we have to decide when we process the results of the task. If we send a task per
    document, we can process the results:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理所有文档，因此我们必须放弃`invokeAny()`方法。另外两种方法都不方便。如果我们使用`submit()`方法，我们必须决定何时处理任务的结果。如果我们为每个文档发送一个任务，我们可以处理结果：
- en: After sending every task, this is nonviable
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送每个任务之后，这是不可行的
- en: After the finalization of all the tasks, we have to store a lot of `Future`
    objects
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有任务完成后，我们必须存储大量的`Future`对象
- en: After sending a group of tasks, we have to include code to synchronize both
    operations
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送一组任务后，我们必须包含代码来同步这两个操作。
- en: 'All these approaches have a problem: we process the results of the tasks in
    a sequential way. If we use the `invokeAll()` method, we are in a situation similar
    to point 2\. We have to wait for the finalization of all the tasks.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都有一个问题：我们以顺序方式处理任务的结果。如果我们使用`invokeAll()`方法，我们就处于类似于第2点的情况。我们必须等待所有任务完成。
- en: One possible option is to create other tasks to process the `Future` objects
    associated with every task, and the Java concurrency API provides us with an elegant
    solution to implement this solution with the `CompletionService` interface and
    its implementation, the `ExecutorCompletionService` class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的选择是创建其他任务来处理与每个任务相关的`Future`对象，而Java并发API为我们提供了一种优雅的解决方案，即使用`CompletionService`接口及其实现，即`ExecutorCompletionService`类。
- en: 'A `CompletionService` object is a mechanism that has an executor and allows
    you to decouple the production of tasks and the consumption of the results of
    those tasks. You can send tasks to the executor using the `submit()` method and
    get the results of the tasks when they finish using the `poll()` or `take()` methods.
    So, for our solution, we are going to implement the following elements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionService`对象是一个具有执行程序的机制，它允许您解耦任务的生产和对这些任务结果的消费。您可以使用`submit()`方法将任务发送到执行程序，并在任务完成时使用`poll()`或`take()`方法获取任务的结果。因此，对于我们的解决方案，我们将实现以下元素：'
- en: A `CompletionService` object to execute the tasks.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`CompletionService`对象来执行任务。
- en: A task per document to parse the document and generate its vocabulary. This
    task will be executed by the `CompletionService` object. These tasks are implemented
    in the `IndexingTask` class.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文档一个任务，解析文档并生成其词汇表。这个任务将由`CompletionService`对象执行。这些任务在`IndexingTask`类中实现。
- en: Two threads to process the results of the tasks and construct the inverted index.
    These threads are implemented in the `InvertedIndexTask` class.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个线程来处理任务的结果并构建倒排索引。这些线程在`InvertedIndexTask`类中实现。
- en: A `main()` method to create and execute all the elements. This `main()` method
    is implemented in the `ConcurrentIndexingMain` class.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`main()`方法来创建和执行所有元素。这个`main()`方法是在`ConcurrentIndexingMain`类中实现的。
- en: Let's analyze the source code of these classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这些类的源代码。
- en: The IndexingTask class
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IndexingTask类
- en: 'This class implements the tasks that will parse a document to obtain its vocabulary.
    It implements the `Callable` interface parameterized with the `Document` class.
    It has an internal attribute to store the `File` object that represents the document
    it has to parse. Take a look at the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了解析文档以获取其词汇表的任务。它实现了参数化为`Document`类的`Callable`接口。它有一个内部属性来存储代表它必须解析的文档的`File`对象。看一下下面的代码：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `call()` method, it simply uses the `parse()` method of the `DocumentParser`
    class to parse the document and obtain the vocabulary and create and return the
    `Document` object with the data obtained:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`call()`方法中，它简单地使用`DocumentParser`类的`parse()`方法来解析文档并获取词汇表，并创建并返回包含获取的数据的`Document`对象：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The InvertedIndexTask class
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InvertedIndexTask类
- en: This class implements the tasks that get the `Document` objects generated by
    the `IndexingTask` objects and construct the inverted index. This tasks will be
    executed as `Thread` objects (we don't use an executor in this case), so they
    are based in the `Runnable` interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了获取`IndexingTask`对象生成的`Document`对象并构建倒排索引的任务。这些任务将作为`Thread`对象执行（在这种情况下我们不使用执行程序），因此它们基于`Runnable`接口。
- en: 'The `InvertedIndexTask` class uses three internal attributes:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvertedIndexTask`类使用三个内部属性：'
- en: A `CompletionService` object parameterized with the `Document` class to get
    access to the objects returned by the `IndexingTask` objects.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数化为`Document`类的`CompletionService`对象，以访问`IndexingTask`对象返回的对象。
- en: A `ConcurrentHashMap` to store the inverted index. The keys are the words and
    the values are `ConcurrentLinkedDeque` of string with the names of the files.
    In this case, we have to use concurrent data structures, and the ones used in
    the serial version are not synchronized.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ConcurrentHashMap`来存储倒排索引。键是单词，值是`ConcurrentLinkedDeque`，其中包含文件的名称。在这种情况下，我们必须使用并发数据结构，而串行版本中使用的数据结构没有同步。
- en: A Boolean value to indicate to the task that it can finish its work.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值来指示任务可以完成其工作。
- en: 'The code for this is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `run()` method uses the method `take()` from `CompletionService` to obtain
    the `Future` object associated with a task. We implement a loop that will be running
    until the thread is interrupted. Once the thread has been interrupted, it processes
    all the pending `Future` objects using the `take()` method again. We update the
    inverted index using the `updateInvertedIndex()` method with the object returned
    by the `take()` method. We have the following method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法使用`CompletionService`的`take()`方法获取与任务关联的`Future`对象。我们实现一个循环，直到线程被中断为止。一旦线程被中断，它将使用`take()`方法再次处理所有未决的`Future`对象。我们使用`take()`方法返回的对象更新倒排索引，使用`updateInvertedIndex()`方法。我们有以下方法：'
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, the `updateInvertedIndex` method receives the vocabulary obtained
    from a document, the inverted index, and the name of the file that has been processed
    as parameters. It processes all the words from the vocabulary. We use the `computeIfAbsent()`
    method to add the word to `invertedIndex` if it''s not present:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`updateInvertedIndex`方法接收从文档中获取的词汇表、倒排索引和已处理文件的名称作为参数。它处理词汇表中的所有单词。如果单词不存在，我们使用`computeIfAbsent()`方法将单词添加到`invertedIndex`中：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The ConcurrentIndexing class
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发索引类
- en: This is the main class in the example. It creates and launches all the components,
    waits for its finalization, and prints the final execution time in the console.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例中的主要类。它创建和启动所有组件，等待其完成，并在控制台中打印最终执行时间。
- en: 'First, it creates and initializes all the variables needed for its execution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它创建并初始化了所有需要执行的变量：
- en: An executor to run the `InvertedTask` tasks. As with the previous examples,
    we use the number of cores of the machine as the maximum number of work threads
    in the executor, but in this case, we leave one core to execute the independent
    threads.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行器来运行`InvertedTask`任务。与之前的示例一样，我们使用机器的核心数作为执行器中工作线程的最大数量，但在这种情况下，我们留出一个核心来执行独立线程。
- en: A `CompletionService` object to run the tasks. We use the executor created before
    to initialize this object.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`CompletionService`对象来运行任务。我们使用之前创建的执行程序来初始化这个对象。
- en: A `ConcurrentHashMap` to store the inverted index.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ConcurrentHashMap`来存储倒排索引。
- en: An array of `File` objects with all the documents we have to process.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`File`对象数组，其中包含我们需要处理的所有文档。
- en: 'We have the following method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下方法：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we process all the files of the array. For every file, we create a `InvertedTask`
    object and send it to the `CompletionService` class using the `submit()` method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们处理数组中的所有文件。对于每个文件，我们创建一个`InvertedTask`对象，并使用`submit()`方法将其发送到`CompletionService`类：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we create two `InvertedIndexTask` objects to process the results returned
    by the `InvertedTask` tasks and execute them as normal `Thread` objects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建两个`InvertedIndexTask`对象来处理`InvertedTask`任务返回的结果，并将它们作为普通的`Thread`对象执行：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once we have launched all the elements, we wait for the finalization of the
    executor using the `shutdown()` and the `awaitTermination()` methods. The `awaitTermination()`
    method will return when all the `InvertedTask` tasks have finished its execution,
    so we can finish the threads that execute the `InvertedIndexTask` tasks. To do
    this, we interrupt these threads (see my comment about `InvertedIndexTask`).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了所有元素，我们等待执行器的完成，使用`shutdown()`和`awaitTermination()`方法。`awaitTermination()`方法将在所有`InvertedTask`任务完成执行时返回，因此我们可以完成执行`InvertedIndexTask`任务的线程。为此，我们中断这些线程（参见我关于`InvertedIndexTask`的评论）。
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we write the size of the inverted index and the execution time of
    all the process in the console:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在控制台中写入倒排索引的大小和整个过程的执行时间：
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second concurrent version – multiple documents per task
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个并发版本 - 每个任务处理多个文档
- en: We have implemented a second concurrent version of this example. The basic principles
    are the same as the first version, but, in this case, each task will process more
    that one document instead of only one. The number of documents processed by each
    task will be an input parameter of the main method. We have tested the results
    with 100, 1,000, and 5,000 documents per task.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了这个示例的第二个并发版本。基本原则与第一个版本相同，但在这种情况下，每个任务将处理多个文档而不是只有一个。每个任务处理的文档数量将是主方法的输入参数。我们已经测试了每个任务处理100、1,000和5,000个文档的结果。
- en: 'To implement this new approach, we are going to implement three new classes:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种新方法，我们将实现三个新类：
- en: The `MultipleIndexingTask` class, which is equivalent to the `IndexingTask`
    class, but it will process a list of documents instead of only one
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleIndexingTask`类，相当于`IndexingTask`类，但它将处理一个文档列表，而不是只有一个'
- en: The `MultipleInvertedIndexTask` class, which is equivalent to the `InvertedIndexTask`
    class, but now the tasks will retrieve a list of `Document` objects instead of
    only one
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleInvertedIndexTask`类，相当于`InvertedIndexTask`类，但现在任务将检索一个`Document`对象的列表，而不是只有一个'
- en: The `MultipleConcurrentIndexing` class, which is equivalent to the `ConcurrentIndexing`
    class but using the new classes
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultipleConcurrentIndexing`类，相当于`ConcurrentIndexing`类，但使用新的类'
- en: As much of the source code is similar to the previous version, we only show
    the differences.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分源代码与之前的版本相似，我们只展示不同之处。
- en: The MultipleIndexingTask class
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重索引任务类
- en: 'As we mentioned earlier, this class is similar to the `IndexingTask` class
    presented before. The main difference is that it uses a list of `File` objects
    instead of only one file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类与之前介绍的`IndexingTask`类相似。主要区别在于它使用一个`File`对象的列表，而不是只有一个文件：
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `call()` method returns a list of `Document` objects instead of only one:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`方法返回一个`Document`对象的列表，而不是只有一个：'
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The MultipleInvertedIndexTask class
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重倒排索引任务类
- en: As we mentioned before, this class is similar to `InvertedIndexClass` presented
    earlier. The main difference is in the `run()` method. The `Future` object returned
    by the `poll()` method returns a list of `Document` objects, so we have to process
    the whole list.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类与之前介绍的`InvertedIndexClass`类相似。主要区别在于`run（）`方法。`poll（）`方法返回的`Future`对象返回一个`Document`对象列表，因此我们必须处理整个列表。
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The MultipleConcurrentIndexing class
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MultipleConcurrentIndexing类
- en: 'As we mentioned earlier, this class is similar to the `ConcurrentIndexing`
    class. The only difference is the utilization of the new classes and the use of
    the first parameter to determine the number of documents processed per task. We
    have the following method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个类与`ConcurrentIndexing`类相似。唯一的区别在于利用新类和使用第一个参数来确定每个任务处理的文档数量。我们有以下方法：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Comparing the solutions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较解决方案
- en: Let's compare the solutions of the three versions of the example we have implemented.
    As we mentioned earlier, like document collection, we have taken the Wikipedia
    pages with information about movies to construct a set of 100,673 documents. We
    have converted each Wikipedia page in a text file. You can download this document
    collection with all the information about the book.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下我们实现的三个版本的解决方案。正如我们之前提到的，就像文档集合一样，我们已经获取了包含有关电影信息的维基百科页面，构建了一组100,673个文档。我们已经将每个维基百科页面转换成了一个文本文件。您可以下载包含有关该书的所有信息的文档集合。
- en: 'We have executed five different versions of the solutions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了五个不同版本的解决方案：
- en: The serial version
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行版本
- en: The concurrent version with one task per document
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文档一个任务的并发版本
- en: The concurrent version with multiple tasks per document, with 100, 1,000, and
    5,000 documents per task
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个任务的并发版本，每个文档100、1,000和5,000个文档
- en: 'The following table shows the execution time of the five versions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了五个版本的执行时间：
- en: '| Algorithm | Execution time (milliseconds) |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 执行时间（毫秒） |'
- en: '| --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Serial | 69,480.50 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 串行 | 69,480.50 |'
- en: '| Concurrent: one document per task | 49,655.49 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 并发：每个任务一个文档 | 49,655.49 |'
- en: '| Concurrent: 100 documents per task | 48,438.14 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 并发：每个任务100个文档 | 48,438.14 |'
- en: '| Concurrent: 1,000 documents per task | 49,362.37 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 并发：每个任务1,000个文档 | 49,362.37 |'
- en: '| Concurrent: 5,000 documents per task | 58,362.22 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 并发：每个任务5,000个文档 | 58,362.22 |'
- en: 'We can draw the following conclusions:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出以下结论：
- en: Concurrent versions always obtain better performance than the serial one
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发版本总是比串行版本获得更好的性能
- en: For the concurrent versions, if we increase the number of documents per task,
    we obtain worse results
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于并发版本，如果我们增加每个任务的文档数量，结果会变得更糟。
- en: 'If we compare the concurrent version with the serial one using the speed-up,
    the results are:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用加速比将并发版本与串行版本进行比较，结果如下：
- en: '![Comparing the solutions](img/00013.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![比较解决方案](img/00013.jpeg)'
- en: Other methods of interest
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他感兴趣的方法
- en: In this chapter, we have used some methods of the `AbstractExecutorService`
    interface (implemented in the `ThreadPoolExecutor` class) and `CompletionService`
    interfaces (implemented in the `ExecutorCompletionService`) to manage the results
    of `Callable` tasks. However, there are other versions of the methods we have
    used and other methods we want to mention here.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了`AbstractExecutorService`接口（在`ThreadPoolExecutor`类中实现）和`CompletionService`接口（在`ExecutorCompletionService`中实现）的一些方法来管理`Callable`任务的结果。但是，我们还有其他版本的方法和其他要在这里提到的方法。
- en: 'About the `AbstractExecutorService` interface, let''s discuss the following
    methods:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“AbstractExecutorService”接口，让我们讨论以下方法：
- en: '`invokeAll (Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method returns a list of `Future` objects associated with the list
    of `Callable` tasks passed as parameters when all the tasks have finished its
    execution or the timeout specified by the second and third parameters expires.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll（Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit）`：此方法在所有任务完成其执行或第二个和第三个参数指定的超时到期时，返回与作为参数传递的`Callable`任务列表相关联的`Future`对象列表。'
- en: '`invokeAny (Collection<? Extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method returns the result of the first task of the list of `Callable`
    tasks passed as a parameter that finishes its execution without throwing an exception
    if it finishes before the timeout specified by the second and third parameters
    expires. If the timeout expires, the method throws a `TimeoutException` exception.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny（Collection<? Extends Callable<T>> tasks, long timeout, TimeUnit
    unit）`：此方法返回作为参数传递的`Callable`任务列表中第一个任务的结果，如果它在第二个和第三个参数指定的超时之前完成执行而不抛出异常，则超时后抛出`TimeoutException`异常。'
- en: 'About the `CompletionService` interface, let''s discuss the following methods:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“CompletionService”接口，让我们讨论以下方法：
- en: 'The `poll()` method: We have used a version of this method with two parameters,
    but there is also a version without parameters. From the internal data structures,
    this version retrieves and removes the `Future` object of the next task that has
    finished since the last call to the `poll()` or `take()` methods. If no tasks
    have finished, its execution returns a `null` value.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll（）`方法：我们使用了带有两个参数的此方法的版本，但也有一个不带参数的版本。从内部数据结构来看，此版本检索并删除自上次调用`poll（）`或`take（）`方法以来已完成的下一个任务的`Future`对象。如果没有任务完成，其执行返回`null`值。'
- en: 'The `take()` method: This method is similar to the previous one, but if no
    tasks have finished, it sleeps the thread until one task finishes its execution.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “take（）”方法：此方法类似于上一个方法，但如果没有任务完成，它会使线程休眠，直到一个任务完成其执行。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the different mechanisms that you can use to work
    with tasks that return a result. These tasks are based on the `Callable` interface,
    which declares the `call()` method. This is a parameterized interface with the
    class returned by the `call` method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了可以用来处理返回结果的任务的不同机制。这些任务基于`Callable`接口，该接口声明了`call（）`方法。这是一个由`call`方法返回的类的参数化接口。
- en: When you execute a `Callable` task in an executor, you will always obtain an
    implementation of the `Future` interface. You can use this object to cancel the
    execution of the task, know if the task has finished its execution or get the
    result returned by the `call()` method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在执行器中执行“Callable”任务时，您将始终获得“Future”接口的实现。您可以使用此对象来取消任务的执行，了解任务是否已完成其执行或获取“call（）”方法返回的结果。
- en: You send `Callable` tasks to the executor using three different methods. With
    the `submit()` method, you send one task, and you will get immediately a `Future`
    object associated with this task. With the `invokeAll()` method, you send a list
    of tasks and will get a list of `Future` objects when all the tasks have finished
    its execution. With the `invokeAny()` method, you send a list of tasks, and you
    will receive the result (not a `Future` object) of the first task that finishes
    without throwing an exception. The rest of the tasks are canceled.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用三种不同的方法将“Callable”任务发送到执行器。使用“submit（）”方法，您发送一个任务，并且将立即获得与此任务关联的“Future”对象。使用“invokeAll（）”方法，您发送一个任务列表，并在所有任务完成执行时获得“Future”对象列表。使用“invokeAny（）”方法，您发送一个任务列表，并且将接收第一个完成而不抛出异常的任务的结果（不是“Future”对象）。其余任务将被取消。
- en: The Java concurrency API provides another mechanism to work with these kind
    of tasks. This mechanism is defined in the `CompletionService` interface and implemented
    in the `ExecutorCompletionService` class. This mechanism allows you to decouple
    the execution of tasks and the processing of their results. The `CompletionService`
    interface works internally with an executor and provides the `submit()` method
    to send tasks to the `CompletionService` interface and the `poll()` and `take()`
    methods to get the results of the tasks. These results are provided in the same
    order in which tasks finish their execution.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了另一种机制来处理这些类型的任务。这种机制在“CompletionService”接口中定义，并在“ExecutorCompletionService”类中实现。该机制允许您解耦任务的执行和其结果的处理。“CompletionService”接口在内部使用执行器，并提供“submit（）”方法将任务发送到“CompletionService”接口，并提供“poll（）”和“take（）”方法来获取任务的结果。这些结果以任务完成执行的顺序提供。
- en: 'You also learned to implement these concepts with two real-world examples:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何在两个真实世界的例子中实现这些概念：
- en: A best-matching algorithm using the UKACD dataset
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UKACD数据集的最佳匹配算法
- en: An inverted index constructor, using a dataset with more than 1,00,000 documents
    with information of movies extracted from Wikipedia
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从维基百科提取的有关电影的信息的数据集的倒排索引构造器
- en: 'In the next chapter, you will learn how to execute algorithms in a concurrent
    way that can be divided into phases, for example, a keyword extraction algorithm.
    You can implement that algorithm in the following three steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何以并发方式执行可以分为阶段的算法，例如关键词提取算法。您可以按照以下三个步骤实现该算法：
- en: Step 1 – parse all the documents and extract all the words.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步 - 解析所有文档并提取所有单词。
- en: Step 2 – calculate the importance of each word on each document.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步 - 计算每个文档中每个单词的重要性。
- en: Step 3 – obtain the best keywords.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步 - 获取最佳关键词。
- en: The main characteristic of these steps is that you must finish one completely
    before you can start the next one. Java concurrency API provides the `Phaser`
    class to facilitate the concurrent implementation of these algorithms. It allows
    you to synchronize all the tasks involved on it at the end of a phase, so none
    of them will start the next one until all have finished the current one.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的主要特点是，您必须在开始下一个步骤之前完全完成一个步骤。Java并发API提供了“Phaser”类来促进这些算法的并发实现。它允许您在阶段结束时同步涉及其中的所有任务，因此在所有任务完成当前任务之前，没有一个任务会开始下一个任务。
