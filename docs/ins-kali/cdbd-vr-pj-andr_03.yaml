- en: Chapter 3. Cardboard Box
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 Cardboard Box
- en: Remember when you were a kid and happy to just play in a cardboard box? This
    project might even be more fun than that! Our first Cardboard project will be
    a simple scene with a box (a geometric cube), a triangle, and a bit of user interaction.
    Let's call it "CardboardBox." Get it?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得小时候开心地玩纸板盒吗？这个项目甚至可能比那更有趣！我们的第一个Cardboard项目将是一个简单的场景，有一个盒子（一个几何立方体），一个三角形，还有一点用户交互。我们称之为“CardboardBox”。懂了吗？
- en: Specifically, we're going to create a new project, build a simple app that just
    draws a triangle, then enhance the app to draw a shaded 3D cube, and illustrate
    some user interactions by highlighting the cube when you look at it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将创建一个新项目，构建一个简单的应用程序，只绘制一个三角形，然后增强该应用程序以绘制阴影的3D立方体，并通过在观察时突出显示立方体来说明一些用户交互。
- en: 'In this chapter, you will be:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将会：
- en: Creating a new Cardboard project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Cardboard项目
- en: Adding a triangle object to the scene, including geometry, simple shaders, and
    render buffers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加三角形对象，包括几何、简单着色器和渲染缓冲区
- en: Using a 3D camera, perspective, and head rotation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3D相机、透视和头部旋转
- en: Using model transformations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型变换
- en: Making and drawing a cube object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作和绘制立方体对象
- en: Adding a light source and shading
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加光源和阴影
- en: Spinning the cube
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转立方体
- en: Adding a floor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加地板
- en: Highlighting the object that the user is looking at
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出显示用户正在查看的对象
- en: The project in this chapter is derived from an example application provided
    by the Google Cardboard team called *Treasure Hunt*. Originally, we considered
    instructing you to simply download Treasure Hunt, and we'd walk you through the
    code explaining how it works. Instead, we decided to build a similar project from
    scratch, explaining as we go along. This also mitigates the possibility that Google
    changes or even replaces that project after this book is published.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的项目源自Google Cardboard团队提供的一个示例应用程序，名为*寻宝游戏*。最初，我们考虑让您简单地下载寻宝游戏，然后我们会在代码中引导您解释其工作原理。相反，我们决定从头开始构建一个类似的项目，并在进行过程中进行解释。这也减轻了谷歌在本书出版后更改或甚至替换该项目的可能性。
- en: The source code for this project can be found on the Packt Publishing website
    and on GitHub at [https://github.com/cardbookvr/cardboardbox](https://github.com/cardbookvr/cardboardbox)
    (with each topic as a separate commit).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码可以在Packt Publishing网站和GitHub上找到，网址为[https://github.com/cardbookvr/cardboardbox](https://github.com/cardbookvr/cardboardbox)（每个主题作为单独的提交）。
- en: The Android SDK version is important to your finished app, but your desktop
    environment can also be set up in a number of ways. We mentioned earlier that
    we used Android Studio 2.1 to build the projects in this book. We also used the
    Java SDK Version 8 (1.8). It will be important for you to have this version installed
    (you can have many versions installed side by side) in order to import the projects.
    As with any development environment, any changes made to Java or Android Studio
    may "break" the import process in the future, but the actual source code should
    compile and run for many years to come.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK版本对于您的成品应用程序很重要，但您的桌面环境也可以以多种方式设置。我们之前提到，我们使用Android Studio 2.1构建了本书中的项目。我们还使用了Java
    SDK版本8（1.8）。对于您来说，安装这个版本很重要（您可以并排安装许多版本），以便导入项目。与任何开发环境一样，对Java或Android Studio所做的任何更改可能会在将来“破坏”导入过程，但实际的源代码应该可以编译和运行多年。
- en: Creating a new project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'If you''d like more details and explanation about these steps, refer to the
    *Creating a new Cardboard project* section in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关这些步骤的更多详细信息和解释，请参考[第2章](ch02.html "第2章 骨架Cardboard项目")中的*创建新的Cardboard项目*部分，*骨架Cardboard项目*，并跟随那里进行：
- en: With Android Studio opened, create a new project. Let's name it `CardboardBox`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`CardboardBox`，并针对**Android 4.4 KitKat (API
    19)**使用**空活动**。
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Cardboard SDK的`common.aar`和`core.aar`库文件作为新模块添加到项目中，使用**文件** | **新建** | **新建模块...**。
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库模块设置为项目应用程序的依赖项，使用**文件** | **项目结构**。
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[第2章](ch02.html "第2章 骨架Cardboard项目")中的说明编辑`AndroidManifest.xml`文件，*骨架Cardboard项目*，要小心保留此项目的`package`名称。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[第2章](ch02.html "第2章 骨架Cardboard项目")中的说明编辑`build.gradle`文件，*骨架Cardboard项目*，以便编译SDK
    22。
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[第2章](ch02.html "第2章 骨架Cardboard项目")中的说明编辑`activity_main.xml`布局文件，*骨架Cardboard项目*。
- en: 'Edit the `MainActivity` Java class so that it `extends` `CardboardActivity`
    and `implement``s` `CardboardView.StereoRenderer`. Modify the class declaration
    line as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`MainActivity` Java类，使其`extends` `CardboardActivity`并`implement` `CardboardView.StereoRenderer`。修改类声明行如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add the stub method overrides for the interface (using intellisense implement
    methods or pressing *Ctrl* + *I*).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加接口的存根方法覆盖（使用智能实现方法或按下*Ctrl* + *I*）。
- en: 'At the top of the `MainActivity` class, add the following comments as placeholders
    for variables that we will be creating in this project:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部，添加以下注释作为我们将在此项目中创建的变量的占位符：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Lastly, edit `onCreate()` by adding the `CardboadView` instance as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过以下方式编辑`onCreate()`，添加`CardboadView`实例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Hello, triangle!
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，三角形！
- en: Let's add a triangle to the scene. Yeah, I know that a triangle isn't even a
    box. However, we're going to start with super simple tips. Triangles are the building
    blocks of all 3D graphics and the simplest shapes that OpenGL can render (that
    is, in triangle mode).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中添加一个三角形。是的，我知道三角形甚至不是一个盒子。然而，我们将从非常简单的提示开始。三角形是所有3D图形的基本构件，也是OpenGL可以渲染的最简单的形状（即以三角形模式）。
- en: Introducing geometry
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入几何图形
- en: Before moving on, let's talk a little about geometry.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们谈谈几何图形。
- en: Virtual reality is largely about creating 3D scenes. Complex models are organized
    as three-dimensional data with vertices, faces, and meshes, forming objects that
    can be hierarchically assembled into more complex models. For now, we're taking
    a really simple approach—a triangle with three vertices, stored as a simple Java
    array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实在很大程度上是关于创建3D场景。复杂的模型被组织为具有顶点、面和网格的三维数据，形成可以按层次组装成更复杂模型的对象。目前，我们采用了一个非常简单的方法——一个由三个顶点组成的三角形，存储为一个简单的Java数组。
- en: The triangle is composed of three vertices (that's why, it's called a **tri-angle**!).
    We're going to define our triangle as top (0.0, 0.6), bottom-left (-0.5, -0.3),
    bottom-right (0.5, -0.3). The first vertex is the topmost point of the triangle
    and has *X=0.0*, so it's at the center and *Y=0.6* up.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形由三个顶点组成（这就是为什么它被称为**三角形**！）。我们将把我们的三角形定义为顶部（0.0, 0.6），左下角（-0.5, -0.3），右下角（0.5,
    -0.3）。第一个顶点是三角形的最顶点，具有*X=0.0*，因此它位于中心，*Y=0.6*向上。
- en: 'The order of the vertices, or triangle winding, is very important as it indicates
    the front-facing direction of the triangle. OpenGL drivers expect it to wind in
    a counter-clockwise direction, as shown in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的顺序或三角形的绕组非常重要，因为它指示了三角形的正面方向。OpenGL驱动程序希望它以逆时针方向绕组，如下图所示：
- en: '![Introducing geometry](img/B05144_03_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![引入几何图形](img/B05144_03_01.jpg)'
- en: If the vertices are defined clockwise, the shader will assume that the triangle
    is facing the other direction, away from the camera, and will thus not be visible
    and rendered. This is an optimization called **culling**, which allows the rendering
    pipeline to readily throw away geometry that is on the back side of an object.
    That is, if it is not visible to the camera, don't even bother trying to draw
    it. Having said this, you can set various culling modes to choose to only render
    front faces, back faces, or both.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顶点是顺时针定义的，着色器将假定三角形朝向相反方向，远离摄像头，因此不可见且不会被渲染。这是一种优化称为**剔除**，它允许渲染管线轻松丢弃在物体背面的几何图形。也就是说，如果对摄像头不可见，甚至不要尝试绘制它。话虽如此，您可以设置各种剔除模式，选择只渲染正面、背面或两者。
- en: Refer to the creative commons source at [http://learnopengl.com/#!Advanced-OpenGL/Face-culling](http://learnopengl.com/#!Advanced-OpenGL/Face-culling).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://learnopengl.com/#!Advanced-OpenGL/Face-culling](http://learnopengl.com/#!Advanced-OpenGL/Face-culling)上的创作共用来源。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '*The OpenGL Programming Guide* by Dave Shreiner, Graham Sellers, John M. Kessenich,
    Bill Licea-Kane, "*By convention, polygons whose vertices appear in a counter-clockwise
    order on the screen are called front-facing*." This is determined by a global
    state mode, and the default value is `GL_CCW` ([https://www.opengl.org/wiki/Face_Culling](https://www.opengl.org/wiki/Face_Culling)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenGL编程指南*，作者Dave Shreiner，Graham Sellers，John M. Kessenich，Bill Licea-Kane，“按照惯例，在屏幕上顶点逆时针顺序出现的多边形被称为正面朝向”。这是由全局状态模式确定的，默认值为`GL_CCW`（[https://www.opengl.org/wiki/Face_Culling](https://www.opengl.org/wiki/Face_Culling)）。'
- en: Three-dimensional points, or vertices, are defined with *x*, *y*, and *z* coordinate
    values. A triangle, for example, in 3D space is made up of three vertices, each
    having an *x*, *y*, and *z* value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 三维点或顶点是用*x*、*y*和*z*坐标值定义的。例如，在3D空间中，三角形由三个顶点组成，每个顶点都有*x*、*y*和*z*值。
- en: Our triangle lies on a plane parallel to the screen. When we add 3D viewing
    to the scene (later in this chapter), we'll need a *z* coordinate to place it
    in 3D space. In anticipation, we'll set the triangle on the *Z=-1* plane. The
    default camera in OpenGL is at the origin (0,0,0) and looks down at the negative
    *z* axis. In other words, objects in the scene are looking up the positive *z*
    axis at the camera. We put the triangle one unit away from the camera so that
    we can see it at *Z=-1.0*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的三角形位于与屏幕平行的平面上。当我们在场景中添加3D视图（本章后面会介绍）时，我们需要一个*z*坐标将其放置在3D空间中。为了预期，我们将三角形设置在*Z=-1*平面上。OpenGL中的默认摄像头位于原点（0,0,0），并朝着负*z*轴方向。换句话说，场景中的物体朝着正*z*轴向摄像头看。我们将三角形放置在离摄像头一单位远的地方，这样我们就可以在*Z=-1.0*处看到它。
- en: Triangle variables
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角形变量
- en: 'Add the following code snippet to the top of the `MainActivity` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`MainActivity`类的顶部：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our triangle coordinates are assigned to the `triCoords` array. All the vertices
    are in 3D space with three coordinates (*x*, *y*, and *z*) per vertex (`COORDS_PER_VERTEX`).
    The `triVertexCount` variable, precalculated as the length of the triangle's `triCoords`
    array, is divided by `COORDS_PER_VERTEX`. We also define an arbitrary `triColor`
    value for our triangle, which is composed of R, G, B, and A values (red, green,
    blue, and alpha (transparency)). The `triVerticesBuffer` variable will be used
    in the draw code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的三角形坐标被分配给`triCoords`数组。所有顶点都在3D空间中，每个顶点（`COORDS_PER_VERTEX`）有三个坐标（*x*、*y*和*z*）。预先计算的`triVertexCount`变量是三角形`triCoords`数组的长度，除以`COORDS_PER_VERTEX`。我们还为我们的三角形定义了一个任意的`triColor`值，由R、G、B和A值（红色、绿色、蓝色和alpha（透明度））组成。`triVerticesBuffer`变量将在绘制代码中使用。
- en: For those who are new to Java programming, you might also wonder about the variable
    types. Integers are declared `int` and floating point numbers are declared `float`.
    All the variables here are being declared `private`, which means that they'll
    only be visible and used within this class definition. The ones that are declared
    `static` will share their data across multiple instances of the class. The ones
    that are declared `final` are immutable and are not expected to change once they
    are initialized.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚接触 Java 编程的人来说，你可能也会对变量类型感到困惑。整数声明为 `int`，浮点数声明为 `float`。这里的所有变量都被声明为 `private`，这意味着它们只能在这个类定义内部可见和使用。被声明为
    `static` 的变量将在类的多个实例之间共享数据。被声明为 `final` 的变量是不可变的，一旦初始化就不会改变。
- en: onSurfaceCreated
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onSurfaceCreated
- en: The purpose of this activity code is to draw stuff on the Android device display.
    We do this through the OpenGL graphics library, which draws onto a surface, a
    memory buffer onto which you can draw graphics via a rendering pipeline.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动代码的目的是在 Android 设备显示器上绘制东西。我们通过 OpenGL 图形库来实现这一点，它会绘制到一个表面上，一个内存缓冲区，你可以通过渲染管线绘制图形。
- en: After the activity is created (`onCreate`), a surface is created and `onSurfaceCreated`
    is called. It has several responsibilities, including initializing the scene and
    compiling the shaders. It also prepares for rendering by allocating memory for
    vertex buffers, binding textures, and initializing the render pipeline handles.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 活动创建后（`onCreate`），会创建一个表面并调用 `onSurfaceCreated`。它有几个责任，包括初始化场景和编译着色器。它还通过为顶点缓冲区分配内存、绑定纹理和初始化渲染管线句柄来准备渲染。
- en: 'Here''s the method, which we''ve broken into several private methods that we''re
    going to write next:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方法，我们将把它分成几个私有方法，接下来我们将编写这些方法：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There''s nothing to initialize in the scene at this point:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，场景中没有什么需要初始化的：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's move on to the shaders and rendering discussions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论着色器和渲染。
- en: Introducing OpenGL ES 2.0
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 OpenGL ES 2.0
- en: Now is a good time to introduce the *graphics pipeline*. When a Cardboard app
    draws 3D graphics on the screen, it hands the rendering to a separate graphics
    processor (GPU). Android and our Cardboard app uses the OpenGL ES 2.0 standard
    graphics library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是介绍 *图形管线* 的好时机。当 Cardboard 应用在屏幕上绘制 3D 图形时，它会将渲染交给一个单独的图形处理器（GPU）。Android
    和我们的 Cardboard 应用使用 OpenGL ES 2.0 标准图形库。
- en: OpenGL is a specification for how applications interact with graphics drivers.
    You could say that it's a long list of function calls that do things in graphics
    hardware. Hardware vendors write their drivers to conform to the latest specification,
    and some intermediary, in this case Google, creates a library that hooks into
    driver functions in order to provide method signatures that you can call from
    whatever language you're using (generally, Java, C++, or C#).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 是应用程序与图形驱动程序交互的规范。你可以说它是一长串在图形硬件中执行操作的函数调用。硬件供应商编写他们的驱动程序以符合最新的规范，而一些中间件，比如
    Google，在这种情况下创建了一个库，它连接到驱动程序函数，以提供你可以从任何语言中调用的方法签名（通常是 Java、C++ 或 C#）。
- en: OpenGL ES is the mobile, or **Embedded Systems**, version of OpenGL. It follows
    the same design patterns as OpenGL, but its version history is very different.
    Different versions of OpenGL ES and even different implementations of the same
    version will require different approaches to drawing 3D graphics. Thus, your code
    might differ greatly between OpenGL ES 1.0, 2.0, and 3.0\. Thankfully, most major
    changes happened between Version 1 and 2, and the Cardboard SDK is set up to use
    2.0\. The `CardboardView` interface also varies slightly from a normal `GLSurfaceView`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 是 OpenGL 的移动版，也称为嵌入式系统。它遵循与 OpenGL 相同的设计模式，但其版本历史非常不同。不同版本的 OpenGL
    ES 甚至同一版本的不同实现都需要不同的方法来绘制 3D 图形。因此，你的代码在 OpenGL ES 1.0、2.0 和 3.0 之间可能会有很大的不同。值得庆幸的是，大部分重大变化发生在版本
    1 和 2 之间，Cardboard SDK 设定为使用 2.0。`CardboardView` 接口也与普通的 `GLSurfaceView` 稍有不同。
- en: 'To draw graphics on the screen, OpenGL needs two basic things:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制图形，OpenGL 需要两个基本的东西：
- en: The graphics programs, or *shaders* (sometimes used interchangeably), which
    define how to draw shapes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义如何绘制形状的图形程序，或 *着色器*（有时可以互换使用）
- en: The data, or *buffers*, which define what is being drawn
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义正在绘制的数据，或 *缓冲区*
- en: There are also some parameters that specify transformation matrices, colors,
    vectors, and so on. You might be familiar with the concept of a game loop, which
    is a basic pattern to set up the game environment and then initiate a loop that
    runs some game logic, renders the screen, and repeats at a semi-regular interval
    until the game is paused or the program exits. The `CardboardView` sets up the
    game loop for us, and basically, all that we have to do is implement the interface
    methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些参数，用于指定变换矩阵、颜色、向量等。你可能熟悉游戏循环的概念，这是一种设置游戏环境并启动一个循环的基本模式，该循环运行一些游戏逻辑，渲染屏幕，并在半规律的时间间隔内重复，直到游戏暂停或程序退出。`CardboardView`
    为我们设置了游戏循环，基本上，我们只需要实现接口方法。
- en: 'A bit more on shaders: at the bare minimum, we need a vertex shader and a fragment
    shader. The vertex shader is responsible for transforming the vertices of an object
    from world space (where they are in the world) to screen space (where they should
    be drawn on the screen).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于着色器的更多信息：至少我们需要一个顶点着色器和一个片段着色器。顶点着色器负责将对象的顶点从世界空间（它们在世界中的位置）转换到屏幕空间（它们应该在屏幕上绘制的位置）。
- en: The fragment shader is called on each pixel that the shape occupies (determined
    by the raster function, a fixed part of the pipeline) and returns the color that
    is drawn. Every shader is a single function, accompanied by a number of attributes
    that can be used as inputs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器在形状占据的每个像素上调用（由光栅函数确定），并返回绘制的颜色。每个着色器都是一个单一的函数，伴随着一些可以用作输入的属性。
- en: A collection of functions (that is, a vertex and a fragment) is compiled by
    OpenGL into a program. Sometimes, whole programs are referred to as shaders, but
    this is a colloquialism that assumes the basic knowledge that more than one function,
    or *shader*, is required to fully draw an object. The program and the values for
    all its parameters will sometimes be referred to as a *material*, given that it
    completely describes the material of the surface that it draws.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL将一组函数（即顶点和片段）编译成一个程序。有时，整个程序被称为着色器，但这是一种俚语，假设需要多个函数或*着色器*才能完全绘制一个对象。程序及其所有参数的值有时会被称为*材质*，因为它完全描述了它绘制的表面的材质。
- en: Shaders are cool. However, they don't do anything until your program sets up
    the data buffers and makes a bunch of draw calls.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器很酷。但是，在程序设置数据缓冲区并进行大量绘制调用之前，它们不会做任何事情。
- en: A draw call consists of a **Vertex Buffer Object** (**VBO**), the shaders that
    will be used to draw it, a number of parameters that specify the transformation
    applied to the object, the texture(s) used to draw it, and any other shader parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制调用由**顶点缓冲对象**（**VBO**）、将用于绘制的着色器、指定应用于对象的变换的参数数量、用于绘制的纹理和任何其他着色器参数组成。
- en: The VBO refers to any and all data used to describe the shape of an object.
    A very basic object (for example, a triangle) only needs an array of vertices.
    The vertices are read in order, and every three positions in space define a single
    triangle. Slightly more advanced shapes use an array of vertices and an array
    of indices, which define which vertices to draw in what order. Using an index
    buffer, multiple vertices can be re-used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: VBO是指用于描述对象形状的任何和所有数据。一个非常基本的对象（例如三角形）只需要一个顶点数组。顶点按顺序读取，每三个空间位置定义一个三角形。稍微更高级的形状使用顶点数组和索引数组，定义了以什么顺序绘制哪些顶点。使用索引缓冲区，可以重复使用多个顶点。
- en: While OpenGL can draw a number of shape types (a point, line, triangle, and
    quad), we will assume that all are triangles. This is both a performance optimization
    and a matter of convenience. If we want a quad, we can draw two triangles. If
    we want a line, we can draw a really long, skinny quad. If we want a point, we
    can draw a tiny triangle. This way, not only can we leave OpenGL in triangle mode,
    but we can also treat all VBOs in exactly the same manner. Ideally, you want your
    render code to be completely agnostic to what it is rendering.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OpenGL可以绘制多种形状类型（点、线、三角形和四边形），但我们假设所有形状都是三角形。这既是性能优化，也是方便之处。如果我们想要一个四边形，我们可以绘制两个三角形。如果我们想要一条线，我们可以绘制一个非常长而细的四边形。如果我们想要一个点，我们可以绘制一个微小的三角形。这样，不仅可以将OpenGL保留在三角形模式下，还可以以完全相同的方式处理所有VBO。理想情况下，您希望您的渲染代码完全不受其渲染对象的影响。
- en: 'To summarize:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: The purpose of the OpenGL graphics library is to give us access to the GPU hardware,
    which then paints pixels on the screen based on the geometry in a scene. This
    is achieved through a rendering pipeline, where data is transformed and passed
    through a series of shaders.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL图形库的目的是让我们访问GPU硬件，然后根据场景中的几何图形在屏幕上绘制像素。这是通过渲染管线实现的，其中数据经过一系列着色器的转换和传递。
- en: A shader is a small program that takes certain inputs and generates corresponding
    outputs, depending on the stage of the pipeline.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器是一个小程序，它接受某些输入并生成相应的输出，具体取决于管线的阶段。
- en: As a program, shaders are written in a special C-like language. The source code
    is compiled to be run very efficiently on the Android device's GPU.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个程序，着色器是用一种特殊的类似于C的语言编写的。源代码经过编译后可以在Android设备的GPU上高效运行。
- en: For example, a *vertex shader* handles processing individual vertices, outputting
    a transformed version of each one. Another step rasterizes the geometry, after
    which a *fragment shader* receives a raster fragment and outputs colored pixels.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*顶点着色器*处理单个顶点的处理，输出每个顶点的变换版本。另一个步骤是对几何图形进行光栅化，之后*片段着色器*接收光栅片段并输出彩色像素。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll be discussing the OpenGL rendering pipeline later on, and you can read
    about it at [https://www.opengl.org/wiki/Rendering_Pipeline_Overview](https://www.opengl.org/wiki/Rendering_Pipeline_Overview).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面讨论OpenGL渲染管线，并且您可以在[https://www.opengl.org/wiki/Rendering_Pipeline_Overview](https://www.opengl.org/wiki/Rendering_Pipeline_Overview)上阅读相关内容。
- en: You can also review the Android OpenGL ES API Guide at [http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html)上查看Android
    OpenGL ES API指南。
- en: For now, don't worry too much about it and let's just follow along.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要太担心这个问题，让我们跟着走就好。
- en: 'Note: GPU drivers actually implement the entire OpenGL library on a per-driver
    basis. This means that someone at NVIDIA (or in this case, probably Qualcomm or
    ARM) wrote the code that compiles your shaders and reads your buffers. OpenGL
    is a specification for how this API should work. In our case, this is the GL class
    that''s part of Android.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：GPU驱动程序实际上是根据每个驱动程序来实现整个OpenGL库的。这意味着NVIDIA（或在这种情况下，可能是Qualcomm或ARM）的某个人编写了编译您的着色器和读取您的缓冲区的代码。OpenGL是关于这个API应该如何工作的规范。在我们的情况下，这是Android的GL类的一部分。
- en: Simple shaders
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单着色器
- en: 'Presently, we''ll write a couple of simple shaders. Our shader code will be
    written in a separate file, which is loaded and compiled by our app. Add the following
    functions at the end of the `MainActivity` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`MainActivity`类的末尾添加以下函数。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will call `loadShader` to load a shader program (via `readRawTextFile`) and
    compile it. This code will be useful in other projects as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`loadShader`来加载一个着色器程序（通过`readRawTextFile`）并对其进行编译。这段代码在其他项目中也会很有用。
- en: Now, we'll write a couple of simple shaders in the `res/raw/simple_vertex.shader`
    and `res/raw/simple_fragment.shader` files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`res/raw/simple_vertex.shader`和`res/raw/simple_fragment.shader`文件中编写一些简单的着色器。
- en: In the **Project Files** hierarchy view, on the left-hand side of Android Studio,
    locate the `app/res/` resource folder, right-click on it, and go to **New** |
    **Android Resource Directory**. In the **New Resource Directory** dialog box,
    from **Resource Type:**, select **Raw**, and then click on **OK**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio左侧的**项目文件**层次结构视图中，定位`app/res/`资源文件夹，右键单击它，转到**新建** | **Android资源目录**。在**新资源目录**对话框中，从**资源类型：**中选择**Raw**，然后单击**确定**。
- en: 'Right-click on the new `raw` folder, go to **New** | **File**, and name it
    `simple_vertex.shader`. Add the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击新的`raw`文件夹，转到**新建** | **文件**，并将其命名为`simple_vertex.shader`。添加以下代码：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, for the fragment shader, right-click on the `raw` folder, go to
    **New** | **File**, and name it `simple_fragment.shader`. Add the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于片段着色器，右键单击`raw`文件夹，转到**新建** | **文件**，并将其命名为`simple_fragment.shader`。添加以下代码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basically, these are identity functions. The vertex shader passes through the
    given vertex, and the fragment shader passes through the given color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这些是恒等函数。顶点着色器通过给定的顶点，片段着色器通过给定的颜色。
- en: 'Notice the names of the parameters that we declared: an attribute named `a_Position`
    in `simple_vertex` and a uniform variable named `u_Color` in `simple_fragment`.
    We''ll set these up from the `MainActivity onSurfaceCreated` method. Attributes
    are properties of each vertex, and when we allocate buffers for them, they must
    all be arrays of equal length. Other attributes that you will encounter are vertex
    normals, texture coordinates, and vertex colors. Uniforms will be used to specify
    information that applies to the whole material, such as in this case, the solid
    color applied to the whole surface.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们声明的参数的名称：`simple_vertex`中的属性名为`a_Position`，`simple_fragment`中的统一变量名为`u_Color`。我们将从`MainActivity
    onSurfaceCreated`方法中设置这些属性。属性是每个顶点的属性，当我们为它们分配缓冲区时，它们必须都是相等长度的数组。您将遇到的其他属性是顶点法线、纹理坐标和顶点颜色。统一变量将用于指定适用于整个材质的信息，例如在这种情况下，应用于整个表面的固体颜色。
- en: Also, note that the `gl_FragColor` and `gl_Position` variables are built-in
    variable names that OpenGL is looking for you to set. Think of them as the returns
    on your shader function. There are other built-in output variables, which we will
    see later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意`gl_FragColor`和`gl_Position`变量是OpenGL正在寻找你设置的内置变量名称。把它们想象成着色器函数的返回值。还有其他内置的输出变量，我们稍后会看到。
- en: The compileShaders method
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: compileShaders方法
- en: We're now ready to implement the `compileShaders` method that `onSurfaceCreated`
    calls.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现`onSurfaceCreated`调用的`compileShaders`方法。
- en: 'Add the following variables on top of `MainActivity`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的顶部添加以下变量：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement `compileShaders`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`compileShaders`，如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The prepareRenderingTriangle method
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: prepareRenderingTriangle方法
- en: The `onSurfaceCreated` method prepares for rendering by allocating memory for
    vertex buffers, creating OpenGL programs, and initializing the render pipeline
    handles. We will do this for our triangle shape now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated`方法通过为顶点缓冲区分配内存，创建OpenGL程序和初始化渲染管道句柄来准备渲染。现在我们将为我们的三角形形状执行此操作。'
- en: 'Add the following variables on top of `MainActivity`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的顶部添加以下变量：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s a skeleton of the function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数的框架：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to prepare some memory buffers that will be passed to OpenGL when each
    frame is rendered. This is the first go-round for our triangle and simple shaders;
    we now only need a vertex buffer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要准备一些内存缓冲区，当每帧被渲染时，它们将被传递给OpenGL。这是我们的三角形和简单着色器的第一次尝试；现在我们只需要一个顶点缓冲区：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These five lines of code result in the setting up of the `triVerticesBuffer`
    value, which are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这五行代码导致了`triVerticesBuffer`值的设置，如下所示：
- en: A `ByteBuffer` is allocated that is big enough to hold our triangle coordinate
    values
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个足够大的`ByteBuffer`，以容纳我们的三角形坐标值。
- en: The binary data is arranged to match the hardware's native byte order
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据被排列以匹配硬件的本机字节顺序
- en: The buffer is formatted for a floating point and assigned to our `FloatBuffer`
    vertex buffer
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为浮点格式化缓冲区，并将其分配给我们的`FloatBuffer`顶点缓冲区
- en: The triangle data is put into it, and then we reset the buffer cursor position
    to the beginning
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形数据被放入其中，然后我们将缓冲区光标位置重置到开头
- en: 'Next, we build the OpenGL ES program executable. Create an empty OpenGL ES
    program using `glCreateProgram`, and assign its ID as `triProgram`. This ID will
    be used in other methods as well. We attach any shaders to the program, and then
    build the executable with `glLinkProgram`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建OpenGL ES程序可执行文件。使用`glCreateProgram`创建一个空的OpenGL ES程序，并将其ID分配为`triProgram`。这个ID也将在其他方法中使用。我们将任何着色器附加到程序中，然后使用`glLinkProgram`构建可执行文件：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we get a handle on the render pipeline. A call to `glGetAttribLocation`
    on `a_Position` retrieves the location of the vertex buffer parameter, `glEnableVertexAttribArray`
    gives permission to access it, and a call to `glGetUniformLocation` on `u_Color`
    retrieves the location of the color components. We''ll be happy that we did this
    once we get to `onDrawEye`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们获得了渲染管道的句柄。调用`glGetAttribLocation`的`a_Position`检索顶点缓冲区参数的位置，`glEnableVertexAttribArray`允许访问它，并调用`glGetUniformLocation`的`u_Color`检索颜色组件的位置。一旦我们到达`onDrawEye`，我们会很高兴我们这样做了：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, we've isolated the code needed to prepare a drawing of the triangle model
    in this function. First, it sets up buffers for the vertices. Then, it creates
    a GL program, attaching the shaders it'll use. Then, we get handles to the parameters
    in the shaders that we'll use to draw.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这个函数中隔离了准备绘制三角形模型所需的代码。首先，它为顶点设置了缓冲区。然后，它创建了一个GL程序，附加了它将使用的着色器。然后，我们获得了在着色器中使用的参数的句柄，用于绘制。
- en: onDrawEye
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onDrawEye
- en: '*Ready, Set, and Go!* If you think of what we''ve written so far as the "Ready
    Set" part, now we do the "Go" part! That is, the app starts and creates the activity,
    calling `onCreate`. The surface is created and calls `onSurfaceCreated` to set
    up the buffers and shaders. Now, as the app runs, for each frame, the display
    is updated. Go!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*准备，设置和开始！* 如果您认为我们迄今为止所写的内容是“准备就绪”部分，那么现在我们要做“开始”部分！ 也就是说，应用程序启动并创建活动，调用`onCreate`。
    创建表面并调用`onSurfaceCreated`来设置缓冲区和着色器。 现在，随着应用程序的运行，每帧都会更新显示。 开始吧！'
- en: The `CardboardView.StereoRenderer` interface delegates these methods. We can
    handle `onNewFrame` (and will later on). For now, we'll just implement the `onDrawEye`
    method, which will draw the contents from the point of view of an eye. This method
    gets called twice, once for each eye.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardboardView.StereoRenderer`接口委托这些方法。 我们可以处理`onNewFrame`（稍后会处理）。 现在，我们只需实现`onDrawEye`方法，该方法将从眼睛的角度绘制内容。
    此方法将被调用两次，每只眼睛一次。'
- en: 'All that `onDrawEye` needs to do for now is render our lovely triangle. Nonetheless,
    we''ll split it into a separate function (that''ll make sense later):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`onDrawEye`所需要做的就是渲染我们可爱的三角形。 尽管如此，我们将其拆分为一个单独的函数（稍后会有意义）：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to specify which shader program we are using by calling `glUseProgram`.
    A call to `glVertexAttribPointer` sets our vertex buffer to the pipeline. We also
    set the color using `glUniform4fv` (`4fv` refers to the fact that our uniform
    is a vector with four floats). Then, we actually draw using `glDrawArrays`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过调用`glUseProgram`来指定我们使用的着色器程序。 调用`glVertexAttribPointer`将我们的顶点缓冲区设置到管道中。
    我们还使用`glUniform4fv`来设置颜色（`4fv`指的是我们的统一变量是一个具有四个浮点数的向量）。 然后，我们使用`glDrawArrays`来实际绘制。
- en: Building and running
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行
- en: That's it. *Yee haa!* That wasn't so bad, was it? Actually, if you're familiar
    with Android development and OpenGL, you might have breezed through this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。 *耶哈！* 这并不那么糟糕，是吧？ 实际上，如果您熟悉Android开发和OpenGL，您可能已经轻松完成了这一步。
- en: Let's build and run it. Go to **Run** | **Run 'app'**, or simply use the green
    triangle **Run** icon on the toolbar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行它。 转到**运行** | **运行'app'**，或者只需使用工具栏上的绿色三角形**运行**图标。
- en: Gradle will do its build thing. Select the **Gradle Console** tab at the bottom
    of the Android Studio window to view the Gradle build messages. Then, assuming
    that all goes well, the APK file will be installed on your connected phone (it's
    connected and turned on, right?). Select the **Run** tab at the bottom to view
    the upload and launch messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle将执行其构建操作。 选择Android Studio窗口底部的**Gradle控制台**选项卡以查看Gradle构建消息。 然后，假设一切顺利，APK文件将安装在您连接的手机上（连接并打开了，对吧？）。
    选择底部的**运行**选项卡以查看上传和启动消息。
- en: 'This is what it displays:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它显示的内容：
- en: '![Building and running](img/B05144_03_02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![构建和运行](img/B05144_03_02.jpg)'
- en: Actually, it kind of looks like a Halloween pumpkin carving! *Spooky*. But in
    VR you'll see just a single triangle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它看起来有点像万圣节南瓜雕刻！ *阴森*。 但在VR中，您只会看到一个单独的三角形。
- en: Notice that while the triangle vertex coordinates define edges with straight
    lines, the `CardboardView` renders it with barrel distortion to compensate for
    the lens optics in the headset. Also, the left image is different from the right,
    one for each eye. When you insert the phone in a Google Cardboard headset, the
    left and right stereoscopic views appear as one triangle floating in space with
    straight edges.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然三角形的顶点坐标定义了直线边缘，但`CardboardView`以桶形畸变呈现它，以补偿头盔中的透镜光学。 此外，左图像与右图像不同，每只眼睛一个。
    当您将手机插入Google Cardboard头盔时，左右立体视图将显示为一个三角形，浮在空间中，边缘笔直。
- en: That's great! We just built a simple Cardboard app for Android from scratch.
    Like any Android app, there are a number of different pieces that need to be defined
    just to get a basic thing going, including the `AndroidManifest.xml`, `activity_main.xml`,
    and `MainActivity.java` files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！ 我们刚刚从头开始为Android构建了一个简单的Cardboard应用程序。 与任何Android应用程序一样，需要定义许多不同的部分才能使基本功能正常运行，包括`AndroidManifest.xml`，`activity_main.xml`和`MainActivity.java`文件。
- en: Hopefully everything went as planned. Like a good programmer, you've probably
    been building and running the app after making incremental changes to the account
    for syntax errors and unhandled exceptions. A little bit later, we will call the
    GLError function to check error information from OpenGL. As always, pay close
    attention to errors in logcat (try filtering for the running application) and
    to variable names. You might have a syntax error in your shader, causing its compiling
    to fail, or you might have a typo in the attribute/uniform name when trying to
    access the handles. These kind of things will not result in any compile-time errors
    (shaders are compiled at runtime), and your app will run but may not render anything
    as a result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 希望一切都按计划进行。 像一个好的程序员一样，您可能在进行增量更改后构建和运行应用程序，以解决语法错误和未处理的异常。 稍后，我们将调用GLError函数来检查来自OpenGL的错误信息。
    一如既往，要密切关注logcat中的错误（尝试过滤正在运行的应用程序）和变量名称。 您的着色器可能存在语法错误，导致编译失败，或者在尝试访问句柄时，属性/统一名称可能存在拼写错误。
    这些问题不会导致任何编译时错误（着色器在运行时编译），并且您的应用程序将运行，但可能不会渲染任何内容。
- en: 3D camera, perspective, and head rotation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D相机，透视和头部旋转
- en: As awesome as this is (*ha ha*), our app is kind of boring and not very Cardboard-like.
    Specifically, it's stereoscopic (dual views) and has lens distortion, but it's
    not yet a 3D perspective view and it doesn't move with your head. We're going
    to fix this now.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这很棒（*哈哈*），但我们的应用有点无聊，不太像Cardboard。 具体来说，它是立体的（双视图）并具有透镜畸变，但它还不是3D透视视图，也不会随着您的头部移动。
    我们现在要修复这个问题。
- en: Welcome to the matrix
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎来到矩阵
- en: We can't talk about developing for virtual reality without talking about matrix
    mathematics for 3D computer graphics.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论为虚拟现实开发时，我们不能不谈论用于3D计算机图形的矩阵数学。
- en: What is a matrix? The answer is out there, Neo, and it's looking for you, and
    it will find you if you want it to. That's right, it's time to learn about the
    matrix. Everything will be different now. Your perspective is about to change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是矩阵？答案就在那里，Neo，它正在寻找你，如果你愿意，它会找到你。没错，是时候了解矩阵了。一切都将不同。你的视角即将改变。
- en: We're building a three-dimensional scene. Each location in space is described
    by the X, Y, and Z coordinates. Objects in the scene may be constructed from X,
    Y, and Z vertices. An object can be transformed by moving, scaling, and/or rotating
    its vertices. This transformation can be represented mathematically with a matrix
    of 16 floating point values (four rows of four floats each). How it works mathematically
    is cool, but we won't get into it here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个三维场景。空间中的每个位置由X、Y和Z坐标描述。场景中的物体可以由X、Y和Z顶点构成。通过移动、缩放和/或旋转其顶点，可以对物体进行变换。这种变换可以用一个包含16个浮点值的矩阵来数学表示（每行四个浮点数）。
- en: 'Matrices can be combined by multiplying them together. For example, if you
    have a matrix that represents how much to resize an object (scale) and another
    matrix to reposition (translate), then you could make a third matrix, representing
    both the resizing and repositioning by multiplying the two together. You can''t
    just use the primitive `*` operator though. Also, note that unlike a simple scalar
    multiplication, matrix multiplication is not commutative. In other words, we know
    that *a * b = b * a*. However, for matrices A and B, *AB ≠ BA*! The Matrix Android
    class library provides functions for doing matrix math. Here''s an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以通过相乘来组合。例如，如果你有一个表示对象缩放（比例）的矩阵和另一个用于重新定位（平移）的矩阵，那么你可以通过将两者相乘来创建第三个矩阵，表示缩放和重新定位。但是，你不能只使用原始的`*`运算符。另外，需要注意的是，与简单的标量乘法不同，矩阵乘法不是可交换的。换句话说，我们知道*a
    * b = b * a*。然而，对于矩阵A和B，*AB ≠ BA*！Matrix Android类库提供了执行矩阵运算的函数。以下是一个例子：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that due to the way in which matrix multiplication works, multiplying a
    vector by the result matrix will have the same effect as first multiplying it
    by the scale matrix (right-hand side), and then multiplying it by the translate
    matrix (left-hand side). This is the opposite of what you might expect.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于矩阵乘法的工作方式，将向量乘以结果矩阵将产生与首先将其乘以缩放矩阵（右侧）相同的效果，然后将其乘以平移矩阵（左侧）。这与你可能期望的相反。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation of the Matrix API can be found at [http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Matrix API的文档可以在[http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html)找到。
- en: This matrix stuff will be used a lot. Something that is worth mentioning here
    is precision loss. You might get a "drift" from the actual values if you repeatedly
    scale and translate that combined matrix because floating point calculations lose
    information due to rounding. It's not just a problem for computer graphics but
    also for banks and Bitcoin mining! (Remember the movie *Office Space*?)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵的东西将被大量使用。值得在这里提到的一点是精度损失。如果你反复缩放和平移组合矩阵，可能会出现与实际值的“漂移”，因为浮点计算由于四舍五入而丢失信息。这不仅是计算机图形的问题，也是银行和比特币挖掘的问题！（还记得电影《办公空间》吗？）
- en: One fundamental use of this matrix math, which we need immediately, is to transform
    a scene into a screen image (projection) as viewed from the user's perspective.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种矩阵数学的一个基本用途是立即将场景转换为用户视角的屏幕图像（投影）。
- en: In a Cardboard VR app, to render the scene from a particular viewpoint, we think
    of a camera that is looking in a specific direction. The camera has X, Y, and
    Z positions like any other object and is rotated to its view direction. In VR,
    when you turn your head, the Cardboard SDK reads the motion sensors in your phone,
    determines the current head pose (the view direction and angles), and gives your
    app the corresponding transformation matrix.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cardboard虚拟现实应用中，为了从特定视角渲染场景，我们考虑一个朝向特定方向的摄像机。摄像机像任何其他物体一样具有X、Y和Z位置，并旋转到其视角方向。在虚拟现实中，当你转动头部时，Cardboard
    SDK读取手机中的运动传感器，确定当前的头部姿势（视角和角度），并给你的应用程序相应的变换矩阵。
- en: 'In fact, in VR for each frame, we render two slightly different perspective
    views: one for each eye, offset by the actual distance between one''s eyes (the
    interpupillary distance).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在虚拟现实中，对于每一帧，我们渲染两个稍微不同的透视视图：每只眼睛一个，偏移了实际的眼睛间距（瞳距）。
- en: Also, in VR, we want to render the scene using a perspective projection (versus
    isometric) so that objects closer to you appear larger than the ones further away.
    This can be represented with a 4 x 4 matrix as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在虚拟现实中，我们希望使用透视投影（而不是等距投影）来渲染场景，以便靠近你的物体比远处的物体更大。这也可以用4x4矩阵来表示。
- en: 'We can combine each of these transformations by multiplying them together to
    get a `modelViewProjection` matrix:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些变换组合起来，将它们相乘以获得`modelViewProjection`矩阵：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A complete `modelViewProjection` (MVP) transformation matrix is a combination
    of any model transforms (for example, scaling or positioning the model in the
    scene) with the camera eye view and perspective projection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`modelViewProjection`（MVP）变换矩阵是任何模型变换（例如，在场景中缩放或定位模型）与摄像机视角和透视投影的组合。
- en: When OpenGL goes to draw an object, the vertex shader can use this `modelViewProjection`
    matrix to render the geometry. The whole scene gets drawn from the user's viewpoint,
    in the direction his head is pointing, with a perspective projection for each
    eye to appear stereoscopically through your Cardboard viewer. VR MVP FTW!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当OpenGL开始绘制一个对象时，顶点着色器可以使用`modelViewProjection`矩阵来渲染几何图形。整个场景从用户的视角绘制，朝向他的头部指向，每只眼睛都有透视投影，通过你的Cardboard观看器呈现立体效果。虚拟现实MVP
    FTW！
- en: The MVP vertex shader
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP顶点着色器
- en: The super simple vertex shader that we wrote earlier doesn't transform each
    vertex; it just passed it through the next step in the pipeline. Now, we want
    it to be 3D-aware and use our `modelViewProjection` (MVP) transformation matrix.
    Create a shader to handle it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的超级简单的顶点着色器并不会变换每个顶点；它只是将它传递到管道的下一步。现在，我们希望它能够具有3D感知能力，并使用我们的`modelViewProjection`（MVP）变换矩阵。创建一个着色器来处理它。
- en: 'In the hierarchy view, right-click on the `app/res/raw` folder, go to **New**
    | **File**, enter the name, `mvp_vertex.shader`, and click on **OK**. Write the
    following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构视图中，右键单击`app/res/raw`文件夹，转到**新建** | **文件**，输入名称`mvp_vertex.shader`，然后单击**确定**。编写以下代码：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This shader is almost the same as `simple_vertex` but transforms each vertex
    by the `u_MVP` matrix. (Note that while multiplying matrices and vectors with
    `*` does not work in Java, it does work in the shader code!)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器几乎和`simple_vertex`一样，但是通过`u_MVP`矩阵来变换每个顶点。（请注意，虽然在Java中用`*`来乘矩阵和向量是不起作用的，但在着色器代码中是可以的！）
- en: 'Replace the shader resource in the `compleShaders` function to use `R.raw.mvp_vertex`
    instead:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`compleShaders`函数中的着色器资源替换为使用`R.raw.mvp_vertex`：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Setting up the perspective viewing matrices
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置透视视图矩阵
- en: 'To add the camera and view to our scene, we define a few variables. In the
    `MainActivity.java` file, add the following code to the beginning of the `MainActivity`
    class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将摄像机和视图添加到我们的场景中，我们定义了一些变量。在`MainActivity.java`文件中，在`MainActivity`类的开头添加以下代码：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Z_NEAR` and `Z_FAR` constants define the depth planes used later to calculate
    the perspective projection for the camera eye. `CAMERA_Z` will be the position
    of the camera (for example, at X=0.0, Y=0.0, and Z=0.01).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Z_NEAR`和`Z_FAR`常量定义了后面用于计算摄像机眼睛的透视投影的深度平面。`CAMERA_Z`将是摄像机的位置（例如，在X=0.0，Y=0.0和Z=0.01处）。'
- en: The `triMVPMatrixParam` variable will be used to set the model transformation
    matrix in our improved shader.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`triMVPMatrixParam`变量将用于在我们改进的着色器中设置模型变换矩阵。'
- en: The `camera`, `view`, and `modelViewProjection` matrices will be 4 x 4 matrices
    (an array of 16 floats) used for perspective calculations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`camera`、`view`和`modelViewProjection`矩阵将是4x4矩阵（16个浮点数的数组），用于透视计算。'
- en: 'In `onCreate`, we initialize the `camera`, `view`, and `modelViewProjection`
    matrices:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中，我们初始化了`camera`、`view`和`modelViewProjection`矩阵：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `prepareRenderingTriangle`, we initialize the `triMVPMatrixParam` variable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prepareRenderingTriangle`中，我们初始化了`triMVPMatrixParam`变量：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The default camera in OpenGL is at the origin (0,0,0) and looks down at the
    negative *Z* axis. In other words, objects in the scene are facing toward the
    positive *Z* axis at the camera. To place them in front of the camera, give them
    a position with some negative Z value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中的默认摄像机位于原点（0,0,0），并朝向负*Z*轴。换句话说，场景中的物体朝着摄像机的正*Z*轴。为了将它们放在摄像机前面，给它们一个带有一些负Z值的位置。
- en: There is a longstanding (and pointless) debate in the 3D graphics world about
    which axis is up. We can somehow all agree that the *X* axis goes left and right,
    but does the *Y* axis go up and down, or is it Z? Plenty of software picks Z as
    the up-and-down direction, and defines Y as pointing in and out of the screen.
    On the other hand, the Cardboard SDK, Unity, Maya, and many others choose the
    reverse. If you think of the coordinate plane as drawn on graph paper, it all
    depends on where you put the paper. If you think of the graph as you look down
    from above, or draw it on a whiteboard, then *Y* is the vertical axis. If the
    graph is sitting on the table in front of you, then the *missing* *Z* axis is
    vertical, pointing up and down. In any case, the Cardboard SDK, and therefore
    the projects in this book, treat Z as the *forward and backward* axis.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D图形世界中有一个长期存在的（且毫无意义的）关于哪个轴是上的争论。我们可以在某种程度上都同意*X*轴是左右移动的，但*Y*轴是上下移动的，还是*Z*轴是呢？许多软件选择*Z*作为上下方向，并将*Y*定义为指向屏幕内外。另一方面，Cardboard
    SDK、Unity、Maya和许多其他软件选择了相反的方式。如果你把坐标平面想象成在图纸上绘制，那么这取决于你把纸放在哪里。如果你把图形想象成从上面往下看，或者在白板上绘制，那么*Y*就是垂直轴。如果图形放在你面前的桌子上，那么*缺失的*
    *Z*轴就是垂直的，指向上下。无论如何，Cardboard SDK，因此本书中的项目，将Z视为*前后*轴。
- en: Render in perspective
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透视渲染
- en: With things set up, we can now handle redrawing the screen for each frame.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置好了，我们现在可以处理每一帧重新绘制屏幕的工作。
- en: First, set the camera position. It can be defined once, like in `onCreate`.
    But, often in a VR application, the camera position in the scene can change, so
    we'll reset it for each frame.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置摄像机位置。它可以像在`onCreate`中那样定义一次。但是，在VR应用程序中，场景中的摄像机位置通常会发生变化，因此我们需要在每一帧中重置它。
- en: 'The first thing to do is reset the camera matrix at the start of a new frame
    to a generic front-facing direction. Define the `onNewFrame` method, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的一帧开始时，首先要做的是重置摄像机矩阵，使其指向一个通用的正面方向。定义`onNewFrame`方法如下：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note, as you write `Matrix`, Android Studio will want to auto-import the package.
    Ensure that the import you choose is `android.opengl.Matrix`, and not some other
    matrix library, such as `android.graphic.Matrix`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你写`Matrix`时，Android Studio会想要自动导入包。确保你选择的导入是`android.opengl.Matrix`，而不是其他矩阵库，比如`android.graphic.Matrix`。
- en: 'Now, when it''s time to draw the scene from the viewpoint of each eye, we calculate
    the perspective view matrix. Modify `onDrawEye` as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当需要从每只眼睛的视角绘制场景时，我们会计算透视视图矩阵。修改`onDrawEye`如下：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first two lines that we added reset the OpenGL depth buffer. When 3D scenes
    are rendered, in addition to the color of each pixel, OpenGL keeps track of the
    distance the object occupying that pixel is from the eye. If the same pixel is
    rendered for another object, the depth buffer will know whether it should be visible
    (closer) or ignored (further away). (Or, perhaps the colors get combined in some
    way, for example, transparency). We clear the buffer before rendering any geometry
    for each eye. The color buffer, which is the one you actually see on screen, is
    also cleared. Otherwise, in this case, you would end up filling the entire screen
    with a solid color.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的前两行重置了OpenGL深度缓冲区。当渲染3D场景时，除了每个像素的颜色外，OpenGL还会跟踪占据该像素的对象与眼睛的距离。如果为另一个对象渲染相同的像素，深度缓冲区将知道它是否应该可见（更近）或忽略（更远）。
    （或者，也许颜色以某种方式组合在一起，例如透明度）。我们在渲染每只眼睛的任何几何图形之前清除缓冲区。实际上，也清除了屏幕上实际看到的颜色缓冲区。否则，在这种情况下，您最终会用纯色填满整个屏幕。
- en: Now, let's move on to the viewing transformations. `onDrawEye` receives the
    current `Eye` object, which describes the stereoscopic rendering details of the
    eye. In particular, the `eye.getEyeView()` method returns a transformation matrix
    that includes head tracking rotation, position shift, and interpupillary distance
    shift. In other words, where the eye is located in the scene and what direction
    it's looking. Though Cardboard does not offer positional tracking, the positions
    of the eyes do change in order to simulate a virtual head. Your eyes don't rotate
    on a central axis, but rather your head pivots around your neck, which is a certain
    distance from the eyes. As a result, when the Cardboard SDK detects a change in
    orientation, the two virtual cameras move around the scene as though they were
    actual eyes in an actual head.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行查看转换。`onDrawEye`接收当前的`Eye`对象，该对象描述了眼睛的立体渲染细节。特别是，`eye.getEyeView()`方法返回一个包括头部跟踪旋转、位置移动和瞳距移动的变换矩阵。换句话说，眼睛在场景中的位置以及它所看的方向。尽管Cardboard不提供位置跟踪，但眼睛的位置会发生变化，以模拟虚拟头部。您的眼睛不会围绕中心轴旋转，而是您的头部围绕颈部旋转，这是眼睛的一定距离。因此，当Cardboard
    SDK检测到方向变化时，两个虚拟摄像头会在场景中移动，就好像它们是实际头部中的实际眼睛一样。
- en: 'We need a transformation that represents the perspective view of the camera
    at this eye''s position. As mentioned earlier, this is calculated as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个代表该眼睛位置的摄像机透视视图的变换。如前所述，这是如下计算的：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We multiply the `camera` by the eye view transform (`getEyeView`), then multiply
    the result by the perspective projection transform (`getPerspective`). Presently,
    we do not transform the triangle model itself and leave the `modelTransform` matrix
    out.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`camera`乘以眼睛视图变换（`getEyeView`），然后将结果乘以透视投影变换（`getPerspective`）。目前，我们不对三角形模型本身进行变换，而是将`modelTransform`矩阵排除在外。
- en: The result (`modelViewProjection`) is passed to OpenGL to be used by the shaders
    in the rendering pipeline (via `glUniformMatrix4fv`). Then, we draw our stuff
    (via `glDrawArrays` as written earlier).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（`modelViewProjection`）被传递给OpenGL，供渲染管线中的着色器使用（通过`glUniformMatrix4fv`）。然后，我们绘制我们的东西（通过之前写的`glDrawArrays`）。
- en: 'Now, we need to pass the view matrix to the shader program. In the `drawTriangle`
    method, add it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将视图矩阵传递给着色器程序。在`drawTriangle`方法中，添加如下内容：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Building and running
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行
- en: Let's build and run it. Go to **Run** | **Run 'app'**, or simply use the green
    triangle **Run** icon on the toolbar. Now, moving the phone will change the display
    synchronized with your view direction. Insert the phone in a Google Cardboard
    viewer and it's like VR (*kinda sorta*).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行它。转到**运行** | **运行'app'**，或者直接使用工具栏上的绿色三角形**运行**图标。现在，移动手机将改变与您的视图方向同步的显示。将手机插入Google
    Cardboard查看器中，就像VR一样（*有点像*）。
- en: Note that if your phone is lying flat on the table when the app starts, the
    camera in our scene will be facing straight down rather than forward at our triangle.
    What's worse, when you pick up the phone, the neutral direction may not be facing
    straight in front of you. So, each time you run apps in this book, pick up the
    phone first, so you look forward in VR, or keep the phone propped up in position
    (personally, I use a Gekkopod, which is available at [http://gekkopod.com/](http://gekkopod.com/)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您的手机在应用程序启动时平放在桌子上，则我们场景中的摄像头将面向三角形的正下方而不是向前。更糟糕的是，当您拿起手机时，中性方向可能不会正对着您的前方。因此，每次在本书中运行应用程序时，先拿起手机，这样您就可以在VR中向前看，或者将手机支撑在位置上（我个人使用的是Gekkopod，可在[http://gekkopod.com/](http://gekkopod.com/)上购买）。
- en: Also, in general, make sure that your phone is not set to **Lock Portrait**
    in the **Settings** dialog box.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请确保您的手机在**设置**对话框中未设置为**锁定竖屏**。
- en: Repositioning the triangle
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新定位三角形
- en: Our matrix-fu has really gotten us places. Let's go further.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的矩阵技术确实让我们走得更远了。
- en: I want to move the triangle out of the way. We'll do this by setting up another
    transformation matrix and then using it on the model when it's time to draw.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我想把三角形移到一边。我们将通过设置另一个变换矩阵来实现这一点，然后在绘制时将其用于模型。
- en: 'Add two new matrices named `triTransform` and `triView`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个名为`triTransform`和`triView`的新矩阵：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Initialize them in `onCreate` as well:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中初始化它们：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s set the model matrix that positions the triangle in the `initializeScene`
    method (called by `onSurfaceCreated`). We''ll offset it by 5 units in X and backwards
    5 units in Z. Add the following code to `initializeScene`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`initializeScene`方法中设置定位三角形的模型矩阵（由`onSurfaceCreated`调用）。我们将其在X轴上偏移5个单位，并在Z轴上向后偏移5个单位。在`initializeScene`中添加以下代码：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we use the model matrix to build the `modelViewProjection` matrix in
    `onDrawEye`. Modify `onDrawEye`, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用模型矩阵在`onDrawEye`中构建`modelViewProjection`矩阵。修改`onDrawEye`如下：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Build and run it. You will now see the triangle further away and off to the
    side.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。现在，您将看到三角形离得更远，偏向一侧。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To summarize one more time: the `modelViewProjection` matrix is a combination
    of the triangle''s position transform (`triTransform`), the camera''s location
    and orientation (`camera`), the current eye''s viewpoint from `CardboardView`
    based on the phone''s motion sensors (`eye.getEyeView`), and the `perspective`
    projection. This MVP matrix is handed to the vertex shader to determine its actual
    location when drawing the triangle on the screen.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次总结一下：`modelViewProjection`矩阵是三角形位置变换（`triTransform`）、摄像机位置和方向（`camera`）、基于手机运动传感器的`CardboardView`当前眼睛的视点（`eye.getEyeView`）以及`perspective`投影的组合。这个MVP矩阵被传递给顶点着色器，以确定在屏幕上绘制三角形时的实际位置。
- en: Hello, cube!
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，立方体！
- en: 'A flat triangle floating in 3D space may be amazing, but it''s nothing compared
    to what we''re going to do next: a 3D cube!'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D空间中漂浮的平面三角形可能很惊人，但与我们接下来要做的事情相比，简直不值一提：一个3D立方体！
- en: The cube model data
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立方体模型数据
- en: The triangle, with just three vertices, was declared in the `MainActivity` class
    to keep the example simple. Now, we will introduce more complex geometry. We'll
    put it in a class named `Cube`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持示例简单，三角形只有三个顶点，声明在`MainActivity`类中。现在，我们将引入更复杂的几何形状。我们将把它放在一个名为`Cube`的类中。
- en: Okay, it's just a cube that is composed of eight distinct vertices, forming
    six faces, right?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它只是由八个不同的顶点组成的立方体，形成了六个面，对吧？
- en: Well, GPUs prefer to render triangles rather than quads, so subdivide each face
    into two triangles; that's 12 triangles in total. To define each triangle separately,
    that's a total of 36 vertices, with proper winding directions, defining our model,
    as shown in `CUBE_COORDS`. Why not just define eight vertices and reuse them?
    We'll show you how to do this later.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，GPU更喜欢渲染三角形而不是四边形，因此将每个面细分为两个三角形；总共有12个三角形。要单独定义每个三角形，总共需要36个顶点，带有适当的绕组方向，定义我们的模型，如`CUBE_COORDS`中所示。为什么不只定义八个顶点并重用它们？我们稍后会告诉你如何做。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we always need to be careful of the winding order of the vertices
    (counter-clockwise) so that the visible side of each triangle is facing outward.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们始终需要小心顶点的绕组顺序（逆时针），以便每个三角形的可见面朝外。
- en: 'In Android Studio, in the Android project hierarchy pane on the left-hand side,
    find your Java code folder (such as `com.cardbookvr.cardboardbox`). Right-click
    on it, and go to **New** | **Java Class**. Then, set **Name: Cube**, and click
    on **OK**. Then, edit the file, as follows (remember that the code for the projects
    in this book are available for download from the publisher''s website and from
    the book''s public GitHub repositories):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，在左侧的Android项目层次结构窗格中，找到您的Java代码文件夹（例如`com.cardbookvr.cardboardbox`）。右键单击它，然后转到**新建**
    | **Java类**。然后，设置**名称：Cube**，然后单击**确定**。然后，编辑文件，如下所示（请记住，本书项目的代码可以从出版商网站和书籍的公共GitHub存储库中下载）：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Cube code
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立方体代码
- en: Returning to the `MainActivity` file, we'll just copy/paste/edit the triangle
    code and reuse it for the cube. Obviously, this isn't ideal, and once we see a
    good pattern, we can abstract out some of this into reusable methods. Also, we'll
    use the same shaders as those of the triangle, and then in the next section, we'll
    replace them with a better lighting model. That is to say, we'll implement lighting
    or what a 2D artist might call **shading**, which we haven't done so far.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`MainActivity`文件，我们将只是复制/粘贴/编辑三角形代码，并将其重用于立方体。显然，这并不理想，一旦我们看到一个好的模式，我们可以将其中一些抽象出来成为可重用的方法。此外，我们将使用与三角形相同的着色器，然后在下一节中，我们将用更好的光照模型替换它们。也就是说，我们将实现光照或2D艺术家可能称之为**着色**的东西，这是我们到目前为止还没有做的。
- en: 'Like the triangle, we declare a bunch of variables that we are going to need.
    The vertex count, obviously, should come from the new `Cube.CUBE_COORDS` array:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与三角形一样，我们声明了一堆我们将需要的变量。顶点数显然应该来自新的`Cube.CUBE_COORDS`数组：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code to `onCreate`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`onCreate`中：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following code to `onSurfaceCreated`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`onSurfaceCreated`中：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write the `prepareRenderingCube` method, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`prepareRenderingCube`方法，如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will position the cube 5 units away and rotate it 30 degrees on a diagonal
    axis of (1, 1, 0). Without the rotation, we''ll just see the square of the front
    face. Add the following code to `initializeScene`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把立方体定位在5个单位之外，并在对角轴（1,1,0）上旋转30度。没有旋转，我们只会看到正面的正方形。将以下代码添加到`initializeScene`中：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following code to `onDrawEye` to calculate the MVP matrix, including
    the `cubeTransform` matrix, and then draw the cube:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`onDrawEye`中以计算MVP矩阵，包括`cubeTransform`矩阵，然后绘制立方体：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Write the `drawCube` method, which is very similar to the `drawTri` method,
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`drawCube`方法，它与`drawTri`方法非常相似，如下所示：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Build and run it. You will now see a 3D view of the cube, as shown in the following
    screenshot. It needs shading.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。现在您将看到立方体的3D视图，如下截图所示。它需要着色。
- en: '![Cube code](img/B05144_03_03.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![Cube code](img/B05144_03_03.jpg)'
- en: Lighting and shading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照和着色
- en: We need to introduce a light source into the scene and provide a shader that
    will use it. For this, the cube needs additional data, defining normal vectors
    and colors at each vertex.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在场景中引入光源并提供一个将使用它的着色器。为此，立方体需要额外的数据，定义每个顶点的法向量和颜色。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Vertex colors aren't always required for shading, but in our case, the gradient
    is very subtle, and the different color faces will help you distinguish the edges
    of the cube. We will also be doing shading calculations in the vertex shader,
    which is a faster way to do it (there are fewer vertices than raster pixels),
    but works less well for smooth objects, such as spheres. To do vertex lighting,
    you need vertex colors in the pipeline, so it also makes sense to do something
    with those colors. In this case, we choose a different color per face of the cube.
    Later in this book, you will see an example of per-pixel lighting and the difference
    it makes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点颜色并不总是需要用于着色，但在我们的情况下，渐变非常微妙，不同颜色的面将帮助您区分立方体的边缘。我们还将在顶点着色器中进行着色计算，这是一种更快的方法（顶点比光栅像素少），但对于球体等光滑对象效果不佳。要进行顶点光照，您需要在管道中使用顶点颜色，因此对这些颜色做点什么也是有意义的。在这种情况下，我们选择立方体的每个面使用不同的颜色。在本书的后面，您将看到像素级光照的示例以及它带来的差异。
- en: 'We''ll now build the app to handle our lighted cube. We''ll do this by performing
    the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建应用程序来处理我们的光照立方体。我们将通过执行以下步骤来完成：
- en: Write and compile a new shader for lighting
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并编译用于光照的新着色器
- en: Generate and define cube vertex normal vectors and colors
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和定义立方体顶点法线矢量和颜色
- en: Allocate and set up data buffers for rendering
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为渲染分配和设置数据缓冲区
- en: Define and set up a light source for rendering
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和设置用于渲染的光源
- en: Generate and set up transformation matrices for rendering
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和设置用于渲染的变换矩阵
- en: Adding shaders
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加着色器
- en: Let's write an enhanced vertex shader that can use a light source and vertex
    normals from a model.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个增强的顶点着色器，可以使用模型的光源和顶点法线。
- en: 'Right-click on the `app/res/raw` folder in the project hierarchy, go to **New**
    | **File**, and name it `light_vertex.shader`. Add the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目层次结构中的`app/res/raw`文件夹上右键单击，转到**新建** | **文件**，并命名为`light_vertex.shader`。添加以下代码：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Without going through the details of writing a lighting shader, you can see
    that the vertex color is calculated based on a formula related to the angle between
    the light ray and the surface and how far the light source is from the vertex.
    Note that we are also bringing in the `ModelView` matrix as well as the MVP matrix.
    This means that you will need to have access to both steps of the process, and
    you can't overwrite/throw away the MV matrix after you're done with it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要详细介绍编写光照着色器的细节，您可以看到顶点颜色是根据与光线和表面之间的角度以及光源与顶点之间的距离相关的公式计算的。请注意，我们还引入了`ModelView`矩阵以及MVP矩阵。这意味着您需要访问流程的两个步骤，并且在完成后不能覆盖/丢弃MV矩阵。
- en: Notice that we used a small optimization. Numeric literals (for example, `1.0`)
    use uniform space, and on certain hardware, this can cause problems, so we declare
    constants instead (refer to [http://stackoverflow.com/questions/13963765/declaring-constants-instead-of-literals-in-vertex-shader-standard-practice-or](http://stackoverflow.com/questions/13963765/declaring-constants-instead-of-literals-in-vertex-shader-standard-practice-or)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了一个小优化。数字文字（例如，`1.0`）使用统一空间，在某些硬件上可能会导致问题，因此我们改为声明常量（参考[http://stackoverflow.com/questions/13963765/declaring-constants-instead-of-literals-in-vertex-shader-standard-practice-or](http://stackoverflow.com/questions/13963765/declaring-constants-instead-of-literals-in-vertex-shader-standard-practice-or)）。
- en: There are more variables to be set in this shader, as compared to the earlier
    simple one, for the lighting calculations. We'll send these over to the draw methods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期简单着色器相比，此着色器中要设置的变量更多，用于光照计算。我们将把这些发送到绘制方法中。
- en: 'We also need a slightly different fragment shader. Right-click on the `raw`
    folder in the project hierarchy, go to **New** | **File**, and name it `passthrough_fragment.shader`.
    Add the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个略有不同的片段着色器。在项目层次结构中的`raw`文件夹上右键单击，转到**新建** | **文件**，并命名为`passthrough_fragment.shader`。添加以下代码：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The only difference in the fragment shader from the simple one is that we replace
    uniform `vec4 u_Color` with varying `vec4 v_Color` because colors are now passed
    in from the vertex shader in the pipeline. And the vertex shader now gets an array
    buffer of colors. This is a new issue that we'll need to address in our setup/draw
    code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器与简单着色器的唯一区别在于，我们用varying `vec4 v_Color`替换了uniform `vec4 u_Color`，因为颜色现在是从管道中的顶点着色器传递的。现在顶点着色器获得了一个颜色数组缓冲区。这是我们需要在设置/绘制代码中解决的新问题。
- en: 'Then, in `MainActivity`, add these variables:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`MainActivity`中添加这些变量：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Compile the shader in the `compileShaders` method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compileShaders`方法中编译着色器：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Cube normals and colors
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立方体法线和颜色
- en: Each face of a cube faces outwards in a different direction that's perpendicular
    to the face. A vector is an XYZ coordinate. One that is normalized to a length
    of 1 can be used to indicate this direction, and is called a **normal vector**.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体的每个面朝向不同的方向，与面垂直。矢量是XYZ坐标。将其归一化为长度为1的矢量可用于指示此方向，并称为**法向量**。
- en: The geometry we pass to OpenGL is defined as vertices, not faces. Therefore,
    we need to provide a normal vector for each vertex of the face, as shown in the
    following diagram. Strictly speaking, not all vertices on a given face have to
    face the same direction. This is used in a technique called **smooth shading**,
    where the lighting calculations give the illusion of a curved face instead of
    a flat one. We will be using the same normal for each face (**hard edges**), which
    also saves us time while specifying the normal data. Our array only needs to specify
    six vectors, which can be expanded into a buffer of 36 normal vectors. The same
    applies to color values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给OpenGL的几何图形是由顶点定义的，而不是面。因此，我们需要为面的每个顶点提供一个法向量，如下图所示。严格来说，并非给定面上的所有顶点都必须面向同一方向。这在一种称为**平滑着色**的技术中使用，其中光照计算给出了曲面的错觉，而不是平面的错觉。我们将对每个面使用相同的法线（**硬边缘**），这也节省了我们在指定法线数据时的时间。我们的数组只需要指定六个矢量，可以扩展为36个法向量的缓冲区。颜色值也是如此。
- en: '![Cube normals and colors](img/B05144_03_04.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![立方体法线和颜色](img/B05144_03_04.jpg)'
- en: 'Each vertex also has a color. Assuming that each face of the cube is a solid
    color, we can assign each vertex of that face the same color. In the `Cube.java`
    file, add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点也有一个颜色。假设立方体的每个面都是一个实色，我们可以将该面的每个顶点分配相同的颜色。在`Cube.java`文件中，添加以下代码：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For each face of the cube, we defined a solid color (`CUBE_COLORS_FACES`) and
    a normal vector (`CUBE_NORMALS_FACES`).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体的每个面，我们定义了一个实色（`CUBE_COLORS_FACES`）和一个法向量（`CUBE_NORMALS_FACES`）。
- en: 'Now, write a reusable method, `cubeFacesToArray`, to generate the float arrays
    actually needed in `MainActivity`. Add the following code to your `Cube` class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写一个可重复使用的方法`cubeFacesToArray`，以生成`MainActivity`中实际需要的浮点数组。将以下代码添加到您的`Cube`类中：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add this data to `MainActivity` with the other variables, as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数据添加到`MainActivity`中的其他变量中，如下所示：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can also delete the declaration of `private float cubeColor[]`, as it's
    not needed now.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以删除`private float cubeColor[]`的声明，因为现在不再需要它。
- en: Armed with a normal and color, the shader can calculate the values of each pixel
    occupied by the object.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了法向量和颜色，着色器可以计算对象占据的每个像素的值。
- en: Preparing the vertex buffers
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备顶点缓冲区
- en: The rendering pipeline requires that we set up memory buffers for the vertices,
    normals, and colors. We already have vertex buffers from before, we now need to
    add the others.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管道要求我们为顶点、法向量和颜色设置内存缓冲区。我们已经有了顶点缓冲区，现在需要添加其他缓冲区。
- en: 'Add the variables, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 添加变量，如下所示：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Prepare the buffers, and add the following code to the `prepareRenderingCube`
    method (called from `onSurfaceCreated`). (This is the first half of the full `prepareRenderingCube`
    method):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 准备缓冲区，并将以下代码添加到`prepareRenderingCube`方法（从`onSurfaceCreated`调用）。 （这是完整的`prepareRenderingCube`方法的前半部分）：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Preparing the shaders
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备着色器
- en: 'Having defined the `lighting_vertex` shader, we need to add the param handles
    to use it. At the top of the `MainActivity` class, add four more variables to
    the lighting shader params:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了`lighting_vertex`着色器，我们需要添加参数句柄来使用它。在`MainActivity`类的顶部，添加四个变量到光照着色器参数：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `prepareRenderingCube` method (which is called by `onSurfaceCreated`),
    attach the `lightVertexShader` and `passthroughFragmentShader` shaders instead
    of the simple ones, get the shader params, and enable the arrays so that they
    now read as follows. (This is the second half of `prepareRenderingCube`, continuing
    from the preceding section):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prepareRenderingCube`方法中（由`onSurfaceCreated`调用），附加`lightVertexShader`和`passthroughFragmentShader`着色器，而不是简单的着色器，获取着色器参数，并启用数组，使其现在读取如下。（这是`prepareRenderingCube`的后半部分，从前一节继续）：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you refer to the shader code that we wrote earlier, you'll notice that these
    calls to `glGetUniformLocation` and `glGetAttribLocation` correspond to the `uniform`
    and `attribute` parameters declared in those scripts, including the change of
    `cubeColorParam` from `u_Color` to now `a_Color`. This renaming is not required
    by OpenGL, but it helps us distinguish between vertex attributes and uniforms.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您参考我们之前编写的着色器代码，您会注意到这些对`glGetUniformLocation`和`glGetAttribLocation`的调用对应于那些脚本中声明的`uniform`和`attribute`参数，包括`cubeColorParam`从`u_Color`到现在的`a_Color`的更改。OpenGL不需要这种重命名，但它有助于我们区分顶点属性和统一性。
- en: Shader attributes that reference array buffers must be enabled.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 引用数组缓冲区的着色器属性必须启用。
- en: Adding a light source
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加光源
- en: Next, we'll add a light source to our scene and tell the shader its position
    when we draw. The light will be positioned just above the user.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在场景中添加一个光源，并在绘制时告诉着色器它的位置。光源将被放置在用户的正上方。
- en: 'At the top of `MainActivity`, add variables to the light position:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的顶部，添加光源位置的变量：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Calculate the position of the light by adding the following code to `onDrawEye`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码到`onDrawEye`来计算光的位置：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we're using the `view` matrix (the eye `view *` `camera`) to transform
    the light position into the current view space using the `Matrix.multiplyMV` function.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`view`矩阵（眼睛`view *` `camera`）使用`Matrix.multiplyMV`函数将光的位置转换为当前视图空间。
- en: 'Now, we just tell the shader about the light position and the viewing matrices
    it needs. Modify the `drawCube` method (called by `onDrawEye`), as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需告诉着色器光源的位置和它所需的视图矩阵。修改`drawCube`方法（由`onDrawEye`调用），如下所示：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Building and running the app
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行应用程序
- en: 'We are now ready to go. When you build and run the app, you will see a screen
    similar to the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好了。构建并运行应用程序时，您将看到类似以下截图的屏幕：
- en: '![Building and running the app](img/B05144_03_05.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: ！[构建和运行应用程序]（img/B05144_03_05.jpg）
- en: Spinning the cube
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转立方体
- en: 'The next step is a quick one. Let''s make the cube spin. This is achieved by
    rotating the `cubeTransform` matrix a little bit for each frame. We can define
    a `TIME_DELTA` value for this. Add the static variable, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步很快。让我们让立方体旋转。这是通过在每帧中稍微旋转`cubeTransform`矩阵来实现的。我们可以为此定义一个`TIME_DELTA`值。添加静态变量，如下所示：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, modify `cubeTransform` for each frame, and add the following line of
    code to the `onNewFrame` method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改每帧的`cubeTransform`，并将以下代码添加到`onNewFrame`方法：
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Matrix.rotateM` function applies a rotation to a transformation matrix
    based on an angle and an axis. In this case, we are rotating by an angle of `TIME_DELTA`
    around the axis vector (0.5, 0.5, 1). Strictly speaking, you should provide a
    normalized axis, but all that matters is the direction of the vector and not the
    magnitude.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix.rotateM`函数根据角度和轴向量对变换矩阵应用旋转。在这种情况下，我们围绕轴向量（0.5,0.5,1）旋转`TIME_DELTA`的角度。严格来说，您应该提供一个归一化的轴，但重要的是向量的方向而不是大小。'
- en: Build and run it. Now the cube is spinning. *Animazing!*
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。现在立方体正在旋转。*令人惊叹！*
- en: Hello, floor!
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，地板！
- en: Having a sense of being grounded can be important in virtual reality. It can
    be much more comfortable to feel like you're standing (or sitting) than to be
    floating in space like a bodyless eyeball. So, let's add a floor to our scene.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟现实中，有一种脚踏实地的感觉可能很重要。感觉像站着（或坐着）要比像一个无身体的眼球漂浮在空间中更舒服得多。因此，让我们在场景中添加一个地板。
- en: This should be much more familiar now. We'll have a shader, model, and rendering
    pipeline similar to the cube. So, we'll just do it without much explanation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这应该更加熟悉了。我们将有一个类似于立方体的着色器、模型和渲染管道。所以，我们将不做太多解释，就这样做吧。
- en: Shaders
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器
- en: The floor will use our `light_shader` with a small modification and a new fragment
    shader.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 地板将使用我们的`light_shader`进行一些小修改和一个新的片段着色器。
- en: 'Modify the `light_vertex.shader` by adding a `v_Grid` variable, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`v_Grid`变量来修改`light_vertex.shader`，如下所示：
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a new shader in `app/res/raw` named `grid_fragment.shader`, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/res/raw`中创建一个名为`grid_fragment.shader`的新着色器，如下所示：
- en: '[PRE57]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It may seem complicated, but all that we are doing is drawing some grid lines
    on a solid color shader. The `if` statement will detect whether we are within
    0.1 units of a multiple of 10\. If so, we draw a color that is somewhere between
    white (1, 1, 1, 1) and `v_Color`, based on the depth of that pixel, or its distance
    from the camera. `gl_FragCoord` is a built-in value that gives us the position
    of the pixel that we are rendering in window space as well as the value in the
    depth buffer (`z`), which will be within the range [0, 1]. The fourth parameter,
    `w`, is essentially the inverse of the camera's draw distance and, when combined
    with the depth value, gives the world-space depth of the pixel. The `v_Grid` variable
    has actually given us access to the world-space position of the current pixel,
    based on the local vertex position and the model matrix that we introduced in
    the vertex shader.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很复杂，但我们所做的只是在一个纯色着色器上绘制一些网格线。`if`语句将检测我们是否在10的倍数的0.1单位内。如果是，我们将绘制一个颜色，介于白色（1,1,1,1）和`v_Color`之间，根据该像素的深度或其与相机的距离。`gl_FragCoord`是一个内置值，它给出了我们在窗口空间中渲染的像素的位置，以及深度缓冲区（`z`）中的值，该值将在范围[0,1]内。第四个参数`w`本质上是相机绘制距离的倒数，当与深度值结合时，给出了像素的世界空间深度。`v_Grid`变量实际上已经让我们根据顶点着色器中引入的本地顶点位置和模型矩阵，访问了当前像素的世界空间位置。
- en: 'In `MainActivity`, add a variable for the new fragment shader:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，添加一个新的片段着色器变量：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Compile the shader in the `compileShaders` method, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compileShaders`方法中编译着色器，如下所示：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Floor model data
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地板模型数据
- en: 'Create a new Java file named `Floor` in the project. Add the floor plane coordinates,
    normals, and colors:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中创建一个名为`Floor`的新的Java文件。添加地板平面坐标、法线和颜色：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Variables
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Add all the variables that we need to `MainActivity`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们需要的所有变量添加到`MainActivity`中：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: onCreate
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onCreate
- en: 'Allocate the matrices in `onCreate`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中分配矩阵：
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: onSurfaceCreated
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onSurfaceCreated
- en: 'Add a call to `prepareRenderingFloor` in `onSufraceCreated`, which we''ll write
    as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onSufraceCreated`中添加对`prepareRenderingFloor`的调用，我们将其编写如下：
- en: '[PRE63]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: initializeScene
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: initializeScene
- en: 'Set up the `floorTransform` matrix in the `initializeScene` method:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializeScene`方法中设置`floorTransform`矩阵：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: prepareRenderingFloor
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: prepareRenderingFloor
- en: 'Here''s the complete `prepareRenderingFloor` method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的`prepareRenderingFloor`方法：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: onDrawEye
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: onDrawEye
- en: 'Calculate MVP and draw the floor in `onDrawEye`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onDrawEye`中计算MVP并绘制地板：
- en: '[PRE66]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: drawFloor
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制地板
- en: 'Define a `drawFloor` method, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`drawFloor`方法，如下所示：
- en: '[PRE67]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Build and run it. It will now look like the following screenshot:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。现在它看起来像以下的截图：
- en: '![drawFloor](img/B05144_03_06.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![drawFloor](img/B05144_03_06.jpg)'
- en: '*Woot!*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*哇！*'
- en: Hey, look at this!
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嘿，看这个！
- en: In the last part of the project, we add a feature that detects when you're looking
    at an object (the cube) and highlights it with a different color.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的最后部分，我们添加了一个功能，当您看着一个物体（立方体）时，它会用不同的颜色进行高亮显示。
- en: This is accomplished with the help of the `CardboardView` interface method,
    `onNewFrame`, which passes the current head transformation information.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`CardboardView`接口方法`onNewFrame`来实现的，该方法传递当前头部变换信息。
- en: The isLookingAtObject method
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: isLookingAtObject方法
- en: 'Let''s start with the most interesting part. We''ll borrow the `isLookingAtObject`
    method from Google''s Treasure Hunt demo. It checks whether the user is looking
    at an object by calculating where the object is in the eye space and returns true
    if the user is looking at the object. Add the following code to `MainActivity`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最有趣的部分开始。我们将从Google的寻宝演示中借用`isLookingAtObject`方法。它通过计算对象在眼睛空间中的位置来检查用户是否正在看着一个对象，并在用户看着对象时返回true。在`MainActivity`中添加以下代码：
- en: '[PRE68]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The method takes two arguments: the `modelView` and `modelTransform` transformation
    matrices of the object we want to test. It also references the `headView` class
    variable, which we''ll set in `onNewFrame`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：我们要测试的对象的`modelView`和`modelTransform`变换矩阵。它还引用了`headView`类变量，我们将在`onNewFrame`中设置。
- en: A more precise way to do this might be to cast a ray from the camera into the
    scene in the direction in which the camera is looking and determines whether it
    intersects any geometry in the scene. This will be very effective but also very
    computationally expensive.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更精确的方法是从相机向场景中的方向发射一条射线，并确定它是否与场景中的任何几何体相交。这将非常有效，但也非常消耗计算资源。
- en: Instead, this function takes a simpler approach and doesn't even use the geometry
    of the object. It rather uses the object's view transform to determine how far
    the object is from the center of the screen and tests whether the angle of that
    vector is within a narrow range (`PITCH_LIMIT` and `YAW_LIMIT`). *Yeah I know,
    people get PhDs to come up with this stuff!*
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这个函数采用了更简单的方法，甚至不使用对象的几何形状。它使用对象的视图变换来确定对象距离屏幕中心有多远，并测试该向量的角度是否在一个狭窄的范围内（`PITCH_LIMIT`和`YAW_LIMIT`）。*是的，我知道，人们获得博士学位来想出这些东西！*
- en: 'Let''s define the variables that we need as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式定义我们需要的变量：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Allocate `headView` in `onCreate`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中分配`headView`：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Get the current `headView` value on each new frame. Add the following code
    to `onNewFrame`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧新的`headView`值。在`onNewFrame`中添加以下代码：
- en: '[PRE71]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, modify `drawCube` to check whether the user is looking at the cube and
    decide which colors to use:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`drawCube`以检查用户是否正在看着立方体，并决定使用哪种颜色：
- en: '[PRE72]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*That''s it!* Except for one (minor) detail: we need a second set of vertex
    colors for the highlight mode. We''ll highlight the cube by drawing all the faces
    with the same yellow color. There are a few changes to be made in order to make
    this happen.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*就是这样！*除了一个（微小的）细节：我们需要第二组顶点颜色用于突出显示模式。我们将通过使用相同的黄色绘制所有面来突出显示立方体。为了实现这一点，需要进行一些更改。'
- en: 'In `Cube`, add the following RGBA values:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cube`中，添加以下RGBA值：
- en: '[PRE73]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `MainActivity`, add these variables:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，添加这些变量：
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the following code to the `prepareRenderingCube` method:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`prepareRenderingCube`方法中：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Build and run it. When you look directly at the cube, it gets highlighted.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。当你直接看着立方体时，它会被突出显示。
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It may be more fun and challenging if the cubes weren't so close. Try setting
    `cubeDistance` to something like *12f*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果立方体不那么接近，可能会更有趣和具有挑战性。尝试将`cubeDistance`设置为*12f*。
- en: Like the Treasure Hunt demo, try setting a new set of random values for the
    cube position every time you look at it. Now, you have a game!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 就像寻宝演示一样，尝试每次看着它时设置一个新的随机立方体位置。现在，你有了一个游戏！
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a Cardboard Android app from scratch, starting with
    a new project and adding Java code a little bit at a time. In our first build,
    we had a stereoscopic view of a triangle that you can see in a Google Cardboard
    headset.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始构建了一个Cardboard Android应用，从一个新项目开始，逐渐添加Java代码。在我们的第一个构建中，我们有一个三角形的立体视图，你可以在Google
    Cardboard头盔中看到。
- en: We then added the model transformation, 3D camera views, perspective and head
    rotation transformations, and discussed a bit about matrix mathematics. We built
    a 3D model of a cube, and then created shader programs to use a light source to
    render the cube with shading. We also animated the cube and added a floor grid.
    Lastly, we added a feature that highlights the cube when the user is looking at
    it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了模型变换、3D摄像机视图、透视和头部旋转变换，并讨论了一些关于矩阵数学的内容。我们建立了一个立方体的3D模型，然后创建了着色器程序，使用光源来渲染带有阴影的立方体。我们还为立方体添加了动画，并添加了一个地板网格。最后，我们添加了一个功能，当用户看着立方体时，它会被突出显示。
- en: Along the way, we enjoyed good discussions of 3D geometry, OpenGL, shaders,
    matrix math for 3D perspective viewing, geometric normals, and data buffers for
    the rendering pipeline. We also started thinking about the ways in which you can
    abstract common patterns in the code into reusable methods.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们享受了关于3D几何、OpenGL、着色器、用于渲染管线的几何法线和数据缓冲区的良好讨论。我们还开始思考如何将代码中的常见模式抽象为可重用的方法。
- en: In the next chapter, we will take a different approach to stereoscopic rendering
    using Android layout views to build a useful "virtual lobby" that can be used
    as a 3D menu system or portal into other worlds.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采用不同的方法来使用Android布局视图进行立体渲染，构建一个有用的“虚拟大厅”，可以用作3D菜单系统或通往其他世界的门户。
