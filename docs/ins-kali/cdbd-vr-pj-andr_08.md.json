["```kt\npublic class MainActivity extends CardboardActivity implements IRenderBox {\n    private static final String TAG = \"ModelViewer\";\n    CardboardView cardboardView;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        cardboardView = (CardboardView) findViewById(R.id.cardboard_view);\n        cardboardView.setRenderer(new RenderBox(this, this));\n        setCardboardView(cardboardView);\n    }\n    @Override\n    public void setup() {\n    }\n    @Override\n    public void preDraw() {\n        // code run beginning each frame\n    }\n    @Override\n    public void postDraw() {\n        // code run end of each frame\n    }\n}\n```", "```kt\n    public void setup() {\n        new Transform()\n            .setLocalPosition(0,0,-7)\n            .setLocalRotation(45,60,0)\n            .addComponent(new Cube(true));\n    }\n```", "```kt\n# Simple Wavefront file\nv 0.0 0.0 0.0\nv 0.0 1.0 0.0\nv 1.0 0.0 0.0\nf 1 2 3\n```", "```kt\npublic class ModelObject extends RenderObject {\n}\n```", "```kt\n    public ModelObject(int objFile) {\n        super();\n        InputStream inputStream = RenderBox.instance.mainActivity.getResources().openRawResource(objFile);\n        if (inputStream == null)\n            return; // error\n        parseObj(inputStream);\n        createMaterial();\n    }\n```", "```kt\n    public static FloatBuffer vertexBuffer;\n    public static FloatBuffer colorBuffer;\n    public static FloatBuffer normalBuffer;\n    public static ShortBuffer indexBuffer;\n    public int numIndices;\n```", "```kt\n    public ModelObject createMaterial(){\n        SolidColorLightingMaterial scm = new SolidColorLightingMaterial(new float[]{0.5f, 0.5f, 0.5f, 1});\n        scm.setBuffers(vertexBuffer, normalBuffer, indexBuffer, numIndices);\n        material = scm;\n        return this;\n    }\n```", "```kt\n    Vector<Short> faces=new Vector<Short>();\n    Vector<Short> vtPointer=new Vector<Short>();\n    Vector<Short> vnPointer=new Vector<Short>();\n    Vector<Float> v=new Vector<Float>();\n    Vector<Float> vn=new Vector<Float>();\n    Vector<Material> materials=null;\n```", "```kt\n    void parseObj(InputStream inputStream) {\n        BufferedReader reader = null;\n        String line = null;\n\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n        if (reader == null)\n            return; // error\n\n        try { // try to read lines of the file\n            while ((line = reader.readLine()) != null) {\n                parseLine(line);\n            }\n            buildBuffers();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```", "```kt\n    private void parseLine(String line) {\n        Log.v(\"obj\", line);\n        if(line.startsWith(\"f\")){//a polygonal face\n            processFLine(line);\n        }\n        else\n        if(line.startsWith(\"vn\")){\n            processVNLine(line);\n        }\n        else\n        if(line.startsWith(\"v\")){ //line having geometric position of single vertex\n            processVLine(line);\n        }\n    }\n\n    private void processVLine(String line){\n        String [] tokens=line.split(\"[ ]+\"); \n        //split the line at the spaces\n        int c=tokens.length;\n        for(int i=1; i<c; i++){ //add the vertex to the vertex array\n            v.add(Float.valueOf(tokens[i]));\n        }\n    }\n\n    private void processVNLine(String line){\n        String [] tokens=line.split(\"[ ]+\"); \n        //split the line at the spaces\n        int c=tokens.length;\n        for(int i=1; i<c; i++){ //add the vertex to the vertex array\n            vn.add(Float.valueOf(tokens[i]));\n        }\n    }\n```", "```kt\n    private void processFLine(String line){\n        String [] tokens=line.split(\"[ ]+\");\n        int c=tokens.length;\n\n        if(tokens[1].matches(\"[0-9]+\")){//f: v\n            if(c==4){//3 faces\n                for(int i=1; i<c; i++){\n                    Short s=Short.valueOf(tokens[i]);\n                    s--;\n                    faces.add(s);\n                }\n            }\n        }\n    }\n```", "```kt\n    public static Vector<Short> triangulate(Vector<Short> polygon){\n        Vector<Short> triangles=new Vector<Short>();\n        for(int i=1; i<polygon.size()-1; i++){\n            triangles.add(polygon.get(0));\n            triangles.add(polygon.get(i));\n            triangles.add(polygon.get(i+1));\n        }\n        return triangles;\n    }\n```", "```kt\n    private void processFLine(String line) {\n        String[] tokens = line.split(\"[ ]+\");\n        int c = tokens.length;\n\n        if (tokens[1].matches(\"[0-9]+\") || //f: v\n            tokens[1].matches(\"[0-9]+/[0-9]+\")) {//f: v/vt\n\n            if (c == 4) {//3 faces\n                for (int i = 1; i < c; i++) {\n                    Short s = Short.valueOf(tokens[i]);\n                    s--;\n                    faces.add(s);\n                }\n            }\n            else{//more faces\n                Vector<Short> polygon=new Vector<Short>();\n                for(int i=1; i<tokens.length; i++){\n                    Short s=Short.valueOf(tokens[i]);\n                    s--;\n                    polygon.add(s);\n                }\n                faces.addAll(triangulate(polygon));\n                //triangulate the polygon and //add the resulting faces\n            }\n        }\n        //if(tokens[1].matches(\"[0-9]+//[0-9]+\")){//f: v//vn\n        //if(tokens[1].matches(\"[0-9]+/[0-9]+/[0-9]+\")){\n\t\t//f: v/vt/vn\n    }\n```", "```kt\n    if(tokens[1].matches(\"[0-9]+//[0-9]+\")){//f: v//vn\n        if(c==4){//3 faces\n            for(int i=1; i<c; i++){\n                Short s=Short.valueOf(tokens[i].split(\"//\")[0]);\n                s--;\n                faces.add(s);\n                s=Short.valueOf(tokens[i].split(\"//\")[1]);\n                s--;\n                vnPointer.add(s);\n            }\n        }\n        else{//triangulate\n            Vector<Short> tmpFaces=new Vector<Short>();\n            Vector<Short> tmpVn=new Vector<Short>();\n            for(int i=1; i<tokens.length; i++){\n                Short s=Short.valueOf(tokens[i].split(\"//\")[0]);\n                s--;\n                tmpFaces.add(s);\n                s=Short.valueOf(tokens[i].split(\"//\")[1]);\n                s--;\n                tmpVn.add(s);\n            }\n            faces.addAll(triangulate(tmpFaces));\n            vnPointer.addAll(triangulate(tmpVn));\n        }\n    }\n```", "```kt\n    if(tokens[1].matches(\"[0-9]+/[0-9]+/[0-9]+\")){//f: v/vt/vn\n        if(c==4){//3 faces\n            for(int i=1; i<c; i++){\n                Short s=Short.valueOf(tokens[i].split(\"/\")[0]);\n                s--;\n                faces.add(s);\n                // (skip vt)\n                s=Short.valueOf(tokens[i].split(\"/\")[2]);\n                s--;\n                vnPointer.add(s);\n            }\n        }\n        else{//triangulate\n            Vector<Short> tmpFaces=new Vector<Short>();\n            Vector<Short> tmpVn=new Vector<Short>();\n            for(int i=1; i<tokens.length; i++){\n                Short s=Short.valueOf(tokens[i].split(\"/\")[0]);\n                s--;\n                tmpFaces.add(s);\n                // (skip vt)\n                s=Short.valueOf(tokens[i].split(\"/\")[2]);\n                s--;\n                tmpVn.add(s);\n            }\n            faces.addAll(triangulate(tmpFaces));\n            vnPointer.addAll(triangulate(tmpVn));\n        }\n    }\n```", "```kt\n                   if (s < 0)\n                       s = (short)(s + v.size());\n                   else\n                       s--;\n```", "```kt\n    private void buildBuffers() {\n        numIndices = faces.size();\n        float[] tmp = new float[v.size()];\n        int i = 0;\n        for(Float f : v)\n            tmp[i++] = (f != null ? f : Float.NaN);\n        vertexBuffer = allocateFloatBuffer(tmp);\n\n        i = 0;\n        tmp = new float[vn.size()];\n        for(Float f : vn)\n            tmp[i++] = (f != null ? -f : Float.NaN); \n            //invert normals\n        normalBuffer = allocateFloatBuffer(tmp);\n\n        i = 0;\n        short[] indicies = new short[faces.size()];\n        for(Short s : faces)\n            indicies[i++] = (s != null ? s : 0);\n        indexBuffer = allocateShortBuffer(indicies);\n    }\n```", "```kt\n    public Vector3 extentsMin, extentsMax;\n```", "```kt\n    public ModelObject(int objFile) {\n        super();\n        extentsMin = new Vector3(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE);\n        extentsMax = new Vector3(Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE);\n        . . .\n```", "```kt\n    private void processVLine(String line) {\n        String[] tokens = line.split(\"[ ]+\"); \n        //split the line at the spaces\n        int c = tokens.length;\n        for (int i = 1; i < c; i++) { //add the vertex to the vertex array\n            Float value = Float.valueOf(tokens[i]);\n            v.add(value);\n            setExtents(i, value);\n        }\n    }\n```", "```kt\n    private void setExtents(int coord, Float value) {\n        switch (coord) {\n            case 1:\n                if (value < extentsMin.x)\n                    extentsMin.x = value;\n                if (value > extentsMax.x)\n                    extentsMax.x = value;\n                break;\n            case 2:\n                if (value < extentsMin.y)\n                    extentsMin.y = value;\n                if (value > extentsMax.y)\n                    extentsMax.y = value;\n                break;\n            case 3:\n                if (value < extentsMin.z)\n                    extentsMin.z = value;\n                if (value > extentsMax.z)\n                    extentsMax.z = value;\n                break;\n        }\n    }\n```", "```kt\n    public float normalScalar() {\n        float sizeX = (extentsMax.x - extentsMin.x);\n        float sizeY = (extentsMax.y - extentsMin.y);\n        float sizeZ = (extentsMax.z - extentsMin.z);\n        return (2.0f / Math.max(sizeX, Math.max(sizeY, sizeZ)));\n    }\n```", "```kt\n    Transform model;\n```", "```kt\n    public void setup() {\n        ModelObject modelObj = new ModelObject(R.raw.teapot);\n        float scalar = modelObj.normalScalar();\n        model = new Transform()\n                .setLocalPosition(0, 0, -3)\n                .setLocalScale(scalar, scalar, scalar)\n                .addComponent(modelObj);\n    }\n```", "```kt\n                .setLocalPosition(0, -2, -3) \n```", "```kt\n    public void preDraw() {\n        float[] hAngles = RenderBox.instance.headAngles;\n        Quaternion rot = new Quaternion();\n        rot.setEulerAnglesRad(hAngles[0], hAngles[1], hAngles[2]);\n        model.setLocalRotation(rot.conjugate());\n    }\n```", "```kt\n                .setLocalPosition(0, 0, -3)\n```", "```kt\n    public boolean headTracking = true;\n```", "```kt\n        if (headTracking) {\n            // Apply the eye transformation to the camera.\n            Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);\n        } else {\n             // copy camera into view\n            for (int i=0; i < camera.length; i++) { view[i] = camera[i]; }\n        }\n```", "```kt\n        RenderBox.instance.mainCamera.headTracking = false;\n```", "```kt\n    public ModelObject(final int objFile) {\n        super();\n        extentsMin = new Vector3(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE);\n        extentsMax = new Vector3(Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE);\n\n        SolidColorLightingMaterial.setupProgram();\n        enabled = false;\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                InputStream inputStream = RenderBox.instance.mainActivity.getResources().openRawResource(objFile);\n                if (inputStream == null)\n                    return; // error\n                createMaterial();\n                enabled = true;\n                float scalar = normalScalar();\n                transform.setLocalScale(scalar, scalar, scalar);\n            }\n        }).start();\n    }\n```", "```kt\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"file\" />\n                <data android:mimeType=\"*/*\" />\n                <data android:pathPattern=\".*\\\\.obj\" />\n                <data android:host=\"*\" />\n            </intent-filter>\n```", "```kt\n    public ModelObject(final String uri) {\n        super();\n        extentsMin = new Vector3(Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE);\n        extentsMax = new Vector3(Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE);\n        SolidColorLightingMaterial.setupProgram();\n        enabled = false;\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                File file = new File(uri.toString());\n                FileInputStream fileInputStream;\n                try {\n                    fileInputStream = new FileInputStream(file);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return; // error\n                }\n                parseObj(fileInputStream);\n                createMaterial();\n                enabled = true;\n                float scalar = normalScalar();\n                transform.setLocalScale(scalar, scalar, scalar);\n            }\n        }).start();\n    }\n```", "```kt\n    public void setup() {\n        ModelObject modelObj;\n        Uri intentUri = getIntent().getData();\n        if (intentUri != null) {\n            Log.d(TAG, \"!!!! intent \" + intentUri.getPath());\n            modelObj = new ModelObject(intentUri.getPath());\n        } else {\n            // default object\n            modelObj = new ModelObject(R.raw.teapot);\n        }\n        //...        \n```"]