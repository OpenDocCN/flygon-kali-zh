["```kt\n/*Sample Loop created within OnDraw()on Canvas \n* This loop works with 2D android game development\n*/\n@Override\npublic void onDraw(Canvas canvas)\n{\n  //If the game loop is active then only update and render\n  if(gameRunning)\n  {\n    //update game state\n    MainGameUpdate();\n\n    //set rendering pipeline for updated game state\n    RenderFrame(canvas);\n    //Invalidate previous frame, so that updated pipeline can be\n    // rendered\n    //Calling invalidate() causes recall of onDraw()\n    invalidate();\n  }\n  else\n  {\n    //If there is no active game loop\n    //Exit the game\n    System.exit(0);\n  }\n}\n```", "```kt\n/* Called When a surface is changed */\n@Override\npublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n{\n}\n/* Called on create of a SurfaceView */\n@Override\npublic void surfaceCreated(SurfaceHolder holder)\n{\n}\n/* Called on destroy of a SurfaceView is destroyed */\n@Override\npublic void surfaceDestroyed(SurfaceHolder holder)\n{\n}\n```", "```kt\npublic class BaseGameThread extends Thread\n{\n  private boolean isGameRunning;\n  private SurfaceHolder currentHolder;\n  private MyGameState currentState;\n  public void activateGameThread(SurfaceHolder holder, MyGameState state)\n  {\n    currentState = state;\n    isGameRunning = true;\n    currentHolder = holder;\n    this.start();\n  }\n\n  @Override\n  public void run()\n  {\n    Canvas gameCanvas = null;\n    while(isGameRunning)\n    {\n      //clear canvas\n      gameCanvas = null;\n      try\n      {\n        //locking the canvas for screen pixel editing\n        gameCanvas  = currentHolder.lockCanvas();\n        //Update game state\n        currentState.update();\n        //render game state\n        currentState.render(gameCanvas);\n      }\n      catch(Exception e)\n      {\n        //Update game state without rendering (Optional)\n        currentState.update();\n      }\n    }\n  }\n}\n```", "```kt\npublic myGameCanvas extends SurfaceView implements SurfaceHolder\n{\n  //Declare thread\n  private BaseGameThread gameThread;\n  private MyGameState gameState;\n  @Override\n  public void surfaceCreated(SurfaceHolder holder)\n  {\n    //Initialize game state\n    gameState = new MyGameState();\n    //Instantiate game thread\n    gameThread = new BaseGameThread();\n    //Start game thread\n    gameThread. activateGameThread(this.getHolder(),gameState);\n  }\n\n  @Override\n  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)\n  {\n  }\n\n  @Override\n  public void surfaceDestroyed(SurfaceHolder holder)\n{\n}\n}\n```", "```kt\n/* import proper view and implement touch listener */\npublic class MyGameView extends View implements View.OnTouchListener\n/* declare game state */\nprivate MyGameState gameState;\n/* set listener */\npublic MyGameView (Context context)\n{\n  super(context);\n  setOnTouchListener(this);\n  setFocusableInTouchMode(true);\n  gameState = new MyGameState();\n}\n\n/* override onTouch() and call state update on individual touch events */\n@Override\npublic boolean onTouch(View v, MotionEvent event) \n{\n  if(event.getAction() == MotionEvent.ACTION_UP)\n  {\n    //call changes in current state on touch release\n    gameState.handleInputTouchRelease((int)event.getX(), (int)event.getY());\n    return false;\n  }\n  else if(event.getAction() == MotionEvent.ACTION_DOWN)\n  {\n    //call changes in current state on touch begin\n    gameState.handleInputTouchEngage((int)event.getX(), (int)event.getY());\n  }\n  else if(event.getAction() == MotionEvent.ACTION_MOVE)\n  {\n    //call changes in current state on touch drag\n    gameState.handleInputTouchDrag((int)event.getX(), (int)event.getY());\n  }\n  return true;\n}\n```", "```kt\nPoint touchBegin = null;\nPoint touchDragged = null;\nPoint touchEnd = null;\n\n@Override\npublic boolean onTouch(View v, MotionEvent event)\n{\n  if(event.getAction() == MotionEvent.ACTION_UP)\n  {\n    touchEnd = new Point(int)event.getX(), (int)event.getY());\n    return false;\n  }\n  else if(event.getAction() == MotionEvent.ACTION_DOWN)\n  {\n    touchBegin = new Point(int)event.getX(), (int)event.getY());\n\n  }\n  else if(event.getAction() == MotionEvent.ACTION_MOVE)\n  {\n    touchDragged = new Point(int)event.getX(), (int)event.getY());\n\n  }\n  return true;\n}\n\n/* declare checking input mechanism */\nprivate void checkUserInput() \n{\n  if(touchBegin != null)\n  {\n    //call changes in current state on touch begin\n    gameState. handleInputTouchEngage (touchBegin);\n    touchBegin = null;\n  }\n\n  if(touchDragged != null)\n  {\n    //call changes in current state on touch drag\n    gameState. handleInputTouchDrag (touchDragged);\n    touchDragged = null;\n  }\n\n  if(touchEnd != null)\n{\n    //call changes in current state on touch release  \n    gameState.handleInputTouchRelease (touchEnd);\n    touchEnd = null;\n  }\n}\n\n/* finally we need to invoke checking inside game loop */\n@Override\npublic void onDraw(Canvas canvas)\n{\n  //If the game loop is active then only update and render\n  if(gameRunning)\n  {\n    //check user input\n    checkUserInput();\n    //update game state\n    MainGameUpdate();\n\n    //set rendering pipeline for updated game state\n    RenderFrame(canvas);\n    //Invalidate previous frame, so that updated pipeline can be\n    // rendered\n    //Calling invalidate() causes recall of onDraw()\n    invalidate();\n  }\n  else\n  {\n    //If there is no active game loop\n    //Exit the game\n    System.exit(0);\n  }\n}\n```", "```kt\n@Override\nprotected void onPause() \n{\n  super.onPause();\n  // pause and save game loop here\n}\n// When control is given back to application, then onResume() is // called.\n@Override\nprotected void onResume() \n{\n  super.onResume();\n  //resume the game loop here\n}\n```", "```kt\nprivate static boolean gamePaused = false;\n@Override\npublic void onDraw(Canvas canvas)\n{\n  if(gameRunning && ! gamePaused)\n  {\n    MainGameUpdate();\n    RenderFrame(canvas);\n\n    invalidate();\n  }\n  else if(! gamePaused)\n  {\n    //If there is no active game loop\n    //Exit the game\n    System.exit(0);\n  }\n}\n\npublic static void enableGameLoop(boolean enable)\n{\n  gamePaused = enable;\n  if(!gamePaused)\n  {\n    //invalidation of previous draw has to be called from static\n    // instance of current View class\n    this.invalidate();\n  }\n  else\n  {\n    //save state\n  }\n}\n```", "```kt\npublic class MainStateManager\n{\n  private int currentStateId;\n  //setting up state IDs\n  public Interface GameStates\n  {\n    public static final int STATE_1 = 0;\n    public static final int STATE_2 = 1;\n    public static final int STATE_3 = 2;\n    public static final int STATE_4 = 3; \n  }\n\n  private void initializeState(int stateId)\n  {\n    currentStateId = stateId;\n    switch(currentStateId)\n    {\n      case STATE_1:\n        // initialize/load state 1\n      break;\n      case STATE_2:\n        // initialize/load state 2\n      break;\n      case STATE_3:\n        // initialize/load state 3\n      break;\n      case STATE_4:\n        // initialize/load state 4\n      break;\n    }\n  }\n}\n/*\n* update is called in every cycle of game loop.\n* make sure that the state is already initialized before updating the state\n*/\nprivate void updateState()\n{\n  switch(currentStateId)\n  {\n    case STATE_1:\n      // Update state 1\n    break;\n    case STATE_2:\n      // Update state 2\n    break;\n    case STATE_3:\n      // Update state 3\n    break;\n    case STATE_4:\n      // Update state 4\n    break;\n  }\n}\n/*\n* render is called in every cycle of game loop.\n* make sure that the state is already initialized before updating the state\n*/\nprivate void renderState()\n{\n  switch(currentStateId)\n  {\n    case STATE_1:\n      // Render state 1\n    break;\n    case STATE_2:\n      // Render state 2\n    break;\n    case STATE_3:\n      // Render state 3\n    break;\n    case STATE_4:\n      // Render state 4\n    break;\n  }\n}\n/*\n* Change state can be triggered from outside of manager or from any other state\n* This should be responsible for destroying previous state and free memory and initialize new state\n*/\npublic void changeState(int nextState)\n{\n  switch(currentStateId)\n  {\n    case STATE_1:\n      // Destroy state 1\n    break;\n    case STATE_2:\n      // Destroy state 2\n    break;\n    case STATE_3:\n      // Destroy state 3\n    break;\n    case STATE_4:\n      // Destroy state 4\n    break;\n  }\n  initializeState(nextState);\n}\n}\n```", "```kt\nlong startTime;\nlong endTime;\npublic final int TARGET_FPS = 60;\n\n@Override\npublic void onDraw(Canvas canvas)\n{\n  if(isRunning)\n  {\n    startTime = System.currentTimeMillis();\n    //update and paint in game cycle\n    MainGameUpdate();\n\n    //set rendering pipeline for updated game state\n    RenderFrame(canvas);\n\n    endTime = System.currentTimeMillis();\n    long delta = endTime - startTime;\n    long interval = (1000 - delta)/TARGET_FPS;\n\n    try\n    {\n      Thread.sleep(interval);\n    }\n    catch(Exception ex)\n    {}\n    invalidate();\n  }\n}\n```", "```kt\nlong startTime;\nlong endTime;\npublic final int TARGET_FPS = 60;\n@Override\npublic void run()\n{\n  Canvas gameCanvas = null;\n  while(isGameRunning)\n  {\n    startTime = System.currentTimeMillis();\n    //clear canvas\n    gameCanvas = null;\n    try\n    {\n      //locking the canvas for screen pixel editing\n      gameCanvas  = currentHolder.lockCanvas();\n      //Update game state\n      currentState.update();\n      //render game state\n      currentState.render(gameCanvas);\n      endTime = System.currentTimeMillis();\n      long delta = endTime - startTime;\n      long interval = (1000 - delta)/TARGET_FPS;\n\n      try\n      {\n        Thread.sleep(interval);\n      }\n      catch(Exception ex) \n      {}\n    }\n    Catch(Exception e)\n    {\n      //Update game state without rendering (Optional)\n      currentState.update();\n    }\n  }\n}\n```", "```kt\nchar[] name = \"my name is android\";\nfor(int i = 0; i < name.length; i ++)\n{\n  //some operation\n}\n```", "```kt\nchar[] name = \"my name is android\";\nint length = name.length;\nfor(int i = 0; i < length; ++ i)\n{\n  //some operation\n}\n```", "```kt\nlong startTime;\nlong endTime;\npublic static in ACTUAL_FPS = 0;\n\n@Override\npublic void onDraw(Canvas canvas)\n{\n  if(isRunning)\n  {\n    startTime = System.currentTimeMillis();\n    //update and paint in game cycle\n    MainGameUpdate();\n\n    //set rendering pipeline for updated game state\n    RenderFrame(canvas);\n\n    endTime = System.currentTimeMillis();\n    long delta = endTime - startTime;\n    ACTUAL_FPS = 1000 / delta;\n    invalidate();\n  }\n}\n```", "```kt\nlong startTime;\nlong endTime;\npublic final int TARGET_FPS = 60;\npublic static int ACTUAL_FPS = 0;\n\n@Override\npublic void onDraw(Canvas canvas)\n{\n  if(isRunning)\n  {\n    startTime = System.currentTimeMillis();\n    //update and paint in game cycle\n    MainGameUpdate();\n\n    //set rendering pipeline for updated game state\n    RenderFrame(canvas);\n\n    endTime = System.currentTimeMillis();\n    long delta = endTime - startTime;\n\n    //hybrid system begins\n    if(delta < 1000)\n    {\n      long interval = (1000 - delta)/TARGET_FPS;\n      ACTUAL_FPS = TARGET_FPS;\n      try\n      {\n        Thread.sleep(interval);\n      }\n      catch(Exception ex) \n      {}\n    }\n    else\n    {\n      ACTUAL_FPS = 1000 / delta;\n    }\n    invalidate();\n  }\n}\n```"]