- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*'
- en: OOP in Depth
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解面向对象编程
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this lesson, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课结束时，您将能够：
- en: Implement interfaces in Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中实现接口
- en: Perform typecasting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行类型转换
- en: Utilize the `Object` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`Object`类
- en: Work with abstract classes and methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类和方法
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous lesson, we looked at the basics of object-oriented programming,
    such as classes and objects, inheritance, polymorphism, and overloading.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，我们看了面向对象编程的基础知识，如类和对象、继承、多态和重载。
- en: We saw how classes act as a blueprint from which we can create objects, and
    saw how methods define the behavior of a class while fields hold the state.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到类如何作为一个蓝图，我们可以从中创建对象，并看到方法如何定义类的行为，而字段保存状态。
- en: We looked at how a class can acquire properties from another class through inheritance
    to enable us to reuse code. Then, we learned how we can reuse a method name through
    overloading – that is, as long as they have different signatures. Finally, we
    had a look at how subclasses can redefine their own unique behavior by overriding
    methods from the superclass.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一个类如何通过继承从另一个类获得属性，以便我们可以重用代码。然后，我们学习了如何通过重载重用方法名称 - 也就是说，只要它们具有不同的签名。最后，我们看了子类如何通过覆盖超类的方法重新定义自己独特的行为。
- en: In this lesson, we will delve deeper into the principles of object-oriented
    programming and how to better structure our Java programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将深入探讨面向对象编程的原则，以及如何更好地构建我们的Java程序。
- en: We will start with interfaces, which are constructs that allow us to define
    a generic behavior that any class can implement. We will then learn about a concept
    called **typecasting**, whereby we can change a variable from one type to another
    and back. In the same manner, we will deal with primitive data types as objects
    by using wrapper classes that are provided by Java. We will finish off with a
    detailed look at abstract classes and methods, which is a way to let users who
    are inheriting your class to run their own unique implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从接口开始，这些构造允许我们定义任何类都可以实现的通用行为。然后，我们将学习一个称为**类型转换**的概念，通过它我们可以将一个变量从一种类型转换为另一种类型，然后再转回来。同样，我们将使用Java提供的包装类将原始数据类型作为对象处理。最后，我们将详细了解抽象类和方法，这是一种让继承您的类的用户运行其自己独特实现的方法。
- en: In this lesson, we will walk through three activities by using the `Animal`
    class we created in the previous lesson. We will also be using our `Person` class
    to demonstrate some of these concepts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们将通过使用我们在上一课创建的“动物”类来进行三个活动。我们还将使用我们的“人”类来演示一些概念。
- en: Let's get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Interfaces
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: In Java, you can use interfaces to provide a set of methods that classes must
    implement for them to be conformant.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，您可以使用接口提供一组类必须实现的方法。
- en: Let's take the example of our `Person` class. We want to define a set of actions
    that define the behavior of any person, regardless of their age or gender.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的“人”类为例。我们想定义一组行为，定义任何人的行为，而不管他们的年龄或性别。
- en: A few examples of these actions include sleeping, breathing, and moving/walking.
    We can place all of these common actions in an interface and let any class that
    claims to be a person implement them. A class that implements this interface is
    often referred to as being of the type `Person`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的一些示例包括睡觉、呼吸和移动/行走。我们可以将所有这些常见操作放在一个接口中，让任何声称是人的类来实现它们。实现此接口的类通常被称为“人”类型。
- en: In Java, we use the keyword interface to denote that the following block will
    be an interface. All the methods in an interface are empty and are not implemented.
    This is because any class that will implement this interface will provide its
    unique implementation details. Therefore, an interface is essentially a group
    of methods with no bodies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们使用关键字interface来表示接下来的代码块将是一个接口。接口中的所有方法都是空的，没有实现。这是因为任何实现此接口的类都将提供其独特的实现细节。因此，接口本质上是一组没有主体的方法。
- en: 'Let''s create an interface to define the behavior of a person:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个接口来定义一个人的行为：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This interface is called `PersonBehavior` and it contains three methods: one
    to breathe, another one to sleep, and one to walk at a given speed. Every class
    that implements this interface will have to also implement these three methods.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口称为`PersonBehavior`，它包含三个方法：一个用于呼吸，另一个用于睡觉，还有一个用于以给定速度行走。实现此接口的每个类都必须实现这三个方法。
- en: We use the `implements` keyword after a class name, followed by the interface
    name, when we want to implement a given interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要实现一个给定的接口时，我们在类名后面使用`implements`关键字，然后是接口名。
- en: 'Let''s see this with an example. We will create a new class called `Doctor`
    to represent doctors. This class will implement the `PersonBehavior` interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子。我们将创建一个新的类`Doctor`来代表医生。这个类将实现`PersonBehavior`接口：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because we have stated that we want to conform to the `PersonBehavior` interface,
    the compiler will give us an error if we don''t implement the three methods in
    the interface:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经声明要符合`PersonBehavior`接口，如果我们不实现接口中的三个方法，编译器将给出错误。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the `@Override` annotation to indicate that this method is from the interface.
    Inside these methods, we are free to perform any kind of operations that are relevant
    to our `Doctor` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Override`注解来指示这个方法来自接口。在这些方法中，我们可以自由地执行与我们的“医生”类相关的任何操作。
- en: 'In the same spirit, we can also create an `Engineer` class that implements
    the same interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的精神下，我们也可以创建一个实现相同接口的“工程师”类：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In *Lesson 1*, *Introduction to Java*, we mentioned abstraction as one of the
    underlying principles of OOP. Abstraction is a way for us to provide a consistent
    interface to our classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1课*，*Java简介*中，我们提到抽象是面向对象编程的基本原则之一。抽象是我们为类提供一致的接口的一种方式。
- en: Let's use a mobile phone as an example. With a mobile phone, you are able to
    call and text your friends. When calling, you press the call button and immediately
    get connected to a friend. That call button forms an interface between you and
    your friend. We don't really know what happens when we press the button because
    all those details are abstracted (hidden) from us.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以手机为例。使用手机，您可以给朋友打电话和发短信。打电话时，您按下通话按钮，立即与朋友连接。该通话按钮形成了您和朋友之间的接口。我们并不真正知道按下按钮时会发生什么，因为所有这些细节都对我们进行了抽象（隐藏）。
- en: You will often hear the term **API**, which stands for Application Programming
    Interface. It is a way for different software to speak to each other in harmony.
    An example is when you want to log in to an app using Facebook or Google. The
    application will call the Facebook or Google API. The Facebook API will then define
    the rules to be followed to log in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会听到**API**这个术语，它代表应用程序编程接口。这是不同软件和谐交流的一种方式。例如，当您想要使用Facebook或Google登录应用程序时。应用程序将调用Facebook或Google
    API。然后Facebook API将定义要遵循的登录规则。
- en: 'A class in Java can implement more than one interface. These extra interfaces
    are separated by a comma. The class must provide implementations for all the methods
    it promises to implement in the interfaces:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的类可以实现多个接口。这些额外的接口用逗号分隔。类必须为接口中它承诺实现的所有方法提供实现：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use Case: Listeners'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例：监听器
- en: One of the most important uses of interfaces is creating listeners for conditions
    or events in your programs. Basically, a listener notifies you of any state changes
    when an action takes place. Listeners are also called callbacks – a term that
    stems from procedural languages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接口最重要的用途之一是为程序中的条件或事件创建监听器。基本上，监听器在发生动作时通知您任何状态更改。监听器也称为回调 - 这个术语源自过程式语言。
- en: For example, an event listener could be called when a button is clicked or hovered
    over.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当单击或悬停在按钮上时，可以调用事件监听器。
- en: This kind of event-driven programming is popular for making Android apps using
    Java.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事件驱动的编程在使用Java制作Android应用程序时很受欢迎。
- en: Imagine that we want to know when a person walks or sleeps so that we can perform
    some other actions. We can achieve this by using an interface that listens for
    such events. We will look at this in the following exercise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要知道一个人行走或睡觉时，以便我们可以执行一些其他操作。我们可以通过使用一个监听此类事件的接口来实现这一点。我们将在以下练习中看到这一点。
- en: 'Exercise 13: Implementing Interfaces'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习13：实现接口
- en: 'We are going to create an interface called `PersonListener` that listens for
    two events: `onPersonWalking` and `onPersonSleeping`. When the `walk(int speed)`
    method is called, we will dispatch the `onPersonWalking` event, and when `sleep()`
    is called, `onPersonSleeping` will be called:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`PersonListener`的接口，用于监听两个事件：`onPersonWalking`和`onPersonSleeping`。当调用`walk(int
    speed)`方法时，我们将分派`onPersonWalking`事件，当调用`sleep()`时，将调用`onPersonSleeping`：
- en: 'Create an interface called `PersonListener` and paste the following code inside
    it:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PersonListener`的接口，并将以下代码粘贴到其中：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open our `Doctor` class and add the `PersonListener` interface after the `PersonBehavior`
    interface, separated by a comma:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的`Doctor`类，并在`PersonBehavior`接口之后添加`PersonListener`接口，用逗号分隔：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the two methods in our `PersonListener` interface. When the doctor
    walks, we will perform some actions and raise the `onPersonWalking` event to let
    other listeners know that the doctor is walking. When the doctor sleeps, we shall
    raise the `onPersonSleeping` event. Modify the `walk()` and `sleep()` methods
    to look like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们的`PersonListener`接口中的两个方法。当医生行走时，我们将执行一些操作并触发`onPersonWalking`事件，以让其他监听器知道医生正在行走。当医生睡觉时，我们将触发`onPersonSleeping`事件。修改`walk()`和`sleep()`方法如下：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the main method to test our code by calling `walk()` and `sleep()`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`walk()`和`sleep()`来添加主方法以测试我们的代码：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the `Doctor` class and see the output in the console. You should see something
    like this:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`Doctor`类并在控制台中查看输出。您应该看到类似于这样的内容：
- en: '![Figure 5.1: Output of the Doctor class](img/C09581_05_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：Doctor类的输出](img/C09581_05_01.jpg)'
- en: 'Figure 5.1: Output of the Doctor class'
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.1：Doctor类的输出
- en: 'The full `Doctor` class is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`Doctor`类如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since a class can implement more than one interface, we can use interfaces in
    Java to simulate multiple inheritance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个类可以实现多个接口，我们可以在Java中使用接口来模拟多重继承。
- en: 'Activity 16: Creating and Implementing Interfaces in Java'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动16：在Java中创建和实现接口
- en: 'Scenario: In our animal farm from the previous lesson, we wish to have common
    actions that all animals must possess, regardless of their type. We want to also
    know when an animal has moved or made any sound. A movement can help us keep track
    of where each animal is and the sound can be indicative of distress.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：在我们之前的动物农场中，我们希望所有动物都具备的共同动作，而不管它们的类型如何。我们还想知道动物何时移动或发出任何声音。移动可以帮助我们跟踪每个动物的位置，声音可以表明动物是否处于困境。
- en: 'Objective: We are going to implement two interfaces: one that holds two actions
    that all animals must possess, `move()` and `makeSound()`, and the other that
    listens for movement and sound from the animals.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：我们将实现两个接口：一个包含所有动物必须具备的两个动作`move()`和`makeSound()`，另一个用于监听动物的移动和声音。
- en: 'Aim: To understand how to create interfaces in Java and implement them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：了解如何在Java中创建接口并实现它们。
- en: 'These steps will help you complete this activity:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Open your `Animals` project from the previous lesson.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一课的`Animals`项目。
- en: Create a new interface called `AnimalBehavior`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimalBehavior`的新接口。
- en: 'In this, create two methods: `void move()` and `void makeSound()`'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建两个方法：`void move()`和`void makeSound()`
- en: Create another interface called `AnimalListener` with `onAnimalMoved()` and
    `onAnimalSound()` method.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`AnimalListener`的接口，其中包含`onAnimalMoved()`和`onAnimalSound()`方法。
- en: Create a new public class called `Cow` and implement the `AnimalBehavior` and
    `AnimalListener` interface.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Cow`的新公共类，并实现`AnimalBehavior`和`AnimalListener`接口。
- en: Create instance variable sound and `movementType` in `Cow` class.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cow`类中创建实例变量`sound`和`movementType`。
- en: Override the `move()` such that the `movementType` is "Walking" and the `onAnimalMoved()`
    method is called.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`move()`，使`movementType`为"Walking"，并调用`onAnimalMoved()`方法。
- en: Override the `makeSound()` such that `movementType` is "Moo" and the `onAnimalMoved()`
    method is called.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`makeSound()`，使`movementType`为"Moo"，并调用`onAnimalMoved()`方法。
- en: Override the `onAnimalMoved()` and `inAnimalMadeSound()` methods.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`onAnimalMoved()`和`inAnimalMadeSound()`方法。
- en: Create a `main()` to test the code.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main()`来测试代码。
- en: 'The output should be similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 323.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第323页找到。
- en: Typecasting
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: We have already seen how, when we write `int a = 10`, `a` is of integer data
    type, which is usually 32 bits in size. When we write `char c = 'a'`, `c` has
    a data type of character. These data types were referred to as primitive types
    because they can be used to hold simple information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当我们写`int a = 10`时，`a`是整数数据类型，通常大小为32位。当我们写`char c = 'a'`时，`c`的数据类型是字符。这些数据类型被称为原始类型，因为它们可以用来保存简单的信息。
- en: Objects also have types. The type of an object is often the class of that object.
    For example, when we create an object such as `Doctor myDoctor = new Doctor()`,
    the `myDoctor` object is of type `Doctor`. The `myDoctor` variable is often referred
    to as a reference type. As we discussed earlier, this is because the `myDoctor`
    variable doesn't hold the object itself. Rather, it holds the reference to the
    object in memory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也有类型。对象的类型通常是该对象的类。例如，当我们创建一个对象，比如`Doctor myDoctor = new Doctor()`，`myDoctor`对象的类型是`Doctor`。`myDoctor`变量通常被称为引用类型。正如我们之前讨论的那样，这是因为`myDoctor`变量并不持有对象本身。相反，它持有对象在内存中的引用。
- en: Typecasting is a way for us to change the class or interface from one type to
    another. It's important to note that only classes or interfaces (together, these
    are called types) that belong to the same superclass or implement the same interface,
    that is, they have a parent-child relationship, can be cast or converted into
    each other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是我们将一个类型转换为另一个类型的一种方式。重要的是要注意，只有属于同一个超类或实现相同接口（统称为类型）的类或接口，即它们具有父子关系，才能被转换或转换为彼此。
- en: 'Let''s go back to our `Person` example. We created the `Student` class, which
    inherits from this class. This essentially means that the `Student` class is in
    the `Person` family and so is any other class that inherits from the `Person`
    class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Person`例子。我们创建了`Student`类，它继承自这个类。这基本上意味着`Student`类是`Person`家族中的一员，任何从`Person`类继承的其他类也是如此：
- en: '![Figure 5.3: Inheriting the subclass from the base class](img/C09581_05_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：从基类继承子类](img/C09581_05_02.jpg)'
- en: 'Figure 5.2: Inheriting the subclass from the base class'
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.2：从基类继承子类
- en: 'We typecast in Java by using brackets before the object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Java中使用对象前使用括号进行类型转换：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we have created an object of type `Student` called `student`.
    We then typecast it to a `Person` by using the `(Person)student` statement. This
    statement labels s`tudent` as a `Person` type instead of `Student` type. This
    type of typecasting, where we label the subclass as a superclass, is called upcasting.
    This operation doesn't change the original object; it only labels it as a different
    type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`student`的`Student`类型的对象。然后，我们通过使用`(Person)student`语句将其转换为`Person`类型。这个语句将`student`标记为`Person`类型，而不是`Student`类型。这种类型的类型转换，即我们将子类标记为超类，称为向上转换。这个操作不会改变原始对象；它只是将其标记为不同的类型。
- en: Upcasting reduces the number of methods we have access to. For example, the
    `student` variable cannot access the methods and fields in the `Student` class
    anymore.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 向上转换减少了我们可以访问的方法的数量。例如，`student`变量不能再访问`Student`类中的方法和字段。
- en: 'We convert `student` back to the `Student` type by performing downcasting:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行向下转换将`student`转换回`Student`类型：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Downcasting is the conversion of a superclass type into a subclass type. This
    operation gives us access to the methods and fields in the subclass. For example,
    `newStudent` now has access to all the methods in the `Student` class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 向下转换是将超类类型转换为子类类型。此操作使我们可以访问子类中的方法和字段。例如，`newStudent`现在可以访问`Student`类中的所有方法。
- en: 'For downcasting to work, the object must have originally been of the subclass
    type. For example, the following operation is not possible:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使向下转换起作用，对象必须最初是子类类型。例如，以下操作是不可能的：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you try to run this program, you will get the following exception:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试运行此程序，您将收到以下异常：
- en: '![Figure 5.4: Exception message while downcasting](img/C09581_05_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：向下转换时的异常消息](img/C09581_05_03.jpg)'
- en: 'Figure 5.3: Exception message while downcasting'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.3：向下转换时的异常消息
- en: This is because `person` was not originally a `Lecturer` type, but rather a
    `Student` type. We will talk more about exceptions in the upcoming lessons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`person`最初不是`Lecturer`类型，而是`Student`类型。我们将在接下来的课程中更多地讨论异常。
- en: 'To avoid such kinds of exceptions, you can use the `instanceof` operator to
    first check whether an object is of a given type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种类型的异常，您可以使用`instanceof`运算符首先检查对象是否是给定类型：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `instanceof` operator returns `true` if `person` was originally of type
    `Lecturer`, or returns false otherwise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`person`最初是`Lecturer`类型，则`instanceof`运算符返回`true`，否则返回false。
- en: 'Activity 17: Using instanceof and Typecasting'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动17：使用instanceof和类型转换
- en: 'On previous activity, you used interface to declare common methods around salary
    and tax on the Employee interface. With the expansion of JavaWorks limited, sales-people
    started to get commission. That means that now, you''ll need to write a new class:
    `SalesWithCommission`. This class will extends from `Sales`, which means it has
    all the behavior that employees have but will also have an additional method:
    `getCommission`. This new method returns the gross sales of this employee (which
    will be passed in the constructor) times the sales commission, which is 15% for
    all.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的活动中，您使用接口声明了有关员工接口的工资和税收的常见方法。随着JavaWorks有限公司的扩张，销售人员开始获得佣金。这意味着现在，您需要编写一个新的类：`SalesWithCommission`。这个类将扩展自`Sales`，这意味着它具有员工的所有行为，但还将具有一个额外的方法：`getCommission`。这个新方法返回这个员工的总销售额（将在构造函数中传递）乘以销售佣金，即15%。
- en: 'As part of this activity, you''ll also write a class that has a method that
    generates employees. This will serve as the `datasource` for this and other activities.
    This `EmployeeLoader` class will have one method: `getEmployee()`, which returns
    an Employee. Inside this method, you can use any means to return a newly generated
    employee. Using the `java.util.Random` class might help you to accomplish this
    and still get consistency if you need it.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个活动的一部分，您还将编写一个具有生成员工方法的类。这将作为此活动和其他活动的`数据源`。这个`EmployeeLoader`类将有一个方法：`getEmployee()`，它返回一个Employee。在这个方法中，您可以使用任何方法返回一个新生成的员工。使用`java.util.Random`类可能会帮助您完成这个任务，并且如果需要的话，仍然可以获得一致性。
- en: With your data source and the new `SalesWithCommission`, you'll write an application
    that will call the `EmployeeLoader.getEmployee` method a few times using a `for`
    loop. With each generated employee, it will print their net salary and the tax
    they pay. It will also check if the employee is an instance of `SalesWithCommission`,
    cast it and print his commission.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的数据源和新的`SalesWithCommission`，您将编写一个应用程序，使用`for`循环多次调用`EmployeeLoader.getEmployee`方法。对于每个生成的员工，它将打印他们的净工资和所支付的税款。它还将检查员工是否是`SalesWithCommission`的实例，对其进行转换并打印他的佣金。
- en: 'To complete this activity you''ll need to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动，您需要：
- en: Create a `SalesWithCommission` class that extends `Sales`. Add a constructor
    that receives the gross sales as double and store it as a field. Also add a method
    called `getCommission` which returns a double that is the gross sales times 15%
    (0.15).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`SalesWithCommission`类，它扩展自`Sales`。添加一个接收double类型的总销售额并将其存储为字段的构造函数。还添加一个名为`getCommission`的方法，它返回总销售额乘以15%（0.15）的double类型。
- en: Create another class that will work as a data source, generating employees.
    This class has one method `getEmployee()` that will create an instance of one
    of the implementations of Employee and return it. The method return type should
    be Employee.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个类，作为数据源，生成员工。这个类有一个名为`getEmployee()`的方法，将创建一个Employee实现的实例并返回它。方法的返回类型应该是Employee。
- en: Write an application that calls `getEmployee()` repeatedly inside a `for` loop
    and print the information about the Employee salary and tax. And if the employee
    is an instance of `SalesWithCommission`, also print his commission.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个应用程序，在`for`循环中重复调用`getEmployee()`并打印有关员工工资和税收的信息。如果员工是`SalesWithCommission`的实例，还要打印他的佣金。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 325.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第325页找到。
- en: The Object Class
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类
- en: 'Java provides a special class called `Object`, from which all classes implicitly
    inherit. You don''t have to manually inherit from this class because the compiler
    does that for you. `Object` is the superclass of all classes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个特殊的类称为“Object”，所有类都隐式继承自它。您不必手动从这个类继承，因为编译器会为您执行。`Object`是所有类的超类：
- en: '![](img/C09581_05_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C09581_05_04.jpg)'
- en: 'Figure 5.4: Superclass Object'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.4：超类Object
- en: 'This means that any class in Java can be upcast to `Object`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Java中的任何类都可以向上转型为`Object`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, you can downcast to the original class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以向原始类进行向下转换：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use this `Object` class when you want to pass around objects whose type
    you don't know. It's also used when the JVM wants to perform garbage collection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要传递您不知道类型的对象时，可以使用这个`Object`类。当JVM想要执行垃圾回收时，也会使用它。
- en: Autoboxing and Unboxing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动装箱和拆箱
- en: Sometimes, we need to deal with primitive types in methods that only accept
    objects. A good example of this is when we want to store integers in an ArrayList
    (which we will discuss later). This class, `ArrayList`, only accepts objects,
    and not primitives. Fortunately, Java provides all primitive types as classes.
    Wrapper classes can hold primitive values and we can manipulate them as if they
    were normal classes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要处理只接受对象的方法中的原始类型。一个很好的例子是当我们想要在ArrayList中存储整数时（稍后我们将讨论）。这个类`ArrayList`只接受对象，而不是原始类型。幸运的是，Java提供了所有原始类型作为类。包装类可以保存原始值，我们可以像操作普通类一样操作它们。
- en: 'An example of the `Integer` class, which can hold an `int` is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integer`类的一个示例，它可以保存一个`int`如下：'
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also skip the `new` keyword and the compiler will implicitly wrap it
    for us:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以省略`new`关键字，编译器会自动为我们进行包装：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can then use the object as if it was any other object. We can upcast it to
    `Object` and then downcast it back to an `Integer`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像处理其他对象一样使用这个对象。我们可以将其向上转型为`Object`，然后将其向下转型为`Integer`。
- en: This operation of converting a primitive type into an object (reference type)
    is referred to as autoboxing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始类型转换为对象（引用类型）的操作称为自动装箱。
- en: 'We can also convert the object back into a primitive type:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将对象转换回原始类型：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `b` primitive is assigned the value of `a`, which is 1\. This operation
    of converting a reference type back to a primitive is called unboxing. The compiler
    performs autoboxing and unboxing automatically for us.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，将原始类型`b`赋值为`a`的值，即1。将引用类型转换回原始类型的操作称为拆箱。编译器会自动为我们执行自动装箱和拆箱。
- en: 'In addition to `Integer`, Java also provides the following wrapper classes
    for the following primitives:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Integer`，Java还为以下基本类型提供了以下包装类：
- en: '![](img/C09581_Table_05_01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C09581_Table_05_01.jpg)'
- en: 'Table 5.1: Table representing the wrapper classes for primitives'
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 表5.1：表示基本类型的包装类的表格
- en: 'Activity 18: Understanding Typecasting in Java'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动18：理解Java中的类型转换
- en: 'Scenario: Let''s understand typecasting concepts using our `Animal` classes
    we have been working with.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：让我们使用我们一直在使用的`Animal`类来理解类型转换的概念。
- en: 'Objective: We are going to create a test class for our `Animal` class, and
    upcast and downcast the `Cow` and `Cat` classes.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：我们将为我们的`Animal`类创建一个测试类，并对`Cow`和`Cat`类进行向上转型和向下转型。
- en: 'Aim: Internalize the concepts of typecasting.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：内化类型转换的概念。
- en: 'These steps will help you complete this activity:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: 'Perform the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `Animals` project.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Animals`项目。
- en: Create a new class called `AnimalTest` and, inside it, create the `main` method
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AnimalTest`的新类，并在其中创建`main`方法
- en: In the `main()` method create an object of the `Cat` and `Cow` classes.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`方法中创建`Cat`和`Cow`类的对象。
- en: Print the owner of the `Cat` object.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印Cat对象的所有者。
- en: Upcast the object of `Cat` class to `Animal` and try to print the owner once
    more. Notice the error.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Cat`类的对象向上转型为`Animal`，并尝试再次打印所有者。注意错误。
- en: Print the sound of the object of `Cow` class.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印Cow类的对象的声音。
- en: Upcast the object of `Cow` class to `Animal` and try to print the owner once
    more. Notice the error.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Cow`类的对象向上转型为`Animal`，并尝试再次打印所有者。注意错误。
- en: Downcast the object of Animal class to the new object of `Cat` class and print
    the owner again.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Animal类的对象向下转型为Cat类的新对象，并再次打印所有者。
- en: 'The output should be similar to this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于这样：
- en: '![Figure 5.8:  Output of the AnimalTest class](img/C09581_05_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：AnimalTest类的输出](img/C09581_05_05.jpg)'
- en: 'Figure 5.5: Output of the AnimalTest class'
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.5：AnimalTest类的输出
- en: Note
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 327.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第327页找到。
- en: Abstract Classes and Methods
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和方法
- en: Earlier, we discussed interfaces and how they can be useful when we wish to
    have a contract with our classes on the methods they have to implement. We then
    saw how we can only cast classes that share the same hierarchy tree.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们讨论了接口以及当我们希望与我们的类在它们必须实现的方法上有一个合同时，它们可以是有用的。然后我们看到了我们只能转换共享相同层次树的类。
- en: Java also allows us to have classes with abstract methods that all classes inheriting
    from it must implement. Such a class is referred to as an `abstract` keyword after
    the access modifier.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Java还允许我们拥有具有抽象方法的类，所有从它继承的类必须实现这些方法。这样的类在访问修饰符之后被称为`abstract`关键字。
- en: 'When we declare a class as `abstract`, any class inheriting from it must implement
    the `abstract` methods in it. We cannot instantiate abstract classes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个类声明为`abstract`时，从它继承的任何类必须在其中实现`abstract`方法。我们不能实例化抽象类：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because `abstract` classes are still classes in the first place, they can have
    a logic and state of their own. This gives them more advantages compared to interfaces
    whose methods are empty. In addition, once we inherit from an `abstract` class,
    we can perform typecasting along that class hierarchy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`abstract`类首先仍然是类，它们可以有自己的逻辑和状态。这使它们比方法为空的接口具有更多的优势。此外，一旦我们从`abstract`类继承，我们可以沿着该类层次结构执行类型转换。
- en: Java also allows us to have `abstract` method must also be declared as `abstract`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Java还允许我们拥有`abstract`方法，必须声明为`abstract`。
- en: We use the `abstract` keyword after the access modifier to declare a method
    `abstract`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在访问修饰符之后使用`abstract`关键字来声明一个方法为`abstract`。
- en: 'When we inherit from an `abstract` class, we have to implement all the `abstract`
    methods in it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个`abstract`类继承时，我们必须在其中实现所有的`abstract`方法：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Activity 19: Implementing Abstract Classes and Methods in Java'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动19：在Java中实现抽象类和方法
- en: 'Scenario: Imagine that you have been tasked by the local hospital to build
    a piece of software to manage the different types of people who use the facility.
    You have to find a way to represent the doctors, nurses, and patients.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：想象一下，当地医院委托您构建一款软件来管理使用该设施的不同类型的人。您必须找到一种方式来代表医生、护士和患者。
- en: 'Objective: We are going to create three classes: one that''s abstract, to represent
    any person, another one to represent the doctor, and finally, one to represent
    the patient. All of the classes are going to inherit from the abstract person
    class.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：我们将创建三个类：一个是抽象类，代表任何人，另一个代表医生，最后一个代表患者。所有的类都将继承自抽象人类。
- en: 'Aim: To understand these concepts of `abstract` classes and methods in Java.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：了解Java中`abstract`类和方法的概念。
- en: 'These steps will help you complete the activity:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Create a new project called `Hospital` and open it.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Hospital`的新项目并打开它。
- en: 'Inside the `src` folder, create an abstract class called `Person`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个名为`Person`的抽象类：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an `abstract` method that returns the type of person in the hospital.
    Name this method String `getPersonType()`, returning a String:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回医院中人员类型的`abstract`方法。将此方法命名为String `getPersonType()`，返回一个字符串：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have finished our `abstract` class and method. Now, we will continue to inherit
    from it and implement this `abstract` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的`abstract`类和方法。现在，我们将继续从中继承并实现这个`abstract`方法。
- en: 'Create a new class called `Doctor` that inherits from the `Person` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Doctor`的新类，它继承自`Person`类：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Override the `getPersonType` abstract method in our `Doctor` class. Return
    the "`Arzt`" string. This is German for doctor:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Doctor`类中重写`getPersonType`抽象方法。返回"`Arzt`"字符串。这是医生的德语名称：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create another class called `Patient` to represent the patients in the hospital.
    Similarly, make sure that the class inherits from `Person` and overrides the `getPersonType`
    method. Return "`Kranke`". This is German for patient:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`Patient`的类来代表医院里的病人。同样，确保该类继承自`Person`并重写`getPersonType`方法。返回"`Kranke`"。这是德语中的病人：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we have two classes, we will test our code using a third test class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个类，我们将使用第三个测试类来测试我们的代码。
- en: Create a third class called `HospitalTest`. We will use this class to test the
    two classes we created previously.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HospitalTest`的第三个类。我们将使用这个类来测试之前创建的两个类。
- en: 'Inside the `HospitalTest` class, create the `main` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HospitalTest`类中，创建`main`方法：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside the `main` method, create an instance of `Doctor` and another instance
    of `Patient`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，创建一个`Doctor`的实例和一个`Patient`的实例：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Try calling the `getPersonType` method for each of the objects and print it
    out to the console. What is the output?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试为每个对象调用`getPersonType`方法并将其打印到控制台上。输出是什么？
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C09581_05_06.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C09581_05_06.jpg)'
- en: 'Figure 5.6: Output on calling getPersonType()'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.6：调用getPersonType()的输出
- en: Note
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 329.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第329页找到。
- en: 'Activity 20: Use abstract class to Encapsulate Common Logic'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动20：使用抽象类封装公共逻辑
- en: JavaWorks keeps growing. Now that they have many employees, they noticed that
    salary variation is not supported for the application you've built before. So
    far every Engineer had to have the same salary as all others. Same with Managers,
    Sales and Sales with commission people. To solve that, you're going to use an
    abstract class that encapsulates the logic to calculate net salary, based on the
    tax. For that to work, the abstract class will have a constructor that receives
    the gross salary. It will not implement the `getTax()` method, delegating that
    to the subclasses. With new subclasses for the generic employees that receive
    the gross salary as an argument for the constructor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JavaWorks不断发展。现在他们有了许多员工，他们注意到之前构建的应用程序不支持工资变化。到目前为止，每个工程师的工资都必须与其他人相同。经理、销售和带佣金的销售人员也是如此。为了解决这个问题，您将使用一个封装根据税收计算净工资的逻辑的抽象类。为了使其工作，抽象类将有一个接收总工资的构造函数。它不会实现`getTax()`方法，而是将其委托给子类。使用接收总工资作为构造函数参数的新通用员工的子类。
- en: You'll also add a new method to the `EmployeeLoader`, `getEmployeeWithSalary()`,
    that will generate a new generic employee with a randomly generated gross salary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将在`EmployeeLoader`中添加一个新方法`getEmployeeWithSalary()`，它将生成一个新的通用员工，并随机生成总工资。
- en: And last, on your application, you'll do just like you did before, print the
    salary information and tax, and if the employee is an instance of `GenericSalesWithCommission`,
    also print his commission.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您的应用程序中，您将像以前一样，打印工资信息和税，如果员工是`GenericSalesWithCommission`的实例，还要打印他的佣金。
- en: 'To complete this activity, you''ll need to:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，您需要：
- en: 'Create an abstract class `GenericEmployee` that has a constructor that receives
    the gross salary and stores that in a field. It should implement the Employee
    interface and have two methods: `getGrossSalary()` and `getNetSalary()`. The first
    will just return the value passed into the constructor. The latter will return
    the gross salary minus the result of calling `getTax()` method.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个抽象类`GenericEmployee`，它有一个接收总工资并将其存储在字段中的构造函数。它应该实现Employee接口并有两个方法：`getGrossSalary()`和`getNetSalary()`。第一个方法只会返回传入构造函数的值。后者将返回总工资减去调用`getTax()`方法的结果。
- en: 'Create a new generic version of each type of employee: `GenericEngineer`, `GenericManager`,
    `GenericSales`, and `GenericSalesWithCommission`. They all need a constructor
    that receives gross salary and pass it to the super constructor. They also need
    to implement the `getTax()` method, returning the correct tax value for each class.
    Remember to also receive the gross sales on the `GenericSalesWithCommission` class,
    and add the method that calculates the commission.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种类型的员工创建一个新的通用版本：`GenericEngineer`、`GenericManager`、`GenericSales`和`GenericSalesWithCommission`。它们都需要一个接收总工资并将其传递给超级构造函数的构造函数。它们还需要实现`getTax()`方法，返回每个类的正确税值。记得在`GenericSalesWithCommission`类中也接收总销售额，并添加计算佣金的方法。
- en: Add a new method `getEmployeeWithSalary` to your `EmployeeLoader` class. This
    method will generate a random salary between 70,000 and 120,000 and assign to
    the newly created employee before returning it. Remember to also provide a gross
    sales when creating a `GenericSalesWithCommission` employee.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EmployeeLoader`类中添加一个新方法`getEmployeeWithSalary`。这个方法将在返回之前为新创建的员工生成一个介于70,000和120,000之间的随机工资。在创建`GenericSalesWithCommission`员工时，也记得提供一个总销售额。
- en: 'Write an application that calls the `getEmployeeWithSalary` method multiple
    times from inside a `for` loop. This method will work like the one in the previous
    activity: print the net salary and tax for all employees. If the employee is an
    instance of `GenericSalesWithCommission` also print his commission.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个应用程序，从`for`循环内多次调用`getEmployeeWithSalary`方法。这个方法将像前一个活动中一样工作：打印所有员工的净工资和税。如果员工是`GenericSalesWithCommission`的实例，还要打印他的佣金。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 331.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第331页找到。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, we have learned that interfaces are a way for us to define a
    set of methods that all classes implementing them must provide specific implementations
    for. Interfaces can be used to implement events and listeners in your code when
    a specific action occurs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们学到了接口是一种定义一组方法的方式，所有实现它们的类必须提供特定的实现。接口可以用于在代码中实现事件和监听器，当特定动作发生时。
- en: We then learned that typecasting is a way for us to change a variable of one
    type to another type, as long as they are on the same hierarchy tree or implement
    a common interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们了解到，类型转换是一种让我们将一个类型的变量改变为另一个类型的方法，只要它们在同一层次树上或实现了一个共同的接口。
- en: We also looked at the use of the `instanceof` operator and the `Object` class
    in Java, and learned the concepts of autoboxing, unboxing, abstract classes, and
    abstract methods in Java.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了在Java中使用`instanceof`运算符和`Object`类，并学习了自动装箱、拆箱、抽象类和抽象方法的概念。
- en: In the next lesson, we will look at a few common classes and data structures
    that come with Java.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将研究一些Java中附带的常见类和数据结构。
