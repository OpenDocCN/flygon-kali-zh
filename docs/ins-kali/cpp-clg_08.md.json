["```cpp\ncrc = 14*1 + 13*2 + 12*0 + 11*1 + 10*7 + 9*1 + 8*2 + 7*0 + 6*1 + 5*3 \n           +  4*4 +  3*8 +  2*9 +  1*5\n    = 230 = 23 * 10\n```", "```cpp\n\nclass password_validator\n{\npublic:\n   virtual bool validate(std::string_view password) = 0;\n   virtual ~password_validator() {}\n};\n\nclass length_validator final : public password_validator\n{\npublic:\n   length_validator(unsigned int min_length): length(min_length)\n   {}\n\n   virtual bool validate(std::string_view password) override\n   {\n      return password.length() >= length;\n   }\n\nprivate:\n   unsigned int length;\n};\n\nclass password_validator_decorator : public password_validator\n{\npublic:\n   explicit password_validator_decorator(\n      std::unique_ptr<password_validator> validator):\n         inner(std::move(validator))\n   {\n   }\n\n   virtual bool validate(std::string_view password) override\n   {\n      return inner->validate(password);\n   }\n\nprivate:\n   std::unique_ptr<password_validator> inner;\n};\n\nclass digit_password_validator final : public password_validator_decorator\n{\npublic:\n   explicit digit_password_validator(\n      std::unique_ptr<password_validator> validator):\n         password_validator_decorator(std::move(validator))\n   {\n   }\n\n   virtual bool validate(std::string_view password) override\n   {\n      if(!password_validator_decorator::validate(password))\n         return false;\n\n      return password.find_first_of(\"0123456789\") != std::string::npos;\n   }\n};\n\nclass case_password_validator final : public password_validator_decorator\n{\npublic:\n   explicit case_password_validator(\n      std::unique_ptr<password_validator> validator):\n         password_validator_decorator(std::move(validator))\n   {\n   }\n\n   virtual bool validate(std::string_view password) override\n   {\n      if(!password_validator_decorator::validate(password))\n         return false;\n\n      bool haslower = false;\n      bool hasupper = false;\n\n      for(size_t i = 0; i < password.length() && !(hasupper && haslower); \n         ++i)\n      {\n         if(islower(password[i])) haslower = true;\n         else if(isupper(password[i])) hasupper = true;\n      }\n\n      return haslower && hasupper;\n   }\n};\n\nclass symbol_password_validator final : public password_validator_decorator\n{\npublic:\n   explicit symbol_password_validator(\n      std::unique_ptr<password_validator> validator):\n         password_validator_decorator(std::move(validator))\n   {\n   }\n\n   virtual bool validate(std::string_view password) override\n   {\n      if(!password_validator_decorator::validate(password))\n         return false;\n\n      return password.find_first_of(\"!@#$%^&*(){}[]?<>\") != \n         std::string::npos;\n   }\n};\n```", "```cpp\nint main()\n{\n   auto validator1 = std::make_unique<digit_password_validator>(\n      std::make_unique<length_validator>(8));\n\n   assert(validator1->validate(\"abc123!@#\"));\n   assert(!validator1->validate(\"abcde!@#\"));\n\n   auto validator2 = \n      std::make_unique<symbol_password_validator>(\n         std::make_unique<case_password_validator>(\n            std::make_unique<digit_password_validator>(\n               std::make_unique<length_validator>(8))));\n\n   assert(validator2->validate(\"Abc123!@#\"));\n   assert(!validator2->validate(\"Abc123567\"));\n}\n```", "```cpp\nclass password_generator\n{\npublic:\n   virtual std::string generate() = 0;\n\n   virtual std::string allowed_chars() const = 0;\n   virtual size_t length() const = 0;\n\n   virtual void add(std::unique_ptr<password_generator> generator) = 0;\n\n   virtual ~password_generator(){}\n};\n\nclass basic_password_generator : public password_generator\n{\n   size_t len;\npublic:\n   explicit basic_password_generator(size_t const len) noexcept : len(len) \n   {}\n\n   virtual std::string generate() override\n   { throw std::runtime_error(\"not implemented\"); }\n\n   virtual void add(std::unique_ptr<password_generator>) override\n   { throw std::runtime_error(\"not implemented\"); }\n\n   virtual size_t length() const override final\n   {return len;}\n};\n\nclass digit_generator : public basic_password_generator\n{\npublic:\n   explicit digit_generator(size_t const len) noexcept\n   : basic_password_generator(len) {}\n\n   virtual std::string allowed_chars() const override\n   {return \"0123456789\";}\n};\n\nclass symbol_generator : public basic_password_generator\n{\npublic:\n   explicit symbol_generator(size_t const len) noexcept\n   : basic_password_generator(len) {}\n\n   virtual std::string allowed_chars() const override\n   {return \"!@#$%^&*(){}[]?<>\";}\n};\n\nclass upper_letter_generator : public basic_password_generator\n{\npublic:\n   explicit upper_letter_generator(size_t const len) noexcept\n   : basic_password_generator(len) {}\n\n   virtual std::string allowed_chars() const override\n   {return \"ABCDEFGHIJKLMNOPQRSTUVXYWZ\";}\n};\n\nclass lower_letter_generator : public basic_password_generator\n{\npublic:\n   explicit lower_letter_generator(size_t const len) noexcept\n   : basic_password_generator(len) {}\n\n   virtual std::string allowed_chars() const override\n   {return \"abcdefghijklmnopqrstuvxywz\";}\n};\n\nclass composite_password_generator : public password_generator\n{\n   virtual std::string allowed_chars() const override\n   { throw std::runtime_error(\"not implemented\"); };\n   virtual size_t length() const override\n   { throw std::runtime_error(\"not implemented\"); };\npublic:\n   composite_password_generator()\n   {\n      auto seed_data = std::array<int, std::mt19937::state_size> {};\n      std::generate(std::begin(seed_data), std::end(seed_data), \n                    std::ref(rd));\n      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n      eng.seed(seq);\n   }\n\n   virtual std::string generate() override\n   {\n      std::string password;\n      for(auto & generator : generators)\n      {\n         std::string chars = generator->allowed_chars();\n         std::uniform_int_distribution<> ud(\n            0, static_cast<int>(chars.length() - 1));\n\n         for(size_t i = 0; i < generator->length(); ++i)\n            password += chars[ud(eng)];\n      }\n\n      std::shuffle(std::begin(password), std::end(password), eng);\n\n      return password;\n   }\n\n   virtual void add(std::unique_ptr<password_generator> generator) override\n   {\n      generators.push_back(std::move(generator));\n   }\n\nprivate:\n   std::random_device rd;\n   std::mt19937 eng;\n   std::vector<std::unique_ptr<password_generator>> generators;\n};\n```", "```cpp\nint main()\n{\n   composite_password_generator generator;\n   generator.add(std::make_unique<symbol_generator>(2));\n   generator.add(std::make_unique<digit_generator>(2));\n   generator.add(std::make_unique<upper_letter_generator>(2));\n   generator.add(std::make_unique<lower_letter_generator>(4));\n\n   auto password = generator.generate();\n}\n```", "```cpp\nenum class sex_type {female, male};\n\nclass social_number_generator\n{\nprotected:\n   virtual int sex_digit(sex_type const sex) const noexcept = 0;\n   virtual int next_random(unsigned const year, unsigned const month, \n                           unsigned const day) = 0;\n   virtual int modulo_value() const noexcept = 0;\n\n   social_number_generator(int const min, int const max):ud(min, max)\n   {\n      std::random_device rd;\n      auto seed_data = std::array<int, std::mt19937::state_size> {};\n      std::generate(std::begin(seed_data), std::end(seed_data), \n                    std::ref(rd));\n      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n      eng.seed(seq);\n   }\n\npublic:\n   std::string generate(\n      sex_type const sex,\n      unsigned const year, unsigned const month, unsigned const day)\n   {\n      std::stringstream snumber;\n\n      snumber << sex_digit(sex);\n\n      snumber << year << month << day;\n\n      snumber << next_random(year, month, day);\n\n      auto number = snumber.str();\n\n      auto index = number.length();\n      auto sum = std::accumulate(std::begin(number), std::end(number), 0,\n         [&index](int const s, char const c) {\n            return s + index-- * (c-'0');});\n\n      auto rest = sum % modulo_value();\n      snumber << modulo_value() - rest;\n\n      return snumber.str();\n   }\n\n   virtual ~social_number_generator() {}\n\nprotected:\n   std::map<unsigned, int> cache;\n   std::mt19937 eng;\n   std::uniform_int_distribution<> ud;\n};\n\nclass southeria_social_number_generator final : \n   public social_number_generator\n{\npublic:\n   southeria_social_number_generator():\n      social_number_generator(1000, 9999)\n   {\n   }\n\nprotected:\n   virtual int sex_digit(sex_type const sex) const noexcept override\n   {\n      if(sex == sex_type::female) return 1;\n      else return 2;\n   }\n\n   virtual int next_random(unsigned const year, unsigned const month, \n                           unsigned const day) override\n   {\n      auto key = year * 10000 + month * 100 + day;\n      while(true)\n      {\n         auto number = ud(eng);\n         auto pos = cache.find(number);\n         if(pos == std::end(cache))\n         {\n            cache[key] = number;\n            return number;\n         }\n      }\n   }\n\n   virtual int modulo_value() const noexcept override\n   {\n      return 11;\n   }\n};\n\nclass northeria_social_number_generator final : \n   public social_number_generator\n{\npublic:\n   northeria_social_number_generator():\n      social_number_generator(10000, 99999)\n   {\n   }\n\nprotected:\n   virtual int sex_digit(sex_type const sex) const noexcept override\n   {\n      if(sex == sex_type::female) return 9;\n      else return 7;\n   }\n\n   virtual int next_random(unsigned const year, unsigned const month, \n                           unsigned const day) override\n   {\n      auto key = year * 10000 + month * 100 + day;\n      while(true)\n      {\n         auto number = ud(eng);\n         auto pos = cache.find(number);\n         if(pos == std::end(cache))\n         {\n            cache[key] = number;\n            return number;\n         }\n      }\n   }\n\n   virtual int modulo_value() const noexcept override\n   {\n      return 11;\n   }\n};\n\nclass social_number_generator_factory\n{\npublic:\n   social_number_generator_factory()\n   {\n      generators[\"northeria\"] = \n      std::make_unique<northeria_social_number_generator>();\n      generators[\"southeria\"] = \n         std::make_unique<southeria_social_number_generator>();\n   }\n\n   social_number_generator* get_generator(std::string_view country) const\n   {\n      auto it = generators.find(country.data());\n      if(it != std::end(generators))\n      return it->second.get();\n\n      throw std::runtime_error(\"invalid country\");\n   }\n\nprivate:\n   std::map<std::string, \n   std::unique_ptr<social_number_generator>> generators;\n};\n```", "```cpp\nint main()\n{\n   social_number_generator_factory factory;\n\n   auto sn1 = factory.get_generator(\"northeria\")->generate(\n                 sex_type::female, 2017, 12, 25);\n   auto sn2 = factory.get_generator(\"northeria\")->generate(\n                 sex_type::female, 2017, 12, 25);\n   auto sn3 = factory.get_generator(\"northeria\")->generate(\n                 sex_type::male, 2017, 12, 25);\n\n   auto sss1 = factory.get_generator(\"southeria\")->generate(\n                 sex_type::female, 2017, 12, 25);\n   auto ss2 = factory.get_generator(\"southeria\")->generate(\n                 sex_type::female, 2017, 12, 25);\n   auto ss3 = factory.get_generator(\"southeria\")->generate(\n                 sex_type::male, 2017, 12, 25);\n}\n```", "```cpp\nclass role\n{\npublic:\n   virtual double approval_limit() const noexcept = 0;\n   virtual ~role() {}\n};\n\nclass employee_role : public role\n{\npublic:\n   virtual double approval_limit() const noexcept override\n   {\n      return 1000;\n   }\n};\n\nclass team_manager_role : public role\n{\npublic:\n   virtual double approval_limit() const noexcept override\n   {\n      return 10000;\n   }\n};\n\nclass department_manager_role : public role\n{\npublic:\n   virtual double approval_limit() const noexcept override\n   {\n      return 100000;\n   }\n};\n\n```", "```cpp\nclass president_role : public role\n{\npublic:\n   virtual double approval_limit() const noexcept override\n   {\n      return std::numeric_limits<double>::max();\n   }\n};\n\nstruct expense\n{\n   double amount;\n   std::string description;\n\n   expense(double const amount, std::string_view desc):\n      amount(amount), description(desc)\n   {\n   }\n};\n\nclass employee\n{\npublic:\n   explicit employee(std::string_view name, std::unique_ptr<role> ownrole)\n      : name(name), own_role(std::move(ownrole))\n   {\n   }\n\n   void set_direct_manager(std::shared_ptr<employee> manager)\n   {\n      direct_manager = manager;\n   }\n\n   void approve(expense const & e)\n   {\n      if(e.amount <= own_role->approval_limit())\n         std::cout << name << \" approved expense '\" << e.description \n                   << \"', cost=\" << e.amount << std::endl;\n      else if(direct_manager != nullptr)\n         direct_manager->approve(e);\n }\n\nprivate:\n   std::string               name;\n   std::unique_ptr<role>     own_role;\n   std::shared_ptr<employee> direct_manager;\n};\n```", "```cpp\nint main()\n{\n   auto john = std::make_shared<employee>(\"john smith\", \n                    std::make_unique<employee_role>());\n\n   auto robert = std::make_shared<employee>(\"robert booth\", \n                      std::make_unique<team_manager_role>());\n\n   auto david = std::make_shared<employee>(\"david jones\", \n                     std::make_unique<department_manager_role>());\n\n   auto cecil = std::make_shared<employee>(\"cecil williamson\", \n                     std::make_unique<president_role>());\n\n   john->set_direct_manager(robert);\n   robert->set_direct_manager(david);\n   david->set_direct_manager(cecil);\n\n   john->approve(expense{500, \"magazins\"});\n   john->approve(expense{5000, \"hotel accomodation\"});\n   john->approve(expense{50000, \"conference costs\"});\n   john->approve(expense{200000, \"new lorry\"});\n}\n```", "```cpp\nenum class collection_action\n{\n   add,\n   remove,\n   clear,\n   assign\n};\n\nstd::string to_string(collection_action const action)\n{\n   switch(action)\n   {\n      case collection_action::add:    return \"add\";\n      case collection_action::remove: return \"remove\";\n      case collection_action::clear:  return \"clear\";\n      case collection_action::assign: return \"assign\";\n   }\n}\n\nstruct collection_change_notification\n{\n   collection_action action;\n   std::vector<size_t> item_indexes;\n};\n\nclass collection_observer\n{\npublic:\n   virtual void collection_changed(\n      collection_change_notification notification) = 0;\n   virtual ~collection_observer() {}\n};\n\ntemplate <typename T, class Allocator = std::allocator<T>>\nclass observable_vector final\n{\n   typedef typename std::vector<T, Allocator>::size_type size_type;\npublic:\n   observable_vector() noexcept(noexcept(Allocator()))\n      : observable_vector( Allocator() ) {}\n   explicit observable_vector( const Allocator& alloc ) noexcept\n      : data(alloc){}\n   observable_vector( size_type count, const T& value, \n                     const Allocator& alloc = Allocator())\n      : data(count, value, alloc){}\n   explicit observable_vector( size_type count, \n                               const Allocator& alloc = Allocator() )\n      :data(count, alloc){}\n   observable_vector(observable_vector&& other) noexcept\n      :data(other.data){}\n   observable_vector(observable_vector&& other, \n                     const Allocator& alloc)\n      :data(other.data, alloc){}\n   observable_vector(std::initializer_list<T> init,\n      const Allocator& alloc = Allocator())\n      :data(init, alloc){}\n   template<class InputIt>\n   observable_vector(InputIt first, InputIt last, const \n                     Allocator& alloc = Allocator())\n      :data(first, last, alloc){}\n\n   observable_vector& operator=(observable_vector const & other)\n   {\n      if(this != &other)\n      {\n         data = other.data;\n\n         for(auto o : observers)\n         {\n            if(o != nullptr)\n            {\n               o->collection_changed({\n                  collection_action::assign,\n                  std::vector<size_t> {}\n               });\n            }\n         }\n      }\n\n      return *this;\n   }\n\n   observable_vector& operator=(observable_vector&& other)\n   {\n      if(this != &other)\n      {\n         data = std::move(other.data);\n\n         for(auto o : observers)\n         {\n            if(o != nullptr)\n            {\n               o->collection_changed({\n                  collection_action::assign,\n                  std::vector<size_t> {}\n               });\n            }\n         }\n      }\n\n      return *this;\n   }\n\n   void push_back(T&& value)\n   {\n      data.push_back(value);\n\n      for(auto o : observers)\n      {\n         if(o != nullptr)\n         {\n            o->collection_changed({\n               collection_action::add,\n               std::vector<size_t> {data.size()-1}\n            });\n         }\n      }\n   }\n\n   void pop_back()\n   {\n      data.pop_back();\n\n      for(auto o : observers)\n      {\n         if(o != nullptr)\n         {\n            o->collection_changed({\n               collection_action::remove,\n               std::vector<size_t> {data.size()+1}\n            });\n         }\n      }\n   }\n\n   void clear() noexcept\n   {\n      data.clear();\n\n      for(auto o : observers)\n      {\n         if(o != nullptr)\n         {\n            o->collection_changed({\n               collection_action::clear,\n               std::vector<size_t> {}\n            });\n         }\n      }\n   }\n\n   size_type size() const noexcept\n   {\n      return data.size();\n   }\n\n   [[nodiscard]] bool empty() const noexcept\n   {\n      return data.empty();\n   }\n\n   void add_observer(collection_observer * const o)\n   {\n      observers.push_back(o);\n   }\n\n   void remove_observer(collection_observer const * const o)\n   {\n      observers.erase(std::remove(std::begin(observers), \n                                  std::end(observers), o),\n                      std::end(observers));\n   }\n\nprivate:\n   std::vector<T, Allocator> data;\n   std::vector<collection_observer*> observers;\n};\n\nclass observer : public collection_observer\n{\npublic:\n   virtual void collection_changed(\n      collection_change_notification notification) override\n   {\n      std::cout << \"action: \" << to_string(notification.action);\n      if(!notification.item_indexes.empty())\n      {\n         std::cout << \", indexes: \";\n         for(auto i : notification.item_indexes)\n            std::cout << i << ' ';\n      }\n      std::cout << std::endl;\n   }\n};\n```", "```cpp\nint main()\n{\n   observable_vector<int> v;\n   observer o;\n\n   v.add_observer(&o);\n\n   v.push_back(1);\n   v.push_back(2);\n   v.pop_back();\n   v.clear();\n\n   v.remove_observer(&o);\n\n   v.push_back(3);\n   v.push_back(4);\n\n   v.add_observer(&o);\n\n   observable_vector<int> v2 {1,2,3};\n   v = v2;\n   v = observable_vector<int> {7,8,9};\n}\n```", "```cpp\nstruct discount_type\n{\n   virtual double discount_percent(\n      double const price, double const quantity) const noexcept = 0;\n   virtual ~discount_type() {}\n};\n\nstruct fixed_discount final : public discount_type\n{\n   explicit fixed_discount(double const discount) noexcept \n      : discount(discount) {}\n   virtual double discount_percent(\n      double const, double const) const noexcept \n   {return discount;}\n\nprivate:\n   double discount;\n};\n\nstruct volume_discount final : public discount_type\n{\n   explicit volume_discount(double const quantity, \n                            double const discount) noexcept \n     : discount(discount), min_quantity(quantity) {}\n   virtual double discount_percent(\n      double const, double const quantity) const noexcept \n   {return quantity >= min_quantity ? discount : 0;}\n\nprivate:\n   double discount;\n   double min_quantity;\n};\n\nstruct price_discount : public discount_type\n{\n   explicit price_discount(double const price, \n                           double const discount) noexcept \n      : discount(discount), min_total_price(price) {}\n   virtual double discount_percent(\n      double const price, double const quantity) const noexcept \n   {return price*quantity >= min_total_price ? discount : 0;}\n\nprivate:\n   double discount;\n   double min_total_price;\n};\n\nstruct amount_discount : public discount_type\n{\n   explicit amount_discount(double const price, \n                            double const discount) noexcept \n      : discount(discount), min_total_price(price) {}\n   virtual double discount_percent(\n      double const price, double const) const noexcept \n   {return price >= min_total_price ? discount : 0;}\n\nprivate:\n   double discount;\n   double min_total_price;\n};\n```", "```cpp\nstruct customer\n{\n   std::string    name;\n   discount_type* discount;\n};\n\nenum class article_unit\n{\n   piece, kg, meter, sqmeter, cmeter, liter\n};\n\nstruct article\n{\n   int            id;\n   std::string    name;\n   double         price;\n   article_unit   unit;\n   discount_type* discount;\n};\n\nstruct order_line\n{\n   article        product;\n   int            quantity;\n   discount_type* discount;\n};\n\nstruct order\n{\n   int                     id;\n   customer*               buyer;\n   std::vector<order_line> lines;\n   discount_type*          discount;\n};\n```", "```cpp\nstruct price_calculator\n{\n   virtual double calculate_price(order const & o) = 0;\n};\n\nstruct cumulative_price_calculator : public price_calculator\n{\n   virtual double calculate_price(order const & o) override\n   {\n      double price = 0;\n\n      for(auto ol : o.lines)\n      {\n         double line_price = ol.product.price * ol.quantity;\n\n         if(ol.product.discount != nullptr)\n            line_price *= (1.0 - ol.product.discount->discount_percent(\n               ol.product.price, ol.quantity));\n\n         if(ol.discount != nullptr)\n            line_price *= (1.0 - ol.discount->discount_percent(\n               ol.product.price, ol.quantity));\n\n         if(o.buyer != nullptr && o.buyer->discount != nullptr)\n            line_price *= (1.0 - o.buyer->discount->discount_percent(\n               ol.product.price, ol.quantity));\n\n         price += line_price;\n      }\n\n      if(o.discount != nullptr)\n         price *= (1.0 - o.discount->discount_percent(price, 0));\n\n      return price;\n   }\n};\n```", "```cpp\ninline bool are_equal(double const d1, double const d2, \n                      double const diff = 0.001)\n{\n   return std::abs(d1 - d2) <= diff;\n}\n\nint()\n{\n   fixed_discount  d1(0.1);\n   volume_discount d2(10, 0.15);\n   price_discount  d3(100, 0.05);\n   amount_discount d4(100, 0.05);\n\n   customer c1 {\"default\", nullptr};\n   customer c2 {\"john\", &d1};\n   customer c3 {\"joane\", &d3};\n\n   article a1 {1, \"pen\", 5, article_unit::piece, nullptr};\n   article a2 {2, \"expensive pen\", 15, article_unit::piece, &d1};\n   article a3 {3, \"scissors\", 10, article_unit::piece, &d2};\n\n   cumulative_price_calculator calc;\n\n   order o1 {101, &c1, {{a1, 1, nullptr}}, nullptr};\n   assert(are_equal(calc.calculate_price(o1), 5));\n\n```", "```cpp\n   order o3 {103, &c1, {{a2, 1, nullptr}}, nullptr};\n   assert(are_equal(calc.calculate_price(o3), 13.5));\n\n   order o6 {106, &c1, {{a3, 15, nullptr}}, nullptr};\n   assert(are_equal(calc.calculate_price(o6), 127.5));\n\n   order o9 {109, &c3, {{a2, 20, &d1}}, &d4};\n   assert(are_equal(calc.calculate_price(o9), 219.3075));\n}\n```"]