["```kt\n    public class MainActivity extends CardboardActivity implements CardboardView.StereoRenderer {\n    ```", "```kt\n    CardboardView.StereoRenderer {\n       private static final String TAG = \"MainActivity\";\n\n       // Scene variables\n       // Model variables\n       // Viewing variables\n       // Rendering variables\n    ```", "```kt\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            CardboardView cardboardView = (CardboardView) findViewById(R.id.cardboard_view);\n            cardboardView.setRenderer(this);\n            setCardboardView(cardboardView);  \n        }\n    ```", "```kt\n    // Model variables\n    private static final int COORDS_PER_VERTEX = 3;\n    private static float triCoords[] = {\n        // in counter-clockwise order\n        0.0f,  0.6f, -1.0f, // top\n       -0.5f, -0.3f, -1.0f, // bottom left\n        0.5f, -0.3f, -1.0f  // bottom right\n    };\n\n    private final int triVertexCount = triCoords.length / COORDS_PER_VERTEX;\n    // yellow-ish color\n    private float triColor[] = { 0.8f, 0.6f, 0.2f, 0.0f }; \n    private FloatBuffer triVerticesBuffer;\n```", "```kt\n    @Override\n    public void onSurfaceCreated(EGLConfig eglConfig) {\n        initializeScene();\n        compileShaders();\n        prepareRenderingTriangle();\n    }\n```", "```kt\nprivate void initializeScene() {\n}\n```", "```kt\n   /**\n     * Utility method for compiling a OpenGL shader.\n     *\n     * @param type - Vertex or fragment shader type.\n     * @param resId - int containing the resource ID of the shader code file.\n     * @return - Returns an id for the shader.\n     */\n    private int loadShader(int type, int resId){\n        String code = readRawTextFile(resId);\n        int shader = GLES20.glCreateShader(type);\n\n        // add the source code to the shader and compile it\n        GLES20.glShaderSource(shader, code);\n        GLES20.glCompileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Converts a raw text file into a string.\n     *\n     * @param resId The resource ID of the raw text file about to be turned into a shader.\n     * @return The content of the text file, or null in case of error.\n     */\n    private String readRawTextFile(int resId) {\n        InputStream inputStream = getResources().openRawResource(resId);\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n            reader.close();\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```", "```kt\nattribute vec4 a_Position;\nvoid main() {\n    gl_Position = a_Position;\n}\n```", "```kt\nprecision mediump float;\nuniform vec4 u_Color;\nvoid main() {\n    gl_FragColor = u_Color;\n}\n```", "```kt\n    // Rendering variables\n    private int simpleVertexShader;\n    private int simpleFragmentShader;\n```", "```kt\n    private void compileShaders() {\n        simpleVertexShader = loadShader(GLES20.GL_VERTEX_SHADER, R.raw.simple_vertex);\n        simpleFragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, R.raw.simple_fragment);\n    }\n```", "```kt\n    // Rendering variables\n    private int triProgram;\n    private int triPositionParam;\n    private int triColorParam;\n```", "```kt\n    private void prepareRenderingTriangle() {\n        // Allocate buffers\n        // Create GL program\n        // Get shader params\n    }\n```", "```kt\n        // Allocate buffers\n        // initialize vertex byte buffer for shape coordinates (4 bytes per float)\n        ByteBuffer bb = ByteBuffer.allocateDirect(triCoords.length * 4);\n        // use the device hardware's native byte order\n        bb.order(ByteOrder.nativeOrder());\n\n        // create a floating point buffer from the ByteBuffer\n        triVerticesBuffer = bb.asFloatBuffer();\n        // add the coordinates to the FloatBuffer\n        triVerticesBuffer.put(triCoords);\n        // set the buffer to read the first coordinate\n        triVerticesBuffer.position(0);\n```", "```kt\n        // Create GL program\n        // create empty OpenGL ES Program\n        triProgram = GLES20.glCreateProgram();\n        // add the vertex shader to program\n        GLES20.glAttachShader(triProgram, simpleVertexShader);\n        // add the fragment shader to program\n        GLES20.glAttachShader(triProgram, simpleFragmentShader);\n        // build OpenGL ES program executable\n        GLES20.glLinkProgram(triProgram);\n        // set program as current\n        GLES20.glUseProgram(triProgram);\n```", "```kt\n        // Get shader params\n        // get handle to vertex shader's a_Position member\n        triPositionParam = GLES20.glGetAttribLocation(triProgram, \"a_Position\");\n        // enable a handle to the triangle vertices\n        GLES20.glEnableVertexAttribArray(triPositionParam);\n        // get handle to fragment shader's u_Color member\n        triColorParam = GLES20.glGetUniformLocation(triProgram, \"u_Color\");\n```", "```kt\n    @Override\n    public void onDrawEye(Eye eye) {\n        drawTriangle();\n    }\n\n    private void drawTriangle() {\n        // Add program to OpenGL ES environment\n        GLES20.glUseProgram(triProgram);\n\n        // Prepare the coordinate data\n        GLES20.glVertexAttribPointer(triPositionParam, COORDS_PER_VERTEX,\n                GLES20.GL_FLOAT, false, 0, triVerticesBuffer);\n\n        // Set color for drawing\n        GLES20.glUniform4fv(triColorParam, 1, triColor, 0);\n\n        // Draw the model\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, triVertexCount);\n    }\n```", "```kt\n// allocate the matrix arrays\nfloat scale[] = new float[16];\nfloat translate[] = new float[16];\nfloat scaleAndTranslate[] = new float[16];\n\n// initialize to Identity\nMatrix.setIdentityM(scale, 0);\nMatrix.setIdentityM(translate, 0);\n\n// scale by 2, move by 5 in Z\nMatrix.scaleM(scale, 0, 2.0, 2.0, 2.0);\nMatrix.translateM(translate, 0, 0, 0.0, 0.0, 5.0);\n\n// combine them with a matrix multiply\nMatrix.multipyMM(scaleAndTranslate, 0, translate, 0, scale, 0);\n```", "```kt\nmodelViewProjection = modelTransform X camera  X  eyeView  X  perspectiveProjection\n```", "```kt\nuniform mat4 u_MVP;\nattribute vec4 a_Position;\nvoid main() {\n   gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nsimpleVertexShader = loadShader(GLES20.GL_VERTEX_SHADER, R.raw.mvp_vertex)\n```", "```kt\n// Viewing variables\nprivate static final float Z_NEAR = 0.1f;\nprivate static final float Z_FAR = 100.0f;\nprivate static final float CAMERA_Z = 0.01f;\n\nprivate float[] camera;\nprivate float[] view;\nprivate float[] modelViewProjection;\n\n// Rendering variables\nprivate int triMVPMatrixParam;\n```", "```kt\n    protected void onCreate(Bundle savedInstanceState) {\n        //...\n\n        camera = new float[16];\n        view = new float[16];\n        modelViewProjection = new float[16];\n    }\n```", "```kt\n// get handle to shape's transformation matrix\ntriMVPMatrixParam = GLES20.glGetUniformLocation(triProgram, \"u_MVP\");\n```", "```kt\n    @Override\n    public void onNewFrame(HeadTransform headTransform) {\n        // Build the camera matrix and apply it to the ModelView.\n        Matrix.setLookAtM(camera, 0, 0.0f, 0.0f, CAMERA_Z, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n    }\n```", "```kt\n    public void onDrawEye(Eye eye) {\n        GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n\n        // Apply the eye transformation to the camera\n        Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);\n\n        // Get the perspective transformation\n        float[] perspective = eye.getPerspective(Z_NEAR, Z_FAR);\n\n        // Apply perspective transformation to the view, and draw\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, view, 0);\n\n        drawTriangle();\n    }\n```", "```kt\nmodelViewProjection = modelTransform  X  camera  X  eyeView  X  perspectiveProjection\n```", "```kt\n    private void drawTriangle() {\n        // Add program to OpenGL ES environment\n        GLES20.glUseProgram(triProgram);\n\n        // Pass the MVP transformation to the shader\n        GLES20.glUniformMatrix4fv(triMVPMatrixParam, 1, false, modelViewProjection, 0);\n\n        // . . .\n```", "```kt\n    // Model variables\n    private float[] triTransform;\n\n    // Viewing variables\n    private float[] triView;\n```", "```kt\n        triTransform = new float[16];\n        triView = new float[16];\n```", "```kt\n       // Position the triangle\n        Matrix.setIdentityM(triTransform, 0);\n        Matrix.translateM(triTransform, 0, 5, 0, -5);\n```", "```kt\n    public void onDrawEye(Eye eye) {\n        ...\n        // Apply perspective transformation to the view, and draw\n        Matrix.multiplyMM(triView, 0, view, 0, triTransform, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, triView, 0);\n        drawTriangle();\n    }\n```", "```kt\npackage com.cardbookvr.cardboardbox;\n\npublic class Cube {\n\n    public static final float[] CUBE_COORDS = new float[] {\n        // Front face\n        -1.0f, 1.0f, 1.0f,\n        -1.0f, -1.0f, 1.0f,\n        1.0f, 1.0f, 1.0f,\n        -1.0f, -1.0f, 1.0f,\n        1.0f, -1.0f, 1.0f,\n        1.0f, 1.0f, 1.0f,\n\n        // Right face\n        1.0f, 1.0f, 1.0f,\n        1.0f, -1.0f, 1.0f,\n        1.0f, 1.0f, -1.0f,\n        1.0f, -1.0f, 1.0f,\n        1.0f, -1.0f, -1.0f,\n        1.0f, 1.0f, -1.0f,\n\n        // Back face\n        1.0f, 1.0f, -1.0f,\n        1.0f, -1.0f, -1.0f,\n        -1.0f, 1.0f, -1.0f,\n        1.0f, -1.0f, -1.0f,\n        -1.0f, -1.0f, -1.0f,\n        -1.0f, 1.0f, -1.0f,\n\n        // Left face\n        -1.0f, 1.0f, -1.0f,\n        -1.0f, -1.0f, -1.0f,\n        -1.0f, 1.0f, 1.0f,\n        -1.0f, -1.0f, -1.0f,\n        -1.0f, -1.0f, 1.0f,\n        -1.0f, 1.0f, 1.0f,\n\n        // Top face\n        -1.0f, 1.0f, -1.0f,\n        -1.0f, 1.0f, 1.0f,\n        1.0f, 1.0f, -1.0f,\n        -1.0f, 1.0f, 1.0f,\n        1.0f, 1.0f, 1.0f,\n        1.0f, 1.0f, -1.0f,\n\n        // Bottom face\n        1.0f, -1.0f, -1.0f,\n        1.0f, -1.0f, 1.0f,\n        -1.0f, -1.0f, -1.0f,\n        1.0f, -1.0f, 1.0f,\n        -1.0f, -1.0f, 1.0f,\n        -1.0f, -1.0f, -1.0f,\n    };\n}\n```", "```kt\n    // Model variables\n    private static float cubeCoords[] = Cube.CUBE_COORDS;\n    private final int cubeVertexCount = cubeCoords.length / COORDS_PER_VERTEX;\n    private float cubeColor[] = { 0.8f, 0.6f, 0.2f, 0.0f }; // yellow-ish\n    private float[] cubeTransform;\n    private float cubeDistance = 5f;\n\n    // Viewing variables\n    private float[] cubeView;\n\n    // Rendering variables\n    private FloatBuffer cubeVerticesBuffer;\n    private int cubeProgram;\n    private int cubePositionParam;\n    private int cubeColorParam;\n    private int cubeMVPMatrixParam;\n```", "```kt\n        cubeTransform = new float[16];\n        cubeView = new float[16];\n```", "```kt\n        prepareRenderingCube();\n```", "```kt\nprivate void prepareRenderingCube() {\n        // Allocate buffers\n        ByteBuffer bb = ByteBuffer.allocateDirect(cubeCoords.length * 4);\n        bb.order(ByteOrder.nativeOrder());\n        cubeVerticesBuffer = bb.asFloatBuffer();\n        cubeVerticesBuffer.put(cubeCoords);\n        cubeVerticesBuffer.position(0);\n\n        // Create GL program\n        cubeProgram = GLES20.glCreateProgram();\n        GLES20.glAttachShader(cubeProgram, simpleVertexShader);\n        GLES20.glAttachShader(cubeProgram, simpleFragmentShader);\n        GLES20.glLinkProgram(cubeProgram);\n        GLES20.glUseProgram(cubeProgram);\n\n        // Get shader params\n        cubePositionParam = GLES20.glGetAttribLocation(cubeProgram, \"a_Position\");\n        cubeColorParam = GLES20.glGetUniformLocation(cubeProgram, \"u_Color\");\n        cubeMVPMatrixParam = GLES20.glGetUniformLocation(cubeProgram, \"u_MVP\");\n\n        // Enable arrays\n        GLES20.glEnableVertexAttribArray(cubePositionParam);\n    }\n```", "```kt\n        // Rotate and position the cube\n        Matrix.setIdentityM(cubeTransform, 0);\n        Matrix.translateM(cubeTransform, 0, 0, 0, -cubeDistance);\n        Matrix.rotateM(cubeTransform, 0, 30, 1, 1, 0);\n```", "```kt\n        Matrix.multiplyMM(cubeView, 0, view, 0, cubeTransform, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, cubeView, 0);\n        drawCube();\n```", "```kt\n    private void drawCube() {\n        GLES20.glUseProgram(cubeProgram);\n        GLES20.glUniformMatrix4fv(cubeMVPMatrixParam, 1, false, modelViewProjection, 0);\n        GLES20.glVertexAttribPointer(cubePositionParam, COORDS_PER_VERTEX,\n                GLES20.GL_FLOAT, false, 0, cubeVerticesBuffer);\n        GLES20.glUniform4fv(cubeColorParam, 1, cubeColor, 0);\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, cubeVertexCount);\n    }\n```", "```kt\nuniform mat4 u_MVP;\nuniform mat4 u_MVMatrix;\nuniform vec3 u_LightPos;\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec3 a_Normal;\n\nconst float ONE = 1.0;\nconst float COEFF = 0.00001;\n\nvarying vec4 v_Color;\n\nvoid main() {\n   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);\n   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));\n\n   float distance = length(u_LightPos - modelViewVertex);\n   vec3 lightVector = normalize(u_LightPos - modelViewVertex);\n   float diffuse = max(dot(modelViewNormal, lightVector), 0.5);\n\n   diffuse = diffuse * (ONE / (ONE + (COEFF * distance * distance)));\n   v_Color = a_Color * diffuse;\n   gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision mediump float;\nvarying vec4 v_Color;\n\nvoid main() {\n    gl_FragColor = v_Color;\n}\n```", "```kt\n    // Rendering variables\n    private int lightVertexShader;\n    private int passthroughFragmentShader;\n```", "```kt\n        lightVertexShader = loadShader(GLES20.GL_VERTEX_SHADER,\n                R.raw.light_vertex);\n        passthroughFragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER,\n                R.raw.passthrough_fragment);\n```", "```kt\n    public static final float[] CUBE_COLORS_FACES = new float[] {\n        // Front, green\n        0f, 0.53f, 0.27f, 1.0f,\n        // Right, blue\n        0.0f, 0.34f, 0.90f, 1.0f,\n        // Back, also green\n        0f, 0.53f, 0.27f, 1.0f,\n        // Left, also blue\n        0.0f, 0.34f, 0.90f, 1.0f,\n        // Top, red\n        0.84f,  0.18f,  0.13f, 1.0f,\n        // Bottom, also red\n        0.84f,  0.18f,  0.13f, 1.0f,\n    };\n\n    public static final float[] CUBE_NORMALS_FACES = new float[] {\n        // Front face\n        0.0f, 0.0f, 1.0f,\n        // Right face\n        1.0f, 0.0f, 0.0f,\n        // Back face\n        0.0f, 0.0f, -1.0f,\n        // Left face\n        -1.0f, 0.0f, 0.0f,\n        // Top face\n        0.0f, 1.0f, 0.0f,\n        // Bottom face\n        0.0f, -1.0f, 0.0f,\n    };\n```", "```kt\n    /**\n     * Utility method for generating float arrays for cube faces\n     *\n     * @param model - float[] array of values per face.\n     * @param coords_per_vertex - int number of coordinates per vertex.\n     * @return - Returns float array of coordinates for triangulated cube faces.\n     *               6 faces X 6 points X coords_per_vertex\n     */\n    public static float[] cubeFacesToArray(float[] model, int coords_per_vertex) {\n        float coords[] = new float[6 * 6 * coords_per_vertex];\n        int index = 0;\n        for (int iFace=0; iFace < 6; iFace++) {\n            for (int iVertex=0; iVertex < 6; iVertex++) {\n                for (int iCoord=0; iCoord < coords_per_vertex; iCoord++) {\n                    coords[index] = model[iFace*coords_per_vertex + iCoord];\n                    index++;\n                }\n            }\n        }\n        return coords;\n    }\n```", "```kt\n    // Model variables\n    private static float cubeCoords[] = Cube.CUBE_COORDS;\n    private static float cubeColors[] = Cube.cubeFacesToArray(Cube.CUBE_COLORS_FACES, 4);\n    private static float cubeNormals[] = Cube.cubeFacesToArray(Cube.CUBE_NORMALS_FACES, 3);\n```", "```kt\n    // Rendering variables\n    private FloatBuffer cubeVerticesBuffer;\n    private FloatBuffer cubeColorsBuffer;\n    private FloatBuffer cubeNormalsBuffer;\n```", "```kt\n    private void prepareRenderingCube() {\n        // Allocate buffers\n        ByteBuffer bb = ByteBuffer.allocateDirect(cubeCoords.length * 4);\n        bb.order(ByteOrder.nativeOrder());\n        cubeVerticesBuffer = bb.asFloatBuffer();\n        cubeVerticesBuffer.put(cubeCoords);\n        cubeVerticesBuffer.position(0);\n\n        ByteBuffer bbColors = ByteBuffer.allocateDirect(cubeColors.length * 4);\n bbColors.order(ByteOrder.nativeOrder());\n cubeColorsBuffer = bbColors.asFloatBuffer();\n cubeColorsBuffer.put(cubeColors);\n cubeColorsBuffer.position(0);\n\n ByteBuffer bbNormals = ByteBuffer.allocateDirect(cubeNormals.length * 4);\n bbNormals.order(ByteOrder.nativeOrder());\n cubeNormalsBuffer = bbNormals.asFloatBuffer();\n cubeNormalsBuffer.put(cubeNormalParam);\n cubeNormalsBuffer.position(0);\n\n        // Create GL program\n```", "```kt\n    // Rendering variables\n    private int cubeNormalParam;\n    private int cubeModelViewParam;\n    private int cubeLightPosParam;\n```", "```kt\n        // Create GL program\n        cubeProgram = GLES20.glCreateProgram();\n        GLES20.glAttachShader(cubeProgram, lightVertexShader);\n        GLES20.glAttachShader(cubeProgram, passthroughFragmentShader);\n        GLES20.glLinkProgram(cubeProgram);\n        GLES20.glUseProgram(cubeProgram);\n\n        // Get shader params\n        cubeModelViewParam = GLES20.glGetUniformLocation(cubeProgram, \"u_MVMatrix\");\n        cubeMVPMatrixParam = GLES20.glGetUniformLocation(cubeProgram, \"u_MVP\");\n        cubeLightPosParam = GLES20.glGetUniformLocation(cubeProgram, \"u_LightPos\");\n\n        cubePositionParam = GLES20.glGetAttribLocation(cubeProgram, \"a_Position\");\n        cubeNormalParam = GLES20.glGetAttribLocation(cubeProgram, \"a_Normal\");\n cubeColorParam = GLES20.glGetAttribLocation(cubeProgram, \"a_Color\");\n\n        // Enable arrays\n        GLES20.glEnableVertexAttribArray(cubePositionParam);\n        GLES20.glEnableVertexAttribArray(cubeNormalParam);\n GLES20.glEnableVertexAttribArray(cubeColorParam);\n\n```", "```kt\n    // Scene variables\n    // light positioned just above the user\n    private static final float[] LIGHT_POS_IN_WORLD_SPACE = new float[] { 0.0f, 2.0f, 0.0f, 1.0f };\n    private final float[] lightPosInEyeSpace = new float[4];\n```", "```kt\n        // Apply the eye transformation to the camera\n        Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);\n\n        // Calculate position of the light\n        Matrix.multiplyMV(lightPosInEyeSpace, 0, view, 0, LIGHT_POS_IN_WORLD_SPACE, 0);\n```", "```kt\n    private void drawCube() {\n        GLES20.glUseProgram(cubeProgram);\n\n        // Set the light position in the shader\n GLES20.glUniform3fv(cubeLightPosParam, 1, lightPosInEyeSpace, 0);\n\n        // Set the ModelView in the shader, used to calculate lighting\n GLES20.glUniformMatrix4fv(cubeModelViewParam, 1, false, cubeView, 0);\n\n        GLES20.glUniformMatrix4fv(cubeMVPMatrixParam, 1, false, modelViewProjection, 0);\n\n        GLES20.glVertexAttribPointer(cubePositionParam, COORDS_PER_VERTEX,\n                GLES20.GL_FLOAT, false, 0, cubeVerticesBuffer);\n        GLES20.glVertexAttribPointer(cubeNormalParam, 3, GLES20.GL_FLOAT, false, 0,\n cubeNormalsBuffer);\n GLES20.glVertexAttribPointer(cubeColorParam, 4, GLES20.GL_FLOAT, false, 0,\n cubeColorsBuffer);\n\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, cubeVertexCount);\n    }\n```", "```kt\n    // Viewing variables\n    private static final float TIME_DELTA = 0.3f;\n```", "```kt\nMatrix.rotateM(cubeTransform, 0, TIME_DELTA, 0.5f, 0.5f, 1.0f);\n```", "```kt\nuniform mat4 u_Model;\nuniform mat4 u_MVP;\nuniform mat4 u_MVMatrix;\nuniform vec3 u_LightPos;\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec3 a_Normal;\n\nvarying vec4 v_Color;\nvarying vec3 v_Grid;\n\nconst float ONE = 1.0;\nconst float COEFF = 0.00001;\n\nvoid main() {\n v_Grid = vec3(u_Model * a_Position);\n\n    vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);\n    vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));\n\n    float distance = length(u_LightPos - modelViewVertex);\n    vec3 lightVector = normalize(u_LightPos - modelViewVertex);\n    float diffuse = max(dot(modelViewNormal, lightVector), 0.5);\n\n    diffuse = diffuse * (ONE / (ONE + (COEFF * distance * distance)));\n    v_Color = a_Color * diffuse;\n    gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision mediump float;\nvarying vec4 v_Color;\nvarying vec3 v_Grid;\n\nvoid main() {\n    float depth = gl_FragCoord.z / gl_FragCoord.w; // Calculate world-space distance.\n\n    if ((mod(abs(v_Grid.x), 10.0) < 0.1) || (mod(abs(v_Grid.z), 10.0) < 0.1)) {\n        gl_FragColor = max(0.0, (90.0-depth) / 90.0) * vec4(1.0, 1.0, 1.0, 1.0)\n                + min(1.0, depth / 90.0) * v_Color;\n    } else {\n        gl_FragColor = v_Color;\n    }\n}\n```", "```kt\n    // Rendering variables\n    private int gridFragmentShader;\n```", "```kt\n        gridFragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER,\n                R.raw.grid_fragment);\n```", "```kt\n    public static final float[] FLOOR_COORDS = new float[] {\n        200f, 0, -200f,\n        -200f, 0, -200f,\n        -200f, 0, 200f,\n        200f, 0, -200f,\n        -200f, 0, 200f,\n        200f, 0, 200f,\n    };\n\n    public static final float[] FLOOR_NORMALS = new float[] {\n        0.0f, 1.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n    };\n\n    public static final float[] FLOOR_COLORS = new float[] {\n            0.0f, 0.34f, 0.90f, 1.0f,\n            0.0f, 0.34f, 0.90f, 1.0f,\n            0.0f, 0.34f, 0.90f, 1.0f,\n            0.0f, 0.34f, 0.90f, 1.0f,\n            0.0f, 0.34f, 0.90f, 1.0f,\n            0.0f, 0.34f, 0.90f, 1.0f,\n    };\n```", "```kt\n    // Model variables\n    private static float floorCoords[] = Floor.FLOOR_COORDS;\n    private static float floorColors[] = Floor.FLOOR_COLORS;\n    private static float floorNormals[] = Floor.FLOOR_NORMALS;\n    private final int floorVertexCount = floorCoords.length / COORDS_PER_VERTEX;\n    private float[] floorTransform;\n    private float floorDepth = 20f;\n\n    // Viewing variables\n    private float[] floorView;\n\n    // Rendering variables\n    private int gridFragmentShader;\n\n    private FloatBuffer floorVerticesBuffer;\n    private FloatBuffer floorColorsBuffer;\n    private FloatBuffer floorNormalsBuffer;\n    private int floorProgram;\n    private int floorPositionParam;\n    private int floorColorParam;\n    private int floorMVPMatrixParam;\n    private int floorNormalParam;\n    private int floorModelParam;\n    private int floorModelViewParam;\n    private int floorLightPosParam;\n```", "```kt\n        floorTransform = new float[16];\n        floorView = new float[16];\n```", "```kt\n        prepareRenderingFloor();\n```", "```kt\n        // Position the floor\n        Matrix.setIdentityM(floorTransform, 0);\n        Matrix.translateM(floorTransform, 0, 0, -floorDepth, 0);\n```", "```kt\n    private void prepareRenderingFloor() {\n        // Allocate buffers\n        ByteBuffer bb = ByteBuffer.allocateDirect(floorCoords.length * 4);\n        bb.order(ByteOrder.nativeOrder());\n        floorVerticesBuffer = bb.asFloatBuffer();\n        floorVerticesBuffer.put(floorCoords);\n        floorVerticesBuffer.position(0);\n\n        ByteBuffer bbColors = ByteBuffer.allocateDirect(floorColors.length * 4);\n        bbColors.order(ByteOrder.nativeOrder());\n        floorColorsBuffer = bbColors.asFloatBuffer();\n        floorColorsBuffer.put(floorColors);\n        floorColorsBuffer.position(0);\n\n        ByteBuffer bbNormals = ByteBuffer.allocateDirect(floorNormals.length * 4);\n        bbNormals.order(ByteOrder.nativeOrder());\n        floorNormalsBuffer = bbNormals.asFloatBuffer();\n        floorNormalsBuffer.put(floorNormals);\n        floorNormalsBuffer.position(0);\n\n        // Create GL program\n        floorProgram = GLES20.glCreateProgram();\n        GLES20.glAttachShader(floorProgram, lightVertexShader);\n        GLES20.glAttachShader(floorProgram, gridFragmentShader);\n        GLES20.glLinkProgram(floorProgram);\n        GLES20.glUseProgram(floorProgram);\n\n        // Get shader params\n        floorPositionParam = GLES20.glGetAttribLocation(floorProgram, \"a_Position\");\n        floorNormalParam = GLES20.glGetAttribLocation(floorProgram, \"a_Normal\");\n        floorColorParam = GLES20.glGetAttribLocation(floorProgram, \"a_Color\");\n\n        floorModelParam = GLES20.glGetUniformLocation(floorProgram, \"u_Model\");\n        floorModelViewParam = GLES20.glGetUniformLocation(floorProgram, \"u_MVMatrix\");\n        floorMVPMatrixParam = GLES20.glGetUniformLocation(floorProgram, \"u_MVP\");\n        floorLightPosParam = GLES20.glGetUniformLocation(floorProgram, \"u_LightPos\");\n\n        // Enable arrays\n        GLES20.glEnableVertexAttribArray(floorPositionParam);\n        GLES20.glEnableVertexAttribArray(floorNormalParam);\n        GLES20.glEnableVertexAttribArray(floorColorParam);\n    }\n```", "```kt\n        Matrix.multiplyMM(floorView, 0, view, 0, floorTransform, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, floorView, 0);\n        drawFloor();\n```", "```kt\n    private void drawFloor() {\n        GLES20.glUseProgram(floorProgram);\n        GLES20.glUniform3fv(floorLightPosParam, 1, lightPosInEyeSpace, 0);\n        GLES20.glUniformMatrix4fv(floorModelParam, 1, false, floorTransform, 0);\n        GLES20.glUniformMatrix4fv(floorModelViewParam, 1, false, floorView, 0);\n        GLES20.glUniformMatrix4fv(floorMVPMatrixParam, 1, false, modelViewProjection, 0);\n        GLES20.glVertexAttribPointer(floorPositionParam, COORDS_PER_VERTEX,\n                GLES20.GL_FLOAT, false, 0, floorVerticesBuffer);\n        GLES20.glVertexAttribPointer(floorNormalParam, 3, GLES20.GL_FLOAT, false, 0,\n                floorNormalsBuffer);\n        GLES20.glVertexAttribPointer(floorColorParam, 4, GLES20.GL_FLOAT, false, 0,\n                floorColorsBuffer);\n        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, floorVertexCount);\n    }\n```", "```kt\n/**\n     * Check if user is looking at object by calculating where the object is in eye-space.\n     *\n     * @return true if the user is looking at the object.\n     */\n    private boolean isLookingAtObject(float[] modelView, float[] modelTransform) {\n        float[] initVec = { 0, 0, 0, 1.0f };\n        float[] objPositionVec = new float[4];\n\n        // Convert object space to camera space. Use the headView from onNewFrame.\n        Matrix.multiplyMM(modelView, 0, headView, 0, modelTransform, 0);\n        Matrix.multiplyMV(objPositionVec, 0, modelView, 0, initVec, 0);\n\n        float pitch = (float) Math.atan2(objPositionVec[1], -objPositionVec[2]);\n        float yaw = (float) Math.atan2(objPositionVec[0], -objPositionVec[2]);\n\n        return Math.abs(pitch) < PITCH_LIMIT && Math.abs(yaw) < YAW_LIMIT;\n    }\n```", "```kt\n    // Viewing variables\n    private static final float YAW_LIMIT = 0.12f;\n    private static final float PITCH_LIMIT = 0.12f;\n\n    private float[] headView;\n```", "```kt\n        headView = new float[16];\n```", "```kt\n        headTransform.getHeadView(headView, 0);\n```", "```kt\n        if (isLookingAtObject(cubeView, cubeTransform)) {\n            GLES20.glVertexAttribPointer(cubeColorParam, 4, GLES20.GL_FLOAT, false, 0,\n                    cubeFoundColorsBuffer);\n        } else {\n            GLES20.glVertexAttribPointer(cubeColorParam, 4, GLES20.GL_FLOAT, false, 0,\n                    cubeColorsBuffer);\n        }\n```", "```kt\n    public static final float[] CUBE_FOUND_COLORS_FACES = new float[] {\n        // Same yellow for front, right, back, left, top, bottom faces\n        1.0f,  0.65f, 0.0f, 1.0f,\n        1.0f,  0.65f, 0.0f, 1.0f,\n        1.0f,  0.65f, 0.0f, 1.0f,\n        1.0f,  0.65f, 0.0f, 1.0f,\n        1.0f,  0.65f, 0.0f, 1.0f,\n        1.0f,  0.65f, 0.0f, 1.0f,\n    };\n```", "```kt\n    // Model variables\n    private static float cubeFoundColors[] = Cube.cubeFacesToArray(Cube.CUBE_FOUND_COLORS_FACES, 4);\n\n    // Rendering variables\n    private FloatBuffer cubeFoundColorsBuffer;\n```", "```kt\n        ByteBuffer bbFoundColors = ByteBuffer.allocateDirect(cubeFoundColors.length * 4);\n        bbFoundColors.order(ByteOrder.nativeOrder());\n        cubeFoundColorsBuffer = bbFoundColors.asFloatBuffer();\n        cubeFoundColorsBuffer.put(cubeFoundColors);\n        cubeFoundColorsBuffer.position(0);\n```"]