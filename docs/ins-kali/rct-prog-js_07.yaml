- en: Chapter 7. Not Reinventing the Wheel – Tools for Functional Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。不要重复造轮子-函数式响应式编程工具
- en: In this chapter, we will look at a few out of the many good tools for building
    on top of "bare-metal" JavaScript, as discussed briefly in the last chapter. JavaScript
    is not interesting only for its properties as a core language; browser JavaScript
    is home to an ecosystem, or perhaps multiple ecosystems. Regarding tools for functional
    reactive programming, the total set of offerings represents a good, healthy, and
    sprawling bazaar, next to which the direct use of JavaScript alone for all web
    development looks more like a cathedral. We will be taking a small sample of this
    bazaar, with the understanding that this chapter does not intend to cover all
    that is good, interesting, or worthwhile. That's very hard to do in a bazaar!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些用于在“裸金属”JavaScript之上构建的许多优秀工具中的一些，正如上一章中简要讨论的那样。JavaScript不仅因为其作为核心语言的特性而有趣；浏览器JavaScript是一个生态系统，或者说可能是多个生态系统的家园。关于函数式响应式编程的工具，总体的提供代表了一个良好、健康和庞大的集市，与之相比，仅仅使用JavaScript进行所有Web开发看起来更像是一座大教堂。我们将从这个集市中取一小部分，理解到本章并不打算涵盖所有好的、有趣的或值得的东西。在集市中做到这一点是非常困难的！
- en: 'The tools that we will cover include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍的工具包括以下内容：
- en: ClojureScript and Om
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClojureScript和Om
- en: Bacon.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacon.js
- en: Brython
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brython
- en: Immutable.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Immutable.js
- en: Jest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest
- en: Fluxxor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluxxor
- en: The set of tools we would include, or not include, in a chapter such as this
    involves drawing lines that are up for, and making judgment calls. Readers interested
    in a more comprehensive treatment can look at the link compendium at [http://tinyurl.com/reactjs-complementary-tools](http://tinyurl.com/reactjs-complementary-tools),
    and drill down to the tools that are of interest to their specific concerns. There
    is a lot there, and probably a lot of gems for almost any purpose.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这样一个章节中包含或不包含的一组工具，涉及到需要划定界限和做出判断。对于更全面的处理感兴趣的读者可以查看[http://tinyurl.com/reactjs-complementary-tools](http://tinyurl.com/reactjs-complementary-tools)上的链接汇编，并深入研究他们特定关注的工具。那里有很多东西，几乎可以满足任何目的的很多宝贝。
- en: ClojureScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClojureScript
- en: ClojureScript, and perhaps Clojure in general, represents an important watershed
    in software and web development. ClojureScript proves by example that it is possible
    to have a solid foundation and environment for development in a language other
    than JavaScript, and this pioneering language is a Lisp dialect. (This is fitting
    perhaps, for one of the two oldest programming languages in common use. Lisp was
    good when it came out, and it's still a good language today.) Furthermore, Lisp
    may enjoy a good advantage compared to JavaScript, and be alive due to some of
    the same reasons. JavaScript is the language of web browsers and Lisp is the language
    of Emacs. Also, Lisp offers a sort of proto-JavaScript; before there were web
    browsers that were programmable in JavaScript, there were Emacsen programmable
    in Lisp, and someone who said Lisp was the better language in comparison to JavaScript
    would hardly be contested.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript，也许是Clojure总体上，代表了软件和Web开发的一个重要分水岭。ClojureScript通过示例证明，除了JavaScript之外，还可以在其他语言中拥有坚实的基础和开发环境，而这种开创性的语言是一种Lisp方言。（这或许很合适，因为它是两种最常用的最古老的编程语言之一。Lisp在诞生时就很好，今天仍然是一种很好的语言。）此外，与JavaScript相比，Lisp可能具有很大的优势，并且由于一些相同的原因而存在。JavaScript是Web浏览器的语言，而Lisp是Emacs的语言。此外，Lisp提供了一种原始的JavaScript；在可以用JavaScript编程的Web浏览器出现之前，可以用Lisp编程的Emacs就已经存在了，而且任何人说Lisp比JavaScript更好的话几乎不会受到质疑。
- en: 'There is good reason to suggest that Lisp, and not the Emacs default key bindings,
    is responsible for the classical Emacs learning curve in this "classical learning
    curves" cartoon that has been floating around on the Internet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有充分的理由表明，Lisp而不是Emacs默认的键绑定，是导致在互联网上流传的“经典学习曲线”漫画中的经典Emacs学习曲线的原因：
- en: '![ClojureScript](img/B04148_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![ClojureScript](img/B04148_07_01.jpg)'
- en: As suggested in an earlier chapter, the uniformity of everybody programming
    directly in JavaScript may give way to a beautiful diversity, or a patchwork quilt.
    In this beautiful patchwork quilt, JavaScript may still be pre-eminent, but JavaScript's
    pre-eminence may serve as the new "bare metal." We may have a collection of high-level
    languages and tools for frontend development. Again, as Alan Perlis said, "A language
    is low-level when it requires attention to the irrelevant." On those grounds,
    JavaScript is low-level.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前面的章节中建议的那样，每个人直接在JavaScript中编程的统一性可能会让位于美丽的多样性，或者一块拼布。在这个美丽的拼布中，JavaScript可能仍然是卓越的，但JavaScript的卓越地位可能成为新的“裸金属”。我们可能会有一系列用于前端开发的高级语言和工具。再次引用Alan
    Perlis的话，“当一个语言需要关注无关紧要的事情时，它就是低级的。”基于这些理由，JavaScript是低级的。
- en: Some of these tools may have a better portfolio of good parts with respect to
    the bad parts. They may lend themselves to frontend work that may still finally
    be executed in JavaScript. But they may also open up frontend web development
    in which new developers are no longer told, "Here is the language that we will
    use, and here are some large portions of the language that you should try to avoid
    as much as possible because they are fundamentally toxic." Newer versions of ECMAScript
    (the formal name for JavaScript, and it is not particularly connected to Emacs)
    may offer better collections of features, but it is still desirable to work in
    high-level languages that offer a better terrain for productive work and results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的一些可能在好的部分方面比坏的部分更好。它们可能适用于前端工作，最终仍然会在JavaScript中执行。但它们也可能开启前端Web开发，其中新的开发人员不再被告知，“这是我们将使用的语言，这是语言的一些大部分，你应该尽量避免，因为它们从根本上是有毒的。”ECMAScript（JavaScript的正式名称，与Emacs没有特别的联系）的新版本可能提供更好的功能集合，但在高级语言中工作仍然是可取的，因为它们提供了更好的生产工作和结果的平台。
- en: ClojureScript says, with bells on, that it is possible to have a good high-level
    language that will run on browsers, and this isn't good news only for Lisp hackers.
    It is good news for everyone. It demonstrates an open door to the possibility
    of web development in other high-level languages and potentially a better web
    development environment with fewer tar pits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript毫不犹豫地表示，可以在浏览器上运行一个良好的高级语言，这不仅对Lisp黑客是个好消息。这对每个人都是好消息。它展示了在其他高级语言中进行Web开发的可能性，并且可能会有一个更好的Web开发环境，减少了沥青坑的可能性。
- en: 'ClojureScript can be used both for client-side work and on the server side
    with Node.js. *Hello, World!* is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript既可以用于客户端工作，也可以在Node.js上用于服务器端。*Hello, World!* 如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Om
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Om
- en: Om is a wrapper that makes ReactJS available for ClojureScript. Apart from the
    fact that ClojureScript is usually fast, a certain part of Om is actually about
    two times faster than in JavaScript. The difference has to do with identifying
    changes so as to optimally and appropriately update the DOM when ReactJS does
    that. The reason is that ReactJS, in its diffing algorithm (by dealing with mutable
    JavaScript data structures), has to perform a deep comparison to see what, if
    anything, in the (pure JavaScript) synthetic virtual DOM has changed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Om是一个包装器，使ReactJS可用于ClojureScript。除了ClojureScript通常很快之外，Om的某个部分实际上比JavaScript快大约两倍。这种差异与识别变化有关，以便在ReactJS执行DOM更新时进行最佳和适当的更新。原因是ReactJS在其差异算法中（通过处理可变的JavaScript数据结构）必须执行深度比较，以查看（纯JavaScript）合成虚拟DOM中的内容是否有变化。
- en: 'This is still lightning fast compared to direct DOM manipulations, so fast
    that it''s really not the bottleneck for most ReactJS users. But it''s faster
    in Om. The reason is that ClojureScript, like a good functional programming language,
    has immutable data. You can easily enough get a mutated copy of something, but
    you cannot tamper with the original or trip up anyone who has access to the original.
    This means that Om can get by with only comparing top-level references and not
    digging into the depths of data structures. This is enough to make Om faster than
    the original JavaScript use of ReactJS. *Hello, World!* in Om is written like
    this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接DOM操作相比，这仍然非常快，以至于对大多数ReactJS用户来说并不是瓶颈。但在Om中更快。原因是ClojureScript像一种良好的函数式编程语言一样具有不可变数据。你可以很容易地获得某物的突变副本，但你不能篡改原始副本或使访问原始副本的任何人受到影响。这意味着Om只需比较顶层引用而不深入数据结构的深度就足够了。这足以使Om比原始的JavaScript使用ReactJS更快。在Om中，*Hello,
    World!* 是这样写的：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Bacon.js
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bacon.js
- en: Note that discussing ReactJS and Bacon.js alone does not qualify as an exhaustive
    list. To mention one alternative suite, Microsoft has tried to create RxJS, RxCpp
    [Rx for C++], Rx.NET, and Rx* for various JavaScript frameworks and libraries,
    and they've at least tried to make a polyglot-friendly portfolio for multiple
    languages and optimized versions for multiple JavaScript frameworks and libraries.
    There is really a lot available that offers some form of functional reactive programming.
    And while most of the few (at the time of writing this book) functional reactive
    programming and ReactJS resources on the Web are golden, there are some that aren't.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅讨论ReactJS和Bacon.js并不足以构成一个详尽的列表。提到另一个替代套件，微软已经尝试创建了RxJS、RxCpp [Rx for C++]、Rx.NET和Rx*，适用于各种JavaScript框架和库，并且他们至少尝试为多种语言和多种JavaScript框架和库的优化版本创建了一个多语言友好的组合。实际上有很多可用的提供某种形式的函数式响应式编程。虽然大多数（在撰写本书时）Web上的函数式响应式编程和ReactJS资源都是宝贵的，但也有一些不是。
- en: 'Andre Stalz writes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈·斯塔尔兹写道：
- en: '*"So you''re curious in learning this new thing called Reactive Programming,
    particularly its variant comprising of Rx, Bacon.js, RAC, and others.*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“所以你对学习这个叫做响应式编程的新东西感到好奇，特别是它的变体，包括Rx、Bacon.js、RAC等。”*'
- en: '>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Learning it is hard, even harder by the lack of good material. When I started,
    I tried looking for tutorials. I found only a handful of practical guides, but
    they just scratched the surface and never tackled the challenge of building the
    whole architecture around it. Library documentations often don''t help when you''re
    trying to understand some function. I mean, honestly, look at this:*'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*学习它很难，缺乏好的材料使它更加困难。当我开始时，我试图寻找教程。我只找到了少数实用指南，但它们只是皮毛，从未解决围绕它构建整个架构的挑战。当你试图理解某个函数时，库文档通常没有帮助。我是说，老实说，看看这个：*'
- en: '>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Rx.Observable.prototype.flatMapLatest(selector, [thisArg])*'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Rx.Observable.prototype.flatMapLatest(selector, [thisArg])*'
- en: '>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Projects each element of an observable sequence into a new sequence of observable
    sequences by incorporating the element''s index and then transforms an observable
    sequence of observable sequences into an observable sequence producing values
    only from the most recent observable sequence."*'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*通过将可观察序列的每个元素投影到一个新的可观察序列中，该新序列将元素的索引合并，然后将可观察序列转换为仅从最近的可观察序列产生值的可观察序列。*'
- en: I now understand what the quotation is saying, but that's because I've learned
    from other resources that have communicated better. Part of the intent behind
    this book you are reading is to make good documentation a little less difficult
    to understand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在明白这句引语的意思，但那是因为我从其他沟通更好的资源中学到了。你正在阅读的这本书的目的之一是让好的文档变得更容易理解一些。
- en: 'There is a famous question in the open source community: would you buy a car
    with the hood welded shut? ReactJS can be described as a car that most people
    can drive without opening the hood. It''s not that ReactJS is closed-source, or
    that Facebook shows any signs of making it harder to read as much of the source
    code as you want. But to pick one salient example, **Denotative continuous-time
    semantics** was part of Conal Elliott''s second thoughts about what would be a
    better name for what is now called functional reactive programming. Whether one
    agrees or disagrees with his suggestion for a better and more descriptive name,
    such second thoughts from a leading light can be very insightful and illuminating.
    And with ReactJS, if it''s working correctly, a novice programmer can be given
    the same explanation that Calvin''s father (a patent attorney!) in Calvin and
    Hobbes gives when Calvin asks how a lamp, or a vacuum cleaner, works—*It''s magic!*
    Looking at a newcomer''s question, "How is continuous time handled?" the reply
    is *It''s magic!* "How can you get away with discarding and recreating the DOM
    every single time?"—*It''s magic!*; "But how does ReactJS achieve an astonishing
    60 fps on a non-JIT iPhone?"—*It''s magic!*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源社区中有一个著名的问题：你会买一个发动机盖被焊死的汽车吗？ReactJS可以被描述为大多数人可以在不打开发动机盖的情况下驾驶的汽车。这并不是说ReactJS是闭源的，或者Facebook显示出任何使其更难阅读源代码的迹象。但举一个显著的例子，**指示性连续时间语义**是Conal
    Elliott对现在称为函数式反应式编程的东西的更好名称的第二次思考的一部分。无论一个人是否同意他对更好和更具描述性名称的建议，这位领军人物的第二次思考可能非常有洞察力和启发性。而且对于ReactJS，如果它工作正常，一个新手程序员可以得到与Calvin的父亲（一位专利律师！）在Calvin
    and Hobbes中给出的相同解释，当Calvin问一个灯或者吸尘器是如何工作的时候——*这是魔术！*看着一个新手的问题，“连续时间是如何处理的？”回答是*这是魔术！*“你怎么能够丢弃和重新创建DOM每一次？”——*这是魔术！*；“但是ReactJS如何在非JIT
    iPhone上实现惊人的60fps？”——*这是魔术！*
- en: Functional reactive programming describes certain tasks that need to be accomplished,
    such as the appropriate handling of event streams, but the ReactJS documentation
    doesn't seem to explain how to address this handling because the responsibility
    is offloaded to ReactJS; *It's magic!*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式反应式编程描述了需要完成的某些任务，比如适当处理事件流，但ReactJS的文档似乎没有解释如何处理这些任务，因为这个责任被转移到了ReactJS；*这是魔术！*
- en: Not only does Bacon.js not weld the hood shut, but you are also expected to
    tinker under the hood. Bacon.js seems closer to the roots of basic functional
    reactive programming. Some programmers, intending to work in ReactJS, might find
    it profitable to "lift weights" a bit and strengthen themselves with Bacon.js.
    One significant area of functional reactive programming is dealing with emitted
    streams of events, and as far as ReactJS goes, *It's magic!*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js不仅没有焊死发动机盖，而且还期望你在发动机盖下进行调整。Bacon.js似乎更接近基本函数式反应式编程的根源。一些打算在ReactJS中工作的程序员可能会发现用Bacon.js“举重”一点并用Bacon.js加强自己是有利可图的。函数式反应式编程的一个重要领域是处理事件流的发射，就ReactJS而言，*这是魔术！*
- en: In Bacon.js, it is in fact not magic that all is done without you ever moving
    a finger; it is something that the programmer needs to work out, and they are
    given good tools to do so. On these grounds, it could help form a developer for
    a solid reactive programming foundation to use ReactJS. If the selling point of
    ReactJS is that it is a tool optimized to allow good user interface work while
    drawing on the strengths of functional reactive programming, the selling point
    of Bacon.js is that it is a tool in JavaScript that is optimized for (learning
    and) performing solid functional reactive programming in theory and practice as
    a whole.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bacon.js中，事实上并不是魔术，所有这些都是在你没有动手的情况下完成的；这是程序员需要解决的问题，并且他们有很好的工具来做到这一点。基于这些理由，使用ReactJS可能有助于为开发人员打下坚实的反应式编程基础。如果ReactJS的卖点是它是一个优化工具，可以在利用函数式反应式编程的优势的同时允许良好的用户界面工作，那么Bacon.js的卖点是它是一个在JavaScript中优化的工具，可以在理论和实践中（学习和）执行扎实的函数式反应式编程。
- en: The difference between ReactJS and Bacon.js doesn't seem to be a matter of unearthing
    that one framework is simply better than the other. It is rather a matter of taking
    stock of what you want to do and accomplish, recognizing that ReactJS and Bacon.js
    (besides being worthy competitors) have different areas where they really shine,
    and deciding whether your work sounds more like a ReactJS sweet spot or a Bacon.js
    sweet spot. Moreover, with respect to the topic of sweet spots, Bacon.js (unlike
    ReactJS) has a name meant to make your mouth water, and the `~` functional operator
    is called "bacon" in the references.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS和Bacon.js之间的区别似乎不是挖掘出一个框架比另一个更好的问题。相反，这更多地是关于审视你想要做和实现的事情，认识到ReactJS和Bacon.js（除了是值得竞争对手之外）在它们真正擅长的不同领域，并决定你的工作更像是ReactJS的甜蜜点还是Bacon.js的甜蜜点。此外，关于甜蜜点的话题，Bacon.js（不像ReactJS）有一个让你垂涎欲滴的名字，而`~`函数操作符在参考文献中被称为“bacon”。
- en: Brython – a Python browser implementation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Brython - 一个Python浏览器实现
- en: Brython ([http://brython.info](http://brython.info)), a browser and Python implementation,
    is another example of an alternative to programming a browser in JavaScript, and
    while it would be a bit unfair to Brython to call it merely experimental, it is
    also not necessarily appropriate to call it mature—certainly not in the same sense
    that ClojureScript has some significant maturity. ClojureScript is developed well
    enough to essentially replace "bare metal" JavaScript for a frontend developer
    who'd really prefer to use Lisp rather than JavaScript. In other words, unless
    we are talking about something performance-critical or possibly special cases,
    there aren't too many cases where ClojureScript experts would answer the question,
    "How do I do this in ClojureScript?" with, "Use JavaScript directly for this kind
    of problem." Brython is included not because the sun rises or sets on Python but
    as an illustration that Lisp in ClojureScript is not a fundamental exception in
    terms of being the only non-JavaScript language that works for frontend web development,
    but perhaps the first of many.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Brython ([http://brython.info](http://brython.info))是一个浏览器和Python实现，是另一个用Python编程浏览器的替代方案的例子，虽然将Brython仅仅称为实验性的有点不公平，但也不一定适合称其为成熟的——至少不像ClojureScript具有一定的成熟度。ClojureScript的发展足够好，可以基本上替代前端开发人员真正希望使用Lisp而不是JavaScript的"裸金属"JavaScript。换句话说，除非我们谈论一些性能关键的问题或可能的特殊情况，否则ClojureScript专家不会回答"我在ClojureScript中怎么做这个？"这样的问题，而是会说"对于这种问题直接使用JavaScript。"
    Brython被包含在这里并不是因为Python是唯一的非JavaScript语言，可以用于前端开发，而是作为一个例证，即ClojureScript中的Lisp并不是在前端Web开发方面的基本例外，而可能是许多例外中的第一个。
- en: Brython is meant for world domination. Its home page boldly announces, "Brython
    is intended to replace JavaScript as the scripting language for the Web," and
    it will, perhaps, never reach that quite naïve goal. Brython takes surprisingly
    long to load and is slow to run after it has loaded. It may be better to use one
    of the Python-to-JavaScript compilers (which would be closer to ClojureScript),
    but Brython really offers quite a lot of Python's goodness and may be someday
    be seen as significant. Yet, I would suggest that it is silly to try to be the
    next JavaScript and take the place of every other transpiler that renders JavaScript.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Brython旨在征服世界。它的主页大胆宣布："Brython旨在取代JavaScript成为Web的脚本语言"，也许永远无法达到这个相当天真的目标。Brython加载时间长，加载后运行速度慢。也许最好使用其中一个Python到JavaScript编译器（更接近ClojureScript），但Brython确实提供了相当多Python的优点，也许有一天会被视为重要。然而，我认为试图成为下一个JavaScript并取代其他渲染JavaScript的转译器是愚蠢的。
- en: 'In Brython, the goal of world domination also lends itself to a blind spot:
    failing to see how important it is to be able to interoperate with tools written
    in other languages. But the good news is that Brython or other Python-to-JavaScript
    approaches may be significant without needing to become the "One Language to Rule
    Them All." Python is hardly the only backend language available, but it''s a good
    player, and there is every reason for good implementations of Python to be worthwhile
    players in a patchwork quilt composed of multiple languages that can all be used
    profitably for frontend web development.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Brython中，征服世界的目标也导致了一个盲点：未能看到与其他语言编写的工具进行互操作的重要性。但好消息是，Brython或其他Python到JavaScript的方法可能是重要的，而无需成为"统治所有语言的一种语言"。Python并不是唯一可用的后端语言，但它是一个很好的选择，并且有充分的理由让Python的良好实现成为前端Web开发中可以有利用的多种语言拼贴拼图中的有价值的一部分。
- en: 'Furthermore, at least a *Hello,World!* program with ReactJS is straightforward
    to implement in Brython. A *Hello, World!* program, as run after gathering Brython
    and ReactJS on a page, includes first JavaScript (not JSX) commented out, and
    then the Python code that calls React in the browser via Brython:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用ReactJS编写至少一个*Hello,World!*程序在Brython中也很容易实现。在将Brython和ReactJS放在同一页后，运行*Hello,
    World!*程序，首先是JavaScript（不是JSX）被注释掉，然后是Python代码通过Brython在浏览器中调用React：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This displays what is shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了以下内容：
- en: '![Brython – a Python browser implementation](img/B04108_07_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Brython - 一个Python浏览器实现](img/B04108_07_02.jpg)'
- en: Note that the entire first script tag and contents, and not just the JavaScript
    inside them, are in an HTML comment. This means that the first (JavaScript) script,
    shown here for clarity, is not active, the second (Python) script being the one
    that runs and displays its message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个第一个脚本标签和内容，而不仅仅是其中的JavaScript，都在HTML注释中。这意味着第一个（JavaScript）脚本在这里仅用于清晰显示，并不活跃，第二个（Python）脚本才是运行并显示其消息的脚本。
- en: The second script is an interesting one; the included Python code is equivalent
    (apart from the message) to the commented-out JavaScript text and does the same
    thing. This is quite a feat, especially when combined with how Brython successfully
    implements most features in the 3.x branch of Python. Even if Brython is looked
    into for a project and deemed not the right solution, it remains an achievement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本很有趣；包含的Python代码（除了消息之外）与被注释掉的JavaScript文本相当，并且执行相同的操作。这是一个相当了不起的成就，特别是当Brython成功地实现了Python
    3.x分支中的大多数功能时。即使Brython被用于一个项目并被认为不是正确的解决方案，它仍然是一个成就。
- en: In one sense, Brython is presented here as an example of a possibility rather
    than, in any sense, the only member of its class that is worth attention. The
    point is not specifically that Python can be used for frontend development; it's
    that ClojureScript Lisp may not be the only additional language besides JavaScript
    that is available for use in frontend development.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，Brython在这里被提出作为一个可能性的例子，而不是任何意义上值得关注的唯一成员。重点不是特别是Python可以用于前端开发；而是ClojureScript
    Lisp可能不是除JavaScript之外唯一可用于前端开发的其他语言。
- en: Immutable.js – permanent protection from change
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Immutable.js - 永久保护免受更改
- en: Immutable.js, with its home page at [http://facebook.github.io/immutable-js](http://facebook.github.io/immutable-js)
    and a tagline of **Immutable collections for JavaScript**, was originally named
    for persistence. Then it went through a name change to something that would register
    more quickly by referring to the immutable. Immutable.js plugs a gap in JavaScript
    as a functional language and offers significantly more functional-friendly data
    structures for collections (which is the point for which it was created).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Immutable.js 的主页位于 [http://facebook.github.io/immutable-js](http://facebook.github.io/immutable-js)，标语是
    **Immutable collections for JavaScript**，最初是为持久性而命名的。然后它经历了一个更快地注册不可变的名称更改。Immutable.js
    填补了 JavaScript 作为函数语言的空白，并为集合提供了更多功能友好的数据结构（这是它创建的目的）。
- en: It offers data structures for collections that are immutable. They support the
    creation of modified copies gracefully enough, but it is always the copy that
    is changed, never the original. Though this is more of a minor point, it greatly
    reduces the need for "defensive copying" and related workarounds for not using
    immutable data where there are multiple programmers. The original code could be
    chugging along with a different and modified copy of the data structure that you
    want, but your copy, which you have kept as a reference, is guaranteed to be entirely
    untouched. The library is intended to support other niceties, such as easy conversion
    to and from staple JavaScript data structures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它为不可变的集合提供了数据结构支持。它们优雅地支持创建修改后的副本，但始终是副本发生了变化，而不是原始数据。尽管这更多是一个小点，但它大大减少了“防御性复制”和相关解决方法的需求，以便在有多个程序员的地方不使用不可变数据。原始代码可能会使用您想要的数据结构的不同和修改后的副本，但您保留为参考的副本保证完全不受影响。该库旨在支持其他便利功能，比如轻松地转换为和从基本的
    JavaScript 数据结构。
- en: However, data structures of Immutable.js are not only immutable; they are also
    lazy in some aspects, and the document clearly marks which aspects of an application
    are eager. (as a reminder, lazy data structures are treated in a print-on-demand
    fashion when needed, while eager operations are done at once and upfront). Furthermore,
    certain functional idioms are baked into Immutable.js facilities. For instance,
    there is a .`take(n)` method offered. It returns the first *n* items of a list
    in the classic functional fashion. Other functional staples, such as `map()`,
    `filter()`, and `reduce()`, are also available. In general, runtime complexity
    is as good as a computer scientist could reasonably request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Immutable.js 的数据结构不仅是不可变的；在某些方面它们也是懒惰的，文档清楚地标记了应用程序的哪些方面是急切的。 （作为提醒，懒惰的数据结构在需要时以按需打印的方式处理，而急切的操作是一次性和前置的）。此外，Immutable.js
    设施中还包含了某些函数习语。例如，它提供了一个 `.take(n)` 方法。它以经典的函数方式返回列表的前 *n* 个项目。其他函数标准，如 `map()`、`filter()`
    和 `reduce()`，也是可用的。总的来说，运行时复杂度和计算机科学家合理要求的一样好。
- en: 'There are several data types provided by Immutable.js; these include the following
    (the descriptions in this and the next table are partly based on the official
    documentation):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Immutable.js 提供了几种数据类型；其中包括以下内容（本表和下一个表中的描述部分基于官方文档）：
- en: '| Immutable.js class | Description |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Immutable.js 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Collection` | This is an abstract base class for Immutable.js data structures.
    It cannot be directly instantiated. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Collection` | 这是 Immutable.js 数据结构的抽象基类。不能直接实例化。 |'
- en: '| `IndexedCollection` | A collection that represents indexed values in a particular
    order. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `IndexedCollection` | 代表特定顺序中的索引值的集合。 |'
- en: '| `IndexedIterable` | This is an iterable with indexed numeric keys that support
    some array-like interface features, such as `indexOf()` (An iterable is something
    that you can iterate through like a list, but it may or may not be a list in the
    internals). |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `IndexedIterable` | 这是一个可迭代对象，具有支持一些类似数组接口功能的索引数字键，比如 `indexOf()`（可迭代对象是可以像列表一样迭代的东西，但在内部可能是也可能不是列表）。
    |'
- en: '| `IndexedSeq` | A `Seq` that supports an ordered indexed list of values. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `IndexedSeq` | 支持有序索引值列表的 `Seq`。 |'
- en: '| `Iterable` | A set of (key and index) values that can be iterated through.
    This class is the base class for all collections. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Iterable` | 一组（键和索引）值，可以进行迭代。这个类是所有集合的基类。 |'
- en: '| `KeyedCollection` | A collection that represents key-value pairs. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `KeyedCollection` | 代表键值对的集合。 |'
- en: '| `KeyedIterable` | An iterable with discrete keys tied to each iterable. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `KeyedIterable` | 一个与每个可迭代对象相关联的离散键的可迭代对象。 |'
- en: '| `KeyedSeq` | A sequence that represents key-value pairs. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `KeyedSeq` | 代表键值对的序列。 |'
- en: '| `List` | An ordered collection, somewhat like a (dense) JavaScript array.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `List` | 一个有序的集合，有点像（密集的）JavaScript 数组。 |'
- en: '| `Map` | A keyed iterable of key-value pairs. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | 一个键值对的可迭代对象。 |'
- en: '| `OrderedMap` | A map that does everything that a map does and, in addition,
    guarantees that iterations will produce keys in the order in which they are set.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedMap` | 一个地图，除了执行地图的所有操作之外，还保证迭代会按照设置的顺序产生键。 |'
- en: '| `OrderedSet` | A set that does everything that a set does and, in addition,
    guarantees, that iterations will produce values in the order in which they are
    set. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedSet` | 一个集合，除了保证迭代会按照设置的顺序产生值之外，还可以执行集合的所有操作。 |'
- en: '| `Record` | A class that produces concrete records. Conceptually, this is
    different from the other records here. The other elements are, conceptually, collections
    of "whatnots," perhaps objects that have a similar structure. The `Record` class
    is closer to the records one encounters in school, where one record is similar
    to a row in a database table, while result sets or tables are more like container
    objects. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Record` | 一个产生具体记录的类。在概念上，这与其他记录不同。其他元素在概念上是“杂物”的集合，可能是具有类似结构的对象。`Record`
    类更接近于学校里遇到的记录，其中一个记录类似于数据库表中的一行，而结果集或表更像容器对象。 |'
- en: '| `Seq` | A sequence of values, which may or may not be backed by a concrete
    data structure. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Seq` | 一个值的序列，可能有可能没有由具体数据结构支持。 |'
- en: '| `Set` | A collection of unique values. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | 一组唯一的值。 |'
- en: '| `SetCollection` | A collection of values without keys or indices. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `SetCollection` | 一组没有键或索引的值。 |'
- en: '| `SetIterable` | Iterables representing values without keys or indices. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `SetIterable` | 代表没有键或索引的值的可迭代对象。 |'
- en: '| `SetSeq` | A sequence representing a set of values. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `SetSeq` | 代表一组值的序列。 |'
- en: '| `Stack` | A standard stack with `push()` and `pop()`. Semantics always go
    to first element, unlike JavaScript arrays. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `Stack` | 一个标准的堆栈，带有`push()`和`pop()`。语义总是指向第一个元素，不像JavaScript数组。 |'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Record` is slightly different from the others; it is similar to a JavaScript
    object that meets certain criteria. The other elements are related container classes
    that provide functional access to some collection of objects and tend to have
    a similar list of methods supported.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record`与其他元素略有不同；它类似于满足某些条件的JavaScript对象。其他元素是相关的容器类，提供对一些对象集合的功能访问，并且通常具有类似的方法列表。'
- en: 'The methods for List, to pick one example, include the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的方法，以一个例子为例，包括以下内容：
- en: '| Immutable.List method | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Immutable.List 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `asImmutable` | A function that takes a (mutable) JavaScript collection and
    renders an Immutable.js collection. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `asImmutable` | 一个函数，接受一个（可变的）JavaScript集合，并渲染一个Immutable.js集合。 |'
- en: '| `asMutable` | This is a concession to "not-the-best" programming. The proper
    way to handle mutations based on an Immutable.js collection is to use with Mutations.
    Even if `asMutable` is available, it should only be used inside of functions and
    never be made available or returned. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `asMutable` | 这是对“不是最佳”编程的让步。基于Immutable.js集合处理变化的正确方法是使用Mutations。即使`asMutable`可用，也应该只在函数内部使用，永远不要公开或返回。
    |'
- en: '| `butLast` | This produces a similar new List, but it lacks the last entry.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `butLast` | 这会产生一个类似的新列表，但它缺少最后一个条目。 |'
- en: '| `concat` | Concatenate (that is, append) two iterables of the same type.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `concat` | 连接（即追加）两个相同类型的可迭代对象。 |'
- en: '| `contains` | This is true if the value exists in this List. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `contains` | 如果值存在于此列表中，则为真。 |'
- en: '| `count` | Return the size of this List. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 返回此列表的大小。 |'
- en: '| `countBy` | Group the List''s contents with a grouper function, and then
    emit counts for the keys as partitioned by the grouper. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `countBy` | 使用分组函数对列表的内容进行分组，然后按分组器分区发出键的计数。 |'
- en: '| `delete` | Create a new List without this key. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 创建一个没有此键的新列表。 |'
- en: '| `deleteIn` | Remove a key from a keypath, which allows traversal from an
    outer collection to an inner collection, much like the way a filesystem path allows
    traversal of the filesystem from an outer directory to an inner directory. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `deleteIn` | 从键路径中删除一个键，这允许从外部集合到内部集合的遍历，就像文件系统路径允许从外部目录到内部目录的遍历一样。 |'
- en: '| `entries` | An iteration of the List as `key`, `value tuples`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `entries` | 作为`key`，`value`元组的列表迭代。 |'
- en: '| `entrySeq` | Create a new `IndexedSeq` of key, value tuples. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `entrySeq` | 创建一个新的键值元组的`IndexedSeq`。 |'
- en: '| `equals` | This is a full equality comparison. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `equals` | 这是完全相等的比较。 |'
- en: '| `every` | This is true if a predicate is true for all entries in this List.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `every` | 如果断言对此列表中的所有条目都为真，则为真。 |'
- en: '| `filter` | Returns the elements of a List for which the provided predicate
    holds true. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 返回提供的断言为真的列表元素。 |'
- en: '| `filterNot` | Returns the elements of a List for which the provided predicate
    returns false. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `filterNot` | 返回提供的断言返回false的列表元素。 |'
- en: '| `find` | Returns the value for which the provided predicate holds true. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `find` | 返回满足提供的断言的值。 |'
- en: '| `findIndex` | Returns the first index for which the provided predicate holds
    true. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `findIndex` | 返回提供的断言第一次为真的索引。 |'
- en: '| `findLast` | Returns the last element for which the provided predicate holds
    true. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `findLast` | 返回最后一个满足提供的断言的元素。 |'
- en: '| `findLastIndex` | Returns the last index for which the provided predicate
    holds true. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `findLastIndex` | 返回提供的断言最后为真的索引。 |'
- en: '| `first` | The first value in the List. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `first` | 列表中的第一个值。 |'
- en: '| `flatMap` | This flat-maps, or collapses, a potential List of Lists into
    a List that is one deep. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `flatMap` | 这将潜在的列表列表展平成一个深度为一的列表。 |'
- en: '| `flatten` | This flattens nested iterables. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `flatten` | 这会展平嵌套的可迭代对象。 |'
- en: '| `forEach` | Executes a function for each entry in the list. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `forEach` | 对列表中的每个条目执行一个函数。 |'
- en: '| `fromEntrySeq` | Return a `KeyedSeq` of any iterable of the key, value tuples.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `fromEntrySeq` | 返回任何键值元组的可迭代对象的`KeyedSeq`。 |'
- en: '| `get` | Returns the value for a key. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `get` | 返回键的值。 |'
- en: '| `getIn` | Traverses a key path (like a filesystem path) to get a key, if
    available. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `getIn` | 遍历键路径（类似于文件系统路径）以获取键（如果可用）。 |'
- en: '| `groupBy` | Converts a List into a List of Lists keyed by the grouping of
    a provided grouper function. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `groupBy` | 将列表转换为由提供的分组函数分组的列表的列表。 |'
- en: '| `has` | This is true if a key exists in this List. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `has` | 如果键存在于此列表中，则为真。 |'
- en: '| `hashCode` | This calculates a hash code for this collection. It is appropriate
    for use in a hash table. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `hashCode` | 为此集合计算哈希码。适用于哈希表。 |'
- en: '| `hasIn` | This is true if a collection''s equivalent to a filesystem walk
    finds the value in question. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `hasIn` | 如果集合的等效于文件系统遍历找到了问题的值，则为真。 |'
- en: '| `indexOf` | The index of the first occurrence in this List, for example,
    `Array.prototype.indexOf`. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf` | 例如，`Array.prototype.indexOf`中的第一个出现的索引。 |'
- en: '| `interpose` | Interpose a separator between individual List entries. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `interpose` | 在单个列表条目之间插入分隔符。 |'
- en: '| `interleave` | Interleave the provided Lists into one list of the same type.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `interleave` | 将提供的列表交错成一个相同类型的列表。 |'
- en: '| `isEmpty` | This tells whether this iterable has values or not. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty` | 这告诉这个可迭代对象是否有值。 |'
- en: '| `isList` | This is true if the value is a List. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `isList` | 如果值是列表，则为真。 |'
- en: '| `isSubset` | True if every value in the comparison iterable is in this List.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `isSubset` | 如果比较可迭代对象中的每个值都在此列表中，则为真。 |'
- en: '| `isSuperset` | True if every value in this List is in the comparison iterable.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '- `isSuperset` | 如果此列表中的每个值都在比较可迭代对象中，则为 true。'
- en: '| `join` | This joins together as a string with a separator (default). |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '- `join` | 使用分隔符（默认）将条目连接成字符串。'
- en: '| `keys` | An iterator of this List''s keys. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '- `keys` | 此列表的键的迭代器。'
- en: '| `keySeq` | Returns a `KeySeq` for this iterable, discarding all values. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '- `keySeq` | 返回此可迭代对象的 `KeySeq`，丢弃所有值。'
- en: '| `last` | The last value in the List. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '- `last` | 列表中的最后一个值。'
- en: '| `lastIndexOf` | Returns the last index at which a value can be found in this
    List. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '- `lastIndexOf` | 返回此列表中可以找到值的最后索引。'
- en: '| `List` | The constructor for lists. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '- `List` | 列表的构造函数。'
- en: '| `map` | Returns a new List with values passed through a map function. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '- `map` | 通过映射函数返回一个新的列表。'
- en: '| `max` | Returns the maximum value in this collection. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '- `max` | 返回此集合中的最大值。'
- en: '| `maxBy` | This is like max, but with more fine-grained control. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '- `maxBy` | 这类似于 max，但具有更精细的控制。'
- en: '| `merge` | Merges iterables or JavaScript objects into one List. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '- `merge` | 将可迭代对象或 JavaScript 对象合并为一个列表。'
- en: '| `mergeDeep` | A recursive analog to merge. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '- `mergeDeep` | 合并的递归模拟。'
- en: '| `mergeDeepIn` | Performs a deep merge, starting at a given keypath. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '- `mergeDeepIn` | 从给定的键路径开始执行深度合并。'
- en: '| `mergeDeepWith` | This is like `mergeDeep`, but uses a provided merger function
    when nodes conflict. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '- `mergeDeepWith` | 这类似于 `mergeDeep`，但在节点冲突时使用提供的合并函数。'
- en: '| `mergeIn` | This is a combination of update and merge. It performs a merger
    at a specified keypath. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '- `mergeIn` | 这是更新和合并的组合。它在指定的键路径执行合并。'
- en: '| `mergeWith` | This is like merge, but uses a provided merger function when
    nodes conflict. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '- `mergeWith` | 这类似于 merge，但在节点冲突时使用提供的合并函数。'
- en: '| `min` | Returns the minimum value in the List. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '- `min` | 返回列表中的最小值。'
- en: '| `minBy` | Returns the minimum value in the List as determined by a helper
    function you provide. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '- `minBy` | 根据您提供的辅助函数确定列表中的最小值。'
- en: '| `of` | Creates a new list containing its arguments as values. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '- `of` | 创建一个包含其参数作为值的新列表。'
- en: '| `pop` | This returns everything in this List but the last. Note that this
    differs from the standard push semantics, but a regular `push()` can be simulated
    by calling `last()` before `push()`. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '- `pop` | 返回列表中除最后一个条目之外的所有内容。请注意，这与标准的推送语义不同，但可以通过在 `push()` 之前调用 `last()`
    来模拟常规的 `push()`。'
- en: '| `push` | Returns a new list with the specified value (or values) appended
    at the end. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '- `push` | 返回一个在末尾附加指定值（或值）的新列表。'
- en: '| `reduce` | Calls the reducing function for every value and returns the accumulated
    value. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '- `reduce` | 对每个值调用减少函数，并返回累积值。'
- en: '| `reduceRight` | This is similar to reduce, but starts at the right and moves
    progressively to the left, the opposite of the basic reduce. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '- `reduceRight` | 这类似于 reduce，但从右边开始，逐渐向左移动，与基本的 reduce 相反。'
- en: '| `rest` | Returns the tail of a List, that is, all entries but the first.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '- `rest` | 返回列表的尾部，即除第一个条目之外的所有条目。'
- en: '| `reverse` | Provides a List in reverse order. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '- `reverse` | 以相反的顺序提供列表。'
- en: '| `set` | Returns a new List with the value at the index. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '- `set` | 返回具有指定索引处的值的新列表。'
- en: '| `setIn` | Return a new List with this value at the keypath. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '- `setIn` | 在键路径处返回一个新的列表与此值。'
- en: '| `setSize` | Creates a new List with the size that you specify, truncating
    or adding undefined values as needed. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '- `setSize` | 创建一个具有您指定大小的新列表，根据需要截断或添加未定义的值。'
- en: '| `shift` | Creates a new list with the first value subtracted and all other
    values shifted down. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '- `shift` | 创建一个减去第一个值并将所有其他值向下移动的新列表。'
- en: '| `skip` | Returns all that is left of the List when the first *n* entries
    are not included. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '- `skip` | 当不包括前 *n* 个条目时，返回列表中剩余的所有条目。'
- en: '| `skipLast` | Returns all that is left of the List when the last n entries
    are not included. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '- `skipLast` | 当不包括最后 n 个条目时，返回列表中剩余的所有条目。'
- en: '| `skipUntil` | Returns a new iterable containing all entries after the first
    where a provided predicate is true. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '- `skipUntil` | 返回一个新的可迭代对象，其中包含第一个满足提供的谓词的条目之后的所有条目。'
- en: '| `skipWhile` | This returns a new iterable containing all entries before a
    provided predicate is false. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '- `skipWhile` | 返回一个新的可迭代对象，其中包含在提供的谓词为 false 之前的所有条目。'
- en: '| `slice` | Returns a new iterable containing this list''s contents from the
    start value to one before the last, inclusive. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '- `slice` | 返回一个新的可迭代对象，其中包含从起始值到倒数第二个值（包括）的列表内容。'
- en: '| `some` | True if a predicate returns true for any element of the List. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '- `some` | 如果谓词对列表的任何元素返回 true，则为 true。'
- en: '| `sort` | Returns a new List sorted by an optional comparator. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '- `sort` | 返回一个按可选比较器排序的新列表。'
- en: '| `sortBy` | Returns a new List sorted by an optional comparator value mapper,
    with more detailed information available for the comparator and therefore more
    refined results. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '- `sortBy` | 返回一个按可选比较器值映射器排序的新列表，比较器提供了更详细的信息，因此结果更精细。'
- en: '| `splice` | Replaces a segment of the first list with the second, or deletes
    it if no second list is provided. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '- `splice` | 用第二个列表替换第一个列表的一部分，如果没有提供第二个列表，则删除它。'
- en: '| `take` | Creates a new List containing exactly the first n entries in a List.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '- `take` | 创建一个包含列表中前 n 个条目的新列表。'
- en: '| `takeLast` | Creates a new List containing exactly the last *n* entries in
    a List. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '- `takeLast` | 创建一个包含列表中最后 *n* 个条目的新列表。'
- en: '| `takeUntil` | This returns a new List containing all entries as long as the
    predicate returns false; then it stops. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '- `takeUntil` | 返回一个新的列表，其中包含只要谓词返回 false 的所有条目；然后停止。'
- en: '| `takeWhile` | This returns a new List containing all entries as long as the
    predicate returns true; then it stops. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '- `takeWhile` | 只要谓词返回 true，就返回一个包含所有条目的新列表；然后停止。'
- en: '| `toArray` | Shallowly converts this List to an Array, discarding the keys.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '- `toArray` | 将此列表浅层转换为数组，丢弃键。'
- en: '| `toIndexedSeq` | Return an `IndexedSeq` of this List, discarding the keys.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '- `toIndexedSeq` | 返回此列表的 `IndexedSeq`，丢弃键。'
- en: '| `toJS` | Deeply converts this List into an Array. This method has `toJSON()`
    as an alias, although the documentation does not clearly state whether or not
    `toJS()` returns JavaScript objects, while `toJSON()` returns a JSON-encoded string.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `toJS` | 深度将此列表转换为数组。这个方法有`toJSON()`作为别名，尽管文档并没有清楚地说明`toJS()`是否返回JavaScript对象，而`toJSON()`返回一个JSON编码的字符串。
    |'
- en: '| `toKeyedSeq` | Returns a `KeyedSeq` from this List where indices are treated
    as keys. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `toKeyedSeq` | 从此列表返回一个`KeyedSeq`，其中索引被视为键。 |'
- en: '| `toList` | Returns itself. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `toList` | 返回自身。 |'
- en: '| `toMap` | Converts this List into a Map. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `toMap` | 将此列表转换为Map。 |'
- en: '| `toObject` | Shallowly converts this List into an Object. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `toObject` | 浅层将此列表转换为对象。 |'
- en: '| `toOrderedMap` | Convert this List into a Map, preserving the order of iteration.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `toOrderedMap` | 将此列表转换为Map，保留迭代顺序。 |'
- en: '| `toSeq` | Returns an `IndexedSeq`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `toSeq` | 返回一个`IndexedSeq`。 |'
- en: '| `toSet` | Converts this List to a Set, discarding the keys. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `toSet` | 将此列表转换为Set，丢弃键。 |'
- en: '| `toSetSeq` | Converts this List to a `SetSeq`, discarding the keys. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `toSetSeq` | 将此列表转换为`SetSeq`，丢弃键。 |'
- en: '| `toStack` | Convert this List to a Stack, discarding the keys. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `toStack` | 将此列表转换为Stack，丢弃键。 |'
- en: '| `unshift` | Prepend the provided values to a List. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `unshift` | 将提供的值添加到列表的开头。 |'
- en: '| `update` | Update an entry on a List by a provided updater function. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 通过提供的更新函数更新列表中的条目。 |'
- en: '| `updateIn` | Update an entry, as in update(), but at a given key path. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `updateIn` | 更新条目，就像`update()`一样，但在给定的键路径上。 |'
- en: '| `values` | An iterator of this List''s values. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 此列表值的迭代器。 |'
- en: '| `valueSeq` | An `IndexedSeq` of this List''s values. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `valueSeq` | 此列表值的`IndexedSeq`。 |'
- en: '| `withMutations` | This is an optimization (recall "Premature optimization
    is the root of all evil," said by Donald Knuth) hook meant to allow more performant
    work when multiple mutations are performed. It is to be used when there are known
    and persistent performance issues where other tools have demonstrably not solved
    the problem. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `withMutations` | 这是一个优化（回想一下，“过早的优化是万恶之源”，唐纳德·克努斯说过），旨在在执行多个变异时允许更高性能的工作。当已知和持久的性能问题存在，并且其他工具明显没有解决问题时，应该使用它。
    |'
- en: '| `zip` | Returns an iterable zipped (that is, joined pairwise to make a list
    of 2-tuples) with this List. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `zip` | 与此列表一起返回一个被压缩的可迭代对象（即成对连接以生成2元组列表）。 |'
- en: '| `zipWith` | Returns an iterable zipped with a custom zipping function. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `zipWith` | 返回与自定义压缩函数一起压缩的可迭代对象。 |'
- en: The documentation for the API, which is under the **Documentation** link available
    on the home page, is pretty clear. But as a rule, Immutable.js collections do
    what a functional programmer would expect them to do as much as possible, and
    indeed there appears to be a presumable overriding design consideration of "do
    what a functional programmer would want as much as we can."
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: API的文档位于主页上的**Documentation**链接下，非常清晰。但是作为一个规则，Immutable.js集合尽可能地做到了函数式程序员所期望的，实际上似乎有一个可以推测的主要设计考虑是“尽可能地做到函数式程序员所希望的”。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing that might be an unpleasant surprise to functional programmers is
    that the documentation does not explain how to create infinite lists. It is not
    obvious how one might create a generator for a list (if they do so at all), or
    produce lists of mathematical sequences, such as all counting all numbers, positive
    even numbers, squares, primes, Fibonacci numbers, powers of 2, factorials, and
    so on. Such functionality is apparently not supported (at the time of writing
    this book). Lazy sequences cannot build infinite lists with Immutable.js because
    constructing a collection includes an eager inclusion of all elements ever in
    the list, which must therefore be finite. It shouldn't be terribly difficult to
    create lazy, and potentially infinite, data structures in the style of Immutable.js
    that have a memoized generator inside and allow you to XYZ.take(5). But Immutable.js
    appears not to have expanded into that territory yet.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让函数式程序员感到不愉快的一件事是，文档没有解释如何创建无限列表。不明显如何创建列表的生成器（如果有的话），或者产生数学序列的列表，比如所有计数所有数字，正偶数，平方数，质数，斐波那契数，2的幂，阶乘等等。这样的功能显然不受支持（在撰写本书时）。由于构造集合包括列表中的所有元素的急切包含，因此不可能使用Immutable.js构建无限列表。在Immutable.js中创建惰性序列不能构建无限列表，因为构造集合包括列表中的所有元素的急切包含，因此必须是有限的。在Immutable.js的风格中创建惰性和潜在无限的数据结构应该不是非常困难，这样的数据结构内部有一个记忆生成器，并允许你XYZ.take(5)。但是Immutable.js似乎还没有扩展到这个领域。
- en: Jest – BDD unit testing from Facebook
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jest - 来自Facebook的BDD单元测试
- en: Jest is a JavaScript unit testing framework intended to support behavior-driven
    development. It is built on top of Jasmine, and in the future, it may be able
    to interact with other foundations. It has been used for a couple of years and
    is used on Facebook, though there appears to be no decisive endorsement that ReactJS
    development is best done using Jest. (Facebook uses JSX with ReactJS internally
    but tends to make a relatively unopinionated statement that about half of ReactJS
    users opt to use JSX. It is actually designed to be entirely optional.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个旨在支持行为驱动开发的JavaScript单元测试框架。它是建立在Jasmine之上的，并且在未来可能能够与其他基础互动。它已经被使用了几年，并且在Facebook上被使用，尽管似乎没有明确的认可，即ReactJS开发最好使用Jest。（Facebook在内部使用JSX与ReactJS，但倾向于发表一个相对不带偏见的声明，大约一半的ReactJS用户选择使用JSX。它实际上被设计为完全可选的。）
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'JSX—the *X* boldly meaning XML at a time when XML has fallen out of favor—is
    a well-made syntactic sugar that "puts angle brackets in your code." This loosely
    means that you can put HTML into your JavaScript in `.jsx` files and things just
    work. Also, you can use almost anything that you can build on a page that has
    been built into a ReactJS component. You can include things such as images that
    have been part of HTML from the beginning, and you can just as easily include
    a calendar as defined in this title, a threaded networked discussion, or a draggable
    and zoomable fractal. Like subroutines, once a component is defined, it can be
    used zero, one, or many times anywhere in your web app. The JSX syntactic sugar
    allows components that you and others have defined as easily as old HTML tags.
    The JSX for the outer shell in the project in chapters 8 to 11 is "dirt simple"
    in terms of allowing us to incorporate the other components that we have developed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JSX——*X*大胆地表示XML，这是在XML已经不受青睐的时候制作的一种良好的语法糖，它“在您的代码中放置尖括号”。这松散地意味着您可以在`.jsx`文件中将HTML放入JavaScript中，一切都可以正常工作。此外，您可以使用几乎任何可以构建在ReactJS组件中的页面上的东西。您可以包括一些从一开始就包含在HTML中的图像，也可以轻松地包括在本标题中定义的日历、线程化的网络讨论或可拖动和可缩放的分形。与子例程一样，一旦定义了组件，它就可以在Web应用程序的任何位置零次、一次或多次使用。JSX语法糖允许您像旧的HTML标签一样轻松地包含您和其他人定义的组件。在第8到11章的项目的外壳中，JSX“非常简单”，因为它允许我们合并我们开发的其他组件：
- en: '[PRE3]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One Facebook employee said that he had made Jest open source for "selfish reasons,"
    namely that he wanted to use it in his personal projects. This may give a good
    hint about why Jest is at least worth considering. It is nice enough for at least
    one user to really want to use Jest, so much so that he was willing to make proprietary
    intellectual property open source, and did this even when no one told him to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的一名员工表示，他出于“自私的原因”使Jest成为开源项目，即他想在自己的个人项目中使用它。这可能对为什么至少值得考虑Jest提供了一个很好的提示。至少有一个用户真的想要使用Jest，以至于他愿意将专有的知识产权开源，即使没有人告诉他这样做。
- en: It is arguable that in its beginnings, unit testing has served what is most
    easily unit tested, which means that unit testing has washed its hands of integration
    and user interface testing. So, you might see a blog article on unit testing that
    tests and confirms a "red, green, refactor" approach to a function that converts
    your language's integers to Roman numerals, which is a pretty good example of
    a problem that serves the needs of primitive unit testing. If you want to test
    whether your code is interacting with its database appropriately, that's a slightly
    taller order. And Jest, like other frameworks, doesn't really have which is pretensions
    of obviating the need for good, old-fashioned budget usability testing as Jakob
    Nielsen and others advocate. There is an old (pre-IT) business distinction between
    asking, "Are we building the product right?" and "Are we building the right product?"
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，在其开始阶段，单元测试已经为最容易进行单元测试的内容提供了服务，这意味着单元测试已经摆脱了集成和用户界面测试。因此，您可能会看到一篇关于单元测试的博客文章，测试并确认了将您语言的整数转换为罗马数字的函数的“红色、绿色、重构”方法，这是一个很好的例子，可以满足原始单元测试的需求。如果您想测试您的代码是否与数据库适当地交互，那就是一个稍微高一点的要求。而且，Jest等其他框架并没有真正具有消除对好的、老式的预算可用性测试的需求的虚假倾向，就像Jakob
    Nielsen和其他人所主张的那样。在（IT之前）业务上有一个区别，即询问“我们是否正在正确地构建产品？”和“我们是否正在构建正确的产品？”。
- en: Both of these questions are valuable and have their place, but unit testing
    helps more with the first than the second, and it is dangerous to let a good test
    suite that addresses the first question well lull you to sleep which is regarding
    addressing the second question well. Nonetheless, Jest offers something more useful
    than just testing whether a unit of code will successfully take input of a primitive
    data type, such as an integer, a float, or a string, and return the correct and
    expected output of a primitive data type (such as the right Roman numeral for
    an input integer). Though this is not true only for Jest, Jest simulates the user
    interface so as to support (for instance) user interface events, such as clicks
    on an element, and supports testing user interface changes, such as the text on
    a label (compare the Jasmine home page, where the first several examples involve
    assertions using primitive data types only).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都很有价值，都有其存在的理由，但是单元测试对第一个问题的帮助更大，而不是第二个问题，让一个很好地解决了第一个问题的测试套件让您对解决第二个问题的测试套件产生危险。尽管如此，Jest提供的东西比仅仅测试代码单元是否能成功接受原始数据类型（例如整数、浮点数或字符串）的输入，并返回原始数据类型的正确和预期输出（例如输入整数的正确罗马数字）更有用。尽管这不仅适用于Jest，但Jest模拟用户界面以支持（例如）用户界面事件，例如单击元素，并支持测试用户界面更改，例如标签上的文本（比较Jasmine主页，那里的前几个示例只涉及使用原始数据类型的断言）。
- en: Jest is intended to provide layers on top of Jasmine (and potentially other
    backends in the future), but with significant added value. Besides certain features,
    such as running tests in parallel so that testing becomes more responsive, Jest
    is a solution intended to require a minimum amount of time and fuss to get good
    test coverage, based on the thought that it is desirable for developers to spend
    most of their time on their main development and not on writing unit tests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Jest旨在在Jasmine（以及将来可能的其他后端）之上提供层，但具有显著的附加值。除了某些功能，例如并行运行测试，使测试变得更加响应，Jest是一种解决方案，旨在需要最少的时间和麻烦来获得良好的测试覆盖率，基于这样的想法，即开发人员应该花费大部分时间在主要开发上，而不是编写单元测试。
- en: 'Jest is intended to mock everything, or almost everything, pulled in with `require()`.
    You can opt out for individual elements by calling `jest.dontMock()`, and it is
    boilerplate practice that tests usually call `jest.dontMock()` for the components
    that they are testing. It automatically finds and runs tests in the `__tests__`
    directory. Jest can handle JSX if ReactJS''s preprocessor is included in, for
    example, `preprocessor.js`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Jest旨在模拟使用`require()`导入的所有内容，或几乎所有内容。您可以通过调用`jest.dontMock()`来选择不模拟单个元素，测试通常会调用`jest.dontMock()`来取消模拟它们正在测试的组件。它会自动查找并运行`__tests__`目录中的测试。如果在例如`preprocessor.js`中包含了ReactJS的预处理器，Jest可以处理JSX：
- en: '[PRE4]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `package.json` file needs to be told what to load:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件需要告诉它要加载什么：'
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we will lightly adapt Facebook's example. Facebook provides an example `CheckboxWithLabel`
    class. This class displays one label when the checkbox is unchecked and another
    when it is checked. The Jest unit test here simulates a click and confirms that
    the label changes appropriately.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将轻微地改编Facebook的示例。Facebook提供了一个`CheckboxWithLabel`类的示例。这个类在复选框未选中时显示一个标签，在选中时显示另一个标签。这里的Jest单元测试模拟了一次点击，并确认标签是否适当地更改。
- en: 'The `CheckboxWithLabel.js` file reads as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckboxWithLabel.js`文件的内容如下：'
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `__tests__/CheckboxWithLabel-test.js` test file reads:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`__tests__/CheckboxWithLabel-test.js`测试文件中写道：'
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing the Flux Architecture using Fluxxor
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fluxxor实现Flux架构
- en: As mentioned in earlier chapters, Flux is an architecture that was developed
    by Facebook and used by them as something largely complementary to ReactJS. It
    helped untangle a genuine rat's nest of crossed wires and let Facebook eradicate
    a recurrent message count bug that kept coming back—the Flux Architecture killed
    it permanently. **Fluxxor**, by Brandon Tilley ([http://fluxxor.com](http://fluxxor.com)),
    is a tool intended to help people implement the Flux Architecture in their applications.
    There is no need to use the Flux Architecture in order to use ReactJS, or use
    the Fluxxor tool to implement the Flux Architecture. But Flux, and perhaps Fluxxor,
    is at least worth considering to make things easier.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Flux是Facebook开发并被他们用作ReactJS的一个大部分补充的架构。它帮助解开了一个真正的交叉线的乱麻，并让Facebook彻底消除了一个反复出现的消息计数错误——Flux架构永久地杀死了它。**Fluxxor**，由Brandon
    Tilley ([http://fluxxor.com](http://fluxxor.com))，是一个旨在帮助人们在他们的应用程序中实现Flux架构的工具。没有必要使用Flux架构来使用ReactJS，或者使用Fluxxor工具来实现Flux架构。但是Flux，也许是Fluxxor，至少值得考虑，以使事情变得更容易。
- en: Fluxxor has classes for the Flux Architecture overall, including a `Fluxxor.Flux`
    container (which includes a dispatcher) and `Action` and `Store` classes. The
    sample code was concise and readable and seemed to have little boilerplate. Two
    ReactJS-friendly mixin classes are provided for ease of use. Sample code is written
    using JSX.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Fluxxor具有用于整体Flux架构的类，包括`Fluxxor.Flux`容器（其中包括一个分发器）和`Action`和`Store`类。示例代码简洁易读，看起来几乎没有样板。还提供了两个适用于ReactJS的mixin类以方便使用。示例代码使用JSX编写。
- en: I might also comment with reference to Fluxxor's author that [http://fluxxor.com](http://fluxxor.com)
    has a link at the bottom of the page asking people to report an issue on GitHub
    if something is unclear or if there is an issue. I noticed a common usability
    defect—visited and unvisited links being the same color—and reported the issue
    on GitHub. The author apologized immediately, and the issue I opened was *Closed
    fixed* within no more than 15 minutes. I think he is the kind of person one likes
    to work with.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可能评论Fluxxor的作者，[http://fluxxor.com](http://fluxxor.com)在页面底部有一个链接，要求人们在GitHub上报告问题，如果有什么不清楚或有问题。我注意到一个常见的可用性缺陷——访问和未访问的链接颜色相同——并在GitHub上报告了这个问题。作者立即道歉，我提出的问题在不到15分钟内就被*关闭并修复*了。我认为他是那种人们愿意一起工作的人。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now let's see what we covered in this chapter. We explained Om and ClojureScript,
    which allow Lisp-based development that takes advantage of ReactJS's abilities.
    It is said that ClojureScript may be the leading light of solutions that allow
    a beautiful patchwork of different languages that are usable for frontend development,
    compiling, or interpreting JavaScript as the new "bare metal."
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看本章涵盖了什么。我们解释了Om和ClojureScript，它们允许利用ReactJS的能力进行基于Lisp的开发。据说ClojureScript可能是允许美丽的不同语言拼接的解决方案的领头羊，这些语言可用于前端开发、编译或解释JavaScript作为新的“裸金属”。
- en: Bacon.js is a very respectable technology that competes with ReactJS that allows
    good functional reactive programming in the browser. This is presented, not as
    the "one and only" good example, but as an example of good stuff that is beyond
    the scope of this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js是一种非常受尊敬的技术，与ReactJS竞争，允许在浏览器中进行良好的函数式响应式编程。这不是作为“唯一”良好示例，而是作为超出本书范围的好东西的一个例子。
- en: We also covered Brython, a browser-based Python environment. It is not perfect
    but interesting. It is highlighted as an example of what can be used as a language
    outside of Lisp other than JavaScript for web development. As a reminder, [http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)
    offers a directory of other languages that compile to JavaScript or can be interpreted
    in a web browser, ranging from syntactic sugar such as CoffeeScript to JavaScript
    extensions to separate languages such as Ruby, Python (including Brython), Erlang,
    Perl, and so on and so forth.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Brython，一个基于浏览器的Python环境。它并不完美，但很有趣。它被作为一个可以在Lisp之外的语言中用作网页开发的例子。提醒一下，[http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)提供了一个目录，其中包括了编译为JavaScript或可以在Web浏览器中解释的其他语言，从语法糖如CoffeeScript到JavaScript扩展到独立语言如Ruby、Python（包括Brython）、Erlang、Perl等等。
- en: Immutable.js plugs a hole in functional JavaScript by providing mainly collections
    that allow copy-on-mutate without disrupting the functional advantages of immutable
    data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Immutable.js通过提供主要是允许在不破坏不可变数据的功能优势的情况下进行复制的集合，填补了函数式JavaScript中的漏洞。
- en: Jest is a behavior-driven development JavaScript unit testing framework that
    is used by Facebook for ReactJS. Fluxxor is an implementation of controllers,
    actions, and stores intended to make it easier to apply the Flux Architecture
    to JavaScript development, including ReactJS.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个由Facebook用于ReactJS的行为驱动开发JavaScript单元测试框架。Fluxxor是一个控制器、动作和存储的实现，旨在使将Flux架构应用到JavaScript开发中更容易，包括ReactJS。
- en: Join us in the next chapter as we explore a more in-depth example using ReactJS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们一起探索使用ReactJS的更深入的示例。
