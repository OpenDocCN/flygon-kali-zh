- en: MicroProfile OpenAPI and Type-Safe REST Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI和类型安全的REST客户端
- en: Eclipse MicroProfile has a rich set of specifications for Java microservices.
    Two of these, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client,
    help with the API documentation for your microservices and provide an API for
    type-safe invocation on REST endpoints, respectively. OpenAPI simplifies the documentation
    for microservice endpoints and makes this metadata available for perusal by third-party
    developers. A type-safe REST client simplifies the marshalling and unmarshalling
    of objects to HTTP or JSON.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile为Java微服务提供了丰富的规范集。其中两个，Eclipse MicroProfile OpenAPI和Eclipse
    MicroProfile REST Client，分别用于帮助您的微服务的API文档，并为REST端点的类型安全调用提供API。OpenAPI简化了微服务端点的文档，并使这些元数据可供第三方开发人员查看。类型安全的REST客户端简化了对象到HTTP或JSON的编组和解组。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The capabilities offered by each of these specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个规范提供的功能
- en: Simple code examples of some of these capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些这些功能的简单代码示例
- en: How to obtain further information about each of these specifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取有关每个规范的更多信息
- en: Introduction to MicroProfile OpenAPI and its capabilities
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI及其功能简介
- en: The mobile force that fuels the digital economy led to the need for businesses
    to establish an omni-channel approach to development in order to optimize costs,
    increase efficiencies, and improve customer experience. A facilitator of this
    approach was APIs, which led to the API economy and concepts such as API-led or
    API-first development practices. In addition, the microservices architecture has
    become the architecture of choice for modern development. API-based (that is,
    RESTful) communication among microservices has been adopted as the *de facto*
    standard because it is a good fit for the *smart endpoints and dumb pipes*, *decentralized
    governance*, and *decentralized data management* characteristics of microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 推动数字经济的移动力量导致企业需要建立全渠道开发方法，以优化成本，提高效率和改善客户体验。这种方法的促进者是API，它导致了API经济和概念，如API驱动或API优先开发实践。此外，微服务架构已成为现代开发的首选架构。基于API（即RESTful）的微服务之间的通信已被采用为*事实*标准，因为它非常适合微服务的*智能端点和愚蠢管道*，*分散式治理*和*分散式数据管理*特征。
- en: However, as the number of microservices increases in a microservices architecture,
    their management can become unwieldy. However, you can manage your microservices
    via their APIs. You can apply management, security, load balancing, and throttling
    policies to the APIs that are fronting your microservices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着微服务在微服务架构中的数量增加，它们的管理可能变得难以控制。但是，您可以通过它们的API来管理您的微服务。您可以将管理、安全、负载平衡和节流策略应用于为您的微服务提供前端的API。
- en: 'Eclipse MicroProfile OpenAPI provides Java interfaces to developers for generating
    OpenAPI v3 documents from their Java RESTful Web Services (JAX-RS) applications.
    The specification requires that a fully processed OpenAPI document be available
    at the root URL, `/openapi`, as an HTTP `GET` operation, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile OpenAPI为开发人员提供了Java接口，用于从其Java RESTful Web Services（JAX-RS）应用程序生成OpenAPI
    v3文档。规范要求完全处理的OpenAPI文档必须作为HTTP `GET`操作在根URL `/openapi` 上可用，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The required protocol is `http`. However, implementors of the specification
    are strongly encouraged to also support the `https` protocol for secure connectivity
    to the OpenAPI endpoint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的协议是`http`。但是，强烈建议规范的实现者也支持`https`协议，以便安全连接到OpenAPI端点。
- en: 'There are three sources from which the OpenAPI document is created. These three
    sources (described in later sections in this chapter) are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建OpenAPI文档的三个来源。这三个来源（在本章的后续部分中描述）如下：
- en: Generated by processing the JAX-RS annotations (and optional OpenAPI annotations)
    found in the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理应用中找到的JAX-RS注释（和可选的OpenAPI注释）生成
- en: Programmatically built by an application by providing a Java class that implements
    `OasModelReader`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供实现`OasModelReader`的Java类，应用程序以编程方式构建
- en: A static OpenAPI document included in application deployment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用部署中包含的静态OpenAPI文档
- en: These three sources (any combination) are combined to produce a single OpenAPI
    document, which can be filtered (by providing a Java class that implements the
    `OasFilter` interface) and then served at the preceding `/openapi` endpoint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个来源（任意组合）被合并为单个OpenAPI文档，可以通过提供实现`OasFilter`接口的Java类来进行过滤，然后在前述的`/openapi`端点提供服务。
- en: Configuration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: The MicroProfile OpenAPI specification makes use of the MicroProfile configuration
    specification to configure its parameters and values. For example, for injecting
    configuration values, MicroProfile OpenAPI can use the default and custom ConfigSources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI规范利用MicroProfile配置规范来配置其参数和值。例如，对于注入配置值，MicroProfile OpenAPI可以使用默认和自定义ConfigSources。
- en: For more information on ConfigSources, you can visit [https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ConfigSources的更多信息，您可以访问[https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc)。
- en: 'There are many configurable items. The following table contains a subset of
    them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可配置的项目。以下表格包含其中的一部分：
- en: '| **Configuration item** | **Description** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **配置项** | **描述** |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mp.openapi.scan.di sable` | Configuration property to disable annotation
    scanning. The default value is `false`. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `mp.openapi.scan.di sable` | 禁用注释扫描的配置属性。默认值为`false`。'
- en: '| `mp.openapi.servers` | Configuration property to specify the list of global
    servers that ... |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `mp.openapi.servers` | 指定全局服务器列表的配置属性...'
- en: Generating the OpenAPI document
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成OpenAPI文档
- en: As already described, the MicroProfile OpenAPI specification requires that an
    OpenAPI document be generated from a combination of three sources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MicroProfile OpenAPI规范要求从三个来源的组合生成OpenAPI文档。
- en: 'You then have a number of choices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您有多种选择：
- en: Extend the OpenAPI document generated by the JAX-RS annotations using the MicroProfile
    OpenAPI annotations.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile OpenAPI注释扩展由JAX-RS注释生成的OpenAPI文档。
- en: Leverage the initial output from `/openapi`, which you can use as a reference
    to start documenting your APIs. In this case, you can write static OpenAPI files
    (described in a later section in this chapter) before any code is written, which
    is a usual approach adopted by organizations to lock-in the contract of the API,
    that is, it is an API-first development practice.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`/openapi`的初始输出，您可以将其用作开始记录API的参考。在这种情况下，您可以在编写任何代码之前编写静态的OpenAPI文件（在本章的后面部分描述），这是组织机构采用的通常方法，用于锁定API的合同，即API优先开发实践。
- en: Bootstrap or complete the OpenAPI model tree by coding using the programming
    model, covered later in this chapter.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编程模型，通过编码来引导或完成OpenAPI模型树，本章后面将介绍。
- en: Additionally, you can use a filter to update the OpenAPI model after it has
    been built.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用过滤器在构建后更新OpenAPI模型。
- en: MicroProfile OpenAPI annotations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI注释
- en: Probably the most common source of OpenAPI information is the set of annotations
    that make up the definition of a standard JAX-RS application. These annotations,
    along with additional (optional) annotations defined by the MicroProfile OpenAPI
    specification, can be scanned and processed by the MicroProfile platform to produce
    an OpenAPI document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常见的OpenAPI信息来源是构成标准JAX-RS应用程序定义的一组注释。这些注释以及MicroProfile OpenAPI规范定义的附加（可选）注释可以被MicroProfile平台扫描和处理，以生成一个OpenAPI文档。
- en: The MP OpenAPI specification requires the generation of a valid OpenAPI document
    from pure JAX-RS 2.0 applications. If you are new to OpenAPI, you can simply deploy
    your existing JAX-RS application to a MicroProfile OpenAPI runtime and check out
    the output from `/openapi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MP OpenAPI规范要求从纯JAX-RS 2.0应用程序生成有效的OpenAPI文档。如果您对OpenAPI还不熟悉，您可以简单地将现有的JAX-RS应用程序部署到MicroProfile
    OpenAPI运行时，并检查`/openapi`的输出。
- en: To fill out additional details of the generated OpenAPI document, you may further
    annotate your ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要填写生成的OpenAPI文档的其他细节，您可以进一步注释您的...
- en: Usage examples
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法示例
- en: 'Some usage examples of MicroProfile OpenAPI annotations are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI注释的一些用法示例如下：
- en: 'Example 1 – Simple operation description (abbreviated):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-简单操作描述（缩写）：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output for example 1:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例1的输出：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Example 2 – Operation with different responses (abbreviated):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-具有不同响应的操作（缩写）：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output for example 2:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例2的输出：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more examples, please refer to the MicroProfile OpenAPI specification wiki
    at [https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多示例，请参阅MicroProfile OpenAPI规范维基[https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki)。
- en: Static OpenAPI files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态OpenAPI文件
- en: As mentioned earlier in the chapter, static OpenAPI files are one of the three
    sources from which the OpenAPI document can be created. In the following, we give
    you a short introductory description of how you could generate one and how to
    include it in your deployment. Many organizations use an API-first development
    practice, which entails defining static OpenAPI files even before any code is
    implemented for them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，静态OpenAPI文件是可以创建OpenAPI文档的三个来源之一。在接下来，我们将简要介绍如何生成静态OpenAPI文件以及如何将其包含在部署中。许多组织使用API优先开发实践，这意味着甚至在为其实现任何代码之前，就定义了静态OpenAPI文件。
- en: 'First, you can create an OpenAPI document by using an open source editor such
    as Swagger Editor ([https://editor.swagger.io](https://editor.swagger.io)). The
    following is a screenshot shows this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以使用Swagger Editor（[https://editor.swagger.io](https://editor.swagger.io)）等开源编辑器创建一个OpenAPI文档。以下是一个截图显示了这一点：
- en: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
- en: Using this editor, you can start with sample ...
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此编辑器，您可以从样本开始...
- en: Programming model
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程模型
- en: You can provide OpenAPI elements via Java POJOs (Plain Old Java Objects) by
    using the MicroProfile OpenAPI programming model. The complete set of models is
    described in the `org.eclipse.microprofile.openapi.models` package. You can read
    more about it at [https:](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)[//github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用MicroProfile OpenAPI编程模型，通过Java POJOs（Plain Old Java Objects）提供OpenAPI元素。完整的模型集在`org.eclipse.microprofile.openapi.models`包中描述。您可以在[https:](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)[//github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)上阅读更多信息。
- en: 'You can create an OpenAPI tree by using `OASFactory`. Refer to the following
    code block by way of an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`OASFactory`创建一个OpenAPI树。以下是一个示例代码块：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To bootstrap the OpenAPI model tree, you can use the `OASModelReader` interface.
    You can then create an implementation of this interface and register it using
    the `mp.openapi.model.reader` configuration key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要引导OpenAPI模型树，您可以使用`OASModelReader`接口。然后，您可以创建此接口的实现并使用`mp.openapi.model.reader`配置键进行注册。
- en: 'The following is globally an example of what its definition would look like
    in `META-INF/microprofile-config.properties`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全局示例，显示了在`META-INF/microprofile-config.properties`中的定义：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like static files, the model reader can be used to provide either complete or
    partial model trees. To provide a complete OpenAPI model tree, you should set
    the `mp.openapi.scan.disable` configuration to `true`. Otherwise, this partial
    model will be assumed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态文件一样，模型读取器可用于提供完整或部分模型树。要提供完整的 OpenAPI 模型树，您应该将 `mp.openapi.scan.disable`
    配置设置为 `true`。否则，将假定为部分模型。
- en: Using a filter for updates
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器进行更新
- en: To update or remove certain elements and fields of the OpenAPI document, you
    can use a filter. The OASFilter ([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))
    interface allows you to receive callbacks for various OpenAPI elements. It allows
    you to override the methods you care about. You can create an implementation of
    this interface and register it using the `mp.openapi.filter` configuration key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新或删除 OpenAPI 文档的某些元素和字段，可以使用过滤器。OASFilter ([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))
    接口允许您接收各种 OpenAPI 元素的回调。它允许您重写您关心的方法。您可以创建此接口的实现并使用 `mp.openapi.filter` 配置键进行注册。
- en: 'Here''s an example of what its definition would look like in `META-INF/microprofile-config.properties`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `META-INF/microprofile-config.properties` 中定义的示例：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A registered filter is called once for each model element. For example, the
    `filterPathItem` method is ...
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的过滤器对每个模型元素调用一次。例如，`filterPathItem` 方法是...
- en: Introduction to the MicroProfile REST Client and its capabilities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile REST Client 及其功能简介
- en: The **MicroProfile REST Client** (**MP-RC**) provides an API for type-safe invocation
    on REST endpoints. It can be used from applications to perform remote invocations
    on other services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile REST Client** (**MP-RC**) 提供了一个用于对 REST 端点进行类型安全调用的 API。它可以从应用程序中用于对其他服务进行远程调用。'
- en: It leverages JAX-RS annotations on Java interfaces to describe the actual contract
    with remotes services. These interfaces are then used to create client proxies
    that hide much of the underlying HTTP communication.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它利用 Java 接口上的 JAX-RS 注解来描述与远程服务的实际契约。然后使用这些接口创建客户端代理，隐藏了大部分底层的 HTTP 通信。
- en: The MP-RC specification defines the requirements for leveraging the JAX-RS annotations
    on the Java interface, as well as MP-RC-specific annotations to augment behavior,
    including how incoming request headers should be propagated, how to augment JAX-RS
    behaviors using providers, exception mapping, CDI support, and integration with
    other MicroProfile specifications. We will look at MP-RC in more detail by starting
    with the definition of a type-safe endpoint interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC 规范定义了在 Java 接口上利用 JAX-RS 注解以及 MP-RC 特定注解来增强行为的要求，包括如何传播传入请求头，如何使用提供者增强
    JAX-RS 行为，异常映射，CDI 支持以及与其他 MicroProfile 规范的集成。我们将通过定义类型安全的端点接口来更详细地了解 MP-RC。
- en: Defining the endpoint Interface
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义端点接口
- en: 'To define the type-safe interface for an endpoint, we create a Java interface
    that leverages JAX-RS annotations to map interface methods to the REST endpoint
    they proxy. A basic example is illustrated in the following `WorldClockApi` interface:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义端点的类型安全接口，我们创建一个 Java 接口，利用 JAX-RS 注解将接口方法映射到它们代理的 REST 端点。一个基本的示例如下所示的
    `WorldClockApi` 接口：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: MicroProfile REST Client programmatic API usage
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile REST Client 编程 API 使用
- en: 'MP-RC supports both programmatic lookup and CDI injection approaches for usage.
    An example of a REST service making use of `org.eclipse.microprofile.rest.client.RestClientBuilder`
    to create a type-safe client for the `WorldClockApi` interface is listed in the
    following as `WorldClockUser.java`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC 支持编程查找和 CDI 注入两种用法。下面是一个使用 `org.eclipse.microprofile.rest.client.RestClientBuilder`
    创建 `WorldClockApi` 接口的类型安全客户端的 REST 服务的示例，名为 `WorldClockUser.java`：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `baseUri()` method is used to specify the server URI against which the
    `WorldClockApi` method paths are to be resolved. The `build()` method takes the
    Java interface of the type-safe client that is to be built. Additional `RestClientBuilder`
    methods include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseUri()` 方法用于指定服务器 URI，该 URI 用于解析 `WorldClockApi` 方法路径。`build()` 方法接受要构建的类型安全客户端的
    Java 接口。其他 `RestClientBuilder` 方法包括以下内容：'
- en: '`baseUrl(URL)`: Similar to `baseUri`, but takes a `java.net.URL` type.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseUrl(URL)`: 类似于 `baseUri`，但接受 `java.net.URL` 类型。'
- en: '`connectTimeout(long timeout, TimeUnit unit)`: The amount of time to wait to
    connect to the remote server. A value of 0 indicates having to wait forever.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectTimeout(long timeout, TimeUnit unit)`: 等待连接到远程服务器的时间。值为 0 表示永远等待。'
- en: '`readTimeout(long timeout, TimeUnit unit)`: The amount of time to wait on reads
    of the remote server connection. A value of 0 indicates having to wait forever.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readTimeout(long timeout, TimeUnit unit)`: 等待远程服务器连接读取的时间。值为 0 表示永远等待。'
- en: '`executorService(ExecutorService executor)`: Used for async requests. We will
    return to this in the async section.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executorService(ExecutorService executor)`: 用于异步请求。我们将在异步部分回到这里。'
- en: MicroProfile REST Client CDI usage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile REST Client CDI 使用
- en: 'MP-RC type-safe interfaces may be injected as CDI beans. The runtime must create
    a CDI bean for each interface annotated with `@RegisterRestClient`. A CDI client
    injects bean created will include a qualifier, `@RestClient` , to differentiate
    use as an MP-RC injection point. The following update to our `WorldClockApi` interface
    illustrates the use of the `@RegisterRestClient` annotation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC 类型安全接口可以作为 CDI bean 进行注入。运行时必须为每个带有 `@RegisterRestClient` 注解的接口创建一个 CDI
    bean。CDI 客户端注入的 bean 将包括一个限定符 `@RestClient`，以区分用作 MP-RC 注入点的用法。下面对我们的 `WorldClockApi`
    接口的更新说明了 `@RegisterRestClient` 注解的用法：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: MicroProfile Config integration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Config 集成
- en: 'For CDI-defined interfaces, it is possible to use MicroProfile Config properties
    to define additional behaviors that are available via the `RestClientBuilder`
    API. Given our `io.pckt.restc.contract.WorldClockApi` interface, the following
    MicroProfile Config properties are available to control the generated proxy behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CDI定义的接口，可以使用MicroProfile Config属性来定义可通过`RestClientBuilder` API控制的附加行为。给定我们的`io.pckt.restc.contract.WorldClockApi`接口，以下MicroProfile
    Config属性可用于控制生成的代理行为：
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`: The base URL to use for
    this service, the equivalent of the `RestClientBuilder#baseUrl` method.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`: 用于此服务的基本URL，相当于`RestClientBuilder#baseUrl`方法。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`: The fully qualified class
    name to a CDI scope to use for injection; it defaults to `javax.enterprise.context.Dependent`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`: 用于注入的CDI范围的完全限定类名；默认为`javax.enterprise.context.Dependent`。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`: A comma-separated
    list of fully qualified provider class names to include in the client, the equivalent
    of the `RestClientBuilder#register` method or the `@RegisterProvider` annotation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`: 要包含在客户端中的逗号分隔的完全限定提供程序类名列表，相当于`RestClientBuilder#register`方法或`@RegisterProvider`注解。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`:
    This will override the priority of the `com.mycompany.MyProvider` provider for
    this interface.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`:
    这将覆盖`com.mycompany.MyProvider`提供程序的优先级，用于此接口。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`: The timeout
    specified in milliseconds to wait to connect to the remote endpoint.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`: 指定的超时时间（以毫秒为单位），等待连接到远程端点。'
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`: The timeout specified
    in milliseconds to wait for a response from the remote endpoint.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`: 指定的超时时间（以毫秒为单位），等待远程端点的响应。'
- en: Simplifying configuration keys
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化配置键
- en: 'Since the default MP Config property names for a CDI interface can be quite
    long due to the inclusion of the interface package name, the MP-RC specification
    supports a way to simplify the property name prefix using the `configKey` attribute
    of the `@RegisterRestClient` annotation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CDI接口的默认MP Config属性名称可能会因包含接口包名称而变得很长，MP-RC规范支持一种使用`@RegisterRestClient`注解的`configKey`属性来简化属性名称前缀的方法：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the `worldClock` configKey, the previous list of property names simplifies
    to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`worldClock` configKey，前面的属性名称列表简化为以下内容：
- en: '`worldClock/mp-rest/url`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/url`'
- en: '`worldClock/mp-rest/uri`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/uri`'
- en: '`worldClock/mp-rest/scope`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/scope`'
- en: '`worldClock/mp-rest/providers`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/providers`'
- en: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
- en: Dealing with client headers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理客户端标头
- en: Let's say you want to specify credentials in the HTTP authorization header to
    a secure remote service, but you do not want to have a string `authHeader` parameter
    in the client interface method. The MP-RC `@ClientHeaderParam` annotation can
    be used to specify HTTP headers that should be sent without altering the client
    interface method signature.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要在HTTP授权标头中指定凭据以连接到安全的远程服务，但不想在客户端接口方法中有一个字符串`authHeader`参数。MP-RC `@ClientHeaderParam`注解可用于指定应发送的HTTP标头，而无需更改客户端接口方法签名。
- en: 'The following example illustrates two uses of the `@ClientHeaderParam` annotation
    to provide a `User-Agent` HTTP header in a variation of the `WorldClockApi` interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了`@ClientHeaderParam`注解的两种用法，以在`WorldClockApi`接口的变体中提供`User-Agent` HTTP标头：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also possible to add or propagate headers in bulk using a `ClientHeadersFactory`
    implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`ClientHeadersFactory`实现批量添加或传播标头：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, the `incomingHeaders` and `clientOutgoingHeaders`
    parameters are used as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`incomingHeaders`和`clientOutgoingHeaders`参数的用法如下：
- en: '`incomingHeaders`: Represents the map of headers for the inbound request'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incomingHeaders`: 表示入站请求的标头映射'
- en: '`clientOutgoingHeaders`: Represents the read-only map of header values specified
    on the client interface, the union of header values from `@ClientHeaderParam`,
    `@HeaderParam`, and so on'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientOutgoingHeaders`: 表示客户端接口上指定的只读标头值映射，来自`@ClientHeaderParam`、`@HeaderParam`等的标头值的并集'
- en: The `update` method should return a `MultivaluedMap` that contains the headers
    to merge with the `clientOutgoingHeaders` map for the complete map of headers
    to be sent to the outbound request. Providers such as filters, interceptors, and
    message body writers could still modify the final map of headers prior to sending
    the HTTP request.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法应返回一个`MultivaluedMap`，其中包含要与`clientOutgoingHeaders`映射合并的标头，以便发送到出站请求的完整标头映射。诸如过滤器、拦截器和消息体写入器之类的提供程序仍然可以在发送HTTP请求之前修改最终的标头映射。'
- en: To enable a `ClientHeadersFactory`, the client interface must be annotated with
    the `@RegisterClientHeaders` annotation. If this annotation specifies a value,
    the client implementation must invoke an instance of the specified `ClientHeadersFactory`
    implementation class. If no value is specified, then the client implementation
    must invoke `DefaultClientHeadersFactoryImpl`. This default factory will propagate
    specified headers from the inbound JAX-RS request to the outbound request – these
    headers are specified with a comma-separated list using the MicroProfile Config
    property, `org.eclipse.microprofile.rest.client.propagateHeaders`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`ClientHeadersFactory`，必须使用`@RegisterClientHeaders`注解对客户端接口进行注释。如果此注解指定了一个值，则客户端实现必须调用指定的`ClientHeadersFactory`实现类的实例。如果未指定值，则客户端实现必须调用`DefaultClientHeadersFactoryImpl`。此默认工厂将从入站JAX-RS请求传播指定的标头到出站请求
    - 这些标头使用MicroProfile Config属性`org.eclipse.microprofile.rest.client.propagateHeaders`的逗号分隔列表指定。
- en: Provider registration for advanced usage
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级用法的提供程序注册
- en: The `RestClientBuilder` interface extends the `Configurable` interface from
    JAX-RS, allowing a user to register custom providers while it is being built.
    The behavior of the providers supported is defined by the JAX-RS Client API specification.
    An MP-RC implementation will support `ClientResponseFilter`, `ClientRequestFilter`,
    `MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ReaderInterceptor`,
    and `WriterInterceptor` from JAX-RS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestClientBuilder`接口扩展了JAX-RS的`Configurable`接口，允许用户在构建过程中注册自定义提供者。支持的提供者的行为由JAX-RS客户端API规范定义。MP-RC实现将支持来自JAX-RS的`ClientResponseFilter`、`ClientRequestFilter`、`MessageBodyReader`、`MessageBodyWriter`、`ParamConverter`、`ReaderInterceptor`和`WriterInterceptor`。'
- en: For the `ClientResponseFilter` and `ClientRequestFilter` interfaces that have
    a `ClientRequestContext` parameter in their `filter` method, MP-RC implementations
    add an `org.eclipse.microprofile.rest.client.invokedMethod` property, the value
    of which is the `java.lang.reflect.Method` object ...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ClientResponseFilter`和`ClientRequestFilter`接口的`filter`方法中带有`ClientRequestContext`参数的实现，MP-RC实现将添加一个`org.eclipse.microprofile.rest.client.invokedMethod`属性，其值为`java.lang.reflect.Method`对象...
- en: Provider priority
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者优先级
- en: Providers may be registered via both annotations and `RestClientBuilder`. Providers
    registered via a builder will take precedence over the `@RegisterProvider` annotation.
    The `@RegisterProvider` annotation priority value takes precedence over any `@javax.annotation.Priority`
    annotation on the class. Provider priorities can be overridden when using the
    register methods on the `RestClientBuilder` interface as it allows for priority.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者可以通过注解和`RestClientBuilder`进行注册。通过构建器注册的提供者将优先于`@RegisterProvider`注解。`@RegisterProvider`注解的优先级值优先于类上的任何`@javax.annotation.Priority`注解。在使用`RestClientBuilder`接口上的注册方法时，可以覆盖提供者的优先级，因为它允许设置优先级。
- en: Feature registration
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性注册
- en: If the type of provider registered is a JAX-RS `Feature`, then the priority
    set by that `Feature` will be part of the builder as well. Implementations maintain
    the overall priority of registered providers, regardless of how they are registered.
    `Feature` will be used to register additional providers at runtime, and may be
    registered via `@RegisterProvider`, configuration, or via `RestClientBuilder`.
    `Feature` will be executed immediately. As a result, its priority is not taken
    into account (features are always executed).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册的提供者类型是JAX-RS的`Feature`，那么由该`Feature`设置的优先级也将成为构建器的一部分。实现会维护已注册提供者的整体优先级，无论它们是如何注册的。`Feature`将用于在运行时注册额外的提供者，并可以通过`@RegisterProvider`、配置或通过`RestClientBuilder`进行注册。`Feature`将立即执行。因此，它的优先级不会被考虑（特性总是被执行）。
- en: Default providers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认提供者
- en: 'MP-RC implementations must provide a minimum set of providers, including the
    following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC实现必须提供一组最小的提供者，包括以下内容：
- en: '`*/json` types:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*/json`类型：'
- en: JSON-P, `javax.json.JsonValue`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-P、`javax.json.JsonValue`
- en: JSON-B, `javax.json.bind`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-B、`javax.json.bind`
- en: '`*` types:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`类型：'
- en: '`byte[]`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`'
- en: '`java.lang.String`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String`'
- en: '`java.io.InputStream`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.InputStream`'
- en: '`java.io.Reader`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.Reader`'
- en: '`text/plain` types:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/plain`类型：'
- en: '`java.lang.Number and subtypes`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Number`和子类型'
- en: '`int, long, float and double`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数、长整数、浮点数和双精度浮点数
- en: '`java.lang.Character and char`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character`和`char`'
- en: '`java.lang.Boolean and boolean`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Boolean`和`boolean`'
- en: Exception mapping
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常映射
- en: 'MP-RC provides support for mapping an invocation response into an exception
    via the `org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper` interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC支持通过`org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper`接口将调用响应映射为异常：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Consider the following ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容...
- en: Default exception mapping
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认异常映射
- en: 'Each implementation provides a default `ResponseExceptionMapper` implementation
    that will map and invoke a response to `javax.ws.rs.WebApplicationException` when
    the response status code is >= 400\. It has a priority of `Integer.MAX_VALUE`,
    and is meant to be used as a fallback whenever an error is encountered. This mapper
    will be registered by default to all client interfaces, but this can be disabled
    by setting an MP Config property, `microprofile.rest.client.disable.default.mapper`,
    to `true`. It can also be disabled on a per-client basis by using the same property
    when building the client:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现都提供了一个默认的`ResponseExceptionMapper`实现，当响应状态码大于等于400时，将映射并调用响应为`javax.ws.rs.WebApplicationException`。它的优先级为`Integer.MAX_VALUE`，意味着在遇到错误时将作为后备使用。此映射器将默认注册到所有客户端接口，但可以通过将MP配置属性`microprofile.rest.client.disable.default.mapper`设置为`true`来禁用。也可以在构建客户端时使用相同的属性在每个客户端上禁用它：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Async support
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步支持
- en: 'MP-RC supports asynchronous method invocations. A client interface method is
    asynchronous when the return type of the method is of the `java.util.concurrent.CompletionStage<?>`
    type. An alternative version, called `WorldClockApiAsync.java`, of the `WorldClockApi`
    interface that declares an asynchronous method is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RC支持异步方法调用。当客户端接口方法的返回类型为`java.util.concurrent.CompletionStage<?>`类型时，该方法是异步的。声明异步方法的`WorldClockApi`接口的另一个版本`WorldClockApiAsync.java`如下：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about two Eclipse MicroProfile specifications,
    namely, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client. The
    former provides a specification for generating OpenAPI-compliant documentation
    for your microservices, and the latter supplies a specification for calling REST
    endpoints in a type-safe manner. In this chapter, we covered the specific capabilities
    of these specifications, provided some example code, and supplied pointers on
    how to get further information about these specifications. You have learned the
    features and capabilities of the Eclipse MicroProfile OpenAPI and Eclipse MicroProfile
    REST Client specifications, how to use their annotations and programmatic interfaces,
    and how you could incorporate them into your applications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了两个Eclipse MicroProfile规范，即Eclipse MicroProfile OpenAPI和Eclipse MicroProfile
    REST Client。前者提供了一个规范，用于为您的微服务生成符合OpenAPI的文档，后者以类型安全的方式提供了调用REST端点的规范。在本章中，我们介绍了这些规范的具体功能，提供了一些示例代码，并提供了关于如何获取有关这些规范的更多信息的指针。您已经了解了Eclipse
    MicroProfile OpenAPI和Eclipse MicroProfile REST Client规范的功能和能力，以及如何使用它们的注释和编程接口，以及如何将它们整合到您的应用程序中。
- en: In the next chapter, we will discuss and delve into the open source implementations
    of Eclipse MicroProfile that currently exist on the market.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并深入研究目前市场上存在的Eclipse MicroProfile的开源实现。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do you need to do anything to get information supplied to the `/openapi` endpoint?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做些什么才能获得提供给`/openapi`端点的信息？
- en: Can I enhance OpenAPI output with just one or two extra annotations?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以用一两个额外的注释增强OpenAPI输出吗？
- en: What is the point of using static OpenAPI files?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态OpenAPI文件有什么意义？
- en: Do I need the REST endpoint microservice I want to use to provide the MP-REST
    interface?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我需要REST端点微服务来提供MP-REST接口吗？
- en: How do you externalize the base URL for a type-safe interface?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将基本URL外部化为类型安全接口？
- en: What if I need to propagate incoming request headers?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我需要传播传入的请求头怎么办？
