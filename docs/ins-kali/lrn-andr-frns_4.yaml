- en: Chapter 4. Extracting Data Logically from Android Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。从安卓设备逻辑提取数据
- en: This chapter will be covering logical data extraction by using free and open
    source tools wherever possible. The majority of the material covered in this chapter
    will use the ADB methods previously discussed in [Chapter 2](part0019.xhtml "Chapter 2. Setting
    Up an Android Forensic Environment"), *Setting Up an Android Forensic Environment*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将尽可能使用免费和开源工具来覆盖逻辑数据提取。本章大部分内容将使用之前在[第2章](part0019.xhtml "第2章。设置安卓取证环境")中讨论过的ADB方法。
- en: 'By the end of this chapter, the reader should be familiar with the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，读者应该熟悉以下内容：
- en: What logical extraction means
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑提取的含义
- en: What data to expect from logical extractions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑提取可以期望得到的数据
- en: What data is available with and without root
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有和没有Root权限时可用的数据
- en: Manual ADB data extractions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动ADB数据提取
- en: ADB Backup extractions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADB备份提取
- en: ADB dumpsys information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADB dumpsys信息
- en: How to bypass Android lock screens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绕过安卓锁屏
- en: SIM card extractions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIM卡提取
- en: Logical extraction overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑提取概述
- en: In digital forensics, the term logical extraction is typically used to refer
    to extractions that do not recover deleted data, or do not include a full bit-by-bit
    copy of the evidence. However, a more correct definition of logical extraction,
    also defined in [Chapter 1](part0014.xhtml "Chapter 1. Introducing Android Forensics"),
    *Introducing Android Forensics*, is any method that requires communication with
    the base operating system. Because of this interaction with the operating system,
    a forensic examiner cannot be sure that they have recovered all of the data possible;
    the operating system is choosing which data it allows the examiner to access.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字取证中，逻辑提取一词通常用于指不恢复已删除数据的提取，或者不包括证据的完整比特对比拷贝。然而，在[第1章](part0014.xhtml "第1章。介绍安卓取证")中定义的更正确的逻辑提取的定义是任何需要与基本操作系统通信的方法。由于与操作系统的交互，取证员无法确定他们已经恢复了所有可能的数据；操作系统正在选择允许取证员访问哪些数据。
- en: In traditional computer forensics, logical extraction is analogous to copying
    and pasting a folder in order to extract data from a system; this process will
    only copy files that the user can access and see. If any hidden or deleted files
    are present in the folder being copied, they will not be in the pasted version
    of the folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统计算机取证中，逻辑提取类似于复制和粘贴文件夹以从系统中提取数据；这个过程只会复制用户可以访问和看到的文件。如果被复制的文件夹中存在任何隐藏或已删除的文件，它们将不会出现在粘贴版本的文件夹中。
- en: As you will see, however, the line between logical and physical extractions
    in mobile forensics is somewhat blurrier than in traditional computer forensics.
    For example, deleted data can routinely be recovered from logical extractions
    on mobile devices, due to the prevalence of SQLite databases being used to store
    data. Furthermore, almost every mobile extraction will require some form of interaction
    with the Android operating system; there is no simple equivalent to pulling a
    hard drive and imaging it without booting the drive. For our purposes, we will
    define a logical extraction as the process that obtains data visible to the user,
    and may include data that has been marked for deletion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，移动取证中逻辑提取和物理提取之间的界限要比传统计算机取证模糊得多。例如，由于SQLite数据库的普遍使用，可以经常从移动设备的逻辑提取中恢复已删除的数据。此外，几乎每次移动设备的提取都需要与安卓操作系统进行某种形式的交互；没有简单的等同于拔出硬盘并在不启动硬盘的情况下对其进行成像的操作。对于我们的目的，我们将逻辑提取定义为获取用户可见的数据的过程，并且可能包括已标记为删除的数据。
- en: What data can be recovered logically?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些数据可以逻辑恢复？
- en: 'For the most part, any and all user data may be recovered logically:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，任何和所有用户数据都可以通过逻辑方式恢复：
- en: Contacts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: Call logs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通话记录
- en: SMS/MMS
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信/彩信
- en: Application data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序数据
- en: System logs and information
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统日志和信息
- en: The bulk of this data is stored in SQLite databases, so it is even possible
    to recover large amounts of deleted data through a logical extraction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据的大部分存储在SQLite数据库中，因此甚至可以通过逻辑提取恢复大量已删除的数据。
- en: Root access
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Root权限
- en: When forensically analyzing an Android device, the limiting factor is often
    not the type of data being sought, but rather whether or not the examiner has
    the ability to access the data. Root access has been covered extensively in [Chapter
    2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic Environment"), *Setting
    Up an Android Forensic Environment*, but it is important enough to warrant repetition.
    All of the data listed above, when stored on the internal flash memory, is protected
    and requires root access to read. The exception to this is application data that
    is stored on the SD card, which will be discussed later in this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在法庭上分析安卓设备时，限制因素通常不是所寻找的数据类型，而是检查员是否有能力访问数据。在[第2章](part0019.xhtml "第2章。设置安卓取证环境")中已经广泛涵盖了Root访问权限，但这一点很重要，值得重复。上述所有存储在内部闪存存储器上的数据都是受保护的，需要Root访问权限才能读取。例外情况是存储在SD卡上的应用程序数据，这将在本书后面讨论。
- en: Without root access, a forensic examiner cannot simply copy information from
    the data partition. The examiner will have to find some method of escalating their
    privileges in order to gain access to the contacts, call logs, SMS/MMS, and application
    data. These methods often carry many risks, such as the potential to destroy or
    "brick" the device (making it unable to boot), and may alter data on the device
    in order to gain permanence. The methods commonly vary from device to device,
    and there is no universal, one-click method to gain root access to every device.
    Commercial mobile forensic tools such as **MicroSystemation XRY** and **Cellebrite
    UFED** have built-in capabilities to temporarily and safely root many devices,
    but do not cover the wide range of all Android devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 没有root权限，法医检查员无法简单地从数据分区复制信息。检查员将不得不找到某种方法来提升他们的权限，以便访问联系人、通话记录、短信/彩信和应用程序数据。这些方法通常带有许多风险，例如可能破坏或“砖化”设备（使其无法启动），并且可能会改变设备上的数据以获得永久性。这些方法通常因设备而异，并且没有通用的、一键式的方法可以获得对每个设备的root权限。商业移动法医工具，如**MicroSystemation
    XRY**和**Cellebrite UFED**，具有内置功能，可以临时和安全地root许多设备，但不涵盖所有Android设备的广泛范围。
- en: Throughout this chapter, we will make note of situations where root is required
    for each technique demonstrated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将注意到每种技术所需的root权限。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The decision to root a device should be made in accordance with your local operating
    procedures and court opinions in your jurisdiction. The legal acceptance of evidence
    obtained by rooting varies by jurisdiction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 是否对设备进行root处理应根据您所在地区的操作程序和法院意见做出决定。通过root获取的证据的法律接受程度因司法管辖区而异。
- en: Manual ADB data extraction
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动ADB数据提取
- en: The ADB `pull` command can be used to pull single files or entire directories
    directly from the device on to the forensic examiner's computer. This method is
    especially useful for small, targeted examinations. For example, in an investigation
    strictly involving SMS messages, the examiner can choose to pull just the relevant
    files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ADB的`pull`命令可用于直接从设备上将单个文件或整个目录拉到法医检查员的计算机上。这种方法对于小型、有针对性的检查特别有用。例如，在严格涉及短信的调查中，检查员可以选择只拉取相关文件。
- en: USB debugging
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USB调试
- en: Setting up the ADB environment has been previously discussed in this book. However,
    the device under examination must also be configured properly. USB debugging is
    the actual method through which the examiner's computer will communicate with
    the device. The **USB debugging** option is found under the **Developer options**
    in the **Settings** menu. However, as of Android 4.2, the Developer Options menu
    is hidden; to reveal it, a user has to go to **Settings** | **About Phone**, and
    then tap the **Build Number** field *seven* times. An on-screen dialog will appear
    that says **You are now a developer!** At this point, **Developer options** is
    available in the **Settings** menu; simply open this menu and select **Enable
    USB debugging**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ADB环境的设置在本书中已经讨论过。然而，受检设备也必须正确配置。USB调试是法医检查员的计算机与设备通信的实际方法。**USB调试**选项位于**设置**菜单中的**开发者选项**下。然而，从Android
    4.2开始，开发者选项菜单是隐藏的；要显示它，用户必须转到**设置** | **关于手机**，然后点击**版本号**字段*七*次。屏幕上会出现一个对话框，上面写着**您现在是开发者！**此时，**开发者选项**在**设置**菜单中可用；只需打开此菜单并选择**启用USB调试**。
- en: In addition to USB debugging, the correct drivers must be installed on the examiner's
    computer. Generally they can be found online, either from the manufacturer's website
    or at [www.xda-developers.com](http://www.xda-developers.com). If commercial forensic
    tools are installed on the machine, the appropriate drivers may already be installed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了USB调试，检查员的计算机上还必须安装正确的驱动程序。通常可以在制造商的网站上或[www.xda-developers.com](http://www.xda-developers.com)上找到。如果在计算机上安装了商业法医工具，则可能已经安装了适当的驱动程序。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Another excellent resource is the Universal ADB Driver that can be downloaded
    for free at [http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml](http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的资源是可以免费下载的通用ADB驱动程序，网址为[http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml](http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml)。
- en: 'Prior to Android 4.2.2, enabling **USB debugging** was the only requirement
    to communicate with the device over ADB. In Android 4.2.2, Google added **Secure
    USB debugging** option. The **Secure USB debugging** option adds an additional
    requirement of selecting to connect to a computer on the device''s screen; this
    prevents ADB access to locked devices from untrusted computers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 4.2.2之前，启用**USB调试**是与设备通过ADB通信的唯一要求。在Android 4.2.2中，Google添加了**安全USB调试**选项。**安全USB调试**选项增加了在设备屏幕上选择连接到计算机的额外要求；这可以防止来自不受信任计算机的ADB访问被锁定的设备：
- en: '![USB debugging](img/image00302.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![USB调试](img/image00302.jpeg)'
- en: RSA fingerprint dialog
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RSA指纹对话框
- en: If **Always allow from this computer** is selected, the device will store the
    computer's RSA key and the prompt will not appear on future connections to that
    computer, even if the device is locked.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了**始终允许此计算机**，设备将存储计算机的RSA密钥，并且在将来连接到该计算机时，提示将不会出现，即使设备被锁定。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It may be possible, depending on the device and OS version, to circumvent the
    **Secure USB debugging** protection. Find more information at [https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/](https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备和操作系统版本的不同，可能可以规避**安全USB调试**保护。在[https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/](https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/)上找到更多信息。
- en: It is also possible to bypass **Secure USB debugging** by using a computer previously
    authorized to access the device, which is discussed in the Issues with Android
    Lollipop section later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过使用先前获得授权访问设备的计算机来绕过**安全USB调试**，这将在本章后面的Android Lollipop部分中讨论。
- en: 'Once **USB debugging** has been enabled and the **Secure USB debugging** check
    passed (depending on Android version), the device is ready for examination. To
    verify that the device is connected and ready to use ADB, execute the following
    command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦**USB调试**已启用并且**安全USB调试**检查通过（取决于Android版本），设备就准备好进行检查了。要验证设备是否已连接并准备使用ADB，执行以下命令：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If no devices are shown, ensure that **USB debugging** is enabled and that
    the proper device drivers have been installed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示任何设备，请确保**USB调试**已启用，并且已安装正确的设备驱动程序：
- en: '![USB debugging](img/image00303.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![USB调试](img/image00303.jpeg)'
- en: 'If the device status is `offline` or `unauthorized`, the **Secure USB debugging**
    prompt needs to be selected on the screen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备状态为`离线`或`未授权`，则需要在屏幕上选择**安全USB调试**提示：
- en: '![USB debugging](img/image00304.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![USB调试](img/image00304.jpeg)'
- en: 'If everything is running correctly, the device status should show `device`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常运行，设备状态应显示为`设备`：
- en: '![USB debugging](img/image00305.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![USB调试](img/image00305.jpeg)'
- en: Using ADB shell to determine if a device is rooted
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ADB shell来确定设备是否已root
- en: 'The simplest method to determine if a device is rooted is to use the ADB shell.
    This will open a shell on the device that will be accessed on the examiner''s
    computer; this means that any commands run in the shell will be executed on the
    device. Once **USB debugging** is enabled and **Secure USB debugging** is bypassed
    (or from recovery mode, as discussed in later in this chapter), open a terminal
    on the local computer and run:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确定设备是否已root的最简单方法是使用ADB shell。这将在设备上打开一个shell，取证人员可以在自己的计算机上访问该shell；这意味着在shell中运行的任何命令都将在设备上执行。一旦**USB调试**已启用并且**安全USB调试**已绕过（或者从恢复模式中，如本章后面讨论的），在本地计算机上打开终端并运行：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The shell will appear one of two ways, either with `$` or `#`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: shell将以`$`或`#`的方式出现：
- en: '![Using ADB shell to determine if a device is rooted](img/image00306.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用ADB shell来确定设备是否已root](img/image00306.jpeg)'
- en: 'On Linux systems, the `#` symbol is used to indicate a root user, and the `$`
    symbol indicates a non-root user. If the shell returns showing `#`, the shell
    has root access:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，`#`符号用于表示根用户，`$`符号表示非根用户。如果shell返回显示`#`，则shell具有根访问权限：
- en: '![Using ADB shell to determine if a device is rooted](img/image00307.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用ADB shell来确定设备是否已root](img/image00307.jpeg)'
- en: 'One further step may be required on some rooted devices. If the shell returns
    `$`, try running the `su` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些已root的设备上可能需要进一步的步骤。如果shell返回`$`，尝试运行`su`命令：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the su binary is installed on the device, which is usually a part of the
    root process, this will escalate the shell's permissions to root if it did not
    open with them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备上安装了su二进制文件，通常是root过程的一部分，这将提升shell的权限到root，如果shell没有以root权限打开的话。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some older devices automatically ran the shell as root; simply opening the ADB
    shell may be enough to give an examiner root access.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些旧设备会自动以root身份运行shell；仅仅打开ADB shell可能就足以给取证人员root访问权限。
- en: ADB pull
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADB pull
- en: 'As discussed in [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android
    Forensic Environment"), *Setting Up an Android Forensic Environment*, the ADB
    `pull` command is used to transfer files from the device to the local workstation.
    The format for the ADB `pull` command is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](part0019.xhtml "第2章。设置Android取证环境")*设置Android取证环境*中讨论的，ADB `pull`命令用于将文件从设备传输到本地工作站。ADB
    `pull`命令的格式为：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The optional `-p` flag shows the transfer''s progress, while the optional `-a`
    flag will copy the file''s timestamp and mode. The `<remote>` parameter is the
    exact path to the file on the device. The optional `<local>` parameter is the
    path where the file will be written on the examiner''s computer. If no local path
    is specified, the file will be written to the present working directory. To see
    what an ADB `pull` command may look like, run the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`-p`标志显示传输的进度，而可选的`-a`标志将复制文件的时间戳和模式。`<remote>`参数是设备上文件的确切路径。可选的`<local>`参数是文件将被写入到取证人员计算机上的路径。如果没有指定本地路径，文件将被写入到当前工作目录。要查看ADB
    `pull`命令的样子，运行以下命令：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command would pull the SMS database file from the device, and write it
    to a directory for the case. Again, note that the device must be rooted for this
    to work; otherwise, the output would simply show that `0` files were pulled. In
    our case, the following output is obtained:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从设备中拉取短信数据库文件，并将其写入到案例的目录中。再次注意，设备必须已root才能正常工作；否则，输出将只显示拉取了`0`个文件。在我们的案例中，获得以下输出：
- en: '![ADB pull](img/image00308.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![ADB pull](img/image00308.jpeg)'
- en: 'The preceding output shows that the file is `1020400` bytes in size. As a result
    of our command, the `mmssms.db` database now resides in the `Case_0001` folder:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示文件大小为`1020400`字节。由于我们的命令，`mmssms.db`数据库现在位于`Case_0001`文件夹中：
- en: '![ADB pull](img/image00309.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![ADB pull](img/image00309.jpeg)'
- en: The database pulled from the device, seen in Windows Explorer
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备中拉取的数据库，在Windows资源管理器中可见
- en: The database can now be examined with a SQL Browser or other forensic tools,
    which will be covered in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用SQL浏览器或其他取证工具来检查数据库，这将在[第7章](part0053.xhtml "第7章。Android应用程序的取证分析")*Android应用程序的取证分析*中进行讨论。
- en: 'Similarly, if an investigator wishes to pull the files for an entire application,
    that can be done with ADB pull also:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果调查人员希望为整个应用程序拉取文件，也可以使用ADB pull：
- en: '![ADB pull](img/image00310.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![ADB pull](img/image00310.jpeg)'
- en: 'This time, the ADB pull command fetched every file in the `com.google.android.gm`
    directory, which happens to contain all of the data for Gmail. The output was
    quite long, as it individually listed all `31` pulled files, so the entire output
    is not shown in the following figure, in which we see the total size of the transfer
    is shown as `1233373` bytes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，ADB pull命令获取了`com.google.android.gm`目录中的每个文件，这恰好包含了Gmail的所有数据。输出非常长，因为它逐个列出了所有`31`个拉取的文件，所以整个输出在下图中没有显示，我们可以看到传输的总大小显示为`1233373`字节：
- en: '![ADB pull](img/image00311.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![ADB pull](img/image00311.jpeg)'
- en: 'Now, the `Case_0002` directory contains all of the files from the Gmail application,
    as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Case_0002`目录包含了Gmail应用程序的所有文件，如下截图所示：
- en: '![ADB pull](img/image00312.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ADB pull](img/image00312.jpeg)'
- en: All files pulled from the Gmail directory, seen in Windows Explorer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中看到的从Gmail目录中拉取的所有文件
- en: 'It is even possible to do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以做到以下事情：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This would pull every logical file available from the `/data/data` directory,
    and put them in the examiner's `Case_0003` folder. This is not equivalent to a
    physical image, as certain files are skipped and deleted files will not be copied,
    but it is a simple method for pulling the vast majority of a user's application
    data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`/data/data`目录中拉取所有可用的逻辑文件，并将它们放在检查员的`Case_0003`文件夹中。这并不等同于物理镜像，因为某些文件会被跳过，已删除的文件不会被复制，但这是拉取用户应用程序数据绝大部分的简单方法。
- en: 'Another advantage of the ADB `pull` command is that it is highly useful for
    scripting purposes. A knowledgeable examiner can maintain a list of paths for
    common files of interest, and write a script that automatically pulls these files
    from a device, or even have the script automatically pull the entire `/data/data`
    directory. A simple example of Python code that will perform this function is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ADB `pull`命令的另一个优点是它非常适用于脚本目的。一个知识渊博的检查员可以维护一个常见感兴趣文件路径的列表，并编写一个自动从设备中拉取这些文件的脚本，甚至可以让脚本自动拉取整个`/data/data`目录。一个执行此功能的Python代码的简单示例是：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that code is not very refined; it's only purpose is to illustrate the ease
    with which ADB commands can be scripted. At the very least, properly implementing
    the code should include the option to specify an output directory and handle any
    errors. However, the six lines of the preceding code would be sufficient to pull
    the entire `/data/data` directory logically assuming **USB debugging** is enabled
    and the device is rooted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码并不是非常精练；它的唯一目的是说明ADB命令可以被脚本化的简易性。至少，正确实现代码应该包括指定输出目录的选项并处理任何错误。然而，前述代码的六行足以逻辑上拉取整个`/data/data`目录，假设**USB调试**已启用并且设备已root。
- en: Recovery mode
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复模式
- en: In order to truly be forensically sound, ADB data extractions should not be
    used against a phone while it is turned on. While the device is running, timestamps
    can be modified and applications may be running and updating files in the background.
    To avoid this, an examiner should place the device into a custom recovery mode,
    as shown in [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic
    Environment"), *Setting Up an Android Forensic Environment*, if possible. ADB
    access is not available through the stock Android recovery mode. Typically, the
    first step in the rooting process is to flash a custom recovery mode to allow
    a method for repairing the device if something goes wrong. Rooted devices are
    far more likely to contain a custom recovery, but it is possible to flash a custom
    recovery to a non-rooted device. This method also allows the examiner to avoid
    the **Secure USB debugging** prompt on newer versions of Android, although our
    testing shows that this does not work on Android Lollipop. Recovery mode also
    may not require **USB debugging** to be enabled, which makes it an excellent option
    for bypassing a locked device.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正具有法庭取证的可靠性，不应在手机开机时使用ADB数据提取。当设备正在运行时，时间戳可能会被修改，应用程序可能在后台运行并更新文件。为了避免这种情况，检查员应该将设备置于自定义恢复模式中，如[第2章](part0019.xhtml
    "第2章。设置Android取证环境")中所示，*设置Android取证环境*，如果可能的话。通过原始Android恢复模式无法访问ADB。通常，rooting过程的第一步是刷入自定义恢复模式，以便在出现问题时修复设备。已root的设备更有可能包含自定义恢复模式，但是也有可能将自定义恢复模式刷入未root的设备。这种方法还允许检查员避免在较新版本的Android上出现的**安全USB调试**提示，尽管我们的测试显示这在Android
    Lollipop上不起作用。恢复模式也可能不需要启用**USB调试**，这使其成为绕过锁定设备的绝佳选择。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This method will not work against devices with full disk encryption enabled.
    Booting into Recovery Mode will *not* decrypt the data partition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不适用于启用了全盘加密的设备。进入恢复模式将*不*解密数据分区。
- en: The process to boot into recovery mode will vary for each device. Typically,
    it involves some combination of powering the device off and holding the volume
    and power keys. Guides for specific models can be found online.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 进入恢复模式的过程对于每个设备都会有所不同。通常情况下，它涉及一些关机并按住音量和电源键的组合。特定型号的指南可以在线找到。
- en: 'The stock recovery mode will typically show a picture of an Android being operated
    on:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原始恢复模式通常会显示一个正在操作的Android的图片：
- en: '![Recovery mode](img/image00313.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00313.jpeg)'
- en: Stock Recovery mode
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 原始恢复模式
- en: Custom recoveries look like the following screenshots. Also, stock recoveries
    will not allow ADB communication; running adb devices will simply show no devices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义恢复模式看起来像以下的截图。此外，原始恢复模式将不允许ADB通信；运行adb devices将只显示没有设备。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Custom recovery images for many devices can be found at [https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)
    and [http://teamw.in/project/twrp2](http://teamw.in/project/twrp2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备的自定义恢复镜像可以在[https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)和[http://teamw.in/project/twrp2](http://teamw.in/project/twrp2)找到。
- en: 'If a device is in a custom Recovery Mode and the correct drivers have been
    installed on the examiner''s computer, the device can be accessed via ADB as if
    it were live. Note that its status using the adb devices command now shows that
    it is in recovery mode:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备处于自定义恢复模式，并且在审查员的计算机上安装了正确的驱动程序，则可以通过ADB访问设备，就像它是活动的一样。请注意，使用adb devices命令现在显示它处于恢复模式：
- en: '![Recovery mode](img/image00314.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00314.jpeg)'
- en: 'There is one final step before the examiner can begin extracting data over
    ADB: the data partition must be mounted in order to access user data. Some custom
    recoveries may mount this automatically, and others might not. If using either
    the Clockwork Mod Recovery or **Team Win Recovery Project** (**TWRP**) images
    from the URLs above, the data partition can be mounted by selecting **Mounts**
    and then selecting the data partition, as shown in the following screenshots.
    The recovery menu is generally either navigated by using the volume keys to move
    up and down and the power button to select, or may be touch-based depending on
    the custom recovery image used.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查员可以开始通过ADB提取数据之前，还有最后一步：必须挂载数据分区以访问用户数据。一些自定义恢复可能会自动挂载这个分区，而其他可能不会。如果使用上面的URL中的Clockwork
    Mod Recovery或Team Win Recovery Project（TWRP）映像，可以通过选择Mounts然后选择数据分区来挂载数据分区，如下面的屏幕截图所示。恢复菜单通常可以使用音量键上下移动和电源按钮选择，或者根据使用的自定义恢复映像而可能是基于触摸的。
- en: 'For a TWRP recovery, from the main recovery screen, select **Mount**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TWRP恢复，从主恢复屏幕中选择**Mount**：
- en: '![Recovery mode](img/image00315.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00315.jpeg)'
- en: 'After choosing **Mount**, select the partition(s) to be mounted:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Mount**后，选择要挂载的分区：
- en: '![Recovery mode](img/image00316.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00316.jpeg)'
- en: 'In a Clockwork Mod Recovery, select **mounts and storage**:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clockwork Mod Recovery中，选择mounts and storage：
- en: '![Recovery mode](img/image00317.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00317.jpeg)'
- en: 'Then select the partition(s) to mount:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择要挂载的分区：
- en: '![Recovery mode](img/image00318.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![恢复模式](img/image00318.jpeg)'
- en: Once the data partition (and any other partition the examiner wants to investigate)
    is mounted, the examiner can perform ADB data extractions, as demonstrated earlier
    in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据分区（以及审查员想要调查的任何其他分区）被挂载，审查员就可以执行ADB数据提取，就像本章前面演示的那样。
- en: If the device does not have a custom recovery, the following section will show
    how to boot into one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备没有自定义恢复，下一节将显示如何启动到自定义恢复。
- en: Fastboot mode
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速启动模式
- en: Fastboot is another protocol utility built into the Android SDK, and is used
    for interacting directly with a device's bootloader. Essentially, it is a much
    lower-level version of ADB, and is frequently used to flash new images to a device.
    How can this be helpful to an examiner?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Fastboot是Android SDK中内置的另一个协议实用程序，用于直接与设备的引导加载程序进行交互。基本上，它是ADB的一个更低级别版本，并且经常用于向设备刷入新映像。这对审查员有什么帮助呢？
- en: Fastboot can allow an examiner to boot from a custom recovery image, and temporarily
    gain root access on a device, thus gaining access to data that would have been
    unavailable otherwise. Fastboot does not require USB debugging to be enabled or
    root access. The process of loading a custom bootloader onto a device is commonly
    used by commercial forensic tools to temporarily root a device, but a skilled
    examiner can also perform the process manually. Using this method, the recovery
    image is loaded into RAM; no permanent data on the device is altered in any way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Fastboot可以允许审查员从自定义恢复映像启动，并临时获得设备的root访问权限，从而访问以其他方式无法访问的数据。Fastboot不需要启用USB调试或root访问权限。将自定义引导加载程序加载到设备上通常由商业取证工具使用，以临时获取设备的root权限，但是熟练的审查员也可以手动执行该过程。使用此方法，恢复映像加载到RAM中；设备上的任何永久数据都不会以任何方式被更改。
- en: The most important requirement for using fastboot is an unlocked bootloader;
    locked bootloaders will not allow a device to boot from code that isn't specifically
    signed by the manufacturer. Unfortunately for forensic purposes, most devices
    no longer ship with an unlocked bootloader as it is a serious security risk, and
    manually unlocking a bootloader typically erases the user data. As such, the number
    of devices for which this is a feasible method is somewhat limited. But, when
    it works, it's an absolutely invaluable tool for an examiner to have in their
    arsenal.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用fastboot最重要的要求是解锁引导加载程序；锁定的引导加载程序将不允许设备从制造商专门签名的代码启动。不幸的是，出于取证目的，大多数设备不再出厂时带有解锁的引导加载程序，因为这是一个严重的安全风险，并且手动解锁引导加载程序通常会擦除用户数据。因此，这种方法适用的设备数量有些有限。但是，当它起作用时，对于审查员来说，这是一个绝对无价的工具。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This method will not work against devices with full disk encryption enabled.
    Booting into recovery mode will *not* decrypt the data partition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不适用于启用了全盘加密的设备。进入恢复模式将*不*解密数据分区。
- en: Determining bootloader status
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定引导加载程序状态
- en: 'Much like everything involving Android forensics, there is no one guaranteed
    method to determine if a bootloader is locked, as it varies depending upon the
    manufacturer. To boot into the bootloader, use the following ADB command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与涉及Android取证的所有内容一样，确定引导加载程序是否已锁定没有一种保证的方法，因为这取决于制造商。要进入引导加载程序，请使用以下ADB命令：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The device should boot to a screen that shows information regarding the bootloader.
    Frequently, this screen will display the bootloader status, as seen in the following
    screenshot.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 设备应该启动到显示有关引导加载程序的信息的屏幕。通常，此屏幕将显示引导加载程序状态，如下面的屏幕截图所示。
- en: 'Here''s a generic, stock fastboot menu from a Nexus 5\. Note that the **Lock
    State** indicates that the bootloader is unlocked:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Nexus 5的通用、原始快速启动菜单。请注意，**Lock State**指示引导加载程序已解锁：
- en: '![Determining bootloader status](img/image00319.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![确定引导加载程序状态](img/image00319.jpeg)'
- en: 'A standard HTC fastboot screen is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的HTC快速启动屏幕如下：
- en: '![Determining bootloader status](img/image00320.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![确定引导加载程序状态](img/image00320.jpeg)'
- en: 'Following is a standard Samsung **Odin** mode screen; Odin is the Samsung proprietary
    equivalent to fastboot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标准的三星**Odin**模式屏幕；Odin是三星专有的等效快速启动：
- en: '![Determining bootloader status](img/image00321.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![确定引导加载程序状态](img/image00321.jpeg)'
- en: Booting to a custom recovery image
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导到自定义恢复映像
- en: Once the bootloader is determined to be unlocked, an examiner will need a custom
    recovery image from which to boot. An excellent source of recovery images is either
    [https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)
    or [http://teamw.in/twrp_view_all_devices](http://teamw.in/twrp_view_all_devices).
    Both sites offer coverage of a wide variety of devices, and will provide the same
    functionality for the purposes of this method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 确定引导加载程序已解锁后，检查员将需要一个自定义恢复映像来引导。恢复映像的绝佳来源是[https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)或[http://teamw.in/twrp_view_all_devices](http://teamw.in/twrp_view_all_devices)。这两个网站都提供各种设备的覆盖，并且将为此方法提供相同的功能。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is absolutely critical to select the correct recovery image for the device
    being examined; they are not interchangeable, and booting from the wrong image
    may brick the device.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在检查的设备，选择正确的恢复映像绝对至关重要；它们不能互换，从错误的映像引导可能会砖化设备。
- en: 'Once a recovery image is selected and downloaded, the device needs to be placed
    into fastboot mode. This can be accomplished in one of two ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 选择并下载恢复映像后，需要将设备放入快速启动模式。可以通过以下两种方式之一完成：
- en: ADB
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADB
- en: Physical device buttons
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理设备按钮
- en: 'To enter fastboot device over ADB, the device must already have **USB debugging**
    enabled. The command to enter fastboot mode over ADB is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过ADB进入快速启动设备，设备必须已启用**USB调试**。通过ADB进入快速启动模式的命令是：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If USB Debugging cannot be enabled or ADB cannot be used, there is also typically
    a combination of buttons to press while the device is booting, similar to entering
    Recovery Mode. The exact combination can be found online for each device specifically.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法启用USB调试或无法使用ADB，通常还有一组按钮组合可在设备启动时按下，类似于进入恢复模式。可以在线找到每个设备特定的确切组合。
- en: 'Once the device is in fastboot mode, running the following command will verify
    if the device is connected and ready to communicate:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设备进入快速启动模式后，运行以下命令将验证设备是否已连接并准备好通信：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following command will load the custom recovery image into RAM and boot
    the device into Recovery Mode:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将加载自定义恢复映像到RAM并将设备引导到恢复模式：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Booting to a custom recovery image](img/image00322.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![引导到自定义恢复映像](img/image00322.jpeg)'
- en: The device should now reboot and enter Recovery Mode. As shown in the Recovery
    Mode section, the /data partition may need to be mounted in order to access user
    data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 设备现在应该重新启动并进入恢复模式。如恢复模式部分所示，可能需要挂载/data分区以访问用户数据。
- en: Entering the ADB shell will show that the examiner now has root access. The
    device will allow root access until it is rebooted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 进入ADB shell将显示检查员现在具有根访问权限。设备将允许根访问权限，直到重新启动。
- en: '![Booting to a custom recovery image](img/image00323.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![引导到自定义恢复映像](img/image00323.jpeg)'
- en: 'If the fastboot boot command fails, it is a likely indicator that the device''s
    bootloader is locked, as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果快速启动引导命令失败，则很可能表明设备的引导加载程序已锁定，如下面的屏幕截图所示：
- en: '![Booting to a custom recovery image](img/image00324.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![引导到自定义恢复映像](img/image00324.jpeg)'
- en: ADB backup extractions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADB备份提取
- en: Google implemented ADB backup functionality, beginning in Android 4.0 Ice Cream
    Sandwich. This allows users (and forensic examiners) to backup application data
    to a local computer over ADB. This process does not require root, and is therefore
    highly useful for forensic purposes. However, it does not acquire every application
    installed on the device. When a developer makes a new app, it is set to allow
    backups by default, but this can be changed by the developer. In practice, it
    seems the vast majority of developers leave the default setting, which means that
    backups do capture most third-party applications. Unfortunately, most Google applications
    disable backups; full application data from apps such as Gmail and Google Maps
    will not be included.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Google在Android 4.0冰淇淋三明治中实现了ADB备份功能。这允许用户（和取证检查员）通过ADB将应用程序数据备份到本地计算机。此过程不需要根权限，因此对于取证目的非常有用。但是，它不会获取设备上安装的每个应用程序。当开发人员创建新应用程序时，默认情况下将其设置为允许备份，但开发人员可以更改此设置。实际上，似乎绝大多数开发人员保留默认设置，这意味着备份可以捕获大多数第三方应用程序。不幸的是，大多数Google应用程序禁用备份；来自应用程序（如Gmail和Google
    Maps）的完整应用程序数据将不包括在内。
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This method will not be useful against a locked device as user interaction with
    the screen is required.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法对于锁定的设备将无效，因为需要用户与屏幕进行交互。
- en: Extracting a backup over ADB
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ADB提取备份
- en: 'The format of the ADB backup command is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ADB备份命令的格式是：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The flags are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标志：
- en: '`-f`: Names the path for the output file. If not specified, defaults to `backup.ab`
    in present working directory.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：为输出文件命名路径。如果未指定，默认为当前工作目录中的`backup.ab`。'
- en: '`[-apk|noapk]`: Choose whether or not to back up the `.apk` file. Defaults
    to `-noapk`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-apk|noapk]`：选择是否备份`.apk`文件。默认为`-noapk`。'
- en: '`[-obb|-noobb]`: Choose whether or not to back up `.obb` (APK expansion) files.
    Defaults to `-noobb`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-obb|-noobb]`：选择是否备份`.obb`（APK扩展）文件。默认为`-noobb`。'
- en: '`[-shared|-noshared]`: Choose whether or not to back up data from shared storage
    and the SD card. Defaults to `-noshared`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-shared|-noshared]`：选择是否备份共享存储和SD卡中的数据。默认为`-noshared`。'
- en: '`[-all]`: Include all applications for which backups are enabled.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-all]`：包括启用备份的所有应用程序。'
- en: '`[-system|-nosystem]`: Choose whether or not to include system applications.
    Defaults to `-system`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-system|-nosystem]`：选择是否包括系统应用程序。默认为`-system`。'
- en: '`[<packages>]`: Explicitly name application packages to be backed up. Not needed
    if using `-all` or `-shared`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[<packages>]`：显式命名要备份的应用程序包。如果使用`-all`或`-shared`，则不需要。'
- en: 'An example ADB backup command to capture all possible application data would
    be:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获所有可能的应用程序数据的示例ADB备份命令如下：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, an example ADB backup command to capture a specific application''s
    data would be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，捕获特定应用程序数据的示例ADB备份命令如下：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see something like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似的东西：
- en: '![Extracting a backup over ADB](img/image00325.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![通过ADB提取备份](img/image00325.jpeg)'
- en: 'When performing a backup, the user must approve the backup on the device. This
    means that backups cannot be performed without bypassing screen locks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行备份时，用户必须在设备上批准备份。这意味着不能绕过屏幕锁定进行备份：
- en: '![Extracting a backup over ADB](img/image00326.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![通过ADB提取备份](img/image00326.jpeg)'
- en: Accepting the backup on the device
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上接受备份
- en: Depending on the number of applications installed, the backup process may take
    a significant amount of time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据安装的应用程序数量，备份过程可能需要相当长的时间。
- en: Parsing ADB backups
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析ADB备份
- en: The resulting backup data is stored as a .`ab` file, but is actually a `.tar`
    file that has been compressed with the **Deflate** algorithm. If a password was
    entered on the device when the backup was created, the file would also be AES
    encrypted. It should also be mentioned that these files may exist on a suspect's
    computer, and can be analyzed using the same methods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的备份数据存储为`.ab`文件，但实际上是使用**Deflate**算法压缩的`.tar`文件。如果在创建备份时在设备上输入了密码，文件也将被AES加密。还应该提到，这些文件可能存在于嫌疑人的计算机上，并且可以使用相同的方法进行分析。
- en: There are many free utilities to turn the `.ab` backup file into a `.tar` that
    can be viewed. One such utility is the Android Backup Extractor, found at [http://sourceforge.net/projects/adbextractor/](http://sourceforge.net/projects/adbextractor/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多免费的实用程序可以将`.ab`备份文件转换为可以查看的`.tar`文件。其中一个实用程序是Android备份提取工具，位于[http://sourceforge.net/projects/adbextractor/](http://sourceforge.net/projects/adbextractor/)。 '
- en: 'To use the Android Backup Extractor, simply extract its files into the directory
    with the backup. The command to run the utility is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Android备份提取工具，只需将其文件提取到备份所在的目录中。运行该实用程序的命令是：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the command runs properly, the command line will display as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令正确运行，命令行将显示如下内容：
- en: '![Parsing ADB backups](img/image00327.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![解析ADB备份](img/image00327.jpeg)'
- en: 'The first line of the output informs the examiner that the file was not encrypted.
    Had it been encrypted, the examiner would have to pass the password as an argument
    at the end of the command line. As seen in the output, the backup created in the
    previous section is approximately 4 GB, even though it is still compressed. The
    `.tar` file will be at the path specified on the command line or the current working
    directory if no path is specified. Decompressing the `.tar` file may be done manually
    on a Linux command line or with one of the many Windows archive utilities, such
    as WinRAR or 7Zip:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行通知审查员文件未加密。如果文件已加密，审查员将不得不在命令行的末尾作为参数传递密码。如输出所示，即使备份仍然被压缩，上一节中创建的备份大约为4GB。`.tar`文件将位于命令行指定的路径或当前工作目录（如果未指定路径）。可以在Linux命令行上手动解压缩`.tar`文件，也可以使用许多Windows存档实用程序之一，如WinRAR或7Zip：
- en: '![Parsing ADB backups](img/image00328.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![解析ADB备份](img/image00328.jpeg)'
- en: Directories within the backup, seen in Windows Explorer
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 备份中的目录，在Windows资源管理器中查看
- en: Data locations within ADB backups
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADB备份中的数据位置
- en: 'Now that the backup has been converted to a `.tar` file and then extracted,
    the examiner can view the data contained in the backup. In our example, there
    are two directories found in the root of the backup:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在备份已转换为`.tar`文件并进行了提取，审查员可以查看备份中包含的数据。在我们的示例中，在备份的根目录中找到了两个目录：
- en: '`apps`: This folder contains data from `/data/data` for applications that were
    included in the backup.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps`：此文件夹包含备份中包含的应用程序的`/data/data`中的数据。'
- en: '`shared`: This folder contains all data from SD card, only present if the –shared
    argument was passed at the command line.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`：此文件夹包含SD卡中的所有数据，仅在命令行传递了`-shared`参数时才存在。'
- en: Note that the files within the apps directory are stored in directories by their
    package name (just as seen in `/data/data` from within the ADB shell), and the
    shared directory is exactly what the user would see if they accessed the SD card
    by plugging it into a computer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应用程序目录中的文件存储在其包名称的目录中（就像在ADB shell内部的`/data/data`中看到的那样），共享目录正是用户如果将SD卡插入计算机中所看到的。
- en: For a benign example of user data that was pulled from the backup, the user's
    **Pandora** activity is shown below. Pandora is a streaming music service with
    millions of downloads in the Google Play Store. Pandora's application data will
    be contained in the apps folder of the backup in the folder named `com.pandora.android`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为从备份中提取的用户数据的良性示例，下面显示了用户的**Pandora**活动。 Pandora是一个在Google Play商店中有数百万次下载的流媒体音乐服务。
    Pandora的应用程序数据将包含在备份的apps文件夹中，文件夹名为`com.pandora.android`。
- en: '![Data locations within ADB backups](img/image00329.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![ADB备份中的数据位置](img/image00329.jpeg)'
- en: The Pandora directory from the backup
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从备份中提取的Pandora目录
- en: 'This is a fairly standard layout for an Android application, as discussed in
    [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic Environment"),
    *Setting Up an Android Forensic Environment*. The application''s databases will
    be in the `db` folder:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的Android应用程序布局，如[第2章](part0019.xhtml "第2章。设置Android取证环境")中所讨论的那样，*设置Android取证环境*。应用程序的数据库将在`db`文件夹中：
- en: '![Data locations within ADB backups](img/image00330.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![ADB备份中的数据位置](img/image00330.jpeg)'
- en: Files within the db folder of the Pandora backup
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Pandora备份的db文件夹中的文件
- en: 'XML configuration settings will be in the `sp` folder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: XML配置设置将在`sp`文件夹中：
- en: '![Data locations within ADB backups](img/image00331.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![ADB备份中的数据位置](img/image00331.jpeg)'
- en: Files within the sp folder of the Pandora backup
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Pandora备份的sp文件夹中的文件
- en: 'Using a database viewer to view `pandora.db` reveals stations that the user
    has created, as well as the timestamp for when it was created:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库查看器查看`pandora.db`，可以查看用户创建的站点以及创建时间戳：
- en: '![Data locations within ADB backups](img/image00332.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![ADB备份中的数据位置](img/image00332.jpeg)'
- en: Contents of pandora.db from the backup
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从备份中的pandora.db的内容
- en: 'Looking in the XML preferences file, the timestamp of the app installation
    can be found under `firstInstallId`. Note that the exact method for converting
    the timestamps is shown in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML首选项文件中，可以在`firstInstallId`下找到应用程序安装的时间戳。请注意，转换时间戳的确切方法显示在[第7章](part0053.xhtml
    "第7章。Android应用程序的法医分析")中，*Android应用程序的法医分析*中：
- en: '![Data locations within ADB backups](img/image00333.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![ADB备份中的数据位置](img/image00333.jpeg)'
- en: Contents of the XML preferences file
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: XML首选项文件的内容
- en: If, for some odd reason, the user's Pandora usage was a major question in the
    investigation, what could an examiner determine from these two seemingly innocuous
    files?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种奇怪的原因，用户的Pandora使用在调查中是一个重要问题，调查员可以从这两个看似无害的文件中得出什么结论？
- en: Firstly, the `lastTransmission` and `firstInstallID` timestamps are within milliseconds
    of each other, indicating that the application was never used after it was installed.
    Furthermore, the creation dates of each station precede the installation of the
    application, in some cases, by years. This would be an indicator that the user
    has used Pandora on other devices, which may be highly relevant to the investigation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`lastTransmission`和`firstInstallID`时间戳相差毫秒，表明该应用程序安装后从未使用过。此外，每个站点的创建日期在某些情况下早于应用程序的安装日期，有些甚至早于几年。这表明用户在其他设备上使用了Pandora，这可能与调查高度相关。
- en: While Pandora is generally not germane to digital forensic investigations, it
    is an example of data that can be gleaned from a simple backup over ADB. A more
    detailed application analysis will be presented in [Chapter 7](part0053.xhtml
    "Chapter 7. Forensic Analysis of Android Applications"), *Forensic Analysis of
    Android Applications*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Pandora通常与数字取证调查无关，但它是通过ADB进行简单备份的数据的一个例子。更详细的应用程序分析将在[第7章](part0053.xhtml
    "第7章。Android应用程序的法医分析")中呈现，*Android应用程序的法医分析*。
- en: ADB Dumpsys
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADB Dumpsys
- en: '**Dumpsys** is a tool built into the Android OS, generally used for development
    purposes to show the status of services running on the device. However, it can
    also contain forensically interesting information. Dumpsys does not require root
    access, but like all ADB commands, it does require USB Debugging to be enabled
    on the device and Secure USB Debugging to be bypassed.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dumpsys**是内置在Android操作系统中的工具，通常用于开发目的，以显示设备上运行的服务的状态。但是，它也可能包含法医学上有趣的信息。Dumpsys不需要root访问权限，但与所有ADB命令一样，它需要设备上启用USB调试和绕过安全USB调试。'
- en: 'The exact services that can be viewed differ across devices and Android versions.
    To view a list of all possible services that can be dumped, run the following
    command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查看的确切服务因设备和Android版本而异。要查看可以转储的所有可能服务的列表，请运行以下命令：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the command will appear as a list, shown as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将显示为列表，如下所示：
- en: '![ADB Dumpsys](img/image00334.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![ADB Dumpsys](img/image00334.jpeg)'
- en: 'The service name located before the colon is the argument we will pass to dumpsys.
    A valid dumpsys command, using service number seven (`iphonesubinfo`) in the preceding
    screenshot, looks like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号前的服务名称是我们将传递给dumpsys的参数。使用前面截图中的服务编号七（`iphonesubinfo`）的有效dumpsys命令如下所示：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following screenshot, we see that the output of the `iphonesubinfo`
    service includes the device IMEI:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们看到`iphonesubinfo`服务的输出包括设备的IMEI：
- en: '![ADB Dumpsys](img/image00335.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![ADB Dumpsys](img/image00335.jpeg)'
- en: 'There are many forensically interesting dumpsys services; following are several
    examples. As the dumpsys services may vary by OS version and device, this list
    is not all-inclusive and is merely intended to show the usefulness of dumpsys
    to a forensic examiner:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多法医学上有趣的dumpsys服务；以下是一些示例。由于dumpsys服务可能因操作系统版本和设备而异，此列表并不包括所有内容，仅旨在展示dumpsys对法医检查员的有用性：
- en: iphonesubinfo
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iphonesubinfo
- en: batterystats
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: batterystats
- en: procstats
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: procstats
- en: user
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: appops
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: appops
- en: Wi-Fi
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi
- en: notification
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知
- en: Dumpsys batterystats
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys batterystats
- en: 'Batterystats is used to show the usage of running applications. Its output
    can be very verbose, depending on the number of applications in use. In the following
    screenshot , the output was redirected to a file because it did not fit in the
    Windows command line:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Batterystats用于显示正在运行的应用程序的使用情况。根据使用的应用程序数量，其输出可能非常冗长。在下面的截图中，输出被重定向到文件，因为它无法适应Windows命令行：
- en: '![Dumpsys batterystats](img/image00336.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys batterystats](img/image00336.jpeg)'
- en: This shows us the network usage of Google Chrome. This information can be used
    to show that the application had been used recently, and this information will
    exist even if Chrome was used in Incognito Mode and leaves no forensic evidence
    elsewhere.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了Google Chrome的网络使用情况。这些信息可以用来显示该应用程序最近是否被使用，即使Chrome在隐身模式下使用并且在其他地方没有留下法医证据，这些信息仍将存在。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **wake lock** section can be very useful for detecting malware. A wake lock
    is a method of keeping the device awake (not entering sleep mode), and is indicative
    of an application attempting to stay running in the background.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**唤醒锁**部分对于检测恶意软件非常有用。唤醒锁是一种使设备保持唤醒状态（不进入睡眠模式）的方法，表明应用程序试图在后台保持运行。'
- en: Dumpsys procstats
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys procstats
- en: 'The **procstats** is a service to display the processor usage by running applications.
    Similar to batterystats, it is another method that can be used to show that an
    application was recently used on a device, as shown in the following screen shot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**procstats**是一种显示运行应用程序的处理器使用情况的服务。与batterystats类似，它是可以用来显示应用程序最近在设备上使用的另一种方法，如下截图所示：'
- en: '![Dumpsys procstats](img/image00337.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys procstats](img/image00337.jpeg)'
- en: Dumpsys user
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys user
- en: Beginning with Android Jelly Bean, Google added support for multiple users on
    tablet devices. With the release of Lollipop, Google extended this support to
    phones. One of the most challenging problems in digital forensics for a long time
    has been to prove who was using a device when incriminating actions were performed;
    "Who was behind the keyboard?"
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android Jelly Bean开始，Google为平板设备添加了多用户支持。随着Lollipop的发布，Google将此支持扩展到手机。长期以来，数字取证中最具挑战性的问题之一是在执行可疑操作时证明谁在使用设备；“谁在键盘后面？”
- en: 'Running dumpsys on the user service will show last login info for all users:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户服务上运行dumpsys将显示所有用户的最后登录信息：
- en: '![Dumpsys user](img/image00338.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys user](img/image00338.jpeg)'
- en: As only one user can be logged in at a time, looking at the user with the most
    recent login will identify the account currently in use on the device.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一次只能有一个用户登录，查看最近登录的用户将确定设备上当前正在使用的帐户。
- en: Dumpsys App Ops
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys App Ops
- en: 'The **App Ops** may be the most interesting dumpsys service. The term App Ops
    is generally used to refer to permissions accessible by an application. In older
    versions of Android, it was rumoured that Google would include the ability for
    users to revoke specific permissions from an application. This has never come
    to fruition, but this service at least remains, and shows the last time an application
    used each permission that it can access. Following is another example from Google
    Chrome:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**App Ops**可能是最有趣的dumpsys服务。术语App Ops通常用于指代应用程序可以访问的权限。在较早版本的Android中，有传言称Google将包括用户可以撤消应用程序的特定权限的功能。尽管这从未实现，但这项服务至少仍然存在，并显示了应用程序上次使用每个可以访问的权限的时间。以下是来自Google
    Chrome的另一个示例：'
- en: '![Dumpsys App Ops](img/image00339.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys App Ops](img/image00339.jpeg)'
- en: In the above output, we can see that approximately 1 hour and 7 minutes before
    App Ops was dumped with dumpsys, Chrome used the `TAKE_AUDIO_FOCUS` permission,
    and later used `AUDIO_MEDIA_VOLUME`. This indicates what Chrome was used to listen
    to and when.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，我们可以看到大约在App Ops使用dumpsys之前1小时7分钟，Chrome使用了`TAKE_AUDIO_FOCUS`权限，后来使用了`AUDIO_MEDIA_VOLUME`。这表明Chrome用于听音乐的时间和内容。
- en: 'A somewhat more interesting example is the following phone application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣的例子是以下的手机应用程序：
- en: '![Dumpsys App Ops](img/image00340.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys App Ops](img/image00340.jpeg)'
- en: '`44` minutes ago, the user used the phone application and required the `READ_CONTACTS`
    permission, then immediately used the `WRITE_CALL_LOG` permission. We can surmise
    that the user made a phone call `44` minutes ago; even if they had deleted the
    call from the records afterwards.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`44`分钟前，用户使用了电话应用程序并需要`READ_CONTACTS`权限，然后立即使用了`WRITE_CALL_LOG`权限。我们可以推断用户在`44`分钟前打了电话；即使他们之后从记录中删除了通话。'
- en: Dumpsys Wi-Fi
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys Wi-Fi
- en: 'The **Wi-Fi** service will show a list of all SSIDs for which a connection
    has been saved. This could be useful for showing that a user was at a certain
    location, for example. More detailed Wi-Fi information is also available on the
    file system, but requires root to view. Using dumpsys, we can access this data
    without requiring root:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wi-Fi**服务将显示已保存连接的所有SSID的列表。例如，这可能对于显示用户曾经在某个位置非常有用。更详细的Wi-Fi信息也可以在文件系统上找到，但需要root权限才能查看。使用dumpsys，我们可以在不需要root权限的情况下访问这些数据：'
- en: '![Dumpsys Wi-Fi](img/image00341.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys Wi-Fi](img/image00341.jpeg)'
- en: Dumpsys notification
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys notification
- en: 'The **notification** service will provide information about currently active
    notifications. This can be useful for recording the state of a device when it
    is seized, or identifying which application is displaying a specific notification.
    Each notification can be rather large and contain a lot of information, only some
    of which may be of use. The following example shows an incoming email from the
    Gmail application, which includes the subject (`This is a test email`) and body
    (`To see a test notification`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**通知**服务将提供有关当前活动通知的信息。这对于记录设备被扣押时的状态，或者识别显示特定通知的应用程序非常有用。每个通知可能相当大，并包含大量信息，其中只有一些可能有用。以下示例显示了来自Gmail应用程序的一封新邮件，其中包括主题（`这是一封测试邮件`）和正文（`查看测试通知`）：'
- en: '![Dumpsys notification](img/image00342.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Dumpsys notification](img/image00342.jpeg)'
- en: Dumpsys conclusions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dumpsys结论
- en: 'Running the dumpsys command with no service name will run dumpsys on all available
    services. However, the output will be very large, and should be redirected into
    a text file. On most platforms, the command to do this would be:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有服务名称的情况下运行dumpsys命令将在所有可用的服务上运行dumpsys。但是，输出将非常庞大，应将其重定向到文本文件中。在大多数平台上，执行此操作的命令将是：
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would write the output to dumpsys.txt in the current working directory.
    The output can then be searched, or a parsing script can be run to pull out known
    relevant fields.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把输出写入到当前工作目录中的dumpsys.txt文件中。然后可以搜索输出，或者运行解析脚本来提取已知的相关字段。
- en: Dumpsys is an extremely powerful tool that can be used to show information that
    cannot be obtained elsewhere on the device. We recommend running dumpsys on every
    Android device when it is seized, prior to being shut down. This will save a wide
    variety of information that may be useful later, and does not require root.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Dumpsys是一个非常强大的工具，可以用来显示设备上无法在其他地方获取的信息。我们建议在扣押Android设备时，在关机之前运行dumpsys。这将保存各种各样的信息，以后可能会有用，并且不需要root权限。
- en: Bypassing Android lock screens
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过Android锁屏
- en: Lock screens are the most challenging aspect of Android forensic examinations.
    Frequently, the entire investigation depends on the examiner's ability to gain
    access to a locked device. While there are methods to bypass them, this can be
    highly dependent on the OS version, device settings, and technical capabilities
    of the examiner. There is no magical solution that will work every time on every
    device. Commercial forensics tools such as Cellebrite and XRY have fairly robust
    bypass capabilities, but are far from infallible. This chapter will show how an
    examiner can increase their odds of bypassing locked devices with free tools and
    methods.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 锁屏是安卓取证调查中最具挑战性的方面。调查的整个过程经常取决于取证人员获取锁定设备的能力。虽然有绕过锁屏的方法，但这很大程度上取决于操作系统版本、设备设置和取证人员的技术能力。并没有一种可以在每台设备上都有效的神奇解决方案。商业取证工具如Cellebrite和XRY具有相当强大的绕过能力，但并非万无一失。本章将展示取证人员如何利用免费工具和方法提高绕过锁定设备的成功率。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An examiner should never attempt to guess a Pattern/PIN/Password on the device.
    Many manufacturers implement a setting that will wipe the device after a number
    of failed attempts. Many also allow the user to lower that number.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 取证人员不应尝试在设备上猜测图案/PIN/密码。许多制造商实施了一个设置，将在一定次数的失败尝试后擦除设备。许多还允许用户降低这个次数。
- en: Lock screen types
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁屏类型
- en: 'There are many methods used to secure a device, and the methods for bypassing
    each vary:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于保护设备的方法，以及绕过每种方法的方法都有所不同：
- en: None/Slide
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无/滑动
- en: Pattern
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图案
- en: PIN
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIN
- en: Password
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Smart Lock
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能锁
- en: Trusted Face
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可信面部
- en: Trusted Location
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可信位置
- en: Trusted Device
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可信设备
- en: Other security options may exist; as Android is open source, the possibilities
    are only limited by the developer's imagination. These are the options that are
    available in the stock version of Android Lollipop released by Google. Most security
    options used by vendors generally use one of these stock options as a failsafe,
    in case a user is unable to log in with their unique options. Versions in which
    the setting was first used also refer to stock Android; various manufacturers
    may have implemented them sooner.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在其他安全选项；由于安卓是开源的，可能性只受开发者想象力的限制。这些是谷歌发布的安卓棒棒糖原始版本中提供的选项。大多数供应商使用的安全选项通常将这些原始选项作为备用选项，以防用户无法使用他们独特的选项登录。首次使用该设置的版本也指的是原始安卓；各种制造商可能更早地实施了它们。
- en: None/Slide lock screens
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无/滑动锁屏
- en: The **Slide to unlock** screen is the default setting of most Android devices.
    It provides no level of security, and is bypassed by sliding a finger on the screen
    in the indicated direction.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**滑动解锁**屏幕是大多数安卓设备的默认设置。它提供了零级安全，并且可以通过在屏幕上滑动手指来绕过。'
- en: Pattern lock screens
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图案锁屏
- en: Pattern lock screens are the iconic Android security method. Frequently referred
    to as **swipe codes** and similar names, these require the user to trace a pattern
    on the device with a finger. A common bypass for this lock is the **smudge attack**,
    looking for patterns left on the screen by the user's finger.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图案锁屏是标志性的安卓安全方法。经常被称为**滑动码**和类似的名称，这些要求用户用手指在设备上划出一个图案。这种锁的常见绕过方法是**指纹攻击**，寻找用户手指在屏幕上留下的图案。
- en: Password/PIN lock screens
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码/PIN锁屏
- en: 'Users familiar with Apple''s iOS will recognize this option. It requires a
    user to type a password or PIN in order to unlock the device. These are lumped
    together because forensically, they are identical: they store their passwords
    the same way.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉苹果iOS的用户会认识到这个选项。它要求用户输入密码或PIN码才能解锁设备。它们被归为一类，因为在取证上它们是相同的：它们以相同的方式存储密码。
- en: Smart Locks
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能锁
- en: 'The **Smart Lock** is a term introduced in Android Lollipop, although the Face
    unlock option was previously available. They require a specific condition to unlock
    the device: a user''s face must be recognized, the user must be in a known location,
    or a specific other device must be nearby.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能锁**是安卓棒棒糖中引入的术语，尽管面部解锁选项以前就已经存在。它们需要特定条件才能解锁设备：用户的脸必须被识别，用户必须在已知位置，或者附近必须有特定的其他设备。'
- en: Trusted Face
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可信面部
- en: 'Face unlock works exactly as it sounds: it uses facial recognition to determine
    if the user has been previously been set up as a trusted user. Older versions
    of Face locks were easily fooled by pictures of a trusted user, though newer versions
    may require the user to blink in order to unlock the device.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 面部解锁的工作原理就像它的名字一样：它使用面部识别来确定用户是否已被设置为可信用户。旧版本的面部锁很容易被信任用户的照片欺骗，尽管新版本可能要求用户眨眼才能解锁设备。
- en: Trusted Location
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可信位置
- en: Trusted Location is available in Android Lollipop and is also commonly referred
    to as **geo-fencing**. If a user is in a location that has been marked as trusted
    (such as home or work), the device will not lock. There is no input required from
    the user, but the GPS must be enabled.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 可信位置在安卓棒棒糖中可用，通常被称为**地理围栏**。如果用户在被标记为可信的位置（比如家或工作地点）上，设备将不会锁定。用户无需输入，但必须启用GPS。
- en: Trusted Device
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可信设备
- en: Trusted Device is available in Android Lollipop and works via Bluetooth; if
    a device that has been setup as a trusted device is nearby, the lock screen will
    be disabled. This may be used with smart watches, vehicles that pair over Bluetooth,
    Bluetooth headsets, or any other Bluetooth-capable device.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可信设备在安卓棒棒糖中可用，通过蓝牙工作；如果附近有设置为可信设备的设备，锁屏将被禁用。这可以与智能手表、通过蓝牙配对的车辆、蓝牙耳机或任何其他蓝牙设备一起使用。
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All Smart Lock options require a Pattern/PIN/Password as a backup security method.
    This means we only have to learn how to bypass Patterns/PINs/Passwords in order
    to crack all of the security options.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有智能锁选项都需要图案/PIN/密码作为备用安全方法。这意味着我们只需要学会如何绕过图案/PIN/密码才能破解所有的安全选项。
- en: General bypass information
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过信息
- en: In all cases, bypassing the lock screen will require retrieving a file from
    the device. Pattern locks are stored as hash values at `/data/system/gesture.key`
    and PIN/Password locks are stored as hash values at `/data/system/password.key`.
    Additionally, the password.key hash is salted; the salt value is stored at `/data/data/com.android.providers.settings/databases/settings.db`
    prior to Android 4.4, and `/data/system/locksettings.db` on devices running Android
    4.4 and higher.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，绕过锁屏将需要从设备中检索文件。图案锁存储为哈希值，位于`/data/system/gesture.key`，PIN/密码锁存储为哈希值，位于`/data/system/password.key`。此外，password.key哈希值是加盐的；盐值存储在Android
    4.4之前的设备上的`/data/data/com.android.providers.settings/databases/settings.db`，以及运行Android
    4.4及更高版本的设备上的`/data/system/locksettings.db`。
- en: 'If the device is locked, how is an examiner supposed to access these files?
    Again, there is no magic solution that works every time, but there are some options,
    which are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备被锁定，调查员应该如何访问这些文件？同样，并没有一个可以每次都有效的魔法解决方案，但有一些选项，如下所示：
- en: ADB
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADB
- en: Requires root
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要root权限
- en: Requires **USB debugging**
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要**USB调试**
- en: Requires **Secure USB debugging** pairing (depending on OS version)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要**安全USB调试**配对（取决于操作系统版本）
- en: Booting into a custom recovery mode
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导到自定义恢复模式
- en: Does not require root (root will be given through the recovery image)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要root权限（通过恢复映像将获得root权限）
- en: Does not require **USB debugging** (accomplished via fastboot)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需USB调试（通过fastboot完成）
- en: Does not require **Secure USB debugging** (this is bypassed entirely)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要**安全USB调试**（这完全被绕过）
- en: Requires an unlocked bootloader
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要解锁的引导加载程序
- en: JTAG/Chip-off
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JTAG/Chip-off
- en: Highly advanced
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常先进
- en: Does not require any specific device settings or options
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要任何特定的设备设置或选项
- en: 'The files that need to be pulled to crack a PIN/password on devices prior to
    Android 4.4 are:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 需要拉取的文件以破解Android 4.4之前的设备上的PIN/密码为：
- en: /`data/system/password.key`
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /`data/system/password.key`
- en: '`/data/data/com.android.providers.settings/databases/settings.db`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/com.android.providers.settings/databases/settings.db`'
- en: 'The files that need to be pulled to crack a PIN/password on devices running
    Android 4.4 and higher are:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 需要拉取的文件以破解运行Android 4.4及更高版本设备上的PIN/密码为：
- en: '`/data/system/password.key`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/system/password.key`'
- en: '`/data/system/locksettings.db`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/system/locksettings.db`'
- en: 'Only one file needs to be pulled to crack a Pattern lock on all versions of
    Android:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要拉取一个文件即可破解所有版本的Android上的图案锁：
- en: '`/data/system/gesture.key`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/system/gesture.key`'
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not always necessary to actually crack the PIN or Password. They can also
    be bypassed by simply overwriting or deleting the files. However, this is changing
    the original evidence and may not be forensically valid in your jurisdiction.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是需要实际破解PIN或密码。它们也可以通过简单地覆盖或删除文件来绕过。然而，这会改变原始证据，可能在您的司法管辖区内并不具备法医学有效性。
- en: Note that the below cracking sections do NOT apply to Lollipop devices. The
    pattern locks are no longer unsalted, and as of the time of writing, no information
    has been published regarding how to recover the salt. However, the lock screen
    can still be bypassed by deleting the relevant files.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下面的破解部分不适用于棒棒糖设备。图案锁不再是未加盐的，截至撰写时，尚未发布有关如何恢复盐的信息。然而，仍然可以通过删除相关文件来绕过锁屏。
- en: Many tools exist that will bypass lock screens automatically; however, in this
    chapter, we will show the manual process to explain what these tools are doing
    in the background. A good tool that is free for law enforcement can be found at
    [https://andriller.com/](https://andriller.com/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多可以自动绕过锁屏的工具；然而，在本章中，我们将展示手动过程，以解释这些工具在后台的操作。一款适用于执法人员的好工具可以在[https://andriller.com/](https://andriller.com/)找到。
- en: Cracking an Android pattern lock
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解Android图案锁
- en: 'Now that we have `gesture.key`, which contains the pattern lock information,
    let''s take a look at the file contents:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`gesture.key`，其中包含图案锁信息，让我们来看看文件内容：
- en: '![Cracking an Android pattern lock](img/image00343.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android图案锁](img/image00343.jpeg)'
- en: Contents of gesture.key in a hex editor
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器中的gesture.key的内容
- en: The hex contents of the file are an unsalted SHA-1 hash of the swipe pattern.
    The fact that there are a limited number of possible patterns (there is a four
    digit minimum and a nine digit maximum because each number can only be used once),
    the simplest method for cracking this hash is a dictionary attack. An examiner
    can create a dictionary consisting of every possible pattern, but re-inventing
    the wheel isn't always necessary. CCL Forensics, based in the UK, provides a free
    Python script to create the hash dictionary. It can be downloaded at [http://www.cclgroupltd.com/product/android-pattern-lock-scripts/](http://www.cclgroupltd.com/product/android-pattern-lock-scripts/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的十六进制内容是滑动图案的未加盐SHA-1哈希。由于可能的图案数量有限（因为每个数字只能使用一次，最小为四位数，最大为九位数），破解此哈希的最简单方法是使用字典攻击。调查员可以创建一个包含每种可能图案的字典，但重新发明轮子并不总是必要的。总部位于英国的CCL
    Forensics提供了一个免费的Python脚本来创建哈希字典。它可以在[http://www.cclgroupltd.com/product/android-pattern-lock-scripts/](http://www.cclgroupltd.com/product/android-pattern-lock-scripts/)下载。
- en: 'The file is `GenerateAndroidGestureRainbowTable.py`. To run it, Python 3 must
    be installed on the examiner''s system. Python 3 can be downloaded at [https://www.python.org/downloads/](https://www.python.org/downloads/).
    Many forensics tools provide Python support or use it themselves, so an examiner
    may already have it installed. To execute the file, simply navigate to the directory
    containing it and run:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是`GenerateAndroidGestureRainbowTable.py`。要运行它，调查员的系统必须安装Python 3。Python 3可以在[https://www.python.org/downloads/](https://www.python.org/downloads/)下载。许多取证工具提供Python支持或自己使用它，因此调查员可能已经安装了它。要执行该文件，只需导航到包含它的目录并运行：
- en: '![Cracking an Android pattern lock](img/image00344.jpeg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android图案锁](img/image00344.jpeg)'
- en: The script may take a while to run, possibly between 20 and 30 minutes. Once
    it completes, there should now be a file called `AndroidLockScreenRainbow.sqlite`
    in the same directory as the `GenerateAndroidGestureRainbowTable.py` script.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可能需要一段时间才能运行，可能在20到30分钟之间。完成后，应该会在与`GenerateAndroidGestureRainbowTable.py`脚本相同的目录中有一个名为`AndroidLockScreenRainbow.sqlite`的文件。
- en: Now that we have a database containing the hash of every possible Android pattern,
    we simply need to look up the hash we found in the `gesture.key` file. This can
    be done manually with a SQLite viewer or even SQL commands. However, CCL Forensics
    also provides `Android_GestureFinder.py`, a script that will look up the hash
    in the database created previously.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含每个可能的安卓图案哈希的数据库，我们只需要在`gesture.key`文件中查找我们找到的哈希。这可以通过SQLite查看器或者SQL命令手动完成。然而，CCL
    Forensics还提供了`Android_GestureFinder.py`，这是一个脚本，将在之前创建的数据库中查找哈希。
- en: 'Unfortunately, this free script doesn''t quite suit our purposes. It is built
    to look at a physical dump binary and find a lock screen pattern; we already have
    the file containing the pattern. In order for the script to work properly, we
    will need to modify the code. `Android_GestureFinder.py` will need to be opened
    in some sort of a code-friendly editor; Notepad++, Sublime Text, or the Python
    IDLE GUI will all work. The following screenshots are from Sublime Text. Make
    a copy of the file, open the original and find line 85, which says:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个免费脚本并不完全符合我们的目的。它是用来查看物理转储二进制并找到锁定屏幕图案的；我们已经有包含图案的文件了。为了使脚本正常工作，我们需要修改代码。`Android_GestureFinder.py`需要在某种代码友好的编辑器中打开；Notepad++、Sublime
    Text或Python IDLE GUI都可以。以下截图来自Sublime Text。复制文件，打开原始文件，找到第85行，其中写着：
- en: '[PRE18]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This line needs to be commented out. To do so, just place a `#` sign at the
    beginning of the line:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行需要被注释掉。只需在行的开头放一个`#`号：
- en: '[PRE19]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Due to Python''s formatting, we will now undo indents in the lines following
    the statement we commented out. Lines 86, 89, 91, and 92 need to be moved to the
    left, so that they are in line with our commented out statement. Finally, line
    94 needs to move four backspaces to the left so that it is one tab indented from
    the line above it. The final code should look like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的格式，我们现在需要取消注释后面语句的缩进。第86、89、91和92行需要向左移动，使它们与我们注释掉的语句对齐。最后，第94行需要向左移动四个空格，使其与上面的行相齐。最终的代码应该是这样的：
- en: '![Cracking an Android pattern lock](img/image00345.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![破解安卓图案锁](img/image00345.jpeg)'
- en: Final code for Android_GestureFinder.py
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Android_GestureFinder.py的最终代码
- en: Note that line 85 now begins with `#`, lines 86, 89, 91, and 92 are in line
    with line 85, and line 94 is indented one tab to the right from the other lines
    (or four backspaces from its original location).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第85行现在以`#`开头，第86、89、91和92行与第85行对齐，第94行向右缩进一个制表符（或者从原来的位置向左移动四个空格）。
- en: 'Now the code is ready to run against our file; save the changes to `Android_GestureFinder.py`.
    Ensure that the `AndroidLockScreenRainbow.sqlite` and `gesture.key` files are
    in the same directory as `Android_GestureFinder.py`, and run the following script:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经准备好运行我们的文件；保存对`Android_GestureFinder.py`的更改。确保`AndroidLockScreenRainbow.sqlite`和`gesture.key`文件与`Android_GestureFinder.py`在同一个目录中，并运行以下脚本：
- en: '![Cracking an Android pattern lock](img/image00346.jpeg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![破解安卓图案锁](img/image00346.jpeg)'
- en: 'The output should return very quickly, as it is performing a simple lookup
    in the hash database. The `Offset` is negative, due to the fact that we used the
    script against a single file; if pointed at a binary physical dump, it would display
    the offset of the lock screen hash within the blob. The `Hash` column shows the
    hash value that was found, and the `Pattern` is the corresponding lock screen
    pattern:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该非常快，因为它只是在哈希数据库中进行简单的查找。`Offset`是负数，因为我们使用脚本对单个文件进行了操作；如果指向一个二进制物理转储，它将显示在blob中锁定屏幕哈希的偏移量。`Hash`列显示找到的哈希值，`Pattern`是相应的锁定屏幕图案：
- en: '![Cracking an Android pattern lock](img/image00347.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![破解安卓图案锁](img/image00347.jpeg)'
- en: Lock screen numbering
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定屏幕编号
- en: In this example, the pattern would begin at `0` in the top left corner, pass
    through **4** in the center, touch **8** in the bottom right corner, then cross
    the **7** in the bottom middle, and end at the **6** in the bottom left corner.
    This pattern can now be used on the device to bypass the lock screen.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，图案将从左上角的`0`开始，经过中间的**4**，触摸右下角的**8**，然后穿过底部中间的**7**，最后在左下角的**6**结束。现在可以在设备上使用这个图案来绕过锁定屏幕。
- en: 'If the script encountered errors, the file was likely not modified correctly.
    The following result would likely indicate that the script was not modified properly;
    perhaps the copy of the file was run instead of the modified version:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本遇到错误，文件很可能没有正确修改。以下结果很可能表明脚本没有正确修改；也许运行的是文件的副本而不是修改后的版本：
- en: '![Cracking an Android pattern lock](img/image00348.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![破解安卓图案锁](img/image00348.jpeg)'
- en: 'To resolve this error, verify that the script was modified as shown above.
    The following error is indicative of improper indentation:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个错误，验证脚本是否按照上面显示的方式进行了修改。以下错误表明缩进不正确：
- en: '![Cracking an Android pattern lock](img/image00349.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![破解安卓图案锁](img/image00349.jpeg)'
- en: To resolve this error, navigate to the specified line (86 in the example above),
    and ensure that the alignment is as shown in the preceding modified code.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个错误，导航到指定的行（在上面的例子中是第86行），确保对齐方式与前面修改后的代码一样。
- en: If the errors cannot be resolved, or if modifying the script is too daunting
    to an examiner, the hash value can always be looked up manually in the hash database.
    An excellent free SQL viewer, DB Browser for SQLite, can be found at [http://sourceforge.net/projects/sqlitebrowser/](http://sourceforge.net/projects/sqlitebrowser/).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误无法解决，或者修改脚本对于检查员来说太困难，哈希值总是可以在哈希数据库中手动查找。一个优秀的免费SQL查看器，DB Browser for SQLite，可以在[http://sourceforge.net/projects/sqlitebrowser/](http://sourceforge.net/projects/sqlitebrowser/)找到。
- en: 'Open AndroidLockScreenRainbow.sqlite with DB Browser for SQLite, and select
    the Browse Data tab. Then, simply type the hash value found in gesture.key into
    the search field in the hash column. Note that the characters in the database
    are lower case; the search field is case-sensitive:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DB Browser for SQLite打开AndroidLockScreenRainbow.sqlite，然后选择浏览数据选项卡。然后，只需将在gesture.key中找到的哈希值输入到哈希列的搜索字段中。请注意，数据库中的字符是小写的；搜索字段区分大小写：
- en: '![Cracking an Android pattern lock](img/image00350.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android图案锁](img/image00350.jpeg)'
- en: Contents of the AndroidLockScreenRainbow.sqlite file in SQLite Browser
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite浏览器中的AndroidLockScreenRainbow.sqlite文件的内容
- en: The results are the same as if the script had been run.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与运行脚本的结果相同。
- en: Cracking an Android PIN/Password
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解Android PIN/密码
- en: 'To crack the PIN/Password lock, we''ll need to take a look in the contents
    of the files pulled earlier. `Password.key` is very similar to `gesture.key`;
    it contains a hash of the password as shown in following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解PIN/密码锁，我们需要查看之前提取的文件的内容。`Password.key`与`gesture.key`非常相似；它包含密码的哈希值，如下面的截图所示：
- en: '![Cracking an Android PIN/Password](img/image00351.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android PIN/密码](img/image00351.jpeg)'
- en: Contents of password.key in a hex editor
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器中的password.key的内容
- en: However, this time the hash is salted. To have a chance at cracking it, the
    salt will have to be recovered. As noted above, its location will be dependent
    on the version of Android the device is running. If the device is running version
    4.3 or lower, it will be located in the `settings.db` file within the `secure`
    table. In 4.4 or higher, it will be in the `locksettings.db` within the `locksettings`
    table. The following example shows `locksettings.db`, but the process is identical
    for both.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次哈希是有盐的。为了有机会破解它，必须恢复盐。如上所述，其位置将取决于设备运行的Android版本。如果设备运行的是4.3或更低版本，则将位于`secure`表中的`settings.db`文件中。在4.4或更高版本中，它将位于`locksettings`表中的`locksettings.db`中。下面的示例显示了`locksettings.db`，但该过程对两者都是相同的。
- en: 'Within the database file, we''ll need to locate the `lockscreen.password_salt`
    key. This can be done in a SQL browser, or just by opening the file in a hex editor
    and searching. The salt value is highlighted as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库文件中，我们需要找到`lockscreen.password_salt`键。这可以在SQL浏览器中完成，或者只需在十六进制编辑器中打开文件并搜索。盐值如下所示：
- en: '![Cracking an Android PIN/Password](img/image00352.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android PIN/密码](img/image00352.jpeg)'
- en: Contents of locksettings.db in a hex editor
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器中的locksettings.db的内容
- en: For the Pattern lock, we were able to use a dictionary attack to quickly break
    the pattern, because there were a relatively small number of possibilities. With
    a salted hash, dictionary attacks are infeasible, so instead we will simply brute-force
    it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图案锁，我们能够使用字典攻击来快速破解图案，因为可能性相对较少。使用盐哈希，字典攻击是不可行的，所以我们将简单地进行暴力破解。
- en: Once again, CCL Forensics provides a useful Python script for this purpose.
    Other cracking tools, such as hashcat, could also be used. The CCL Forensics PIN/Password
    tool can be downloaded for free at [http://www.cclgroupltd.com/product/android-pin-password-lock-tool/](http://www.cclgroupltd.com/product/android-pin-password-lock-tool/).
    Two files will be downloaded, `BruteForceAndroidPin.py` and `RecoverAndroidPIN.py`.
    `RecoverAndroidPIN.py` is for locating the necessary files within a physical image;
    we won't be needing it for our purposes.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: CCL Forensics再次提供了一个有用的Python脚本。也可以使用其他破解工具，如hashcat。CCL Forensics PIN/密码工具可以免费下载[http://www.cclgroupltd.com/product/android-pin-password-lock-tool/](http://www.cclgroupltd.com/product/android-pin-password-lock-tool/)。将下载两个文件，`BruteForceAndroidPin.py`和`RecoverAndroidPIN.py`。`RecoverAndroidPIN.py`用于在物理图像中定位必要的文件；我们不需要它。
- en: 'The format for `BruteForceAndroidPIN.py` is:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`BruteForceAndroidPIN.py`的格式是：'
- en: '[PRE20]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `t` argument on the end is used to indicate the hash is of a password; it
    is not needed for cracking a PIN and would simply increase the time it takes to
    run.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`t`参数用于指示哈希是密码的哈希；对于破解PIN是不需要的，只会增加运行时间。
- en: 'The hash value shown above is from a PIN, so we simply need to fill in the
    `<hash>`, `<salt>`, and `<max code length>` fields:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 上面显示的哈希值来自PIN，所以我们只需要填写`<hash>`、`<salt>`和`<max code length>`字段：
- en: '![Cracking an Android PIN/Password](img/image00353.jpeg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![破解Android PIN/密码](img/image00353.jpeg)'
- en: The PIN from this example was `2587` as indicated in the output. It took less
    than a second for this PIN to crack, however longer PINs or even short passwords
    may take significantly longer.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的PIN为`2587`，如输出所示。这个PIN破解不到一秒，但更长的PIN甚至短密码可能需要更长的时间。
- en: Android SIM card extractions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android SIM卡提取
- en: 'Traditionally, SIM cards were used for transferring data between devices. In
    the past, SIM cards were used to store many different types of data, such as:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，SIM卡用于在设备之间传输数据。过去，SIM卡用于存储许多不同类型的数据，例如：
- en: User data
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据
- en: Contacts
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: SMS messages
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信
- en: Dialed calls
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拨打电话
- en: Network data
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络数据
- en: '**Integrated Circuit Card Identifier** (**ICCID**): Serial number of the SIM'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成电路卡标识符**（**ICCID**）：SIM卡的序列号'
- en: '**International Mobile Subscriber Identity** (**IMSI**): Identifier that ties
    the SIM to a specific user account'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国际移动用户识别码**（**IMSI**）：将SIM卡与特定用户账户绑定的标识符'
- en: '**MSISDN**: Phone number assigned to the SIM'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSISDN**：分配给SIM卡的电话号码'
- en: '**Location Area Identity** (**LAI**): Identifies the cell that a user is in'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置区域标识**（**LAI**）：标识用户所在的小区'
- en: '**Authentication Key** (**Ki**): Used to authenticate to the mobile network'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证密钥**（**Ki**）：用于在移动网络上进行身份验证'
- en: Various other network-specific information
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种特定于网络的信息
- en: With the rise in capacity of device storage, SD cards, and cloud backups, the
    necessity for storing data on a SIM card has decreased. As such, most modern smartphones
    typically do not store much, if any, user data on the SIM card. All network data
    listed above does still reside on the SIM, as a SIM is necessary to connect to
    all modern (4G) cellular networks.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 随着设备存储容量、SD卡和云备份的增加，将数据存储在SIM卡上的必要性已经减少。因此，大多数现代智能手机通常不会在SIM卡上存储太多用户数据，如果有的话。上述所有网络数据仍然存储在SIM卡上，因为SIM卡是连接所有现代（4G）蜂窝网络的必要条件。
- en: As with all Android devices, though there is no concrete stipulation that user
    data can't be stored on a SIM, it simply doesn't happen by default. Individual
    device manufacturers can easily decide to write user data to the SIM, and individual
    users can download applications to provide that functionality. This means that
    a device's SIM card should always be examined during a forensic examination. It
    is a very quick process, and should never be overlooked.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有Android设备一样，虽然没有明确规定用户数据不能存储在SIM卡上，但默认情况下并不会发生。个别设备制造商可以轻松决定将用户数据写入SIM卡，个别用户也可以下载应用程序来提供该功能。这意味着在取证调查期间应该始终检查设备的SIM卡。这是一个非常快速的过程，不应该被忽视。
- en: Acquiring SIM card data
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取SIM卡数据
- en: The SIM card should always be removed from the device and examined separately.
    While some tools claim to read the SIM card through the device interface, this
    may not recover deleted data or all data on the SIM; the only way for an examiner
    to be certain all data was acquired is to read the SIM through a standalone SIM
    card reader with a tool that has been tested and verified.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: SIM卡应该始终从设备中取出并单独检查。虽然有些工具声称可以通过设备接口读取SIM卡，但这可能无法恢复已删除的数据或SIM卡上的所有数据；取证人员确保已获取所有数据的唯一方法是使用经过测试和验证的独立SIM卡读卡器读取SIM卡。
- en: The location of the SIM will vary by device, but is typically either stored
    beneath the battery or in a tray located on the side of the device. Once the SIM
    is removed, it should be placed in a SIM card reader. There are hundreds of SIM
    card readers available in the marketplace, and all major mobile forensics tools
    come with an included reader that will work with their software. Often, the forensic
    tools will also support third-party SIM readers as well.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: SIM的位置会因设备而异，但通常存放在电池下方或设备侧面的托盘中。一旦SIM卡被取出，就应该放入SIM卡读卡器中。市场上有数百种SIM卡读卡器可供选择，所有主要的移动取证工具都配备了一个可与其软件配合使用的读卡器。通常，取证工具也会支持第三方SIM读卡器。
- en: There is a surprising lack of thorough, free SIM card reading softwares. Any
    software used should always be tested and validated on a SIM card that has been
    populated with known data prior to being used in an actual forensic investigation.
    Also, keep in mind that much of the free software available works for older 2G/3G
    SIMs, but may not work properly on a modern 4G SIM. We used the Mobiledit! Lite,
    a free version of Mobiledit!, for the following screenshots. It is available at
    [http://www.mobiledit.com/downloads](http://www.mobiledit.com/downloads).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，缺乏彻底的免费SIM卡读取软件。任何使用的软件都应该在实际取证调查之前经过测试和验证，以确保在SIM卡上填充了已知数据。此外，请记住，许多免费软件适用于旧的2G/3G
    SIM卡，但可能无法在现代4G SIM卡上正常工作。我们使用了Mobiledit! Lite，Mobiledit!的免费版本，用于以下截图。它可以在[http://www.mobiledit.com/downloads](http://www.mobiledit.com/downloads)上下载。
- en: The following screenshot shows a sample 4G SIM card extraction from an Android
    phone running version 4.4.4; note that nothing that could be considered user data
    was acquired, despite the SIM being used actively for over a year, though fields
    such as the ICCID, IMSI, and MSISDN (own phone number) could be useful for subpoenas/warrants
    or other aspects of an investigation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从运行版本为4.4.4的Android手机中提取的样本4G SIM卡；请注意，尽管SIM卡在过去一年中一直在使用，但并未获取到可以被视为用户数据的内容，尽管ICCID、IMSI和MSISDN（自己的电话号码）等字段可能对传票/令状或调查的其他方面有用。
- en: '![Acquiring SIM card data](img/image00354.jpeg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![获取SIM卡数据](img/image00354.jpeg)'
- en: SIM card extraction overview
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: SIM卡提取概述
- en: 'The following screenshot highlights SMS messages on the SIM card:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出显示了SIM卡上的短信：
- en: '![Acquiring SIM card data](img/image00355.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![获取SIM卡数据](img/image00355.jpeg)'
- en: 'The following image highlights the phonebook of the SIM card:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片突出显示了SIM卡的电话簿：
- en: '![Acquiring SIM card data](img/image00356.jpeg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![获取SIM卡数据](img/image00356.jpeg)'
- en: 'The following image highlights the phone number of the SIM card (also called
    the MSISDN):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片突出显示了SIM卡的电话号码（也称为MSISDN）：
- en: '![Acquiring SIM card data](img/image00357.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![获取SIM卡数据](img/image00357.jpeg)'
- en: SIM security
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SIM卡安全
- en: 'Due to the fact that SIM cards conform to established international standards,
    all SIM cards provide the same security functionality: a 4- to 8-digit PIN. Generally,
    this PIN must be set through a menu on the device. On Android devices, this setting
    is found at **Settings** | **Security** | **Set up SIM card lock**. The SIM PIN
    is completely independent of any lock screen security settings, and only has to
    be entered when the device boots. The SIM PIN only protects user data on the SIM;
    all network information is still recoverable even if the SIM is PIN locked.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SIM卡符合已建立的国际标准，所有SIM卡都提供相同的安全功能：4到8位的PIN码。通常，必须通过设备菜单设置此PIN码。在Android设备上，此设置位于**设置**
    | **安全** | **设置SIM卡锁**。SIM PIN完全独立于任何锁屏安全设置，只有在设备启动时才需要输入。SIM PIN仅保护SIM卡上的用户数据；即使SIM卡被PIN锁定，所有网络信息仍然是可恢复的。
- en: The SIM card will allow three attempts to enter the PIN. If one of these attempts
    is correct, the counter will reset. On the other hand, if all of these attempts
    are incorrect the SIM will enter **Personal Unblocking Key** (**PUK**) mode. The
    PUK is an 8-digit number assigned by the carrier, and is frequently found on documentation
    when the SIM is purchased. Bypassing a PUK is not possible with any commercial
    forensic software; because of this, an examiner should never attempt to enter
    the PIN on the device as the device will not indicate how many attempts remain
    before the PUK is activated. An examiner could unwittingly PUK-lock the SIM, and
    be unable to access the device. Forensic tools, however, will show how many attempts
    remain before the PUK is activated, as seen in the screenshots preceding.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: SIM卡将允许三次尝试输入PIN码。如果其中一次尝试正确，计数器将重置。另一方面，如果所有这些尝试都不正确，SIM卡将进入**个人解锁密钥**（**PUK**）模式。PUK是由运营商分配的8位数字，通常在购买SIM卡时的文件中找到。使用任何商用取证软件都无法绕过PUK；因此，检查员不应尝试在设备上输入PIN码，因为设备不会指示在激活PUK之前还有多少次尝试。检查员可能会无意中将SIM卡锁定，无法访问设备。然而，取证工具将显示在激活PUK之前还有多少次尝试，如前面的屏幕截图所示。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Common carrier defaults for SIM PINs are 0000 and 1234\. If 3 tries remain before
    activating the PUK, an examiner may successfully unlock the SIM with one of these
    defaults.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: SIM卡的通用载体默认的PIN码是0000和1234。如果在激活PUK之前还有3次尝试，检查员可以成功地使用这些默认值解锁SIM卡。
- en: Carriers frequently retain PUK keys when a SIM is issued. These may be available
    through a subpoena or warrant issued to the carrier.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 运营商经常在发放SIM卡时保留PUK密钥。这些密钥可以通过发给运营商的传票或令状获得。
- en: SIM cloning
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SIM卡克隆
- en: The SIM PIN itself provides almost no additional security, and can easily be
    bypassed through SIM cloning. SIM cloning is a feature provided in almost all
    commercial mobile forensic software, although the term cloning is somewhat misleading.
    SIM cloning, in the case of mobile forensics, is the process of copying the network
    data from a locked SIM onto a forensically sterile SIM that does not have the
    PIN activated. The phone will identify the cloned SIM based on this network data
    (typically the ICCID and IMSI) and think that it is the same SIM that was inserted
    previously, but this time there will be no SIM PIN. This cloned SIM will also
    be unable to access the cellular network, which makes it an effective solution
    similar to Airplane mode. Therefore, SIM cloning will allow an examiner to access
    the device, but the user data on the original SIM is still inaccessible as it
    remains protected by the PIN.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: SIM卡的PIN本身几乎没有提供额外的安全性，并且可以很容易地通过SIM卡克隆来绕过。SIM卡克隆是几乎所有商用移动取证软件提供的功能，尽管克隆这个术语有些误导。在移动取证的情况下，SIM卡克隆是将锁定的SIM卡上的网络数据复制到一个没有激活PIN的取证无菌SIM卡上的过程。手机将根据这些网络数据（通常是ICCID和IMSI）识别克隆的SIM卡，并认为它是之前插入的相同SIM卡，但这次没有SIM
    PIN。这个克隆的SIM卡也无法访问蜂窝网络，这使它成为类似飞行模式的有效解决方案。因此，SIM卡克隆将允许检查员访问设备，但原始SIM卡上的用户数据仍然无法访问，因为它仍然受到PIN的保护。
- en: We are unaware of any free software that performs forensic SIM cloning. However,
    it is supported by almost all commercial mobile forensic kits. These kits will
    typically include a SIM card reader, software to perform the clone, as well as
    multiple blank SIM cards for the cloning process.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道有任何免费软件可以进行取证SIM卡克隆。然而，几乎所有商用移动取证工具都支持这一功能。这些工具通常包括SIM卡读卡器、执行克隆的软件，以及多张空白SIM卡用于克隆过程。
- en: Issues and opportunities with Android Lollipop
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android棒棒糖的问题和机会
- en: As noted several times in this chapter, the recent unveiling of Android Lollipop
    Version 5.0 has introduced many strong security features, which of course creates
    complications for forensic examiners. It was initially announced that Android
    Lollipop devices would ship with full disk encryption by default, however, Google
    later retracted this requirement due to performance issues on many devices. Instead
    of a requirement, Google only strongly suggests that full disk encryption be enabled
    when the user first creates an account. Google has also hinted that this will
    be a requirement in future OS versions, more information can be found in section
    **9.9** at [http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章中多次提到的那样，最近发布的Android棒棒糖5.0版本引入了许多强大的安全功能，这当然给取证检查员带来了复杂性。最初宣布Android棒棒糖设备将默认启用全盘加密，然而，由于许多设备上的性能问题，谷歌后来撤回了这一要求。谷歌只是强烈建议用户在首次创建帐户时启用全盘加密。谷歌还暗示这将成为未来操作系统版本的要求，更多信息可以在[http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf)的第9.9节找到。
- en: Devices with full disk encryption enabled make bypassing locked devices all
    but impossible, because even if the key files could be recovered, they would be
    encrypted; though surely the commercial tool manufacturers will eventually catch
    up. At the time of this writing, there is no known method for bypassing a locked,
    encrypted Lollipop device, unless it has **USB debugging** enabled and previously
    remembered a computer's RSA key to bypass **Secure USB debugging**. In this case,
    the `adbkey` and `adbkey.pub` files can be pulled from the suspect's computer
    and placed on an examination machine; the device will then think it is communicating
    with a known, approved computer. The `adbkey` and `adbkey.pub` files can be found
    at `C:\Users\<username>\.android` on Windows computers and `/Users/<username>/.android`
    on Apple computers.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 启用完整磁盘加密的设备几乎不可能绕过锁定的设备，因为即使可以恢复密钥文件，它们也会被加密；尽管商业工具制造商最终肯定会赶上。在撰写本文时，没有已知的方法可以绕过锁定的、加密的棒棒糖设备，除非它已启用**USB调试**并且先前记住了计算机的RSA密钥以绕过**安全USB调试**。在这种情况下，可以从嫌疑人的计算机中拉取`adbkey`和`adbkey.pub`文件，并将其放在检查机器上；然后设备将认为它正在与已知的、批准的计算机通信。`adbkey`和`adbkey.pub`文件可以在Windows计算机的`C:\Users\<username>\.android`和苹果计算机的`/Users/<username>/.android`中找到。
- en: 'There is one significant advantage for examiners performing Lollipop forensics:
    the Smart Locks mentioned earlier in this chapter. Smart Locks allow a user to
    set conditions that, if met, will leave the device unlocked without the need to
    enter the password even once. If the examination is performed at a Trusted Location
    that has been enabled, the examiner will not need to bypass the lock. The same
    is true if a Trusted Device is nearby and turned on while the device is being
    examined. However, there is no indication on the device that a trusted device
    is being used; the device just appears to not have a lock screen. Thus, securing
    all digital evidence from a scene becomes even more critical. Devices that would
    have previously been overlooked, such as Bluetooth headsets, may turn out to be
    the key that gets the examiner past a locked device. It is becoming increasingly
    common for devices to be paired with vehicles, so an examiner may have to perform
    an extraction while sitting in the suspect''s vehicle! The additional security
    of Lollipop means that examiners may have to get more creative with the forensic
    process.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进行棒棒糖取证的检查员来说，有一个重要的优势：本章前面提到的智能锁。智能锁允许用户设置条件，如果满足条件，设备将无需输入密码即可解锁。如果在启用的受信任位置进行检查，检查员将不需要绕过锁定。如果在检查设备时附近有一个已启用的受信任设备，情况也是如此。但是，设备上没有任何指示表明正在使用受信任的设备；设备看起来只是没有锁屏。因此，从现场保护所有数字证据变得更加关键。以前可能被忽视的设备，如蓝牙耳机，可能会成为让检查员绕过锁定设备的关键。越来越普遍的是设备与车辆配对，因此检查员可能不得不在嫌疑人的车辆中进行提取！棒棒糖的额外安全性意味着检查员可能需要在取证过程中变得更有创造力。
- en: Android Lollipop also brings multi-user support to all devices, which was previously
    limited to tablets. On a device with multiple accounts, data for all users is
    still found in the `/data` partition, but resides in a slightly different location.
    If multiple accounts are setup on the device, the app data directory for each
    account can be found in `/data/user`. Each user will have a unique number assigned;
    `0` is the first account setup on the device. The `/data/user/0` directory is
    actually a symbolic link to `/data/data`. The second account was in the `10` directory,
    which directly contained all application data for the second user. Each user added
    is stored in a directory incremented by `10`; i.e. the third user is in `/data/user/20`,
    the fourth user is in `/data/user/30`, and so on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Android棒棒糖还为所有设备带来了多用户支持，这在以前仅限于平板电脑。在具有多个帐户的设备上，所有用户的数据仍然位于`/data`分区中，但位于稍有不同的位置。如果在设备上设置了多个帐户，则每个帐户的应用数据目录可以在`/data/user`中找到。每个用户都将被分配一个唯一的编号；`0`是设备上设置的第一个帐户。`/data/user/0`目录实际上是一个符号链接到`/data/data`。第二个帐户位于`10`目录中，该目录直接包含了第二个用户的所有应用程序数据。每添加一个用户，都会存储在以`10`递增的目录中；即第三个用户在`/data/user/20`中，第四个用户在`/data/user/30`中，依此类推。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter has covered many topics related to logical extractions of Android
    devices. As a recap, the various methods and their requirements are as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了与Android设备的逻辑提取相关的许多主题。简而言之，各种方法及其要求如下：
- en: '| Method | Requirements |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 要求 |'
- en: '| --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ADB pull |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| ADB拉取 |'
- en: '**USB debugging** enabled'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB调试**已启用'
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.2+上绕过**安全USB调试**
- en: Root access to obtain user data
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户数据的根访问权限
- en: '|'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ADB pull from Recovery Mode |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 从恢复模式下的ADB拉取 |'
- en: Must be a custom recovery to enable ADB access
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须是自定义恢复以启用ADB访问
- en: Root access to obtain user data
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户数据的根访问权限
- en: '|'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Fastboot to boot from custom recovery image |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 从自定义恢复映像中启动的Fastboot |'
- en: Unlocked bootloader
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁的引导加载程序
- en: Boot image for device
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的引导镜像
- en: '|'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ADB backup |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| ADB备份 |'
- en: '**USB debugging** enabled'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB调试**已启用'
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.2+上绕过**安全USB调试**
- en: Must be done from a running device (not Recovery mode)
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在运行设备上完成（而不是恢复模式）
- en: '|'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ADB dumpsys |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| ADB dumpsys |'
- en: '**USB debugging** enabled'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USB调试**已启用'
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2.2+上绕过**安全USB调试**
- en: Must be done from a running device (not recovery mode)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在运行设备上完成（而不是恢复模式）
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| SIM card extraction |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| SIM卡提取 |'
- en: None, should be done independent of device
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无，应独立于设备完成
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Additionally, valuable user data can be recovered from the SD card, which will
    be covered in [Chapter 5](part0040.xhtml "Chapter 5. Extracting Data Physically
    from Android Devices"), *Extracting Data Physically from Android Devices*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有价值的用户数据可以从SD卡中恢复，这将在[第5章](part0040.xhtml "第5章。从Android设备物理提取数据")中进行介绍，*从Android设备物理提取数据*。
- en: If a screen is locked, an examiner can pull the key files using the methods
    listed above and crack them in order to bypass it.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕被锁定，检查员可以使用上述列出的方法提取关键文件并破解它们，以绕过锁定。
- en: 'There is a lot of data in this chapter. To help simplify it somewhat, a suggested
    *best practices* flow chart is shown as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节有大量的数据。为了帮助简化它，下面展示了一个建议的*最佳实践*流程图：
- en: .
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '![Summary](img/image00358.jpeg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![摘要](img/image00358.jpeg)'
- en: Android Forensics Flow Chart
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓取证流程图
