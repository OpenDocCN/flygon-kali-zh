- en: '*Chapter 3*: Getting Started with Danfo.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：开始使用Danfo.js
- en: The **Python** data science and machine learning ecosystem is very mature when
    compared to other programming languages, but when it comes to data presentation
    and the client side, **JavaScript** reigns supreme. From its robust data presentation
    tools to its ready availability in the browser to ease of setup, JavaScript is
    always recommended.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言相比，**Python**数据科学和机器学习生态系统非常成熟，但在数据呈现和客户端方面，**JavaScript**占据主导地位。从其强大的数据呈现工具到其在浏览器中的易用性，JavaScript总是被推荐的。
- en: In this chapter, we will introduce you to the Danfo.js library, thus giving
    you an efficient tool for data analysis and manipulation in JavaScript. We'll
    cover the core data structures of Danfo.js – DataFrames and Series. We'll show
    you how to load different types of files, such as JSON, Excel, and CSV, into Danfo.js,
    and finally, you'll learn about some important functions available in Danfo.js
    that make data analysis and preprocessing in JavaScript easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍Danfo.js库，为您提供JavaScript中高效的数据分析和操作工具。我们将介绍Danfo.js的核心数据结构——DataFrames和Series。我们将向您展示如何将不同类型的文件（如JSON、Excel和CSV）加载到Danfo.js中，最后，您将了解一些在JavaScript中使数据分析和预处理更容易的重要函数。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why you need Danfo.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要Danfo.js
- en: Installing Danfo.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Danfo.js
- en: Introducing Series and DataFrames
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Series和DataFrames
- en: Essential functions and methods in Danfo.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Danfo.js中的重要函数和方法
- en: Data loading and working with different file formats
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据加载和处理不同的文件格式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow along with this chapter, you should have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章，您应该具备以下条件：
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器，如Chrome、Safari、Opera或Firefox
- en: '**Node.js**, Danfo.js, and **Dnotebook** installed on your system'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的系统上安装了Node.js、Danfo.js和Dnotebook
- en: 'The code for this chapter is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在这里可用：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter03)。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For most of the code snippets, you can make use of Dnotebook available online
    here: [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数代码片段，您可以使用在线提供的Dnotebook：[https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/)。
- en: Why you need Danfo.js
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你需要Danfo.js
- en: To successfully bring a machine learning project written in Python to the web,
    there are a lot of processes and tasks to be carried out, things such as model
    deployment, creating API routes with frameworks such as **Flask**, **FastAPI**,
    or **Django**, and then using JavaScript to send HTTP requests to the model. You
    can clearly observe that the process involves a lot of JavaScript. It would be
    super awesome if we could perform all these processes in just JavaScript, wouldn't
    it? Well, the good news is that we can.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地将用Python编写的机器学习项目带到Web上，需要执行许多过程和任务，例如模型部署、使用Flask、FastAPI或Django等框架创建API路由，然后使用JavaScript向模型发送HTTP请求。您可以清楚地观察到该过程涉及大量JavaScript。如果我们能够仅使用JavaScript执行所有这些过程，那将是非常棒的，不是吗？好消息是我们可以。
- en: Over the past years, browsers have steadily increased in computational power
    and can support highly intensive computation, hence giving JavaScript the edge
    to challenge Python when it comes to data-intensive tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，浏览器的计算能力稳步增加，并且可以支持高强度的计算，因此在处理数据密集型任务时，JavaScript具有挑战Python的优势。
- en: With the help of Node.js, JavaScript has access to the GPU available on local
    computers, giving us the ability to undergo a full-stack machine learning project
    using Node.js for the backend and pure JavaScript for the frontend.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 借助Node.js，JavaScript可以访问本地计算机上可用的GPU，使我们能够使用Node.js进行全栈机器学习项目，并使用纯JavaScript进行前端开发。
- en: One of the benefits of using JavaScript is that inference can easily be done
    on the client side, hence data does not have to leave the client side to the server.
    Also, JavaScript gives our program cross-platform support and with the help of
    a **Content Delivery Network** (**CDN**), all the JavaScript packages needed for
    app development can easily be used without installing them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript的好处之一是可以轻松地在客户端进行推断，因此数据不必离开客户端到服务器。此外，JavaScript使我们的程序具有跨平台支持，并且借助内容传送网络（CDN），所有用于应用程序开发的JavaScript包都可以轻松使用，而无需安装它们。
- en: With the introduction of tools such as **TensorFlow.js** and Danfo.js, we see
    more support for JavaScript in the data science and machine learning ecosystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TensorFlow.js和Danfo.js等工具的引入，我们看到JavaScript在数据科学和机器学习生态系统中得到了更多支持。
- en: Imagine a powerful data processing library such as **Python pandas** ([https://pandas.pydata.org/](https://pandas.pydata.org/))
    on the web, and think about the capability of infusing such a tool into popular
    modern frameworks in JavaScript such as **Vue** or **React**; the possibilities
    are endless. This is the power Danfo.js brings to the web.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在Web上拥有强大的数据处理库，比如Python pandas（[https://pandas.pydata.org/](https://pandas.pydata.org/)），并考虑将这样的工具融入JavaScript中流行的现代框架，如Vue或React；可能性是无限的。这就是Danfo.js带给Web的力量。
- en: There have been various attempts by JavaScript developers to bring the data
    processing capabilities of pandas to the web. Hence, we have libraries such as
    `pandas-js`, `dataframe-js`, `data-forge`, and `jsdataframe`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发人员已经做出了各种尝试，将pandas的数据处理能力带到Web上。因此，我们有诸如`pandas-js`、`dataframe-js`、`data-forge`和`jsdataframe`等库。
- en: The need to port Python pandas to JavaScript arose mainly because there was
    a need to perform data preprocessing and manipulation tasks in the browser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python pandas移植到JavaScript的需求主要是因为需要在浏览器中执行数据预处理和操作任务。
- en: 'This is a thread on **Stack Overflow** ([https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646](https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646))
    that gives a detailed overview of different tools for data preprocessing and manipulation
    in JavaScript, but most of these tools failed because of the following two reasons
    as explained in the thread:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于 **Stack Overflow** 的讨论串 ([https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646](https://stackoverflow.com/questions/30610675/python-pandas-equivalent-in-JavaScript/43825646))，其中详细介绍了
    JavaScript 中用于数据预处理和操作的不同工具，但大多数这些工具因为以下两个原因而失败，如串中所述：
- en: Lack of collaboration into a single library (lots of libraries trying to do
    different things)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏将多个库合并为单个库的协作（许多库试图执行不同的任务）
- en: 'Most of the libraries not having the main features of pandas, as shown: [https://github.com/pandas-dev/pandas#main-features](https://github.com/pandas-dev/pandas#main-features
    )'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数库都没有 pandas 的主要功能，如：[https://github.com/pandas-dev/pandas#main-features](https://github.com/pandas-dev/pandas#main-features)
- en: Besides the two reasons listed here, another issue we have observed when trying
    most of the existing tools is the lack of a good user experience like Python's
    pandas. pandas is very popular, and since most of the tools created in JavaScript
    mimic pandas, it is better to have a user experience that is quite similar to
    pandas.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里列出的两个原因，我们在尝试大多数现有工具时观察到的另一个问题是缺乏像 Python 的 pandas 那样良好的用户体验。pandas 非常受欢迎，由于大多数使用
    JavaScript 创建的工具都模仿 pandas，因此最好拥有与 pandas 相当相似的用户体验。
- en: Danfo.js was built to cover the gaps and issues faced by existing data processing
    libraries. The API has been carefully modeled after the pandas API, and as such
    provides a similar experience for people coming from a Python background, while
    at the same time providing a simple and intuitive API for JavaScript developers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js 的构建是为了弥补现有数据处理库所面临的差距和问题。API 经过精心设计，模仿了 pandas API，并且为从 Python 背景而来的人提供了类似的体验，同时也为
    JavaScript 开发人员提供了简单直观的 API。
- en: Besides a simple and familiar API, Danfo.js is faster thanks to TensorFlow.js,
    which powers all mathematical operations. Danfo.js has gained popularity in the
    JavaScript data science community with over 1,500 stars on GitHub in less than
    a year, as well as acceptance by the TensorFlow.js team at Google ([https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html](https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html)).
    Also, it is worth mentioning that Danfo.js is well maintained and under constant
    development thanks to active contributors, who ensure it is up to date and stable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单且熟悉的 API 外，由于 TensorFlow.js 的支持，Danfo.js 更快。Danfo.js 在 JavaScript 数据科学社区中备受欢迎，在不到一年的时间里在
    GitHub 上获得了超过 1500 颗星，同时也得到了 Google 的 TensorFlow.js 团队的认可 ([https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html](https://blog.tensorflow.org/2020/08/introducing-danfo-js-pandas-like-library-in-JavaScript.html))。另外，值得一提的是
    Danfo.js 得到了积极贡献者的大力维护和不断发展，他们确保其始终保持最新和稳定。
- en: Apart from the preceding reasons, there are many more reasons why we decided
    to write this book on Danfo.js so as to give you the required skills and knowledge
    to perform data manipulation tasks in JavaScript. In the next section, we will
    start by learning how to install and import Danfo.js both in the browser and also
    in a Node.js environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述原因，我们决定撰写这本关于 Danfo.js 的书籍还有许多其他原因，以便为您提供在 JavaScript 中执行数据操作任务所需的技能和知识。在下一节中，我们将首先学习如何在浏览器中安装和导入
    Danfo.js，同时也在 Node.js 环境中进行。
- en: Installing Danfo.js
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Danfo.js
- en: 'Danfo.js is readily available in both the browser and a Node.js environment.
    To use Danfo.js in the browser, you can add the `script` tag to the header of
    your `HTML` file as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js 在浏览器和 Node.js 环境中都可以轻松获取。要在浏览器中使用 Danfo.js，可以将 `script` 标签添加到 `HTML`
    文件的头部，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the time of writing, the latest version of Danfo.js for a browser environment
    is 0.2.7\. This will most likely have changed, but rest assured that all code
    and snippets used in this book will work in future versions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，浏览器环境中 Danfo.js 的最新版本为 0.2.7。这很可能已经改变，但请放心，本书中使用的所有代码和片段将在未来版本中起作用。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To install or get the latest version of Danfo.js, you can check the release
    page here, [https://danfo.jsdata.org/release-notes](https://danfo.jsdata.org/release-notes),
    in the official documentation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装或获取 Danfo.js 的最新版本，可以在官方文档的发布页面 [https://danfo.jsdata.org/release-notes](https://danfo.jsdata.org/release-notes)
    中查看。
- en: 'In a Node.js environment, Danfo.js can be installed using `yarn`, as shown
    in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 环境中，可以使用 `yarn` 安装 Danfo.js，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once installed, you can import Danfo.js using any of the following commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以使用以下任一命令导入 Danfo.js：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For practice, you can always make use of [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/),
    as discussed in the previous chapter. With this, you have online access to make
    use of Dnotebook for fast experimentation. To make use of the latest version of
    Danfo.js in Dnotebook, you can always use the `load_package` function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，您可以始终使用 [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/)，如前一章所述。有了这个，您可以在线访问
    Dnotebook 进行快速实验。要在 Dnotebook 中使用 Danfo.js 的最新版本，您可以始终使用 `load_package` 函数。
- en: The browser and Node.js versions of Danfo.js follow the same API design. The
    major difference is that in the browser, Danfo.js is added to the global scope
    under the name `dfd`. Hence, the `dfd` variable is available to all JavaScript
    or HTML files.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js 的浏览器和 Node.js 版本遵循相同的 API 设计。主要区别在于在浏览器中，Danfo.js 被添加到全局范围下的名称 `dfd`。因此，`dfd`
    变量可用于所有 JavaScript 或 HTML 文件。
- en: Now that we are done with the installation, we'll move on to the next section,
    where we discuss the major data structures and methods available in Danfo.js and
    Series.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们安装完成后，我们将继续下一节，讨论 Danfo.js 和 Series 中提供的主要数据结构和方法。
- en: Introducing Series and DataFrames
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Series 和 DataFrames
- en: Danfo.js exposes two main data structures, Series and DataFrames, to which all
    data manipulation can be done easily. DataFrames and Series provide a general
    representation for different types of data, hence the same data handling process
    can be applied to datasets with different formats.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js 公开了两种主要数据结构，Series 和 DataFrames，可以轻松进行所有数据操作。DataFrames 和 Series 为不同类型的数据提供了通用表示，因此可以将相同的数据处理过程应用于具有不同格式的数据集。
- en: In this section, we will look at different means of creating Series and DataFrames.
    We will see how to handle data in DataFrame and Series format. We will also look
    into different DataFrame and Series methods for data handling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到创建 Series 和 DataFrames 的不同方法。我们将了解如何处理 DataFrame 和 Series 格式的数据。我们还将研究不同的
    DataFrame 和 Series 方法来处理数据。
- en: We will start this section by looking at how to handle data in a Series data
    structure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从处理 Series 数据结构的数据开始本节。
- en: Series
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Series
- en: A Series provides an entry point to handling one-dimensional data, such as a
    single array with a sequence of values of the same data type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Series 提供了处理一维数据的入口，例如具有相同数据类型的一系列值的单个数组。
- en: 'In this section, we will get familiar with Series data structures with the
    following Series methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将熟悉以下 Series 方法的 Series 数据结构：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code gives us the following output table:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出表：
- en: '![Figure 3.1 – Series table'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Series 表'
- en: '](img/B17076_3_1.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_1.jpg)'
- en: Figure 3.1 – Series table
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Series 表
- en: 'In the preceding code snippet, we make use of `table()` to print the Series
    table. This is because we are making use of Dnotebook for most of the code in
    this chapter. To print DataFrames or Series in a browser or Node.js console, you
    can always call `print()` as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用 `table()` 来打印 Series 表。这是因为我们在本章的大部分代码中都在使用 Dnotebook。要在浏览器或 Node.js
    控制台中打印 DataFrames 或 Series，可以始终调用 `print()` 如下：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In subsequent code, we will always make use of the `table()` function, which
    allows us to print the DataFrame on the browser web page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的代码中，我们将始终使用 `table()` 函数，这允许我们在浏览器网页上打印 DataFrame。
- en: 'The `.index` attribute: By default, the column name for a Series table is always
    0 unless it is specified. Also note that the index of a Series table ranges from
    `0` to `n – 1` of the data, where `n` is the length of the data. The index can
    also be obtained via the following:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.index` 属性: 默认情况下，Series 表的列名始终为 0，除非另有指定。还要注意，Series 表的索引范围为数据的 `0` 到 `n
    – 1`，其中 `n` 是数据的长度。索引也可以通过以下方式获取：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`.dtype` and `astype()`: Sometimes the data passed into a Series might not
    be homogeneous, and may contain fields with mixed data types, as follows:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dtype` 和 `astype()`: 有时传入 Series 的数据可能不是同质的，并且可能包含混合数据类型的字段，如下所示：'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`dtype` outputted `string`, whereas the data is of a different data type, hence
    we can always change `dtype` as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype` 输出了 `string`，而数据是不同的数据类型，因此我们可以始终像以下代码一样更改 `dtype`：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code changes the data type of the Series, but it does not actually
    cast the strings in the data to `int32`. Hence, this will throw an error if we
    perform a numerical operation on the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码更改了 Series 的数据类型，但实际上并没有将数据中的字符串转换为 `int32`。因此，如果对数据执行数值操作，将会引发错误。
- en: 'The `.tensor` attribute: The data in a Series can be obtained in two main formats
    – as JavaScript `series.tensor` is a valid TensorFlow.js tensor, and as such all
    supported tensor operations can be performed on it. For example, in the following
    code, we call the exponential function on the Series `tensor` object:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.tensor` 属性: Series 中的数据可以以两种主要格式获取 – 作为 JavaScript `series.tensor` 是一个有效的
    TensorFlow.js 张量，因此可以对其执行所有支持的张量操作。例如，在以下代码中，我们对 Series `tensor` 对象调用指数函数：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we were able to print out the exponential of the Series
    data because we had access to the underlying tensor. The `arraySync` method returns
    the array format of a tensor. Let's look at the `set_index()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们能够打印出 Series 数据的指数，因为我们可以访问底层张量。`arraySync` 方法返回张量的数组格式。让我们来看一下 `set_index()`
    方法。
- en: 'The `set_index()` method: The index can be specified when creating a Series
    data structure. We demonstrate this in the following code:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_index()` 方法: 在创建 Series 数据结构时可以指定索引。我们在以下代码中演示了这一点：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This sets the index of the Series and replaces the default numerical index
    as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置 Series 的索引并替换默认的数值索引，如下所示：
- en: '![Figure 3.2 – Series with a named index'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 具有命名索引的 Series'
- en: '](img/B17076_3_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_2.jpg)'
- en: Figure 3.2 – Series with a named index
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 具有命名索引的 Series
- en: 'We can always change the default index value of a Series, as shown in the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终更改 Series 的默认索引值，如以下代码所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`sdata.set_index()` resets the index and returns a new Series as shown in *Figure
    3.2* (*left*), without mutating the original Series. We can set `set_index()`
    to actually update the index of the original Series and not return a new Series,
    by setting the `inplace` key to `true`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdata.set_index()` 重置索引并返回一个新的 Series，如 *图3.2* (*左*) 所示，而不会改变原始 Series。我们可以将
    `set_index()` 设置为实际更新原始 Series 的索引并且不返回新的 Series，方法是将 `inplace` 键设置为 `true`：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now look at the `.apply()` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 `.apply()` 方法。
- en: 'The `.apply()` method: Since a Series is a single-dimensional array, it is
    easy to apply operations similar to how it would be done if working with an array
    in JavaScript. Series have a method called `.apply` to which you can apply any
    function on each value of the Series data:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.apply()` 方法: 由于 Series 是单维数组，因此可以轻松应用类似于在 JavaScript 中处理数组的操作。Series 有一个名为
    `.apply` 的方法，可以在 Series 数据的每个值上应用任何函数：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This converts each of the strings in the Series to uppercase by applying `x.toLocaleUpperCase()`
    on each of the values. The following figure shows the table output before and
    after applying `x.toLocaleUpperCase` on the Series data:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过在每个值上应用 `x.toLocaleUpperCase()` 将 Series 中的每个字符串转换为大写。下图显示了在应用 `x.toLocaleUpperCase`
    之前和之后的表输出：
- en: '![Figure 3.3 – Left: setting the index to string. Right: using apply to convert
    all strings to uppercase'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 左：将索引设置为字符串。右：使用apply将所有字符串转换为大写'
- en: '](img/B17076_3_3.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_3.jpg)'
- en: 'Figure 3.3 – Left: setting the index to string. Right: using apply to convert
    all strings to uppercase'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 左：将索引设置为字符串。右：使用apply将所有字符串转换为大写
- en: 'The `.apply` method is also handy for performing numerical operations on each
    value of the Series data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply`方法也非常适用于对Series数据的每个值执行数值操作：'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We used the `.apply` function to find the log of each value in the Series. The
    same can also be done for all other mathematical operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.apply`函数找到了Series中每个值的对数。对于所有其他数学运算也是一样的。
- en: 'The preceding code outputs the following table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下表格：
- en: '![Figure 3.4 – Applying math ops (Math.log) to each value of a Series'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 对Series的每个值应用数学运算（Math.log）'
- en: '](img/B17076_3_4.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_4.jpg)'
- en: Figure 3.4 – Applying math ops (Math.log) to each value of a Series
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 对Series的每个值应用数学运算（Math.log）
- en: 'The Series data structure also contains the `.map` method, similar to `.apply`.
    This method maps each value of the Series to another value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Series数据结构还包含`.map`方法，类似于`.apply`。该方法将Series的每个值映射到另一个值：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The map accepts objects and functions as parameters. In the preceding code,
    we created an object called `map` that contains the values in the Series as keys
    and the values that each key should be mapped to.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: map接受对象和函数作为参数。在上述代码中，我们创建了一个名为`map`的对象，其中包含Series中的值作为键，以及每个键应映射到的值。
- en: 'The preceding code outputs the following table:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下表格：
- en: '![Figure 3.5 – Using map on Series values'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 - 在Series值上使用map'
- en: '](img/B17076_3_5.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_5.jpg)'
- en: Figure 3.5 – Using map on Series values
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 在Series值上使用map
- en: Next, we will look at the `.isna()` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下`.isna()`方法。
- en: 'The `.isna()` method: The data we''ve been passing into the Series so far seems
    to be okay and contains no missing values or undefined values, but when working
    with real data, we will always have `NaN` or undefined values. We can always check
    whether such values exist in our Series:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isna()`方法：到目前为止，我们传递到Series中的数据似乎都没有问题，不包含缺失值或未定义值，但在处理真实数据时，我们总会有`NaN`或未定义的值。我们可以随时检查我们的Series中是否存在这样的值：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a test, we create a Series containing `NaN` and an undefined variable. We
    obtain the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，我们创建了一个包含`NaN`和一个未定义变量的Series。我们得到以下输出：
- en: '![Figure 3.6 – Table containing a Series frame with NaN values'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 包含NaN值的Series框架的表'
- en: '](img/B17076_3_6.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_6.jpg)'
- en: Figure 3.6 – Table containing a Series frame with NaN values
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 包含NaN值的Series框架的表
- en: 'Let''s check the rows containing `NaN` and undefined values; for each of these
    rows, we output `true`, and if not, they are represented with `false` as shown
    in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查包含`NaN`和未定义值的行；对于这些行中的每一行，我们输出`true`，如果没有，则显示为`false`，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We obtain the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![Figure 3.7 – The isna table for the Series data'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 - Series数据的isna表'
- en: '](img/B17076_3_7.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_7.jpg)'
- en: Figure 3.7 – The isna table for the Series data
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - Series数据的isna表
- en: The `.add()` method is as follows.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`.add()`方法如下。'
- en: 'The `.add()` method: The Series data structure also supports element-wise operations
    (such as addition, subtraction, multiplication, and division) between Series,
    and after this operation, the indexes are automatically aligned:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.add()`方法：Series数据结构还支持Series之间的逐元素操作（如加法、减法、乘法和除法），在此操作之后，索引会自动对齐：'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下输出：
- en: '![Figure 3.8 – Adding two Series'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 添加两个Series
- en: '](img/B17076_3_8.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_8.jpg)'
- en: Figure 3.8 – Adding two Series
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 添加两个Series
- en: The preceding code snippet adds the `sf2` Series to `sf1`, and each of the values
    is added element-wise, per row.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将`sf2` Series添加到`sf1`，并且每个值都是按元素逐行添加的。
- en: 'Note also that a single value can be passed to `sf1.add`, which will add a
    constant value to each of the elements in the `sf1` Series:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，可以将单个值传递给`sf1.add`，这将向`sf1` Series中的每个元素添加一个常量值：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output of the preceding code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 3.9 – Adding a constant value to Series elements'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 向Series元素添加常量值'
- en: '](img/B17076_3_9.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_9.jpg)'
- en: Figure 3.9 – Adding a constant value to Series elements
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 向Series元素添加常量值
- en: The operation shown previously applies for all other mathematical operations
    as well as Series.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的操作也适用于所有其他数学运算以及Series。
- en: In the next sub-section, we'll look into the operation of DataFrames, how to
    create a DataFrame, and how to handle data with DataFrame operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将研究数据框的操作，如何创建数据框以及如何使用数据框操作处理数据。
- en: DataFrames
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框
- en: A DataFrame represents a collection of Series, although unlike Series, it is
    basically a two-dimensional representation of data (although it can also represent
    higher dimensions) containing multiple columns and rows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框表示一组Series，尽管与Series不同，它基本上是数据的二维表示（尽管它也可以表示更高的维度），包含多列和多行。
- en: 'A DataFrame can basically be constructed using JavaScript objects, as shown
    in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框基本上可以使用JavaScript对象构建，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting DataFrame should look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数据框应如下所示：
- en: '![Figure 3.10 – DataFrame table'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 - 数据框表'
- en: '](img/B17076_3_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_10.jpg)'
- en: Figure 3.10 – DataFrame table
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 数据框表
- en: 'In the preceding code, JavaScript object data is created containing keys and
    values. Note the following about the JavaScript object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，创建了包含键和值的JavaScript对象数据。请注意JavaScript对象的以下内容：
- en: Each key contains a list value representing data per column.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键包含一个列表值，表示每列的数据。
- en: Each key represents the column and the column name.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键代表列和列名。
- en: Each key must have the same length of list values.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键必须具有相同长度的列表值。
- en: 'The following are common methods for handling DataFrame data structures:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理数据框数据结构的常见方法：
- en: 'The `head()` and `tail()` methods: Sometimes, while working on a big dataset,
    you might need to see the first set of rows (maybe the first 5 rows or the first
    30 rows, as much as you like) and also the last rows in the data.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head()`和`tail()`方法：有时，在处理大型数据集时，您可能需要查看数据的前几行（可能是前5行或前30行，只要您喜欢的数量），以及数据的最后几行。'
- en: 'Since our DataFrame contains five rows, let''s print the first two rows of
    the table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的DataFrame包含五行，让我们打印表的前两行：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `head()` method by default prints out the first five rows of a DataFrame,
    but we can specify `2` since our data is small.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()`方法默认打印DataFrame的前五行，但我们可以指定`2`，因为我们的数据很小。'
- en: 'The following table shows the result of the preceding code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表显示了前述代码的结果：
- en: '![Figure 3.11 – Table for df.head(2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - 用于df.head(2)的表'
- en: '](img/B17076_3_11.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_11.jpg)'
- en: Figure 3.11 – Table for df.head(2)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - 用于df.head(2)的表
- en: 'Also, to see the last set of rows in the DataFrame, we make use of the `tail()`
    method. By default, the `tail` method prints out the last five rows in the DataFrame:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要查看DataFrame中的最后一组行，我们使用`tail()`方法。默认情况下，`tail`方法会打印出DataFrame中的最后五行：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `tail` function takes in a value that specifies the number of rows to print
    from the end of the DataFrame table, as shown:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`函数接受一个值，该值指定要从DataFrame表末尾打印的行数，如下所示：'
- en: '![Figure 3.12 – Printing the last two rows'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - 打印最后两行'
- en: '](img/B17076_3_12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_12.jpg)'
- en: Figure 3.12 – Printing the last two rows
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - 打印最后两行
- en: '`data` variable contains the data, which is represented as an array of an array.
    Each array in the data array contains values arranged row-wise as it will be represented
    in the DataFrame table; `[Drake, 5, $1m]` represents a row in the DataFrame, while
    each value (`Drake`, `5`, `$1m`) represents different columns. `Drake` belongs
    to the `artist` column and `$1m` belongs to the `dollar` column, as shown in the
    following figure:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`变量包含数据，表示为数组的数组。数据数组中的每个数组按行排列的值将在DataFrame表中表示为`[Drake, 5, $1m]`表示DataFrame中的一行，而每个值（`Drake`，`5`，`$1m`）表示不同的列。`Drake`属于`artist`列，`$1m`属于`dollar`列，如下图所示：'
- en: '![Figure 3.13 – DataFrame table'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - DataFrame表'
- en: '](img/B17076_3_13.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_13.jpg)'
- en: Figure 3.13 – DataFrame table
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - DataFrame表
- en: 'Recall that we said a DataFrame is a collection of Series, hence it is possible
    to access each of these Series from the DataFrame like the way we access JavaScript
    object elements. Here is how to do that:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们说过DataFrame是Series的集合，因此可以像访问JavaScript对象元素的方式一样从DataFrame中访问这些Series。下面是如何做到这一点的：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that `artist` is the name of a column in the DataFrame, hence if we were
    to think of a DataFrame as an object, `artist` is the key and the value of the
    key is a Series. The preceding code should output the following table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`artist`是DataFrame中的列名，因此如果我们将DataFrame视为对象，则`artist`是键，键的值是Series。前述代码应输出以下表：
- en: '![Figure 3.14 – Column Series'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 - 列系列'
- en: '](img/B17076_3_14.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_14.jpg)'
- en: Figure 3.14 – Column Series
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - 列系列
- en: 'The `artist` column can also be accessed via `df[''artist'']`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`artist`列也可以通过`df[''artist'']`访问：'
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method also outputs the same result as the initial `df.dollar` method
    being used:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也输出与使用初始`df.dollar`方法相同的结果：
- en: '![Figure 3.15 – Accessing column values'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 - 访问列值'
- en: '](img/B17076_3_15.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_15.jpg)'
- en: Figure 3.15 – Accessing column values
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 - 访问列值
- en: 'Apart from accessing column values via an object-like method, we can also change
    the column data as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过类似对象的方法访问列值之外，我们还可以按以下方式更改列数据：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we were to print out `df.dollar`, we would obtain the following output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要打印`df.dollar`，我们将获得以下输出：
- en: '![Figure 3.16 – Changing the column value'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 - 更改列值'
- en: '](img/B17076_3_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_16.jpg)'
- en: Figure 3.16 – Changing the column value
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 - 更改列值
- en: 'The changing of column data can also be done by creating a Series frame and
    then assigning it to a column in the DataFrame, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过创建一个Series框架，然后将其分配给DataFrame中的列来更改列数据，如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code changes the value of the column rating and outputs the following
    table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码更改了列评分的值，并输出了以下表：
- en: '![Figure 3.17 – Changing column data with a Series value'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 - 使用Series值更改列数据'
- en: '](img/B17076_3_17.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_17.jpg)'
- en: Figure 3.17 – Changing column data with a Series value
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 - 使用Series值更改列数据
- en: This method of using Series data to update column data comes in handy when working
    on a time-related column. We might need to extract hours or months in a date column
    and replace the column with the extracted information (hours or months).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '在处理与时间相关的列时，使用Series数据来更新列数据的方法非常方便。我们可能需要提取日期列中的小时或月份，并用提取的信息（小时或月份）替换列。 '
- en: 'Let''s add a date column to the DataFrame:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向DataFrame添加一个日期列：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We make use of the `addColumn` method to add a new column to the DataFrame.
    The `addColumn` method accepts an object argument that must contain the following
    keys:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`addColumn`方法向DataFrame添加新列。`addColumn`方法接受一个必须包含以下键的对象参数：
- en: a) The name of the `column` to add
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: a) 要添加的“列”的名称
- en: b) The new `value` for the column
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: b) 列的新“值”
- en: 'The preceding code should output the following table:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码应输出以下表：
- en: '![Figure 3.18 – Adding a new column'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 - 添加新列'
- en: '](img/B17076_3_18.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_18.jpg)'
- en: Figure 3.18 – Adding a new column
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 - 添加新列
- en: 'The new column created is a date-time column, hence we can convert this column
    to a time series data structure and then extract the month name for each data
    point in the column:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的新列是一个日期时间列，因此我们可以将此列转换为时间序列数据结构，然后提取列中每个数据点的月份名称：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We extract the date column and assign it to a `date_series` variable. From `date_series`
    (which is actually a Series data structure), we extract the month name for each
    value. A Series data structure contains the `dt` method, which converts the Series
    structure to a time series structure and then extracts the month name using the
    `month_name()` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取日期列并将其分配给`date_series`变量。从`date_series`（实际上是一个Series数据结构）中，我们提取每个值的月份名称。Series数据结构包含`dt`方法，它将Series结构转换为时间序列结构，然后使用`month_name()`方法提取月份名称。
- en: 'The preceding code outputs the following table:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出了以下表格：
- en: '![Figure 3.19 – Extracting the month name'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 提取月份名称'
- en: '](img/B17076_3_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_19.jpg)'
- en: Figure 3.19 – Extracting the month name
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 提取月份名称
- en: The next methods that we will look into are `.values` and `.tensor`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一个方法是`.values`和`.tensor`。
- en: '`.values` and `.tensor`: The DataFrame values, that is, each column value,
    can be obtained as a giant array using `df.values`:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.values`和`.tensor`：DataFrame的值，即每个列值，可以使用`df.values`作为一个巨大的数组获得：'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Sometimes, we might want to obtain the DataFrame as a tensor for machine learning
    operations, hence the following shows how to obtain a DataFrame as tensor values:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望将DataFrame作为张量获得用于机器学习操作，因此以下显示了如何将DataFrame作为张量值获得：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `tensor` attribute returned a TensorFlow.js tensor data structure. Since
    a tensor must always contain a unique data type, all the data points in our DataFrame
    are converted to a `dtype` string.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`tensor`属性返回了一个TensorFlow.js张量数据结构。由于张量必须始终包含唯一的数据类型，因此我们DataFrame中的所有数据点都转换为`dtype`字符串。'
- en: 'The `.transpose()` method: Since we made the claim that a DataFrame is a two-dimensional
    representation of data, we should be able to transpose the DataFrame:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.transpose()`方法：由于我们声称DataFrame是数据的二维表示，因此我们应该能够对DataFrame进行转置：'
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`df.transpose()` moves the column list as an index and the index as a column,
    as shown in the following table:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`df.transpose()`将列列表作为索引，将索引作为列，如下表所示：'
- en: '![Figure 3.20 – Transposing a DataFrame'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – 转置DataFrame'
- en: '](img/B17076_3_20.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_20.jpg)'
- en: Figure 3.20 – Transposing a DataFrame
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 转置DataFrame
- en: 'We can obtain the index of the DataFrame and see whether the column is now
    the current index:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取DataFrame的索引并查看列是否现在是当前索引：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is the index of the transposed DataFrame. In the preceding
    examples, the index has always been a numerical value, but with this, it shows
    that the index can also be a string.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是转置DataFrame的索引。在前面的示例中，索引始终是数值，但是通过这个示例，可以看到索引也可以是字符串。
- en: 'The `.set_index()` method: Using the DataFrame itself, before transposing it,
    let''s change the index of the DataFrame from integers to a string index:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.set_index()`方法：使用DataFrame本身，在对其进行转置之前，让我们将DataFrame的索引从整数更改为字符串索引：'
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the `set_index` method in the DataFrame sets the index with the given
    key values. `set_index` also accepts the `inplace` key (the `inplace` key is a
    Boolean key it receives either `true` or `false` as a value, but the default value
    is `false`) key to specify whether the DataFrame should be updated or a new DataFrame
    containing the update should be returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame中的`set_index`方法使用给定的键值设置索引。`set_index`还接受`inplace`键（`inplace`键是一个布尔键，它接收`true`或`false`作为值，但默认值为`false`）来指定DataFrame是否应该更新或返回包含更新的新DataFrame。
- en: 'The following table shows the result of the preceding code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了上述代码的结果：
- en: '![Figure 3.21 – Setting the index of the DataFrame'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21 – 设置DataFrame的索引'
- en: '](img/B17076_3_21.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_21.jpg)'
- en: Figure 3.21 – Setting the index of the DataFrame
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 设置DataFrame的索引
- en: 'Since the index can be anything, we can also set the index of the DataFrame
    to be one of the columns in the DataFrame:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于索引可以是任何内容，因此我们也可以将DataFrame的索引设置为DataFrame中的一列：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time around, `set_index` takes in a value instead of an array of proposed
    index values. If a single value is passed as a key index, `set_index` believes
    it should be available as a column in the DataFrame.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`set_index`接受一个值而不是一个提议的索引值数组。如果将单个值作为键索引传递，`set_index`认为它应该作为DataFrame中的列可用。
- en: The values in the `artist` column are used to replace the default index. Also
    note that the default value of `inplace` is `false`, hence a new DataFrame is
    created and returned with the updated index.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`artist`列中的值用于替换默认索引。还要注意`inplace`的默认值为`false`，因此会创建并返回一个包含更新索引的新DataFrame。'
- en: 'The following shows the output of the DataFrame created:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了创建的DataFrame的输出：
- en: '![Figure 3.22 – Setting the index to the artist column'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.22 – 将索引设置为艺术家列'
- en: '](img/B17076_3_22.png)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_22.png)'
- en: Figure 3.22 – Setting the index to the artist column
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – 将索引设置为艺术家列
- en: By now, you should be aware of how to create a Series and DataFrame and how
    to make use of their respective methods for data processing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经了解如何创建Series和DataFrame以及如何利用它们各自的方法进行数据处理。
- en: In the next section, we look into some essential functions and methods in Danfo.js
    that will commonly be used for data analysis and processing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究一些在Danfo.js中常用于数据分析和处理的基本函数和方法。
- en: Essential functions and methods in Danfo.js
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Danfo.js中的基本函数和方法
- en: 'In this section, we will look at some important functions and methods in relation
    to Series and DataFrames. The methods in each of the data structures are a lot
    and we can always visit the documentation for more methods. This section will
    only mention some of the most commonly used methods:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与Series和DataFrames相关的一些重要函数和方法。每个数据结构中的方法都很多，我们可以随时查看文档以获取更多方法。本节将只提到一些最常用的方法：
- en: '`loc` and `iloc` indexing'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loc`和`iloc`索引'
- en: 'Sorting: the `sort_values` and `sort_index` methods'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序：`sort_values`和`sort_index`方法
- en: '`Filter`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`过滤器`'
- en: Arithmetic operations such as `add`, `sub`, `div`, `mul`, and `cumsum`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算，如`add`，`sub`，`div`，`mul`和`cumsum`
- en: loc and iloc indexing
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: loc和iloc索引
- en: Accessing DataFrame rows and columns is made easier with the `loc` and `iloc`
    methods; both methods allow you to specify the rows and columns you would like
    to access. For those of you coming from Python' pandas library, the `loc` and
    `iloc` format as implemented in Danfo.js should be familiar.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loc`和`iloc`方法更容易地访问DataFrame的行和列；这两种方法都允许您指定要访问的行和列。对于那些来自Python的pandas库的人来说，Danfo.js中实现的`loc`和`iloc`格式应该是熟悉的。
- en: 'The `loc` method is used to access a DataFrame with an index that is not numeric,
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loc`方法访问具有非数字索引的DataFrame，如下所示：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Making use of the last updated DataFrame from the previous section, we used
    the `loc` method to obtain a certain row index from the DataFrame. This index
    value is specified in the `rows` key element:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上一节中更新的DataFrame，我们使用`loc`方法从DataFrame中获取特定的行索引。这个索引值在`rows`关键元素中指定：
- en: '![Figure 3.23 – Accessing specific row index values'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23-访问特定的行索引值'
- en: '](img/B17076_3_23.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_23.jpg)'
- en: Figure 3.23 – Accessing specific row index values
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23-访问特定的行索引值
- en: Also, the `loc` and `iloc` methods give us the ability to slice an array. This
    should be familiar to Python users. Don't worry if you don't know what it is;
    the following examples will show what it means and how it is done.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`loc`和`iloc`方法使我们能够对数组进行切片。这对于Python用户来说应该是熟悉的。如果你不知道它是什么，不要担心；下面的例子将展示它的含义和如何做到这一点。
- en: 'To obtain a range of indexes, we can specify the upper and lower bounds even
    for a non-numerical index:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一系列的索引，我们可以指定非数字索引的上限和下限：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `loc` method is used whenever the column name and index of a DataFrame is
    a string. For the preceding code, we specify that we want to extract data values
    between the `Rihanna` row index and the `Bellion` row index.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当DataFrame的列名和索引是字符串时，使用`loc`方法。对于上述代码，我们指定要提取`Rihanna`行索引和`Bellion`行索引之间的数据值。
- en: 'This colon helps specify the range boundary. The following table shows the
    output of the preceding code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个冒号有助于指定范围边界。以下表格显示了上述代码的输出：
- en: '![Figure 3.24 – String indexing'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24-字符串索引'
- en: '](img/B17076_3_24.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_24.jpg)'
- en: Figure 3.24 – String indexing
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24-字符串索引
- en: 'Apart from indexing the rows, we can also extract a specific column:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对行进行索引，我们还可以提取特定的列：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A `columns` key is passed into `loc` to extract the column called `rating`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将`columns`键传递到`loc`中以提取名为`rating`的列。
- en: 'The following table shows the result of the preceding code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了上述代码的结果：
- en: '![Figure 3.25 – Column and row indexing'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25-列和行索引'
- en: '](img/B17076_3_25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_25.jpg)'
- en: Figure 3.25 – Column and row indexing
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25-列和行索引
- en: 'We can also specify the range for the indexing column, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定索引列的范围，如下所示：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should return a table similar to the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个类似于以下的表：
- en: '![Figure 3.26 – Column range'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.26-列范围'
- en: '](img/B17076_3_26.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_26.jpg)'
- en: Figure 3.26 – Column range
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26-列范围
- en: From the preceding table, we can see the range is quite different from the row
    indexing; the column indexing does exclude the upper bound.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中，我们可以看到范围与行索引相比是完全不同的；列索引排除了上限。
- en: The `loc` method in a DataFrame uses characters to index both the row data and
    the column data. `iloc` does the same but makes use of integers for indexing rows
    and columns.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame中的`loc`方法使用字符来索引行数据和列数据。`iloc`也是一样，但是使用整数来索引行和列。
- en: 'Using the initial DataFrame as shown in the following table, we are going to
    perform indexing using the `iloc` method:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下表格中显示的初始DataFrame，我们将使用`iloc`方法进行索引：
- en: '![Figure 3.27 – The artist table'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.27-艺术家表'
- en: '](img/B17076_3_27.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_27.jpg)'
- en: Figure 3.27 – The artist table
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27-艺术家表
- en: 'Let''s use `iloc` to access index `2` to `4` of the table shown in *Figure
    3.27*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`iloc`来访问*图3.27*中显示的表的索引`2`到`4`：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `iloc` method accepts the same keywords as the `loc` method: the `rows`
    and `columns` keywords. The numbers are wrapped in a string because we want to
    perform `loc` method.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc`方法接受与`loc`方法相同的关键字：`rows`和`columns`关键字。数字被包装在字符串中，因为我们想执行`loc`方法。'
- en: 'The following table shows the result of the preceding code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了上述代码的结果：
- en: '![Figure 3.28 – Indexing table rows from 2 to 4 using a closed upper bound'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.28-使用封闭上限从2到4索引表行'
- en: '](img/B17076_3_28.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_28.jpg)'
- en: Figure 3.28 – Indexing table rows from 2 to 4 using a closed upper bound
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28-使用封闭上限从2到4索引表行
- en: Slicing arrays (fancy indexing)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 切片数组（花式索引）
- en: Slicing arrays will be familiar to those coming from Python. In Python, it is
    possible to index an array using a range of values, for example, `test = [1,2,3,4,5,6,7]
    test [2:5] => [3,4,5]`. JavaScript does not have this property, hence Danfo.js
    does this by passing the range as a string, and from the string, the upper and
    lower bounds are extracted.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些来自Python的人来说，切片数组将是熟悉的。在Python中，可以使用一系列值对数组进行索引，例如，`test = [1,2,3,4,5,6,7]
    test [2:5] => [3,4,5]`。JavaScript没有这个属性，因此Danfo.js通过将范围作为字符串传递，并从字符串中提取上限和下限来实现这一点。
- en: 'The same slicing operation as done in the previous example for rows can also
    be done on columns:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与在前面的例子中对行进行的相同的切片操作也可以对列进行：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`df.iloc({columns:[''1:'']})` is used to extract the column starting from index
    1 (which represents the `rating` column) up to the last column. For integer indexing,
    whenever the upper bound is not specified, it picks the last column as the upper
    bound.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`df.iloc({columns:[''1:'']})`用于提取从索引1（表示`rating`列）到最后一列的列。对于整数索引，当未指定上限时，它会选择最后一列作为上限。'
- en: In this section, we talked about indexing and different methods of indexing
    a DataFrame. In the next section, we will be talking about sorting a DataFrame
    by column value and row index.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了对DataFrame进行索引和不同的索引方法。在下一节中，我们将讨论如何按列值和行索引对DataFrame进行排序。
- en: Sorting
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: Danfo.js supports two methods for sorting data – in terms of index or by a column
    value. Also, Series data can only be sorted by index, because it is a DataFrame
    object with a single column. DataFrames have a method called `sort_values` that
    enables you to sort data by a specific column, hence by sorting a particular column,
    we are sorting all other columns with respect to this column.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js支持两种排序数据的方法 - 按索引或按列值。此外，Series数据只能按索引排序，因为它是一个只有单列的DataFrame对象。DataFrame有一个名为`sort_values`的方法，它使您能够按特定列对数据进行排序，因此通过对特定列进行排序，我们正在对其他所有列进行排序。
- en: 'Let''s create a DataFrame containing numbers:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含数字的DataFrame：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This outputs the following table:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下表格：
- en: '![Figure 3.29 – DataFrame of numbers'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.29 – 数字DataFrame'
- en: '](img/B17076_3_29.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_29.jpg)'
- en: Figure 3.29 – DataFrame of numbers
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29 – 数字DataFrame
- en: 'Now, let''s sort the DataFrame by the values in column `B`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按列`B`中的值对DataFrame进行排序：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `sort_values` method takes in the following keyword arguments:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_values`方法接受以下关键字参数：'
- en: '`by`: The name of the column used to sort the DataFrame.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by`：用于对DataFrame进行排序的列的名称。'
- en: '`inplace`: Whether the original DataFrame should be updated or not (`true`
    or `false`).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inplace`：是否应更新原始DataFrame（`true`或`false`）。'
- en: '`ascending`: Whether the column should be sorted in ascending order or not.
    The default value is always `false`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ascending`：列是否应按升序排序。默认值始终为`false`。'
- en: 'In the preceding code snippet, we specify to sort the DataFrame by column `C`
    and also set `inplace` to `true`, hence the DataFrame is updated and the column
    is also sorted in descending order. The following table shows the output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们指定按列`C`对DataFrame进行排序，并将`inplace`设置为`true`，因此DataFrame被更新，并且列也按降序排序。以下表格显示了输出：
- en: '![Figure 3.30 – DataFrame sorted by column values'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.30 – 按列值排序的DataFrame'
- en: '](img/B17076_3_30.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_30.jpg)'
- en: Figure 3.30 – DataFrame sorted by column values
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 – 按列值排序的DataFrame
- en: 'Sometimes we might not want to update the original DataFrame itself. Here lies
    the influence of the `inplace` keyword:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能不想更新原始DataFrame本身。这就是`inplace`关键字的影响所在：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code, the DataFrame was sorted by a column. Let''s try to
    sort the same DataFrame by its index:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，DataFrame按列排序。让我们尝试按其索引对相同的DataFrame进行排序：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`sort_index` also accepts keyword arguments: `ascending` and `inplace`. We
    set the `ascending` keyword to be `true`, which should give us the DataFrame with
    its index set in ascending order.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_index`还接受关键字参数：`ascending`和`inplace`。我们将`ascending`关键字设置为`true`，这应该会给我们一个按升序排列的DataFrame。'
- en: 'The following output is obtained:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是获得的输出：
- en: '![Figure 3.31 – Sorted index DataFrame'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.31 – 排序索引DataFrame'
- en: '](img/B17076_3_31.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_31.jpg)'
- en: Figure 3.31 – Sorted index DataFrame
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 – 排序索引DataFrame
- en: 'Sorting in a Series requires quite a simple approach; sorting is done by calling
    the `sort_values` method, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在Series中进行排序需要一个非常简单的方法；通过调用`sort_values`方法来进行排序，如下所示：
- en: '[PRE44]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `sort_values` method also accepts keyword arguments, `ascending` and `inplace`.
    By default, `ascending` is set to `true` and `inplace` is set to `false`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_values`方法还接受关键字参数`ascending`和`inplace`。默认情况下，`ascending`设置为`true`，`inplace`设置为`false`。'
- en: 'The following table shows the result of the preceding code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了上述代码的结果：
- en: '![Figure 3.32 – Sorting a Series by value'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.32 – 按值排序Series'
- en: '](img/B17076_3_32.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_32.jpg)'
- en: Figure 3.32 – Sorting a Series by value
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 – 按值排序Series
- en: Note the `sort_values` and `sort_index` methods also work for columns and indexes
    containing strings.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sort_values`和`sort_index`方法也适用于包含字符串的列和索引。
- en: 'Using our `artist` DataFrame, let''s try sorting a column with a string as
    follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`artist` DataFrame，让我们尝试按以下方式对一个列进行排序：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The DataFrame is sorted using the `artist` column in descending order. This
    results in a table with `Rihanna` in the first row followed by `Passenger`, based
    on the first character:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame使用`artist`列按降序排序。这将导致一个表，其中`Rihanna`在第一行，其后是`Passenger`，基于第一个字符：
- en: '![Figure 3.33 – Sorting by the string column'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.33 – 按字符串列排序'
- en: '](img/B17076_3_33.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_33.jpg)'
- en: Figure 3.33 – Sorting by the string column
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 – 按字符串列排序
- en: In this section, we saw how to sort a DataFrame by column values and row index.
    In the next section, we will see how we can filter DataFrame values.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何按列值和行索引对DataFrame进行排序。在下一节中，我们将看到如何过滤DataFrame值。
- en: Filtering
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: Filtering out rows of a DataFrame based on some particular values in a column
    comes in handy most of the time during data manipulation and processing. Danfo.js
    has a method called `query` that is used to filter rows based on the value in
    a column.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 根据列中的某些特定值过滤DataFrame的行在数据操作和处理过程中大多数时间都很方便。Danfo.js有一个名为`query`的方法，用于根据列中的值过滤行。
- en: 'The `query` method takes in the following keyword arguments:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`方法接受以下关键字参数：'
- en: '`column`: The column name'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`：列名'
- en: '`is`: Specifies the logical operator to use (`>, <, >=, <=, ==`)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`：指定要使用的逻辑运算符（`>，<，>=，<=，==`）'
- en: '`to`: The value used to filter the DataFrame'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`：用于过滤DataFrame的值'
- en: '`inplace`: Updates the original DataFrame or returns a new one'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inplace`：更新原始DataFrame或返回一个新的'
- en: Here is an example of how the `query` method works.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`query`方法的工作示例。
- en: 'First, we create a DataFrame:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个DataFrame：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following figure shows the table:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了表格：
- en: '![Figure 3.34 – DataFrame'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.34 – DataFrame'
- en: '](img/B17076_3_34.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_34.jpg)'
- en: Figure 3.34 – DataFrame
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 – DataFrame
- en: 'Let''s sort the DataFrame by a value in column `B`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按列`B`中的值对DataFrame进行排序：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we filter column `B` by a value greater than 5\. This will result in
    returning rows containing a value greater than 5 in column `B`, as shown here:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过大于5的值来过滤列`B`。这将导致返回包含列`B`中大于5的值的行，如下所示：
- en: '![Figure 3.35 – Filtered by a value greater than 5 in column B'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.35 – 按列B中大于5的值过滤'
- en: '](img/B17076_3_35.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_35.jpg)'
- en: Figure 3.35 – Filtered by a value greater than 5 in column B
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 – 按列B中大于5的值过滤
- en: 'Let''s filter the DataFrame by checking whether the values in column `C` equal
    to `20`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查列`C`中的值是否等于`20`来过滤DataFrame：
- en: '[PRE48]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this, we obtain the following output:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们得到了以下输出：
- en: '![Figure 3.36 – Filtered by values equal to 20 in column C'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.36 – 在C列值等于20的情况下进行过滤'
- en: '](img/B17076_3_36.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_36.jpg)'
- en: Figure 3.36 – Filtered by values equal to 20 in column C
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 – 在C列值等于20的情况下进行过滤
- en: In this section, we saw how to filter a DataFrame by column values. In the next
    section, we will see how to perform different arithmetic operations.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何通过列值过滤DataFrame。在下一节中，我们将看到如何执行不同的算术运算。
- en: Arithmetic operations
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算
- en: In this sub-section, we will look into different arithmetic operations and how
    to use them to preprocess our data.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将研究不同的算术运算以及如何使用它们来预处理我们的数据。
- en: 'Arithmetic operations such as addition, subtraction, multiplication, and division
    can be done between the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下之间进行加法、减法、乘法和除法等算术运算：
- en: A DataFrame and a Series
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个Series
- en: A DataFrame and an array
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个数组
- en: A DataFrame and a `scalar` value
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个`标量`值
- en: 'We start by performing an arithmetic operation between DataFrame and `scalar`
    values:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先进行了DataFrame和`标量`值之间的算术运算：
- en: '[PRE49]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `add` method is used to add a `scalar` variable of `20` across each row
    of the DataFrame. The `add` method takes in two arguments:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法用于在DataFrame的每一行上添加一个`标量`变量20。`add`方法接受两个参数：'
- en: '`other`: This represents either a DataFrame, Series, array, or `scalar`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`other`：这表示DataFrame、Series、数组或`标量`。'
- en: '`axis`: Specifies whether the operation should be applied by row or by column.
    The row axis is represented with `0` and the column by `1`. The default is `0`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axis`：指定操作是按行还是按列应用的。行轴用`0`表示，列轴用`1`表示。默认为`0`。'
- en: 'For the `scalar` operation, we obtain the following result:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`标量`操作，我们得到了以下结果：
- en: '![Figure 3.37 – Left: original DataFrame. Right: DataFrame after doing scalar
    addition'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.37 – 左：原始DataFrame。右：进行标量加法后的DataFrame'
- en: '](img/B17076_3_37.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_37.jpg)'
- en: 'Figure 3.37 – Left: original DataFrame. Right: DataFrame after doing scalar
    addition'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 – 左：原始DataFrame。右：进行标量加法后的DataFrame
- en: 'Let''s create a Series and pass it to the `add` method:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Series并将其传递给`add`方法：
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A Series is created containing two-row elements. This two-row element equals
    the number of columns in the `ar_df` DataFrame, which means that the first row
    value of `add_series` belongs to the first column of `ar_df`, just as the second
    row value corresponds to the second column of `ar_df`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个包含两行元素的Series。这两行元素等于`ar_df` DataFrame中的列数，这意味着`add_series`的第一行值属于`ar_df`的第一列，就像第二行值对应于`ar_df`的第二列一样。
- en: 'The explanation in the preceding paragraph means that `20` will be used to
    multiply `Col1` and `30` will be used to multiply `Col2`. For this to occur, we
    specify the axis to be `1`, which tells the add operation to perform the operation
    column-wise, as we can see in the following table:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 前面段落中的解释意味着`20`将用于乘以`Col1`，`30`将用于乘以`Col2`。为了实现这一点，我们指定轴为`1`，这告诉add操作按列进行操作，正如我们在下表中所看到的：
- en: '![Figure 3.38 – Add operation between the DataFrame and Series'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.38 – DataFrame和Series之间的加法操作'
- en: '](img/B17076_3_38.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_38.jpg)'
- en: Figure 3.38 – Add operation between the DataFrame and Series
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38 – DataFrame和Series之间的加法操作
- en: The addition operation between a DataFrame and a Series is the same between
    a DataFrame and a normal JavaScript array, since a Series is just a JavaScript
    array with some extended functionality.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame和Series之间的加法操作与DataFrame和普通JavaScript数组之间的操作相同，因为Series只是具有一些扩展功能的JavaScript数组。
- en: 'Let''s look into the operation between two DataFrames:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个DataFrame之间的操作：
- en: '[PRE51]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we create two sets of DataFrames and then add them together; but we must
    ensure the two DataFrames have the same number of columns and rows. Also, this
    operation is done row-wise.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两组DataFrame，然后将它们相加；但是我们必须确保两个DataFrame具有相同数量的列和行。此外，此操作是逐行进行的。
- en: The operation does not actually care whether the two DataFrames have the same
    column name or not, but the resulting column name is the column of the DataFrame
    we are adding to the former DataFrame.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作实际上并不关心两个DataFrame是否具有相同的列名，但是结果列名是我们要添加到前一个DataFrame的DataFrame的列名。
- en: 'The following table shows the result of the DataFrames created in the preceding
    code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表显示了前面代码中创建的DataFrame的结果：
- en: '![Figure 3.39 – From left to right: tables for DataFrames df and df2 and addition
    between df and df2'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.39 – 从左到右：DataFrame df和df2的表格以及df和df2之间的加法'
- en: '](img/B17076_3_39.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_39.jpg)'
- en: 'Figure 3.39 – From left to right: tables for DataFrames df and df2 and addition
    between df and df2'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 – 从左到右：DataFrame df和df2的表格以及df和df2之间的加法
- en: The example done with the add operation is the same for the `sub()`, `mul()`,
    `div()`, `pow()`, and `mod()` methods.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用add操作进行的示例与`sub()`、`mul()`、`div()`、`pow()`和`mod()`方法相同。
- en: 'Also, for both DataFrames and Series there is a set of mathematical operations
    called cumulative, which comprises the following methods:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于DataFrame和Series，还有一组称为累积的数学运算，其中包括以下方法：
- en: 'Cumulative sum: `cumsum()`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积求和：`cumsum()`
- en: 'Cumulative min: `cummin()`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积最小值：`cummin()`
- en: 'Cumulative max: `cummax()`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积最大值：`cummax()`
- en: 'Cumulative product: `cumprod()`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积乘积：`cumprod()`
- en: 'Each of these operations is the same in terms of the argument being passed
    in. They all accept the axis in which the operation is to be performed:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的每一个在传递参数方面都是相同的。它们都接受操作应该在哪个轴上执行的参数：
- en: '[PRE52]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We create a DataFrame by specifying its data and columns, and we then perform
    a cumulative sum along the `0` axis.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定其数据和列来创建一个DataFrame，然后沿着`0`轴执行累积求和。
- en: 'The following table shows the result of the preceding code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表显示了前面代码中创建的DataFrame的结果：
- en: '![Figure 3.40 – Left: the DataFrame before cumsum(). Right: the DataFrame after
    cumsum()'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.40 – 左：cumsum()之前的DataFrame。右：cumsum()之后的DataFrame'
- en: '](img/B17076_3_40.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_40.jpg)'
- en: 'Figure 3.40 – Left: the DataFrame before cumsum(). Right: the DataFrame after
    cumsum()'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.40 - 左：cumsum()之前的DataFrame。右：cumsum()之后的DataFrame
- en: 'Let''s perform a `cumsum` operation along axis `1` of the DataFrame:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们沿着DataFrame的轴`1`执行`cumsum`操作：
- en: '[PRE53]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This gives us the following table:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下表格：
- en: '![Figure 3.41 – cumsum along axis 1'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.41 - 沿轴1的累积和'
- en: '](img/B17076_3_41.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_41.jpg)'
- en: Figure 3.41 – cumsum along axis 1
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.41 - 沿轴1的累积和
- en: 'The same cumulative operations can also be applied to Series. Let''s apply
    the same cumulative sum to Series data:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的累积操作也可以应用于Series。让我们将相同的累积和应用于Series数据：
- en: '[PRE54]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`cumsum` in a Series does not take in any argument. With the preceding operation,
    we have as the output, the following table *Figure 3.42* that is the original
    Series before applying the cumulative Series.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Series中的`cumsum`不接受任何参数。通过前面的操作，我们得到了以下表格*图3.42*，即在应用累积Series之前的原始Series。
- en: 'The following table shows the result of the `series.cumsum()` operation in
    the preceding code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了在前面代码中`series.cumsum()`操作的结果：
- en: '![Figure 3.42 – The cumulative sum Series'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.42 - 累积和Series'
- en: '](img/B17076_3_42.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_42.jpg)'
- en: Figure 3.42 – The cumulative sum Series
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.42 - 累积和Series
- en: All other cumulative operations, such as `cumprod`, `cummin`, and `cummax`,
    are used in the same way as the `cumsum()` operation as shown in the preceding
    `cumsum` examples.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他累积操作，如`cumprod`、`cummin`和`cummax`，都与前面`cumsum`示例中所示的方式相同。
- en: In this section, we looked into different arithmetic operations and how to make
    use of these operations to preprocess data. In the next section, we will dive
    into logical operations such as how to perform logical operations between a DataFrame
    and Series, array, and `Scalar` values.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究了不同的算术操作以及如何利用这些操作来预处理数据。在下一节中，我们将深入研究逻辑操作，例如如何在DataFrame和Series、数组和`标量`值之间执行逻辑操作。
- en: Logical operations
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑操作
- en: In this section, we will see how we can perform logical operations, such as
    comparing the values between a DataFrame and Series, array, and scalar values.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何执行逻辑操作，例如比较DataFrame和Series、数组和标量值之间的值。
- en: 'The way logical operations are called and used is quite similar to how arithmetic
    operations work. A logical operation can be done between the following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑操作的调用和使用方式与算术操作的工作方式非常相似。逻辑操作可以在以下之间进行：
- en: A DataFrame and a Series
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个Series
- en: A DataFrame and an array
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个数组
- en: A DataFrame and a scalar value
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DataFrame和一个标量值
- en: 'The following logical operations are implemented:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 实施了以下逻辑操作：
- en: 'Equal to (`==`): `.eq()`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于（`==`）：`.eq()`
- en: 'Greater than (`>`): `gt()`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`>`）：`gt()`
- en: 'Less than (`<`): `lt()`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`<`）：`lt()`
- en: 'Not equal to (`!=`): `ne()`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不等于（`!=`）：`ne()`
- en: 'Less than or equal to (`<=`): `le()`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`<=`）：`le()`
- en: 'Greater than or equal to (`>=`): `ge()`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`>=`）：`ge()`
- en: 'All these methods take in the same argument, which are `other` and `axis`.
    Using the `lt()` method, let''s see how they work:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都接受相同的参数，即`other`和`axis`。使用`lt()`方法，让我们看看它们是如何工作的：
- en: '[PRE55]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The code checks whether each of the values in the DataFrame is less than 20\.
    The result can be seen in the following figure:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查DataFrame中的每个值是否小于20。结果可以在下图中看到：
- en: '![Figure 3.43 – Left: DataFrame for df. Right: DataFrame for df_rep'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.43 - 左：df的DataFrame。右：df_rep的DataFrame'
- en: '](img/B17076_3_43.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_43.jpg)'
- en: 'Figure 3.43 – Left: DataFrame for df. Right: DataFrame for df_rep'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.43 - 左：df的DataFrame。右：df_rep的DataFrame
- en: 'Also, the same operation can be done with a DataFrame and Series, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的操作也可以在DataFrame和Series之间进行，如下所示：
- en: '[PRE56]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `series` operation with the DataFrame is done column-wise. The following
    table is the result:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame与Series的`series`操作是按列进行的。以下表格是结果：
- en: '![Figure 3.44 – Logical operation between a DataFrame and Series'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.44 - DataFrame和Series之间的逻辑操作'
- en: '](img/B17076_3_44.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_44.jpg)'
- en: Figure 3.44 – Logical operation between a DataFrame and Series
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.44 - DataFrame和Series之间的逻辑操作
- en: 'Let''s perform a logical operation between two DataFrames, as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在两个DataFrame之间执行逻辑操作，如下所示：
- en: '[PRE57]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The code outputs the following result:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出了以下结果：
- en: '![Figure 3.45 – Logical operation between DataFrames'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.45 - DataFrame之间的逻辑操作'
- en: '](img/B17076_3_45.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_45.jpg)'
- en: Figure 3.45 – Logical operation between DataFrames
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.45 - DataFrame之间的逻辑操作
- en: In this section, we looked into some essential DataFrame operations, such as
    how to filter a DataFrame by column value. We also saw how to sort a DataFrame
    by column value and row index. Also, this section dived into the indexing of DataFrames
    with `loc` and `iloc`, and finally, we looked into arithmetic and logical operations.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究了一些重要的DataFrame操作，例如如何按列值过滤DataFrame。我们还看到了如何按列值和行索引对DataFrame进行排序。此外，本节还深入研究了使用`loc`和`iloc`对DataFrame进行索引，最后，我们研究了算术和逻辑操作。
- en: In the next section, we will dive into working with different data formats,
    how to parse these files into Danfo.js, and converting them into a DataFrame or
    Series.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入研究如何处理不同的数据格式，如何将这些文件解析为Danfo.js，并将它们转换为DataFrame或Series。
- en: Data loading and working with different file formats
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据加载和处理不同的文件格式
- en: 'In this section, we will look at how to work with different file formats. Danfo.js
    provides a method for working with three different file formats: CSV, Excel, and
    JSON. Data presented in these formats can easily be read and presented as a DataFrame.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何处理不同的文件格式。Danfo.js提供了一种处理三种不同文件格式的方法：CSV、Excel和JSON。以这些格式呈现的数据可以轻松地被读取并呈现为DataFrame。
- en: 'The following are the methods needed for each of the file formats:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 每种文件格式所需的方法如下：
- en: '`read_csv()`: To read CSV files'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_csv()`: 读取CSV文件'
- en: '`read_json()`: To read JSON files'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_json()`: 读取JSON文件'
- en: '`read_excel()`: To read Excel files presented as `.xslx`'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_excel()`: 读取以`.xslx`格式呈现的Excel文件'
- en: Each of these methods can read data locally and from the internet. Also, these
    methods only have access to the local files in a `Node.js` environment. On the
    web, these methods can read provided files (CSV, JSON, and .`xslx` files) provided
    these files are available on the internet.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个都可以在本地和互联网上读取数据。此外，在`Node.js`环境中，这些方法只能访问本地文件。在网络上，这些方法可以读取提供的文件（CSV、JSON和`.xslx`文件），只要这些文件在互联网上可用。
- en: 'Let''s see how to read local files in the Node.js environment:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Node.js环境中读取本地文件：
- en: '[PRE58]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, we import the Node.js version of Danfo.js and then make a call to `read_csv()`
    to read the `titanic.csv` files available in the same directory. Note that if
    the file to be read is not in the same directory, you will need to specify the
    path.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入Node.js版本的Danfo.js，然后调用`read_csv()`来读取同一目录中可用的`titanic.csv`文件。请注意，如果要读取的文件不在同一目录中，您需要指定路径。
- en: '`df.head().print()` prints the first five rows of the DataFrame table in the
    Node.js console; the `print()` function is similar to the `table()` function we''ve
    been using in Dnotebook. We obtain the following table from the preceding code:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`df.head().print()`在Node.js控制台中打印DataFrame表的前五行；`print()`函数类似于我们在Dnotebook中使用的`table()`函数。我们从前面的代码中得到以下表格：'
- en: '![Figure 3.46 – DataFrame table read from a CSV file'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.46 – 从CSV文件读取的DataFrame表'
- en: '](img/B17076_3_46.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_46.jpg)'
- en: Figure 3.46 – DataFrame table read from a CSV file
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.46 – 从CSV文件读取的DataFrame表
- en: 'Similarly, the same thing can be done on the web, but we will be using the
    `http` link, which makes the same data available online:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以在网络上进行相同的操作，但我们将使用`http`链接，这样相同的数据就可以在线使用：
- en: '[PRE59]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This gives the same result as the previous code block. The same thing applies
    to all other file format methods:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一个代码块产生相同的结果。对所有其他文件格式方法也是一样的：
- en: '[PRE60]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `read_excel()` method accepts an optional config argument that ensures
    the Excel files are properly parsed:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_excel()`方法接受一个可选的配置参数，确保正确解析Excel文件：'
- en: '`source`: String, URL, or local file path to retrieve an Excel file.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：字符串、URL或本地文件路径，用于检索Excel文件。'
- en: '`sheet_name` (optional): The name of the sheet you want to parse. The default
    is the first sheet.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sheet_name`（可选）：要解析的工作表的名称。默认为第一个工作表。'
- en: '`header_index` (optional): int, index of the row that represents the header
    column.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header_index`（可选）：int，表示标题列的行索引。'
- en: '`data_index` (optional): int, index of the row that indicates where the data
    begins.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_index`（可选）：int，指示数据开始的行索引。'
- en: 'In the preceding code block, we specify the `header_index` value to be `7`
    since that''s where the header columns are located, hence we have the following
    result:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们将`header_index`的值指定为`7`，因为标题列位于那里，因此我们得到以下结果：
- en: '![Figure 3.47 – DataFrame table read from an Excel file'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.47 – 从Excel文件读取的DataFrame表'
- en: '](img/B17076_3_47.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_47.jpg)'
- en: Figure 3.47 – DataFrame table read from an Excel file
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.47 – 从Excel文件读取的DataFrame表
- en: 'The `read_json()` method is quite similar to `read_csv()` in terms of the argument
    being passed in; the method only accepts a URL to the JSON file or a directory
    path to where the JSON file is located:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_json()`方法在传递参数方面与`read_csv()`非常相似；该方法只接受指向JSON文件的URL或JSON文件所在目录路径：'
- en: '[PRE61]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This reads a file called `book.json` from the same directory and outputs the
    following:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这读取了同一目录中名为`book.json`的文件，并输出了以下内容：
- en: '![Figure 3.48 – DataFrame read from a JSON file'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.48 – 从JSON文件读取的DataFrame'
- en: '](img/B17076_3_48.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_3_48.jpg)'
- en: Figure 3.48 – DataFrame read from a JSON file
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.48 – 从JSON文件读取的DataFrame
- en: Also, Danfo.js contains an ultimate tabular file reader method called `reader`;
    this method can read both CSV and Excel. It can also read other files such as
    `Datapackage` as specified in the Frictionless specs at [https://frictionlessdata.io/](https://frictionlessdata.io/).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Danfo.js包含一个名为`reader`的终极表格文件读取方法；该方法可以读取CSV和Excel。它还可以读取其他文件，如[https://frictionlessdata.io/](https://frictionlessdata.io/)中Frictionless规范中指定的`Datapackage`。
- en: The `reader` method makes use of a package called `Frictionless.js` at [https://github.com/frictionlessdata/frictionless-js](https://github.com/frictionlessdata/frictionless-js)
    to read local or remote files.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader`方法使用名为`Frictionless.js`的包在[https://github.com/frictionlessdata/frictionless-js](https://github.com/frictionlessdata/frictionless-js)中读取本地或远程文件。'
- en: 'The `reader` method has the same API design as `read_csv` and `read_excel`,
    just that it can read both file types, as shown in the following code:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader`方法与`read_csv`和`read_excel`具有相同的API设计，只是它可以读取两种文件类型，如下面的代码所示：'
- en: '[PRE62]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: From the preceding code, we output the same table as shown in *Figure 3.48*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们输出了与*图3.48*中显示的相同的表格。
- en: Transforming a DataFrame into another file format
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将DataFrame转换为另一种文件格式
- en: After a series of data processing, we might want to transform our final DataFrame
    into a file format for proper saving. Danfo.js implements a method to transform
    a DataFrame into CSV format.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一系列数据处理后，我们可能希望将最终的DataFrame转换为文件格式以便保存。Danfo.js实现了一种将DataFrame转换为CSV格式的方法。
- en: 'Let''s convert the DataFrame we''ve created so far into a CSV file. Note that
    this will only work in a Node.js environment:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将迄今为止创建的DataFrame转换为CSV文件。请注意，这只适用于Node.js环境：
- en: '[PRE63]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This (`df.to_csv()`) saves the DataFrame in a CSV file in the path directory
    specified and with the name given to it (`path.csv`).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这（`df.to_csv()`）将DataFrame保存为CSV文件，保存在指定的路径目录中，并赋予给它的名称（path.csv）。
- en: In this section, we looked into reading files in different formats, such as
    CSV, JSON, and Excel, as available in Danfo.js. We looked into different methods
    of reading these files and we also looked into a more generic method for reading
    these file formats.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究了在Danfo.js中可用的不同格式的文件，如CSV、JSON和Excel。我们研究了读取这些文件的不同方法，还研究了一种更通用的读取这些文件格式的方法。
- en: We also saw how to convert a DataFrame into the file format specified by the
    user.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何将DataFrame转换为用户指定的文件格式。
- en: Summary
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through why Danfo.js is needed, then looked into what
    Series and DataFrames actually are. We also discussed some of the essential functionality
    available in Danfo.js and implemented it in DataFrames and Series.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为什么需要 Danfo.js，然后深入了解了 Series 和 DataFrames 的实际含义。我们还讨论了 Danfo.js 中一些基本功能，并在
    DataFrames 和 Series 中实现了这些功能。
- en: We also saw how we can use DataFrames and Series methods to handle and preprocess
    data. We saw how to filter a DataFrame based on column values. We also sorted
    a DataFrame by row index and column values. This chapter equips us to perform
    day-to-day data operations such as reading files in different formats, converting
    formats, and saving DataFrames after preprocessing into a desirable file format.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用 DataFrames 和 Series 方法来处理和预处理数据。我们学会了如何根据列值筛选 DataFrame。我们还按行索引和列值对
    DataFrame 进行了排序。本章使我们能够执行日常数据操作，如以不同格式读取文件、转换格式，并将预处理后的 DataFrames 保存为理想的文件格式。
- en: In the next chapter, we will look into data analysis, wrangling, and transformation.
    We will discuss data handling and preprocessing further and see how to handle
    missing numbers and how to deal with string and time series data.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究数据分析、数据整理和转换。我们将进一步讨论数据处理和预处理，并了解如何处理缺失的数字，以及如何处理字符串和时间序列数据。
