- en: '*Chapter 8*: RBAC Policies and Auditing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：RBAC策略和审计'
- en: Authentication is only the first step in managing access in a cluster. Once
    access to a cluster is granted, it's important to limit what accounts can do,
    depending on whether an account is for an automated system or a user. Authorizing
    access to resources is an important part of both protecting against accidental
    issues and bad actors looking to abuse a cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 认证只是集群访问管理的第一步。一旦集群访问权限被授予，限制账户的操作是很重要的，这取决于账户是用于自动化系统还是用户。授权访问资源是保护集群免受意外问题和恶意行为者滥用的重要部分。
- en: In this chapter, we're going to detail how Kubernetes authorizes access via
    its **Role-Based Access Control** (**RBAC**) model. The first part of this chapter
    will be a deep dive into how Kubernetes RBAC is configured, what options are available,
    and mapping the theory into practical examples. Debugging and troubleshooting
    RBAC policies will be the focus of the second half.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍Kubernetes如何通过其基于角色的访问控制（RBAC）模型授权访问。本章的第一部分将深入探讨Kubernetes RBAC的配置方式，可用的选项以及将理论映射到实际示例中。调试和故障排除RBAC策略将是第二部分的重点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to RBAC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC简介
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将企业身份映射到Kubernetes以授权访问资源
- en: Namespace multi-tenancy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间多租户
- en: Kubernetes auditing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes审计
- en: Using **audit2rbac** to debug policies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**audit2rbac**调试策略
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: A KinD cluster running with the configuration from [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203),
    *Integrating Authentication into Your Cluster*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)的配置运行的KinD集群，*将身份验证集成到您的集群*
- en: Access to the SAML2 lab from [*Chapter 6*](B15514_06_Final_ASB_ePub.xhtml#_idTextAnchor174),
    *Services, Load Balancing, and External DNS*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[*第6章*](B15514_06_Final_ASB_ePub.xhtml#_idTextAnchor174)的SAML2实验室访问，*服务、负载均衡和外部DNS*
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: Introduction to RBAC
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RBAC简介
- en: Before we jump into RBAC, let's take a quick look at the history of Kubernetes
    and access controls.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究RBAC之前，让我们快速了解一下Kubernetes和访问控制的历史。
- en: Before Kubernetes 1.6, access controls were based on **Attribute-Based Access
    Control** (**ABAC**). As the name implies, ABAC provides access by comparing a
    rule against attributes, rather than roles. The assigned attributes can be assigned
    any type of data, including user attributes, objects, environments, locations,
    and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.6之前，访问控制是基于基于属性的访问控制（ABAC）的。顾名思义，ABAC通过将规则与属性进行比较来提供访问权限，而不是角色。分配的属性可以分配任何类型的数据，包括用户属性、对象、环境、位置等。
- en: 'In the past, to configure a Kubernetes cluster for ABAC, you had to set two
    values on the API server:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，要为ABAC配置Kubernetes集群，您必须在API服务器上设置两个值：
- en: '**--authorization-policy-file**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--authorization-policy-file**'
- en: '**--authorization-mode=ABAC**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--authorization-mode=ABAC**'
- en: '**authorization-policy-file** is a local file on the API server. Since it''s
    a local file on each API server, any changes to the file require privileged access
    to the host and will require you to restart the API server. As you can imagine,
    the process to update ABAC policies becomes difficult and any immediate changes
    will require a short outage as the API servers are restarted.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**authorization-policy-file** 是API服务器上的本地文件。由于它是每个API服务器上的本地文件，对文件的任何更改都需要对主机进行特权访问，并且需要重启API服务器。可以想象，更新ABAC策略的过程变得困难，任何即时更改都将需要短暂的停机，因为API服务器正在重新启动。'
- en: Starting in Kubernetes 1.6, **RBAC** became the preferred method of authorizing
    access to resources. Unlike **ABAC**, **RBAC** uses Kubernetes native objects,
    and updates are reflected without restarts to the API servers. **RBAC** is also
    compatible with different authentication methods. From here, our focus will be
    on how to develop RBAC policies and applying them to your cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.6开始，**RBAC** 成为授权访问资源的首选方法。与**ABAC** 不同，**RBAC** 使用Kubernetes本机对象，更新可以在不重启API服务器的情况下反映出来。**RBAC**
    也与不同的身份验证方法兼容。从这里开始，我们的重点将放在如何开发RBAC策略并将其应用到您的集群上。
- en: What's a Role?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是角色？
- en: 'In Kubernetes, a Role is a way to tie together permissions into an object that
    can be described and configured. Roles have rules, which are a collection of resources
    and verbs. Working backward, we have the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，角色是将权限绑定到可以描述和配置的对象的一种方式。角色有规则，这些规则是资源和动词的集合。往回推，我们有以下内容：
- en: '**Verbs**: The actions that can be taken on an API, such as reading (**get**),
    writing (**create**, **update**, **patch**, and **delete**), or listing and watching.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动词**：可以在API上执行的操作，例如读取（**get**），写入（**create**，**update**，**patch**和**delete**），或列出和监视。'
- en: '**Resources**: Names of APIs to apply the verbs to, such as **services**, **endpoints**,
    and so on. Specific sub-resources may be listed as well. Specific resources can
    be named to provide very specific permissions on an object.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：要对其应用动词的API名称，例如**services**，**endpoints**等。也可以列出特定的子资源。可以命名特定资源以在对象上提供非常具体的权限。'
- en: A Role does not say who can perform the verbs on the resources—that is handled
    by **RoleBindings** and **ClusterRoleBindings**. We will learn more about these
    in the *RoleBindings and ClusterRoleBindings* section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 角色并不说明谁可以在资源上执行动词，这由**RoleBindings**和**ClusterRoleBindings**处理。我们将在*RoleBindings和ClusterRoleBindings*部分了解更多信息。
- en: Important Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The term "role" can have multiple meanings, and RBAC is often used in other
    contexts. In the enterprise world, the term "role" is often associated with a
    business role and used to convey entitlements to that role instead of a specific
    person. As an example, an enterprise may assign all accounts' payable staff the
    ability to issue checks instead of creating a specific assignment for each member
    of the accounts' payable department the specific permission in order to issue
    a check. When someone moves between roles, they lose the permissions from their
    old role and gain permisions for their new role. In the instance of moving from
    accounts payable to accounts receivable the user would lose the ability to make
    payments and gain the ability to accept payment. By tying the permisions to roles,
    instead of individuals, the change in permissions happens automatically with the
    role change instead of having to manually toggle permissions for each user. This
    is the more "classic" use of the term RBAC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“角色”可能有多重含义，并且RBAC经常在其他上下文中使用。在企业世界中，“角色”一词通常与业务角色相关联，并用于传达该角色的权限，而不是特定的个人。例如，企业可能会为所有应付账款人员分配发放支票的权限，而不是为应付账款部门的每个成员创建特定的分配以发放支票的特定权限。当某人在不同角色之间移动时，他们会失去旧角色的权限，并获得新角色的权限。例如，从应付账款到应收账款的转移中，用户将失去支付的能力并获得接受付款的能力。通过将权限与角色而不是个人绑定，权限的更改会随着角色更改而自动发生，而不必为每个用户手动切换权限。这是术语RBAC的更“经典”用法。
- en: 'Each resource that a rule will be built of is identified by the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则将构建的资源由以下内容标识：
- en: '**apiGroups**: A list of groups the resources are a member of'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**apiGroups**：资源所属的组列表'
- en: '**resources**: The name of the object type for the resource (and potentially
    sub-resources)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resources**：资源的对象类型的名称（可能还包括子资源）'
- en: '**resourceNames**: An optional list of specific objects to apply this rule
    to'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resourceNames**：要应用此规则的特定对象的可选列表'
- en: Each rule *must* have a list of **apiGroups** and **resources**. **resourceNames**
    is optional.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则*必须*有一个**apiGroups**和**resources**的列表。**resourceNames**是可选的。
- en: Important Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you find yourself authorizing access to specific objects in a namespace from
    within that namespace, it's time to rethink your authorization strategy. Kubernetes'
    tenant boundary is the namespace. Except for very specific reasons, naming specific
    Kubernetes objects in an RBAC Role is an anti-pattern and should be avoided. When
    specific objects are being named by RBAC Roles, consider breaking up the namespace
    they're in to create separate namespaces.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己从命名空间内部授权对特定对象的访问权限，那么是时候重新思考您的授权策略了。Kubernetes的租户边界是命名空间。除非有非常特定的原因，否则在RBAC角色中命名特定的Kubernetes对象是一种反模式，应该避免。当RBAC角色命名特定对象时，请考虑分割它们所在的命名空间以创建单独的命名空间。
- en: Once the resource is identified in a rule, verbs can be specified. A verb is
    an action that can be taken on the resource, providing access to the object in
    Kubernetes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在规则中标识了资源，就可以指定动词。动词是可以在资源上执行的操作，从而在Kubernetes中提供对对象的访问权限。
- en: If the desired access to an object should be **all**, you do not need to add
    each verb; instead, the wildcard character may be used to identify all the **verbs**,
    **resources**, or **apiGroups**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对对象的期望访问应为**all**，则无需添加每个动词；相反，可以使用通配符字符来标识所有**动词**、**资源**或**apiGroups**。
- en: Identifying a Role
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别角色
- en: 'The Kubernetes authorization page ([https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/))
    uses the following Role as an example to allow someone to get the details of a
    pod and its logs:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes授权页面（[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)）使用以下角色作为示例，允许某人获取pod及其日志的详细信息：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: Role'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：角色
- en: 'metadata:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'namespace: default'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'name: pod-and-pod-logs-reader'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：pod-and-pod-logs-reader
- en: 'rules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups: [""]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: [""]'
- en: 'resources: ["pods", "pods/log"]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：["pods", "pods/log"]
- en: 'verbs: ["get", "list"]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：["get", "list"]
- en: Working backward to determine how this Role was defined, we will start with
    **resources**, since it is the easiest aspect to find. All objects in Kubernetes
    are represented by URLs. If you want to pull all the information about the pods
    in the default namespace, you would call the **/api/v1/namespaces/default/pods**
    URL, and if you wanted the logs for a specific pod, you would call the **/api/v1/namespaces/default/pods/mypod/log**
    URL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向确定此角色是如何定义的，我们将从**资源**开始，因为这是最容易找到的方面。Kubernetes中的所有对象都由URL表示。如果要获取默认命名空间中有关pod的所有信息，您将调用**/api/v1/namespaces/default/pods**
    URL，如果要获取特定pod的日志，您将调用**/api/v1/namespaces/default/pods/mypod/log** URL。
- en: The URL pattern will be true of all namespace-scoped objects. **pods** lines
    up to **resources**, as does **pods/log**. When trying to identify which resources
    you want to authorize, use the **api-reference** document from the Kubernetes
    API documentation at [https://kubernetes.io/docs/reference/#api-reference](https://kubernetes.io/docs/reference/#api-reference).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此URL模式适用于所有命名空间范围的对象。**pods**与**资源**对齐，**pods/log**也是如此。在尝试确定要授权的资源时，请使用Kubernetes
    API文档中的**api-reference**文档[https://kubernetes.io/docs/reference/#api-reference](https://kubernetes.io/docs/reference/#api-reference)。
- en: If you are trying to access an additional path component after the name of the
    object (such as with status and logs on pods), it needs to be explicitly authorized.
    Authorizing pods does not immediately authorize logs or status.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在对象名称之后访问其他路径组件（例如在pod上的状态和日志），则需要明确授权。授权pod并不立即授权日志或状态。
- en: Based on the use of URL mapping to **resources**, your next thought may be that
    **verbs** is going to be HTTP verbs. This is not the case. There is no **GET**
    verb in Kubernetes. Verbs are instead defined by the schema of the object in the
    API server. The good news is that there's a static mapping between HTTP verbs
    and RBAC verbs (https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb).
    Looking at this URL, notice that there are verbs on top of the HTTP verbs for
    **PodSecurityPolicies** and impersonation. That's because the **RBAC** model is
    used beyond authorizing specific APIs and is also used to authorize who can impersonate
    users and how to assign a **PodSecurityPolicy** object. The focus of this chapter
    is going to be on the standard HTTP verb mappings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于使用URL映射到**资源**，你可能会认为**动词**将是HTTP动词。但事实并非如此。在Kubernetes中没有**GET**动词。动词是由API服务器中对象的模式定义的。好消息是，HTTP动词和RBAC动词之间有静态映射（https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb）。查看此URL时，请注意**PodSecurityPolicies**和模拟的HTTP动词之上有动词。这是因为**RBAC**模型不仅用于授权特定API，还用于授权谁可以模拟用户以及如何分配**PodSecurityPolicy**对象。本章重点将放在标准HTTP动词映射上。
- en: The final component to identify is **apiGroups**. This is an additional area
    of inconsistency from the URL model. **pods** is part of the "core" group, but
    the **apiGroups** list is just an empty string (**""**). These are legacy APIs
    that were part of the original Kubernetes. Most other APIs will be in an API group
    and that group will be part of their URL. You can find the group by looking at
    the API documentation for the object you are looking to authorize.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要识别的组件是 **apiGroups**。这是来自 URL 模型的另一个不一致的地方。**pods** 是“core”组的一部分，但 **apiGroups**
    列表只是一个空字符串（**""**）。这些是最初 Kubernetes 的一部分的传统 API。大多数其他 API 将在 API 组中，并且该组将成为它们的
    URL 的一部分。您可以通过查看要授权的对象的 API 文档来找到该组。
- en: The inconsistencies in the RBAC model can make debugging difficult, to say the
    least. The last lab in this chapter will walk through the debugging process and
    take much of the guesswork out of defining your rules.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 模型中的不一致性可能会使调试变得困难，至少可以这么说。本章的最后一个实验将介绍调试过程，并消除定义规则时的大部分猜测。
- en: Now that we've defined the contents of a Role and how to define specific permissions,
    it's important to note that Roles can be applied at both the namespace and cluster
    level.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 Role 的内容以及如何定义特定权限，重要的是要注意，Role 可以应用于命名空间和集群级别。
- en: Roles versus ClusterRoles
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色与 ClusterRoles
- en: 'RBAC rules can be scoped either to specific namespaces or to the entire cluster.
    Taking our preceding example, if we defined it as a ClusterRole instead of a Role,
    and removed the namespace, we would have a Role that authorizes someone to get
    the details and logs of all pods across the cluster. This new role could alternatively
    be used in individual namespaces to assign the permissions to the pods in a specific
    namespace:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 规则可以针对特定命名空间或整个集群进行范围限定。以前面的示例为例，如果我们将其定义为 ClusterRole 而不是 Role，并移除命名空间，我们将得到一个授权某人获取整个集群中所有
    pod 的详细信息和日志的 Role。这个新角色也可以用于单独的命名空间，以将权限分配给特定命名空间中的 pod：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRole'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'metadata:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: cluster-pod-and-pod-logs-reader'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-pod-and-pod-logs-reader
- en: 'rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups: [""]'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: [""]'
- en: 'resources: ["pods", "pods/log"]'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：["pods", "pods/log"]
- en: 'verbs: ["get", "list"]'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：["get", "list"]
- en: Whether this permission is applied globally across a cluster or within the scope
    of a specific namespace depends on how it's bound to the subjects it applies to.
    This will be covered in the *RoleBindings and ClusterRoleBindings* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个权限是全局应用于集群还是在特定命名空间范围内取决于它绑定到的主体。这将在 *RoleBindings 和 ClusterRoleBindings*
    部分进行介绍。
- en: In addition to applying a set of rules across the cluster, ClusterRoles are
    used to apply rules to resources that aren't mapped to a namespace, such as PersistentVolume
    and StorageClass objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在集群中应用一组规则外，ClusterRoles 也用于将规则应用于未映射到命名空间的资源，例如 PersistentVolume 和 StorageClass
    对象。
- en: After understanding how a Role is defined, let's understand the different ways
    Roles can be designed for specific purposes. In the next sections, we'll look
    at different patterns for defining Roles and their application in a cluster.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何定义 Role 之后，让我们了解一下为特定目的设计 Role 的不同方式。在接下来的部分中，我们将看看定义 Role 和它们在集群中的应用的不同模式。
- en: Negative Roles
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负面角色
- en: 'One of the most common requests for authorization is "*can I write a Role that
    lets me do everything EXCEPT xyz*?". In RBAC, the answer is *NO*. RBAC requires
    either every resource to be allowed or specific resources and verbs to be enumerated.
    There are two reasons for this in RBAC:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 授权的最常见请求之一是“*我能否编写一个让我做除 xyz 之外的所有事情的 Role*？”在 RBAC 中，答案是*不行*。RBAC 要求要么允许每个资源，要么枚举特定资源和动词。这在
    RBAC 中有两个原因：
- en: '**Better security through simplicity**: Being able to enforce a rule that says
    *every Secret except this one* requires a much more complex evaluation engine
    than RBAC provides. The more complex an engine, the harder it is to test and validate,
    and the easier it is to break. A simpler engine is just simpler to code and keep
    secure.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过简单实现更好的安全性**：能够执行一条规则，说*每个秘密除了这一个*，需要比RBAC提供的更复杂的评估引擎。引擎越复杂，测试和验证就越困难，破坏的可能性就越大。一个更简单的引擎只是更容易编码和保持安全。'
- en: '**Unintended consequences**: Allowing someone to do everything *except* xyz
    leaves the door open for issues in unintended ways as the cluster grows and new
    capabilities are added.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意想不到的后果：允许某人做任何事情，*除了* xyz，会在集群不断增长并添加新功能时以意想不到的方式留下问题的可能性。
- en: On the first point, building an engine with this capability is difficult to
    build and maintain. It also makes the rules much harder to keep track of. To express
    this type of rule, you need to not only have authorization rules but also an order
    to those rules. For instance, to say *I want to allow everything except this Secret*,
    you would first need a rule that says *allow everything* and then a rule that
    says *deny this secret*. If you switch the rules to say *deny this secret* then
    *allow everything*, the first rule would be overridden. You could assign priorities
    to different rules, but that now makes it even more complex.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一点上，构建具有这种功能的引擎很难构建和维护。这也使规则更难以跟踪。要表达这种类型的规则，你不仅需要授权规则，还需要对这些规则进行排序。例如，要说*我想允许一切，除了这个秘密*，你首先需要一个规则，说*允许一切*，然后一个规则，说*拒绝这个秘密*。如果你把规则改成*拒绝这个秘密*然后*允许一切*，第一个规则将被覆盖。你可以为不同的规则分配优先级，但这会使事情变得更加复杂。
- en: There are ways to implement this pattern, either by using a custom authorization
    webhook or by using a controller to dynamically generate RBAC **Role** objects.
    These should both be considered security anti-patterns and so won't be covered
    in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这种模式，可以使用自定义授权webhook或使用控制器动态生成RBAC **Role**对象。这两种方法都应被视为安全反模式，因此本章不涉及这些内容。
- en: The second point deals with unintended consequences. It's becoming more popular
    to support the provisioning of infrastructure that isn't Kubernetes using the
    operator pattern, where a custom controller looks for new instances of a **CustomResourceDefinition**
    (**CRD**) to provision infrastructure such as databases. Amazon Web Services publishes
    an operator for this purpose ([https://github.com/aws/aws-controllers-k8s](https://github.com/aws/aws-controllers-k8s)).
    These operators run in their own namespaces with administrative credentials for
    their cloud looking for new instances of their objects to provision resources.
    If you have a security model that allows everything "except…", then once deployed,
    anyone in your cluster can provision cloud resources that have real costs and
    can create security holes. Enumerating your resources, from a security perspective,
    is an important part of knowing what is running and who has access.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点涉及意想不到的后果。支持使用操作员模式支持不是Kubernetes的基础设施的供应变得越来越流行，其中自定义控制器寻找**CustomResourceDefinition**（**CRD**）的新实例来供应基础设施，如数据库。亚马逊网络服务为此目的发布了一个操作员（[https://github.com/aws/aws-controllers-k8s](https://github.com/aws/aws-controllers-k8s)）。这些操作员在其自己的命名空间中以其云的管理凭据运行，寻找其对象的新实例来供应资源。如果你有一个允许一切“除了…”的安全模型，那么一旦部署，你集群中的任何人都可以供应具有实际成本并可能造成安全漏洞的云资源。从安全的角度来枚举你的资源是了解正在运行的内容和谁有访问权限的重要部分。
- en: The trend of Kubernetes clusters is to provide more control over infrastructure
    outside of the cluster via the custom resource API. You can provision anything
    from VMs to additional nodes, to any kind of API-driven cloud infrastructure.
    There are other tools you can use besides RBAC to mitigate the risk of someone
    creating a resource they shouldn't, but these should be secondary measures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群的趋势是通过自定义资源API在集群外提供对基础设施的更多控制。您可以为VM、额外节点或任何类型的API驱动云基础设施提供任何内容。除了RBAC之外，您还可以使用其他工具来减轻某人创建不应该创建的资源的风险，但这些应该是次要措施。
- en: Aggregated ClusterRoles
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合的ClusterRoles
- en: 'ClusterRoles can become confusing quickly and be difficult to maintain. It''s
    best to break them up into smaller ClusterRoles that can be combined as needed.
    Take the admin ClusterRole, which is designed to let someone do generally anything
    inside of a specific namespace. When we look at the admin ClusterRole, it enumerates
    just about every resource there is. You may think someone wrote this ClusterRole
    so that it would contain all those resources, but that would be really inefficient,
    and what happens as new resource types get added to Kubernetes? The admin ClusterRole
    is an aggregated ClusterRole. Take a look at the **ClusterRole**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRoles可能会很快变得令人困惑并且难以维护。最好将它们分解为较小的ClusterRoles，以根据需要进行组合。以管理员ClusterRole为例，它旨在让某人在特定命名空间内做任何事情。当我们查看管理员ClusterRole时，它列举了几乎所有资源。您可能会认为有人编写了这个ClusterRole，以便它包含所有这些资源，但那将非常低效，而且随着新的资源类型被添加到Kubernetes，会发生什么？管理员ClusterRole是一个聚合的ClusterRole。看一下**ClusterRole**：
- en: 'kind: ClusterRole'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'metadata:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: admin'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：admin
- en: 'labels:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标签：
- en: 'kubernetes.io/bootstrapping: rbac-defaults'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: kubernetes.io/bootstrapping：rbac-defaults
- en: 'annotations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：
- en: 'rbac.authorization.kubernetes.io/autoupdate: ''true'''
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: rbac.authorization.kubernetes.io/autoupdate：'true'
- en: 'rules:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: 'aggregationRule:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: aggregationRule：
- en: 'clusterRoleSelectors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: clusterRoleSelectors：
- en: '- matchLabels:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '- 匹配标签：'
- en: 'rbac.authorization.k8s.io/aggregate-to-admin: ''true'''
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: rbac.authorization.k8s.io/aggregate-to-admin：'true'
- en: 'The key is the **aggregationRule** section. This section tells Kubernetes to
    combine the rules for all ClusterRoles where the **rbac.authorization.k8s.io/aggregate-to-admin**
    label is true. When a new CRD is created, an admin is not able to create instances
    of that CRD without adding a new ClusterRole that includes this label. To allow
    namespace admin users to create an instance of the new **myapi**/**superwidget**
    objects, create a new **ClusterRole**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是**aggregationRule**部分。该部分告诉Kubernetes将所有具有**rbac.authorization.k8s.io/aggregate-to-admin**标签为true的ClusterRoles的规则合并起来。当创建新的CRD时，管理员无法创建该CRD的实例，而不添加包含此标签的新ClusterRole。为了允许命名空间管理员用户创建新的**myapi**/**superwidget**对象的实例，创建一个新的**ClusterRole**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRole'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'metadata:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: aggregate-superwidget-admin'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：aggregate-superwidget-admin
- en: 'labels:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标签：
- en: Add these permissions to the "admin" default role.
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将这些权限添加到“admin”默认角色。
- en: 'rbac.authorization.k8s.io/aggregate-to-admin: "true"'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: rbac.authorization.k8s.io/aggregate-to-admin："true"
- en: 'rules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups: ["myapi"]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups：["myapi"]'
- en: 'resources: ["superwidgets"]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：["superwidgets"]
- en: 'verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：["get"，"list"，"watch"，"create"，"update"，"patch"，"delete"]
- en: The next time you look at the admin ClusterRole, it will include **myapi**/**superwidgets**.
    You can also reference this ClusterRole directly for more specific permissions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下次您查看管理员ClusterRole时，它将包括**myapi**/**superwidgets**。您还可以直接引用此ClusterRole以获取更具体的权限。
- en: RoleBindings and ClusterRoleBindings
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RoleBindings和ClusterRoleBindings
- en: 'Once a permission is defined, it needs to be assigned to something to enable
    it. "Something" can be a user, a group, or a service account. These options are
    referred to as subjects. Just as with Roles and ClusterRoles, a RoleBinding binds
    a Role or ClusterRole to a specific namespace and a ClusterRoleBinding will apply
    a ClusterRole across the cluster. A binding can have many subjects but may only
    reference a single Role or ClusterRole. To assign the **pod-and-pod-logs-reader**
    Role created earlier in this chapter to a service account called **mysa** in the
    default namespace, a user named **podreader**, or anyone with the **podreaders**
    group, create a **RoleBinding**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦权限被定义，就需要将其分配给某个东西以启用它。这个“东西”可以是用户、组或服务账户。这些选项被称为主题。与角色和ClusterRoles一样，RoleBinding将一个角色或ClusterRole绑定到特定的命名空间，而ClusterRoleBinding将在整个集群中应用一个ClusterRole。一个绑定可以有多个主题，但只能引用一个单一的角色或ClusterRole。为了将本章前面创建的**pod-and-pod-logs-reader**角色分配给默认命名空间中名为**mysa**的服务账户、名为**podreader**的用户，或者拥有**podreaders**组的任何人，创建一个**RoleBinding**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：rbac.authorization.k8s.io/v1
- en: 'kind: RoleBinding'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：RoleBinding
- en: 'metadata:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: pod-and-pod-logs-reader'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：pod-and-pod-logs-reader
- en: 'namespace: default'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'subjects:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- kind: ServiceAccount'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：ServiceAccount'
- en: 'name: mysa'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：mysa
- en: 'namespace: default'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: api组：rbac.authorization.k8s.io
- en: '- kind: User'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：用户'
- en: 'name: podreader'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreader
- en: '- kind: Group'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：组'
- en: 'name: podreaders'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreaders
- en: 'roleRef:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: roleRef：
- en: 'kind: Role'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：角色
- en: 'name: pod-and-pod-logs-reader'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：pod-and-pod-logs-reader
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: api组：rbac.authorization.k8s.io
- en: 'The preceding **RoleBinding** lists three different subjects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的**RoleBinding**列出了三个不同的主题：
- en: '**ServiceAccount**: Any service account in the cluster can be authorized to
    a RoleBinding. The namespace must be included since a RoleBinding could authorize
    a service account in any namespace, not just the one the RoleBinding is defined
    in.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ServiceAccount**：集群中的任何服务账户都可以被授权为RoleBinding。必须包含命名空间，因为RoleBinding可以授权任何命名空间中的服务账户，而不仅仅是定义RoleBinding的命名空间。'
- en: '**User**: A user is asserted by the authentication process. Remember from [*Chapter
    7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203), *Integrating Authentication
    into Your Cluster*, that there are no objects in Kubernetes that represent users.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：用户是由认证过程断言的。请记住来自[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)，*将认证集成到您的集群中*，在Kubernetes中没有代表用户的对象。'
- en: '**Group**: Just as with users, groups are asserted as part of the authentication
    process and have an object associated with them.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：与用户一样，组也是认证过程的一部分，并与一个对象相关联。'
- en: 'Finally, the Role we created earlier is referenced. In a similar fashion, to
    assign the same subjects the ability to read pods and their logs across the cluster,
    a ClusterRoleBinding can be created to reference the **cluster-pod-and-pod-logs-reader**
    ClusterRole created earlier in the chapter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们引用了之前创建的角色。类似地，为了将相同的主题赋予在整个集群中读取pod及其日志的能力，可以创建一个ClusterRoleBinding来引用本章前面创建的**cluster-pod-and-pod-logs-reader**
    ClusterRole：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRoleBinding'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: cluster-pod-and-pod-logs-reader'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-pod-and-pod-logs-reader
- en: 'subjects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- kind: ServiceAccount'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：ServiceAccount'
- en: 'name: mysa'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：mysa
- en: 'namespace: default'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: api组：rbac.authorization.k8s.io
- en: '- kind: User'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：用户'
- en: 'name: podreader'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreader
- en: '- kind: Group'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：组'
- en: 'name: podreaders'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreaders
- en: 'roleRef:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: roleRef：
- en: 'kind: ClusterRole'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRole
- en: 'name: cluster-pod-and-pod-logs-reader'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-pod-and-pod-logs-reader
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: api组：rbac.authorization.k8s.io
- en: The **ClusterRoleBinding** is bound to the same subjects, but is instead bound
    to a ClusterRole instead of a namespace-bound Role. Now, instead of having the
    ability to read pod details and pod/logs in the default namespace, these users
    can read all pod details and pod/logs in all namespaces.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**ClusterRoleBinding**绑定到相同的主体，但是绑定到一个ClusterRole而不是命名空间绑定的Role。现在，这些用户可以读取所有命名空间中的所有pod详情和pod/logs，而不是只能读取默认命名空间中的pod详情和pod/logs。'
- en: Combining ClusterRoles and RoleBindings
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合ClusterRoles和RoleBindings
- en: 'We have a use case where a log aggregator wants to pull logs from pods in multiple
    namespaces, but not all namespaces. A ClusterRoleBinding is too broad. While the
    Role could be recreated in each namespace, this is inefficient and a maintenance
    headache. Instead, define a ClusterRole but reference it from a RoleBinding in
    the applicable namespaces. This allows the reuse of permission definitions while
    still applying those permissions to specific namespaces. In general, note the
    following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个使用案例，日志聚合器希望从多个命名空间中的pod中拉取日志，但不是所有命名空间。ClusterRoleBinding太宽泛了。虽然Role可以在每个命名空间中重新创建，但这样做效率低下且维护困难。相反，定义一个ClusterRole，但在适用的命名空间中从RoleBinding中引用它。这允许重用权限定义，同时仍将这些权限应用于特定的命名空间。一般来说，请注意以下内容：
- en: ClusterRole + ClusterRoleBinding = cluster-wide permission
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClusterRole + ClusterRoleBinding = 集群范围的权限
- en: ClusterRole + RoleBinding = namespace-specific permission
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClusterRole + RoleBinding = 特定于命名空间的权限
- en: 'To apply our ClusterRoleBinding in a specific namespace, create a Role, referencing
    the **ClusterRole** instead of a namespaced **Role** object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定命名空间中应用我们的ClusterRoleBinding，创建一个Role，引用**ClusterRole**而不是命名空间的**Role**对象：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'kind: RoleBinding'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：RoleBinding
- en: 'metadata:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: pod-and-pod-logs-reader'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：pod-and-pod-logs-reader
- en: 'namespace: default'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'subjects:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 主体：
- en: '- kind: ServiceAccount'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '- 种类：ServiceAccount'
- en: 'name: mysa'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：mysa
- en: 'namespace: default'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：默认
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: '- kind: User'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '- 种类：用户'
- en: 'name: podreader'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreader
- en: '- kind: Group'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '- 种类：组'
- en: 'name: podreaders'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：podreaders
- en: 'roleRef:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 角色引用：
- en: 'kind: ClusterRole'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'name: cluster-pod-and-pod-logs-reader'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-pod-and-pod-logs-reader
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: The preceding **RoleBinding** lets us reuse the existing **ClusterRole**. This
    cuts down on the number of objects that need to be tracked in the cluster and
    makes it easier to update permissions cluster-wide if the ClusterRole permissions
    need to change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的**RoleBinding**让我们重用现有的**ClusterRole**。这减少了需要在集群中跟踪的对象数量，并且使得在ClusterRole权限需要更改时更容易更新权限。
- en: Having built our permissions and defined how to assign them, next we'll look
    at how to map enterprise identities into cluster policies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了我们的权限并定义了如何分配它们之后，接下来我们将看看如何将企业身份映射到集群策略中。
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将企业身份映射到Kubernetes以授权对资源的访问
- en: 'One of the benefits of centralizing authentication is leveraging the enterprise''s
    existing identities instead of having to create new credentials that users that
    interact with your clusters need to remember. It''s important to know how to map
    your policies to these centralized users. In [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203),
    *Integrating Authentication into Your Cluster*, you created a cluster and integrated
    it with either **Active Directory Federation Services** (**ADFS**) or Tremolo
    Security''s testing identity provider. To finish the integration, the following
    **ClusterRoleBinding** was created:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 集中身份验证的好处之一是利用企业现有的身份，而不是必须创建用户需要记住的新凭据。重要的是要知道如何将您的策略映射到这些集中的用户。在[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)中，*将身份验证集成到您的集群*，您创建了一个集群，并将其与**Active
    Directory联合服务**（**ADFS**）或Tremolo Security的测试身份提供者集成。为了完成集成，创建了以下**ClusterRoleBinding**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRoleBinding'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: ou-cluster-admins'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：ou-cluster-admins
- en: 'subjects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- kind: Group'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：组'
- en: 'name: k8s-cluster-admins'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：k8s-cluster-admins
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: 'roleRef:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: roleRef：
- en: 'kind: ClusterRole'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRole
- en: 'name: cluster-admin'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-admin
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: This binding allows all users that are members of the **k8s-cluster-admins**
    group to have full cluster access. At the time, the focus was on authentication,
    so there weren't many details provided as to why this binding was created.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定允许所有属于**k8s-cluster-admins**组的用户拥有完整的集群访问权限。当时，重点是身份验证，所以并没有提供太多关于为什么创建这个绑定的细节。
- en: 'What if we wanted to authorize our users directly? That way, we have control
    over who has access to our cluster. Our RBAC **ClusterRoleBinding** would look
    different:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接授权我们的用户会怎样？这样，我们就可以控制谁可以访问我们的集群。我们的RBAC **ClusterRoleBinding**会有所不同：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRoleBinding'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: ou-cluster-admins'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：ou-cluster-admins
- en: 'subjects:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- kind: User'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：用户'
- en: 'name: https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp#mlbiamext'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp#mlbiamext
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: 'roleRef:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: roleRef：
- en: 'kind: ClusterRole'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRole
- en: 'name: cluster-admin'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-admin
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroup：rbac.authorization.k8s.io
- en: Using the same ClusterRole as before, this ClusterRoleBinding will assign the
    **cluster-admin** privileges only to my testing user.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的ClusterRole，这个ClusterRoleBinding将仅将**cluster-admin**权限分配给我的测试用户。
- en: The first issue to point out is that the user has the URL of our OpenID Connect
    issuer in front of the username. When OpenID Connect was first introduced, it
    was thought that Kubernetes would integrate with multiple identity providers and
    different types of identity providers, so the developers wanted you to be able
    to easily distinguish between users from different identity sources. For instance,
    **mlbiamext** in domain 1 is a different user then **mlbiamext** in domain 2\.
    To ensure that a user's identity doesn't collide with another user across identity
    providers, Kubernetes requires the identity provider's issuer to be prepended
    to your user. This rule doesn't apply if the username claim defined in your API
    server flags is mail. It also doesn't apply if you're using certificates or impersonation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要指出的问题是用户在用户名前面有我们的 OpenID Connect 发行者的URL。当 OpenID Connect 首次引入时，人们认为 Kubernetes
    将与多个身份提供者和不同类型的身份提供者集成，因此开发人员希望您能够轻松区分来自不同身份来源的用户。例如，域1中的**mlbiamext**与域2中的**mlbiamext**是不同的用户。为确保用户的身份不会与来自身份提供者的另一个用户发生冲突，Kubernetes
    要求在用户之前添加身份提供者的发行者。如果在 API 服务器标志中定义的用户名声明是邮件，则不适用此规则。如果您使用证书或模拟，则也不适用此规则。
- en: 'Beyond the inconsistent implementation requirements, this approach can cause
    problems in a few ways:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不一致的实施要求，这种方法还可能在几个方面引起问题：
- en: '**Changing your identity provider URL**: Today, you''re using an identity provider
    at one URL, but tomorrow you decide to move it. Now, you need to go through every
    ClusterRoleBinding and update them.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改您的身份提供者URL**：今天，您在一个URL上使用一个身份提供者，但明天您决定将其移动。现在，您需要查看每个 ClusterRoleBinding
    并对其进行更新。'
- en: '**Audits**: You can''t query for all RoleBindings associated with a user. You
    need to instead enumerate every binding.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：您无法查询与用户关联的所有 RoleBindings。您需要枚举每个绑定。'
- en: '**Large bindings**: Depending on how many users you have, your bindings can
    get quite large and difficult to track.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型绑定**：根据您拥有的用户数量，您的绑定可能会变得非常庞大且难以跟踪。'
- en: While there are tools you can use to help manage these issues, it's much easier
    to associate your bindings with groups instead of individual users. You could
    use the **mail** attribute to avoid the URL prefix, but that is considered an
    anti-pattern and will result in equally difficult changes to your cluster if an
    email address changes for any reason.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些工具可以帮助您管理这些问题，但将绑定与组关联起来要比将其与个人用户关联起来容易得多。您可以使用**mail**属性来避免URL前缀，但这被认为是一种反模式，如果出于任何原因更改了电子邮件地址，将导致对集群的同样困难的更改。
- en: So far in this chapter, we have learned how to define access policies and map
    those policies to enterprise users. Next, we need to determine how clusters will
    be divided into tenants.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何定义访问策略并将这些策略映射到企业用户。接下来，我们需要确定如何将集群划分为租户。
- en: Implementing namespace multi-tenancy
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施命名空间多租户
- en: 'Clusters deployed for multiple stakeholders, or tenants, should be divided
    up by namespace. This is the boundary that was designed into Kubernetes from the
    very beginning. When deploying namespaces, there are generally two ClusterRoles
    that are assigned to users in the namespace:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个利益相关者或租户部署的集群应该按命名空间划分。这是 Kubernetes 从一开始就设计的边界。在部署命名空间时，通常会为命名空间中的用户分配两个
    ClusterRoles：
- en: '**admin**: This aggregated ClusterRole provides access to every verb and nearly
    every resource that ships with Kubernetes, making the admin user the ruler of
    their namespace. The exception to this is any namespace-scoped object that could
    affect the entire cluster, such as **ResourceQuotas**.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**：这个聚合的 ClusterRole 提供了对 Kubernetes 提供的几乎每个资源的每个动词的访问权限，使管理员用户成为其命名空间的统治者。唯一的例外是可能影响整个集群的命名空间范围对象，例如**ResourceQuotas**。'
- en: '**edit**: Similar to **admin**, but without the ability to create RBAC Roles
    or RoleBindings.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**：类似于**admin**，但没有创建RBAC角色或RoleBindings的能力。'
- en: It's important to note that the **admin** ClusterRole can't make changes to
    the namespace object by itself. Namespaces are cluster-wide resources, so they
    can only be assigned permissions via a ClusterRoleBinding.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，**admin** ClusterRole 本身不能对命名空间对象进行更改。命名空间是集群范围的资源，因此只能通过 ClusterRoleBinding
    分配权限。
- en: 'Depending on your strategy for multi-tenancy, the **admin** ClusterRole may
    not be appropriate. The ability to generate RBAC Role and RoleBinding objects
    means that a namespace admin may grant themselves the ability to change resource
    quotas or run elevated PodSecurityPolicy privileges. This is where RBAC tends
    to fall apart and needs some additional options:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的多租户策略，**admin** ClusterRole 可能不合适。生成 RBAC Role 和 RoleBinding 对象的能力意味着命名空间管理员可以授予自己更改资源配额或运行提升的
    PodSecurityPolicy 权限的能力。这就是 RBAC 倾向于崩溃并需要一些额外选项的地方：
- en: '**Don''t grant access to Kubernetes**: Many cluster owners want to keep Kubernetes
    out of the hands of their users and limit their interaction to external CI/CD
    tools. This works well with microservices but begins to fall apart on multiple
    lines. First, more legacy applications being moved into Kubernetes means more
    legacy administrators needing to directly access their namespace. Second, if the
    Kubernetes team keeps users out of the clusters, they are now responsible. The
    people who own Kubernetes may not want to be the reason things aren''t happening
    the way application owners want them to and often, the application owners want
    to be able to control their own infrastructure to ensure they can handle any situation
    that impacts their own performance.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要授予对Kubernetes的访问权限**：许多集群所有者希望让他们的用户远离Kubernetes，并将其互动限制在外部CI/CD工具上。这对于微服务来说效果很好，但在多条线上开始出现问题。首先，将更多的传统应用程序移入Kubernetes意味着需要更多的传统管理员直接访问其命名空间。其次，如果Kubernetes团队让用户远离集群，他们现在就要负责了。拥有Kubernetes的人可能不想成为应用程序所有者希望的事情没有发生的原因，而且通常，应用程序所有者希望能够控制自己的基础设施，以确保他们能够处理任何影响其性能的情况。'
- en: '**Treat access as privileged**: Most enterprises require a privileged user
    to access infrastructure. This is typically done using a privileged access model
    where an admin has a separate account that needs to be "checked out" in order
    to use it and is only authorized at certain times as approved by a "change board"
    or process. The use of these accounts is closely monitored. This is a good approach
    if you already have a system in place, especially one that integrates with your
    enterprise''s central authentication system.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将访问视为特权：大多数企业都需要特权用户才能访问基础设施。这通常是使用特权访问模型来完成的，其中管理员有一个单独的帐户，需要“签出”才能使用，并且只在“变更委员会”或流程批准的特定时间内获得授权。对这些帐户的使用受到严格监控。如果您已经有一个系统，特别是一个与企业的中央身份验证系统集成的系统，这是一个很好的方法。
- en: '**Give each tenant a cluster**: This model moves multi-tenancy from the cluster
    to the infrastructure layer. You haven''t eliminated the problem, only moved where
    it is addressed. This can lead to sprawl that becomes unmanageable and can skyrocket
    costs depending on how you are implementing Kubernetes.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为每个租户提供一个集群**：这种模式将多租户从集群移动到基础设施层。您并没有消除问题，只是移动了解决问题的地方。这可能导致无法管理的蔓延，并且根据您如何实施
    Kubernetes，成本可能会飙升。'
- en: '**Admission controllers**: These augment RBAC by limiting which objects can
    be created. For instance, an admission controller can decide to block an RBAC
    policy from being created, even if RBAC explicitly allows it. This topic will
    be covered in [*Chapter 11*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272),
    *Extending Security Using Open Policy Agent*.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准入控制器**：这些通过限制可以创建哪些对象来增强 RBAC。例如，准入控制器可以决定阻止创建 RBAC 策略，即使 RBAC 明确允许。这个主题将在
    [*第 11 章*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272)，*使用 Open Policy Agent
    扩展安全性* 中介绍。'
- en: In addition to authorizing access to namespaces and resources, a multi-tenant
    solution needs to know how to provision tenants. This topic will be covered in
    the final chapter, [*Chapter 14*](B15514_14_Final_ASB_ePub.xhtml#_idTextAnchor337),
    *Provisioning a Platform*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了授权访问命名空间和资源外，多租户解决方案还需要知道如何提供租户。这个主题将在最后一章，[*第 14 章*](B15514_14_Final_ASB_ePub.xhtml#_idTextAnchor337)，*提供平台*
    中介绍。
- en: Now that we have a strategy for implementing authorization policies, we'll need
    a way to debug those policies as we create them and also to know when those policies
    are violated. Kubernetes provides an audit capability that will be the focus of
    the next section where we will add the audit log to our KinD cluster and debug
    the implementation of RBAC policies.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了实施授权策略的策略，我们需要一种方法来调试这些策略，以及在创建它们时知道何时违反这些策略。Kubernetes 提供了审计功能，这将是下一节的重点，我们将在其中将审计日志添加到我们的
    KinD 集群并调试 RBAC 策略的实施。
- en: Kubernetes auditing
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 审计
- en: The Kubernetes audit log is where you track what is happening in your cluster
    from an API perspective. It's in JSON format, which makes reading it directly
    more difficult, but makes it much easier to parse using tools such as Elasticsearch.
    In [*Chapter 12*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295), *Pod Auditing
    Using Falco and EFK*, we will cover how to create a full logging system using
    the **Elasticsearch, Fluentd, and Kibana (EFK)** stack.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 审计日志是您从 API 视角跟踪集群中发生的事情的地方。它以 JSON 格式呈现，这使得直接阅读变得更加困难，但使用诸如 Elasticsearch
    等工具解析变得更加容易。在 [*第 12 章*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295)，*使用
    Falco 和 EFK 进行 Pod 审计* 中，我们将介绍如何使用 **Elasticsearch、Fluentd 和 Kibana (EFK)** 堆栈创建完整的日志系统。
- en: Creating an audit policy
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建审计策略
- en: A policy file is used to control what events are recorded and where to store
    the logs, which can be a standard log file or a webhook. We have included an example
    audit policy in the **chapter8** directory of the GitHub repository and we will
    apply it to the KinD cluster that we have been using throughout the book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 策略文件用于控制记录哪些事件以及在哪里存储日志，可以是标准日志文件或 Webhook。我们在 GitHub 存储库的 **chapter8** 目录中包含了一个示例审计策略，并将其应用于我们在整本书中一直在使用的
    KinD 集群。
- en: An audit policy is a collection of rules that tell the API server which API
    calls to log and how. When Kubernetes parses the policy file, all rules are applied
    in order and only the initial matching policy event will be applied. If you have
    more than one rule for a certain event, you may not receive the expected data
    in your log files. For this reason, you need to be careful that your events are
    created correctly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 审计策略是一组规则，告诉 API 服务器要记录哪些 API 调用以及如何记录。当 Kubernetes 解析策略文件时，所有规则都按顺序应用，只有初始匹配的策略事件才会应用。如果对某个事件有多个规则，可能无法在日志文件中收到预期的数据。因此，您需要小心确保事件被正确创建。
- en: 'Policies use the **audit.k8s.io** API and the manifest kind of **Policy**.
    The following example shows the beginning of a policy file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 策略使用 **audit.k8s.io** API 和 **Policy** 的清单类型。以下示例显示了策略文件的开头：
- en: 'apiVersion: audit.k8s.io/v1beta1'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: audit.k8s.io/v1beta1'
- en: 'kind: Policy'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Policy'
- en: 'rules:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- level: Request'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '- level: Request'
- en: 'userGroups: ["system:nodes"]'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'userGroups: ["system:nodes"]'
- en: 'verbs: ["update","patch"]'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：["update","patch"]
- en: 'resources:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：
- en: '- group: "" # core'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '- group: "" # core'
- en: 'resources: ["nodes/status", "pods/status"]'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'resources: ["nodes/status", "pods/status"]'
- en: 'omitStages:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'omitStages:'
- en: '- "RequestReceived"'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '- "RequestReceived"'
- en: Important Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While a policy file may look like a standard Kubernetes manifest, you do not
    apply it using **kubectl**. A policy file is used with the **--audit-policy-file**
    API flag on the API server(s). This will be explained in the *Enabling auditing
    on a cluster* section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然策略文件看起来像标准的 Kubernetes 清单，但您不使用 **kubectl** 应用它。策略文件与 API 服务器上的 **--audit-policy-file**
    API 标志一起使用。这将在 *在集群上启用审计* 部分进行解释。
- en: To understand the rule and what it will log, we will go through each section
    in detail.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解规则及其将记录的内容，我们将详细介绍每个部分。
- en: 'The first section of the rule is **level**, which determines the type of information
    that will be logged for the event. There are four levels that can be assigned
    to events:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的第一部分是 **level**，它确定将为事件记录的信息类型。可以为事件分配四个级别：
- en: '![Table 8.1 – Kubernetes auditing levels'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.1 – Kubernetes 审计级别'
- en: '](image/B15514_table_8.1.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15514_table_8.1.jpg)'
- en: Table 8.1 – Kubernetes auditing levels
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 – Kubernetes 审计级别
- en: The **userGroups**, **verbs**, and **resources** values tell the API server
    the object and action that will trigger the auditing event. In this example, only
    requests from **system:nodes** that attempt an action of **update** or **patch**
    on a **node/status** or **pod/status** on the **core** API will create an event.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**userGroups**、**verbs** 和 **resources** 值告诉 API 服务器将触发审计事件的对象和操作。在这个例子中，只有来自
    **system:nodes** 的请求，尝试在 **core** API 上的 **node/status** 或 **pod/status** 上执行
    **update** 或 **patch** 操作才会创建事件。'
- en: '**omitStages** tells the API server to skip any logging events during a *stage*,
    which helps you to limit the amount of data that is logged. There are four stages
    that an API request goes through:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**omitStages** 告诉 API 服务器在 *stage* 期间跳过任何日志记录事件，这有助于限制记录的数据量。API 请求经历四个阶段：'
- en: '![Table 8.2 – Auditing stages'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.2 – 审计阶段'
- en: '](image/B15514_table_8.2.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15514_table_8.2.jpg)'
- en: Table 8.2 – Auditing stages
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 审计阶段
- en: In our example, we have set the event to ignore the **RequestReceived** event,
    which tells the API server not to log any data for the incoming API request.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们设置了事件忽略 **RequestReceived** 事件，这告诉 API 服务器不要记录任何传入 API 请求的数据。
- en: Every organization has its own auditing policy, and policy files can become
    long and complex. Don't be afraid to set up a policy that logs everything until
    you get a handle on the types of events that you can create. Logging everything
    is not a good practice since the log files become very large. Fine-tuning an audit
    policy is a skill that is learned over time and as you learn more about the API
    server, you will start to learn what events are most valuable to audit.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组织都有自己的审计政策，政策文件可能会变得又长又复杂。不要害怕设置一个记录所有内容的策略，直到您掌握了可以创建的事件类型。记录所有内容并不是一个好的做法，因为日志文件会变得非常庞大。调整审计策略是一个随着时间学习的技能，随着您对
    API 服务器的了解越来越多，您将开始了解哪些事件对审计最有价值。
- en: Policy files are just the start of enabling cluster auditing, and now that we
    have an understanding of the policy file, let's explain how to enable auditing
    on a cluster.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 策略文件只是启用集群审计的开始，现在我们已经了解了策略文件，让我们解释如何在集群上启用审计。
- en: Enabling auditing on a cluster
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集群上启用审计
- en: Enabling auditing is specific to each distribution of Kubernetes. In this section,
    we will enable the audit log in KinD to understand the low-level steps. As a quick
    refresher, the finished product of the last chapter was a KinD cluster with impersonation
    enabled (instead of directly integrating with OpenID Connect). The rest of the
    steps and examples in this chapter assume this cluster is being used.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 启用审计对于每个Kubernetes发行版都是特定的。在本节中，我们将在KinD中启用审计日志以了解低级步骤。作为一个快速提醒，上一章的最终产品是一个启用模拟的KinD集群（而不是直接集成OpenID
    Connect）。本章中的其余步骤和示例假定正在使用此集群。
- en: 'You can follow the steps in this section manually or you can execute the included
    script, **enable-auditing.sh**, in the **chapter8** directory of the GitHub repository:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动按照本节中的步骤操作，也可以在GitHub存储库的**chapter8**目录中执行包含的脚本**enable-auditing.sh**：
- en: 'First, copy the example audit policy from the **chapter8** directory to the
    API server:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将示例审计策略从**chapter8**目录复制到API服务器：
- en: k8s@book:~/kind-oidc-ldap-master$ docker cp k8s-audit-policy.yaml cluster01-control-plane:/etc/kubernetes/audit/
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: k8s@book:~/kind-oidc-ldap-master$ docker cp k8s-audit-policy.yaml cluster01-control-plane:/etc/kubernetes/audit/
- en: 'Next, create the directories to store the audit log and policy configuration
    on the API server. We will exec into the container since we need to modify the
    API server file in the next step:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在API服务器上创建存储审计日志和策略配置的目录。我们将进入容器，因为我们需要在下一步中修改API服务器文件：
- en: k8s@book:~/kind-oidc-ldap-master$ docker exec -ti cluster01-control-plane bash
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: k8s@book:~/kind-oidc-ldap-master$ docker exec -ti cluster01-control-plane bash
- en: root@cluster01-control-plane:/# mkdir /var/log/k8s
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: root@cluster01-control-plane:/# mkdir /var/log/k8s
- en: root@cluster01-control-plane:/# mkdir /etc/kubernetes/audit
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: root@cluster01-control-plane:/# mkdir /etc/kubernetes/audit
- en: root@cluster01-control-plane:/# exit
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: root@cluster01-control-plane:/# exit
- en: At this point, you have the audit policy on the API server and you can enable
    the API options to use the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经在API服务器上有了审计策略，并且可以启用API选项以使用该文件。
- en: On the API server, edit the **kubeadm** configuration file, **/etc/kubernetes/manifests/kube-apiserver.yaml**,
    which is the same file that we updated to enable OpenID Connect. To enable auditing,
    we need to add three values. It's important to note that many Kubernetes clusters
    may only require the file and the API options. We need the second and third steps
    since we are using a KinD cluster for our testing.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API服务器上，编辑**kubeadm**配置文件**/etc/kubernetes/manifests/kube-apiserver.yaml**，这是我们更新以启用OpenID
    Connect的相同文件。要启用审计，我们需要添加三个值。需要注意的是，许多Kubernetes集群可能只需要文件和API选项。由于我们正在使用KinD集群进行测试，我们需要第二和第三步。
- en: 'First, add command-line flags for the API server that enable the audit logs.
    Along with the policy file, we can add options to control the log file rotation,
    retention, and maximum size:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为启用审计日志的API服务器添加命令行标志。除了策略文件，我们还可以添加选项来控制日志文件的轮换、保留和最大大小：
- en: '- --tls-private-key-**file=/etc/kubernetes/pki/apiserver.key**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '- --tls-private-key-**file=/etc/kubernetes/pki/apiserver.key**'
- en: '**    - --audit-log-path=/var/log/k8s/audit.log**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**    - --audit-log-path=/var/log/k8s/audit.log**'
- en: '**    - --audit-log-maxage=1**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**    - --audit-log-maxage=1**'
- en: '**    - --audit-log-maxbackup=10**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**    - --audit-log-maxbackup=10**'
- en: '**    - --audit-log-maxsize=10**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**    - --audit-log-maxsize=10**'
- en: '**    - --audit-policy-file=/etc/kubernetes/audit/k8s-audit-policy.yaml**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**    - --audit-policy-file=/etc/kubernetes/audit/k8s-audit-policy.yaml**'
- en: Notice that the option is pointing to the policy file that you copied over in
    the previous step.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该选项指向您在上一步中复制的策略文件。
- en: 'Next, add the directories that store the policy configuration and the resulting
    logs to the **volumeMounts** section:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**volumeMounts**部分添加存储策略配置和生成日志的目录：
- en: '- mountPath: /usr/share/ca-certificates'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '- mountPath: /usr/share/ca-certificates'
- en: 'name: usr-share-ca-certificates'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: usr-share-ca-certificates'
- en: 'readOnly: true'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'readOnly: true'
- en: '**- mountPath: /var/log/k8s**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '- mountPath：/var/log/k8s'
- en: '**      name: var-log-k8s**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：var-log-k8s
- en: '**      readOnly: false**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 只读：false
- en: '**    - mountPath: /etc/kubernetes/audit**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '- mountPath：/etc/kubernetes/audit'
- en: '**      name: etc-kubernetes-audit**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：etc-kubernetes-audit
- en: '**      readOnly: true**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 只读：true
- en: 'Finally, add the **hostPath** configurations to the **volumes** section so
    that Kubernetes knows where to mount the local paths to:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 **hostPath** 配置添加到 **volumes** 部分，以便 Kubernetes 知道在哪里挂载本地路径：
- en: '- hostPath:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '- hostPath：'
- en: 'path: /usr/share/ca-certificates'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：/usr/share/ca-certificates
- en: 'type: DirectoryOrCreate'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：目录或创建
- en: 'name: usr-share-ca-certificates'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：usr-share-ca-certificates
- en: '**  - hostPath:**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '- hostPath：'
- en: '**      path: /var/log/k8s**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：/var/log/k8s
- en: '**      type: DirectoryOrCreate**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：目录或创建
- en: '**    name: var-log-k8s**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：var-log-k8s
- en: '**  - hostPath:**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '- hostPath：'
- en: '**      path: /etc/kubernetes/audit**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：/etc/kubernetes/audit
- en: '**      type: DirectoryOrCreate**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：目录或创建
- en: '**    name: etc-kubernetes-audit**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：etc-kubernetes-audit
- en: Save and exit the file.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出文件。
- en: Like all API option changes, you need to restart the API server for the changes
    to take effect; however, KinD will detect that the file has changed and restart
    the API server's pod automatically.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有 API 选项更改一样，您需要重新启动 API 服务器才能使更改生效；但是，KinD 将检测到文件已更改并自动重新启动 API 服务器的 pod。
- en: 'Exit from the attached shell and check the pods in the **kube-system** namespace:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 退出附加的 shell 并检查 **kube-system** 命名空间中的 pods：
- en: '**k8s@book:~/kind-oidc-ldap-master$ kubectl get pods -n kube-system**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: k8s@book:~/kind-oidc-ldap-master$ kubectl get pods -n kube-system
- en: '**NAME                                              READY   STATUS    RESTARTS   AGE**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：READY STATUS RESTARTS AGE
- en: '**calico-kube-controllers-5b644bc49c-q68q7          1/1     Running   0          28m**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: calico-kube-controllers-5b644bc49c-q68q7 1/1 Running 0 28m
- en: '**calico-node-2cvm9                                 1/1     Running   0          28m**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: calico-node-2cvm9 1/1 Running 0 28m
- en: '**calico-node-n29tl                                 1/1     Running   0          28m**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: calico-node-n29tl 1/1 Running 0 28m
- en: '**coredns-6955765f44-gzvjd                          1/1     Running   0          28m**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: coredns-6955765f44-gzvjd 1/1 Running 0 28m
- en: '**coredns-6955765f44-r567x                          1/1     Running   0          28m**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: coredns-6955765f44-r567x 1/1 Running 0 28m
- en: '**etcd-cluster01-control-plane                      1/1     Running   0          28m**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: etcd-cluster01-control-plane 1/1 Running 0 28m
- en: '**kube-apiserver-cluster01-control-plane            1/1     Running   0          14s**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: kube-apiserver-cluster01-control-plane 1/1 Running 0 14s
- en: '**kube-controller-manager-cluster01-control-plane   1/1     Running   0          28m**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: kube-controller-manager-cluster01-control-plane 1/1 Running 0 28m
- en: '**kube-proxy-h62mj                                  1/1     Running   0          28m**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy-h62mj 1/1 Running 0 28m
- en: '**kube-proxy-pl4z4                                  1/1     Running   0          28m**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy-pl4z4 1/1 Running 0 28m
- en: '**kube-scheduler-cluster01-control-plane            1/1     Running   0          28m**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: kube-scheduler-cluster01-control-plane 1/1 Running 0 28m
- en: The API server is highlighted to have been running for only 14 seconds, showing
    that it successfully restarted.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器被强调仅运行了 14 秒，显示其成功重新启动。
- en: 'Having verified that the API server is running, let''s look at the audit log
    to verify that it''s working correctly. To check the log, you can use **docker
    exec** to tail **audit.log**:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已验证 API 服务器正在运行，让我们查看审计日志以验证其是否正常工作。要检查日志，您可以使用 **docker exec** 来查看 **audit.log**：
- en: '**$ docker exec cluster01-control-plane  tail /var/log/k8s/audit.log**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker exec cluster01-control-plane tail /var/log/k8s/audit.log
- en: 'This command generates the following log data:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成以下日志数据：
- en: '**{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"473e8161-e243-4c5d-889c-42f478025cc2","stage":"ResponseComplete","requestURI":"/apis/crd.projectcalico.org/v1/clusterinformations/default","verb":"get","user":{"usernam**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"473e8161-e243-4c5d-889c-42f478025cc2","stage":"ResponseComplete","requestURI":"/apis/crd.projectcalico.org/v1/clusterinformations/default","verb":"get","user":{"usernam**'
- en: '**e":"system:serviceaccount:kube-system:calico-kube-controllers","uid":"38b96474-2457-4ec9-a146-9a63c2b8182e","groups":["system:serviceaccounts","system:serviceaccounts:kube-system","system:authenticated"]},"sourceIPs":["172.17.0.2"],"userAgent":"**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**e":"system:serviceaccount:kube-system:calico-kube-controllers","uid":"38b96474-2457-4ec9-a146-9a63c2b8182e","groups":["system:serviceaccounts","system:serviceaccounts:kube-system","system:authenticated"]},"sourceIPs":["172.17.0.2"],"userAgent":"**'
- en: '**Go-http-client/2.0","objectRef":{"resource":"clusterinformations","name":"default","apiGroup":"crd.projectcalico.org","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2020-05-20T00:27:07.378345Z","stageT**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go-http-client/2.0","objectRef":{"resource":"clusterinformations","name":"default","apiGroup":"crd.projectcalico.org","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2020-05-20T00:27:07.378345Z","stageT**'
- en: '**imestamp":"2020-05-20T00:27:07.381227Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC:
    allowed by ClusterRoleBinding \"calico-kube-controllers\" of ClusterRole \"calico-kube-controllers\"
    to ServiceAc**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**imestamp":"2020-05-20T00:27:07.381227Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC:
    allowed by ClusterRoleBinding \"calico-kube-controllers\" of ClusterRole \"calico-kube-controllers\"
    to ServiceAc**'
- en: '**count \"calico-kube-controllers/kube-system\""}}**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**计数\"calico-kube-controllers/kube-system\""}}**'
- en: There is quite a bit of information in this JSON, and it would be challenging
    to find a specific event looking at a log file directly. Luckily, now that you
    have auditing enabled, you can forward events to a central logging server. We
    will do this in [*Chapter 12*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295)*,
    Auditing Using Falco and EFK*, where we will deploy an EFK stack.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON中包含了大量信息，直接查看日志文件可能会很具有挑战性地找到特定事件。幸运的是，现在您已经启用了审计，可以将事件转发到中央日志服务器。我们将在[*第12章*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295)*，使用Falco和EFK进行审计*中进行此操作，我们将部署一个EFK堆栈。
- en: Now that we have auditing enabled, the next step is to practice debugging RBAC
    policies.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了审计，下一步是练习调试RBAC策略。
- en: Using audit2rbac to debug policies
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用audit2rbac调试策略
- en: 'There is a tool called **audit2rbac** that can reverse engineer errors in the
    audit log into RBAC policy objects. In this section, we''ll use this tool to generate
    an RBAC policy after discovering that one of our users can''t perform an action
    they need to be able to do. This is a typical RBAC debugging process and learning
    how to use this tool can save you hours trying to isolate RBAC issues:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**audit2rbac**的工具，可以将审计日志中的错误反向工程成RBAC策略对象。在本节中，我们将使用这个工具在发现我们的一个用户无法执行他们需要执行的操作后生成一个RBAC策略。这是一个典型的RBAC调试过程，学会使用这个工具可以节省您花费在隔离RBAC问题上的时间：
- en: In the previous chapter, a generic RBAC policy was created to allow all members
    of the **k8s-cluster-admins** group to be administrators in our cluster. If you're
    logged into OpenUnison, log out.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中，创建了一个通用的RBAC策略，允许**k8s-cluster-admins**组的所有成员成为我们集群中的管理员。如果您已登录OpenUnison，请注销。
- en: Now, log in again, but before hitting the **Finish Login** button at the bottom
    of the screen, remove the **k8s-cluster-admins** group and add **cn=k8s-create-ns,cn=users,dc=domain,dc=com**:![Figure
    8.1 – Updated login attributes
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次登录，但在屏幕底部点击**完成登录**按钮之前，删除**k8s-cluster-admins**组，并添加**cn=k8s-create-ns,cn=users,dc=domain,dc=com**：![图8.1
    – 更新的登录属性
- en: '](image/Fig_8.1_B15514.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_8.1_B15514.jpg)'
- en: Figure 8.1 – Updated login attributes
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 更新的登录属性
- en: Next, click on **Finish Login**. Once logged in, go to the dashboard. Just as
    when OpenUnison was first deployed, there won't be any namespaces or other information
    because the RBAC policy for cluster administrators doesn't apply anymore.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**完成登录**。登录后，转到仪表板。就像当OpenUnison首次部署时一样，因为集群管理员的RBAC策略不再适用，所以不会有任何命名空间或其他信息。
- en: Important Note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The format of the **memberOf** attribute was changed from a simple name to an
    LDAP distinguished name because this is the format that's most often presented
    by ADFS or Active Directory. A **distinguished name**, or **DN**, is read from
    left to right with the leftmost component being the name of the object and each
    component to its right being its placement in the LDAP tree. For example, the
    **name cn=k8s-create-ns,cn=users,dc=domain,dc=com** group is read as "The group
    **k8s-create-ns** in the **users** container (**cn**) in the **domain.com** domain
    (**dc**)." While ADFS can generate more user-friendly names, that requires specific
    configuration or scripting, so most implementations just add the **memberOf**
    attributes, which list all the groups the user is a member of.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**memberOf**属性的格式已从简单名称更改为LDAP专有名称，因为这是ADFS或Active Directory最常呈现的格式。**专有名称**或**DN**从左到右读取，最左边的组件是对象的名称，其右边的每个组件是其在LDAP树中的位置。例如，**name
    cn=k8s-create-ns,cn=users,dc=domain,dc=com**组被读作"在**domain.com**域（**dc**）的**users**容器（**cn**）中的**k8s-create-ns**组。"虽然ADFS可以生成更用户友好的名称，但这需要特定的配置或脚本编写，因此大多数实现只是添加**memberOf**属性，列出用户所属的所有组。'
- en: Next, copy your **kubectl** configuration from the token screen, making sure
    to paste it into a window that isn't your main KinD terminal so as to not overwrite
    your master configuration.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从令牌屏幕上复制您的**kubectl**配置，确保将其粘贴到不是您的主KinD终端的窗口中，以免覆盖您的主配置。
- en: 'Once your tokens are set, attempt to create a namespace called **not-going-to-work**:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的令牌设置好，尝试创建一个名为**not-going-to-work**的命名空间：
- en: '**PS C:\Users\mlb> kubectl create ns not-going-to-work**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**PS C:\Users\mlb> kubectl create ns not-going-to-work**'
- en: '**Error from server (Forbidden): namespaces is forbidden: User "mlbiamext"
    cannot create resource "namespaces" in API group "" at the cluster scope**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器错误（禁止）：命名空间被禁止：用户"mlbiamext"无法在集群范围的API组""中创建资源"namespaces"**'
- en: There's enough information here to reverse engineer an RBAC policy.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有足够的信息来反向工程一个RBAC策略。
- en: 'In order to eliminate this error message, create a **ClusterRole** with a resource
    for **"namespaces"**, **apiGroups** set to **""**, and a verb of **"create"**:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消除此错误消息，创建一个带有**"namespaces"**资源的**ClusterRole**，**apiGroups**设置为**""**，动词为**"create"**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRole'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ClusterRole'
- en: 'metadata:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: cluster-create-ns'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cluster-create-ns'
- en: 'rules:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'rules:'
- en: '- apiGroups: [""]'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: [""]'
- en: 'resources: ["namespaces"]'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'resources: ["namespaces"]'
- en: 'verbs: ["create"]'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'verbs: ["create"]'
- en: 'Next, create a **ClusterRoleBinding** for the user and this ClusterRole:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为用户和这个ClusterRole创建一个**ClusterRoleBinding**：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRoleBinding'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ClusterRoleBinding'
- en: 'metadata:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: cluster-create-ns'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cluster-create-ns'
- en: 'subjects:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'subjects:'
- en: '- kind: User'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '- kind: User'
- en: 'name: mlbiamext'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: mlbiamext'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'roleRef:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'roleRef:'
- en: 'kind: ClusterRole'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ClusterRole'
- en: 'name: cluster-create-ns'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cluster-create-ns'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'Once the ClusterRole and ClusterRoleBinding are created, try running the command
    again and it will work:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了ClusterRole和ClusterRoleBinding后，尝试再次运行命令，它将起作用：
- en: '**PS C:\Users\mlb> kubectl create ns not-going-to-work namespace/not-going-to-work
    created**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**PS C:\Users\mlb> kubectl create ns not-going-to-work namespace/not-going-to-work
    created**'
- en: Unfortunately, this is not likely how most RBAC debugging will go. Most of the
    time, debugging RBAC will not be this clear or simple. Typically, debugging RBAC
    means getting unexpected error messages between systems. For instance, if you're
    deploying the **kube-Prometheus** project for monitoring, you'll generally want
    to monitor by **Service** objects, not by explicitly naming pods. In order to
    do this, the Prometheus ServiceAccount needs to be able to list the **Service**
    objects in the namespace of the service you want to monitor. Prometheus won't
    tell you this needs to happen; you just won't see your services listed. A better
    way to debug is to use a tool that knows how to read the audit log and can reverse
    engineer a set of roles and bindings based on the failures in the log.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不太可能是大多数 RBAC 调试的情况。大多数情况下，调试 RBAC 不会如此清晰或简单。通常，调试 RBAC 意味着在系统之间收到意外的错误消息。例如，如果您正在部署
    **kube-Prometheus** 项目进行监控，通常希望通过 **Service** 对象进行监控，而不是通过显式命名的 pods。为了做到这一点，Prometheus
    ServiceAccount 需要能够列出要监控的服务所在命名空间中的 **Service** 对象。Prometheus 不会告诉您需要发生这种情况；您只会看不到列出的服务。更好的调试方法是使用一个知道如何读取审计日志并且可以根据日志中的失败来逆向工程一组角色和绑定的工具。
- en: 'The **audit2rbac** tool is the best way to do this. It will read the audit
    log and give you a set of policies that will work. It may not be the exact policy
    that''s needed, but it will provide a good starting point. Let''s try it out:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**audit2rbac** 工具是这样做的最佳方式。它将读取审计日志并为您提供一组可行的策略。它可能不是确切所需的策略，但它将提供一个良好的起点。让我们试一试：'
- en: 'First, attach a shell to the **control-plane** container of your cluster and
    download the tool from GitHub ([https://github.com/liggitt/audit2rbac/releases](https://github.com/liggitt/audit2rbac/releases)):'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 shell 附加到集群的 **control-plane** 容器上，并从 GitHub 下载工具（[https://github.com/liggitt/audit2rbac/releases](https://github.com/liggitt/audit2rbac/releases)）：
- en: '**root@cluster01-control-plane:/# curl -L https://github.com/liggitt/audit2rbac/releases/download/v0.8.0/audit2rbac-linux-amd64.tar.gz
    2>/dev/null > audit2rbac-linux-amd64.tar.gz**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**root@cluster01-control-plane:/# curl -L https://github.com/liggitt/audit2rbac/releases/download/v0.8.0/audit2rbac-linux-amd64.tar.gz
    2>/dev/null > audit2rbac-linux-amd64.tar.gz**'
- en: '**root@cluster01-control-plane:/# tar -xvzf audit2rbac-linux-amd64.tar.gz**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**root@cluster01-control-plane:/# tar -xvzf audit2rbac-linux-amd64.tar.gz**'
- en: 'Before using the tool, make sure to close the browser with the Kubernetes dashboard
    in it to keep from polluting the logs. Also, remove the **cluster-create-ns**
    ClusterRole and ClusterRoleBinding created previously. Finally, try creating the
    **still-not-going-to-work** namespace:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用该工具之前，请确保关闭包含 Kubernetes 仪表板的浏览器，以免污染日志。此外，删除之前创建的 **cluster-create-ns**
    ClusterRole 和 ClusterRoleBinding。最后，尝试创建 **still-not-going-to-work** 命名空间：
- en: '**PS C:\Users\mlb> kubectl create ns still-not-going-to-work**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**PS C:\Users\mlb> kubectl create ns still-not-going-to-work**'
- en: '**Error from server (Forbidden): namespaces is forbidden: User "mlbiamext"
    cannot create resource "namespaces" in API group "" at the cluster scope**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器错误（禁止）：用户“mlbiamext”无法在集群范围的 API 组中创建“namespaces”资源**'
- en: 'Next, use the **audit2rbac** tool to look for any failures for your test user:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，使用 **audit2rbac** 工具查找测试用户的任何失败： '
- en: '**root@cluster01-control-plane:/# ./audit2rbac --filename=/var/log/k8s/audit.log  --user=mlbiamext**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**root@cluster01-control-plane:/# ./audit2rbac --filename=/var/log/k8s/audit.log  --user=mlbiamext**'
- en: '**Opening audit source...**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开审计源...**'
- en: '**Loading events...**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载事件...**'
- en: '**Evaluating API calls...**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估 API 调用...**'
- en: '**Generating roles...**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成角色...**'
- en: '**apiVersion: rbac.authorization.k8s.io/v1**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**apiVersion: rbac.authorization.k8s.io/v1**'
- en: '**kind: ClusterRole**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**kind: ClusterRole**'
- en: '**metadata:**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**metadata:**'
- en: '**  annotations:**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**  annotations:**'
- en: '**    audit2rbac.liggitt.net/version: v0.8.0**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/version: v0.8.0**'
- en: '**  labels:**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**  labels:**'
- en: '**    audit2rbac.liggitt.net/generated: "true"**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/generated: "true"**'
- en: '**    audit2rbac.liggitt.net/user: mlbiamext**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/user: mlbiamext**'
- en: '**  name: audit2rbac:mlbiamext**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**  名称：audit2rbac:mlbiamext**'
- en: '**rules:**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则：**'
- en: '**- apiGroups:**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**- apiGroups:**'
- en: '**  - ""**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**  - ""**'
- en: '**  resources:**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**  资源：**'
- en: '**  - namespaces**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**  - 命名空间**'
- en: '**  verbs:**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**  动词：**'
- en: '**  - create**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**  - 创建**'
- en: '**---**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**---**'
- en: '**apiVersion: rbac.authorization.k8s.io/v1**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**apiVersion: rbac.authorization.k8s.io/v1**'
- en: '**kind: ClusterRoleBinding**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**种类：ClusterRoleBinding**'
- en: '**metadata:**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**元数据：**'
- en: '**  annotations:**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**  注释：**'
- en: '**    audit2rbac.liggitt.net/version: v0.8.0**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/version: v0.8.0**'
- en: '**  labels:**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**  标签：**'
- en: '**    audit2rbac.liggitt.net/generated: "true"**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/generated: "true"**'
- en: '**    audit2rbac.liggitt.net/user: mlbiamext**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**    audit2rbac.liggitt.net/user: mlbiamext**'
- en: '**  name: audit2rbac:mlbiamext**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**  名称：audit2rbac:mlbiamext**'
- en: '**roleRef:**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**roleRef:**'
- en: '**  apiGroup: rbac.authorization.k8s.io**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**  apiGroup: rbac.authorization.k8s.io**'
- en: '**  kind: ClusterRole**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**  种类：ClusterRole**'
- en: '**  name: audit2rbac:mlbiamext**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**  名称：audit2rbac:mlbiamext**'
- en: '**subjects:**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '**- apiGroup: rbac.authorization.k8s.io**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**- apiGroup: rbac.authorization.k8s.io**'
- en: '**  kind: User**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**  种类：用户**'
- en: '**  name: mlbiamext**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**  名称：mlbiamext**'
- en: '**Complete!**'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成！**'
- en: This command generated a policy that will exactly allow the test user to create
    namespaces. This becomes an anti-pattern, though, of explicitly authorizing access
    to users.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令生成了一个策略，确切地允许测试用户创建命名空间。然而，这成为了一个反模式，明确授权用户访问。
- en: 'In order to better leverage this policy, it would be better to use our group:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地利用这个策略，最好使用我们的组：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRole'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'metadata:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: create-ns-audit2rbac'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：create-ns-audit2rbac
- en: 'rules:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups:'
- en: '- ""'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '- ""'
- en: 'resources:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：
- en: '- namespaces'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '- 命名空间'
- en: 'verbs:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：
- en: '- create'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '- 创建'
- en: '---'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRoleBinding'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: create-ns-audit2rbac'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：create-ns-audit2rbac
- en: 'roleRef:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'roleRef:'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'kind: ClusterRole'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'name: create-ns-audit2rbac'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：create-ns-audit2rbac
- en: 'subjects:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- apiGroup: rbac.authorization.k8s.io'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroup: rbac.authorization.k8s.io'
- en: '**kind: Group**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**种类：组**'
- en: '**  name: cn=k8s-create-ns,cn=users,dc=domain,dc=com**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**  名称：cn=k8s-create-ns,cn=users,dc=domain,dc=com**'
- en: The major change is highlighted. Instead of referencing the user directly, the
    **ClusterRoleBinding** is now referencing the **cn=k8s-create-ns,cn=users,dc=domain,dc=com**
    group so that any member of that group can now create namespaces.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变化已经突出显示。现在，**ClusterRoleBinding**不再直接引用用户，而是引用**cn=k8s-create-ns,cn=users,dc=domain,dc=com**组，以便该组的任何成员现在都可以创建命名空间。
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter's focus was on RBAC policy creation and debugging. We explored
    how Kubernetes defines authorization policies and how it applies those policies
    to enterprise users. We also looked at how these policies can be used to enable
    multi-tenancy in your cluster. Finally, we enabled the audit log in our KinD cluster
    and learned how to use the **audit2rbac** tool to debug RBAC issues.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点是RBAC策略的创建和调试。我们探讨了Kubernetes如何定义授权策略以及如何将这些策略应用于企业用户。我们还看了这些策略如何用于在集群中启用多租户。最后，我们在KinD集群中启用了审计日志，并学习了如何使用**audit2rbac**工具来调试RBAC问题。
- en: Using Kubernetes' built-in RBAC policy management objects lets you enable access
    that's needed for operational and development tasks in your clusters. Knowing
    how to design policies can help limit the impact of issues, providing the confidence
    to let users do more on their own.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes内置的RBAC策略管理对象可以让您在集群中启用操作和开发任务所需的访问权限。了解如何设计策略可以帮助限制问题的影响，从而让用户更有信心自行处理更多事务。
- en: In the next chapter, we'll be learning about how to secure the Kubernetes dashboard,
    as well as how to approach security for other infrastructure applications that
    make up your cluster. You'll learn how to apply what we've learned about authentication
    and authorization to the applications that make up your cluster, providing your
    developers and infrastructure team with a better and more secure experience.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何保护 Kubernetes 仪表板，以及如何处理组成您集群的其他基础设施应用程序的安全性。您将学习如何将我们对认证和授权的学习应用到组成您集群的应用程序中，为您的开发人员和基础设施团队提供更好、更安全的体验。
- en: Questions
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: True or false – ABAC is the preferred method of authorizing access to Kubernetes
    clusters.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - ABAC 是授权访问 Kubernetes 集群的首选方法。
- en: A. True
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: What are the three components of a Role?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色的三个组成部分是什么？
- en: A. Subject, noun, and verb
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: A. 主题，名词和动词
- en: B. Resource, action, and group
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: B. 资源，动作和组
- en: C. **apiGroups**, resources, and verbs
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: C. **apiGroups**，资源和动词
- en: D. Group, resource, and sub-resource
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: D. 组，资源和子资源
- en: Where can you go to look up resource information?
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以去哪里查找资源信息？
- en: A. Kubernetes API reference
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: A. Kubernetes API 参考
- en: B. The library
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: B. 这个库
- en: C. Tutorials and blog posts
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: C. 教程和博客文章
- en: How can you reuse Roles across namespaces?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在命名空间之间重用角色？
- en: A. You can't; you need to re-create them.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: A. 你不能；你需要重新创建它们。
- en: B. Define a ClusterRole and reference it in each namespace as a RoleBinding.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: B. 定义一个 ClusterRole，并在每个命名空间中引用它作为 RoleBinding。
- en: C. Reference the Role in one namespace with the RoleBindings of other namespaces.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: C. 在一个命名空间中引用角色，使用其他命名空间的 RoleBindings。
- en: D. None of the above.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: How should bindings reference users?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定应该如何引用用户？
- en: A. Directly, listing every user.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: A. 直接，列出每个用户。
- en: B. RoleBindings should only reference service accounts.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: B. RoleBindings 应该只引用服务账户。
- en: C. Only ClusterRoleBindings should reference users.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: C. 只有 ClusterRoleBindings 应该引用用户。
- en: D. Whenever possible, RoleBindings and ClusterRoleBindings should reference
    groups.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: D. 在可能的情况下，RoleBindings 和 ClusterRoleBindings 应该引用组。
- en: True or false – RBAC can be used to authorize access to everything except for
    one resource.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - RBAC 可以用于授权访问除一个资源之外的所有内容。
- en: A. True
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: True or false – RBAC is the only method of authorization in Kubernetes.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - RBAC 是 Kubernetes 中唯一的授权方法。
- en: A. True
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
