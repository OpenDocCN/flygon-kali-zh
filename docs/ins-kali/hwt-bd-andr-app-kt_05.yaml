- en: '5\. Essential Libraries: Retrofit, Moshi, and Glide'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 必要的库：Retrofit、Moshi和Glide
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will cover the steps needed to present app users with dynamic
    content fetched from remote servers. You will be introduced to the different libraries
    required to retrieve and handle this dynamic data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍呈现来自远程服务器获取的动态内容所需的步骤。您将了解到检索和处理此动态数据所需的不同库。
- en: By the end of this chapter, you will be able to fetch data from a network endpoint
    using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and
    load images into `ImageViews` using Glide.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使用Retrofit从网络端点获取数据，使用Moshi将JSON有效负载解析为Kotlin数据对象，并使用Glide将图像加载到`ImageViews`中。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to implement navigation in our app.
    In this chapter, we will learn how to present dynamic content to the user as they
    navigate around our app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在应用程序中实现导航。在本章中，我们将学习如何在用户在我们的应用程序中导航时向他们呈现动态内容。
- en: Data presented to users can come from different sources. It can be hardcoded
    into the app, but that comes with limitations. To change hardcoded data, we have
    to publish an update to our app. Some data cannot be hardcoded by its nature,
    such as currency exchange rates, the real-time availability of assets, and the
    current weather, to name a few. Other data may become outdated, such as the terms
    of use of an app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户呈现的数据可以来自不同的来源。它可以硬编码到应用程序中，但这会带来一些限制。要更改硬编码数据，我们必须发布应用程序的更新。某些数据由于其性质而无法硬编码，例如货币汇率、资产的实时可用性和当前天气等。其他数据可能会过时，例如应用程序的使用条款。
- en: 'In such cases, you would usually fetch the relevant data from a server. One
    of the most common architectures for serving such data is the **representational
    state transfer** (**REST**) architecture. The REST architecture is defined by
    a set of six constraints: the client-server architecture, statelessness, cacheability,
    a layered system, code on demand (optional), and a uniform interface. To read
    more about REST, visit [https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f](https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您通常会从服务器获取相关数据。用于提供此类数据的最常见架构之一是**表现状态转移**（**REST**）架构。REST架构由一组六个约束定义：客户端-服务器架构、无状态性、可缓存性、分层系统、按需代码（可选）和统一接口。要了解有关REST的更多信息，请访问[https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f](https://medium.com/extend/what-is-rest-a-simple-explanation-for-beginners-part-1-introduction-b4a072f8740f)。
- en: When applied to a web service **application programming interface** (**API**),
    we get a **HyperText Transfer Protocol** (**HTTP**)-based RESTful API. The HTTP
    protocol is the foundation of data communication for the World Wide Web, also
    known as the internet. It is the protocol used by servers all around the world
    to serve websites to users in the form of HTML documents, images, style sheets,
    and so forth. An interesting article on this topic for further information can
    be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于Web服务**应用程序编程接口**（**API**）时，我们得到了基于**超文本传输协议**（**HTTP**）的RESTful API。HTTP协议是互联网数据通信的基础，也被称为万维网。它是全球各地服务器用来向用户提供HTML文档、图像、样式表等的协议。有关此主题的有趣文章，可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)找到。
- en: RESTful APIs rely on the standard HTTP methods—`GET`, `POST`, `PUT`, `DELETE`,
    and `PATCH`—to fetch and transform data. These methods allow us to fetch, store,
    delete, and update data entities on remote servers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API依赖于标准的HTTP方法——`GET`、`POST`、`PUT`、`DELETE`和`PATCH`——来获取和转换数据。这些方法允许我们在远程服务器上获取、存储、删除和更新数据实体。
- en: To execute these HTTP methods, we can rely on the built-in Java `HttpURLConnection`
    class or use a library such as `OkHttp`, which offers additional features such
    as gzipping, redirects, retries, and both synchronous and asynchronous calls.
    Interestingly, from Android 4.4, `HttpURLConnection` is just a wrapper around
    `OkHttp`. If we choose `OkHttp`, we might as well go for **Retrofit**, as we will
    in this chapter, to benefit from its type safety, which is better suited for handling
    REST calls.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些HTTP方法，我们可以依赖于内置的Java `HttpURLConnection`类，或者使用诸如`OkHttp`之类的库，它提供了额外的功能，如gzip压缩、重定向、重试以及同步和异步调用。有趣的是，从Android
    4.4开始，`HttpURLConnection`只是`OkHttp`的一个包装器。如果我们选择`OkHttp`，我们也可以选择**Retrofit**，正如我们将在本章中所做的那样，以从其类型安全中受益，这更适合处理REST调用。
- en: 'Most commonly, data is represented by **JavaScript Object Notation** (**JSON**).
    JSON is a text-based data transfer format. As the name implies, it was derived
    from JavaScript. However, it has since become one of the most popular standards
    for data transfer, and its most modern programming languages have libraries that
    encode or decode data to or from JSON. A simple JSON payload may look something
    like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的数据表示形式是**JavaScript对象表示法**（**JSON**）。JSON是一种基于文本的数据传输格式。顾名思义，它源自JavaScript。然而，它已经成为了最流行的数据传输标准之一，大多数现代编程语言都有编码或解码数据到JSON或从JSON的库。一个简单的JSON有效负载可能如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another common data structure used by RESTful services is **Extensible Markup
    Language** (**XML**), which encodes documents in a format that is human- and machine-readable.
    XML is considerably more verbose than JSON. The same data structure as the previous
    in XML would look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务常用的另一种数据结构是**可扩展标记语言**（**XML**），它以一种人类和机器可读的格式对文档进行编码。XML比JSON更冗长。以XML表示的与前述相同的数据结构可能如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this chapter, we will focus on JSON.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于JSON。
- en: When obtaining a JSON payload, we are essentially receiving a string. To convert
    that string into a data object, we have a few options—the most popular ones being
    libraries such as `org.json` package. For its lightweight nature, we will focus
    on Moshi.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取JSON有效负载时，我们实质上是接收一个字符串。要将该字符串转换为数据对象，我们有一些选项，其中最流行的是`org.json`包等库。由于其轻量级特性，我们将专注于Moshi。
- en: Finally, we will look into loading images from the web. Doing so will allow
    us not only to provide up-to-date images but also to load the right images for
    the user's device. It will also let us only load the images when we need them,
    thus keeping our APK size smaller.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将研究如何从网络加载图像。这样做不仅可以让我们提供最新的图像，还可以为用户的设备加载正确的图像。这样做还可以让我们在需要时才加载图像，从而保持APK大小较小。
- en: Fetching Data from a Network Endpoint
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络端点获取数据
- en: For the purpose of this section, we will use TheCatAPI ([https://thecatapi.com/](https://thecatapi.com/)).
    This RESTful API offers us vast data about, well… cats.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本节的目的，我们将使用TheCatAPI（[https://thecatapi.com/](https://thecatapi.com/)）。这个RESTful
    API为我们提供了大量关于猫的数据。
- en: 'To get started, we will create a new project. We then have to grant our app
    internet access permission. This is done by adding the following code to your
    `AndroidManifest.xml` file, right before the `Application` tag:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将创建一个新项目。然后我们必须授予我们的应用程序互联网访问权限。这是通过在您的`AndroidManifest.xml`文件中，在`Application`标签之前添加以下代码来完成的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to set up our app to include Retrofit. `OkHttp` HTTP client.
    Retrofit helps us generate **Uniform Resource Locators** (**URLs**), which are
    the addresses of the server endpoints we want to access. It also makes the decoding
    of JSON payloads easier by providing integration with several parsing libraries.
    Sending data to the server is also easier with Retrofit, as it helps with encoding
    the requests. You can read more about Retrofit here: [https://square.github.io/retrofit/](https://square.github.io/retrofit/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的应用程序以包含Retrofit。`OkHttp` HTTP客户端。 Retrofit帮助我们生成**统一资源定位符**（**URL**），这些是我们要访问的服务器端点的地址。它还通过与几个解析库的集成，使JSON有效负载的解码更容易。使用Retrofit发送数据到服务器也更容易，因为它有助于对请求进行编码。您可以在这里阅读更多关于Retrofit的信息：[https://square.github.io/retrofit/](https://square.github.io/retrofit/)。
- en: 'To add Retrofit to our project, we need to add the following code to the `dependencies`
    block of the `build.gradle` file of our app:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Retrofit添加到我们的项目中，我们需要将以下代码添加到我们应用程序的`build.gradle`文件的`dependencies`块中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the latest version here: [https://github.com/square/retrofit](https://github.com/square/retrofit).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到最新版本：[https://github.com/square/retrofit](https://github.com/square/retrofit)。
- en: With Retrofit included in our project, we can proceed to set it up.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中包含了Retrofit后，我们可以继续设置它。
- en: 'First, to access an HTTP(S) endpoint, we start by defining the contract with
    that endpoint. A contract to access the `https://api.thecatapi.com/v1/images/search`
    endpoint looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要访问HTTP(S)端点，我们首先要定义与该端点的合同。访问`https://api.thecatapi.com/v1/images/search`端点的合同如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few things to note here. First, you will notice that the contract
    is implemented as an interface. This is how you define contracts for Retrofit.
    Next, you will notice that the name of the interface implies that this interface
    can, eventually, cover all calls made to the TheCatAPI service. It is a bit unfortunate
    that Square chose `Service` as the conventional suffix for these contracts, as
    the term service has a different meaning in the Android world, as you will see
    in *Chapter 8*, *Services, Broadcast Receivers, and Notifications*. Nevertheless,
    this is the convention.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。首先，您会注意到合同被实现为一个接口。这是您为Retrofit定义合同的方式。接下来，您会注意到接口的名称暗示着这个接口最终可以涵盖对TheCatAPI服务的所有调用。遗憾的是Square选择了`Service`作为这些合同的常规后缀，因为在Android世界中，服务一词有不同的含义，您将在*第8章*，*服务、广播接收器和通知*中看到。尽管如此，这是惯例。
- en: To define our endpoint, we start by stating the method with which the call will
    be made using the appropriate annotation—in our case, `@GET`. The parameter passed
    to the annotation is the path of the endpoint to access. You'll notice that `https://api.thecatapi.com/v1/`
    is stripped from that path. That is because this is the common address for all
    of the endpoints of TheCatAPI, and so will be passed to our Retrofit instance
    at construction time instead. Next, we choose a meaningful name for our function—in
    this case, we'll be calling the image search endpoint, and so `searchImages` seems
    appropriate. The parameters of the `searchImages` function define the values we
    can pass to the API when we make the calls.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们的端点，我们首先要声明使用适当注释进行调用的方法。在我们的情况下，是`@GET`。传递给注释的参数是要访问的端点的路径。您会注意到`https://api.thecatapi.com/v1/`从该路径中删除了。这是因为这是TheCatAPI所有端点的常用地址，因此将在构建时传递给我们的Retrofit实例。接下来，我们选择一个有意义的函数名字，比如在这种情况下，我们将调用图像搜索端点，所以`searchImages`似乎是合适的。`searchImages`函数的参数定义了我们在进行调用时可以传递给API的值。
- en: There are different ways in which we can transfer data to the API. `@Query`
    allows us to define values added to the query of our request URL (that's the optional
    part of the URL that comes after the question mark). It takes a key value pair
    (in our case, we have `limit` and `size`) and a data type. If the data type is
    not a string, the value of that type will be transformed into a string. Any value
    passed will be URL-encoded for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将数据传输到API。`@Query`允许我们定义添加到请求URL查询的值（这是URL中问号后面的可选部分）。它接受一个键值对（在我们的例子中，我们有`limit`和`size`）和一个数据类型。如果数据类型不是字符串，那么该类型的值将被转换为字符串。传递的任何值都将被URL编码。
- en: Another such way is using `@Path`. This annotation can be used to replace a
    token in our path wrapped in curly brackets with a provided value. The `@Header`,
    `@Headers`, and `@HeaderMap` annotations will allow us to add or remove HTTP headers
    from the request. `@Body` can be used to pass content in the body of `POST`/`PUT`
    requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`@Path`。此注释可用于将路径中用大括号括起来的标记替换为提供的值。`@Header`、`@Headers`和`@HeaderMap`注释将允许我们向请求添加或删除
    HTTP 标头。`@Body`可用于在`POST`/`PUT`请求的正文中传递内容。
- en: Lastly, we have a return type. To keep things simple at this stage, we will
    accept the response as a string. We wrapped our string in a `Call` interface.
    `Call` is Retrofit's mechanism for executing network requests synchronously (via
    `execute()`) or asynchronously (via `enqueue(Callback)`). When using RxJava (the
    Java implementation of ReactiveX, or Reactive Extensions; you can read more about
    ReactiveX at `https://reactivex.io/`), we can wrap our result in an `Observable`
    class (a class that emits data) or a `Single` class (a class that emits data once)
    as appropriate instead (see *Chapter 13*, *RxJava and Coroutines*, for more information
    on RxJava).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个返回类型。在这个阶段，为了保持简单，我们将接受响应作为字符串。我们将字符串包装在`Call`接口中。`Call`是 Retrofit 执行网络请求的机制，可以同步（通过`execute()`）或异步（通过`enqueue(Callback)`）执行。当使用
    RxJava（ReactiveX 的 Java 实现，或者叫做 Reactive Extensions；您可以在`https://reactivex.io/`上了解更多关于
    ReactiveX 的信息）时，我们可以适当地将结果包装在`Observable`类（发出数据的类）或`Single`类（一次发出数据的类）中（有关 RxJava
    的更多信息，请参见*第13章*，*RxJava 和协程*）。
- en: 'With our contract defined, we can get Retrofit to implement our service interface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的合同，我们可以让 Retrofit 实现我们的服务接口：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we try to run our app with this code, our app will crash with `IllegalArgumentException`.
    This is because Retrofit needs us to tell the app how to process the server response
    to a string. This processing is done with what Retrofit calls `ConverterFactory`
    instance to our `retrofit` instance, we need to add the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用此代码运行应用程序，应用程序将崩溃并显示`IllegalArgumentException`。这是因为 Retrofit 需要我们告诉应用程序如何将服务器响应处理为字符串。这个处理是通过
    Retrofit 调用的`ConverterFactory`实例来完成的，我们需要向我们的`retrofit`实例添加以下内容：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For our project to recognize `ScalarsConverterFactory`, we need to update our
    app''s `build.gradle` file by adding another dependency:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的项目识别`ScalarsConverterFactory`，我们需要通过添加另一个依赖项来更新我们的应用程序的`build.gradle`文件：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we can obtain a `Call` instance by calling `val call = theCatApiService.searchImages(1,
    "full")`. With the instance obtained in this fashion, we can execute an async
    request by calling `call.enqueue(Callback)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`val call = theCatApiService.searchImages(1, "full")`来获得一个`Call`实例。通过以这种方式获得的实例，我们可以通过调用`call.enqueue(Callback)`来执行异步请求。
- en: 'Our `Callback` implementation will have two methods: `onFailure(Call, Throwable)`
    and `onResponse(Call, Response)`. Note that we are not guaranteed to have a successful
    response if `onResponse` was called. `onResponse` is called whenever we successfully
    receive any response from the server and no unexpected exception occurred. So,
    to confirm that the response is a success response, we should check the `response.isSuccessful`
    property. The `onFailure` function will be called in the case of a network error
    or an unexpected exception somewhere along the way.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Callback`实现将有两个方法：`onFailure(Call, Throwable)`和`onResponse(Call, Response)`。请注意，如果调用了`onResponse`，我们不能保证会有一个成功的响应。只要我们成功地从服务器接收到任何响应并且没有发生意外异常，就会调用`onResponse`。因此，为了确认响应是成功的响应，我们应该检查`response.isSuccessful`属性。在网络错误或沿途某处发生意外异常的情况下，将调用`onFailure`函数。
- en: So, where should we implement the Retrofit code? In clean architecture, data
    is provided by repositories. Repositories, in turn, have data sources. One such
    data source can be a network data source. This is where we would be implementing
    our network calls. Our ViewModels (in the case of **Model-View-ViewModel** (**MVVM**),
    the ViewModel is an abstraction of the view that exposes properties and commands)
    will then request data from repositories via use cases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该在哪里实现 Retrofit 代码呢？在干净的架构中，数据由存储库提供。存储库又有数据源。这样的数据源可以是网络数据源。这就是我们将实现网络调用的地方。然后，我们的
    ViewModel（在**Model-View-ViewModel**（**MVVM**）的情况下，ViewModel 是暴露属性和命令的视图的抽象）将通过用例从存储库请求数据。
- en: For our implementation, we will simplify the process by instantiating Retrofit
    and the service in the Activity. This is not good practice. Do not do this in
    a production app. It does not scale well and is very difficult to test. Instead,
    adopt an architecture that decouples your views from your business logic and your
    data. See *Chapter 14*, *Architecture Patterns*, for some ideas.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将简化流程，通过在 Activity 中实例化 Retrofit 和服务来完成。这不是一个好的做法。在生产应用中不要这样做。它不具有良好的可扩展性，并且非常难以测试。相反，采用一种将视图与业务逻辑和数据解耦的架构。参见*第14章*，*架构模式*，了解一些想法。
- en: 'Exercise 5.01: Reading Data from an API'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：从 API 读取数据
- en: 'In the following chapters, we will be developing an app for an imaginary secret
    agency with a worldwide network of agents saving the world from countless dangers.
    The secret agency in question is quite unique: it operates secret cat agents.
    In this exercise, we will create an app that presents us with one random secret
    cat agent from TheCatAPI. Before you can present data from an API to your user,
    you first have to fetch that data. Let''s start:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开发一个为一家全球特工机构的虚构应用程序，该机构拥有一个遍布全球的特工网络，拯救世界免受无数危险。所涉及的秘密机构非常独特：它运营秘密猫特工。在这个练习中，我们将创建一个应用程序，该应用程序将向我们展示来自
    TheCatAPI 的一个随机秘密猫特工。在向用户呈现 API 数据之前，您首先必须获取该数据。让我们开始：
- en: Start by creating a new `Empty Activity` project (`File` | `New` | `New Project`
    | `Empty Activity`). Click `Next`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的`Empty Activity`项目（`文件`|`新建`|`新项目`|`空活动`）。然后点击`下一步`。
- en: Name your application `Cat Agent Profile`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序命名为`Cat Agent Profile`。
- en: Make sure your package name is `com.example.catagentprofile`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的包名称为`com.example.catagentprofile`。
- en: Set the save location to where you want to save your project.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为您要保存项目的位置。
- en: Leave everything else at its default values and click `Finish`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有内容保留为默认值，然后点击“完成”。
- en: 'Make sure you are on the `Android` view in your `Project` pane:![Figure 5.1:
    Android view in the Project pane'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在`Project`窗格中处于`Android`视图下：![图5.1：项目窗格中的Android视图
- en: '](img/B15216_05_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_01.jpg)'
- en: 'Figure 5.1: Android view in the Project pane'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：项目窗格中的Android视图
- en: 'Open your `AndroidManifest.xml` file. Add internet permission to your app like
    so:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`AndroidManifest.xml`文件。像这样为你的应用程序添加互联网权限：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add Retrofit and the scalars converter to your app, open the app module,
    `build.gradle` (`Gradle Scripts` | `build.gradle (Module: app)`), and add the
    following lines anywhere inside the `dependencies` block:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要向你的应用程序添加Retrofit和标量转换器，打开应用程序模块的`build.gradle`（`Gradle Scripts` | `build.gradle
    (Module: app)`），并在`dependencies`块的任何位置添加以下行：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Your `dependencies` block should now look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`dependencies`块现在应该看起来像这样：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Between the time of writing and when you carry out this exercise, some dependencies
    may have changed. You should still only add the lines in bold from the preceding
    code block. These will add Retrofit and support for reading server responses as
    single strings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行这个练习的时间和实施之间，一些依赖关系可能已经发生了变化。你应该仍然只添加前面代码块中加粗的行。这些将添加Retrofit和支持读取服务器响应作为单个字符串的功能。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that Retrofit now requires, as a minimum, Android API 21
    or Java 8.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Retrofit现在要求至少Android API 21或Java 8。
- en: Click the `Sync Project with Gradle Files` button in Android Studio.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中点击`Sync Project with Gradle Files`按钮。
- en: Open your `activity_main.xml` file in `Text` mode.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`Text`模式打开你的`activity_main.xml`文件。
- en: 'To be able to use your label to present the latest server response, you need
    to assign an ID to it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用标签来呈现最新的服务器响应，你需要为它分配一个ID：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `Project` pane on the left, right-click on your app package (`com.example.catagentprofile`),
    then select `New` | `Package`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的`Project`窗格中，右键单击你的应用程序包（`com.example.catagentprofile`），然后选择`New` | `Package`。
- en: Name your package `api`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的包命名为`api`。
- en: Now, right-click on the newly created package (`com.example.catagentprofile.api`),
    then select `New` | `Kotlin File/Class`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新创建的包（`com.example.catagentprofile.api`）上右键单击，然后选择`New` | `Kotlin File/Class`。
- en: Name your new file `TheCatApiService`. For `Kind`, choose `Interface`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的新文件命名为`TheCatApiService`。对于`Kind`，选择`Interface`。
- en: 'Add the following into the `interface` block:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`interface`块中添加以下内容：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This defines the image search endpoint. Make sure to import all the required
    Retrofit dependencies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了图像搜索的端点。确保导入所有必需的Retrofit依赖项。
- en: Open your `MainActivity` file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`MainActivity`文件。
- en: 'At the top of the `MainActivity` class block, add the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`类块的顶部添加以下内容：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add `serverResponseView` as a field:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`serverResponseView`添加为一个字段：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the `getCatImageResponse()` function after the `onCreate(Bundle?)`
    function:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`onCreate(Bundle?)`函数之后添加`getCatImageResponse()`函数：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will fire off the search request and handle the possible outcomes—a
    successful response, an error response, and any other thrown exception.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将发出搜索请求并处理可能的结果——成功的响应、错误的响应和任何其他抛出的异常。
- en: 'Invoke a call to `getCatImageResponse()` in `onCreate()`. This will trigger
    the call as soon as the activity is created:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`中调用`getCatImageResponse()`。这将在活动创建时触发调用：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the missing imports.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加缺失的导入。
- en: 'Run your app by clicking the `Run ''app''` button or pressing *Ctrl* + *R*.
    On the emulator, it should look like this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`Run 'app'`按钮或按下*Ctrl* + *R*来运行你的应用程序。在模拟器上，它应该看起来像这样：
- en: '![Figure 5.2: The app presenting the server response JSON'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：应用程序呈现服务器响应JSON'
- en: '](img/B15216_05_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_02.jpg)'
- en: 'Figure 5.2: The app presenting the server response JSON'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：应用程序呈现服务器响应JSON
- en: Because every time you run your app a new call is made and a random response
    is returned, your result will likely differ. However, whatever your result, if
    successful, it should be a JSON payload. Next, we will learn how to parse that
    JSON payload and extract the data we want from it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次运行应用程序都会进行一次新的调用并返回一个随机的响应，所以你的结果可能会有所不同。然而，无论你的结果如何，如果成功的话，它应该是一个JSON负载。接下来，我们将学习如何解析该JSON负载并从中提取我们想要的数据。
- en: Parsing a JSON Response
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON响应
- en: Now that we have successfully retrieved a JSON response from an API, it is time
    to learn how to use the data we have obtained. To do so, we need to parse the
    JSON payload. This is because the payload is a plain string representing the data
    object, and we are interested in specific properties of that object. If you look
    closely at *Figure 5.2*, you may notice that the JSON contains breed information,
    an image URL, and some other bits of information. However, for our code to use
    that information, first we have to extract it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功从API中检索到了JSON响应，是时候学习如何使用我们获取到的数据了。为了做到这一点，我们需要解析JSON负载。这是因为负载是一个表示数据对象的纯字符串，我们对该对象的特定属性感兴趣。如果你仔细看*图5.2*，你可能会注意到JSON包含品种信息、图像URL和一些其他信息。然而，为了让我们的代码使用这些信息，首先我们需要提取它。
- en: As mentioned in the introduction, multiple libraries exist that will parse a
    JSON payload for us. The most popular ones are Google's GSON ([https://github.com/google/gson](https://github.com/google/gson))
    and, more recently, Square's Moshi ([https://github.com/square/moshi](https://github.com/square/moshi)).
    Moshi is very lightweight, which is why we have chosen to use it in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，存在多个库可以解析JSON负载。最流行的是Google的GSON（[https://github.com/google/gson](https://github.com/google/gson)）和最近更受欢迎的是Square的Moshi（[https://github.com/square/moshi](https://github.com/square/moshi)）。Moshi非常轻量级，这就是为什么我们选择在本章中使用它的原因。
- en: What do JSON libraries do? Basically, they help us convert data classes into
    JSON strings (serialization) and vice versa (deserialization). This helps us communicate
    with servers that understand JSON strings while allowing us to use meaningful
    data structures in our code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JSON库的作用是什么？基本上，它们帮助我们将数据类转换为JSON字符串（序列化）以及反之（反序列化）。这帮助我们与理解JSON字符串的服务器进行通信，同时允许我们在代码中使用有意义的数据结构。
- en: 'To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to
    our project. This is done by adding the following line to the `dependencies` block
    of our app''s `build.gradle` file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Retrofit中使用Moshi，我们需要将Moshi Retrofit转换器添加到我们的项目中。这是通过将以下行添加到我们应用程序的`build.gradle`文件的`dependencies`块中来完成的：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we will no longer be accepting the responses as strings, we can go ahead
    and remove the scalars Retrofit converter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将不再接受字符串作为响应，我们可以继续删除标量Retrofit转换器。
- en: Next, we need to create a data class to map the server JSON response to. One
    convention is to suffix the names of API response data classes with `Data`—so
    we'll call our data class `ImageResultData`. Another common suffix is `Entity`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个数据类，将服务器JSON响应映射到该类。一个惯例是给API响应数据类的名称添加后缀`Data`——所以我们将我们的数据类称为`ImageResultData`。另一个常见的后缀是`Entity`。
- en: 'When we design our server response data classes, we need to take two factors
    into account: the structure of the JSON response and our data requirements. The
    first will affect our data types and field names, while the second will allow
    us to omit fields we do not currently need. JSON libraries know that they should
    ignore data in fields we have not defined in our data classes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计服务器响应数据类时，我们需要考虑两个因素：JSON响应的结构和我们的数据需求。第一个将影响我们的数据类型和字段名称，而第二个将允许我们省略我们当前不需要的字段。JSON库知道它们应该忽略我们在数据类中未定义的字段中的数据。
- en: 'One more thing JSON libraries do for us is automatically map JSON data to fields
    if they happen to have the exact same name. While this is a nice feature, it is
    also problematic. If we rely solely on it, our data classes (and the code accessing
    them) will be tightly coupled to the API naming. Because not all APIs are designed
    well, you might end up with meaningless field names, such as `fn` or `last`, or
    inconsistent naming. Luckily, there is a solution to this problem. Moshi provides
    us with an `@field:Json` annotation. It can be used to map a JSON field name to
    a meaningful field name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JSON库为我们做的另一件事是，如果它们恰好具有完全相同的名称，它们会自动将JSON数据映射到字段。虽然这是一个很好的功能，但也有问题。如果我们完全依赖它，我们的数据类（以及访问它们的代码）将与API命名紧密耦合。因为并非所有API都设计良好，您可能最终会得到毫无意义的字段名称，例如`fn`或`last`，或者不一致的命名。幸运的是，这个问题有解决办法。Moshi为我们提供了一个`@field:Json`注解。它可以用来将JSON字段名称映射到有意义的字段名称：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Some consider it better practice to include the annotation even when the API
    name is the same as the field name for the sake of consistency. We prefer the
    conciseness of direct conversion when the field name is clear enough. This approach
    can be challenged when obfuscating our code. If we do, we have to either exclude
    our data classes or make sure to annotate all fields.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有人认为，出于一致性考虑，即使API名称与字段名称相同，也最好包括该注解。当字段名称足够清晰时，我们更喜欢直接转换的简洁性。当我们混淆我们的代码时，这种方法可能会受到挑战。如果我们这样做，我们要么排除我们的数据类，要么确保对所有字段进行注释。
- en: While we are not always lucky enough to have properly documented APIs, when
    we do, it is best to consult the documentation when designing our model. Our model
    would be a data class into which the JSON data from all calls we make will be
    decoded. The documentation for the image search endpoint of TheCatAPI can be found
    at [https://docs.thecatapi.com/api-reference/images/images-search](https://docs.thecatapi.com/api-reference/images/images-search).
    You will often find documentation to be partial or inaccurate. If this happens
    to be the case, the best thing you can do is contact the owners of the API and
    request that they update the documentation. You may have to resort to experimenting
    with an endpoint, unfortunately. This is risky because undocumented fields or
    structures are not guaranteed to remain the same, so when possible, try and get
    the documentation updated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们并不总是幸运地拥有适当记录的API，但当我们拥有时，最好在设计我们的模型时咨询文档。我们的模型将是一个数据类，其中我们进行的所有调用的JSON数据将被解码。TheCatAPI图像搜索端点的文档可以在[https://docs.thecatapi.com/api-reference/images/images-search](https://docs.thecatapi.com/api-reference/images/images-search)找到。您经常会发现文档是部分的或不准确的。如果是这种情况，您能做的最好的事情就是联系API的所有者，并要求他们更新文档。不幸的是，您可能不得不尝试使用端点。这是有风险的，因为未记录的字段或结构不能保证保持不变，所以在可能的情况下，尽量获取文档更新。
- en: 'Based on the response schema obtained from the preceding link, we can define
    our model as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从上述链接获取的响应模式，我们可以定义我们的模型如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the response structure is actually that of a list of results. This
    means we need our responses mapped to `List<ImageResultData>`, not simply `ImageResultData`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，响应结构实际上是结果列表。这意味着我们需要将我们的响应映射到`List<ImageResultData>`，而不仅仅是`ImageResultData`。
- en: Now, we need to update `TheCatApiService`. Instead of `Call<String>`, we can
    now have `Call<List<ImageResultData>>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`TheCatApiService`。现在我们可以有`Call<List<ImageResultData>>`，而不是`Call<String>`。
- en: Next, we need to update the construction of our Retrofit instance. Instead of
    `ScalarsConverterFactory`, we will now have `MoshiConverterFactory`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的Retrofit实例的构造。现在我们将有`MoshiConverterFactory`，而不是`ScalarsConverterFactory`。
- en: 'Lastly, we need to update our callback, since it should no longer be handing
    string calls, but `List<ImageResultData>` instead:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的回调，因为它不再处理字符串调用，而是处理`List<ImageResultData>`：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Exercise 5.02: Extracting the Image URL from the API Response'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：从API响应中提取图像URL
- en: 'So, we have a server response as a string. Now, we want to extract the image
    URL from that string and present only that URL on the screen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个作为字符串的服务器响应。现在，我们想从该字符串中提取图像URL，并仅在屏幕上显示该URL：
- en: 'Open the app''s `build.gradle` file and replace the scalars converter implementation
    with a Moshi converter one:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序的`build.gradle`文件，并用Moshi转换器替换标量转换器实现：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Click the `Sync Project with Gradle Files` button.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“与Gradle文件同步”按钮。
- en: Under your app package (`com.example.catagentprofile`), create a `model` package.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序包（`com.example.catagentprofile`）下，创建一个`model`包。
- en: Within the `com.example.catagentprofile.model` package, create a new Kotlin
    file named `CatBreedData`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.catagentprofile.model`包中，创建一个名为`CatBreedData`的新的Kotlin文件。
- en: 'Populate the newly created file with the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容填充新创建的文件：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, create `ImageResultData` under the same package.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在同一个包下创建`ImageResultData`。
- en: 'Set its contents to the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其内容设置为以下内容：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `TheCatApiService` file and update the `searchImages` return type:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TheCatApiService`文件并更新`searchImages`返回类型：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lastly, open `MainActivity`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`MainActivity`。
- en: 'Update the Retrofit initialization block to use the Moshi converter to deserialize JSON:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Retrofit初始化块以使用Moshi转换器进行反序列化JSON：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `getCatImageResponse()` function to handle `List<ImageResultData>`
    requests and responses:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getCatImageResponse()`函数以处理`List<ImageResultData>`的请求和响应：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you need to check not only for a successful response but also that there
    is at least one `ImageResultData` instance. You can then read the `imageUrl` property
    of that instance and present it to the user.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要检查的不仅是成功的响应，还要确保至少有一个`ImageResultData`实例。然后，您可以读取该实例的`imageUrl`属性并将其呈现给用户。
- en: 'Run your app. It should now look something like the following:![Figure 5.3:
    App presenting the parsed image URL'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。现在它应该看起来像下面这样：![图5.3：应用程序呈现解析后的图像URL
- en: '](img/B15216_05_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_03.jpg)'
- en: 'Figure 5.3: App presenting the parsed image URL'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：应用程序呈现解析后的图像URL
- en: Again, due to the random nature of the API responses, your URL will likely be different.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于API响应的随机性，您的URL可能会不同。
- en: You have now successfully extracted a specific property from an API response.
    Next, we will learn how to load the image from the URL provided to us by the API.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已成功从API响应中提取了特定属性。接下来，我们将学习如何从API提供的URL加载图像。
- en: Loading Images from a Remote URL
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程URL加载图像
- en: We just learned how to extract particular data from an API response. Quite often,
    that data will include URLs to images we want to present to the user. There is
    quite a bit of work involved in achieving that. First, you have to fetch the image
    as a binary stream from the URL. Then, you need to transform that binary stream
    into an image (it could be a GIF, JPEG, or one of a few other image formats).
    Then, you need to convert it into a bitmap instance, potentially resizing it to
    use less memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚学会了如何从API响应中提取特定数据。很多时候，这些数据将包括我们想要呈现给用户的图像的URL。这需要相当多的工作。首先，您必须从URL中获取图像作为二进制流。然后，您需要将该二进制流转换为图像（可以是GIF、JPEG或其他几种图像格式之一）。然后，您需要将其转换为位图实例，可能调整大小以使用更少的内存。
- en: You may also want to apply other transformations to it at that point. Then,
    you need to set it to an `ImageView`. Sounds like a lot of work, doesn't it? Well,
    luckily for us, there are a few libraries that do all of that (and more) for us.
    The most commonly used libraries are Square's **Picasso** ([https://square.github.io/picasso/](https://square.github.io/picasso/))
    and **Glide** by Bump Technologies ([https://github.com/bumptech/glide](https://github.com/bumptech/glide)).
    Facebook's **Fresco** ([https://frescolib.org/](https://frescolib.org/)) is somewhat
    less popular. We will proceed with Glide because it is consistently the faster
    of the two for loading images, whether it is from the internet or from the cache.
    It's worth noting that Picasso is more lightweight, so it is a trade-off, and
    both libraries are quite useful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望在此时对其进行其他转换。然后，您需要将其设置为`ImageView`。听起来是很多工作，不是吗？幸运的是，有一些库可以为我们完成所有这些工作（甚至更多）。最常用的库是Square的**Picasso**（[https://square.github.io/picasso/](https://square.github.io/picasso/)）和Bump
    Technologies的**Glide**（[https://github.com/bumptech/glide](https://github.com/bumptech/glide)）。Facebook的**Fresco**（[https://frescolib.org/](https://frescolib.org/)）相对不太受欢迎。我们将继续使用Glide，因为它始终是加载图像的两者中更快的一个，无论是来自互联网还是缓存。值得注意的是Picasso更轻量级，所以这是一个权衡，两个库都非常有用。
- en: 'To include Glide in your project, add it to the `dependencies` block of your
    app''s `build.gradle` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Glide，请将其添加到应用程序的`build.gradle`文件的`dependencies`块中：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In fact, because we might change our minds at a later point, this is a great
    opportunity to abstract away the concrete library to have a simpler interface
    of our own. So, let''s start by defining our `ImageLoader` interface:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，因为我们可能在以后改变主意，这是一个很好的机会来将具体库抽象出来，以拥有更简单的接口。所以，让我们从定义我们的`ImageLoader`接口开始：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a naïve implementation. In a production implementation, you might want
    to add arguments (or multiple functions) to support options such as different
    cropping strategies or having loading states.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个天真的实现。在生产实现中，您可能希望添加参数（或多个函数）以支持不同的裁剪策略或具有加载状态。
- en: 'Our implementation of the interface will rely on Glide, and so will look something
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接口实现将依赖于Glide，因此看起来会像这样：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We prefix our class name with `Glide` to differentiate it from other potential
    implementations. Constructing `GlideImageLoader` with `context` allows us to implement
    the clean `loadImage(String, ImageView)` interface without having to worry about
    the context, which is required by Glide for image loading. In fact, Glide is smart
    about the Android context. That means we could have separate implementations for
    `Activity` and `Fragment` scopes, and Glide would know when an image-loading request
    went beyond the scope.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类名前加上`Glide`以区别于其他潜在的实现。使用`context`构建`GlideImageLoader`允许我们实现清晰的`loadImage(String,
    ImageView)`接口，而不必担心Glide所需的上下文，这实际上是Glide对Android上下文的智能处理。这意味着我们可以针对`Activity`和`Fragment`范围有单独的实现，而Glide会知道何时图像加载请求超出范围。
- en: 'Since we haven''t yet added an `ImageView` to our layout, let''s do that now:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未在布局中添加`ImageView`，现在让我们这样做：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will add an `ImageView` with an ID of `main_profile_image` below our `TextView`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的`TextView`下方添加一个ID为`main_profile_image`的`ImageView`。
- en: 'We can now create an instance of `GlideImageLoader` in `MainActivity`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`MainActivity`中创建`GlideImageLoader`的实例：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, in a production app, you would be injecting the dependency, rather than
    creating it inline.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用中，您将注入依赖项，而不是内联创建。
- en: 'Next, we tell our Glide loader to load the image and, once loaded, center-crop
    it inside the provided `ImageView`. This means the image will be scaled up or
    down to fully fill the `ImageView`, with any excess content cut off (cropped).
    Since we already obtained an image URL before, all we need to do is make the call:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉我们的Glide加载器加载图像，并且一旦加载完成，就在提供的`ImageView`内居中裁剪它。这意味着图像将被放大或缩小以完全填充`ImageView`，任何多余的内容都将被裁剪掉。由于我们之前已经获得了图像URL，所以我们需要做的就是调用：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have to make sure the result contains a string that is not empty or made
    of spaces (`isBlank()` in the preceding code block). Then, we can safely load
    the URL into our `ImageView`. And we''re done. If we run our app now, we should
    see something similar to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保结果包含一个不为空或由空格组成的字符串（在前面的代码块中使用`isBlank()`）。然后，我们可以安全地将URL加载到我们的`ImageView`中。然后就完成了。如果现在运行我们的应用程序，应该会看到类似以下的东西：
- en: '![Figure 5.4: Server response image URL with the actual image'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：服务器响应图像URL与实际图像'
- en: '](img/B15216_05_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_04.jpg)'
- en: 'Figure 5.4: Server response image URL with the actual image'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：服务器响应图像URL与实际图像
- en: Remember that the API returns random results, so the actual image is likely
    to be different. If we're lucky, we might even get an animated GIF, which we would
    then see animating.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，API返回随机结果，因此实际图像可能会有所不同。如果我们幸运的话，甚至可能会得到一个动画GIF，然后我们就会看到它动画。
- en: 'Exercise 5.03: Loading the Image from the Obtained URL'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：从获取的URL加载图像
- en: 'In the previous exercise, we extracted the image URL from the API response.
    Now, we will use that URL to fetch an image from the web and display it in our
    app:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们从API响应中提取了图像URL。现在，我们将使用该URL从网络获取图像并在我们的应用程序中显示它：
- en: 'Open the app''s `build.gradle` file and add the Glide dependency:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序的`build.gradle`文件并添加Glide依赖项：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Synchronize your project with the Gradle files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目与Gradle文件同步。
- en: On the left `Project` panel, right-click on your project package name (`com.example.catagentprofile`)
    and select `New` | `Kotlin File/Class`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的`Project`面板上，右键单击您的项目包名称（`com.example.catagentprofile`），然后选择`New` | `Kotlin
    File/Class`。
- en: Fill in `ImageLoader` in the `Name` field. For `Kind`, choose `Interface`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Name`字段中填写`ImageLoader`。对于`Kind`，选择`Interface`。
- en: 'Open the newly created `ImageLoader.kt` file and update it like so:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的`ImageLoader.kt`文件，并像这样更新它：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will be your interface for any image loader in the app.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是应用程序中任何图像加载器的接口。
- en: Right-click on the project package name again, and again select `New` | `Kotlin
    File/Class`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目包名称，然后再次选择`New` | `Kotlin File/Class`。
- en: Name the new file `GlideImageLoader`, and select `Class` for `Kind`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`GlideImageLoader`，并选择`Class`作为`Kind`。
- en: 'Update the newly created file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新新创建的文件：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Open `activity_main.xml`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`。
- en: 'Update it like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样更新它：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open the `MainActivity.kt` file.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.kt`文件。
- en: 'Add a field for your newly added `ImageView` at the top of your class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的类顶部添加一个新添加的`ImageView`字段：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define `ImageLoader` just above the `onCreate(Bundle?)` function:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate(Bundle?)`函数的上方定义`ImageLoader`：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update your `getCatImageResponse()` function like so:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样更新您的`getCatImageResponse()`函数：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, once you have a non-blank URL, it will be loaded into `profileImageView`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦您有一个非空的URL，它将被加载到`profileImageView`中。
- en: 'Run the app:![Figure 5.5: Exercise outcome – showing a random image and its
    source URL'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序：![图5.5：练习结果-显示随机图像及其源URL
- en: '](img/B15216_05_05.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_05.jpg)'
- en: 'Figure 5.5: Exercise outcome – showing a random image and its source URL'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：练习结果-显示随机图像及其源URL
- en: The following are bonus steps.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是额外的步骤。
- en: 'Update your layout like so:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样更新您的布局：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will add an `Agent breed` label and tidy up the view layout. Now, your
    layout looks a bit more like a proper cat agent profile app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加一个`Agent breed`标签并整理视图布局。现在，您的布局看起来更像是一个合适的猫代理配置文件应用程序。
- en: 'In `MainActivity.kt`, locate the following lines:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.kt`中，找到以下行：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace that line with the following to look up the new name field:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换该行以查找新的名称字段：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update `getCatImageResponse()` like so:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getCatImageResponse()`如下：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is done to load the first breed returned from the API into `agentNameView`,
    with a fallback to `Unknown`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了将API返回的第一个品种加载到`agentNameView`中，如果没有则回退到`Unknown`。
- en: 'At the time of writing, not many pictures in TheCatAPI have breed data. However,
    if you run your app enough times, you will end up seeing something like this:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本文时，TheCatAPI中没有太多带有品种数据的图片。但是，如果您运行应用程序足够多次，最终会看到类似这样的东西：
- en: '![Figure 5.6: Showing the cat agent image and breed'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：显示猫代理图像和品种'
- en: '](img/B15216_05_06.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_06.jpg)'
- en: 'Figure 5.6: Showing the cat agent image and breed'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：显示猫代理图像和品种
- en: In this chapter, we learned how to fetch data from a remote API. We then learned
    how to process that data and extract the information we need from it. Lastly,
    we learned how to present an image on the screen when given an image URL.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从远程API获取数据。然后，我们学习了如何处理这些数据并从中提取我们需要的信息。最后，我们学习了如何在给定图像URL时在屏幕上呈现图像。
- en: In the following activity, we will apply our knowledge to develop an app that
    tells the user the current weather in New York, presenting the user with a relevant
    weather icon, too.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，我们将应用我们的知识开发一个应用程序，告诉用户纽约的当前天气，并向用户展示相关的天气图标。
- en: 'Activity 5.01: Displaying the Current Weather'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：显示当前天气
- en: Let's say we want to build an app that shows the current weather in New York.
    Furthermore, we also want to display an icon that represents the current weather.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个应用程序，显示纽约的当前天气。此外，我们还想显示代表当前天气的图标。
- en: This activity aims to create an app that polls an API endpoint for the current
    weather in JSON format, transforms that data into a local model, and uses that
    model to present the current weather. It also extracts the URL to an icon representing
    the current weather and fetches that icon to be displayed on the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动旨在创建一个应用程序，它会轮询一个API端点以获取JSON格式的当前天气，将这些数据转换为本地模型，并使用该模型呈现当前天气。它还会提取代表当前天气的图标的URL，并获取该图标以在屏幕上显示。
- en: We will use the free OpenWeatherMap.org API for the purpose of this activity.
    Documentation can be found at [https://www.metaweather.com/api/](https://www.metaweather.com/api/).
    To sign up for an API token, please go to [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).
    You can find your keys and generate new ones as needed at [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用免费的OpenWeatherMap.org API来完成这个活动的目的。文档可以在[https://www.metaweather.com/api/](https://www.metaweather.com/api/)找到。要注册API令牌，请转到[https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)。您可以在[https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys)找到您的密钥，并根据需要生成新的密钥。
- en: 'The steps are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Create a new app.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序。
- en: Grant internet permissions to the app in order to be able to make API and image requests.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予应用程序互联网权限，以便能够进行API和图像请求。
- en: Add Retrofit, the Moshi converter, and Glide to the app.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Retrofit、Moshi转换器和Glide添加到应用程序中。
- en: Update the app layout to support the presentation of the weather in a textual
    form (short and long description) as well as a weather icon image.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序布局，以支持以文本形式（简短和长描述）呈现天气以及天气图标图像。
- en: Define the model. Create classes that will contain the server response.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模型。创建包含服务器响应的类。
- en: Add the Retrofit service for the OpenWeatherMap API,[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为OpenWeatherMap API添加Retrofit服务，[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather)。
- en: Create a Retrofit instance with a Moshi converter.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Moshi转换器创建一个Retrofit实例。
- en: Call the API service.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用API服务。
- en: Handle the successful server response.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理成功的服务器响应。
- en: Handle the different failure scenarios.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理不同的失败场景。
- en: 'The expected output is shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 5.7: The final weather app'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：最终的天气应用程序'
- en: '](img/B15216_05_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_05_07.jpg)'
- en: 'Figure 5.7: The final weather app'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：最终的天气应用程序
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在此处找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to fetch data from an API using Retrofit. We
    then learned how to handle JSON responses using Moshi, as well as plain text responses.
    We also saw how different error scenarios can be handled.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了如何使用Retrofit从API获取数据。然后我们学会了如何使用Moshi处理JSON响应，以及纯文本响应。我们还看到了如何处理不同的错误场景。
- en: We later learned how to load images from URLs using Glide and how to present
    them to the user via `ImageView`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 后来我们学会了如何使用Glide从URL加载图像，以及如何通过`ImageView`呈现给用户。
- en: There are quite a few popular libraries for fetching data from APIs as well
    as for loading images. We only covered some of the most popular ones. You might
    want to try out some of the other libraries to find out which ones fit your purpose
    best.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多流行的库可以从API中获取数据，以及加载图像。我们只涵盖了一些最流行的库。您可能想尝试一些其他库，找出哪些最适合您的目的。
- en: In the next chapter, we will be introduced to `RecyclerView`, which is a powerful
    UI component that we can use to present our users with lists of items.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`RecyclerView`，这是一个强大的UI组件，我们可以用它来向用户呈现项目列表。
