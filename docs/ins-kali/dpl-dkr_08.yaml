- en: Building Our Own Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们自己的平台
- en: 'In previous chapters, we spent a lot of time working on individual pieces of
    infrastructure building up little isolated pieces here and there, but in this
    chapter, we will try to put as many concepts together and build a minimally-viable
    **Platform-as-a-Service** (**PaaS**). In the following sections, we will cover
    these topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们花了很多时间在基础设施的各个部分上建立了一些孤立的小部分，但在本章中，我们将尝试将尽可能多的概念结合在一起，构建一个最小可行的平台即服务（PaaS）。在接下来的章节中，我们将涵盖以下主题：
- en: '**Configuration Management **(**CM**) tooling'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理（CM）工具
- en: '**Amazon Web Service** (**AWS**) deployment'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务（AWS）部署
- en: Continuous integration/Continuous delivery (CI/CD)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成/持续交付（CI/CD）
- en: As we build up the core of our services, we will see what it takes to take a
    small service and deploy it into the real cloud.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的服务核心时，我们将看到将一个小服务部署到真正的云中需要做些什么。
- en: One thing to note here is that this chapter is provided as only a quick primer
    and a basic example on real deployments in the cloud since creating a full PaaS
    infrastructure with all the bells and whistles is something that is usually so
    complex that it takes large teams months or years sometime to work out all the
    problems. Compounding the issue, the solutions are usually very specifically tailored
    to the choices of services and orchestration tooling running on top of this and
    as such, consider things you see in this chapter as a sample of the current ecosystem
    that you could use in your own deployment but other tools may be better suited
    to your specific needs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，本章仅作为云中实际部署的快速入门和基本示例，因为创建一个带有所有功能的PaaS基础设施通常是非常复杂的，需要大型团队花费数月甚至数年的时间来解决所有问题。更为复杂的是，解决方案通常非常具体地针对运行在其上的服务和编排工具的选择，因此，请将本章中看到的内容视为您自己部署中可使用的当前生态系统的样本，但其他工具可能更适合您的特定需求。
- en: Configuration management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: With every system that depends on a large number of similarly configured machines
    (regardless of whether they are physical or virtual ones), there always arises
    a need for simple and easy rebuild tooling to help automate the majority of the
    tasks that have in the past been done by hand. In the case of PaaS clusters, ideally,
    all pieces of the infrastructure are capable of being rebuilt with minimal user
    intervention into the exact state that is wanted. In the case of bare-metal PaaS
    server nodes, this is critically important as any operation that you have to do
    manually gets multiplied by the number of nodes you have, so streamlining this
    process should be of utmost importance for any kind of production-ready clustering
    infrastructure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个依赖大量类似配置的机器的系统（无论是物理还是虚拟的），总会出现对简单易用的重建工具的需求，以帮助自动化大部分过去需要手动完成的任务。在PaaS集群的情况下，理想情况下，所有基础设施的部分都能够在最小用户干预的情况下被重建为所需的确切状态。对于裸金属PaaS服务器节点来说，这是至关重要的，因为任何需要手动操作的操作都会随着节点数量的增加而增加，因此优化这个过程对于任何生产就绪的集群基础设施来说都是至关重要的。
- en: 'Now you may ask yourself, "Why do we care about covering CM tooling?" and the
    truth of the matter is that if you do not have proper CM around your container
    infrastructure, you are guaranteeing yourself after-hour emergency calls due to
    various issues such as: the nodes never joining the cluster, mismatched configurations,
    unapplied changes, version incompatibilities, and many other problems that will
    make you pull your hair out. So to prevent this set of situations from happening
    to you, we will really dive deep into this ecosystem of supporting software.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问自己，“为什么我们要关心CM工具？”事实上，如果您在容器基础设施周围没有适当的CM，您将确保自己在各种问题上会在非工作时间接到紧急电话，例如：节点永远无法加入集群，配置不匹配，未应用的更改，版本不兼容，以及许多其他问题，这些问题会让您抓狂。因此，为了防止这一系列情况发生在您身上，我们将深入研究这个支持软件生态系统。
- en: 'With that explained and out of the way, we can see some of the options we have
    available to choose from for the CM tooling:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解释清楚并且了解清楚之后，我们可以看到一些可供选择的CM工具：
- en: Ansible ([https://www.ansible.com](https://www.ansible.com))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible ([https://www.ansible.com](https://www.ansible.com))
- en: Puppet ([https://puppet.com](https://puppet.com))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet ([https://puppet.com](https://puppet.com))
- en: Chef ([https://www.chef.io/chef/](https://www.chef.io/chef/))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef ([https://www.chef.io/chef/](https://www.chef.io/chef/))
- en: SaltStack ([https://saltstack.com](https://saltstack.com))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SaltStack ([https://saltstack.com](https://saltstack.com))
- en: A few others that are mostly far weaker in terms of functionality and stability.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些其他工具在功能和稳定性方面大多较弱。
- en: Due to the fact that both Puppet and Chef require an agent-based deployment
    and SaltStack is trailing in Ansible popularity by a huge margin, for our work
    here, we will cover Ansible as the CM tooling of choice but as your needs will
    probably vary. Use your own requirements to select the most appropriate tool for
    the job.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Puppet和Chef都需要基于代理的部署，而SaltStack在Ansible的流行度方面落后很多，因此在我们的工作中，我们将Cover Ansible作为首选的CM工具，但是您的需求可能会有所不同。根据自己的需求选择最合适的工具。
- en: As a relevant side note from my interactions with the DevOps online communities,
    it seems that at the time of writing this material, Ansible is becoming the de
    facto standard for CM tooling but it is not without its flaws. While I would love
    to recommend its use everywhere for a myriad of great features, expect complex
    edge cases of bigger modules to be marginally reliable and keep in mind that most
    bugs you will find are likely to have been already fixed by an unmerged pull request
    on GitHub that you might have to apply locally as needed.WARNING! Choice of configuration
    management tooling should not be taken lightly and you should weigh the pros and
    cons of each before committing to a single one as this tooling is the hardest
    to switch out once you have a few machines managed with it! While many IT and
    DevOps professionals treat this choice almost as a way of life (similar to polarization
    between `vim` and `emacs` users), make sure that you evaluate your options carefully
    and logically due to the high costs of switching to a different one down the road.
    I have personally never heard of a company switch CM tooling after running with
    one for a while though I am sure there are a few out there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个相关的侧面说明，从我与DevOps在线社区的互动中，似乎在撰写本材料时，Ansible正在成为CM工具的事实标准，但它并非没有缺陷。虽然我很愿意推荐它的使用，因为它有许多出色的功能，但请预期更大模块的复杂边缘情况可能不太可靠，并且请记住，您可能会发现的大多数错误可能已经通过GitHub上的未合并的拉取请求进行了修复，您可能需要根据需要在本地应用。警告！选择配置管理工具不应该轻率对待，您应该在承诺使用某个工具之前权衡利弊，因为一旦您管理了一些机器，这个工具是最难更换的！虽然许多IT和DevOps专业人员几乎将这个选择视为一种生活方式（类似于`vim`和`emacs`用户之间的极化），但请确保您仔细和理性地评估您的选择，因为在未来更换到不同的工具的成本很高。我个人从未听说过一家公司在使用某种工具一段时间后更换配置管理工具，尽管我相信有一些公司这样做了。
- en: Ansible
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: 'If you have not worked with Ansible before, it is has the following benefits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有使用过Ansible，它具有以下好处：
- en: It is relatively easy to use (YAML/Ninja2 based)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它相对容易使用（基于YAML/Ninja2）
- en: It only needs an SSH connection to the target
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只需要一个SSH连接到目标
- en: It contains a huge amount of pluggable modules to extend its functionality ([https://docs.ansible.com/ansible/latest/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules_by_category.html)),
    many of which are in the base install so you usually do not have to worry about
    dependencies
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含大量可插拔模块，以扩展其功能（[https://docs.ansible.com/ansible/latest/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules_by_category.html)），其中许多在基本安装中，因此通常不必担心依赖关系
- en: If this list doesn't sound good enough, the whole Ansible architecture is extensible,
    so if there are no available modules that satisfy your requirements, they are
    somewhat easy to write and integrate, and thus Ansible is able to accommodate
    almost any infrastructure you may have or want to build. Under the covers, Ansible
    uses Python and SSH to run commands directly on the target host but in a much
    higher-level **domain-specific language** (**DSL**) that makes it very easy and
    quick for someone to write a server configuration versus scripting SSH commands
    directly through something like Bash.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个列表听起来不够好，整个Ansible架构是可扩展的，因此如果没有满足您要求的可用模块，它们相对容易编写和集成，因此Ansible能够适应您可能拥有或想要构建的几乎任何基础设施。在底层，Ansible使用Python和SSH直接在目标主机上运行命令，但使用了一个更高级的**领域特定语言**（**DSL**），使得对比直接通过类似Bash的方式编写SSH命令，编写服务器配置对某人来说非常容易和快速。
- en: The current Ubuntu LTS version (16.04) comes with Ansible 2.0.0.2, which should
    be adequate for most purposes, but using versions that are closer to upstream
    ones is often advised for both bug fixes and for new module additions. If you
    choose the latter route, make sure to have the version pinned to ensure consistently
    working deployments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Ubuntu LTS版本（16.04）带有Ansible 2.0.0.2，这对大多数情况来说应该是足够的，但通常建议使用更接近上游版本的版本，既可以修复错误，也可以添加新的模块。如果选择后者，请确保固定版本以确保一致的工作部署。
- en: Installation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'To install Ansible on most Debian-based distributions, generally the process
    is extremely simple:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在大多数基于Debian的发行版上安装Ansible，通常过程非常简单：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Basics
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'The standard layout for a project is usually split into roles that define functionality
    slices with the rest of the configurations basically just supporting those roles.
    The basic file structure of Ansible projects looks something like this (though
    more complex setups are often needed):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的标准布局通常分为定义功能切片的角色，其余的配置基本上只是支持这些角色。Ansible项目的基本文件结构看起来像这样（尽管通常需要更复杂的设置）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us break down the basic structure of this filesystem tree and see how each
    piece is used in the bigger picture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个文件系统树的基本结构，并看看每个部分在更大的图景中是如何使用的：
- en: '`group_vars/all`: This file is used to define variables that are used for all
    of your playbooks. These can be used in playbooks and templates with variable
    expansions (`"{{ variable_name }}"`).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars/all`：这个文件用于定义所有playbooks中使用的变量。这些变量可以在playbooks和模板中使用变量扩展（`"{{
    variable_name }}"`）。'
- en: '`hosts/`: This file or a directory lists hosts and groups that you want to
    manage and any specific connectivity details like protocol, username, SSH key,
    and so on. In documentation, this file is often called the inventory file.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts/`：这个文件或目录列出了您想要管理的主机和组，以及任何特定的连接细节，比如协议、用户名、SSH密钥等。在文档中，这个文件通常被称为清单文件。'
- en: '`roles/`: This holds a list of role definitions that can be applied in a hierarchical
    and layered way to a target machine. Usually, it is further subdivided into `tasks/`,
    `files/`, `vars/`, and other layout-sensitive structures within each role:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles/`：这里列出了可以以分层和分层方式应用于目标机器的角色定义列表。通常，它进一步细分为`tasks/`、`files/`、`vars/`和每个角色内的其他布局敏感结构：'
- en: '`<role_name>/tasks/main.yml`: A YAML file that lists the main steps to execute
    as part of the role.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<role_name>/tasks/main.yml`：一个YAML文件，列出了作为角色一部分执行的主要步骤。'
- en: '`<role_name>/files/...`: Here you would add static files that would be copied
    to target a machine that do not require any pre-processing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<role_name>/files/...`：在这里，您将添加静态文件，这些文件将被复制到目标机器上，不需要任何预处理。'
- en: '`<role_name>/templates/...`: In this directory, you would add template files
    for role-related tasks. These usually contain templates that will be copied to
    the target machine with variable substitutions.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<role_name>/templates/...`：在这个目录中，您将为与角色相关的任务添加模板文件。这些通常包含将带有变量替换的模板复制到目标机器上。'
- en: '`<role_name>/vars/main.yml`: Just like the parent directory implies, this YAML
    file holds role-specific variable definitions.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<role_name>/vars/main.yml`：就像父目录暗示的那样，这个YAML文件保存了特定于角色的变量定义。'
- en: '`playbooks/`: In this directory, you would add all top-level ancillary playbooks
    that do not fit well in role definitions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbooks/`：在这个目录中，您将添加所有顶层的辅助playbooks，这些playbooks在角色定义中无法很好地适应。'
- en: Usage
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: Now that we have been introduced to what Ansible looks like and how it operates,
    it is time to do something practical with it. What we will do at this point is
    make an Ansible deployment configuration to apply some of the system tweaks we
    covered in the previous chapter and have Docker ready for us on the machine after
    running the playbook.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Ansible的外观和操作方式，是时候用它做一些实际的事情了。我们现在要做的是创建一个Ansible部署配置，应用我们在上一章中介绍的一些系统调整，并在运行playbook后让Docker在机器上为我们准备好。
- en: This example is relatively simple but it should show pretty well the ease of
    use and power of a decent configuration management tooling. Ansible is also a
    massive topic that a small section like this just can not cover in as much detail
    as I would like to but the documentation is relatively good and you can find it
    at [https://docs.ansible.com/ansible/latest/index.html](https://docs.ansible.com/ansible/latest/index.html).This
    example (and others) can be found at [https://github.com/sgnn7/deploying_with_docker/tree/master/chapter_8/ansible_deployment](https://github.com/sgnn7/deploying_with_docker/tree/master/chapter_8/ansible_deployment)
    if you want to skip the manual typing; however, it might be good practice to do
    it once to get the hang of the Ansible YAML file structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相对简单，但它应该很好地展示了一个体面的配置管理工具的易用性和强大性。Ansible也是一个庞大的主题，像这样的一个小节无法覆盖我想要的那么详细，但文档相对不错，你可以在[https://docs.ansible.com/ansible/latest/index.html](https://docs.ansible.com/ansible/latest/index.html)找到它。如果你想跳过手工输入，可以在[https://github.com/sgnn7/deploying_with_docker/tree/master/chapter_8/ansible_deployment](https://github.com/sgnn7/deploying_with_docker/tree/master/chapter_8/ansible_deployment)找到这个例子（和其他例子）；然而，这可能是一个很好的练习，做一次以熟悉Ansible的YAML文件结构。
- en: 'First, we will need to create our file structure for holding files. We will
    call our main role `swarm_node` and since our whole machine is just going to be
    a swarm node, we will name our top-level deployment playbook the same:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为保存文件创建我们的文件结构。我们将称我们的主要角色为`swarm_node`，由于我们整个机器只是一个swarm节点，我们将把我们的顶层部署playbook命名为相同的名称：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s add the following content to the top-level `swarm_node.yml`. This
    will be the main entry point for Ansible and it basically just defines target
    hosts and roles that we want to be run on them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将以下内容添加到顶层的`swarm_node.yml`。这将是Ansible的主入口点，它基本上只定义了目标主机和我们想要在它们上运行的角色：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: YAML files are whitespace structured so make sure that you do not omit any spacing
    when editing this file. In general, all nesting levels are two spaces farther
    than the parent, key/values are defined with colons, and lists are itemized with
    a `-` (minus) prefix. For more information, about the YAML structure go to  [https://en.wikipedia.org/wiki/YAML#Syntax](https://en.wikipedia.org/wiki/YAML#Syntax).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件是以空格结构化的，所以在编辑这个文件时要确保不要省略任何空格。一般来说，所有的嵌套级别都比父级多两个空格，键/值用冒号定义，列表用`-`（减号）前缀列出。有关YAML结构的更多信息，请访问[https://en.wikipedia.org/wiki/YAML#Syntax](https://en.wikipedia.org/wiki/YAML#Syntax)。
- en: 'What we are doing here should be mostly obvious:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的大部分都是显而易见的：
- en: '`hosts: all`: Run this on all the defined servers in the inventory file. Generally,
    this would be just a DNS name but since we will only have a single machine target,
    `all` should be fine.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主机：所有`：在清单文件中定义的所有服务器上运行此命令。通常，这只是一个DNS名称，但由于我们只有一个单一的机器目标，`all`应该没问题。'
- en: '`become: True`: Since we use SSH to run things on the target and the SSH user
    is usually not root, we need to tell Ansible that it needs to elevate permissions
    with `sudo` for the commands that we will run. If the user requires a password
    to use `sudo`, you can specify it when invoking the playbook with the `ansible-playbook
    -K` flag, but we will be using AWS instances later in the chapter which do not
    require one.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become: True`: 由于我们使用SSH在目标上运行命令，而SSH用户通常不是root，我们需要告诉Ansible需要使用`sudo`提升权限来运行命令。如果用户需要密码来使用`sudo`，可以在调用playbook时使用`ansible-playbook
    -K`标志指定密码，但在本章后面我们将使用不需要密码的AWS实例。'
- en: '`roles: swarm_mode`: This is a list of roles we want to apply to the targets
    which is for now just a single one called `swarm_node`. This name *must* match
    a folder name in `roles/`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles: swarm_mode`: 这是我们要应用于目标的角色列表，目前只有一个叫做`swarm_node`的角色。这个名称*必须*与`roles/`中的文件夹名称匹配。'
- en: 'Next in line for defining will be our system tweaking configuration files that
    we covered in the previous chapter for things like increases in file descriptor
    maximum, ulimits, and a couple of others. Add the following files and their respective
    content to the `roles/swarm_node/files/` folder:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要定义的是我们在上一章中涵盖的系统调整配置文件，用于增加文件描述符最大值、ulimits等。将以下文件及其相应内容添加到`roles/swarm_node/files/`文件夹中：
- en: '`conntrack.conf`:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conntrack.conf`:'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`file-descriptor-increase.conf`:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file-descriptor-increase.conf`:'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`socket-buffers.conf`:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket-buffers.conf`:'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ulimit-open-files-increase.conf`:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ulimit-open-files-increase.conf`:'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With those added, our tree should look a bit more like this now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些文件后，我们的目录结构应该看起来更像这样：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With most of the files in place, we can now finally move onto the main configuration
    file--`roles/swarm_mode/tasks/main.yml`. In it, we will lay out our configuration
    steps one by one using Ansible''s modules and DSL to:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分文件已经就位，现在我们终于可以转向主配置文件--`roles/swarm_mode/tasks/main.yml`。在其中，我们将使用Ansible的模块和DSL逐步列出我们的配置步骤：
- en: '`apt-get dist-upgrade` the image for security'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get dist-upgrade` 更新镜像以提高安全性'
- en: Apply various improvements to machine configuration files in order to perform
    better as a Docker host
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对机器配置文件进行各种改进，以便更好地作为Docker主机运行
- en: Install Docker
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'To simplify understanding the following Ansible configuration code, it would
    be good to also keep this structure in mind since it underpins each discrete step
    we will use and is pretty easy to understand after you see it a couple of times:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化理解以下的Ansible配置代码，也可以记住这个结构，因为它是我们将使用的每个离散步骤的基础，并且在看到几次后很容易理解：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find all module documentation we use in the playbook below at the main
    Ansible website ([https://docs.ansible.com/ansible/latest/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/list_of_all_modules.html)).
    We will avoid getting too deep in module documentation here due to the sheer volume
    of information that will generally be a distraction to the purpose of this section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在主Ansible网站上找到我们在playbook中使用的所有模块文档([https://docs.ansible.com/ansible/latest/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/list_of_all_modules.html))。由于信息量巨大，我们将避免在此处深入研究模块文档，因为这通常会分散本节的目的。
- en: 'You can also find module-specific documentation that we used here too:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在这里找到我们使用的特定模块的文档：
- en: '- [https://docs.ansible.com/ansible/latest/apt_module.html](https://docs.ansible.com/ansible/latest/apt_module.html)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/apt_module.html](https://docs.ansible.com/ansible/latest/apt_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/copy_module.html](https://docs.ansible.com/ansible/latest/copy_module.html)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/copy_module.html](https://docs.ansible.com/ansible/latest/copy_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/lineinfile_module.html](https://docs.ansible.com/ansible/latest/lineinfile_module.html)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/lineinfile_module.html](https://docs.ansible.com/ansible/latest/lineinfile_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/command_module.html](https://docs.ansible.com/ansible/latest/command_module.html)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/command_module.html](https://docs.ansible.com/ansible/latest/command_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/apt_key_module.html](https://docs.ansible.com/ansible/latest/apt_key_module.html)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/apt_key_module.html](https://docs.ansible.com/ansible/latest/apt_key_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/apt_repository_module.html](https://docs.ansible.com/ansible/latest/apt_repository_module.html)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/apt_repository_module.html](https://docs.ansible.com/ansible/latest/apt_repository_module.html)'
- en: 'Let us see what that main installation playbook (`roles/swarm_mode/tasks/main.yml`)
    should look like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看主安装playbook（`roles/swarm_mode/tasks/main.yml`）应该是什么样子的：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: WARNING! This configuration has *no* hardening for the image to be comfortably
    placed on the internet live so use care and add whatever securing steps and tooling
    you require into this playbook before doing your real deployment. At the absolute
    least I would suggest installing the `fail2ban` package but you may have alternative
    strategies (e.g. seccomp, grsecurity, AppArmor, etc).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！这个配置对于放在互联网上运行没有进行*任何*加固，所以在进行真正的部署之前，请小心并在这个playbook中添加任何您需要的安全步骤和工具。至少我建议安装`fail2ban`软件包，但您可能有其他策略（例如seccomp、grsecurity、AppArmor等）。
- en: In this file, we sequentially ordered the steps one by one to configure the
    machine from base to a system fully capable of running Docker containers by using
    some of the core Ansible modules and the configuration files we created earlier.
    One thing that might not be very obvious is our use of the `{{ ansible_distribution
    | lower }}` type variables but in those, we are using Ansible facts ([https://docs.ansible.com/ansible/latest/playbooks_variables.html](https://docs.ansible.com/ansible/latest/playbooks_variables.html))
    gathered about the system we are running on and passing them though a Ninja2 `lower()`
    filter to ensure that the variables are lowercase. By doing this for the repository
    endpoint, we can use the same configuration without problems on almost any deb-based
    server target without much trouble as the variables will be substituted to the
    appropriate values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们按顺序一步一步地配置了机器，从基本配置到完全能够运行Docker容器的系统，使用了一些核心的Ansible模块和我们之前创建的配置文件。可能不太明显的一点是我们使用了`{{
    ansible_distribution | lower }}`类型的变量，但在这些变量中，我们使用了有关我们正在运行的系统的Ansible事实（[https://docs.ansible.com/ansible/latest/playbooks_variables.html](https://docs.ansible.com/ansible/latest/playbooks_variables.html)），并通过Ninja2的`lower()`过滤器传递它们，以确保变量是小写的。通过对存储库端点执行此操作，我们可以在几乎任何基于deb的服务器目标上使用相同的配置而不会遇到太多麻烦，因为变量将被替换为适当的值。
- en: At this point, the only thing we would need to do in order to apply this configuration
    to a machine is to add our server IP/DNS to `hosts` file and run the playbook
    with `ansible-playbook <options> swarm_node.yml`. But since we want to run this
    on an Amazon infrastructure, we will stop here and see how we can take these configuration
    steps and from them create an **Amazon Machine Image** (**AMI**) on which we can
    start any number of **Elastic Compute Cloud** (**EC2**) instances that are identical
    and have already been fully configured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要做的唯一一件事就是将我们的服务器IP/DNS添加到`hosts`文件中，并使用`ansible-playbook <options>
    swarm_node.yml`运行playbook。但由于我们想在亚马逊基础设施上运行这个，我们将在这里停下来，看看我们如何可以采取这些配置步骤，并从中创建一个**亚马逊机器映像**（**AMI**），在这个映像上我们可以启动任意数量的**弹性计算云**（**EC2**）实例，这些实例是相同的，并且已经完全配置好了。
- en: Amazon Web Services setup
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊网络服务设置
- en: To continue onto our Amazon Machine Image (AMI) building section, we cannot
    go any further without having a working AWS account and an associated API key
    so we will do that first before continuing further. To avoid ambiguity, be aware
    that almost all AWS services cost money to use and your use of the API may incur
    charges for you even for things that you might not readily expect (that is, bandwidth
    usage, AMI snapshot storage, and on ) so use it accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续进行我们的Amazon Machine Image (AMI)构建部分，我们必须先拥有一个可用的AWS账户和一个关联的API密钥，然后才能继续。为避免歧义，请注意几乎所有AWS服务都需要付费使用，您使用API可能会为您产生费用，即使是您可能没有预期的事情（如带宽使用、AMI快照存储等），所以请谨慎使用。
- en: AWS is a massively complex piece of machinery, exponentially more than Ansible,
    and covering everything that you might need to know about it is impossible to
    do within the scope of this book. But we will try here to provide you with enough
    relevant instructions for you to have a place to start from. If you decide you
    want to learn more about AWS, their documentation is generally pretty great and
    you can find it at [https://aws.amazon.com/documentation/](https://aws.amazon.com/documentation/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: AWS是一个非常复杂的机器，比Ansible复杂得多，覆盖关于它的所有内容是不可能在本书的范围内完成的。但我们会在这里尽量为您提供足够相关的指导，让您有一个起点。如果您决定想了解更多关于AWS的信息，他们的文档通常非常好，您可以在[https://aws.amazon.com/documentation/](https://aws.amazon.com/documentation/)找到。
- en: Creating an account
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个账户
- en: 'While the process is pretty straightforward, it has changed a couple of times
    in very significant ways, so detailing the full process here with no way to update
    it would would end up being a disservice to you so to create the account, I will
    guide you to the link that has the most up-to-date information on how to do it,
    which is [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/).
    In general, the start of the process is at [https://aws.amazon.com/](https://aws.amazon.com/)
    and you can begin it by clicking on the yellow Sign Up or Create an AWS Account
    button on the top right of the screen and following the instructions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程非常简单，但它已经在很多重要的方面发生了一些变化，因此在这里详细介绍整个过程并无法更新，这对您来说是一种伤害，所以为了创建账户，我将引导您到具有最新信息的链接，该链接是[https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/)。一般来说，这个过程的开始是在[https://aws.amazon.com/](https://aws.amazon.com/)，您可以通过单击屏幕右上角的黄色注册或创建AWS账户按钮并按照说明进行操作：
- en: '![](assets/ee360b0d-e6ef-4cf5-a704-a3c19f28462d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee360b0d-e6ef-4cf5-a704-a3c19f28462d.png)'
- en: Getting API keys
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: 'With the AWS account created, we now need to get our API keys so that we can
    access and use our resources through the various tools we want to use:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了AWS账户后，我们现在需要获取API密钥，以便通过我们想要使用的各种工具访问和使用资源：
- en: 'Sign in to your console by going to `https://<account_id or alias>.signin.aws.amazon.com/console`.
    Note that you may need to sign in as the root account initially to do this (small
    blue link below the Sign In button, as shown in the following screenshot) if you
    did not create a user when you registered the account:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到`https://<account_id or alias>.signin.aws.amazon.com/console`登录您的控制台。请注意，您可能需要最初以根账户身份登录（如下截图所示，在登录按钮下方有一个小蓝色链接），如果您注册账户时没有创建用户：
- en: '![](assets/96e3d45c-e762-42df-8171-8ab7a21c4019.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96e3d45c-e762-42df-8171-8ab7a21c4019.png)'
- en: Navigate to the IAM page at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
    and click on the Users link on the left-hand side of the screen.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到IAM页面[https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)，并单击屏幕左侧的用户链接。
- en: Click on Add user to start the user creation process.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“添加用户”以开始用户创建过程。
- en: '![](assets/3e2af10f-fe45-4a06-9abe-37a6f98ca761.png)CAUTION! Make sure that
    the Programmatic access checkbox is ticked, or else your AWS API keys will not
    work for our examples.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3e2af10f-fe45-4a06-9abe-37a6f98ca761.png)注意！确保选中“程序化访问”复选框，否则您的AWS
    API密钥将无法用于我们的示例。'
- en: 'For the permissions, we will give this user full administrator access. For
    production services, you will want to limit this to only the needed level of access:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于权限，我们将为该用户提供完整的管理员访问权限。对于生产服务，您将希望将其限制为所需的访问级别：
- en: '![](assets/b06d52c2-375d-47c6-b148-efebf348b7e0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b06d52c2-375d-47c6-b148-efebf348b7e0.png)'
- en: 'Follow the rest of the wizard and make a record of the key ID and key secret,
    as these will be your API credentials for AWS:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照向导的其余部分，并记录密钥ID和密钥秘钥，因为这些将是您的AWS API凭据：
- en: '![](assets/11fc7117-065e-4978-afc3-a37968ccbbcc.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11fc7117-065e-4978-afc3-a37968ccbbcc.png)'
- en: Using the API keys
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API密钥
- en: 'To use the API keys in the easiest way, you can export variables in your shell
    that will get picked up by the tooling; however, you will need to do this on every
    Terminal where you are working with AWS APIs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以最简单的方式使用API密钥，您可以在shell中导出变量，这些变量将被工具接收；但是，您需要在使用AWS API的每个终端上执行此操作：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, if you have the `awscli` tool installed (`sudo apt-get install
    awscli`), you can just run `aws configure`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您已安装`awscli`工具（`sudo apt-get install awscli`），您可以直接运行`aws configure`：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are many other ways to set your credentials as well through things like
    profiles but it really all depends on your expected usage case. For more information
    on these options,  you can refer to the official documentation at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他设置凭据的方法，例如通过配置文件，但这确实取决于您的预期使用情况。有关这些选项的更多信息，您可以参考官方文档[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)。
- en: So with the key available and configured for CLI use, we can now proceed onto
    building custom AMI images with Packer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了可用并配置为CLI使用的密钥，我们现在可以继续使用Packer构建自定义AMI镜像。
- en: HashiCorp Packer
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashiCorp Packer
- en: As we previously implied, our CM scripts are really not that optimal if we have
    to run them every time on a new machine that we add to the cluster or the cloud
    infrastructure in general. While we can do that, we really shouldn't, since in
    a perfect world the cluster nodes should be a flexible group that can spawn and
    kill instances depending on the usage with minimal user intervention so requiring
    a manual setup of each new machine is simply untenable even at the smallest cluster
    scales. With AMI image creation we can pre-bake a templated base system image with
    Ansible a single time, when the image is being made. By doing that, we can launch
    any new machine with this same image and our interaction with a running system
    would be kept at a minimum since everything would ideally be already configured.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所暗示的，如果我们必须在每次将新机器添加到集群或云基础架构中时运行CM脚本，那么我们的CM脚本实际上并不那么理想。虽然我们可以这样做，但我们真的不应该这样做，因为在理想的情况下，集群节点应该是一个灵活的群组，可以根据使用情况生成和销毁实例，最大程度地减少用户干预，因此要求手动设置每台新机器甚至在最小的集群规模下都是不可行的。通过AMI镜像创建，我们可以在制作镜像时预先制作一个带有Ansible的模板基本系统镜像。通过这样做，我们可以使用相同的镜像启动任何新机器，并且我们与运行中的系统的交互将被保持在最低限度，因为理想情况下一切都应该已经配置好。
- en: To make these machine images, HashiCorp Packer ([https://www.packer.io/](https://www.packer.io/))
    allows us to do exactly that by applying a provisioning run of our CM tool of
    choice (Ansible) and outputting a ready-to-use image for any of the big cloud
    providers. By doing this, you could have the desired state of the cluster nodes
    (or any other server configuration) permanently enshrined in an image, and for
    any node addition needs for the cluster all you would need to do is spawn more
    VM instances based on the same Packer image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些机器映像，HashiCorp Packer ([https://www.packer.io/](https://www.packer.io/))
    允许我们通过应用我们选择的CM工具（Ansible）的配置运行，并为任何大型云提供商输出一个可供使用的映像。通过这样做，您可以将集群节点（或任何其他服务器配置）的期望状态永久地记录在映像中，对于集群的任何节点添加需求，您只需要基于相同的Packer映像生成更多的VM实例。
- en: Installation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Due to the fact that Packer is written in Go programming language, to install
    Packer, you only need to download the binary from their website found at [https://www.packer.io/downloads.html](https://www.packer.io/downloads.html).
    You can usually do something like the following for a quick installation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Packer是用Go编程语言编写的，要安装Packer，您只需要从他们的网站[https://www.packer.io/downloads.html](https://www.packer.io/downloads.html)下载二进制文件。通常可以通过以下方式快速安装：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: CAUTION! Packer binaries only provide TLS authentication for their runner without
    any form of signature checking, so the assurance that the program was published
    by HashiCorp itself is orders of magnitude lower than a GPG-signed `apt` repository
    that Docker uses; so, exercise extra care when getting it this way or build it
    from source ([https://github.com/hashicorp/packer](https://github.com/hashicorp/packer)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！Packer二进制文件仅为其运行程序提供TLS身份验证，而没有任何形式的签名检查，因此，与Docker使用的GPG签名的`apt`存储库相比，程序由HashiCorp自己发布的保证要低得多；因此，在以这种方式获取它或从源代码构建时，请格外小心（[https://github.com/hashicorp/packer](https://github.com/hashicorp/packer)）。
- en: Usage
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: 'Using Packer is actually relatively easy as all you need in most cases is the
    Ansible setup code and a relatively small `packer.json` file. Add this content
    to `packer.json` in our Ansible deployment configuration from the earlier section:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用Packer实际上相当容易，因为您只需要Ansible设置代码和一个相对较小的`packer.json`文件。将此内容添加到我们在早期部分的Ansible部署配置中的`packer.json`中：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If it is not obvious, what we have here in this configuration file is the `provisioners`
    and `builders` sections, which in general correspond to Packer inputs and outputs,
    respectively. In our preceding example, we first install Ansible through the `shell`
    provisioner since the next step requires it, and then run the `main.yml` playbook
    from our current directory with the `ansible-local` provisioner on a base AMI.
    After applying all the changes, we save the result as a new **Elastic Block Store**
    (**EBS**) optimized AMI image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不明显，我们在此配置文件中有`provisioners`和`builders`部分，它们通常对应于Packer的输入和输出。在我们之前的示例中，我们首先通过`shell`
    provisioner安装Ansible，因为下一步需要它，然后使用`ansible-local` provisioner在基本AMI上运行我们当前目录中的`main.yml`
    playbook。应用所有更改后，我们将结果保存为新的**弹性块存储**（**EBS**）优化的AMI映像。
- en: AWS **Elastic Block Store** (**EBS**) is a service that provides block device
    storage to EC2 instances (these instances are basically just VMs). To the machine,
    these look like regular hard disks and can be formatted to whatever filesystem
    you want and are used to persist data in a permanent manner in the Amazon Cloud.
    They have configurable size and levels of performance; however, as you might expect,
    the price goes up as those two settings increase. The only other thing to keep
    in mind is that while you can move the drive around EC2 instances just like you
    would move a physical disk, you cannot move an EBS volume across availability
    zones. A simple workaround is to copy the data over."AMI image" phrase expands
    into "Amazon Machine Image image", which is a really quirky way to phrase things,
    but just like the sister phrase "PIN number", it flows much better when used that
    way and will be intentionally referred to in that way in this section. If you're
    curious about this particularity of the English language, you should peruse the
    Wiki page for RAS syndrome at [https://en.wikipedia.org/wiki/RAS_syndrome](https://en.wikipedia.org/wiki/RAS_syndrome).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **弹性块存储**（**EBS**）是一项为EC2实例提供块设备存储的服务（这些实例基本上只是虚拟机）。对于机器来说，这些看起来像是常规的硬盘，可以格式化为任何你想要的文件系统，并用于在亚马逊云中以永久方式持久化数据。它们具有可配置的大小和性能级别；然而，正如你可能期望的那样，随着这两个设置的增加，价格也会上涨。唯一需要记住的另一件事是，虽然你可以像移动物理磁盘一样在EC2实例之间移动驱动器，但你不能跨可用性区域移动EBS卷。一个简单的解决方法是复制数据。"AMI镜像"短语扩展为"Amazon
    Machine Image image"，这是一个非常古怪的表达方式，但就像姐妹短语"PIN number"一样，在本节中使用这种方式会更流畅。如果你对英语语言的这种特殊性感到好奇，你可以查阅RAS综合症的维基页面[https://en.wikipedia.org/wiki/RAS_syndrome](https://en.wikipedia.org/wiki/RAS_syndrome)。
- en: 'For the builders section, it will be helpful to explain some of the parameters
    in more detail as they may not be obvious from reading the JSON file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建器部分，更详细地解释一些参数将会很有帮助，因为它们可能并不明显，无法从JSON文件中直接看出来：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can find more information on this particular builder type and its available
    options at [https://www.packer.io/docs/builders/amazon-ebs.html](https://www.packer.io/docs/builders/amazon-ebs.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.packer.io/docs/builders/amazon-ebs.html](https://www.packer.io/docs/builders/amazon-ebs.html)找到有关此特定构建器类型及其可用选项的更多信息。
- en: Choosing the right AMI base image
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的AMI基础镜像
- en: Unlike selecting the base Docker image to extend that we covered in earlier
    chapters, choosing the correct AMI to use Packer on is sadly not a simple task.
    Some distributions are regularly updated, so the IDs change. The IDs are also
    unique per AWS region and you may want hardware or paravirtualization (`HVM` vs
    `PV`). On top of all this, you also have to chose the right one for your storage
    needs (`instance-store`, `ebs`, and `ebs-ssd` at the time of writing this book),
    creating an absolutely un-intuitive matrix of options.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在早期章节中介绍的选择要扩展的基础Docker镜像不同，选择正确的AMI来在Packer上使用是一个不简单的任务。一些发行版经常更新，因此ID会发生变化。ID也是每个AWS区域独一无二的，您可能需要硬件或半虚拟化（`HVM`
    vs `PV`）。除此之外，您还需要根据您的存储需求选择正确的存储类型（在撰写本书时为`instance-store`、`ebs`和`ebs-ssd`），这创建了一个绝对不直观的选项矩阵。
- en: 'If you have not worked with Amazon **Elastic Compute Cloud** (**EC2**) and
    EBS, the storage options are a bit confusing to newcomers but they mean the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用过Amazon **弹性计算云**（**EC2**）和EBS，存储选项对新手来说可能有点令人困惑，但它们的含义如下：
- en: '`instance-store`: This type of storage is local to the EC2 VM that is running,
    has space varied depending on the VM type (usually very little though), and gets
    completely discarded anytime the VM is terminated (a stopped or rebooted VM retains
    its state though). Instance store is great for nodes that do not need to keep
    any state but should not be used for machines that you want to have data retained
    on; however, you can mount a separate EBS drive to an instance--store VM independently
    if you want to have persistent storage and also utilize the stateless storage.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance-store`：这种存储类型是本地的EC2 VM，空间取决于VM类型（尽管通常很少），并且在VM终止时完全丢弃（停止或重新启动的VM保留其状态）。实例存储非常适合不需要保留任何状态的节点，但不应该用于希望保留数据的机器；但是，如果您想要持久存储并且利用无状态存储，您可以独立地将单独的EBS驱动器挂载到实例存储VM上。'
- en: '`ebs`: This storage type creates and associates an EBS volume backed by older
    magnetic spinning hard drives (relatively slow vs solid-state drives) anytime
    an EC2 instance is started with this specific image, so the data is always kept
    around. This option is good if you want to have your data persisted or the `instance-store`
    volumes are not big enough. As of today though, this option is being actively
    deprecated, so it is likely that it will disappear in the future.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ebs`：每当使用特定镜像启动EC2实例时，此存储类型将创建并关联由旧的磁性旋转硬盘支持的EBS卷，因此数据始终保留。如果您想要持久保存数据或`instance-store`卷不够大，这个选项很好。不过，截至今天，这个选项正在被积极弃用，因此很可能在未来会消失。'
- en: '`ebs-ssd`: This option is pretty much the same as the preceding one, but using
    **Solid State Devices** (SSD) that are much faster but much more expensive per
    gigabyte of allocation as the backing store.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ebs-ssd`：这个选项基本上与前面的选项相同，但使用**固态设备**（SSD），速度更快，但每GB分配的成本更高。'
- en: 'Another thing that we need to choose is the virtualization type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择的另一件事是虚拟化类型：
- en: 'Paravirtualization / `pv`: This type of virtualization is older and uses software
    to chain load your image, so it was capable to run on a much more diverse hardware.
    While it was faster long time ago, today it is generally slower than the hardware
    virtualization.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半虚拟化/`pv`：这种虚拟化比较老，使用软件来链式加载您的镜像，因此能够在更多样化的硬件上运行。虽然很久以前它比较快，但今天通常比硬件虚拟化慢。
- en: 'Hardware virtualization / `hvm`: This type of virtualization uses CPU-level
    instructions to run your image in a completely isolated environment akin to running
    the image directly on bare-metal hardware. While it depends on specific Intel
    VT CPU technology implementations, it is generally much better performant than
    `pv` virtualization, so in most cases, you should probably use it over other options,
    especially if you are not sure which one to choose.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件虚拟化/`hvm`：这种虚拟化使用CPU级指令在完全隔离的环境中运行您的镜像，类似于直接在裸机硬件上运行镜像。虽然它取决于特定的英特尔VT CPU技术实现，但通常比`pv`虚拟化性能更好，因此在大多数情况下，您应该优先使用它而不是其他选项，特别是如果您不确定选择哪个选项。
- en: 'With our new knowledge of the available options, we can now figure out what
    image we will use as the base. For our designated OS version (Ubuntu LTS), you
    can use the helper page at [https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)
    to find the right one:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们对可用选项的新知识，我们现在可以确定我们将使用哪个镜像作为基础。对于我们指定的操作系统版本（Ubuntu LTS），您可以使用辅助页面在[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)找到合适的镜像：
- en: '![](assets/c078e660-0b39-4cfc-a458-246a2aed150e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c078e660-0b39-4cfc-a458-246a2aed150e.png)'
- en: 'For our test builds, we will be using `us-west-1` region, Ubuntu 16.04 LTS
    version (`xenial`), 64-bit architecture (`amd64`), `hvm` virtualization, and `ebs-ssd` storage
    so we can use the filters at the bottom of the page to narrow things down:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试构建，我们将使用`us-west-1`地区，Ubuntu 16.04 LTS版本（`xenial`），64位架构（`amd64`），`hvm`虚拟化和`ebs-ssd`存储，以便我们可以使用页面底部的过滤器来缩小范围：
- en: '![](assets/a4fe9542-6e35-4fd1-a9f5-5aa1cfc6dd6d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a4fe9542-6e35-4fd1-a9f5-5aa1cfc6dd6d.png)'
- en: As you can see, the list collapses to one choice and in our `packer.json` we
    will use `ami-1c1d217c`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，列表收缩到一个选择，在我们的`packer.json`中，我们将使用`ami-1c1d217c`。
- en: Since this list is updated with AMIs that have newer security patches, it is
    very likely that by the time you are reading this section the AMI ID will be something
    else on your end. Because of that, do not be alarmed if you see discrepancies
    between values we have found here and what you have available to you while reading
    of this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此列表更新了具有更新的安全补丁的AMI，很可能在您阅读本节时，AMI ID在您的端上将是其他值。因此，如果您看到我们在这里找到的值与您在阅读本章时可用的值之间存在差异，请不要感到惊讶。
- en: Building the AMI
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建AMI
- en: 'WARNING! Running this Packer build will for sure incur some (albeit barely
    a couple of US dollars at the time of writing this book) charges on your AWS account
    due to usage of non-free instance type, snapshot use, and AMI use, some possibly
    recurring. Refer to the pricing documentation of AWS for those services to estimate
    the amount that you will be charged. As an additional note, it is also good practice
    to clean up everything either from the console or CLI after you finish working
    with AWS objects that will not be kept around since it will ensure that you do
    not get additional charges after working with this code.With the `packer.json` in
    place, we can now do a build of our image. We will first install the pre-requisites
    (`python-boto` and `awscli`), then check the access, and finally build our AMI:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！运行此Packer构建肯定会在您的AWS帐户上产生一些（尽管在撰写本书时可能只有几美元）费用，因为使用了非免费实例类型、快照使用和AMI使用，有可能是一些重复的费用。请参考AWS的定价文档来估算您将被收取的金额。另外，清理掉您在AWS对象上完成工作后不会保留的一切，也是一个良好的做法，因为这将确保您在使用此代码后不会产生额外的费用。有了`packer.json`，我们现在可以构建我们的镜像。我们将首先安装先决条件（`python-boto`和`awscli`），然后检查访问权限，最后构建我们的AMI：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Success! With this new image ID that you can see at the end of the output (`ami-a694a8c6`),
    we can now launch instances in EC2 with this AMI and they will have all the tweaks
    we have applied as well as have Docker pre-installed!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！通过这个新的镜像ID（您可以在输出的末尾看到`ami-a694a8c6`），我们现在可以在EC2中使用这个AMI启动实例，并且它们将具有我们应用的所有调整以及预安装的Docker！
- en: Deployments to AWS
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到AWS
- en: 'With just the bare images and no virtual machines to run them on, our previous
    Packer work has not gotten us yet fully into an automated working state. To really
    get there, we will now need to tie everything together with more Ansible glue
    to complete the deployment. The encapsulation hierarchy of the different stages
    should conceptually look something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只有裸露的镜像，没有虚拟机来运行它们，我们之前的Packer工作还没有完全实现自动化工作状态。为了真正实现这一点，我们现在需要用更多的Ansible粘合剂将所有东西联系在一起，以完成部署。不同阶段的封装层次应该在概念上看起来像这样：
- en: '![](assets/4620e596-f554-42e0-a087-4078996b65ef.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4620e596-f554-42e0-a087-4078996b65ef.png)'
- en: 'As you can see from the diagram, we will take a layered approach to deployments:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中可以看出，我们将采取分层的方法进行部署：
- en: In the innermost level, we have the Ansible scripts to take a bare machine,
    VM, or an AMI to the configuration state we want it to be in.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最内层，我们有Ansible脚本，将裸机、虚拟机或AMI转换为我们想要的配置状态。
- en: Packer encapsulates that process and produces static AMI images that are further
    usable on Amazon EC2 cloud offerings.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer封装了该过程，并生成了静态AMI镜像，这些镜像可以进一步在Amazon EC2云服务上使用。
- en: Ansible then finally encapsulates everything mentioned previously by deploying
    machines with those static, Packer-created images.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，Ansible最终通过部署使用那些静态的、由Packer创建的镜像来封装之前提到的一切。
- en: The road to automated infrastructure deployment
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化基础设施部署的道路
- en: Now that we know what we want, how can we do it? Luckily for us, as hinted in
    the previous list, Ansible can do that part for us; we just need to write a couple
    of configuration files. But AWS is very complex here so it will not be as simple
    as just starting an instance since we want an isolated VPC environment. However,
    since we will only manage one server, we don't really care much for inter-VPC
    networking, so that will make things a bit easier.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想要什么，我们该如何做呢？幸运的是，如前面的列表所示，Ansible可以为我们完成这部分工作；我们只需要编写一些配置文件。但是，由于AWS在这里非常复杂，所以它不会像只启动一个实例那样简单，因为我们想要一个隔离的VPC环境。但是，由于我们只管理一个服务器，我们对VPC之间的网络连接并不是很在意，所以这会让事情变得简单一些。
- en: 'We first need to consider all the steps that will be required. Some of these
    will be very foreign to most of you as AWS is pretty complex and most developers
    do not usually work on networking, but they are the minimum necessary steps to
    have an isolated VPC without clobbering the default settings of your account:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑所有所需的步骤。其中一些对大多数人来说可能非常陌生，因为AWS相当复杂，大多数开发人员通常不会在网络上工作，但这些是必需的步骤，以便在不破坏帐户的默认设置的情况下拥有一个隔离的VPC：
- en: Set up the VPC for a specific virtual network.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定虚拟网络设置VPC。
- en: Create and tie a subnet to it. Without this, our machines will not be able to
    use the network on it.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并将子网绑定到它。如果没有这个，我们的机器将无法在上面使用网络。
- en: Set up a virtual Internet gateway and attach it to the VPC for unresolvable
    addresses with a routing table. If we do not do this, the machines will not be
    able to use the Internet.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置虚拟互联网网关并将其附加到VPC，以便使用路由表解析地址。如果我们不这样做，机器将无法使用互联网。
- en: Set up a security group (firewall) whitelist of ports that we want to be able
    to access our server (SSH and HTTP ports). By default all ports are blocked so
    this makes sure that the launched instances are reachable.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个安全组（防火墙）白名单，列出我们希望能够访问我们服务器的端口（SSH和HTTP端口）。默认情况下，所有端口都被阻止，因此这可以确保启动的实例是可访问的。
- en: Finally, provision the VM instance using the configured VPC for networking.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用配置的VPC进行网络设置来提供VM实例。
- en: To tear down everything, we will need to do the same thing, but just in reverse.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要拆除所有内容，我们需要做同样的事情，只是相反。
- en: 'First, we need some variables that will be shared across both deploy and teardown playbooks.
    Create a `group_vars/all` file in the same directory as the big Ansible example
    that we have been working on in this chapter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些变量，这些变量将在部署和拆除playbooks之间共享。在与本章中我们一直在使用的大型Ansible示例相同的目录中创建一个`group_vars/all`文件：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can write our `deploy.yml` in the same directory that `packer.json`
    is in, using some of those variables:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在与`packer.json`相同的目录中编写我们的`deploy.yml`，并使用其中一些变量：
- en: 'The difficulties of this deployment is starting to scale up significantly from
    our previous examples and there is no good way to cover all the information that
    is spread between dozens of AWS, networking, and Ansible topics to describe it
    in a concise way, but here are some links to the modules we will use that, if
    possible, you should read before proceeding:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署的困难程度从我们之前的示例中显著增加，并且没有很好的方法来涵盖分散在数十个AWS、网络和Ansible主题之间的所有信息，以简洁的方式描述它，但是这里有一些我们将使用的模块的链接，如果可能的话，您应该在继续之前阅读：
- en: - [https://docs.ansible.com/ansible/latest/ec2_vpc_net_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_net_module.html)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_vpc_net_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_net_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/set_fact_module.html](https://docs.ansible.com/ansible/latest/set_fact_module.html)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/set_fact_module.html](https://docs.ansible.com/ansible/latest/set_fact_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/ec2_vpc_subnet_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_subnet_module.html)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_vpc_subnet_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_subnet_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/ec2_vpc_igw_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_igw_module.html)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_vpc_igw_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_igw_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/ec2_vpc_route_table_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_route_table_module.html)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_vpc_route_table_module.html](https://docs.ansible.com/ansible/latest/ec2_vpc_route_table_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/ec2_group_module.html](https://docs.ansible.com/ansible/latest/ec2_group_module.html)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_group_module.html](https://docs.ansible.com/ansible/latest/ec2_group_module.html)'
- en: - [https://docs.ansible.com/ansible/latest/ec2_module.html](https://docs.ansible.com/ansible/latest/ec2_module.html)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '- [https://docs.ansible.com/ansible/latest/ec2_module.html](https://docs.ansible.com/ansible/latest/ec2_module.html)'
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we are doing here closely matches our earlier plan but now we have concrete
    deployment code to match it up against:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的与我们之前的计划非常相似，但现在我们有具体的部署代码与之匹配：
- en: We set up the VPC with the `ec2_vpc_net` module.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ec2_vpc_net`模块设置VPC。
- en: We create our subnet and associate it to the VPC with the `ec2_vpc_subnet` module.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ec2_vpc_subnet`模块创建子网并将其关联到VPC。
- en: The Internet virtual gateway for our cloud is created with `ec2_vpc_igw`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的云创建Internet虚拟网关使用`ec2_vpc_igw`。
- en: Internet gateway is then made to resolve any addresses that are not within the
    same network.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建Internet网关以解析不在同一网络中的任何地址。
- en: '`ec2_group` module is used to enable ingress and egress networking but only
    port `22` (SSH) and port `80` (HTTP) are allowed in.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ec2_group`模块启用入站和出站网络，但只允许端口`22`（SSH）和端口`80`（HTTP）。
- en: Finally, our EC2 instance is created within the newly configured VPC with the `ec2`
    module.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的EC2实例是在新配置的VPC中使用`ec2`模块创建的。
- en: 'As we mentioned earlier, the tear-down should be very similar but in reverse
    and contain a lot more `state: absent` arguments. Let''s put the following in
    `destroy.yml` in the same folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们之前提到的，拆除应该非常类似，但是相反，并包含更多的`state: absent`参数。让我们把以下内容放在同一个文件夹中的`destroy.yml`中：'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the deploy playbook was readable, then this playbook should be generally
    easy to understand and as we mentioned, it just runs the same steps in reverse,
    removing any infrastructure pieces we already created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部署playbook可读，则该playbook应该很容易理解，正如我们所提到的，它只是以相反的方式运行相同的步骤，删除我们已经创建的任何基础设施部分。
- en: Running the deployment and tear-down playbooks
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行部署和拆除playbooks
- en: 'If you remember, earlier in our `group_vars` definition, we had a key variable
    (`ssh_key_name: swarm_key`) that at this point becomes relatively important as
    without a working key we can neither deploy nor start our VM, so let''s do that
    now. We will use `awscli` and `jq`--a JSON parsing tool that will reduce the amount
    of work we do, but it is possible to do without it as well through the GUI console:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您还记得，在我们的`group_vars`定义中，我们有一个关键变量（`ssh_key_name: swarm_key`），在这一点上变得相对重要，因为没有工作密钥，我们既不能部署也不能启动我们的VM，所以现在让我们这样做。我们将使用`awscli`和`jq`--一个JSON解析工具，它将减少我们的工作量，但也可以通过GUI控制台完成。'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the key in place, we can finally run our deploy script:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥放置后，我们终于可以运行我们的部署脚本：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you see errors similar to `"No handler was ready to authenticate. 1 handlers
    were checked. ['HmacAuthV4Handler'] Check your credentials"`, ensure that you
    have your AWS credentials set properly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似于`"没有处理程序准备好进行身份验证。已检查1个处理程序。['HmacAuthV4Handler']检查您的凭据"`的错误，请确保您已正确设置AWS凭据。
- en: 'Looks like everything is working! At this point, we could literally deploy
    our previously built 3-tier application if we wanted to. As we are done with our
    example and since we have our mini PaaS working, we can go back and clean up things
    by running the `destroy.yml` playbook:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都在运行！在这一点上，如果我们愿意，我们可以部署我们之前构建的三层应用程序。由于我们已经完成了我们的示例，并且我们的迷你PaaS正在运行，我们可以返回并通过运行`destroy.yml`
    playbook来清理事务：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And with that, we have automated deployments and teardowns of our infrastructure
    with single commands. While the example is pretty limited in scope, it should
    give you some ideas on how to expand beyond that with auto-scaling groups, orchestration
    management AMIs, registry deployment, and data persistence that would turn this
    into a full-fledged PaaS.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以使用单个命令自动部署和拆除我们的基础架构。虽然这个例子的范围相当有限，但它应该能给你一些关于如何通过自动扩展组、编排管理AMI、注册表部署和数据持久化来扩展的想法。
- en: Continuous integration/Continuous delivery
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成/持续交付
- en: As you make more services, you will notice that manual deployments of changes
    from source control and builds are taking up more time due to the need to figure
    out which image dependencies belong where, which image actually needs rebuilding
    (if you run a mono-repo), if the service changed at all, and many other ancillary
    issues. In order to simplify and streamline our deployment process, we will need
    to find a way to make this whole system fully automated so that the only thing
    needed to deploy a new version of services is a commit of a change to a branch
    of your code repository.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您创建更多的服务，您会注意到来自源代码控制和构建的手动部署需要更多的时间，因为需要弄清楚哪些图像依赖关系属于哪里，哪个图像实际上需要重建（如果您运行的是单一存储库），服务是否发生了任何变化，以及许多其他辅助问题。为了简化和优化我们的部署过程，我们需要找到一种方法，使整个系统完全自动化，以便部署新版本的服务所需的唯一事情是提交代码存储库分支的更改。
- en: As of today, the most popular automation server called Jenkins is generally
    used in such function to do this build automation and deployment of Docker images
    and infrastructure but others like Drone, Buildbot, Concoure, etc have been rising
    fast through the ranks of very capable software CI/CD tooling too but none have
    so far reached the same acceptance levels from the industry yet. Since Jenkins
    is also relatively easy to use, we can do a quick demonstration of its power,
    and while the example is a bit simplistic, it should make it obvious on how this
    can be used for much more.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 截至今天，名为Jenkins的最流行的自动化服务器通常用于进行构建自动化和Docker镜像和基础架构的部署，但其他工具如Drone、Buildbot、Concoure等也在非常有能力的软件CI/CD工具排行榜上迅速上升，但迄今为止还没有达到行业的同等接受水平。由于Jenkins相对容易使用，我们可以快速演示其功能，虽然这个例子有点简单，但它应该很明显地表明了它可以用于更多的用途。
- en: 'Since Jenkins will need `awscli`, Ansible, and `python-boto`, we have to make
    a new Docker image based on the Jenkins that is available from Docker Hub. Create
    a new folder and add a `Dockerfile` with the following content in it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jenkins将需要`awscli`、Ansible和`python-boto`，我们必须基于Docker Hub上可用的Jenkins创建一个新的Docker镜像。创建一个新文件夹，并在其中添加一个`Dockerfile`，内容如下：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we build and run our server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们构建并运行我们的服务器：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While it is still running, let''s go to the main page and enter the installation
    password that we got a warning for during the image start. Go to `http://localhost:8080`
    and enter the password that was in your logs:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在它仍在运行时，让我们转到主页并输入我们在镜像启动期间收到警告的安装密码。转到`http://localhost:8080`并输入日志中的密码：
- en: '![](assets/b92e7df8-9270-444e-ad56-3042aa188d7a.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b92e7df8-9270-444e-ad56-3042aa188d7a.png)'
- en: 'Click on Install Suggested Plugins on the next window and then after the relevant
    downloads are finished, select Continue as admin on the last installer page, which
    should lead you to the main landing page:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个窗口上点击“安装建议的插件”，然后在相关下载完成后，选择最后一个安装程序页面上的“以管理员身份继续”，这应该会带您到主要的登陆页面：
- en: '![](assets/e82e77e8-f006-4cb2-ba62-bdcaee9d5aa5.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e82e77e8-f006-4cb2-ba62-bdcaee9d5aa5.png)'
- en: 'Click on create new jobs, name it `redeploy_infrastructure`, and make it a
    Freestyle project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建新作业”，命名为`redeploy_infrastructure`，并将其设置为自由风格项目。
- en: '![](assets/f90a1571-c515-4365-9c1d-80bdf33d8857.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f90a1571-c515-4365-9c1d-80bdf33d8857.png)'
- en: 'Next, we will configure the job with our Git repository endpoint so that it
    builds on any commits to the master branch:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的Git存储库端点配置作业，以便在主分支上的任何提交上构建：
- en: '![](assets/6bb0475d-efd1-41d3-b071-a4f835c45f7a.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bb0475d-efd1-41d3-b071-a4f835c45f7a.png)'
- en: 'As our build step, when the repository trigger activates, we will destroy and
    deploy the infrastructure, effectively replacing it with a newer version. Add
    a new build step of **Execute Shell** type and add the following to it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的构建步骤，当存储库触发器激活时，我们将销毁并部署基础设施，有效地用新版本替换它。添加一个新的**执行Shell**类型的构建步骤，并添加以下内容：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The job should look quite a bit similar to this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 工作应该看起来与这个相似：
- en: '![](assets/c56d4689-5abb-4777-b187-a2dc96a5b7fb.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c56d4689-5abb-4777-b187-a2dc96a5b7fb.png)'
- en: 'Save the changes with `Save`, which should take you to the build''s main page.
    Here, click on the `Build Now` button and once the build appears on the left side
    build list, click on its progress bar or the dropdown  next to its name and select
    `View Log`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改并点击“保存”，这应该会带您到构建的主页。在这里，点击“立即构建”按钮，一旦构建出现在左侧构建列表中，点击其进度条或名称旁边的下拉菜单，并选择“查看日志”：
- en: '![](assets/f8092593-3a14-4fea-97d5-6050e1ba03a5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8092593-3a14-4fea-97d5-6050e1ba03a5.png)'
- en: Success! As you can see, with Jenkins and a small configuration, we just made
    an automated deployment of our simple infrastructure. It is crude but effective
    though normally you would not want to redeploy everything but just the pieces
    that have changed and have the Jenkins live in-cluster, but that are somewhat
    more-involved endeavors that will be left to the reader as possible points of
    improvement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！正如您所看到的，通过Jenkins和一些小的配置，我们刚刚实现了我们简单基础设施的自动部署。虽然粗糙但有效，通常情况下，您不希望重新部署所有内容，而只是更改了的部分，并且Jenkins生活在集群中，但这些都是一些更复杂的努力，将留给读者作为可能的改进点。
- en: Resource considerations
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源考虑
- en: Since Jenkins runs on top of a Java VM, it will eat up available RAM at an alarming
    rate and is usually the biggest hog of usage along with being the most frequent
    **out-of-memory** (**OOM**) culprit I have had experience with. In even the lightest
    use cases, plan to allocate at least 1 GB of RAM to Jenkins workers or risk various
    failures at the most inopportune stages of your build pipelines. As a general
    rule, most Jenkins installation at this time will not have many problems with
    2 GB of RAM allocated to them, but due to the price of RAM in VM instances, you
    can try to scale things back until you reach the acceptable levels of performance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jenkins在Java虚拟机上运行，它会以惊人的速度消耗可用的RAM，并且通常是使用量最大的，也是我经验最丰富的**内存不足**（**OOM**）罪魁祸首。即使在最轻量的使用情况下，计划为Jenkins工作节点分配至少1GB的RAM，否则可能在构建流水线的最不合时宜的阶段出现各种故障。一般规则是，目前大多数Jenkins安装将不会在分配给它们2GB的RAM时出现太多问题，但由于VM实例中RAM的价格，您可以尝试缩减规模，直到达到可接受的性能水平。
- en: The last thing to also pay attention to is that the Jenkins image is also a
    bulky one relatively speaking, weighing in at about a hefty 800 MB, so keep in
    mind that moving this container is really not as easy nor fast as some other tooling
    that we have been using.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的最后一件事是，相对而言，Jenkins镜像也是一个庞大的镜像，重达约800 MB，因此请记住，移动这个容器并不像我们之前使用的一些其他工具那样容易或快速。
- en: First-deploy circular dependency
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次部署的循环依赖
- en: When using Jenkins within your cluster as a Dockerized service to chain-build
    all other images, it is important for me to mention a common pitfall where you
    will inevitably have the issue with new deployments where Jenkins is not available
    initally since at the cluster initialization stage no images are usually available
    in the registry and the default Jenkins Docker image is not configured in any
    way. On top of all this, since you often need an already-running Jenkins instance
    to build a newer Jenkins image, you will be in the the classic Catch-22 situation.
    You may have a reflex to build Jenkins manually as a followup deployment step,
    but you must resist the urge to do so if you want to really have infrastructure
    that is mostly hands-off.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中使用Jenkins作为Docker化服务来链接构建所有其他镜像时，我需要提到一个常见的陷阱，即您将不可避免地在新部署中遇到问题，因为Jenkins最初不可用，因为在集群初始化阶段，注册表中通常没有镜像可用，并且默认的Jenkins
    Docker镜像没有进行任何配置。除此之外，由于您经常需要一个已运行的Jenkins实例来构建更新的Jenkins镜像，您将陷入经典的进退两难的境地。您可能会有一种本能去手动构建Jenkins作为后续部署步骤，但如果您真的想要拥有大部分无需干预的基础设施，您必须抵制这种冲动。
- en: 'The general workaround to this is problem of bootstrapping Jenkins on a clean
    cluster has generally been something as shown in the following diagram:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一般方法通常是在干净的集群上引导Jenkins，通常是如下图所示的方式：
- en: '![](assets/b5ffcb96-c3ad-4d99-ac8f-840034f3ea73.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5ffcb96-c3ad-4d99-ac8f-840034f3ea73.png)'
- en: The cluster deployment is done first to ensure that we have a way t build our
    bootstrap image, and the **Docker Registry** is used to store the image after
    it is built. Following this, we build the Jenkins image on any available Docker
    Engine node and push it to the registry so that the service will have the right
    image to start with. If needed, we then launch the mentioned service using the
    same configuration management tool (like Ansible) or the orchestration tooling
    and wait for the auto-start job that will build all other remaining images which
    should populate the registry with all the other images needed to run the full
    cluster. The basic idea here is to do the initial bootstrap through CM tooling
    and then let the Jenkins service rebuild all the other images and (re)start the
    tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先进行集群部署，以确保我们有一种构建引导映像的方法，然后使用Docker Registry存储构建后的映像。随后，在任何可用的Docker Engine节点上构建Jenkins映像，并将其推送到注册表，以便服务将具有正确的映像来启动。如果需要，然后使用相同的配置管理工具（如Ansible）或编排工具启动所述服务，并等待自动启动作业，该作业将构建所有其他剩余的映像，这些映像应填充注册表以运行完整的集群所需的所有其他映像。这里的基本思想是通过CM工具进行初始引导，然后让Jenkins服务重新构建所有其他映像并（重新）启动任务。
- en: In large-scale deployments, it is also possible to use your cluster orchestration
    to schedule and handle this bootstrap procedure instead of the CM tooling but
    due to the vast differences between each orchestration engine, these steps may
    vary wildly between them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模部署中，还可以使用集群编排来安排和处理此引导过程，而不是使用CM工具，但由于每个编排引擎之间存在巨大差异，这些步骤可能在它们之间大相径庭。
- en: Further generic CI/CD uses
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的通用CI/CD用途
- en: 'Good CI tooling like Jenkins can do much more than the things we covered here;
    they all require significant investment of time and effort to get working, but
    the benefits are pretty significant if you can get them implemented:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像Jenkins这样的良好的CI工具可以做的事情远不止我们在这里介绍的内容；它们都需要大量的时间和精力来使其正常工作，但如果您能够实施它们，其好处是非常显著的：
- en: '**Self-building**: As mentioned in the workaround previously, you can have
    Jenkins build its own image when the configuration changes and have it redeploy
    itself.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自构建：如前所述，当配置更改时，您可以让Jenkins构建自己的映像，并重新部署自己。
- en: '**Deployment of only changed Docker images**: If you use Docker caching, you
    can check whether the new build created a different image hash and only deploy
    if it did. Doing this will prevent pointless work and have your infrastructure
    always running the newest code.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅部署已更改的Docker映像：如果使用Docker缓存，您可以检查新构建是否创建了不同的映像哈希，并且仅在确实创建了不同的映像时部署。这样做将防止无谓的工作，并使您的基础设施始终运行最新的代码。
- en: '**Timed Docker pruning**: You can run cleanup jobs (or any other jobs similar
    to `cron`)  on Jenkins that will free up or manage your Docker nodes to avoid
    manual interactions.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时Docker清理：您可以在Jenkins上运行清理作业（或类似于`cron`的任何其他作业），以释放或管理您的Docker节点，以避免手动交互。
- en: 'This list can also include: automated releases, failure notifications, build
    tracking, and quite a few other things that can be gained as well but suffice it
    to say, you really want a working CI pipeline in any non-trivial deployment.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表还可以包括：自动发布、故障通知、构建跟踪，以及许多其他可以获得的东西，但可以说，您确实希望在任何非平凡的部署中都有一个可工作的CI流水线。
- en: A rule of thumb is that if you need to do something manually that can be automated
    with some timers and shell script, most CI tooling (like Jenkins) is there to
    help you out, so don't be afraid to try different and creative uses for it. With
    a full array of options and other tooling we have covered in this chapter, you
    can go to sleep soundly knowing that your clusters are going to be fine for a
    little while without needing constant babysitting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，如果您需要手动完成某些可以通过一些定时器和shell脚本自动化的工作，大多数CI工具（如Jenkins）都可以帮助您，所以不要害怕尝试不同和创造性的用法。通过本章中涵盖的一整套选项和其他工具，您可以放心地入睡，知道您的集群在一段时间内都不需要不断地看护。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered more on how you would truly deploy a PaaS
    infrastructure and the following topics that were required for it were examined
    in depth: configuration Management tooling with Ansible, cloud image management
    with HashiCorp Packer, and continuous integration with Jenkins. With the knowledge
    gained here, you should now be able to use the various tooling we discussed and
    create your own mini-PaaS for your own service deployments, and with some additional
    work, you can turn it into a full-scale PaaS!'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地介绍了如何真正部署PaaS基础架构以及为此所需的以下主题：使用Ansible进行配置管理工具化、使用HashiCorp Packer进行云镜像管理以及使用Jenkins进行持续集成。通过在这里获得的知识，您现在应该能够使用我们讨论过的各种工具，并为自己的服务部署创建自己的迷你PaaS，再经过一些额外的工作，您可以将其转变为全面的PaaS！
- en: In the next chapter, we will take a look at how we can take our current Docker
    and infrastructure work and take it even bigger. We will also cover what direction
    this field might be moving toward, so if you would like to gain insights into
    the largest of deployments in the world, stick around.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何将我们当前的Docker和基础架构工作扩大。我们还将探讨这个领域可能朝着什么方向发展，所以如果您想了解世界上最大规模的部署，敬请关注。
