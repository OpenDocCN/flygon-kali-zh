- en: Packages and Accessibility (Visibility)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和可访问性（可见性）
- en: By now, you are already quite familiar with packages. In this chapter, we will
    complete its description and then discuss different levels of accessibility (also
    called visibility) of classes and class members – methods and fields. It all will
    come down to the key concept of object-oriented programming – the encapsulation –
    and lay the foundation for our discussion of object-oriented design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经对包非常熟悉。在本章中，我们将完成其描述，然后讨论类和类成员（方法和字段）的不同可访问性级别（也称为可见性）。这一切都将归结为面向对象编程的关键概念——封装——并为我们讨论面向对象设计原则奠定基础。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is importing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是导入？
- en: Static importing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态导入
- en: Interface access modifiers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口访问修饰符
- en: Class access modifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类访问修饰符
- en: Method access modifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法访问修饰符
- en: Property access modifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问修饰符
- en: Encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Exercise – Shadowing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-遮蔽
- en: What is importing?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是导入？
- en: 'Importing allows us to specify a fully qualified class or interface name only
    once at the beginning of the `.java` file, before the class or interface declaration.
    The format of an import statement is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 导入允许我们在`.java`文件的开头只指定一次完全限定的类或接口名称，然后是类或接口声明。导入语句的格式如下：
- en: '```java'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import <package>.<class or interface name>;
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: import <package>.<class or interface name>;
- en: '```'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'For example, look at the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的例子：
- en: '```java'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import com.packt.javapath.ch04demo.MyApplication;
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.ch04demo.MyApplication;
- en: '```'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'From now on, this class can be referred to in the code by its name, `MyApplication`,
    only. It is also possible to import all the classes or interfaces of a package
    using the wildcard character (`*`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这个类只能在代码中通过它的名字`MyApplication`来引用。还可以使用通配符字符(`*`)导入包的所有类或接口：
- en: '```java'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import com.packt.javapath.ch04demo.*;
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.ch04demo.*;
- en: '```'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the preceding import statement imports classes and interfaces of
    the subpackages of the `com.packt.javapath.ch04demo` package. If needed, each
    subpackage has to be imported separately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的导入语句导入了`com.packt.javapath.ch04demo`包的子包的类和接口。如果需要，每个子包都必须单独导入。
- en: But, before we continue, let's talk about the `.java` file structure and packages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续之前，让我们谈谈`.java`文件的结构和包。
- en: Structure of the .java file and packages
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .java文件和包的结构
- en: As you already know, the package name reflects the directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the public class defined in it. The first
    line of the `.java` file is the package statement that starts with the `package` keyword,
    followed by the actual package name—the directory path to this file, in which
    slashes are replaced with dots. Let's look at some examples. We will look primarily
    at the `.java` file that contains a class definition, but we will also look at
    files with interfaces and the `enum` class definition because there is a particular
    type of importing (called static importing) that is primarily used with interfaces
    and `enum`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，包名反映了目录结构，从包含`.java`文件的项目目录开始。每个`.java`文件的名称必须与其中定义的公共类的名称相同。`.java`文件的第一行是以`package`关键字开头的包语句，后面是实际的包名称——此文件的目录路径，其中斜杠用点替换。让我们看一些例子。我们将主要关注包含类定义的`.java`文件，但我们还将查看包含接口和`enum`类定义的文件，因为有一种特殊的导入（称为静态导入）主要用于接口和`enum`。
- en: 'We assume that the `src/main/java` (for Linux) or `src\main\java` (for Windows) project
    directory contains all the `.java` files, and the definition of the `MyClass` and
    `MyEnum` classes and the `MyInterface` interface from the package `com.packt.javapath` are
    stored in the files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`src/main/java` (for Linux)或`src\main\java` (for Windows)项目目录包含所有`.java`文件，并且`MyClass`和`MyEnum`类以及`MyInterface`接口的定义来自`com.packt.javapath`包存储在以下文件中：
- en: '```java'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: src/main/java/com/packt/javapath/MyClass.java (for Linux)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: src/main/java/com/packt/javapath/MyClass.java (for Linux)
- en: src/main/java/com/packt/javapath/MyEnum.java
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: src/main/java/com/packt/javapath/MyEnum.java
- en: src/main/java/com/packt/javapath/MyInterface.java
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: src/main/java/com/packt/javapath/MyInterface.java
- en: '```'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: or (for Windows)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或（对于Windows）
- en: '```java'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: src\main\java\com\packt\javapath\MyClass.java (for Windows)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: src\main\java\com\packt\javapath\MyClass.java (for Windows)
- en: src\main\java\com\packt\javapath\MyEnum.java
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: src\main\java\com\packt\javapath\MyEnum.java
- en: src\main\java\com\packt\javapath\MyInterface.java
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: src\main\java\com\packt\javapath\MyInterface.java
- en: '```'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The first line of each of these files is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的每一行的第一行如下：
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If we do not import anything, then the next line in each file is a class or
    interface declaration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有导入任何内容，那么每个文件的下一行就是一个类或接口声明。
- en: 'The declaration of the `MyClass` class looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass`类的声明如下：'
- en: '```java'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass extends SomeClass
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass extends SomeClass
- en: implements Interface1, Interface2, ... {...}
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: implements Interface1, Interface2, ... {...}
- en: '```'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It consists of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; one of the classes in the file has to be `public`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符；文件中的一个类必须是`public`
- en: The `class` keyword
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`关键字'
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以大写字母开头的类名（标识符）
- en: If the class is a child of another class, the `extends` keyword and the name
    of the parent class
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类是另一个类的子类，则使用`extends`关键字和父类的名称
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类实现了一个或多个接口，使用`implements`关键字后跟随逗号分隔的接口列表
- en: The body of the class (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的主体（定义字段和方法的地方）由大括号`{}`括起来
- en: 'The declaration of the `MyEnum` class looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyEnum`类的声明如下：'
- en: '```java'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public enum MyEnum implements Interface1, Interface2, ... {...}
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: public enum MyEnum implements Interface1, Interface2, ... {...}
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It consists of the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; it has to be `public` if it is the only class defined in
    the file
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问修饰符；如果它是文件中唯一定义的类，则必须是`public`
- en: The `enum` keyword
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`关键字'
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以大写字母开头的类名（标识符）按照约定
- en: No `extends` keyword because the enum type extends the `java.lang.Enum` class implicitly
    and, in Java, a class can have only one parent
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`extends`关键字，因为枚举类型隐式地扩展了`java.lang.Enum`类，在Java中，一个类只能有一个父类
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类实现了一个或多个接口，则使用`implements`关键字后跟逗号分隔的接口列表
- en: The body of the class (where the constants and methods are defined) surrounded
    by braces, `{}`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的主体（常量和方法的定义）由大括号`{}`括起来
- en: 'The declaration of the `MyInterface` interface looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyInterface`接口的声明如下：'
- en: '```java'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface MyInterface extends Interface1, Interface2, ... {...}
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: public interface MyInterface extends Interface1, Interface2, ... {...}
- en: '```'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It consists of the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; one of the interfaces in the file has to be `public`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问修饰符；文件中的一个接口必须是`public`
- en: The `interface` keyword
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`关键字'
- en: The interface name (identifier) that starts with a capital letter by convention
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照约定以大写字母开头的接口名称（标识符）
- en: If the interface is a child of one or more interfaces, the `extends` keyword followed
    by the comma-separated list of the parent interfaces
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接口是一个或多个接口的子接口，则使用`extends`关键字后跟父接口的逗号分隔列表
- en: The body of the interface (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的主体（字段和方法的定义）由大括号`{}`括起来
- en: 'Without importing, we would need to refer to each class or interface we are
    using by its fully qualified name, which includes the package name and class,
    or interface name. For example, the `MyClass` class declaration would look like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不导入，我们需要通过完全限定的名称引用我们使用的每个类或接口，其中包括包名和类或接口名。例如，`MyClass`类的声明将如下所示：
- en: '```java'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类
- en: extends com.packt.javapath.something.AnotherMyClass
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: extends com.packt.javapath.something.AnotherMyClass
- en: implements com.packt.javapath.something2.Interface1,
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: implements com.packt.javapath.something2.Interface1,
- en: com.packt.javapath.something3.Interface2
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: com.packt.javapath.something3.Interface2
- en: '```'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or, let''s say we would like to instantiate the `SomeClass` class from the `com.packt.javapath.something` package.
    The fully qualified name of that class would be `com.packt.javapath.something.SomeClass` and
    its object creation statement would look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，假设我们想要实例化`com.packt.javapath.something`包中的`SomeClass`类。该类的完全限定名称将是`com.packt.javapath.something.SomeClass`，其对象创建语句如下所示：
- en: '```java'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: com.packt.javapath.something.SomeClass someClass =
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: com.packt.javapath.something.SomeClass someClass =
- en: new com.packt.javapath.something.SomeClass();
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: new com.packt.javapath.something.SomeClass();
- en: '```'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is too verbose, isn't it? This is where package importing comes to the rescue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太啰嗦了，不是吗？这就是包导入发挥作用的地方。
- en: Single class import
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个类导入
- en: 'To avoid using the fully qualified class or interface name in the code, we
    can add an import statement in the space between the package declaration and class
    or interface declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在代码中使用完全限定的类或接口名称，我们可以在包声明和类或接口声明之间的空间中添加一个导入语句：
- en: '```java'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import com.packt.javapath.something.SomeClass;
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.something.SomeClass;
- en: public class MyClass {
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: //...
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: SomeClass someClass = new SomeClass();
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass someClass = new SomeClass();
- en: //...
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the import statement allows avoiding usage of the fully qualified
    class name, which makes the code easier to read.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，import语句允许避免使用完全限定的类名，这样使得代码更容易阅读。
- en: Multiple classes import
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个类导入
- en: If several classes or interfaces from the same package are imported, it is possible
    to import all the package members using the asterisk (`*`) wildcard character.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从同一包中导入了多个类或接口，则可以使用星号（`*`）通配符字符导入所有包成员。
- en: 'If `SomeClass` and `SomeOtherClass` belong to the same package, then the import
    statement may look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SomeClass`和`SomeOtherClass`属于同一个包，则导入语句可能如下所示：
- en: '```java'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import com.packt.javapath.something.*;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.something.*;
- en: public class MyClass {
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: //...
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: SomeClass someClass = new SomeClass();
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass someClass = new SomeClass();
- en: SomeOtherClass someClass1 = new SomeOtherClass();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SomeOtherClass someClass1 = new SomeOtherClass();
- en: //...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The advantage of using the asterisk is a shorter list of import statements,
    but such a style hides the names of the imported classes and interfaces. So, the
    programmer may not know exactly where they come from. Besides, when two or more
    packages contain members with the same name, you just have to import them explicitly
    as a single class import. Otherwise, the compiler will generate an error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用星号的优点是更短的导入语句列表，但这种样式隐藏了导入的类和接口的名称。因此，程序员可能不知道它们确切来自哪里。此外，当两个或更多个包包含具有相同名称的成员时，您只需将它们作为单个类导入显式导入。否则，编译器将生成错误。
- en: On the other hand, the programmers who prefer wildcard importing, argue that
    it helps to prevent accidentally creating a class with a name that exists already
    in one of the imported packages. So, you have to make your own choice when it
    comes to style and configuring your IDE to use or not use the wildcard importing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，喜欢通配符导入的程序员认为，这有助于防止意外地创建一个与导入包中已存在的名称相同的类。因此，当涉及到样式和配置IDE使用或不使用通配符导入时，你必须自己做出选择。
- en: 'In IntelliJ IDEA, the default style of import is using a wildcard. If you would
    like to switch to a single class import, click on File | Other Settings | Default
    Settings, as in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ IDEA中，默认的导入样式是使用通配符。如果你想切换到单个类导入，点击文件|其他设置|默认设置，如下截图所示：
- en: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
- en: 'On the screen that opens, select Editor | Java and check the Use single class
    import checkbox:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的屏幕上，选择编辑器|Java，并选中使用单个类导入复选框：
- en: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
- en: There are other settings on this page that you might find useful, so try to
    remember how to access it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面上还有其他一些你可能会发现有用的设置，所以试着记住如何访问它。
- en: Static import
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态导入
- en: 'Static import allows importing not just a class or an interface but its public
    members—fields and methods—individually. If you look in one of our test classes,
    you will see the following static import statement:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入允许单独导入一个类或接口，以及它的公共成员——字段和方法。如果你查看我们的一个测试类，你会看到以下静态导入语句：
- en: '```java'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import static org.junit.jupiter.api.Assertions.*;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: import static org.junit.jupiter.api.Assertions.*;
- en: '```'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This statement allowed us to write the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句允许我们编写以下内容：
- en: '```java'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p = new Person("Joe", "Blow", dob);
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = new Person("Joe", "Blow", dob);
- en: assertTrue(p.equals(p));
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(p.equals(p));
- en: '```'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is instead of writing this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写：
- en: '```java'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p = new Person("Joe", "Blow", dob);
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = new Person("Joe", "Blow", dob);
- en: Assertions.assertTrue(p.equals(p));
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Assertions.assertTrue(p.equals(p));
- en: '```'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is one widespread case of static import usage. Another popular case is
    static importing of constants of an interface or `enum`. For example, if we have
    an interface as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是静态导入用法的一个普遍情况。另一个常见情况是静态导入接口或`enum`的常量。例如，如果我们有一个如下的接口：
- en: '```java'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.api;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.api;
- en: public interface Constants {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Constants {
- en: String NAME = "name";
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: String NAME = "name";
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'Then, to use its constants, one can import them statically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用它的常量，可以静态导入它们：
- en: '```java'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import static com.packt.javapath.api.Constants.*;
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: import static com.packt.javapath.api.Constants.*;
- en: public class MyClass {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: //...
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = "My " + NAME + " is Joe";
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: String s = "My " + NAME + " is Joe";
- en: 'System.out.println(s);        //Prints: My name is Joe'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);        //打印：My name is Joe
- en: //...
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'By the way, the same effect could be achieved by importing that `Constants` interface
    non-statically and having the class implement it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，通过非静态导入`Constants`接口并让类实现它也可以达到同样的效果：
- en: '```java'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import com.packt.javapath.api.Constants;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.api.Constants;
- en: public class MyClass implements Constants {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass implements Constants {
- en: //...
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = "My " + NAME + " is Joe";
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: String s = "My " + NAME + " is Joe";
- en: 'System.out.println(s);        //Prints: My name is Joe'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);        //打印：My name is Joe
- en: //...
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This style of implementing an interface in order to use their constants is quite
    popular among Java programmers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现接口以使用它们的常量的方式在Java程序员中相当流行。
- en: 'An example of using static import in order to use the `enum` constants looks
    similar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入来使用`enum`常量的示例看起来很相似：
- en: '```java'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import static java.time.DayOfWeek.*;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: import static java.time.DayOfWeek.*;
- en: '```'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It allows the code to use `DayOfWeek` constants as `MONDAY`, instead of `DayOfWeek.MONDAY`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许代码将`DayOfWeek`常量用作`MONDAY`，而不是`DayOfWeek.MONDAY`。
- en: Access modifiers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: There are three explicit access modifiers—public, private, and protected—and
    one implicit (default) access modifier that is implied when no access modifier
    is set. They can be applied to the top-level class or interface, their members,
    and constructors. A *top-level* class or interface can include a *member* class
    or interface. Other *members* of a class or interface are fields and methods.
    Classes also have *constructors*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种显式访问修饰符——public、private和protected——以及一种隐式（默认）访问修饰符，当没有设置访问修饰符时会被隐含。它们可以应用于顶级类或接口、它们的成员和构造函数。*顶级*类或接口可以包括*成员*类或接口。类或接口的其他*成员*是字段和方法。类还有*构造函数*。
- en: 'To demonstrate the accessibility, let''s create a `com.packt.javapath.Ch07demo.pack01` package that
    contains two classes and two interfaces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示可访问性，让我们创建一个`com.packt.javapath.Ch07demo.pack01`包，其中包含两个类和两个接口：
- en: '```java'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PublicClass01 {
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass01 {
- en: public static void main(String[] args){
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: //We will write code here
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: //我们将在这里编写代码
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class DefaultAccessClass01 {
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类 DefaultAccessClass01 {
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public interface PublicInterface01 {
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: public interface PublicInterface01 {
- en: String name = "PublicInterface01";
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "PublicInterface01";
- en: '}'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DefaultAccessInterface01 {
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 DefaultAccessInterface01 {
- en: String name = "DefaultAccessInterface01";
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "DefaultAccessInterface01";
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We will also create another `com.packt.javapath.Ch07demo.pack02` package with
    one class in it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建另一个`com.packt.javapath.Ch07demo.pack02`包，并在其中创建一个类：
- en: '```java'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PublicClass02 {
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass02 {
- en: public static void main(String[] args){
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: //We will write code here
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: //我们将在这里编写代码
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Each of the preceding classes and interfaces is in its own file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个类和接口都在自己的文件中：
- en: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
- en: Now we are ready to explore the accessibility of classes, interfaces, their
    members, and constructors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备探索类、接口、它们的成员和构造函数的可访问性。
- en: The accessibility of a top-level class or interface
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶级类或接口的可访问性
- en: 'The public class or interface is accessible from anywhere. We can import them
    and access them from another package:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类或接口可以从任何地方访问。我们可以导入它们并从另一个包中访问它们：
- en: '```java'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import com.packt.javapath.Ch07demo.pack01.PublicClass01;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.Ch07demo.pack01.PublicClass01;
- en: import com.packt.javapath.Ch07demo.pack01.PublicInterface01;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.Ch07demo.pack01.PublicInterface01;
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessInterface01;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessInterface01;
- en: public class PublicClass02 {
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass02 {
- en: public static void main(String[] args){
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: System.out.println(PublicInterface01.name);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(PublicInterface01.name);
- en: PublicClass01 o = new PublicClass01();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PublicClass01 o = new PublicClass01();
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, the two import statements are commented out because they
    generate an error. That is because in the `DefaultAccessClass01` class and the `DefaultAccessClass01` interface,
    we did not use the access modifier, which made them accessible only to the members
    of the same package.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，两个导入语句被注释掉，因为它们会生成错误。这是因为在`DefaultAccessClass01`类和`DefaultAccessClass01`接口中，我们没有使用访问修饰符，这使它们只能被同一包的成员访问。
- en: Without an access modifier, a top-level class or interface can be accessed only
    by the members of the same package.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 没有访问修饰符的顶层类或接口只能被同一包的成员访问。
- en: Making an access modifier `private` in the declaration of a top-level class
    or interface make them inaccessible, so using a `private` access modifier for
    a top-level class or interface does not make sense.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层类或接口的声明中使用`private`访问修饰符会使它们无法访问，因此在顶层类或接口中使用`private`访问修饰符是没有意义的。
- en: The `protected` keyword cannot be applied to a top level. This limitation is
    not as obvious. We will see in the next section that `protected` means it is accessible
    to the package members and the children. So, one could argue that `protected`
    access can be applicable to a top-level class or interface too. Yet, the Java
    authors decided not to do it, and the compiler will generate an exception if you
    try to make a top-level class or interface `protected`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`关键字不能应用于顶层。这个限制并不那么明显。我们将在下一节中看到`protected`意味着它对包成员和子类是可访问的。因此，有人可能会认为`protected`访问也适用于顶层类或接口。然而，Java的作者决定不这样做，如果您尝试将顶层类或接口设置为`protected`，编译器将生成异常。'
- en: However, `private` and `protected` access modifiers can be applied to inner
    classes or interfaces—the members of the top-level class or interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`private`和`protected`访问修饰符可以应用于内部类或接口-顶层类或接口的成员。
- en: Access to class or interface members
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问类或接口成员
- en: Even when class or interface members are declared public, they cannot be accessed
    if the enclosing class or interface is inaccessible. So, all of the following
    discussion will be done under the assumption that the class or interface is accessible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 即使类或接口成员被声明为公共，如果封闭类或接口是不可访问的，它们也无法被访问。因此，以下所有讨论都将在类或接口是可访问的假设下进行。
- en: Members of a class or interface can access other members of the same class or
    interface no matter what access modifiers they have. Which makes sense, doesn't
    it? It all happens inside the same enclosing class or interface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类或接口的成员可以访问同一类或接口的其他成员，无论它们有什么访问修饰符。这是有道理的，不是吗？这一切都发生在同一个封闭类或接口内。
- en: By default, the interface members are public. So, if an interface itself can
    be accessed, its members without access modifier can be accessed too. And, just
    to remind you, the interface fields are static and final (constants) by default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，接口成员是公共的。因此，如果可以访问接口本身，则其没有访问修饰符的成员也可以被访问。而且，只是提醒一下，接口字段默认是静态和最终的（常量）。
- en: The class members, on the other hand, without an access modifier, are accessible
    only to the package members. So, the class or interface may be public, but their
    members are less accessible, if not made public explicitly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，没有访问修饰符的类成员只能被包成员访问。因此，类或接口可能是公共的，但它们的成员是不太可访问的，除非明确设置为公共。
- en: Private class or interface members are accessible only to the other members
    of the same class or interface. That is the most restricted access possible. Even
    children of the class cannot access their parents' private members.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 私有类或接口成员只能被同一类或接口的其他成员访问。这是可能的最受限制的访问。甚至类的子类也不能访问其父类的私有成员。
- en: 'Protected package members are accessible to other members of the same package
    and to the children of the class or interface, which means that protected members
    can be overridden. And that is often used by programmers as an expression of the
    intent: they make those members protected that they expect to be overridden. Otherwise,
    they make them either private or public. Default—no access modifiers—access is
    rarely used.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的包成员对于同一包中的其他成员和类或接口的子类是可访问的，这意味着受保护的成员可以被覆盖。程序员经常使用这种方式来表达意图：他们将那些他们期望被覆盖的成员设置为受保护。否则，他们将它们设置为私有或公共。默认-没有访问修饰符-访问很少被使用。
- en: '**Private**: Allows access from the same class (or interface) only'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有**：仅允许从相同的类（或接口）访问'
- en: '**No modifier (default)**: Allows access from the same class (or interface)
    and the same package'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**无修饰符（默认）**：允许从相同的类（或接口）和相同的包中访问'
- en: '**Protected**: Allows access from the same class (or interface), the same package,
    and any child'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护的**：允许从相同的类（或接口）、相同的包和任何子类访问'
- en: '**Public**: Allows access from anywhere'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共**：允许从任何地方访问'
- en: 'The same accessibility rules apply to inner classes and interfaces too. Here
    is an example of a class that contains inner classes and interfaces:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的可访问性规则也适用于内部类和接口。这是一个包含内部类和接口的类的示例：
- en: '```java'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PublicClass01 {
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass01 {
- en: public static void main(String[] args){
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: System.out.println(DefaultAccessInterface01.name);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(DefaultAccessInterface01.name);
- en: DefaultAccessClass01 o = new DefaultAccessClass01();
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: DefaultAccessClass01 o = new DefaultAccessClass01();
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class DefaultAccessClass{
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: class DefaultAccessClass{
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected class ProtectedClass{
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的类ProtectedClass{
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class PrivateClass{
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: private class PrivateClass{
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DefaultAccessInterface {
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认访问接口{
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected class ProtectedInterface{
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: protected class ProtectedInterface{
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private class PrivateInterface{
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: private class PrivateInterface{
- en: '}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is an interface with an inner class and interface:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有内部类和接口的接口：
- en: '```java'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface PublicInterface01 {
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: public interface PublicInterface01 {
- en: String name = "PublicInterface01";
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "PublicInterface01";
- en: class DefaultAccessClass{
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类DefaultAccessClass{
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DefaultAccessInterface {
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接口DefaultAccessInterface {
- en: '}'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, only default (public) access is allowed for the inner classes
    and interfaces of an interface.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，接口的内部类和接口只允许默认（公共）访问。
- en: 'And, just to repeat what we have already discussed, we will briefly mention
    some other related aspects of members accessibility:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，为了重复我们已经讨论过的内容，我们将简要提及一些与成员可访问性相关的其他方面：
- en: A static nested class (it is an inner class, but is called nested in the case
    of the static class by convention) cannot access non-static members of the same
    class, while they can access it
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态嵌套类（在静态类的情况下被称为嵌套类，但按照惯例）不能访问同一类的非静态成员，而它们可以访问它
- en: Being a member of some top-level class, a static nested class can be public, protected,
    package-accessible (default), or private
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为某个顶级类的成员，静态嵌套类可以是公共的、受保护的、包访问（默认）的或私有的
- en: Public, protected, and package-accessible members of a class are inherited by
    the child
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的公共、受保护和包访问成员都会被子类继承
- en: The constructor's accessibility is the same as any class member
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的可访问性与任何类成员相同
- en: As the title of this section has stated, that is all we can say about the accessibility
    of a constructor. Naturally, when we talk about constructors, we talk only about
    classes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节标题所述，这就是我们对构造函数可访问性能说的一切。当然，当我们谈论构造函数时，我们只谈论类。
- en: 'The interesting thing about constructors is their ability to have private access
    only. It means that a class can provide its own factory method (see [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*), control how each object is constructed,
    and even control how many of them can be put into the circulation. The last feature
    is especially valuable in the case where each object requires access to a certain
    resource (a file or another database) that has limited support for concurrent
    access. Here is how the simplest version of such a factory method with a limited number
    of objects created may look:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的有趣之处在于它们只能具有私有访问权限。这意味着一个类可以提供自己的工厂方法（参见[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)，*接口、类和对象构造*），控制每个对象的构造方式，甚至控制可以将多少个对象放入流通中。在每个对象都需要访问某个资源（文件或另一个数据库）的情况下，最后一个特性尤为有价值，因为这些资源对并发访问的支持有限。以下是一个具有有限创建对象数量的最简单版本的工厂方法的样子：
- en: '```java'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private String field;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 私有String field;
- en: private static int count;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态int count;
- en: private PublicClass02(String s){
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 私有PublicClass02(String s){
- en: this.field = s;
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: this.field = s;
- en: '}'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static PublicClass02 getInstance(String s){
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: public static PublicClass02 getInstance(String s){
- en: if(count > 5){
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: if(count > 5){
- en: return null;
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 返回null;
- en: '} else {'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: count++;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: count++;
- en: return new PublicClass02(s);
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新的PublicClass02(s);
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The usefulness of this code is not great and we show it only to demonstrate
    how a privately accessible constructor can be used. It is possible because each
    class members can access all other class members no matter their access modifiers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的用处并不大，我们只是为了演示私有可访问的构造函数如何被使用。这是可能的，因为每个类成员都可以访问所有其他类成员，无论它们的访问修饰符是什么。
- en: All the accessibility-related features would be not needed unless they brought
    some advantages. And that is what we are going to talk about in the next section –
    about the central concept of object-oriented programming, called encapsulation,
    which would be impossible without accessibility control.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除非可访问性相关的特性带来了一些优势，否则它们是不需要的。这就是我们将在下一节讨论的内容——面向对象编程的中心概念封装的优势。
- en: Encapsulation
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: The concept of OOP was born in an effort to manage the increasing complexity
    of software systems. The concept of data and procedures bundled in an object with
    controlled access to them (called encapsulation) allows better-organized data
    and procedures in layers, some of them hidden, others exposed to an access from
    outside. The accessibility control described in the previous sections was a significant
    part of it. Together with inheritance, interface (also called abstraction), and
    polymorphism, encapsulation became one of the central concepts of OOP.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的概念诞生于管理软件系统日益增长的复杂性的努力中。将数据和程序捆绑在一个对象中，并对它们进行受控访问（称为封装）的概念允许更好地组织数据和程序在层中，其中一些被隐藏，其他则暴露给外部访问。前面章节中描述的可访问性控制是其中的重要部分。连同继承、接口（也称为抽象）和多态性，封装成为面向对象编程的中心概念之一。
- en: There is often no clear-cut separation of one OOP concept from another. Interfaces
    help to hide (encapsulate) the implementation details too. Inheritance, with its
    ability to override and hide methods of the parent classes, adds a dynamic aspect
    to the accessibility. All these three concepts make it possible to add the concept
    of polymorphism—the ability of the same object to present itself as a different
    type, depending on the context (based on inheritance or an implemented interface),
    or change its behavior based on the data availability (using composition—we will
    talk about it in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles—*or method overloading, hiding, and overriding).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很难清晰地将一个面向对象的概念与另一个分开。接口也有助于隐藏（封装）实现细节。继承具有覆盖和隐藏父类方法的能力，为可访问性增加了动态方面。所有这三个概念使得多态的概念成为可能——同一个对象可以根据上下文（基于继承或实现的接口）呈现为不同类型，或者根据数据可用性改变其行为（使用组合——我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论，*面向对象设计（OOD）原则*，或者方法重载、隐藏和覆盖）。
- en: 'But none of the concepts would be possible without encapsulation. That is why
    it is the most fundamental among the four concepts of OOP. Chances are, you will
    hear it mentioned a lot, so we have decided to dedicate this section to the terms
    often used in the context of an encapsulation based on the advantages it provides:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有封装，这些概念都是不可能的。这就是为什么它是面向对象编程的四个概念中最基本的。很有可能，你会经常听到它被提到，所以我们决定专门为这一部分介绍在封装的背景下经常使用的术语，基于它提供的优势：
- en: Data hiding and decoupling
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据隐藏和解耦
- en: Flexibility, maintainability, refactoring
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性，可维护性，重构
- en: Reusability
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Testability
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Data hiding and decoupling
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据隐藏和解耦
- en: When we make object states (values of its fields) and some methods private or
    impose some other measure of restricted access to the internal object data, we
    participate in *data hiding*. The user of the object's functionality can call
    only certain methods based on their accessibility and cannot manipulate the object's
    internal state directly. The object's users may have no idea how exactly the functionality
    is implemented and the data is stored. They pass the required input data to the
    accessible methods and get back the results. This way we *decouple* the internal
    state from its usage and the implementation details from the API.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使对象状态（字段的值）和一些方法私有或对内部对象数据施加一些其他限制访问的措施时，我们参与了*数据隐藏*。对象功能的用户只能根据其可访问性调用特定的方法，并且不能直接操纵对象的内部状态。对象的用户可能不知道功能的具体实现方式和数据的存储方式。他们将所需的输入数据传递给可访问的方法，并获得结果。这样我们就*解耦*了内部状态和其使用，以及API中的实现细节。
- en: Grouping related methods and data in the same class also increases *decoupling*,
    this time between different areas of functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关方法和数据放在同一个类中也增加了*解耦*，这次是在不同功能区域之间。
- en: You may hear the term *tightly coupled* as something that should be allowed
    only when there is no way to avoid it because it usually means that any change
    of one part would require a corresponding change of another part. Even in everyday
    life, we prefer to deal with modularized systems that allow replacing one module
    only without changing any other component of the rest of the system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到*紧耦合*这个术语，只有在无法避免的情况下才应该允许，因为它通常意味着一个部分的任何更改都需要相应地更改另一个部分。即使在日常生活中，我们也更喜欢处理模块化系统，允许仅替换一个模块而不更改其余系统的任何其他组件。
- en: That is why *loose coupling* is usually something programmers prefer although
    it often comes at the price of not being sure that there will be no unexpected
    surprises until the system is tested in all possible execution paths. A well-thought-out
    system of tests that cover the essential use cases usually helps to reduce the
    chance of a defect propagation in production.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*松耦合*通常是程序员喜欢的东西，尽管它经常以不确定系统在所有可能的执行路径中测试之前是否会出现意外惊喜的代价。一个经过深思熟虑的测试系统，覆盖了基本用例，通常有助于减少生产中缺陷传播的机会。
- en: Flexibility, maintainability, and refactoring
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性，可维护性和重构
- en: When we talked about decoupling in the previous section, the idea of flexibility
    and maintainability probably came to mind by association. Loosely coupled systems
    are more flexible and easier to maintain.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一节中谈到解耦时，灵活性和可维护性的概念可能会因为联想而浮现。松耦合的系统更灵活，更易于维护。
- en: 'For example, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, we demonstrated a flexible solution when implementing
    an object factory:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中，*接口、类和对象构造*，我们演示了一种灵活的解决方案，用于实现对象工厂：
- en: '```java'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static Calculator createInstance(){
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator createInstance(){
- en: WhichImpl whichImpl =
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(Utils.class,
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
- en: switch (whichImpl){
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: switch (whichImpl){
- en: 'case multiplies:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 案例乘法：
- en: return new CalculatorImpl();
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: return new CalculatorImpl();
- en: 'case adds:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 案例添加：
- en: return new AnotherCalculatorImpl();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新的AnotherCalculatorImpl();
- en: 'default:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: throw new RuntimeException("Houston, we have another problem."+
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出新的RuntimeException("休斯顿，我们又有问题了。"+
- en: '" We do not have implementation for the key " +'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们没有关键的实现" +'
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL + "值" + whichImpl);
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '```'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is tightly coupled with its `Calculator` interface (its API) only, but that
    is inevitable because it is the contract the implementation must honor. As for
    the implementation inside the factory, it is much freer from any restrictions
    as long as it adheres to the contract.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 它与其`Calculator`接口（其API）紧密耦合，但这是不可避免的，因为这是实现必须遵守的合同。至于工厂内部的实现，只要遵守合同，就可以更自由地进行任何限制。
- en: 'We could create an instance of each of the implementations only once and return
    only that one instance (making each class a singleton). Here is an example of
    `CalculatorImpl` as a singleton:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能创建每个实现的一个实例，并且只返回该实例（使每个类成为单例）。以下是`CalculatorImpl`作为单例的示例：
- en: '```java'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private static Calculator calculator = null;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: private static Calculator calculator = null;
- en: public static Calculator createInstance(){
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator createInstance(){
- en: WhichImpl whichImpl =
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: WhichImpl whichImpl =
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Utils.getWhichImplValueFromConfig(Utils.class,
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
- en: switch (whichImpl){
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: switch (whichImpl){
- en: 'case multiplies:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 案例乘法：
- en: if(calculator == null){
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: if(calculator == null){
- en: calculator = new CalculatorImpl();
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: calculator = new CalculatorImpl();
- en: '}'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return calculator;
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回计算器；
- en: 'case adds:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 案例添加：
- en: return new AnotherCalculatorImpl();
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新的AnotherCalculatorImpl();
- en: 'default:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: throw new RuntimeException("Houston, we have another problem."+
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出新的RuntimeException("休斯顿，我们又有问题了。"+
- en: '" We do not have implementation for the key " +'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们没有关键的实现" +'
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Calculator.CONF_WHICH_IMPL + "值" + whichImpl);
- en: '}'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '}'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or we could add another `Calculator` implementation to the factory as a nested
    class and use it instead of `CalculatorImpl`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将另一个`Calculator`实现作为嵌套类添加到工厂中，并使用它来代替`CalculatorImpl`：
- en: '```java'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static Calculator createInstance(){
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: public static Calculator createInstance(){
- en: String whichImpl = Utils.getStringValueFromConfig(CalculatorFactory.class,
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: String whichImpl = Utils.getStringValueFromConfig(CalculatorFactory.class,
- en: '"calculator.conf", "which.impl");'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '"calculator.conf", "which.impl");'
- en: if(whichImpl.equals("multiplies")){
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(whichImpl.equals("multiplies")){
- en: return new Whatever();
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: return new Whatever();
- en: '} else if (whichImpl.equals("adds")){'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (whichImpl.equals("adds")){'
- en: return new AnotherCalculatorImpl();
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: return new AnotherCalculatorImpl();
- en: '} else {'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: throw new RuntimeException("Houston, we have a problem. " +
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: throw new RuntimeException("休斯顿，我们有问题。" +
- en: '"Unknown key which.impl value " + whichImpl +'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '"未知的键 which.impl 值 " + whichImpl +'
- en: '" is in config.");'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '" is in config.");'
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static class Whatever implements Calculator {
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: static class Whatever implements Calculator {
- en: public static String addOneAndConvertToString(double d){
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: public static String addOneAndConvertToString(double d){
- en: System.out.println(Whatever.class.getName());
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Whatever.class.getName());
- en: return Double.toString(d + 1);
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: return Double.toString(d + 1);
- en: '}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int multiplyByTwo(int i){
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: public int multiplyByTwo(int i){
- en: System.out.println(Whatever.class.getName());
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Whatever.class.getName());
- en: return i * 2;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 2;
- en: '}'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: And the client code of this factory would never know the difference unless it
    prints out information about the class using the `getClass()` method on the object
    returned from the factory. But that is another story. Functionally, our new implementation
    of `Whatever` would work as an old one.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个工厂的客户端代码永远不会知道这种区别，除非它通过对从工厂返回的对象使用`getClass()`方法打印类的信息。但这是另一回事。从功能上讲，我们的`Whatever`的新实现将像旧的一样工作。
- en: 'And that is actually a common practice—to change internal implementation from
    one release to another. There are bug fixes, of course, and new functionality
    added. And as the code of the implementation is evolving, its programmers are
    constantly watching for the possibility of refactoring. In computer science, factoring
    is a synonym of decomposition, which is breaking a complex code into simpler parts
    with the purpose of making the code more readable and maintainable. For example,
    let''s assume we were asked to write a method that accepts two parameters of the `String`
    type (each represents an integer) and returns their sum as an integer too. After
    thinking for a moment, we decided to do it this way:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个常见的做法——从一个版本到另一个版本改变内部实现。当然有bug修复，还有新功能添加。随着实现代码的演变，程序员们不断地关注重构的可能性。在计算机科学中，factoring
    是 decomposition 的同义词，它是将复杂的代码分解成更简单的部分，目的是使代码更易读和易维护。例如，假设我们被要求编写一个方法，接受两个`String`类型的参数（每个表示一个整数），并将它们的和作为整数返回。思考了一会儿后，我们决定这样做：
- en: '```java'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public long sum(String s1, String s2){
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: public long sum(String s1, String s2){
- en: int i1 = Integer.parseInt(s1);
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = Integer.parseInt(s1);
- en: int i2 = Integer.parseInt(s1);
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = Integer.parseInt(s1);
- en: return i1 + i2;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: return i1 + i2;
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But then we have asked for a sample of possible input values, so we can test
    our code in the condition close to production. It turned out that some of the
    values can be up to 10,000,000,000, which exceeds 2,147,483,647 (the maximum `Integer.MAX_VALUE` int
    value Java allows). So we have changed our code to the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 但后来我们要求提供可能输入值的样本，这样我们就可以在接近生产条件的情况下测试我们的代码。结果发现，一些值可能高达10,000,000,000，这超过了2,147,483,647（Java允许的最大`Integer.MAX_VALUE`
    int值）。因此，我们将我们的代码更改为以下内容：
- en: '```java'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public long sum(String s1, String s2){
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: public long sum(String s1, String s2){
- en: long l1 = Long.parseLong(s1);
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: long l1 = Long.parseLong(s1);
- en: long l2 = Long.parseLong(s2);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: long l2 = Long.parseLong(s2);
- en: return l1 + l2;
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: return l1 + l2;
- en: '}'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now our code can handle values up to 9,223,372,036,854,775,807 (which is `Long.MAX_VALUE`).
    We deployed the code to production and it worked just fine for several months,
    used by a big software system that processes statistics. Then the system switched
    to a new source of data and the code started breaking. We investigated and found
    out that a new source of data yields values that can include letters and some
    other characters. We have tested our code for such cases and discovered that the
    following line throws `NumberFormatException`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码可以处理高达9,223,372,036,854,775,807的值（即`Long.MAX_VALUE`）。我们将代码部署到生产环境，它在几个月内都运行良好，被一个处理统计数据的大型软件系统使用。然后系统切换到了新的数据源，代码开始出现问题。我们调查后发现，新的数据源产生的值可能包含字母和其他一些字符。我们已经为这种情况测试了我们的代码，并发现以下行会抛出`NumberFormatException`：
- en: '```java'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long l1 = Long.parseLong(s1);
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: long l1 = Long.parseLong(s1);
- en: '```'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We discussed the situation with the domain experts and they suggested we record
    the values that are not integer, skip them, and continue the sum calculations.
    So, we have fixed our code, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与领域专家讨论了这种情况，他们建议我们记录不是整数的值，跳过它们，并继续进行求和计算。因此，我们已经修复了我们的代码，如下所示：
- en: '```java'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public long sum(String s1, String s2){
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: public long sum(String s1, String s2){
- en: long l1 = 0;
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: long l1 = 0;
- en: try{
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: l1 = Long.parseLong(s1);
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: l1 = Long.parseLong(s1);
- en: '} catch (NumberFormatException ex){'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (NumberFormatException ex){'
- en: //make a record to a log
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: //记录日志
- en: '}'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: long l2 = 0;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: long l2 = 0;
- en: try{
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: l2 = Long.parseLong(s2);
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: l2 = Long.parseLong(s2);
- en: '} catch (NumberFormatException ex){'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (NumberFormatException ex){'
- en: //make a record to a log
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: //记录日志
- en: '}'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return l1 + l2;
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 返回l1 + l2;
- en: '}'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have quickly released the code to production, but for the next release got
    new requirements: the input `String` values can contain decimal numbers. So, we
    have changed the way we process the input `String` values by assuming they carry
    decimal values (which cover integer values too) and refactored the code, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速将代码发布到生产环境，但在下一个版本中得到了新的要求：输入的`String`值可以包含小数。因此，我们已经改变了处理输入`String`值的方式，假设它们包含小数值（也包括整数值），并重构了代码，如下所示：
- en: '```java'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private long getLong(String s){
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: private long getLong(String s){
- en: double d = 0;
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: double d = 0;
- en: try{
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试{
- en: d = Double.parseDouble(s);
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: d = Double.parseDouble(s);
- en: '} catch (NumberFormatException ex){'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (NumberFormatException ex){'
- en: //make a record to a log
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: //记录日志
- en: '}'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return Math.round(d);
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Math.round(d);
- en: '}'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public long sum(String s1, String s2){
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: public long sum(String s1, String s2){
- en: return getLong(s1) + getLong(s2);
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 返回getLong(s1) + getLong(s2);
- en: '}'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is what refactoring does. It restructures the code without changing its
    API. As new requirements keep coming in, we can change the `getLong()` method
    without even touching the `sum()` method. We also can reuse the `getLong()` method
    in other places, and that is going to be the topic of the next section.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是重构的作用。它重新构造代码而不改变其API。随着新的需求不断出现，我们可以改变`getLong()`方法，甚至不用触及`sum()`方法。我们还可以在其他地方重用`getLong()`方法，这将是下一节的主题。
- en: Reusability
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性
- en: 'Encapsulation definitely makes it easier to achieve reusability because it
    hides the implementation details. For example, the `getLong()` method we wrote
    in the previous section can be reused by another method of the same class:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 封装绝对使得实现可重用性更容易，因为它隐藏了实现细节。例如，我们在上一节中编写的`getLong()`方法可以被同一类的另一个方法重用：
- en: '```java'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public long sum(int i, String s2){
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: public long sum(int i, String s2){
- en: return i + getLong(s2);
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 返回i + getLong(s2);
- en: '}'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It can even be made public and used by other classes, like in the following
    line:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以被设为公共的并被其他类使用，就像以下行一样：
- en: '```java'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = new Ch07DemoApp().getLong("23", "45.6");
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: int i = new Ch07DemoApp().getLong("23", "45.6");
- en: '```'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That would be an example of a composition when some functionality is built
    (composed) using methods of different classes not related by inheritance. And,
    since it does not depend on the object state (such a method is called stateless),
    it can be made static:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个组合的例子，当某些功能是使用不相关的类的方法构建（组合）时。而且，由于它不依赖于对象状态（这样的方法称为无状态），它可以被设为静态：
- en: '```java'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = Ch07DemoApp.getLong("23", "45.6");
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: int i = Ch07DemoApp.getLong("23", "45.6");
- en: '```'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Well, if the method is used concurrently by several other methods at runtime,
    even such a simple code may need to be protected (synchronized) against parallel
    usage. But such considerations are outside of the scope of this book. For now,
    if in doubt, do not make the method static.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果该方法在运行时被几个其他方法同时使用，即使是这样一个简单的代码也可能需要受到保护（同步）以防并行使用。但这些考虑超出了本书的范围。现在，如果有疑问，不要将方法设为静态。
- en: If you read about the history of object-oriented programming, you will find
    that inheritance was originally tasked, among other things, to be the primary
    mechanism of code reuse. And it does the job. A child inherits (reuses) all the
    methods of its parent and overrides only those that need to be overridden for
    the child's specialization.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解面向对象编程的历史，你会发现继承最初的任务之一是成为代码重用的主要机制。它做到了。子类继承（重用）其父类的所有方法，并且只覆盖那些需要为子类专门化的方法。
- en: But in practice, it seems that other reusability techniques, similar to those
    demonstrated earlier, are more popular, especially for cases when the reused method
    is stateless. We will talk more about the reasons for that in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，实践中似乎更受欢迎的是其他可重用性技术，尤其是对于重用方法是无状态的情况。我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中更多地讨论这些原因，*面向对象设计（OOD）原则*。
- en: Testability
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可测试性
- en: Code testability is another area where encapsulation helps. If the implementation
    details were not hidden, we would need to test every single line of code and change
    the test every time we change any line of the implementation. But hiding the details
    behind the facade of the API allows us to focus only on the test cases that are
    required and limited by the set of possible input data (parameter values).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可测试性是另一个封装有所帮助的领域。如果实现细节没有被隐藏，我们将需要测试每一行代码，并且每次改变实现的任何一行时都需要改变测试。但是将细节隐藏在API的外观后面，使我们只需要专注于所需的测试用例，并且受到可能的输入数据（参数值）的限制。
- en: Also, there are frameworks that allow us to create an object that returns a
    certain result based on the certain value of the input parameters. Mockito is
    a popular framework that does it ([http://site.mockito.org](http://site.mockito.org)).
    Such objects are called mock objects. They are especially helpful when you need
    to get certain results from methods of one object to test other methods, but you
    cannot run the actual implementation of the methods you use as the source of data
    because you do not have the necessary data in the database, for example, or it
    requires some complicated setup. To get around the problem, you can replace the
    actual implementation of certain methods—mock them—with one that returns the data
    you need unconditionally or in response to certain input data. Without the encapsulation,
    such simulation of a method behavior may be impossible because the client code
    would be tied to the specific implementation and you would not be able to change
    it without changing the client code.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些框架允许我们创建一个对象，根据输入参数的某个值返回某个结果。Mockito是一个流行的框架，它可以做到这一点（[http://site.mockito.org](http://site.mockito.org)）。这样的对象被称为模拟对象。当你需要从一个对象的方法中获得某些结果来测试其他方法时，它们尤其有帮助，但你不能运行你用作数据源的方法的实际实现，因为你没有数据库中需要的数据，或者它需要一些复杂的设置。为了解决这个问题，你可以用返回你需要的数据的方法替换某些方法的实际实现-模拟它们-无条件地或者响应于某些输入数据。没有封装，这样模拟方法行为可能是不可能的，因为客户端代码将与特定实现绑定，你将无法在不改变客户端代码的情况下进行更改。
- en: Exercise – Shadowing
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-阴影
- en: Write the code that demonstrates variable shadowing. We have not talked about
    it, so you will need to do some research.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 编写演示变量阴影的代码。我们还没有讨论过它，所以你需要做一些研究。
- en: Answer
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here is one possible solution:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的解决方案：
- en: '```java'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ShadowingDemo {
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类ShadowingDemo {
- en: private String x = "x";
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串x = "x";
- en: public void printX(){
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: public void printX(){
- en: System.out.println(x);
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);
- en: String x = "y";
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串x = "y";
- en: System.out.println(x);
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);
- en: '}'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you run `new ShadowingDemo().printX();`, it will print `x` first, then `y` because
    the local variable `x` in the following line shadows the `x` instance variable:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行`new ShadowingDemo().printX();`，它将首先打印`x`，然后打印`y`，因为以下行中的局部变量`x`遮蔽了`x`实例变量：
- en: '```java'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String x = "y";
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: String x = "y";
- en: '```'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Please note that shadowing can be a source of a defect or can be used for the
    benefit of the program. Without it, you would be not able to use a local variable
    identifier that is already used by an instance variable. And here is another example
    of a case where variable shadowing helps:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，遮蔽可能是程序的缺陷来源，也可以用于程序的利益。如果没有它，您将无法使用已经被实例变量使用的局部变量标识符。这里是另一个变量遮蔽有帮助的情况的例子：
- en: '```java'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private String x = "x";
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: private String x = "x";
- en: public void setX(String x) {
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: public void setX(String x) {`;
- en: this.x = x;
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: this.x = x;
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `x` local variable (parameter) shadows the `x` instance variable. It allows
    using the same identificator for a local variable name that has been already used
    for an instance variable name. To avoid possible confusion, it is recommended
    to refer to an instance variable using the keyword `this` as we did in the example
    above.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`局部变量（参数）遮蔽了`x`实例变量。它允许使用相同的标识符作为已经用于实例变量名称的局部变量名称。为了避免可能的混淆，建议使用关键字`this`来引用实例变量，就像我们在上面的示例中所做的那样。'
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about one of the fundamental features of an object-oriented
    language – the rules of accessibility of classes, interfaces, their members, and
    constructors. You now can import classes and interfaces from other packages and
    avoid using their fully qualified names. All that discussion allowed us to introduce
    the central concept of OOP—encapsulation. With that, we can start an informed
    discussion of **object-oriented design** (**OOD**) principles.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了面向对象语言的基本特性之一 - 类、接口、成员和构造函数的可访问性规则。现在您可以从其他包中导入类和接口，并避免使用它们的完全限定名称。所有这些讨论使我们能够介绍面向对象编程的核心概念
    - 封装。有了这个，我们可以开始对面向对象设计（OOD）原则进行有根据的讨论。
- en: The next chapter presents a higher-level view of Java programming. It discusses
    the criteria of a good design and provides a guide to the well-proven OOD principles.
    Each of the design principles is described in detail and illustrated using a corresponding
    code example.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了Java编程的更高层次视图。它讨论了良好设计的标准，并提供了经过验证的OOD原则指南。每个设计原则都有详细描述，并使用相应的代码示例进行说明。
