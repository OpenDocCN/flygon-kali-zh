- en: Authoring Tutorials and Live Coding Hacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写教程和实时编码黑客
- en: This is the final chapter of this book for Webpack 5.0\. By now, you may feel
    like an expert, but proof of your mastery comes both from your ability to take
    ownership of the code itself and to customize the platform, and even to hack into
    it. A purist might shy away from terms such as *hacking* in favor of workarounds
    or patching, but we are essentially talking about the same subject (except explaining
    to the layperson that you have hacked Webpack during live production would certainly
    impress the most ardent skeptic of your coding superpowers).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Webpack 5.0的最后一章。到目前为止，您可能已经感觉自己是一个专家，但是您的掌握能力不仅来自于您对代码本身的掌握，还包括自定义平台的能力，甚至是对其进行黑客。纯粹主义者可能会避免使用“黑客”这样的术语，而更倾向于使用变通方法或修补程序，但我们基本上讨论的是同一个主题（除非向外行解释您在实时生产中黑客了Webpack肯定会给编码超能力的最坚定的怀疑者留下深刻印象）。
- en: That being said, this chapter is a compilation of the hardest things to do in
    Webpack and the easiest ways to accomplish them. We will begin with authoring
    libraries and move on to custom loaders, something discussed in this guide already,
    particularly with the use of Babel's **application programming interface** (**API**).
    This chapter will, however, discuss a more native approach to customization without
    the need for an API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，本章是Webpack中最难做的事情和最简单的实现方法的汇编。我们将从编写库开始，然后转向自定义加载程序，这在本指南中已经讨论过，特别是使用Babel的**应用程序编程接口**（**API**）。然而，本章将讨论一种更本地的定制方法，而无需API。
- en: We will, naturally, cover some topics already discussed in some detail in this
    guide, such as testing and shimming, but this guide will offer a little more salience
    and relevance to customization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将涵盖一些在本指南中已经详细讨论过的主题，例如测试和shimming，但是本指南将更加突出和相关于定制。
- en: From there, we will cover some very interesting hacks, specifically when working
    with live publications in a **Hot Module Replacement** (**HMR**)-enabled environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将涵盖一些非常有趣的黑客，特别是在**热模块替换**（**HMR**）启用的环境中进行实时发布时。
- en: 'Some of the topics covered in this final chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些主题如下：
- en: Authoring libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写库
- en: Custom loaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义加载程序
- en: Live coding hacks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时编码黑客
- en: Authoring libraries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写库
- en: This section of this chapter will be of great use to anyone hoping to streamline
    their bundling strategy. It is not very well known that Webpack can be used for
    bundling both libraries and applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分对于希望简化其捆绑策略的任何人都非常有用。人们并不太了解Webpack可以用于捆绑库和应用程序。
- en: We will begin with a hypothetical custom library project, which we'll call `numbers-to-text`.
    It will work by converting numerals from, say, `1` to `5` to a textual representation
    of the number, such as `3` to `three`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个假设的自定义库项目开始，我们将其称为`numbers-to-text`。它将通过将数字从`1`到`5`转换为数字的文本表示，例如将`3`转换为`three`。
- en: 'Let''s discuss each task in detail and explain what is happening in the code,
    with examples to help us understand with greater clarity exactly what is happening
    and how the code behaves. We will proceed as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每个任务，并解释代码中发生的事情，通过示例帮助我们更清楚地理解发生了什么以及代码的行为如何。我们将按以下方式进行：
- en: 'We will begin by getting our project structure in line. The basic project structure
    should look like this:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先整理我们的项目结构。基本项目结构应如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the structure may look different from the previous tutorial—namely,
    the presence of the `ref.json` file. You will need to create those extra files
    if you don't have them before we go any further.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结构可能与以前的教程不同，特别是`ref.json`文件的存在。在继续之前，您需要创建这些额外的文件。
- en: 'Next, we come back to the **command-line interface** (**CLI**), and we first
    need to initialize `npm`, then make sure we have installed Webpack and `lodash`.
    If you have already installed this by following the example in previous chapters,
    then don''t worry—duplicate installation attempts will only overwrite the last
    and shouldn''t cause any harm at all. Run the following code:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们回到**命令行界面**（**CLI**），首先需要初始化`npm`，然后确保我们已安装了Webpack和`lodash`。如果您已经按照以前章节中的示例安装了这些内容，那就不用担心了，重复安装尝试只会覆盖最后一次，并不会造成任何伤害。运行以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That being done, we avert our attention to the newly built `src/ref.json` **JSON** file.
    This is the essential data of the custom library. It should look like the following
    example:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些工作后，我们将注意力转向新构建的`src/ref.json` **JSON**文件。这是自定义库的基本数据。它应该看起来像以下示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this constitutes a simple list of options representing a number,
    with a corresponding written word version of that number. This will form the backbone
    of our very simple library structure, to demonstrate the concept in principle.
    Once the tutorial is complete, you should naturally see how you can adapt the
    library to your needs, no matter how complex.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这构成了一个简单的选项列表，代表一个数字，以及该数字的对应文字版本。这将构成我们非常简单的库结构的支柱，以原则上演示概念。一旦教程完成，您应该自然地看到如何根据需要调整库，无论多么复杂。
- en: 'Now, we need to make an index file (such as `src/index.js`). You should follow
    the coding displayed in this block:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要制作一个索引文件（例如`src/index.js`）。您应该按照此块中显示的编码进行操作：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see from the preceding code how the index file essentially contains
    a series of `export` and `return` functions related to the **JSON** file contents.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的代码中看到索引文件实质上包含一系列与**JSON**文件内容相关的`export`和`return`函数。
- en: 'Now, we need to define the usage specification. This is done as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义使用规范。操作如下：
- en: 'ES2015 module import:'
  id: totrans-25
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015模块导入：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'CommonJS module require:'
  id: totrans-27
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块要求：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the following snippet of code, in the same file, to set the functions when
    using `AMD`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的文件中使用以下代码片段来设置使用`AMD`时的函数：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The user can also use the library by loading it via a `script` tag, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以通过`script`标签加载库，如下所示：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the most common way in which a library is loaded, and, as a JavaScript
    developer, it's something that should be second nature to follow. That being said,
    it can be configured to expose a property in the global object for Node.js or
    as a property in a `this` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加载库的最常见方式，作为JavaScript开发人员，这应该是一种应该很容易遵循的事情。也就是说，它可以配置为在全局对象中公开属性，用于Node.js，或者作为`this`对象中的属性。
- en: This takes us to the basic configuration for the library. There is more than
    one level of configuration for authorizing this library, so this is just the first
    step.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们进入库的基本配置。授权这个库有多个级别的配置，所以这只是第一步。
- en: The basic configuration
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本配置
- en: 'As with any Webpack project, we need to configure it. This requires some extra
    attention when dealing with a custom library. Several unusual things must be achieved
    with this configuration as opposed to a typical one. Let''s consider these objectives
    now. The library should be bundled in a way that achieves the following goals:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何Webpack项目一样，我们需要对其进行配置。与典型的配置相比，处理自定义库时需要实现一些不寻常的事情。现在让我们考虑这些目标。库应该以一种实现以下目标的方式捆绑：
- en: The use of externals to avoid bundling `lodash` so the user is required to load
    it
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部来避免捆绑`lodash`，因此用户需要加载它
- en: Specifying the external limitations of the library
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定库的外部限制
- en: Exposing the library as a variable called `numbersToText`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库公开为名为`numbersToText`的变量
- en: Setting the library name to `numbers-to-text`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库名称设置为`numbers-to-text`
- en: Permitting the access to the **Node.js** library indie
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在**Node.js**库中访问
- en: 'Also, note that the user must be able to access and have use of the library
    in the following ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意用户必须能够以以下方式访问并使用库：
- en: Through importing `numbersToText` from `numbers-to-text` as an **ECMAScript
    2015** (**ES 2015**) module
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从`numbers-to-text`导入`numbersToText`作为**ECMAScript 2015** (**ES 2015**)模块
- en: Through the CommonJS module, such as using the `require('webpack-numbers')`method
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过CommonJS模块，例如使用`require('webpack-numbers')`方法
- en: Through a global variable when included through such methods as a script tag
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过全局变量，当通过脚本标签包含时
- en: 'With all that in mind, the first thing to do is set up the Webpack configuration
    through the normal files we use for this `webpack.config.js` file, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，首先要做的是通过我们用于`webpack.config.js`文件的常规文件设置Webpack配置，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That is the basic configuration, but we''ll now move on to the next goal identified:
    the externalizing of `lodash`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本配置，但现在我们将转向下一个确定的目标：将`lodash`外部化。
- en: Using externals to avoid bundling lodash
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部来避免捆绑lodash
- en: If you now perform a build, you will see that quite a large bundle is created.
    Inspecting the file reveals that `lodash` has been bundled alongside it. For the
    sake of this tutorial, `lodash` is better treated as a peer dependency. This essentially
    means that the user would have `lodash` installed, effectively giving control
    of this external library to the user of this library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在执行构建，你会看到创建了一个相当大的捆绑包。检查文件会发现`lodash`已经与其捆绑在一起。出于本教程的目的，最好将`lodash`视为对等依赖项。这基本上意味着用户必须安装`lodash`，有效地将这个外部库的控制权交给了这个库的用户。
- en: 'This can be done through the configuration of externals, as in `webpack.config.js`,asfollows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过外部的配置来完成，如`webpack.config.js`中所示，如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code means that the library expects a dependency named `lodash`
    to be available in the user's environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码意味着库期望用户环境中有一个名为`lodash`的依赖项。
- en: Note that externals may be specified as an array if the plan is to use the library
    as a dependency in a parallel Webpack bundle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果计划在并行的Webpack捆绑包中将库用作依赖项，则可以将外部指定为数组。
- en: It's also important to specify a limitation on the externals, and we will discuss
    this now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部指定限制也很重要，我们现在将讨论这一点。
- en: Specifying external limitations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定外部限制
- en: 'You may work with libraries that use several files from a dependency, such
    as in the following descriptive block:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多个文件的库，例如以下描述性块中的文件：
- en: '`import A from ''library/one'';`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import A from ''library/one'';`'
- en: '`import B from ''library/two'';`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import B from ''library/two'';`'
- en: 'In this case, they can''t be excluded from the bundle by specifying the library
    in the externals. They would need to be excluded one at a time or by using a regular
    expression,* s*uch as with the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它们不能通过在外部指定库来从捆绑包中排除。它们需要逐个排除，或者使用正则表达式，例如以下示例：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once that is accomplished, we need to expose the library or allow it to be loaded
    into our frontend. This is covered in the next subsection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们需要公开库或允许它加载到我们的前端。这将在下一小节中介绍。
- en: Exposing the library
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开库
- en: 'Exposing a library is something already discussed in this guide, but if you''re
    jumping into this chapter, you may be puzzled. We are simply allowing our application
    to load the library from an external source, as with any library externally loading
    into a web page, for example. The library should be compatible with different
    environments, such as **CommonJS**, **MD**, or **Node.js** to ensure the widespread
    usability of the library. To ensure this, proceed as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 公开库是本指南中已经讨论过的内容，但如果您跳到本章，您可能会感到困惑。我们只是允许我们的应用程序从外部源加载库，就像任何外部加载到网页中的库一样。库应该与不同的环境兼容，例如**CommonJS**、**MD**或**Node.js**，以确保库的广泛可用性。为了确保这一点，按照以下步骤进行：
- en: 'The `library` property should be added inside the output in the `webpack.config.js` 
    configuration file, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在`webpack.config.js`配置文件的输出中添加`library`属性，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The library setup is related to configuration. In most cases, specifying one
    entry point is enough. Multiple-part libraries are possible; however, it is simpler
    to expose partial exports through an index script, serving as the entry point.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 库设置与配置相关。在大多数情况下，指定一个入口点就足够了。多部分库是可能的；然而，通过一个索引脚本公开部分导出更简单，作为入口点。
- en: It is unwise to attempt to use an array to a library entry point, as it won't
    compile very well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用数组作为库入口点是不明智的，因为它不会编译得很好。
- en: This achieves the exposure of the library bundle as a global variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了将库捆绑包公开为全局变量。
- en: 'You can make your library compatible with other environments by adding a `libraryTarget`
    property to the configuration file, adding different options on how they expose
    the library, using `webpack.config.js`, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过向配置文件添加`libraryTarget`属性，以不同的选项公开库，使用`webpack.config.js`，使您的库与其他环境兼容，如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the configuration set, we now need to expose the library. Note that this
    can be done in the following ways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配置设置后，我们现在需要公开库。请注意，可以通过以下方式完成：
- en: As a variable—as a global variable made available by a script tag, such as `libraryTarget:'var'`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为变量——作为脚本标签提供的全局变量，例如`libraryTarget:'var'`
- en: As an object—available through a `this` object, such as `libraryTarget:'this'`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对象——通过`this`对象可用，例如`libraryTarget:'this'`
- en: Window—this is available through the `window` object, such as `libraryTarget:'window'`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Window——通过`window`对象可用，例如`libraryTarget:'window'`
- en: '**Universal Module Definition** (**UMD**)—available after CommonJS or AMD `require`
    statements, such as `libraryTarget:''umd''`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用模块定义**（**UMD**）—在CommonJS或AMD `require`语句之后可用，例如`libraryTarget:''umd''`'
- en: If you set the library but don't do this for the `libraryTarget` function, the
    latter will default to a variable, as specified in the output configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了库但没有为`libraryTarget`函数执行此操作，后者将默认为变量，如输出配置中所指定的那样。
- en: Naming the library and working with Node.js
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名库和使用Node.js
- en: 'As explained, we are now in the last steps of this authoring. The optimization
    of the output should be made by following the guide as we proceed. While we do
    this, we will add in the path to the bundle output as the package''s main field
    with the `package.json` file, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所解释的，我们现在处于编写的最后步骤。随着我们的进行，应该按照指南进行输出的优化。在这样做的同时，我们将在`package.json`文件中将捆绑输出的路径添加为包的主字段，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The option key named `"main"` in the preceding code block refers to the standard
    we retrieve from the `package.json` file. The `"module"` key refers to a proposal
    that allows the JavaScript environment to upgrade, to be able to use ES2015 modules
    without harming any backward-compatibility capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码块中名为`"main"`的选项键指的是我们从`package.json`文件中检索到的标准。`"module"`键指的是一个提案，允许JavaScript环境升级，能够在不损害任何向后兼容性能力的情况下使用ES2015模块。
- en: In the case of the `"module"` property, this should point to a script that uses
    ES2015 module syntax throughout, but no other syntax that is not yet supported
    by browsers or Node.js. This will enable Webpack to parse module syntax and allow
    lighter bundles through tree shaking, as users are likely only consuming certain
    parts of any given library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`"module"`属性的情况下，这应该指向一个使用ES2015模块语法的脚本，但不应使用浏览器或Node.js尚不支持的其他语法。这将使Webpack能够解析模块语法，并通过摇树来允许更轻的捆绑包，因为用户可能只使用任何给定库的某些部分。
- en: Once this is done, the bundle can be published as an `npm` package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，捆绑包可以作为`npm`包发布。
- en: You have learned how to set up and configure your first custom library using
    a JSON file with corresponding numbers and text, including exposing the new library
    in your frontend and specifying the limitations in scope for the library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何使用具有相应数字和文本的JSON文件设置和配置您的第一个自定义库，包括在前端公开新库并指定库的范围限制。
- en: In a related sphere, let's now talk about custom loaders.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个相关的领域，现在让我们谈谈自定义加载器。
- en: Custom loaders
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义加载器
- en: Loaders have been discussed in detail in previous chapters of this guide. However,
    we have only alluded to the customization or authoring of them. This will be increasingly
    important to at least demonstrate your mastery of Webpack, so we should discuss
    it now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器在本指南的先前章节中已经详细讨论过。但是，我们只是提到了它们的定制或编写。至少展示您对Webpack的掌握至关重要，因此我们现在应该讨论一下。
- en: 'The following tutorial will be structured like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下教程将按照以下结构进行：
- en: Setup
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置
- en: Simple usage
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单使用
- en: Complex usage
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂使用
- en: Guidelines
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指南
- en: The *Guidelines* section will itself be subcategorized, but for now, let's begin
    with the setup.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*指南*部分本身将被细分，但现在，让我们从设置开始。'
- en: Setup
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'The best way to start this section is to look at how we can develop and test
    a loader locally. This is a nice and palatable way to begin, and we will proceed
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 开始本节的最佳方法是看看我们如何在本地开发和测试加载器。这是一个很好的和可接受的开始方式，我们将按照以下步骤进行：
- en: 'When testing a single loader, you can simply use a path to resolve to a local
    file within a rule object in **`webpack.config.js`**,as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试单个加载器时，您可以简单地在**`webpack.config.js`**的规则对象中使用路径来解析到本地文件，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To test multiple loaders, you can utilize the `resolveLoader.modules` configuration,
    whereby Webpack will search for loaders in `webpack.config.js`. For example, if
    you had a local directory in your project with a loader inside of it, the code
    would look like this:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试多个加载器，可以利用`resolveLoader.modules`配置，Webpack将在`webpack.config.js`中搜索加载器。例如，如果您的项目中有一个包含加载器的本地目录，代码将如下所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That should be all you need to begin. However, if you've already created a separate
    repository for your loader, you could use an `npm` link to the project in which
    you'd like to run the test.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是你开始的所有内容。但是，如果您已经为您的加载器创建了一个单独的存储库，您可以在您想要运行测试的项目中使用`npm`链接到该项目。
- en: There's more than one methodology depending on the usage of the loader, so—naturally—we
    will begin with simple usage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据加载器的使用方式，有不止一种方法，因此——自然地——我们将从简单的使用开始。
- en: Simple usage
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单使用
- en: The idea of simple loaders has already been alluded to, this being that a loader
    is more useful when it performs a very simple and specific task. This will make
    testing easier and, as there are so many, they can be *chained* to others in a
    more complex usage to perform a greater variety of tasks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 简单加载器的概念已经被提到过，即加载器在执行非常简单和特定的任务时更有用。这将使测试更容易，因为有这么多加载器，它们可以*链接*到其他加载器以执行更多样的任务。
- en: When a single loader is applied to the resource, the loader is called with only
    one parameter. This is a string containing the content of the resource being loaded.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当单个加载器应用于资源时，加载器只会被调用一个参数。这是一个包含正在加载的资源内容的字符串。
- en: Synchronous loaders can return a single value representing the transformed module.
    In more complex cases, the loader can return any number of values by using the
    following function: `this.callback(err, values...)`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同步加载器可以返回表示转换模块的单个值。在更复杂的情况下，加载器可以通过使用以下函数返回任意数量的值：`this.callback(err, values...)`。
- en: Errors are then either passed to the function or thrown in a synchronized loader.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后错误要么传递给函数，要么在同步加载器中抛出。
- en: In this case, the loader is expected to give back one or two values. The first
    value is some resulting JavaScript code as a string. The second value is optional
    and results in a `SourceMap` and JavaScript object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，加载器预计会返回一个或两个值。第一个值是一些作为字符串的结果JavaScript代码。第二个值是可选的，会产生一个`SourceMap`和JavaScript对象。
- en: Loaders tend to get more complex in situations where they are chained. When
    discussing complex usage of custom loaders, that would be a good place to start,
    so let's do that now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载器被链接的情况下，加载器往往变得更加复杂。当讨论自定义加载器的复杂用法时，这将是一个很好的开始，所以现在让我们开始吧。
- en: Complex usage
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂用法
- en: As discussed in the previous subsection, *Simple usage*, complex usage generally
    refers to the use of a loader in context with another or a set of loaders in a
    chained pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所讨论的，*简单用法*，复杂用法通常指的是在上下文中使用加载器或一组加载器进行链接模式。
- en: When multiple loaders are chained, it is important to remember that they are
    executed in reverse order!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个加载器被链接在一起时，重要的是要记住它们是以相反的顺序执行的！
- en: 'This will be either right to left or bottom to top, depending on the array
    format you use. For instance, the following will apply:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是从右到左或从下到上，取决于您使用的数组格式。例如，以下将适用：
- en: The last loader, which is called by the script first, will be passed the contents
    of the raw resource (the data or script being run by the loader).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个加载器首先被脚本调用，将传递原始资源的内容（加载器运行的数据或脚本）。
- en: The first loader, called last, is expected to return JavaScript and an optional
    source map.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个加载器，称为最后一个，预计会返回JavaScript和一个可选的源映射。
- en: The loaders in between will be executed with the result(s) of the previous loader
    in the chain.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的加载器将使用链中前一个加载器的结果进行执行。
- en: So, in the following common example, `foo-loader` would be passed the raw resource,
    and `bar-loader` would receive the output of `foo-loader` and return the final
    transformed module and a source map, if necessary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在以下常见示例中，`foo-loader`将传递原始资源，而`bar-loader`将接收`foo-loader`的输出，并返回最终转换的模块和源映射（如果需要）。
- en: 'To chain loaders this way, start with the `webpack.config.js` configuration
    file, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式链接加载器，从`webpack.config.js`配置文件开始，就像这样：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's the configurations, but as chained loaders are complex by nature, it's
    good to follow a standard. What follows is a set of guidelines that will help
    your project come together without fraying at the edges.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置，但由于链接加载器本质上是复杂的，最好遵循一个标准。接下来是一组指南，将帮助您的项目在不受影响的情况下完成。
- en: Guidelines
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南
- en: 'The following guidelines should be followed when writing a loader. They are
    ordered in terms of importance, and some only apply in certain scenarios:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写加载器时，应遵循以下指南。它们按重要性排序，有些只适用于特定情况：
- en: Simplifying the purpose of the loader
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化加载器的目的
- en: Utilizing chaining
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用链接
- en: Modular outputting
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化输出
- en: Ensuring statelessness
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保无状态
- en: Employing loader utilities
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载器实用程序
- en: Marking loader dependencies
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记加载器依赖关系
- en: Resolving module dependencies
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决模块依赖关系
- en: Extracting common code
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取公共代码
- en: Avoiding absolute paths at all costs!
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不惜一切代价避免绝对路径！
- en: Using peer dependencies
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对等依赖
- en: Let's go through each one in more detail, starting with simplification.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论每一个，从简化开始。
- en: Simplifying the purpose of the loader
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化加载器的目的
- en: Loaders work best when they perform a simple and clear task. This can make the
    job of maintaining each loader simpler, and also permits chaining for use in more
    complex tasks. This is because there may be many different loaders specific to
    the different tasks; so, to allow versatility, they are often used in sequence.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器在执行简单和清晰的任务时效果最佳。这可以使每个加载器的维护工作更简单，也可以允许链式使用在更复杂的任务中。这是因为可能有许多不同的加载器针对不同的任务；因此，为了允许多样性，它们经常被顺序使用。
- en: 'Therefore, much as with Webpack bundles, they should be modular. Therefore,
    the specific task they perform can be isolated and refined, which will also allow
    more ubiquitous application when used in a chain with other loaders. This brings
    us to the next concept: the chaining of a loader.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像Webpack捆绑包一样，它们应该是模块化的。因此，它们执行的特定任务可以被隔离和完善，这也将允许在与其他加载器链式使用时更广泛地应用。这将引出下一个概念：加载器的链接。
- en: Utilizing chaining
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用链接
- en: Take advantage of the fact that loaders can be chained together. Instead of
    writing a single loader that tackles many tasks, write multiple loaders. Isolating
    them not only keeps each loader simple but may also allow them to be used for
    something more varied.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 利用加载器可以链接在一起的事实。不要编写一个处理多个任务的单个加载器，而是编写多个加载器。将它们隔离开不仅使每个加载器简单，还可以使它们用于更多样的任务。
- en: 'When rendering a template file with data specified via loader options or query
    parameters, for example, it could be written as a single loader that compiles
    the template from source, executes it, and returns a module that exports a string
    containing the HTML code. However, in the following guidelines, a simple `apply-loader`
    exists that can be chained with other open source loaders:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用加载程序选项或查询参数指定数据来呈现模板文件时，可以编写为单个加载程序，该加载程序从源代码编译模板，执行它，并返回一个导出包含HTML代码的字符串的模块。但是，在以下准则中，存在一个简单的`apply-loader`，可以与其他开源加载程序链接：
- en: '`jade-loader`: This converts the template to a module that exports a function.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jade-loader`：这将模板转换为导出函数的模块。'
- en: '`apply-loader`: This executes the function with loader options and returns
    basic HTML code.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply-loader`：这将使用加载程序选项执行函数并返回基本的HTML代码。'
- en: '`e idea HTML-loader`: This accepts the HTML code and outputs a valid JavaScript
    module.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e idea HTML-loader`：这个加载程序接受HTML代码并输出一个有效的JavaScript模块。'
- en: The fact that loaders can be chained also means they don't necessarily have
    to output JavaScript, as long as the next loader in the chain can handle its output.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载程序可以链接，这意味着它们不一定必须输出JavaScript，只要链中的下一个加载程序可以处理其输出。
- en: Webpack is always modular, so let's look at the advice concerning that when
    working with chained loaders.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack始终是模块化的，因此在使用链接加载程序时，让我们看一下关于这方面的建议。
- en: Modular outputting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化输出
- en: You should always, and in the best of circumstances, keep output modular. Loader-generated
    modules should adhere to the same design heuristics as normal modules.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在最好的情况下，您应该始终保持输出模块化。加载程序生成的模块应遵循与普通模块相同的设计启发。
- en: This may be for obvious reasons, but compatibility with existing projects would
    mean that this standard should be followed. It will also be of increasing importance
    for the chaining of loaders, as discussed previously. Loaders are often used in
    sequence with each other, and many Webpack projects require the installation and
    usage of many of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是显而易见的原因，但与现有项目的兼容性意味着应该遵循这一标准。这对于加载程序的链接也将变得越来越重要，正如之前讨论的那样。加载程序通常按顺序与彼此一起使用，并且许多Webpack项目需要安装和使用其中许多加载程序。
- en: Therefore, the adherence to a modular output convention will prevent projects
    from becoming overly complicated and, in fact, possibly cause a reversal in the
    purpose of Webpack bundling, which is making a smaller, more succinct, and optimized
    application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，遵循模块化输出约定将防止项目变得过于复杂，并且实际上可能导致Webpack捆绑的目的发生逆转，即使应用程序更小，更简洁和更优化。
- en: This conventional adherence or standard formatting is something that will be
    second nature to most developers, but when working with Webpack, there may be
    some compatibility considerations you have overlooked as they are so peculiar
    to bundling. One of these considerations is the "state" of the loader.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统的遵循或标准格式对大多数开发人员来说将是第二天性的，但在使用Webpack时，可能会有一些兼容性考虑您可能已经忽略了，因为它们对捆绑是如此特殊。其中一个考虑因素是加载程序的“状态”。
- en: Ensuring statelessness
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保无状态
- en: Make sure the loader does not retain a state between module transformations.
    Each run should always be independent of other compiled modules.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 确保加载程序在模块转换之间不保留状态。每次运行都应始终独立于其他已编译的模块。
- en: During the compilation process, you may end up running several builds as you
    fine-tune your bundle, and you don't want to correct each run, but rather retain
    each build in its original state.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，您可能需要运行多个构建，以微调您的捆绑包，您不希望在每次运行时进行更正，而是保留每个构建的原始状态。
- en: This will make things much easier to keep track of should things go wrong, as
    you can always start again with the source files without starting at the very
    beginning of your command-line session.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，这将使跟踪变得更加容易，因为您始终可以从源文件重新开始，而无需从命令行会话的最开始开始。
- en: It is also important to consider compatibility with other loaders. As this is
    a convention among loaders, you should maintain that same convention unless it
    is fundamentally necessary for your loader to perform its specific task, and,
    if so, this should be made clear to the developer so that no mistakes are made.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑与其他加载程序的兼容性也很重要。由于这是加载程序之间的约定，除非对于您的加载程序执行其特定任务是基本必要的，否则您应该保持相同的约定，并且如果是这样，应该向开发人员明确说明，以免出现错误。
- en: 'If the passing of a state is necessary for the functionality of your loader,
    then there is a convenient solution to provide adherence to conventions: the loader
    utilities package.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递状态对于您的加载程序的功能是必要的，那么有一个方便的解决方案可以提供对约定的遵循：加载程序实用程序包。
- en: Employing loader utilities
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加载程序实用程序
- en: 'Why not take advantage of the `loader-utils` package? It provides a variety
    of useful tools, but one of the most common of these is the ability to retrieve
    the options being passed to any loader in use. Along with `loader-utils`, the
    `schema-utils` package should be used for consistent JSON Schema-based validation.
    The following code block shows an example that utilizes both packages, using `loader.js`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不利用`loader-utils`包呢？它提供了各种有用的工具，但其中最常见的之一是能够检索正在使用的任何加载程序传递的选项。除了`loader-utils`，还应该使用`schema-utils`包进行一致的基于JSON模式的验证。以下代码块显示了一个利用这两个包的示例，使用`loader.js`：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can apply some transformations to the source, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对源代码应用一些转换，就像这样：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This transformation will **stringify** the code—essentially, outputting the
    contents into a single line of code that is difficult to read by humans but ideal
    for computers. This also often helps with privacy issues, should anyone wish to
    manually copy the code. With that understood, let's move on to loader dependency
    guidelines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换将**字符串化**代码-基本上，将内容输出为一行代码，这对人类来说很难阅读，但对计算机来说是理想的。这通常也有助于隐私问题，如果有人希望手动复制代码。了解了这一点，让我们继续讨论加载程序依赖项的准则。
- en: Marking loader dependencies
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记加载程序依赖项
- en: 'If a loader uses external resources, such as when reading from a filesystem,
    the loader must indicate this. This information is used to invalidate "cacheable"
    loaders and recompile them in watch mode. What follows is a brief example of how
    to accomplish this, using the `addDependency` method inside of `loader.js`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载器使用外部资源，比如从文件系统中读取，加载器必须指示这一点。这些信息用于使“可缓存”的加载器失效，并在监视模式下重新编译它们。接下来是一个简短的示例，说明如何使用`loader.js`中的`addDependency`方法来实现这一点：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are some differences between the loader and modular dependencies. Let's
    now discuss the latter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器和模块依赖之间存在一些差异。现在让我们讨论后者。
- en: Resolving module dependencies
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析模块依赖
- en: Depending on the type of module you are using, there may be a different schema
    in use to specify any dependency. In **Cascading Style Sheets** (**CSS**), for
    example, the `@import` and `URL(...)` statements are used. When doing this, these
    dependencies should be resolved by the module system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的模块类型的不同模式，可能会使用不同的模式来指定任何依赖项。例如，在**层叠样式表**（**CSS**）中，使用`@import`和`URL(...)`语句。在这种情况下，这些依赖项应该由模块系统解析。
- en: 'This can be achieved in one of the following two ways:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下两种方式之一实现这一点：
- en: By transforming the statements to `require` statements
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将语句转换为`require`语句
- en: Using the `this.resolve` function to resolve a path
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`this.resolve`函数来解析路径
- en: The `css-loader` is a good example of the first approach. It transforms dependencies
    to `require` statements, by replacing `@import` statements with a request to the
    other style sheet and `url(...)` with a request to the file being referenced.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`css-loader`是第一种方法的一个很好的例子。它通过将`@import`语句替换为对其他样式表的请求和将`url(...)`替换为对被引用文件的请求，将依赖项转换为`require`语句。'
- en: In respect to the LESS loader, each `@import` statement is unable to transform
    to a `require` statement because **fewer** files must be compiled in a single
    iteration. As a result, the LESS loader will use custom path-resolving logic to
    extend the LESS compiler. It will then use the `this.resolve` method to resolve
    the dependency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于LESS加载器，每个`@import`语句都无法转换为`require`语句，因为在单次迭代中必须编译**更少**的文件。因此，LESS加载器将使用自定义路径解析逻辑来扩展LESS编译器。然后使用`this.resolve`方法来解析依赖项。
- en: If you're using language that only accepts relative **Uniform Resource Locators**
    (**URLs**), the *~* tilde convention can be used to specify references to the
    installing modules. An example would be `url('~some-library/image.png')`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的语言只接受相对**统一资源定位符**（**URL**），则可以使用*~*波浪号约定来指定对安装模块的引用。例如`url('~some-library/image.png')`。
- en: Extracting common code
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取公共代码
- en: As part of best practice here, the generating of common code in every module
    of the loader process should be avoided. A better approach is to use a runtime
    file in the loader and generate a `require` statement process to any shared module.
    This better suits how Webpack parses code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践的一部分，应该避免在加载器过程的每个模块中生成公共代码。更好的方法是在加载器中使用运行时文件，并生成对任何共享模块的`require`语句过程。这更适合Webpack解析代码的方式。
- en: It is the essential purpose of Webpack to compile a project so that code is
    not duplicated, so this may go without saying, but the loaders themselves should
    do this and not leave it to the Webpack core processing. Otherwise, applications
    would be needlessly large or have needlessly long compilation times.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack的基本目的是编译项目，以便代码不会重复，因此这可能是不言而喻的，但加载器本身应该这样做，而不是留给Webpack核心处理。否则，应用程序将会变得非常庞大，或者编译时间会变得非常长。
- en: If you have experience in programming plugins, you may overlook this very obvious
    precept, but it is worth mentioning here as it is so essential to the operation
    and processes of Webpack.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有编程插件的经验，您可能会忽视这个非常明显的原则，但是在这里提到它是值得的，因为它对于Webpack的操作和流程非常重要。
- en: Avoiding absolute paths
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免绝对路径
- en: As alluded to, inserting absolute paths into any code related to a module should
    not be done, as hashing will break if the root directory is ever moved. Also,
    note that there is a `stringifyRequest` method in the `loader-utils` loader, which
    can be used to an absolute path to a relative one to help automate your process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所暗示的，不应该在与模块相关的任何代码中插入绝对路径，因为如果根目录被移动，哈希将会破坏。另外，请注意，在`loader-utils`加载器中有一个`stringifyRequest`方法，可以用来将绝对路径转换为相对路径，以帮助自动化您的流程。
- en: Refer to [Chapter 2](3307482e-bfac-4ad6-8d58-767063722dda.xhtml), *Working with
    Modules and Code Splitting, *to get a refresher on absolute paths if you think
    you need it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第2章](3307482e-bfac-4ad6-8d58-767063722dda.xhtml)，*使用模块和代码拆分*，如果您认为需要的话，可以重新了解绝对路径。
- en: As with common code, this is something very fundamental to how Webpack works,
    and if you don't have that in mind during your authoring you may overlook it,
    so it is certainly worth mentioning. Relative paths are the way to go.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与公共代码一样，这是Webpack工作的非常基本的部分，如果在编写过程中没有考虑到这一点，您可能会忽视它，因此值得一提。相对路径是正确的方式。
- en: One last point on standards relates to peer dependencies. Let's look at these
    now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标准的最后一点与对等依赖项有关。现在让我们来看看这些。
- en: Using peer dependencies
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对等依赖项
- en: In the event of developing a loader that is a simple wrapper (essentially, code
    that acts as a shell for more operational code within), the operational code—or
    package—should be included as `peerDependency`. This is because it will allow
    you to specify the exact version of the package using the `package.json` file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发一个简单的包装器加载器时（基本上是在更高级代码内部充当外壳的代码），操作代码或包应该作为`peerDependency`包含。这是因为它将允许您使用`package.json`文件指定包的确切版本。
- en: 'In the following example, the `sass-loader` specifies `node-sass` as a peer
    dependency. Take a look at the code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`sass-loader`将`node-sass`指定为对等依赖项。看一下代码：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This can be invaluable for compatibility issues, especially on complex programming
    projects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于兼容性问题可能非常有价值，特别是在复杂的编程项目中。
- en: Unit testing
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Thus far, we have written a custom loader, followed the guidelines, and even
    got it running locally. The next step is testing. The following example is a simple
    unit testing procedure. It makes use of the `babel-jest` **Jest** framework and
    some other presets to allow the use of the `import/export` and `async/await` methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一个自定义加载器，遵循了指南，甚至在本地运行了它。下一步是测试。以下示例是一个简单的单元测试过程。它使用`babel-jest`
    **Jest**框架和一些其他预设，允许使用`import/export`和`async/await`方法：
- en: 'We''ll start by installing and saving these as something called `devDependencies`,
    like this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装并保存这些内容，称为`devDependencies`，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous command-line entry installs the **Jest** framework and **Babel**
    with **Jest** in development mode.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令行条目以开发模式安装了**Jest**框架和**Babel**与**Jest**。
- en: 'Next, we must look at the configuration used in `webpack.config.js` concerning
    this particular unit testing procedure, as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须查看`webpack.config.js`中使用的配置，关于这个特定的单元测试过程，如下所示：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function of the loader in the example is to process a text file and replace
    any instance of `[name]` with the option given to the loader. It then outputs
    a valid **JavaScript** module containing the text as its default export, as seen
    in the following example inside of **`src/loader.js`**:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例中加载器的功能是处理文本文件，并用加载器提供的选项替换`[name]`的任何实例。然后，它输出一个包含文本的有效**JavaScript**模块作为其默认导出，如下例所示，位于**`src/loader.js`**中：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This loader will be used to process the following text file, called `test/example.txt`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个加载器将用于处理以下文本文件，名为`test/example.txt`：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is a little more complicated. It uses the **Node.js** API and
    `memory-fs` to execute Webpack. This will avoid content being output to the local
    hard drive (very handy to know) and gives us access to statistical data that can
    be used to take hold of our transformed module. It begins with the following command
    line:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步有点复杂。它使用**Node.js** API和`memory-fs`来执行Webpack。这将避免内容输出到本地硬盘（非常方便），并使我们能够访问可以用来控制我们转换模块的统计数据。它从以下命令行开始：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once it''s installed, there''s some work we need to do on its associated compiler
    script. Use the following **`test/compiler.js` **file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要在其关联的编译器脚本上做一些工作。使用以下**`test/compiler.js` **文件：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous example, we inlined our configuration, but a configuration as
    a parameter to the `export` function can also be accepted. This allows the testing
    of multiple setups using the same compiler module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们内联了我们的配置，但是也可以将配置作为`export`函数的参数来接受。这允许使用相同的编译器模块测试多个设置。
- en: 'This being done, we can now write our test and add an `npm` script to run it. Let''s
    begin by adding the following code to our `test/loader.test.js` file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做之后，我们现在可以编写我们的测试并添加一个`npm`脚本来运行它。让我们首先将以下代码添加到我们的`test/loader.test.js`文件中：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code block shows the testing function that loads in the example
    text, should the program work correctly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块显示了测试函数，它加载示例文本，如果程序工作正常的话。
- en: Everything should now be in place.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都应该就绪了。
- en: 'The code can now be run, and we''ll check whether the new loader has passed
    the test by running an `npm` build in the command line and viewing the command-line
    window, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以运行代码了，我们将通过在命令行中运行`npm`构建并查看命令行窗口来检查新加载器是否通过了测试，如下所示：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you see something like the preceding text in the corresponding file, then
    it passed. Well done!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在相应文件中看到类似前面文本的内容，那么它通过了测试。干得好！
- en: At this point, you should be able to develop, test, and deploy your loaders.
    Don't forget to share your creations with the rest of the Webpack community and
    help expand the capabilities of developers everywhere, and make your mark at the
    same time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够开发、测试和部署您的加载器。不要忘记与Webpack社区的其他成员分享您的创作，并帮助扩展开发人员的能力，同时留下您的印记。
- en: We've covered a huge amount in this guide and I suppose you feel like an expert,
    having built custom libraries and loaders, but making live coding hacks would
    make your skillset even more impressive. These are useful to know, especially
    on custom jobs where workarounds and makeshift approaches are more likely than
    tried-and-tested code, so let's dive right in!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南中，我们涵盖了大量内容，我想您现在感觉像一个专家，已经构建了自定义库和加载器，但是进行实时编码会使您的技能更加令人印象深刻。这些是有用的知识，特别是在自定义工作中，解决方法和临时方法比经过试验的代码更有可能，所以让我们开始吧！
- en: Live coding hacks
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时编码技巧
- en: In this section, we will get to see some very intriguing stuff that will leave
    an expert feeling like a superhero, should he or she ever get into hot water or
    simply wish to show off. We will discuss loaders that work well with **HMR**, such
    as `monkey-hot-loader` and `react-hot-loader`, as well as the various uses of `eval`
    and `__Eval`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到一些非常有趣的东西，这些东西会让专家感觉像超级英雄，如果他或她陷入困境或者只是想炫耀的话。我们将讨论与**HMR**很好配合的加载器，比如`monkey-hot-loader`和`react-hot-loader`，以及`eval`和`__Eval`的各种用途。
- en: 'To begin with, you should note that there is a side effect with **HMR**. It
    always evaluates the entire module again when it updates. This includes the dependency
    chain, which updates to point to new modules. However, we may just want the original
    module to evaluate the new code, not the entire module. Thankfully, there is a
    hack around this: using `monkey-hot-loader`!'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该注意**HMR**存在一个副作用。当它更新时，它总是重新评估整个模块。这包括依赖链，它会更新指向新模块。然而，我们可能只想让原始模块评估新代码，而不是整个模块。幸运的是，有一个绕过这个问题的方法：使用`monkey-hot-loader`！
- en: Monkey Hot Loader
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monkey Hot Loader
- en: This will also mean that if your module has side effects, such as starting a
    server, then `monkey-hot-loader` won't work that well with it. That won't be the
    case if there is a global state, but there really shouldn't be one if it's coded
    correctly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，如果您的模块具有副作用，比如启动服务器，那么`monkey-hot-loader`就不太适用。如果有全局状态，情况就不一样了，但如果编写正确，就不应该有全局状态。
- en: Also, note that when we change a module by taking `monkey-patch` and patch the
    original module with the updates.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，当我们通过“猴子补丁”来更改一个模块并用更新的内容来修补原始模块时。
- en: In this section, we will explore how patching top-level functions works in detail.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细探讨如何对顶级函数进行补丁。
- en: '`monkey-hot-loader` is a Webpack loader that parses the JavaScript file and
    extracts all the names of the top-level functions in the file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkey-hot-loader`是一个Webpack加载程序，它解析JavaScript文件并提取文件中所有顶级函数的名称：'
- en: 'For example, take a look at the following code, which we are placing in the
    `app.js` file but can be placed anywhere, as the code works globally and will
    affect top-level functions:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，看一下以下代码，我们将其放在`app.js`文件中，但可以放在任何地方，因为该代码在全局范围内工作，并且将影响顶级函数：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In respect to the previous example, the latest version of `monkey-hot-loader` currently
    only extracts the function names `foo` and `bar`, as only these functions can
    be patched. A few other types of functions could be made patchable, but let's
    keep things simple for now for the sake of explanation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，`monkey-hot-loader`的最新版本目前只提取函数名称`foo`和`bar`，因为只有这些函数可以进行补丁。还有一些其他类型的函数可以被制作成可补丁的，但为了解释的简单起见，我们现在先保持简单。
- en: The `foo` and `bar` functions can be patched by setting them to new functions.
    This is because they are top-level functions. When updated, the functions will
    be created in the same scope. It's then easy to inject new code there.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`和`bar`函数可以通过设置它们为新函数来进行补丁。这是因为它们是顶级函数。更新后，函数将在相同的作用域中创建。然后很容易在那里注入新代码。'
- en: 'There is only one real problem with that, concerning exporting the function:
    modules using the exported function would still be referencing the old variation. Quite
    a bit of work needs to be done to get around that, which we will go over now.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的真正问题是，关于导出函数：使用导出函数的模块仍将引用旧的变体。需要做大量的工作来解决这个问题，我们现在将详细介绍。
- en: The names of these functions are given to the runtime code that `monkey-hot-loader`
    appends to each module.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的名称将被提供给`monkey-hot-loader`附加到每个模块的运行时代码。
- en: 'When the module runs initially, it will iterate over these names and make each
    function patchable, and we do this by replacing it with the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模块最初运行时，它将遍历这些名称，并使每个函数都可以进行补丁，我们通过以下代码来实现这一点：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `f` variable would reference the name `foo` if we were patching it.
    Note that the semantics of `patched` should be the same as the `f` variable. Any
    call to the `patched` variable should produce the same result as a call to `f`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们要对其进行补丁，`f`变量将引用名称`foo`。请注意，“patched”的语义应与`f`变量相同。对`patched`变量的任何调用应产生与对`f`的调用相同的结果。
- en: With the initial semantics of `foo` intact, we have installed a "hook" to perform
    a check to see whether there's a new version of the function to call. After all
    top-level functions are replaced with this variation, we can simply override any
    of them by loading a function into `patchedBindings`. Even exported functions
    will call the new variation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持`foo`的初始语义的同时，我们安装了一个“钩子”来执行检查，以查看是否有新版本的函数要调用。在所有顶级函数都用这种变体替换后，我们可以通过将函数加载到`patchedBindings`中来简单地覆盖其中的任何一个。即使导出的函数也将调用新的变体。
- en: Currently, the `monkey-hot-loader` implements this top-level function patching
    as an initial experiment. You may consider playing with it by using the `backend-with-webpack` project to
    see how to integrate it with your application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`monkey-hot-loader`将此顶级函数补丁实现为一个初始实验。您可以考虑使用`backend-with-webpack`项目来玩一下，看看如何将其与您的应用程序集成。
- en: Depending on the context, a different heuristic may need to be adopted for patching.
    For instance, if your frontend uses **React**, most of your code will exist inside
    the **React** library components. The `react-hot-loader` works fantastically well
    for that. However, concerning your backend code, most of it might be classed with
    methods, in which case patching the method on the prototype works best for that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，可能需要采用不同的启发式方法进行补丁。例如，如果您的前端使用**React**，那么大部分代码将存在于**React**库组件内。`react-hot-loader`对此效果非常好。但是，对于后端代码，大部分可能是类和方法，这种情况下最好的方法是对原型上的方法进行补丁。
- en: React Hot Patching
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React热补丁
- en: '`react-hot-loader` works by binding the original module to any new code, whether
    it be functions, classes, or methods. It will patch all of the methods of **React**
    components to use the new methods.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-hot-loader`的工作原理是将原始模块绑定到任何新代码，无论是函数、类还是方法。它将修补所有**React**组件的方法以使用新方法。'
- en: 'The question this leaves is how to patch the original module. Things will get
    extremely complicated if you try to accept an update. For instance, if you change
    code inside a closure, it becomes hard to patch the closure without losing the
    existing state. It may be achievable to use the **React** engine''s debugger API
    but to make this change throughout may be difficult: how difficult will depend
    greatly on your specific context.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下的问题是如何对原始模块进行补丁。如果尝试接受更新，事情将变得非常复杂。例如，如果更改闭包内的代码，将很难在不丢失现有状态的情况下对闭包进行补丁。可能可以使用**React**引擎的调试器API，但要在整个项目中进行此更改可能会很困难：困难程度将在很大程度上取决于您的具体上下文。
- en: Note that when patching closures, only allowing very basic patching is best
    as it's intuitively easy to keep track of how everything works.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当对闭包进行补丁时，最好只允许进行非常基本的补丁，因为直观地跟踪一切是很容易的。
- en: We often have to patch code when it's a complex and custom project. One tool
    that is very common with Webpack is an innate patching tool called `eval`. We
    will take a closer look at that now.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理复杂和定制项目时，通常需要进行补丁代码。Webpack中非常常见的一个工具是一个内在的补丁工具叫做`eval`。我们现在将更仔细地看一下它。
- en: Eval
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eval
- en: 'Whether it''s React Hot Patching or Monkey Hot Loader, we can install all these
    patch versions throughout the module''s scope using `eval`. After that, we save
    the scope of the module. This will only happen when the module runs for the first
    time:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是React热修补还是Monkey热加载器，我们都可以通过`eval`在整个模块范围内安装所有这些补丁版本。之后，我们保存模块的范围。这只会在模块第一次运行时发生：
- en: 'If we need the ability to alter code in this specific scope, we can do that
    by creating an `eval` proxy to maintain any state in the `app.js` file, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要在特定范围内更改代码的能力，可以通过创建一个`eval`代理来在`app.js`文件中维护任何状态来实现这一点：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function is later passed to future variations of this module through the
    dispose handler.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数稍后通过处理程序传递给此模块的未来变体。
- en: While all of the aforementioned happened on the initial run of the module in
    question, consecutive updates through a different route. In this case, the entire
    module is evaluated again except iterating over each top-level binding, then a
    call is made to `func.toString()` to return the function code, then the code is
    reevaluated in the scope of the original module using `moduleEval`—to reference
    the original state.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面提到的所有事情都发生在所讨论的模块的初始运行中，但通过不同的路径进行连续更新。在这种情况下，整个模块将再次进行评估，而不是迭代每个顶级绑定，然后调用`func.toString()`返回函数代码，然后使用`moduleEval`在原始模块的范围内重新评估代码-引用原始状态。
- en: 'Then, this `eval` function is installed in `patchedBindings` so that it is
    used in any future calls made by the system, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此`eval`函数安装在`patchedBindings`中，以便在系统未来的任何调用中使用：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In an ideal situation, we might get the source code of the module updated and
    avoid running the module since we just want the code in the form of a string anyway.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我们可能会获取模块的源代码更新，并避免运行模块，因为我们只想要代码的字符串形式。
- en: As it happens, it is possible to avoid the whole `func.toString()` and `moduleEval`
    process and simply not support any global state, although the global state is
    very useful for debugging operations. This is especially true for interactions
    that are simple to **REPL** (**Read–Eval–Print Loop**). Classes, however, don't
    have this issue, insomuch that all of their states are part of the instance, which
    is why `react-hot-loader` works just fine without this hack.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，可以避免整个`func.toString()`和`moduleEval`过程，而简单地不支持任何全局状态，尽管全局状态对于调试操作非常有用。这对于简单的REPL（读取-评估-打印循环）交互特别有效。然而，类没有这个问题，因为它们的所有状态都是实例的一部分，这就是为什么`react-hot-loader`可以在没有这个技巧的情况下正常工作。
- en: For the uninitiated, a REPL is also known as an interactive top-level or language
    shell, which takes single user inputs and evaluates them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未经培训的人来说，REPL也被称为交互式顶层或语言外壳，它接受单个用户输入并对其进行评估。
- en: Be aware that in Webpack 5, there are currently known problems with `eval()` that
    relate to `optimization.innerGraph` when in production mode.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Webpack 5中，`eval()`在生产模式下存在与`optimization.innerGraph`相关的已知问题。
- en: There is a hack available for `_eval`, and it's very useful to know. Let's get
    to that part now.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`_eval`，有一个可用的技巧，这是非常有用的。现在让我们来看看这一部分。
- en: The __Eval hack
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __Eval技巧
- en: Time for one last hack, and it is probably the biggest trick in this whole book! The
    `_eval()` function evaluates a string as an expression of a function. This can
    be used in conjunction with hot loading to allow an immediate evaluation of your
    code right across your project. This is essentially what the `_Eval` hack is.
    Let's explore it a little more now.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一个技巧的时间，这可能是整本书中最大的技巧！`_eval()`函数将字符串作为函数的表达式进行评估。这可以与热加载一起使用，以允许立即评估整个项目中的代码。这本质上就是`_Eval`的技巧。现在让我们更深入地探讨一下。
- en: 'If we want a REPL that evaluates code inside a module and to be able to open
    modules to choose which context to evaluate in, then we can''t do that with this
    infrastructure, but we can get most of the way there with the following example
    in the `app.js` file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个REPL来评估模块内的代码，并且能够打开模块以选择要在其中评估的上下文，那么我们无法使用这种基础设施，但我们可以通过`app.js`文件中的以下示例实现大部分功能：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once this is done and you define a function named  `__eval`, `monkey-hot-loader`
    will execute it every time the module updates. This is highly useful for instant
    feedback. With this approach, you could call some APIs and log the results, then
    work on those APIs on the fly until you see the results you want. That way, all
    you have to do is make some coding alterations, save the file, and then instantly
    see the updated output.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作并定义一个名为`__eval`的函数后，`monkey-hot-loader`将在模块更新时执行它。这对于即时反馈非常有用。通过这种方法，您可以调用一些API并记录结果，然后即时对这些API进行调整，直到看到想要的结果。这样，您只需进行一些编码更改，保存文件，然后立即查看更新后的输出。
- en: Also, you can use the code form `__eval` as a globally used script and allow
    the typical **HMR** system to run the module every time it's updated. This being
    said, any module with side effects will need specialist code. What's more, you
    can build a state across evaluations to play with or debug.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用`__eval`的代码形式作为全局使用的脚本，并允许典型的HMR系统在每次更新模块时运行。也就是说，任何具有副作用的模块都需要专门的代码。此外，您可以在评估中构建跨评估的状态以进行调试。
- en: Unlike the old **Lisp** style of doing things (that is, select code and press
    *Ctrl *+ *E* to run), this technique is done per module, and you have the latitude
    to select a context to run the code in.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧的Lisp风格不同（即选择代码并按Ctrl + E运行），此技术是针对每个模块进行的，并且您可以选择要在其中运行代码的上下文。
- en: One consideration is that new variables cannot be introduced, such as changing
    a variable's value, using the `_eval` function in `strict` mode. This will also
    apply to `__eval`, so it's worth bearing in mind before you begin.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个考虑是，在`strict`模式下，不能使用`_eval`函数引入新变量，例如更改变量的值。这也适用于`__eval`，因此在开始之前值得记住。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has taken you through some of the more advanced features that are
    possible with Webpack, such as library authoring and live coding hacks, using
    the `_Eval` technique with hot loading to allow instant feedback across your project.
    This has included detailed explanations and examples of how to customize loaders,
    and even patch top-level functions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带您了解了Webpack的一些更高级的功能，比如库编写和实时编码技巧，使用`_Eval`技术进行热加载，以实现项目间的即时反馈。这包括了如何自定义加载器的详细解释和示例，甚至修补顶层函数。
- en: You should now have an understanding of manual bundling and live coding, deep
    enough to parallel any expert. Why not demonstrate this know-how to yourself by
    taking the quiz at the very end of this chapter? It should stand you in good stead
    if you are ever put on the spot at job interviews or even presentations to major
    clients, to be able to quickly express your expertise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对手动捆绑和实时编码有足够深入的了解，可以与任何专家并驾齐驱。为什么不通过在本章末尾的测验中展示这种专业知识来向自己证明呢？如果您在工作面试或向重要客户做演示时能够快速表达自己的专业知识，这将对您大有裨益。
- en: This book as a whole has given extensive and comprehensive detail on both how
    to use Webpack competently and take your application development to completely
    new levels. This particular chapter will be increasingly important as your Webpack
    bundling develops, and you can be sure that this chapter specifically will be
    one bookmarked for many projects to come.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都详细而全面地介绍了如何熟练使用Webpack，并将应用程序开发提升到全新的水平。随着您的Webpack捆绑的发展，本章将变得越来越重要，您可以确信，这一章将成为未来许多项目的书签。
- en: Once you have tried the practice quiz questions, you may want to flip back to
    the start of the book and test yourself on each chapter. You will find the assessment
    answers in a separate chapter at the back of this guide. Successful completion
    will result in your expertise being beyond doubt, so give it a try.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您尝试了练习测验问题，您可能想翻回书的开头，对每一章进行自我测试。您将在本指南后面的一个单独章节中找到评估答案。成功完成将使您的专业知识毋庸置疑，所以试一试吧。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can Webpack be used to bundle libraries as well as applications?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack可以用来捆绑库以及应用程序吗？
- en: How are external libraries excluded from the bundle when authoring libraries?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写库时，如何将外部库排除在捆绑包之外？
- en: Webpack offers four ways to expose a custom library. What are they?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack提供了四种公开自定义库的方式。它们是什么？
- en: Why shouldn't absolute paths be used when building a custom module?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建自定义模块时为什么不应该使用绝对路径？
- en: How can the function prefix of `__eval` help with instant feedback?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__eval`的函数前缀如何帮助实现即时反馈？'
- en: Why must a developer indicate the reading of external resources such as a filesystem
    by a loader?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么开发人员必须通过加载器指示读取外部资源，比如文件系统？
- en: How are loaders executed when they are chained?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当加载器被链接时，它们是如何执行的？
