["```java\nprivate class Node {\n\u00a0\u00a0private Node left;\n\u00a0\u00a0private Node right;\n\u00a0\u00a0private final T element;\n\u00a0\u00a0public Node(T element) {\n\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0this.left = null;\n\u00a0\u00a0\u00a0\u00a0this.right = null;\n\u00a0\u00a0}\n\u00a0\u00a0public Node(Node left, Node right, T element) {\n\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0this.left = left;\n\u00a0\u00a0\u00a0\u00a0this.right = right;\n\u00a0\u00a0}\n\u00a0\u00a0// operations\n}\n```", "```java\nprivate void printLevelOrder(Node node) {\n\u00a0\u00a0Queue<Node> queue = new ArrayDeque<>();\n\u00a0\u00a0queue.add(node);\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0// Step 1\n\u00a0\u00a0\u00a0\u00a0Node current = queue.poll();\n\u00a0\u00a0\u00a0\u00a0// Step 2\n\u00a0\u00a0\u00a0\u00a0System.out.print(\" \" + current.element);\n\u00a0\u00a0\u00a0\u00a0// Step 3\n\u00a0\u00a0\u00a0\u00a0if (current.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(current.left);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Step 4\n\u00a0\u00a0\u00a0\u00a0if (current.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(current.right);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nprivate void printPreOrder(Node node) {\n\u00a0\u00a0if (node != null) {\n\u00a0\u00a0\u00a0\u00a0System.out.print(\" \" + node.element);\n\u00a0\u00a0\u00a0\u00a0printPreOrder(node.left);\n\u00a0\u00a0\u00a0\u00a0printPreOrder(node.right);\n\u00a0\u00a0}\n}\n```", "```java\nprivate void printInOrder(Node node) {\n\u00a0\u00a0if (node != null) {\n\u00a0\u00a0\u00a0\u00a0printInOrder(node.left);\n\u00a0\u00a0\u00a0\u00a0System.out.print(\" \" + node.element);\n\u00a0\u00a0\u00a0\u00a0printInOrder(node.right);\n\u00a0\u00a0}\n}\n```", "```java\nprivate void printPostOrder(Node node) {\n\u00a0\u00a0if (node != null) {\n\u00a0\u00a0\u00a0\u00a0printPostOrder(node.left);\n\u00a0\u00a0\u00a0\u00a0printPostOrder(node.right);\n\u00a0\u00a0\u00a0\u00a0System.out.print(\" \" + node.element);\n\u00a0\u00a0}\n}\n```", "```java\nIs this a balanced tree? Is it a full binary tree?, Is it a BST?. In other words, don't base your solution on assumptions that may not be true for the given binary tree.\n```", "```java\npublic class MaxHeap<T extends Comparable<T>> {\n\u00a0\u00a0private static final int DEFAULT_CAPACITY = 5;\n\u00a0\u00a0private int capacity;\n\u00a0\u00a0private int size;\n\u00a0\u00a0private T[] heap;\n\u00a0\u00a0public MaxHeap() {\n\u00a0\u00a0\u00a0\u00a0capacity = DEFAULT_CAPACITY;\n\u00a0\u00a0\u00a0\u00a0this.heap = (T[]) Array.newInstance(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Comparable[].class.getComponentType(),DEFAULT_CAPACITY);\n\u00a0\u00a0}\n\u00a0\u00a0// operations\n}\n```", "```java\npublic class Graph<T> {\n\u00a0\u00a0// the vertices list\n\u00a0\u00a0private final List<T> elements;\n\u00a0\u00a0public Graph() {\n\u00a0\u00a0\u00a0\u00a0this.elements = new ArrayList<>();\n\u00a0\u00a0}\n\u00a0\u00a0// operations\n}\n```", "```java\npublic class Graph<T> {\n\u00a0\u00a0// the adjacency list is represented as a map\n\u00a0\u00a0private final Map<T, List<T>> adjacencyList;\n\u00a0\u00a0public Graph() {\n\u00a0\u00a0\u00a0\u00a0this.adjacencyList = new HashMap<>();\n\u00a0\u00a0}\n\u00a0\u00a0// operations\n}\n```", "```java\npublic boolean isPath(T from, T to) {\n\u00a0\u00a0Queue<T> queue = new ArrayDeque<>();\n\u00a0\u00a0Set<T> visited = new HashSet<>();\n\u00a0\u00a0// we start from the 'from' node\n\u00a0\u00a0visited.add(from);\n\u00a0\u00a0queue.add(from);\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0T element = queue.poll();\n\u00a0\u00a0\u00a0\u00a0List<T> adjacents = adjacencyList.get(element);\n\u00a0\u00a0\u00a0\u00a0if (adjacents != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (T t : adjacents) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (t != null && !visited.contains(t)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.add(t);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(t);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we reached the destination (the 'to' node)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (t.equals(to)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic void minimalBst(T m[]) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0root = minimalBst(m, 0, m.length - 1);\n}\nprivate Node minimalBst(T m[], int start, int end) {\n\u00a0\u00a0if (end < start) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0int middle = (start + end) / 2;\n\u00a0\u00a0Node node = new Node(m[middle]);\n\u00a0\u00a0nodeCount++;\n\u00a0\u00a0node.left = minimalBst(m, start, middle - 1);\n\u00a0\u00a0node.right = minimalBst(m, middle + 1, end);\n\u00a0\u00a0return node;\n}\n```", "```java\npublic List<List<T>> fetchAllLevels() {\n\u00a0\u00a0// each list holds a level\n\u00a0\u00a0List<List<T>> allLevels = new ArrayList<>();\n\u00a0\u00a0// first level (containing only the root)\n\u00a0\u00a0Queue<Node> currentLevelOfNodes = new ArrayDeque<>();\n\u00a0\u00a0List<T> currentLevelOfElements = new ArrayList<>();\n\u00a0\u00a0currentLevelOfNodes.add(root);\n\u00a0\u00a0currentLevelOfElements.add(root.element);\n\u00a0\u00a0while (!currentLevelOfNodes.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0// store the current level as the previous level\n\u00a0\u00a0\u00a0\u00a0Queue<Node> previousLevelOfNodes = currentLevelOfNodes;\n\u00a0\u00a0\u00a0\u00a0// add level to the final list\n\u00a0\u00a0\u00a0\u00a0allLevels.add(currentLevelOfElements);\n\u00a0\u00a0\u00a0\u00a0// go to the next level as the current level\n\u00a0\u00a0\u00a0\u00a0currentLevelOfNodes = new ArrayDeque<>();\n\u00a0\u00a0\u00a0\u00a0currentLevelOfElements = new ArrayList<>();\n\u00a0\u00a0\u00a0\u00a0// traverse all nodes on current level\n\u00a0\u00a0\u00a0\u00a0for (Node parent : previousLevelOfNodes) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (parent.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentLevelOfNodes.add(parent.left);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentLevelOfElements.add(parent.left.element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (parent.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentLevelOfNodes.add(parent.right);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentLevelOfElements.add(parent.right.element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return allLevels;\n}\n```", "```java\npublic boolean isSubtree(BinaryTree q) {\n\u00a0\u00a0return isSubtree(root, q.root);\n}\nprivate boolean isSubtree(Node p, Node q) {\n\u00a0\u00a0if (p == null) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0// if the roots don't match\n\u00a0\u00a0if (!match(p, q)) {\n\u00a0\u00a0\u00a0\u00a0return (isSubtree(p.left, q) || isSubtree(p.right, q));\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\nprivate boolean match(Node p, Node q) {\n\u00a0\u00a0if (p == null && q == null) {\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0if (p == null || q == null) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0return (p.element == q.element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& match(p.left, q.left)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& match(p.right, q.right));\n}\n```", "```java\nlong t1 = Duration.between(current.element.\n\u00a0\u00a0plusMinutes(current.time), element).toMinutes();\nlong t2 = Duration.between(current.element,\u00a0\u00a0\u00a0\n\u00a0\u00a0element.plusMinutes(time)).toMinutes();\nif (t1 <= 0 && t2 >= 0) {\n\u00a0\u00a0\u00a0\u00a0// overlapping found\n}\n```", "```java\npublic class BinarySearchTree<Temporal> {\n\u00a0\u00a0private Node root = null;\n\u00a0\u00a0private class Node {\n\u00a0\u00a0\u00a0\u00a0private Node left;\n\u00a0\u00a0\u00a0\u00a0private Node right;\n\u00a0\u00a0\u00a0\u00a0private final LocalTime element;\n\u00a0\u00a0\u00a0\u00a0private final int time;\n\u00a0\u00a0\u00a0\u00a0public Node(LocalTime element, int time) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.time = time;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.left = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.right = null;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0public Node(Node left, Node right, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LocalTime element, int time) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.time = time;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.left = left;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.right = right;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0public void insert(LocalTime element, int time) {\n\u00a0\u00a0\u00a0\u00a0if (element == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new IllegalArgumentException(\"...\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0root = insert(root, element, time);\n\u00a0\u00a0}\n\u00a0\u00a0private Node insert(Node current, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LocalTime element, int time) {\n\u00a0\u00a0\u00a0\u00a0if (current == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new Node(element, time);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0long t1 = Duration.between(current.element.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0plusMinutes(current.time), element).toMinutes();\n\u00a0\u00a0\u00a0\u00a0long t2 = Duration.between(current.element, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0element.plusMinutes(time)).toMinutes();\n\u00a0\u00a0\u00a0\u00a0if (t1 <= 0 && t2 >= 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"Cannot reserve the runway at \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ element + \" for \" + time + \" minutes !\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return current;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (element.compareTo(current.element) < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current.left = insert(current.left, element, time);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current.right = insert(current.right, element, time);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return current;\n\u00a0\u00a0}\n\u00a0\u00a0public void printInOrder() {\n\u00a0\u00a0\u00a0\u00a0printInOrder(root);\n\u00a0\u00a0}\n\u00a0\u00a0private void printInOrder(Node node) {\n\u00a0\u00a0\u00a0\u00a0if (node != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printInOrder(node.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(\" \" + node.element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ \"(\" + node.time + \")\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printInOrder(node.right);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic boolean isBalanced() {\n\u00a0\u00a0return isBalanced(root);\n}\nprivate boolean isBalanced(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0if (Math.abs(height(root.left) - height(root.right)) > 1) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0return isBalanced(root.left) && isBalanced(root.right);\n\u00a0\u00a0}\n}\nprivate int height(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0}\n\u00a0\u00a0return Math.max(height(root.left), height(root.right)) + 1;\n}\n```", "```java\npublic boolean isBalanced() {\n\u00a0\u00a0return checkHeight(root) != Integer.MIN_VALUE;\n}\nprivate int checkHeight(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0}\n\u00a0\u00a0int leftHeight = checkHeight(root.left);\n\u00a0\u00a0if (leftHeight == Integer.MIN_VALUE) {\n\u00a0\u00a0\u00a0\u00a0return Integer.MIN_VALUE; // error \n\u00a0\u00a0}\n\u00a0\u00a0int rightHeight = checkHeight(root.right);\n\u00a0\u00a0if (rightHeight == Integer.MIN_VALUE) {\n\u00a0\u00a0\u00a0\u00a0return Integer.MIN_VALUE; // error \n\u00a0\u00a0}\n\u00a0\u00a0if (Math.abs(leftHeight - rightHeight) > 1) {\n\u00a0\u00a0\u00a0\u00a0return Integer.MIN_VALUE; // pass error back\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0return Math.max(leftHeight, rightHeight) + 1;\n\u00a0\u00a0}\n}\n```", "```java\npublic boolean isBinarySearchTree() {\n\u00a0\u00a0return isBinarySearchTree(root, null, null);\n}\nprivate boolean isBinarySearchTree(Node node, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T minElement, T maxElement) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0if ((minElement != null && \n\u00a0\u00a0\u00a0\u00a0node.element.compareTo(minElement) <= 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| (maxElement != null && node.element.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compareTo(maxElement) > 0)) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0if (!isBinarySearchTree(node.left, minElement, node.element)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| !isBinarySearchTree(node.right, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.element, maxElement)) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\nNode inOrderSuccessor(Node n) {\n\u00a0\u00a0if (n has a right sub-tree) {\n\u00a0\u00a0\u00a0\u00a0return the leftmost child of right sub-tree\n\u00a0\u00a0} \n\u00a0\u00a0while (n is a right child of n.parent) {\n\u00a0\u00a0\u00a0\u00a0n = n.parent; // traverse upwards \n\u00a0\u00a0}\n\u00a0\u00a0return n.parent; // parent has not been traversed\n}\n```", "```java\npublic void inOrderSuccessor() {\n\u00a0\u00a0// choose the node\n\u00a0\u00a0Node node = ...;\n\u00a0\u00a0System.out.println(\"\\n\\nIn-Order:\");\n\u00a0\u00a0System.out.print(\"Start node: \" + node.element);\n\u00a0\u00a0node = inOrderSuccessor(node);\n\u00a0\u00a0System.out.print(\" Successor node: \" + node.element);\n}\nprivate Node inOrderSuccessor(Node node) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0// case (a)\n\u00a0\u00a0if (node.right != null) {\n\u00a0\u00a0\u00a0\u00a0return findLeftmostNode(node.right);\n\u00a0\u00a0}\n\u00a0\u00a0// case (b)\n\u00a0\u00a0while (node.parent != null && node.parent.right == node) {\n\u00a0\u00a0\u00a0\u00a0node = node.parent;\n\u00a0\u00a0}\n\u00a0\u00a0return node.parent;\n}\n```", "```java\npublic Stack<T> topologicalSort(T startElement) {\n\u00a0\u00a0Set<T> visited = new HashSet<>();\n\u00a0\u00a0Stack<T> stack = new Stack<>();\n\u00a0\u00a0topologicalSort(startElement, visited, stack);\n\u00a0\u00a0return stack;\n}\nprivate void topologicalSort(T currentElement, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Set<T> visited, Stack<T> stack) {\n\u00a0\u00a0visited.add(currentElement);\n\u00a0\u00a0List<T> adjacents = adjacencyList.get(currentElement);\n\u00a0\u00a0if (adjacents != null) {\n\u00a0\u00a0\u00a0\u00a0for (T t : adjacents) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (t != null && !visited.contains(t)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0topologicalSort(t, visited, stack);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.add(t);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0stack.push(currentElement);\n}\n```", "```java\npublic T commonAncestor(T e1, T e2) {\n\u00a0\u00a0Node n1 = findNode(e1, root);\n\u00a0\u00a0Node n2 = findNode(e2, root);\n\u00a0\u00a0if (n1 == null || n2 == null) {\n\u00a0\u00a0\u00a0\u00a0throw new IllegalArgumentException(\"Both nodes \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0must be present in the tree\");\n\u00a0\u00a0}\n\u00a0\u00a0return commonAncestor(root, n1, n2).element;\n}\nprivate Node commonAncestor(Node root, Node n1, Node n2) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0if (root == n1 && root == n2) {\n\u00a0\u00a0\u00a0\u00a0return root;\n\u00a0\u00a0}\n\u00a0\u00a0Node left = commonAncestor(root.left, n1, n2);\n\u00a0\u00a0if (left != null && left != n1 && left != n2) {\n\u00a0\u00a0\u00a0\u00a0return left;\n\u00a0\u00a0}\n\u00a0\u00a0Node right = commonAncestor(root.right, n1, n2);\n\u00a0\u00a0if (right != null && right != n1 && right != n2) {\n\u00a0\u00a0\u00a0\u00a0return right;\n\u00a0\u00a0}\n\u00a0\u00a0// n1 and n2 are not in the same sub-tree\n\u00a0\u00a0if (left != null && right != null) {\n\u00a0\u00a0\u00a0\u00a0return root;\n\u00a0\u00a0} else if (root == n1 || root == n2) {\n\u00a0\u00a0\u00a0\u00a0return root;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0return left == null ? right : left;\n\u00a0\u00a0}\n}\n```", "```java\nprivate int countknightMoves(Node startCell, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node targetCell, int n) {\n\u00a0\u00a0// store the visited cells\n\u00a0\u00a0Set<Node> visited = new HashSet<>();\n\u00a0\u00a0// create a queue and enqueue the start cell\n\u00a0\u00a0Queue<Node> queue = new ArrayDeque<>();\n\u00a0\u00a0queue.add(startCell);\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0Node cell = queue.poll();\n\u00a0\u00a0\u00a0\u00a0int r = cell.r;\n\u00a0\u00a0\u00a0\u00a0int c = cell.c;\n\u00a0\u00a0\u00a0\u00a0int distance = cell.distance;\n\u00a0\u00a0\u00a0\u00a0// if destination is reached, return the distance\n\u00a0\u00a0\u00a0\u00a0if (r == targetCell.r && c == targetCell.c) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return distance;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// the cell was not visited\n\u00a0\u00a0\u00a0\u00a0if (!visited.contains(cell)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mark current cell as visited\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0visited.add(cell);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// enqueue each valid movement into the queue \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < 8; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// get the new valid position of knight from current\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// position on chessboard and enqueue it in the queue \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// with +1 distance\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rt = r + ROW[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int ct = c + COL[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (valid(rt, ct, n)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(new Node(rt, ct, distance + 1));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// if path is not possible\n\u00a0\u00a0return Integer.MAX_VALUE;\n}\n// Check if (r, c) is valid\u00a0\u00a0\u00a0\u00a0\nprivate static boolean valid(int r, int c, int n) {\n\u00a0\u00a0if (r < 0 || c < 0 || r >= n || c >= n) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\npublic void printCorners() {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0Queue<Node> queue = new ArrayDeque<>();\n\u00a0\u00a0queue.add(root);\n\u00a0\u00a0int level = 0;\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0// get the size of the current level\n\u00a0\u00a0\u00a0\u00a0int size = queue.size();\n\u00a0\u00a0\u00a0\u00a0int position = size;\n\u00a0\u00a0\u00a0\u00a0System.out.print(\"Level: \" + level + \": \");\n\u00a0\u00a0\u00a0\u00a0level++;\n\u00a0\u00a0\u00a0\u00a0// process all nodes present in current level\n\u00a0\u00a0\u00a0\u00a0while (position > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node node = queue.poll();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if corner node found, print it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (position == (size - 1) || position == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(node.element + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// enqueue left and right child of current node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(node.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(node.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// level done\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0System.out.println();\n\u00a0\u00a0}\n}\n```", "```java\npublic int maxPathSum() {\n\u00a0\u00a0maxPathSum(root);\n\u00a0\u00a0return max;\n}\nprivate int maxPathSum(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0}\n\u00a0\u00a0// maximum of the left child and 0\n\u00a0\u00a0int left = Math.max(0, maxPathSum(root.left));\n\u00a0\u00a0// maximum of the right child and 0\n\u00a0\u00a0int right = Math.max(0, maxPathSum(root.right));\n\u00a0\u00a0// maximum at the current node (all four cases 1,2,3 and 4)\n\u00a0\u00a0max = Math.max(max, left + right + root.element);\n\u00a0\u00a0//return the maximum from left, right along with current\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0return Math.max(left, right) + root.element;\n}\n```", "```java\n// print the diagonal elements of given binary tree\npublic void printDiagonalRecursive() {\n\u00a0\u00a0// map of diagonals\n\u00a0\u00a0Map<Integer, List<T>> map = new HashMap<>();\n\u00a0\u00a0// Pre-Order traversal of the tree and fill up the map\n\u00a0\u00a0printDiagonal(root, 0, map);\n\u00a0\u00a0// print the current diagonal\n\u00a0\u00a0for (int i = 0; i < map.size(); i++) {\n\u00a0\u00a0\u00a0\u00a0System.out.println(map.get(i));\n\u00a0\u00a0}\n}\n// recursive Pre-Order traversal of the tree \n// and put the diagonal elements in the map\nprivate void printDiagonal(Node node, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int diagonal, Map<Integer, List<T>> map) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// insert the current node in the diagonal\n\u00a0\u00a0if (!map.containsKey(diagonal)) {\n\u00a0\u00a0\u00a0\u00a0map.put(diagonal, new ArrayList<>());\n\u00a0\u00a0}\n\u00a0\u00a0map.get(diagonal).add(node.element);\n\u00a0\u00a0// increase the diagonal by 1 and go to the left sub-tree\n\u00a0\u00a0printDiagonal(node.left, diagonal + 1, map);\n\u00a0\u00a0// maintain the current diagonal and go \n\u00a0\u00a0// to the right sub-tree\n\u00a0\u00a0printDiagonal(node.right, diagonal, map);\n}\n```", "```java\n(first diagonal)\nEnqueue the root and all its right children \nWhile the queue is not empty\n\tDequeue (let's denote it as A)\n\tPrint A\n\u00a0\u00a0\u00a0\u00a0(next diagonal)\n\tIf A has a left child then enqueue it \n\u00a0\u00a0\u00a0\u00a0(let's denote it as B)\n\t\tContinue to enqueue all the right children of B\n```", "```java\npublic void printDiagonalIterative() {\n\u00a0\u00a0Queue<Node> queue = new ArrayDeque<>();\n\u00a0\u00a0// mark the end of a diagonal via dummy null value\n\u00a0\u00a0Node dummy = new Node(null);\n\u00a0\u00a0// enqueue all the nodes of the first diagonal\n\u00a0\u00a0while (root != null) {\n\u00a0\u00a0\u00a0\u00a0queue.add(root);\n\u00a0\u00a0\u00a0\u00a0root = root.right;\n\u00a0\u00a0}\n\u00a0\u00a0// enqueue the dummy node at the end of each diagonal\n\u00a0\u00a0queue.add(dummy);\n\u00a0\u00a0// loop while there are more nodes than the dummy\n\u00a0\u00a0while (queue.size() != 1) {\n\u00a0\u00a0\u00a0\u00a0Node front = queue.poll();\n\u00a0\u00a0\u00a0\u00a0if (front != dummy) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// print current node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(front.element + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// enqueue the nodes of the next diagonal \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node node = front.left;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (node != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(node);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node = node.right;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// at the end of the current diagonal enqueue the dummy\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(dummy);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nprivate class Node {\n\u00a0\u00a0private T element;\n\u00a0\u00a0private int count;\n\u00a0\u00a0private Node left;\n\u00a0\u00a0private Node right;\n\u00a0\u00a0private Node(Node left, Node right, T element) {\n\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0this.left = left;\n\u00a0\u00a0\u00a0\u00a0this.right = right;\n\u00a0\u00a0\u00a0\u00a0this.count = 1;\n\u00a0\u00a0}\n}\n```", "```java\nprivate Node insert(Node current, T element) {\n\u00a0\u00a0if (current == null) {\n\u00a0\u00a0\u00a0\u00a0return new Node(null, null, element);\n\u00a0\u00a0}\n\u00a0\u00a0// START: Handle inserting duplicates\n\u00a0\u00a0if (element.compareTo(current.element) == 0) {\n\u00a0\u00a0\u00a0\u00a0current.count++;\n\u00a0\u00a0\u00a0\u00a0return current;\n\u00a0\u00a0}\n\u00a0\u00a0// END: Handle inserting duplicates\n...\n}\n```", "```java\nprivate Node delete(Node node, T element) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0if (element.compareTo(node.element) < 0) {\n\u00a0\u00a0\u00a0\u00a0node.left = delete(node.left, element);\n\u00a0\u00a0} else if (element.compareTo(node.element) > 0) {\n\u00a0\u00a0\u00a0\u00a0node.right = delete(node.right, element);\n\u00a0\u00a0}\n\u00a0\u00a0if (element.compareTo(node.element) == 0) {\n\u00a0\u00a0\u00a0\u00a0// START: Handle deleting duplicates\n\u00a0\u00a0\u00a0\u00a0if (node.count > 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.count--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// END: Handle deleting duplicates\n\u00a0\u00a0\u00a0\u00a0...\n}\n```", "```java\nprivate boolean isIsomorphic(Node treeOne, Node treeTwo) {\n\u00a0\u00a0// step 1\n\u00a0\u00a0if (treeOne == null && treeTwo == null) {\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0// step 2\n\u00a0\u00a0if ((treeOne == null || treeTwo == null)) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0// step 3\n\u00a0\u00a0if (!treeOne.element.equals(treeTwo.element)) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0// steps 4, 5, 6 and 7\n\u00a0\u00a0return (isIsomorphic(treeOne.left, treeTwo.right)\n\u00a0\u00a0\u00a0\u00a0&& isIsomorphic(treeOne.right, treeTwo.left)\n\u00a0\u00a0\u00a0\u00a0|| isIsomorphic(treeOne.left, treeTwo.left)\n\u00a0\u00a0\u00a0\u00a0&& isIsomorphic(treeOne.right, treeTwo.right));\n}\n.\n```", "```java\nprivate void printRightViewIterative(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// enqueue root node\n\u00a0\u00a0Queue<Node> queue = new ArrayDeque<>();\n\u00a0\u00a0queue.add(root);\n\u00a0\u00a0Node currentNode;\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0// number of nodes in the current level is the queue size\n\u00a0\u00a0\u00a0\u00a0int size = queue.size();\n\u00a0\u00a0\u00a0\u00a0int i = 0;\n\u00a0\u00a0\u00a0\u00a0// traverse each node of the current level and enqueue its\n\u00a0\u00a0\u00a0\u00a0// non-empty left and right child\n\u00a0\u00a0\u00a0\u00a0while (i < size) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode = queue.poll();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if this is last node of current level just print it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == size) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(currentNode.element + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (currentNode.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(currentNode.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (currentNode.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(currentNode.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic void kthLargest(int k) {\n\u00a0\u00a0kthLargest(root, k);\n}\nprivate int c;\nprivate void kthLargest(Node root, int k) {\n\u00a0\u00a0if (root == null || c >= k) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0kthLargest(root.right, k);\n\u00a0\u00a0c++;\n\u00a0\u00a0// we found the kth largest value\n\u00a0\u00a0if (c == k) {\n\u00a0\u00a0\u00a0\u00a0System.out.println(root.element);\n\u00a0\u00a0}\n\u00a0\u00a0kthLargest(root.left, k);\n}\n```", "```java\nprivate Node mirrorTreeInTree(Node root) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0Node node = new Node(root.element);\n\u00a0\u00a0node.left = mirrorTreeInTree(root.right);\n\u00a0\u00a0node.right = mirrorTreeInTree(root.left);\n\u00a0\u00a0return node;\n}\n```", "```java\nprivate void mirrorTreeInPlace(Node node) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0Node auxNode;\n\u00a0\u00a0mirrorTreeInPlace(node.left);\n\u00a0\u00a0mirrorTreeInPlace(node.right);\n\u00a0\u00a0auxNode = node.left;\n\u00a0\u00a0node.left = node.right;\n\u00a0\u00a0node.right = auxNode;\n}\n```", "```java\npublic void spiralOrderTraversalRecursive() {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0int level = 1;\n\u00a0\u00a0boolean flip = false;\n\u00a0\u00a0// as long as printLevel() returns true there \n\u00a0\u00a0// are more levels to print\n\u00a0\u00a0while (printLevel(root, level++, flip = !flip)) {\n\u00a0\u00a0\u00a0\u00a0// there is nothing to do\n\u00a0\u00a0};\n}\n// print all nodes of a given level \nprivate boolean printLevel(Node root, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int level, boolean flip) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0if (level == 1) {\n\u00a0\u00a0\u00a0\u00a0System.out.print(root.element + \" \");\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0if (flip) {\n\u00a0\u00a0\u00a0\u00a0// process left child before right child\n\u00a0\u00a0\u00a0\u00a0boolean left = printLevel(root.left, level - 1, flip);\n\u00a0\u00a0\u00a0\u00a0boolean right = printLevel(root.right, level - 1, flip);\n\u00a0\u00a0\u00a0\u00a0return left || right;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0// process right child before left child\n\u00a0\u00a0\u00a0\u00a0boolean right = printLevel(root.right, level - 1, flip);\n\u00a0\u00a0\u00a0\u00a0boolean left = printLevel(root.left, level - 1, flip);\n\u00a0\u00a0\u00a0\u00a0return right || left;\n\u00a0\u00a0}\n}\n```", "```java\nprivate void printSpiralTwoStacks(Node node) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// create two stacks to store alternate levels\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0Stack<Node> rl = new Stack<>(); // right to left\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0Stack<Node> lr = new Stack<>(); // left to right \n\u00a0\u00a0// Push first level to first stack 'rl' \n\u00a0\u00a0rl.push(node);\n\u00a0\u00a0// print while any of the stacks has nodes \n\u00a0\u00a0while (!rl.empty() || !lr.empty()) {\n\u00a0\u00a0\u00a0\u00a0// print nodes of the current level from 'rl' \n\u00a0\u00a0\u00a0\u00a0// and push nodes of next level to 'lr'\n\u00a0\u00a0\u00a0\u00a0while (!rl.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node temp = rl.peek();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rl.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(temp.element + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lr.push(temp.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lr.push(temp.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// print nodes of the current level from 'lr' \n\u00a0\u00a0\u00a0\u00a0// and push nodes of next level to 'rl'\n\u00a0\u00a0\u00a0\u00a0while (!lr.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node temp = lr.peek();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lr.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(temp.element + \" \");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rl.push(temp.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (temp.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rl.push(temp.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nprivate void leafDistance(Node node, \n\u00a0\u00a0\u00a0\u00a0List<Node> pathToLeaf, Set<Node> nodesAtDist, int dist) {\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// for each leaf node, store the node at distance 'dist'\n\u00a0\u00a0if (isLeaf(node) && pathToLeaf.size() >= dist) {\n\u00a0\u00a0\u00a0\u00a0nodesAtDist.add(pathToLeaf.get(pathToLeaf.size() - dist));\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// add the current node into the current path\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0pathToLeaf.add(node);\n\u00a0\u00a0// go\u00a0\u00a0to left and right subtree via recursion\n\u00a0\u00a0leafDistance(node.left, pathToLeaf, nodesAtDist, dist);\n\u00a0\u00a0leafDistance(node.right, pathToLeaf, nodesAtDist, dist);\n\u00a0\u00a0// remove the current node from the current path\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0pathToLeaf.remove(node);\n}\nprivate boolean isLeaf(Node node) {\n\u00a0\u00a0return (node.left == null && node.right == null);\n}\n```", "```java\npublic boolean findPairSum(int sum) {\n\u00a0\u00a0return findPairSum(root, sum, new HashSet());\n}\nprivate static boolean findPairSum(Node node, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int sum, Set<Integer> set) {\n\u00a0\u00a0// base case\n\u00a0\u00a0if (node == null) {\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n\u00a0\u00a0// find the pair in the left subtree \n\u00a0\u00a0if (findPairSum(node.left, sum, set)) {\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0// if pair is formed with current node then print the pair\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0if (set.contains(sum - node.element)) {\n\u00a0\u00a0\u00a0\u00a0System.out.print(\"Pair (\" + (sum - node.element) + \", \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ node.element + \") = \" + sum);\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0set.add(node.element);\n\u00a0\u00a0}\n\u00a0\u00a0// find the pair in the right subtree \n\u00a0\u00a0return findPairSum(node.right, sum, set);\n}\n```", "```java\npublic boolean findPairSumTwoStacks(int sum) {\n\u00a0\u00a0return findPairSumTwoStacks(root, sum);\n}\nprivate static boolean findPairSumTwoStacks(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node node, int sum) {\n\u00a0\u00a0Stack<Node> fio = new Stack<>(); // fio - Forward In-Order\n\u00a0\u00a0Stack<Node> rio = new Stack<>(); // rio - Reverse In-Order\n\u00a0\u00a0Node minNode = node;\n\u00a0\u00a0Node maxNode = node;\n\u00a0\u00a0while (!fio.isEmpty() || !rio.isEmpty()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| minNode != null || maxNode != null) {\n\u00a0\u00a0\u00a0\u00a0if (minNode != null || maxNode != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (minNode != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fio.push(minNode);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minNode = minNode.left;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (maxNode != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rio.push(maxNode);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxNode = maxNode.right;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int elem1 = fio.peek().element;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int elem2 = rio.peek().element;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (fio.peek() == rio.peek()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((elem1 + elem2) == sum) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(\"\\nPair (\" + elem1 + \", \" \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ elem2 + \") = \" + sum);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((elem1 + elem2) < sum) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minNode = fio.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minNode = minNode.right;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxNode = rio.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxNode = maxNode.left;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\nprivate void verticalSum(Node root, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Map<Integer, Integer> map, int dist) {\n\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0if (!map.containsKey(dist)) {\n\u00a0\u00a0\u00a0\u00a0map.put(dist, 0);\n\u00a0\u00a0}\n\n\u00a0\u00a0map.put(dist, map.get(dist) + root.element);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0// or in functional-style\n\u00a0\u00a0/*\n\u00a0\u00a0BiFunction <Integer, Integer, Integer> distFunction\n\u00a0\u00a0\u00a0\u00a0= (distOld, distNew) -> distOld + distNew;\n\u00a0\u00a0map.merge(dist, root.element, distFunction);\n\u00a0\u00a0*/\n\u00a0\u00a0// decrease horizontal distance by 1 and go to left\n\u00a0\u00a0verticalSum(root.left, map, dist - 1);\n\u00a0\u00a0// increase horizontal distance by 1 and go to right\n\u00a0\u00a0verticalSum(root.right, map, dist + 1);\n}\n```", "```java\npublic static void convertToMinHeap(int[] maxHeap) {\n\u00a0\u00a0// build heap from last node to all \n\u00a0\u00a0// the way up to the root node\n\u00a0\u00a0int p = (maxHeap.length - 2) / 2;\n\u00a0\u00a0while (p >= 0) {\n\u00a0\u00a0\u00a0\u00a0heapifyMin(maxHeap, p--, maxHeap.length);\n\u00a0\u00a0}\n}\n// heapify the node at index p and its two direct children\u00a0\u00a0\u00a0\u00a0\nprivate static void heapifyMin(int[] maxHeap,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int p, int size) {\n\u00a0\u00a0// get left and right child of node at index p\n\u00a0\u00a0int left = leftChild(p);\n\u00a0\u00a0int right = rightChild(p);\n\u00a0\u00a0int smallest = p;\n\u00a0\u00a0// compare maxHeap[p] with its left and \n\u00a0\u00a0// right child and find the smallest value\n\u00a0\u00a0if ((left < size) && (maxHeap[left] < maxHeap[p])) {\n\u00a0\u00a0\u00a0\u00a0smallest = left;\n\u00a0\u00a0}\n\u00a0\u00a0if ((right < size) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& (maxHeap[right] < maxHeap[smallest]))\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0smallest = right;\n\u00a0\u00a0}\n\u00a0\u00a0// swap 'smallest' with 'p' and heapify\n\u00a0\u00a0if (smallest != p) {\n\u00a0\u00a0\u00a0\u00a0swap(maxHeap, p, smallest);\n\u00a0\u00a0\u00a0\u00a0heapifyMin(maxHeap, smallest, size);\n\u00a0\u00a0}\n}\n/* Helper methods */\nprivate static int leftChild(int parentIndex) {\n\u00a0\u00a0return (2 * parentIndex + 1);\n}\nprivate static int rightChild(int parentIndex) {\n\u00a0\u00a0return (2 * parentIndex + 2);\n}\n// utility function to swap two indices in the array\nprivate static void swap(int heap[], int i, int j) {\n\u00a0\u00a0int aux = heap[i];\n\u00a0\u00a0heap[i] = heap[j];\n\u00a0\u00a0heap[j] = aux;\n}\n```", "```java\nprivate boolean isSymmetricRecursive(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node leftNode, Node rightNode) {\n\u00a0\u00a0boolean result = false;\n\u00a0\u00a0// empty trees are symmetric\n\u00a0\u00a0if (leftNode == null && rightNode == null) {\n\u00a0\u00a0\u00a0\u00a0result = true;\n\u00a0\u00a0}\n\u00a0\u00a0// conditions 1, 2, and 3 from above\n\u00a0\u00a0if (leftNode != null && rightNode != null) {\n\u00a0\u00a0\u00a0\u00a0result = (leftNode.element.equals(rightNode.element))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& isSymmetricRecursive(leftNode.left, rightNode.right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& isSymmetricRecursive(leftNode.right, rightNode.left);\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic boolean isSymmetricIterative() {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0boolean result = false;\n\u00a0\u00a0Queue<Node> queue = new LinkedList<>();\n\u00a0\u00a0queue.offer(root.left);\n\u00a0\u00a0queue.offer(root.right);\n\u00a0\u00a0while (!queue.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0Node left = queue.poll();\n\u00a0\u00a0\u00a0\u00a0Node right = queue.poll();\n\u00a0\u00a0\u00a0\u00a0if (left == null && right == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = true;\n\u00a0\u00a0\u00a0\u00a0} else if (left == null || right == null \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| left.element != right.element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = false;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.offer(left.left);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.offer(right.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.offer(left.right);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.offer(right.left);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return result;\n}\n```", "```java\npublic int minimumCost(int[] ropeLength) {\n\u00a0\u00a0if (ropeLength == null) {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0// add the lengths of the ropes to the heap\n\u00a0\u00a0for (int i = 0; i < ropeLength.length; i++) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0add(ropeLength[i]);\n\u00a0\u00a0}\n\u00a0\u00a0int totalLength = 0;\n\u00a0\u00a0while (size() > 1) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0int l1 = poll();\n\u00a0\u00a0\u00a0\u00a0int l2 = poll();\n\u00a0\u00a0\u00a0\u00a0totalLength += (l1 + l2);\n\u00a0\u00a0\u00a0\u00a0add(l1 + l2);\n\u00a0\u00a0}\n\u00a0\u00a0return totalLength;\n}\n```"]