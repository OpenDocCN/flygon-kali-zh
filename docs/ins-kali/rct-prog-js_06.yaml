- en: Chapter 6. Functional Reactive Programming – The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。函数式响应式编程-基础知识
- en: 'I might begin here by somewhat awkwardly mentioning that I have a Master''s
    degree in math and lots of math awards, but I find some of the mathematical concepts
    associated with basic functional programming to be a tad slippery. One wouldn''t
    discourage someone strong in the relevant math and computer science fields from
    tackling the full mathematical rigor of, for example, the foundational functional
    reactive programming papers linked to in the Wikipedia article on functional reactive
    programming. However, the intent here is slightly different: to learn something
    from functional reactive programming that is useful to professional developers
    who do not have, or do not remember, the level of mathematical formation that
    informs those seminal works.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能从这里有点尴尬地提到，我有数学硕士学位和许多数学奖项，但我发现与基本函数式编程相关的一些数学概念有点难以理解。一个人不会阻止在相关数学和计算机科学领域有扎实基础的人去攻克，例如，在维基百科关于函数式响应式编程中链接的基础性函数式响应式编程论文的完整数学严谨性。然而，这里的意图略有不同：从函数式响应式编程中学到对于没有或不记得那些开创性作品所依赖的数学水平的专业开发人员有用的东西。
- en: StackOverflow comments repeatedly ask, "Can you explain it in a way that doesn't
    assume a PhD in computational mathematics?" The intent here is not to provide
    the whole of those mathematical articles together, but a subset that can be practical
    and is useful to real professional software developers who do not dream in Scheme
    or Haskell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: StackOverflow的评论反复问道，“你能不能以不假设计算数学博士的方式解释它？”这里的意图不是提供那些数学文章的全部内容，而是提供一个对于真正的专业软件开发人员有用的、实用的子集，他们不会梦见Scheme或Haskell。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: A trip down computer folklore's memory lane
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机传统的记忆之旅
- en: Functional reactive programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: If you learn just one thing…
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只学到一件事……
- en: Learn what you can about functional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解有关函数式编程的知识
- en: The future of frontend web development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端Web开发的未来
- en: Let's dig in. The folklore-laden trip down memory lane may be fairly long, but
    it is not, in any sense, dull.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解。这段充满传统的记忆之旅可能会相当漫长，但在任何意义上都不会枯燥无味。
- en: A trip down computer folklore's memory lane
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机传统的记忆之旅
- en: There is a scathingly insulting checklist that has been floating around to apply
    to pet (or other) programming languages. One of the put-downs is, "Programmers
    should not have to understand category theory to write, *Hello, World!*" It reflects,
    in part, an irritation of mistakes that wet-behind-the-ears juniors keep making
    when they propose the best programming language yet. In that, it might be compared
    to the viral evil overlord list of stupid things that keep happening in adventure
    movies. Learning from the mistakes of countless movie villains, the author declares
    that "Shooting is not too good for my enemies" and "I will not include a self-destruct
    mechanism unless absolutely necessary…" The put-downs come from frustration at
    seeing the same mistakes again and again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常侮辱性的检查表一直在流传，适用于宠物（或其他）编程语言。其中一个侮辱是，“程序员不应该需要理解范畴论来编写*Hello, World!*”这反映了部分湿后耳朵的初级程序员在他们提出最好的编程语言时不断犯的错误的烦恼。在这方面，它可能与愚蠢的事情清单一样，愚蠢的事情清单是从无数冒险电影中发生的愚蠢事情中学到的。作者从无数电影反派的错误中吸取教训，宣称“射击对我的敌人来说并不是太好”，“除非绝对必要，我不会包括自毁机制……”这些侮辱来自于一次又一次看到相同错误的挫败感。
- en: There are other points that show programming wit and wisdom. For one example,
    there are orders of magnitude more pet or toy languages than successful languages,
    where success can either be in academic computer science circles or business information
    technology. One widely recognized turning point in the development of any language
    is when it works at a level where one could *dogfood* it by using it to write
    its own compiler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些显示编程智慧和智慧的观点。例如，宠物或玩具语言的数量级比成功的语言要多得多，成功可以是在学术计算机科学领域或商业信息技术领域。任何语言发展中被广泛认可的转折点是，当它在一个可以通过使用它来编写自己的编译器的水平上工作时。
- en: 'And this is not an insignificant point; when Java was first announced, it was
    declared that the Java compiler was written in Java itself, with the implication
    that a system that could run the Java runtime environment should be able to compile
    software written in Java. In relation to this, a standard question to insult someone''s
    enthusiastically gushed-about pet language is, "Has it been used to write anything
    besides its own compiler?" And this particular node of computer wisdom and folklore
    is baked into the checklist: two of the entries are, in quick succession, "The
    most significant program written in this language is its own compiler" and then,
    even more insultingly, "The most significant program written in this language
    isn''t even its own compiler".'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个不重要的观点；当Java首次宣布时，宣称Java编译器是用Java本身编写的，这意味着能够运行Java运行时环境的系统应该能够编译用Java编写的软件。在这方面，一个常见的侮辱某人对自己热情洋溢的宠物语言的标准问题是，“除了自己的编译器，它还用来写过其他东西吗？”计算机智慧和传统的这一特定节点已经融入了检查表：其中两个条目是，“用这种语言编写的最重要的程序是它自己的编译器”，然后，更具侮辱性的是，“用这种语言编写的最重要的程序甚至不是它自己的编译器”。
- en: 'But the philosophical objection of, "Programmers should not need to understand
    category theory to write, *Hello, World!*" is not simply making things up to sound
    insulting. There is a tradition started by the 1978 first edition of Kernigan
    and Ritchie''s classic *The C Programming Language*, where the first program developed
    before diving into intricacies was a minimal C program, on the thought of "Let''s
    crawl before we try to walk," to print out *Hello, World!*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，“程序员不应该需要理解范畴论来编写*Hello, World!*”的哲学反对意见并不是为了听起来侮辱而凭空捏造的。这是由1978年Kernigan和Ritchie经典著作《C程序设计语言》第一版开始的传统，在深入研究复杂性之前开发的第一个程序是一个最小的C程序，思想是“让我们在尝试行走之前先爬”，打印出*Hello,
    World!*：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: People introducing new programming languages overwhelmingly follow in the tradition
    of using `Hello, World!` as their first sample program. That's one end of "Programmers
    should not need to understand category theory to write, *Hello, World!*" So what
    is the other end of the spectrum?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍新编程语言的人普遍遵循使用“Hello, World!”作为他们的第一个示例程序的传统。这是“程序员不需要理解范畴论就能编写*Hello, World!*”的一端。那么光谱的另一端是什么？
- en: 'In the world of academic mathematics, whether pure or applied, mathematics
    as a sign of success has become very specialized (like almost any domain that''s
    had enough work). It has been commented that it''s a rare beast of a mathematician
    who can understand more than 13 of 50 papers presented at a math conference. Mathematics
    has become specialized enough that most math PhDs, however competent, cannot understand
    the work of most other math PhDs. In that case this doesn''t make sense, the hope
    of being able to understand all of mathematics is like the hope of being able
    to speak all human languages: a bit naïve. The point of a math PhD program is
    perhaps not to develop you to the point of being able to follow the whole breadth
    of the discipline of mathematics, but to understand some narrow area deeply enough
    that, by the time your PhD is complete, you understand that highly focused area
    better than anyone else in the world.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术数学世界中，无论是纯数学还是应用数学，数学作为成功的标志已经变得非常专业化（就像任何经历了足够工作的领域一样）。有评论说，能够理解数学会议上提出的50篇论文中的13篇以上的数学家是非常罕见的。数学已经变得足够专业化，以至于大多数数学博士，无论多么有能力，都无法理解大多数其他数学博士的工作。在这种情况下，希望能够理解所有数学就像希望能够说出所有人类语言一样：有点天真。数学博士项目的目的也许不是让你发展到能够理解数学学科的整个广度，而是深入理解某个狭窄领域，以至于在你的博士学位完成时，你比世界上任何其他人更深入地理解了这个高度专注的领域。
- en: There are two exceptions of a sort, disciplines that connect all of mathematics,
    but from completely opposite directions. On one hand, there is logic and the foundations
    of mathematics, which looks at the bedrock that all other areas of mathematics
    is founded on. Now there are some questions about whether logic belongs to math
    or philosophy, and one hears of people asked to decide whether they want to be
    logicians or mathematicians. But setting aside some of these questions, it would
    not be too controversial to say that logic connects to all of mathematics by digging
    into the bedrock that the rest of mathematics rests on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种例外，连接所有数学的学科，但从完全相反的方向。一方面是逻辑和数学基础，它研究了所有其他数学领域所基础的基石。现在有一些关于逻辑属于数学还是哲学的问题，人们也听说过有人被要求决定他们想成为逻辑学家还是数学家。但撇开这些问题，可以说逻辑通过挖掘其他数学领域所依赖的基石与所有数学领域相连接。
- en: 'And then there''s the other option: *category theory*. A Barbie doll once said,
    "Math is hard", but the mathematical community understands that very well without
    Barbie''s help. Albert Einstein said, "Do not worry about your difficulties with
    mathematics. I can assure you that mine are greater still." But the branch of
    mathematics called category theory is particularly and obnoxiously harder.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有另一种选择：*范畴论*。一个芭比娃娃曾经说过，“数学很难”，但数学界很清楚这一点，不需要芭比的帮助。阿尔伯特·爱因斯坦说过，“不要担心你在数学上的困难。我可以向你保证，我的困难更大。”但数学分支范畴论尤其难以理解。
- en: If logic can study the bedrock that the great edifice of mathematics is built
    on, category theory looks at the already built city and explores architectural
    themes and similarities running through all kinds of mathematical neighborhoods.
    Category theory is a discipline a bit like the academic discipline of comparative
    in that practitioners are expected to be able to cope with comparative literature
    in not just one, but several languages. It could be argued that category theory
    is the most difficult place under the whole mathematical umbrella. You need to
    do something most math PhDs are never taught.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑可以研究数学伟大建筑的基石，范畴论则着眼于已经建成的城市，并探索贯穿各种数学领域的建筑主题和相似之处。范畴论是一门学科，有点像比较文学学科，从业者被期望能够应对不只一种语言的比较文学。可以说范畴论是整个数学领域中最困难的地方。你需要做一些大多数数学博士从未学过的事情。
- en: Also, it is perhaps a tribute that my thesis advisor, who was a category theorist,
    was able to effectively supervise a thesis in the obscure branch of point-set
    topology even though he did not show any particular specialization in point-set
    topology. So saying that a programmer using your language needs to understand
    category theory to write *Hello, world!* is quite the scathing insult.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也许是一种致敬，我的导师是一位范畴论家，他能够有效地指导一个关于点集拓扑这个鲜为人知的分支的论文，尽管他在点集拓扑方面并没有显示出特别的专长。因此，说一个使用你的语言的程序员需要理解范畴论才能编写*Hello,
    world!*是相当刻薄的侮辱。
- en: So what does this have to do with functional or functional reactive programming?
    Glad you asked!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这与函数式或函数式反应式编程有什么关系呢？很高兴你问！
- en: 'In the sources linked to in the Wikipedia article for functional reactive programming,
    Haskell (or something built on it) is the dominant language. There are a couple
    of other players, such as a dialect of Scheme, but people seem to keep coming
    back to Haskell. There are a number of Haskell resources out there; one of the
    most respected is *Learn You a Haskell for Great Good*, [http://tinyurl.com/reactjs-learn-haskell](http://tinyurl.com/reactjs-learn-haskell).
    It has a *Hello, World!* program that mysteriously appears in the ninth chapter
    instead of the first. Why the ninth? Well, as explained, input and output are
    built on top of monads. But does it really take that much explanation to get to
    monads? Yes; monads are built on top of the concept of applicative functors, which
    are built on the basic concept of functors, which ring a bell as the name of something
    met in math grad school and not really understood. Let''s visit the Wikipedia
    page for functors. The Wikipedia is known for being something that is clear and
    easy to read. And there are a couple of things in the Wikipedia page for functors.
    One is that the language is awfully esoteric for the Wikipedia. The other point
    is that functors are in fact something acquired from category theory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科文章中链接的函数式响应式编程的资源中，Haskell（或者构建在其上的东西）是主导语言。还有一些其他的语言，比如Scheme的一个方言，但人们似乎总是回到Haskell。有很多Haskell的资源；其中最受尊敬的之一是《学习Haskell为了更好的》[http://tinyurl.com/reactjs-learn-haskell](http://tinyurl.com/reactjs-learn-haskell)。它在第九章中神秘地出现了一个*Hello,
    World!*程序，而不是第一章。为什么是第九章？嗯，正如解释的那样，输入和输出是建立在单子之上的。但是真的需要这么多的解释才能理解单子吗？是的；单子是建立在应用函子的概念之上的，而应用函子是建立在函子的基本概念之上的，这让人想起在数学研究生阶段遇到的某个名字，但并没有真正理解。让我们去维基百科的函子页面看看。维基百科以清晰易读而闻名。维基百科页面中有一些内容。其中一点是，语言对于维基百科来说实在是太过神秘了。另一点是，函子实际上是从范畴论中获得的东西：
- en: '*In mathematics, a functor is a type of mapping between categories, which is
    applied in category theory. Functors can be thought of as homomorphisms between
    categories. In the category of small categories, functors can be thought of more
    generally as morphisms.*'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在数学中，函子是范畴之间的一种映射，适用于范畴论。函子可以被看作是范畴之间的同态。在小范畴的范畴中，函子可以被更普遍地看作是态射。*'
- en: Functors were first considered in algebraic topology, where algebraic objects
    (such as the fundamental group) are associated with topological spaces, and algebraic
    homomorphisms are associated with continuous maps. Nowadays, functors are used
    throughout modern mathematics to relate to various categories. Thus, functors
    are generally applicable in areas within mathematics that category theory can
    make an abstraction of.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函子最初是在代数拓扑学中考虑的，在那里，代数对象（如基本群）与拓扑空间相关联，代数同态与连续映射相关联。如今，函子在现代数学中被广泛应用于各种范畴。因此，函子通常适用于数学中范畴论可以进行抽象的领域。
- en: Advanced prerequisites for Hello, World!
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello, World!的高级先决条件！
- en: 'If you want a challenge, read the Wikipedia article on functors. But if you
    find yourself skimming because it''s mostly over your head, you''re in good company:
    possibly a lot of math Ph.D.''s tend to skim the same way you would, for much
    the same reason.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想挑战自己，可以阅读维基百科关于函子的文章。但如果你发现自己只是匆匆浏览，因为大部分内容都超出了你的理解范围，那么你不用担心：可能很多数学博士也会以同样的方式匆匆浏览，出于同样的原因。
- en: There is more that can be said at this point, but I'll limit myself to one further
    remark after commenting on the intent of this chapter. This leads into the central
    difficulty of this chapter. This is a text on information technology rather than
    computer science, and while one may check in with computer scientists, this text
    is intended to be written from the perspective of one programmer who doesn't follow
    all the layers of math to another. The equivalent of the goal in Haskell, would
    be to say on a *monkey see, monkey do* basis, "This is an example of a pure function;
    that is an example of an input and output monad. Try to do as much of your heavy
    lifting as possible from the pure portion of your program and confine input and
    output to as small a quarantined space as possible."
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上还有更多可以说的，但我将限制自己在评论本章意图之后再做一点补充。这导致了本章的核心困难。这是一本关于信息技术而不是计算机科学的文本，虽然可以向计算机科学家请教，但这本文本的撰写意图是从一个程序员的角度向另一个程序员撰写。在Haskell中，目标相当于基于*看到，模仿*的基础上说，“这是一个纯函数的例子；那是一个输入和输出单子的例子。尽量让你的程序的大部分工作都来自纯部分，并将输入和输出限制在尽可能小的隔离空间中。”
- en: 'And there is one point where one would contrast Haskell with Python, starting
    again with XKCD—note what is given as the first example of everything being simple
    in Python. One''s first encounter with Python leads to the feeling of being head
    over heels in love with programming again. The same is entirely true of ReactJS,
    which is like discovering the web for the first time all over again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点可以用Haskell和Python进行对比，再次以XKCD为例——注意Python中给出的一切都是简单的第一个例子。第一次接触Python会让人感觉再次爱上编程。同样的情况也完全适用于ReactJS，就像再次发现网络一样：
- en: '![Advanced prerequisites for Hello, World!](img/B04108_06_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Hello, World!的高级先决条件！](img/B04108_06_1.jpg)'
- en: 'Python and Haskell are similar in at least one respect: they both allow rapid
    software development. Haskell boasts a similar feature to what one would expect
    of Python: an undergraduate spent a few months and implemented a good deal of
    the Quake 3 engine in Haskell. There may be other strengths to Haskell, such as
    its rock solid type system, and by the time something compiles, it already stands
    a good chance of working. However, the question pursued here is, "Does it make
    programmers highly productive?" This screen shot is from a Quake 3 level implemented
    in a few months for a one student''s undergraduate project. There are things Haskell
    has that Python doesn''t: a rock-solid type system, for instance. However, Haskell
    and Python are similar at least in this: in the hands of a proficient developer,
    they allow productivity and pace of development that needs to be seen before it
    can believed.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python和Haskell在至少一个方面相似：它们都允许快速软件开发。Haskell拥有与Python所期望的类似功能：一名本科生花了几个月的时间，在Haskell中实现了Quake
    3引擎的大部分功能。Haskell可能还有其他优势，比如其非常可靠的类型系统，而且一旦某些东西编译完成，它就已经有很大的可能性可以工作。然而，这里追求的问题是，“它能让程序员高效生产吗？”这个屏幕截图来自一个本科生项目中在几个月内实现的Quake
    3级别。Haskell有一些Python没有的东西：比如非常可靠的类型系统。然而，Haskell和Python至少在这一点上是相似的：在熟练开发者的手中，它们都允许生产力和开发速度，这需要在看到之前才能相信。
- en: '![Advanced prerequisites for Hello, World!](img/B04108_06_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Hello, World!的高级先决条件](img/B04108_06_2.jpg)'
- en: But, while seasoned programmers may try Python and find themselves flying, if
    they can't handle the math, they won't have the same experience using Haskell.
    Haskell offers rapid development super powers to people who can handle a good
    deal of computational math. Python offers such powers to a much wider group of
    programmers, whether or not they have a heavy math background.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有经验的程序员可能会尝试Python并发现自己能够游刃有余，但如果他们无法处理数学，他们在使用Haskell时就不会有相同的体验。Haskell为那些能够处理大量计算数学的人提供了快速开发的超能力。Python为更广泛的程序员群体提供了这样的能力，无论他们是否具有丰富的数学背景。
- en: This chapter is an attempt, rightly or wrongly, to explain things so that workers
    in information technology, rather than computer science specifically, can have
    a seasoned programmer's good Python experience with functional reactive programming
    and ReactJS, instead of a seasoned programmer's bad Haskell experience that leads
    so many developers to keep on making comments that become very sad after a while,
    depressing comments such as "I might understand this if I just knew more math."
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是一个尝试，无论对错，都是为了解释事情，以便信息技术工作者，而不仅仅是计算机科学专业人员，可以像有经验的程序员一样，用函数式响应式编程和ReactJS获得良好的Python体验，而不是导致许多开发人员继续发表令人沮丧的评论的有经验的程序员的糟糕的Haskell体验，这些评论在一段时间后变得非常悲伤，比如“如果我懂得更多数学，我可能会理解这个”。
- en: 'The purpose of our writing this book is to make a book useful for programmers
    in the field, not just computer science students who know a lot of math. But an
    easier approach is at least hinted at, along with seasoned programmers saying
    "I might get this if I knew more math." Taken directly from the page [http://tinyurl.com/reactjs-learn-monads](http://tinyurl.com/reactjs-learn-monads).
    Now, here are some steps on how to learn Monads:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写这本书的目的是为了使程序员在这个领域有用，而不仅仅是懂很多数学的计算机科学学生。但至少暗示了一种更简单的方法，以及有经验的程序员说“如果我懂得更多数学，我可能会理解这个”。直接从页面[http://tinyurl.com/reactjs-learn-monads](http://tinyurl.com/reactjs-learn-monads)获取。现在，以下是学习单子的一些步骤：
- en: Get a PhD in computer science.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得计算机科学博士学位。
- en: Throw it away because you don't need it for this section!
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把它丢掉，因为你在这一部分不需要它！
- en: (Perhaps ordinary developers can, after all, profit from (reactive) functional
    programming!)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: （也许普通开发人员终究可以从（响应式）函数式编程中获益！）
- en: Distinguishing the features of functional reactive programming
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分函数式响应式编程的特点
- en: 'One of the leading lights of functional reactive programming, and arguably
    a grandfather to functional reactive programming, Conal Elliott, looked back on
    the term "functional reactive programming," and a leading light''s second thoughts
    about a name can be very interesting. Elliott expressed a reservation about the
    term *functional*, suggesting that the word means so many things now that it means
    very little, and expressed a regret about a word that the term didn''t include:
    time. He suggested an alternative name of denotative continuous-time programming,
    which is significant even if we use the more standard term of "functional reactive
    programming" here. By *denotative*, we mean, as we discussed earlier about ReactJS,
    that you specify only what needs to be accomplished, not every step of how to
    accomplish it. Continuous-time did not merely mean that it should be called such,
    but that continuous time was important enough that it should be baked into the
    name for what is now called functional reactive programming.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数式响应式编程的领军人物之一，也可以说是函数式响应式编程的鼻祖之一，Conal Elliott回顾了术语“函数式响应式编程”，一个领军人物对于名称的反思可能会非常有趣。Elliott对术语“函数式”表示了保留意见，他认为这个词现在意味着很多东西，因此意义不大，并对术语没有包含的一个词表示遗憾：时间。他提出了一个另类的名称，即指示性连续时间编程，即使我们在这里使用更标准的术语“函数式响应式编程”，这也是重要的。通过“指示性”，我们的意思是，正如我们之前讨论ReactJS时所讨论的，你只需指定需要完成的任务，而不是每一步如何完成它。连续时间不仅仅意味着应该这样称呼它，而且连续时间是如此重要，以至于它应该被纳入现在所谓的函数式响应式编程的名称中。
- en: The continuous time element comes up in the sources and may seem surprising
    to some, since computers only measure time discretely, but the distinction is
    a distinction in a conceptual model rather than a feature observed in implementations.
    The comparison is made to infinite lists as they exist in functional languages,
    where one may take as much or as little from a list without running out of precomputed
    entries, or perhaps more saliently to the difference between raster graphics (GIF,
    JPEG, PNG), which have a certain fixed number of pixels represented, and vector
    graphics (SVG, some PDF) where admittedly, an image is rendered to be displayed
    on something with a concrete number of fixed pixels, but an SVG logo can be rendered
    in accordance with a classic advertising executive's quote that a company logo
    should look as good one sixteenth of an inch high on letterhead as it does eight
    feet tall on top of corporate headquarters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 连续时间元素出现在这些来源中，对一些人来说可能会感到惊讶，因为计算机只能离散地测量时间，但这种区别是概念模型中的区别，而不是实现中观察到的特征。这种比较类似于函数式语言中存在的无限列表，人们可以从列表中取出多少或多少而不会用完预先计算的条目，或者更明显地是栅格图形（GIF、JPEG、PNG）与矢量图形（SVG、一些PDF）之间的区别，栅格图形有一定数量的像素表示，而矢量图形可以根据经典广告执行人员的说法进行渲染，公司标志在信头上高一英寸时看起来和在公司总部的八英尺高处一样好看。
- en: Continuous time means that time is handled like SVG or other vector graphics,
    not raster GIF/JPEG/PNG, which is stored at a fixed resolution and not a pixel
    more. One of the suggestions made for functional reactive programming is that
    continuous-time events and probably continuous-valued behaviors or streams of
    events have a first-class entity status as one of the defining features (though,
    some might point out, perhaps not the only one) is that functions are first-class
    entities that can be passed as arguments, as one does in JavaScript and other
    languages with anonymous functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 连续时间意味着时间的处理方式类似于SVG或其他矢量图形，而不是栅格GIF/JPEG/PNG，后者存储在固定分辨率上，没有多余的像素。对于函数式响应式编程的建议之一是，连续时间事件和可能是连续值行为或事件流具有第一类实体的地位，作为定义特征的一部分（尽管有人可能指出，也许不是唯一的特征）是函数是第一类实体，可以作为参数传递，就像JavaScript和其他语言中的匿名函数一样。
- en: It may not be immediately obvious how ReactJS relates to this; I've watched
    over a dozen ReactJS videos, usually from Facebook developers. There is emphatic
    mention of *denotational symantics*, a formal term to describe only what needs
    to be accomplished and not every step of how to accomplish it. And there is consistent
    discussion of the virtual DOM, which amounts to "You can learn more if you want,
    but all you need to do is tell how to `render()`, and trust the system to do all
    the rest." But in fact, continuous time semantics are baked into how ReactJS works
    at a very basic level. Part of the developer's responsibility is to write a `render()`
    method that specifies what should appear on the page at the time it is called
    (and, perhaps, to call `render()` appropriately; `render()` doesn't run by itself).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS与这个有什么关系可能并不立即明显；我看过十多个ReactJS视频，通常是来自Facebook开发人员。强调了*指称语义*，这是一个正式术语，用来描述只需要完成什么，而不是如何完成每一步。还有关于虚拟DOM的持续讨论，这相当于“如果你想了解更多，你可以学习，但你只需要告诉系统如何`render()`，然后相信系统会完成其余的工作。”但事实上，连续时间语义是内置在ReactJS的基本工作原理中的。开发人员的责任之一是编写一个`render()`方法，指定在调用时页面上应该显示什么（也许还要适当地调用`render()`；`render()`不会自己运行）。
- en: This does not have every feature of continuous time; one instructional video
    hints at a system that does not just work in real time, but allows VCR-style "rewind"
    and "fast forward" functionality to step through time, and one of Pete Hunt's
    ReactJS videos hints that Facebook, through ReactJS technology, might take a bug
    report and be able to replay, detail by detail, what went wrong before someone
    gave a bug report with no written description of what went wrong beyond "a profanity."
    However, the front and center use case is one where continuous time is assumed
    and it is the developer's responsibility to make a `render()` function that can
    correctly say what to render the instance it is called, and (incidentally) to
    call that function appropriately.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不具备连续时间的所有特性；一个教学视频暗示了一个系统，不仅可以实时工作，还可以允许类似VCR的“倒带”和“快进”功能来逐步通过时间，Pete Hunt的一个ReactJS视频暗示了Facebook可能通过ReactJS技术接收一个错误报告，并能够逐个细节地重放发生错误之前的情况，而没有书面描述错误的情况，只是“粗话”。然而，最突出的用例是假定连续时间，并且开发人员有责任编写一个`render()`函数，可以在调用时正确地指定要渲染的内容，并且（顺便）适当地调用该函数。
- en: If you learn just one thing...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果你只学到一件事...
- en: 'Richard P. Feynman''s classic "Feynman lectures," held as an exemplar of clear
    explanation of technical topics, opens with a very simple question: if all else
    of science were forgotten and only one sentence''s worth of information survived,
    what would that ideally be? Feynman gave a succinct answer that actually says
    quite a lot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 理查德·P·费曼的经典“费曼讲义”被认为是对技术主题进行清晰解释的典范，他以一个非常简单的问题开篇：如果科学的其他一切都被遗忘，只有一句话的信息幸存下来，那么理想情况下会是什么？费曼给出了一个简洁的答案，实际上表达了很多内容：
- en: '*"If, in some cataclysm, all of scientific knowledge were to be destroyed,
    and only one sentence passed on to the next generation of creatures, what statement
    would contain the most information in the fewest words? I believe it is the atomic
    hypothesis that **all things are made of atoms — little particles that move around
    in perpetual motion, attracting each other when they are a little distance apart,
    but repelling upon being squeezed into one another.** In that one sentence, you
    will see, there is an enormous amount of information about the world, if just
    a little imagination and thinking are applied."*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"如果在某场灾难中，所有的科学知识都被摧毁，只有一句话传给下一代生物，哪句话会包含最多信息？我相信那就是原子假设，即**一切事物都是由原子组成的——小颗粒在永恒的运动中移动，当它们相距一点时相互吸引，但当它们被挤压到一起时则相互排斥。**在这一句话中，你会看到，关于世界的大量信息，只要稍加想象和思考。"*'
- en: And this serves as the springboard, in the Feynman lectures, to say a lot about
    physics as we know it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这在费曼讲座中作为一个跳板，可以让我们对我们所知道的物理学说很多。
- en: 'The biggest learning point from functional reactive programming that can be
    put into a single sentence is a lesson associated with the functional programming
    itself, that functional reactive programming further refines: *Spend as much time
    writing pure functions, math-style, as you can, and as little time as possible
    writing or following recipes*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程的最大学习要点可以用一句话概括，这是与函数式编程本身相关的一堂课，函数式响应式编程进一步完善了这一点：*尽可能多地编写纯函数，数学风格的，尽可能少地编写或遵循配方*。
- en: A recipe says such things as "Preheat your oven to 350 °F. Mix the leaves, ghee,
    and salt together in a large bowl. Line two large baking trays with parchment.
    Divide the leaves evenly in a single layer on each tray..." Now this is not taking
    a dig at home economics and people who cook. (A purely functional approach to
    cooking would never produce anything edible, a minor drawback if you want to get
    anything done.) Recipes are equally to be found in the many, many YouTube videos
    detailing how to replace, for example, a broken wiper blade on a 2004 Ford Escort,
    and they power traditional hacker-written How-to's, which are less prominent today
    than they were earlier, not because the hacker community has realized that using
    a How-to is not an appropriate way to resolve a difficulty when following your
    nose is getting you nowhere, but because the general usability of almost everything
    has improved enough that you don't need a How-to that mentions the moon phase
    if you want to burn a CD; How-tos are much less likely to be the only game in
    town (which is really their best use case).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 配方会说一些诸如“将烤箱预热至350°F。在一个大碗中混合叶子、酥油和盐。用羊皮纸在两个大烤盘上铺一层。将叶子均匀分布在每个托盘上的一层中…”现在这并不是在挖苦家政和烹饪的人。（纯粹的功能性烹饪方法永远不会产生任何可食用的东西，如果你想完成任何事情，这是一个小缺点。）配方同样可以在许多许多YouTube视频中找到，详细说明如何更换，例如2004年福特Escort上的破损雨刷，它们也支持传统的黑客编写的How-to，尽管它们在今天不像早期那样突出，这并不是因为黑客社区意识到使用How-to不是解决困难的适当方式，而是因为几乎所有事物的通用性都得到了足够的改善，以至于你不需要一个在烧录CD时提到月相的How-to；How-to很少可能是唯一的选择（这实际上是它们最好的用例）。
- en: 'I am somewhat concerned with what theoretical contortions Haskell went through
    (read: *needed* to go through) to include input and output with minimal compromise
    to its functional status. But all the same, even if purely functional JavaScript
    may or may not be possible, we would do well to grow the portion of our software
    that is purely functional and minimize what gets work done by specifying how to
    do things. Functions here should not mean, as in structured programming, "a subroutine
    that returns a value." A function is not doing something plus returning something
    interesting when it is done. It rather has the mathematical sense of "something
    that takes zero or more arguments and does neither more nor less than return a
    value that is arrived at based on that value."'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我对Haskell经历了哪些理论上的扭曲（即：*需要*经历）以最小程度地妥协其功能状态来包含输入和输出有些担忧。但同样，即使纯粹的函数式JavaScript可能存在与否，我们最好还是尽量增加我们的软件部分是纯函数式的，并最小化通过指定如何做事来完成工作的部分。这里的函数不应该像结构化编程中那样意味着“返回一个值的子例程”。一个函数不是在做某事并在完成时返回一些有趣的东西。它更多地具有数学上的意义，“接受零个或多个参数，并且不多不少地返回一个基于该值得到的值。”
- en: Examples of pure functions from basic mathematics used by computer people include
    arithmetic functions such as addition, subtraction, multiplication, division,
    exponentiation, factorial (4 factorial, for instance, is 4 * 3 * 2 * 1), Fibonacci
    numbers, trigonometric functions such as sine and cosine, hyperbolic functions,
    integral, derivative, Euclidean division to calculate the greatest common divisor
    between two positive integers, and so on. Without exception, these take zero or
    more (or, as the case may be for these, one or more) inputs, and yield something
    calculated from them without making any external changes; none of them update
    a database or output something to the console. They just take their inputs and
    deterministically calculate an output, no more, no less. That is of the essence
    of a pure function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机人员使用的基本数学中的纯函数的例子包括算术函数，如加法、减法、乘法、除法、指数、阶乘（例如，4的阶乘是4*3*2*1），斐波那契数，三角函数，如正弦和余弦，双曲函数，积分，导数，欧几里得除法来计算两个正整数之间的最大公约数，等等。毫无例外，这些函数接受零个或更多个（或者，对于这些情况，一个或更多个）输入，并从中计算出一些东西，而不做任何外部更改；它们没有更新数据库或输出东西到控制台。它们只是接受它们的输入，并确定性地计算出一个输出，不多不少。这就是纯函数的本质。
- en: A **sesquipedalian** term is "a word that is a foot and a half long." Some of
    them float around, including in videos on ReactJS and functional reactive programming,
    such as idempotent and **referential transparency**. But the meanings are simple
    and straightforward in relation to pure functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**长词**是“一个半英尺长的词”。其中一些词在各处流传，包括在关于ReactJS和函数式响应式编程的视频中，比如幂等和**引用透明度**。但是与纯函数相关的含义是简单而直接的。'
- en: 'An idempotent function is the one that returns the same result whether you
    call it once or a hundred times. In mathematics, addition and factorial, for instance,
    always give the same result. RESTful web services offer a less mathematical example
    of idempotence: requesting the same URL means getting the same HTML or other data,
    every single time. Getting static content is idempotent; a version of a library
    pulled from CDN should result in the same download no matter who requests it,
    where, or when.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等函数是指无论调用一次还是一百次，都会返回相同结果的函数。在数学中，例如加法和阶乘，总是给出相同的结果。RESTful网络服务提供了一个较少数学的幂等性的例子：请求相同的URL意味着每次都会得到相同的HTML或其他数据。获取静态内容是幂等的；从CDN获取的库的版本应该无论谁、在哪里或何时请求，都会得到相同的下载。
- en: Caching, such as one aims for with Steve Souder's classic far-future *Expires*
    headers for Yslow, is a useful thing to do precisely where there is idempotence
    between downloads. (If a download is idempotent, a document is the same document
    regardless of whether one downloaded a fresh copy or supplied it from your browser's
    cache.) Dynamic content, whether old-fashioned CGI scripts or dynamic Django applications,
    is not idempotent. If a page says, even in an HTML comment, "This page downloaded
    at such-and-such time," it is not idempotent. The Web was designed from the beginning
    to be idempotent; later on people started to realize that dynamic content could
    be highly desirable and worked on how to overcome the stateless, idempotent design
    of HTTP.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存，比如使用Steve Souder的经典远期*Expires*头部来实现Yslow，是一种非常有用的方法，特别是在下载之间存在幂等性的情况下。（如果下载是幂等的，无论是下载新副本还是从浏览器缓存中提供副本，文档都是相同的。）动态内容，无论是老式的CGI脚本还是动态的Django应用程序，都不是幂等的。如果一个页面上甚至在HTML注释中写着“此页面在某个时间下载”，那就不是幂等的。Web最初是设计为幂等的；后来人们开始意识到动态内容可能非常有用，并开始研究如何克服HTTP的无状态、幂等设计。
- en: The nice eight syllables of referential transparency mean that a function call
    can equivalently be replaced with the value it returns. Because 4! is 24, it should
    be equivalent to include 4! in your code and just include 24 instead. If you have
    the cosine of a value, it should be equivalent to use a stored value of the result
    of that call to `cos()`, or to recompute. Impure behavior that would break referential
    transparency would be to have `cos()` log a string each time it was called, which
    is a classic example of a *side effect*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明度这八个音节的词意味着函数调用可以等效地替换为它返回的值。因为4!等于24，所以在你的代码中包含4!和只包含24应该是等效的。如果你有一个值的余弦，使用`cos()`的结果的存储值或重新计算应该是等效的。破坏引用透明度的不纯行为是每次调用`cos()`都记录一个字符串，这是一个经典的*副作用*的例子。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The term side effect is unfortunate and probably intended to be loaded language;
    in a medical context, all drugs produce multiple effects, some of which are the
    point of taking the medication and some of which are tolerated as a necessary
    evil that comes with getting the desired effects. A side effect medically is a
    medication effect that is tolerated but not why the medication is taken. Saying
    that logging a message in a program is a side effect is a bit like saying that
    taking a pain reliever, and experiencing consequent reduction in one''s physical
    pain, is experiencing a side effect: that is the entire point of taking the medication,
    not any other effects the drug may have, and it''s an odd thing to call this a
    side effect.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “副作用”这个术语是不幸的，可能是有意使用的措辞；在医学背景下，所有药物都会产生多种效果，其中一些是服药的目的，而另一些则被容忍为必要的副作用。在医学上，副作用是指药物的效果是被容忍的，但不是服药的目的。在程序中记录消息是一种副作用，有点像说服用止痛药并随后减轻身体疼痛是一种副作用：这正是服药的全部目的，而不是药物可能产生的其他效果，这样称呼它是一种副作用有点奇怪。
- en: Preceding are some stock examples of functions from basic math, and perhaps
    that is easy, because in certain areas of math, everything is a pure function,
    perhaps built from pure functions, and the setting precludes impure functions
    or side effects. One could also give polynomials as an example of pure functions
    built up from pure functions, which is a really nice approach if you are equipped
    to use it, but feels foreign and confusing if one is used to framing everything
    in informative assumptions. Between functional and imperative functions, for programmers
    with an imperative-based formation, imperative function is the approach that is
    easiest in the short term but harder in the long term. For programmers with a
    functionally-based formation, functional programming is easy, both in the short
    term and the long term. But for an example of these concerns playing out in practical
    information technology, we need look no further than ReactJS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是一些基本数学函数的示例，也许这很容易，因为在某些数学领域，一切都是纯函数，可能是由纯函数构建的，而且环境排除了不纯函数或副作用。人们也可以举多项式作为由纯函数构建的纯函数的例子，如果你有能力使用它，这是一种非常好的方法，但如果习惯于用信息性假设来构建一切，这种方法会感到陌生和困惑。对于以命令为基础的程序员来说，命令式函数是短期内最容易的方法，但长期来看更难。对于以函数为基础的程序员来说，函数式编程在短期和长期内都很容易。但是，要在实际信息技术中看到这些问题的例子，我们不需要看得比ReactJS更远。
- en: Facebook's learning from prolonged pain essentially led to a realization that
    the way out of the morass was through idempotency and referential transparency,
    and that is what ReactJS was written to deliver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的长期痛苦学习基本上导致了一个认识，即摆脱困境的方法是通过幂等性和引用透明度，这就是ReactJS的编写目的。
- en: Learn what you can!
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学会你能学到的东西！
- en: A wise master in the Orthodox spiritual tradition boiled many things down into
    55 maxims ([http://tinyurl.com/reactjs-55-maxims](http://tinyurl.com/reactjs-55-maxims)),
    the second of which was, *Pray as you can, not as you think you must*, and these
    are wise words for much of programming too. And there is a suggestion here, but
    not so non-mathematicians will be daunted. Follow this one suggestion as you can,
    not as you think you must. Learn as much functional programming as you can. Write
    JavaScript in as purely a functional fashion as you can.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正统精神传统中的一位智者将许多事情归纳为55条格言（[http://tinyurl.com/reactjs-55-maxims](http://tinyurl.com/reactjs-55-maxims)），其中第二条是，“祈祷应该是你能做到的，而不是你认为你必须做到的”，这些话对于大部分编程也同样适用。这里有一个建议，但不会让非数学家感到畏惧。尽可能按照你能做到的方式去遵循这个建议，而不是你认为你必须这样做。尽可能多地学习函数式编程。尽可能纯粹地使用JavaScript进行函数式编程。
- en: I have wrapped my head around functors now, as I failed to do so as a graduate
    student in math. I haven't conceptually wrapped my head around applicative functors
    and monads from a theory perspective, but the idea of writing pure functions as
    much as possible and making minimal use of input and output monads is something
    that appears doable on a *monkey see, monkey do* basis, which is much less taxing
    than having to trace a monad's conceptual genealogy. And this falls into the category
    of using functional programming as you can, not as you think you must.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经理解了函子，而在我读数学研究生时却未能做到。从理论角度来看，我还没有完全理解应用函子和单子的概念，但尽可能地编写纯函数，并尽量少地使用输入和输出单子的想法似乎是可行的，这比追溯单子的概念起源要容易得多。这属于尽可能地使用函数式编程，而不是你认为必须使用的范畴。
- en: The Wikipedia article on functional reactive programming links to nine major
    works in the field, and if you want to wrestle with a good mathematical challenge,
    all of them are worth a good wrestle. The mathematical symbols can be as dense
    as they are on the Wikipedia article on functors, which is quite dense.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程的维基百科文章链接到了该领域的九部重要作品，如果你想解决一个良好的数学难题，所有这些作品都值得一搏。数学符号可能像维基百科上的函子文章一样密集。
- en: 'But if we look at languages, there''s a clue here. There are a few interesting
    possibilities, all functional, that are mentioned in the literature: a Scheme
    dialect, DDD, and Elm (which is its own language compiling, comparably to DDD,
    to its own JavaScript / HTML / CSS). But the strongest attraction of functional
    reactive programming authors seems to be by far Haskell. This offers us a free
    clue that, at least in its origins, Haskell is a center of gravity to pretty much
    all the seminal papers on functional reactive programming. Any language, including
    Haskell, has flaws, but it would be silly to simply ignore the fact that seminal
    works in functional reactive programming gravitate towards Haskell.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们看看编程语言，这里有一个线索。文献中提到了几种有趣的可能性，都是函数式的：一种Scheme方言，DDD和Elm（它是一种独立的语言，编译成自己的JavaScript
    / HTML / CSS，与DDD相比）。但是，函数式响应式编程作者最感兴趣的似乎远远是Haskell。这给了我们一个免费的线索，至少在其起源中，Haskell是几乎所有关于函数式响应式编程的重要论文的重心。任何语言，包括Haskell，都有缺陷，但简单地忽略函数式响应式编程的重要作品倾向于Haskell是愚蠢的。
- en: Functional reactive programming is reactive programming built out of the building
    blocks of functional programming. Some aspects of this are taken care of for us
    when developing in JavaScript with ReactJS. We only need to specify declaratively
    what the UI should look like when rendered, and ReactJS will handle all necessary
    compilation so a declarative `render()` method will be translated into optimized
    imperative manipulations on the DOM. But at least at first glance, it would make
    sense, if you want to understand functional reactive programming, to learn a technique
    closely tied to Haskell from the outset and only later, after you've walked a
    mile in Haskell's shoes and then know if they pinch you, write your "declaration
    of independence" from Haskell's lead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程是建立在函数式编程的基础上的响应式编程。在使用ReactJS开发JavaScript时，一些方面已经为我们处理了。我们只需要声明性地指定UI在渲染时应该是什么样子，ReactJS将处理所有必要的编译，因此声明性的`render()`方法将被转换为DOM上的优化的命令。但至少乍一看，如果你想理解函数式响应式编程，学习一种与Haskell紧密相关的技术是有意义的，只有在你穿上Haskell的鞋走了一英里之后，然后知道它们是否会让你不舒服，才写下你对Haskell的“独立宣言”。
- en: There is criticism of *Learn You a Haskell for Great Good*, but the book was
    deliberately chosen as an excellent text to teach a top-notch functional language.
    Pointing out that a Haskell text covers eight chapters of theory and some category
    theory concepts before allowing the reader to see the traditional *Hello, world!*
    program, makes a much stronger point by picking on a strong text than picking
    on an introduction that is mediocre and invites of an obvious response of but
    there are much better examples that don't have that problem. A companion text
    that is more focused on practical applications for real-world information technology
    needs is Real World Haskell ([http://book.realworldhaskell.org/read/](http://book.realworldhaskell.org/read/)).
    These aren't the only books out there, but they offer at least a good pairing
    and a starting point, and are often recommended together.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 《Learn You a Haskell for Great Good》受到了批评，但这本书被故意选为教授一门一流的函数式语言的优秀教材。指出Haskell的教材在允许读者看到传统的“Hello,
    world!”程序之前，涵盖了八章的理论和一些范畴论概念，这比挑剔一个一般的介绍更有说服力，并且会引起一个明显的反应，但是有更好的例子没有这个问题。一个更专注于实际应用于现实世界信息技术需求的伴随教材是《Real
    World Haskell》（[http://book.realworldhaskell.org/read/](http://book.realworldhaskell.org/read/)）。这些并不是唯一的教材，但至少提供了一个很好的搭配和一个起点，并经常一起推荐。
- en: 'More to the point, don''t try to snarf these two books and expect that after
    a day''s study, or even a month, it will be easier to get things done in Haskell
    than whatever favorite language you''ve given years of use. Instead play around,
    and tinker with these things. Treat the Glasgow Haskell Compiler as a nice set
    of virtual Lego that a loved one gave you for Christmas. *Learn You a Haskell
    for Great Good* nowhere dives into how you can write a web server, and that is
    one of the book''s strengths. It builds core strengths that are only to your benefit
    and should put you in a better position to appreciate and exploit opportunities
    for functional programming in JavaScript. G.K. Chesterton said:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，不要试图匆匆翻阅这两本书，并期望经过一天甚至一个月的学习，就能比你多年使用的任何喜爱的语言更容易地在Haskell中完成工作。相反，玩耍，尝试这些东西。把Glasgow
    Haskell Compiler当作你圣诞节收到的一套漂亮的虚拟乐高。《Learn You a Haskell for Great Good》从未深入探讨如何编写Web服务器，这正是该书的优势所在。它建立了只有对你有利的核心优势，并应该让你更有能力欣赏和利用JavaScript中函数式编程的机会。G.K.切斯特顿说：
- en: '*"…to understand everything a strain. The poet only desires exaltation and
    expansion, a world to stretch himself in. The poet only asks to get his head into
    the heavens. It is the logician who seeks to get the heavens into his head. And
    it is his head that splits." Try to get your head into the Heavens, not the Heavens
    immediately into your head. If you are an adept programmer now, perhaps in an
    imperative paradigm, chances are good that when you were in school and exploring
    things, you sought to get your head into Heavens with programming. You wrote games;
    you played around, and acquired a foundation you would later use for professional
    work. If you want to learn Haskell, don''t cram it. Become like a little child
    again and play. And read Learn You a Haskell for Great Good, with its deliberate
    avoidance of how to get something slammed out for a deadline, until you have an
    actual foundation before reading Real World Haskell, and please do not take Real
    World Haskell to be justification to "cut to the chase" and just try to release
    commercial-style functionality on deadline-style timing.*'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理解一切都是一种负担。诗人只渴望升华和扩张，一个可以展现自己的世界。诗人只希望把头伸进天堂。是逻辑学家试图把天堂放进他的脑袋。而他的脑袋却会崩裂。试着把你的头伸进天堂，而不是立刻把天堂放进你的头脑。如果你现在是一个熟练的程序员，也许是在命令范式中，那么很有可能在学校时，当你探索事物时，你试图用编程把头伸进天堂。你写游戏；你玩耍，获得了以后在专业工作中会用到的基础。如果你想学习Haskell，不要死记硬背。重新变成一个小孩，玩耍。阅读《Learn
    You a Haskell for Great Good》，它故意避免了如何在最后期限前快速完成某事，直到你真正掌握了基础才去阅读《Real World Haskell》，请不要把《Real
    World Haskell》当作“抄近路”的理由，试图在最后期限内发布商业风格的功能。
- en: Douglas Crockford, in his South American presentation on *The Better Parts*,
    gives an increasingly strong functional focus to functional programming when he
    describes good JavaScript. All of the earlier Crockford videos I've seen, from
    when there was just *The Good Parts* and no *The Better Parts* even on the horizon,
    seem to associate JavaScript's better parts with its functional side. But *The
    Better Parts* is even more explicit in saying that one of JavaScript harmony's
    improvements is that you can apply tail recursion, and use functional styles of
    flow control that make some kinds of flow control, such as looping almost or completely
    unnecessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于《更好的部分》的南美演讲中，道格拉斯·克罗克福德在描述良好的JavaScript时，给了越来越强的函数式编程重点。我看过的早期克罗克福德的视频，当时只有《好部分》，甚至没有《更好的部分》的迹象，似乎将JavaScript的更好部分与其函数式一面联系在一起。但《更好的部分》更明确地表示，JavaScript和谐的改进之一是你可以应用尾递归，并使用函数式的流程控制风格，使一些流程控制，如循环几乎或完全不必要。
- en: Even apart from functional reactive programming, better JavaScript seems to
    increasingly mean functional JavaScript. And this is a very good thing. Scheme,
    as mentioned earlier, has been called "the best language you'll never use," and
    the set of generally functional languages that computer scientists consistently
    choose on their merits for computer science usage are a little paradise that one
    must leave to enter professional programming.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不考虑函数式响应式编程，更好的JavaScript似乎越来越意味着函数式JavaScript。这是一件非常好的事情。正如前面提到的，Scheme被称为“你永远不会使用的最好的语言”，计算机科学家们一直选择基于计算机科学使用价值的一组通常的函数式语言，这是一个必须离开的小天堂，才能进入专业编程。
- en: JavaScript changed that, and not only by making anonymous functions mainstream.
    JavaScript, especially when used with ReactJS, provides one of the greatest opportunities
    to enjoy the goodness of functional programming in mainstream software development.
    And as long as you understand what you are doing, the more you can write JavaScript
    in a functional paradigm.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript改变了这一点，不仅仅是通过使匿名函数成为主流。特别是在与ReactJS一起使用时，JavaScript为主流软件开发提供了享受函数式编程优点的最大机会。只要你明白自己在做什么，你就能越多地以函数式范式编写JavaScript。
- en: Functional programming, reactive or otherwise, may come more easily if you're
    introduced to it in schooling that covers the more mathematical side of functional
    programming. But it is possible to teach a programmer how to write *Hello, world!*
    in Haskell while leaving the most incomprehensible mathematics of category theory
    out of sight and under the hood.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程，无论是响应式还是其他方式，如果你在学校接触了更数学化的函数式编程，可能会更容易理解。但是可以教会程序员如何在Haskell中写出“Hello,
    world!”，同时将范畴论中最难理解的数学知识放在视线之外，隐藏在引擎盖下。
- en: 'The computational mathematical foundations of functional programming are something
    that should be like a machine or assembler in a higher-level language: present
    under the hood and making language capabilities possible, but out of sight with
    minimally leaky abstractions that *just work*, regardless of whether one is a
    mechanic competent to make adjustments under the hood.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的计算数学基础应该像高级语言中的机器或汇编语言一样：存在于引擎盖下，使语言功能成为可能，但在最小程度上是不透明的抽象，*只是工作*，无论一个人是否是一个能够在引擎盖下进行调整的机械师。
- en: In some sense, for seasoned programmers who have been out of school for a while,
    what is needed is *The Good Parts* of learning functional programming. Now in
    this case the good parts may vary from programmer to programmer depending on their
    comfort level for functional programming. The criterion is "Do what you can, not
    what you think you must." Getting your head around the difference between declarative/denotative
    programming and imperative programming, is perhaps difficult, but not too difficult.
    The closely connected concept of writing pure functions as much as reasonably
    possible and quarantining code that must have side effects even if you're trying
    to avoid them, is a shift in thinking but not too slippery.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，对于已经离开学校一段时间的资深程序员来说，需要的是学习函数式编程的“好部分”。在这种情况下，好部分可能因程序员的函数式编程舒适水平而异。标准是“做你能做的，而不是你认为你必须做的”。理解声明式/指示性编程与命令式编程之间的差异，可能有些困难，但并不是太难。尽可能编写纯函数，并隔离必须具有副作用的代码，即使你试图避免它们，这是一种思维转变，但并不是太棘手。
- en: Learning functors, for instance, is actually a bit easier in Haskell than in
    category theory, even if the Wikipedia page does not reflect this. It shouldn't
    take most programmers too long to write a first Haskell program that is mostly
    pure functions and input and output handled by a minimal quarantine of monads.
    But using features such as monads is much easier than understanding the contorted
    steps one uses to work with pure functions and build up to monads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Haskell中学习函子实际上比范畴论要容易一些，即使维基百科页面没有反映出这一点。大多数程序员不应该花太长时间编写一个主要是纯函数，输入和输出由单子的最小隔离处理的第一个Haskell程序。但是使用单子等功能要比理解使用纯函数并逐步构建单子的扭曲步骤容易得多。
- en: 'And it is worth repeating: if functional (reactive) programming is appropriate
    for mainstream use, the heavily mathematical theory used to get from a function
    to a monad should no more be forced on average Joe professional developers than
    even a C programmer should be forced to work with the assembler or machine instructions
    generated by his software. One wag said that "C is a language that combines the
    power of assembler with the ease of using assembler," but C never forces most
    programmers to micromanage how the compiler renders the C source.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 而且值得重申：如果函数式（反应式）编程适合主流使用，那么从函数到单子的重度数学理论不应该像C程序员被迫使用汇编语言或软件生成的机器指令一样被强加给普通的专业开发人员。有人说，“C是一种将汇编语言的强大与使用汇编语言的便利结合在一起的语言”，但C从来没有强迫大多数程序员微观管理编译器如何渲染C源代码。
- en: Many mainstream languages now, in particular multi-paradigm languages, have
    incorporated some elements of functional programming strengths. All the same,
    one might suggest that JavaScript, of all mainstream languages, directly offers
    the best set of functional programming strengths bar none. Not necessarily the
    best functional programming among the languages favored by computer scientists
    such as Haskell or Lisp/Scheme; it's hard to find a mainstream programming job
    where management will allow a solution in Haskell or Scheme. But among mainstream
    languages, JavaScript is still the juiciest. Computer scientists have long been
    fond of functional programming, and at least one programmer who studied math in
    school commented, "Functional programming is the first programming paradigm I've
    seen that makes sense." And for excellence that computer scientists have almost
    universally favored for (mumble) years or decades, JavaScript isn't just the language
    browsers will execute, important as that may be. It also offers the best opportunity
    for functional programming goodness in a language frequently encountered on job
    descriptions for employers who want to hire you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多主流语言，特别是多范式语言，已经融入了一些函数式编程的优势。尽管如此，有人可能会建议，JavaScript是所有主流语言中直接提供最佳函数式编程优势的语言。不一定是计算机科学家喜欢的Haskell或Lisp/Scheme等语言中最好的函数式编程；很难找到一个主流编程工作，管理层会允许使用Haskell或Scheme的解决方案。但在主流语言中，JavaScript仍然是最有吸引力的。计算机科学家长期以来一直喜欢函数式编程，至少有一位在学校学习数学的程序员评论说，“函数式编程是我见过的第一个有意义的编程范式。”对于几乎所有计算机科学家都喜欢的卓越性，JavaScript不仅仅是浏览器执行的语言，尽管这很重要。它还为在雇主的招聘要求中经常遇到的语言提供了最佳的函数式编程机会。
- en: JavaScript as the new bare metal
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript作为新的裸金属
- en: 'Douglas Crockford, in *The Better Parts* mentioned earlier, tries to make the
    point that programmers are just as emotional as everyone else. He backs up this
    point in a way that would not be a surprise to a Kuhn scholar: fundamental improvements
    in software engineering win by the attrition of programmers holding the earlier
    approach. He gives an example of six or so "it took a generation" remarks: "it
    took a generation" for software engineers to recognize that high-level languages
    were a good idea, or that the F-bomb of all programming language statements, the
    G-bomb or goto statement, was not a good idea. And although Crockford gives several
    examples, his efforts do not seem to have pretensions of including all the significant
    examples: although I''m not completely sure of the dates, it seems to have taken
    about a generation between the 1960s, when Smalltalk recognized that references
    were better than pointers (pointers have been called "the goto of data structures"),
    and the 1990s when a mainstream language that was "front and center," like Java,
    superceded pointers with references.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Douglas Crockford在前面提到的《更好的部分》中试图表明程序员和其他人一样情感用事。他以一种对于库恩学者来说并不奇怪的方式支持了这一观点：软件工程的基本改进是通过坚持早期方法的程序员的消退而取得的。他举了六个或者更多的“需要一代人”的例子：“需要一代人”才意识到高级语言是一个好主意，或者所有编程语言语句中的F炸弹，goto语句，不是一个好主意。尽管Crockford举了几个例子，但他的努力似乎并不打算包括所有重要的例子：尽管我并不完全确定日期，但似乎在20世纪60年代，Smalltalk意识到引用比指针更好（指针被称为“数据结构的goto”），到20世纪90年代，像Java这样的主流语言用引用取代了指针，大约需要一代人的时间。
- en: Crockford made a few remarks about programmers invoking freedom of self-expression
    to do all programming on bare metal or routinely use goto statements to handle
    flow control. But when all is said and done, including that it took two generations
    for anonymous functions to be used in a mainstream language, JavaScript being
    the first, improvements in software development do not take root because existing
    programmers embrace better ways.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Crockford对程序员以自我表达的自由来进行裸金属编程或者经常使用goto语句来处理流程控制做了一些评论。但说到底，包括匿名函数在主流语言中使用需要两代人的时间，JavaScript是第一个，软件开发的改进并不是因为现有的程序员接受了更好的方法而生根。
- en: 'They take root because new programmers embrace better ways, while the majority
    of older, unconvinced programmers die. (Even if they could learn. But in some
    sense there is an option to opt-out of becoming obsolete, by embracing new changes.
    It''s just that many people say, "If it was good enough for me at 20, it''s good
    enough for me at 40." There is no iron determinism grasping every individual:
    only a "default setting" on /programmers/ that ages poorly as a default setting.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它们生根是因为新程序员接受了更好的方法，而大多数年长、不信服的程序员则逐渐消失。（即使他们可能学会了。但在某种意义上，通过接受新变化来避免过时是一种选择。只是很多人会说，“20岁时对我来说够好，40岁时也够好了。”并不是每个人都被铁定的决定所控制：只是在程序员中存在一个“默认设置”，随着时间推移而变得不再合适。）
- en: JavaScript is *lingua franca* on the web, and even if you object to it because
    it's not your favorite language (indeed, why should it be just like Perl, Python,
    Java or C++?), it is here to stay and is perhaps the best bet around for what
    will be the most important language, and will be for quite a while. But what may
    "take a generation" in this context is the realization that web programming in
    non-JavaScript languages is a good idea.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是网络上的*通用语言*，即使你不喜欢它，因为它不是你最喜欢的语言（确实，为什么它会像Perl、Python、Java或C++一样呢？），它已经存在并且可能是最重要的语言，而且将在相当长的一段时间内保持这种地位。但在这种情况下，“需要一代人”的可能是意识到在非JavaScript语言中进行网络编程是一个好主意。
- en: 'Alan Perlis said, "A programming language is low level when its programs require
    attention to the irrelevant," and if programming well in JavaScript requires avoiding
    large minefields of languages for reasons that are far from obvious to casual
    inspection, JavaScript requires attention to the irrelevant: JavaScript is low
    level.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Alan Perlis说过，“当一个编程语言的程序需要关注无关紧要的事情时，它就是低级的”，如果要在JavaScript中进行良好的编程，就需要避开许多语言的陷阱，而这些原因对于一般检查来说并不明显，JavaScript需要关注无关紧要的事情：JavaScript是低级的。
- en: One encouraging sign in newer web development, in ReactJS videos, is not only
    that another non-JavaScript language or syntactic sugar, CoffeeScript, is used,
    but that its introduction was presented smoothly and casually, and entirely without
    apology, defense, or explanation. The fact that they used CoffeeScript at all
    is significant, and the fact that they did so without any trace of defensiveness
    is even more significant. Now CoffeeScript might not be any kind of be-all, end-all
    among languages that can or should be able to be compiled to JavaScript. But it
    is encouraging to see something other than JavaScript "bare metal."
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的网络开发中，ReactJS视频中的一个令人鼓舞的迹象不仅是使用了另一种非JavaScript语言或语法糖CoffeeScript，而且它的引入是平稳和随意的，完全没有道歉、辩护或解释。他们使用CoffeeScript的事实本身就很重要，而且他们这样做时没有任何防御性的痕迹更加重要。现在CoffeeScript可能不是所有可以或应该被编译成JavaScript的语言中的全部或最终选择。但看到除了JavaScript“裸金属”之外的东西是令人鼓舞的。
- en: This does not mean that there is no place for that "bare metal" programming.
    Amateur game developers or programmers from mega-corporations trying to squeeze
    the last ounce of performance out of either bare metal for standalone applications
    and games, will legitimately want to squeeze the last ounce of performance out
    of their user's computer, whether working on the "bare metal" of application programming
    or JavaScript on the web. But just as one ordinarily does not write web applications
    in C or assembler (and didn't do so even when CGI scripts were the primary means
    of delivering dynamic content), for most uses of web programming, a good smartphone
    (a slightly old iPhone 5 is roughly 100 times as fast as a top-of-the-line computer
    from when the web was new) really is fast enough to run code generated by compiling
    other languages to JavaScript. And JavaScript is, after all, so much more impressive
    when one understands how it is developed. It is a computer language that was designed
    in 10 days, something that one ordinarily greets not with, "That's an impressive
    feat!" but also, "Dude, ease up a bit! If you keep abusing stimulants like that,
    you'll kill yourself!"
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着“裸金属”编程没有用武之地。业余游戏开发者或来自大型公司的程序员，试图从裸金属中挤出最后一丝性能，无论是为独立应用程序和游戏，都会合理地希望挤出用户计算机的最后一丝性能，无论是在应用程序编程的“裸金属”上还是在网络上的JavaScript上。但就像通常情况下不会用C或汇编语言编写Web应用程序一样（即使在CGI脚本是交付动态内容的主要手段时也不会这样），对于大多数Web编程的用途来说，一部好的智能手机（稍微老一点的iPhone
    5大约比网络刚刚出现时的顶级计算机快100倍）真的足够快，可以运行通过编译其他语言生成的JavaScript代码。而且，当人们了解JavaScript是如何开发的时，它就更加令人印象深刻。这是一种在10天内设计的计算机语言，通常人们不仅会对此表示印象深刻，还会说：“伙计，放松点！如果你继续滥用兴奋剂，你会害死自己！”
- en: The essential reason why using a high-level language is desirable is something
    painfully obvious that programmers learn to shut out so they can get any work
    done in JavaScript. Douglas Crockford's *The Good Parts*, and with it the idea
    that JavaScript has both treasures and land mines and a good part of navigating
    JavaScript well is avoiding minefields altogether, has taken such deep root that
    this title's brief summary may be entirely superfluous for most programmers reading
    this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级语言是可取的基本原因是程序员们学会忽略这一点，以便在JavaScript中完成任何工作。道格拉斯·克罗克福德的《精粹》，以及JavaScript既有宝藏又有地雷的想法，以及良好地避开地雷的一部分，已经深深扎根，以至于对于大多数阅读本书的程序员来说，这本书的简要摘要可能是完全多余的。
- en: That, even by itself, is serious reason to consider alternatives to programming
    on JavaScript "bare metal" if one has the option. And in fact, there are many
    alternatives to JavaScript "bare metal" for frontend web development. [http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)
    has a long list of other languages, including family and friends intended to offer
    an enhanced JavaScript in some aspect or other, and compilers for other languages
    to JavaScript, including (often) multiple options for Basic, C/C++, C#/F#/.NET,
    Erlang, Go, Haskell, Java/JVM, Lisp, OCAML, Pascal, PHP, Python, Ruby, Scheme,
    Smalltalk, and SQL. Presumably not every single one of the compilers and implementations
    is particularly good, but like every other serious computer language, JavaScript
    is Turing-complete, and not only is it theoretically possible to compile other
    complete languages to JavaScript as well as "bare metal", but it is practically
    possible and makes plenty of sense. JavaScript may become the most important compilation
    target, eclipsing even x86_64 machine code. Or it may not, but JavaScript's desirability
    and capabilities mean that the phenomenon of writing in languages compiled to
    JavaScript—meaning most other languages—might only grow in the foreseeable future.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身就是一个严肃的理由，如果有选择的话，要考虑替代JavaScript“裸金属”编程。事实上，对于前端Web开发，有许多替代JavaScript“裸金属”的选择。[http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)列出了许多其他语言，包括旨在在某些方面提供增强JavaScript的家族和朋友，以及将其他语言编译为JavaScript的编译器，包括（通常）Basic、C/C++、C#/F#/.NET、Erlang、Go、Haskell、Java/JVM、Lisp、OCAML、Pascal、PHP、Python、Ruby、Scheme、Smalltalk和SQL的多个选项。显然，并非每个编译器和实现都特别好，但就像其他任何严肃的计算机语言一样，JavaScript是图灵完备的，不仅在理论上可以将其他完整的语言编译为JavaScript以及“裸金属”，而且在实践中也是可能的，并且是有充分意义的。JavaScript可能会成为最重要的编译目标，甚至超越x86_64机器代码。或者也可能不会，但JavaScript的可取性和能力意味着编写编译为JavaScript的语言的现象——意味着大多数其他语言——在可预见的未来可能会不断增长。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter may be an early attempt at the kind of endeavor where early attempts
    often do not succeed. There are seminal documents easily available on the web,
    but they assume you can not only program but handle a particular kind of math
    that most professional developers cannot and perhaps have never achieved proficiency.
    The goal here is not to provide another highly mathematical explanation, but to
    produce a document that would be useful, perhaps on a less highly exalted plane,
    to the majority of frontend developers who naturally think of imperative solutions.
    The goal here is to move towards more functional and less imperative programming,
    but also to produce a text appropriate to the level of mathematical skill that
    professional programmers actually have, not the level of math skills some authority
    might wish them to have. Consequently, the prerequisites are meant not to assume
    an understanding of category theory itself before programmers are allowed to write,
    *Hello, world!*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章可能是对早期尝试的一种尝试，而早期尝试通常不会成功。网上有许多重要文件，但它们假设你不仅可以编程，还可以处理大多数专业开发人员无法处理的特定类型的数学，也许甚至从未达到过熟练程度。这里的目标不是提供另一个高度数学化的解释，而是产生一份对大多数前端开发人员有用的文件，也许在一个不那么高尚的层面上，自然会考虑命令式解决方案。这里的目标是朝着更加功能化和不那么命令式的编程方向发展，但也要产生一份适合专业程序员实际具有的数学技能水平的文件，而不是某个权威可能希望他们具有的数学技能水平。因此，先决条件并不是假设程序员在被允许编写“Hello,
    world!”之前必须理解范畴论本身。
- en: In this chapter, we took a trip down computer folklore's memory lane. This trip
    looked at a scathing computer checklist, simple *Hello, world!* program, and category
    theory—and how functional reactive programming's preferred language, Haskell,
    may want you to use category theory if you're allowed to write, *Hello, world!*
    This is a major problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了计算机传说的记忆。这次回顾包括了对严厉的计算机清单、简单的“Hello, world!”程序和范畴论的探讨，以及函数式响应式编程首选语言Haskell可能会要求你在写“Hello,
    world!”时使用范畴论。这是一个重大问题。
- en: We've also had a look at the distinguishing features of functional reactive
    programming including how time is treated. Also a serious answer to the question,
    "If you learn just one thing from functional reactive programming, what would
    be the best thing to learn?" is covered in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了函数式响应式编程的特点，包括时间的处理方式。本章还涵盖了对问题“如果你只能从函数式响应式编程中学到一件事，最好学什么？”的认真回答。
- en: Learning what you can about pure functional development, not what you think
    you must learn about it, is also covered here. It's easy to paralyze yourself
    by trying to learn too much functional programming, and honestly, functional programming
    (which requires that you shift how you look at the world) is not the easiest thing
    for seasoned imperative programmers to learn. This is an attempt to offer a sane
    measure of profiting from what functional programming one can without getting
    completely lost in the almost infinite trackless wastes of grappling with functional
    programming.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了学习纯函数式开发的内容，而不是你认为必须学习的内容。试图学习太多函数式编程很容易让自己陷入瘫痪，而且老练的命令式程序员学习函数式编程（需要改变看待世界的方式）并不是件容易的事。这是一种尝试，提供了一种理智的方法来从函数式编程中获益，而不至于完全迷失在与函数式编程的无尽挣扎中。
- en: We also discussed the future of web development, where JavaScript is viewed
    as the new "bare metal."
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Web开发的未来，JavaScript被视为新的“裸金属”。
- en: In our next chapter, we will explore tools to support functional reactive programming.
    Let's begin!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将探讨支持函数式响应式编程的工具。让我们开始吧！
