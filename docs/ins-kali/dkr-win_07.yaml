- en: Adopting Container-First Solution Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用容器优先解决方案设计
- en: Adopting Docker as your application platform brings clear operational benefits.
    Containers are a much lighter unit of compute than virtual machines, but they
    still provide isolation, so you can run more workloads on less hardware. All these
    workloads have the same shape in Docker, so operations teams can manage .NET,
    Java, Go, and Node.js applications in the same way. The Docker platform also has
    benefits in application architecture. In this chapter, I'll look at how container-first
    solution design helps you add features to your application, with high quality
    and low risk.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将Docker作为应用程序平台带来明显的运营优势。容器比虚拟机更轻，但仍提供隔离，因此您可以在更少的硬件上运行更多的工作负载。所有这些工作负载在Docker中具有相同的形状，因此运维团队可以以相同的方式管理.NET、Java、Go和Node.js应用程序。Docker平台在应用程序架构方面也有好处。在本章中，我将探讨容器优先解决方案设计如何帮助您向应用程序添加功能，具有高质量和低风险。
- en: I'll be returning to NerdDinner in this chapter, picking up from where I left
    off in [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized
    .NET Framework and .NET Core Applications*. NerdDinner is a traditional .NET application,
    a monolithic design with tight coupling between components in which all communication
    is synchronous. There is no unit testing, integration testing, or end-to-end testing.
    NerdDinner is like millions of other .NET apps—it may have the features the users
    need, but it's difficult and dangerous to modify. Moving apps like this to Docker
    lets you take a different approach to modifying or adding features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将回到NerdDinner，从我在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中离开的地方继续。NerdDinner是一个传统的.NET应用程序，是一个单片设计，组件之间耦合紧密，所有通信都是同步的。没有单元测试、集成测试或端到端测试。NerdDinner就像其他数百万个.NET应用程序一样——它可能具有用户需要的功能，但修改起来困难且危险。将这样的应用程序移至Docker可以让您采取不同的方法来修改或添加功能。
- en: Two aspects of the Docker platform will change the way you think about solution
    design. First, networking, service discovery, and load balancing means you can
    distribute applications across multiple components, each running in containers
    that can be moved, scaled, and upgraded independently. Second, the expanding range
    of production-grade software available on Docker Hub and other registries means
    you can use off-the-shelf software for many generic services and manage them in
    the same way as your own components. This gives you the freedom to design better
    solutions, without infrastructure or technology restrictions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台的两个方面将改变您对解决方案设计的思考方式。首先，网络、服务发现和负载平衡意味着您可以将应用程序分布到多个组件中，每个组件都在容器中运行，可以独立移动、扩展和升级。其次，Docker
    Hub和其他注册表上可用的生产级软件范围不断扩大，这意味着您可以为许多通用服务使用现成的软件，并以与自己的组件相同的方式管理它们。这使您有自由设计更好的解决方案，而不受基础设施或技术限制。
- en: 'In this chapter, I''ll show you how to modernize a traditional .NET application,
    by adopting container-first design:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何通过采用容器优先设计来现代化传统的.NET应用程序：
- en: Design goals for NerdDinner
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NerdDinner的设计目标
- en: Running a message queue in Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中运行消息队列
- en: Starting a multi-container solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始多容器解决方案
- en: Modernizing legacy applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化遗留应用程序
- en: Adding new features in containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中添加新功能
- en: From monolith to distributed solution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体到分布式解决方案
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Docker running on Windows 10 with update 18.09, or Windows Server
    2019 to follow along with the examples. The code for this chapter is available at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch05](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着示例进行操作，您需要在Windows 10上运行Docker，并更新到18.09版，或者在Windows Server 2019上运行。本章的代码可在[https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch05](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch05)上找到。
- en: Design goals for NerdDinner
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NerdDinner的设计目标
- en: In [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized
    .NET Framework and .NET Core Applications*, I extracted the NerdDinner home page
    into a separate component, which enabled the rapid delivery of UI changes. Now
    I'm going to make some more fundamental changes, breaking down the legacy application
    and modernizing the architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中，*开发Docker化的.NET Framework和.NET
    Core应用程序*，我将NerdDinner首页提取到一个单独的组件中，这样可以快速交付UI更改。现在我要做一些更根本的改变，分解传统的应用程序并现代化架构。
- en: I'll start by looking at a performance issue in the web application. The data
    layer in NerdDinner uses **Entity Framework** (**EF**), and all database access
    is synchronous. A lot of traffic to the site will create a lot of open connections
    to SQL Server and run a lot of queries. Performance will deteriorate as the load
    increases, to the point where queries time out or the connection pool is starved
    and the site will show errors to the users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先查看Web应用程序中的性能问题。NerdDinner中的数据层使用**Entity Framework**（**EF**），所有数据库访问都是同步的。网站的大量流量将创建大量打开的连接到SQL
    Server并运行大量查询。随着负载的增加，性能将恶化，直到查询超时或连接池被耗尽，网站将向用户显示错误。
- en: One way to improve this would be to make all the data-access methods `async`,
    but that's an invasive change—all the controller actions would need to be made
    `async` too, and there is no automated test suite to verify such a wholesale set
    of changes. Alternatively, I could add a cache for data retrieval so that `GET`
    requests would hit the cache and not the database. That's also a complex change,
    and I would need to cache data for long enough to make a cache hit likely while
    keeping the cache in sync when the data changed. Again, the lack of tests means
    complex changes such as this are hard to verify, so this is also a risky approach.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的一种方式是使所有数据访问方法都是`async`，但这是一种侵入性的改变——所有控制器操作也需要变成`async`，而且没有自动化的测试套件来验证这样一系列的改变。另外，我可以添加一个用于数据检索的缓存，这样`GET`请求将命中缓存而不是数据库。这也是一个复杂的改变，我需要让缓存数据保持足够长的时间，以便缓存命中的可能性较大，同时在数据更改时保持缓存同步。同样，缺乏测试意味着这样的复杂改变很难验证，因此这也是一种风险的方法。
- en: It would be hard to estimate the benefit if I did implement these complex changes.
    If all the data access moves to asynchronous methods, will that make the website
    run faster and enable it to handle more traffic? If I can integrate a cache that
    is efficient enough to take reads away from the database, will that improve the
    overall performance? These benefits are difficult to quantify until you've actually
    made the change, when you might find that the improvement doesn't justify the
    investment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我实施这些复杂的改变，很难估计好处。如果所有数据访问都转移到异步方法，这会使网站运行更快，并使其能够处理更多的流量吗？如果我可以集成一个高效的缓存，使读取数据从数据库中移开，这会提高整体性能吗？这些好处很难量化，直到你实际进行了改变，当你可能会发现改进并不能证明投资的价值。
- en: 'With a container-first approach, you can look at the design differently. If
    you identify one feature that makes expensive database calls but doesn''t need
    to run synchronously, you can move the database code to a separate component.
    Then you use asynchronous messaging between the components, publishing an event
    from the main web app to a message queue and acting on the event message in the
    new component. With Docker, each of these components will run in one or more containers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 采用以容器为先的方法，可以以不同的方式来看待设计。如果您确定了一个功能，它会进行昂贵的数据库调用，但不需要同步运行，您可以将数据库代码移动到一个单独的组件中。然后，您可以在组件之间使用异步消息传递，从主Web应用程序发布事件到消息队列，并在新组件中对事件消息进行操作。使用Docker，这些组件中的每一个都将在一个或多个容器中运行：
- en: '![](Images/ddfe4194-1d38-4f65-b62d-874a61c97120.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ddfe4194-1d38-4f65-b62d-874a61c97120.png)'
- en: 'If I focus on just one feature, then I can implement the change quickly. This
    design has none of the drawbacks of the other approaches, and it has a number
    of benefits:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我只专注于一个功能，那么我可以快速实现变化。这种设计没有其他方法的缺点，并且有许多好处：
- en: It's a targeted change, and only one controller action changes in the main application
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个有针对性的变化，只有一个控制器动作在主应用程序中发生了变化
- en: The new message handler component is small and highly cohesive, so it will be
    easy to test
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的消息处理程序组件小而高度内聚，因此很容易进行测试
- en: The web layer and the data layer are decoupled, so they can be scaled independently
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web层和数据层是解耦的，因此它们可以独立扩展
- en: I'm moving work away from the web application, so we can be sure of a performance
    improvement
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在将工作从Web应用程序中移出，这样我们就可以确保性能得到改善
- en: There are other advantages too. The new component is completely independent
    of the original application; it just needs to listen for an event message and
    act on it. You can use .NET, .NET Core, or any other technology stack for the
    message handler; you don't need to be constrained to a single stack. You also
    have events that are being published from the app, so you have the option to add
    other features later by adding new handlers that listen for these events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他优点。新组件完全独立于原始应用程序；它只需要监听事件消息并对其进行操作。您可以使用.NET、.NET Core或任何其他技术堆栈来处理消息；您不需要受限于单一堆栈。您还可以通过添加监听这些事件的新处理程序，以后添加其他功能。
- en: Dockerizing NerdDinner's configuration
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker化NerdDinner的配置
- en: NerdDinner uses `Web.config` for configuration—both for application configuration
    values that are constant between releases and for environmental configuration
    values that change between different environments. The configuration file is baked
    into the release package, which makes it awkward to change. In [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml),
    *Developing Dockerized .NET Framework and .NET Core Applications*, I split the
    `appSettings` and the `connectionStrings` sections from `Web.config` into separate
    files; doing this lets me run a container with a different set of configurations,
    by attaching a volume containing different config files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner使用`Web.config`进行配置 - 既用于应用程序配置值（在发布之间保持不变）又用于在不同环境之间变化的环境配置值。配置文件被嵌入到发布包中，这使得更改变得尴尬。在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中，*开发Docker化的.NET
    Framework和.NET Core应用程序*，我将`Web.config`中的`appSettings`和`connectionStrings`部分拆分成单独的文件；这样做可以让我运行一个包含不同配置文件的容器，通过附加包含不同配置文件的卷。
- en: There are different types of configuration, though, and having to mount a volume
    is quite a heavy option for developers. It's good for feature settings that you
    want to toggle without changing code—settings like `UnobtrusiveJavaScriptEnabled`
    do belong in configuration files. But settings that change for every environment
    and every developer—like `BingMapsKey`—should have an easier way to set them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有不同类型的配置，而挂载卷对开发人员来说是一个相当沉重的选项。对于您希望在不更改代码的情况下切换的功能设置来说是很好的——像`UnobtrusiveJavaScriptEnabled`这样的设置应该放在配置文件中。但是对于每个环境和每个开发人员都会更改的设置——比如`BingMapsKey`——应该有一种更简单的设置方式。
- en: Ideally you want multiple layers of configuration, reading from files but with
    the option to override values using environment variables. That's how the configuration
    system works in .NET Core, and because the configuration packages in .NET Core
    are actually .NET Standard libraries, they can be used in classic .NET Framework
    projects too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望有多层配置，可以从文件中读取，但也可以使用环境变量覆盖值。这就是.NET Core中配置系统的工作方式，因为.NET Core中的配置包实际上是.NET
    Standard库，它们也可以用于经典的.NET Framework项目。
- en: 'In preparation for the bigger changes to come, I''ve updated the code for this
    chapter to use the .NET Core configuration model for all environment configuration
    settings, as shown in the following code. The previous files `appSettings.config`
    and `connectionStrings.config`, have been migrated to the new JSON configuration
    style in `appsettings.json`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了迎接即将到来的更大变化，我已经更新了本章的代码，使用.NET Core配置模型来设置所有环境配置，如下所示。之前的文件`appSettings.config`和`connectionStrings.config`已经迁移到新的JSON配置样式`appsettings.json`中：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The JSON format is easier to read, and because it contains nested objects, you
    can group similar settings together, which I've done with the `Apis` object. I
    can get the Bing Maps API key in my code by accessing the current config object
    with the key `Apis:BingMaps:Key`. I'm still storing the config file in a separate
    directory, so I can use a volume to override the whole file, but I've also set
    the configuration to use environment variables. This means that if an environment
    variable called `Apis:BingMaps:Key` is set, the value of that variable overrides
    the value in the JSON file. In my code, I just reference the configuration key,
    and at runtime, .NET Core fetches it from environment variables or the config
    file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式更易于阅读，因为它包含嵌套对象，您可以将类似的设置分组在一起，我已经在`Apis`对象中这样做了。我可以通过访问当前配置对象的`Apis:BingMaps:Key`键在我的代码中获取Bing
    Maps API密钥。我仍然将配置文件存储在一个单独的目录中，所以我可以使用卷来覆盖整个文件，但我也设置了配置来使用环境变量。这意味着如果设置了一个名为`Apis:BingMaps:Key`的环境变量，那么该变量的值将覆盖JSON文件中的值。在我的代码中，我只需引用配置键，而在运行时，.NET
    Core会从环境变量或配置文件中获取它。
- en: This approach lets me use default values for the database connection strings
    in the JSON file so that the app is usable when developers start the database
    and web containers without having to specify any environment variables. The app
    isn't 100% functional, though, because the API keys are needed for Bing Maps and
    the IP geolocation services. These are rate-limited services, so you are likely
    to have different keys for each developer and each environment, which can be set
    with environment variables in the web container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让我可以在JSON文件中为数据库连接字符串使用默认值，这样当开发人员启动数据库和Web容器时，应用程序就可以使用，而无需指定任何环境变量。不过，该应用程序并非100%功能完善，因为Bing
    Maps和IP地理位置服务需要API密钥。这些是有速率限制的服务，因此您可能需要为每个开发人员和每个环境设置不同的密钥，这可以在Web容器中使用环境变量来设置。
- en: 'To keep environment values safer, Docker lets you load them from a file rather
    than specifying them in plain text in the `docker container run` command. Isolating
    values in a file means that the file itself can be secured so that only administrators
    and the Docker service account can access it. The environment file is a simple-text
    format, with one line for each environment variable, written as a key-value pair.
    For the web container, my environment file contains the secret API keys:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使环境值更安全，Docker允许您从文件中加载它们，而不是在`docker container run`命令中以纯文本指定它们。将值隔离在文件中意味着文件本身可以被保护，只有管理员和Docker服务帐户才能访问它。环境文件是一个简单的文本格式，每个环境变量写成键值对的一行。对于web容器，我的环境文件包含了秘密API密钥：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To run the container and load the file contents as environment variables, you
    can use the `--env-file` option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器并将文件内容加载为环境变量，您可以使用`--env-file`选项。
- en: Environment values still aren't secure. If someone gains access to your app,
    they could print out all the environment variables and get your API keys. The
    approach I'm using with a JSON file as well as environment variables means I can
    use the same application image in production with Docker secrets for configuration—and
    that is secure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 环境值仍然不安全。如果有人获得了对您的应用程序的访问权限，他们可以打印出所有的环境变量并获取您的API密钥。我正在使用JSON文件以及环境变量的方法意味着我可以在生产中使用相同的应用程序镜像，使用Docker
    secrets进行配置 - 这是安全的。
- en: I've packaged those changes in a new version of the NerdDinner Docker image,
    which you can find at `dockeronwindows/ch05-nerd-dinner-web:2e`. Like the other
    examples from [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing
    Dockerized .NET Framework and .NET Core Applications*, the Dockerfile uses a bootstrap
    script as the entry point, which promotes environment variables to the machine
    level so the ASP.NET application can read them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这些更改打包到了NerdDinner Docker镜像的新版本中，您可以在`dockeronwindows/ch05-nerd-dinner-web:2e`找到。与[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中的其他示例一样，《开发Docker化的.NET
    Framework和.NET Core应用程序》，Dockerfile使用引导脚本作为入口点，将环境变量提升到机器级别，以便ASP.NET应用程序可以读取它们。
- en: 'The new version of the NerdDinner website runs in Docker with this command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner网站的新版本在Docker中运行的命令是：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The application needs other components to be running for it to start correctly.
    I have a PowerShell script which starts containers in the right order with the
    right options, but by the end of the chapter this script will be unwieldy. I'll
    address that in the next chapter when I look at Docker Compose.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要其他组件才能正确启动。我有一个PowerShell脚本，它以正确的顺序和选项启动容器，但到本章结束时，这个脚本将变得笨拙。在下一章中，当我研究Docker
    Compose时，我会解决这个问题。
- en: Splitting out the create dinner feature
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分创建晚餐功能
- en: In the `DinnerController` class the `Create` action is a relatively expensive
    database operation, which doesn't need to be synchronous. This feature is a good
    candidate for splitting into a separate component. I can publish a message from
    the web app instead of saving it to the database while the user waits—if the site
    is experiencing a high load, the message may wait in the queue for seconds or
    even minutes before being processed, but the response back to the user will be
    almost instant.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DinnerController`类中，`Create`操作是一个相对昂贵的数据库操作，不需要是同步的。这个特性很适合拆分成一个单独的组件。我可以从web应用程序发布消息，而不是在用户等待时将其保存到数据库中
    - 如果网站负载很高，消息可能会在队列中等待几秒甚至几分钟才能被处理，但对用户的响应几乎是即时的。
- en: There are two pieces of work that need to be done to split the feature into
    a new component. The web application needs to publish a message to a queue when
    a dinner is created, and a message handler needs to listen on the queue and save
    the dinner when it receives a message. In NerdDinner, there's a bit more work
    to do because the existing code base is a physical monolith as well as a logical
    monolith—there's just one Visual Studio project that contains everything, all
    the model definitions as well as the UI code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件工作需要做，将该功能拆分为一个新组件。Web应用程序需要在创建晚餐时向队列发布消息，消息处理程序需要在队列上监听并在接收到消息时保存晚餐。在NerdDinner中，还有更多的工作要做，因为现有的代码库既是物理单体，也是逻辑单体——只有一个包含所有内容的Visual
    Studio项目，所有的模型定义以及UI代码。
- en: In this chapter's source code, I've added a new .NET assembly project called
    `NerdDinner.Model` to the solution and moved the EF classes to that project so
    that they can be shared between the web app and the message handler. The model
    project targets the full .NET Framework rather than the .NET Core, so I can use
    the existing code as it is and I don't need to bring an upgrade of EF into scope
    for this feature change. This choice restricts the message handler to being a
    full .NET Framework application too.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码中，我添加了一个名为`NerdDinner.Model`的新的.NET程序集项目到解决方案中，并将EF类移动到该项目中，以便它们可以在Web应用程序和消息处理程序之间共享。模型项目针对完整的.NET
    Framework而不是.NET Core，所以我可以直接使用现有的代码，而不需要为了这个功能更改而引入EF的升级。这个选择也限制了消息处理程序也必须是一个完整的.NET
    Framework应用程序。
- en: There's also a shared assembly project to isolate the message queue code in
    `NerdDinner.Messaging`. I'll be using the NATS message system, which is a high-performance
    open source message queue. There is a NATS client package on NuGet that targets
    .NET Standard, so it can be used in both .NET Framework and .NET Core, and my
    messaging project has the same client package. This means that I can be flexible
    so that other message handlers that don't use the EF model could be written in
    .NET Core.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个共享的程序集项目来隔离`NerdDinner.Messaging`中的消息队列代码。我将使用NATS消息系统，这是一个高性能的开源消息队列。NuGet上有一个针对.NET
    Standard的NATS客户端包，所以它可以在.NET Framework和.NET Core中使用，我的消息项目也有相同的客户端包。这意味着我可以灵活地编写不使用EF模型的其他消息处理程序，可以使用.NET
    Core。
- en: 'In the model project, the original definition of the `Dinner` class is polluted
    with a lot of EF and MVC code to capture validation and storage behavior, like
    the following definition for the `Description` property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型项目中，`Dinner`类的原始定义被大量的EF和MVC代码污染，以捕获验证和存储行为，比如`Description`属性的以下定义：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class should be a simple POCO definition, but these attributes mean that
    the model definition is not portable because any consumers also need to reference
    EF and MVC. To avoid this in the messaging project, I have defined a simple `Dinner`
    entity without any of these attributes, and that class is the one I use to send
    dinner information in the messages. I can use the `AutoMapper` NuGet package to
    convert between `Dinner` class definitions, as the properties are fundamentally
    the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类应该是一个简单的POCO定义，但是这些属性意味着模型定义不具有可移植性，因为任何消费者也需要引用EF和MVC。为了避免这种情况，在消息项目中，我定义了一个简单的`Dinner`实体，没有任何这些属性，这个类是我用来在消息中发送晚餐信息的。我可以使用`AutoMapper`
    NuGet包在`Dinner`类定义之间进行转换，因为属性基本上是相同的。
- en: This is the sort of challenge you will find in lots of older projects—there's
    no clear separation of concerns, so breaking out features is not straightforward.
    You can take this approach to isolate shared components into new library projects.
    This is restructuring the code base without fundamentally changing its logic,
    which will help with modernizing the app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你会在许多旧项目中找到的挑战类型 - 没有明确的关注点分离，因此分解功能并不简单。您可以采取这种方法，将共享组件隔离到新的库项目中。这样重构代码库，而不会从根本上改变其逻辑，这将有助于现代化应用程序。
- en: 'The main code in the `Create` method of the `DinnersController` class now maps
    the dinner model to the clean `Dinner` entity and publishes an event instead of
    writing to the database:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`DinnersController`类的`Create`方法中的主要代码现在将晚餐模型映射到干净的`Dinner`实体，并发布事件，而不是写入数据库：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the fire-and-forget messaging pattern. The web application is the producer,
    publishing an event message. The producer doesn't wait for a response and doesn't
    know which components—if any—will consume the message and act on it. It's loosely
    coupled and fast, and it puts the responsibility to deliver the message on to
    the message queue, which is where it should be.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种“发出即忘记”的消息模式。Web应用程序是生产者，发布事件消息。生产者不等待响应，也不知道哪些组件 - 如果有的话 - 将消耗消息并对其进行操作。它松散耦合且快速，并且将传递消息的责任放在消息队列上，这正是应该的地方。
- en: 'Listening for this event message is a new .NET Framework console project in
    `NerdDinner.MessageHandlers.CreateDinner`. The `Main` method of the console app
    uses the shared messaging project to open a connection to the message queue and
    subscribe to these dinner-created event messages. When a message is received,
    the handler maps the `Dinner` entity in the message back to a dinner model and
    saves the model to the database using code taken from the original implementation
    in the `DinnersController` class (and tidied up a little):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 监听此事件消息的是一个新的.NET Framework控制台项目，位于`NerdDinner.MessageHandlers.CreateDinner`中。控制台应用程序的`Main`方法使用共享的消息项目打开与消息队列的连接，并订阅这些创建晚餐事件消息。当接收到消息时，处理程序将消息中的`Dinner`实体映射回晚餐模型，并使用从`DinnersController`类中原始实现中取出的代码将模型保存到数据库中（并进行了一些整理）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the message handler can be packaged into its own Docker image and run in
    a container alongside the website container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消息处理程序可以打包到自己的Docker镜像中，并在网站容器旁边的容器中运行。
- en: Packaging .NET console apps in Docker
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中打包.NET控制台应用程序
- en: Console apps are easy to build as good citizens for Docker. The compiled executable
    for the app will be the main process that Docker starts and monitors, so you just
    need to make use of the console for logging and you can use files and environment
    variables for configuration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序很容易构建为Docker的良好组件。应用程序的编译可执行文件将是Docker启动和监视的主要进程，因此您只需要利用控制台进行日志记录，并且可以使用文件和环境变量进行配置。
- en: For my message handler, I'm using a Dockerfile with a slightly different pattern.
    I have a separate image for the builder stage that I use to compile the whole
    solution—both the web project and the new projects I've added. I'll walk through
    the builder image later in the chapter once you've seen all the new components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的消息处理程序，我正在使用一个稍有不同模式的Dockerfile。我有一个单独的镜像用于构建阶段，我用它来编译整个解决方案 - 包括Web项目和我添加的新项目。一旦您看到所有新组件，我将在本章后面详细介绍构建者镜像。
- en: 'The builder compiles the solution and the Dockerfile for the console application
    references the `dockeronwindows/ch05-nerd-dinner-builder:2e` image to copy out
    the compiled binaries. The whole Dockerfile is very simple:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者编译解决方案，控制台应用程序的Dockerfile引用`dockeronwindows/ch05-nerd-dinner-builder:2e`镜像以复制编译的二进制文件。整个Dockerfile非常简单：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `from` argument in the `COPY` instruction specifies the source of the files.
    It can be another stage in a multistage build, or—as in this example—an existing
    image on the local machine or a registry.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令中的`from`参数指定文件的来源。它可以是多阶段构建中的另一个阶段，或者—就像在这个例子中—本地机器或注册表中的现有镜像。'
- en: The new message handler needs to access the message queue and the database,
    and the connection strings for each are captured in the project's `appsettings.json`
    file. The console app uses the same `Config` class as the NerdDinner web app,
    which loads default values from the JSON file and can override them from environment
    variables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 新的消息处理程序需要访问消息队列和数据库，每个连接字符串都在项目的`appsettings.json`文件中。控制台应用程序使用与NerdDinner
    web应用程序相同的`Config`类，该类从JSON文件加载默认值，并可以从环境变量中覆盖它们。
- en: In the Dockerfile, the entry point in the `CMD` instruction is the console executable,
    so the container will keep running as long as the console app is running. The
    listener for the message queue runs asynchronously on a separate thread to the
    main application. The handler code will fire when a message is received, so there's
    no polling of the queue, and the app runs very efficiently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中，`CMD`指令中的入口点是控制台可执行文件，因此只要控制台应用程序在运行，容器就会保持运行。消息队列的监听器在单独的线程上异步运行到主应用程序。当收到消息时，处理程序代码将触发，因此不需要轮询队列，应用程序运行非常高效。
- en: 'Keeping the console app running indefinitely is straightforward using a `ManualResetEvent`
    object. In the `Main` method, I wait for a reset event that never happens, so
    the program keeps running:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ManualResetEvent`对象可以简单地使控制台应用程序无限期地保持运行。在`Main`方法中，我等待一个永远不会发生的重置事件，因此程序会继续运行：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a simple and efficient way of keeping a .NET Framework or a .NET Core
    console app alive. When I start a message handler container, it will keep running
    in the background and listen for messages until the container is stopped.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保持.NET Framework或.NET Core控制台应用程序保持活动状态的一种简单有效的方法。当我启动一个消息处理程序容器时，它将在后台保持运行并监听消息，直到容器停止。
- en: Running a message queue in Docker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行消息队列
- en: The web application now publishes messages, and a handler listens for them,
    so the final component I need is a message queue to connect the two. Queues need
    the same level of availability as the rest of the solution, so they're good candidates
    for running in Docker containers. In a distributed solution that is deployed on
    many servers, the queue can be clustered across multiple containers for performance
    and redundancy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Web应用程序发布消息，处理程序监听这些消息，因此我需要的最后一个组件是一个消息队列来连接这两者。队列需要与解决方案的其余部分具有相同的可用性水平，因此它们是在Docker容器中运行的良好候选项。在部署在许多服务器上的分布式解决方案中，队列可以跨多个容器进行集群，以提高性能和冗余性。
- en: Your choice of messaging technology depends on the features you need, but there
    are plenty of options with .NET client libraries. **Microsoft Message Queue**
    (**MSMQ**) is the native Windows queue, **RabbitMQ** is a popular open source
    queue that supports durable messaging, and **NATS** is an open source in-memory
    queue that is hugely performant.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的消息传递技术取决于您需要的功能，但在.NET客户端库中有很多选择。**Microsoft Message Queue**（**MSMQ**）是本机Windows队列，**RabbitMQ**是一个流行的开源队列，支持持久化消息，**NATS**是一个开源的内存队列，性能非常高。
- en: The high throughput and low latency of NATS messaging makes it a good choice
    to communicate between containers, and there is an official image for NATS on
    Docker Hub. NATS is a Go application that runs cross platform, and there are Linux,
    Windows Server Core, and Nano Server variants of the Docker image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NATS消息传递的高吞吐量和低延迟使其成为在容器之间通信的良好选择，并且在Docker Hub上有一个官方的NATS镜像。NATS是一个跨平台的Go应用程序，Docker镜像有Linux、Windows
    Server Core和Nano Server的变体。
- en: At the time of writing, the NATS team only had images for Windows Server 2016
    published on Docker Hub. There will be a Windows Server 2019 image soon, but I've
    built my own for this chapter. Look at the Dockerfile for `dockeronwindows/ch05-nats:2e`
    and you'll see how easy it is to use the content from an official image in one
    of your own images.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，NATS团队仅在Docker Hub上发布了Windows Server 2016的镜像。很快将有Windows Server 2019镜像，但我已经为本章构建了自己的镜像。查看`dockeronwindows/ch05-nats:2e`的Dockerfile，您将看到如何轻松地在自己的镜像中使用官方镜像的内容。
- en: 'You run the NATS message queue like any other container. The Docker images
    exposes port `4222`, which is the port that clients use to connect to the queue,
    but you don''t need to publish that port unless you want to send messages to NATS
    outside a Docker container. Containers in the same network can always access one
    another''s ports, and they only need to be published to make them available outside
    Docker. The NerdDinner web app and message handler are using the server name `message-queue`
    to connect to NATS, so that needs to be the container name:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像运行其他容器一样运行NATS消息队列。Docker镜像公开了端口`4222`，这是客户端用来连接队列的端口，但除非您想要在Docker容器外部发送消息到NATS，否则您不需要发布该端口。同一网络中的容器始终可以访问彼此的端口，它们只需要被发布以使它们在Docker外部可用。NerdDinner
    Web应用程序和消息处理程序正在使用服务器名称`message-queue`来连接NATS，因此需要使用该容器名称：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The NATS server application logs messages to the console so that the log entries
    are collected by Docker. When the container is running, you can verify that the
    queue is listening using `docker container logs`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: NATS服务器应用程序将消息记录到控制台，以便Docker收集日志条目。当容器正在运行时，您可以使用`docker container logs`来验证队列是否正在监听：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The message queue is an infrastructure-level component with no dependencies
    on other components. It can be started before other containers and left running
    when application containers are stopped or upgraded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是一个基础架构级组件，不依赖于其他组件。它可以在其他容器之前启动，并且在应用程序容器停止或升级时保持运行。
- en: Starting a multi-container solution
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动多容器解决方案
- en: As you make more use of Docker, your solution will become distributed across
    more containers—either running custom code that you split out from a monolith
    or tried and trusted third-party software from Docker Hub or a third-party registry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您对Docker的更多使用，您的解决方案将分布在更多的容器中 - 无论是运行自己从单体中拆分出来的自定义代码，还是来自Docker Hub或第三方注册表的可靠的第三方软件。
- en: NerdDinner now runs across five containers—SQL Server, the original web app,
    the new homepage, the NATS message queue, and the message handler. There are dependencies
    between the containers, and they need to be started in the correct order and created
    with the correct names so that components can be found using Docker's service
    discovery.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner现在跨越了五个容器运行 - SQL Server，原始Web应用程序，新的主页，NATS消息队列和消息处理程序。容器之间存在依赖关系，它们需要以正确的顺序启动并使用正确的名称创建，以便组件可以使用Docker的服务发现找到它们。
- en: 'In the next chapter, I''ll use Docker Compose to declaratively map out these
    dependencies. For now, I have a PowerShell script called `ch05-run-nerd-dinner_part-1.ps1` that
    explicitly starts the containers with the correct configuration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将使用Docker Compose来声明性地映射这些依赖关系。目前，我有一个名为`ch05-run-nerd-dinner_part-1.ps1`的PowerShell脚本，它明确地使用正确的配置启动容器：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this script I'm using the SQL database and home page images from [Chapter
    3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized .NET Framework
    and .NET Core Applications*—these components haven't changed, so they can be run
    alongside the new components. If you want to run this yourself with full functionality,
    you will need to populate your own API keys in the file `api-keys.env`. You'll
    need to sign up to the Bing Maps API and the IP information database. You can
    run the app without those keys, but not all features will work correctly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我正在使用[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中的SQL数据库和主页图像，*开发Docker化的.NET
    Framework和.NET Core应用程序*——这些组件没有改变，所以它们可以与新组件一起运行。如果您想要自己运行具有完整功能的应用程序，您需要在文件`api-keys.env`中填写自己的API密钥。您需要注册Bing
    Maps API和IP信息数据库。您可以在没有这些密钥的情况下运行应用程序，但不是所有功能都会正常工作。
- en: 'When I run the script with my own API keys set and inspect the web container
    to get the port, I can browse to the application. It''s a fully featured version
    of NerdDinner now. I can log in and complete the create dinner form, complete
    with map integration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用自己设置的API密钥运行脚本并检查Web容器以获取端口时，我可以浏览应用程序。现在，NerdDinner是一个功能齐全的版本。我可以登录并完成创建晚餐表单，包括地图集成：
- en: '![](Images/68a1f0a6-8a3f-42ff-b0e0-aeb43fe1b36e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/68a1f0a6-8a3f-42ff-b0e0-aeb43fe1b36e.png)'
- en: 'When I submit the form, the web app publishes an event message to the queue.
    That is a very cheap operation, so the web app returns to the user almost immediately.
    Listening for messages is the console application, running in a different container—potentially
    on a different host. It picks up the message and processes it. The handler logs
    the activity to the console so that admin users can monitor it using `docker container
    logs`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我提交表单时，Web应用程序会向队列发布事件消息。这是一个非常廉价的操作，所以Web应用程序几乎立即返回给用户。控制台应用程序在监听消息，它运行在不同的容器中——可能在不同的主机上。它接收消息并处理它。处理程序将活动记录到控制台，以便管理员用户可以使用`docker
    container logs`来监视它：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The functionality of the create dinner feature is the same—data entered by the
    user is saved to SQL Server—and the user experience is the same, but the scalability
    of this feature is massively improved. Designing for containers lets me extract
    the persistence code into a new component, knowing the component can be deployed
    on the same infrastructure as the existing solution and that it will inherit the
    existing levels of scalability and failover, if the application is deployed on
    a cluster.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建晚餐功能的功能是相同的——用户输入的数据保存到SQL Server——用户体验也是相同的，但是这个功能的可扩展性得到了极大的改善。为容器设计让我可以将持久性代码提取到一个新的组件中，知道该组件可以部署在与现有解决方案相同的基础设施上，并且如果应用程序部署在集群上，它将继承现有的可扩展性和故障转移级别。
- en: 'I can rely on the Docker platform and take a dependency on a new core component:
    the message queue. The queue technology itself is enterprise-grade software, capable
    of processing hundreds of thousands of messages per second. NATS is free open
    source software that is available on Docker Hub to drop straight into your solution,
    running as a container and connected to other containers in the Docker network.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以依赖Docker平台并依赖一个新的核心组件：消息队列。队列技术本身是企业级软件，能够每秒处理数十万条消息。NATS是免费的开源软件，可以直接在Docker
    Hub上使用，作为一个容器运行并连接到Docker网络中的其他容器。
- en: So far I've used the container-first design and the power of Docker to modernize
    one part of NerdDinner. Targeting a single feature means I can release this new
    version confidently, after testing only the feature that's changed. If I wanted
    to add auditing to the create dinner feature, I would just make an update to the
    message handler, and I wouldn't need to do a full regression test of the web application,
    because that component is not going to be updated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经使用了以容器为先的设计和Docker的强大功能来现代化NerdDinner的一部分。针对单个功能意味着我可以在仅测试已更改的功能后，自信地发布这个新版本。如果我想要为创建晚餐功能添加审计，我只需更新消息处理程序，而不需要对Web应用进行完整的回归测试，因为该组件不会被更新。
- en: Designing with containers in mind also gives me a foundation to modernize the
    architecture of my legacy app and to add new features.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以容器为先的设计也为我提供了一个基础，可以用来现代化传统应用程序的架构并添加新功能。
- en: Modernizing legacy applications
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代化传统应用程序
- en: Breaking out backend features is a great way to start decomposing legacy monoliths.
    Adding a message queue to your deployment makes this a pattern you can repeat
    with any feature that would benefit from being asynchronous. There are other patterns
    for breaking down monolithic apps. We can really start to modernize NerdDinner
    if we expose a REST API and move to a modular UI for the frontend, with a reverse
    proxy to route between different components. We can do all of this with Docker.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将后端功能拆分是开始分解传统单体应用的好方法。将消息队列添加到部署中，使其成为一种模式，您可以重复使用任何受益于异步的功能。还有其他分解单体应用的模式。如果我们暴露一个REST
    API并将前端移动到模块化UI，并使用反向代理在不同组件之间进行路由，我们就可以真正开始现代化NerdDinner。我们可以用Docker做到这一切。
- en: Adding a REST API to expose data
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加REST API以公开数据
- en: Legacy apps often end up as stores of data that can't be accessed outside the
    app. The data would be valuable to other applications or to business partners
    if it was accessible. NerdDinner is a good example—it was designed and built before
    the age of Single Page Apps, where the UI is logic is separated from the business
    logic, which is exposed through a REST API. NerdDinner keeps its data to itself;
    you can't see a list of dinners unless you go through the NerdDinner UI.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序通常最终成为无法在应用程序外部访问的数据存储。如果这些数据可以访问，它们对其他应用程序或业务合作伙伴将非常有价值。NerdDinner是一个很好的例子——它是在单页面应用程序时代之前设计和构建的，其中UI逻辑与业务逻辑分离，并通过REST
    API公开。NerdDinner保留其数据；除非通过NerdDinner UI，否则无法查看晚餐列表。
- en: 'It''s easy to unlock legacy data with a simple REST API running in a Docker
    container. It doesn''t need to be a complex delivery: you can start by identifying
    a single dataset in the legacy app, which is useful for other business units or
    external consumers. Then, simply extract the loading logic for that dataset into
    a separate feature and deploy it as a read-only API in a container. You can iteratively
    add more features to the API when you have the demand, you don''t need to implement
    the whole service catalogue for your first release.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker容器中运行一个简单的REST API可以轻松解锁传统数据。它不需要复杂的交付：您可以首先识别传统应用程序中有用于其他业务部门或外部消费者的单个数据集。然后，将该数据集的加载逻辑简单提取到一个单独的功能中，并将其部署为只读API。当有需求时，您可以逐步向API添加更多功能，无需在第一个发布中实现整个服务目录。
- en: The main dataset in NerdDinner is the list of dinners, and I've built an ASP.NET
    Core REST API to expose all the dinners in a read-only `GET` request. The code
    is in the `NerdDinner.DinnerApi` project for this chapter, and it's a very simple
    implementation. Because I've already split the core entity definitions out from
    the main `NerdDinner` project, I can expose the existing contract from the API
    and use whatever data access technology I like inside the project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner的主要数据集是晚餐列表，我已经构建了一个ASP.NET Core REST API来在只读的`GET`请求中公开所有的晚餐。这一章的代码在`NerdDinner.DinnerApi`项目中，它是一个非常简单的实现。因为我已经将核心实体定义从主`NerdDinner`项目中拆分出来，所以我可以从API中公开现有的契约，并在项目内使用任何我喜欢的数据访问技术。
- en: 'I''ve chosen to use Dapper, which is a fast and intuitive object-relational
    mapper built for .NET Standard, so it works with .NET Framework and .NET Core
    apps. Dapper uses convention-based mapping; you provide a SQL statement and a
    target class type and it executes the database query and maps the results to objects.
    The code to load the dinner data from the existing table and map it to the shared
    `Dinner` object is quite straightforward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用Dapper，它是一个为.NET Standard构建的快速直观的对象关系映射器，因此它可以与.NET Framework和.NET Core应用程序一起使用。Dapper使用基于约定的映射；你提供一个SQL语句和一个目标类类型，它执行数据库查询并将结果映射到对象。从现有表中加载晚餐数据并将其映射到共享的`Dinner`对象的代码非常简单。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `GetAll` method is called in the API controller class, and the rest of the
    code is the usual ASP.NET Core setup.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在API控制器类中调用了`GetAll`方法，其余的代码是通常的ASP.NET Core设置。
- en: Dapper is usually much easier to work with than this example, but it lets you
    do some manual mapping when you need to, which is what I've done here. NerdDinner
    uses an SQL Server location data type to store where dinners are taking place.
    This maps to a .NET `DbGeography` type, but that type doesn't exist in .NET Standard.
    If you look through the code in `Chapter 5`, you'll see a few places where I map
    between `DbGeography` and my custom `Coordinates` types, which is what you'll
    need to do if you have a similar issue.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper通常比这个例子更容易使用，但当你需要时它可以让你进行一些手动映射，这就是我在这里所做的。NerdDinner使用SQL Server位置数据类型来存储晚餐的举办地点。这映射到.NET的`DbGeography`类型，但这种类型在.NET
    Standard中不存在。如果你浏览`第5章`中的代码，你会看到我在几个地方映射了`DbGeography`和我的自定义`Coordinates`类型，如果你遇到类似的问题，你就需要这样做。
- en: 'I''ve changed the original NerdDinner web app to use this new API when it fetches
    the list of dinners in the `DinnersController` class. I''m using a feature flag
    through the configuration setting `DinnerApi:Enabled` so that the app can either
    use the API as the data source, or query from the database directly. This lets
    me do a staged roll-out of the feature:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经修改了原始的NerdDinner web应用程序，使其在`DinnersController`类中获取晚餐列表时使用这个新的API。我通过配置设置`DinnerApi:Enabled`使用了一个功能标志，这样应用程序可以使用API作为数据源，或直接从数据库查询。这让我可以分阶段地推出这个功能：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new API gets packaged into the Docker image named `dockeronwindows/ch05-nerd-dinner-api`.
    The Dockerfile for this is very simple; it just starts from the official ASP.NET
    Core base image called `microsoft/dotnet:2.1-aspnetcore-runtime-nanoserver-1809`
    and copies in the compiled API code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 新的API被打包到名为`dockeronwindows/ch05-nerd-dinner-api`的Docker镜像中。这个Dockerfile非常简单；它只是从名为`microsoft/dotnet:2.1-aspnetcore-runtime-nanoserver-1809`的官方ASP.NET
    Core基础镜像开始，并复制编译后的API代码进去。
- en: I could run the API in a Docker container as an internal component, used by
    the NerdDinner web container but not publicly accessible, or I could publish a
    port on the API container and make it available outside the Docker network. It
    would be unusual to have a custom port for a public REST API, where consumers
    expect to access it on port `80` for HTTP and port `443` for HTTPS. I can add
    one more component to my solution that lets me use the standard set of ports for
    all my services and route incoming requests to different containers—that is called
    a **reverse proxy**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在Docker容器中运行API作为内部组件，由NerdDinner web容器使用，但不对外公开，或者我可以在API容器上发布一个端口，并使其在Docker网络之外可用。对于公共REST
    API来说，使用自定义端口是不寻常的，消费者期望在端口`80`上访问HTTP和端口`443`上访问HTTPS。我可以向我的解决方案添加一个组件，让我可以为所有服务使用标准端口集，并将传入的请求路由到不同的容器中——这就是所谓的**反向代理**。
- en: Routing HTTP requests between containers with a reverse proxy
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理在容器之间路由HTTP请求
- en: A reverse proxy is a very useful piece of technology to add to your project,
    whether you're looking at building a new microservices architecture or modernizing
    a legacy monolith. The reverse proxy is just an HTTP server that receives all
    the incoming web traffic from the outside world, fetches content from another
    HTTP server, and returns it to the client. In Docker the reverse proxy runs in
    a container with published ports, and it proxies traffic from other containers,
    which do not have any published ports.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理是一个非常有用的技术，无论您是在考虑构建新的微服务架构还是现代化传统的单体架构。反向代理只是一个HTTP服务器，它接收来自外部世界的所有传入网络流量，从另一个HTTP服务器获取内容，并将其返回给客户端。在Docker中，反向代理在一个带有发布端口的容器中运行，并代理来自其他没有发布端口的容器的流量。
- en: 'This is the architecture of the UI and API containers with the reverse proxy
    in place:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UI和API容器的架构，反向代理已经就位：
- en: '![](Images/c25f793f-b5b8-4a2c-99da-5fe28361943e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c25f793f-b5b8-4a2c-99da-5fe28361943e.png)'
- en: All the routing rules for incoming traffic are in the proxy container. It will
    be configured to load requests for the home page location `/` from the `nerd-dinner-homepage`
    container; requests that start with the path `/api` will be loaded from the `nerd-dinner-api`
    container, and any other requests will be loaded from the original app in the
    `nerd-dinner-web` container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有传入流量的路由规则都在代理容器中。它将被配置为从`nerd-dinner-homepage`容器加载主页位置`/`的请求；以路径`/api`开头的请求将从`nerd-dinner-api`容器加载，而其他任何请求将从`nerd-dinner-web`容器中的原始应用加载。
- en: It's important to realize that the proxy does not redirect the client to these
    other services. The proxy is the only endpoint that the client connects to. The
    proxy makes HTTP requests to the actual service on the client's behalf, using
    the containers' host names.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到代理不会将客户端重定向到其他服务。代理是客户端连接的唯一端点。代理代表客户端向实际服务发出HTTP请求，使用容器的主机名。
- en: Reverse proxies can do a lot more than routing requests. All traffic passes
    through the reverse proxy, so it can be the layer where you apply SSL termination
    and HTTP caching. You can even build security into your reverse proxy, using it
    for authentication and as a web application firewall, protecting you from common
    attacks like SQL injection. This is especially attractive for legacy applications.
    You can make performance and security improvements in the proxy layer, leaving
    the original app as an internal component in a container that can't be reached
    except through the proxy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理不仅可以路由请求。所有流量都通过反向代理，因此它可以是应用SSL终止和HTTP缓存的层。您甚至可以在反向代理中构建安全性，将其用于身份验证和作为Web应用程序防火墙，保护您免受常见攻击，如SQL注入。这对于传统应用程序尤其有吸引力。您可以在代理层中进行性能和安全改进，将原始应用程序作为容器中的内部组件，除非通过代理，否则无法访问。
- en: There are many technology options for the reverse proxy. Nginx and HAProxy are
    popular options in the Linux world, and they can also be used in Windows containers.
    You can even implement IIS as a reverse proxy, running it in a separate container
    with all the routing rules set up using the URL rewrite module. These options
    are powerful, but need quite a lot of configuration to get up and running. I'm
    going to use a reverse proxy called **Traefik**, which was built to run in a container
    in cloud-native applications, and it gets the configuration it needs from Docker.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理有许多技术选项。Nginx和HAProxy是Linux世界中受欢迎的选项，它们也可以在Windows容器中使用。您甚至可以将IIS实现为反向代理，将其运行在一个单独的容器中，并使用URL重写模块设置所有路由规则。这些选项功能强大，但需要相当多的配置才能运行起来。我将使用一个名为Traefik的反向代理，它是专为在云原生应用程序中运行的容器而构建的，并且它从Docker中获取所需的配置。
- en: Proxying traffic from Docker containers with Traefik
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Traefik代理来自Docker容器的流量
- en: 'Traefik is a fast, powerful, and easy-to-use reverse proxy. You run it in a
    container and publish the HTTP (or HTTPS) port, and configure the container to
    listen for events from the Docker Engine API:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik是一个快速、强大且易于使用的反向代理。您可以在一个容器中运行它，并发布HTTP（或HTTPS）端口，并配置容器以侦听来自Docker Engine
    API的事件：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Traefik is an official image on Docker Hub, but just like NATS the only Windows
    images available are based on Windows Server 2016\. I'm using my own image here,
    based on Windows Server 2019\. The Dockerfile is in my `sixeyed/dockerfiles-windows`
    repository on GitHub, but you should check Docker Hub to see whether there's a
    2019 variant of the official Traefik image before you use mine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik是Docker Hub上的官方镜像，但与NATS一样，唯一可用的Windows镜像是基于Windows Server 2016的。我在这里使用自己的镜像，基于Windows
    Server 2019。Dockerfile在我的GitHub上的`sixeyed/dockerfiles-windows`存储库中，但在使用我的镜像之前，您应该检查Docker
    Hub，看看官方Traefik镜像是否有2019变体。
- en: You've seen the `volume` option before - it's used to mount a filesystem directory
    on the host into the container. Her, I'm using it to mount a Windows **named pipe**,
    called `docker_engine`. Pipes are a networking approach for client-server communication.
    The Docker CLI and Docker API support connections over both TCP/IP and named pipes.
    Mounting a pipe like this lets a container query the Docker API without needing
    to know the IP address of the host where the container is running.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前见过`volume`选项-它用于将主机上的文件系统目录挂载到容器中。在这里，我使用它来挂载一个名为`docker_engine`的Windows**命名管道**。管道是客户端-服务器通信的一种网络方法。Docker
    CLI和Docker API支持TCP/IP和命名管道上的连接。像这样挂载一个管道让容器可以查询Docker API，而无需知道容器运行的主机的IP地址。
- en: Traefik subscribes to the event stream from the Docker API with the named pipe
    connection, using the connection details in the `docker.endpoint` option. It will
    get notifications from Docker when containers are created or removed, and Traefik
    uses the data in those events to build its own routing map.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik通过命名管道连接订阅来自Docker API的事件流，使用`docker.endpoint`选项中的连接详细信息。当容器被创建或移除时，Traefik将从Docker那里收到通知，并使用这些事件中的数据来构建自己的路由映射。
- en: 'When you have Traefik running, you create your application containers with
    labels to tell Traefik which requests should be routed to which containers. Labels
    are just key-value pairs that can be applied to containers when you create them.
    They are surfaced in the event stream from Docker. Traefik uses labels with the
    prefix `traefik.frontend` to build its routing rules. This is how I run the API
    container with routing by Traefik:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Traefik时，您可以使用标签创建应用程序容器，告诉Traefik应该将哪些请求路由到哪些容器。标签只是在创建容器时可以应用的键值对。它们会在来自Docker的事件流中显示。Traefik使用带有前缀`traefik.frontend`的标签来构建其路由规则。这就是我如何通过Traefik运行具有路由的API容器：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Docker creates the container called `nerd-dinner-api` and then publishes an
    event with the new container's details. Traefik gets that event, and adds a rule
    to its routing map. Any requests that come into Traefik with the HTTP `Host` header
    `api.nerddinner.local` will be proxied from the API container. The API container
    does not publish any ports - the reverse proxy is the only publicly accessible
    component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker创建名为`nerd-dinner-api`的容器，然后发布一个包含新容器详细信息的事件。Traefik接收到该事件后，会在其路由映射中添加一条规则。任何进入Traefik的带有HTTP
    `Host` 头部`api.nerddinner.local`的请求都将从API容器中进行代理。API容器不会发布任何端口 - 反向代理是唯一可公开访问的组件。
- en: Traefik has a very rich set of routing rules, using different parts of the HTTP
    request—the host, path, headers, and query string. You can map anything from wildcard
    strings to very specific URLs using Traefik's rules. There's much more that Traefik
    can do too, like load balancing and SSL termination. The documentation can be
    found at [https://traefik.io](https://traefik.io).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Traefik具有非常丰富的路由规则集，可以使用HTTP请求的不同部分 - 主机、路径、标头和查询字符串。您可以使用Traefik的规则将任何内容从通配符字符串映射到非常具体的URL。Traefik还可以执行更多操作，如负载平衡和SSL终止。文档可以在[https://traefik.io](https://traefik.io)找到。
- en: 'Using similar rules I can deploy the new version of NerdDinner and have all
    the frontend containers proxied by Traefik. The script `ch05-run-nerd-dinner_part-2.ps1`
    is an upgrade that removes the existing web containers first:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的规则，我可以部署NerdDinner的新版本，并让所有前端容器都由Traefik进行代理。脚本`ch05-run-nerd-dinner_part-2.ps1`是一个升级版本，首先删除现有的web容器：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Labels and environment variables are applied when a container is created, and
    they last for the life of the container. You can''t change those values on an
    existing container; you need to remove it and create a new one. I want to run
    the NerdDinner web and home page containers with labels for Traefik, so I need
    to replace the existing containers. The rest of the script starts Traefik, replaces
    the web containers with a new configuration, and starts the API container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 标签和环境变量在容器创建时被应用，并在容器的生命周期内持续存在。您无法更改现有容器上的这些值；您需要将其删除并创建一个新的容器。我想要为Traefik运行NerdDinner网站和主页容器，并为其添加标签，因此我需要替换现有的容器。脚本的其余部分启动Traefik，用新配置替换web容器，并启动API容器：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now when I load the NerdDinner website, I''ll browse to the Traefik container
    on port `80`. I''m using `Host` header routing rules, so I''ll be putting `http://nerddinner.local`
    into my browser. This is a local development environment, so I''ve added these
    values to my `hosts` file (in test and production environments, there would be
    a real DNS system resolving the host names):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我加载NerdDinner网站时，我将浏览到端口`80`上的Traefik容器。我正在使用`Host`头路由规则，所以我会在浏览器中输入`http://nerddinner.local`。这是一个本地开发环境，所以我已经将这些值添加到了我的`hosts`文件中（在测试和生产环境中，将有一个真正的DNS系统解析主机名）：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The home page request for the path `/` gets proxied from the home page container,
    and I also have a routing path specified for the CSS file so that I see the new
    home page complete with styling:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路径`/`的主页请求是从主页容器代理的，并且我还为CSS文件指定了一个路由路径，这样我就可以看到包含样式的新主页：
- en: '![](Images/a2acc8e6-3888-4052-b7ee-991a945b7e29.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a2acc8e6-3888-4052-b7ee-991a945b7e29.png)'
- en: 'This response is generated by the home page container, but proxied by Traefik.
    I can browse to `api.nerddinner.local` and see the all the dinners in JSON format
    from the new REST API container:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应是由主页容器生成的，但是由Traefik代理。我可以浏览到`api.nerddinner.local`，并从新的REST API容器中以JSON格式看到所有晚宴的信息：
- en: '![](Images/7c905e8a-1c7a-402a-87be-8afb6fa9c156.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7c905e8a-1c7a-402a-87be-8afb6fa9c156.png)'
- en: 'The original NerdDinner app still works in the same way, but when I browse
    to `/Dinners`, the list of dinners to display is fetched from the API instead
    of the database directly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的NerdDinner应用程序仍然以相同的方式工作，但是当我浏览到`/Dinners`时，显示的晚宴列表是从API中获取的，而不是直接从数据库中获取的：
- en: '![](Images/4c9a8b38-967c-4e76-921a-b5f648d91eb8.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4c9a8b38-967c-4e76-921a-b5f648d91eb8.png)'
- en: Working out the routing rules for the proxy is one of the harder parts of breaking
    up a monolith into multiple frontend containers. Microservice apps tend to be
    easier here, because they're designed to be different concerns running at different
    domain paths. You'll need a good understanding of Traefik's rules and of regular
    expressions when you start routing UI features to their own containers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 制定代理的路由规则是将单体应用程序分解为多个前端容器的较难部分之一。微服务应用程序在这方面往往更容易，因为它们被设计为在不同的域路径上运行的不同关注点。当您开始将UI功能路由到它们自己的容器时，您需要对Traefik的规则和正则表达式有很好的理解。
- en: 'Container-first design has let me modernize the architecture of NerdDinner
    without a complete rewrite. I''m using enterprise-grade open source software and
    Docker to power the following three patterns for breaking up the monolith:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 容器优先设计使我能够在不完全重写的情况下现代化NerdDinner的架构。我正在使用企业级开源软件和Docker来支持以下三种分解单体的模式：
- en: Making features asynchronous by publishing and subscribing to events on a message
    queue
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在消息队列上发布和订阅事件使功能异步化
- en: Exposing data with REST APIs, using a simple modern technology stack
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的现代技术栈通过REST API公开数据
- en: Splitting frontend features across multiple containers and routing between them
    with a reverse proxy
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前端功能拆分到多个容器中，并通过反向代理在它们之间进行路由
- en: Now I can be far more agile about delivering improvements to features because
    I won't always need to regression test the full application. I also have events
    that are published from key user activities, which is a step towards event-driven
    architecture. This lets me add completely new features without changing any existing
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以更加灵活地提供功能改进，因为我不总是需要对整个应用程序进行回归测试。我还有一些从关键用户活动中发布的事件，这是迈向事件驱动架构的一步。这让我可以在不更改任何现有代码的情况下添加全新的功能。
- en: Adding new features in containers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中添加新功能
- en: Breaking down a monolith into small components and modernizing the architecture
    has a beneficial side effect. The approach I've taken has introduced event publishing
    for one feature. I can build on that to add new features, again taking a container-first
    approach.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体架构分解为小组件并现代化架构具有有益的副作用。我采取的方法已经为一个功能引入了事件发布。我可以在此基础上构建新功能，再次采用以容器为先的方法。
- en: In NerdDinner there is a single data store, a transactional database stored
    in SQL Server. That's fine for servicing the website, but it's limited when it
    comes to user-facing features, such as reporting. There's no user-friendly way
    to search the data, build dashboards, or enable self-service reporting.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在NerdDinner中，有一个单一的数据存储，即存储在SQL Server中的事务性数据库。这对于为网站提供服务是可以的，但在涉及用户界面功能（如报告）时有限。没有用户友好的方式来搜索数据，构建仪表板或启用自助式报告。
- en: An ideal solution to this would be to add a secondary data store, a reporting
    database, using a technology that does provide self-service analytics. Without
    Docker, that would be a major project, needing a redesign or additional infrastructure
    or both. With Docker, I can leave the existing application alone and add new features
    running in containers on the existing servers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的理想方案是添加一个次要数据存储，即报告数据库，使用提供自助式分析的技术。如果没有Docker，这将是一个重大项目，需要重新设计或额外的基础设施或两者兼而有之。有了Docker，我可以让现有应用程序保持不变，并在现有服务器上运行容器中添加新功能。
- en: Elasticsearch is another enterprise-grade open source project which is available
    as an official image on Docker Hub. Elasticsearch is a full search document data
    store that works well as a reporting database, along with the companion product
    Kibana, which provides a user-friendly web frontend.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch是另一个企业级开源项目，可以作为Docker Hub上的官方镜像使用。Elasticsearch是一个完整的搜索文档数据存储，作为报告数据库运行良好，还有伴随产品Kibana，提供用户友好的Web前端。
- en: I can add self-service analytics for the dinners created in NerdDinner by running
    Elasticsearch and Kibana in containers in the same network as the other containers.
    The current solution already publishes events with dinner details, so to add dinners
    to the reporting database, I need to build a new message handler that subscribes
    to the existing events and saves the details in Elasticsearch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过在与其他容器相同的网络中在容器中运行Elasticsearch和Kibana，为NerdDinner中创建的晚餐添加自助式分析。当前解决方案已经发布了晚餐详情的事件，因此要将晚餐添加到报告数据库中，我需要构建一个新的消息处理程序，订阅现有事件并将详情保存在Elasticsearch中。
- en: When the new reporting feature is ready, it can be deployed to production without
    any changes to the running application. Zero-downtime deployment is another benefit
    of container-first design. Features are built to run in decoupled units, so individual
    containers can be started or upgraded without affecting other containers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的报告功能准备就绪时，可以将其部署到生产环境，而无需对正在运行的应用程序进行任何更改。零停机部署是容器优先设计的另一个好处。功能被构建为以解耦单元运行，因此可以启动或升级单个容器而不影响其他容器。
- en: For the next feature, I'll add a new message handler that is independent of
    the rest of the solution. If I needed to replace the implementation of the save-dinner
    handler, I could also do that with zero-downtime, using the message queue to buffer
    events while replacing the handler.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个功能，我将添加一个与解决方案的其余部分独立的新消息处理程序。如果我需要替换保存晚餐处理程序的实现，我也可以使用消息队列在替换处理程序时缓冲事件，实现零停机。
- en: Using Elasticsearch with Docker and .NET
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Elasticsearch与Docker和.NET。
- en: Elasticsearch is such a widely useful technology that it's worth looking at
    in a little detail. It's a Java application, but running in Docker, you can treat
    it as a black box and manage it in the same way as all other Docker workloads—you
    don't need to install Java or configure the JDK. Elasticsearch exposes a REST
    API for writing, reading, and searching data, and there are client wrappers for
    the API available in all major languages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch是一种非常有用的技术，值得稍微详细地了解一下。它是一个Java应用程序，但在Docker中运行时，你可以将其视为一个黑盒子，并以与所有其他Docker工作负载相同的方式进行管理——你不需要安装Java或配置JDK。Elasticsearch提供了一个REST
    API用于写入、读取和搜索数据，并且所有主要语言都有API的客户端包装器可用。
- en: Data in Elasticsearch is stored as JSON documents, and every document can be
    fully indexed so that you can search for any value in any field. It's a clustered
    technology that can run across many nodes for scale and resilience. In Docker,
    you can run each node in a separate container and distribute them across your
    server estate to gain scale and resilience, but with the ease of deployment and
    management you get with Docker.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch中的数据以JSON文档的形式存储，每个文档都可以完全索引，这样你就可以在任何字段中搜索任何值。它是一个可以在许多节点上运行的集群技术，用于扩展和弹性。在Docker中，你可以在单独的容器中运行每个节点，并将它们分布在服务器群中，以获得规模和弹性，但同时也能获得Docker的部署和管理的便利性。
- en: The same storage considerations apply to Elasticsearch as they do to any stateful
    workload—in development, you can save data inside the container so that when the
    container is replaced, you start with a fresh database. In test environments,
    you can use a Docker volume mounted to a drive folder on the host to keep persistent
    storage outside the container. In production, you can use a volume with a driver
    for an on-premises storage array or a cloud-storage service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何有状态的工作负载一样，Elasticsearch也需要考虑存储方面的问题——在开发中，你可以将数据保存在容器内，这样当容器被替换时，你就可以从一个新的数据库开始。在测试环境中，你可以使用一个Docker卷挂载到主机上的驱动器文件夹，以便在容器外保持持久存储。在生产环境中，你可以使用一个带有驱动程序的卷，用于本地存储阵列或云存储服务。
- en: 'There''s an official Elasticsearch image on Docker Hub, but it currently has
    only Linux variants. I have my own image on Docker Hub which packages Elasticsearch
    into a Windows Server 2019 Docker image. Running Elasticsearch in Docker is the
    same as starting any container. This command exposes port `9200`, which is the
    default port for the REST API:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub上有一个官方的Elasticsearch镜像，但目前只有Linux变体。我在Docker Hub上有自己的镜像，将Elasticsearch打包成了一个Windows
    Server 2019的Docker镜像。在Docker中运行Elasticsearch与启动任何容器是一样的。这个命令暴露了端口`9200`，这是REST
    API的默认端口。
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Elasticsearch is a memory-hungry application, and by default it allocates 2
    GB of system memory when it starts. In a development environment, I don't need
    that much memory for the database. I can configure this by setting the `ES_JAVA_OPTS`
    environment variable. In this command, I limit Elasticsearch to 512 MB of memory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch是一个占用内存很多的应用程序，默认情况下在启动时会分配2GB的系统内存。在开发环境中，我不需要那么多的内存来运行数据库。我可以通过设置`ES_JAVA_OPTS`环境变量来配置这个。在这个命令中，我将Elasticsearch限制在512MB的内存中。
- en: Elasticsearch is a cross-platform application, like NATS. There is no official
    Elasticsearch image for Windows, but you can check my Dockerfile on GitHub in
    the repository `sixeyed/dockerfiles-windows`. You'll see that I use the official
    OpenJDK Java image based on Windows Server Core 2019 for my Elasticsearch image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch是一个跨平台的应用程序，就像NATS一样。Windows没有官方的Elasticsearch镜像，但你可以在GitHub的`sixeyed/dockerfiles-windows`仓库中查看我的Dockerfile。你会看到我使用了基于Windows
    Server Core 2019的官方OpenJDK Java镜像来构建我的Elasticsearch镜像。
- en: There is a NuGet package for Elasticsearch called **NEST**, which is an API
    client for reading and writing data, and is targeted for the .NET Framework and
    .NET Core. I use this package in a new .NET Core console project, `NerdDinner.MessageHandlers.IndexDinner`.
    The new console app listens for the dinner-created event message from NATS and
    writes the dinner details as a document in Elasticsearch.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**NEST**的Elasticsearch NuGet包，它是用于读写数据的API客户端，面向.NET Framework和.NET Core。我在一个新的.NET
    Core控制台项目`NerdDinner.MessageHandlers.IndexDinner`中使用这个包。新的控制台应用程序监听来自NATS的dinner-created事件消息，并将dinner详情作为文档写入Elasticsearch。
- en: 'The code to connect to the message queue and subscribe to messages is the same
    as the existing message handler. I have a new `Dinner` class, which represents
    the Elasticsearch document, so that the message handler code maps from the `Dinner`
    entity to the dinner document and saves it in Elasticsearch:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到消息队列并订阅消息的代码与现有消息处理程序相同。我有一个新的`Dinner`类，它代表Elasticsearch文档，因此消息处理程序代码将`Dinner`实体映射到dinner文档并将其保存在Elasticsearch中：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Elasticsearch will run in a container, and the new document message handler
    will run in a container, all in the same Docker network as the rest of the NerdDinner
    solution. I can start the new containers while the existing solution is running,
    as there are no changes to the web application or the SQL Server message handler.
    Adding this new feature with Docker is a zero-downtime deployment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch将在一个容器中运行，新的文档消息处理程序将在一个容器中运行，都在与NerdDinner解决方案的其余部分相同的Docker网络中。我可以在现有解决方案运行时启动新的容器，因为Web应用程序或SQL
    Server消息处理程序没有任何更改。使用Docker添加这个新功能是零停机部署。
- en: The Elasticsearch message handler has no dependency on EF or any of the legacy
    code, just like the new REST API. I've taken advantage of this to write those
    apps in .NET Core, which gives me the freedom to run them in a Docker container
    on Linux or Windows hosts. My Visual Studio solution now has .NET Framework, .NET
    Standard, and .NET Core projects. Parts of the codebase are shared between the
    .NET Framework and .NET Core application projects. I can use multistage builds
    for each application Dockerfile, but that could cause problems in larger projects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch消息处理程序不依赖于EF或任何旧代码，就像新的REST API一样。我利用了这一点，在.NET Core中编写这些应用程序，这使我可以在Linux或Windows主机上的Docker容器中运行它们。我的Visual
    Studio解决方案现在有.NET Framework、.NET Standard和.NET Core项目。代码库的部分代码在.NET Framework和.NET
    Core应用程序项目之间共享。我可以为每个应用程序的Dockerfile使用多阶段构建，但在较大的项目中可能会引发问题。
- en: Large .NET codebases tend to have a multi-solution approach, with a master solution
    containing all the projects used in the CI server, and different `.sln` files
    for each area of the application, which each have a subset of projects. This lets
    different teams work on their part of the codebase without every developer having
    to load millions of lines of code into Visual Studio. It saves a lot of developer
    time, but it does introduce the risk that changes to a shared component can break
    another team's build.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大型.NET代码库往往采用多解决方案方法，其中一个主解决方案包含CI服务器中使用的所有项目，并且应用程序的每个区域都有不同的`.sln`文件，每个文件都有一部分项目。这样可以让不同的团队在不必加载数百万行代码到Visual
    Studio的情况下处理他们的代码库的一部分。这节省了很多开发人员的时间，但也引入了一个风险，即对共享组件的更改可能会破坏另一个团队的构建。
- en: If you move to multi-stage builds for all your components, you could still have
    this problem when you move to Docker. In that case, you can use an alternative
    approach where you build all the code in a single Dockerfile, much like the old
    master solution for Visual Studio.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将所有组件都迁移到多阶段构建，那么当您迁移到Docker时，仍可能遇到这个问题。在这种情况下，您可以使用另一种方法，在其中在单个Dockerfile中构建所有代码，就像Visual
    Studio的旧主解决方案一样。
- en: Building hybrid .NET Framework and .NET Core solutions in Docker
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中构建混合.NET Framework和.NET Core解决方案
- en: The multistage builds you've seen up until now have all used the `microsoft/dotnet-framework:4.7.2-sdk`
    image or the `microsoft/dotnet:2.2-sdk` image on Docker Hub. These images provide
    the relevant .NET runtime, together with the SDK components to restore packages,
    compile source code, and publish applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所看到的多阶段构建都使用了Docker Hub上的`microsoft/dotnet-framework:4.7.2-sdk`图像或`microsoft/dotnet:2.2-sdk`图像。这些图像提供了相关的.NET运行时，以及用于还原包、编译源代码和发布应用程序的SDK组件。
- en: The .NET Framework 4.7.2 image also contains the .NET Core 2.1 SDK, so if you're
    using those versions (or earlier), then you can build both .NET Framework and
    .NET Core apps in the same Dockerfile.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 4.7.2图像还包含.NET Core 2.1 SDK，因此如果您使用这些版本（或更早版本），则可以在同一个Dockerfile中构建.NET
    Framework和.NET Core应用程序。
- en: In the first edition of this book, there was no official image that had both
    the .NET Framework and .NET Core SDKs, so I showed you how to build your own using
    quite a complex Dockerfile with lots of Chocolatey installs. I also wrote, "*I
    expect later releases of MSBuild and .NET Core will have integrated tooling, so
    the complexity of managing multiple toolchains will go away," *and I'm glad to
    say that's where we are right now, with Microsoft managing those toolchains in
    Docker for us.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，没有官方图像同时包含.NET Framework和.NET Core SDK，因此我向您展示了如何使用非常复杂的Dockerfile自己构建图像，并进行了大量的Chocolatey安装。我还写道，“*我期望MSBuild和.NET
    Core的后续版本将具有集成工具，因此管理多个工具链的复杂性将消失，”*我很高兴地说，现在我们就在这个阶段，微软正在为我们管理这些工具链。
- en: Compiling the hybrid NerdDinner solution
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译混合NerdDinner解决方案
- en: I'm taking a different approach to building NerdDinner in this chapter, one
    that fits nicely with a CI process if you're mixing .NET Core and .NET Framework
    projects (I cover CI and CD with Docker in [Chapter 10](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml),
    *Powering a Continuous Deployment Pipeline with Docker*). I'll compile the whole
    solution in one image and use that image as the source for the binaries in my
    application Dockerfiles.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我采用了一种不同的方法来构建NerdDinner，这种方法与CI流程很好地契合，如果您正在混合使用.NET Core和.NET Framework项目（我在[第10章](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml)中使用Docker进行CI和CD，*使用Docker打造持续部署流水线*）。我将在一个图像中编译整个解决方案，并将该图像用作应用程序Dockerfile中二进制文件的来源。
- en: 'The following diagram shows how the SDK and builder images are used to package
    the application images for this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了SDK和构建器图像如何用于打包本章的应用程序图像：
- en: '![](Images/747a90e4-03ad-417c-ab18-06b37344e7ef.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/747a90e4-03ad-417c-ab18-06b37344e7ef.png)'
- en: 'All the tools I need to build the solution are in Microsoft''s SDK, so the
    Dockerfile for `dockeronwindows/ch05-nerd-dinner-builder:2e` is straightforward.
    It starts from the SDK, copies in the source tree for the solution, and restores
    dependencies:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解决方案所需的所有工具都在Microsoft的SDK中，因此`dockeronwindows/ch05-nerd-dinner-builder:2e`的Dockerfile很简单。它从SDK开始，复制解决方案的源树，并还原依赖项：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This runs `nuget restore` for the NerdDinner solution file. This restores all
    the .NET Framework, .NET Standard, and .NET Core references for all the projects.
    The last instruction builds each of the application projects, specifying the project
    file and a separate output path for each of them:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为NerdDinner解决方案文件运行`nuget restore`。这将为所有项目还原所有.NET Framework、.NET Standard和.NET
    Core引用。最后一条指令构建每个应用程序项目，指定项目文件和它们各自的单独输出路径：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can just run `msbuild` for the whole solution file, but this produces the
    compiled binaries and not the fully publish directories. This approach means that
    each app is published ready to be packaged, and the output is in a known location
    in the builder image. It also means that the whole application is compiled from
    the same set of source code, so you will find any breaking issues with dependencies
    between applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以只运行`msbuild`来处理整个解决方案文件，但这只会生成已编译的二进制文件，而不是完全发布的目录。这种方法意味着每个应用程序都已经准备好进行打包发布，并且输出位于构建图像中的已知位置。这也意味着整个应用程序是从相同的源代码集编译的，因此您将发现应用程序之间的依赖关系中的任何破坏问题。
- en: The disadvantage of this approach is that it doesn't make smart use of the Docker
    cache. The whole source tree is copied into the image as the first step. Whenever
    there is a code change, the build will update the packages, even if the package
    references haven't changed. You could write this builder differently, copying
    in the `.sln`, `.csproj` and `package.config` files first for the restore phase,
    and then copying in the rest of the source for the build phase.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它没有充分利用Docker缓存。整个源树被复制到映像中作为第一步。每当有代码更改时，构建将更新软件包，即使软件包引用没有更改。您可以以不同的方式编写此构建器，首先复制`.sln`、`.csproj`和`package.config`文件进行还原阶段，然后复制其余源进行构建阶段。
- en: That would give you package caching and a faster build, at the cost of a more
    brittle Dockerfile—you'd need to edit the initial file list every time you added
    or removed a project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供软件包缓存和更快的构建速度，但代价是更脆弱的Dockerfile - 每次添加或删除项目时都需要编辑初始文件列表。
- en: You can choose the approach that works best with your processes. In the case
    of a more complex solution than this, developers may build and run the app from
    Visual Studio and only build the Docker images to run tests before checking in
    the code. In this case, the slower Docker image build is not an issue (I discuss
    the options for running your application in Docker while you're developing it
    in [Chapter 11](d8929de7-3bbe-48ed-b755-5e918f048bd9.xhtml), *Debugging and Instrumenting
    Application Containers*).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择最适合您流程的方法。在比这更复杂的解决方案中，开发人员可能会从Visual Studio构建和运行应用程序，然后只构建Docker映像以在提交代码之前运行测试。在这种情况下，较慢的Docker映像构建不是问题（我在[第11章](d8929de7-3bbe-48ed-b755-5e918f048bd9.xhtml)中讨论了在开发过程中在Docker中运行应用程序的选项，*调试和检测应用程序容器*）。
- en: 'One thing is different regarding how this image is built. The Dockerfile copies
    in the `src` folder, which is one level higher than the folder where the Dockerfile
    lives. To make sure the `src` folder is included in the Docker context, I need
    to run the `build image` command from the `ch05` folder and specify the path to
    the Dockerfile with the `--file` option:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建此映像的方式有一个不同之处。Dockerfile复制了`src`文件夹，该文件夹比Dockerfile所在的文件夹高一级。为了确保`src`文件夹包含在Docker上下文中，我需要从`ch05`文件夹运行`build
    image`命令，并使用`--file`选项指定Dockerfile的路径：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Building the image compiles and packages all the projects, so I can use that
    image as the source for the published output in the application Dockerfiles. I
    need to build the builder only once, and then I can use it to build all the other
    images.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 构建映像会编译和打包所有项目，因此我可以将该映像用作应用程序Dockerfiles中发布输出的源。我只需要构建构建器一次，然后就可以用它来构建所有其他映像。
- en: Packaging .NET Core console apps in Docker
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中打包.NET Core控制台应用程序
- en: In [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized
    .NET Framework and .NET Core Applications*, I built the replacement NerdDinner
    home page as an ASP.NET Core web application, and in this chapter, I have the
    REST API and the Elasticsearch message handler as .NET Core applications. These
    can be packaged as Docker images, using variants of the `microsoft/dotnet` image
    on Docker Hub.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml)中，《开发Docker化的.NET Framework和.NET
    Core应用程序》，我将替换NerdDinner首页的ASP.NET Core Web应用程序构建为REST API和Elasticsearch消息处理程序作为.NET
    Core应用程序。这些可以打包为Docker镜像，使用Docker Hub上`microsoft/dotnet`镜像的变体。
- en: 'The Dockerfile for the REST API `dockeronwindows/ch05-nerd-dinner-api:2e` is
    very simple: it just sets up the container environment and then copies in the
    published application from the builder image:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的Dockerfile `dockeronwindows/ch05-nerd-dinner-api:2e`非常简单：它只是设置容器环境，然后从构建图像中复制发布的应用程序：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Dockerfile for the message handler `dockeronwindows/ch05-nerd-dinner-index-handler:2e`
    is even simpler—this is a .NET Core console app, so there are no ports to expose:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理程序的Dockerfile `dockeronwindows/ch05-nerd-dinner-index-handler:2e`更简单——这是一个.NET
    Core控制台应用程序，因此不需要暴露端口：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The content is very similar to the .NET Framework console app used for the SQL
    Server message handler. The differences are the `FROM` image; here, I'm using
    the .NET Core runtime image and the `CMD` instruction, and here it's the `dotnet`
    command that is running the console application DLL. Both the message handlers
    use the builder image as the source for copying the compiled application, and
    then set up the environment variables and startup commands they need.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 内容与用于SQL Server消息处理程序的.NET Framework控制台应用程序非常相似。不同之处在于`FROM`图像；在这里，我使用.NET Core运行时图像和`CMD`指令，这里运行控制台应用程序DLL的是`dotnet`命令。两个消息处理程序都使用构建图像作为复制编译应用程序的来源，然后设置它们需要的环境变量和启动命令。
- en: Both the .NET Core applications are bundled with default configuration values
    in `appsettings.json`, which can be overridden at container runtime using environment
    variables. These capture the URLs for the message queue and the Elasticsearch
    API, and the connection string for the SQL Server database. The startup command
    runs the .NET Core application. ASP.NET Core apps continue running in the foreground
    until the application is stopped. The .NET Core console app for the message handler
    stays alive in the foreground with a `ManualResetEvent` object. Both write log
    entries to the console, so they integrate well with Docker.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core应用程序都捆绑了`appsettings.json`中的默认配置值，可以使用环境变量在容器运行时进行覆盖。这些配置包括消息队列和Elasticsearch
    API的URL，以及SQL Server数据库的连接字符串。启动命令运行.NET Core应用程序。ASP.NET Core应用程序会一直在前台运行，直到应用程序停止。消息处理程序的.NET
    Core控制台应用程序会使用`ManualResetEvent`对象在前台保持活动状态。两者都会将日志条目写入控制台，因此它们与Docker集成良好。
- en: When the index handler application runs, it will listen for messages from NATS,
    with the dinner-created message subject. When events are published from the web
    application, NATS will send copies to every subscriber, so the SQL Server save
    handler and the Elasticsearch index handler will both get copies of the event.
    The event message contains enough detail for both handlers to operate. If a future
    feature requires more detail, then the web app can publish a new version of the
    event with additional information, but the existing message handlers will not
    need to change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引处理程序应用程序运行时，它将监听来自NATS的消息，主题为dinner-created。当从Web应用程序发布事件时，NATS将向每个订阅者发送副本，因此SQL
    Server保存处理程序和Elasticsearch索引处理程序都将获得事件的副本。事件消息包含足够的细节，以便两个处理程序运行。如果将来的功能需要更多细节，那么Web应用程序可以发布带有附加信息的事件的新版本，但现有的消息处理程序将不需要更改。
- en: Running another container with Kibana will complete this feature and add self-service
    analytics to NerdDinner.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行另一个带有Kibana的容器将完成此功能，并为NerdDinner添加自助式分析。
- en: Providing analytics with Kibana
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kibana提供分析
- en: Kibana is an open source web frontend for Elasticsearch that gives you visualizations
    for analytics and the ability to search for specific data. It's produced by the
    company behind Elasticsearch and is very widely used because it provides a user-friendly
    way to navigate huge quantities of data. You can explore the data interactively,
    and power users can build comprehensive dashboards to share with others.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana是Elasticsearch的开源Web前端，为您提供了用于分析的可视化和搜索特定数据的能力。它由Elasticsearch背后的公司制作，并且被广泛使用，因为它提供了一个用户友好的方式来浏览大量的数据。您可以交互式地探索数据，而高级用户可以构建全面的仪表板与他人分享。
- en: 'The latest version of Kibana is a Node.js application, so like Elasticsearch
    and NATS, it''s a cross-platform application. There''s an official image on Docker
    Hub with Linux and variants, and I''ve packaged my own image based on Windows
    Server 2019\. The Kibana image is built using the same convention-based approach
    that I''ve used in the message handlers: it expects to connect to a container
    called `elasticsearch` on the default API port `9200`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana的最新版本是一个Node.js应用程序，因此像Elasticsearch和NATS一样，它是一个跨平台应用程序。Docker Hub上有一个官方的Linux和变体镜像，我已经基于Windows
    Server 2019打包了自己的镜像。Kibana镜像使用了与消息处理器中使用的相同的基于约定的方法构建：它期望连接到默认API端口`9200`上名为`elasticsearch`的容器。
- en: 'In the source code directory for this chapter, there is a second PowerShell
    script that deploys the containers for this feature. The fine named `ch05-run-nerd-dinner_part-3.ps1`
    starts the additional Elasticsearch, Kibana, and index handler containers, and
    it assumes that the other components are already running from the part-1 and part-2
    scripts:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码目录中，有第二个PowerShell脚本，用于部署此功能的容器。名为`ch05-run-nerd-dinner_part-3.ps1`的脚本启动了额外的Elasticsearch、Kibana和索引处理器容器，并假定其他组件已经从part-1和part-2脚本中运行：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Kibana container is labelled with Traefik's frontend rules. By default,
    Kibana listens on port `5601`, but in my setup, I'll be able to reach it on port
    `80` using the `kibana.nerddinner.local` domain, which I've added to my `hosts`
    file, and Traefik will proxy the UI.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana容器带有Traefik的前端规则。默认情况下，Kibana监听端口`5601`，但在我的设置中，我将能够在端口`80`上使用`kibana.nerddinner.local`域名访问它，我已经将其添加到我的`hosts`文件中，Traefik将代理UI。
- en: 'The full stack is running now. When I add a new dinner, I will see the logs
    from the message handler containers showing that the data is now being saved to
    Elasticsearch, as well as to the SQL Server:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 整个堆栈现在正在运行。当我添加一个新的晚餐时，我将看到来自消息处理器容器的日志，显示数据现在正在保存到Elasticsearch，以及SQL Server：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Kibana is being proxied by Traefik, so I just need to browse to `kibana.nerddinner.local`.
    The only configuration the launch-screen needs is the name of the document collection,
    which Elasticsearch calls an index. In this case, the index is called **dinners**.
    I''ve already added a document with the message handler so that Kibana can access
    the Elasticsearch metadata to determine the fields in the documents:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana由Traefik代理，所以我只需要浏览到`kibana.nerddinner.local`。启动屏幕唯一需要的配置是文档集合的名称，Elasticsearch称之为索引。在这种情况下，索引被称为**dinners**。我已经使用消息处理器添加了一个文档，以便Kibana可以访问Elasticsearch元数据以确定文档中的字段：
- en: '![](Images/e12648b2-f748-4981-a941-a9ca1de192e9.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e12648b2-f748-4981-a941-a9ca1de192e9.png)'
- en: 'Every dinner created will now be saved in the original transactional database
    SQL Server, and also in the new reporting database, Elasticsearch. Users can create
    visualizations over aggregated data, looking for patterns in popular times or
    locations, and they can search for particular dinner details and retrieve specific
    documents:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建的每个晚餐都将保存在原始的事务性数据库SQL Server中，也会保存在新的报告数据库Elasticsearch中。用户可以对聚合数据创建可视化，寻找热门时间或地点的模式，并且可以搜索特定的晚餐详情并检索特定文档：
- en: '![](Images/7f7fed5f-7a23-4f37-bbea-8747c53e1135.png)Elasticsearch and Kibana
    are hugely capable software systems. Docker has made them accessible to a whole
    new set of users. I won''t cover them in any further detail in this book, but
    they are popular components with a lot of online resources, that you can search
    for, if you want to learn more.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7f7fed5f-7a23-4f37-bbea-8747c53e1135.png)Elasticsearch和Kibana是非常强大的软件系统。
    Docker使它们对一大批新用户可用。我不会在本书中进一步详细介绍它们，但它们是受欢迎的组件，有很多在线资源，如果您想了解更多，可以搜索。'
- en: From monolith to distributed solution
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体架构到分布式解决方案
- en: NerdDinner has evolved from a legacy monolith to an easily scalable, easily
    extensible solution running on a modern application platform using modern design
    patterns. It's been a fast and low-risk evolution, powered by the Docker platform
    and container-first design.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner已经从传统的单体架构发展为一个易于扩展、易于扩展的解决方案，运行在现代应用程序平台上，使用现代设计模式。这是一个快速且低风险的演变，由Docker平台和以容器为先的设计推动。
- en: 'The project started by migrating NerdDinner to Docker as-is, running one container
    for the web application and one for the SQL Server database. Now I have ten components
    running in containers. Five are running my custom code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目开始将NerdDinner迁移到Docker，运行一个容器用于Web应用程序，另一个用于SQL Server数据库。现在我有十个组件在容器中运行。其中五个运行我的自定义代码：
- en: The original ASP.NET NerdDinner web application
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的ASP.NET NerdDinner Web应用程序
- en: The new ASP.NET Core web homepage
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的ASP.NET Core Web首页
- en: The new .NET Framework save-dinner message handler
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的.NET Framework save-dinner消息处理程序
- en: The new .NET Core index-dinner message handler
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的.NET Core index-dinner消息处理程序
- en: The new ASP.NET Core dinners API
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的ASP.NET Core晚餐API
- en: 'Four are enterprise-grade open source technologies:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种企业级开源技术：
- en: Traefik reverse proxy
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Traefik反向代理
- en: NATS message queue
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NATS消息队列
- en: Elasticsearch document database
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch文档数据库
- en: Kibana analytics UI
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kibana分析UI
- en: 'The last is SQL Server Express, which is free to use in production. Each component
    runs in a lightweight Docker container, and each is capable of being independently
    deployed so that they can follow their own release cadence:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是SQL Server Express，在生产中免费使用。每个组件都在轻量级的Docker容器中运行，并且每个组件都能够独立部署，以便它们可以遵循自己的发布节奏：
- en: '![](Images/810be7f9-9933-4e95-8b15-0a730684c67a.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/810be7f9-9933-4e95-8b15-0a730684c67a.png)'
- en: One of the great benefits of Docker is the huge library of packaged software
    available to add to your solution. The official images on Docker Hub have been
    tried and trusted by the community for years. Certified images on Docker Hub provide
    commercial software that is guaranteed to work correctly on Docker Enterprise.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个巨大好处是其庞大的打包软件库，可供您添加到解决方案中。 Docker Hub上的官方镜像已经经过社区多年的尝试和信任。 Docker
    Hub上的认证镜像提供了商业软件，保证在Docker Enterprise上能够正确运行。
- en: More and more software packages are becoming available for Windows in easily-consumed
    Docker images, giving you the scope to add features to your application without
    significant development.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的软件包以易于消费的Docker镜像形式提供给Windows，使您有能力在不需要大量开发的情况下为您的应用程序添加功能。
- en: The new custom components in the NerdDinner stack are the message handlers and
    the REST API, all simple applications containing around 100 lines of code. The
    save-dinner handler uses the original code from the web application and uses the
    EF model, which I refactored into its own project to enable its reuse. The index
    dinner handler and the REST API use all new code written in .NET Core, which makes
    it efficient and portable at runtime, but at build time, all the projects are
    in a single Visual Studio solution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: NerdDinner堆栈中的新自定义组件是消息处理程序和REST API，所有这些都是包含大约100行代码的简单应用程序。save-dinner处理程序使用了Web应用程序的原始代码，并使用了我重构为自己的项目以实现重用的EF模型。index
    dinner处理程序和REST API使用了.NET Core中的全新代码，这使得它在运行时更高效和可移植，但在构建时，所有项目都在一个单一的Visual
    Studio解决方案中。
- en: 'The container-first approach is about breaking features into discrete components
    and designing these components to run in containers, either as small custom applications
    that you write yourself or as off-the-shelf images from Docker Hub. This feature-driven
    approach means that you focus on an area that is valuable to the project''s stakeholders:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以容器为先的方法是将功能分解为离散的组件，并设计这些组件以在容器中运行，无论是作为你自己编写的小型自定义应用程序，还是作为Docker Hub上的现成镜像。这种以功能为驱动的方法意味着你专注于对项目利益相关者有价值的领域：
- en: To the business, because it gives them new functionality or more frequent releases
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于业务来说，这是因为它为他们提供了新的功能或更频繁的发布
- en: To operations, because it makes the application more resilient and easier to
    maintain
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于运维来说，因为它使应用程序更具弹性和更易于维护
- en: To the development team, because it addresses technical debt and allows greater
    architectural freedom
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对开发团队来说，因为它解决了技术债务并允许更大的架构自由
- en: Managing build and deployment dependencies
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理构建和部署依赖。
- en: 'In the current evolution, NerdDinner has a well-structured and logical architecture,
    but practically, it has a lot of dependencies. The container-first design approach
    gives me technology stack freedom, but that can lead to a lot of new technologies.
    If you were to join the project at this stage and wanted to run the application
    locally outside Docker, you''d need the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的演进中，NerdDinner有一个结构良好、逻辑清晰的架构，但实际上它有很多依赖。以容器为先的设计方法给了我技术栈的自由，但这可能会导致许多新技术。如果你在这个阶段加入项目并希望在Docker之外本地运行应用程序，你需要以下内容：
- en: Visual Studio 2017
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017
- en: .NET Core 2.1 runtime and SDK
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.1运行时和SDK
- en: IIS and ASP.NET 4.7.2
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIS和ASP.NET 4.7.2
- en: SQL Server
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server
- en: Traefik, NATS, Elasticsearch, and Kibana
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Traefik、NATS、Elasticsearch和Kibana
- en: If you join the project and you have Docker Desktop on Windows 10, you don't
    need any of these dependencies. When you've cloned the source code, you can build
    and run the whole application stack with Docker. You can even develop and debug
    the solution with Docker and a lightweight editor, such as VS Code, removing even
    the dependency for Visual Studio.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加入了这个项目并且在Windows 10上安装了Docker Desktop，你就不需要这些依赖。当你克隆了源代码后，你可以使用Docker构建和运行整个应用程序堆栈。你甚至可以使用Docker和轻量级编辑器（如VS
    Code）开发和调试解决方案，甚至不需要依赖Visual Studio。
- en: 'This also makes continuous integration very easy: your build servers only need
    Docker installed to build and package the solution. You can use disposable build
    servers, spinning up a VM when you have builds queued and then destroying the
    VM when the queue is empty. You don''t need complex initialization scripts for
    the VM, just a scripted Docker install. You could also use a managed CI service
    in the cloud, as they all now support Docker.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得持续集成非常容易：你的构建服务器只需要安装Docker来构建和打包解决方案。你可以使用一次性构建服务器，在排队构建时启动一个虚拟机，然后在队列为空时销毁虚拟机。你不需要复杂的虚拟机初始化脚本，只需要一个脚本化的Docker安装。你也可以使用云中的托管CI服务，因为它们现在都支持Docker。
- en: There are still runtime dependencies for the solution, which I'm currently managing
    with a script that starts all the containers with the right options and in the
    right order. This is a brittle and limited approach—the script has no logic to
    handle any failures or to allow for a partial start where some containers are
    already running. You wouldn't do this in a real project; I'm only using the script
    so we can focus on building and running the containers. In the next chapter, I'll
    show you the right way to do it, using Docker Compose to define and run the whole
    solution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中仍然存在运行时依赖关系，我目前正在使用一个脚本来管理所有容器的启动选项和正确的顺序。这是一种脆弱和有限的方法——脚本没有逻辑来处理任何故障或允许部分启动，其中一些容器已经在运行。在一个真正的项目中你不会这样做；我只是使用这个脚本让我们可以专注于构建和运行容器。在下一章中，我会向你展示正确的方法，使用Docker
    Compose来定义和运行整个解决方案。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter I looked at container-first solution design, making use of the
    Docker platform at design time to easily and safely add features to your application.
    I described a feature-driven approach to modernizing an existing software project
    that maximizes return on your investment and gives you clear visibility on its
    progress.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我讨论了基于容器的解决方案设计，利用Docker平台在设计时轻松而安全地为你的应用程序添加功能。我描述了一种面向特性的方法，用于现代化现有软件项目，最大限度地提高投资回报，并清晰地展示其进展情况。
- en: The container-first approach to features lets you use production-grade software
    from Docker Hub to add capabilities to your solution, with official and certified
    images that are high-quality curated applications. You can add these off-the-shelf
    components and focus on building small custom components to complete the features.
    Your application will evolve to be loosely coupled so that individual elements
    can each have the most appropriate release cycle.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的功能优先方法让你可以使用来自Docker Hub的生产级软件来为你的解决方案增加功能，使用官方和认证的高质量精心策划的镜像。你可以添加这些现成的组件，并专注于构建小型定制组件来完成功能。你的应用程序将逐渐演变为松散耦合，以便每个单独的元素都可以拥有最合适的发布周期。
- en: The speed of development in this chapter has outpaced operations, so we currently
    have a well-architected solution that is fragile to deploy. In the next chapter
    I'll introduce **Docker Compose**, which provides a clear and uniform way to describe
    and manage multi-container solutions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，开发速度已经超过了运维，所以我们目前拥有一个良好架构的解决方案，但部署起来很脆弱。在下一章中，我会介绍Docker Compose，它提供了一种清晰和统一的方式来描述和管理多容器解决方案。
