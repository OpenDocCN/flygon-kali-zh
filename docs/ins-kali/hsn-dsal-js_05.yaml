- en: Simplify Complex Applications Using Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图简化复杂应用程序
- en: 'The simplest way to define a graph would be anything that is a collection of
    nodes in which the nodes are connected by edges. Graphs are one of the most popular
    mathematical concepts that are used in computer science. Popular examples of graph
    implementations would be any social media website these days. Facebook use *friends*
    as nodes and *friendship* as edges; Twitter, on the other hand, defines *followers*
    as nodes and *following* as an edge, and so on. Take a look at the following image:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 定义图的最简单方法是任何由边连接的节点集合。图是计算机科学中使用的最流行的数学概念之一。图的常见实现示例是任何社交媒体网站。Facebook使用*朋友*作为节点，*友谊*作为边；而Twitter则将*追随者*定义为节点，*关注*作为边，依此类推。看一下下面的图像：
- en: '![](assets/d8be5138-4d0c-4624-9c82-e933197e3fd2.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d8be5138-4d0c-4624-9c82-e933197e3fd2.png)'
- en: In the preceding image, you can see a typical graph with *nodes* and *edges*.
    As you can note, there are no directions listed out to our edges, and there are
    no details mentioned on our nodes. This is because there are different types of
    graphs, and the nodes and edges vary slightly between these different types of
    graphs, which we will see in the subsequent sections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图像中，你可以看到一个典型的图，有*节点*和*边*。正如你所注意到的，我们的边没有列出方向，节点也没有详细信息。这是因为有不同类型的图，节点和边在这些不同类型的图之间略有不同，我们将在接下来的部分中看到。
- en: 'In this chapter, we will first go over the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论以下主题：
- en: Types of graphs
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图的类型
- en: Creating a reference generator for a job portal
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为求职门户网站创建一个参考生成器
- en: Creating a friend recommendation system
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个朋友推荐系统
- en: Types of graphs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的类型
- en: 'From the preceding description, we can speculate on the types of graphs. There
    are way too many to cover in this chapter or even in this book. However, let''s
    take a look at some of the most important and popular graphs, which we will be
    exploring with examples in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的描述，我们可以推测出图的类型。有太多类型要在本章甚至本书中涵盖。然而，让我们来看一些最重要和最流行的图，我们将在本章中通过示例来探索：
- en: '**Simple graphs**: A simple graph is an undirected, unweighted graph that contains
    no loops or multi-edge (that is multiple edges between the two nodes also known
    as parallel edges) nodes:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单图**：简单图是一个无向、无权重的图，不包含循环或多边（即两个节点之间的多条边，也称为平行边）节点：'
- en: '![](assets/c6c9cd6b-d1fe-4904-bc9d-15317644dfc0.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6c9cd6b-d1fe-4904-bc9d-15317644dfc0.png)'
- en: '**Undirected graphs**: This is a graph in which the edge definitions are interchangeable.
    For example, in the following image, the edge between nodes **1** and **2** can
    be represented as (1,2) or (2,1). The nodes are thus joined by a line without
    the arrows pointing towards any of the nodes:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无向图**：这是一个图，其中边的定义是可互换的。例如，在下面的图像中，节点**1**和**2**之间的边可以表示为(1,2)或(2,1)。因此，节点之间通过一条没有箭头指向任何节点的线连接：'
- en: '![](assets/6f480d4b-8a1a-4a4c-937a-589b08501a32.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f480d4b-8a1a-4a4c-937a-589b08501a32.png)'
- en: '**Directed graphs**: This is a graph in which the edges are given predefined
    direction based on a functional or logical condition. The edges are drawn with
    arrows, indicating the direction of the flow, for example, one user following
    another user on Twitter. Take a look at the following image:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向图**：这是一个图，其中边根据功能或逻辑条件给定预定义方向。边用箭头绘制，表示流动的方向，例如Twitter上的一个用户关注另一个用户。看一下下面的图像：'
- en: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
- en: '**Cyclic graphs**: This is a graph in which the edges form a circular connection
    between nodes, that is, the start and end nodes are the same. For example, in
    the following image, we can note that the nodes **1** >> **5** >> **6** >> **7**
    >> **3** >> **1** form the cycle within the graph:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环图**：这是一个图，其中边形成节点之间的循环连接，即起始和结束节点相同。例如，在下面的图像中，我们可以注意到节点**1** >> **5**
    >> **6** >> **7** >> **3** >> **1**形成了图中的循环：'
- en: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
- en: '**Directed acyclic graphs**: This is a directed graph with no cycles. These
    are the most common kind of graphs. In the following example, nodes are **1**,
    **2**, **3**, **4**, **5**, **6**, **7** and edges are {(1, 2), (1, 3), (1, 5),
    (2, 4), (4, 3), (4, 6), (5, 4), (5, 6), (6, 7), (7, 3)}:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向无环图**：这是一个没有循环的有向图。这是最常见的图的类型。在下面的例子中，节点是**1**、**2**、**3**、**4**、**5**、**6**、**7**，边是{(1,
    2), (1, 3), (1, 5), (2, 4), (4, 3), (4, 6), (5, 4), (5, 6), (6, 7), (7, 3)}：'
- en: '![](assets/46f3b2e7-694f-4ce4-a7b9-f6550d0016d6.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46f3b2e7-694f-4ce4-a7b9-f6550d0016d6.png)'
- en: '**Weighted graphs**: This is a graph in which the edges are assigned numeric
    weights based on how expensive or inexpensive it can be to traverse that edge.
    The usage of the weight of each edge can vary based on the use cases. In the following
    example, you can note that the graphs are assigned weights (**0**, **1**, **3**,
    or **5**) based on the edges between them:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加权图**：这是一个图，其中边根据穿越该边的成本或便宜程度被分配数值权重。每条边的权重的使用可以根据用例而变化。在下面的例子中，你可以注意到图之间的边被分配了权重(**0**、**1**、**3**或**5**)：'
- en: '![](assets/c6e00e40-2786-46eb-b85d-43d2ac14d9d7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6e00e40-2786-46eb-b85d-43d2ac14d9d7.png)'
- en: Fortunately, or unfortunately, the problems that we face in our day-to-day challenges
    do not directly tell us whether we can solve them with a graph, and if so, what
    kind of graph it needs to be or what kind of parsing algorithm we will need to
    employ. This is something that we take upon a case-by-case basis, which is what
    we will be doing with the following use cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，或不幸的是，我们在日常挑战中面临的问题并没有直接告诉我们是否可以用图解决它们，如果可以，它需要什么样的图或者我们需要使用什么样的解析算法。这是我们会根据具体情况来处理的事情，这也是我们将在下面的用例中所做的。
- en: Use cases
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Implementing a graph is similar to that of trees; there is no set way of creating
    one. However, based on your use case, you can structure your graphs as directed,
    cyclic, or any other form as explained earlier. Doing this can make their traversal
    easier, which would, in turn, make data retrieval easier and faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现图与树的方式类似；没有固定的创建方式。然而，根据您的用例，您可以根据需要将图结构化为有向、循环或其他形式，如前面所述。这样做可以使它们的遍历更容易，从而使数据检索更容易、更快。
- en: Let's take a look at some examples for which we will be needing a base application
    first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一些示例，我们首先需要一个基础应用程序。
- en: Creating a Node.js web server
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Node.js Web服务器
- en: 'Let''s first create a web server using Node.js, which we will use to create
    endpoints later on to access our graph-based applications:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Node.js创建一个Web服务器，稍后我们将使用它来创建端点以访问我们基于图的应用程序：
- en: 'The first step is to create your application''s project folder; to do so, run
    the following command from the Terminal:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建应用程序的项目文件夹；要做到这一点，从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to initialize a Node.js project, run the `init` command in the root folder
    of your project. This will prompt a series of questions to generate the `package.json`file.
    You can fill out the answers you want or just click on `return`to accept default
    values for the prompts:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要初始化一个Node.js项目，在项目的根目录运行`init`命令。这将提示一系列问题以生成`package.json`文件。您可以填写您想要的答案，或者只需点击`return`接受提示的默认值：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, since we want to create a web server, we will use `express`*, *which
    is a very powerful and popular framework available for Node.js. We will also use
    another library called `body-parser`, which helps us parse the incoming JSON body
    requests with ease. Lastly, we will also use `lodash` to help out with some complex
    data manipulations. To install `lodash`, `express`, and `body-parser`, run the
    following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，因为我们想要创建一个Web服务器，我们将使用`express`，这是一个非常强大和流行的Node.js框架。我们还将使用另一个名为`body-parser`的库，它可以帮助我们轻松解析传入的JSON请求体。最后，我们还将使用`lodash`来帮助处理一些复杂的数据操作。要安装`lodash`，`express`和`body-parser`，运行以下命令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have the application setup done, we will need to start the application
    server using express and include our `body-parser` middleware. So, we can now
    create a `server.js` file at the root and then add the following code to it:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了应用程序的设置，我们将需要使用express启动应用程序服务器，并包含我们的`body-parser`中间件。因此，我们现在可以在根目录下创建一个`server.js`文件，然后添加以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, the app is ready to be launched. Under the `scripts` tag of your `package.json`
    file, add the following and then run `npm start` from the terminal to bring your
    server up:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应用程序已经准备好启动了。在您的`package.json`文件的`scripts`标签下，添加以下内容，然后从终端运行`npm start`来启动服务器：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a reference generator for a job portal
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为求职门户创建一个参考生成器
- en: In this example, we will create a reference generator for a job portal. For
    instance, we have a few users who are friends with each other, we will create
    nodes for each of the users and associate each of the nodes with data, such as
    their name and the company at which they work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将为一个求职门户创建一个参考生成器。例如，我们有一些彼此为朋友的用户，我们将为每个用户创建节点，并将每个节点与数据关联，例如他们的姓名和他们工作的公司。
- en: Once we create all these nodes, we will join them based on some predefined relationships
    between the nodes. Then, we will use these predefined relationships to determine
    who a user would have to talk to to get referred for a job interview at a company
    of their choice. For example, A who works at company X and B who works at company
    Y are friends, B and C who works at company Z are friends. So, if A wants to get
    referred to company Z, then A talks to B, who can introduce them to C for a referral
    to company Z.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有这些节点，我们将根据节点之间的一些预定义关系将它们连接起来。然后，我们将使用这些预定义关系来确定一个用户需要与谁交谈，以便获得推荐去他们选择的公司的工作面试。例如，A在X公司工作，B在Y公司工作并且是朋友，B和C在Z公司工作并且是朋友。因此，如果A想要被推荐到Z公司，那么A与B交谈，B可以介绍他们给C，以获得去Z公司的推荐。
- en: In most production-level apps, you will not be creating the graphs in such a
    fashion. You can simply use a graph database, which can perform a lot of features
    out of the box.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数生产级应用程序中，您不会以这种方式创建图。您可以简单地使用图数据库，它可以直接执行许多功能。
- en: Returning to our example, in more technical terms, we have an undirected graph
    (think of users as nodes and friendship as edges between them), and we want to
    determine the shortest path from one node to another.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，更加技术性地说，我们有一个无向图（将用户视为节点，友谊视为它们之间的边），我们想要确定从一个节点到另一个节点的最短路径。
- en: To do what we have described so far, we will be using a technique known as **Breadth
    First Search**(**BFS**)*. *BFS is a graph traversal mechanism in which the neighboring
    nodes are examined or evaluated first before moving on to the next level. This
    helps to ensure that the number of links found in the resulting chain is always
    minimum, hence we always get the shortest possible path from node A to node B.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们到目前为止所描述的内容，我们将使用一种称为**广度优先搜索**（**BFS**）的技术。BFS是一种图遍历机制，首先检查或评估相邻节点，然后再移动到下一级。这有助于确保在结果链中找到的链接数量始终是最小的，因此我们总是得到从节点A到节点B的最短可能路径。
- en: Although there are other algorithms, such as **Dijkstra**, to achieve similar
    results, we will go with BFS because Dijkstra is a more complex algorithm that
    is well suited when each edge has an associated cost with it. For example, in
    our case, we would go with Dijkstraif our user's friendships have a weight associated
    with it such as *acquaintance*, *friend*, and *close friend*, which would help
    us associate weights with each of those paths.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有其他算法，比如**Dijkstra**，可以实现类似的结果，但我们将选择BFS，因为Dijkstra是一种更复杂的算法，适用于每个边都有相关成本的情况。例如，在我们的情况下，如果我们的用户友谊有与之相关的权重，比如*熟人*、*朋友*和*密友*，那么我们将选择Dijkstra，这将帮助我们为每条路径关联权重。
- en: A good use case to consider Dijkstra would be for something such as a Maps application,
    which would give you directions from point A to B based on the traffic (that is,
    the weight or cost associated with each edge) in between.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用Dijkstra的一个很好的用例是地图应用程序，它会根据两点之间的交通情况（即每条边的权重或成本）为你提供从A点到B点的方向。
- en: Creating a bidirectional graph
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个双向图
- en: 'We can start with logic for our graph by creating a new file under `utils/graph.js`,
    which will hold the edges and then provide a simple `shortestPath`method to access
    the Graph and apply the BFS algorithm on the graph that is generated, as shown
    in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`utils/graph.js`下创建一个新文件来为我们的图形创建逻辑，该文件将保存边缘，然后提供一个简单的`shortestPath`方法来访问图形，并在生成的图形上应用BFS算法，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we add the edges to our graph, it has nodes (user IDs), and edges are
    defined as the relationship between each user ID and friend in the `friends` array,
    which is available for each user. Forming the graph was an easy task, thanks to
    the way our data is structured. In our example dataset, each user has a set of
    friends list, which is listed in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将边添加到我们的图形中，它就有了节点（用户ID），边被定义为每个用户ID和`friends`数组中的朋友之间的关系。由于我们的数据结构的方式，形成图形是一项容易的任务。在我们的示例数据集中，每个用户都有一个朋友列表，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can note in the preceding code, we did not really have to establish a
    bidirectional edge exclusively here because if user `1` is a friend of user `2`
    then user `2` is also a friend of user `1.`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中所看到的，我们在这里并不需要专门建立双向边，因为如果用户`1`是用户`2`的朋友，那么用户`2`也是用户`1`的朋友。
- en: Generating a pseudocode  for the shortest path generation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成最短路径的伪代码
- en: 'Before its implementation, let''s quickly jot down what we are about to do
    so that the actual implementation becomes a lot easier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施之前，让我们快速记录一下我们将要做的事情，这样实际的实施就会变得更容易：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing the shortest path generation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现最短路径生成
- en: 'Let''s now create our customized BFS algorithm to parse the graph and generate
    the shortest possible path for our user to get referred to company A:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们定制的BFS算法来解析图并生成用户被推荐到A公司的最短路径：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The most important part of the code is when the match is found, as shown in
    the following code block from the preceding code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最重要部分是当找到匹配时，如前面代码块所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are employing a technique called backtracking, which helps us retrace
    our steps when the result is found. The idea here is that we add the current state
    of the iteration to a map whenever the result is not found—the key as the node
    being visited currently, and the value as the node from which we are visiting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一种称为回溯的技术，当找到结果时，它可以帮助我们重新追溯我们的步骤。这里的想法是，每当找不到结果时，我们将迭代的当前状态添加到一个映射中——键作为当前正在访问的节点，值作为我们正在访问的节点。
- en: 'So, for example, if we visited node 1 from node 3, then the map would contain
    { 1: 3 } until we visit node 1 from some other node, and when that happens, our
    map will update to point to the new node from which we got to node 1, such as
    { 1: newNode }. Once we set up these previous paths, we can easily trace our steps
    back by looking at this map. By adding some log statements (available only in
    the GitHub code to avoid confusion), we can easily take a look at the long but
    simple flow of the data. Let us take an example of the data set that we defined
    earlier, so when Bill tries to look for friends who can refer him to Toyota, we
    see the following log statements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们从节点3访问节点1，那么直到我们从其他节点访问节点1，地图中将包含{1:3}，当发生这种情况时，我们的地图将更新为指向我们从中得到节点1的新节点，例如{1:newNode}。一旦我们设置了这些先前的路径，我们可以通过查看这个地图轻松地追溯我们的步骤。通过添加一些日志语句（仅在GitHub代码中可用，以避免混淆），我们可以轻松地查看数据的长但简单的流程。让我们以我们之前定义的数据集为例，当Bill试图寻找可以推荐他给丰田的朋友时，我们看到以下日志语句：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we basically have here is an iterative process using BFS to traverse the
    tree and backtracking the result. This forms the core of our functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上在这里使用BFS进行迭代过程，以遍历树并回溯结果。这构成了我们功能的核心。
- en: Creating a web server
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Web服务器
- en: 'We can now add a route to access this graph and its corresponding `shortestPath`
    method.  Let''s first create the route under `routes/references` and add it as
    a middleware to the web server:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个路由来访问这个图形及其相应的`shortestPath`方法。让我们首先在`routes/references`下创建路由，并将其添加为Web服务器的中间件：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, create the route as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建如下代码所示的路由：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the reference generator
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行参考生成器
- en: To test this, simply start the web server by running the `npm start` command
    from the root of the project as shown earlier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，只需从项目的根目录运行`npm start`命令启动Web服务器，如前面所示。
- en: 'Once the server is up and running, you can use any tool you wish to post the
    request to your web server, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动运行，你可以使用任何你希望的工具将请求发送到你的Web服务器，如下面的截图所示：
- en: '![](assets/986cd6f5-bb76-4a38-87cc-86cbe6efd012.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/986cd6f5-bb76-4a38-87cc-86cbe6efd012.png)'
- en: As you can see in the preceding screenshot, we get the response back as expected.
    This can, of course, be changed in a way to return all the user objects instead
    of just the names. That could be a fun extension of the example for you to try
    on your own.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的截图中所看到的，我们得到了预期的响应。当然，这可以以一种方式进行更改，以返回所有用户对象而不仅仅是名称。这可能是一个有趣的扩展示例，你可以自己尝试一下。
- en: Creating a friend recommendation system for social media
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为社交媒体创建一个好友推荐系统
- en: You cannot simply deny the fact that social networking sites are all about the
    data. This is why a majority of the features built in these websites rely on the
    data that you provide to them. One such example of these is a *people you might
    know* or a *who to follow* component that you can find on many of the websites.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能简单地否认社交网络网站都是关于数据的事实。这就是为什么这些网站中构建的大多数功能都依赖于你提供给它们的数据。这些中的一个例子就是*你可能认识的人*或*推荐关注*组件，你可以在许多网站上找到。
- en: From the previous example, we know that the data can be grouped into `nodes`
    and `edges`, in which the nodes are the people and the edges are the relationships
    that you want to establish between the nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们知道数据可以分组为“节点”和“边”，其中节点是人，边是您想要在节点之间建立的关系。
- en: We could simply form a bidirected graph and then apply a BFS algorithm to determine
    the connected nodes at *n*th degree, which we can then de-duplicate to show the
    friend or node recommendations. However, considering that we already did this
    in the preceding example, and also that the actual list of users and friends of
    each of these users is huge in a production application, we will take a different
    approach. We will go with the assumption that our dataset is stored in a graph
    database, such as **neo4j***, *and then we will use an algorithm called **Personalized
    PageRank**, that is a BFS and PageRank combination which we will explore in the
    next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地形成一个双向图，然后应用BFS算法来确定第n度的连接节点，然后我们可以去重以显示朋友或节点推荐。然而，考虑到我们在前面的例子中已经这样做了，而且在生产应用程序中，每个用户和这些用户的朋友的实际列表都非常庞大，我们将采取不同的方法。我们将假设我们的数据集存储在图数据库中，比如**neo4j**，然后我们将使用一种称为**Personalized
    PageRank**的算法，这是一种BFS和PageRank的组合，我们将在下一节中探讨。
- en: Understanding PageRank algorithm
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解PageRank算法
- en: At some point in our lives, we must have come across this term, PageRank. PageRank
    is one of the many ways in which Google ranks the web pages for searching and
    indexing. A simple Google search (pun totally intended) will return results that
    tell you how it basically involves a collection of nodes from which we can walk
    in a random direction. However, what does that really mean?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的生活中的某个时刻，我们一定遇到过这个术语，PageRank。PageRank是Google对网页进行搜索和索引排名的众多方式之一。一个简单的谷歌搜索（完全是故意的双关语）将返回结果，告诉您它基本上涉及从中我们可以随机走向的一组节点。然而，这到底意味着什么呢？
- en: Given that the control is dropped on any node within a graph, we are saying
    that the control can jump to any node on the graph unbiased with a probability
    of `alpha`,and when it does land on any node, it shares a portion of its rank
    equally with all of its connected nodes before traversing along one of these nodes
    edges randomly with a probability of `(1 - alpha)`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设控制权被放置在图中的任何节点上，我们说控制权可以以`alpha`的概率不偏向地跳转到图上的任何节点，当它确实落在任何节点上时，它会在以`(1-alpha)`的概率随机地沿着这些节点的边之一遍历之前，与所有连接的节点平均分享其排名的一部分。
- en: How and why does this matter? It's just jumping from one node to another and
    then randomly traversing to some other connected node, right?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么意义和原因呢？这只是从一个节点跳到另一个节点，然后随机地遍历到其他连接的节点，对吧？
- en: 'If you do this for long enough, you would land on all the nodes and some of
    the nodes more times than the other. You see where I am going with this? This
    would end up telling you which nodes are more frequented compared to others, which
    could happen for the following two reasons :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您这样做足够长的时间，您会落在所有节点上，有些节点会比其他节点多次。您明白我要说什么吗？这最终会告诉您哪些节点比其他节点更频繁地访问，这可能是由于以下两个原因：
- en: We just happened to jump to the same node multiple times
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们碰巧多次跳转到同一个节点
- en: That node is connected to multiple nodes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该节点连接到多个节点
- en: The first scenario can happen, but, since we know that our jumps are unbiased
    and the Law of Large Numbers dictates that this would yield the normalized value
    when done for long enough, we can safely rule it out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况可能发生，但是，由于我们知道我们的跳跃是不偏向的，大数定律规定，这将在足够长的时间内产生归一化的值，我们可以安全地排除它。
- en: The second scenario, on the other hand, is not only possible but also very important
    to PageRank. Once you land on one of these nodes, that's when we calculate the
    PageRank for that node-based on alpha and on the rank inherited from the preceding
    node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第二种情况不仅可能，而且对PageRank非常重要。一旦您落在其中一个节点上，这时我们根据alpha和从前一个节点继承的排名来计算该节点的PageRank。
- en: 'We were talking in abstract terms of nodes and edges; however, for a brief
    time, let''s take a look at a statement made in the very first publication of
    PageRank by Sergey Brin and Lawrence Page ([http://infolab.stanford.edu/~backrub/google.html](http://infolab.stanford.edu/~backrub/google.html)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在抽象的节点和边的术语中进行了讨论；然而，让我们暂时看一下Sergey Brin和Lawrence Page在PageRank的第一篇发表文章中所说的一句话([http://infolab.stanford.edu/~backrub/google.html](http://infolab.stanford.edu/~backrub/google.html))：
- en: 'We assume page A has pages T1...Tn which point to it (i.e., are citations).
    The parameter d is a damping factor which can be set between 0 and 1\. We usually
    set d to 0.85. There are more details about d in the next section. Also, C(A)
    is defined as the number of links going out of page A. The PageRank of page A
    is given as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设页面A有指向它的页面T1...Tn（即引用）。参数d是一个阻尼因子，可以设置在0和1之间。我们通常将d设置为0.85。关于d的更多细节将在下一节中介绍。此外，C(A)被定义为从页面A指向外部的链接数。页面A的PageRank如下所示：
- en: PR(A) = (1-d) + d (PR(T1)/C(T1) + ... + PR(Tn)/C(Tn))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PR(A) = (1-d) + d (PR(T1)/C(T1) + ... + PR(Tn)/C(Tn))
- en: Note that the PageRanks form a probability distribution over web pages, so the
    sum of all web pages' PageRanks will be one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PageRanks形成了网页的概率分布，因此所有网页的PageRanks之和将为1。
- en: From the preceding statement, we can see that the PageRank *(PR*) of a given
    page/node is derived from the *PR* of its citations (*T1...Tn*), but how does
    one know where to start since we need to know its citations to calculate the PR
    for *T1*. The simple answer is that we do not need to know the value of the *PR(T1)*
    or any other citation as a matter of fact. What we can do instead is to simply
    guess a value for *PR(T1)* and recursively apply the values that are derived from
    the preceding step.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的陈述中，我们可以看到给定页面/节点的PageRank *(PR*)是从其引用(*T1...Tn*)的*PR*派生出来的，但是我们如何知道从哪里开始，因为我们需要知道它的引用来计算*T1*的PR。简单的答案是，实际上我们不需要知道*PR(T1)*的值或者事实上任何其他引用的值。相反，我们可以简单地猜测*PR(T1)*的值，并递归地应用从前一步骤派生出的值。
- en: However, why on earth would that work, you ask? The answer is simple, remember
    the Law of Large Numbers? If you repeat an action for long enough, the result
    of the said action will converge to the median value. Then, there are questions
    about how you can do it for the millions and billions of web pages and be effective?
    There are ways and means, which are beyond the scope of this chapter and book;
    however, for those interested, this book that explains Google's Page Rank is a
    great read, available at [https://press.princeton.edu/titles/8216.html](https://press.princeton.edu/titles/8216.html).
    I hope that this book sheds some light on the basic principle involved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你为什么会这样问呢？答案很简单，记得大数定律吗？如果你重复一个动作足够长的时间，该动作的结果将收敛到中位数值。然后，还有关于如何在数百万和数十亿的网页上进行有效操作的问题？有方法和手段，这超出了本章和本书的范围；然而，对于那些感兴趣的人，这本解释Google
    Page Rank的书是一本很好的读物，可在[https://press.princeton.edu/titles/8216.html](https://press.princeton.edu/titles/8216.html)上获得。我希望这本书能为基本原则提供一些启发。
- en: Understanding Personalized PageRank (PPR) Algorithm
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解个性化PageRank（PPR）算法
- en: Now that we have a brief understanding of PageRank, what is Personalized PageRank?
    It's quite simple actually, instead of jumping to a random node every time, we
    jump to a predefined node and then recursively accumulate the probability of hitting
    each node while traversing using BFS.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对PageRank有了简要的了解，那么个性化PageRank是什么？实际上很简单，每次不是跳转到随机节点，而是跳转到预定义的节点，然后递归地累积每个节点的命中概率，使用BFS进行遍历。
- en: 'Let''s assume that we have a few friends who are structured as shown in the
    following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些朋友，他们的结构如下图所示：
- en: '![](assets/1ae23c87-a88e-4087-8b5b-0b8f5f37b003.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ae23c87-a88e-4087-8b5b-0b8f5f37b003.png)'
- en: This is straightforward; we have bidirectional edges between the nodes, indicating
    a friendship between them. In this problem, we can assume that we want to suggest
    new friends to User **A**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；节点之间有双向边，表示它们之间有友谊关系。在这个问题中，我们可以假设我们想向用户**A**推荐新的朋友。
- en: The simplest part is also the important thing that we need to talk about before
    moving onto the code for PPR. We will always be starting out from our target node,
    that is, the jumps are no longer started at random. We start at our target node,
    assume that the control traverses all edges equally, and then come back to the
    parent. Then, we recursively repeat this process while expanding the degree by
    one edge at a time until we meet our target degree.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的部分也是我们在转到PPR的代码之前需要讨论的重要事情。我们将始终从我们的目标节点开始，也就是说，跳转不再是随机开始的。我们从我们的目标节点开始，假设控制以相等的方式遍历所有边，然后回到父节点。然后，我们递归地重复这个过程，同时通过一条边扩展度，直到满足目标度。
- en: Also, every time we increase our search by one degree from the target node,
    we are sharing the probability of the node with the neighbors, but if we share
    all of it, the node becomes 0 so what we would do instead is to apply a damping
    factor (alpha).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每次我们从目标节点增加一度搜索时，我们都会与邻居分享节点的概率，但如果我们全部分享，节点就会变为0，所以我们要做的是应用一个阻尼因子（alpha）。
- en: For example, assume that we are at the node *X*, which has a probability of
    1 (that is, it is the target node), and that this node *X* has two neighbors, *Y*,
    and *Z*. The alpha that we set (for example, 0.5) will be applied here, so after
    the first iteration, *X* would have the probability as 0.5, and then *Y* and *Z*
    would have an equal probability of 0.25\. Then, the process would be repeated
    recursively to the next degree with this new map of probabilities that we have
    just created.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在节点*X*，它的概率为1（即，它是目标节点），并且这个节点*X*有两个邻居*Y*和*Z*。我们设置的alpha（例如，0.5）将在这里应用，因此在第一次迭代之后，*X*的概率将为0.5，然后*Y*和*Z*将有相等的概率0.25。然后，这个过程将递归地重复到下一个度，使用我们刚刚创建的新概率映射。
- en: Pseudocode for personalized PageRank
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个性化PageRank的伪代码
- en: 'Let''s convert what we discussed in the earlier section into the pseudocode
    for an easier implementation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前部分讨论的内容转换为伪代码，以便更容易实现：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that was not scary, was it? Implementing the PPR algorithm now is going
    to be easy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这并不可怕，是吗？现在实现PPR算法将会很容易。
- en: Creating a web server
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Web服务器
- en: Before we write any code for our Personalized PageRank, let's first create a
    Node.js application, as explained earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为个性化PageRank编写任何代码之前，让我们首先创建一个Node.js应用程序，就像之前解释的那样。
- en: 'Once the application is ready, let''s create a route that will be serving us
    our user suggestions. Similar to the example from the preceding example, we can
    quickly piece together the following route under `routes/suggestions.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序准备就绪，让我们创建一个路由，用于为我们提供用户建议。类似于之前的示例，我们可以快速拼凑出以下路由，放在`routes/suggestions.js`下：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also quickly piece together our express server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以快速拼凑出我们的express服务器：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementing Personalized PageRank
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现个性化PageRank
- en: 'Now, let''s move over to creating our **Personalized PageRank** (**PPR**) algorithm.
    We will be creating an `ES6` class, which will handle all of the logic to generate
    the suggestions once we provide the graph and target node to it. Note that in
    the preceding code, I have already shown you what the graph looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到创建我们的**个性化PageRank**（**PPR**）算法。我们将创建一个`ES6`类，它将处理提供图形和目标节点后生成建议的所有逻辑。请注意，在上面的代码中，我已经向您展示了图形的样子：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have established a bidirectional relationship by specifying two nodes as
    each other''s neighbors.  Now, we can start with the code for PPR:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定两个节点为彼此的邻居建立了双向关系。现在，我们可以开始编写PPR的代码：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will first accept the graph as the input to our `constructor`. Next, we
    will define our `getSuggestions` method, which will accept the input `nodeId`
    and then pass it to calculate the PPR. This is also the first step of our preceding
    pseudo code, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将图形作为输入接受到我们的`constructor`中。接下来，我们将定义我们的`getSuggestions`方法，它将接受输入的`nodeId`，然后将其传递给计算PPR。这也是我们之前伪代码的第一步，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since our control is defined to start from a fixed node, we are setting it the
    probability of `1`. We will be iterating three times simply because we want to
    go only three levels out to get the suggestions. Level 1 is the target node, level
    2 is the neighbors of the target node (that is, current friends) and then level
    3 is the neighbors of neighbors (that is, friends of friends).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的控制被定义为从一个固定节点开始，我们将其概率设置为`1`。我们将进行三次迭代，只是因为我们只想走出三个级别来获取建议。第1级是目标节点，第2级是目标节点的邻居（即当前的朋友），然后第3级是邻居的邻居（即朋友的朋友）。
- en: 'Now, we get to the fun part. We will recursively calculate the probability
    of us jumping on to each of the neighboring nodes, starting from the target node:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了有趣的部分。我们将递归地计算我们跳到每个相邻节点的概率，从目标节点开始：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That was not half as bad as you thought, right? Once we have the PPR algorithm
    ready to go, we can now import this class into our `suggestions` route and can
    use it to generate the recommendations for any input user, as shown in the following
    code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像你想象的那样糟糕，对吧？一旦我们准备好PPR算法，我们现在可以将这个类导入到我们的`suggestions`路由中，并可以用它来为任何输入用户生成推荐，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Results and analysis
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果和分析
- en: 'Now, to test this, let''s start off our web server by running the `npm start`
    command from the root folder. Once your application starts, you will see the following
    message on your terminal:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这个，让我们通过从根文件夹运行`npm start`命令来启动我们的Web服务器。一旦您的应用程序启动，您将在终端上看到以下消息：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the message appears, you can either open Postman or anything else of your
    choice to make the API calls for suggestions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息出现，您可以打开Postman或您选择的其他任何东西来进行API调用以获取建议：
- en: '![](assets/3a99d1de-2e5a-4c3e-bbfd-86262553501b.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3a99d1de-2e5a-4c3e-bbfd-86262553501b.png)'
- en: We can see that user `C` has received more score than user `E`. This is because
    we can see from the input dataset that the users `A` and `C` have more common
    friends than user `A` and `E`. This is why, as per our deduction earlier, the
    chances of our control landing on node `C` are higher than that of node `E`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户`C`比用户`E`得分更高。这是因为我们可以从输入数据集中看到用户`A`和`C`比用户`A`和`E`有更多的共同朋友。这就是为什么，根据我们之前的推断，我们的控制落在节点`C`上的机会比节点`E`上的机会更高。
- en: 'Also, the interesting thing to note is that the actual value of the score is
    immaterial here. You only need to look at the comparison of the scores to determine
    which one is more likely to happen. You can change alpha as you wish to decide
    how much probability each node is going to split between its neighbors, and that
    would ultimately change the score of each of the resultant nodes, for example,
    the results which shows the name and the score as we saw preceding are with the
    alpha value of 0.5; we will now change it to `0.33`, that is, the parent node
    keeps one-third and splits the rest with the neighbors:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，需要注意的有趣的事情是，这里实际分数的值并不重要。您只需要看分数的比较来确定哪一个更有可能发生。您可以根据需要更改alpha来决定每个节点之间将分配多少概率，这最终会改变每个结果节点的分数，例如，我们将alpha值更改为0.5的结果，显示了名称和分数，我们将现在将其更改为`0.33`，即父节点保留三分之一，其余与邻居分配：
- en: '![](assets/0c1ffd35-abd0-4486-b64c-ca37e5574010.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c1ffd35-abd0-4486-b64c-ca37e5574010.png)'
- en: 'Few log statements are added before each recursive call for some additional
    clarity:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个递归调用之前添加了一些日志语句，以便更清晰地理解：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding log statements yield the following results:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的日志语句产生了以下结果：
- en: '![](assets/09b6cd98-6333-4725-b931-03af662e5509.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09b6cd98-6333-4725-b931-03af662e5509.png)'
- en: From the preceding screenshot, you can note that at the end of the first iteration,
    the total probability of 1, which we assigned to target node `A`, has been split
    into three parts after our logic determined by BFS traversal that neighbors of
    node `A` are nodes `B` and `D`. Now, this became the input of iteration 2, where
    we repeated the process until the last iteration, at the end of which we remove
    the current target node `A` and its immediate neighbor nodes `B` and `D` (since
    they are already friends) and return the remaining, that is, nodes `C` and `E`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，您可以注意到在第一次迭代结束时，我们分配给目标节点`A`的总概率为1，在我们的逻辑确定的BFS遍历后，被分成了三部分，即节点`A`的邻居`B`和`D`。现在，这成为了第2次迭代的输入，我们重复这个过程，直到最后一次迭代结束，在最后一次迭代结束时，我们移除了当前目标节点`A`及其直接邻居节点`B`和`D`（因为它们已经是朋友），并返回剩下的节点`C`和`E`。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took some real-world challenges head-on and created some
    custom solutions based on the problem at hand. This is one of the most important
    takeaways from this chapter. Rarely would you find a scenario where an ideal solution
    is readily available. We took up one of the graph theories algorithms, known as
    BFS, and leveraged it to our advantage in generating the recommendations for our
    job portal and user suggestions. We also briefly discussed PageRank algorithm,
    which any developer should be familiar with. That brings the question of why and
    when to use one algorithm over the other. What are the pros and cons of choosing
    an algorithm? This will be the topic for our next chapter, where we will do an
    analysis of the different types of algorithms and where we can apply them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们直面了一些现实世界的挑战，并根据手头的问题创建了一些定制解决方案。这是本章最重要的收获之一。很少会有一个理想的解决方案是readily available。我们采用了图论算法之一，称为BFS，并利用它来为我们的职位门户和用户建议生成推荐。我们还简要讨论了PageRank算法，任何开发人员都应该熟悉。这引出了为什么以及何时使用一种算法而不是另一种算法的问题。选择算法的利弊是什么？这将是我们下一章的主题，我们将分析不同类型的算法以及它们可以应用的地方。
