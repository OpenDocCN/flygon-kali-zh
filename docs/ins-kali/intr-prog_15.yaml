- en: Managing Collections and Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理集合和数组
- en: The classes that we will be discussing in this chapter allow us to create, initialize,
    and modify objects of Java collections and arrays. They also allow the creation
    of unmodifiable and immutable collections. Some of these classes belong to Java
    standard libraries, others to popular Apache Commons libraries. Knowledge of these
    classes and familiarity with their methods are essential for any Java programmer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论的类允许我们创建、初始化和修改Java集合和数组的对象。它们还允许创建不可修改和不可变集合。这些类中的一些属于Java标准库，其他属于流行的Apache
    Commons库。了解这些类并熟悉它们的方法对于任何Java程序员都是必不可少的。
- en: 'We will cover the following areas of functionality:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下功能领域：
- en: Managing collections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理集合
- en: Managing arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数组
- en: 'The list of the overviewed classes includes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 概述的类列表包括：
- en: '`java.util.Collections`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Collections`'
- en: '`org.apache.commons.collections4.CollectionUtils`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.commons.collections4.CollectionUtils`'
- en: '`java.util.Arrays`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`'
- en: '`org.apache.commons.lang3.ArrayUtils`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.apache.commons.lang3.ArrayUtils`'
- en: Managing collections
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理集合
- en: In this section, we will review how collection objects can be created and initialized,
    what immutable collections are, and how to perform basic operations over collections—copy,
    sort, and shuffle, for example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何创建和初始化集合对象，什么是不可变集合，以及如何对集合执行基本操作——复制、排序和洗牌，例如。
- en: Initializing collections
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化集合
- en: We have already seen a few examples of collection constructors without parameters.
    Now, we are going to see other ways to create and initialize collection objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些不带参数的集合构造函数的示例。现在，我们将看到创建和初始化集合对象的其他方法。
- en: Collection constructor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合构造函数
- en: 'Each of the collection classes has a constructor that accepts a collection
    of elements of the same type. For example, here is how an object of class `ArrayList` can
    be created using the `ArrayList(Collection collection)` constructor and how an
    object of class `HashSet` can be created using the `HashSet<Collection collection)` constructor:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合类都有一个接受相同类型元素集合的构造函数。例如，这是如何使用`ArrayList(Collection collection)`构造函数创建`ArrayList`类的对象，以及如何使用`HashSet(Collection
    collection)`构造函数创建`HashSet`类的对象：
- en: '```java'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = new ArrayList<>();
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = new ArrayList<>();
- en: list1.add("s1");
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s1");
- en: list1.add("s1");
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s1");
- en: List<String> list2 = new ArrayList<>(list1);
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = new ArrayList<>(list1);
- en: 'System.out.println(list2);      //prints: [s1, s1]'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list2);      //输出：[s1, s1]
- en: Set<String> set = new HashSet<>(list1);
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>(list1);
- en: 'System.out.println(set);        //prints: [s1]'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);        //输出：[s1]
- en: List<String> list3 = new ArrayList<>(set);
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list3 = new ArrayList<>(set);
- en: 'System.out.println(list3);      //prints: [s1]'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list3);      //输出：[s1]
- en: '```'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will show more examples of using such constructors in the *Using other objects
    and streams* subsection later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*使用其他对象和流*子部分中展示更多使用这些构造函数的示例。
- en: Instance initializer (double brace)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例初始化程序（双括号）
- en: 'It is possible to use a double brace initializer for the collection initialization.
    It fits especially well when the collection is the value of an instance field,
    so it is initialized automatically during object creation. Here is an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用双括号初始化器进行集合初始化。当集合是实例字段的值时，它特别适用，因此在对象创建期间会自动初始化。这是一个例子：
- en: '```java'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ManageCollections {
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: public class ManageCollections {
- en: private List<String> list = new ArrayList<>() {
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: private List<String> list = new ArrayList<>() {
- en: '{'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: add(null);
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: add(null);
- en: add("s2");
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: add("s2");
- en: add("s3");
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: add("s3");
- en: '}'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: public List<String> getThatList(){
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: public List<String> getThatList(){
- en: return this.list;
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: return this.list;
- en: '}'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void main(String... args){
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args){
- en: ManageCollections mc = new ManageCollections();
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ManageCollections mc = new ManageCollections();
- en: 'System.out.println(mc.getThatList());    //prints: [null, s2, s3]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(mc.getThatList());    //输出：[null, s2, s3]
- en: '}'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have added a getter and use it when the `main()` method runs. Unfortunately,
    the double brace initializer does not save any time typing compared with the traditional
    collection initialization in a constructor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个getter，并在`main()`方法运行时使用它。不幸的是，双括号初始化器与构造函数中的传统集合初始化相比并没有节省任何输入时间：
- en: '```java'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class ManageCollections {
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: public class ManageCollections {
- en: private List<String> list = new ArrayList<>();
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: private List<String> list = new ArrayList<>();
- en: public ManageCollections(){
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: public ManageCollections(){
- en: list.add(null);
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.add("s2");
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s3");
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s3");
- en: '}'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public List<String> getThatList(){
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: public List<String> getThatList(){
- en: return this.list;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: return this.list;
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void main(String... args){
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args){
- en: ManageCollections mc = new ManageCollections();
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ManageCollections mc = new ManageCollections();
- en: 'System.out.println(mc.getThatList());    //prints: [null, s2, s3]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(mc.getThatList());    //输出：[null, s2, s3]
- en: '}'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The only difference is that you need to type the `list` variable for each call
    of `add()` method. Besides, the double brace initializer has an overhead of creating
    an anonymous class with just an instance initializer and references to the enclosing
    class. It also has potentially more problems, so should be avoided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是每次调用`add()`方法时都需要为`list`变量输入。此外，双括号初始化器有一个额外的开销，它创建了一个只有实例初始化程序和对封闭类的引用的匿名类。它也可能有更多的问题，因此应该避免使用。
- en: 'The good news is that there is a much shorter and more convenient way to initialize
    a collection as the field value or as a local variable value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，有一种更短、更方便的初始化集合的方法，作为字段值或局部变量值：
- en: '```java'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private List<String> list = Arrays.asList(null, "s2", "s3");
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: private List<String> list = Arrays.asList(null, "s2", "s3");
- en: '```'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The static method `asList()` of the `java.util.Arrays` class is very popular
    (we will talk about the `Arrays` class in more detail shortly). The only potential
    drawback is that such a list does not allow the addition of elements:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`的`asList()`静态方法非常受欢迎（我们将很快更详细地讨论`Arrays`类）。唯一的潜在缺点是这样的列表不允许添加元素：'
- en: '```java'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = Arrays.asList(null, "s2", "s3");
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = Arrays.asList(null, "s2", "s3");
- en: list.add("s4");    // throws UnsupportedOperationException
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s4");    //抛出UnsupportedOperationException
- en: '```'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, we can always create a new collection by passing the initialized list
    into a constructor:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们总是可以通过将初始化的列表传递给构造函数来创建一个新的集合：
- en: '```java'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList(Arrays.asList(null, "s2", "s3"));
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList(Arrays.asList(null, "s2", "s3"));
- en: list.add("s4");   //works just fine
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s4");   //完全正常
- en: Set<String> set = new HashSet<>(Arrays.asList(null, "s2", "s3"));
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>(Arrays.asList(null, "s2", "s3"));
- en: set.add("s4");   //works just fine as well
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s4");   //同样可以正常工作
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice that the constructors of collection classes accept any object that implements
    the `Collection` interface. It allows lists to be created from sets, and vice
    versa. But, the `Map` interface does not extend `Collection`, so `Map` implementations
    only allow a map to be created from another map:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，集合类的构造函数接受实现`Collection`接口的任何对象。它允许从集合创建列表，反之亦然。但是，`Map`接口不扩展`Collection`，因此`Map`实现只允许从另一个映射创建映射：
- en: '```java'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: Map<Integer, String> anotherMap = new HashMap<>(map);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> anotherMap = new HashMap<>(map);
- en: '```'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The types of keys and values of the new map have to be either the same as in
    the provided map or have to be parents of the types of the provided map:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 新映射的键和值的类型必须与提供的映射中的类型相同，或者必须是提供的映射类型的父类型：
- en: '```java'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A{}
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: class A{}
- en: class B extends A{}
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A{}
- en: Map<Integer, B> mb = new HashMap<>();
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, B> mb = new HashMap<>();
- en: Map<Integer, A> ma = new HashMap<>(mb);
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, A> ma = new HashMap<>(mb);
- en: '```'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'For example, this is an acceptable assignment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个可以接受的赋值：
- en: '```java'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map1 = new HashMap<>();
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map1 = new HashMap<>();
- en: Map<Integer, Object> map2 = new HashMap<>(map1);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, Object> map2 = new HashMap<>(map1);
- en: '```'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is because the `HashMap` constructor limits the types just to the children
    of the map elements:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`HashMap`构造函数将类型限制在映射元素的子类型之间：
- en: '```java'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: HashMap(Map<? extends K,? extends V> map)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: HashMap(Map<? extends K,? extends V> map)
- en: '```'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There''s a similar problem with the following code too:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有以下代码也有类似的问题：
- en: '```java'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A {}
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: class A {}
- en: class B extends A {}
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A {}
- en: List<A> l1 = Arrays.asList(new B());
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> l1 = Arrays.asList(new B());
- en: List<B> l2 = Arrays.asList(new B());
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: List<B> l2 = Arrays.asList(new B());
- en: //List<B> l3 = Arrays.asList(new A()); //compiler error
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: //List<B> l3 = Arrays.asList(new A()); //编译错误
- en: '```'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code makes sense, doesn''t it? `class B` has (inherits) all the
    non-private methods and fields of `class A`, but can have other non-private methods
    and fields that are not available in `class A`. Even if both classes are empty
    today, as in our example, tomorrow we may decide to add some methods to `class
    B`. So, the compiler protects us from such a case and does not allow a collection
    with elements of a parent type to be assigned to the collection of children. And
    that is the meaning of the generics in the following constructor definitions,
    as you see them in the Java Standard Library API''s `java.util` package:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是有意义的，不是吗？`class B`有（继承）`class A`的所有非私有方法和字段，但可以有其他非私有方法和字段，这些方法和字段在`class
    A`中不可用。即使今天两个类都是空的，就像我们的例子一样，明天我们可能决定向`class B`中添加一些方法。因此，编译器保护我们免受这种情况的影响，并且不允许将具有父类型元素的集合分配给子类型的集合。这就是泛型在以下构造函数定义中的含义，正如您在Java标准库API的`java.util`包中看到的那样：
- en: '`ArrayList(Collection<? extends E> collection)`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList(Collection<? extends E> collection)`'
- en: '`HashSet(Collection<? extends E> collection)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet(Collection<? extends E> collection)`'
- en: '`HashMap(Map<? extends K,? extends V> map)`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap(Map<? extends K,? extends V> map)`'
- en: We hope that by now, you have become more comfortable with such generics. If
    in doubt, read the sections about generics in the previous chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望到目前为止，您对这样的泛型更加熟悉。如果有疑问，请阅读上一章关于泛型的部分。
- en: Static initialization block
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态初始化块
- en: 'There is a similar solution for static field initialization. The static block
    can include the code necessary to generate values that have to be used for static
    field initialization:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段初始化也有类似的解决方案。静态块可以包含必要的代码，用于生成必须用于静态字段初始化的值：
- en: '```java'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass{
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass{
- en: public String getThatString(){
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: public String getThatString(){
- en: return "that string";
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: return "that string";
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class ManageCollections {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: public class ManageCollections {
- en: private static Set<String> set = new HashSet<>();
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: private static Set<String> set = new HashSet<>();
- en: static {
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: static {
- en: SomeClass someClass = new SomeClass();
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass someClass = new SomeClass();
- en: set.add(someClass.getThatString());
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(someClass.getThatString());
- en: set.add("another string");
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("another string");
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void main(String... args){
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args){
- en: 'System.out.println(set); //prints: [that string, another string]'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set); //输出：[that string, another string]
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Since `set` is a static field, it cannot be initialized in a constructor because
    a constructor is called only when an instance is created, while a static field
    can be accessed without creating an instance. We also could rewrite the preceding
    code as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`set`是一个静态字段，它不能在构造函数中初始化，因为构造函数只有在创建实例时才会被调用，而静态字段可以在不创建实例的情况下被访问。我们也可以将前面的代码重写如下：
- en: '```java'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private static Set<String> set =
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: private static Set<String> set =
- en: new HashSet<>(Arrays.asList(new SomeClass().getThatString(),
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: new HashSet<>(Arrays.asList(new SomeClass().getThatString(),
- en: '"another string"));'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"another string"));'
- en: '```'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But, you can argue that it looks somewhat awkward and difficult to read. So,
    the static initialization block might be a better choice if it allows more readable
    code to be written.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以说它看起来有些笨拙和难以阅读。因此，如果它允许编写更易读的代码，静态初始化块可能是更好的选择。
- en: Factory methods of()
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of()的工厂方法
- en: 'Since Java 9, yet another option for creating and initializing a collection
    is available in each of the interfaces, including `Map`—the `of()` factory methods.
    They are called *factory* because they produce objects. There are eleven such
    methods, which accept from 0 to 10 parameters, each parameter being an element
    that has to be added to the collection, for example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 9以来，每个接口中都有另一种创建和初始化集合的选项，包括`Map`——`of()`工厂方法。它们被称为*工厂*，因为它们生成对象。有11种这样的方法，它们接受0到10个参数，每个参数都是要添加到集合中的元素，例如：
- en: '```java'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> iList0 = List.of();
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> iList0 = List.of();
- en: List<String> iList1 = List.of("s1");
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> iList1 = List.of("s1");
- en: List<String> iList2 = List.of("s1", "s2");
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> iList2 = List.of("s1", "s2");
- en: List<String> iList3 = List.of("s1", "s2", "s3");
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: iList3列表=List.of("s1", "s2", "s3");
- en: Set<String> iSet1 = Set.of("s1", "s2", "s3", "s4");
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> iSet1 = Set.of("s1", "s2", "s3", "s4");
- en: Set<String> iSet2 = Set.of("s1", "s2", "s3", "s4", "s5");
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> iSet2 = Set.of("s1", "s2", "s3", "s4", "s5");
- en: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
- en: '"s7", "s8", "s9", "s10");'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '"s7", "s8", "s9", "s10");'
- en: Map<Integer, String> iMap = Map.of(1, "s1", 2, "s2", 3, "s3", 4, "s4");
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> iMap = Map.of(1, "s1", 2, "s2", 3, "s3", 4, "s4");
- en: '```'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Please note how the map is constructed: from a pair of values up to 10 such
    pairs.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意地图是如何构建的：从一对值到10对这样的值。
- en: We have decided to start the identificators for the above variables with "`i`"
    to indicate that these collections are immutable. We will talk about this in the
    next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定从上面的变量开始使用"`i`"作为标识符，以表明这些集合是不可变的。我们将在下一节中讨论这一点。
- en: 'Another feature of these factory methods is that they do not allow `null` as
    an element value. If added, `null` element will cause an error (`NullPointerException`)
    at runtime. The reason `null` is not allowed is because it had to be banned from
    most collections a long time ago. This issue is especially important for `Set` because
    a set provides keys to `Map` while the `null` key does not make much sense, does
    it? Look at the following code, for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工厂方法的另一个特点是它们不允许`null`作为元素值。如果添加，`null`元素将导致运行时错误（`NullPointerException`）。之所以不允许`null`是因为很久以前就不得不禁止它出现在大多数集合中。这个问题对`Set`尤为重要，因为集合为`Map`提供键，而`null`键没有太多意义，对吧？例如，看下面的代码：
- en: '```java'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(null, "s1");
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(null, "s1");
- en: map.put(2, "s2");
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: 'System.out.println(map.get(null));     //prints: s1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.get(null)); //输出：s1
- en: '```'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You may also recall that the `put()` method of the `Map` interface returns `null`
    if there was no value associated with the key provided, or if the old value was
    `null`. This ambiguity is annoying, isn't it?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得`Map`接口的`put()`方法，如果提供的键没有关联的值，或者旧值为`null`，则返回`null`。这种模棱两可很烦人，不是吗？
- en: That's why the authors of Java 9 decided to start squeezing out `null` from
    the collections. There will probably always be special implementations of collections
    that allow `null`, but the most often used collections will eventually not allow
    `null`, and the factory methods we are describing now are the first step in that
    direction.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Java 9的作者决定开始从集合中排除`null`。可能总会有允许`null`的特殊集合实现，但是最常用的集合最终将不允许`null`，我们现在描述的工厂方法是朝着这个方向迈出的第一步。
- en: 'Another long-awaited feature added along with these factory methods is randomization
    of the order of the set elements. It means that the order is different every time
    the same set creation is executed. For example, if we run these lines:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工厂方法添加的另一个期待已久的特性是集合元素顺序的随机化。这意味着每次执行相同的集合创建时顺序都不同。例如，如果我们运行这些行：
- en: '```java'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> iSet3 = Set.of("s1", "s2", "s3", "s4", "s5", "s6",
- en: '"s7", "s8", "s9", "s10");'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '"s7", "s8", "s9", "s10");'
- en: System.out.println(iSet3);
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(iSet3);
- en: '```'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The output may be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能如下：
- en: '![](img/7fad692b-4ec9-4098-af18-134dcffba2ce.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fad692b-4ec9-4098-af18-134dcffba2ce.png)'
- en: 'But, if we run the same two lines again, the output will be different:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们再次运行相同的两行，输出将不同：
- en: '![](img/2824cd6d-1f51-407f-8ae6-7739de2b3619.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2824cd6d-1f51-407f-8ae6-7739de2b3619.png)'
- en: And every execution of set creation results in a different order of its elements.
    This is the randomization in action. It helps to uncover early the incorrect programmer's
    reliance on a certain element's order in places where order is not guaranteed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行集合创建都会导致元素的不同顺序。这就是随机化的作用。它有助于及早发现程序员对顺序的某种依赖在不保证顺序的地方。
- en: Using other objects and streams
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他对象和流
- en: 'In the *Constructor* subsection, we demonstrated how the `List<T> Arrays.asList(T...a)` method can
    be used to generate a list of values, which can then be passed in a constructor
    of any class that implements the `Collection` interface (or any interface that
    extends the `Collection`, such as `List` and `Set`, for example). As a reminder,
    we would like to mention that the `(T...a)` notation is called varargs and means
    that the parameter can be passed in any of the following two ways:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在*构造函数*子部分中，我们演示了`List<T> Arrays.asList(T...a)`方法如何用于生成值列表，然后可以将其传递给实现`Collection`接口的任何类的构造函数（或者扩展`Collection`的任何接口，例如`List`和`Set`）。作为提醒，我们想提一下`(T...a)`表示法称为可变参数，意味着可以以以下两种方式之一传递参数：
- en: As an unlimited comma-separated sequence of values of type T
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为T类型的无限逗号分隔值序列
- en: As an array of type T of any size
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为任何大小的T类型数组
- en: 'So, both the following statements create equal lists:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两个语句都创建了相等的列表：
- en: '```java'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> x1 = Arrays.asList(null, "s2", "s3");
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> x1 = Arrays.asList(null, "s2", "s3");
- en: String[] array = {null, "s2", "s3"};
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: String[] array = {null, "s2", "s3"};
- en: List<String> x2 = Arrays.asList(array);
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> x2 = Arrays.asList(array);
- en: 'System.out.println(x1.equals(x2));       //prints: true'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x1.equals(x2)); //输出：true
- en: '```'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Another way to create a collection was added with Java 8, which introduced
    streams. Here is one possible example of a list and set objects generation (we
    will talk about streams more in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8增加了另一种创建集合的方法，引入了流。这是一个可能的列表和集合对象生成的例子（我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中更多地讨论流和管道）：
- en: '```java'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list2 = Stream.of(null, "s2", "s3")
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = Stream.of(null, "s2", "s3")
- en: .collect(Collectors.toList());
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: 'System.out.println(list2);               //prints: [null, s2, s3]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list2);               //prints: [null, s2, s3]'
- en: Set<String> set2 = Stream.of(null, "s2", "s3")
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set2 = Stream.of(null, "s2", "s3")
- en: .collect(Collectors.toSet());
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toSet());
- en: 'System.out.println(set2);               //prints: [null, s2, s3]'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set2);               //prints: [null, s2, s3]'
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If you read the documentation about the `Collectors.toList()` or `Collectors.toSet()`
    methods, you will find it says that "<q>there are no guarantees on the type, mutability,
    serializability, or thread-safety of the List returned; if more control over the
    returned List is required, use toCollection(Supplier).</q>" They refer to the
    `toCollection(Supplier<C> collectionFactory)` method of the `Collectors` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读关于`Collectors.toList()`或`Collectors.toSet()`方法的文档，你会发现它说“返回的列表的类型、可变性、可序列化性或线程安全性没有保证；如果需要对返回的列表有更多的控制，使用toCollection(Supplier)。”它们指的是`Collectors`类的`toCollection(Supplier<C>
    collectionFactory)`方法。
- en: The `Supplier<C>` notation describes a function that takes no parameters and
    produces a value of type `C`, hence the name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier<C>`表示一个不带参数并产生类型为`C`的值的函数，因此得名。'
- en: 'In many cases (if not most), we do not care which class (implementation of
    `List` or `Set`) is returned. That is exactly the beauty of coding to an interface.
    But if we do, here is an example of how to use the `toCollection()` method which,
    according to the previous recommendation, is a better option than `toList()` or
    `toSet()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下（如果不是大多数情况），我们不关心返回的是哪个类（`List`或`Set`的实现）。这正是面向接口编程的美妙之处。但如果我们关心，这里是如何使用`toCollection()`方法的一个例子，根据之前的建议，这是比`toList()`或`toSet()`更好的选择：
- en: '```java'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list3 = Stream.of(null, "s2", "s3")
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list3 = Stream.of(null, "s2", "s3")
- en: .collect(Collectors.toCollection(ArrayList::new));
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toCollection(ArrayList::new));
- en: 'System.out.println(list3);               //prints: [null, s2, s3]'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list3);               //prints: [null, s2, s3]'
- en: Set<String> set3 = Stream.of(null, "s2", "s3")
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set3 = Stream.of(null, "s2", "s3")
- en: .collect(Collectors.toCollection(HashSet::new));
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toCollection(HashSet::new));
- en: 'System.out.println(set3);               //prints: [null, s2, s3]'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set3);               //prints: [null, s2, s3]'
- en: '```'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If it looks strange to you that we create a collection, then stream it and reproduce
    the same collection again, but bear in mind that in real-life programming, you
    might be getting the `Stream` object only, while we create a stream in order for
    the example to work and also to show you which values to expect.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得我们创建一个集合，然后流它，再次生成相同的集合看起来很奇怪，但请记住，在实际编程中，你可能只会得到`Stream`对象，而我们创建一个流是为了让示例工作，并向你展示期望得到的值。
- en: 'In the case of `Map`, the following code is also mentioned in the documentation
    as having "<q>no guarantees on the type</q>":'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Map`的情况下，文档中还提到了以下代码，没有关于类型的保证：
- en: '```java'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> m = new HashMap<>();
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> m = new HashMap<>();
- en: m.put(1, null);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: m.put(1, null);
- en: m.put(2, "s2");
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: m.put(2, "s2");
- en: Map<Integer, String> map2 = m.entrySet().stream()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map2 = m.entrySet().stream()
- en: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
- en: .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
- en: 'System.out.println(map2);    //prints: {1=, 2=s2}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(map2);    //prints: {1=, 2=s2}'
- en: '```'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Please note how we are handling `null` by replacing it with an empty `String`
    literal, "", so as to avoid the dreaded `NullPointerException`. And here is the
    code that, similar to the `toCollection()` method previously, produces a map with
    the implementation of our choice, the `HashMap` class in this case:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何处理`null`，通过用空的`String`文字""替换它，以避免可怕的`NullPointerException`。这里是类似于之前的`toCollection()`方法的代码，使用我们选择的实现，这里是`HashMap`类：
- en: '```java'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map3 = m.entrySet().stream()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map3 = m.entrySet().stream()
- en: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '.map(e -> e.getValue() == null ? Map.entry(e.getKey(), "") : e)'
- en: .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue(),
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue(),
- en: (k,v) -> v, HashMap::new));
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (k,v) -> v, HashMap::new));
- en: 'System.out.println(map3);    //prints: {1=, 2=s2}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(map3);    //prints: {1=, 2=s2}'
- en: '```'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If the examples provided look too complex to you, you are correct; they are
    complex even for experienced programmers. And there are two reasons for that:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的示例对你来说看起来太复杂，你是对的；即使对有经验的程序员来说，它们也很复杂。原因有两个：
- en: Functional programming is a different way of writing code than the one used
    in Java for the first twenty years of its existence
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程是一种与Java存在的头二十年中使用的编码方式不同的编码方式
- en: It was introduced in Java only recently and there are not many utility methods
    built around it to make the code look simpler
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是最近才在Java中引入的，没有太多围绕它构建的实用方法，使代码看起来更简单
- en: The good news is that after some time, you will get used to it, and streams
    and functional programming will start looking simple to you. There is even a good
    chance you will prefer it over the traditional object-oriented code because using
    functions and streams makes the code more compact and yet more powerful and cleaner,
    especially when a lot of data (big data) has to be processed efficiently, which
    seems to be the current trend, stretching far into the future.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，过一段时间，你会习惯它，流和函数式编程会开始变得简单。甚至有很大的机会你会更喜欢它，因为使用函数和流使代码更紧凑，更强大，更清晰，特别是在需要高效处理大量数据（大数据）的情况下，这似乎是当前的趋势，延伸到未来。
- en: We will talk more about this in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming;* in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*; and in [Chapter 19](aa01584a-ae53-454d-b59b-395d484b4c94.xhtml),
    *Reactive Systems*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)、*Lambda表达式和函数式编程*；[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)、*流和管道*；以及[第19章](aa01584a-ae53-454d-b59b-395d484b4c94.xhtml)、*响应式系统*中更多地讨论这个问题。
- en: Immutable collections
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: In everyday language, the adjectives *immutable* and *unmodifiable* are used
    interchangeably. But in the case of Java collections, an unmodifiable collection
    can be changed. Well, it also depends on what kind of meaning you give to the
    word *change*. Here is what we mean by this.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常语言中，形容词*不可变*和*不可修改*是可以互换使用的。但是在Java集合的情况下，不可修改的集合是可以更改的。好吧，这也取决于你对*更改*这个词的理解。这就是我们的意思。
- en: Immutable versus unmodifiable
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变与不可修改
- en: 'There are eight static methods in the `Collections` class that make a collection
    *unmodifiable*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类中有八个静态方法可以使集合*不可修改*：'
- en: '`Set<T>  unmodifiableSet(Set<? extends T> set)`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<T>  unmodifiableSet(Set<? extends T> set)`'
- en: '`List<T>  unmodifiableList(List<? extends T> list)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>  unmodifiableList(List<? extends T> list)`'
- en: '`Map<K,V>  unmodifiableMap(Map<? extends K, ? extends V> map)`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V>  unmodifiableMap(Map<? extends K, ? extends V> map)`'
- en: '`Collection<T> unmodifiableCollection (Collection<? extends T> collection)`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<T> unmodifiableCollection (Collection<? extends T> collection)`'
- en: '`SortedSet<T>  unmodifiableSortedSet(SortedSet<T> sortdedSet)`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedSet<T>  unmodifiableSortedSet(SortedSet<T> sortdedSet)`'
- en: '`SortedMap<K,V>  unmodifiableSortedMap(SortedMap<K,? extends V> sortedMap)`,'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedMap<K,V>  unmodifiableSortedMap(SortedMap<K,? extends V> sortedMap)`,'
- en: '`NavigableSet<T>  unmodifiableNavigableSet(NavigableSet<T> navigableSet)`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableSet<T>  unmodifiableNavigableSet(NavigableSet<T> navigableSet)`'
- en: '`NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K,? extends V> navigableMap)`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K,? extends V> navigableMap)`'
- en: 'Here is an example of code that creates an unmodifiable list:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建不可修改列表的代码示例：
- en: '```java'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = Arrays.asList("s1", "s1");
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = Arrays.asList("s1", "s1");
- en: 'System.out.println(list);          //prints: [s1, s1]'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);          //打印：[s1, s1]
- en: List<String> unmodfifiableList = Collections.unmodifiableList(list);
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> unmodfifiableList = Collections.unmodifiableList(list);
- en: //unmodfifiableList.set(0, "s1"); //UnsupportedOperationException
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: //unmodfifiableList.set(0, "s1"); //UnsupportedOperationException
- en: //unmodfifiableList.add("s2");    //UnsupportedOperationException
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: //unmodfifiableList.add("s2");    //UnsupportedOperationException
- en: '```'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you have probably expected, we can neither change the value of an element
    nor add a new element to an unmodifiable list. Nevertheless, we can change the
    underlying list because we still hold the reference to it. And this change will
    be picked up by the unmodifiable list created earlier:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能期望的那样，我们既不能更改元素的值，也不能向不可修改的列表中添加新元素。尽管如此，我们仍然可以更改底层列表，因为我们仍然持有对它的引用。之前创建的不可修改列表将捕获到这种更改：
- en: '```java'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'System.out.println(unmodfifiableList);      //prints: [s1, s1]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(unmodfifiableList);      //打印：[s1, s1]
- en: list.set(0, "s0");
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: list.set(0, "s0");
- en: //list.add("s2");       //UnsupportedOperationException
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add("s2");       //UnsupportedOperationException
- en: 'System.out.println(unmodfifiableList);      //prints: [s0, s1]'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(unmodfifiableList);      //打印：[s0, s1]
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, by changing the original list, we have managed to change the
    value of the element in the unmodifiable list created earlier. And that is the
    weakness of this way of creating unmodifiable collections, because they are basically
    just wrappers around regular ones.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变原始列表，我们成功地改变了之前创建的不可修改列表中元素的值。这就是创建不可修改集合的这种方式的弱点，因为它们基本上只是常规集合的包装器。
- en: The `of()`  collection of factory methods do not have this weakness because
    they do not have two-step collection creation as in the case of unmodifiable collections.
    That is why there is no way to change the collection created by the `of` factory
    method. It is not possible to change either the collection composition nor any
    of its elements. The collections created this way are called "immutable." That
    is the difference between *unmodifiable* and *immutable* in the world of Java
    collections.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`of()`工厂方法的集合没有这个弱点，因为它们没有像不可修改集合那样的两步集合创建。这就是为什么无法更改`of`工厂方法创建的集合的原因。无法更改集合的组成部分或任何元素。以这种方式创建的集合称为"不可变"。这就是Java集合世界中*不可修改*和*不可变*之间的区别。'
- en: Immutable without methods of()
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用of()方法的不可变
- en: 'To be fair, there are ways to create an immutable collection even without using
    the `of()` factory methods. Here is one way to do it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，即使不使用`of()`工厂方法，也有办法创建不可变集合。以下是一种方法：
- en: '```java'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> iList =
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> iList =
- en: Collections.unmodifiableList(new ArrayList<>() {{
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.unmodifiableList(new ArrayList<>() {{
- en: add("s1");
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: add("s1");
- en: add("s1");
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: add("s1");
- en: '}});'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '}});'
- en: //iList.set(0, "s0");       //UnsupportedOperationException
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: //iList.set(0, "s0");       //UnsupportedOperationException
- en: //iList.add("s2");          //UnsupportedOperationException
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: //iList.add("s2");          //UnsupportedOperationException
- en: 'System.out.println(iList);  //prints: [s1, s1]'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(iList);  //打印：[s1, s1]
- en: '```'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The trick is not to have a reference to the original collection (the source
    of values) used to create the unmodifiable collection, so it cannot be used to
    change the underlying source.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是不要引用用于创建不可修改集合的原始集合（值的来源），因此不能用于更改底层来源。
- en: 'And here is another way to create an immutable collection without using the `of()` factory
    methods:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种创建不可变集合的方法，而不使用`of()`工厂方法：
- en: '```java'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String[] source = {"s1", "s2"};
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: String[] source = {"s1", "s2"};
- en: List<String> iList2 =
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> iList2 =
- en: Arrays.stream(source).collect(Collectors.toList());
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码流转换为列表。
- en: 'System.out.println(iList2);      //prints: [s1, s2]'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(iList2);      //打印：[s1, s2]
- en: source[0]="s0";
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: source[0]="s0";
- en: 'System.out.println(iList2);      //prints: [s1, s2]'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(iList2);      //打印：[s1, s2]
- en: '```'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It looks as if we have here the `source` reference to the original values. But,
    the stream does not maintain the reference between the value and its source. It
    copies each value before processing them, thus breaking the value's connection
    with its source. That is why our attempt to change the element of `iList2` by
    changing an element of the `source` array did not succeed. We will talk more about
    streams in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像我们在这里有对原始值的`source`引用。但是，流不会保持值与其源之间的引用。它在处理之前会复制每个值，从而打破值与其源的连接。这就是为什么我们尝试通过更改`source`数组的元素来更改`iList2`的元素并没有成功。我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中更多地讨论流，*流和管道*。
- en: The need for immutable collections arises from an effort to protect the collection
    object from modification when it is passed as a parameter into a method. As we
    have mentioned already, such modification would be a side effect that may introduce
    unexpected and difficult-to-trace defects.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 需要不可变集合是为了在将其作为参数传递到方法中时保护集合对象免受修改。正如我们已经提到的，这样的修改将是一个可能引入意外和难以追踪的副作用。
- en: Please note that the `of()` factory methods without parameters create empty
    immutable collections. They also might be needed when you need to call a method
    that requires a collection as a parameter, but you do not have data for it and
    also do not want to give the method a chance to modify the passed-in collection.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`of()`工厂方法不带参数时会创建空的不可变集合。当您需要调用一个需要集合作为参数的方法，但又没有数据，并且也不想给方法修改传入的集合的机会时，它们也可能是需要的。
- en: 'There are also three constants in the `Collections` class that provide immutable
    empty collections:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类中还有三个常量，提供了不可变的空集合：'
- en: '```java'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = Collections.EMPTY_LIST;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = Collections.EMPTY_LIST;
- en: //list1.add("s1");       //UnsupportedOperationException
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: //list1.add("s1");       //UnsupportedOperationException
- en: Set<String> set1 = Collections.EMPTY_SET;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set1 = Collections.EMPTY_SET;
- en: Map<Integer, String> map1 = Collections.EMPTY_MAP;
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map1 = Collections.EMPTY_MAP;
- en: '```'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In addition, there are seven methods in the `Collections` class that create
    immutable empty collections too:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Collections`类中还有七种方法可以创建不可变的空集合：
- en: '```java'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list2 = Collections.emptyList();
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = Collections.emptyList();
- en: //list2.add("s1");       //UnsupportedOperationException
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: //list2.add("s1");       //UnsupportedOperationException
- en: Set<String> set2 = Collections.emptySet();
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set2 = Collections.emptySet();
- en: Map<Integer, String> map2 = Collections.emptyMap();
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map2 = Collections.emptyMap();
- en: SortedSet<String> set3 = Collections.emptySortedSet();
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: SortedSet<String> set3 = Collections.emptySortedSet();
- en: Map<Integer, String> map3 = Collections.emptySortedMap();
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map3 = Collections.emptySortedMap();
- en: NavigableSet<String> set4 = Collections.emptyNavigableSet();
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: NavigableSet<String> set4 = Collections.emptyNavigableSet();
- en: NavigableMap<Integer, String> map4 = Collections.emptyNavigableMap();
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: NavigableMap<Integer, String> map4 = Collections.emptyNavigableMap();
- en: '```'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the following methods of the `Collections` class create immutable collections
    with one element only:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类的以下方法创建只有一个元素的不可变集合：'
- en: '`Set<T> singleton(T object)`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<T> singleton(T object)`'
- en: '`List<T> singletonList(T object)`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> singletonList(T object)`'
- en: '`Map<K,V> singletonMap(K key, V value)`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V> singletonMap(K key, V value)`'
- en: 'You can see how it works in the following code snippet:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码片段中看到它是如何工作的：
- en: '```java'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> singletonS1 = Collections.singletonList("s1");
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> singletonS1 = Collections.singletonList("s1");
- en: System.out.println(singletonS1);
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(singletonS1);
- en: //singletonS1.add("s1");        //UnsupportedOperationException
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: //singletonS1.add("s1");        //UnsupportedOperationException
- en: '```'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: All of these can be done using the `of()` factory methods. We have described
    it just for you to have a complete picture of the options available for immutable
    collection creation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用`of()`工厂方法来完成。我们已经为您描述了这一点，以便您对不可变集合创建的可用选项有一个完整的了解。
- en: 'But the `List<T> nCopies(int n, T object)` methodof the `Collections` class creates
    an immutable list of `n` copies of the same object in a more compact manner than
    the `of()` method:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`Collections`类的`List<T> nCopies(int n, T object)`方法以比`of()`方法更紧凑的方式创建了`n`个相同对象的不可变列表：
- en: '```java'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> nList = Collections.nCopies(3, "s1");
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> nList = Collections.nCopies(3, "s1");
- en: System.out.println(nList);
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(nList);
- en: //nList.add("s1");        //UnsupportedOperationException
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: //nList.add("s1");        //UnsupportedOperationException
- en: '```'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Similar code that uses the `of()` method is more verbose:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`of()`方法的类似代码更冗长：
- en: '```java'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> nList = List.of("s1", "s1", "s1");
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> nList = List.of("s1", "s1", "s1");
- en: '```'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If that does not look too bad for you, imagine that you need to create a list
    of 100 of the same objects.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说不是太糟糕，想象一下你需要创建一个包含100个相同对象的列表。
- en: Methods add() and put() confusion
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: add()和put()方法的混淆
- en: There is one aspect of immutable collection use that is a source of occasional
    confusion. You have seen from our examples that the immutable collections, like
    any Java collection, have the `add()` or `put()` methods. The compiler does not
    generate an error, only JVM at runtime does so. So, code that uses immutable collections
    should be well tested to avoid this kind of error in production.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合使用的一个方面是偶尔会引起混淆的源。从我们的例子中可以看出，不可变集合，就像任何Java集合一样，都有`add()`或`put()`方法。编译器不会生成错误，只有运行时的JVM才会这样做。因此，使用不可变集合的代码应该经过充分测试，以避免在生产中出现这种错误。
- en: java.util.Collections class
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: java.util.Collections类
- en: All methods of the `java.util.Collections` class are static and stateless. The
    latter means that they do not maintain any state anywhere, and that their results
    do not depend on the history of calls but only on the values passed in as parameters.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collections`类的所有方法都是静态且无状态的。后者意味着它们不会在任何地方维护任何状态，它们的结果不依赖于调用历史，而只依赖于作为参数传递的值。'
- en: There are many methods in the `Collections` class and you have seen some of
    them already in the previous section. We encourage you to look up the online documentation
    of this class. Here, we have grouped some of them for your convenience, so you
    can have a better overview of the methods of the `Collections` class.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类中有许多方法，您已经在上一节中看到了其中一些。我们鼓励您查阅此类的在线文档。在这里，我们为您整理了其中一些方法，以便您更好地了解`Collections`类的方法。'
- en: Copy
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: 'The `void copy(List<T> dest, List<T> src)` method copies elements of the `src` list to
    the `dest` list and preserves the element order. This method is very useful in
    case you need to make one list a sublist of another list:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`void copy(List<T> dest, List<T> src)`方法将`src`列表的元素复制到`dest`列表并保留元素顺序。如果需要将一个列表作为另一个列表的子列表，这个方法非常有用：'
- en: '```java'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = Arrays.asList("s1","s2");
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = Arrays.asList("s1","s2");
- en: List<String> list2 = Arrays.asList("s3", "s4", "s5");
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = Arrays.asList("s3", "s4", "s5");
- en: Collections.copy(list2, list1);
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.copy(list2, list1);
- en: 'System.out.println(list2);    //prints: [s1, s2, "s5"]'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list2);    //输出：[s1, s2, "s5"]
- en: '```'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'While doing this, the `copy()` method does not consume additional memory -
    it just copies the values over the already allocated memory. It makes this method
    helpful for cases where the traditional way of copying lists of equal sizes is
    not acceptable:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作时，`copy()`方法不会消耗额外的内存 - 它只是将值复制到已分配的内存上。这使得这个方法对于传统的复制相同大小的列表的情况非常有帮助：
- en: '```java'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = Arrays.asList("s1","s2");
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = Arrays.asList("s1","s2");
- en: List<String> list2 = Arrays.asList("s3", "s4");
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = Arrays.asList("s3", "s4");
- en: list2 = new ArrayList(list1);
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: list2 = new ArrayList(list1);
- en: 'System.out.println(list2);    //prints: [s1, s2]'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list2);    //输出：[s1, s2]
- en: '```'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This code abandons the values originally assigned to `list2` and allocates new
    memory for `list2` to hold a copy of `list1` values. The abandoned values sit
    in the memory until the garbage collector removes them and allows the reuse of
    the memory. Imagine these lists are of a substantial size, and you can appreciate
    that using `Collections.copy()`, which in this case removes a lot of overhead.
    It also helps to avoid the `OutOfMemory` exception.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码放弃了最初分配给`list2`的值，并分配了新的内存来保存`list1`的值的副本。被放弃的值会一直留在内存中，直到垃圾收集器将它们移除并允许重用内存。想象一下，这些列表的大小是可观的，您就会明白在这种情况下使用`Collections.copy()`会减少很多开销。它还有助于避免`OutOfMemory`异常。
- en: Sort and equals()
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和相等()
- en: 'The two static sorting methods of the `Collections` class are:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类的两个静态排序方法是：'
- en: '`void sort(List<T> list)`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sort(List<T> list)`'
- en: '`void sort(List<T> list, Comparator<T> comparator)`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sort(List<T> list, Comparator<T> comparator)`'
- en: The first `sort(List<T>)` method accepts only lists with elements that implement
    the `Comparable` interface, which requires implementation of the `compareTo(T)` method.
    The order established by the `compareTo(T)` method implemented by each element
    is called *natural ordering*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`sort(List<T>)`方法只接受实现`Comparable`接口的元素的列表，这要求实现`compareTo(T)`方法。每个元素实现的`compareTo(T)`方法建立的顺序称为“自然排序”。
- en: The second `sort()` method does not require the list elements to implement any
    particular interface. It uses the passed-in object of the class `Comparator` to
    establish the required order using the `Comparator.compare(T o1, T o2)` method. If
    the elements of the list implement `Comparable`, then their method `compareTo(T)` is
    ignored and the order is established by the method `Comparator.compare(T o1, T
    o2)` only.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`sort()`方法不需要列表元素实现任何特定的接口。它使用传入的`Comparator`类的对象来使用`Comparator.compare(T
    o1, T o2)`方法建立所需的顺序。如果列表的元素实现了`Comparable`，那么它们的方法`compareTo(T)`会被忽略，顺序只由`Comparator.compare(T
    o1, T o2)`方法建立。
- en: The order defined by the `Comparator` object (the `compare(T o1, T o2)` method)
    overrides the natural order defined by the `Comparable` interface (the method `compareTo(T)`).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`对象定义的顺序（`compare(T o1, T o2)`方法）会覆盖`Comparable`接口定义的自然顺序（`compareTo(T)`方法）。'
- en: 'For example, here is how the class `String` implements the interface `Comparable`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是类`String`如何实现接口`Comparable`：
- en: '```java'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> no = Arrays.asList("a","b", "Z", "10", "20", "1", "2");
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> no = Arrays.asList("a","b", "Z", "10", "20", "1", "2");
- en: Collections.sort(no);
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(no);
- en: 'System.out.println(no);     //prints: [1, 10, 2, 20, Z, a, b]'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(no);     //输出：[1, 10, 2, 20, Z, a, b]
- en: '```'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For many people, the fact that `10` is placed in front of `2` and a capital
    `Z` is placed in front of the lowercase `a` probably does not look *natural*,
    but this term is not based on human perception. It is based on how the objects
    are going to be sorted when no comparator is provided. In such cases, they are
    ordered based on the implemented method, `compareTo(T)`. This implemented method
    can be considered to be *built into* the elements. That is why such an ordering
    is called *natural*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，`10`排在`2`前面，大写`Z`排在小写`a`前面可能看起来并不“自然”，但这个术语并不是基于人类的感知。它是基于对象在没有提供比较器时将如何排序的。在这种情况下，它们是基于实现的方法`compareTo(T)`排序的。这个实现的方法可以被认为是内置在元素中的。这就是为什么这样的排序被称为“自然”的原因。
- en: A natural ordering is one defined by the implementation of the interface `Comparable` (the
    method `compareTo(T)`).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 自然排序是由接口`Comparable`的实现定义的（方法`compareTo(T)`）。
- en: 'Although it looks somewhat unexpected for humans, the `String` implementation
    of the `compareTo(T)` method is very helpful in many ordering cases. For example,
    we can use it for the implementation of the `Comparable` interface in our class  `Person`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对人类来说看起来有些意外，但`String`对`compareTo(T)`方法的实现在许多排序情况下非常有帮助。例如，我们可以用它来实现`Person`类中`Comparable`接口的实现：
- en: '```java'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person implements Comparable<Person>{
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 类Person实现Comparable<Person> {
- en: private String firstName = "", lastName = "";
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: private String firstName = "", lastName = "";
- en: public Person(String firstName, String lastName) {
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数public Person(String firstName, String lastName) {
- en: this.firstName = firstName;
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: this.firstName = firstName;
- en: this.lastName = lastName;
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: this.lastName = lastName;
- en: '}'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getFirstName() { return firstName; }
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: public String getFirstName() { return firstName; }
- en: public String getLastName() { return lastName; }
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: public String getLastName() { return lastName; }
- en: '@Override'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int compareTo(Person person){
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: public int compareTo(Person person){
- en: int result = this.firstName.compareTo(person.firstName);
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: int result = this.firstName.compareTo(person.firstName);
- en: if(result == 0) {
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: if(result == 0) {
- en: return this.lastName.compareTo(person.lastName);
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: return this.lastName.compareTo(person.lastName);
- en: '}'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return result;
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We compare first names first, and if they are equal, compare last names. This
    means that we would like `Person` objects to be ordered by first name, then by
    last name.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先比较名字，如果它们相等，再比较姓。这意味着我们希望`Person`对象按名字顺序排列，然后按姓氏排列。
- en: 'The `String` implementation of the `compareTo(T)` method returns the difference
    between the ordering positions of the first (or this) and the second objects.
    For example, the difference between the ordering positions of `a` and `c` is `2`,
    and here is the result of their comparison:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`的`compareTo(T)`方法的实现返回第一个（或this）和第二个对象的排序位置之间的差异。例如，`a`和`c`的排序位置之间的差异是`2`，这是它们比较的结果：'
- en: '```java'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println("a".compareTo("c"));   //prints: -2'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("a".compareTo("c"));   //prints: -2'
- en: 'System.out.println("c".compareTo("a"));   //prints: 2'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("c".compareTo("a"));   //prints: 2'
- en: '```'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This makes sense: `a` is placed before `c`, so its position is smaller when
    we count it from left to right.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的：`a`在`c`之前，所以它的位置在我们从左到右计算时更小。
- en: 'Notice, though, that the `Integer` implementation of `compareTo(T)` does not
    return the difference in the ordering position. Instead, it returns `0` when objects
    are equal, `-1` when this object is smaller than the method parameter, and `1`
    otherwise:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Integer`的`compareTo(T)`实现并不返回排序位置的差异。相反，当对象相等时，它返回`0`，当此对象小于方法参数时，它返回`-1`，否则返回`1`：
- en: '```java'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Integer.valueOf(3)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.valueOf(3)
- en: '.compareTo(Integer.valueOf(3))); //prints: 0'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '.compareTo(Integer.valueOf(3))); //prints: 0'
- en: System.out.println(Integer.valueOf(3)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.valueOf(3)
- en: '.compareTo(Integer.valueOf(4))); //prints: -1'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '.compareTo(Integer.valueOf(4))); //prints: -1'
- en: System.out.println(Integer.valueOf(3)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.valueOf(3)
- en: '.compareTo(Integer.valueOf(5))); //prints: -1'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '.compareTo(Integer.valueOf(5))); //prints: -1'
- en: System.out.println(Integer.valueOf(5)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.valueOf(5)
- en: '.compareTo(Integer.valueOf(4))); //prints: 1'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '.compareTo(Integer.valueOf(4))); //prints: 1'
- en: System.out.println(Integer.valueOf(5)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.valueOf(5)
- en: '.compareTo(Integer.valueOf(3))); //prints: 1'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '.compareTo(Integer.valueOf(3))); //prints: 1'
- en: '```'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We get the same results using `Comparator` and its method `compare(T o1, T
    o2)`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Comparator`及其方法`compare(T o1, T o2)`得到相同的结果：
- en: '```java'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Comparator<String> compStr = Comparator.naturalOrder();
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Comparator<String> compStr = Comparator.naturalOrder();
- en: 'System.out.println(compStr.compare("a", "c"));  //prints: -2'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(compStr.compare("a", "c"));  //prints: -2'
- en: Comparator<Integer> compInt = Comparator.naturalOrder();
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Comparator<Integer> compInt = Comparator.naturalOrder();
- en: 'System.out.println(compInt.compare(3, 5));     //prints: -1'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(compInt.compare(3, 5));     //prints: -1'
- en: '```'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, beware that the documentation of the methods `Comparable.compareTo(T)`
    and `Compartor.compare(T o1, T o2)` defines only the following return:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，方法`Comparable.compareTo(T)`和`Compartor.compare(T o1, T o2)`的文档只定义了以下返回：
- en: '`0` when the objects are equal'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`表示对象相等'
- en: '`-1` when the first object is smaller than the second one'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`表示第一个对象小于第二个对象'
- en: '`1` when the first object is bigger than the second one'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`表示第一个对象大于第二个对象'
- en: In the case of `String`, `smaller`, and `bigger` are defined according to their
    ordering position—smaller is placed in front of bigger in the ordered list. As
    you can see, the API documentation does not guarantee that the difference in the
    ordering position is returned for all types of objects.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在`String`的情况下，`smaller`和`bigger`根据它们的排序位置进行定义——在有序列表中，`smaller`放在`bigger`前面。正如您所看到的，API文档并不保证对所有类型的对象都返回排序位置的差异。
- en: It is important to make sure that the method `equals()` is aligned with the
    method `Comparable.compareTo(T)` so that for equal objects, the method `Comparable.compareTo(T)` returns
    0\. Otherwise, one may get unpredictable sorting results.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要确保方法`equals()`与方法`Comparable.compareTo(T)`对齐，以便对于相等的对象，方法`Comparable.compareTo(T)`返回0。否则，可能会得到不可预测的排序结果。
- en: 'That is why we add the following method `equals()` to our class `Person`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在我们的类`Person`中添加了以下方法`equals()`：
- en: '```java'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object other) {
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object other) {
- en: if (other == null) return false;
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: if (other == null) return false;
- en: if (this == other) return true;
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == other) return true;
- en: if (!(other instanceof Person)) return false;
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: if (!(other instanceof Person)) return false;
- en: final Person that = (Person) other;
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: final Person that = (Person) other;
- en: return this.firstName.equals(that.getFirstName()) &&
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: return this.firstName.equals(that.getFirstName()) &&
- en: this.lastName.equals(that.getLastName());
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: this.lastName.equals(that.getLastName());
- en: '}'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now the method `equals()` is aligned with the method `compareTo(T)`, so that
    `compareTo(T)` returns 0 when used for equal `Person` objects:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在方法`equals()`与方法`compareTo(T)`对齐，因此对于相等的`Person`对象，`compareTo(T)`返回0：
- en: '```java'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person joe1 = new Person("Joe", "Smith");
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: Person joe1 = new Person("Joe", "Smith");
- en: Person joe2 = new Person("Joe", "Smith");
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Person joe2 = new Person("Joe", "Smith");
- en: Person bob = new Person("Bob", "Smith");
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Person bob = new Person("Bob", "Smith");
- en: 'System.out.println(joe1.equals(joe2));    //prints: true'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(joe1.equals(joe2));    //prints: true'
- en: 'System.out.println(joe1.compareTo(joe2)); //prints: 0'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(joe1.compareTo(joe2)); //prints: 0'
- en: 'System.out.println(joe1.equals(bob));     //prints: false'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(joe1.equals(bob));     //prints: false'
- en: 'System.out.println(joe1.compareTo(bob));  //prints: 8'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(joe1.compareTo(bob));  //prints: 8'
- en: 'System.out.println(joe2.compareTo(bob));  //prints: 8'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(joe2.compareTo(bob));  //prints: 8'
- en: '```'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The value `8` is returned because that is the difference between the positions
    of `B` and `J` in alphabetical order.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值`8`是因为这是`B`和`J`在字母顺序中的位置之间的差异。
- en: 'We have also added the following `toString()` method to our class `Person`
    too:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在我们的类`Person`中添加了以下`toString()`方法：
- en: '```java'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString(){
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString(){
- en: return this.firstName + " " + this.lastName;
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: return this.firstName + " " + this.lastName;
- en: '}'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It will allow us to demonstrate ordering results better, and that is what we
    are going to do now. Here is the demo code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 它将允许我们更好地展示排序结果，这正是我们现在要做的。以下是演示代码：
- en: '```java'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p1 = new Person("Zoe", "Arnold");
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Person p1 = new Person("Zoe", "Arnold");
- en: Person p2 = new Person("Alex", "Green");
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Person p2 = new Person("Alex", "Green");
- en: Person p3 = new Person("Maria", "Brown");
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Person p3 = new Person("Maria", "Brown");
- en: List<Person> list7 = Arrays.asList(p1, p2, p3);
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list7 = Arrays.asList(p1, p2, p3);
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
- en: Collections.sort(list7);
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(list7);
- en: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
- en: '```'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the order of the elements after sorting (the last line of the
    previous example) matches the one defined in the `compareTo(T)` method.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在排序后元素的顺序（前一个示例的最后一行）与`compareTo(T)`方法中定义的顺序相匹配。
- en: 'Now, let''s create a comparator that sorts objects of class `Person` differently:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个以不同方式对`Person`类的对象进行排序的比较器：
- en: '```java'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class OrderByLastThenFirstName implements Comparator<Person> {
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: class OrderByLastThenFirstName implements Comparator<Person> {
- en: '@Override'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int compare(Person p1, Person p2){
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: public int compare(Person p1, Person p2){
- en: return (p1.getLastName() + p1.getFirstName())
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: return (p1.getLastName() + p1.getFirstName())
- en: .compareTo(p2.getLastName() + p2.getFirstName());
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: .compareTo(p2.getLastName() + p2.getFirstName());
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the preceding comparator establishes an order based on the
    natural order of the last names first, and then the natural order of the first
    names. If we use this comparator with the same list and objects, we will get the
    following results:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的比较器首先根据姓氏的自然顺序，然后根据名字的自然顺序建立了一个顺序。如果我们使用相同的列表和对象与此比较器，我们将得到以下结果：
- en: '```java'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Collections.sort(list7, new OrderByLastThenFirstName());
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(list7, new OrderByLastThenFirstName());
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
- en: '```'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As was expected, the `compareTo(T)` method was ignored and the passed-in `Comparator` object's
    order was enforced.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`compareTo(T)`方法被忽略，传入的`Comparator`对象的顺序被强制执行。
- en: Reverse and rotate
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转和旋转
- en: 'There are three static reverse-related, and one rotate-related, methods in
    the class `Collections`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Collections`中有三个静态的与反转相关的方法，以及一个与旋转相关的方法：
- en: '`void reverse(List<?> list)`: Reverses the current order of elements'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void reverse(List<?> list)`: 反转元素的当前顺序'
- en: '`void rotate(List<?> list, int distance) `: Rotates the order of the elements
    by moving each of them to the right for the specified number of positions (distance)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void rotate(List<?> list, int distance) `: 将元素的顺序旋转，将每个元素向右移动指定数量的位置（距离）'
- en: '`Comparator<T> reverseOrder()`: Returns a comparator that creates an order
    that is the reverse of the natural ordering; applies only to elements that implement
    the `Comparable` interface'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comparator<T> reverseOrder()`: 返回一个创建与自然顺序相反的顺序的比较器；仅适用于实现了`Comparable`接口的元素'
- en: '`Comparator<T> reverseOrder(Comparator<T> comparator)`: Returns a comparator
    that reverses the order defined by the passed-in comparator'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comparator<T> reverseOrder(Comparator<T> comparator)`: 返回一个反转传入比较器定义的顺序的比较器'
- en: 'And here is the code that demonstrates the listed methods:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示列出的方法的代码：
- en: '```java'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p1 = new Person("Zoe", "Arnold");
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Person p1 = new Person("Zoe", "Arnold");
- en: Person p2 = new Person("Alex", "Green");
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Person p2 = new Person("Alex", "Green");
- en: Person p3 = new Person("Maria", "Brown");
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Person p3 = new Person("Maria", "Brown");
- en: List<Person> list7 = Arrays.asList(p1,p2,p3);
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list7 = Arrays.asList(p1,p2,p3);
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
- en: Collections.reverse(list7);
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.reverse(list7);
- en: System.out.println(list7);  //[Maria Brown, Alex Green, Zoe Arnold]
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Maria Brown, Alex Green, Zoe Arnold]
- en: Collections.rotate(list7, 1);
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.rotate(list7, 1);
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
- en: Collections.sort(list7, Collections.reverseOrder());
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(list7, Collections.reverseOrder());
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
- en: Collections.sort(list7, new OrderByLastThenFirstName());
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(list7, new OrderByLastThenFirstName());
- en: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Maria Brown, Alex Green]
- en: Collections.sort(list7,
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.sort(list7,
- en: Collections.reverseOrder(new OrderByLastThenFirstName()));
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Collections.reverseOrder(new OrderByLastThenFirstName()));
- en: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Alex Green, Maria Brown, Zoe Arnold]
- en: '```'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Search and equals()
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索和equals()
- en: 'There are five static search-related methods in the class `Collections`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Collections`中有五个静态的与搜索相关的方法：
- en: '`int binarySearch(List<Comparable<T>> list, T key)`'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int binarySearch(List<Comparable<T>> list, T key)`'
- en: '`int binarySearch(List<T> list, T key, Comparator<T> comparator)`'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int binarySearch(List<T> list, T key, Comparator<T> comparator)`'
- en: '`int indexOfSubList(List<?> source, List<?> target) `'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int indexOfSubList(List<?> source, List<?> target) `'
- en: '`int lastIndexOfSubList(List<?> source, List<?> target)`'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int lastIndexOfSubList(List<?> source, List<?> target)`'
- en: '`int frequency(Collection<?> collection, Object object)`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int frequency(Collection<?> collection, Object object)`'
- en: The `binarySearch()` methods search for the `key` value in the provided list.
    The important thing to notice is that the provided list must be *sorted* in *ascending*
    order because of the nature of the binary search. The algorithm compares the key
    to the middle element of the list; if they are unequal, the half in which the
    key cannot belong is ignored and the algorithm compares the key to the middle
    element of the other half of the list. The search continues until the element
    equal to the key is found or only one element is left to search and it is not
    equal to the key.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: The `binarySearch()` methods search for the `key` value in the provided list.
    The important thing to notice is that the provided list must be *sorted* in *ascending*
    order because of the nature of the binary search. The algorithm compares the key
    to the middle element of the list; if they are unequal, the half in which the
    key cannot belong is ignored and the algorithm compares the key to the middle
    element of the other half of the list. The search continues until the element
    equal to the key is found or only one element is left to search and it is not
    equal to the key.
- en: 'The `indexOfSubList()` and `lastIndexOfSubList()` methods return the position
    of the provided sublist in the provided list:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `indexOfSubList()` and `lastIndexOfSubList()` methods return the position
    of the provided sublist in the provided list:'
- en: '```java'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = List.of("s3","s5","s4","s1");
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = List.of("s3","s5","s4","s1");
- en: List<String> list2 = List.of("s4","s5");
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = List.of("s4","s5");
- en: int index = Collections.indexOfSubList(list1, list2);
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: int index = Collections.indexOfSubList(list1, list2);
- en: 'System.out.println(index);  //prints: -1'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(index);  //prints: -1'
- en: List<String> list3 = List.of("s5","s4");
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list3 = List.of("s5","s4");
- en: index = Collections.indexOfSubList(list1, list3);
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: index = Collections.indexOfSubList(list1, list3);
- en: 'System.out.println(index);   //prints: 1'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(index);   //prints: 1'
- en: '```'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Please notice that the sublist should be exactly in the same order. Otherwise,
    it will not be found.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Please notice that the sublist should be exactly in the same order. Otherwise,
    it will not be found.
- en: 'And the last method, `frequency(Collection, Object)`, returns the number of
    times the provided object appears in the provided collection:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 'And the last method, `frequency(Collection, Object)`, returns the number of
    times the provided object appears in the provided collection:'
- en: '```java'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list4 = List.of("s3","s4","s4","s1");
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list4 = List.of("s3","s4","s4","s1");
- en: int count = Collections.frequency(list4, "s4");
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: int count = Collections.frequency(list4, "s4");
- en: 'System.out.println(count);         //prints: 2'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(count);         //prints: 2'
- en: '```'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you are going to use these methods (or any other methods that search collections
    for that matter) and if the collections include objects of custom classes, you
    have to have the method `equals()` implemented. A typical search algorithm uses
    the method `equals()` for the identification of the object. If you do not implement
    the method `equals()` in your custom class, the method `equals()` from the base
    class `Object` is going to be used, which compares only the object references,
    not their states (values of their fields). Here is a demonstration of this behavior:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'If you are going to use these methods (or any other methods that search collections
    for that matter) and if the collections include objects of custom classes, you
    have to have the method `equals()` implemented. A typical search algorithm uses
    the method `equals()` for the identification of the object. If you do not implement
    the method `equals()` in your custom class, the method `equals()` from the base
    class `Object` is going to be used, which compares only the object references,
    not their states (values of their fields). Here is a demonstration of this behavior:'
- en: '```java'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A{}
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: class A{}
- en: class B extends A{}
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A{}
- en: List<A> list5 = List.of(new A(), new B());
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list5 = List.of(new A(), new B());
- en: int c = Collections.frequency(list5, new A());
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: int c = Collections.frequency(list5, new A());
- en: 'System.out.println(c);         //prints: 0'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 0'
- en: A a = new A();
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: A a = new A();
- en: List<A> list6 = List.of(a, new B());
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list6 = List.of(a, new B());
- en: c = Collections.frequency(list6, a);
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: c = Collections.frequency(list6, a);
- en: 'System.out.println(c);         //prints: 1'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 1'
- en: '```'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the object of class `A` is found only if it is literally the
    same object. But if we implement the method `equals()`, then the object of class
    A is found according to the criteria we have put in the method `equals()` implementation:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'As you can see, the object of class `A` is found only if it is literally the
    same object. But if we implement the method `equals()`, then the object of class
    A is found according to the criteria we have put in the method `equals()` implementation:'
- en: '```java'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A{
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: class A{
- en: '@Override'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o){
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o){
- en: if (o == null) return false;
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null) return false;
- en: return (o instanceof A);
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: return (o instanceof A);
- en: '}'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class B extends A{}
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A{}
- en: List<A> list5 = List.of(new A(), new B());
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list5 = List.of(new A(), new B());
- en: int c = Collections.frequency(list5, new A());
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: int c = Collections.frequency(list5, new A());
- en: 'System.out.println(c);         //prints: 2'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 2'
- en: A a = new A();
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: A a = new A();
- en: List<A> list6 = List.of(a, new B());
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list6 = List.of(a, new B());
- en: c = Collections.frequency(list6, a);
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: c = Collections.frequency(list6, a);
- en: 'System.out.println(c);         //prints: 2'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 2'
- en: '```'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now, the count of objects `A` in each case is `2` because `B` extends `A` and
    thus has two types, `B` and `A`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Now, the count of objects `A` in each case is `2` because `B` extends `A` and
    thus has two types, `B` and `A`.
- en: 'If we prefer to identify the object by exactly the current class name and not
    include its parent class in the consideration, we should implement the method
    `equals()` differently:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we prefer to identify the object by exactly the current class name and not
    include its parent class in the consideration, we should implement the method
    `equals()` differently:'
- en: '```java'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A{
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: class A{
- en: '@Override'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o){
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o){
- en: if (o == null) return false;
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null) return false;
- en: return o.getClass().equals(this.getClass());
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: return o.getClass().equals(this.getClass());
- en: '}'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class B extends A{}
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A{}
- en: List<A> list5 = List.of(new A(), new B());
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list5 = List.of(new A(), new B());
- en: int c = Collections.frequency(list5, new A());
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: int c = Collections.frequency(list5, new A());
- en: 'System.out.println(c);         //prints: 1'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 1'
- en: A a = new A();
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: A a = new A();
- en: List<A> list6 = List.of(a, new B());
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list6 = List.of(a, new B());
- en: c = Collections.frequency(list6, a);
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: c = Collections.frequency(list6, a);
- en: 'System.out.println(c);         //prints: 1'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c);         //prints: 1'
- en: '```'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The method `getClass()` returns the class name used when the object was created
    by the operator `new`. That is why the count in both cases is now `1`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: The method `getClass()` returns the class name used when the object was created
    by the operator `new`. That is why the count in both cases is now `1`.
- en: For the rest of this chapter, we are going to assume that the method `equals()`
    is implemented in the elements of the collections and arrays. Most of the time,
    we are going to use objects of the class `String` in our example. As we have mentioned
    earlier in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, the class `String` has an `equals()` method implementation
    based on the string literal value, not on object reference only. And, as we have
    explained in the previous subsection, the class `String` also implements the interface
    `Comparable` so that it provides natural ordering.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将假设集合和数组的元素实现了`equals()`方法。大多数情况下，我们将在示例中使用`String`类的对象。正如我们在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中提到的那样，*运算符、表达式和语句*，`String`类具有基于字符串字面值的`equals()`方法实现，而不仅仅是基于对象引用。并且，正如我们在前一小节中解释的那样，`String`类还实现了`Comparable`接口，因此它提供了自然排序。
- en: Comparing two collections
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较两个集合
- en: 'There is one straightforward static method for comparing two collections in
    the class `Collections`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类中有一个简单的静态方法用于比较两个集合：'
- en: '`boolean disjoint(Collection<?> c1, Collection<?> c2)`: Returns `true` if none
    of the elements of one collection equal any element of another collection'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean disjoint(Collection<?> c1, Collection<?> c2)`: 如果一个集合的元素都不等于另一个集合的任何元素，则返回`true`'
- en: As you probably guessed, this method uses the method `equals()` to identify
    equal elements.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，这个方法使用`equals()`方法来识别相等的元素。
- en: Min and max elements
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小和最大元素
- en: 'The following `Collections` class methods can be used to select the *biggest* and
    the *smallest* element of the provided collection:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Collections`类的方法可用于选择提供的集合中的*最大*和*最小*元素：
- en: '`T min(Collection<? extends T> collection)`'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T min(Collection<? extends T> collection)`'
- en: '`T max(Collection<? extends T>collection)`'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T max(Collection<? extends T>collection)`'
- en: '`T min(Collection<? extends T>collection, Comparator<T> comparator)`'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T min(Collection<? extends T>collection, Comparator<T> comparator)`'
- en: '`T max(Collection<? extends T>collection, Comparator<T> comparator)`'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T max(Collection<? extends T>collection, Comparator<T> comparator)`'
- en: The first two methods require the collection elements to implement `Comparable` (the
    method `compareTo(T)`), while the other two methods use an object of the class `Comparator` to
    compare the elements.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法要求集合元素实现`Comparable`（方法`compareTo(T)`），而另外两个方法使用`Comparator`类的对象来比较元素。
- en: 'The smallest element is the one that is first in the sorted list; the biggest
    is on the opposite end of the sorted list. Here is the demonstration code:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的元素是在排序后的列表中首先出现的元素；最大的元素在排序后的列表的另一端。以下是演示代码：
- en: '```java'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p1 = new Person("Zoe", "Arnold");
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Person p1 = new Person("Zoe", "Arnold");
- en: Person p2 = new Person("Alex", "Green");
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: Person p2 = new Person("Alex", "Green");
- en: Person p3 = new Person("Maria", "Brown");
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: Person p3 = new Person("Maria", "Brown");
- en: List<Person> list7 = Arrays.asList(p1,p2,p3);
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list7 = Arrays.asList(p1,p2,p3);
- en: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list7);  //[Zoe Arnold, Alex Green, Maria Brown]
- en: 'System.out.println(Collections.min(list7)); //prints: Alex Green'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Collections.min(list7)); //输出：Alex Green
- en: 'System.out.println(Collections.max(list7)); //prints: Zoe Arnold'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Collections.max(list7)); //输出：Zoe Arnold
- en: Person min = Collections.min(list7, new OrderByLastThenFirstName());
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: Person min = Collections.min(list7, new OrderByLastThenFirstName());
- en: System.out.println(min);                    //[Zoe Arnold]
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(min);                    //[Zoe Arnold]
- en: Person max = Collections.max(list7, new OrderByLastThenFirstName());
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: Person max = Collections.max(list7, new OrderByLastThenFirstName());
- en: System.out.println(max);                    //[Alex Green]
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(max);                    //[Alex Green]
- en: '```'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first two methods use natural ordering to establish the order, while the
    second two use the comparator passed in as a parameter.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法使用自然排序来建立顺序，而后两个方法使用作为参数传递的比较器。
- en: Add and replace elements
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和替换元素
- en: 'The following are three static methods of the class `Collections` that add
    or replace elements in a collection:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Collections`类的三个静态方法，用于向集合中添加或替换元素：
- en: '`boolean addAll(Collection<T> c, T... elements)`: Adds all the provided elements
    to the provided collection; if the provided element is `Set`, only unique elements
    are added. It performs significantly faster than the `addAll()` method of the
    corresponding collection type.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addAll(Collection<T> c, T... elements)`: 将所有提供的元素添加到提供的集合中；如果提供的元素是`Set`，则只添加唯一的元素。它的执行速度比相应集合类型的`addAll()`方法要快得多。'
- en: '`boolean replaceAll(List<T> list, T oldVal, T newVal)`: Replaces every element
    in the provided list that is equal to `oldValue` with the `newValue`; when `oldValue` is
    `null`, the method replaces every `null` value in the provided list with the `newValue`.
    It returns `true` if at least one element was replaced.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean replaceAll(List<T> list, T oldVal, T newVal)`: 用`newValue`替换提供的列表中等于`oldValue`的每个元素；当`oldValue`为`null`时，该方法将提供的列表中的每个`null`值替换为`newValue`。如果至少替换了一个元素，则返回`true`。'
- en: '`void fill(List<T> list, T object)`: Replaces every element in the provided
    list with the provided object.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void fill(List<T> list, T object)`: 用提供的对象替换提供的列表中的每个元素。'
- en: Shuffle and swap elements
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洗牌和交换元素
- en: 'The following three static methods of the class `Collections` shuffle and swap
    elements of the provided list:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类的以下三个静态方法可以对提供的列表进行洗牌和交换元素：'
- en: '`void shuffle(List<?> list)`: Uses the default source of randomness to shuffle
    the positions of the elements in the provided list'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void shuffle(List<?> list)`: 使用默认的随机源来打乱提供的列表中元素的位置'
- en: '`void shuffle(List<?> list, Random random)`: Uses the provided source of randomness
    (we will talk about such sources in a corresponding section later) to shuffle
    the positions of the elements in the provided list'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void shuffle(List<?> list, Random random)`: 使用提供的随机源（我们将在后面的相应部分讨论这样的源）来打乱提供的列表中元素的位置'
- en: '`void swap(List<?> list, int i, int j)` : Swaps the element at position `i`
    in the provided list with the element at position j'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void swap(List<?> list, int i, int j`): 将提供的列表中位置`i`的元素与位置`j`的元素交换'
- en: Converting to a checked collection
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为已检查的集合
- en: 'The following nine static methods of the class `Collections` convert the provided
    collection from a raw type (one without generics) to a certain type of element.
    The name *checked* implies that after the transformation, the type of each newly
    added element will be checked:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Collections`的以下九个静态方法将提供的集合从原始类型（没有泛型）转换为某种元素类型。名称*checked*意味着转换后，每个新添加的元素的类型都将被检查：
- en: '`Set<E> checkedSet(Set<E> s, Class<E> type)`'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<E> checkedSet(Set<E> s, Class<E> type)`'
- en: '`List<E> checkedList(List<E> list, Class<E> type)`'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<E> checkedList(List<E> list, Class<E> type)`'
- en: '`Queue<E> checkedQueue(Queue<E> queue, Class<E> type)`'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<E> checkedQueue(Queue<E> queue, Class<E> type)`'
- en: '`Collection<E> checkedCollection(Collection<E> collection, Class<E> type)`'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<E> checkedCollection(Collection<E> collection, Class<E> type)`'
- en: '`Map<K,V> checkedMap(Map<K,V> map, Class<K> keyType, Class<V> valueType)`'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V> checkedMap(Map<K,V> map, Class<K> keyType, Class<V> valueType)`'
- en: '`SortedSet<E> checkedSortedSet(SortedSet<E> set, Class<E> type)`'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedSet<E> checkedSortedSet(SortedSet<E> set, Class<E> type)`'
- en: '`NavigableSet<E> checkedNavigableSet(NavigableSet<E> set, Class<E> type)`'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableSet<E> checkedNavigableSet(NavigableSet<E> set, Class<E> type)`'
- en: '`SortedMap<K,V> checkedSortedMap(SortedMap<K,V> map, Class<K> keyType, Class<V>
    valueType)`'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedMap<K,V> checkedSortedMap(SortedMap<K,V> map, Class<K> keyType, Class<V>
    valueType)`'
- en: '`NavigableMap<K,V> checkedNavigableMap(NavigableMap<K,V> map, Class<K> keyType,
    Class<V> valueType)`'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableMap<K,V> checkedNavigableMap(NavigableMap<K,V> map, Class<K> keyType,
    Class<V> valueType)`'
- en: 'Here is the demonstration code:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示代码：
- en: '```java'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: list.add("s1");
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add(42);
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(42);
- en: 'System.out.println(list);    //prints: [s1, s2, 42]'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);    //prints: [s1, s2, 42]'
- en: List cList = Collections.checkedList(list, String.class);
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: List cList = Collections.checkedList(list, String.class);
- en: 'System.out.println(list);   //prints: [s1, s2, 42]'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);   //prints: [s1, s2, 42]'
- en: list.add(42);
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(42);
- en: 'System.out.println(list);   //prints: [s1, s2, 42, 42]'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);   //prints: [s1, s2, 42, 42]'
- en: //cList.add(42);           //throws ClassCastException
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: //cList.add(42);           //throws ClassCastException
- en: '```'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can observe that conversion does not affect the current elements of the
    collection. We have added objects of the `String` class and an object of the `Integer`
    class to the same list and were able to convert it to a checked list `cList` without
    any problem. We can continue adding to the original list objects of different
    types, but the attempt to add a non-String object to the checked list generates
    `ClassCastException` at runtime.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到转换不会影响集合的当前元素。我们已经向同一个列表添加了`String`类的对象和`Integer`类的对象，并且能够将其转换为一个检查过的列表`cList`，没有任何问题。我们可以继续向原始列表添加不同类型的对象，但是尝试向检查过的列表添加非String对象会在运行时生成`ClassCastException`。
- en: Convert to a thread-safe collection
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为线程安全的集合
- en: 'There are eight static methods in the class `Collections` that convert a regular
    collection to a thread-safe one:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Collections`中有八个静态方法，可以将常规集合转换为线程安全的集合：
- en: '`Set<T> synchronizedSet(Set<T> set)`'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<T> synchronizedSet(Set<T> set)`'
- en: '`List<T> synchronizedList(List<T> list)`'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> synchronizedList(List<T> list)`'
- en: '`Map<K,V> synchronizedMap(Map<K,V> map)`'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V> synchronizedMap(Map<K,V> map)`'
- en: '`Collection<T> synchronizedCollection(Collection<T> collection)`'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<T> synchronizedCollection(Collection<T> collection)`'
- en: '`SortedSet<T> synchronizedSortedSet(SortedSet<T> set)`'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedSet<T> synchronizedSortedSet(SortedSet<T> set)`'
- en: '`SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> map)`'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> map)`'
- en: '`NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> set)`'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> set)`'
- en: '`NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> map)`'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> map)`'
- en: A thread-safe collection is constructed so that two application threads can only modify
    it sequentially without stepping on each other's temporary results. But, multithreaded
    processing is outside the scope of this book, so we'll leave it at that.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全的集合是这样构造的，以便两个应用程序线程只能顺序地修改它，而不会互相干扰。但是，多线程处理超出了本书的范围，所以我们就此打住。
- en: Convert to another collection type
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为另一种集合类型
- en: 'The four static methods that convert one type of collection into another include:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 将一种类型的集合转换为另一种类型的四个静态方法包括：
- en: '`ArrayList<T> list(Enumeration<T> e)`'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList<T> list(Enumeration<T> e)`'
- en: '`Enumeration<T> enumeration(Collection<T> c)`'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enumeration<T> enumeration(Collection<T> c)`'
- en: '`Queue<T> asLifoQueue(Deque<T> deque)`'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T> asLifoQueue(Deque<T> deque)`'
- en: '`Set<E> newSetFromMap(Map<E,Boolean> map)`'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<E> newSetFromMap(Map<E,Boolean> map)`'
- en: The interface `java.util.Enumeration` is a legacy interface that came with Java
    1, along with the legacy classes `java.util.Hashtable` and `java.util.Vector` that
    use it. It is very similar to the `Iterator` interface. In fact, an `Enumeration`
    type object can be converted into an `Iterator` type by using the `Enumeration.asIterator()`
    method.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`java.util.Enumeration`是一个遗留接口，它是在Java 1中引入的，与使用它的遗留类`java.util.Hashtable`和`java.util.Vector`一起。它与`Iterator`接口非常相似。实际上，可以使用`Enumeration.asIterator()`方法将`Enumeration`类型对象转换为`Iterator`类型。
- en: All these methods are rarely used in mainstream programming, so we are listing
    them here only for completeness.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法在主流编程中很少使用，所以我们只是为了完整性而在这里列出它们。
- en: Create enumeration and iterator
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建枚举和迭代器
- en: 'The following are also not-often-used static methods that allow the creation
    of an empty `Enumeration`, `Iterator`, and `ListIterator` - all are interfaces
    of the `java.util` package:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是不经常使用的静态方法，允许创建一个空的`Enumeration`，`Iterator`和`ListIterator` - 都是`java.util`包的接口：
- en: '`Iterator<T> empty iterator``()`'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator<T> empty iterator``()`'
- en: '`ListIterator<T> emptyListIterator()`'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListIterator<T> emptyListIterator()`'
- en: '`Enumeration<T> emptyEnumeration()`'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enumeration<T> emptyEnumeration()`'
- en: Class collections4.CollectionUtils
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Class collections4.CollectionUtils
- en: 'The class `org.apache.commons.collections4.CollectionUtils` in the Apache Commons
    project contains static stateless methods that compliment the methods of the class
    `java.util.Collections`. They help to search, process, and compare Java collections.
    To use this class, you would need to add the following dependency to the Maven
    configuration file `pom.xml`:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Commons项目中的`org.apache.commons.collections4.CollectionUtils`类包含了与`java.util.Collections`类的方法相辅相成的静态无状态方法。它们有助于搜索、处理和比较Java集合。要使用这个类，您需要将以下依赖项添加到Maven配置文件`pom.xml`中：
- en: '```java'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: <dependency>
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: <dependency>
- en: <groupId>org.apache.commons</groupId>
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: <groupId>org.apache.commons</groupId>
- en: <artifactId>commons-collections4</artifactId>
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: <artifactId>commons-collections4</artifactId>
- en: <version>4.1</version>
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: <version>4.1</version>
- en: </dependency>
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: </dependency>
- en: '```'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There are many methods in this class, and more methods will probably be added
    over time. The just-reviewed `Collections` class will probably cover most of your
    needs, especially when you are just entering the field of Java programming. So,
    we are not going to spend time on explaining the purpose of each method, as we
    have done for the `Collections` class. Besides, the methods of `CollectionUtils`
    are created in addition to the methods of `Collections`, so they are more complex
    and nuanced and do not fit the scope of this book.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中有很多方法，而且随着时间的推移，可能会添加更多的方法。刚刚审查的`Collections`类可能会涵盖大部分您的需求，特别是当您刚刚进入Java编程领域时。因此，我们不会花时间解释每个方法的目的，就像我们为`Collections`类所做的那样。此外，`CollectionUtils`的方法是作为`Collections`方法的补充而创建的，因此它们更加复杂和微妙，不适合本书的范围。
- en: 'To give you an idea of the methods available in the class `CollectionUtils`,
    we have grouped them by related functionality:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解`CollectionUtils`类中可用的方法，我们将它们按相关功能进行了分组：
- en: 'Methods that retrieve an element:'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索元素的方法：
- en: '`Object get(Object object, int index)`'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object get(Object object, int index)`'
- en: '`Map.Entry<K,V> get(Map<K,V> map, int index)`'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.Entry<K,V> get(Map<K,V> map, int index)`'
- en: '`Map<O,Integer> getCardinalityMap(Iterable<O> collection)`'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<O,Integer> getCardinalityMap(Iterable<O> collection)`'
- en: 'Methods that add an element or a group of elements to a collection:'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加元素或一组元素到集合的方法：
- en: '`boolean addAll(Collection<C> collection, C[] elements)`'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addAll(Collection<C> collection, C[] elements)`'
- en: '`boolean addIgnoreNull(Collection<T> collection, T object)`'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addIgnoreNull(Collection<T> collection, T object)`'
- en: '`boolean addAll(Collection<C> collection, Iterable<C> iterable)`'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addAll(Collection<C> collection, Iterable<C> iterable)`'
- en: '`boolean addAll(Collection<C> collection, Iterator<C> iterator)`'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addAll(Collection<C> collection, Iterator<C> iterator)`'
- en: '`boolean addAll(Collection<C> collection, Enumeration<C> enumeration)`'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean addAll(Collection<C> collection, Enumeration<C> enumeration)`'
- en: 'Methods that merge `Iterable` elements:'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并`Iterable`元素的方法：
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b)`'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<O> collate(Iterable<O> a, Iterable<O> b)`'
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c)`'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c)`'
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, boolean includeDuplicates)`'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<O> collate(Iterable<O> a, Iterable<O> b, boolean includeDuplicates)`'
- en: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c, boolean includeDuplicates)`'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<O> collate(Iterable<O> a, Iterable<O> b, Comparator<O> c, boolean includeDuplicates)`'
- en: 'Methods that remove or retain elements with or without criteria:'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或保留具有或不具有标准的元素的方法：
- en: '`Collection<O> subtract(Iterable<O> a, Iterable<O> b)`'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> subtract(Iterable<O> a, Iterable<O> b)`'
- en: '``Collection<O> subtract(Iterable<O> a, Iterable<O> b, Predicate<O> p)``'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``Collection<O> subtract(Iterable<O> a, Iterable<O> b, Predicate<O> p)``'
- en: '`Collection<E> removeAll(Collection<E> collection, Collection<?> remove)`'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<E> removeAll(Collection<E> collection, Collection<?> remove)`'
- en: '`Collection<E> removeAll(Iterable<E> collection, Iterable<E> remove, Equator<E>
    equator)`'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<E> removeAll(Iterable<E> collection, Iterable<E> remove, Equator<E>
    equator)`'
- en: '`Collection<C> retainAll(Collection<C> collection, Collection<?> retain)`'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<C> retainAll(Collection<C> collection, Collection<?> retain)`'
- en: '`Collection<E> retainAll(Iterable<E> collection, Iterable<E> retain, Equator<E>
    equator)`'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<E> retainAll(Iterable<E> collection, Iterable<E> retain, Equator<E>
    equator)`'
- en: 'Methods that compare two collections:'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个集合的方法：
- en: '`boolean containsAll(Collection<?> coll1, Collection<?> coll2)`'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean containsAll(Collection<?> coll1, Collection<?> coll2)`'
- en: '`boolean containsAny(Collection<?> coll1, Collection<?> coll2)`'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean containsAny(Collection<?> coll1, Collection<?> coll2)`'
- en: '`boolean isEqualCollection(Collection<?> a, Collection<?> b)`'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEqualCollection(Collection<?> a, Collection<?> b)`'
- en: '`boolean isEqualCollection(Collection<E> a, Collection<E> b, Equator<E> equator)`'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEqualCollection(Collection<E> a, Collection<E> b, Equator<E> equator)`'
- en: '`boolean isProperSubCollection(Collection<?> a, Collection<?> b)`'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isProperSubCollection(Collection<?> a, Collection<?> b)`'
- en: 'Methods that transform a collection:'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换集合的方法：
- en: '`Collection<List<E>> permutations(Collection<E> collection)`'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<List<E>> permutations(Collection<E> collection)`'
- en: '`void transform(Collection<C> collection, Transformer<C,C> transformer)`'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void transform(Collection<C> collection, Transformer<C,C> transformer)`'
- en: '`Collection<E> transformingCollection(Collection<E> collection, Transformer<E,E>
    transformer)`'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<E> transformingCollection(Collection<E> collection, Transformer<E,E>
    transformer)`'
- en: '`Collection<O> collect(Iterator<I> inputIterator, Transformer<I,O> transformer)`'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> collect(Iterator<I> inputIterator, Transformer<I,O> transformer)`'
- en: '`Collection<O> collect(Iterable<I> inputCollection, Transformer<I,O> transformer)`'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> collect(Iterable<I> inputCollection, Transformer<I,O> transformer)`'
- en: '`Collection<O> R collect(Iterator<I> inputIterator, Transformer<I,O> transformer,
    R outputCollection)`'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> R collect(Iterator<I> inputIterator, Transformer<I,O> transformer,
    R outputCollection)`'
- en: '`Collection<O> R collect(Iterable<I> inputCollection, Transformer<I,O> transformer,
    R outputCollection)`'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> R collect(Iterable<I> inputCollection, Transformer<I,O> transformer,
    R outputCollection)`'
- en: 'Methods that select and filter a collection:'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和过滤集合的方法：
- en: '``Collection<O> select(Iterable<O> inputCollection, Predicate<O> predicate)``'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``Collection<O> select(Iterable<O> inputCollection, Predicate<O> predicate)``'
- en: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
- en: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection, R rejectedCollection)`'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> R select(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection, R rejectedCollection)`'
- en: '`Collection<O> selectRejected(Iterable<O> inputCollection, Predicate<O> predicate)`,'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> selectRejected(Iterable<O> inputCollection, Predicate<O> predicate)`'
- en: '`Collection<O> R selectRejected(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> R selectRejected(Iterable<O> inputCollection, Predicate<O> predicate,
    R outputCollection)`'
- en: '`E extractSingleton(Collection<E> collection)`'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E extractSingleton(Collection<E> collection)`'
- en: '`boolean filter(Iterable<T> collection, Predicate<T> predicate)`'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean filter(Iterable<T> collection, Predicate<T> predicate)`'
- en: '`boolean filterInverse(Iterable<T> collection, Predicate<T> predicate)`'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean filterInverse(Iterable<T> collection, Predicate<T> predicate)`'
- en: '`Collection<C> predicatedCollection(Collection<C> collection, Predicate<C>
    predicate)`'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<C> predicatedCollection(Collection<C> collection, Predicate<C>
    predicate)`'
- en: 'Methods that generate a union, an intersection, or a difference of two collections:'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成两个集合的并集、交集或差集的方法：
- en: '`Collection<O> union(Iterable<O> a, Iterable<O> b)`'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> union(Iterable<O> a, Iterable<O> b)`'
- en: '`Collection<O> disjunction(Iterable<O> a, Iterable<O> b)`'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> disjunction(Iterable<O> a, Iterable<O> b)`'
- en: '`Collection<O> intersection(Iterable<O> a, Iterable<O> b)`'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<O> intersection(Iterable<O> a, Iterable<O> b)`'
- en: 'Methods that create an immutable empty collection:'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不可变空集合的方法：
- en: '`<T> Collection<T> emptyCollection()`'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Collection<T> emptyCollection()`'
- en: '`Collection<T> emptyIfNull(Collection<T> collection)`'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<T> emptyIfNull(Collection<T> collection)`'
- en: 'Methods that check collection size and emptiness:'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查集合大小和是否为空的方法：
- en: '`int size(Object object)`'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int size(Object object)`'
- en: '`boolean sizeIsEmpty(Object object)`'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean sizeIsEmpty(Object object)`'
- en: '`int maxSize(Collection<Object> coll)`'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int maxSize(Collection<Object> coll)`'
- en: '`boolean isEmpty(Collection<?> coll)`'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isEmpty(Collection<?> coll)`'
- en: '`boolean isNotEmpty(Collection<?> coll)`'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isNotEmpty(Collection<?> coll)`'
- en: '`boolean isFull(Collection<Object> coll)`'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isFull(Collection<Object> coll)`'
- en: 'Method that reverses an array:'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转数组的方法：
- en: '`void reverseArray(Object[] array)`'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void reverseArray(Object[] array)`'
- en: This last method should probably belong to the utility class that handles arrays,
    and that is what we are going to discuss now.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的方法可能应该属于处理数组的实用类，这就是我们现在要讨论的内容。
- en: Manage arrays
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数组
- en: In this section, we will review how array objects can be created and initialized,
    and where you can find methods that allow us to perform some operations over arrays—copy,
    sort, and compare, for example.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何创建和初始化数组对象，以及在哪里可以找到允许我们对数组执行一些操作的方法——例如复制、排序和比较。
- en: Although arrays have their place in some algorithms and legacy code, in practice
    an `ArrayList()` can do everything an array can do and does not require setting
    the size upfront. In fact, an `ArrayList` is using an array to store its elements
    at the back. So, the performance of an array and `ArrayList` is comparable too.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组在一些算法和旧代码中有它们的用武之地，但在实践中，`ArrayList()`可以做任何数组可以做的事情，并且不需要提前设置大小。事实上，`ArrayList`也使用数组来存储其元素。因此，数组和`ArrayList`的性能也是可比较的。
- en: So, we are not going to discuss array management too much beyond the basics
    of creation and initialization. We will provide a short overview and references
    on where to find the array utility methods in case you need them.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不打算过多地讨论数组管理，只是基本的创建和初始化。我们将提供一个简短的概述和参考资料，告诉您在哪里可以找到数组实用方法，以防您需要它们。
- en: Initialize arrays
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化数组
- en: We have seen already a few examples of array construction. Now, we are going
    to review them and present other ways to create and initialize array objects.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些数组构造的例子。现在，我们将回顾它们并介绍创建和初始化数组对象的其他方法。
- en: Creation expression
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表达式
- en: 'An array creation expression includes:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 数组创建表达式包括：
- en: The array element type
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组元素类型
- en: The number of levels of nested arrays
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套数组的级数
- en: The length of the array for at least the first of the levels
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少在第一级上的数组长度
- en: 'Here are one-level array creation examples:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一级数组创建示例：
- en: '```java'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] ints = new int[10];
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: int[] ints = new int[10];
- en: 'System.out.println(ints[0]);     //prints: 0'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(ints[0]);     //输出：0
- en: Integer[] intW = new Integer[10];
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[] intW = new Integer[10];
- en: 'System.out.println(intW[0]);     //prints: null'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(intW[0]);     //输出：null
- en: boolean[] bs = new boolean[10];
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: boolean[] bs = new boolean[10];
- en: 'System.out.println(bs[0]);       //prints: false'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(bs[0]);       //输出：false
- en: Boolean[] bW = new Boolean[10];
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: Boolean[] bW = new Boolean[10];
- en: 'System.out.println(bW[0]);       //prints: 0'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(bW[0]);       //输出：0
- en: String[] strings = new String[10];
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: String[] strings = new String[10];
- en: 'System.out.println(strings[0]);  //prints: null'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(strings[0]);  //输出：null
- en: A[] as = new A[10];
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: A[] as = new A[10];
- en: 'System.out.println(as[0]);       //prints: null'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(as[0]);       //输出：null
- en: 'System.out.println(as.length);   //prints: 10'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(as.length);   //输出：10
- en: '```'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As we have shown in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*, every Java type has a default initialization value,
    used during object creation when no value is assigned explicitly. Because an array
    is a class, its elements are initialized—like the instance fields of any class
    - even if a programmer does not assign values to them explicitly. The numeral
    primitive types have a default value of 0, and the `boolean` primitive type `false`,
    while all reference types have the default value `null`. The class `A` used in
    the previous example is defined as `class A {}`. And the length of the array is
    captured in the final public property, `length`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中所展示的，*Java语言元素和类型*，每种Java类型都有一个默认的初始化值，在对象创建时使用，当没有明确分配值时。因为数组是一个类，它的元素被初始化——就像任何类的实例字段一样——即使程序员没有明确地为它们分配值。数字原始类型的默认值为0，布尔原始类型为false，而所有引用类型的默认值为null。在前面的示例中使用的类A被定义为`class
    A {}`。数组的长度被捕获在最终的公共属性`length`中。
- en: 'The multi-level nested initialization looks as follows:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 多级嵌套初始化如下所示：
- en: '```java'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: //A[][] as2 = new A[][10];             //compilation error
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: //A[][] as2 = new A[][10];             //编译错误
- en: A[][] as2 = new A[10][];
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: A[][] as2 = new A[10][];
- en: 'System.out.println(as2.length);        //prints: 10'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(as2.length);        //输出：10
- en: 'System.out.println(as2[0]);            //prints: null'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(as2[0]);            //输出：null
- en: //System.out.println(as2[0].length);   //NullPointerException
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(as2[0].length);   //NullPointerException
- en: //System.out.println(as2[0][0]);       //NullPointerException
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(as2[0][0]);       //NullPointerException
- en: as2 = new A[2][3];
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: as2 = new A[2][3];
- en: 'System.out.println(as2[0]); //prints: ManageArrays$A;@282ba1e'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(as2[0]); //prints: ManageArrays$A;@282ba1e'
- en: 'System.out.println(as2[0].length); //prints: 3'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(as2[0].length); //prints: 3'
- en: 'System.out.println(as2[0][0]);     //prints: null'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(as2[0][0]);     //prints: null'
- en: '```'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first thing to notice is that an attempt to create an array without defining
    the length of the first-level array generates a compilation error. The second
    observation is that the `length` property of the multi-level array captures the
    length of the array of the first (top) level. The third is that every element
    of the top-level array is an array. The elements of the next-level array are also
    arrays if that is not the last level.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，尝试创建一个没有定义第一级数组长度的数组会生成编译错误。第二个观察是多级数组的`length`属性捕获了第一（顶级）级数组的长度。第三个是顶级数组的每个元素都是一个数组。如果不是最后一级，下一级数组的元素也是数组。
- en: In our previous example, we did not set the second-level array length, so each
    element of the top-level array was initialized to `null` because that is the default
    value of any reference type (and an array is a reference type too). That is why
    an attempt to get the length or any value of the second-level array generated
    `NullPointerException`.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们没有设置第二级数组的长度，因此顶级数组的每个元素都被初始化为`null`，因为这是任何引用类型的默认值（数组也是引用类型）。这就是为什么尝试获取第二级数组的长度或任何值会生成`NullPointerException`。
- en: 'As soon as we set the length of the second-level array to three, we were able
    to get its length and the value of its first element (`null` because that is the
    default value). The strange printout `ManageArrays$A;@282ba1e` is the array binary
    reference because the object array does not have a `toString()` method implemented.
    The closest you can get is a static method, `toString()`, of the utility class
    `java.util.Arrays` (see the next section). It returns a `String` representation
    of all array elements:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将第二级数组的长度设置为三，我们就能够得到它的长度和第一个元素的值（`null`，因为这是默认值）。奇怪的打印`ManageArrays$A;@282ba1e`是数组二进制引用，因为对象数组没有实现`toString()`方法。您可以得到的最接近的是实用类`java.util.Arrays`的静态方法`toString()`（请参见下一节）。它返回所有数组元素的`String`表示：
- en: '```java'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Arrays.toString(as2));
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Arrays.toString(as2));
- en: '//prints: [[ManageArrays$A;@282ba1e, [ManageArrays$A;@13b6d03]'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: [[ManageArrays$A;@282ba1e, [ManageArrays$A;@13b6d03]'
- en: System.out.println(Arrays.toString(as2[0])); //[null, null, null]
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Arrays.toString(as2[0])); //[null, null, null]
- en: '```'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It works just fine for the last (the deepest) nested array, but still prints
    a binary reference for the higher-level arrays. If you want to print out all the
    elements of all the nested arrays, use the `Arrays.deepToString(Object[])` method:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后（最深层）嵌套的数组，它可以正常工作，但对于更高级别的数组仍然打印二进制引用。如果要打印所有嵌套数组的所有元素，请使用`Arrays.deepToString(Object[])`方法：
- en: '```java'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: System.out.println(Arrays.deepToString(as2));
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Arrays.deepToString(as2));
- en: '//the above prints: [[null, null, null], [null, null, null]]'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: //上面的打印：[[null, null, null], [null, null, null]]
- en: '```'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Please note that if array elements do not implement the `toString()` method,
    then the binary reference will be printed for those elements that are not `null`.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果数组元素没有实现`toString()`方法，则对于那些不是`null`的元素，将打印二进制引用。
- en: Array initializer
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组初始化程序
- en: 'An array initializer consists of a comma-separated list of expressions, enclosed
    in braces `{}`. The comma after the last expression is allowed and ignored:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 数组初始化程序由逗号分隔的表达式列表组成，括在大括号`{}`中。允许并忽略最后一个表达式后面的逗号：
- en: '```java'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String[] arr = {"s0", "s1", };
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = {"s0", "s1", };
- en: 'System.out.println(Arrays.toString(arr)); //prints: [s0, s1]'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr)); //prints: [s0, s1]'
- en: '```'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We often use this way of initializing an array in our examples because it is
    the most compact way to do it.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在示例中使用这种初始化数组的方式，因为这是最紧凑的方式。
- en: Static initialization block
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态初始化块
- en: 'As in the case of collections too, a static block can be used to initialize
    an array static property when some code has to be executed:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一样，当需要执行一些代码时，可以使用静态块来初始化数组静态属性：
- en: '```java'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ManageArrays {
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 类ManageArrays {
- en: private static A[] AS_STATIC;
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: private static A[] AS_STATIC;
- en: static {
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: static {
- en: AS_STATIC = new A[2];
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: AS_STATIC = new A[2];
- en: for(int i = 0; i< AS_STATIC.length; i++){
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i< AS_STATIC.length; i++){
- en: AS_STATIC[i] = new A();
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: AS_STATIC[i] = new A();
- en: '}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: AS_STATIC[0] = new A();
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: AS_STATIC[0] = new A();
- en: AS_STATIC[1] = new A();
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: AS_STATIC[1] = new A();
- en: '}'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... the rest of class code goes here
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: //...类代码的其余部分在这里
- en: '}'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The code in the static block is executed every time a class is loaded, even
    before the constructor is called. But if the field is not static, the same initialization
    code can be placed in the constructor:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 静态块中的代码在每次加载类时都会执行，甚至在调用构造函数之前。但是，如果字段不是静态的，则可以将相同的初始化代码放在构造函数中：
- en: '```java'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ManageArrays {
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 类ManageArrays {
- en: private A[] as;
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: private A[] as;
- en: public ManageArrays(){
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: public ManageArrays(){
- en: as = new A[2];
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: as = new A[2];
- en: for(int i = 0; i< as.length; i++){
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i< as.length; i++){
- en: as[i] = new A();
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: as[i] = new A();
- en: '}'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: as[0] = new A();
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: as[0] = new A();
- en: as[1] = new A();
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: as[1] = new A();
- en: '}'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //the reat of class code goes here
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: //类代码的其余部分在这里
- en: '}'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: From collection
  id: totrans-831
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从收集
- en: 'If there is a collection that can be used as the source for the array values,
    it has the method `toArray()`, which can be called as follows:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个可以用作数组值源的集合，它有一个`toArray()`方法，可以按如下方式调用：
- en: '```java'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> list = List.of(0, 1, 2, 3);
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list = List.of(0, 1, 2, 3);
- en: Integer[] arr1 = list.toArray(new Integer[list.size()]);
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[] arr1 = list.toArray(new Integer[list.size()]);
- en: 'System.out.println(Arrays.toString(arr1)); //prints: [0, 1, 2, 3]'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr1)); //prints: [0, 1, 2, 3]'
- en: '```'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Other possible methods
  id: totrans-838
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他可能的方法
- en: 'In a different context, there may be some other methods used to create and
    initialize an array. It is also a matter of the style you prefer. Here are examples
    of the variety of array creation and initialization methods you can choose from:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的上下文中，可能会使用一些其他方法来创建和初始化数组。这也是你喜欢的风格问题。以下是您可以选择的各种数组创建和初始化方法的示例：
- en: '```java'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String[] arr2 = new String[3];
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr2 = new String[3];
- en: Arrays.fill(arr2, "s");
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.fill(arr2, "s");
- en: 'System.out.println(Arrays.toString(arr2));      //prints: [s, s, s]'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr2));      //prints: [s, s, s]'
- en: String[] arr3 = new String[5];
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: arr3 = new String[5];
- en: Arrays.fill(arr3, 2, 3, "s");
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.fill(arr3, 2, 3, "s");
- en: System.out.println(Arrays.toString(arr3));
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Arrays.toString(arr3));
- en: '//prints: [null, null, s, null, null]'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: [null, null, s, null, null]'
- en: String[] arr4 = {"s0", "s1", };
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr4 = {"s0", "s1", };
- en: String[] arr4Copy = Arrays.copyOf(arr4, 5);
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr4Copy = Arrays.copyOf(arr4, 5);
- en: System.out.println(Arrays.toString(arr4Copy));
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Arrays.toString(arr4Copy));
- en: '//prints: [s0, s1, null, null, null]'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: [s0, s1, null, null, null]'
- en: String[] arr5 = {"s0", "s1", "s2", "s3", "s4" };
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr5 = {"s0", "s1", "s2", "s3", "s4" };
- en: String[] arr5Copy = Arrays.copyOfRange(arr5, 1, 3);
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr5Copy = Arrays.copyOfRange(arr5, 1, 3);
- en: 'System.out.println(Arrays.toString(arr5Copy));    //prints: [s1, s2]'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr5Copy));    //prints: [s1, s2]'
- en: Integer[] arr6 = {0, 1, 2, 3, 4 };
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[] arr6 = {0, 1, 2, 3, 4 };
- en: Object[] arr6Copy = Arrays.copyOfRange(arr6,1, 3, Object[].class);
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] arr6Copy = Arrays.copyOfRange(arr6,1, 3, Object[].class);
- en: 'System.out.println(Arrays.toString(arr6Copy));      //prints: [1, 2]'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr6Copy));      //prints: [1, 2]'
- en: String[] arr7 = Stream.of("s0", "s1", "s2").toArray(String[]::new);
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr7 = Stream.of("s0", "s1", "s2").toArray(String[]::new);
- en: 'System.out.println(Arrays.toString(arr7));    //prints: [s0, s1, s2]'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.toString(arr7));    //prints: [s0, s1, s2]'
- en: '```'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Out of six examples above, five used the class `java.util.Arrays` (see the next
    section) to fill or copy an array. And all of them used the method `Arrays.toString()`
    to print elements of the resulting array.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的六个例子中，有五个使用了`java.util.Arrays`类（见下一节）来填充或复制数组。所有这些例子都使用了`Arrays.toString()`方法来打印结果数组的元素。
- en: The first example assigns to all the elements of an array `arr2` values `s`.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子为数组`arr2`的所有元素分配了值`s`。
- en: The second example assigns the value `s` only to the elements from index 2 to
    index 3\. Notice that the second index is not inclusive. That's why only one element
    of an array `arr3` is assigned the value.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子仅为索引2到索引3的元素分配了值`s`。请注意，第二个索引不包括在内。这就是为什么数组`arr3`的一个元素被赋予了值。
- en: The third example copies the `arr4` array and makes the new array longer in
    size. That is why the rest of the new array elements are initialized to the default
    value of `String`, which is `null`. Notice that we have put a trailing comma in
    the `arr4` array initializer to demonstrate that it is allowed and ignored. It
    does not look like a very important feature. We have pointed it out just in case
    you see it in other people's code and wonder how it works.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子复制了`arr4`数组，并使新数组的大小更长。这就是为什么新数组的其余元素被初始化为`String`的默认值，即`null`。请注意，我们在`arr4`数组初始化器中放置了一个尾随逗号，以演示它是允许的并被忽略的。这看起来不像是一个非常重要的特性。我们只是提出来，以防你在其他人的代码中看到它并想知道它是如何工作的。
- en: The fourth example creates a copy of an array using its elements from index
    1 to 3\. Again, the second index is not included, so only two elements are copied.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个例子使用其元素从索引1到3创建了一个数组的副本。再次强调，第二个索引不包括在内，因此只复制了两个元素。
- en: The fifth example not only creates a copy of the range of the elements but also
    converts them to the `Object` type, which is possible because the source array
    is of reference type.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个例子不仅创建了元素范围的副本，还将它们转换为`Object`类型，这是可能的，因为源数组是引用类型。
- en: And the last example is using the `Stream` class, which we are going to discuss
    in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子使用了`Stream`类，我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中讨论*流和管道*。
- en: Class java.util.Arrays
  id: totrans-868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类java.util.Arrays
- en: 'We have used the class `java.util.Arrays` already several times. It is the
    primary tool for array management. But, it used to be very popular with those
    who use collections too because the method `asList(T...a)` was the most compact
    way of creating and initializing a collection:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用了`java.util.Arrays`类。它是数组管理的主要工具。但是，它曾经非常受到那些使用集合的人的欢迎，因为`asList(T...a)`方法是创建和初始化集合的最紧凑的方法：
- en: '```java'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = Arrays.asList("s0", "s1");
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = Arrays.asList("s0", "s1");
- en: Set<String> set = new HashSet<>(Arrays.asList("s0", "s1");
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>(Arrays.asList("s0", "s1");
- en: '```'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But after a factory method, `of()`, was introduced in each of the collections,
    the popularity of the `Arrays` class dropped substantially. The following is a
    more natural way to create a collection:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在每个集合中引入了`of()`工厂方法之后，`Arrays`类的流行度大大下降。以下是创建集合的更自然的方法：
- en: '```java'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("s0", "s1");
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("s0", "s1");
- en: Set<String> set = Set.of("s0", "s1");
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = Set.of("s0", "s1");
- en: '```'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This collection''s objects are immutable. But if a mutable one is needed, it
    can be created as follows:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合的对象是不可变的。但是，如果需要一个可变的集合，可以按照以下方式创建：
- en: '```java'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>(List.of("s0", "s1"));
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>(List.of("s0", "s1"));
- en: Set<String> set1 = new HashSet<>(list);
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set1 = new HashSet<>(list);
- en: Set<String> set2 = new HashSet<>(Set.of("s0", "s1"));
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set2 = new HashSet<>(Set.of("s0", "s1"));
- en: '```'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We talked about this in great detail in the *Manage collections* section previously.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在*管理集合*部分详细讨论过这个问题。
- en: 'But if your code manages arrays, then you definitely need to use the class
    `Arrays`. It contains more than 160 methods. Most of them are overloaded with
    different parameters and array types. If we group them by method name, there will
    be 21 groups. And if we group them further by functionality, only the following
    10 groups will cover all the `Arrays` class''s functionalities:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您的代码管理数组，那么您肯定需要使用`Arrays`类。它包含了160多种方法。其中大多数都是使用不同参数和数组类型进行重载。如果我们按方法名称对它们进行分组，将会有21组。如果我们进一步按功能对它们进行分组，只有以下10组将涵盖所有`Arrays`类的功能：
- en: '`asList()`: Creates an `ArrayList` object based on the provided array (see
    examples in the previous section)'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asList()`: 基于提供的数组创建一个`ArrayList`对象（请参见上一节中的示例）'
- en: '`binarySearch()`: Allows the searching of an array or just a part of it specified
    (by the range of indices)'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binarySearch()`: 允许搜索数组或其部分（由索引范围指定）'
- en: '`compare()`, `mismatch()`, `equals()`, and `deepEquals()`: Compare two arrays
    or their parts (by the range of indices)'
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare()`, `mismatch()`, `equals()`, and `deepEquals()`: 比较两个数组或它们的部分（由索引范围）'
- en: '`copyOf()` and `copyOfRange()`: Copy all arrays or just a part of them (by
    the range of indices)'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copyOf()` and `copyOfRange()`: 复制所有数组或其中的一部分（由索引范围）'
- en: '`hashcode()` and `deepHashCode()`: Generate a hash code value based on the
    provided array content'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashcode()` and `deepHashCode()`: 根据提供的数组内容生成哈希码值'
- en: '`toString()` and `deepToString()`: Create a `String` representation of an array
    (see examples in the previous section)'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()` and `deepToString()`: 创建数组的`String`表示（请参见上一节中的示例）'
- en: '`fill()`, `setAll()`, `parallelPrefix()`, and `parallelSetAll()`: Set the value
    (fixed or generated by the provided function) of every element of an array or those
    specified by the range of indices'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill()`, `setAll()`, `parallelPrefix()`, and `parallelSetAll()`: 设置数组的每个元素的值（由提供的函数生成的固定值或值）或由索引范围指定的元素的值'
- en: '`sort()` and `parallelSort()`: Sort elements of an array or only part of it
    (specified by the range of indices)'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()` and `parallelSort()`: 对数组的元素进行排序或仅对部分元素进行排序（由索引范围指定）'
- en: '`splititerator()`: Returns a `Splititerator` object for parallel processing
    of an array or part of it (specified by the range of indices)'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splititerator()`: 返回用于并行处理数组或其部分（由索引范围指定）的`Splititerator`对象'
- en: '`stream()`: Generates a stream of array elements or some of them (specified
    by the range of indices); see [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and pipelines*'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream()`: 生成数组元素或其中一些元素的流（由索引范围指定）；请参见[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)，*流和管道*'
- en: All of these methods are helpful, but we would like to attract your attention
    to the `equals(a1, a2)` and `deepEquals(a1, a2)` methods. They are particularly
    helpful for array comparison because an array object does not allow to implement
    a custom method `equals(a)` and thus always uses the implementation of the class
    `Object` that compares only references.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都很有用，但我们想要吸引您注意的是`equals(a1, a2)`和`deepEquals(a1, a2)`方法。它们对于数组比较特别有帮助，因为数组对象不允许实现自定义方法`equals(a)`，因此总是使用类`Object`的实现来比较只有引用。
- en: 'By contrast, both `equals(a1, a2)` and `deepEquals(a1, a2)` methods compare
    not just references `a1` and `a2`, but, in the case of arrays, use the method
    `equals(a)` to compare elements. This means that non-nested arrays are compared
    by values of their elements and considered equal when either both arrays are `null`
    or they have equal length and the method `a1[i].equals(a2[i])` returns `true`
    for each index:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`equals(a1, a2)`和`deepEquals(a1, a2)`方法不仅比较引用`a1`和`a2`，而且在数组的情况下使用`equals(a)`方法来比较元素。这意味着非嵌套数组是通过它们的元素的值进行比较的，并且当两个数组都为`null`或它们的长度相等且方法`a1[i].equals(a2[i])`对于每个索引返回`true`时被认为是相等的：
- en: '```java'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Integer[] as1 = {1,2,3};
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[] as1 = {1,2,3};
- en: Integer[] as2 = {1,2,3};
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[] as2 = {1,2,3};
- en: 'System.out.println(as1.equals(as2));               //prints: false'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(as1.equals(as2));               //prints: false'
- en: 'System.out.println(Arrays.equals(as1, as2));       //prints: true'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.equals(as1, as2));       //prints: true'
- en: 'System.out.println(Arrays.deepEquals(as1, as2));   //prints: true'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.deepEquals(as1, as2));   //prints: true'
- en: '```'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As for nested arrays, the `equals(a1, a2)` method uses the method `equals(a)`
    to compare elements of the next level. But the elements of the nested array are
    arrays, so they are compared by reference only, not by the value of their elements.
    If you need to compare values of the elements on all nested levels, use the method `deepEquals(a1,
    a2)`:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套数组，`equals(a1, a2)`方法使用`equals(a)`方法来比较下一级的元素。但是嵌套数组的元素是数组，因此它们仅通过引用而不是它们的元素的值进行比较。如果需要比较所有嵌套级别上的元素的值，请使用方法`deepEquals(a1,
    a2)`：
- en: '```java'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Integer[][] aas1 = {{1,2,3}, {4,5,6}};
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 整数[][] aas1 = {{1,2,3}, {4,5,6}};
- en: Integer[][] aas2 = {{1,2,3}, {4,5,6}};
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[][] aas2 = {{1,2,3}, {4,5,6}};
- en: 'System.out.println(Arrays.equals(aas1, aas2));       //prints: false'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.equals(aas1, aas2));       //prints: false'
- en: 'System.out.println(Arrays.deepEquals(aas1, aas2));   //prints: true'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.deepEquals(aas1, aas2));   //prints: true'
- en: Integer[][][] aaas1 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[][][] aaas1 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
- en: Integer[][][] aaas2 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Integer[][][] aaas2 = {{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}};
- en: 'System.out.println(Arrays.deepEquals(aaas1, aaas2)); //prints: true'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(Arrays.deepEquals(aaas1, aaas2)); //prints: true'
- en: '```'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Class lang3.ArrayUtils
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Class lang3.ArrayUtils
- en: The class `org.apache.commons.lang3.ArrayUtils` is a compliment to the class
    `java.util.Arrays`. It adds new methods to the array managing toolkit and the
    ability to handle `null` in cases when otherwise `NullPointerException` could
    be thrown.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 类`org.apache.commons.lang3.ArrayUtils`是类`java.util.Arrays`的补充。它为数组管理工具包添加了新的方法，并能够在否则会抛出`NullPointerException`的情况下处理`null`。
- en: 'Similarly to the`Arrays` class , the `ArrayUtils` class has many (around 300)
    overloaded methods that can be collected into 12 groups:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Arrays`类类似，`ArrayUtils`类有许多（大约300个）重载方法，可以分为12组：
- en: '`add()`, `addAll()`, and `insert()`: Add elements to an array'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`, `addAll()`, and `insert()`: 向数组添加元素'
- en: '`clone()`: Clones an array, similar to the method `copyOf()` in  `java.util.Arrays` and
    the method `arraycopy()` of `java.lang.System`'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`: 克隆数组，类似于`java.util.Arrays`中的`copyOf()`方法和`java.lang.System`的`arraycopy()`方法'
- en: '`getLength()`: Returns an array length and handles `null` (while the attempt
    to read the property `length` when an array is `null` throws `NullPointerException`)'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLength()`: 返回数组长度并处理`null`（当数组为`null`时，尝试读取属性`length`会抛出`NullPointerException`）'
- en: '`hashCode()`: Calculates the hash value of an array, including nested arrays'
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()`：计算数组的哈希值，包括嵌套数组'
- en: '`contains()`, `indexOf()`, and `lastIndexOf()`: Search an array'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains()`、`indexOf()`和`lastIndexOf()`：搜索数组'
- en: '`isSorted()`,  `isEmpty`, and `isNotEmpty()`: Check an array and handle `null`'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSorted()`、`isEmpty`和`isNotEmpty()`：检查数组并处理`null`'
- en: '`isSameLength()` and `isSameType()`: Compare arrays'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSameLength()`和`isSameType()`：比较数组'
- en: '`nullToEmpty()`: Converts a `null` array to an empty one'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullToEmpty()`: 将`null`数组转换为空数组'
- en: '`remove()`, `removeAll()`, `removeElement()`, `removeElements()`, and `removeAllOccurances()`:
    Remove elements'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`、`removeAll()`、`removeElement()`、`removeElements()`和`removeAllOccurances()`：移除元素'
- en: '`reverse()`, `shift()`, `shuffle()`, and `swap()`: Change the order of array
    elements'
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()`、`shift()`、`shuffle()`和`swap()`：改变数组元素的顺序'
- en: '`subarray()`: Extracts part of an array by the range of indices'
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subarray()`: 通过索引范围提取数组的一部分'
- en: '`toMap()`, `toObject()`, `toPrimitive()`, `toString()`, and `toStringArray()`:
    Convert an array to another type and handle `null` values'
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toMap()`、`toObject()`、`toPrimitive()`、`toString()`和`toStringArray()`：将数组转换为另一种类型并处理`null`值'
- en: Exercise – Sort list of objects
  id: totrans-931
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习- 对对象列表进行排序
- en: Name two methods that allow sorting a list of objects, and the prerequisites
    for their use.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 列出两种允许对对象列表进行排序的方法，以及它们的使用先决条件。
- en: Answer
  id: totrans-933
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Two static methods of the class `java.util.Collections`:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collections`类的两个静态方法：'
- en: '`void sort(List<T> list)`: Sorts a list of objects that implement the interface
    `Comparable` (the `compareTo(T)` method),'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sort(List<T> list)`: 对实现了`Comparable`接口的对象列表进行排序（使用`compareTo(T)`方法）'
- en: '`void sort(List<T> list, Comparator<T> comparator)`: Sorts objects according
    to the `Comparator` provided (the `compare(T o1, T o2)` method)'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sort(List<T> list, Comparator<T> comparator)`: 根据提供的`Comparator`对对象进行排序（使用`compare(T
    o1, T o2)`方法）'
- en: Summary
  id: totrans-937
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the reader to the classes from the Java Standard
    Library and Apache Commons that allow the manipulating of collections and arrays.
    Every Java programmer has to know the capabilities of the classes `java.util.Collections`,
    `java.util.Arrays`, `org.acpache.commons.collections4.CollectionUtils`, and `org.acpache.commons.lang3.ArrayUtils`.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向读者介绍了Java标准库和Apache Commons中的类，这些类允许操作集合和数组。每个Java程序员都必须了解`java.util.Collections`、`java.util.Arrays`、`org.acpache.commons.collections4.CollectionUtils`和`org.acpache.commons.lang3.ArrayUtils`类的功能。
- en: In the next chapter, we are going to discuss classes that, together with classes
    discussed in this chapter, belong to a group of the most popular utilities that
    every programmer has to master in order to become an effective coder.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与本章讨论的类一起属于最受欢迎的实用程序组的类，每个程序员都必须掌握这些类，以成为有效的编码人员。
