- en: Chapter 3. Building Base and Layered Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。构建基础和分层图像
- en: In this chapter, we will learn about building base and layered images for production-ready
    containers. As we saw, Docker containers provide us with ideal environments in
    which we can build, test, automate, and deploy. The reproductive nature of these
    exact environments affords a higher degree of efficacy and confidence that currently
    available script-based deployment systems cannot readily duplicate. The images
    a developer locally builds, tests, and debugs can then be pushed directly into
    staging and production environments as the test environment is nearly a mirror
    image under which the application code runs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何为生产就绪的容器构建基础和分层图像。正如我们所见，Docker容器为我们提供了理想的环境，我们可以在其中构建、测试、自动化和部署。这些确切环境的再现性为我们提供了更高效和更有信心的效果，目前可用的基于脚本的部署系统无法轻易复制。开发人员在本地构建、测试和调试的图像可以直接推送到分段和生产环境中，因为测试环境几乎是应用程序代码运行的镜像。
- en: Images are the literal foundational component of containers, defining what flavor
    of Linux to deploy and what default tools to include and make available to the
    code running inside the container. Image building is, therefore, one of the most
    critical tasks in the application containerization life cycle; correctly building
    your images is critical for effective, repeatable, and secure functionality of
    containerized applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是容器的字面基础组件，定义了部署的Linux版本和要包含和提供给容器内部运行的代码的默认工具。因此，图像构建是应用程序容器化生命周期中最关键的任务之一；正确构建图像对于容器化应用程序的有效、可重复和安全功能至关重要。
- en: A container image consists of a set of runtime variables for your application
    container. Ideally, container images should be as minimal as possible, providing
    the required functionalities only, as this helps in efficient handling of the
    container image, significantly reducing the time to upload and download the image
    from the registry and having a minimal footprint on the host.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像由一组应用程序容器的运行时变量组成。理想情况下，容器镜像应尽可能精简，仅提供所需的功能，这有助于高效处理容器镜像，显著减少了从注册表上传和下载镜像的时间，并在主机上占用空间最小。
- en: Our focus, intent, and direction is in building, debugging, and automating images
    for your Docker containers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点、意图和方向是为您的Docker容器构建、调试和自动化图像。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Building container images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Building base images from scratch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始构建基础镜像
- en: Official base images from Docker registry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Docker注册表的官方基础镜像
- en: Building layered images from Dockerfiles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建分层图像
- en: Debugging images through testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测试调试图像
- en: Automated image building with testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有测试的自动化图像构建
- en: Building container images
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: As this book attempts to *troubleshoot Docker*, wouldn't it prove beneficial
    to reduce our chances for errors that we would have to troubleshoot in the first
    place? Fortunately for us, the Docker community (and the open source community
    at large) provides a healthy registry of base (or *root*) images that dramatically
    reduce errors and provide more repeatable processes. Searching the **Docker Registry**,
    we can find official and automated build statuses for a broad and growing array
    of container images. The Docker official repositories ([https://docs.docker.com/docker-hub/official_repos/)](https://docs.docker.com/docker-hub/official_repos/) are
    carefully organized collections of images supported by Docker Inc.-automated repositories
    that allow you to validate source and content of a particular image also exist.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书试图*解决Docker*的问题，减少我们需要解决的错误的机会不是很有益吗？幸运的是，Docker社区（以及开源社区）提供了一个健康的基础（或*根*）镜像注册表，大大减少了错误并提供了更可重复的过程。在**Docker
    Registry**中搜索，我们可以找到广泛且不断增长的容器镜像的官方和自动化构建状态。 Docker官方仓库（[https://docs.docker.com/docker-hub/official_repos/)](https://docs.docker.com/docker-hub/official_repos/)）是由Docker
    Inc.支持的仔细组织的镜像集合-自动化仓库，允许您验证特定镜像的源和内容也存在。
- en: A major thrust and theme of this chapter will be in basic Docker fundamentals;
    while they may seem trivial to the experienced container user, following some
    best practices and levels of standardization will serve us well in avoiding trouble
    spots in addition to enhancing our abilities to troubleshoot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个主要重点和主题将是基本的Docker基础知识；虽然对于经验丰富的容器用户来说可能看起来微不足道，但遵循一些最佳实践和标准化水平将有助于我们避免麻烦，并增强我们解决问题的能力。
- en: Official images from the Docker Registry
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Registry的官方图像
- en: Standardization is a major component for repeatable processes. As such, wherever
    and whenever possible, one should opt for a standard base image as provided in
    the **Docker Hub** for the variant Linux distributions (for example, CentOS, Debian,
    Fedora, RHEL, Ubuntu, and others) or for specific use cases (for example, WordPress
    applications). Such base images are derived from their respective Linux platform
    images, and are built specifically for use in containers. Further, standardized
    base images are well maintained and updated frequently to address security advisories
    and critical bug fixes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化是可重复过程的重要组成部分。因此，无论何时何地，都应选择**Docker Hub**中提供的标准基础镜像，用于不同的Linux发行版（例如CentOS、Debian、Fedora、RHEL、Ubuntu等）或特定用例（例如WordPress应用程序）。这些基础镜像源自各自的Linux平台镜像，并专门用于容器中使用。此外，标准化的基础镜像经过良好维护，并经常更新以解决安全公告和关键错误修复。
- en: These base images are built, validated, and supported by Docker Inc. and are
    easily recognized by their single word names (for example, `centos`). Additionally,
    user members of the Docker community also provide and maintain prebuilt images
    to address certain use cases. Such user images are denoted with the prefix of
    the Docker Hub username that created them, suffixed with the image name (for example,
    `tutum/centos`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基础镜像由Docker Inc.构建、验证和支持，并通过它们的单词名称（例如`centos`）轻松识别。此外，Docker社区的用户成员还提供和维护预构建的镜像以解决特定用例。这些用户镜像以创建它们的Docker
    Hub用户名为前缀，后缀为镜像名称（例如`tutum/centos`）。
- en: '![Official images from the Docker Registry](graphics/image_03_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Docker Registry的官方图像](graphics/image_03_001.jpg)'
- en: To our great advantage, these standard base images remain ready and are publicly
    available on the Docker Registry; images can be searched for and retrieved simply
    using the `docker search` and `docker pull` Terminal commands. These will download
    any image(s) that are not already located on the Docker host. The Docker Registry
    has become increasingly powerful in providing official base images for which one
    can use directly, or at least as a readily available starting point toward addressing
    the needs of your container building.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这些标准基础镜像仍然是准备就绪的，并且可以在Docker Registry上公开获取；可以使用`docker search`和`docker
    pull`终端命令简单地搜索和检索镜像。这将下载任何尚未位于Docker主机上的镜像。Docker Registry在提供官方基础镜像方面变得越来越强大，可以直接使用，或者至少作为解决容器构建需求的一个可用的起点。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this book assumes your familiarity with Docker Hub/Registry and GitHub/Bitbucket,
    we will dedicate initial coverage of these as your first line of reference for
    efficient image building for containers. You can visit the official registry of
    Docker images at [https://registry.hub.docker.com/](https://registry.hub.docker.com/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书假设您熟悉Docker Hub/Registry和GitHub/Bitbucket，但我们将首先介绍这些内容，作为您构建容器的高效镜像的首要参考线。您可以访问Docker镜像的官方注册表[https://registry.hub.docker.com/](https://registry.hub.docker.com/)。
- en: '![Official images from the Docker Registry](graphics/image_03_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![来自Docker Registry的官方镜像](graphics/image_03_002.jpg)'
- en: 'The Docker Registry can be searched from your Docker Hub account or directly
    from the Terminal, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Registry可以从您的Docker Hub帐户或直接从终端进行搜索，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Flags can be applied to your search criteria to filter images for star ratings,
    automated builds, and many more. To use the official `centos` image from the registry,
    from a Terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对搜索条件应用标志来过滤星级评分、自动构建等图像。要使用来自注册表的官方`centos`镜像，请从终端执行：
- en: '`$ sudo docker pull centos`: This will download the `centos` image to your
    host machine.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ sudo docker pull centos`：这将把`centos`镜像下载到您的主机上。'
- en: '`$ sudo docker run centos`: This will first look for this image localized on
    your host and, if not found, it will download the image to host. The run parameters
    for the image will have been defined in its Dockerfile.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ sudo docker run centos`：这将首先在主机上查找此镜像，如果找不到，将会将镜像下载到主机上。镜像的运行参数将在其Dockerfile中定义。'
- en: User repositories
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户存储库
- en: Further, as we have seen, we are not limited merely to the repositories of official
    Docker images. Indeed, a wealth of community users (both as individuals and from
    corporate enterprises) have prepared images constructed to meet certain needs.
    As an example, an `ubuntu` image is created to run the `joomla` content management
    system within a container running on Apache, MySql, and PHP.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们所见，我们不仅仅局限于官方Docker镜像的存储库。事实上，社区用户（无论是个人还是来自公司企业）已经准备好了满足某些需求的镜像。例如，创建了一个`ubuntu`镜像，用于在运行在Apache、MySql和PHP上的容器中运行`joomla`内容管理系统。
- en: 'Here, we have a user repository with just such an image (`namespace/repository
    name`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个用户存储库，其中有这样的镜像（`命名空间/存储库名称`）：
- en: '![User repositories](graphics/image_03_004.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![用户存储库](graphics/image_03_004.jpg)'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Try it out:** Practice an image `pull` and `run`from the Docker Registry
    from the Terminal.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**试一下：** 从终端练习从Docker Registry拉取和运行图像。'
- en: '`$ sudo docker pull cloudconsulted/joomla`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo docker pull cloudconsulted/joomla`'
- en: pulls our base image for a container and `$ sudo docker run -d -p 80:80 cloudconsulted/joomla`
    runs our container image and maps port `80` of the host to port `80` of the container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器中拉取我们的基础镜像，并且`$ sudo docker run -d -p 80:80 cloudconsulted/joomla` 运行我们的容器镜像，并将主机的端口`80`映射到容器的端口`80`。
- en: Point your browser to `http://localhost` and you will have the build page for
    a new Joomla website!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的浏览器指向`http://localhost`，你将会看到一个新的Joomla网站的构建页面！
- en: Building our own base images
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们自己的基础镜像
- en: There may be occasion, however, when we need to create custom images to suit
    our own development and deployment environment. If your use case dictates using
    a nonstandardized base image, you will need to roll your own image. As with any
    approach, appropriate planning beforehand is necessary. Before building an image,
    you should spend adequate time to fully understand the use case your container
    is meant to address. There isn't much need for a container that cannot run the
    intended application. Other considerations may include whether the library or
    binary you are including in the image is reusable, and many more. Once you feel
    you are done, review your needs and requirements once more and filter out parts
    that are unnecessary; we do not want to bloat our containers for no good reason.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会有情况需要创建定制的镜像以适应我们自己的开发和部署环境。如果你的使用情况要求使用非标准化的基础镜像，你将需要自己创建镜像。与任何方法一样，事先适当的规划是必要的。在构建镜像之前，你应该花足够的时间充分了解你的容器所要解决的使用情况。没有必要运行不符合预期应用程序的容器。其他考虑因素可能包括你在镜像中包含的库或二进制文件是否可重用，等等。一旦你觉得完成了，再次审查你的需求和要求，并过滤掉不必要的部分；我们不希望毫无理由地膨胀我们的容器。
- en: Using the Docker Registry, you may find automated builds. These builds are pulled
    from repositories at GitHub/Bitbucket and can, therefore, be forked and modified
    to your own specifications. Your newly forked repository can then in turn be synced
    to the Docker Registry with your new image, which can then be pulled and run as
    needed for your containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Registry，你可以找到自动构建。这些构建是从GitHub/Bitbucket的仓库中拉取的，因此可以被fork并根据你自己的规格进行修改。然后，你新fork的仓库可以同步到Docker
    Registry，生成你的新镜像，然后可以根据需要被拉取和运行到你的容器中。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Try it out**: Pull the ubuntu minimal image from the following repository
    and drop it to your Dockerfile directory to create your own image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**试一下**：从以下仓库中拉取ubuntu minimal镜像，并将其放入你的Dockerfile目录中，以创建你自己的镜像：'
- en: '`$ sudo docker pull cloudconsulted/ubuntu-dockerbase` `$ mkdir dockerbuilder`
    `$ cd dockerbuilder`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo docker pull cloudconsulted/ubuntu-dockerbase` `$ mkdir dockerbuilder`
    `$ cd dockerbuilder`'
- en: 'Open an editor (vi/vim or nano) and create a new Dockerfile:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个编辑器（vi/vim或nano）并创建一个新的Dockerfile：
- en: '`$ sudo nano Dockerfile`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo nano Dockerfile`'
- en: 'We will delve into creating good Dockerfiles later as we talk about layered
    and automated image building. For now, we just want to create our own new base
    image, only symbolically going through the procedure and location for creating
    a Dockerfile. For the sake of simplicity, here we are just calling the base image
    from which we want to build our new image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将深入讨论如何创建良好的Dockerfile，以及分层和自动化的镜像构建。现在，我们只想创建我们自己的新基础镜像，只是象征性地通过创建Dockerfile的过程和位置。为了简单起见，我们只是从我们想要构建新镜像的基础镜像中调用：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save and close this Dockerfile. We now build our new image locally:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并关闭这个Dockerfile。现在我们在本地构建我们的新镜像：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s check to ensure our new image is listed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下确保我们的新镜像已列出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note our **IMAGE ID** for **mynew-ubuntu**, as we will need it shortly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的**IMAGE ID**为**mynew-ubuntu**，因为我们很快会需要它：
- en: 'Create a new public/private repository under your Docker Hub username. I''m
    adding the new repository here under `<namespace><reponame>` as `cloudconsulted/mynew-ubuntu`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub用户名下创建一个新的公共/私有仓库。我在这里添加了新的仓库，命名为`<namespace><reponame>`，如`cloudconsulted/mynew-ubuntu`：
- en: '![Building our own base images](graphics/image_03_006.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![构建我们自己的基础镜像](graphics/image_03_006.jpg)'
- en: 'Next, return to the Terminal so that we can tag our new image to push to the
    new Docker Hub repository under our `<namespace>`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回到终端，这样我们就可以标记我们的新镜像以推送到我们的`<namespace>`下的新Docker Hub仓库：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Ensure that our new image is correctly tagged for `<namespace><repository>`
    in our images list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的新镜像在我们的镜像列表中正确标记为`<namespace><repository>`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Also, we will find our newly created image labeled for pushing it to our Docker
    Hub repository.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将找到我们新创建的标记为推送到我们的Docker Hub仓库的镜像。
- en: 'Now, let''s push the image up to our Docker Hub repository:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将镜像推送到我们的Docker Hub仓库：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, check the Hub for our new image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查我们的新镜像是否在Hub上：
- en: '![Building our own base images](graphics/image_03_008.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![构建我们自己的基础镜像](graphics/image_03_008.jpg)'
- en: 'There are essentially two approaches to building your own Docker images:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的Docker镜像基本上有两种方法：
- en: Manually constructing layers interactively via bash shell to install necessary
    applications
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过bash shell手动交互式构建层来安装必要的应用程序
- en: Automating through a Dockerfile that builds the images with all necessary applications
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Dockerfile自动化构建带有所有必要应用程序的镜像
- en: Building images using the scratch repository
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用scratch仓库构建镜像
- en: Going about building your own container images for Docker is highly dependent
    on which Linux distribution you intend to package. With such variance, and with
    the prevalence and growing registry of images already available to us via the
    Docker Registry, we won't spend much time on such a manual approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的Docker容器镜像高度依赖于您打算打包的Linux发行版。由于这种差异性，以及通过Docker Registry已经可用的镜像的盛行和不断增长的注册表，我们不会花太多时间在这样的手动方法上。
- en: Here again, we can look in the Docker Registry to provide us with a minimal
    image to use. A `scratch` repository has been created from an empty TAR file that
    can be utilized simply via `docker pull`. As before, make your Dockerfile according
    to your parameters, and you have your new image, from scratch.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以再次查看Docker Registry，以提供我们使用的最小镜像。一个`scratch`仓库已经从一个空的TAR文件中创建，可以通过`docker
    pull`简单地使用。与以前一样，根据您的参数制作Dockerfile，然后您就有了新的镜像，从头开始。
- en: 'This process can be even further simplified by making use of available tools,
    such as **supermin** (Fedora systems) or **debootstrap** (Debian systems). Using
    such tools, the build process for an Ubuntu base image, for example, can be as
    simple as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用可用工具（例如**supermin**（Fedora系统）或**debootstrap**（Debian系统）），这个过程甚至可以进一步简化。例如，使用这些工具，构建Ubuntu基础镜像的过程可以简单如下：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Building layered images
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建分层镜像
- en: A core concept and feature of Docker is layered images. One of the most important
    features of Docker is **image layering** and the management of image content.
    A layered approach for container images is very efficient, as you can reference
    the contents in the image, identifying the layer in a layered image. This is very
    powerful when building multiple images, using the Docker Registry to push and
    pull images.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个核心概念和特性是分层镜像。Docker的最重要的特性之一是**镜像分层**和镜像内容的管理。容器镜像的分层方法非常高效，因为您可以引用镜像中的内容，识别分层镜像中的层。在构建多个镜像时，使用Docker
    Registry来推送和拉取镜像非常强大。
- en: '![Building layered images](graphics/image_03_009.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![构建分层镜像](graphics/image_03_009.jpg)'
- en: '[Image Copyright © Docker, Inc.]'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[镜像版权 © Docker, Inc.]'
- en: Building layered images using Dockerfiles
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建分层镜像
- en: Layered images are primarily built using the **Dockerfile**. In essence, a Dockerfile
    is a script that automatically builds our containers from a source (*base* or
    *root*) image in the order you need them executed by the Docker daemon, step by
    step, layer upon layer. These are successive commands (instructions) and arguments
    enlisted within the file that execute a proscribed set of actions on a base image,
    with each command constituting a new layer, in order to build a new one. This
    not only facilitates the organization of our image building but greatly enhances
    deployments from beginning to end through its simplification. The scripts within
    a Dockerfile can be presented to the Docker daemon in a range of ways to build
    new images for our containers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 分层图像主要是使用**Dockerfile**构建的。实质上，Dockerfile是一个脚本，它可以按照您需要的顺序从源（*基础*或*根*）镜像自动构建我们的容器，逐步、一层叠一层地由Docker守护程序执行。这些是在文件中列出的连续命令（指令）和参数，它们在基础镜像上执行一组规定的操作，每个命令构成一个新层，以构建一个新的镜像。这不仅有助于组织我们的镜像构建，而且通过简化大大增强了从头到尾的部署。Dockerfile中的脚本可以以各种方式呈现给Docker守护程序，以为我们的容器构建新的镜像。
- en: Dockerfile construction
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dockerfile构建
- en: The first command of a Dockerfile is typically the `FROM` command. `FROM` specifies
    the base image to be pulled. This base image can be located in the public Docker
    registry ([https://www.docker.com/](https://www.docker.com/)) within a private
    registry or even a localized Docker image from the host.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的第一个命令通常是`FROM`命令。`FROM`指定要拉取的基础镜像。这个基础镜像可以位于公共Docker注册表（[https://www.docker.com/](https://www.docker.com/)）中，在私有注册表中，甚至可以是主机上的本地化Docker镜像。
- en: Additional layers in a Docker image are populated as per the directives defined
    in the Dockerfile. Dockerfiles have very handy directives. Every new directive
    defined in the Dockerfile constitutes a **layer** in a layered image. With a `RUN` directive,
    we can specify a command to be run, with the result of the command as an additional
    layer in the image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像中的附加层根据Dockerfile中定义的指令进行填充。Dockerfile具有非常方便的指令。在Dockerfile中定义的每个新指令都构成了分层图像中的一个**层**。通过`RUN`指令，我们可以指定要运行的命令，并将命令的结果作为图像中的附加层。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建议
- en: It is highly advised to logically group the operations performed in an image
    and keep the number of layers to a minimum. For example, while trying to install
    the dependencies for your application, one can install all the dependencies in
    one `RUN` directive rather than using *N* number of directives per dependency.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议将图像中执行的操作逻辑分组，并将层的数量保持在最低限度。例如，在尝试为应用程序安装依赖项时，可以在一个`RUN`指令中安装所有依赖项，而不是使用每个依赖项的*N*个指令。
- en: We will inspect more closely, the aspects of Dockerfiles for automation in a
    later section, *Automated image building*. For now, we need to make certain that
    we grasp the concept and construction of the Dockerfile itself. Let's look specifically
    at a simple list of commands that can be employed. As we have seen before, our
    Dockerfile should be created in a working directory containing our existing code
    (and/or other dependencies, scripts, and others).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节“自动化镜像构建”中更仔细地检查Dockerfile的方面。现在，我们需要确保我们理解Dockerfile本身的概念和构造。让我们特别看一下可以使用的一系列简单命令。正如我们之前所看到的，我们的Dockerfile应该在包含我们现有代码（和/或其他依赖项、脚本和其他内容）的工作目录中创建。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建议
- en: '**CAUTION:** Avoid use of the root [`/`] directory as root of your source repository.
    The `docker build` command makes use of the directory containing your Dockerfile
    as the build context (including all of its subdirectories). The build context
    will be sent to the Docker daemon before building the image, which means if you
    use `/` as the source repository, the entire contents of your hard drive will
    get sent to the daemon (and thus to the machine running the daemon). In most cases,
    it is best to put each Dockerfile in an empty directory. Then, only add the files
    needed for building the Dockerfile to the directory. To increase the build''s
    performance, a `.dockerignore` file can be added to the context directory to properly
    exclude files and directories.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**避免使用根目录 [`/`] 作为源代码库的根目录。`docker build` 命令使用包含您的 Dockerfile 的目录作为构建上下文（包括其所有子目录）。构建上下文将在构建镜像之前发送到
    Docker 守护程序，这意味着如果您使用 `/` 作为源代码库，您硬盘的整个内容将被发送到守护程序（因此发送到运行守护程序的机器）。在大多数情况下，最好将每个
    Dockerfile 放在一个空目录中。然后，只向目录添加构建 Dockerfile 所需的文件。为了提高构建的性能，可以向上下文目录添加一个 `.dockerignore`
    文件，以正确排除文件和目录。'
- en: Dockerfile commands and syntax
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dockerfile 命令和语法
- en: While simplistic, the order and syntax of our Dockerfile commands are extremely
    important. Proper attention to details and best practice here will not only help
    ensure successful automated deployments, but also serve to help in any troubleshooting
    efforts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但我们的Dockerfile命令的顺序和语法非常重要。在这里正确关注细节和最佳实践不仅有助于确保成功的自动部署，还有助于任何故障排除工作。
- en: Let's delineate some basic commands and illustrate them directly with a working
    Dockerfile; our `joomla` image from before is a good example of a basic layered
    image build from a Dockerfile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们勾画一些基本命令，并直接用一个工作的Dockerfile来说明它们；我们之前的`joomla`镜像是一个基本的分层镜像构建的好例子。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our sample joomla base image is located in the public Docker index via
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例 joomla 基本镜像位于公共 Docker 索引中
- en: '`cloudconsulted/joomla`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloudconsulted/joomla`。'
- en: '**FROM**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自**'
- en: A proper Dockerfile begins with defining an image `FROM`, from which the build
    process starts. This instruction specifies the base image to be used. It should
    be the first instruction in Dockerfile, and it is a must for building an image
    via Dockerfile. You can specify the local image, an image present at the Docker
    public registry, or image at a private registry.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的 Dockerfile 从定义一个 `FROM` 镜像开始，构建过程从这里开始。这个指令指定要使用的基本镜像。它应该是 Dockerfile
    中的第一个指令，对于通过 Dockerfile 构建镜像是必须的。您可以指定本地镜像、Docker 公共注册表中的镜像，或者私有注册表中的镜像。
- en: '**Common Constructs**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见结构**'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`<tag>` and `<digest>` are optional; if you do not specify them, it defaults
    to `latest`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tag>` 和 `<digest>` 是可选的；如果您不指定它们，它默认为 `latest`。'
- en: '**Example Dockerfile from our Joomla Image**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的 Joomla 镜像的示例 Dockerfile**'
- en: 'Here, we define the base image to be used for the container:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义要用于容器的基本镜像：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**MAINTAINER**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护者**'
- en: This line designates the *Author* of the built image. This is an optional instruction
    in Dockerfile; however, one should specify this instruction with the name and/or
    e-mail address of the author. `MAINTAINER` details can be placed anywhere you
    prefer in your Dockerfile, so long as it is always post your `FROM` command, as
    they do not constitute any execution but rather a value of a definition (that
    is, just some additional information).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了构建镜像的*作者*。这是 Dockerfile 中的一个可选指令；然而，应该指定此指令与作者的姓名和/或电子邮件地址。`维护者`的详细信息可以放在您的
    Dockerfile 中任何您喜欢的地方，只要它总是在您的 `FROM` 命令之后，因为它们不构成任何执行，而是一个定义的值（也就是一些额外的信息）。
- en: '**Common Constructs**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见结构**'
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Example Dockerfile from our Joomla Image**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的 Joomla 镜像的示例 Dockerfile**'
- en: 'Here, we define the author for this container and image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为此容器和镜像定义了作者：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**ENV**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**ENV**'
- en: This instruction sets the environment variable in Dockerfile. An environment
    variable set can be used in subsequent instructions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令在Dockerfile中设置环境变量。设置的环境变量可以在后续指令中使用。
- en: '**Common Constructs**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见结构**'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code sets one environment variable `<key>` with `<value>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了一个环境变量`<key>`为`<value>`。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding instruction sets two environment variables. Use the `=` sign
    between key and value of an environment variable and separate two environment
    key-values with space to define multiple environment variables:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令设置了两个环境变量。使用`=`符号在环境变量的键和值之间，并用空格分隔两个环境键值来定义多个环境变量：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Use quotes for value having spaces for environment variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有空格值的环境变量，请使用引号。
- en: 'The following are the points to remember about `ENV` instructions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`ENV`指令的要点：
- en: Use single instruction to define multiple environment variables
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个指令定义多个环境变量
- en: Environment variables are available when you create container from image
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建容器时环境变量可用
- en: One can review the environment variable from image using `docker inspect <image>`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`docker inspect <image>`从镜像中查看环境变量
- en: Values of environment variables can be changed at runtime by passing the `--env
    <key>=<value>` option to the `docker run` command
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量的值可以通过向`docker run`命令传递`--env <key>=<value>`选项在运行时进行更改
- en: '**Example Dockerfile from our Joomla Image **'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的Joomla镜像的示例Dockerfile**'
- en: 'Here, we set the environment variables for Joomla and the Docker image running
    without an interactive Terminal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为Joomla和Docker镜像设置环境变量，而不使用交互式终端：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**RUN**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**RUN**'
- en: This instruction allows you to run commands and yield a layer. The output of
    the `RUN` instruction will be a layer built for image under process. Command passed
    to the `RUN` instruction runs on the layers built before this instruction; one
    needs to take care of the orders.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令允许您运行命令并生成一个层。`RUN`指令的输出将是在进程中为镜像构建的一个层。传递给`RUN`指令的命令在此指令之前构建的层上运行；需要注意顺序。
- en: '**Common Constructs**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见结构**'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `<command>` is executed in a shell -`/bin/sh -c` shell form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`<command>`在shell中执行-`/bin/sh -c` shell形式。'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this particular form, you specify the `executable` and `parameters` in executable
    form. Ensure that you pass the absolute path of the executable in the command.
    This is useful for cases where the base image does not have `/bin/sh`. You can
    specify an executable, which could be your only executable in a base image and
    build the layers on top using it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊形式中，您可以在可执行形式中指定`可执行文件`和`参数`。确保在命令中传递可执行文件的绝对路径。这对于基础镜像没有`/bin/sh`的情况很有用。您可以指定一个可执行文件，它可以是基础镜像中的唯一可执行文件，并在其上构建层。
- en: 'This is also useful if you do not want to use the `/bin/sh` shell. Consider
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用`/bin/sh` shell，这也很有用。考虑一下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Actually, this is a special form of example, where you specify multiple commands
    separated by `;`. The `RUN` instruction executes such commands together and builds
    a single layer for all of the commands specified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个特殊形式的示例，您可以在其中指定多个由`;`分隔的命令。`RUN`指令一起执行这些命令，并为所有指定的命令构建一个单独的层。
- en: '**Example Dockerfile from our Joomla Image**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的Joomla镜像的示例Dockerfile**'
- en: 'Here, we update the package manager and install required dependencies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更新软件包管理器并安装所需的依赖项：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we have purposefully written so that new packages are to be added
    as their own apt-get install lines, following the initial install commands.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们特意这样写，以便将新软件包作为它们自己的apt-get install行添加，遵循初始安装命令。
- en: This is done so that, should we ever need to add or remove a package, we can
    do so without requiring to re-install all other packages within our Dockerfile.
    Obviously, this provides considerable savings in build time, should the need arise.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了，如果我们需要添加或删除一个软件包，我们可以在Dockerfile中不需要重新安装所有其他软件包。显然，如果有这样的需要，这将节省大量的构建时间。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Docker Cache:** Docker will first check against the host''s image cache for
    any matching layers from previous builds. If found, the given build step within
    the Dockerfile will be skipped to utilize the previous layer, from cache. As such,
    it is best practice to enlist each of the Dockerfile''s `apt-get -y install` commands
    on their own.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker缓存：** Docker首先会检查主机的镜像缓存，查找以前构建的任何匹配层。如果找到，Dockerfile中的给定构建步骤将被跳过，以利用缓存中的上一层。因此，最佳实践是将Dockerfile的每个`apt-get
    -y install`命令单独列出。'
- en: As we've discussed, the `RUN` command in a Dockerfile will execute any given
    command under the context and filesystem of the Docker container, and produce
    a new image layer with any resulting file system changes. We first run `apt-get
    update` to ensure that the repositories and the PPAs of the packages are updated.
    Then, in separate calls, we instruct the package manager to install MySQL, Apache,
    PHP, and Supervisor. The `-y` flag skips interactive confirmation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，Dockerfile中的`RUN`命令将在Docker容器的上下文和文件系统下执行任何给定的命令，并生成具有任何文件系统更改的新镜像层。我们首先运行`apt-get
    update`以确保软件包的存储库和PPA已更新。然后，在单独的调用中，我们指示软件包管理器安装MySQL、Apache、PHP和Supervisor。`-y`标志跳过交互式确认。
- en: 'With all of our necessary dependencies installed to run our service, we ought
    to tidy up a bit to give us a cleaner Docker image:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了我们所有必要的依赖项来运行我们的服务后，我们应该整理一下，以获得一个更干净的Docker镜像：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**ADD**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**ADD**'
- en: This information is used to copy files and directories from the local filesystem
    or files from a remote URL into the image. The source and destination must be
    specified in `ADD` instructions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息用于将文件和目录从本地文件系统或远程URL中的文件复制到镜像中。源和目标必须在`ADD`指令中指定。
- en: '**Common Constructs**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见结构**'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here the path of `<source_file>` is relative to the build context. Also, the
    path of `<destination_directory>` could either be absolute or relative to the
    `WORKDIR`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`<source_file>`的路径是相对于构建上下文的。另外，`<destination_directory>`的路径可以是绝对的，也可以是相对于`WORKDIR`的：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Multiple files, for example, `<file1>` , `<file2>`, and `<file3>`, are copied
    into `<destination_directory>`. Note that paths of these source files should be
    relative to the build context, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 多个文件，例如`<file1>`，`<file2>`和`<file3>`，被复制到`<destination_directory>`中。请注意，这些源文件的路径应该相对于构建上下文，如下所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Contents of the `<source_directory>` are copied into `<destination_directory>` along
    with the filesystem metadata; the directory itself is not copied:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`<source_directory>`的内容与文件系统元数据一起复制到`<destination_directory>`中；目录本身不会被复制：'
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the files starting with `text_` in the build context directory are copied
    in the `/text_files` directory in the container image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建上下文目录中以`text_`开头的所有文件都会被复制到容器镜像中的`/text_files`目录中：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Filename with a space can be specified in quotes; one needs to use a JSON array
    to specify the ADD instruction in this case.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中带有空格的情况可以在引号中指定；在这种情况下，需要使用JSON数组来指定ADD指令。
- en: 'The following are the points to remember about `ADD` instructions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`ADD`指令的要点：
- en: All new files and directories that are copied into the container image have
    UID and GID as `0`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有复制到容器镜像中的新文件和目录的UID和GID都为`0`
- en: In cases where the source file is a remote URL, the destination file will have
    a permission of `600`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源文件是远程URL的情况下，目标文件将具有`600`的权限
- en: All the local files referenced in the source of the `ADD` instruction should
    be in the build context directory or in its subdirectories
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ADD`指令的源中引用的所有本地文件应位于构建上下文目录或其子目录中
- en: If the local source file is a supported tar archive then it is unpacked as a
    directory
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果本地源文件是受支持的tar存档，则它将被解压缩为目录
- en: If multiple source files are specified, the destination must be a directory
    and end with a trailing slash, `/`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了多个源文件，则目标必须是一个目录，并以斜杠`/`结尾
- en: If a destination does not exist, it will be created along with all the parent
    directories in the path, if required
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标不存在，它将与路径中的所有父目录一起创建，如果需要的话
- en: '**Example Dockerfile from our Joomla Image**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Joomla镜像的示例Dockerfile
- en: 'Here, we download `joomla` into the Apache web root:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`joomla`下载到Apache web根目录：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**COPY**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**COPY**'
- en: The `COPY` command specifies that a file, located at the input path, should
    be copied from the same directory as the Dockerfile to the output path inside
    the container.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`命令指定应将位于输入路径的文件从与Dockerfile相同的目录复制到容器内部的输出路径。'
- en: '**CMD**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMD**'
- en: The `CMD` instruction has three forms-a shell form, as default parameters to
    `ENTRYPOINT` and the preferred executable form. The main purpose of a `CMD` is
    to provide defaults for an executing container. These defaults can either include
    or omit an executable, the latter of which must specify an `ENTRYPOINT` instruction
    as well. If the user specifies arguments to Docker `run`, then they will override
    the default specified in `CMD`. If you would like your container to run the same
    executable every time, then you should consider using `ENTRYPOINT` in combination
    with `CMD`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令有三种形式-作为`ENTRYPOINT`的默认参数的shell形式和首选可执行形式。`CMD`的主要目的是为执行容器提供默认值。这些默认值可以包括或省略可执行文件，后者必须指定`ENTRYPOINT`指令。如果用户在Docker
    `run`中指定参数，则它们将覆盖`CMD`中指定的默认值。如果您希望容器每次运行相同的可执行文件，则应考虑结合使用`ENTRYPOINT`和`CMD`。'
- en: 'The following are the points to remember:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要记住的要点：
- en: Do not to confuse `CMD` with `RUN`-`RUN` will actually execute the command and
    commit the result, whereas `CMD` does not execute commands during a build, but
    instead specifies the intended command for the image
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`CMD`与`RUN`混淆-`RUN`实际上会执行命令并提交结果，而`CMD`不会在构建过程中执行命令，而是指定图像的预期命令
- en: A Dockerfile can only execute one `CMD`; if you enlist more than one, only the
    last `CMD` will be executed
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile只能执行一个`CMD`；如果列出多个，则只会执行最后一个`CMD`
- en: '**Example Dockerfile from our Joomla Image**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Joomla镜像的示例Dockerfile
- en: 'Here, we set up Apache for it to start:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置Apache以启动：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the content of our completed Joomla Dockerfile:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们完成的Joomla Dockerfile的内容：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Other common Dockerfile commands are as follows: **ENTRYPOINT**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的Dockerfile命令如下：**ENTRYPOINT**
- en: 'An `ENTRYPOINT` allows you to configure a container that will run as an executable.
    From Docker''s documentation, we will use the provided example; the following
    will start `nginx` with its default content, listening on port `80`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`允许您配置将作为可执行文件运行的容器。根据Docker的文档，我们将使用提供的示例；以下将启动`nginx`，并使用其默认内容，在端口`80`上进行侦听：'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Command-line arguments to `docker run <image>` will be appended after all elements
    in an executable form `ENTRYPOINT`, and will override all elements specified using
    `CMD`. This allows arguments to be passed to the entry point, that is, `docker
    run <image> -d` will pass the `-d` argument to the entry point. You can override
    the `ENTRYPOINT` instruction using the `docker run --entrypoint` flag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run <image>`的命令行参数将在可执行形式的`ENTRYPOINT`中的所有元素之后追加，并将覆盖使用`CMD`指定的所有元素。这允许将参数传递给入口点，即`docker
    run <image> -d`将向入口点传递`-d`参数。您可以使用`docker run --entrypoint`标志覆盖`ENTRYPOINT`指令。'
- en: '**LABEL**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**LABEL**'
- en: This instruction specifies the metadata for the image. This image metadata can
    later be inspected using the `docker inspect <image>` command. The idea here is
    to add information about the image in image metadata for easy retrieval. In order
    to get the metadata from the image, one does not need to create a container from
    the image (or mount the image on local filesystem), Docker associates metdata
    data with every Docker image, and it has a predefined structure for it; using
    `LABEL`, one can add additional associated metadata describing the image.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令指定了图像的元数据。稍后可以使用`docker inspect <image>`命令来检查这些图像元数据。这里的想法是在图像元数据中添加关于图像的信息，以便轻松检索。为了从图像中获取元数据，不需要从图像创建容器（或将图像挂载到本地文件系统），Docker将元数据与每个Docker图像关联，并为其定义了预定义的结构；使用`LABEL`，可以添加描述图像的附加关联元数据。
- en: 'The label for the image is a key-value pair. Following are examples of using
    `LABEL` in a Dockerfile:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的标签是键值对。以下是在Dockerfile中使用`LABEL`的示例：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This instruction will add three labels to the image. Also, note that it will
    create one new layer as all the labels are added in a single `LABEL` instruction:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将向图像添加三个标签。还要注意，它将创建一个新层，因为所有标签都是在单个`LABEL`指令中添加的：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use quotes in labels if the label value has spaces:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签值中有空格，请在标签中使用引号：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the value of the label is long, use backslash to extend the label value to
    a new line.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签的值很长，请使用反斜杠将标签值扩展到新行。
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Multiple labels for an image can be defined by separating them by **End Of Line**
    (**EOL**). Note that, in this case, there will be two image layers created for
    two different `LABEL` instructions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过**行尾**（**EOL**）分隔它们来定义图像的多个标签。请注意，在这种情况下，将为两个不同的`LABEL`指令创建两个图像层。
- en: 'Notes about `LABEL` instructions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`LABEL`指令的注意事项：
- en: Labels are collated together as described in Dockerfile and those from the base
    image specified in the `FROM` instruction
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签按照Dockerfile中描述的方式汇总在一起，并与`FROM`指令中指定的基本图像中的标签一起使用
- en: If `key` in labels are repeated, later one will override the earlier defined
    key's value.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标签中的`key`重复，后面的值将覆盖先前定义的键的值。
- en: Try specifying all the labels in a single `LABEL` instruction to produce an
    efficient image, thus avoiding unnecessary image layer count
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在单个`LABEL`指令中指定所有标签，以生成高效的图像，从而避免不必要的图像层计数
- en: To view the labels for a built image, use the `docker inspect <image>` command
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看构建图像的标签，请使用`docker inspect <image>`命令
- en: '**WORKDIR**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**WORKDIR**'
- en: This instruction is used to set the working directory for subsequent `RUN`,
    `ADD`, `COPY`, `CMD`, and `ENTRYPOINT` instructions in Dockerfile.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令用于为Dockerfile中的后续`RUN`、`ADD`、`COPY`、`CMD`和`ENTRYPOINT`指令设置工作目录。
- en: Define a work directory in Dockerfile, all subsequent relative paths referenced
    inside the container will be relative to the specified work directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中定义工作目录，容器中引用的所有后续相对路径将相对于指定的工作目录。
- en: 'The following are examples of using the `WORKDIR` instruction:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`WORKDIR`指令的示例：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding instruction specifies `/opt/myapp` as the working directory for
    subsequent instructions, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令将`/opt/myapp`指定为后续指令的工作目录，如下所示：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding instruction defines the work directory twice. Note that the second
    `WORKDIR` will be relative to the first `WORKDIR`. The result of the `pwd` command
    will be `/opt/myapp`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令两次定义了工作目录。请注意，第二个`WORKDIR`将相对于第一个`WORKDIR`。`pwd`命令的结果将是`/opt/myapp`：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Work directory can resolve the environment variables defined earlier. In this
    example, the `WORKDIR` instruction can evaluate the `SOURCEDIR` environment variable
    and the resultant working directory will be `/opt/src/myapp`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 工作目录可以解析之前定义的环境变量。在这个例子中，`WORKDIR`指令可以评估`SOURCEDIR`环境变量，结果的工作目录将是`/opt/src/myapp`。
- en: '**USER**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**USER**'
- en: This sets the user for running any subsequent `RUN`, `CMD`, and `ENTRYPOINT` instructions.
    This also sets the user when a container is created and run from the image.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为后续的`RUN`、`CMD`和`ENTRYPOINT`指令设置用户。当从镜像创建和运行容器时，也会设置用户。
- en: 'The following instruction sets the user `myappuser` for the image and container:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令为镜像和容器设置了用户`myappuser`：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notes about `USER` instructions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`USER`指令的注意事项：
- en: One can override the user using `--user=name|uid[:<group|gid>]` in the `docker
    run` command for container
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`docker run`命令中的`--user=name|uid[:<group|gid>]`来覆盖用户容器的用户
- en: Image testing and debugging
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像测试和调试
- en: While we can applaud the benefits of containers, troubleshooting and effectively
    monitoring them currently present some complexity. Since by design, containers
    run in isolation, their resulting environment can be cloudy. Effective troubleshooting
    has generally required shell entry into the container itself, coupled with the
    complications of installing additional Linux tools to merely peruse information
    that is twice as hard to investigate.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以赞赏容器的好处，但目前对其进行故障排除和有效监控会带来一些复杂性。由于容器设计上的隔离性，它们的环境可能会变得模糊不清。有效的故障排除通常需要进入容器本身的shell，并且需要安装额外的Linux工具来查看信息，这使得调查变得更加困难。
- en: 'Typically, available tools, methods, and approaches for meaningful troubleshooting
    of our containers and images has required installing additional packages in every
    container. This results in the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对我们的容器和镜像进行有意义的故障排除所需的工具、方法和途径需要在每个容器中安装额外的软件包。这导致以下结果：
- en: Requirements for connecting or attaching directly to the container, which is
    not always a piddling matter
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接或直接附加到容器的要求并非总是微不足道的
- en: Limitations on inspection of a single container at a time
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能检查一个容器的限制
- en: Compounding these difficulties, adding unnecessary bloat to our containers with
    these tools is something we originally attempted to avoid in our planning; minimalism
    is one of the advantages we looked for in using containers in the first place.
    Let's take a look then at how we can reasonably glean useful information on our
    container images with some basic commands, as well as investigate emergent applications
    that allow us to monitor and troubleshoot containers from the outside.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 增加这些困难的是，使用这些工具给我们的容器增加了不必要的臃肿，这是我们最初在规划中试图避免的；极简主义是我们在使用容器时寻求的优势之一。让我们看看如何可以合理地利用一些基本命令获取有用的容器镜像信息，以及调查新出现的应用程序，使我们能够从外部监视和排除容器。
- en: Docker details for troubleshooting
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于故障排除的Docker详细信息
- en: Now that you have your image (regardless of building method) with Docker running,
    let's do some testing to make sure that all is copacetic with our build. While
    these may seem routine and mundane, it is a good practice to run any or all of
    the following as a *top-down* approach to troubleshooting.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了您的镜像（无论构建方法如何）并且Docker正在运行，让我们进行一些测试，以确保我们的构建一切正常。虽然这些可能看起来很常规和乏味，但作为故障排除的*自上而下*方法来运行以下任何或所有内容是一个很好的做法。
- en: The first two commands here are ridiculously simple and seemingly too generic,
    but will provide base-level detail with which to begin any downstream troubleshooting
    efforts--`$ docker version` and `$ docker info`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的前两个命令非常简单，看起来似乎太通用了，但它们将提供基本级别的细节，以便开始任何下游的故障排除工作--`$ docker version`和`$
    docker info`。
- en: Docker version
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker版本
- en: 'Let''s ensure that we firstly recognize what version of Docker, Go, and Git
    we are running:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保我们知道我们正在运行的Docker、Go和Git的版本：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Docker info
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker信息
- en: 'Additionally, we should understand our host operating system and kernel version,
    as well as storage, execution, and logging drivers. Knowing these things can help
    us troubleshoot from our *top-down* perspective:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该了解我们的主机操作系统和内核版本，以及存储、执行和日志记录驱动程序。了解这些东西可以帮助我们从*自上而下*的角度进行故障排除：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A troubleshooting note for Debian/Ubuntu
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian / Ubuntu的故障排除说明
- en: 'From a `$ sudo docker info` command, you may receive one or both of the following
    warnings:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`$ sudo docker info`命令，您可能会收到以下警告中的一个或两个：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will need to add the following command-line parameters to the kernel in
    order to enable memory and swap accounting:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加以下命令行参数到内核中，以启用内存和交换空间记账：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For these Debian or Ubuntu systems, if you use the default GRUB bootloader,
    those parameters can be added by editing `/etc/default/grub` and extending `GRUB_CMDLINE_LINUX`.
    Locate the following line:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些Debian或Ubuntu系统，如果使用默认的GRUB引导加载程序，则可以通过编辑`/etc/default/grub`并扩展`GRUB_CMDLINE_LINUX`来添加这些参数。找到以下行：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, replace it with the following one:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用以下内容替换它：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, run `update-grub` and reboot the host machine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`update-grub`并重新启动主机。
- en: Listing installed Docker images
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出已安装的Docker镜像
- en: 'We also need to ensure that the container instance has actually installed your
    image locally. SSH into the docker host and execute the `docker images` command.
    You should see your docker image listed, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保容器实例实际上已经在本地安装了您的镜像。SSH进入docker主机并执行`docker images`命令。您应该看到您的docker镜像列在其中，如下所示：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What if my image does not appear?* Check the agent logs and make sure that
    your container instance is able to contact your docker registry by curling the
    registry and printing out the available tags:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我的镜像没有出现怎么办？*检查代理日志，并确保您的容器实例能够通过curl访问您的docker注册表并打印出可用的标签：'
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What $ sudo docker images tells us:** Our container image was successfully
    installed on the host.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ sudo docker images 告诉我们什么：**我们的容器镜像已成功安装在主机上。'
- en: Manually crank your Docker image
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动启动您的Docker镜像
- en: 'Now that we know our image is installed on the host, we need to know whether
    it is accessible to the Docker daemon. An easy way to test to make certain your
    image can be run on the container instance is by attempting to run your image
    from the command line. There is an added benefit here: we will now have the opportunity
    to additionally inspect application logs for further troubleshooting.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们的镜像已安装在主机上，我们需要知道它是否对Docker守护程序可访问。测试确保您的镜像可以在容器实例上运行的简单方法是尝试从命令行运行您的镜像。这里还有一个额外的好处：我们现在有机会进一步检查应用程序日志以进行进一步的故障排除。
- en: 'Let''s take a look at the following example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What $ sudo docker run <imagename> tells us:** Our container image is accessible
    from the docker daemon and also provides accessible output logs for further troubleshooting.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ sudo docker run <imagename>`告诉我们什么：**我们可以从docker守护程序访问容器镜像，并且还提供可访问的输出日志以进行进一步的故障排除。'
- en: '*What if my image does not run?* Check for any running containers. If the intended
    container isn''t running on the host, there may be issues preventing it from starting:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我的镜像无法运行？*检查是否有任何正在运行的容器。如果预期的容器没有在主机上运行，可能会有阻止它启动的问题：'
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When a container fails to start, it does not log anything. Output of logs for
    container start processes are located in `/var/log/containers` on the host. Here,
    you will find files following the naming convention of `<service>_start_errors.log`.
    Within these logs, you will find any output generated by our `RUN` command, and
    are a recommended starting point in troubleshooting as to why your container failed
    to start.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动失败时，它不会记录任何内容。容器启动过程的日志输出位于主机上的`/var/log/containers`中。在这里，您会找到遵循`<service>_start_errors.log`命名约定的文件。在这些日志中，您会找到我们的`RUN`命令生成的任何输出，并且这是故障排除的推荐起点，以了解为什么您的容器启动失败。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**TIP:** Logspout ([https://github.com/gliderlabs/logspout](https://github.com/gliderlabs/logspout)) is
    a log router for Docker containers that runs inside Docker. Logsprout attaches
    to all containers on a host, then routes their logs wherever you desire.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示：** Logspout ([https://github.com/gliderlabs/logspout](https://github.com/gliderlabs/logspout))
    是Docker容器的日志路由器，运行在Docker内部。Logspout附加到主机上的所有容器，然后将它们的日志路由到您想要的位置。'
- en: While we can also peruse the `/var/log/messages` output in our attempts to troubleshoot,
    there are a few other avenues we can persue, albeit a little more labor intensive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们也可以查看`/var/log/messages`中的输出来尝试故障排除，但我们还有一些其他途径可以追求，尽管可能需要更多的工作量。
- en: Examining the filesystem state from cache
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从缓存中检查文件系统状态
- en: As we've discussed, after each successful `RUN` command in our Dockerfiles,
    Docker caches the entire filesytem state. We can exploit this cache to examine
    the latest state prior to the failed `RUN` command.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，每次成功的`RUN`命令在我们的Dockerfile中，Docker都会缓存整个文件系统状态。我们可以利用这个缓存来检查失败的`RUN`命令之前的最新状态。
- en: 'To accomplish the task:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 完成任务的方法：
- en: Access the Dockerfile and comment out the failing `RUN` command, in addition
    to any and subsequent `RUN` commands
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Dockerfile并注释掉失败的`RUN`命令，以及任何后续的`RUN`命令
- en: Re-save the Dockerfile
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新保存Dockerfile
- en: Re-execute `$ sudo docker build` and `$ sudo docker run`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新执行`$ sudo docker build`和`$ sudo docker run`
- en: Image layer IDs as debug containers
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像层ID作为调试容器
- en: Every time Docker successfully executes a `RUN` command from a Dockerfile, a
    new layer in the image filesystem is committed. Conveniently, you can use those
    layers IDs as images to start a new container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每次Docker成功执行Dockerfile中的`RUN`命令时，图像文件系统中都会提交一个新的层。方便起见，您可以使用这些层ID作为图像来启动一个新的容器。
- en: 'Consider the following Dockerfile as an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Dockerfile作为示例：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we then build from this Dockerfile:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从这个Dockerfile构建：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We would get output similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得类似以下的输出：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can then use the preceding image layer IDs to start new containers from
    `b750fe79269d`, `de1d48805de2`, and `40fd00ee38e1`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用前面的图像层ID从`b750fe79269d`、`de1d48805de2`和`40fd00ee38e1`开始新的容器：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We employ `--rm` to remove all the debug containers since there is no reason
    to have them around postruns.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`--rm`来删除所有调试容器，因为没有理由让它们在运行后继续存在。
- en: '*What happens if my container build fails?* Since no image is created on a
    failed build, we''d have no hash of the container with which to ID. Instead, we
    can note the ID of the preceding layer and run a container with a shell of that
    ID:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我的容器构建失败会发生什么？*由于构建失败时不会创建任何映像，我们将无法获得容器的哈希ID。相反，我们可以记录前一层的ID，并使用该ID运行一个带有该ID的shell的容器：'
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once inside the container, execute the failing command in attempt to reproduce
    the issue, fix the command and test, and finally update the Dockerfile with the
    fixed command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，执行失败的命令以重现问题，修复命令并进行测试，最后使用修复后的命令更新Dockerfile。
- en: 'You may also want to start a shell and explore the filesystem, try out commands,
    and others:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想启动一个shell并浏览文件系统，尝试命令等等：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Additional example
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他示例
- en: 'One final example is to comment out of the following Dockerfile, including
    the offending line. We are then able to run the container and docker commands
    manually and look into the logs in the normal way. In this example Dockerfile:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是注释掉以下Dockerfile中的内容，包括有问题的行。然后我们可以手动运行容器和docker命令，并以正常方式查看日志。在这个Dockerfile示例中：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Also, the failure is at shoot, then comment out as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果失败是在射击，那么注释如下：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, build and run:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建和运行：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Checking failed container processes
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查失败的容器进程
- en: Even if your container successfully runs from the command line, it would prove
    beneficial to inspect for any failed container processes, for containers that
    are no longer running, and checking our container configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的容器成功从命令行运行，检查任何失败的容器进程，不再运行的容器，并检查我们的容器配置也是有益的。
- en: 'Run the following command to check for failed or no-longer running containers
    and note the `CONTAINER ID` to inspect a given container''s configuration:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来检查失败或不再运行的容器，并注意`CONTAINER ID`以检查特定容器的配置：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note the **STATUS** of the containers. Should any of your containers, **STATUS**
    show exit codes other than `0`, there could be issues with the container's configuration.
    By way of an example, a bad command would result in an exit code of `127`. With
    this information, you can troubleshoot the task definition `CMD` field to debug.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意容器的**状态**。如果您的任何容器的**状态**显示除`0`之外的退出代码，可能存在容器配置的问题。举个例子，一个错误的命令会导致退出代码为`127`。有了这些信息，您可以调试任务定义`CMD`字段。
- en: 'Although somewhat limited, we can further inspect a container for additional
    troubleshooting details:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些有限，但我们可以进一步检查容器以获取额外的故障排除细节：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, let''s also analyze the container''s application logs. Error messages
    for container start failures are output here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也分析一下容器的应用程序日志。容器启动失败的错误消息将在这里输出：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Other potentially useful resources
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他潜在有用的资源
- en: '`$ sudo docker` top gives us a list of processes running inside a container.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo docker` top给出了容器内运行的进程列表。'
- en: '`$ sudo docker htop` can be utilized when you need a little more detail than
    provided by `top` in a convenient, cursor-controlled inferface. `htop` starts
    faster than `top`, you can scroll the list vertically and horizontally to see
    all processes and complete command lines, and you do not need to type the process
    number to kill a process or the priority value to recieve a process.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要比`top`提供的更多细节时，可以使用`$ sudo docker htop`，它提供了一个方便的、光标控制的界面。`htop`比`top`启动更快，您可以垂直和水平滚动列表以查看所有进程和完整的命令行，您不需要输入进程号来终止进程或优先级值来接收进程。
- en: By the time this book goes to print, it is likely that the mechanisms for troubleshooting
    containers and images will have dramatically improved. Much focus is being given
    by the Docker community toward *baked-in* reporting and monitoring solutions,
    in addition to market forces that will certainly bring additional options to bear.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书付印时，排除容器和镜像的机制可能已经得到了显著改善。Docker社区正在致力于*内置*报告和监控解决方案，市场力量也必将带来更多的选择。
- en: Using sysdig to debug
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sysdig进行调试
- en: As with any newer technology, some of the initial complexities inherent with
    them are debugged in time, and newer tools and applications are developed to enhance
    their use. As we've discussed, containers certainly fit into this category at
    this time. While we have witnessed improvements in availability of official, standardized
    images within the Docker Registry, we are also now seeing emergent tools that
    help us to effectively manage, monitor, and troubleshoot our containers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何新技术一样，一些最初固有的复杂性会随着时间的推移而被排除，新的工具和应用程序也会被开发出来以增强它们的使用。正如我们所讨论的，容器目前确实属于这一类别。虽然我们已经看到Docker
    Registry中官方标准化镜像的可用性有所改善，但我们现在也看到了新出现的工具，这些工具可以帮助我们有效地管理、监视和排除我们的容器。
- en: '![Using sysdig to debug](graphics/image_03_016.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![使用sysdig进行调试](graphics/image_03_016.jpg)'
- en: Sysdig provides application monitoring for containers [Image Copyright © 2014
    Draios, Inc.]
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Sysdig为容器提供应用程序监控[图片版权© 2014 Draios, Inc.]
- en: '**Sysdig** ([http://www.sysdig.org/](http://www.sysdig.org/) [)](http://www.sysdig.org/) is
    one such tool. As an *au courant* application for system-level exploration and
    troubleshooting visibility into containerized environments, the beauty of `sysdig`
    is that we are able to access container data from the outside (even though `sysdig`
    can actually also be installed inside a container). From a top level, what `sysdig`
    brings to our container management is this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sysdig** ([http://www.sysdig.org/](http://www.sysdig.org/) [)](http://www.sysdig.org/) 就是这样的一个工具。作为一个用于系统级探索和排除容器化环境可见性的*au
    courant*应用程序，`sysdig`的美妙之处在于我们能够从外部访问容器数据（尽管`sysdig`实际上也可以安装在容器内部）。从高层来看，`sysdig`为我们的容器管理带来了以下功能：'
- en: Ability to access and review processes (inclusive of internal and external PIDs)
    in each container
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够访问和审查每个容器中的进程（包括内部和外部PID）
- en: Ability to drill-down into specific containers
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够深入到特定容器中
- en: Ability to easily filter sets of containers for process review and analysis
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够轻松过滤一组容器以进行进程审查和分析
- en: Sysdig provides data on CPU usage, I/O, logs, networking, performance, security,
    and system state. To repeat, this is all accomplishable from the outside, without
    a need to install anything into our containers.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Sysdig提供有关CPU使用、I/O、日志、网络、性能、安全和系统状态的数据。重申一遍，这一切都可以从外部完成，而无需在我们的容器中安装任何东西。
- en: We will make continued and valuable use of `sysdig` going forward in this book
    to monitor and troubleshoot specific processes related to our containers, but
    for now we will provide just a few examples toward troubleshooting our basic container
    processes and logs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中继续有效地使用`sysdig`来监视和排除与我们的容器相关的特定进程，但现在我们将提供一些示例来排除我们基本的容器进程和日志问题。
- en: Let's dig into `sysdig` by getting it installed on our host to show off what
    it can do for us and our containers!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装`sysdig`到我们的主机上，以展示它对我们和我们的容器可以做什么！
- en: Single step installation
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单步安装
- en: 'Installation of `sysdig` can be accomplished in a single step by executing
    the following command as root or with `sudo`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以root或`sudo`执行以下命令，可以在一步中完成`sysdig`的安装：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**NOTE:** `sysdig` is currently included natively in the latest Debian and
    Ubuntu versions; however, it is recommended to update/run installation for the
    latest packages.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**`sysdig`目前已在最新的Debian和Ubuntu版本中本地包含；但建议更新/运行安装以获取最新的软件包。'
- en: Advanced installation
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级安装
- en: According to the `sysdig` wiki, the advanced installation method may be useful
    for scripted deployments or containerized environments. It is also easy; the advanced
    installation method is enlisted for RHEL and Debian systems.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`sysdig`维基百科，高级安装方法可能对脚本化部署或容器化环境有用。它也很容易；高级安装方法已列入RHEL和Debian系统。
- en: What are chisels?
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是凿子？
- en: 'To get started with `sysdig`, we should understand some of its parlance, specifically
    **chisels**. In `sysdig`, chisels are little scripts (written in Lua) that analyze
    the `sysdig` event stream to perform useful actions. Events are efficiently brought
    to user level, enriched with context, and then scripts can be applied to them.
    Chisels work well on live systems, but can also be used with trace files for offline
    analysis. You can run as many chisels as you''d like, all at the same time. For
    example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`sysdig`，我们应该了解一些专业术语，特别是**凿子**。在`sysdig`中，凿子是一些小脚本（用Lua编写），用于分析`sysdig`事件流以执行有用的操作。事件被有效地带到用户级别，附加上下文，然后可以应用脚本。凿子在活动系统上运行良好，但也可以与跟踪文件一起用于离线分析。您可以同时运行尽可能多的凿子。例如：
- en: '`topcontainers_error` chisel will show us the top containers by number of errors.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`topcontainers_error` chisel将按错误数量显示顶部容器。'
- en: 'For a list of sysdig chisels:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有关sysdig凿子的列表：
- en: '`$ sysdig -cl` (use the `-i` flag to get detailed information about a specific
    chisel)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sysdig -cl`（使用`-i`标志获取有关特定凿子的详细信息）'
- en: '**Single container processes analysis**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**单容器进程分析**'
- en: 'Using the example of a `topprocs_cpu` chisel, we can apply a filter:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`topprocs_cpu`凿子的示例，我们可以应用过滤器：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These are the example results:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是示例结果：
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Unlike using `$ sudo docker top` (and similar), we can determine exactly which
    containers we want to see processes for; for example, the following example shows
    us processes from only the `wordpress` containers:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`$ sudo docker top`（以及类似）不同，我们可以确定我们想要查看进程的确切容器；例如，以下示例仅显示来自`wordpress`容器的进程：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Other Useful Sysdig Chisels & Syntax**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他有用的Sysdig凿子和语法**'
- en: '`topprocs_cpu` shows top processes by CPU usage'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topprocs_cpu`按CPU使用率显示顶部进程'
- en: '`topcontainers_file` shows top containers by R+W disk bytes'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topcontainers_file`按R+W磁盘字节显示顶部容器'
- en: '`topcontainers_net` shows top containers by network I/O'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topcontainers_net`按网络I/O显示顶部容器'
- en: '`lscontainers` will list the running containers'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lscontainers`将列出正在运行的容器'
- en: '`$ sudo sysdig -pc -cspy_logs` analyzes all logs per screen'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ sudo sysdig -pc -cspy_logs`分析每个屏幕的所有日志'
- en: '`$ sudo sysdig -pc -cspy_logs container.name=zany_torvalds` prints logs for
    the container `zany_torvalds`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ sudo sysdig -pc -cspy_logs container.name=zany_torvalds`打印容器`zany_torvalds`的日志'
- en: Troubleshooting - an open community awaits you
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除-一个开放的社区等待您
- en: In general, most issues you may face have likely been experienced by others,
    somewhere and sometime before. The Docker and open source communities, IRC channels
    and various search engines, can provide resulting information that is highly accessible
    and likely to provide you with answers to situations, and conditions, that perplex.
    Make good use of the open source community (specifically, the Docker community)
    in getting the answers you are looking for. As with any emergent technology, in
    the beginning, we are all somewhat learning together!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可能遇到的大多数问题在其他地方和其他时间已经有人经历过。Docker和开源社区、IRC频道和各种搜索引擎都可以提供高度可访问的信息，并可能为你提供解决困扰的情况和条件的答案。充分利用开源社区（特别是Docker社区）来获取你所寻找的答案。就像任何新兴技术一样，在开始阶段，我们都在一起学习！
- en: Automated image building
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化镜像构建
- en: There are many ways we can go about automating our processes for building container
    images; too many to reasonably provide a full disclosure of approaches within
    a single book. In later chapters of this book, we will delve more deeply into
    a range of automation options and tools. In this particular instance, we are only
    speaking of automation using our Dockerfile. We have already discussed in general
    that Dockerfiles can be used in automating our image building, so let's take a
    more dedicated look into Dockerfile automation specifically.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以自动化构建容器镜像的过程；在一本书中无法合理地提供所有方法。在本书的后面章节中，我们将更深入地探讨一系列自动化选项和工具。在这种特定情况下，我们只讨论使用我们的Dockerfile进行自动化。我们已经讨论过Dockerfile可以用于自动化镜像构建，所以让我们更专门地研究Dockerfile自动化。
- en: Unit tested deployments
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试部署
- en: During the build process, Docker allows us to run any command. Let's take advantage
    of this to enable unit tests while building our image. These unit tests can help
    to identify problems in our production image before we push them to staging or
    deployment, and will at least partially verify the image functions the way we
    intend and expect. If the unit tests run successfully, we have a degree of confidence
    that we have a valid runtime environment for our service. This also means that
    should the tests fail, our build will fail, effectively keeping a nonworking image
    out of its  production.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，Docker允许我们运行任何命令。让我们利用这一点，在构建镜像的同时启用单元测试。这些单元测试可以帮助我们在将镜像推送到分阶段或部署之前识别生产镜像中的问题，并且至少部分验证镜像的功能是否符合我们的意图和期望。如果单元测试成功运行，我们就有了一定程度的信心，我们有一个有效的服务运行环境。这也意味着，如果测试失败，我们的构建也会失败，有效地阻止了一个不工作的镜像进入生产环境。
- en: Using our `cloudconsulted/joomla` repository image from prior, we will set up
    a sample workflow for automated builds, with testing. **PHPUnit** is what we will
    use since it is officially used by the Joomla! project's development teams, as
    it can conveniently run unit tests against our entire stack-the Joomla code, Apache,
    MySQL, and PHP.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前的`cloudconsulted/joomla`仓库镜像，我们将建立一个自动构建的示例工作流程，并进行测试。我们将使用**PHPUnit**，因为它是Joomla项目开发团队正式使用的工具，它可以方便地针对整个堆栈（Joomla代码、Apache、MySQL和PHP）运行单元测试。
- en: Drop in to your Dockerfile directory for `cloudconsulted/joomla` (in our case,
    `dockerbuilder`) and update it as follows.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`cloudconsulted/joomla`的Dockerfile目录（在我们的例子中是`dockerbuilder`），并进行以下更新。
- en: 'Install PHPUnit executing the following commands:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令安装PHPUnit：
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'PHPUnit can also be installed executing the following commands:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit也可以通过执行以下命令进行安装：
- en: '[PRE65]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, let's run our unit tests with `phpunit:`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`phpunit`运行我们的单元测试：
- en: '[PRE66]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also need to make sure that we `COPY` our unit tests to the assets inside
    our image:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保将我们的单元测试`COPY`到镜像内的资产中：
- en: '[PRE67]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Lastly, let''s do some house cleaning. To ensure that our production code cannot
    rely (accidentally or otherwise) on the test code, once the unit tests complete
    we should delete those test files:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们做一些清理工作。为了确保我们的生产代码不能依赖（无论是意外还是其他原因）测试代码，一旦单元测试完成，我们应该删除那些测试文件：
- en: '[PRE68]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Our total updates to the Dockerfile included:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Dockerfile的总更新包括：
- en: '[PRE69]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, we have a scripted Dockerfile that, each and every time we build this image,
    will fully test our Joomla code, Apache, MySQL, and PHP dependencies as a literal
    part of the build process. The results are a tested, reproducible production environment!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个脚本化的Dockerfile，每次构建此镜像时，都将完全测试我们的Joomla代码、Apache、MySQL和PHP依赖项，作为构建过程的一个文字部分。结果是一个经过测试的、可重现的生产环境！
- en: Automating tested deployments
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试部署
- en: With our heightened confidence in producing workable images for deployment,
    this build process still requires a developer or DevOps engineer to rebuild the
    image before every production push. Instead, we will rely on automated builds
    from our Docker and GitHub repositories.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对部署可行图像的信心增强之后，这个构建过程仍然需要开发人员或DevOps工程师在每次生产推送之前重新构建镜像。相反，我们将依赖于来自我们的Docker和GitHub存储库的自动构建。
- en: Our GitHub and Docker Hub repositories will serve to automate our builds. By
    maintaining our Dockerfiles, dependencies, related scripts, and so on on GitHub,
    any pushes or commits to update files on the repository will automatically force
    an updating push to the synced Docker Hub repository. Our production images for
    pull on Docker Hub are automatically updated with any new build information.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GitHub和Docker Hub存储库将用于自动化我们的构建。通过在GitHub上维护我们的Dockerfile、依赖项、相关脚本等，对存储库进行任何推送或提交将自动强制将更新的推送到同步的Docker
    Hub存储库。我们在Docker Hub上拉取的生产图像会自动更新任何新的构建信息。
- en: Docker Clouds is one of the latest offerings to complete the app life cycle,
    it provides a hosted registry service with build and testing facilities. Docker
    Cloud expands on the feature of Tutum and brings a tighter integration with Docker
    Hub. With the help of a Docker Cloud system, admins can deploy and scale applications
    in the cloud with just a few clicks. Continuous deliver the code integrated and
    automated with build, test and deployment workflows. It also provides visibility
    across the containers of the entire infrastructure and accesses the programmatic
    RESTful APIs for a developer-friendly CLI tool. Thus, Docker Cloud can be used
    for automating the build process and test deployments.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Cloud是最新的应用程序生命周期的一部分，它提供了一个托管的注册服务，具有构建和测试设施。Docker Cloud扩展了Tutum的功能，并与Docker
    Hub更紧密地集成。借助Docker Cloud系统，管理员可以仅需点击几下即可在云中部署和扩展应用程序。持续交付代码集成和自动化构建、测试和部署工作流程。它还提供了对整个基础架构容器的可见性，并访问面向开发人员友好的CLI工具的程序化RESTful
    API。因此，Docker Cloud可用于自动化构建过程和测试部署。
- en: 'The following are the important features of Docker Cloud:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Docker Cloud的重要特性：
- en: Allows the building of Docker images and also linking cloud repositories to
    a source code in order to ease the process of image building
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许构建Docker镜像，并将云存储库链接到源代码，以便简化镜像构建过程
- en: It allows linking your infrastructure and cloud services to provision new nodes
    automatically
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许将您的基础架构和云服务链接起来，以自动提供新节点
- en: Once the image has been built, it can be used to deploy services and can be
    linked with Docker Cloud's collection of services and microservices
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，它可以用于部署服务，并可以与Docker Cloud的服务和微服务集合进行链接
- en: Swarm management in beta mode is available for creating swarm within Docker
    Clouds or registering the existing swarms to Docker Clouds using Docker ID
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Cloud中，beta模式下的Swarm管理可用于在Docker Cloud中创建swarm或将现有的swarm注册到Docker Cloud中使用Docker
    ID
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Docker and Dockerfiles provide repeatable processes across the application development
    cycle, providing a distinctive facility for both developers and DevOps engineers-production-ready
    deployments, infused with the confidence of tested images and the ease of automation.
    This provides a high level of empowerment to those needing it most, and results
    in the continuous delivery of tested and production-ready image building that
    we can fully automate, extended as far out as, and across, our clouds.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Docker和Dockerfiles为应用程序开发周期提供了可重复的流程，为开发人员和DevOps工程师提供了独特的便利-生产就绪的部署，注入了经过测试的镜像的信心和自动化的便利。这为最需要的人提供了高度的赋权，并导致了经过测试和生产就绪的图像构建的持续交付，我们可以完全自动化，延伸到我们的云端。
- en: In this chapter, we learned that a mission-critical task in a production-ready
    application containerization is image building. The building of base and layered
    images and avoiding areas for troubleshooting are the primary topics we covered.
    In building our base images, we saw that the Docker Registry provides ample and
    validated images that we can freely use for repeatable processes. We also canvassed
    building images manually, from scratch. Moving forward, we explored building layered
    images with a Dockerfile and enlisted the Dockerfile commands in detail. Finally,
    an example workflow illustrated automated image building with baked-in testing
    of images and containers. Throughout, we highlighted the ways and means for troubleshooting
    areas and options.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到生产就绪的应用程序容器化中的一项关键任务是图像构建。构建基本和分层镜像以及避免故障排除的领域是我们涵盖的主要主题。在构建我们的基本镜像时，我们看到Docker
    Registry提供了丰富和经过验证的图像，我们可以自由地用于可重复的流程。我们还讨论了手动构建图像，从头开始。前进的时候，我们探讨了使用Dockerfile构建分层图像，并详细列出了Dockerfile命令。最后，一个示例工作流程说明了自动化图像构建以及镜像和容器的测试。在整个过程中，我们强调了故障排除领域和选项的方法和手段。
- en: Building succinct Docker images for your application container is vitally crucial
    for your application's functionality and maintainability. Now that we have learned
    about building base and layered images and basic ways to troubleshoot them, we
    will look foward to building real application images. In our next chapter, we
    will learn about planning and building multiple-tier applications with a proper
    set of images.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序容器构建简洁的Docker镜像对于应用程序的功能和可维护性至关重要。现在我们已经了解了构建基本和分层镜像以及基本的故障排除方法，我们将期待构建真实的应用程序镜像。在下一章中，我们将学习使用一组合适的镜像规划和构建多层应用程序。
