- en: Adding Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久性
- en: In this chapter, we will learn how to persist data that a microservice is using. As
    already mentioned in [Chapter 2](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Spring Boot*, we will use the Spring Data project to persist
    data to MongoDB and MySQL databases. The `project` and `recommendation` microservices
    will use Spring Data for MongoDB and the `review` microservice will use Spring
    Data for the **JPA** (short for the **Java Persistence API**) to access a MySQL
    database. We will add operations to the RESTful APIs to be able to create and
    delete data in the databases. The existing APIs for reading data will be updated
    to access the databases. We will run the databases as Docker containers, managed
    by Docker Compose, that is, in the same way as we run our microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何持久化微服务正在使用的数据。如在[第2章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中已经提到的，*Spring
    Boot简介*，我们将使用Spring Data项目将数据持久化到MongoDB和MySQL数据库中。`project`和`recommendation`微服务将使用Spring
    Data来操作MongoDB，而`review`微服务将使用Spring Data来操作**JPA**（Java持久性API）以访问MySQL数据库。我们将添加操作到RESTful
    API中，以便能够在数据库中创建和删除数据。现有的用于读取数据的API将被更新以访问数据库。我们将通过Docker Compose运行数据库作为Docker容器，即与我们运行微服务的方式相同。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding a persistence layer to the core microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向核心微服务添加持久层
- en: Writing automated tests that focus on persistence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写重点放在持久性上的自动化测试
- en: Using the persistence layer in the service layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务层中使用持久层
- en: Extending the composite service API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展复合服务API
- en: Adding databases to the Docker Compose landscape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库添加到Docker Compose景观中
- en: Manual testing of the new APIs and the persistence layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试新的API和持久层
- en: Updating the automated tests of the microservice landscape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新微服务景观的自动化测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but should be straightforward to modify to run on another platform such as Linux
    or Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但应该很容易修改为在其他平台上运行，如Linux或Windows。
- en: No new tools need to be installed in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不需要安装新工具。
- en: To access the databases manually, we will use the CLI tools provided in the
    Docker images used to run the databases. We will, however, expose the standard
    ports used for each database in Docker Compose—`3306` for MySQL and `27017` for
    MongoDB. This will enable you to use your local favorite database tools for accessing
    the databases in the same way as if they were running locally on your computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动访问数据库，我们将使用在运行数据库的Docker镜像中提供的CLI工具。但是，我们将在Docker Compose中公开每个数据库使用的标准端口—MySQL的`3306`和MongoDB的`27017`。这将使您能够使用您喜欢的本地数据库工具来访问数据库，就像它们在您的计算机上本地运行一样。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Following are some sample commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照书中描述的命令运行，下载源代码到一个文件夹，并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下是一些示例命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Boot 2.1.0 (and Spring 5.1.2)—the latest available version of Spring
    Boot at the time of writing this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用的是Spring Boot 2.1.0（和Spring 5.1.2）—这是撰写本章时可用的最新版本的Spring
    Boot。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter06` but
    are, in many cases, edited to remove non-relevant parts of the source code, such
    as comments and import and log statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter06`中的源代码，但在许多情况下，经过编辑以删除源代码的非相关部分，如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),* Adding
    Persistence*, which sees what it took to add persistence to the microservices
    using Spring Data, you can compare it with the source code for [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding API Description Using OpenAPI/Swagger*. You can use your favorite diff tool
    and compare the two folders, `$BOOK_HOME/Chapter05` and `$BOOK_HOME/Chapter06`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)中应用于源代码的更改，*添加持久性*，看看使用Spring
    Data为微服务添加持久性需要做些什么，您可以将其与[第5章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)的源代码进行比较，*使用OpenAPI/Swagger添加API描述*。您可以使用您喜欢的`diff`工具比较这两个文件夹，`$BOOK_HOME/Chapter05`和`$BOOK_HOME/Chapter06`。
- en: But first, let's see where we are heading
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但首先，让我们看看我们的目标是什么
- en: 'By the end of this chapter, we will have layers inside our microservices that
    look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们的微服务内部将看起来像下面这样的层次结构：
- en: '![](img/148fd8fc-30e4-4039-986a-554a4237bb7c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/148fd8fc-30e4-4039-986a-554a4237bb7c.png)'
- en: The **Protocol layer** is very thin, only consisting of `RestController` annotations
    and the common `GlobalControllerExceptionHandler`. The main functionality of each
    microservice resides in the service layers. The `product-composite` service contains
    an integration layer to communicate with the three core microservices. The core microservices
    will all have a **Persistence layer** used for communicating with their databases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议层**非常薄，只包含`RestController`注释和通用的`GlobalControllerExceptionHandler`。每个微服务的主要功能位于服务层。`product-composite`服务包含一个集成层，用于与三个核心微服务进行通信。所有核心微服务都将有一个用于与其数据库通信的**持久层**。'
- en: 'We will be able to see data stored in MongoDB with a command like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来查看存储在MongoDB中的数据：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of the command should look like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果应该如下所示：
- en: '![](img/396be685-3e82-4fc9-b871-3b6e72c7f6d8.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/396be685-3e82-4fc9-b871-3b6e72c7f6d8.png)'
- en: 'Regarding data stored in MySQL, we will be able to see it with a command like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存储在MySQL中的数据，我们可以使用以下命令查看：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the command should look as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果应该如下所示：
- en: '![](img/05445cec-486e-426e-8b16-b611e61649e5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05445cec-486e-426e-8b16-b611e61649e5.png)'
- en: '**Note:** The output from the `mongo` and `mysql` commands have been shortened
    for improved readability.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** `mongo`和`mysql`命令的输出已经缩短以提高可读性。'
- en: Let's see how to go about this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何进行这个过程。
- en: Adding a persistence layer to the core microservices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向核心微服务添加持久层
- en: Let's start with adding a persistence layer to the core microservices. Besides
    using Spring Data, we will also use a Java bean mapping tool, MapStruct, that
    makes it easy to transform between Spring Data entity objects and the API model
    classes. For further details, see [http://mapstruct.org/](http://mapstruct.org/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向核心微服务添加持久层开始。除了使用Spring Data外，我们还将使用Java bean映射工具MapStruct，它可以轻松地在Spring
    Data实体对象和API模型类之间进行转换。有关更多详细信息，请参见[http://mapstruct.org/](http://mapstruct.org/)。
- en: First, we need to add dependencies to MapStruct, Spring Data, and the JDBC drivers
    for the databases we intend to use. After that, we can define our Spring Data
    entity classes and repositories. The Spring Data entity classes and repositories
    will be placed in their own Java package, `persistence`. For example, for the
    product microservice, they will be placed in the Java package, `se.magnus.microservices.core.product.persistence`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加MapStruct、Spring Data和我们打算使用的数据库的JDBC驱动程序的依赖项。之后，我们可以定义Spring Data实体类和存储库。Spring
    Data实体类和存储库将放在它们自己的Java包中，即`persistence`。例如，对于产品微服务，它们将放在Java包`se.magnus.microservices.core.product.persistence`中。
- en: Adding dependencies
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'We will use MapStruct V1.3.0-Beta 2, so we start by defining a variable holding
    the version information in the build file for each core microservice, `build.gradle`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MapStruct V1.3.0-Beta 2，因此我们首先在每个核心微服务的构建文件`build.gradle`中定义一个包含版本信息的变量：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we declare a dependency on MapStruct:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明对MapStruct的依赖：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since MapStruct generates the implementation of the bean mappings at compile
    time by processing MapStruct annotations, we need to add an `annotationProcessor` and
    a `testAnnotationProcessor` dependency:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MapStruct通过处理MapStruct注释在编译时生成bean映射的实现，我们需要添加`annotationProcessor`和`testAnnotationProcessor`依赖项：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make the compile-time generation work in popular IDEs such as IntelliJ IDEA,
    we also need to add the following dependency:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编译时生成在流行的IDE（如IntelliJ IDEA）中工作，我们还需要添加以下依赖项：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using IntelliJ IDEA, you also need to ensure that support for annotation
    processing is enabled. Open Preferences and navigate to Build, Execute, Deployment |
    Compiler | Annotations Processors. Verify that the checkbox named Enable annotation
    processing is selected!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是IntelliJ IDEA，还需要确保启用了对注释处理的支持。打开首选项并导航到构建、执行、部署|编译器|注释处理器。验证已选择名为启用注释处理的复选框！
- en: 'For the `project` and `recommendation` microservices, we declare the following
    dependencies to Spring Data for MongoDB:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`project`和`recommendation`微服务，我们声明以下依赖项到Spring Data for MongoDB：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The test dependency to `de.flapdoodle.embed.mongo` enables us to run MongoDB
    embedded when we run JUnit-based tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 测试依赖项`de.flapdoodle.embed.mongo`使我们能够在运行基于JUnit的测试时运行嵌入式MongoDB。
- en: 'The `review` microservices will use Spring Data for JPA together with MySQL
    as its database in runtime and it will use an embedded database, H2, during tests.
    Therefore, it declares the following dependencies in its build file, `build.gradle`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`review`微服务将在运行时使用Spring Data for JPA与MySQL作为其数据库，并在测试期间使用嵌入式数据库H2。因此，它在构建文件`build.gradle`中声明以下依赖项：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Storing data with entity classes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实体类存储数据
- en: The entity classes are similar to the corresponding API model classes in terms
    of what fields they contain—see the Java package, `se.magnus.api.core`, in the
    `api` project. We will add two fields, `id`, and `version`, in the entity classes
    compared to the fields in the API model classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类与相应的API模型类在包含的字段方面是相似的——请参见`api`项目中的Java包`se.magnus.api.core`。与API模型类中的字段相比，我们将在实体类中添加两个字段`id`和`version`。
- en: The `id` field is used to hold the database identity of each stored entity—the
    primary key when using a relational database. We will delegate the responsibility
    to generate unique values of the identity field to Spring Data. Depending on the
    database used, Spring Data can delegate this responsibility to the database engine.
    In either case, the application code does not need to consider how a unique database
    `id` value is set. The `id` field is not exposed in the API, as a best practice
    from a security perspective. The fields in the model classes that identify an
    entity will be assigned a unique index in the corresponding entity class, to ensure
    consistency in the database from a business perspective.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段用于保存每个存储实体的数据库标识——在使用关系数据库时的主键。我们将委托生成唯一值的标识字段的责任给Spring Data。根据使用的数据库，Spring
    Data可以将这一责任委托给数据库引擎。无论哪种情况，应用程序代码都不需要考虑如何设置唯一的数据库`id`值。出于安全考虑，`id`字段不会在API中公开。在模型类中标识实体的字段将在相应的实体类中分配一个唯一索引，以确保从业务角度在数据库中的一致性。'
- en: The `version` field is used to implement optimistic locking, that is, allowing
    Spring Data to verify that updates of an entity in the database do not overwrite
    a concurrent update. If the value of the version field stored in the database
    is higher than the value of the version field in an update request, it indicates
    that the update is performed on stale data—the information to be updated has been
    updated by someone else since it was read from the database. Attempts to perform
    updates based on stale data will be prevented by Spring Data. In the section on
    writing persistence tests, we will see tests that verify the optimistic locking
    mechanism in Spring Data prevent updates performed on stale data. Since we only
    implement APIs for create, read, and delete operations, we will, however, not
    expose the version field in the API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`字段用于实现乐观锁定，即允许Spring Data验证数据库中实体的更新不会覆盖并发更新。如果数据库中存储的版本字段值高于更新请求中版本字段的值，则表示更新是基于过期数据执行的——要更新的信息自从从数据库中读取以来已被其他人更新。Spring
    Data将阻止基于过期数据执行更新的尝试。在编写持久性测试的部分中，我们将看到验证Spring Data中乐观锁定机制阻止基于过期数据执行更新的测试。由于我们只实现了创建、读取和删除操作的API，因此不会在API中公开版本字段。'
- en: 'The most interesting parts of the product entity class look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 产品实体类的最有趣的部分如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the observations from the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的观察结果：
- en: The `@Document(collection="products")` annotation is used to mark the class
    as an entity class used for MongoDB, that is, mapped to a collection in MongoDB
    with the name, `products`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Document(collection="products")`注解用于标记类作为用于MongoDB的实体类，即映射到MongoDB中名为`products`的集合。'
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`和`@Version`注解用于标记`id`和`version`字段，如前所述，由Spring Data使用。'
- en: The `@Indexed(unique = true)` annotation is used to get a unique index created
    for the business key, `productId`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Indexed(unique = true)`注解用于为业务键`productId`创建唯一索引。'
- en: 'The most interesting parts of the `Recommendation` entity class look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recommendation`实体类的最有趣的部分如下：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Added to the explanations for the preceding product entity, we can see how a
    unique compound index is created using the `@CompoundIndex` annotation for the
    compound business key based on the fields, `productId` and `recommendationId`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述产品实体的解释中，我们可以看到如何使用`@CompoundIndex`注解为基于字段`productId`和`recommendationId`的复合业务键创建唯一复合索引。
- en: 'Finally, the most interesting parts of the `Review` entity class look like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Review`实体类的最有趣的部分如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the observations from the preceding code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的观察结果：
- en: The `@Entity` and `@Table` annotations are used to mark the class as an entity
    class used for JPA—mapped to a table in a SQL database with the name, `products`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity`和`@Table`注解用于标记类作为JPA中的实体类，映射到SQL数据库中名为`products`的表。'
- en: The `@Table` annotation is also used to specify that a unique compound index
    shall be created for the compound business key based on the fields, `productId` and `reviewId`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Table`注解也用于指定基于字段`productId`和`reviewId`的复合业务键创建唯一复合索引。'
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data as explained previously. To direct Spring Data
    for JPA to automatically generate unique `id` values for the `id` field, we are
    using the `@GeneratedValue` annotation.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`和`@Version`注解用于标记`id`和`version`字段，如前所述，由Spring Data使用。为了指示Spring Data
    for JPA自动生成`id`字段的唯一值，我们使用了`@GeneratedValue`注解。'
- en: 'For full source code of the entity classes, see the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实体类的完整源代码，请参见以下内容：
- en: '`se.magnus.microservices.core.product.persistence.ProductEntity` in the `product`
    project'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductEntity`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationEntity` in
    the `recommendation` project'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.persistence.RecommendationEntity`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.persistence.ReviewEntity` in the `review`
    project'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.persistence.ReviewEntity`在`review`项目中'
- en: Defining repositories in Spring Data
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Data中定义存储库
- en: Spring Data comes with a set of base classes for defining repositories. We will
    use the base classes, `CrudRepository` and `PagingAndSortingRepository`. The `CrudRepository` base
    class provides standard methods for performing basic create, read, update, and
    delete operations on the data stored in the databases. The `PagingAndSortingRepository` base
    class adds support for paging and sorting to the `CrudRepository` base class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了一组用于定义存储库的基类。我们将使用基类`CrudRepository`和`PagingAndSortingRepository`。`CrudRepository`基类提供了在数据库中执行基本创建、读取、更新和删除操作的标准方法。`PagingAndSortingRepository`基类在`CrudRepository`基类的基础上添加了对分页和排序的支持。
- en: We will use the `CrudRepository` class as the base class for the `Recommendation`
    and `Review` repositories and the `PagingAndSortingRepository` class as the base
    class for the `Product` repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CrudRepository`类作为`Recommendation`和`Review`存储库的基类，以及`PagingAndSortingRepository`类作为`Product`存储库的基类。
- en: We will also add a few extra query methods to our repositories for looking up
    entities using the business key, `productId`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为我们的存储库添加一些额外的查询方法，以使用业务键`productId`查找实体。
- en: Spring Data supports defining extra query methods based on naming conventions
    for the signature of the method. For example, the `findByProductId(int productId)`
    method signature can be used to direct Spring Data to automatically create a query
    that returns entities from the underlying collection or table that has the `productId` field
    set to the value specified in the `productId` parameter when calling the query
    method. For more details on how to declare extra queries, see [https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data支持根据方法的签名定义额外的查询方法，基于命名约定。例如，`findByProductId(int productId)`方法签名可以用来指示Spring
    Data自动创建一个查询，该查询返回底层集合或表中`productId`字段设置为`productId`参数中指定的值的实体。有关如何声明额外查询的更多详细信息，请参见[https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation)。
- en: 'The `Product` repository class looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`存储库类看起来是这样的：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the `findByProductId` method might return zero or one product entity,
    the return value is marked to be optional by wrapping it in an `Optional` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`findByProductId`方法可能返回零个或一个产品实体，因此返回值被标记为可选，通过将其包装在`Optional`对象中。
- en: 'The `Recommendation` repository class looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recommendation`存储库类看起来是这样的：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the `findByProductId` method will return zero to many recommendation
    entities, so the return value is defined as a list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`findByProductId`方法将返回零个或多个推荐实体，因此返回值被定义为列表。
- en: 'Finally, the `Review` repository class looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Review`存储库类看起来是这样的：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since SQL databases are transactional, we have to specify the default transaction
    type—read-only in our case—for the query method, `findByProductId()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL数据库是事务性的，我们必须为查询方法`findByProductId()`指定默认的事务类型——在我们的情况下是只读。
- en: That's it—this is all it takes to establish a persistence layer for our core
    microservices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——这就是为我们的核心微服务建立持久性层所需的全部内容。
- en: 'For full source code of the repository classes, see the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关存储库类的完整源代码，请参见以下内容：
- en: '`se.magnus.microservices.core.product.persistence.ProductRepository` in the `product` project'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductRepository`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository` in
    the `recommendation` project'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.persistence.ReviewRepository` in the `review` project'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.persistence.ReviewRepository`在`review`项目中'
- en: Let's start using them by writing some persistence tests to verify that they
    work as intended.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些持久性测试来开始使用它们，以验证它们是否按预期工作。
- en: Writing automated tests that focus on persistence
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写重点放在持久性上的自动化测试
- en: When writing persistence tests, we want to start an embedded database when the
    tests begin and tear it down when the tests complete. However, we don't want the
    tests to wait for other resources to start up, for example, a web server such
    as Netty (which is required in runtime).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写持久性测试时，我们希望在测试开始时启动嵌入式数据库，并在测试完成时将其关闭。但是，我们不希望测试等待其他资源启动，例如运行时所需的Web服务器，如Netty。
- en: 'Spring Boot comes with two class level annotations tailored for this specific
    requirement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了两个类级别的注释，专门针对这个特定的需求：
- en: '`@DataMongoTest`: This starts up an embedded MongoDB database when the test
    starts.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataMongoTest`：这在测试开始时启动嵌入式MongoDB数据库。'
- en: '`@DataJpaTest`: This starts up an embedded SQL database when the test starts:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataJpaTest`：这在测试开始时启动嵌入式SQL数据库：'
- en: Since we added a test dependency in the build file for the review microservice
    to the H2 database, it will be used as the embedded SQL database.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从我们在构建文件中为审查微服务添加了对H2数据库的测试依赖项，它将被用作嵌入式SQL数据库。
- en: By default, Spring Boot configures the tests to roll back updates to the SQL
    database to minimize the risk of negative side effects on other tests. In our
    case, this behavior will cause some of the tests to fail. Therefore, automatic
    rollback is disabled with the class level annotation: `@Transactional(propagation
    = NOT_SUPPORTED)`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot配置测试以回滚对SQL数据库的更新，以最小化对其他测试的负面影响的风险。在我们的情况下，这种行为将导致一些测试失败。因此，使用类级别的注释禁用自动回滚：`@Transactional(propagation
    = NOT_SUPPORTED)`。
- en: The persistence tests for the three core microservices are similar to each other,
    so we will only go through the persistence tests for the `Product` microservice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务的持久性测试相互类似，因此我们只会讨论`Product`微服务的持久性测试。
- en: 'The test class declares a method, `setupDb()`, annotated with `@Before`, which
    is executed before each test method. The setup method removes any entities from
    previous tests in the database and inserts an entity that the test methods can
    use as a base for their tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类声明了一个方法`setupDb()`，使用`@Before`进行注释，该方法在每个测试方法之前执行。设置方法从数据库中删除以前测试的任何实体，并插入一个实体，测试方法可以将其用作其测试的基础：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next comes the various test methods. First out is a `create` test:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是各种测试方法。首先是一个`create`测试：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This test creates a new entity and verifies that it can be found using the `findByProductId()`
    method and wraps up with asserting that there are two entities stored in the database,
    the one created by the `setup` method and the one created by the test itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建一个新实体，并验证可以使用`findByProductId()`方法找到它，并最后断言数据库中存储了两个实体，一个是由`setup`方法创建的，另一个是测试本身创建的。
- en: 'The `update` test looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`测试如下所示：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test updates the entity created by the setup method, reads it again from
    the database using the standard `findById()` method, and asserts that it contains
    expected values for some of its fields. Note that, when an entity is created,
    its `version` field is set to `0` by Spring Data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试通过设置方法创建的实体，再次从数据库中使用标准的`findById()`方法读取它，并断言它包含一些字段的预期值。请注意，当实体被创建时，它的`version`字段被Spring
    Data设置为`0`。
- en: 'The `delete` test looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`测试如下所示：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test deletes the entity created by the `setup` method and verifies that
    it no longer exists in the database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试删除了由`setup`方法创建的实体，并验证它在数据库中不再存在。
- en: 'The `read` test looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`测试如下所示：'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test uses the `findByProductId()` method to get the entity created by the
    `setup` method, verifies that it was found, and then uses the local helper method, `assertEqualsProduct()`, to
    verify that the entity returned by `findByProductId()` looks the same as the entity
    stored by the setup method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用`findByProductId()`方法获取由`setup`方法创建的实体，验证它是否被找到，然后使用本地辅助方法`assertEqualsProduct()`来验证`findByProductId()`返回的实体是否与`setup`方法存储的实体相同。
- en: 'Next, it follows two test methods that verify alternative flows—handling of
    error conditions. First, is a test that verifies that duplicates are handled correctly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个验证替代流程的测试方法——处理错误条件。首先是一个验证重复项是否被正确处理的测试：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The test tries to store an entity with the same business key as used by the
    entity saved by the setup method. The test will fail if the save operation succeeds
    or if the save fails with an exception other than the expected, `DuplicateKeyException`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试尝试存储一个具有与由设置方法保存的实体相同的业务键的实体。如果保存操作成功，或者保存失败并出现预期之外的异常，测试将失败。
- en: 'The other negative test is, in my opinion, the most interesting test in the
    test class. It is a test that verifies a correct error handling in the case of
    updates of stale data—it verifies that the optimistic locking mechanism works.
    It looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的看法中，另一个负面测试是测试类中最有趣的测试。它是一个验证在更新陈旧数据时正确处理错误的测试，它验证了乐观锁定机制的工作。它如下所示：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is observed from the preceding code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以观察到以下内容：
- en: First, the test reads the same entity twice and stores it in two different variables, `entity1`
    and `entity2`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，测试两次读取相同的实体，并将其存储在两个不同的变量`entity1`和`entity2`中。
- en: Next, it uses one of the variables, `entity1`, to update the entity. The update
    of the entity in the database will cause the version field of the entity to be
    increased automatically by Spring Data. The other variable, `entity2`, now contains
    stale data, manifested by its version field that holds a lower value than the
    corresponding value in the database.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它使用变量`entity1`中的一个来更新实体。数据库中实体的更新将导致实体的版本字段由Spring Data自动增加。另一个变量`entity2`现在包含陈旧数据，其版本字段的值低于数据库中对应值。
- en: When the test tries to update the entity using the variable, `entity2`, that
    contains stale data, it is expected to fail by throwing an `OptimisticLockingFailureException`
    exception.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试尝试使用包含陈旧数据的变量`entity2`更新实体时，预计会通过抛出`OptimisticLockingFailureException`异常而失败。
- en: The test wraps up by asserting that the entity in the database reflects the
    first update, that is, contains the name `"n1"`, and that the version field has
    the value `1`, that is, only one update has been performed on the entity in the
    database.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试通过断言数据库中的实体反映了第一次更新，即包含名称`"n1"`，并且版本字段的值为`1`，即在数据库中对实体只进行了一次更新。
- en: 'Finally, the `product` service contains a test that demonstrates the usage
    of built-in support for sorting and paging in Spring Data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`product`服务包含一个测试，演示了Spring Data中对排序和分页的内置支持的使用：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is observed from the preceding code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以观察到以下内容：
- en: The test starts with removing any existing data, then inserts 10 entities with
    the `productId` field ranging from `1001` to `1010`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试从删除任何现有数据开始，然后插入`productId`字段从`1001`到`1010`的10个实体。
- en: Next, it creates `PageRequest`, requesting a page count of `4` entities per
    page and a sort order based on `ProductId` in ascending order.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它创建`PageRequest`，请求每页`4`个实体，并根据`ProductId`按升序排序。
- en: Finally, it uses a helper method, `testNextPage`, to read the expected three
    pages, verifying the expected product IDs in each page and verifying that Spring
    Data correctly reports back whether more pages exist or not.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它使用一个辅助方法`testNextPage`来读取预期的三个页面，验证每个页面中预期的产品ID，并验证Spring Data是否正确地报告是否存在更多页面。
- en: 'The helper method `testNextPage` looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法`testNextPage`如下所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The helper method uses the page request object, `nextPage`, to get the next
    page from the repository method, `findAll()`. Based on the result, it extracts
    the product IDs from the returned entities into a string and compares it to the
    expected list of product IDs. Finally, it returns a Boolean indicating whether
    more pages can be retrieved or not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法使用页面请求对象`nextPage`从存储库方法`findAll()`中获取下一页。根据结果，它将返回的实体中的产品ID提取到一个字符串中，并将其与预期的产品ID列表进行比较。最后，它返回一个布尔值，指示是否可以检索更多页面。
- en: 'For full source code of the three persistence test classes, see the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有关三个持久性测试类的完整源代码，请参见以下内容：
- en: '`se.magnus.microservices.core.product.PersistenceTests` in the `product` project'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.PersistenceTests`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.PersistenceTests` in the `recommendation` project'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.PersistenceTests`。'
- en: '`se.magnus.microservices.core.review.PersistenceTests` in the `review` project'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`review`项目中的`se.magnus.microservices.core.review.PersistenceTests`。'
- en: 'The persistence tests in the `product` microservice can be executed using Gradle
    with a command like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似以下命令的Gradle来执行`product`微服务中的持久性测试：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After running the tests, it should respond with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，应该会得到以下响应：
- en: '![](img/cf9108ce-73db-41ea-ab82-0bf1eb098921.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf9108ce-73db-41ea-ab82-0bf1eb098921.png)'
- en: With a persistence layer in place, we can update the service layer in our core
    microservices to use the persistence layer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了持久层，我们可以更新核心微服务中的服务层以使用持久层。
- en: Using the persistence layer in the service layer
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务层中使用持久层
- en: 'In this section, we will learn how to use the persistence layer in the service
    layer to store data and retrieve data from a database. We will go through the
    following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在服务层中使用持久层来存储数据和从数据库中检索数据。我们将按照以下步骤进行：
- en: Log the database connection URL.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录数据库连接URL。
- en: Add new APIs.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的API。
- en: Use the persistence layer.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用持久层。
- en: Declare a Java bean mapper.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个Java bean映射器。
- en: Update the service tests.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务测试。
- en: Log the database connection URL
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录数据库连接URL
- en: When scaling up the number of microservices where each microservice connects
    to its own database, I find myself, from time to time, in a situation where I'm
    not sure what database each microservice actually uses. Therefore, I usually add
    a log statement directly after the startup of a microservice that logs the connection
    URL that is used to connect to the database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展微服务的数量，每个微服务连接到自己的数据库时，我发现自己有时不确定每个微服务实际使用的数据库是什么。因此，我通常在微服务启动后直接添加一个日志语句，记录用于连接到数据库的连接URL。
- en: 'For example, the startup code for the `Product` service looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Product`服务的启动代码如下：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the log, the following type of output should be expected:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，应该期望到以下类型的输出：
- en: '![](img/96ba31d3-159d-4cca-a6b9-b3000522b943.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96ba31d3-159d-4cca-a6b9-b3000522b943.png)'
- en: For the full source code, see the `se.magnus.microservices.core.product.ProductServiceApplication` class
    in the `product` project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请参见`product`项目中的`se.magnus.microservices.core.product.ProductServiceApplication`类。
- en: Adding new APIs
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的API
- en: Before we can use the persistence layer for creating and deleting information
    in the database, we need to create the corresponding API operations in our core
    service APIs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的核心服务API中，为了在数据库中创建和删除信息，我们需要创建相应的API操作。
- en: 'The API operations for creating and deleting a product entity looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除产品实体的API操作如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The implementation of the delete operation will be idempotent, that is, it will
    return the same result if called several times. This is a valuable characteristic
    in fault scenarios. For example, if a client experience a network timeout during
    a call to a delete operation, it can simply call the delete operation again without
    worrying about varying responses, for example, OK (200) in response the first
    time and Not Found (404) in response to consecutive calls, or any unexpected side
    effects. This implies that the operation should return the status code OK (200)
    even though the entity no longer exists in the database.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的实现将是幂等的，也就是说，如果多次调用，它将返回相同的结果。这是在故障场景中的一个有价值的特性。例如，如果客户端在调用删除操作时遇到网络超时，它可以简单地再次调用删除操作，而不必担心不同的响应，例如第一次响应为OK（200），而连续调用的响应为未找到（404），或任何意外的副作用。这意味着该操作应该返回状态码OK（200），即使实体在数据库中已经不存在。
- en: The API operations for the `recommendation` and `review` entities look similar;
    however, note that, when it comes to the delete operation for `recommendation`
    and `review` entities, it will delete all `recommendations` and `reviews` for
    the specified `productId`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommendation`和`review`实体的API操作看起来类似；但是，需要注意的是，当涉及到`recommendation`和`review`实体的删除操作时，它将删除指定`productId`的所有`recommendations`和`reviews`。'
- en: 'For the full source code, see the following classes in the `api` project:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请参见`api`项目中的以下类：
- en: '`se.magnus.api.core.product.ProductService`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`'
- en: '`se.magnus.api.core.recommendation.RecommendationService`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.recommendation.RecommendationService`'
- en: '`se.magnus.api.core.review.ReviewService`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.review.ReviewService`'
- en: The use of the persistence layer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久层的使用
- en: The source code in the service layer for using the persistence layer is structured
    in the same way for all core microservices. Therefore, we will only go through
    the source code for the `Product` microservice.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用持久层的服务层中的源代码在所有核心微服务中都具有相同的结构。因此，我们只会讨论`Product`微服务的源代码。
- en: 'First, we need to inject the repository class from the persistence layer and
    a Java bean mapper class into the constructor:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将持久层的存储库类和Java bean映射类注入到构造函数中：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we will see how the Java mapper class is defined.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Java映射类是如何定义的。
- en: 'Next, the `createProduct` method is implemented as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`createProduct`方法的实现如下：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `create` method used the `save` method in the repository to store a new
    entity. It should be noted how the mapper class is used to convert Java beans
    between an API model class and an entity class using the two mapper methods, `apiToEntity()`
    and `entityToApi()`. The only error we handle for the `create` method is the `DuplicateKeyException`
    exception, which we convert into an `InvalidInputException` exception.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法使用存储库中的`save`方法来存储一个新实体。需要注意的是，映射器类如何使用两个映射方法`apiToEntity()`和`entityToApi()`来在API模型类和实体类之间转换Java
    bean。我们只处理`create`方法的`DuplicateKeyException`异常，将其转换为`InvalidInputException`异常。'
- en: 'The `getProduct` method looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProduct`方法如下：'
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After some basic input validation (that is, ensuring that `productId` is not
    negative), the `findByProductId()` method in the repository is used to find the
    product entity. Since the repository method returns an `Optional` product, we
    can use the `orElseThrow()` method in the `Optional` class to conveniently throw
    a `NotFoundException` exception if no product entity is found. Before the product
    information is returned, the `serviceUtil` object is used to fill in the currently
    used address of the microservice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些基本的输入验证（即确保`productId`不为负数）之后，仓库中的`findByProductId()`方法被用来查找产品实体。由于仓库方法返回一个`Optional`产品，我们可以使用`Optional`类中的`orElseThrow()`方法方便地抛出`NotFoundException`异常，如果没有找到产品实体。在返回产品信息之前，`serviceUtil`对象被用来填写微服务当前使用的地址。
- en: 'Finally, let''s see the `deleteProduct` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下`deleteProduct`方法：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `delete` method also uses the `findByProductId()` method in the repository
    and uses the `ifPresent()` method in the `Optional` class to conveniently delete
    the entity only if it exists. Note that the implementation is idempotent, that
    is, it will not report any failure if the entity is not found.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法也使用仓库中的`findByProductId()`方法，并使用`Optional`类中的`ifPresent()`方法方便地仅在实体存在时删除实体。请注意，该实现是幂等的，即如果未找到实体，则不会报告任何失败。'
- en: 'The source code for the three service implementation classes can be found at
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 三个服务实现类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product` project'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.ProductServiceImpl`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.services.ReviewServiceImpl` in the `review` project'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.services.ReviewServiceImpl`在`review`项目中'
- en: Declaring a Java bean mapper
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个Java bean映射器
- en: So, what about the magic Java bean mapper?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，魔术Java bean映射器呢？
- en: As already mentioned, we use MapStruct to declare our mapper classes. The use
    of MapStruct is similar in all three core microservices, so we will only go through
    the source code for the mapper object in the `Product` microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用MapStruct来声明我们的映射器类。在所有三个核心微服务中使用MapStruct是相似的，因此我们只会浏览`Product`微服务中的映射器对象的源代码。
- en: 'The mapper class for the `product` service looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务的映射器类如下所示：'
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is observed from the preceding code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以观察到以下内容：
- en: The `entityToApi()` method maps entity objects to the API model object. Since
    the entity class does not have a field for `serviceAddress`, the `entityToApi()`
    method is annotated to ignore `serviceAddress`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entityToApi()`方法将实体对象映射到API模型对象。由于实体类没有`serviceAddress`字段，因此`entityToApi()`方法被注释为忽略`serviceAddress`。'
- en: The `apiToEntity()` method maps API model objects to entity objects. In the
    same way, the `apiToEntity()` method is annotated to ignore the `id` and `version`
    fields that are missing in the API model class.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiToEntity()`方法将API模型对象映射到实体对象。同样，`apiToEntity()`方法被注释为忽略API模型类中缺少的`id`和`version`字段。'
- en: 'MapStruct does not only support mapping fields by name, but it can also be
    directed to map fields with different names. In the mapper class for the `Recommendation`
    service, the `rating` entity field is mapped to the API model field, `rate`, using
    the following annotations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: MapStruct不仅支持按名称映射字段，还可以指示将具有不同名称的字段进行映射。在`Recommendation`服务的映射器类中，使用以下注释将`rating`实体字段映射到API模型字段`rate`：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After a successful Gradle build, the generated mapping implementation can be
    found in the `build/classes` folder, for example, the `Product` service: `$BOOK_HOME/Chapter06/microservices/product-service/build/classes/java/main/se/magnus/microservices/core/product/services/ProductMapperImpl.java`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建Gradle后，生成的映射实现可以在`build/classes`文件夹中找到，例如，`Product`服务：`$BOOK_HOME/Chapter06/microservices/product-service/build/classes/java/main/se/magnus/microservices/core/product/services/ProductMapperImpl.java`。
- en: 'The source code for the three mapper classes can be found at the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 三个映射器类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.services.ProductMapper` in the `product`
    project'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.ProductMapper`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationMapper` in
    the `recommendation` project'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.RecommendationMapper`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.services.ReviewMapper` in the `review`
    project'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.services.ReviewMapper`在`review`项目中'
- en: Updating the service tests
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新服务测试
- en: The tests of the APIs exposed by the core microservices have been updated since
    the previous chapter with tests on the create and delete API operations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 自上一章以来，核心微服务暴露的API的测试已经更新，包括对创建和删除API操作的测试。
- en: The added tests are similar in all three core microservices, so we will only
    go through the source code for the service tests in the `Product` microservice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的测试在所有三个核心微服务中都是相似的，因此我们只会浏览`Product`微服务中的服务测试源代码。
- en: 'To ensure a known state for each test, a setup method, `setupDb()`, is declared
    and annotated with `@Before`, so it runs before each test runs. The setup method
    removes any previously created entities:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个测试的已知状态，声明了一个设置方法`setupDb()`，并用`@Before`进行注释，因此它会在每次测试运行之前运行。设置方法会移除任何先前创建的实体：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The test method for the create API verifies that a product entity can be retrieved
    after it has been created and that creating another product entity with the same
    `productId` results in an expected error, `UNPROCESSABLE_ENTITY`, in the response
    to the API request:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API的测试方法验证了在创建后可以检索到产品实体，并且使用相同的`productId`创建另一个产品实体会导致预期的错误`UNPROCESSABLE_ENTITY`在API请求的响应中：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test method for the delete API verifies that a product entity can be deleted
    and that a second delete request is idempotent—it also returns the status code
    OK, even though the entity no longer exists in the database:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 删除API的测试方法验证了可以删除产品实体，并且第二次删除请求是幂等的——即使实体不再存在于数据库中，它也会返回状态码OK：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To simplify sending the create, read, and delete requests to the API and verify
    the response status, three helper methods have been created:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化向API发送创建、读取和删除请求并验证响应状态，已创建了三个辅助方法：
- en: '`postAndVerifyProduct()`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postAndVerifyProduct()`'
- en: '`getAndVerifyProduct()`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAndVerifyProduct()`'
- en: '`deleteAndVerifyProduct()`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteAndVerifyProduct()`'
- en: 'The `postAndVerifyProduct()` method looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`postAndVerifyProduct()`方法如下所示：'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Added to performing the actual HTTP request and verifying its response code,
    the helper method also returns the body of the response for further investigations
    by the caller, if required. The other two helper methods for read and delete requests
    are similar and can be found in the source code pointed out at the beginning of
    this section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行实际的HTTP请求并验证其响应代码之外，辅助方法还返回响应的主体，以便调用者进一步调查（如果需要）。用于读取和删除请求的另外两个辅助方法类似，并且可以在本节开头指出的源代码中找到。
- en: 'The source code for the three service tests classes can be found at the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 三个服务测试类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product`
    project'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.ProductServiceApplicationTests`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` in the `review`
    project'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests`在`review`项目中'
- en: Now, lets move on to seeing how we extend a composite service API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展复合服务API。
- en: Extending the composite service API
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展复合服务API
- en: 'In this section, we will see how we can extend the composite API with operations
    for creating and deleting composite entities. We will go through the following
    steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何扩展复合API以进行创建和删除复合实体的操作。我们将按照以下步骤进行：
- en: Adding new operations in the composite service API
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复合服务API中添加新操作
- en: Adding methods in the integration layer
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集成层中添加方法
- en: Implementing the new composite API operations
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现新的复合API操作
- en: Updating the composite service tests
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新复合服务测试
- en: Adding new operations in the composite service API
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复合服务API中添加新操作
- en: 'The composite versions of creating and deleting entities and handling aggregated
    entities are similar to the create and delete operations in the core service APIs.
    The major difference is that they have annotations added for Swagger-based documentation. For
    an explanation of the usage of the Swagger annotations, `@ApiOperation` and `@ApiResponses`, 
    refer to [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml), *Adding API
    Description Using OpenAPI/Swagger*, the section, *Adding API specific documentation
    in ProductCompositeService*. The API operation for creating a composite product
    entity is declared as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除实体以及处理聚合实体的复合版本与核心服务API中的创建和删除操作类似。主要区别在于它们添加了基于Swagger的文档注释。有关Swagger注释`@ApiOperation`和`@ApiResponses`的用法，请参阅[第5章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)，*使用OpenAPI/Swagger添加API描述*，*在ProductCompositeService中添加API特定文档*。创建复合产品实体的API操作声明如下：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The API operation for deleting a composite product entity is declared as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 删除复合产品实体的API操作声明如下：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For the full source code, see the Java interface, `se.magnus.api.composite.product.ProductCompositeService`,
    in the `api` project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参阅`api`项目中的Java接口`se.magnus.api.composite.product.ProductCompositeService`。
- en: 'We also need to, as before, add the descriptive text of the API documentation
    to the property file, `application.yml`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们还需要将API文档的描述性文本添加到属性文件`application.yml`中：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For details, see the configuration file, `src/main/resources/application.yml`,
    in the `product-composite` project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅`product-composite`项目中的配置文件`src/main/resources/application.yml`。
- en: 'The updated Swagger documentation will look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的Swagger文档将如下所示：
- en: '![](img/52f270b1-6039-4d6e-ad95-f4a9a7029063.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52f270b1-6039-4d6e-ad95-f4a9a7029063.png)'
- en: Later on in this chapter, we will user the Swagger UI to try out the new composite
    API operations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将使用Swagger UI来尝试新的复合API操作。
- en: Adding methods in the integration layer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集成层中添加方法
- en: Before we can implement the new create and delete APIs in the composite services, we
    need to extend the integration layer so it can call the underlying create and
    delete operations in the APIs of the core microservices.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在复合服务中实现新的创建和删除API之前，我们需要扩展集成层，以便它可以调用核心微服务API中的基础创建和删除操作。
- en: The methods in the integration layer for calling the create and delete operations
    in the three core microservices are straightforward and similar to each other,
    so we will only go through the source code for the methods that call the `Product` microservice.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成层中调用三个核心微服务中的创建和删除操作的方法都很简单，且相互类似，因此我们只会查看调用`Product`微服务的方法的源代码。
- en: 'The `createProduct()` method looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`createProduct()`方法如下所示：'
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It simply delegates the responsibility of sending the HTTP request to the `RestTemplate`
    object and delegates error handling to the helper method, `handleHttpClientException`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将发送HTTP请求的责任委托给`RestTemplate`对象，并将错误处理委托给辅助方法`handleHttpClientException`。
- en: 'The `deleteProduct()` method looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteProduct()`方法如下所示：'
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is implemented in the same way as for the create method, but performs an
    HTTP delete request instead.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它的实现方式与创建方法相同，但执行的是HTTP删除请求。
- en: The full source code for the integration layer can be seen in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class in
    the `product-composite` project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 集成层的完整源代码可以在`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中看到。
- en: Implementing the new composite API operations
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新的组合API操作
- en: Now, we can implement the composite create and delete methods!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现组合创建和删除方法！
- en: 'The composite''s create method will split up the aggregate product object into
    discrete objects for `product`, `recommendation`, and `review` and call the corresponding
    create methods in the integration layer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的创建方法将将聚合产品对象拆分为`product`、`recommendation`和`review`的离散对象，并调用集成层中相应的创建方法：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The composite''s delete method simply calls the three delete methods in the
    integration layer to delete the corresponding entities in the underlying databases:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的删除方法简单地调用集成层中的三个删除方法，以删除底层数据库中对应的实体：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class in
    the `product-composite` project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: For happy day scenarios, this implementation will work fine, but if we consider
    various error scenarios this implementation will cause trouble!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于愉快的日常场景，这种实现会很好地工作，但是如果考虑到各种错误场景，这种实现将会带来麻烦！
- en: What if, for example, one of the underlying core microservices temporarily is
    not available, for example, due to internal, network, or database problems?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果其中一个底层核心微服务暂时不可用，例如由于内部、网络或数据库问题，会发生什么？
- en: This might result in partly created or deleted composite products. For the delete
    operation, this can be fixed if the requestor simply calls the composite's delete
    method until it succeeds. However, if the underlying problem remains for a while,
    the requestor will probably give up, resulting in an inconsistent state of the
    composite product—not acceptable in most cases!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致部分创建或删除的组合产品。对于删除操作，如果请求者简单地调用组合的删除方法直到成功，这个问题可以得到解决。然而，如果底层问题持续一段时间，请求者可能会放弃，导致组合产品处于不一致的状态——在大多数情况下是不可接受的！
- en: In the next chapter, [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, we will see how we can address these types of shortcomings
    with synchronous APIs as a RESTful API!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)，*开发响应式微服务*，我们将看到如何通过RESTful
    API解决同步API的这些缺点！
- en: For now, let's move on with this fragile design in mind.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续考虑这种脆弱的设计。
- en: Updating the composite service tests
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新组合服务测试
- en: 'Testing composite services, as already mentioned in [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating
    a Set of Cooperating Microservices* (refer to the *Automated tests of microservices
    in isolation *section), are limited to using simple mock components instead of
    the actual core services. This restricts us from testing more complex scenarios,
    for example, error handling when trying to create duplicates in the underlying
    databases. The tests of the composite create and delete API operations are therefore
    relatively simple:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)中已经提到的，测试组合服务（参见*在隔离中自动测试微服务*部分）受限于使用简单的模拟组件而不是实际的核心服务。这限制了我们无法测试更复杂的场景，例如在尝试在底层数据库中创建重复项时的错误处理。因此，组合创建和删除API操作的测试相对简单：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For the full source code, see the test class, `se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`,
    in the `product-composite` project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的测试类`se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`。
- en: Next, we will see how to add databases to the landscape of Docker Compose.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何将数据库添加到Docker Compose的架构中。
- en: Adding databases to the Docker Compose landscape
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库添加到Docker Compose架构中
- en: Now, we have all of the source code in place. Before we can start up the microservice
    landscape and try out the new APIs together with the new persistence layer, we
    must start up some databases.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有的源代码。在我们启动微服务架构并尝试新的API与新的持久层一起使用之前，我们必须启动一些数据库。
- en: We will bring MongoDB and MySQL into the system landscape controlled by Docker
    Compose and add configuration to our microservices so that they can find their
    databases when running, either with or without running as a Docker container.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把MongoDB和MySQL引入由Docker Compose控制的系统架构，并向我们的微服务添加配置，以便它们在运行时找到它们的数据库，无论是作为Docker容器运行还是不运行。
- en: The Docker Compose configuration
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose配置
- en: 'MongoDB and MySQL are declared as follows in the Docker Compose configuration
    file, `docker-compose.yml`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Compose配置文件`docker-compose.yml`中，MongoDB和MySQL声明如下：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is observed from the preceding code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以观察到以下内容：
- en: We will use the official Docker image for MongoDB V3.6.9 and MySQL 5.7 and forward
    their default ports `27017` and `3306` to the Docker host, also made available
    on `localhost` when using Docker for Mac.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用MongoDB V3.6.9和MySQL 5.7的官方Docker镜像，并将它们的默认端口`27017`和`3306`转发到Docker主机，同时在使用Docker
    for Mac时也可以在`localhost`上使用。
- en: 'For MySQL, we also declare some environment variables, defining the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于MySQL，我们还声明了一些环境变量，定义如下：
- en: The root password
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根密码
- en: The name of the database that will be created on image startup
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在图像启动时创建的数据库的名称
- en: A username and password for a user that is set up for the database on image
    startup
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像启动时为数据库设置的用户的用户名和密码
- en: For MySQL, we also declare a health check that Docker will run to determine
    the status of the MySQL database.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于MySQL，我们还声明了一个健康检查，Docker将运行以确定MySQL数据库的状态。
- en: 'To avoid problems with microservices that try to connect to their databases
    before the database is up and running,  the `product` and `recommendation` services
    are declared dependent on the `mongodb` database, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免微服务在数据库启动之前尝试连接到它们的数据库时出现问题，`product`和`recommendation`服务被声明依赖于`mongodb`数据库，如下所示：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This means that Docker Compose will not start up the `product` and `recommendation`
    containers until the `mongodb` container is launched.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Docker Compose不会启动`product`和`recommendation`容器，直到`mongodb`容器启动。
- en: 'For the same reason, the `review` service is declared dependent on the `mysql`
    database:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，`review`服务被声明依赖于`mysql`数据库：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the `review` service depends on the fact that the `mysql` container
    is not only launched, but also that the `mysql` containers health check reports
    are okay. The reason for this extra step is that the initialization of the `mysql`
    container includes setting up a database and creating a superuser for the database.
    This takes a few seconds and, to hold back the `review` service to startup before
    this is done, we direct Docker Compose to hold back the `review` container from
    being launched until the `mysql` container reports that it is operational through
    its health check.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`review`服务依赖于`mysql`容器不仅已启动，而且`mysql`容器的健康检查报告也是正常的。这个额外步骤的原因是`mysql`容器的初始化包括设置数据库和为数据库创建超级用户。这需要几秒钟的时间，为了阻止`review`服务在此之前启动，我们指示Docker
    Compose在`mysql`容器通过健康检查报告它已经可用之前阻止`review`容器的启动。
- en: Database connect configuration
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库连接配置
- en: With the database in place, we now need to set up the configuration for the
    core microservices so they know how to connect to their databases. This is set
    up in each core microservice's configuration file, `src/main/resources/application.yml`,
    in the `product`, `recommendation`, and `review` projects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库之后，现在我们需要设置核心微服务的配置，以便它们知道如何连接到它们的数据库。这是在每个核心微服务的配置文件`src/main/resources/application.yml`中设置的，包括`product`、`recommendation`和`review`项目。
- en: 'The configuration for the `product` and `recommendation` services are similar,
    so we will only look into the configuration of the `product` services. The following
    part of the configuration is of interest:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`recommendation`服务的配置类似，因此我们只会查看`product`服务的配置。配置的以下部分是感兴趣的：'
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is observed from the preceding code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中观察到以下内容：
- en: When running without Docker using the default Spring profile, the database is
    expected to be reachable on `localhost:27017`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不使用Docker时，使用默认的Spring配置文件，数据库应该可以在`localhost:27017`上访问。
- en: Setting the log level for `MongoTemplate` to `DEBUG` will allow us to see which
    MongoDB statements are executed in the log.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MongoTemplate`的日志级别设置为`DEBUG`将允许我们在日志中看到执行的MongoDB语句。
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on `mongodb:27017`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker中使用Spring配置文件`Docker`时，数据库应该可以在`mongodb:27017`上进行访问。
- en: 'The configuration for the `review` service, which affects how it connects to
    its SQL database, looks like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 影响`review`服务连接到其SQL数据库的配置如下：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is observed from the preceding code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中观察到以下内容：
- en: By default, Hibernate will be used by Spring Data JPA as the JPA Entity Manager.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data JPA将使用Hibernate作为JPA实体管理器。
- en: The `spring.jpa.hibernate.ddl-auto` property is used to tell Spring Data JPA
    to create new or update existing SQL tables during startup.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring.jpa.hibernate.ddl-auto`属性用于告诉Spring Data JPA在启动时创建新的或更新现有的SQL表。'
- en: '**Note:** It is strongly recommended to set the `spring.jpa.hibernate.ddl-auto` property to
    `none` in a production environment—this prevents Spring Data JPA to manipulate
    the structure of the SQL tables.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**强烈建议在生产环境中将`spring.jpa.hibernate.ddl-auto`属性设置为`none`，这可以防止Spring Data
    JPA操作SQL表的结构。'
- en: When running without Docker, using the default Spring profile, the database
    is expected to be reachable on `localhost` using the default port `3306`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不使用Docker时，使用默认的Spring配置文件，数据库应该可以在`localhost`上使用默认端口`3306`进行访问。
- en: By default, HikariCP is used by Spring Data JPA as the JDBC connection pool. To
    minimize startup problems on computers with limited hardware resources, the `initializationFailTimeout`
    parameter is set to 60 seconds. This means that the Spring Boot application will
    wait for up to 60 seconds during startup to establish a database connection.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data JPA使用HikariCP作为JDBC连接池。为了最小化在硬件资源有限的计算机上的启动问题，`initializationFailTimeout`参数设置为60秒。这意味着Spring
    Boot应用程序在启动期间将等待最多60秒来建立数据库连接。
- en: The log level settings for Hibernate will cause Hibernate to print the SQL statements
    used and the actual values used. Please note that, when used in a production environment,
    writing the actual values to the log should be avoided for privacy reasons.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hibernate的日志级别设置将导致Hibernate打印使用的SQL语句和实际使用的值。请注意，在生产环境中，出于隐私原因，应避免将实际值写入日志。
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on the `mysql` hostname using the default port `3306`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker中使用Spring配置文件`Docker`时，数据库应该可以在`mysql`主机名上使用默认端口`3306`进行访问。
- en: The MongoDB and MySQL CLI tools
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB和MySQL的CLI工具
- en: To be able to run the database CLI tools, the Docker Compose `exec` command
    can be used.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行数据库CLI工具，可以使用Docker Compose的`exec`命令。
- en: The commands described in this section will be used when we get to the manual
    tests in the next section. Don't try to run them now; they will fail since we
    have no databases up and running yet!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的命令将在下一节的手动测试中使用。现在不要尝试运行它们；因为我们还没有数据库正在运行，它们会失败！
- en: 'To start the MongoDB CLI tool, `mongo`, inside the `mongodb` container, run
    the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`mongodb`容器内的MongoDB CLI工具`mongo`，运行以下命令：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Enter `exit` to leave the `mongo` CLI.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`exit`退出`mongo` CLI。
- en: 'To start the MySQL CLI tool, `mysql`, inside the `mysql` container and log
    in to `review-db` using the user created at startup, run the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`mysql` CLI工具`mysql`，在`mysql`容器内并使用在启动时创建的用户登录到`review-db`，运行以下命令：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable, `MYSQL_PASSWORD`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql` CLI工具将提示您输入密码；您可以在`docker-compose.yml`文件中找到它。查找环境变量`MYSQL_PASSWORD`的值。'
- en: Enter `exit` to leave the `mysql` CLI.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`exit`以退出`mysql` CLI。
- en: We will see the usage of these tools in the next section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到这些工具的用法。
- en: If you prefer graphical database tools, you can run them locally as well, since
    both the MongoDB and the MySQL containers expose their standard ports on localhost.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢图形化数据库工具，您也可以在本地运行它们，因为MongoDB和MySQL容器都在本地主机上公开它们的标准端口。
- en: Manual tests of the new APIs and the persistence layer
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新API和持久层的手动测试
- en: Now, it is finally time to start everything up and test it manually using the
    Swagger UI.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于可以启动所有内容并使用Swagger UI手动测试它。
- en: 'Build and start the system landscape with the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建和启动系统景观：
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open the Swagger UI in a web browser, `http://localhost:8080/swagger-ui.html`,
    and perform the following steps on the web page:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开Swagger UI，`http://localhost:8080/swagger-ui.html`，并在网页上执行以下步骤：
- en: Click on product-composite-service-impl and the POST method to expand them.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`product-composite-service-impl`和`POST method`以展开它们。
- en: Click on the Try it out button and go down to the body field.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Try it out`按钮并滚动到body字段。
- en: Replace the default value, `0`,  of the `productId` field with `123456`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`productId`字段的默认值`0`替换为`123456`。
- en: Scroll down to the Execute button and click on it.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`Execute`按钮并点击它。
- en: Verify that the returned response code is `200`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证返回的响应代码是否为`200`。
- en: 'Following is a sample screenshot after hitting the Execute button:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是点击`Execute`按钮后的示例截图：
- en: '![](img/eb728f85-f6b7-42e9-89a2-41ed11559551.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb728f85-f6b7-42e9-89a2-41ed11559551.png)'
- en: 'In the log output from the `docker-compose up` command, we should be able to
    see output like the following (abbreviated for increased readability):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose up`命令的日志输出中，我们应该能够看到类似以下内容的输出（为了增加可读性而进行了缩写）：
- en: '![](img/1b2a26c1-fe45-49c0-95e9-9a8d4384351e.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b2a26c1-fe45-49c0-95e9-9a8d4384351e.png)'
- en: We can also use the database CLI tools to see the actual content in the different
    databases.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用数据库CLI工具来查看不同数据库中的实际内容。
- en: 'Look up content in the `product` service, that is, the `products` collection
    in MongoDB, with the following command:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令查找`product`服务中的内容，即MongoDB中的`products`集合：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Expect a response like:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '![](img/0b57bb76-075c-4cfd-9d65-43d2760a8200.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b57bb76-075c-4cfd-9d65-43d2760a8200.png)'
- en: 'Look up content in the `recommendation` service, that is, the `recommendations` collection
    in MongoDB, with the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`recommendation`服务中的内容，即MongoDB中的`recommendations`集合，使用以下命令：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Expect a response like:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '![](img/12d6b674-b3ac-4819-9fc8-5423d00c17af.png)10'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/12d6b674-b3ac-4819-9fc8-5423d00c17af.png)10'
- en: 'Look up content in the `review` service, that is, the `reviews` table in MySQL, with
    the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令查找`review`服务中的内容，即MySQL中的`reviews`表：
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `mysql` CLI tool will prompt you for a password; you can find it in the `docker-compose.yml` file.
    Look for the value of the environment variable, `MYSQL_PASSWORD`. Expect a response
    like the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql` CLI工具将提示您输入密码；您可以在`docker-compose.yml`文件中找到它。查找环境变量`MYSQL_PASSWORD`的值。期望得到如下响应：'
- en: '![](img/b408949c-fb6d-4b76-8976-556538b135d2.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b408949c-fb6d-4b76-8976-556538b135d2.png)'
- en: Bring down the system landscape by interrupting the `docker-compose up` command
    with *Ctrl + C*, followed by the command, `docker-compose down`. After this, let
    us see how to update the automated tests in a microservice landscape.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*Ctrl + C*中断`docker-compose up`命令，然后使用`docker-compose down`命令，将系统景观关闭。之后，让我们看看如何在微服务景观中更新自动化测试。
- en: Updating the automated tests of the microservice landscape
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新微服务景观的自动化测试
- en: The automated tests of the microservice landscape, `test-em-all.bash`, needs
    to be updated so that they ensure that the database of each microservice has a
    known state before it runs the tests.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新微服务景观的自动化测试`test-em-all.bash`，以确保在运行测试之前，每个微服务的数据库都处于已知状态。
- en: The script is extended with a setup function, `setupTestdata()`, which uses
    the composite's create and delete APIs to recreate the products that the tests
    use into a known state.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过设置函数`setupTestdata()`进行了扩展，该函数使用复合的创建和删除API来重新创建测试使用的产品，使其处于已知状态。
- en: 'The `setupTestdata` function looks like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupTestdata`函数如下所示：'
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It uses a helper function, `recreateComposite()`, to perform the actual requests
    to the create and delete APIs:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个辅助函数`recreateComposite()`来执行实际的请求来创建和删除API：
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `setupTestdata` function is called directly after the `waitForService`
    function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupTestdata`函数在`waitForService`函数之后直接调用：'
- en: '[PRE58]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The main purpose of the `waitForService` function is to verify that all microservices
    are up and running. In the previous chapter, the get API on the composite product
    service was used. In this chapter, the delete API is used instead. When using
    the get API, only the product core microservice is called if the entity is not
    found; the recommendation and `review` services will not be called to verify that
    they are up and running. The call to the delete API will also ensure that the
    *Not Found*-test on `productId 13` will succeed. Later on in this book, we will
    see how we can define specific APIs for checking the health state of a microservice
    landscape.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService`函数的主要目的是验证所有微服务是否已启动和运行。在上一章中，使用了复合产品服务上的get API。在本章中，改为使用delete
    API。当使用get API时，如果未找到实体，只会调用产品核心微服务；不会调用推荐和`review`服务以验证它们是否已启动和运行。对delete API的调用还将确保`productId
    13`的*Not Found*测试将成功。在本书的后面，我们将看到如何定义特定的API来检查微服务景观的健康状态。'
- en: 'Execute the updated test script with the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行更新后的测试脚本：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The execution should end by writing a log message like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应该以写入类似于这样的日志消息结束：
- en: '![](img/bcd02c04-4291-440a-96e4-0660e2792679.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd02c04-4291-440a-96e4-0660e2792679.png)'
- en: This ends updating of the automated tests of the microservice landscape.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了微服务景观的自动化测试更新。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how we can use Spring Data to add a persistence
    layer to the core microservices. We used the core concepts of Spring Data, repositories
    and entities, to store data in both MongoDB and MySQL using a programming model
    that is similar, even though not fully portable. We have also seen how Spring
    Boot's annotations, `@DataMongoTest` and `@DataJpaTest`, can be used to conveniently
    set up tests targeted for persistence; this is where an embedded database is started
    automatically before the test runs, but no other infrastructure that the microservice
    will need in runtime, for example, a web server such as Netty, is started up.
    This results in persistence tests that are easy to set up and that start with
    minimum overhead.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Spring Data为核心微服务添加持久层。我们使用了Spring Data的核心概念，仓库和实体，来存储数据，使用了类似的编程模型在MongoDB和MySQL中存储数据，尽管不是完全可移植的。我们还看到了Spring
    Boot的注解`@DataMongoTest`和`@DataJpaTest`，可以方便地设置针对持久性的测试；这是在测试运行之前自动启动嵌入式数据库，但不会启动微服务在运行时需要的其他基础设施，例如Netty这样的Web服务器。这导致了易于设置的持久性测试，并且以最小的开销开始。
- en: We have also seen how the persistence layer can be used by the service layer
    and how we can add APIs for creating and deleting entities, both core and composite
    entities.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了持久层如何被服务层使用，以及如何为创建和删除实体（核心实体和复合实体）添加API。
- en: Finally, we learned how convenient it is to start up databases such as MongoDB
    and MySQL in runtime using Docker Compose and how to use the new create and delete
    APIs to set up test data before running automated tests of the microservice-based
    system landscape.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了使用Docker Compose在运行时启动MongoDB和MySQL数据库以及如何使用新的创建和删除API在运行微服务系统景观的自动化测试之前设置测试数据是多么方便。
- en: However, one major concern was identified in this chapter. Updating (creating
    or deleting) a composite entity—an entity whose parts are stored in a number of
    microservices—using synchronous APIs can lead to inconsistencies, if not all involved
    microservices are updated successfully. This is, in general, not acceptable. This
    leads us into the next chapter, where we will look into why and how to build reactive
    microservices, that is, microservices that are scalable and robust.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中还发现了一个主要问题。使用同步API更新（创建或删除）复合实体（其部分存储在多个微服务中）可能会导致不一致，如果不是所有涉及的微服务都成功更新。这一般是不可接受的。这将引导我们进入下一章，我们将探讨为什么以及如何构建反应式微服务，即可扩展和健壮的微服务。
- en: Questions
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Spring Data, a common programming model based on entities and repositories,
    can be used for different types of database engines. From the source code examples
    in this chapter, what are the most important differences in the persistence code
    for MySQL and MongoDB?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Data是一个基于实体和仓库的通用编程模型，可以用于不同类型的数据库引擎。从本章的源代码示例中，MySQL和MongoDB的持久性代码中最重要的区别是什么？
- en: What is required to implement optimistic locking using Spring Data?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Data实现乐观锁定需要什么？
- en: What is MapStruct used for?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MapStruct用于什么？
- en: What does it mean that an operation is idempotent and why is that useful?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作是幂等的意思是什么，为什么这很有用？
- en: How can we access the data that is stored in the MySQL and MongoDB databases without
    using the API?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在不使用API的情况下访问存储在MySQL和MongoDB数据库中的数据？
