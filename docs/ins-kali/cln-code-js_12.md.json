["```js\nlet basket = [];\nfor (let i = 0; i < 3; i++) {\n  basket.push(\n    makeEgg()\n  );\n}\n```", "```js\nfunction getUnpaidInvoices(invoiceProvider) {\n  const unpaidInvoices = [];\n  const invoices = invoiceProvider.getInvoices();\n  for (var i = 0; i < invoices.length; i++) {\n    if (!invoices[i].isPaid) {\n      unpaidInvoices.push(invoices[i]);\n    }\n  }\n  return unpaidInvoices;\n}\n```", "```js\nfunction getUnpaidInvoices(invoiceProvider) {\n  return invoiceProvider.getInvoices().filter(invoice => {\n    return !invoice.isPaid;\n  });\n}\n```", "```js\nif (feature.isEnabled) {\n  // Do the task.\n}\n```", "```js\n// A feature that is disabled:\nfeature.flags; // => [Feature.DISABLED_FLAG]\n```", "```js\nlet featureIsEnabled = true;\n\nfor (let i = 0; i < feature.flags.length; i++) {\n  if (feature.flags[i] === Feature.DISABLED_FLAG) {\n    featureIsEnabled = false;\n    break;\n  }\n}\n\nif (!featureIsEnabled) {\n  for (let i = 0; i < feature.enabledTimeSlots.length; i++) {\n    if (feature.enabledTimeSlots[i].isNow()) {\n      featureIsEnabled = true;\n      break;\n    }\n  }\n}\n\nif (featureIsEnabled) {\n  // Do the task.\n}\n```", "```js\nclass Feature {\n  // (Other methods of the Feature class here,..)\n\n  _hasDisabledFlag() {\n    return this.flags.includes(Feature.DISABLED_FLAG);\n  }\n\n  _isEnabledTimeSlotNow() {\n    return this.enabledTimeSlots.filter(ts => ts.isNow()).length;\n  }\n\n  isEnabled() {\n    return !this._isDisabledFlag() && this._isEnabledTimeSlotNow();\n  }\n}\n```", "```js\nif (feature.isEnabled()) {\n  // Do the task.\n}\n```", "```js\u00a0or\u00a0`new fn()`)\n*   **Returning**\u00a0(returning from a function via either implicit or explicit\u00a0`return`)\n*   **Yielding**\u00a0(yielding from a generator via\u00a0`yield`)\n*   **Breaking**\u00a0(breaking from a loop or switch via\u00a0`break`)\n*   **Continuing**\u00a0(continuing an iteration via\u00a0`continue`)\n*   **Throwing**\u00a0(throwing an exception via\u00a0`throw`)\n\n# Invocation\n\nInvocation occurs, in its most simple form, by explicitly calling a function. We do this by attaching calling parentheses (`(...)`) to a value we know to be a function. This value on the left side of\u00a0`(...)`\u00a0can be a direct reference to a variable or property that holds a function or any expression that evaluates to a function:\n\n```", "```js\n\nTo construct instances, as we've explored, you can use the\u00a0`new`\u00a0operator. This is also a type of invocation although, in the case of zero arguments, it doesn't technically require calling parentheses:\n\n```", "```js\n\nThe exact syntax of evaluation before the calling parentheses (on the left side of\u00a0`(...)`) is not important as long as it evaluates to a function. If it does not, then you will receive `TypeError`:\n\n```", "```js\n\nWhen a function is called, JavaScript will create a new\u00a0**Lexical Environment**\u00a0(a scope) in which that function will be evaluated, and the function will become the current *execution context*, shifting control from the current area of code to the function's code. This should not be too unintuitive. It makes sense that, in the code,\u00a0`foo();`, `baz();`, and\u00a0`foo()`\u00a0will be given control and will run to completion before\u00a0`baz()`\u00a0is then given control.\n\nA function will return control to you in the following ways:\n\n*   By\u00a0*returning*\u00a0(implicitly or via an explicit\u00a0`return`\u00a0statement)\n*   By\u00a0*throwing*\u00a0(implicitly due to\u00a0`SyntaxError`,\u00a0`TypeError`, and so on or via an explicit\u00a0`throw`\u00a0statement)\n*   By\u00a0*yielding*\u00a0(in the case of a generator)\n\nInvocation can also occur indirectly, via JavaScript's internal mechanisms. For example, in the case of coercion, as explored in the last chapter, methods such as\u00a0`valueOf`,\u00a0`toString`,\u00a0or\u00a0`Symbol.toPrimitive`\u00a0may be called in various scenarios. Additionally, JavaScript enables you to define\u00a0*setters*\u00a0and\u00a0*getters*\u00a0so that your custom functionality is activated whenever a given property is accessed or assigned to:\n\n```", "```js\n\nBy assigning to the\u00a0`name`\u00a0property here, we are effectively invoking a function, which itself may then do all manner of things, potentially invoking other functions itself. You can imagine how the control flow of a given program can become potentially incomprehensible when there are many implicit means of invocation such as this. Such implicit mechanisms do have their advantages, but if too much of our problem domain's logic is embedded within such places, then it's less plainly visible to our fellow programmers and hence more likely to cause confusion.\n\n# Returning\n\n*Returning* is a shift of control from a function to its caller. It is achieved either via an explicit\u00a0`return`\u00a0statement within the function itself or implicitly when the function runs to completion:\n\n```", "```js\n\nHere, you'll notice that we don't bother placing the implied `else`\u00a0condition of a falsy name in its own else block (`else {...}`) as this would be unnecessary. Because we return when the name is truthy, any code following that return statement will therefore only run in the implied `else`\u00a0condition. It's quite common to see such patterns in functions that carry out preemptive input checks:\n\n```", "```js\n\nAs we see here, returning is not only used to return control to the caller but also\u00a0for its side-effect: avoiding work that exists on lines below itself in its function. This is often termed *returning early*\u00a0and can significantly help to reduce the overall complexity of a function.\n\n# Yielding\n\n*Yielding* is a shift of control between a generator and its caller. It is achieved by the\u00a0`yield`\u00a0expression, which can optionally designate a value to its right side (the yielded value). It is only valid to use a `yield` statement within a generator function:\n\n```", "```js\n\nIf you yield without a value (`yield;`) then the result will be the same as yielding\u00a0`undefined`.\u00a0\n\nYielding will force any subsequent calls to the generator function to continue evaluation from the point of yield (as if the yield hadn't occurred). Yielding can be thought of as\u00a0*pausing*\u00a0a function with the prospect of coming back to it later. We can see this in action if we log which part of our generator runs during consecutive calls:\n\n```", "```js\n\nThis will log the following:\n\n*   `\"Calling first time\"`\n*   ``\"Chunk A\"``\n*   `\"Done calling first time\"`\n*   `\"Calling second time\"`\n*   `\"Chunk B\"`\n*   `\"Done calling second time\"`\n\nIt is also possible to return from a generator function with a regular\u00a0`return;`\u00a0statement. This is the same as yielding for the final time. That is, no further code will ever be run within that generator.\u00a0\n\n# Yielding to a yield\n\nYielding is not necessarily a shift of control in just one direction. You can use a generator as a *data consumer*\u00a0or *observer*. In such scenarios, when a caller requests the next yielded value by calling\u00a0`iterable.next()`,\u00a0it can optionally pass an argument to this\u00a0`next()`\u00a0method. Whatever value is passed will then cause the `yield` expression within the generator to evaluate to that value.\n\nThis is more easily explained with an example. Here, we have created a generator that consumes numbers and yields the sum of all numbers previously consumed:\n\n```", "```js\n\nHere, we are using the return value of our\u00a0`yield`\u00a0expression (`yield n`) and then adding it to the existing value of\u00a0`n`\u00a0on each run of the generator. We need to call\u00a0`next()`\u00a0once initially to kick things off as, before this, the `n += yield n`\u00a0expression\u00a0has not been run and is hence is not *waiting for*\u00a0a\u00a0`next()`\u00a0call yet.\u00a0\u00a0\n\nUsing generators as consumers does not have many use cases and can be quite an awkward pattern to employ since we must use the designated `next()` method to pass in data. It is, however, useful to know about the flexibility of the `yield` expression since you may encounter it in the wild.\n\n# Complexity of yielding\n\nFor fellow programmers, comprehending the flow of control within generators can be complicated and counter-intuitive since it involves a lot of *back-and-forth*\u00a0between the caller and the generator.\u00a0Knowing what exact code is running at any specific point may be difficult to determine and so it is advisable to keep your generators short and ensure that they yield consistently\u2014in other words, don't have too many different pathways of yielding within your generators and generally attempt to keep *cyclomatic complexity* quite low (you can read more about this if you skip ahead to the *Handling cyclomatic complexity*\u00a0section).\n\n# Breaking\n\n*Breaking* is a shift of control from within the current\u00a0`for`,\u00a0`while`,\u00a0`switch`, or\u00a0labeled statement to the code following the statement. It effectively terminates the statement, preventing any following code from being executed.\n\nIn the context of iteration, whether or not to continue or break from iteration is usually determined by `ConditionExpression`\u00a0within the construct itself (for example,\u00a0`counter < array.length`), or by the length of the data structure in the case of\u00a0`for..in`\u00a0and\u00a0`for..of`. However, it may still be necessary, at times, to *break out*\u00a0of the iteration early.\n\nFor example, if you are looking for a specific item within a data structure (a\u00a0*needle-in-a-haystack*\u00a0situation), then it would make sense to stop looking once the item is found. We achieve that by breaking:\n\n```", "```js\n\nBreaking from an iteration will immediately halt and exit the iteration, meaning any remaining code within the containing\u00a0`IterationBody`\u00a0will not be run. The code immediately following `IterationBody`\u00a0will then run.\n\nThe\u00a0`break`\u00a0statement is also used to break out from\u00a0`switch`\u00a0statements, typically when you have executed the relevant\u00a0`case`\u00a0statement. As we will discuss later in this chapter, the\u00a0`switch`\u00a0statement will transfer control to the\u00a0`case`\u00a0statement that is considered strictly equal (`===`) to the value passed to\u00a0`switch(...)`, and will then run all code following that\u00a0`case`\u00a0statement until an explicit\u00a0`break;`\u00a0(or\u00a0`return;`,\u00a0`yield;`, or\u00a0`throw;`) occurs:\n\n```", "```js\n\nHere, we see that a value of\u00a0`2`\u00a0shifts control to the matching\u00a0`case 2`, and then all of the following code within the switch's body will run naturally until a\u00a0`break;`\u00a0statement is encountered. Hence, we only see logs for\u00a0`2`,\u00a0`3`,\u00a0and\u00a0`4`. A log for\u00a0`1`\u00a0is avoided as\u00a0`case 1`\u00a0does not match the value,\u00a0`2`, and a log for\u00a0`5`\u00a0is avoided as `break;`\u00a0occurs before it.\n\nWhen\u00a0`case`\u00a0within\u00a0`switch`\u00a0does not break, it is called **fallthrough**. This common technique used in\u00a0`switch`\u00a0statements is useful when you want to carry out a single action or cascade of actions based on more than one matching condition (we will cover this concept more in the\u00a0*The*\u00a0*switch statement se*).\n\nTo the right side of the `break` keyword there may\u00a0be a label that refers to the\u00a0`switch`,\u00a0`for`,\u00a0or\u00a0`while`\u00a0statement.\u00a0If you don't supply a label, then JavaScript will assume you are referring to the current containing iteration or\u00a0`switch`\u00a0construct. This is only useful when you have two or more breakable constructs within each other, for example, an iteration within an iteration. Observe here how we've labeled our outer `for` loop with the\u00a0`outerLoop`\u00a0label, enabling us to break out of it from within the inner `for` loop:\n\n```", "```js\n\nYou can, in fact, break out of\u00a0any\u00a0labeled statement (even if it is outside of an iteration or\u00a0`switch`\u00a0construct) but you must explicitly provide the label:\n\n```", "```js\n\nThis is very rarely applicable but is nonetheless worth knowing about in case you ever run into such code.\n\nOne last thing to note on *breaking out*\u00a0of iterations or\u00a0`switch`\u00a0statements is that, although we typically do so by using an explicit\u00a0`break;`\u00a0statement, it is something that can also effectively occur via other mechanisms of moving control such as\u00a0*yielding*,\u00a0*returning*,\u00a0or\u00a0*throwing*. It's quite common, for example, to see an iteration that uses\u00a0`return;`\u00a0to *break out*\u00a0not only of itself but also of the containing function.\n\n# Continuing\n\n*Continuing* is a shift of control from the current statement to the potential start of the next iteration. It is achieved via a\u00a0`continue`\u00a0statement.\n\nThe `continue` statement is valid in all iteration constructs, including\u00a0`for`,\u00a0`while`,\u00a0`do...while`,\u00a0`for...in`,\u00a0and\u00a0`for...of`.\n\nHere is an example of continuing conditionally, so that the body of the iteration does not execute for a specific item but the iteration still continues to progress:\n\n```", "```js\n\n*Continuing*\u00a0skips all of the code following\u00a0`continue`\u00a0in the current iteration and then moves onto whatever would naturally occur next.\u00a0\n\nSimilar to the\u00a0`break`\u00a0statement, to the right side of the\u00a0`continue`\u00a0keyword can optionally be a label that indicates which iteration construct should be continued. If you don't supply it, then JavaScript will assume you are referring to the current iteration construct. If you have two or more iteration constructs nested within each other, then it may be necessary to use an explicit label:\n\n```", "```js\n\nThe `continue` statement will only work in our native looping constructs. If we wish to continue in an abstracted looping construct such as\u00a0`Array#forEach`,\u00a0then we'll typically want to use a `return` statement instead (to return from the callback and hence continue the iteration).\n\nSince *continuing* is a movement of control, we want to remain cautious about how clearly we are communicating our intent. If we have several layers of loops or several `continue` or `break` statements, it can burden the reader with an unnecessary level of complexity.\u00a0\n\n# Throwing\n\n*Throwing* is a shift of control from the current statement to the nearest containing\u00a0`try...catch`\u00a0statement on the call stack. If no such\u00a0`try...catch`\u00a0statement exists, then the execution of the program will terminate entirely. Throwing is conventionally used to raise exceptions when specific requirements or expectations are not met:\n\n```", "```js\n\nTo catch this error, we would need to have a\u00a0`try...catch`\u00a0block somewhere on the call-stack, wrapping the call to the\u00a0`nameToUpperCase`\u00a0function or the call to the function that calls it (and so on):\n\n```", "```js\n\nIt is a best practice to throw objects that are instances of the natively provided generic\u00a0`Error`\u00a0constructor. There are several native sub-classed constructors of\u00a0`Error`:\n\n*   `SyntaxError`:\u00a0This indicates that a parsing error has occurred\n*   `TypeError`: This\u00a0indicates an unsuccessful operation when none of the other `Error` objects are appropriate\n*   `ReferenceError`: This indicates that an invalid reference value has been detected\n*   `RangeError`:\u00a0This indicates a value that is not in the set or range of allowable values\n*   `URIError`:\u00a0This indicates that a URI handling function was used in a way that is incompatible with its definition\n\nJavaScript will naturally raise such exceptions to you if you misuse native APIs or produce invalid syntax, but you can also use these constructors yourself to provide more semantically meaningful errors to your fellow programmers. If none of the preceding are suitable, then you can directly use `Error` or extend from it to produce your own specialized instance, as follows:\n\n```", "```js\n\nAll `Error` instances will contain a\u00a0`name`\u00a0and\u00a0`message`\u00a0property. Depending on the JavaScript implementation, there may also be additional properties related to the stack trace of the error. In both the V8 JavaScript engine (used in Chromium and Node.js) and in SpiderMonkey (Mozilla), there is a stack property that gives us serialized call stack information:\n\n```", "```js\n\nThere may be unique situations where you wish to throw a value that is not an\u00a0`Error`\u00a0instance, and technically, this is perfectly legal, but it is rarely useful to do so. It's best to only throw in the case of an actual error, and in that case, it is best to use an appropriate\u00a0`Error`\u00a0object to represent the error.\u00a0\n\n# Statements of control flow\n\nNow that we've cemented our understanding of how *control* is moved at a high level, we can delve further into the specific statements and mechanisms that JavaScript gives us to control flow. We'll combine an exploration of the syntax of each statement with some best practices and pitfalls to avoid.\n\n# The if statement\n\nThe\u00a0`if`\u00a0statement is composed of the `if`\u00a0keyword\u00a0followed by a parenthesized expression and then an additional statement:\n\n```", "```js\n\n`ConditionExpression`\u00a0can be of limitless complexity as long as it is truly an expression:\n\n```", "```js\n\nThe statement\u00a0following the parenthesized expression can be a single-line statement or a\u00a0block\u00a0and designates the code that should be run if the\u00a0`ConditionExpression`\u00a0evaluates to a truthy value:\n\n```", "```js\n\nThe value you pass as `ConditionExpression` is compared to a Boolean to determine its truthiness. We've already been aptly introduced to the concepts of truthiness and falsiness in\u00a0[Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*, Primitive and Built-In Types,*\u00a0but just in case you're rusty: there are only seven falsy values in JavaScript, and as such, only seven possible values that you can pass to an\u00a0`if`\u00a0statement that won't satisfy it:\n\n```", "```js\n\nWhen an `if` statement is not satisfied, it will run an optional `else` statement, which you may specify immediately following your `if` statement. Just as with\u00a0`if`, you may use a\u00a0block\u00a0here as well:\n\n```", "```js\n\nYou can effectively *chain*\u00a0together\u00a0`if`/`else`\u00a0statements as follows:\n\n```", "```js\n\nSyntactically, it's important to understand that this isn't a construct of its own (there is no such thing as an\u00a0`if`/`else`/`if`/`else`\u00a0construct); it is merely a regular\u00a0`if`\u00a0statement, followed by an\u00a0`else`\u00a0statement that itself contains its own\u00a0`if`/`else`\u00a0duo. Therefore, it is more accurate, perhaps, to see it as follows:\n\n```", "```js\n\nAn\u00a0`if`\u00a0statement is best suited for when there are one or two possible outcomes of a condition. If there are more possible outcomes, then you may be better off using a switch statement.\u00a0Long\u00a0`if`/`else`\u00a0chains can get unwieldy.\u00a0See the *Handling cyclomatic complexity*\u00a0section\u00a0later in this chapter to explore other novel ways of handling complex conditional logic.\n\n# The for statement\n\nThe `for` statement is used to iterate through a set, typically, an array or any iterable structure. It comes in four broad varieties:\n\n*   **Conventional\u00a0for**: This includes the following:\n    *   **Syntax**:\u00a0`for (initializer; condition; incrementer) {...}`\n    *   **Usage**: Typically used to iterate in a custom fashion through an indexed structure\u00a0\n*   **For...in**:\u00a0This includes the following:\n    *   **Syntax**:\u00a0`for (let item in object) {...}`\n    *   **Usage**: Used to iterate through the keys of any object (typically used on *plain objects*)\n*   **For...of**:\u00a0This includes the following:\n    *   **Syntax**:\u00a0`for (let item of iterable) {...}`\n    *   **Usage**: Used to iterate over an iterable (typically array-like) structure\n\nThe type of\u00a0`for`\u00a0construct you'll employ will depend on what exactly you wish to iterate over. For straightforward indexed and array-like structures, for example, the\u00a0`for...of`\u00a0construct will be most useful. We'll go over each of these constructs to explore use cases and potential challenges.\n\n# Conventional for\n\nThe conventional\u00a0`for`\u00a0statement is used to iterate over all manner of data structures or conceptual looping scenarios. It includes three expressions, parenthesized and separated by semicolons, and a statement at the end, which is considered the\u00a0body\u00a0of the iteration:\n\n```", "```js\n\nThe purpose of each part is as follows:\n\n*   The\u00a0`InitializerExpression`\u00a0initializes\u00a0the iteration; this will be evaluated first and only once. This can be any statement (it usually includes a\u00a0`let`\u00a0or\u00a0`var`\u00a0assignment, but doesn't need to).\n*   The\u00a0`ConditionExpression`\u00a0checks\u00a0whether the iteration may continue; this will be evaluated and coerced to a Boolean (as if via\u00a0`Boolean(...)`) before each iteration to determine whether the next iteration will occur. This can be any expression, though it is usually used to check whether the current index is less than some upper bound (usually the length of the data structure that you are iterating through).\n*   The\u00a0`UpdateExpression`\u00a0finalizes each iteration, ready for the next iteration. This will be evaluated at the end of each iteration. This can be any statement though is most idiomatically used to increment or decrement the current index.\n*   The\u00a0`IterationBody`\u00a0contains the actual iteration logic\u2014the code that will be evaluated on every iteration. This is typically a\u00a0*block*\u00a0but can be a single-line statement.\n\nUsing the conventional `for` statement to loop over an array would look like this:\n\n```", "```js\n\nIt is preferable to use\u00a0`for...of`\u00a0if you're just iterating over a regular array or iterable structure. However, if you need to iterate over a structure indexed unconventionally, then it may be appropriate to use the conventional `for` loop.\n\nAn example of an unconventionally indexed structure is the pixel data of a\u00a0`<canvas>`\u00a0element, which forms an array containing the RGBA (*Red, Green, Blue*, and *Alpha*) values of every pixel consecutively, like so:\n\n```", "```js\n\nSince each individual pixel occupies four elements of the array, we would need to iterate over it four indexes at a time. The conventional `for` loop is perfectly suited to this:\n\n```", "```js\n\nThe conventional\u00a0`for`\u00a0statement is a well understood and idiomatic piece of syntax. It is best to ensure that you use each of its parts for its purpose. It is entirely possible (though unadvisable) to exploit its syntax by including the actual logic of your iteration in the parenthesized portion of the construct, but this and other misuses can be quite hard to parse for humans:\n\n```", "```js\n\n`UpdateExpression`\u00a0here includes the `copy[i] = array[i++]`\u00a0expression,\u00a0which will copy across the element of the array at the current index and will then increment the index. The postfix\u00a0`++`\u00a0operator ensures that the previous value of its operand will be returned, guaranteeing that the index accessed on\u00a0`copy[i]`\u00a0is always equal to\u00a0`array[i++]`. This is a clever but rather obscure syntax. It would have been far clearer to use the idiomatic `for` structure, which places the iteration logic in its own statement after\u00a0`for(...)`:\n\n```", "```js\n\nThis is a more familiar and comprehensible piece of code for most programmers. It is more verbose, and perhaps not as fun to write, but in the end, as explored in the initial chapters of this book, we are most interested in writing code that communicates its intent clearly.\n\nNaturally, this fictional scenario, copying the contents of one array to another array, would be better solved by using the\u00a0`Array#slice`\u00a0method (`array.slice()`) but we used it here as an illustration.\n\n# for...in\n\nThe\u00a0`for...in`\u00a0construct is used to iterate over an\u00a0 object's set of enumerable property names. It has the following syntax:\n\n```", "```js\n\nThe various parts have the following constraints:\n\n*   `LeftSideAssignment`\u00a0can be anything that would be valid on the left side of an assignment expression and is evaluated within the scope of\u00a0`IterationBody` on every new iteration\n*   `Object`\u00a0can be any expression that evaluates to (or can be coerced to) an object\u2014in other words, anything except\u00a0`null`\u00a0or\u00a0`undefined`\n*   `IterationBody`\u00a0is any single-line or block statement\n\nThe\u00a0`for...in`\u00a0construct is usually used to iterate through a plain object's properties:\n\n```", "```js\n\nYou can see that we're using\u00a0`const key`\u00a0here to initialize our\u00a0`key`\u00a0variable on each iteration. This is the preferred declaration to use unless you have a specific need for the mutable behavior of\u00a0`let`\u00a0or the different scoping behavior of\u00a0`var`. Naturally, all of these declarations are perfectly valid to use, in addition to using no declaration whatsoever:\n\n```", "```js\n\nA new block scope is created for each iteration. When you use either a\u00a0`let`\u00a0or\u00a0`const`\u00a0declaration, it will be scoped to that iteration, while a variable declared via\u00a0`var`\u00a0will, as we know, be scoped to the nearest execution context's scope (*function scope*). Using no declaration whatsoever is fine, but you should ensure that you have already initialized that identifier beforehand:\n\n```", "```js\n\nSince anything that would be valid on the left side of an assignment expression is valid on the left side of\u00a0`in`, we can also place a property reference here, as in the following example:\n\n```", "```js\n\nThis would result in\u00a0`foo.key`\u00a0being assigned each key of `obj` as the iteration progresses. This would be quite an odd thing to do, but will nonetheless work correctly.\n\nNow that we have the syntax out of the way, we can discuss the behavior and use cases of\u00a0`for..in`. It is, as mentioned, useful in iterating through the properties of an object. By default, this will include all properties inherited from the object's\u00a0`[[Prototype]]`\u00a0chain as well, but only if they are\u00a0*enumerable*:\n\n```", "```js\n\nAs you can see, properties on the object itself are iterated over before those from inherited objects. The order of iteration, however, should not be depended upon as this may differ between implementations. If you're looking to iterate through a set of keys in a specific order, it may be better instead to gather the keys via\u00a0`Object.keys(obj)`\u00a0and then iterate over that as an array.\n\nSince\u00a0`for...in`\u00a0will naturally iterate over inherited properties, it's conventional to place an additional check within the iteration body to avoid these properties:\n\n```", "```js\n\nWhere you have an iterable object (such as an array), it is advisable to use\u00a0`for...of`\u00a0instead, which is more performant and idiomatic for such situations.\u00a0\n\n# for...of\n\nThe `for...of` construct is used to iterate over an iterable object. Natively provided iterable objects include\u00a0`String`,\u00a0`Array`,\u00a0`TypedArray`,\u00a0`Map`,\u00a0and\u00a0`Set`. Syntactically, `for...of` shares the characteristics of `for...in`:\n\n```", "```js\n\nThe purpose of each part is as follows:\u00a0\n\n*   `LeftSideAssignment`\u00a0can be anything that would be valid on the left side of an assignment expression and is evaluated within the scope of\u00a0`IterationBody` on every new iteration\n*   `IterableObject`\u00a0can be any expression that evaluates to an\u00a0*iterable*\u00a0object\u2014in other words, anything that implements\u00a0`[Symbol.iterator]`\u00a0as a method\n*   `IterationBody`\u00a0is any single-line or block statement\n\nAn idiomatic\u00a0`for...of`\u00a0usage may look like this:\n\n```", "```js\n\nSince its introduction into the language,\u00a0`for...of`\u00a0has become the most idiomatic way to loop over arrays, replacing the previously idiomatic\u00a0`for (var i = 0; i < array.length; i++) {...}`\u00a0pattern.\n\nThe scoping behavior of\u00a0`let`,\u00a0`var`,\u00a0and\u00a0`const`\u00a0is identical to that described in the last section on\u00a0`for...in`. It is advisable to use `const` as it will initialize a fresh and immutable variable for each iteration. Using\u00a0`let`\u00a0is not awful but, unless you have a specific reason to need to mutate the variable yourself within `IterationBody`,\u00a0you'll be better off using\u00a0`const`.\n\n# The while statement\n\nThe\u00a0`while`\u00a0statement is used to run a piece of code until some condition stops being met. It has the following syntax:\n\n```", "```js\n\nThe purpose of each part is as follows:\u00a0\n\n*   `ConditionExpression`\u00a0is evaluated to determine whether\u00a0`IterationBody`\u00a0should run. If it evaluates to\u00a0`true`,\u00a0then the\u00a0`IterationBody`\u00a0portion will run.\u00a0`ConditionExpression`\u00a0will then be re-evaluated and so on. The cycle only stops when\u00a0`ConditionExpression`\u00a0evaluates to\u00a0`false`.\n*   `IterationBody`\u00a0can be either a single-line or block statement and will be run as many times as\u00a0`ConditionExpression`\u00a0evaluates to\u00a0`true`.\n\nIt is rare to use `while` for straightforward iteration because there are more suitable constructs for this (for example,\u00a0`for...of`), but if we wanted to, it might look something like the following:\n\n```", "```js\n\nSince we are initializing\u00a0`i`\u00a0to\u00a0`-1`\u00a0and are using the prefix increment operator (`++i`), `ConditionExpression`\u00a0will evaluate to\u00a0`0 < array.length`,\u00a0`1 < array.length`,\u00a0`2 < array.length`,\u00a0and\u00a0`3 < array.length`. Naturally, the last check will fail as\u00a0`3`\u00a0is not less than\u00a0`array.length`, meaning that the\u00a0`while`\u00a0statement will stop running its\u00a0`IterationBody`. This means `Body`\u00a0will only\u00a0`3`\u00a0times in total.\n\nIt's common to use\u00a0`while`\u00a0when the limit of iteration is, as yet, unknown or computed in a complex fashion. In such instances, it is common to see\u00a0`true`\u00a0directly passed as `ConditionExpression`\u00a0to\u00a0`while(...)`\u00a0and then a manual\u00a0`break;`\u00a0statement within the iteration to force it to end:\n\n```", "```js\n\nThe\u00a0`while`\u00a0statement is also used in the context of generator functions if those generators are intended to produce infinite outputs. For example, you may wish to create a generator that always produces the\u00a0*next*\u00a0letter in an alphabet, and then loops round to the start of the alphabet when it gets to\u00a0`z`:\n\n```", "```js\n\nSuch infinite applications of generators are rare but they do exist and are a perfect place to use\u00a0`while(...)`. Most other applications of\u00a0`while`\u00a0have been replaced with more succinct and contained methods of iteration such as\u00a0`for...in`\u00a0and\u00a0`for...of`. Nonetheless, it is useful to know how to cleanly wield it.\n\n# The do...while statement\n\nThe\u00a0`do...while`\u00a0statement is similar to while it although guarantees\u00a0an iteration before the check is carried out. Its syntax is formed of the `do`\u00a0keyword\u00a0followed by its body and then a typical\u00a0parenthesized\u00a0`while`\u00a0expression:\n\n```", "```js\n\nThe purpose of each part is as follows:\u00a0\n\n*   `IterationBody`\u00a0can be either a single-line or block statement and will be run once initially and then as many times as\u00a0`ConditionExpression`\u00a0evaluates to\u00a0`true`.\n*   `ConditionExpression`\u00a0is evaluated to determine whether\u00a0`IterationBody`\u00a0should run more than once. If it evaluates to\u00a0`true`,\u00a0then the\u00a0`Body`\u00a0portion will run.\u00a0`ConditionExpression`\u00a0will then be re-evaluated and so on. The cycle only stops when\u00a0`ConditionExpression`\u00a0evaluates to\u00a0`false`.\n\nAlthough the behavior of the\u00a0`do...while`\u00a0statement is different from\u00a0 regular\u00a0`while`\u00a0statement, its semantics and broad applications remain the same. It is most useful in contexts where you need to always complete at least one step of an iteration before either checking whether to continue or changing the subject of the iteration. An example of this would be upward DOM traversal. If you have a DOM element and wish to run certain code on it and each of its DOM ancestors, then you may wish to use a `do...while` statement as follows:\n\n```", "```js\n\nA loop like this will execute its body once for the `element` value, whatever `element` is, and then will evaluate the assignment expression,\u00a0`element = element.parentNode`. This assignment expression will evaluate to its newly assigned value, meaning that, in the case of\u00a0`element.parentNode`\u00a0being falsy (for example,\u00a0`null`) the\u00a0`do...while`\u00a0will halt its iteration.\n\nAssigning values in the\u00a0`ConditionExpression`\u00a0portion of a\u00a0`while`\u00a0or\u00a0`do...while`\u00a0statement is relatively common although it can be obscure to fellow programmers, so it's best to only do so if it's plainly obvious what the intent of the code is. If the preceding code was wrapped in a function called\u00a0`traverseDOMAncestors`,\u00a0then that would provide a helpful clue.\n\n# The switch statement\n\nThe `switch` statement is used to move control to a specific inner\u00a0`case`\u00a0clause that specifies a value that matches the value passed to\u00a0`switch(...)`. It has the following syntax:\n\n```", "```js\n\n`SwitchExpression`\u00a0will be evaluated once and its value compared via strict-equality to case statements within `SwitchBody`. Within `SwitchBody`\u00a0there may be one or more\u00a0`case`\u00a0clauses and/or a\u00a0`default`\u00a0clause. The\u00a0`case`\u00a0clauses designate `CaseExpression`,\u00a0whose value will be compared to that of\u00a0`SwitchExpression`, and their syntax is as follows:\n\n```", "```js\n\nThe\u00a0`switch`\u00a0statement is usually used to specify a selection of two or more mutually exclusive outcomes based on a specific value. With fewer conditions, it'd be conventional to use an\u00a0`if...else`\u00a0construct, but to accommodate more potential conditions, it's simpler to use `switch`:\n\n```", "```js\n\nOnce the\u00a0`switch`\u00a0mechanism finds the appropriate\u00a0`case`,\u00a0it will execute all code following that\u00a0`case`\u00a0statement until the very end of the\u00a0`switch`\u00a0statement or until it encounters a\u00a0`break`\u00a0statement. A\u00a0`break`\u00a0statement is used to *break out*\u00a0of `SwitchBody`\u00a0when the desired work is accomplished.\n\n# Breaking and fallthrough\n\nGiven that\u00a0`switch`\u00a0statements are usually used to execute specific and mutually exclusive pieces of code depending on the value, it is conventional to use\u00a0`break`\u00a0between every\u00a0`case`\u00a0statement to ensure that only the appropriate code runs for any given value. Sometimes, however, it is desirable to avoid breaking between cases and let the\u00a0`SwitchBody`code continue to run through multiple\u00a0`case`\u00a0statements and beyond. Doing this is known as **fallthrough**:\n\n```", "```js\n\nHere, you can see that we are employing\u00a0fallthrough\u00a0so that a language of either\u00a0`'German'`,\u00a0`'Deutsche'`,\u00a0or\u00a0`'DE'`\u00a0will result in the same code running\u00a0`welcomeMessage = 'Willkommen!'`. And following that, we immediately break to prevent any more of `SwitchBody`\u00a0from running.\n\nIt's unfortunately quite easy to accidentally forget the odd\u00a0`break;`\u00a0statement, resulting in accidental fallthrough and a very confused programmer. To avoid this, I'd recommend using a linter that has a rule that warns or gives an error in such cases unless given a specific directive. (We will cover linters in more detail in [Chapter 15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner Code*.)\n\n# Returning from a switch directly\n\nWhen you have a\u00a0`switch`\u00a0statement residing in a function, it is sometimes best to simply\u00a0`return`\u00a0the intended values instead of having to rely on\u00a0`break`\u00a0statements. For example, in `generateWelcomeMessage`,\u00a0we can simply return the welcome string. There's no need to go through the rigamarole of initializing a variable, assigning it, and breaking between cases:\n\n```", "```js\n\nReturning directly, in this way, is arguably clearer than breaking within each case, especially if each case's logic is fairly simple.\u00a0\n\n# Case blocks\n\nUsually, the code following a\u00a0`case`\u00a0or\u00a0`default`\u00a0clause will not only occupy a single line. As such, it has become conventional to wrap these statements with a\u00a0block, so that there is a sense of containment:\n\n```", "```js\n\nThis isn't strictly necessary and doesn't change any functionality, but it does offer more clarity to the reader of our code. It also paves the way for any block-level variables, should we wish to introduce these later. As we know, within a\u00a0block\u00a0(delimited with\u00a0`{`\u00a0and\u00a0`}`), we can use\u00a0`const`\u00a0and\u00a0`let`\u00a0to declare variables that will be scoped only to that block:\n\n```", "```js\n\nHere, we're able to declare specific variables that are scoped to the `February`\u00a0case only. This is useful if we have a large amount of logic that we'd like to isolate. At this point, however, we should consider abstracting that logic in some other way. Lengthy `switch` statements can be incredibly hard to understand.\n\n# Multivariant conditions\n\nOften, there's a need to express more complex conditions in each `case`, instead of just matching a singular value. If we pass `true`\u00a0as `SwitchExpression`, then we are free to express custom conditional logic within each\u00a0`CaseExpression`,\u00a0as long as each `CaseExpression`\u00a0evaluates to\u00a0`true`\u00a0when successful:\n\n```", "```js\n\nThis pattern allows us to express more multivariate and hybrid conditions. You may usually feel inclined toward multiple\u00a0`if`/`else`/`if`/`else`\u00a0statements, but if your logic can be expressed in a\u00a0`switch`\u00a0statement, then it may be best to opt for that. As always, you should consider the nature of your problem domain and its logic, and seek to make an informed decision about how you wish to implement your control flow. In some cases, a\u00a0`switch`\u00a0statement will only end up being more confusing.\n\nIn the next section, we will cover some other approaches you can use to handle complex and lengthy logic that doesn't suit native constructs such as\u00a0`switch`.\n\n# Handling cyclomatic complexity\n\n**Cyclomatic complexity**\u00a0is a measure of how many *linearly independent paths* there are through a program's code.\n\nConsider a simple program that contains several conditional checks and function invocations:\n\n```", "```js\n\nEven in this misleadingly simple piece of code, nine distinct paths can be taken. So, depending on the values of `a`, `b`, `c`, and `d`, there are nine possible sequences of `alpha`, `bravo`, `charlie`, and `delta` that will run:\n\n*   `alpha()`\n*   `alpha()` and\u00a0`bravo()`\n*   `alpha()`, `bravo()`, and\u00a0`charlie()`\n*   `alpha()`, `bravo()`, `charlie()`, and\u00a0`delta()`\n*   `alpha()`, `bravo()`, and\u00a0``delta()``\n*   `alpha()`\u00a0and\u00a0`charlie()`\n*   `alpha()`, `charlie()`, and\u00a0`delta()`\n*   `alpha()`\u00a0and\u00a0`delta()`\n*   `delta()`\n\nA high level of cyclomatic complexity is undesirable. It can lead to the following:\n\n*   **Cognitive burden**: Cyclomatically complex code can be difficult for programmers to understand. Code with many branches is difficult to internalize and hold in our minds and therefore harder to maintain or change.\n*   **Unpredictability**: Cyclomatically complex code can be unpredictable, especially if rare situations occur where there is, for example, an unforeseen state transition or underlying change of data.\u00a0\n*   **Fragility**: Cyclomatically complex code can be fragile in the face of change. Changing one line can have a disproportionate effect on the functionality of many other lines.\n*   **Bugginess**: Cyclomatically complex code can cause obscure bugs. If there are a dozen or more code paths within a singular function, then it's possible for a maintainer to not see all of them, leading to regressions.\n\nThere are tools that can quantify a code base's cyclomatic complexity. We will cover these in\u00a0[Chapter 15](https://cdp.packtpub.com/clean_code_in_javascript/wp-admin/post.php?post=415&action=edit#post_508),\u00a0*Tools for Cleaner Code*. Knowing areas of high cyclomatic complexity can help us to focus on those areas for maintenance and testing.\n\nIt's frustratingly easy to end up in a situation where there are so many different conditions and branches within a singular module that nobody can understand what's happening. In addition to using tools to help us to identify areas of high complexity, we can use our own judgment and intuitions. The following are some examples of complexity that we can easily identify and avoid:\n\n*   A function that has more than one\u00a0`if`/`else`/`if`\u00a0combination\u00a0\n*   An\u00a0`if`\u00a0statement\u00a0that\u00a0has many sub-conditions (many\u00a0`if`\u00a0statements within\u00a0`if`\u00a0statements)\n*   A\u00a0`switch`\u00a0statement that has many sub-conditions following each\u00a0`case`\u00a0clause\n*   Many\u00a0`case`\u00a0clauses within a\u00a0`switch`\u00a0block (for example, over 20 would be alarming!)\n\nThese are not precise cautions but they should give you an idea of what you should watch out for. When we find such complexity, the first thing we should do is to sit back and re-consider our problem domain. Can we describe our logic differently? Can we form new or different abstractions?\n\nLet's explore an example of a piece of code with high cyclomatic complexity and consider how we might simplify it with these questions in mind.\n\n# Simplifying conditional spaghetti\n\nTo illustrate\u00a0too much cyclomatic complexity and how we should approach simplifying it, we're going to be refactoring a piece of code that is responsible for deriving a set of ID numbers and types from a set of licenses:\n\n```", "```js\n\nThis function accepts an array of licenses and then extracts the ID numbers of those licenses (avoiding cases of `null` or `undefined` IDs). We determine the type of license based on characters found within its ID. There are four types of licenses that need to be identified and extracted:\n\n*   `car`: These are of the `c{digits}`\u00a0form,\u00a0where digits form a number greater than or equal to 1,000,000\n*   `car_old`: These are of the `c{digits}`\u00a0form,\u00a0where digits form a number less than 1,000,000\n*   `hgv`: These are of the\u00a0`h{digits}`\n*   `motorcycle`: These are of the\u00a0`m{digits}`\n\nThe following is an example of the input and the derived output of the\u00a0`getIDsFromLicenses`\u00a0function:\n\n```", "```js\n\nAs you may have observed, the code we've used to extract the IDs is quite cyclomatically complex. You may consider it perfectly reasonable code, and it arguably is, but it could be simpler still. Our function achieves its results imperatively, using up a lot of syntax to explain *how*\u00a0it wants to accomplish its task instead of *what*\u00a0it wants to accomplish.\u00a0\n\nTo simplify our code, it's first useful to take a fresh look at the problem domain. The task we want to accomplish is to take an input array and, from it, derive a set of license ID types and values. The output array will be an almost\u00a0**1:1\u00a0**mapping from the input array, except for cases where licenses have a falsy\u00a0`id`\u00a0property\u00a0(`null`,\u00a0in this case). The following is an illustration of our I/O flow:\n\n```", "```js\n\nLooked at abstractly in this way, this seems like the perfect opportunity to use\u00a0`Array#map`. The `map` method allows us to run a function on every element within an array to derive a new array containing mapped values.\n\nThe first thing we'll want to map is the license to its\u00a0`id`:\n\n```", "```js\n\nWe'll want to handle cases where there is no\u00a0`id`. To do this, we can apply a filter on the derived IDs:\n\n```", "```js\n\nAnd, in fact, because we know that all valid IDs are truthy, we can simply do a Boolean check by directly passing\u00a0`Boolean`\u00a0as our filter function:\n\n```", "```js\n\nFrom this, we'll receive an array of our licenses but only those with a truthy `id` property. Following this, we can consider the next transformation we wish to apply to the data. We'd like to split the\u00a0`id`\u00a0value into its constituent parts: we need the initial character of the ID (`id.charAt(0)`), and\u00a0then we want to extract the remaining characters (the digits) and cast them to the `Number` type (`Number(id.slice(1))`). We can then pass these parts to another function, which will be responsible for extracting the correct ID fields (`type`\u00a0and\u00a0`digits`) from this information:\n\n```", "```js\n\nThe\u00a0`getIDFields` function will need to determine the type from the individual character and digits for the ID, returning an object of the\u00a0`{ type, digits }`\u00a0form:\n\n```", "```js\n\nSince we've abstracted this part our logic away to an individual function, we can independently observe and test its behavior:\n\n```", "```js\n\nTying everything together, we end up with a new implementation of\u00a0`getIDsFromLicenses`\u00a0that looks like this:\n\n```", "```js\n\nWhat we have achieved here is a significant reduction in the amount of cyclomatic complexity that our fellow programmers will need to contend with. We are utilizing\u00a0`Array#map`\u00a0and\u00a0`Array#filter`\u00a0to abstract away both decision-making and iteration logic. This means we end up with an implementation that is far more\u00a0*declarative*.\n\nYou may notice, as well, that we have extracted repeated logic and generalized it. For example, in our initial implementation, we were implementing many calls to discover the first character of the ID (for example,\u00a0`license.id.indexOf('m') === 0`). Our new implementation generalizes this by mapping to a data structure that already includes the first character as a distinct value that we can then pass through to\u00a0`getIDFields`\u00a0to get the relevant\u00a0`type`\u00a0and\u00a0`digits`\u00a0for that ID.\n\nTo summarize, our general refactoring approach has involved the following considerations:\n\n*   We've considered the problem domain with a fresh perspective\n*   We've considered whether there is a common functional or declarative idiom for our I/O\n*   We've considered whether individual logic can be abstracted away or separated\n\nOur code is now easier to comprehend, and hence easier to maintain and debug. It'll likely also be more reliable and stable since its individual units can be more simply tested and can hence avoid regressions in the future. There is, naturally, the potential for a slight performance decrease due to the increased usage of higher abstracted declarative idioms and functions over imperative code, but this is an incredibly marginal difference and, in the vast majority of situations, is worth implementing\u00a0for the significant benefits that the refactoring produces in terms of maintainability and reliability.\n\n# Asynchronous control flow\n\nMost of the constructs we've looked at so far are used\u00a0for synchronous code, where statements are evaluated sequentially, with each line completing before the next one begins:\n\n```", "```js\n\nCode like this is straightforward. We intuitively understand that these two lines of code will run one after the other. There is also an assumption that neither of these lines will take very long to execute, probably taking no more than a few\u00a0micro- or milliseconds.\u00a0\n\nBut what happens if we wish to bind to a user Event\u00a0or fetch some remote data? These are things that take time and will only complete when some future Event occurs. In a less kind universe, there would be no way to deal with such scenarios other than simply waiting for them to complete and then continuing the execution of our program:\n\n```", "```js\n\nIn this unkind universe,\u00a0`fetchSomeData()`\u00a0would be a *blocking*\u00a0function call, so named because it would block the execution of all other code until it finally completes. This means that we wouldn't be able to carry out any other vital tasks, and our application would essentially be at a standstill state until the task is completed, negatively affecting the user experience.\n\nThankfully, JavaScript gives us a nicer universe than this\u2014one in which we can initialize a task, such as fetching data, and then continue on with the rest of our program while that task is running. Such tasks are named\u00a0*asynchronous*\u00a0because they occur and complete non-synchronously, at a later time than\u00a0*now*. When they do finally complete, JavaScript can helpfully notify us of this fact, calling whatever code depends\u00a0upon the completion of that task.\n\n# The Event Loop\n\nTo accomplish this,\u00a0JavaScript maintains a single-threaded *Event Loop*.\u00a0When the\u00a0*Event Loop*\u00a0kicks off, it'll run our program.\u00a0Following the execution of a piece of code (such as that which initiates our program), the *Event Loop* will await\u00a0messages\u00a0(or\u00a0Events) indicating that something has occurred (for example, a network request has completed or a browser UI event has occurred). When it receives a message, it will then execute any code that is depending upon or listening for that Event. The *Event Loop* will, again, run that code to completion before continuing to await other messages. This process repeats infinitely until the JavaScript program is halted (for example, by closing a tab in a browser).\n\nThe fact that the *Event Loop* will always run a given piece of code to its completion means that any long-running or *blocking*\u00a0code will prevent any other code from executing until it has completed. Some older browser API methods such as\u00a0`alert()`\u00a0and\u00a0`prompt()`\u00a0are examples of blocking functions that you may encounter. Calling these will effectively block any further execution of your JavaScript program:\n\n```", "```js\n\nHere,\u00a0`console.log()`\u00a0will not be evaluated until the alert dialog is dismissed by the user. This could be milliseconds, minutes, or even hours. During this period, our JavaScript program is halted, unable to continue. Its\u00a0*Event Loop*\u00a0may be receiving Events but it will not run the code associated with those Events until\u00a0`alert()`\u00a0finally completes.\n\n# Native asynchronous APIs\n\nNowadays,\u00a0it's normal to expect APIs within\u00a0a\u00a0browser and server to provide non-blocking asynchronous ways to call native mechanisms. Common examples of such APIs include the following:\n\n*   The DOM Event API, enabling code such as\u00a0`window.addEventListener('click', callback)`\n*   The Node.js file API, enabling code such as\u00a0`fs.readFile(path, callback)`\n*   The Browser Fetch API, enabling code such as\u00a0`fetch().then(callback)`\n\nAll such interfaces share something in common: they all provide a way to somehow listen for their completion. Usually, this is achieved via a provided callback (a function). This callback will be called at some later point when the task has completed. Similarly, some native APIs return promises, which enable a richer mechanism of asynchronous control flow, but fundamentally still rely on passing callbacks via the Promise API. Additionally, ECMAScript 2017 introduced the concept of asynchronous functions (`async function() {}`) and the\u00a0`await`\u00a0keyword, which finally provided language support for promises, meaning that the completion of asynchronous work no longer requires callbacks.\n\nLet's explore each of these asynchronous\u00a0of control flow mechanisms\u00a0individually.\n\n# Callbacks\n\nA callback is a conventional approach to providing a way to hook into asynchronous tasks. A callback is simply a function that is passed to another function and is expected to be called at some later point, possibly immediately, possibility soon, and possibly never. Consider the following `requestData`\u00a0function:\n\n```", "```js\n\nAs you can see, it accepts a callback as its second argument. When calling\u00a0`requestData`,\u00a0the callback will typically be anonymously\u00a0passed inline, like so:\n\n```", "```js\n\nIt is, of course, totally fine to have previously declared the callback, and doing so can aid comprehensibility as now the reader of your code will have an inkling as to when a callback might be invoked. Observe here how we're calling our `onResponse`\u00a0callback\u00a0to make clear that it is expected to be called upon the response becoming available (when it completes):\n\n```", "```js\n\nSimilarly, in complex APIs with multiple asynchronous state changes, it's common to see named callbacks registered in bulk, via an\u00a0*object literal*:\n\n```", "```js\n\nA callback will typically be passed arguments that indicate some important state that has been determined from the asynchronous work. For example, the Node.js\u00a0`readFile`\u00a0function invokes its callback with two arguments, a (possibly null) error and the (possibly null) data from the file itself:\n\n```", "```js\n\nThe function you pass a callback to is entirely in control of when your callback is invoked, how it is invoked, and what data is passed along with that invocation. This is why sometimes callbacks are spoken about as an\u00a0*inversion of control*. Normally, you are in control of what functions you call, but when using callbacks, the control is inverted so that you are relying on another function or abstraction to (at some point) call your callback in the expected manner.\n\n*Callback hell*\u00a0is the name given to the undesirable proliferation of multiple nested callbacks within a piece of code, usually done to carry out a series of asynchronous tasks that each rely on another previous asynchronous task. Here is an example of such a situation:\n\n```", "```js\n\nHere, you can see we have three different callbacks, all appearing in one hierarchy of scopes. We await the response of\u00a0`/data/current-user`,\u00a0then we optionally make a request to\u00a0`twitterFeedURL`,\u00a0and then, upon the rendering of the twitter feed (`renderTwitterFeed()`), we finally log a\u00a0`\"twitterFeedRender\"`\u00a0Event. That final log depends on two previous asynchronous tasks completing and so is (seemingly unavoidably)\u00a0nested quite deeply.\n\nWe can observe that this deeply nested piece of code is at the peak of a kind of *horizontal pyramid*\u00a0of indentation. This is a common trait of\u00a0*callback hell*, and as such, you can use the existence of these *horizontal pyramids*as something to watch out for. Not all deep indentations will be due to callbacks, of course, but it's usually high on the list of suspects:\n\n![](assets/9fabad56-8ede-4573-9fcb-0467a4188f66.png)\n\nTo avoid\u00a0the\u00a0*callback hell\u00a0*indicated by the *horizontal pyramid*,\u00a0we should consider re-thinking and potentially re-abstracting our code. In the preceding case, logging a Twitter feed render Event, we could, for example, have a generalized function for *getting and rendering Twitter feed data*. This would simplify the top-level of our program:\n\n```", "```js\n\nObserve how we have shortened our *horizontal pyramid*\u00a0here. We are now free to implement\u00a0`renderTwitterForUser`\u00a0as we wish and import it as a dependency. Even though its implementation may involve its own callbacks, it is still a reduction in overall complexity for the programmer as it abstracts away half of the *pyramid*\u00a0to a neatly separated abstraction. Most\u00a0*callback hell*\u00a0scenarios can be solved with a similar approach to re-designing and abstraction. This was a simple scenario, though. With more intertwined asynchronous tasks, it may be useful to use other mechanisms of asynchronous control flow.\n\n# Event subscribing/emitting\n\nJavaScript is a language that feels right at home when subscribing to and emitting Events. Events are incredibly common in most JavaScript programs, whether dealing with user-derived Events within the browser or server-side Events in Node.js.\n\nThere are various names used for operations relating to Events in JavaScript, so it's useful to know all of these names upfront so we're not confused when encountering them. An event is an occurrence in time that will result in the invocation of any callbacks that have been subscribed for that Event. Subscribing to an Event has many names, which all effectively mean the same thing:\u00a0*subscribing*,\u00a0*registering*,\u00a0*listening*,\u00a0*binding*, and so on. When the Event occurs, the subscribed callback is invoked. This, as well, has many names:\u00a0*invoking*,\u00a0*calling*,\u00a0*emitting*,\u00a0*firing*, or\u00a0*triggering*. The actual function that is called can also have various names:\u00a0*function*,\u00a0*callback*,\u00a0*listener*,\u00a0or\u00a0*handler*.\n\nAt its core, any abstraction that supports Events will usually do so by storing callbacks to be called later, keyed with specific Event names. We can imagine that a DOM element might store its Event listeners in a structure like the following:\n\n```", "```js\n\nAny Event-supporting abstraction will simply store a series of callbacks to be called later. As such, when subscribing to an Event, you will need to provide both the callback you wish it to call and the Event name that it will be tied to. In the DOM, we would do this like so:\n\n```", "```js\n\nHere, we see that an\u00a0`Event`\u00a0object is passed to the callback. This is idiomatically named `e`\u00a0or `evt`\u00a0for succinctness. Most abstractions that provide an Events API will pass specific Event-related information to the callback. This may be in the form of a singular `Event` object or several arguments.\n\nIt's important to note that there truly is no single standard for Events although there are conventions that have emerged. Typically there will always be a method used to register or subscribe to an Event and then another to remove that subscription. The following is an example of using the Node.js Event-Emitter API, which is supported by the native HTTP module:\n\n```", "```js\n\nHere, you can see that the\u00a0`on()`\u00a0method is used to subscribe to Events, and the\u00a0`off()`\u00a0method is used to unsubscribe. Most Events APIs have similar event registration and de-registration methods although they\u00a0may implement them in different ways. If you're crafting your own *Events* implementation, then it's advisable to ensure that you're providing a familiar set of methods and abstractions. To do this, take inspiration from either the native DOM Events interface or the Node.js\u00a0**Event Emitter**. This will ensure that your Events implementation does not surprise or horrify other programmers too much.\n\nEven though an Events API is essentially just a series of callbacks stored and invoked at specific times, there are still challenges in crafting it well. Amongst them are the following:\n\n*   Ensuring the order of invocation when a singular Event fires\n*   Handling cases where Events are emitted while other Events are mid-emission\n*   Handling cases where Events can be entirely canceled or removed per callback\n*   Handling cases where Events can be bubbled, propagated, or delegated (this is usually a DOM challenge)\n\n*Propagation*, *bubbling*, and *delegation* are terms related to firing Events within a hierarchical structure. In the DOM, since\u00a0`<div>`\u00a0may exist within `<body>`, the Events API has prescribed that, if the user clicks on `<div>`, the emitted Event will propagate or *bubble*\u00a0upward, first triggering any `click`\u00a0listeners on `<div>`\u00a0and then `<body>`. Delegation is intentional listening at a higher level of hierarchy, for example, listening at the\u00a0`<body>`\u00a0level and then reacting in a certain way, depending on what the Event object tells you about the Event's\u00a0`target`\u00a0node.\n\nEvents provide more possibilities than a simple callback. Since they allow several different Events to be listened for, and the same Event to be listened for several times, any consuming code has far more flexibility in how it constructs its asynchronous control flow. An object that has an Events interface can be passed around throughout a code base and may be subscribed to many times, potentially. The nature of distinct Events, as well, means that different asynchronous concepts or occurrences are usefully kept separated so that a fellow programmer can easily tell which action will be taken in specific circumstances:\n\n```", "```js\n\nThis type of transparent separation helps to encode expectations within the mind of the programmer. It's simple to discern which function will be called in each case. Compare this to a generalized *something happened*\u00a0`event` with an internal `switch` statement:\n\n```", "```js\n\nWell-implemented Events provide a good semantic separation between conceptually different Events and, therefore, provide the programmer with a predictable series of asynchronous actions that they can reason about easily.\n\n# Promises\n\nA *Promise* is an abstraction that surrounds the concept of an eventual value. It's easiest to think of a *Promise* as a simple object that will, at some point, contain a value. A Promise provides an interface via which you can pass callbacks to wait for either the eventually-fulfilled value or an error.\n\nAt any given time a *Promise* will have a certain state:\n\n*   **Pending**: The *Promise* is awaiting its resolution (the asynchronous task has not yet completed).\n*   **Settled**: The *Promise* is no longer pending and has either been fulfilled or rejected:\n    *   **Fulfilled**: The *Promise* has been successful and now has a value\n    *   **Rejected**: The *Promise* has failed with an error\n\nPromises can be constructed via the *Promise* constructor, by passing a singular function argument (called an\u00a0*executor*) that calls either a `resolve` or `reject` function to indicate either a settled value or an error, respectively:\n\n```", "```js\n\nThe instantiated\u00a0`Promise`\u00a0has\u00a0the following methods available so that we can access its changed state (when it moves from\u00a0*pending*\u00a0to either\u00a0*fulfilled*\u00a0or\u00a0*rejected):*\n\n*   `then(onFulfilled[, onRejected])`: This will append a\u00a0fulfillment\u00a0callback to the *Promise*\u00a0and optionally a\u00a0*rejection*\u00a0callback. It will return a new *Promise* object, which will resolve to the return value of the called fulfillment or rejection handler, or will resolve as per the original *Promise* if there is no handler.\n*   `catch(onRejected)`: This will append a\u00a0*rejection*\u00a0callback to the *Promise* and will return a new *Promise* that will resolve to either the return value of the callback or (if the original *Promise* succeeds) its fulfillment value.\n*   `finally(onFinally)`: This will append a handler to the *Promise*, which will be called when the *Promise* is resolved, regardless of whether the resolution is a fulfillment or a rejection.\n\nWe can access the eventually resolved value of\u00a0`answerToEverything`\u00a0by passing a callback to its `then` method:\n\n```", "```js\n\nWe can illustrate the exact nature of a *Promise* by exploring the native Fetch API, supported by most modern browsers:\n\n```", "```js\n\nThe\u00a0`fetch`\u00a0function returns a *Promise* that we assign to our variable,\u00a0`promiseOfData`. We can then hook into the request's eventual success (or failure) like so:\n\n```", "```js\n\nIt may appear as though promises are just a slightly more verbose abstraction than callbacks. Indeed, in the simplest case, you might just pass a\u00a0*fulfillment*\u00a0callback and a\u00a0*rejection*\u00a0callback. This, arguably, does not provide us with anything more useful than the original callback approach. But promises can be so much more than this.\n\nSince a *Promise* is just a regular object, it can be passed around your program just like any other value, meaning that the eventual resolution of a task no longer needs to be tied to code at the call site of the original task. Additionally, the fact that each\u00a0`then`,\u00a0`catch`,\u00a0or\u00a0`finally`\u00a0call returns a *Promise* of its own, we can chain together any number of either synchronous or asynchronous tasks that rely on some original fulfillment.\n\nIn the case of\u00a0`fetch()`, for example, the fulfilled\u00a0`Response`\u00a0object provides a\u00a0`json()`\u00a0method, which itself completes asynchronously and returns a\u00a0*Promise*. Hence, to get the actual JSON data from a given resource, you would have to do the following:\n\n```", "```js\n\nChaining together `then` calls is a popular pattern used to derive a new value from some prior value. Given the response, we wish to compute the JSON, and given the JSON, we may wish to compute something else:\n\n```", "```js\n\nHere, we are using multiple\u00a0`then`\u00a0calls to compute the sorted forenames of our users. There are, in fact, four distinct promises being created here, as foll:\n\n```", "```js\n\nEach *Promise* will only ever resolve to a single value. Once it's been\u00a0either\u00a0*fulfilled*\u00a0or\u00a0*rejected*, no other value can take its place. But as we see here, we can freely derive a new *Promise* from an original\u00a0*Promise* by simply registering a callback via\u00a0`then`,\u00a0`catch`,\u00a0or\u00a0`finally`. The nature of only resolving once and of returning new derived promises means that we can compose promises together in a number of useful ways. In our example, we could derive two promises from our\u00a0`users`\u00a0data *Promise*: one that collects the forenames of users and another that collects their surnames:\n\n```", "```js\n\nWe can then freely pass around these\u00a0`forenames`\u00a0and\u00a0`surnames`\u00a0promises, and any consuming code can do what it wants with them. For example, we may have a DOM element that we'd like to populate with the forenames when they are eventually available:\n\n```", "```js\n\nThis\u00a0`createForenamesComponent`\u00a0function accepts the `forenames` *Promise* as an argument and then returns a `<div>` element. As you can see, we have called\u00a0`render()`\u00a0initially with\u00a0`null`,\u00a0which populates the DIV element with the `\"loading...\"`\u00a0text. Once the *Promise* is fulfilled, we then re-render\u00a0with the newly populated forenames.\n\nThe ability to pass around promises in this manner makes them far more flexible than callbacks, and similar in spirit to an object that implements an Events API. However, with all of these mechanisms, it is necessary to create and pass around functions so that you can listen for future Events and then act on them. If you have a significant amount of asynchronous logic to express, this can be a real struggle. The control flow of a program littered with callbacks, Events, and promises can be unclear, even to those well accustomed to a particular code base. Even a small number of independently asynchronous Events can create a large variety of *states*\u00a0throughout your application. A programmer can become very confused, as a result; the confusion relates to *what*\u00a0is happening *when*.\u00a0\n\nThe *state*\u00a0of your program is determined at runtime. When a value or piece of data changes, no matter how small, it will be considered a\u00a0*change of state*. *State* is typically expressed in terms of outputs from the program, such as a GUI or a CLI can be also be held internally and manifest in a later observed output.\n\nTo avoid confusion, it's best to implement any timing-related code as transparently as possible, so that there is no room for misunderstanding. The following is an example of code that may lead to misunderstanding:\n\n```", "```js\n\nThis code seems to assume that the *Promise* returned by\u00a0`appStartup()`\u00a0will always fulfill after `userInfoLoader`\u00a0has completed its work. Perhaps the author of this code happens to know that the\u00a0`appStartup()`\u00a0logic will always complete after\u00a0`userInfoLoader`. Perhaps that is a certainty. But for us, reading this code for the first time, we have no confidence that\u00a0`userInfoLoader.data`\u00a0will be populated by the time\u00a0`appStartup()`\u00a0is fulfilled. It would be better to make the timing more transparent by, for example, returning a *Promise* from\u00a0`userInfoLoader.init()`\u00a0and then carrying out\u00a0`appStartup()`\u00a0on the explicit fulfillment of that *Promise:*\n\n```", "```js\n\nHere, we are arranging our code so that it is obvious what actions are dependent on what other actions and in what order the actions will occur. Using promises by themselves, just like any other asynchronous control flow abstraction, does not guarantee that your code will be easily comprehensible. It's important to always consider the perspective of your fellow programmers and the temporal assumptions that they'll make. Next, we will explore a newer addition to JavaScript that gives us native linguistic support for asynchronous code: you'll see how these additions enable us to write asynchronous code that is clearer in terms of *what*\u00a0is happening *when*.\n\n# async and await\n\nThe ECMAScript 2017 specification introduced new concepts to the JavaScript language in the form of the\u00a0`async`\u00a0and\u00a0`await`\u00a0keywords. The\u00a0`async`\u00a0keyword is used to designate a function as asynchronous:\n\n```", "```js\n\nDoing this, effectively, wraps whatever the function returns in `Promise` (if it is not already `Promise`)*.* So, if we attempt to call this function we will receive `Promise`:\n\n```", "```js\n\nAs we've learned, we can subscribe to the fulfillment of `Promise` by using its\u00a0`then`\u00a0method:\n\n```", "```js\n\nIn concert with async functions that return *Promises,* we also have an\u00a0`await`\u00a0keyword. This enables us to wait for the fulfillment (or rejection) of the `Promise` simply by passing it to the right side of `await`. This may, for example, be a `Promise` returned from an `async` function call:\n\n```", "```js\n\nOr it may be a *Promise* designated inline, like so:\n\n```", "```js\n\nAs you can see, the\u00a0`await`\u00a0keyword will wait for its *Promise* to resolve and thereby prevents any following lines from executing until that occurs.\n\nThe following is another example\u2014a\u00a0`setupFeed`\u00a0async function that awaits both\u00a0`fetch()` and\u00a0`response.json()`:\n\n```", "```js\n\nIt's important to note that the\u00a0`await`\u00a0keyword does not block like\u00a0`alert()`\u00a0or\u00a0`prompt()`. Instead, it simply pauses the execution of the asynchronous function, freeing up the\u00a0*Event Loop*\u00a0to continue with other work, and then, when its *Promise* resolves, it will continue execution where it left off. Remember,\u00a0`await`\u00a0is only syntactic *sugar*\u00a0over functionality that we can already achieve. If we wanted to implement our\u00a0`setupFeed`\u00a0function without\u00a0`async`/`await`,\u00a0we could easily do that by reverting to our old pattern of passing callbacks to\u00a0`Promise#then`:\n\n```", "```js\n\nObserve how the code is slightly clunkier and more congested when we don't use\u00a0`await`. Using\u00a0`await`\u00a0in concert with asynchronous functions gives us the same satisfyingly linear and procedural appearance as regular synchronous code. This can vastly simplify an otherwise complicated asynchronous control flow, making it clearer to our fellow programmer *what*\u00a0is happening *when*.\u00a0\n\nThe await keyword is also available for use within the `for...of` iteration construct. Doing so will await each value iterated over. If, during iteration, any encountered value is a *Promise,* the iteration will not continue until that *Promise* has been resolved:\n\n```"]