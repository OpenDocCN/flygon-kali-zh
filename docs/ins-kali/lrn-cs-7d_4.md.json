["```cs\nnamespace Day04\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Write(\"Enter number1:\");\n            var num1 = ReadLine();\n            Write(\"Enter number2:\");\n            var num2 = ReadLine();\n            var sum = Convert.ToInt32(num1) +\n            Convert.ToInt32(num2);\n            Write($\"Sum of {num1} and {num2} is {sum}\");\n            ReadLine();\n        }\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    internal class StringCalculator\n    {\n        public string Num1 { get; set; }\n        public string Num2 { get; set; }\n\n        public int Sum() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n     }\n}\nNum1 and Num2, and one method Sum(), with the access modifier public. This means these properties and the method is accessible to other classes as well. Here is the code snippet that consumes the preceding class:\n```", "```cs\nnamespace Day04\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringCalculator calculator = new\n            StringCalculator();\n            Write(\"Enter number1:\");\n            calculator.Num1 = ReadLine();\n            Write(\"Enter number2:\");\n            calculator.Num2 = ReadLine();\n            Write($\"Sum of {calculator.Num1} and\n            {calculator.Num2} is {calculator.Sum()}\");\n            ReadLine();\n        }\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    class StringCalculator\n    {\n\n        protected string Num1 { get; set; }\n        protected string Num2 { get; set; }\n\n    }\n\n    class StringCalculatorImplementation : StringCalculator\n    {\n        public void Sum()\n        {\n            StringCalculatorImplementation calculator =\n            new StringCalculatorImplementation();\n\n            Write(\"Enter number1:\");\n\n            calculator.Num1 = ReadLine();\n\n            Write(\"Enter number2:\");\n\n            calculator.Num2 = ReadLine();\n\n            int sum = Convert.ToInt32(calculator.Num1) +\n            Convert.ToInt32(calculator.Num2);\n\n            Write($\"Sum of {calculator.Num1} and\n            {calculator.Num2} is {sum}\");\n        }\n    }\n}\n```", "```cs\nclass StringCalculatorImplementation : StringCalculator\n{\n    readonly StringCalculator _stringCalculator = new\n    StringCalculator();\n    public int Sum()\n    {\n        var num=_stringCalculator.Num1; //will not work\n        var number=_stringCalculator.Num2; //will not work\n\n        //other stuff\n    }\n}\n```", "```cs\nnamespace ExternalLib\n{\n    internal class StringCalculatorExternal\n    {\n        public string Num1 { get; set; }\n        public string Num2 { get; set; }\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    internal class StringCalculator\n    {\n        public int Sum()\n        {\n            //This will not work\n            StringCalculatorExternal externalLib = new StringCalculatorExternal();\n            return Convert.ToInt32(externalLib.Num1) + Convert.ToInt32(externalLib.Num2);\n        }\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    internal class StringCalculator\n    {\n        protected internal string Num1 { get; set; }\n        protected internal string Num2 { get; set; }\n    }\n\n    internal class StringCalculatorImplement :\n    StringCalculator\n    {\n        public int Sum() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            var calculator = new\n            StringCalculatorImplement();\n            Write(\"Enter number1:\");\n            calculator.Num1 = ReadLine();\n            Write(\"Enter number2:\");\n            calculator.Num2 = ReadLine();\n\n            Write($\"Sum of {calculator.Num1} and\n            {calculator.Num2} is {calculator.Sum()}\");\n            ReadLine();\n        }\n    }\n}\n```", "```cs\ninternal class StringCalculator\n{\n    private string Num1 { get; set; }\n    private string Num2 { get; set; }\n\n    public int Sum() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n}\n```", "```cs\ninternal class StringCalculatorAnother\n{\n    private readonly StringCalculator _calculator;\n\n    public StringCalculatorAnother(StringCalculator\n    calculator)\n    {\n        _calculator = calculator;\n    }\n\n    public int Sum() => Convert.ToInt32(_calculator.Num1) +        Convert.ToInt32(_calculator.Num2);\n\n}\n```", "```cs\nnamespace Day04\n{\n    internal abstract class StringCalculator\n    {\n        public abstract string Num1 { get; set; }\n        protected abstract string Num2 { get; set; }\n        internal abstract string Num3 { get; set; }\n        protected internal abstract string Num4 { get;\n        set; }\n\n        public int Sum() => Convert.ToInt32(Num1) +            Convert.ToInt32(Num2);\n    }\n}\n```", "```cs\ninternal class StringCalculatorImplement : StringCalculator\n{\n    public override string Num1 { get; set; }\n    protected override string Num2 { get; set; }\n    internal override string Num3 { get; set; }\n    protected internal override string Num4 { get; set; }\n\n    //other stuffs here\n}\nStringCalculatorImplement is implementing the abstract class StringCalculator, and all members are marked as abstract.\n```", "```cs\ninternal abstract class StringCalculator\n{\n    public abstract string Num1 { get; set; }\n    public abstract string Num2 { get; set; }\n    public abstract int SumToBeImplement();\n\n    //non-abstract\n    public int Sum() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n}\n\ninternal class StringCalculatorImplement : StringCalculator\n{\n    public override string Num1 { get; set; }\n    public override string Num2 { get; set; }\n    public override int SumToBeImplement() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n}\n```", "```cs\ninternal abstract class StringCalculator\n{\n    public abstract string Num1 { get; set; }\n    public abstract string Num2 { get; set; }\n    public abstract int SumToBeImplement();\n\n    //non-abstract\n    public int Sum() => Convert.ToInt32(Num1) + Convert.ToInt32(Num2);\n}\ninternal abstract class AnotherAbstractStringCalculator: StringCalculator\n{\n    //no need to implement members of StringCalculator class  \n}\nAnotherAbstractString, is inheriting another abstract class, StringCalculator. As both the classes are abstract, there's no need to implement members of the inherited abstract class that is StringCalculator.\n```", "```cs\ninternal abstract class StringCalculator\n{\n    public  string Num1 { get; set; }\n    public  string Num2 { get; set; }\n    public abstract int Sum();\n\n}\n\ninternal class StringCalculatorImplement : StringCalculator\n{\n    public override int Sum() => Convert.ToInt32(Num1) +     Convert.ToInt32(Num2);\n}\n```", "```cs\ninternal class StringCalculator\n{\n    public string Num1 { get; set; }\n    public string Num2 { get; set; }\n    public async Task<int> Sum() => await Task.Run(()=>Convert.ToInt32(Num1) +\n        Convert.ToInt32(Num2));\n}\n```", "```cs\ninternal class StringCalculator\n{\n    private const int Num1 = 70;\n    public const double Pi = 3.14;\n    public const string Book = \"Learn C# in 7-days\";\n\n    public int Sum()\n    {\n        const int num2 = Num1 + 85;\n        return  Convert.ToInt32(Num1) + Convert.ToInt32(num2);\n    }\n}\n```", "```cs\nStringCalculator calculator = new StringCalculator();\n```", "```cs\ninternal class StringCalculator\n{\n    private const int Num1 = 70;\n    private const int Num2 = 89;\n\n    public int Sum() => Num1 + Num2;\n}\n\ninternal class StingCalculatorImplement : StringCalculator\n{\n    public int Num1 { get; set; }\n    public int Num2 { get; set; }\n\n    public new int Sum() => Num1 + Num2;\n}\n```", "```cs\nnamespace Day04\n{\n    public partial class Calculator\n    {\n        public int Add(int num1, int num2) => num1 + num2;\n    }\n}\nnamespace Day04\n{\n    public partial class Calculator\n    {\n        public int Sub(int num1, int num2) => num1 - num2;\n    }\n}\n```", "```cs\ninternal class StringCalculator\n{\n    private readonly int _num2;\n    public readonly int Num1 = 179;\n\n    public StringCalculator(int num2)\n    {\n        _num2 = num2;\n    }\n\n    public int Sum() => Num1 + _num2; \n}\nNum1 and _num2 are readonly .Here is the code snippet that tells us how to use these fields:\n```", "```cs\nnamespace Day04\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            WriteLine(\"Example of readOnly modifier\");\n            Write(\"Enter number of your choice:\");\n            var num = ReadLine();\n            StringCalculator calculator =\n            newStringCalculator(Convert.ToInt32(num));\n            Write($\"Sum of {calculator.Num1} and {num} is\n            {calculator.Sum()}\");\n            ReadLine();\n        }\n    }\n}\n_num2 is initialized from the constructor and Num1 is initialized at the time of its declaration. When you run the preceding code, it generates output as shown in following screenshot:\n```", "```cs\nNum1 to the readonly field. This is not allowed, so it throws an error.\n```", "```cs\ninternal abstract class StringCalculator\n{\n    public int Num1 { get; set; }\n    public int Num2 { get; set; }\n\n    public abstract int Sum();\n    public virtual int Sub() => Num1 -Num2;\n}\ninternal class Calc : StringCalculator\n{\n    public int Num3 { get; set; }\n    public int Num4 { get; set; }\n    public override int Sub() => Num3 - Num4;\n    //This will not be inherited from within derive classes\n    //any more\n    public sealed override int Sum() => Num3 + Num4;\n}\ncalc, both the methods Sum() and Sub() are overridden. From here, method Sub() is available for further overriding, but Sum() is a sealed method, so we can't override this method anymore in derived classes. If we explicitly try to do this, it throws a compile-time error as shown in the following screenshot:\n```", "```cs\ninternal class StringCalculator\n{\n   public const int Num1 = 10;\n   public const int Num2 = 20;\n}\n```", "```cs\ninternal class Program\n{\n    private static void Main(string[] args)\n    {\n        WriteLine(\"Example of static modifier\");\n        Write($\"Sum of {StringCalculator.Num1} and\n        {StringCalculator.Num2} is{StringCalculator.Num1 +\n        StringCalculator.Num2}\");\n        ReadLine();\n    }\n}\n```", "```cs\ninternal class StringCalculator\n{\n    private const int Num1 = 70;\n    private const int Num2 = 89;\n\n    public virtual int Sum() => Num1 + Num2;\n}\n\ninternal class StingCalculatorImplement : StringCalculator\n{\n    public int Num1 { get; set; }\n    public int Num2 { get; set; }\n\n    public override int Sum() => Num1 + Num2;\n}\n```", "```cs\nnamespace Day04\n{\n    class StringCalculatorUpdated\n    {\n        public int Add(string numbers)\n        {\n            int result=0;\n            if (string.IsNullOrEmpty(numbers))\n                return result;\n            foreach (var n in numbers.Split(','))\n            {\n                result +=\n                Convert.ToInt32(string.IsNullOrEmpty(n) ? \"0\" : n);\n            }\n            return result;\n        }\n    }\n}\nnamespace Day04\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            WriteLine(\"Example of method\");\n            StringCalculatorUpdated calculator = new\n            StringCalculatorUpdated();\n            Write(\"Enter numbers comma separated:\");\n            var num = ReadLine();\n            Write($\"Sum of {num} is\n            {calculator.Add(num)}\");\n            ReadLine();\n        }\n    }\n}\n```", "```cs\nnamespace Day04\n{\n    internal class StringCalculatorUpdated\n   {\n        public int Add(string numbers) =>\n        IsNullOrEmpty(numbers) ? 0 :\n        AddStringNumbers(numbers);\n\n        private bool IsNullOrEmpty(string numbers) =>\n        string.IsNullOrEmpty(numbers);\n\n        private int AddStringNumbers(string numbers) =>\n        GetSplittedStrings(numbers).Sum(StringToInt32);\n\n        private IEnumerable<string>\n        GetSplittedStrings(string numbers) =>\n        numbers.Split(',');\n        private int StringToInt32(string n) =>\n        Convert.ToInt32(string.IsNullOrEmpty(n) ? \"0\" : n);\n    }\n}\n```", "```cs\npublic int Number { get; set; }\n```", "```cs\nprivate int _number;\n\npublic int Number\n{\n    get { return _number; }\n    set { _number = value; }\n}\n```", "```cs\nprivate int _number;\npublic int Number\n{\n    get => _number;\n    set => _number = value;\n}\n```", "```cs\ninternal class ProeprtyExample\n{\n    private int _num1;\n    //with backing field\n    public int Num1\n    {\n        get => _num1;\n        set => _num1 = value;\n    }\n    //auto property\n    public int Num2 { get; set; }\n}\n```", "```cs\ninternal class PropertyExample\n{\n    public PropertyExample(int num1)\n    {\n        Num1 = num1;\n    }\n    //constructor restricted property\n    public int Num1 { get; }\n    //read-only auto proeprty\n    public int Num2 { get; private set; }\n    //read-only collection initialized property\n    public IEnumerable<string> Numbers { get; } = new List<string>();\n}\n```", "```cs\ninternal class ProeprtyExample\n{\n    //other stuff removed\n    public int Num3 { get; set; }\n    public int Num4 { get; set; }\n    public int Sum {\n        get\n        {\n            return Num3 + Num4;\n        }\n    }\n}\n```", "```cs\ninternal class ProeprtyExample\n{\n    public int Num3 { get; set; }\n    public int Num4 { get; set; }\n    public int Add => Num3 + Num4;\n}\n```", "```cs\ninternal class ProeprtyExample\n{\n    private int _number;\n    public int Number\n    {\n        get => _number;\n        set\n        {\n            if (value < 0)\n            {\n                //log for records or take action\n                //Log(\"Number is negative.\");\n                throw new ArgumentException(\"Number can't be -ve.\");\n            }\n            _number = value;\n        }\n    }\n}\n```", "```cs\npublic class PersonCollection\n{\n    private readonly string[] _persons = Persons();\n    public bool this[string name] => IsValidPerson(name);\n    private bool IsValidPerson(string name) =>\n    _persons.Any(person => person == name);\n\n    private static string[] Persons() => new[]\n    {\"Shivprasad\",\"Denim\",\"Vikas\",\"Merint\",\"Gaurav\"};\n}\n```", "```cs\nprivate static void IndexerExample()\n{\n    WriteLine(\"Indexer example.\");\n    Write(\"Enter person name to search from collection:\");\n    var name = ReadLine();\n    var person = new PersonCollection();\n    var result = person[name] ? \"exists.\" : \"does not\n    exist.\";\n    WriteLine($\"Person name {name} {result}\");\n}\n```", "```cs\nprivate static void FileInputOutputOperation()\n{\n    const string textLine = \"This file is created during\n    practice of C#\";\n    Write(\"Enter file name (without extension):\");\n    var fileName = ReadLine();\n    var fileNameWithPath = $\"D:/{fileName}.txt\";\n    using (var fileStream = File.Create(fileNameWithPath))\n    {\n        var iBytes = new\n        UTF8Encoding(true).GetBytes(textLine);\n        fileStream.Write(iBytes, 0, iBytes.Length);\n    }\n    WriteLine(\"Write operation is completed.\");\n    ReadLine();\n    using (var fileStream =\n    File.OpenRead(fileNameWithPath))\n    {\n        var bytes = new byte[1024];\n        var encoding = new UTF8Encoding(true);\n        while (fileStream.Read(bytes, 0, bytes.Length) >\n        0)\n        WriteLine(encoding.GetString(bytes));\n    }\n}\n```", "```cs\nclass ExceptionhandlingExample\n    {\n        public int Div(int dividend,int divisor)\n        {\n            //thrown an exception if divisor is 0\n            return dividend / divisor;\n        }\n    }\n```", "```cs\nprivate static void ExceptionExample()\n{\n    WriteLine(\"Exaception handling example.\");\n    ExceptionhandlingExample example = new ExceptionhandlingExample();\n    Write(\"Enter dividen:\");\n    var dividend = ReadLine();\n    Write(\"Enter divisor:\");\n    var divisor = ReadLine();\n    var quotient = example.Div(Convert.ToInt32(dividend), Convert.ToInt32(divisor));\n    WriteLine($\"Quotient of dividend:{dividend}, divisio:{divisor} is {quotient}\");\n}\n```", "```cs\nclass ExceptionhandlingExample\n{\n    public int Div(int dividend,int divisor)\n    {\n        int quotient = 0;\n        try\n        {\n            quotient = dividend / divisor;\n        }\n        catch (Exception exception)\n        {\n            Console.WriteLine($\"Exception occuered\n            '{exception.Message}'\");\n        }\n        finally\n        {\n            Console.WriteLine(\"Exception occured and cleaned.\");\n        }\n        return quotient;\n    }\n}\n```", "```cs\ninternal class NumberIsExcededException : Exception\n{\n    public NumberIsExcededException(string message) :\n    base(message)\n    {\n    }\n    public NumberIsExcededException(string message,\n    Exception innerException):base(message,innerException)\n    {\n    }\n    protected NumberIsExcededException(SerializationInfo\n    serializationInfo, StreamingContext streamingContext)\n    : base(serializationInfo, streamingContext) {}\n}\nNumberIsExcededException class. We have three constructors and all are self-explanatory. The third constructor is for serialization. If required here, we can do the serialization. So, when the exception goes to client from the remote server, it should be serialized.\n```", "```cs\ninternal class StringCalculatorUpdated\n{\n    public int Add(string numbers)\n    {\n        var result = 0;\n        try\n        {\n            return IsNullOrEmpty(numbers) ? result :\n            AddStringNumbers(numbers);\n        }\n        catch (NumberIsExcededException excededException)\n        {\n            Console.WriteLine($\"Exception\n            occurred:'{excededException.Message}'\");\n        }\n\n        return result;\n    }\n    //other stuffs omitted\n\n    private int StringToInt32(string n)\n    {\n        var number = \n        Convert.ToInt32(string.IsNullOrEmpty(n) ? \"0\" : n);\n        if(number>1000)\n            throw new NumberIsExcededException($\"Number\n            :{number} excedes the limit of 1000.\");\n        return number;\n    }\n}\n```", "```cs\nprivate static void CallStringCalculatorUpdated()\n{\n    WriteLine(\"Rules for operation:\");\n    WriteLine(\"o This operation should only accept input\n    in a string data type\\n\" +\n              \"o Add operation can take 0, 1, or 2 comma -\n              separated numbers, and will return their sum\n              for example \\\"1\\\" or \\\"1, 2\\\"\\n\" +\n              \"o Add operation should accept empty string\n              but for an empty string it will return 0.\\n\"\n              +\n              \"o Throw an exception if number > 1000\\n\");\n              StringCalculatorUpdated calculator = new\n              StringCalculatorUpdated();\n    Write(\"Enter numbers comma separated:\");\n    var num = ReadLine();\n\n    Write($\"Sum of {num} is {calculator.Add(num)}\"); \n}\n```", "```cs\nprivate static void ValidateInputText(string inputText, string regExp,bool isCllection=false,RegexOptions option=RegexOptions.IgnoreCase)\n{\n    var regularExp = new Regex(regExp,option);\n\n    if (isCllection)\n    {\n        var matches = regularExp.Matches(inputText);\n        foreach (var match in matches)\n        {\n            WriteLine($\"Text '{inputText}' matches\n            '{match}' with pattern'{regExp}'\");\n        }\n    }\n    var singleMatch = Regex.Match(inputText, regExp,\n    option);\n    WriteLine($\"Text '{inputText}' matches '{singleMatch}'\n    with pattern '{regExp}'\");\n    ReadLine();\n\n}\n```", "```cs\nprivate static void RegularExpressionExample()\n{\n    WriteLine(\"Regular expression example.\\n\");\n    Write(\"Enter input text to match:\");\n    var inpuText = ReadLine();\n    if (string.IsNullOrEmpty(inpuText))\n        inpuText = @\"The quick brown fox jumps over the lazy dog.\";\n    WriteLine(\"Following is the match based on different pattern:\\n\");\n    const string theDot = @\"\\.\";\n    WriteLine(\"The Period sign [.]\");\n    ValidateInputText(inpuText,theDot,true);\n    const string theword = @\"\\w\";\n    WriteLine(\"The Word sign [w]\");\n    ValidateInputText(inpuText, theword, true);\n    const string theSpace = @\"\\s\";\n    WriteLine(\"The Space sign [s]\");\n    ValidateInputText(inpuText, theSpace, true);\n    const string theSquareBracket = @\"\\[The]\";\n    WriteLine(\"The Square-Brackets sign [( )]\");\n    ValidateInputText(inpuText, theSquareBracket, true);\n    const string theHyphen = @\"\\[a-z0-9]ww\";\n    WriteLine(\"The Hyphen sign [-]\");\n    ValidateInputText(inpuText, theHyphen, true);\n    const string theStar = @\"\\[a*]\";\n    WriteLine(\"The Star sign [*] \");\n    ValidateInputText(inpuText, theStar, true);\n    const string thePlus = @\"\\[a+]\";\n    WriteLine(\"The Plus sign [+] \");\n    ValidateInputText(inpuText, thePlus, true);\n}\n```"]