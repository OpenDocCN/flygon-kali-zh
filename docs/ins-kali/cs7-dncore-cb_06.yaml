- en: Working with Files, Streams, and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件、流和序列化
- en: 'Working with files, streams, and serialization is something you as a developer
    will do many times. Creating import files, exporting data to a file, persisting
    an application state, using a file definition to build a file, and many other
    scenarios will present themselves at some point during your career. In this chapter,
    we will look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件、流和序列化是作为开发人员您将多次进行的工作。创建导入文件，将数据导出到文件，保存应用程序状态，使用文件定义构建文件以及许多其他场景在您的职业生涯中的某个时刻都会出现。在本章中，我们将看到以下内容：
- en: Creating and extracting ZIP archives
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和提取ZIP存档
- en: In-memory stream compression and decompression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存流压缩和解压缩
- en: Async and await file processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步和等待文件处理
- en: How to make a custom type serializable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使自定义类型可序列化
- en: Using ISerializable for custom serialization to a FileStream
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ISerializable进行自定义序列化到FileStream
- en: Using XmlSerializer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XmlSerializer
- en: JSON serializers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON序列化器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Being able to work with files will definitely give you an edge as a developer.
    There are so many frameworks for working with files available to developers today,
    that one tends to forget that some of the functionality you want is already rolled
    up into the .NET Framework itself. Let's look at what exactly we can do with files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 能够处理文件肯定会让您作为开发人员具有优势。如今，开发人员可以使用许多用于处理文件的框架，以至于人们往往会忘记一些您想要的功能已经包含在.NET Framework中。让我们看看我们可以用文件做些什么。
- en: If you ever find that you need to create Excel files in ASP.NET applications,
    do have a look at the excellent EPPlus .NET library available on CodePlex. At
    the time of writing, the URL was: [https://epplus.codeplex.com/](https://epplus.codeplex.com/)
    and is licensed under the GNU **Library General Public License** (**LGPL**). Also
    consider donating to EPPlus. These folks wrote an incredible library that is very
    easy to use and well documented.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己需要在ASP.NET应用程序中创建Excel文件，请查看CodePlex上提供的出色EPPlus .NET库。在撰写本文时，URL为：[https://epplus.codeplex.com/](https://epplus.codeplex.com/)，并且根据GNU
    **图书馆通用公共许可证**（**LGPL**）许可。还考虑捐赠给EPPlus。这些人编写了一个非常易于使用和文档完善的令人难以置信的库。
- en: On March 31, 2017 it was announced that CodePlex would be shut down completely
    on December 15, 2017\. According to the DISCUSSIONS tab on the EPPlus CodePlex
    page ([https://epplus.codeplex.com/discussions/662424](https://epplus.codeplex.com/discussions/662424))
    the source code will be moved to GitHub before CodePlex goes into read-only mode
    in October 2017.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年3月31日宣布，CodePlex将在2017年12月15日完全关闭。根据EPPlus CodePlex页面上的DISCUSSIONS标签（[https://epplus.codeplex.com/discussions/662424](https://epplus.codeplex.com/discussions/662424)），源代码将在CodePlex在2017年10月进入只读模式之前移至GitHub。
- en: Creating and extracting ZIP archives
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和提取ZIP存档
- en: One of the most basic things you can do is work with ZIP files. The .NET Framework
    does an excellent job at providing this functionality right out of the box. You
    might need to provide ZIP functionality in an application that needs to upload
    several files to a network share. Being able to ZIP several files and upload a
    single ZIP file makes more sense than having to upload several smaller files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的最基本的事情之一是处理ZIP文件。 .NET Framework在提供这个功能方面做得非常好。您可能需要在需要上传多个文件到网络共享的应用程序中提供ZIP功能。能够将多个文件压缩成一个ZIP文件并上传，比起上传多个较小的文件更有意义。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a console application and call it `FilesExample`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，将其命名为`FilesExample`：
- en: '![](img/B06434_07_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_01.png)'
- en: 'Right-click on the References node and select Add Reference... from the context
    menu:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“引用”节点，从上下文菜单中选择“添加引用…”：
- en: '![](img/B06434_07_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_02.png)'
- en: In the Reference Manager, search for the word `compression`. Add a reference
    to System.IO.Compression and System.IO.Compression.FileSystem to your project
    and click on the OK button.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“引用管理器”中，搜索“compression”一词。将System.IO.Compression和System.IO.Compression.FileSystem引用添加到您的项目中，然后单击“确定”按钮。
- en: At the time of writing, there was a System.IO.Compression version 4.1.0.0 and
    System.IO.Compression version 4.0.0.0 available from the Reference Manager. The
    example I created just used version 4.1.0.0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，引用管理器中有System.IO.Compression版本4.1.0.0和System.IO.Compression版本4.0.0.0可用。我创建的示例只使用了版本4.1.0.0。
- en: '![](img/B06434_07_03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_03.png)'
- en: 'When you have added your references, your solution should look as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了引用之后，您的解决方案应如下所示：
- en: '![](img/B06434_07_04-1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_04-1.png)'
- en: 'Create a folder called `Documents` in your `temp` folder:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`temp`文件夹中创建一个名为`Documents`的文件夹：
- en: '![](img/B06434_07_05.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_05.png)'
- en: 'Inside this folder, create a few files of varying sizes:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹里，创建几个不同大小的文件：
- en: '![](img/B06434_07_06.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_06.png)'
- en: You are now ready to write some code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始编写一些代码了。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Add the following `using` statements to the top of your `Program.cs` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`语句添加到您的`Program.cs`文件的顶部：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a method called `ZipIt()` and add the code to it to ZIP the `Documents`
    directory. The code is pretty straightforward to understand. I want to, however,
    highlight the use of the `CreateFromDirectory()` method. Notice that we have set
    the compression level to `CompressionLevel.Optimal` and set the `includeBaseDirectory`
    parameter to `false`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ZipIt()`的方法，并将代码添加到其中以压缩`Documents`目录。代码非常简单易懂。然而，我想强调一下`CreateFromDirectory()`方法的使用。请注意，我们已将压缩级别设置为`CompressionLevel.Optimal`，并将`includeBaseDirectory`参数设置为`false`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run your console application and look at the `temp` folder again. You will
    see the following ZIP file created:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，再次查看“temp”文件夹。您将看到创建了以下ZIP文件：
- en: '![](img/B06434_07_07.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_07.png)'
- en: 'Viewing the contents of the ZIP file will display the files contained in the
    `Documents` folder that we saw earlier:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看ZIP文件的内容将显示`Documents`文件夹中包含的文件：
- en: '![](img/B06434_07_08.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_08.png)'
- en: 'Viewing the properties of the ZIP file, you will see that it has been compressed
    to 36 KB:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看ZIP文件的属性，您将看到它已经压缩到36 KB：
- en: '![](img/B06434_07_09.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_09.png)'
- en: 'Extracting a ZIP file is just as easy to do. Create a method called `UnZipIt()`
    and pass the path to the `temp` folder to it. Then, specify the directory to unzip
    the files to and set the variable called `destinationDirectory`. Call the `ExtractToDirectory()`
    method and pass it the `archiveName` and `destinationDirectory` variables as parameters:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压ZIP文件同样很容易。创建一个名为`UnZipIt()`的方法，并将路径传递给`temp`文件夹。然后，指定要解压缩文件的目录，并设置名为`destinationDirectory`的变量。调用`ExtractToDirectory()`方法，并将`archiveName`和`destinationDirectory`变量作为参数传递：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run your console application and view the output folder:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并查看输出文件夹：
- en: '![](img/B06434_07_10.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_10.png)'
- en: 'Viewing the extracted files in the `DocumentsUnzipped` folder, you will see
    the original files we started off with:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DocumentsUnzipped`文件夹中查看提取的文件，您将看到我们开始时的原始文件：
- en: '![](img/B06434_07_11.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_11.png)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Working with ZIP files in .NET is really as easy as it gets. The .NET Framework
    does a lot of the heavy lifting for mundane tasks such as creating archives. It
    also allows developers to maintain a certain standard of code without having to
    "roll their own" archiving methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中使用ZIP文件真的非常简单。.NET Framework为诸如创建存档等繁琐任务做了很多重活。它还允许开发人员在不必“自己动手”创建存档方法的情况下保持一定的代码标准。
- en: In-memory stream compression and decompression
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存流压缩和解压
- en: Sometimes, you need to perform some in-memory compression of a large amount
    of text. You might want to write this to a file or a database. Perhaps you need
    to e-mail the text as an attachment that another system will pick up and then
    decompress. Whatever the reason, in-memory compression and decompression is a
    very useful feature to have around. The best way to do this is to use extension
    methods. If you haven't figured this out by now, I quite like using extension
    methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要对大量文本进行内存压缩。您可能希望将其写入文件或数据库。也许您需要将文本作为附件发送电子邮件，另一个系统将接收并解压缩。无论原因如何，内存压缩和解压缩都是非常有用的功能。最好的方法是使用扩展方法。如果您现在还没有想明白，我非常喜欢使用扩展方法。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code is very straightforward. There is not much you will need to get ready
    beforehand. Just make sure that you include the following `using` statements in your
    project and that you have a file containing text called `file 3.txt` at the following
    path `C:\temp\Documents\file 3.txt`. You can continue using the console application
    created in the preceding recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。您不需要太多准备工作。只需确保在您的项目中包含以下`using`语句，并且在以下路径`C:\temp\Documents\file 3.txt`有一个名为`file
    3.txt`的包含文本的文件。您可以继续使用前面一篇文章中创建的控制台应用程序。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class called `ExtensionMethods` that will contain two extension methods
    called `CompressStream()` and `DecompressStream()`. Both these extension methods
    will act on a byte array and return a byte array:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ExtensionMethods`的类，其中包含两个扩展方法，名为`CompressStream()`和`DecompressStream()`。这两个扩展方法都将作用于字节数组并返回一个字节数组：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Looking at the `CompressStream()` extension method, you need to create a new
    `MemoryStream` to return to the calling code. Make use of the `using` statement
    so that objects are properly disposed of when they move out of scope. Next, add
    a `new GZipStream` object that will compress whatever we give it into the `outStream`
    object. You will notice that  `CompressionMode.Compress` is passed as a parameter
    to the `GZipStream` object. Lastly, write `originalSource` to the `GZipStream`
    object, compressing it and returning it to the calling method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`CompressStream()`扩展方法，您需要创建一个新的`MemoryStream`以返回给调用代码。利用`using`语句，以便在对象移出范围时正确处理对象的释放。接下来，添加一个`new
    GZipStream`对象，它将压缩我们提供的内容到`outStream`对象中。您会注意到，`CompressionMode.Compress`作为参数传递给`GZipStream`对象。最后，将`originalSource`写入`GZipStream`对象，对其进行压缩并返回给调用方法：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Turn your attention to the `DecompressStream()` extension method next. The
    process is actually really simple. Create a new `MemoryStream` from `originalSource`
    and call it `sourceStream`. Create another `MemoryStream` called `outStream` to
    return to the calling code. Next, create a new `GZipStream` object and pass it
     `sourceStream` while setting the `CompressionMode.Decompress` value. Copy the
    decompressed stream to  `outStream` and return it to the calling code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将注意力转向`DecompressStream()`扩展方法。这个过程实际上非常简单。从`originalSource`创建一个新的`MemoryStream`，并将其命名为`sourceStream`。创建另一个名为`outStream`的`MemoryStream`以返回给调用代码。接下来，创建一个新的`GZipStream`对象，并将其传递给`sourceStream`，同时设置`CompressionMode.Decompress`值。将解压缩的流复制到`outStream`并返回给调用代码：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I created a method called `InMemCompressDecompress()` to illustrate the use
    of in-memory compression and decompression. I''m reading the contents of the file
    at `C:tempDocumentsfile 3.txt` into a variable called `inputString`. I then  use
    the default encoding to get the bytes, the original length, compressed length,
    and decompressed length. If you want to get the original text back, be sure to
    include the line `newString = Encoding.Default.GetString(newFromCompressed);`
    in your code and output that to the console window. A word of warning, though:
    if you are reading a lot of text, it''s probably not going to make much sense
    to display that in the console window. Write it to a file instead to check if
    the text is the same as what was compressed:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我创建了一个名为`InMemCompressDecompress()`的方法，以说明内存压缩和解压的用法。我正在读取`C:tempDocumentsfile
    3.txt`文件的内容到一个名为`inputString`的变量中。然后，我使用默认编码来获取字节，原始长度，压缩长度和解压长度。如果您想要恢复原始文本，请确保在您的代码中包含`newString
    = Encoding.Default.GetString(newFromCompressed);`这一行，并将其输出到控制台窗口。不过，需要警告一下：如果您读取了大量文本，将其显示在控制台窗口可能没有太多意义。最好将其写入文件，以检查文本是否与压缩前的文本相同：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure that you have a file called `File 3.txt` in the correct directory, as
    stated previously. Also, ensure that the file contains some text. You can see
    that the file I am going to compress in-memory is about 1.8 MB in size:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在正确的目录中有一个名为`File 3.txt`的文件。还要确保文件包含一些文本。您可以看到，我要在内存中压缩的文件大小约为1.8 MB：
- en: '![](img/B06434_07_06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_06.png)'
- en: 'Running your console application will display the original length of the file,
    the compressed length and then the decompressed length. As would be expected,
    the decompressed length is the same length as the original string length:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将显示文件的原始长度，压缩长度，然后解压长度。预期的是，解压长度与原始字符串长度相同：
- en: '![](img/B06434_07_12-1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_12-1.png)'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In-memory compression and decompression allows developers to use on-the-fly
    compression and decompression when working with objects containing large data.
    This can be useful for when you need to read and write log information to a database,
    for example. This is another example of how the .NET Framework provides developers
    with the perfect platform to build world-class solutions on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内存压缩和解压允许开发人员在处理包含大量数据的对象时使用即时压缩和解压。例如，当您需要将日志信息读取和写入数据库时，这可能非常有用。这是.NET Framework如何为开发人员提供了构建世界一流解决方案的完美平台的另一个例子。
- en: Async and await file processing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步和等待文件处理
- en: With acync and await, developers can keep their applications fully responsive
    while performing intensive tasks such as file processing. This makes a perfect
    candidate for using asynchronous code. If you have several large files that need
    copying, an async and await method would be a perfect solution for keeping your
    form responsive.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步和等待，开发人员可以在执行诸如文件处理之类的密集任务时保持其应用程序完全响应。这使得使用异步代码成为一个完美的选择。如果您有几个需要复制的大文件，异步和等待方法将是保持表单响应的完美解决方案。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the following `using` statements to the top of your
    code file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已将以下`using`语句添加到代码文件的顶部：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For asynchronous code to work, we need to include the threading namespaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使异步代码工作，我们需要包含线程命名空间。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create two folders called `AsyncDestination` and `AsyncSource`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`AsyncDestination`和`AsyncSource`的两个文件夹：
- en: '![](img/B06434_07_13.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_13.png)'
- en: 'To the `AsyncSource` folder, add a couple of large files to process:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AsyncSource`文件夹中，添加一些要处理的大文件：
- en: '![](img/B06434_07_14-1.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_14-1.png)'
- en: 'Create a new WinForms application and add a forms times control, a button,
    and a label called `lblTimer` to the form. Call the timer asyncTimer and set its
    Interval to `1000` milliseconds (1 second):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的WinForms应用程序，并向表单添加一个表单时间控件，一个按钮和一个名为`lblTimer`的标签。将计时器命名为asyncTimer，并将其间隔设置为`1000`毫秒（1秒）：
- en: '![](img/B06434_07_15.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_15.png)'
- en: 'In the code above the constructor, add the `CancellationTokenSource` object
    and the `elapsedTime` variable to the `Form1` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数上面的代码中，将`CancellationTokenSource`对象和`elapsedTime`变量添加到`Form1`类中：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the constructor, set the timer label text:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，设置计时器标签文本：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the button click event handler, add two if conditions. The first will run
    when the button is clicked first. The second will be run when the button is clicked
    again to cancel the process. Take note that this is an `async` event handler for
    `btnCopyFileAsync`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮点击事件处理程序中，添加两个if条件。第一个条件将在首次点击按钮时运行。第二个条件将在再次点击按钮以取消进程时运行。请注意，这是`btnCopyFileAsync`的`async`事件处理程序：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a `Tick` event for the timer and update the timer label text:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为计时器添加一个`Tick`事件，并更新计时器标签文本：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Have a look at the second `if` condition inside the button click. Set the button
    text back to what it was, and then call the `Cancel()` method of the `CancellationTokenSource`
    object:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮点击事件中查看第二个`if`条件。将按钮文本设置回原来的内容，然后调用`CancellationTokenSource`对象的`Cancel()`方法：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the first `if` statement, set the source and destination directory. Also
    update the button text so that when it is clicked again, it will run the cancel
    logic. Instantiate  `CancellationTokenSource`, set the `elapsedTime` variable
    to `0` and then start the timer. We can now start enumerating the files in the
    source folder and store the result in the `fileEntries` variable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`if`语句中，设置源和目标目录。还要更新按钮文本，以便再次点击时运行取消逻辑。实例化`CancellationTokenSource`，将`elapsedTime`变量设置为`0`，然后启动计时器。现在我们可以开始枚举源文件夹中的文件，并将结果存储在`fileEntries`变量中：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Start by iterating over the files in the source folder and copying the file
    from the source folder to the destination folder asynchronously. This can be seen
    in the line of code `await sfs.CopyToAsync(dfs, 81920, cts.Token);`. The value
    `81920` is just the buffer size and the cancellation token `cts.Token` is passed
    to the async method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先迭代源文件夹中的文件，并异步将文件从源文件夹复制到目标文件夹。这可以在代码行`await sfs.CopyToAsync(dfs, 81920, cts.Token);`中看到。值`81920`只是缓冲区大小，取消令牌`cts.Token`被传递给异步方法：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, if the token isn''t canceled, stop the timer and update the timer label:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果令牌未被取消，停止计时器并更新计时器标签：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Putting the code all together, you will see how this all fits together:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有代码放在一起，您将看到这些如何完美地配合在一起：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When the Windows form opens up for the first time, you will see that the timer
    label defaults to Timer Stopped. Click on the Copy Files Async button to start
    the copy process:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows窗体首次打开时，您会看到计时器标签默认为Timer Stopped。单击“复制文件异步”按钮以开始复制过程：
- en: '![](img/B06434_07_16.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_16.png)'
- en: 'When the application has finished processing, you will see that the large files
    have been copied to the destination folder:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序完成处理时，您会看到大文件已被复制到目标文件夹：
- en: '![](img/B06434_07_17.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_17.png)'
- en: 'While the copy process is running, your Windows form remains active and responsive.
    The timer label also continues to count. Usually, with processes such as these,
    the form would be unresponsive:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制过程运行时，您的Windows窗体保持活动和响应。计时器标签也继续计数。通常，对于这样的过程，窗体将无响应：
- en: '![](img/B06434_07_18.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_18.png)'
- en: 'When the files have finished copying, the timer label will display the duration
    of the async copy process. A fun experiment is to play around with this code to
    see how much you can optimize it to improve the copy speed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件复制完成时，计时器标签将显示异步复制过程的持续时间。一个有趣的实验是玩弄这段代码，看看你能够优化它以提高复制速度：
- en: '![](img/B06434_07_19.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_19.png)'
- en: 'The Windows form not only remains responsive, but also allows you to cancel
    the process whenever you like. When you click on the Copy Files Async button,
    the text changes to Cancel Async Copy:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Windows窗体不仅保持响应，而且还允许您在任何时候取消进程。当单击“复制文件异步”按钮时，文本将更改为“取消异步复制”：
- en: '![](img/B06434_07_20.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_20.png)'
- en: Clicking on the Cancel button or sets the `CancellationTokenSource` object to
    canceled, which in turns stops the async file copy process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单击取消按钮或将`CancellationTokenSource`对象设置为取消状态，这将停止异步文件复制过程。
- en: How to make a custom type serializable?
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使自定义类型可序列化？
- en: 'Serialization is the process by which an object''s state is transformed into
    a set of bytes (depending on the serialization type used, it could be XML, binary,
    JSON), which can then be saved in a stream (think `MemoryStream` or `FileStream`)
    or transmitted via WCF or Web API. Making a custom type serializable means that
    you can apply serialization to custom types by adding the `System.SerializableAttribute`.
    Examples of custom types are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将对象的状态转换为一组字节的过程（根据使用的序列化类型，可以是XML、二进制、JSON），然后可以将其保存在流中（考虑`MemoryStream`或`FileStream`）或通过WCF或Web
    API进行传输。使自定义类型可序列化意味着您可以通过添加`System.SerializableAttribute`将序列化应用于自定义类型。以下是自定义类型的示例：
- en: Classes and generic classes
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和泛型类
- en: Structs
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Enums
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: A real-world example of serialization could be to create a recovery mechanism
    for a specific object. Think of a workflow scenario. At some point in time, the
    state of the workflow needs to be persisted. You can serialize the state of that
    object and store this in a database. When the workflow needs to continue at a
    future point in time, you can read the object from the database and deserialize
    it to the exact state as it was before it was persisted to the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化的一个现实世界的例子可能是为特定对象创建一个恢复机制。想象一个工作流场景。在某个时间点，工作流的状态需要被持久化。您可以序列化该对象的状态并将其存储在数据库中。当工作流需要在将来的某个时间点继续时，您可以从数据库中读取对象并将其反序列化为与其在被持久化到数据库之前完全相同的状态。
- en: Trying to serialize a non-serializable type will result in your code throwing
    a `SerializationException`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试序列化一个不可序列化的类型将导致您的代码抛出`SerializationException`。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: If you are running this example from your console application, ensure that the
    console application imports the `System` namespace by adding `using System` to
    the top of your `Program.cs` file. Also ensure that `using System.Runtime.Serialization.Formatters.Binary`
    is added.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从控制台应用程序运行此示例，请确保控制台应用程序通过在`Program.cs`文件顶部添加`using System`来导入`System`命名空间。还要确保添加`using
    System.Runtime.Serialization.Formatters.Binary`。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start by adding an abstract class called `Cat`. This class simply defines fields
    for `Weight` and `Age`. Note that in order to make your class serializable, you
    need to add the `[Serializable]` attribute to it.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为`Cat`的抽象类。这个类简单地定义了`Weight`和`Age`的字段。请注意，为了使您的类可序列化，您需要向其添加`[Serializable]`属性。
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a class called `Tiger` that is derived from the `Cat` class. Note
    that the `Tiger` class must also have the `[Serializable]` attribute added. This
    is because the serialization isn''t inherited from the base class. Each derived
    class must implement serialization on its own:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`Tiger`的类，它是从`Cat`类派生的。请注意，`Tiger`类也必须添加`[Serializable]`属性。这是因为序列化不是从基类继承的。每个派生类必须自己实现序列化：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to create a method to serialize the `Tiger` class. Create a new
    object of type `Tiger` and set some values to it. We then use a `BinaryFormatter`
    to serialize the `Tiger` class into a `stream` and return it to the calling code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个序列化`Tiger`类的方法。创建一个`Tiger`类型的新对象并为其设置一些值。然后，我们使用`BinaryFormatter`将`Tiger`类序列化为`stream`并将其返回给调用代码：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Deserialization is even easier. We create a `DeserializeTiger` method and pass
    the `stream` to it. We then use the `BinaryFormatter` again to deserialize the
    `stream` into an object of type `Tiger`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反序列化更容易。我们创建一个`DeserializeTiger`方法并将`stream`传递给它。然后我们再次使用`BinaryFormatter`将`stream`反序列化为`Tiger`类型的对象：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see the results of our serialization and deserialization, read the result
    from the `SerializeTiger()` method into a new `Stream` and display it in the console
    window. Then, call the `DeserializeTiger()` method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看序列化和反序列化的结果，请从`SerializeTiger()`方法中读取结果到一个新的`Stream`并在控制台窗口中显示它。然后，调用`DeserializeTiger()`方法：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the serialized data is written to the console window, you will see some
    identifying information. Most of it will, however, look jumbled up. This is because
    it's binary serialized data that is being displayed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列化的数据写入控制台窗口时，您将看到一些标识信息。但大部分看起来会混乱。这是因为显示的是二进制序列化数据。
- en: '![](img/B06434_07_21.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_21.png)'
- en: When this serialized data is deserialized, it is cast back to an object of the
    type `Tiger`. You can clearly see how the original values of the fields are visible
    in the deserialized object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些序列化的数据被反序列化时，它被转换回`Tiger`类型的对象。您可以清楚地看到序列化对象中原始字段的值是可见的。
- en: '![](img/B06434_07_22.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_22.png)'
- en: Using ISerializable for custom serialization to a FileStream
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ISerializable进行自定义序列化到FileStream
- en: If you want more control over what is serialized, you should implement `ISerializable`
    on your object. This gives a developer complete control over what is serialized.
    Note that you still need to add the `[ISerializable]` attribute to your object.
    Lastly, the developer also needs to implement a deserialization constructor. Using
    `ISerializable`, however, does have a caveat. According to the MSDN, the forward
    compatibility of your object with newer versions of the .NET Framework and any
    improvements made to the serialization framework might not be applicable on your
    object. You also need to implement `ISerializable` on all the derived types of
    your object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地控制序列化的内容，应该在对象上实现`ISerializable`。这使开发人员完全控制序列化的内容。请注意，您仍然需要在对象上添加`[ISerializable]`属性。最后，开发人员还需要实现一个反序列化构造函数。但是，使用`ISerializable`确实有一个注意事项。根据MSDN的说法，您的对象与.NET
    Framework的新版本和序列化框架的任何改进的向前兼容性可能不适用于您的对象。您还需要在对象的所有派生类型上实现`ISerializable`。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new class that wants to control its own serialization using
    `ISerializable`. Ensure that your application has the `using System.Runtime.Serialization;`
    added to the `using` statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类，希望使用`ISerializable`来控制自己的序列化。确保您的应用程序已经在`using`语句中添加了`using System.Runtime.Serialization;`。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class called `Vehicle`. You will notice that this class implements
    `ISerializable` while still having the `[Serializable]` attribute. You must do
    this so that the Common Language Runtime can identify this class as serializable:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Vehicle`的类。您会注意到这个类实现了`ISerializable`，同时还有`[Serializable]`属性。您必须这样做，以便公共语言运行时可以识别这个类是可序列化的：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To this class, add the following fields and the constructor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个类，添加以下字段和构造函数：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you implement `ISerilizable` on your `Vehicle` class, Visual Studio will
    alert you that the `ISerializable` interface has not been implemented inside your
    class. Add the implementation by clicking on the lightbulb next to the underlined
    interface name and accepting the correction. Visual Studio will now add the `GetObjectData()`
    method inside your class. Note that the method is added with an exception that
    will throw a `NotImplementedException` if you don''t add some code to the method.
    Add very basic code here that simply adds the values of the fields to the `SerializationInfo`
    object:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在`Vehicle`类上实现`ISerilizable`时，Visual Studio会提醒您在类内部未实现`ISerializable`接口。通过点击接口名称旁边的灯泡并接受更正来添加实现。Visual
    Studio现在将在您的类内部添加`GetObjectData()`方法。请注意，如果您不在方法中添加一些代码，该方法将添加一个`NotImplementedException`。在这里添加非常基本的代码，只需将字段的值添加到`SerializationInfo`对象中：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As mentioned previously, we need to add the deserialization constructor that
    will deserialize the fields. This, you add manually:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们需要添加反序列化构造函数，用于反序列化字段。这部分需要手动添加：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After adding all the code, your class should look as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加所有代码后，您的类应该如下所示：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are simply going to write the serialized class to a file. For the purposes
    of this recipe, simply hardcode an output path for the file. Next, create a new
    instance of the `Vehicle` class and set some values to the fields:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需将序列化的类写入文件中。在本示例中，只需为文件硬编码一个输出路径。接下来，创建`Vehicle`类的一个新实例，并为字段设置一些值：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also be sure to add the `VehicleTypes` enumerator to the top of your class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要确保在类的顶部添加`VehicleTypes`枚举器：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then add the code that will serialize the class to the file you specified
    in the hardcoded path. To do this, we add a `FileStream` and a `BinaryFormatter`
    object to serialize the `vehicle` to the file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加代码，将类序列化到硬编码路径中的文件中。为此，我们添加一个`FileStream`和一个`BinaryFormatter`对象，将`vehicle`序列化到文件中：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we add the code to read the file containing the serialized data and
    create the `Vehicle` object containing the state of the `Vehicle` at the time
    it was serialized. While the deserialize code runs immediately after the serialize
    code, note that this is just for demonstration purposes. The `Vehicle` deserialization
    could occur at any future point in time by reading from the file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加代码来读取包含序列化数据的文件，并创建包含`Vehicle`状态的`Vehicle`对象。虽然反序列化代码立即在序列化代码之后运行，但请注意，这只是为了演示目的。`Vehicle`的反序列化可以在将来的任何时间点通过从文件中读取来进行：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After you run your code, you will find that the `vehicleInfo.dat` file has
    been created at the path you specified:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码后，您会发现`vehicleInfo.dat`文件已经在您指定的路径创建了：
- en: '![](img/B06434_07_23.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_23.png)'
- en: 'Opening the file in a text editor will show the serialized information.  As
    you may notice, some of the class information is still visible:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开文件将显示序列化信息。正如您可能注意到的那样，一些类信息仍然可见：
- en: '![](img/B06434_07_24.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_24.png)'
- en: 'If we add a breakpoint in the deserialization code and inspect the created
    `deserializedVehicle` object, you will see that the `Vehicle` state has been *rehydrated*
    to the state it was before serialization:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在反序列化代码中添加断点并检查创建的`deserializedVehicle`对象，您会看到`Vehicle`状态已经*重新生成*到序列化之前的状态：
- en: '![](img/B06434_07_25.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_25.png)'
- en: Using XmlSerializer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XmlSerializer
- en: From the name you probably guessed that the`XmlSerializer` serializes data into
    XML. It gives you more control over the XML structure of the serialized data.
    Typical real-world examples for using this serializer would be to maintain compatibility
    with XML web services. It is also an easy medium to use when transmitting data
    using some type of message queuing (such as MSMQ or RabbitMQ).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称上您可能猜到，`XmlSerializer`将数据序列化为XML。它可以更好地控制序列化数据的XML结构。使用此序列化程序的典型实际示例是与XML
    Web服务保持兼容性。它也是在使用某种消息队列（如MSMQ或RabbitMQ）传输数据时使用的一种简单介质。
- en: The default behavior of  `XmlSerializer` is to serialize public fields and properties.
    Using attributes from the `System.Xml.Serialization` namespace, you can control
    the structure of your XML.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlSerializer`的默认行为是序列化公共字段和属性。使用`System.Xml.Serialization`命名空间中的属性，您可以控制XML的结构。'
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we are going to use  `List<>` in this example, ensure that you have added
    the `using System.Collections.Generic;` namespace. We also want to have more control
    over the structure of the XML, so also include the using `System.Xml.Serialization;`
    namespace so that we can use the appropriate attributes. Lastly, for the LINQ
    query, you will need to add the `using System.Linq;` namespace.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在此示例中使用`List<>`，请确保已添加`using System.Collections.Generic;`命名空间。我们还希望更多地控制XML的结构，因此还包括`using
    System.Xml.Serialization;`命名空间，以便我们可以使用适当的属性。最后，对于LINQ查询，您需要添加`using System.Linq;`命名空间。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start off by creating a `Student` class.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个`Student`类。
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, create a class for a subject called `FundamentalProgramming`. Several
    attributes have been applied to the fields of this class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`FundamentalProgramming`的主题类。已经对此类的字段应用了几个属性：
- en: '`XmlRoot`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlRoot`'
- en: '`XmlElement`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlElement`'
- en: '`XmlIgnore`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlIgnore`'
- en: '`XmlAttribute`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlAttribute`'
- en: '`XmlArray`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlArray`'
- en: 'We can see that the `XmlRoot` attribute specifies that `ElementName` be called
    `FundamentalsOfProgramming`. This attribute thus defines the root of your generated
    XML. The `XmlElement` specifies an element called `LecturerFullName` instead of
    `Lecturer`.  `XmlIgnore` attribute will cause  `XmlSerializer` to ignore this
    field during serialization, while  `XmlAttribute` will create an attribute on
    the root element of the generated XML. Lastly, we are serializing the `List<Student>`
    collection with the `XmlArray` attribute:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`XmlRoot`属性指定了`ElementName`称为`FundamentalsOfProgramming`。因此，此属性定义了生成的XML的根。`XmlElement`指定了一个名为`LecturerFullName`的元素，而不是`Lecturer`。`XmlIgnore`属性将导致`XmlSerializer`在序列化期间忽略此字段，而`XmlAttribute`将在生成的XML的根元素上创建一个属性。最后，我们使用`XmlArray`属性序列化`List<Student>`集合：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the calling code, set up the `Student` objects and add them to the `List<Student>`
    object `students`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用代码中，设置`Student`对象并将它们添加到`List<Student>`对象`students`中：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we create our `FundementalProgramming` class and populate the fields. The
    reason why `ClassAverage` is ignored is because we will always calculate this
    field value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建`FundementalProgramming`类并填充字段。`ClassAverage`被忽略的原因是因为我们将始终计算此字段的值：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following code to serialize the `subject` object, taking note to pass
    the type of object to  `XmlSerializer` as `typeof(FundamentalProgramming)`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以序列化`subject`对象，注意将对象类型传递给`XmlSerializer`作为`typeof(FundamentalProgramming)`：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, add the code to deserialize the XML back into the `FundamentalProgramming`
    object:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加代码将XML反序列化回`FundamentalProgramming`对象：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run the console application, you will find that it creates an XML document
    at the path you specified in the code. Viewing this XML document, you can see
    that the XML elements are defined exactly as we specified on the class by using
    the attributes. Note that the `FundamentalsOfProgramming` root element has the
    `RoomNumber` field as an attribute. The field `ClassAverage` has been ignored
    and is not present in the XML. Lastly, you can see how nicely the `List<Student>`
    object has been serialized to the XML file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行控制台应用程序时，您会发现它在代码中指定的路径创建了一个XML文档。查看此XML文档，您会发现XML元素的定义与我们在类中使用属性指定的完全相同。请注意，`FundamentalsOfProgramming`根元素将`RoomNumber`字段作为属性。字段`ClassAverage`已被忽略，并且不在XML中。最后，您可以看到`List<Student>`对象已经很好地序列化到XML文件中。
- en: '![](img/B06434_07_26-2.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_26-2.png)'
- en: On deserialization of the XML, you will notice that the serialized values are
    displayed. `ClassAverage`; however, does not have a value as it was never serialized
    to begin with.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在对XML进行反序列化时，您会注意到序列化的值被显示。但是`ClassAverage`没有值，因为它从未被序列化。
- en: '![](img/B06434_07_27-1.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_27-1.png)'
- en: JSON serializers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON序列化器
- en: Unlike `BinaryFormatter`, JSON serialization serializes data in a human-readable
    format. Using `XmlSerializer` also produces XML that is human-readable, but JSON
    serialization produces a smaller data size than `XmlSerializer`. JSON is primarily
    used to exchange data and can be used with many different programming languages
    (as can XML).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与`BinaryFormatter`不同，JSON序列化以人类可读的格式序列化数据。使用`XmlSerializer`也会产生人类可读的XML，但是JSON序列化产生的数据大小比`XmlSerializer`小。JSON主要用于交换数据，并且可以与许多不同的编程语言一起使用（就像XML一样）。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the Tools menu, go to NuGet Package Manager and click on the Manage NuGet
    Packages for Solution... menu. In the Browse tab, search for Newtonsoft.Json and
    install the NuGet package. Newtonsoft.Json is a high-performance JSON framework
    for .NET. Once it is installed, you will see that the reference Newtonsoft.Json
    has been added to your project, References.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从工具菜单中，转到NuGet包管理器，单击“解决方案的NuGet包管理器...”菜单。在“浏览”选项卡中，搜索Newtonsoft.Json并安装NuGet包。Newtonsoft.Json是.NET的高性能JSON框架。安装后，您将看到已将Newtonsoft.Json引用添加到您的项目中。
- en: In the `using` statements for your class, add the following namespaces `using
    Newtonsoft.Json;` and `using Newtonsoft.Json.Linq;` to your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的`using`语句中，添加以下命名空间`using Newtonsoft.Json;`和`using Newtonsoft.Json.Linq;`到您的代码中。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start off by creating the `FundamentalProgramming` and `Student` classes we
    used before for  `XmlSerializer`. This time, remove all the attributes to produce
    the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建我们之前用于`XmlSerializer`的`FundamentalProgramming`和`Student`类。这次，删除所有属性以生成以下代码：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the calling code, set up the `Student` object, as previously and add them
    to  `List<Student>`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用代码中，设置`Student`对象，如以前所述，并将它们添加到`List<Student>`中：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `subject` object of type `FundamentalProgramming` and assign the
    values to the fields:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类型为`FundamentalProgramming`的`subject`对象，并为字段分配值：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a `JsonSerializer` object to your code and set the formatting to indented.
    Using a `JsonWriter`, serialize the `subject` to the `serializationPath` to the
    file `classInfo.txt`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的代码添加一个`JsonSerializer`对象，并将格式设置为缩进。使用`JsonWriter`，将`subject`序列化到`serializationPath`文件`classInfo.txt`中：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next section of code will read the text from the file `classInfo.txt` created
    previously and create a `JObject` called `jobj` that uses the `Newtonsoft.Json.Linq`
    namespace to query JSON objects. Use `JObject` to parse the string returned from
    the file. This is where the power of using the `Newtonsoft.Json.Linq` namespace
    becomes evident. I can query the `jobj` object using LINQ to return the student
    marks and calculate an average:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的下一部分将从之前创建的`classInfo.txt`文件中读取文本，并创建一个名为`jobj`的`JObject`，该对象使用`Newtonsoft.Json.Linq`命名空间来查询JSON对象。使用`JObject`来解析从文件返回的字符串。这就是使用`Newtonsoft.Json.Linq`命名空间的强大之处。我可以使用LINQ查询`jobj`对象来返回学生的分数并计算平均值：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you need to deserialize the JSON object, the deserializer logic is quite
    easy to implement. We use a `JsonReader` to get the text from the file and deserialize
    it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要对JSON对象进行反序列化，反序列化逻辑非常容易实现。我们使用`JsonReader`从文件中获取文本并进行反序列化：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After you run your console application, you can view the file created by the
    JSON serializer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序后，您可以查看JSON序列化器创建的文件。
- en: '![](img/B06434_07_28.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_28.png)'
- en: The results of the class average calculation on the class and from the LINQ
    query on the JSON object are exactly the same.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 班级平均值计算的结果和对JSON对象的LINQ查询结果完全相同。
- en: '![](img/B06434_07_29.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_29.png)'
- en: Lastly, the deserialized object from the JSON text in the file can be seen when
    adding a break point to the code and inspecting the `funProg` object. As you can
    see, the object state is the same as before it was serialized to the file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以在代码中添加断点并检查`funProg`对象，从文件中的JSON文本中反序列化的对象可以看到。如您所见，对象状态与序列化到文件之前的状态相同。
- en: '![](img/B06434_07_30.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_30.png)'
- en: Do you remember at the beginning of this recipe I mentioned that JSON produces
    much less data than XML? I created the `Student` class containing 10,000 students
    in  `List<Student>` and serialized using XML and JSON. The comparison between
    the two file sizes is quite stunning. JSON clearly produces a much smaller file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在本教程开始时我提到过JSON产生的数据比XML少得多吗？我创建了包含10,000名学生的`Student`类，使用XML和JSON进行了序列化。两个文件大小的比较非常惊人。显然，JSON产生了一个更小的文件。
- en: '![](img/B06434_07_31.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_07_31.png)'
