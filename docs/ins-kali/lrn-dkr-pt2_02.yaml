- en: Chapter 2. Handling Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。处理Docker容器
- en: In the previous chapter, we explained stimulating and sustainable concepts,
    which showed the Docker's way of crafting futuristic and flexible application-aware
    containers. We discussed all the relevant details of producing the Docker containers
    in multiple environments (on-premise as well as off-premise). Using these techniques,
    you can easily replicate these features in your own environments to get a rewarding
    experience. Therefore, the next step for us is to understand the container's life
    cycle aspects in a decisive manner. You will learn the optimal utilization of
    containers of our own as well as those of other third-party containers in an effective
    and risk-free way. Containers are to be found, assessed, accessed, and leveraged
    toward bigger and better applications. There are several tools that have emerged
    to streamline the handling of containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解释了激动人心和可持续的概念，展示了Docker打造未来和灵活的应用感知容器的方式。我们讨论了在多个环境（本地和离线）中生成Docker容器的所有相关细节。使用这些技术，您可以轻松地在自己的环境中复制这些功能，获得丰富的体验。因此，我们的下一步是以果断的方式了解容器的生命周期方面。您将学习如何以有效和无风险的方式最佳利用我们自己的容器以及其他第三方容器。容器可以被发现、评估、访问和利用，以实现更大更好的应用。出现了几种工具来简化容器的处理。
- en: In this chapter, we will dig deeper and describe the critical aspects of container
    handling at length. A number of practical tips and execution commands for the
    leveraging of containers will also be discussed in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入挖掘并详细描述容器处理的关键方面。本章还将讨论一些实用技巧和执行命令，以利用容器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Clarifying the Docker terms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 澄清Docker术语
- en: Working with the Docker images and containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Docker镜像和容器一起工作
- en: The meaning of the Docker registry and its repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表及其存储库的含义
- en: The Docker Hub Registry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub注册表
- en: Searching the Docker images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索Docker镜像
- en: Working with an interactive container
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与交互式容器一起工作
- en: Tracking the changes inside the containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪容器内部的变化
- en: Controlling and housekeeping the Docker containers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和管理Docker容器
- en: Building images from containers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器构建镜像
- en: Launching a container as a daemon
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器作为守护进程启动
- en: Clarifying the Docker terms
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 澄清Docker术语
- en: To make this chapter substantially simpler to understand and to minimize any
    kind of ambiguity, the frequently used terms will be explained in the following
    section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章更易于理解并尽量减少任何形式的歧义，常用术语将在下一节中解释。
- en: Docker images and containers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker镜像和容器
- en: A **Docker image** is a collection of all of the files that make up a software
    application. Each change that is made to the original image is stored in a separate
    layer. To be precise, any Docker image has to originate from a base image according
    to the various requirements. Additional modules can be attached to the base image
    for deriving the various images that can exhibit the preferred behavior. Each
    time you commit to a Docker image you are creating a new layer on the Docker image,
    but the original image and each pre-existing layer remains unchanged. In other
    words, images are typically of the read-only type. If they are empowered through
    the systematic attachment of newer modules, then a fresh image will be created
    with a new name. The Docker images are turning out to be a viable base for developing
    and deploying the Docker containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是构成软件应用程序的所有文件的集合。对原始镜像所做的每个更改都存储在单独的层中。准确地说，任何Docker镜像都必须源自基础镜像，根据各种要求。可以附加额外的模块到基础镜像，以派生出可以展现所需行为的各种镜像。每次提交到Docker镜像时，都会在Docker镜像上创建一个新的层，但原始镜像和每个现有的层都保持不变。换句话说，镜像通常是只读类型的。如果它们通过系统化附加新模块的方式得到增强，那么将创建一个带有新名称的新镜像。Docker镜像正在成为开发和部署Docker容器的可行基础。
- en: 'A base image has been illustrated here. Debian is the base image, and a variety
    of desired capabilities in the form of functional modules can be incorporated
    on the base image for arriving at multiple images:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个基础镜像。Debian是基础镜像，可以在基础镜像上合并各种所需的功能模块，以得到多个镜像：
- en: '![Docker images and containers](graphics/B03936_02_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Docker镜像和容器](graphics/B03936_02_01.jpg)'
- en: Every image has a unique `ID`, as explained in the following section. The base
    images can be enhanced such that they can create the parent images, which in turn
    can be used for creating the child images. The base image does not have any parent,
    that is, the parent images sit on top of the base image. When we work with an
    image and if we don't specify that image through an appropriate identity (say,
    a new name), then the `latest` image (recently generated) will always be identified
    and used by the Docker engine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都有一个唯一的`ID`，如下一节所述。基础镜像可以进行增强，以便它们可以创建父镜像，而父镜像反过来可以用于创建子镜像。基础镜像没有任何父级，也就是说，父镜像位于基础镜像之上。当我们使用一个镜像时，如果没有通过适当的标识（比如一个新名称）指定该镜像，那么Docker引擎将始终识别并使用`latest`镜像（最近生成的）。
- en: As per the Docker home page, a Docker image has a read-only template. For example,
    an image could contain an Ubuntu operating system, with Apache and your web application
    installed on it. Docker provides a simple way for building new images or of updating
    the existing images. You can also download the Docker images that the other people
    have already created. The Docker images are the building components of the Docker
    containers. In general, the base Docker image represents an operating system,
    and in the case of Linux, the base image can be one of its distributions, such
    as Debian. Adding additional modules to the base image ultimately dawns a container.
    The easiest way of thinking about a container is as the read-write layer that
    sits on one or more read-only images. When the container is run, the Docker engine
    not only merges all of the required images together, but it also merges the changes
    from the read-write layer into the container itself. This makes it a self-contained,
    extensible, and executable system. The changes can be merged by using the Docker
    `docker commit` subcommand. The new container will accommodate all the changes
    that are made to the base image. The new image will form a new layer on top of
    the base image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker官网，Docker镜像是一个只读模板。例如，一个镜像可以包含一个Ubuntu操作系统，上面安装了Apache和你的Web应用程序。Docker提供了一种简单的方法来构建新的镜像或更新现有的镜像。你也可以下载其他人已经创建的Docker镜像。Docker镜像是Docker容器的构建组件。一般来说，基础Docker镜像代表一个操作系统，在Linux的情况下，基础镜像可以是其发行版之一，比如Debian。向基础镜像添加额外的模块最终形成一个容器。最简单的想法是，容器是一个位于一个或多个只读镜像上的读写层。当容器运行时，Docker引擎不仅将所有所需的镜像合并在一起，还将读写层的更改合并到容器本身。这使得它成为一个自包含、可扩展和可执行的系统。可以使用Docker的`docker
    commit`子命令来合并更改。新容器将容纳对基础镜像所做的所有更改。新镜像将形成基础镜像的新层。
- en: 'The following diagram will tell you everything clearly. The base image is the
    **Debian** distribution, then there is an addition of two images (the **emacs**
    and the **Apache** server), and this will result in the container:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图将清楚地告诉你一切。基础镜像是**Debian**发行版，然后添加了两个镜像（**emacs**和**Apache**服务器），这将导致容器：
- en: '![Docker images and containers](graphics/B03936_02_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Docker镜像和容器](graphics/B03936_02_02.jpg)'
- en: Each commit invariably makes a new image. This makes the number of images go
    up steadily, and so managing them becomes a complicated affair. However, the storage
    space is not a big challenge because the new image that is generated is only comprised
    of the newly added modules. In a way, this is similar to the popular object storage
    in the cloud environments. Every time you update an object, there will be a new
    object that gets created with the latest modification and then it is stored with
    a new `ID`. In the case of object storage, the storage size balloons significantly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每次提交都会生成一个新镜像。这使得镜像数量稳步增加，因此管理它们变得复杂。然而，存储空间并不是一个大挑战，因为生成的新镜像只包括新添加的模块。在某种程度上，这类似于云环境中流行的对象存储。每次更新对象，都会创建一个带有最新修改的新对象，然后以新的`ID`存储。在对象存储的情况下，存储大小会显著增加。
- en: A Docker layer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Docker层
- en: A **Docker layer** could represent either read-only images or read-write images.
    However, the top layer of a container stack is always the read-write (writable)
    layer, which hosts a Docker container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**Docker层**可以代表只读镜像或读写镜像。然而，容器堆栈的顶层始终是读写（可写）层，其中托管着一个Docker容器。
- en: A Docker container
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Docker容器
- en: From the preceding diagram, it is clear that the read-write layer is the container
    layer. There could be several read-only images beneath the container layer. Typically,
    a container originates from a read-only image through the act of a `commit`. When
    you `start` a container, you actually refer to an image through its unique `ID`.
    Docker pulls the required image and its parent image. It continues to pull all
    the parent images until it reaches the base image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表可以看出，读写层是容器层。容器层下面可能有几个只读镜像。通常，容器是通过 `commit` 操作从只读镜像创建的。当您 `start` 一个容器时，实际上是通过其唯一的
    `ID` 引用一个镜像。Docker 拉取所需的镜像及其父镜像。它继续拉取所有父镜像，直到达到基础镜像。
- en: Docker Registry
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 注册表
- en: A **Docker Registry** is a place where the Docker images can be stored in order
    to be publicly found, accessed, and used by the worldwide developers for quickly
    crafting fresh and composite applications without any risks. Because all the stored
    images would have gone through multiple validations, verifications, and refinements,
    the quality of those images will be really high. Using the Docker `push` command,
    you can dispatch your Docker image to the Registry so that it is registered and
    deposited. As a clarification, the registry is for registering the Docker images,
    whereas the repository is for storing those registered Docker images in a publicly
    discoverable and centralized place. A Docker image is stored within a Repository
    in the Docker Registry. Each Repository is unique for each user or account.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 注册表**是 Docker 镜像可以存储的地方，以便全球开发人员可以快速创建新的复合应用程序，而不会有任何风险。因为所有存储的镜像都经过多次验证、核实和完善，这些镜像的质量将非常高。使用
    Docker `push` 命令，您可以将 Docker 镜像发送到注册表，以便注册和存储。澄清一下，注册表是用于注册 Docker 镜像的，而仓库是用于在公开可发现和集中的位置存储这些已注册的
    Docker 镜像。Docker 镜像存储在 Docker 注册表中的仓库中。每个用户或帐户的仓库都是唯一的。'
- en: Docker Repository
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 仓库
- en: A **Docker Repository** is a namespace that is used for storing a Docker image.
    For instance, if your app is named `helloworld` and your username or namespace
    for the Registry is `thedockerbook` then, in the Docker Repository, where this
    image would be stored in the Docker Registry would be named `thedockerbook/helloworld`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 仓库**是用于存储 Docker 镜像的命名空间。例如，如果您的应用程序命名为 `helloworld`，并且您的用户名或注册表的命名空间为
    `thedockerbook`，那么在 Docker 仓库中，此镜像将存储在 Docker 注册表中，命名为 `thedockerbook/helloworld`。'
- en: The base images are stored in the Docker Repository. The base images are the
    fountainheads for realizing the bigger and better images with the help of a careful
    addition of new modules. The child images are the ones that have their own parent
    images. The base image does not have any parent image. The images sitting on a
    base image are named as parent images because the parent images bear the child
    images.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像存储在 Docker 仓库中。基础镜像是实现更大更好镜像的源泉，通过谨慎添加新模块来帮助实现。子镜像是具有自己父镜像的镜像。基础镜像没有任何父镜像。坐在基础镜像上的镜像被称为父镜像，因为父镜像承载着子镜像。
- en: Working with Docker images
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 镜像
- en: 'In the previous chapter, we demonstrated the typical `Hello World!` example
    by using a `busybox` image. Now there is a need for a close observation of the
    output of the `docker pull` subcommand, which is a standard command for downloading
    the Docker images. You would have noticed the presence of the `busybox:latest`
    text in the output text, and we will explain this mystery in a detailed manner
    by bringing in a small twist to the `docker pull` subcommand by adding the `-a`
    option, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过使用`busybox`镜像演示了典型的`Hello World!`示例。现在需要仔细观察`docker pull`子命令的输出，这是一个用于下载Docker镜像的标准命令。您可能已经注意到输出文本中存在`busybox:latest`的文本，我们将通过对`docker
    pull`子命令添加`-a`选项来详细解释这个谜团。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Surprisingly, you will observe that the Docker engine downloads a few more
    images with the `-a` option. You can easily check the images that are available
    on the Docker host by running the `docker images` subcommand, which comes in handy,
    and it reveals more details with respect to `:latest` and the additional images
    that are downloaded by running this command. Let us run this command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，您会发现Docker引擎使用`-a`选项下载了更多的镜像。您可以通过运行`docker images`子命令轻松检查Docker主机上可用的镜像，这非常方便，并且通过运行此命令可以揭示有关`:latest`和其他附加镜像的更多细节。让我们运行这个命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get the list of images, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下镜像列表：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Evidently, we have five items in the preceding list, and to gain a better understanding
    of those, we need to comprehend the information that is printed out by the Docker
    images subcommand. Here is a list of the possible categories:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在前面的列表中有五个项目，为了更好地理解这些项目，我们需要理解Docker images子命令打印出的信息。以下是可能的类别列表：
- en: '`REPOSITORY`: This is the name of the repository or image. In the preceding
    example, the repository name is `busybox`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`仓库`: 这是仓库或镜像的名称。在前面的例子中，仓库名称是`busybox`。'
- en: '`TAG`: This is the tag associated with the image, for example `buildroot-2014.02`,
    `ubuntu-14.04`, `latest`. One or more tags can be associated with one image.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: 这是与镜像相关联的标签，例如`buildroot-2014.02`，`ubuntu-14.04`，`latest`。一个镜像可以关联一个或多个标签。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ubuntu-`* tagged images are built by using the `busybox-static` Ubuntu
    package and the `buildroot-`* tagged images are built from scratch by using the
    `buildroot` tool-chain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以`ubuntu-`*标记的镜像是使用`busybox-static` Ubuntu软件包构建的，以`buildroot-`*标记的镜像是使用`buildroot`工具链从头开始构建的。
- en: '`IMAGE ID`: Every image is associated with a unique `ID`. The image `ID` is
    represented by using a 64 Hex digit long random number. By default, the Docker
    images subcommand will only show 12 Hex digits. You can display all the 64 Hex
    digits by using the `--no-trunc` flag (for example: `sudo docker images --no-trunc`).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`镜像ID`: 每个镜像都有一个唯一的`ID`。镜像`ID`由一个64位十六进制长的随机数表示。默认情况下，Docker images子命令只会显示12位十六进制数。您可以使用`--no-trunc`标志显示所有64位十六进制数（例如：`sudo
    docker images --no-trunc`）。'
- en: '`CREATED`: Indicates the time when the image was created.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建时间`: 表示镜像创建的时间。'
- en: '`VIRTUAL SIZE`: Highlights the virtual size of the image.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`虚拟大小`: 突出显示镜像的虚拟大小。'
- en: You might be wondering how, in the preceding example, a single `pull` command
    with the `-a` option was able to download five images, even though we had only
    specified one image by the name of `busybox`. This happened because each Docker
    image repository can have multiple variants of the same image and the `-a` option
    downloads all the variants that are associated with that image. In the preceding
    example, the variants are tagged as `buildroot-2013.08.1`, `ubuntu-14.04`, `ubuntu-12.04`,
    `buildroot-2014.02` and `latest`. A closer observation of the image IDs will reveal
    that both `buildroot-2014.02` and `latest` share the image ID `4986bf8c1536`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会想知道，在前面的例子中，一个带有`-a`选项的`pull`命令是如何能够下载五个镜像的，尽管我们只指定了一个名为`busybox`的镜像。这是因为每个Docker镜像存储库都可以有同一镜像的多个变体，`-a`选项会下载与该镜像相关的所有变体。在前面的例子中，这些变体被标记为`buildroot-2013.08.1`、`ubuntu-14.04`、`ubuntu-12.04`、`buildroot-2014.02`和`latest`。对镜像ID的仔细观察将揭示`buildroot-2014.02`和`latest`共享镜像ID`4986bf8c1536`。
- en: 'By default, Docker always uses the image that is tagged as `latest`. Each image
    variant can be directly identified by qualifying it with its tag. An image can
    be tag-qualified by appending the tag to the repository name with a `:` that is
    added between the tag and the repository name (`<repository>:<tag>`). For instance,
    you can launch a container with the `busybox:ubuntu-14.04` tag, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker始终使用标记为`latest`的镜像。每个镜像变体都可以通过其标签直接识别。可以通过在标签和存储库名称之间添加`:`来将镜像标记为合格。例如，您可以使用`busybox:ubuntu-14.04`标签启动一个容器，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `docker pull` subcommand will always download the image variant that has
    the `latest` tag in that repository. However, if you choose to download an image
    variant other than the latest, then you can do so by qualifying your image with
    the tag name by using the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker pull`子命令将始终下载具有该存储库中`latest`标签的镜像变体。但是，如果您选择下载除最新版本之外的其他镜像变体，则可以通过使用以下命令来限定镜像的标签名称来执行此操作：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Docker Hub Registry
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Hub注册表
- en: In the previous section, when you ran the `docker pull` subcommand, the `busybox`
    image got downloaded mysteriously. In this section, let's unravel the mystery
    around the `docker pull` subcommand and how the Docker Hub immensely contributed
    toward this unintended success.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当您运行`docker pull`子命令时，`busybox`镜像神秘地被下载了。在本节中，让我们揭开`docker pull`子命令周围的神秘，并且Docker
    Hub对这一意外成功做出了巨大贡献。
- en: The good folks in the Docker community have built a repository of images and
    they have made it publicly available at a default location, `index.docker.io`.
    This default location is called the Docker index. The `docker pull` subcommand
    is programmed to look for the images at this location. Therefore, when you `pull`
    a `busybox` image, it is effortlessly downloaded from the default registry. This
    mechanism helps in speeding up the spinning of the Docker containers. The Docker
    Index is the official repository that contains all the painstakingly curated images
    that are created and deposited by the worldwide Docker development community.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Docker社区的热心人士已经构建了一个镜像存储库，并且已经将其公开放置在默认位置`index.docker.io`。这个默认位置称为Docker索引。`docker
    pull`子命令被编程为在此位置查找镜像。因此，当您`pull`一个`busybox`镜像时，它会轻松地从默认注册表中下载。这种机制有助于加快Docker容器的启动速度。Docker
    Index是官方存储库，其中包含由全球Docker开发社区创建和存放的所有经过精心策划的镜像。
- en: This so-called cure is enacted to ensure that all the images stored in the Docker
    index are secure and safe through a host of quarantine tasks. There are proven
    verification and validation methods for cleaning up any knowingly or unknowingly
    introduced malware, adware, viruses, and so on, from these Docker images. The
    digital signature is a prominent mechanism of the utmost integrity of the Docker
    images. Nonetheless, if the official image has been either corrupted, or tampered
    with, then the Docker engine will issue a warning and then continue to run the
    image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这所谓的治疗措施是为了确保存储在Docker索引中的所有镜像都通过一系列隔离任务是安全的。有经过验证和验证的方法来清理任何故意或无意引入的恶意软件、广告软件、病毒等等，从这些Docker镜像中。数字签名是Docker镜像的最高完整性的突出机制。然而，如果官方镜像已经被损坏或篡改，那么Docker引擎将发出警告，然后继续运行镜像。
- en: 'In addition to the official repository, the Docker Hub Registry also provides
    a platform for the third-party developers and providers for sharing their images
    for general consumption. The third-party images are prefixed by the user ID of
    their developers or depositors. For example, `thedockerbook/helloworld` is a third-party
    image, wherein `thedockerbook` is the user ID and `helloworld` is the image repository
    name. You can download any third-party image by using the `docker pull` subcommand,
    as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了官方存储库之外，Docker Hub注册表还为第三方开发人员和提供商提供了一个平台，供他们共享供一般用户使用的镜像。第三方镜像以其开发人员或存款人的用户ID为前缀。例如，`thedockerbook/helloworld`是一个第三方镜像，其中`thedockerbook`是用户ID，`helloworld`是镜像存储库名称。您可以使用`docker
    pull`子命令下载任何第三方镜像，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Apart from the preceding repository, the Docker ecosystem also provides a mechanism
    for leveraging the images from any third-party repository hub other than the Docker
    Hub Registry, and it provides the images hosted by the local repository hubs.
    As mentioned earlier, the Docker engine has been programmed to look for images
    in `index.docker.io` by default, whereas in the case of the third-party or the
    local repository hub, we must manually specify the path from where the image should
    be pulled. A manual repository path is similar to a URL without a protocol specifier,
    such as `https://`, `http://` and `ftp://`. Following is an example of pulling
    an image from a third party repository hub:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的存储库之外，Docker生态系统还提供了一种利用来自Docker Hub注册表以外的任何第三方存储库中的镜像的机制，并且它还提供了本地存储库中托管的镜像。如前所述，Docker引擎默认情况下已编程为在`index.docker.io`中查找镜像，而在第三方或本地存储库中，我们必须手动指定应从哪里拉取镜像的路径。手动存储库路径类似于没有协议说明符的URL，例如`https://`、`http://`和`ftp://`。以下是从第三方存储库中拉取镜像的示例：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Searching Docker images
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索Docker镜像
- en: As we discussed in the previous section, the Docker Hub repository typically
    hosts both the official images as well as the images that have been contributed
    by the third-party Docker enthusiasts. At the time of writing this book, more
    than 14,000 images (also called the Dockerized application) were available for
    the users. These images can be used either as is, or as a building block for the
    user-specific applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，Docker Hub存储库通常托管官方镜像以及由第三方Docker爱好者贡献的镜像。在撰写本书时，超过14,000个镜像（也称为Docker化应用程序）可供用户使用。这些镜像可以直接使用，也可以作为用户特定应用程序的构建块使用。
- en: 'You can search for the Docker images in the Docker Hub Registry by using the
    `docker search` subcommand, as shown in this example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker search`子命令在Docker Hub注册表中搜索Docker镜像，如本示例所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The search on `mysql` will list 400 odd images, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mysql`上的搜索将列出400多个镜像，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding search output excerpts, the images are ordered
    based on their star rating. The search result also indicates whether or not the
    image is official. In order to stay in focus, in this example, we will show only
    two images. Here, you can see the official version of `mysql`, which pulls a `147`
    star rating image as its first result. The second result shows that this version
    of the `mysql` image was published by the user `tutum`. The Docker containers
    are fast becoming the standard for the building blocks of the distributed applications.
    A dynamic repository of the Docker images will be realized with the help of the
    enthusiastic contribution of several community members across the globe. The Repository-based
    software engineering will make it easier for users and programmers to quickly
    code and assemble their projects. The official repositories can be freely downloaded
    from the Docker Hub Registry, and these are curated images. They represent a community
    effort that is focused on providing a great base of images for applications, so
    that the developers and the system administrators can focus on building new features
    and functionalities, while minimizing their repetitive work on commodity scaffolding
    and plumbing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的搜索输出摘录所示，图像是根据其星级排序的。搜索结果还表明图像是否官方。为了保持专注，在这个例子中，我们将只显示两个图像。在这里，您可以看到`mysql`的官方版本，它拉取了一个`147`星级的图像作为其第一个结果。第二个结果显示，这个版本的`mysql`图像是由用户`tutum`发布的。Docker容器正迅速成为分布式应用程序的标准构建块。借助全球许多社区成员的热情贡献，将实现Docker图像的动态存储库。基于存储库的软件工程将使用户和程序员更容易快速编写和组装他们的项目。官方存储库可以免费从Docker
    Hub Registry下载，这些是经过策划的图像。它们代表了一个专注于为应用程序提供良好图像基础的社区努力，以便开发人员和系统管理员可以专注于构建新功能和功能，同时最大程度地减少他们在商品脚手架和管道上的重复工作。
- en: Based on the search queries in the Docker Hub Registry and the discussions with
    many of the developer community members, the Docker company, which spearheaded
    the Docker movement so powerfully and passionately, came to the conclusion that
    the developer community wanted pre-built stacks of their favorite programming
    languages. Specifically, the developers wanted to get to work as quickly as possible
    writing code without wasting time wrestling with environments, scaffolding, and
    dependencies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker Hub Registry中的搜索查询和与许多开发人员社区成员的讨论，Docker公司强有力而充满激情地领导了Docker运动，得出结论，开发人员社区希望获得他们最喜爱的编程语言的预构建堆栈。具体来说，开发人员希望尽快开始编写代码，而不浪费时间与环境、脚手架和依赖进行斗争。
- en: Working with an interactive container
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与交互式容器一起工作
- en: In the first chapter, we ran our first `Hello World!` container to get a feel
    of how the containerization technology works. In this section, we are going to
    run a container in an interactive mode. The `docker run` subcommand takes an image
    as an input and launches it as a container. You have to pass the `-t` and `-i`
    flags to the docker run subcommand in order to make the container interactive.
    The `-i` flag is the key driver, which makes the container interactive by grabbing
    the standard input (`STDIN`) of the container. The `-t` flag allocates a pseudo-TTY
    or a pseudo terminal (terminal emulator) and then assigns that to the container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们运行了我们的第一个`Hello World!`容器，以了解容器化技术的工作原理。在本节中，我们将以交互模式运行一个容器。`docker
    run`子命令以镜像作为输入，并将其作为容器启动。您必须在docker run子命令中传递`-t`和`-i`标志，以使容器变为交互式。`-i`标志是关键驱动程序，它通过获取容器的标准输入（`STDIN`）使容器变得交互式。`-t`标志分配一个伪TTY或伪终端（终端仿真器），然后将其分配给容器。
- en: 'In the following example, we are going to launch an interactive container by
    using the `ubuntu:14.04` image and `/bin/bash` as the command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用`ubuntu:14.04`镜像和`/bin/bash`作为命令启动一个交互式容器：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the `ubuntu` image has not been downloaded yet, if we use the `docker
    pull` subcommand, then we will get the following message and the `run` command
    will start pulling the `ubuntu` image automatically with the following message:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ubuntu`镜像尚未下载，如果我们使用`docker pull`子命令，那么我们将收到以下消息，并且`run`命令将自动开始拉取`ubuntu`镜像，并显示以下消息：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As soon as the download is completed, the container will be launched along
    with the `ubuntu:14.04` image. It will also launch a bash shell within the container,
    because we have specified `/bin/bash` as the command to be executed. This will
    land us in a bash prompt, as shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载完成，容器将与`ubuntu:14.04`镜像一起启动。它还将在容器内启动一个bash shell，因为我们已指定`/bin/bash`作为要执行的命令。这将使我们进入一个bash提示符，如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding bash prompt will confirm that our container has been launched
    successfully, and it is ready to take our input. If you are wondering about the
    Hex number `742718c21816` in the prompt, then it is nothing but the hostname of
    the container. In the Docker parlance, the hostname is the same as the container
    `ID`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的bash提示将确认我们的容器已成功启动，并且准备好接受我们的输入。如果您对提示中的十六进制数字`742718c21816`感到困惑，那么它只是容器的主机名。在Docker术语中，主机名与容器`ID`相同。
- en: 'Let''s quickly run a few commands interactively, and then confirm that what
    we mentioned about the prompt is correct, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速交互式地运行一些命令，然后确认我们之前提到的提示是正确的，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding three commands, it is quite evident that the prompt was composed
    by using the user ID, the hostname, and the current working directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的三个命令可以清楚地看出，提示是通过使用用户ID、主机名和当前工作目录组成的。
- en: 'Now, let''s use one of the niche features of Docker for detaching it from the
    interactive container and then look at the details that Docker manages for this
    container. Yes, we can detach it from our container by using the *Ctrl* + *P*
    and *Ctrl* + *Q* escape sequence. This escape sequence will detach the TTY from
    the container and land us in the Docker host prompt `$`, however the container
    will continue to run. The `docker ps` subcommand will list all the running containers
    and their important properties, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Docker的一个特色功能，将其从交互式容器中分离出来，然后查看Docker为该容器管理的细节。是的，我们可以通过使用*Ctrl* +
    *P*和*Ctrl* + *Q*转义序列将其从容器中分离出来。这个转义序列将从容器中分离TTY，并将我们置于Docker主机提示符`$`中，但是容器将继续运行。`docker
    ps`子命令将列出所有正在运行的容器及其重要属性，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `docker ps` subcommand will list out the following details:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`子命令将列出以下详细信息：'
- en: '`CONTAINER ID`: This shows the container `ID` associated with the container.
    The container `ID` is a 64 Hex digit long random number. By default, the `docker
    ps` subcommand will show only 12 Hex digits. You can display all the 64 digits
    by using the `--no-trunc` flag (for example: `sudo docker ps --no-trunc`).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`容器ID`：这显示了与容器关联的容器`ID`。容器`ID`是一个64位十六进制长随机数。默认情况下，`docker ps`子命令将只显示12位十六进制数。您可以使用`--no-trunc`标志显示所有64位数字（例如：`sudo
    docker ps --no-trunc`）。'
- en: '`IMAGE`: This shows the image from which the Docker container has been crafted.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`镜像`：这显示了Docker容器所制作的镜像。'
- en: '`COMMAND`: This shows you the command executed during the container launch.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命令`：这显示了容器启动期间执行的命令。'
- en: '`CREATED`: This tells you when the container was created.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建时间`：这告诉您容器何时创建。'
- en: '`STATUS`: This tells you the current status of the container.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`：这告诉您容器的当前状态。'
- en: '`PORTS`: This tells you if any port has been assigned to the container.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PORTS`：这告诉你是否已经为容器分配了任何端口。'
- en: '`NAMES`: The Docker engine auto-generates a random container name by concatenating
    an adjective and a noun. Either the container `ID` or its name can be used to
    take further action on the container. The container name can be manually configured
    by using the `--name` option in the `docker run` subcommand.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAMES`：Docker引擎通过连接形容词和名词自动生成一个随机容器名称。容器的`ID`或名称都可以用来对容器进行进一步操作。容器名称可以通过在`docker
    run`子命令中使用`--name`选项手动配置。'
- en: 'Having looked at the container status, let''s attach it back to our container
    by using the `docker attach` subcommand as shown in the following example. We
    can either use the container `ID` or use its name. In this example, we have used
    the container name. If you don''t see the prompt, then press the *Enter* key again:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查看了容器状态后，让我们使用`docker attach`子命令将其重新附加到我们的容器中，如下例所示。我们可以使用容器的`ID`或名称。在这个例子中，我们使用了容器的名称。如果你看不到提示符，那么再次按下*Enter*键：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Docker allows attaching with a container any number of times, which proves
    to be very handy for screen sharing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许任意次数地附加到容器，这对屏幕共享非常方便。
- en: 'The `docker attach` subcommand takes us back to the container prompt. Let''s
    experiment a little more with the interactive container that is up and running
    by using these commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker attach`子命令将我们带回容器提示符。让我们使用这些命令对正在运行的交互式容器进行更多实验：'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As soon as the bash exit command is issued to the interactive container, it
    will terminate the bash shell process, which in turn will stop the container.
    As a result, we will land on the Docker Host's prompt `$`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对交互式容器发出bash退出命令，它将终止bash shell进程，进而停止容器。因此，我们将会回到Docker主机的提示符`$`。
- en: Tracking changes inside containers
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器内跟踪更改
- en: In the previous section, we demonstrated how to craft a container taking `ubuntu`
    as a base image, and then running some basic commands, such as detaching and attaching
    the containers. In that process, we also exposed you to the `docker ps` subcommand,
    which provides the basic container management functionality. In this section,
    we will demonstrate how we can effectively track the changes that we introduced
    in our container and compare it with the image from which we launched the container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们演示了如何以`ubuntu`为基础镜像创建容器，然后运行一些基本命令，比如分离和附加容器。在这个过程中，我们还向您介绍了`docker
    ps`子命令，它提供了基本的容器管理功能。在本节中，我们将演示如何有效地跟踪我们在容器中引入的更改，并将其与我们启动容器的镜像进行比较。
- en: 'Let''s launch a container in the interactive mode, as we had done in the previous
    section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以交互模式启动一个容器，就像在上一节中所做的那样：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s change the directory to `/home`, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把目录切换到`/home`，如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can create three empty files by using the `touch` command as shown in
    the following code snippet. The first `ls -l` command will show that there are
    no files in the directory and the second `ls -l` command will show that there
    are three empty files:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`touch`命令创建三个空文件，如下面的代码片段所示。第一个`ls -l`命令将显示目录中没有文件，第二个`ls -l`命令将显示有三个空文件：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Docker engine elegantly manages its filesystem and it allows us to inspect
    a container filesystem by using the `docker diff` subcommand. In order to inspect
    the container filesystem, we can either detach it from the container or use another
    terminal of our Docker host and then issue the `docker diff` subcommand. Since
    we know that any `ubuntu` container has its hostname, which is a part of its prompt,
    and it is also the container''s `ID`, we can directly run the `docker diff` subcommand
    by using the container `ID` that is taken from the prompt, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎优雅地管理其文件系统，并允许我们使用`docker diff`子命令检查容器文件系统。为了检查容器文件系统，我们可以将其与容器分离，或者使用Docker主机的另一个终端，然后发出`docker
    diff`子命令。由于我们知道任何`ubuntu`容器都有其主机名，这是其提示的一部分，也是容器的`ID`，我们可以直接使用从提示中获取的容器`ID`运行`docker
    diff`子命令，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the given example, the `docker diff` subcommand will generate four lines,
    shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的示例中，`docker diff`子命令将生成四行，如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding output indicates that the `/home` directory has been modified,
    which has been denoted by `C,` and the `/home/abc`, `/home/cde` and the `/home/fgh`
    files have been added, and these are denoted by `A`. In addition, `D` denotes
    deletion. Since we have not deleted any files, it is not in our sample output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明`/home`目录已被修改，这由`C,`表示，`/home/abc`，`/home/cde`和`/home/fgh`文件已被添加，这些由`A`表示。此外，`D`表示删除。由于我们没有删除任何文件，因此它不在我们的示例输出中。
- en: Controlling Docker containers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制Docker容器
- en: So far, we have discussed a few practical examples for clearly articulating
    the nitty-gritty of the Docker containers. In this section, let us introduce a
    few basic as well as a few advanced command structures for meticulously illustrating
    how the Docker containers can be managed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了一些实际示例，以清楚地阐明Docker容器的细枝末节。在本节中，让我们介绍一些基本的以及一些高级的命令结构，以精确地说明如何管理Docker容器。
- en: The Docker engine enables you to `start`, `stop`, and `restart` a container
    with a set of `docker` subcommands. Let's begin with the `docker stop` subcommand,
    which stops a running container. When a user issues this command, the Docker engine
    sends SIGTERM (-15) to the main process, which is running inside the container.
    The **SIGTERM** signal requests the process to terminate itself gracefully. Most
    of the processes would handle this signal and facilitate a graceful exit. However,
    if this process fails to do so, then the Docker engine will wait for a grace period.
    Even after the grace period, if the process has not been terminated, then the
    Docker engine will forcefully terminate the process. The forceful termination
    is achieved by sending SIGKILL (-9). The **SIGKILL** signal cannot be caught or
    ignored, and so it will result in an abrupt termination of the process without
    a proper clean-up.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎使您能够使用一组`docker`子命令`start`，`stop`和`restart`容器。让我们从`docker stop`子命令开始，该子命令停止正在运行的容器。当用户发出此命令时，Docker引擎向容器内运行的主进程发送SIGTERM（-15）。**SIGTERM**信号请求进程优雅地终止自身。大多数进程会处理此信号并促进优雅退出。但是，如果此进程未能这样做，那么Docker引擎将等待一段宽限期。即使在宽限期之后，如果进程未被终止，那么Docker引擎将强制终止该进程。通过发送SIGKILL（-9）来实现强制终止。**SIGKILL**信号无法被捕获或忽略，因此它将导致进程在没有适当清理的情况下突然终止。
- en: 'Now, let''s launch our container and experiment with the `docker stop` subcommand,
    as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动我们的容器，并尝试使用`docker stop`子命令，如下所示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Having launched the container, let''s run the `docker stop` subcommand on this
    container by using the container `ID` that was taken from the prompt. Of course,
    we have to use a second screen or terminal to run this command, and the command
    will always echo back to the container `ID`, as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器后，让我们使用从提示中获取的容器`ID`在该容器上运行`docker stop`子命令。当然，我们必须使用第二个屏幕或终端来运行此命令，命令将始终回显到容器`ID`，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if we switch to the screen or terminal, where we were running the container,
    we will notice that the container is being terminated. If you observe a little
    more closely, you will also notice the text `exit` next to the container prompt.
    This has happened due to the SIGTERM handling mechanism of the bash shell, as
    shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们切换到正在运行容器的屏幕或终端，我们将注意到容器正在被终止。如果你更仔细观察，你还会注意到容器提示旁边的文本`exit`。这是由于bash
    shell的SIGTERM处理机制导致的，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we take it one step further and run the `docker ps` subcommand, then we
    will not find this container anywhere in the list. The fact is that the `docker
    ps` subcommand, by default, always lists the container that is in the running
    state. Since our container is in the stopped state, it has been comfortably left
    out of the list. Now, you might ask, how do we see the container that is in the
    stopped state? Well, the `docker ps` subcommand takes an additional argument `-a`,
    which will list all the containers in that Docker host irrespective of its status.
    This can be done by running the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再进一步运行`docker ps`子命令，那么我们将在列表中找不到这个容器。事实上，默认情况下，`docker ps`子命令总是列出处于运行状态的容器。由于我们的容器处于停止状态，它已经舒适地被从列表中排除了。现在，你可能会问，我们如何看到处于停止状态的容器呢？好吧，`docker
    ps`子命令带有一个额外的参数`-a`，它将列出Docker主机中的所有容器，而不管它的状态如何。可以通过运行以下命令来实现：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let's look at the `docker start` subcommand, which is used for starting
    one or more stopped containers. A container could be moved to the stopped state
    either by the `docker stop` subcommand or by terminating the main process in the
    container either normally or abnormally. On a running container, this subcommand
    has no effect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`docker start`子命令，它用于启动一个或多个已停止的容器。容器可以通过`docker stop`子命令或正常或异常地终止容器中的主进程而被移动到停止状态。对于正在运行的容器，此子命令没有任何效果。
- en: 'Let''s `start` the previously stopped container by using the `docker start`
    subcommand, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`docker start`子命令`start`先前停止的容器，如下所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By default, the `docker start` subcommand will not attach to the container.
    You can attach it to the container either by using the `-a` option in the `docker
    start` subcommand or by explicitly using the `docker attach` subcommand, as shown
    here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker start`子命令不会附加到容器。您可以通过在`docker start`子命令中使用`-a`选项或显式使用`docker
    attach`子命令将其附加到容器，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s run the `docker ps` and verify the container''s running status,
    as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行`docker ps`并验证容器的运行状态，如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `restart` command is a combination of the `stop` and the `start` functionality.
    In other words, the `restart` command will `stop` a running container by following
    the precise steps followed by the `docker stop` subcommand and then it will initiate
    the `start` process. This functionality will be executed by default through the
    `docker restart` subcommand.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart`命令是`stop`和`start`功能的组合。换句话说，`restart`命令将通过`docker stop`子命令遵循的精确步骤`stop`一个正在运行的容器，然后它将启动`start`过程。此功能将默认通过`docker
    restart`子命令执行。'
- en: The next important set of container-controlling subcommands are `docker pause`
    and `docker unpause`. The `docker pause` subcommands will essentially freeze the
    execution of all the processes within that container. Conversely, the `docker
    unpause` subcommand will unfreeze the execution of all the processes within that
    container and resume the execution from the point where it was frozen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的容器控制子命令集是`docker pause`和`docker unpause`。`docker pause`子命令将基本上冻结容器中所有进程的执行。相反，`docker
    unpause`子命令将解冻容器中所有进程的执行，并从冻结的点恢复执行。
- en: 'Having seen the technical explanation of `pause and unpause`, let''s see a
    detailed example for illustrating how this feature works. We have used two screen
    or terminal scenarios. On one terminal, we have launched our container and used
    an infinite while loop for displaying the date and time, sleeping for 5 seconds,
    and then continuing the loop. We will run the following commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在看完`pause`和`unpause`的技术解释后，让我们看一个详细的示例来说明这个功能是如何工作的。我们使用了两个屏幕或终端场景。在一个终端上，我们启动了容器，并使用了一个无限循环来显示日期和时间，每隔5秒睡眠一次，然后继续循环。我们将运行以下命令：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our little script has very faithfully printed the date and time every 5 seconds
    with an exception at the following position:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小脚本非常忠实地每5秒打印一次日期和时间，但在以下位置有一个例外：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we encountered a delay of 25 seconds, because this is when we initiated
    the `docker pause` subcommand on our container on the second terminal screen,
    as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了25秒的延迟，因为这是我们在第二个终端屏幕上启动了`docker pause`子命令的时候，如下所示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we paused our container, we looked at the process status by using the
    `docker ps` subcommand on our container, which was on the same screen, and it
    clearly indicated that the container had been paused, as shown in this command
    result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们暂停容器时，我们使用`docker ps`子命令查看了容器上的进程状态，它在同一屏幕上，并清楚地指示容器已被暂停，如此命令结果所示：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We continued on to issuing the `docker unpause` subcommand, which unfroze our
    container, continued its execution, and then started printing the date and time,
    as we saw in the preceding command, shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用`docker unpause`子命令，解冻了我们的容器，继续执行，并开始打印日期和时间，就像我们在前面的命令中看到的那样，如下所示：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We explained the `pause` and the `unpause` commands at the beginning of this
    section. Lastly, the container and the script running within it had been stopped
    by using the `docker stop` subcommand, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节开始时解释了`pause`和`unpause`命令。最后，使用`docker stop`子命令停止了容器和其中运行的脚本，如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Housekeeping containers
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器清理
- en: In many of the previous examples, when we issued `docker ps -a` we saw the many
    stopped containers. These containers could continue to stay in the stopped status
    for ages, if we chose not to intervene. At the outset, it may look like a glitch,
    but in reality, we can perform operations, such as committing an image from a
    container, restarting the stopped container, and so on. However, not all the stopped
    containers will be reused, and each of these unused containers will take up the
    disk space in the filesystem of the Docker host. The Docker engine provides a
    couple of ways to alleviate this issue. Let's start exploring them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多先前的示例中，当我们发出`docker ps -a`时，我们看到了许多已停止的容器。如果我们选择不进行干预，这些容器可能会继续停留在停止状态很长时间。起初，这可能看起来像是一个故障，但实际上，我们可以执行操作，比如从容器中提交一个镜像，重新启动已停止的容器等。然而，并非所有已停止的容器都会被重用，每个未使用的容器都会占用Docker主机文件系统中的磁盘空间。Docker引擎提供了几种方法来缓解这个问题。让我们开始探索它们。
- en: 'During a container startup, we can instruct the Docker engine to clean up the
    container as soon as it reaches the stopped state. For this purpose, the `docker
    run` subcommand supports an `--rm` option (for example: `sudo docker run -i -t
    --rm ubuntu:14.04 /bin/bash`).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器启动期间，我们可以指示Docker引擎在容器达到停止状态时立即清理容器。为此，`docker run`子命令支持`--rm`选项（例如：`sudo
    docker run -i -t --rm ubuntu:14.04 /bin/bash`）。
- en: 'The other alternative is to list all the containers by using the `-a` option
    of the `docker ps` subcommand and then manually remove them by using the `docker
    rm` subcommand, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`docker ps`子命令的`-a`选项列出所有容器，然后通过使用`docker rm`子命令手动删除它们，如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Two `docker` subcommands, that is, `docker rm` and `docker ps`, could be combined
    to automatically delete all the containers that are not currently running, as
    shown in the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`docker`子命令，即`docker rm`和`docker ps`，可以组合在一起自动删除所有当前未运行的容器，如下命令所示：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding command, the command inside the back quotes will produce a
    list of the full container IDs of every container, running or otherwise, which
    will become the argument for the `docker rm` subcommand. Unless forced with the
    `-f` option to do otherwise, the `docker rm` subcommand will only remove the container
    that is not in the running state. It will generate the following error for the
    running container and then continue to the next container on the list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，反引号内的命令将产生每个容器的完整容器ID列表，无论是运行还是其他状态，这将成为`docker rm`子命令的参数。除非使用`-f`选项强制执行其他操作，否则`docker
    rm`子命令将仅删除未运行状态的容器。对于正在运行的容器，它将生成以下错误，然后继续到列表中的下一个容器：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Building images from containers
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从容器构建镜像
- en: So far, we have crafted a handful of containers by using the standard base images
    `busybox` and `ubuntu`. In this section, let us see how we can add more software
    to our base image on a running container and then convert that container into
    an image for future use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用标准基本镜像`busybox`和`ubuntu`创建了一些容器。在本节中，让我们看看如何在运行的容器中向基本镜像添加更多软件，然后将该容器转换为镜像以供将来使用。
- en: 'Let''s take `ubuntu:14.04` as our base image, install the `wget` application,
    and then convert the running container to an image by performing the following
    steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`ubuntu:14.04`作为基本镜像，安装`wget`应用程序，然后通过以下步骤将运行的容器转换为镜像：
- en: 'Launch an `ubuntu:14.04` container by using the `docker run` subcommand, shown
    here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下`docker run`子命令启动`ubuntu:14.04`容器，如下所示：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Having launched the container, let''s quickly verify if `wget` is available
    for our image or not. We have used the `which` command with `wget` as an argument
    for this purpose and, in our case, it returns empty, which essentially means that
    it could not find any `wget` installation in this container. This command is run
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动容器后，让我们快速验证我们的镜像中是否有`wget`可用。我们已经使用`which`命令并将`wget`作为参数用于此目的，在我们的情况下，它返回空值，这基本上意味着它在这个容器中找不到任何`wget`安装。该命令如下运行：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s move on to the next step which involves the `wget` installation.
    Since it is a brand new `ubuntu` container, before installing `wget`, we must
    synchronize with the `ubuntu` package repository, as shown here:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续下一步，涉及`wget`安装。由于这是一个全新的`ubuntu`容器，在安装`wget`之前，我们必须与`ubuntu`软件包存储库同步，如下所示：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the `ubuntu` package repository synchronization is over, we can proceed
    toward installing `wget`, as shown here:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`ubuntu`软件包存储库同步完成，我们可以继续安装`wget`，如下所示：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Having completed the `wget` installation, let''s confirm our installation of
    `wget` by invoking the `which` command with `wget` as an argument, as shown here:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`wget`安装后，让我们通过调用`which`命令并将`wget`作为参数来确认我们的`wget`安装，如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Installation of any software would alter the base image composition, which
    we can also trace by using the `docker diff` subcommand introduced in *Tracking
    changes inside containers* section of this chapter. From a second terminal or
    screen, we can issue the `docker diff` subcommand, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装任何软件都会改变基础镜像的组成，我们也可以通过本章节*跟踪容器内部变化*介绍的`docker diff`子命令来追踪这些变化。我们可以在第二个终端或屏幕上使用`docker
    diff`子命令，如下所示：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding command would show a few hundred lines of modification to the
    `ubuntu` image. This modification includes the update on package repository, `wget`
    binary, and the support files for `wget`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将显示对`ubuntu`镜像的几百行修改。这些修改包括软件包存储库的更新，`wget`二进制文件以及`wget`的支持文件。
- en: 'Finally, let''s move to the most important step of committing the image. The
    Docker `commit` subcommand can be performed on a running or a stopped container.
    When commit is performed on a running container, the Docker engine will pause
    the container during the `commit` operation in order to avoid any data inconsistency.
    We strongly recommend performing the `commit` operation on a stopped container.
    We can commit a container to an image by the `docker commit` subcommand, as shown
    here:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们转向提交镜像的最重要步骤。Docker `commit`子命令可以在运行或停止的容器上执行。当在运行容器上执行`commit`时，Docker引擎将在`commit`操作期间暂停容器，以避免任何数据不一致。我们强烈建议在停止的容器上执行`commit`操作。我们可以通过`docker
    commit`子命令将容器提交为镜像，如下所示：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have committed our image by using the name `learningdocker/ubuntu_wget`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用名称`learningdocker/ubuntu_wget`提交了我们的镜像。
- en: 'Step by step, we saw how to create an image from a container. Now, let''s quickly
    list the images of our Docker host and see if this newly created image is a part
    of the image list by using the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐步看到了如何从容器创建镜像。现在，让我们快速列出我们的Docker主机上的镜像，并使用以下命令查看这个新创建的镜像是否是镜像列表的一部分：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From the preceding `docker images` subcommand output, it is quite evident that
    our image creation from the container has been quite successful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`docker images`子命令输出中，很明显我们从容器创建的镜像非常成功。
- en: Now that you have learned how to create an image from the containers by using
    a few easy steps, we would encourage you to predominantly use this method for
    testing purposes. The most elegant and the most recommended way of creating an
    image is to use the `Dockerfile` method, which will be introduced in the next
    chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何通过几个简单的步骤从容器创建镜像，我们鼓励您主要使用这种方法进行测试。创建镜像的最优雅和最推荐的方法是使用`Dockerfile`方法，这将在下一章介绍。
- en: Launching a container as a daemon
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为守护进程启动容器
- en: We have already experimented with an interactive container, tracked the changes
    that were made to the containers, created images from the containers and then
    gained insights in the containerization paradigm. Now, let's move on to understanding
    the real workhorse of the Docker technology. Yes that's right. In this section,
    we will walk you through the steps that are required for launching a container
    in the detached mode; in other words, we will learn about the steps that are required
    for launching a container as a daemon. We will also view the text that is generated
    in the container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试过交互式容器，跟踪了对容器的更改，从容器创建了镜像，然后深入了解了容器化范式。现在，让我们继续了解Docker技术的真正工作马。是的，没错。在本节中，我们将为您介绍启动容器的步骤，以分离模式启动容器的步骤。换句话说，我们将了解启动容器作为守护进程所需的步骤。我们还将查看在容器中生成的文本。
- en: 'The `docker run` subcommand supports an option `-d`, which will launch a container
    in a detached mode, that is, it will launch a container as a daemon. For the purpose
    of illustration, let''s resort to our date and time script, which we used in the
    `pause and unpause` container example, as shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`子命令支持一个选项`-d`，它将以分离模式启动一个容器，也就是说，它将以守护进程的方式启动一个容器。为了举例说明，让我们回到我们在“暂停和恢复”容器示例中使用的日期和时间脚本，如下所示：'
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `docker logs` subcommand is used for viewing the output generated by our
    daemon container, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`子命令用于查看守护进程容器生成的输出，如下所示：'
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described the knowledge that is gained in the post-implementation
    phases, primarily regarding the operational aspect of the Docker containers. We
    started the chapter by clarifying important terms, such as images, containers,
    registry, and repository, in order to enable you to acquire an unambiguous understanding
    of the concepts illustrated thereafter. We explained how to search for the images
    in the Docker repository. We also discussed the operation and handling of the
    Docker containers, how to track the changes inside the containers, how to control
    and housekeep the containers. In an easy-to-grasp manner, we will explain the
    process of the Docker image building in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了在后期实施阶段获得的知识，主要是关于Docker容器的操作方面。我们通过澄清重要术语（如镜像、容器、注册表和仓库）来开始本章，以便让您能够清晰地理解随后阐述的概念。我们解释了如何在Docker仓库中搜索镜像。我们还讨论了Docker容器的操作和处理，如何跟踪容器内部的更改，如何控制和维护容器。在下一章中，我们将以易于理解的方式解释Docker镜像构建的过程。
