- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: Automation for Functional Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试的自动化
- en: In previous chapters, we discussed the importance of unit tests and integration
    tests in software development and discussed how they ensure the reliability of
    your code base. We also discussed how unit and integration tests are integral
    parts of all software production stages and are run each time the code base is
    modified.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了单元测试和集成测试在软件开发中的重要性，并讨论了它们如何确保代码库的可靠性。我们还讨论了单元测试和集成测试如何成为所有软件生产阶段的组成部分，并且在每次代码库修改时运行。
- en: There are also other important tests, called functional tests. They are run
    only at the end of each sprint to verify that the output of the sprint actually
    satisfies the specifications that were agreed upon with the stakeholders.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他重要的测试，称为功能测试。它们仅在每个冲刺结束时运行，以验证冲刺的输出实际上是否满足与利益相关者达成的规格。
- en: 'This chapter is specifically dedicated to functional tests and to the techniques
    for defining, executing, and automating them. More specifically, this chapter
    covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门致力于功能测试以及定义、执行和自动化它们的技术。更具体地，本章涵盖以下主题：
- en: Understanding the purpose of functional tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解功能测试的目的
- en: Using unit testing tools to automate functional tests in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中使用单元测试工具自动化功能测试
- en: Use case – automating functional tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例-自动化功能测试
- en: By the end of this chapter, you will be able to design both manual and automatic
    tests to verify that the code produced by a sprint complies with its specifications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够设计手动和自动测试，以验证冲刺产生的代码是否符合其规格。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are encouraged to read *Chapter 18*, *Testing Your Code with Unit Test Cases
    and TDD*, before proceeding with this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，建议您阅读*第18章*，*使用单元测试用例和TDD测试您的代码*。
- en: This chapter requires Visual Studio 2019's free Community Edition or better,
    with all the database tools installed. Here, we will modify the code of *Chapter
    18*, *Testing Your Code with Unit Test Cases and TDD*, which is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2019的免费社区版或更高版本，并安装了所有数据库工具。在这里，我们将修改*第18章*中的代码，*使用单元测试用例和TDD测试您的代码*，该代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)上找到。
- en: Understanding the purpose of functional tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解功能测试的目的
- en: In *Chapter 18*, *Testing Your Code with Unit Test Cases and TDD*, we discussed
    the advantages of automatic tests, how to design them, and their challenges. Functional
    tests use the same techniques and tools as unit and integration tests but differ
    from them in that they are run only at the end of each sprint. They have the fundamental
    role of verifying that the current version of the whole software complies with
    its specifications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第18章*中，*使用单元测试用例和TDD测试您的代码*，我们讨论了自动测试的优势，如何设计它们以及它们的挑战。功能测试使用与单元测试和集成测试相同的技术和工具，但它们与它们不同之处在于它们仅在每个冲刺结束时运行。它们的基本作用是验证当前版本的整个软件是否符合其规格。
- en: Since functional tests also involve the **user interface** (**UI**), they need
    further tools to simulate, somehow, the way the user acts in the UI. We will discuss
    this point further throughout the chapter. The need for extra tools is not the
    only challenge the UI brings with it, because UIs also see frequent and major
    changes. Thus, we mustn't design tests that depend on the UI's graphical details
    or we might be forced to completely rewrite all the tests at each UI change. That's
    why it is sometimes better to renounce automatic tests and fall back to manual
    tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能测试还涉及**用户界面**（**UI**），它们需要进一步的工具来模拟用户在UI中的操作方式。我们将在整个章节中进一步讨论这一点。需要额外工具的需求并不是UI带来的唯一挑战，因为UI也经常发生重大变化。因此，我们不应设计依赖于UI图形细节的测试，否则我们可能会被迫在每次UI更改时完全重写所有测试。这就是为什么有时放弃自动测试并回归手动测试会更好。
- en: 'Whether automatic or manual, functional testing must be a formal process that
    is performed for the following purposes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是自动还是手动，功能测试都必须是一个正式的过程，用于以下目的：
- en: 'Functional tests represent the most important part of the contract between
    stakeholders and the development team, the other part being the verification of
    non-functional specifications. The way this contract is formalized depends on
    the nature of the relationship between the development team and stakeholders:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试代表了利益相关者和开发团队之间合同的最重要部分，另一部分是验证非功能规格。这份合同的形式化方式取决于开发团队和利益相关者之间关系的性质：
- en: In the case of a supplier-customer relationship, the functional tests become
    part of the supplier-customer business contract for each sprint, and a team that
    works for the customer writes them. If the tests fail, then the sprint is rejected
    and the supplier must run a supplementary sprint to fix all problems.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在供应商-客户关系的情况下，功能测试成为每个冲刺的供应商-客户业务合同的一部分，由为客户工作的团队编写。如果测试失败，那么冲刺将被拒绝，供应商必须进行补充冲刺以解决所有问题。
- en: If there is no supplier-customer business relationship because the development
    team and the stakeholder belong to the same company, there is no business contract.
    In this case, the stakeholder together with the team writes an internal document
    that formalizes the requirements of the sprint. If the tests fail, usually, the
    sprint is not rejected but the results of the tests are used to drive the specifications
    for the next sprints. Of course, if the failure percentage is high, the sprint
    may be rejected and should be repeated.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有供应商-客户业务关系，因为开发团队和利益相关者属于同一家公司，那么就没有业务合同。在这种情况下，利益相关者与团队一起编写一份内部文件，正式规定了冲刺的要求。如果测试失败，通常不会拒绝冲刺，而是使用测试结果来驱动下一个冲刺的规格。当然，如果失败率很高，冲刺可能会被拒绝并且需要重复。
- en: Formalized functional tests that run at the end of each sprint prevent any results
    achieved in previous sprints from being destroyed by new code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个冲刺结束时运行的正式功能测试可以防止之前冲刺取得的结果被新代码破坏。
- en: When using an agile development methodology, maintaining an updated battery
    of functional tests is the best way to get a formal representation of the final
    system specifications since, during agile development, the specifications of the
    final system are not decided before development starts but are the result of the
    system's evolution.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用敏捷开发方法时，保持更新的功能测试库是获得最终系统规范的正式表示的最佳方式，因为在敏捷开发过程中，最终系统的规范并不是在开发开始之前决定的，而是系统演变的结果。
- en: Since the output of the first sprints may differ a lot from the final system
    in these early stages, it is not worth spending too much time writing detailed
    manual tests and/or automatized tests. Therefore, you may limit the user stories
    to just a few examples that will be used both as inputs for software development
    and as manual tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最初阶段的前几个冲刺的输出可能与最终系统有很大不同，因此不值得花费太多时间编写详细的手动测试和/或自动化测试。因此，您可以将用户故事限制为仅有几个示例，这些示例将被用作软件开发的输入和手动测试。
- en: 'As system functionalities become more stable, it is worth investing time in
    writing detailed and formal functional tests for them. For each functional specification,
    we must write tests that verify their operation in extreme cases. For instance,
    in a cash withdrawal use case, we must write tests that verify all possibilities:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统功能变得更加稳定，值得投入时间编写详细和正式的功能测试。对于每个功能规范，我们必须编写验证其在极端情况下操作的测试。例如，在取款用例中，我们必须编写验证所有可能性的测试：
- en: Not enough funds
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金不足
- en: Card expired
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡已过期
- en: Wrong credentials
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭证错误
- en: Repeated wrong credentials
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的错误凭证
- en: 'The following picture sketches the whole process with all possible outcomes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片勾勒了整个过程及所有可能的结果：
- en: '![](img/B16756_22.1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_22.1.png)'
- en: 'Figure 22.1: Withdrawal example'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.1：取款示例
- en: In the case of manual tests, for each of the preceding scenarios, we must give
    all the details of all the steps involved in each operation and, for each step,
    the expected result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于手动测试，对于前述每个场景，我们必须给出每个操作涉及的所有步骤的详细信息，以及每个步骤的预期结果。
- en: An important decision is whether you want to automate all or a part of the functional
    tests, since it is very expensive to write automated tests that simulate a human
    operator that interacts with a system's UI. The final decision depends on the
    cost of the test implementation divided by the expected number of times it will
    be used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的决定是是否要自动化所有或部分功能测试，因为编写模拟人操作与系统UI交互的自动化测试非常昂贵。最终决定取决于测试实施的成本除以预期使用次数。
- en: In the case of CI/CD, the same functional test can be executed several times
    but, unluckily, functional tests are strictly tied to the way the UI is implemented,
    and, in modern systems, the UI is changed frequently. Therefore, in this case,
    a test is executed with exactly the same UI no more than a couple of times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD的情况下，同一个功能测试可以被执行多次，但不幸的是，功能测试严格地与UI的实现方式相关联，而在现代系统中，UI经常发生变化。因此，在这种情况下，测试与完全相同的UI执行不超过几次。
- en: In order to overcome all the problems related to the UI, some functional tests
    can be implemented as **subcutaneous tests**, that is, as tests that bypass the
    UI. For instance, some functional tests for an ASP.NET Core application can call
    controller action methods directly instead of sending an actual request through
    a browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服与UI相关的所有问题，一些功能测试可以被实施为**皮下测试**，也就是绕过UI的测试。例如，ASP.NET Core应用程序的一些功能测试可以直接调用控制器动作方法，而不是通过浏览器发送实际请求。
- en: Unfortunately, subcutaneous tests can't verify all possible implementation errors,
    since they can't detect errors in the UI itself. Moreover, in the case of a web
    application, subcutaneous tests usually suffer from other limitations because
    they bypass the whole HTTP protocol.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，皮下测试无法验证所有可能的实现错误，因为它们无法检测UI本身的错误。此外，在Web应用程序的情况下，皮下测试通常受到其他限制的影响，因为它们绕过了整个HTTP协议。
- en: In particular, in the case of ASP.NET Core applications, if we call controller
    action methods directly, we bypass the whole ASP.NET Core pipeline that processes
    each request before passing it to the right action method. Therefore, authentication,
    authorization, CORS, and the behavior of other middleware in the ASP.NET Core
    pipeline will not be analyzed by the tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在ASP.NET Core应用程序的情况下，如果我们直接调用控制器动作方法，就会绕过整个ASP.NET Core管道，该管道在将请求传递给正确的动作方法之前处理每个请求。因此，身份验证、授权、CORS和ASP.NET
    Core管道中其他中间件的行为将不会被测试分析。
- en: 'A complete automated functional test of a web application should do the following
    things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的完整自动化功能测试应该执行以下操作：
- en: Start an actual browser on the URL to be tested
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要测试的URL上启动实际浏览器
- en: Wait so that any JavaScript on the page completes its execution
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待页面上的任何JavaScript执行完成
- en: Then, send commands to the browser that simulate the behavior of a human operator
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向浏览器发送命令，模拟人操作的行为
- en: Finally, after each interaction with the browser, automatic tests should wait
    so that any JavaScript that was triggered by the interaction completes
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在与浏览器的每次交互之后，自动化测试应该等待任何由交互触发的JavaScript完成
- en: While browser automatization tools exist, tests implemented with browser automatization,
    as mentioned earlier, are very expensive and difficult to implement. Therefore,
    the suggested approach of ASP.NET Core MVC is to send actual HTTP requests to
    an actual copy of the web application, with a .NET HTTP client instead of using
    a browser. Once the HTTP client receives an HTTP response, it parses it in a DOM
    tree and verifies that it received the right response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在浏览器自动化工具，但是如前所述，使用浏览器自动化实现的测试非常昂贵且难以实现。因此，ASP.NET Core MVC建议的方法是使用.NET HTTP客户端向Web应用程序的实际副本发送实际的HTTP请求，而不是使用浏览器。一旦HTTP客户端接收到HTTP响应，它会将其解析为DOM树，并验证它是否收到了正确的响应。
- en: The only difference with the browser automatization tools is that the HTTP client
    is not able to run any JavaScript. However, other tests may be added to test the
    JavaScript code. These tests are based on test tools that are specific to JavaScript,
    such as **Jasmine** and **Karma**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器自动化工具的唯一区别是，HTTP客户端无法运行任何JavaScript。然而，其他测试可以添加以测试JavaScript代码。这些测试基于特定于JavaScript的测试工具，如**Jasmine**和**Karma**。
- en: The next section explains how to automatize functional tests for web applications
    with a .NET HTTP client, while a practical example of functional test automation
    is shown in the last section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何使用.NET HTTP客户端自动化Web应用程序的功能测试，而最后一节将展示功能测试自动化的实际示例。
- en: Using unit testing tools to automate functional tests in C#
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#中的单元测试工具来自动化功能测试
- en: Automated functional tests use the same test tools as unit and integration tests.
    That is, these tests can be embedded in the same xUnit, NUnit, or MSTests projects
    that we described in *Chapter 18*, *Testing Your Code with Unit Test Cases and
    TDD*. However, in this case, we must add further tools that are able to interact
    with and inspect the UI.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化功能测试使用与单元测试和集成测试相同的测试工具。也就是说，这些测试可以嵌入到与我们在*第18章*中描述的xUnit、NUnit或MSTests项目中。然而，在这种情况下，我们必须添加进一步的工具，这些工具能够与UI进行交互和检查。
- en: In the remainder of this chapter, we will focus on web applications since they
    are the main focus of this book. Accordingly, if we are testing web APIs, we just
    need `HttpClient` instances since they can easily interact with web API endpoints
    in both XML and JSON.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将专注于Web应用程序，因为它们是本书的主要焦点。因此，如果我们正在测试Web API，我们只需要`HttpClient`实例，因为它们可以轻松地与XML和JSON格式的Web
    API端点进行交互。
- en: In the case of ASP.NET Core MVC applications that return HTML pages, the interaction
    is more complex, since we also need tools for parsing and interacting with the
    HTML page DOM tree. The `AngleSharp` NuGet package is a great solution since it
    supports state-of-the-art HTML and minimal CSS and has extension points for externally
    provided JavaScript engines, such as Node.js. However, we don't advise you to
    include JavaScript and CSS in your tests, since they are strictly tied to target
    browsers, so the best option for them is to use JavaScript-specific test tools
    that you can run directly in the target browsers themselves.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回HTML页面的ASP.NET Core MVC应用程序，交互更加复杂，因为我们还需要用于解析和与HTML页面DOM树交互的工具。`AngleSharp`
    NuGet包是一个很好的解决方案，因为它支持最先进的HTML和最小的CSS，并且具有用于外部提供的JavaScript引擎（如Node.js）的扩展点。然而，我们不建议在测试中包含JavaScript和CSS，因为它们严格绑定到目标浏览器，所以最好的选择是使用JavaScript特定的测试工具，可以直接在目标浏览器中运行它们。
- en: 'There are two basic options for testing a web application with the `HttpClient`
    class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClient`类测试Web应用程序有两个基本选项：
- en: '**Staging application**. An `HttpClient` instance connects with the actual
    *staging* web application through the internet/intranet, together with all other
    humans who are beta-testing the software. The advantage of this approach is that
    you are testing the *real stuff*, but tests are more difficult to conceive since
    you can''t control the initial state of the application before each test.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分段应用程序**。一个`HttpClient`实例通过互联网/内联网连接到实际的*分段*Web应用程序，与所有其他正在进行软件测试的人一起。这种方法的优势在于你正在测试*真实内容*，但是测试更难构思，因为你无法控制每个测试之前应用程序的初始状态。'
- en: '**Controlled application**. An `HttpClient` instance connects with a local
    application that is configured, initialized, and launched before every single
    test. This scenario is completely analogous to the unit test scenario. Test results
    are reproducible, the initial state before each test is fixed, tests are easier
    to design, and the actual database can be replaced by a faster and easier-to-initialize
    in-memory database. However, in this case, you are far from the actual system''s
    operation.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受控应用程序**。一个`HttpClient`实例连接到一个本地应用程序，该应用程序在每次单独的测试之前都被配置、初始化和启动。这种情况与单元测试场景完全类似。测试结果是可重现的，每个测试之前的初始状态是固定的，测试更容易设计，并且实际数据库可以被更快、更容易初始化的内存数据库替换。然而，在这种情况下，你离实际系统的运行很远。'
- en: A good strategy is to use a **controlled application**, where you have full
    control of the initial state, for testing all extreme cases, and then use a **staging
    application** for testing random average cases on the *real stuff*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的策略是使用**受控应用程序**，在这里你完全控制初始状态，用于测试所有极端情况，然后使用**分段应用程序**来测试*真实内容*上的随机平均情况。
- en: The two sections that follow describe both approaches. The two approaches differ
    only in the way that you define the fixtures of your tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分描述了这两种方法。这两种方法的唯一区别在于你如何定义测试的固定装置。
- en: Testing the staging application
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试分段应用程序
- en: In this case, your tests need just an instance of `HttpClient`, so you must
    define an efficient fixture that supplies `HttpClient` instances, avoiding the
    risk of running out of Windows connections. We faced this problem in the *.NET
    Core HTTP clients* section of *Chapter 14*, *Applying Service-Oriented Architectures
    with .NET Core*. It can be solved by managing `HttpClient` instances with `IHttpClientFactory`
    and injecting them with dependency injection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您的测试只需要一个`HttpClient`的实例，因此您必须定义一个有效的夹具，提供`HttpClient`的实例，避免耗尽Windows连接的风险。我们在*第14章*的*.NET
    Core HTTP客户端*部分中遇到了这个问题，*应用Service-Oriented Architectures with .NET Core*。可以通过使用`IHttpClientFactory`管理`HttpClient`实例并通过依赖注入注入它们来解决这个问题。
- en: 'Once we have a dependency injection container, we can enrich it with the capability
    of efficiently handling `HttpClient` instances with the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个依赖注入容器，我们就可以使用以下代码片段来丰富它，以有效地处理`HttpClient`实例：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the `AddHTTPClient` extension belongs to the `Microsoft.Extensions.DependencyInjection`
    namespace and is defined in the `Microsoft.Extensions.Http` NuGet package. Therefore,
    our test fixture must create a dependency injection container, call `AddHttpClient`,
    and finally build the container. The following fixture class does this job (please
    refer to the *Advanced test preparation and tear-down scenarios* section of *Chapter
    18*, *Testing Your Code with Unit Test Cases and TDD*, if you don''t remember
    fixture classes):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AddHTTPClient`扩展属于`Microsoft.Extensions.DependencyInjection`命名空间，并且在`Microsoft.Extensions.Http`
    NuGet包中定义。因此，我们的测试夹具必须创建一个依赖注入容器，调用`AddHttpClient`，最后构建容器。以下的夹具类完成了这个工作（如果您不记得夹具类，请参考*第18章*的*使用单元测试用例和TDD测试准备和拆卸高级场景*部分）：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the preceding definition, your tests should look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述定义之后，您的测试应该如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In `Test1`, once you get an HTTP client, you can test the application by issuing
    an HTTP request and then by analyzing the response returned by the application.
    More details on how to process the response returned by the server will be given
    in the *Use case* section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Test1`中，一旦获得了一个HTTP客户端，您可以通过发出HTTP请求来测试应用程序，然后通过分析应用程序返回的响应来测试应用程序。有关如何处理服务器返回的响应的更多细节将在*用例*部分中给出。
- en: The next section explains how to test an application that runs in a controlled
    environment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分解释了如何测试在受控环境中运行的应用程序。
- en: Testing a controlled application
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试受控应用程序
- en: In this case, we create an ASP.NET Core server within the test application and
    test it with an `HTTPClient` instance. The `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package contains all that we need to create both an HTTP client and the
    server running the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在测试应用程序中创建一个ASP.NET Core服务器，并使用`HTTPClient`实例对其进行测试。`Microsoft.AspNetCore.Mvc.Testing`
    NuGet包包含了我们创建HTTP客户端和运行应用程序的服务器所需的一切。
- en: '`Microsoft.AspNetCore.Mvc.Testing` contains a fixture class that does the job
    of launching a local web server and furnishing a client for interacting with it.
    The predefined fixture class is `WebApplicationFactory<T>`. The generic `T` argument
    must be instantiated with the `Startup` class of your web project.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.Testing`包含一个夹具类，用于启动本地Web服务器并提供用于与其交互的客户端。预定义的夹具类是`WebApplicationFactory<T>`。泛型`T`参数必须实例化为您的Web项目的`Startup`类。'
- en: 'Tests look like the following class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试看起来像以下的类：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to analyze the HTML of the returned pages, you must also reference
    the `AngleSharp` NuGet package. We will see how to use it in the example of the
    next section. The simplest way to cope with databases in this type of test is
    to replace them with in-memory databases that are faster and automatically cleared
    whenever the local server is shut down and restarted.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想分析返回页面的HTML，还必须引用`AngleSharp` NuGet包。我们将在下一节的示例中看到如何使用它。在这种类型的测试中处理数据库的最简单方法是用内存数据库替换它们，这样可以更快地自动清除每当本地服务器关闭和重新启动时。
- en: 'This can be done by creating a new deployment environment, say, `AutomaticStaging`,
    and an associate configuration file that is specific to the tests. After having
    created this new deployment environment, go to the `ConfigureServices` method
    of your application''s `Startup` class and locate the place where you add your
    `DBContext` configuration. Once you''ve located that place, add an `if` there
    that, if the application is running in the `AutomaticStaging` environment, replaces
    your `DBContext` configuration with something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过创建一个新的部署环境，比如`AutomaticStaging`，以及一个特定于测试的关联配置文件来完成。创建了这个新的部署环境后，转到应用程序的`Startup`类的`ConfigureServices`方法，并找到您添加`DBContext`配置的地方。一旦找到了那个地方，在那里添加一个`if`，如果应用程序在`AutomaticStaging`环境中运行，则用类似于这样的东西替换您的`DBContext`配置：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As an alternative, you can also add all the required instructions to clear
    a standard database in the constructor of a custom fixture that inherits from
    `WebApplicationFactory<T>`. Note that deleting all database data is not as easy
    as it might appear, because of integrity constraints. You have various options,
    but none is the best for all cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您还可以将清除标准数据库的所有必需指令添加到从`WebApplicationFactory<T>`继承的自定义夹具的构造函数中。请注意，删除所有数据库数据并不像看起来那么容易，因为存在完整性约束。您有各种选择，但没有一种适用于所有情况：
- en: Delete the whole database and recreate it using migrations, that is, `DbContext.Database.Migrate()`.This
    always works, but it is slow and requires a database user with high privileges.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除整个数据库并使用迁移重新创建它，即`DbContext.Database.Migrate()`。这总是有效的，但速度慢，并且需要具有高权限的数据库用户。
- en: Disable database constraints and then clear all tables in any order. This technique
    sometimes doesn't work and requires a database user with high privileges.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用数据库约束，然后以任何顺序清除所有表。这种技术有时不起作用，并且需要具有高权限的数据库用户。
- en: Delete all data in the right order, thus without violating all database constraints.
    This is not difficult if you keep an ordered delete list of all tables while the
    database grows and you add tables to the database. This delete list is a useful
    resource that you may also use to fix issues in database update operations and
    to remove old entries during production database maintenance. Unfortunately, this
    method also fails in the rare case of circular dependencies, such as a table that
    has a foreign key referring to itself.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按正确顺序删除所有数据，因此不违反所有数据库约束。如果您保持一个有序的删除列表，其中包含数据库增长时添加到数据库的所有表，这并不难。这个删除列表是一个有用的资源，您也可以用它来修复数据库更新操作中的问题，并在生产数据库维护期间删除旧条目。不幸的是，这种方法在很少出现的循环依赖的情况下也会失败，例如一个具有指向自身的外键的表。
- en: I prefer method 3 and revert to method 2 only in the rare case of difficulties
    due to circular dependencies. As an example of method 3, we can write a fixture
    that inherits from `WebApplicationFactory<Startup>` and deletes all test records
    of the application of *Chapter 18*, *Testing Your Code with Unit Test Cases and
    TDD*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢方法3，并且只在由于循环依赖引起的困难的罕见情况下才返回到方法2。作为方法3的示例，我们可以编写一个从`WebApplicationFactory<Startup>`继承的fixture，删除*第18章*中应用程序的所有测试记录，*使用单元测试用例和TDD测试您的代码*。
- en: 'It is enough to delete the data of packages, destinations, and events if you
    don''t need to test the authentication/authorization subsystem. The deletion order
    is straightforward; events must be deleted first since nothing depends on them,
    and then we can delete packages that depend on destinations, and finally the destinations
    themselves. The code is quite easy:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要测试身份验证/授权子系统，则删除包、目的地和事件的数据就足够了。删除顺序很简单；首先必须删除事件，因为没有任何依赖于它们，然后我们可以删除依赖于目的地的包，最后删除目的地本身。代码非常简单：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get a `DBContext` instance from the services inherited from `WebApplicationFactory<Startup>`,
    so you can perform database operations. The only way to delete all data from a
    table simultaneously is through a direct database command. Therefore, since in
    this case we can't use the `SaveChanges` method to enclose all changes in a single
    transaction, we are forced to create a transaction manually.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从继承自`WebApplicationFactory<Startup>`的服务中获取`DBContext`实例，因此可以执行数据库操作。从表中同时删除所有数据的唯一方法是通过直接的数据库命令。因此，在这种情况下，我们无法使用`SaveChanges`方法将所有更改封装在单个事务中，我们被迫手动创建事务。
- en: You can test the class above by adding it to the use case of the next chapter,
    which is based on the code of *Chapter 18*, *Testing Your Code with Unit Test
    Cases and TDD*, too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其添加到下一章的用例中来测试上面的类，该用例基于*第18章*的代码，*使用单元测试用例和TDD测试您的代码*。
- en: Use case – automating functional tests
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 自动化功能测试
- en: In this section, we will add a simple functional test to the ASP.NET Core test
    project of *Chapter 18*, *Testing Your Code with Unit Test Cases and TDD*. Our
    test approach is based on the `Microsoft.AspNetCore.Mvc.Testing` and `AngleSharp`
    NuGet packages. Please make a new copy of the whole solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向*第18章*的ASP.NET Core测试项目中添加一个简单的功能测试。我们的测试方法基于`Microsoft.AspNetCore.Mvc.Testing`和`AngleSharp`
    NuGet包。请制作整个解决方案的新副本。
- en: The test project already references the ASP.NET Core project under `test` and
    all the required xUnit NuGet packages, so we need to add just the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目已经引用了`test`下的ASP.NET Core项目和所有必需的xUnit NuGet包，因此我们只需要添加`Microsoft.AspNetCore.Mvc.Testing`和`AngleSharp`
    NuGet包。
- en: 'Now, let''s add a new class file called `UIExampleTest.cs`. We need `using`
    statements to reference all the necessary namespaces. More specifically, we need
    the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`UIExampleTest.cs`的新类文件。我们需要`using`语句来引用所有必要的命名空间。更具体地说，我们需要以下内容：
- en: '`using PackagesManagement;`: This is needed to reference your application classes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PackagesManagement;：这是引用应用程序类所需的。
- en: '`using Microsoft.AspNetCore.Mvc.Testing;`: This is needed to reference the
    client and server classes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Microsoft.AspNetCore.Mvc.Testing;：这是引用客户端和服务器类所需的。
- en: '`using AngleSharp;` and `using AngleSharp.Html.Parser;`: These are needed to
    reference `AngleSharp` classes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngleSharp;和使用AngleSharp.Html.Parser;：这是引用`AngleSharp`类所需的。
- en: '`System.IO`: This is needed in order to extract HTML from HTTP responses.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System.IO：这是为了从HTTP响应中提取HTML所需的。
- en: '`using Xunit`: This is needed to reference all `xUnit` classes.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Xunit：这是引用所有`xUnit`类所需的。
- en: 'Summing up, the whole `using` block is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，整个`using`块如下：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will use the standard fixture class we introduced in the previous *Testing
    a controlled application* section to write the following test class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面*测试受控应用程序*部分介绍的标准fixture类来编写以下测试类：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we are ready to write a test for the home page! This test verifies that
    the home URL returns a successful HTTP result and that the home page contains
    a link to the package management page, which is the `/ManagePackages` relative
    link.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为主页编写一个测试！这个测试验证主页URL返回成功的HTTP结果，并且主页包含指向包管理页面的链接，即`/ManagePackages`相对链接。
- en: It is fundamental to understand that automatic tests must not depend on the
    details of the HTML, but that they must verify just logical facts, in order to
    avoid frequent changes after each small modification of the application HTML.
    That's why we just verify that the necessary links exist without putting constraints
    on where they are.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则是理解自动化测试不应依赖HTML的细节，而是必须验证逻辑事实，以避免在每次应用程序HTML进行小修改后频繁更改。这就是为什么我们只验证必要的链接是否存在，而不对它们的位置施加约束。
- en: 'Let''s call our home page test `TestMenu`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称我们的主页测试为`TestMenu`：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first step of each test is the creation of a client. Then, if the test
    needs the analysis of some HTML, we must prepare the so-called `AngleSharp` browsing
    context:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试的第一步是创建一个客户端。然后，如果测试需要分析一些HTML，我们必须准备所谓的`AngleSharp`浏览上下文：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The configuration object specifies options such as cookie handling and other
    browser-related properties. At this point, we are ready to require the home page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对象指定选项，如cookie处理和其他与浏览器相关的属性。此时，我们已经准备好需要主页：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a first step, we verify that the response we received contains a success
    status code, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们验证收到的响应是否包含成功的状态代码，如下所示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding method call throws an exception in the case of an unsuccessful
    status code, hence causing the test to fail. HTML analysis needs to be extracted
    from the response. The following code shows a simple way to do it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在不成功的状态代码的情况下，前面的方法调用会引发异常，从而导致测试失败。需要从响应中提取HTML分析。以下代码显示了一种简单的方法：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we must pass the extracted HTML to our previous `AngleSharp` browsing
    context object, so it can build a DOM tree. The following code shows how to do
    it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将提取的HTML传递给我们之前的`AngleSharp`浏览上下文对象，以便它可以构建DOM树。以下代码显示了如何做到这一点：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `OpenAsync` method executes a DOM-building activity with the settings contained
    in `context`. The input for building the DOM document is specified by the lambda
    function passed as an argument to `OpenAsync`. In our case, `req.Content(...)`
    builds a DOM tree from the HTML string passed to the `Content` method, which is
    the HTML contained in the response received by the client.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenAsync`方法使用`context`中包含的设置执行DOM构建活动。构建DOM文档的输入由作为`OpenAsync`参数传递的lambda函数指定。在我们的情况下，`req.Content(...)`从客户端接收的响应中传递给`Content`方法的HTML字符串构建了DOM树。'
- en: 'Once a `document` object is obtained, we can use it as we would use it in JavaScript.
    In particular, we can use `QuerySelector` to find an anchor with the required
    link:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得`document`对象，我们可以像在JavaScript中一样使用它。特别是，我们可以使用`QuerySelector`来查找具有所需链接的锚点：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All that remains is to verify that `node` is not null:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下验证`node`不为空了：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have done it! If you want to analyze pages that require a user to be logged
    in or other more complex scenarios, you need to enable cookies and automatic URL
    redirects in the HTTP client. This way, the client will behave like a normal browser
    that stores and sends cookies and that moves to another URL whenever it receives
    a `Redirect` HTTP response. This can be done by passing an options object to the
    `CreateClient` method, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！如果您想分析需要用户登录或其他更复杂场景的页面，您需要在HTTP客户端中启用cookie和自动URL重定向。这样，客户端将表现得像一个正常的浏览器，存储和发送cookie，并在收到`Redirect`
    HTTP响应时转到另一个URL。这可以通过将选项对象传递给`CreateClient`方法来实现，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the preceding setup, your tests can do everything a normal browser can
    do. For instance, you can design tests where the HTTP client logs in and accesses
    pages that require authentication since `HandleCookies=true` lets the authentication
    cookie be stored by the client and be sent in all subsequent requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的设置，您的测试可以执行普通浏览器可以执行的所有操作。例如，您可以设计需要HTTP客户端登录并访问需要身份验证的页面的测试，因为`HandleCookies=true`允许客户端存储身份验证cookie，并在所有后续请求中发送。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explains the importance of functional tests, and how to define
    detailed manual tests to be run on the output of each sprint. At this point, you
    should be able to define automatic tests to verify that, at the end of each sprint,
    your application complies with its specifications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了功能测试的重要性，以及如何定义详细的手动测试，以在每个迭代的输出上运行。此时，您应该能够定义自动测试，以验证在每个迭代结束时，您的应用程序是否符合其规格。
- en: Then, this chapter analyzed when it is worth automating some or all functional
    tests and described how to automate them in ASP.NET Core applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章分析了何时值得自动化一些或所有功能测试，并描述了如何在ASP.NET Core应用程序中自动化它们。
- en: A final example showed how to write ASP.NET Core functional tests with the help
    of `AngleSharp` to inspect the responses returned by the application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了如何使用`AngleSharp`编写ASP.NET Core功能测试来检查应用程序返回的响应。
- en: Conclusions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: After many chapters discussing the best practices and approaches to developing
    solutions using C# 9 and .NET 5, together with the most up to date cloud environments
    in Azure, you have finally reached the end of this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了使用C# 9和.NET 5开发解决方案的最佳实践和方法以及Azure中最新的云环境之后，您终于到达了本书的结尾。
- en: As you've probably already noticed during your career, it is not a simple task
    to develop software on time, on budget, and with the functionalities your customer
    needs. The primary aim of this book goes beyond showing best practices in the
    elementary areas of the software development cycle. It also demonstrates how to
    use the features and benefits of the tools mentioned, to help you design scalable,
    secure, and high-performance enterprise applications with smart software design
    consideration. That is why the book covers different approaches in each broad
    area, beginning with the user requirements and finishing with the software in
    production, deployed and monitored continuously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在职业生涯中可能已经注意到的那样，按时、按预算开发软件并满足客户需求的功能并不简单。本书的主要目的不仅在于展示软件开发周期基本领域的最佳实践，还演示了如何使用所提到的工具的功能和优势，以帮助您设计可扩展、安全和高性能的企业应用程序，并考虑智能软件设计。这就是为什么本书涵盖了每个广泛领域中的不同方法，从用户需求开始，到生产中的软件，不断部署和监控。
- en: Talking about delivering software continuously, this book has emphasized the
    need of best practices for coding, testing, and monitoring your solution. It is
    not only a matter of developing a project; as a software architect, you will be
    responsible for the decisions you have made until this software is discontinued.
    Now, it is up to you decide the practices and patterns that best fit your scenario.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到持续交付软件，本书强调了编码、测试和监控解决方案的最佳实践的必要性。这不仅仅是开发一个项目的问题；作为软件架构师，您将对您在软件停用之前所做的决定负责。现在，由您决定最适合您情况的实践和模式。
- en: Questions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it always worth automating UI functional tests in the case of quick CI/CD
    cycles?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在快速CI/CD周期的情况下，自动化UI功能测试总是值得的吗？
- en: What is the disadvantage of subcutaneous tests for ASP.NET Core applications?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core应用程序的皮下测试的缺点是什么？
- en: What is the suggested technique for writing ASP.NET Core functional tests?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写ASP.NET Core功能测试的建议技术是什么？
- en: What is the suggested way of inspecting the HTML returned by a server?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务器返回的HTML的建议方式是什么？
- en: Further reading
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details on the `Microsoft.AspNetCore.Mvc.Testing` NuGet package and `AngleSharp`
    can be found in their respective official documentation at [https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests)
    and [https://anglesharp.github.io/](https://anglesharp.github.io/).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.Testing` NuGet包和`AngleSharp`的更多详细信息可以在它们各自的官方文档中找到，网址分别为[https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests)和[https://anglesharp.github.io/](https://anglesharp.github.io)。'
- en: 'Readers interested in JavaScript tests can refer to the Jasmine documentation:
    [https://jasmine.github.io/](https://jasmine.github.io/).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对JavaScript测试感兴趣的读者可以参考Jasmine文档：[https://jasmine.github.io/](https://jasmine.github.io)。
- en: '| **Share your experience**Thank you for taking the time to read this book.
    If you enjoyed this book, help others to find it. Leave a review at [https://www.amazon.com/dp/1800566042](https://www.amazon.com/dp/1800566042).
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **分享您的经验**感谢您抽出时间阅读本书。如果您喜欢这本书，请帮助其他人找到它。在[https://www.amazon.com/dp/1800566042](https://www.amazon.com/dp/1800566042)上留下评论。|'
