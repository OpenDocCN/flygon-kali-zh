- en: Connecting Functions - Pipelining and Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接函数-管道和组合
- en: 'In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions
    - Currying and Partial Application*, we saw several different ways to build new
    functions by applying higher-order functions. In this chapter, we will go to the
    core of FP and see how to create sequences of function calls, so their combination
    will produce a more complex result out of several simpler components. We will
    include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中，*转换函数-柯里化和部分应用*，我们看到了通过应用高阶函数构建新函数的几种不同方式。在本章中，我们将深入FP的核心，看看如何创建函数调用序列，以便它们的组合将从几个更简单的组件中产生更复杂的结果。我们将包括以下内容：
- en: '**Pipelining**, a way to join functions together in similar way to Unix/Linux
    pipes'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道**，一种类似于Unix/Linux管道的函数连接方式'
- en: '**Chaining***,* which may be considered a variant of pipelining, but restricted
    to objects'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**，这可能被认为是管道的一种变体，但限于对象'
- en: '**Composing**, which is a classic operation with its origins in basic computer
    theory'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**，这是一种经典操作，起源于基本的计算机理论'
- en: 'Along the way, we will be touching on related concepts, such as the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将涉及相关概念，例如以下内容：
- en: '**Pointfree style**, which is often used with pipelining and composition'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无点风格**，通常与管道和组合一起使用'
- en: Debugging of composed or piped functions, for which we'll whip up some auxiliary
    tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合或管道函数的调试，我们将编写一些辅助工具
- en: Testing of composed or piped functions, which won't prove to be of high complexity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合或管道函数的测试，这不会被证明是高复杂度的
- en: Pipelining
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'Pipelining and composition are techniques for setting up functions to work
    in sequence, so the output from a function becomes the input to the next function.
    There are two ways of looking at this: from a computer point of view and from
    a mathematical point of view. Usually, most FP texts start with the latter, but
    since I assume that most readers are closer to computers than to math, let''s
    start with the former.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和组合是一种设置函数按顺序工作的技术，因此一个函数的输出成为下一个函数的输入。有两种看待这个问题的方式：从计算机的角度和从数学的角度。通常，大多数FP文本都从后者开始，但由于我假设大多数读者更接近计算机而不是数学，让我们从前者开始。
- en: Piping in Unix/Linux
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix/Linux中的管道
- en: 'In Unix/Linux, the execution of a command and passing its output as an input
    to a second command, whose output will yet the input of a third command, and so
    on, is called a *pipeline*. This is quite common, and an application of the philosophy
    of Unix, as explained in a Bell Laboratories article, written by the creator of
    the pipelining concept himself, Doug McIlroy:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix/Linux中，执行一个命令并将其输出作为第二个命令的输入，其输出将作为第三个命令的输入，依此类推，称为*管道*。这是相当常见的，也是Unix哲学的应用，正如贝尔实验室的一篇文章所解释的，这篇文章是由管道概念的创造者Doug
    McIlroy撰写的：
- en: Make each program do one thing well. To do a new job, build afresh rather than
    complicating old programs by adding new *features*.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让每个程序都做一件事情。要做新工作，最好重新构建，而不是通过添加新的*功能*来使旧程序复杂化。
- en: Expect the output of every program to become the input to another, as yet unknown,
    program.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望每个程序的输出成为另一个尚不知道的程序的输入。
- en: Given the historical importance of Unix, I'd recommend reading some of the seminal
    articles describing the (then new) operating system, in the *Bell System Technical
    Journal*, July 1978, at [http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf).
    The two quoted rules are in the *Style* section, in the *Foreword* article.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Unix的历史重要性，我建议阅读一些描述（当时新的）操作系统的重要文章，位于*贝尔系统技术杂志*1978年7月，网址为[http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf)。两条引用的规则在*风格*部分，*前言*文章中。
- en: 'Let''s consider a simple example to get started. Suppose I want to know how
    many LibreOffice text documents there are in a directory. There are many ways
    to do this, but this will do. We will execute three commands, piping (that''s
    the meaning of the `|` character) each command''s output as input to the next
    one. Suppose we `cd /home/fkereki/Documents` and then do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子来开始。假设我想知道一个目录中有多少个LibreOffice文本文档。有很多方法可以做到这一点，但这样做就可以了。我们将执行三个命令，将每个命令的输出作为输入传递给下一个命令（这就是`|`字符的含义）。假设我们`cd
    /home/fkereki/Documents`，然后执行以下操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What does this mean? How does it work? (Ignore the dollar sign: it''s just
    the console prompt.) We have to analyze the process step by step:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？它是如何工作的？（忽略美元符号：这只是控制台提示。）我们必须逐步分析这个过程：
- en: The first part of the pipeline, `ls -1`, lists all the files in the directory
    (`/home/fkereki/Documents`, as per our `cd` command), in a single column, one
    file name per line
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道的第一部分`ls -1`列出目录中的所有文件（根据我们的`cd`命令为`/home/fkereki/Documents`），以单列形式，每行一个文件名
- en: The output from the first command is provided as input to `grep "odt$"`, which
    filters (lets pass) only those lines that finish with `"odt"`, the standard file
    extension for LibreOffice Writer
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个命令的输出作为`grep "odt$"`的输入，它过滤（通过）只有以`"odt"`结尾的行，这是LibreOffice Writer的标准文件扩展名
- en: The filtered output is provided to the counting command, `wc -l`, which counts
    how many lines there are in its input
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤后的输出提供给计数命令`wc -l`，它计算其输入中有多少行
- en: You can find pipelines in Section 6.2, *Filters*, of the *UNIX Time-Sharing
    System* article by Dennis Ritchie and Ken Thompson, also in the issue of the Bell
    Laboratories journal that I mentioned above.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Dennis Ritchie和Ken Thompson的*UNIX分时系统*文章的第6.2节*过滤器*中找到管道，这也是我上面提到的贝尔实验室期刊的一部分。
- en: 'From the point of view of FP, this is a key concept. We want to build up more
    complex operations out of simple, single-purpose, shorter functions. Pipelining
    is the way the Unix shell uses to apply that concept, simplifying the job of executing
    a command, taking its output, and providing it as an input to yet another command.
    We will be applying similar concepts in our own functional style in JS, as we''ll
    see; check out Figure 8.1:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从FP的角度来看，这是一个关键概念。我们希望通过简单、单一用途、较短的函数来构建更复杂的操作。管道是Unix shell用来应用这个概念的方式，简化了执行命令、获取其输出，并将其作为输入传递给另一个命令的工作。我们将在JS中以我们自己的函数式风格应用类似的概念，正如我们将看到的；请查看图8.1：
- en: '![](assets/bedb088b-2623-4076-b6ad-b5aab8b78d93.jpg)Figure 8.1\. Pipelines
    in JS are similar to Unix/Linux pipelines. The output of each function becomes
    the input for the next.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bedb088b-2623-4076-b6ad-b5aab8b78d93.jpg)图8.1\. JS中的管道与Unix/Linux中的管道类似。每个函数的输出都成为下一个函数的输入。'
- en: By the way (and, no, rest assured, this isn't turning into a shell tutorial!)
    you can also make pipelines to accept parameters. For example, if I happened to
    often desire to count how many files I had with this or that extension, I could
    create a function such as `cfe`, standing for *count for extension:*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句（不，放心，这不会变成一个shell教程！）你也可以使管道接受参数。例如，如果我经常想要计算我有多少个带有这种或那种扩展名的文件，我可以创建一个名为`cfe`的函数，代表*计算扩展名的数量：*
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I could then use `cfe` as a command, giving it the desired extension as an
    argument:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以使用`cfe`作为一个命令，将所需的扩展名作为参数传递：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will also want to write similar parametric pipelines: we are not constrained
    to only have fixed functions in our flow, but rather have full liberty as to what
    we want to include.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望编写类似的参数化管道：我们不仅受限于在我们的流程中只有固定的函数，而是完全自由地决定要包含什么。
- en: Revisiting an example
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视一个例子
- en: 'We can start tying ends together by revisiting a problem from earlier chapters.
    Remember having to calculate the average latitude and longitude for some geographic
    data, which we saw in the *Extracting data from objects* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*? Basically, we started with some
    data like the following and the problem was to calculate the average latitude
    and longitude of the given points:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新审视早期章节中的一个问题来开始将各个部分联系在一起。还记得之前需要计算一些地理数据的平均纬度和经度吗？我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的*从对象中提取数据*部分中看到了这个问题，*声明式编程
    - 更好的风格*？基本上，我们从以下数据开始，问题是要计算给定点的平均纬度和经度：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With what we now know, we can write a solution in terms of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们现在所知道的，我们可以用以下方式来编写一个解决方案：
- en: Being able to extract the latitude (and, afterward, the longitude) from each
    point
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从每个点中提取纬度（以及之后的经度）
- en: Using that function to create an array of latitudes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该函数来创建一个纬度数组
- en: Pipelining the resulting array to the average function we wrote in the *Calculating
    an average* section, of the aforementioned chapter
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果数组传递给我们在*计算平均值*部分编写的平均函数，上述章节
- en: 'To do the first task, we can use the `myMap()` function from the *Parameters
    order* section, of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application*, plus the `getField()` function
    from the *Getting a property from an object* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, plus a bit of currying to fix
    some values. Written out in long, our solution could be the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成第一个任务，我们可以使用[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)的*参数顺序*部分中的`myMap()`函数，以及[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)的*从对象中获取属性*部分中的`getField()`函数，再加上一些柯里化来固定一些值。用长篇大论来写，我们的解决方案可能是以下内容：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, you can always yield to the temptation of going for a couple of
    *one-liners*, but mind: is it really clearer, better?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以屈服于去写一些*一行代码*的诱惑，但要注意：这样真的更清晰，更好吗？
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whether this makes sense to you will depend on your experience with FP. In any
    case, no matter which solution you take, the fact remains that adding pipelining
    (and later on, composition) to your set of tools can help you write tighter, declarative,
    simpler to understand code, so let's now turn to seeing how we can pipeline functions
    in the right way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否对你有意义将取决于你对FP的经验。无论采取哪种解决方案，事实仍然是，添加管道（以及后来的组合）到你的工具集中可以帮助你编写更紧凑、声明式、更容易理解的代码，所以现在让我们转向看看如何以正确的方式进行函数管道化。
- en: Creating pipelines
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管道
- en: 'We want to be able to generate a pipeline of several functions. We can go at
    this in two different ways: by building the pipeline *by hand*, in a problem-specific
    way, or by seeking to use more generic constructs, that can be applied with generality.
    Let''s see both types of solution.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够生成一个包含多个函数的管道。我们可以以两种不同的方式来做到这一点：通过以问题特定的方式*手动*构建管道，或者试图使用更通用的构造，可以以一般性地应用。让我们看看这两种解决方案。
- en: Building pipelines by hand
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建管道
- en: 'Let''s go with a Node.js example, similar to the command-line pipeline we built
    earlier in this chapter. We need a function to read all files in a directory and
    we can do that (in a not very recommendable way, because of the synchronous call,
    normally not good in a server environment) with something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个Node.js的例子来进行，类似于我们在本章前面构建的命令行管道。我们需要一个函数来读取目录中的所有文件，我们可以这样做（这种方式不太推荐，因为它是同步调用，通常在服务器环境中不好）：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Filtering the `odt` files is quite simple. We start with the following function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤`odt`文件非常简单。我们从以下函数开始：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, we can now write the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以写出以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Better still, we can applying currying, and go for pointfree style, as seen
    in the *An unnecessary mistake* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以应用柯里化，并采用无参风格，就像[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)中的*一个不必要的错误*部分所示的那样：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, to count elements in an array, we can simply write the following code.
    Since `.length` is not a function, we cannot apply our demethodizing trick:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要计算数组中的元素，我们可以简单地编写以下代码。由于`.length`不是一个函数，我们无法应用我们的去方法化技巧：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With these functions available, we could write something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些函数，我们可以写出类似这样的代码：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you wanted to get rid of all the intermediate variables, you could also
    go for a *one-liner* definition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想摆脱所有的中间变量，你也可以选择*一行式*的定义：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This gets to the crux of the matter: both implementations of our file-counting
    function have disadvantages. The first definition uses several intermediate variables
    to hold results and makes a multiline function out of what was a single line of
    code in the Linux shell. The second, much shorter, definition, on the other hand,
    is quite harder to understand, insofar as we are writing the steps of the computation
    in seemingly reverse order! Our pipeline has to read files first, then filter
    them, and finally count -- but those functions appear *the other way round* in
    our definition!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是问题的关键：我们的文件计数函数的两种实现都有缺点。第一个定义使用了几个中间变量来保存结果，并且将Linux shell中的一行代码变成了多行函数。另一方面，第二个定义要短得多，但在某种程度上更难理解，因为我们似乎是以相反的顺序编写计算的步骤！我们的流水线必须首先读取文件，然后过滤它们，最后计数--但在我们的定义中，这些函数的顺序却是*相反的*！
- en: We certainly can implement pipelining by hand, as we have seen, but it will
    be better if we can go for a more declarative style. Let's then move on to try
    to build a better pipeline in a more clear and understandable way, trying to apply
    some of the concepts we have already seen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以手动实现流水线处理，正如我们所见，但如果我们可以采用更具声明性的风格会更好。让我们继续尝试以更清晰和可理解的方式构建更好的流水线，尝试应用我们已经见过的一些概念。
- en: Using other constructs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他构造
- en: 'If we think in functional terms, what we have is a list of functions and we
    want to apply them sequentially, starting with the first, then applying the second
    to whatever the first function produced as its result, and then applying the third
    to the second function''s results, and so on. If we were just fixing a pipeline
    of two functions, this could do:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从函数的角度思考，我们拥有的是一系列函数，我们想要按顺序应用它们，从第一个开始，然后将第二个应用于第一个函数产生的结果，然后将第三个应用于第二个函数的结果，依此类推。如果我们只是修复两个函数的流水线，这样就可以：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is not so useless as it may seem because we can compose longer pipelines
    -- though, I''ll admit, it requires too much writing! We can write our three functions''
    pipeline in two different, equivalent ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是那么无用，因为我们可以组合更长的流水线--尽管，我承认，这需要写得太多了！我们可以用两种不同但等效的方式来编写我们的三个函数的流水线：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are taking advantage of the fact that piping is an associative operation.
    In mathematics, the associative property is the one that says that we can compute
    *1+2+3* either by adding *1+2* first and then adding that result to 3, or by adding
    1 to the result of adding *2+3*: in other terms, *1+2+3* is the same as *(1+2)+3*
    or *1+(2+3)*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在利用管道是一个可结合的操作这一事实。在数学中，结合性质是指我们可以通过首先添加*1+2*然后将结果添加到3，或者通过将1添加到添加*2+3*的结果来计算*1+2+3*：换句话说，*1+2+3*与*(1+2)+3*或*1+(2+3)*相同。
- en: 'How does this work? Following in detail the execution of a given call will
    be useful; it''s quite easy to get confused with so many calls! The first implementation
    can be followed step by step, until the final result that fortunately matches
    what we already knew:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？详细跟踪给定调用的执行将是有用的；很容易因为有这么多的调用而感到困惑！第一个实现可以一步一步地跟踪，直到最终结果，幸运的是与我们已经知道的相匹配：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second implementation also comes to the same final result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实现也得到了相同的最终结果：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'OK, so we now know that we can make do with just a basic *pipe of two* higher-order
    function... but we''d really like to be able to work in a shorter, more compact
    way. A first implementation could be along the lines of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们知道我们只需要一个基本的*两个管道*高阶函数...但我们真的希望能够以更短、更紧凑的方式工作。首先的实现可能是以下内容：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This does work -- and the way of specifying our file-counting pipeline is much
    clearer since now the functions are given in their proper order. However, the
    implementation itself of the `pipeline()` function is not very functional and
    rather goes back to old, imperative, loop by hand methods. We can do better using
    `.reduce()`, as in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有效--现在我们的文件计数流水线的指定方式更清晰，因为现在函数按照正确的顺序给出。然而，`pipeline()`函数的实现本身并不是非常函数式的，而是回到了旧的、命令式的、手动循环的方法。我们可以使用`.reduce()`来做得更好，就像[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中的*以更好的风格进行声明式编程*。
- en: If you check some FP libraries, the function that we are here calling `pipeline()`
    may also be known as `flow()` - because data flows from the left to the right-or
    `sequence()` - alluding to the fact that operations are performed in ascending
    sequence - but the semantics are the same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一些FP库，我们这里称为`pipeline()`的函数也可能被称为`flow()`--因为数据从左到右流动--或`sequence()`--暗示操作是按升序顺序执行的--但语义是相同的。
- en: 'The idea is to start evaluation with the first function, pass the result to
    the second, then that result to the third, and so on. We can then achieve our
    pipelining with shorter code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是从第一个函数开始评估，将结果传递给第二个函数，然后将该结果传递给第三个函数，依此类推。然后我们可以用更短的代码实现我们的流水线：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code is more declarative, and you could have even gone one better by writing
    it using our `pipeTwo()` function, which does the same:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更具声明性，你甚至可以通过使用我们的`pipeTwo()`函数来写得更好，它执行的是相同的操作：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can understand this code also by realizing that, basically, it uses the
    associative property that we mentioned, and it first pipes the first function
    to the second; then, it pipes the result of this to the third function, and so
    on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过意识到，基本上它使用了我们提到的结合性质，并首先将第一个函数传递给第二个；然后，将这个结果传递给第三个函数，依此类推来理解这段代码。
- en: 'Which version is better? I would say that the version that refers to the `pipeTwo()`
    function is clearer: if you know how `.reduce()` works, you can readily understand
    that our pipeline goes through the functions two at a time, starting from the
    first -- and that matches what you know about how pipes work. The other versions
    that we wrote are more or less declarative, but possibly not so simple to understand.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个版本更好？我会说引用`pipeTwo()`函数的版本更清晰：如果您知道`.reduce()`的工作原理，您可以很容易理解我们的管道是如何一次两个函数地通过的，从第一个开始--这与您对管道工作原理的了解相匹配。我们写的其他版本更多或少是陈述性的，但可能不那么容易理解。
- en: Debugging pipelines
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试管道
- en: 'Now, let''s turn to a practical question: how do you debug your code? With
    pipelining, you cannot really see what''s passing on from function to function,
    so how do you do it? We have two answers for that: one (also) comes from the Unix/Linux
    world and the other (most appropriately for this book) uses wrappers to provide
    some logs.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一个实际问题：如何调试您的代码？使用管道，您无法真正看到从函数到函数传递的内容，那么您该如何做呢？我们有两个答案：一个（也）来自Unix/Linux世界，另一个（最适合本书）使用包装器来提供一些日志。
- en: Using tee
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tee
- en: 'The first solution we''ll use implies adding a function to the pipeline, which
    will just log its input. We want to implement something similar to the `tee` Linux
    command, which can intercept the standard data flow in a pipeline and send a copy
    to an alternate file or device. Remembering that `/dev/tty` is the usual console,
    we may execute something as follows and get an onscreen copy of everything that
    passes through the `tee` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个解决方案意味着向管道中添加一个函数，该函数将仅记录其输入。我们希望实现类似于`tee` Linux命令的功能，它可以拦截管道中的标准数据流并将副本发送到备用文件或设备。记住`/dev/tty`是通常的控制台，我们可以执行以下操作并在屏幕上获得通过`tee`命令传递的所有内容的副本：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could write a similar function with ease:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地编写一个类似的函数：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you are aware of the uses of the comma operator, you can be quite more concise,
    and just write `const tee = (arg) => (console.log(arg), arg)` -- do you see why?
    Check [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    for the answer!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您了解逗号运算符的用法，您可以更加简洁，只需编写`const tee = (arg) => (console.log(arg), arg)`--您明白为什么吗？查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)获取答案！
- en: 'Our logging function will receive a single argument, list it, and pass it on
    to the next function in the pipe. We can see it working:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志记录函数将接收一个参数，列出它，并将其传递给管道中的下一个函数。我们可以看到它的工作方式：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We could do even better if our `tee()` function could receive a logger function
    as a parameter, as we did in the *Logging in a functional way* section of [Chapter
    6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions - Higher-Order
    Functions*; it's just a matter of doing the same kind of change we managed there.
    The same good design concepts are applied again!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`tee()`函数可以接收一个日志记录函数作为参数，那就更好了，就像我们在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)的*以函数式方式记录日志*部分中所做的那样；这只是做出与我们之前所做的相同类型的更改的问题。同样的良好设计概念再次应用！
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Be aware that there might be a binding problem when passing `console.log` in
    that way. It would be safer to write `console.log.bind(console)`, just as a precaution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以这种方式传递`console.log`可能会存在绑定问题。最好写成`console.log.bind(console)`，作为一种预防措施。
- en: 'However, this would just be a particular enhancement: let''s now consider an
    even more generic tapping function, with more possibilities than just doing a
    bit of logging.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个特定的增强：现在让我们考虑一个更通用的接入函数，比仅仅做一些日志记录更有可能。
- en: Tapping into a flow
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接入流
- en: 'If you wish, you could write an enhanced `tee()` function that could produce
    more debugging information, possibly send the reported data to a file or remote
    service, and so on--there are many possibilities you can explore. You could also
    explore a more general solution, of which `tee()` would just be a particular case
    and which would also allow creating personalized tapping functions. See Figure
    8.2:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以编写一个增强的`tee()`函数，可以产生更多的调试信息，可能将报告的数据发送到文件或远程服务等--您可以探索许多可能性。您还可以探索更一般的解决方案，`tee()`只是一个特例，并且还允许创建个性化的接入函数。参见图8.2：
- en: '![](assets/b07f36e2-f002-4d72-ae32-abf179920530.jpg)Figure 8.2\. Tapping allows
    you to apply some function to inspect data as it flows through the pipeline.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b07f36e2-f002-4d72-ae32-abf179920530.jpg)图8.2。接入允许您应用一些函数来检查数据在管道中流动的情况。'
- en: 'When working with pipelines, you might want to put a logging function in the
    middle of it, or you might want some other kind of *snooping* function -- possibly
    storing data somewhere, or calling a service, or some other kind of side effect.
    We could have a generic `tap()` function, which would behave in this way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用管道时，您可能希望在其中间放置一个日志记录函数，或者您可能需要一些其他类型的*窥探*函数--可能在某处存储数据，或者调用服务，或者其他一些副作用。我们可以有一个通用的`tap()`函数，它可以以这种方式运行：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is probably a candidate for a *trickiest-looking-code-in-the-book* award,
    so let''s explain it. We want to produce a function, that given a function `fn()`
    and an argument `x`, will evaluate `fn(x)` (to produce whatever sort of side of
    effect we may be interested in) but return `x` (so the pipeline goes on without
    interference). The comma operator has exactly that behavior: if you write code
    like `(a, b, c)`, JS will evaluate the three expressions in order and will use
    the last value as the expression''s value.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本书中 *看起来最棘手的代码* 候选，所以让我们解释一下。我们想要生成一个函数，给定一个函数 `fn()` 和一个参数 `x`，将评估 `fn(x)`（以产生我们可能感兴趣的任何一种副作用），但返回
    `x`（这样管道就可以继续进行而不受干扰）。逗号运算符正好具有这种行为：如果您编写像 `(a, b, c)` 这样的代码，JS 将按顺序评估这三个表达式，并使用最后一个值作为表达式的值。
- en: The comma has several uses in JS and you can read more about its usage as an
    operator at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号在 JS 中有几种用法，您可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    上阅读更多关于其作为运算符的用法。
- en: 'We can now take advantage of currying to produce several different tapping
    functions. The one we wrote in the previous section, `tee()`, could also be written
    in the following fashion:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用柯里化来生成几个不同的 tapping 函数。我们在上一节中编写的 `tee()` 函数也可以按照以下方式编写：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By the way, you could have also written `tap()` without currying... but you'll
    admit it loses something of its mystery!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您也可以不使用柯里化来编写 `tap()`... 但您会承认它失去了一些神秘感！
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You'll recognize this way of currying as we saw it in the *Currying by hand*
    section of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您会认出这种柯里化的方式，就像我们在 [第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml) 的 *Currying
    by hand* 部分中看到的那样，*Transforming Functions - Currying and Partial Application*。
- en: Using a logging wrapper
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志包装器
- en: 'The second idea we mentioned is based on the `addLogging()` function that we
    wrote in the *Logging* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. The idea was to wrap a function
    with some logging functionality so that on entry, the arguments would be printed
    and on exit, the result of the function would be shown:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的第二个想法基于我们在 [第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml) 的 *Logging*
    部分中编写的 `addLogging()` 函数，*Producing Functions - Higher-Order Functions*。这个想法是用一些日志功能包装一个函数，这样在进入时，参数将被打印出来，退出时，函数的结果将被显示出来：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can trivially verify that the `pipeline()` function is doing its thing correctly
    -- whatever a function produces as a result is given as input to the next function
    in the line and we can also understand what''s happening with each call. Of course,
    you need not add logging to *every* function in the pipeline: you would probably
    do in the places where you suspected an error was occurring.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松验证 `pipeline()` 函数是否正确执行 -- 函数产生的结果作为输入传递给下一个函数，我们也可以理解每次调用发生了什么。当然，您不需要在
    *每个* 管道函数中添加日志记录：您可能只在怀疑出现错误的地方这样做。
- en: Chaining and fluent interfaces
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接和流畅接口
- en: 'When you work with objects or arrays, there is another way of linking the execution
    of several calls together, by applying *chaining*. For example, when you work
    with arrays, if you apply a `.map()` or `.filter()` method, the result is a new
    array, to which you can apply a new further method, and so forth. We have already
    used such methods, as when we defined the `range()` function back in the *Working
    with ranges* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A* B*etter* S*tyle*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用对象或数组时，还有另一种方法可以将多个调用的执行链接在一起，即应用 *chaining*。例如，当您使用数组时，如果应用了 `.map()` 或
    `.filter()` 方法，结果将是一个新数组，您可以对其应用新的方法，依此类推。我们已经使用了这样的方法，就像我们在 [第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)
    的 *Working with ranges* 部分中定义 `range()` 函数时一样：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we created a new array; then, we applied the `.fill()` method to it,
    which updated the array in place (side effect...) and returned the updated array,
    to which we finally applied a `.map()` method. The latter method did generate
    a new array, to which we could have applied further mappings, filtering, or any
    other available method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新数组；然后，我们对其应用了 `.fill()` 方法，这个方法会直接更新数组（副作用...）并返回更新后的数组，最后我们对其应用了
    `.map()` 方法。后者确实生成了一个新数组，我们可以对其应用进一步的映射、过滤或任何其他可用的方法。
- en: 'This style of continuous chained operation is also used in fluent APIs or interfaces.
    To give just one example, the graphic `D3.js` library (see [https://d3js.org/](https://d3js.org/)
    for more on it) frequently uses this style -- and the following example, taken
    from [https://bl.ocks.org/mbostock/4063269](https://bl.ocks.org/mbostock/4063269)
    shows it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连续链式操作的风格也用于流畅的 API 或接口。举一个例子，图形库 `D3.js`（请参阅 [https://d3js.org/](https://d3js.org/)
    了解更多信息）经常使用这种风格 -- 下面的例子取自 [https://bl.ocks.org/mbostock/4063269](https://bl.ocks.org/mbostock/4063269)：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each method works on the previous object and either provides access to a new
    object to which future method calls will apply (such as the `.selectAll()` or
    `.append()` methods) or updates the current one (as with the `.attr()` attribute
    setting calls). This style is not unique and several other well-known libraries
    (jQuery comes to mind, just to start) also apply it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都作用于前一个对象，并提供对将来应用方法调用的新对象的访问（例如 `.selectAll()` 或 `.append()` 方法），或者更新当前对象（就像
    `.attr()` 属性设置调用一样）。这种风格并不是唯一的，还有其他一些知名的库（比如 jQuery，仅举一个例子）也应用了这种风格。
- en: Can we automate this? In this case, the answer is *possibly, but I'd rather
    not*. In my opinion, using `pipeline()` or `compose()` is just as well, and manages
    the same result. With object chaining, you are limited to returning new objects
    or arrays or something to which methods can be applied. (Remember, if you are
    working with standard types, such as strings or numbers, you cannot add methods
    to them unless you mess with their prototype, which isn't recommended!) With composition,
    however, you can return any kind of value; the only restriction is that the next
    function in line must be expecting the data type that you are providing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能自动化这个过程吗？在这种情况下，答案可能是*可能，但我宁愿不这样做*。在我看来，使用`pipeline()`或`compose()`同样可以实现相同的结果。使用对象链接，你只能返回新的对象或数组或可以应用方法的东西。
    （请记住，如果你使用标准类型，比如字符串或数字，你不能给它们添加方法，除非你修改它们的原型，这是不推荐的！）然而，使用组合，你可以返回任何类型的值；唯一的限制是下一个函数必须期望你提供的数据类型。
- en: 'On the other hand, if you are writing your own API, then you can provide a
    fluent interface by just having each method `return this` -- unless, of course,
    it needs to return something else! If you were working with some other people''s
    API, you could also do some trickery by using a proxy, but be aware there could
    be cases in which your proxied code might fail: maybe another proxy is being used,
    or there are some getters or setters that somehow cause problems, and so on.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在编写自己的API，那么你可以通过让每个方法`return this`来提供一个流畅的接口--当然，除非它需要返回其他东西！如果你正在使用其他人的API，你也可以通过使用代理来进行一些技巧，但要注意可能有情况下你的代理代码可能会失败：也许正在使用另一个代理，或者有一些getter或setter会导致问题，等等。
- en: You may want to read up on proxy objects at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    -- they are very powerful and allow for interesting metaprogramming functionalities,
    but they can also trap you with technicalities and they will also cause an (albeit
    slight) slowdown in your proxied code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)上阅读代理对象的相关内容--它们非常强大，可以提供有趣的元编程功能，但它们也可能陷入技术细节，并且会导致代理代码的轻微减速。
- en: 'Let''s go for a basic example. We could have a `City` class, with name, latitude
    (`lat`) and longitude (`long`) attributes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个基本的例子。我们可以有一个`City`类，带有名称、纬度（`lat`）和经度（`long`）属性：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We could use this class as follows, with details for my native city, Montevideo,
    Uruguay:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样使用这个类，详细介绍我的家乡蒙得维的亚，乌拉圭：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we wanted to allow a fluent handling of the setters, we could set up a proxy
    to detect such calls and provide the missing `return this`. How can we do that?
    If the original method doesn''t return anything, JS will include by default a
    `return undefined` statement, so we can detect whether that''s what the method
    is returning and substitute `return this` instead. Of course, this is a problem:
    what would we do if we had a method that could legally return an `undefined` value
    on its own, because of its semantics? We could have some kind of *exceptions list*,
    to tell our proxy not to add anything in those cases, but let''s not get into
    that.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要允许流畅地处理setter，我们可以设置一个代理来检测这样的调用，并提供缺失的`return this`。我们怎么做呢？如果原始方法没有返回任何东西，JS将默认包含一个`return
    undefined`语句，因此我们可以检测方法是否返回这个值，并替换为`return this`。当然，这是一个问题：如果我们有一个方法，根据其语义，它可以合法地返回一个`undefined`值，我们可以有一种*异常列表*，告诉我们的代理在这些情况下不添加任何东西，但我们不要深入讨论这个问题。
- en: 'The code for our handler is as follows. Whenever a method of an object is invoked,
    a get is implicitly called and we catch it. If we are getting a function, then
    we wrap it with some code of our own, that will call the original method and then
    decide whether to return its value or a reference to the proxied object instead.
    If we weren''t getting a function, then we directly return the requested property''s
    value. Our `chainify()` function will take care of assigning the handler to an
    object and creating the needed proxy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序代码如下。每当调用对象的方法时，都会隐式调用一个get，我们捕获它。如果我们得到一个函数，那么我们用自己的一些代码包装它，这些代码将调用原始方法，然后决定是返回它的值还是返回代理对象的引用。如果我们没有得到一个函数，那么我们直接返回所请求属性的值。我们的`chainify()`函数将负责将处理程序分配给一个对象，并创建所需的代理。
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this, we can *chainify* any object, so we''ll get a chance to inspect
    any called methods. As I''m writing this, I''m currently living in Pune, India,
    so let''s reflect that change:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以*chainify*任何对象，这样我们就有机会检查任何调用的方法。当我写这篇文章时，我目前住在印度浦那，所以让我们反映这个变化。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下内容：
- en: We changed `myCity` to be a proxified version of itself
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`myCity`更改为它自己的代理版本。
- en: We are calling several setters in fluent fashion and they are working fine since
    our proxy is taking care of providing the need this value for the following call
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以流畅的方式调用了几个setter，它们工作正常，因为我们的代理负责为下一个调用提供所需的this值。
- en: The calls to `.getCoords()` and `.getName()` are intercepted, but nothing special
    is done, because they already return a value
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`.getCoords()`和`.getName()`的调用被拦截，但没有做任何特殊处理，因为它们已经返回一个值。
- en: Is this worth it? That's up to you -- but remember my comment that there may
    be cases in which this approach fails, so be wary!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得吗？这取决于你--但请记住我的评论，可能有情况下这种方法会失败，所以要小心！
- en: Pointfree style
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pointfree风格
- en: 'When you join functions together, either in pipeline fashion as here, or with
    composition as we''ll be seeing later in this chapter, you don''t need any intermediate
    variables to hold the results that will become arguments to the next function
    in line: they are implicit. Similarly, you can write functions without mentioning
    their parameters, and this is called pointfree style.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将函数连接在一起，无论是像这样以管道方式，还是像我们将在本章后面看到的组合方式，你都不需要任何中间变量来保存结果，这些结果将成为下一个函数的参数：它们是隐式的。同样，你可以编写函数而不提及它们的参数，这被称为pointfree风格。
- en: Pointfree style is also called tacit programming -- and pointless programming
    by detractors! The term *point* itself means a function parameter and pointfree
    refers to not naming those parameters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 点无码风格也被称为暗示式编程--以及无意义的编程，由反对者提出！术语*point*本身意味着函数参数，点无码指的是不命名这些参数。
- en: Defining pointfree functions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义点无码函数
- en: 'You can easily recognize a pointfree function definition because it doesn''t
    need either the `function` keyword or the `=>` symbol. We can revisit some of
    the previous functions we wrote in this chapter and check that out. For example,
    the definition of our original file-counting functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地识别点无码函数定义，因为它既不需要`function`关键字，也不需要`=>`符号。我们可以重新审视本章中我们之前编写的一些函数的定义，来验证这一点。例如，我们原始的文件计数函数的定义：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code could be rewritten as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以重写如下：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The new definitions do not make reference to the parameter for the newly defined
    functions. You can deduce it by examining the first function in the pipeline (`getDir()`,
    in this case) and seeing what it receives as arguments. (Using type signatures
    as we''ll see in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building
    Better Containers - Functional Data Types*, would be a good help in terms of documentation.)
    Similarly, the definition for `getLat()` is pointfree:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 新的定义没有引用新定义的函数的参数。你可以通过检查管道中的第一个函数（在这种情况下是`getDir()`）并查看它接收的参数来推断它。 （在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中，我们将看到，使用类型签名会对文档方面有所帮助。）同样，`getLat()`的定义是点无码的：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What should be the equivalent full style definition? You''d have to examine
    the `getField()` function (we just saw it in the *Revisiting an example* section),
    to decide that it expects an object as an argument. However, making that need
    explicit by writing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 等价的完整风格定义应该是什么？你需要检查`getField()`函数（我们刚在*重新访问一个例子*部分看到它），来确定它期望一个对象作为参数。然而，通过写成明确的形式来表达这种需求：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This wouldn''t make much sense: if you were willing to write all this, you
    might simply stick with the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有太多意义：如果你愿意写所有这些，你可能只需坚持以下方式：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then you could simply not care about currying or anything like it!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以根本不用关心柯里化或类似的东西！
- en: Converting to pointfree style
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为点无码风格
- en: 'On the other hand, you had better pause a bit, and not try to write *everything*
    in pointfree code, whatever it might cost. For example, consider the `isNegativeBalance()`
    function we wrote back in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，最好稍作停顿，不要试图以点无码的方式写*所有*东西，不管它可能会付出什么代价。例如，考虑我们在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中编写的`isNegativeBalance()`函数，*生成函数
    - 高阶函数*：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Can we write this in pointfree style? Yes, we can, and we''ll see how -- but
    I''m not sure we''d want to code this way! We can consider building a pipeline
    of two functions: one will extract the balance from the given object and the next
    will check whether it''s negative, so we will write our alternative version of
    the balance-checking function in a fashion like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以点无码的方式写这个吗？可以，我们将看到如何做到这一点--但我不确定我们是否想以这种方式编写代码！我们可以考虑构建一个由两个函数组成的流水线：一个函数将从给定对象中提取余额，下一个函数将检查它是否为负数，因此我们将以以下方式编写我们的余额检查函数的替代版本：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To extract the balance attribute from a given object, we can use `getField()`
    and a bit of currying, and then write the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要从给定对象中提取余额属性，我们可以使用`getField()`和一点柯里化，然后写成以下形式：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For the second function, we could write the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个函数，我们可以写成以下形式：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There goes our pointfree goal! Instead, we can use the `binaryOp()` function,
    also from the same earlier cited chapter, plus some more currying, to write the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的点无码目标就在这里！相反，我们可以使用同一章节中的`binaryOp()`函数，再加上一些柯里化，来写成以下形式：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I wrote the test the other way around (*0>x* instead of *x<0*) just for ease
    of coding. An alternative would have been using the enhanced functions I mentioned
    in the *A handier implementation* section of the same chapter -- a bit less complex!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以以另一种方式编写测试（*0>x*而不是*x<0*）只是为了编码方便。另一种选择是使用我在同一章节的*一个更方便的实现*部分中提到的增强函数--稍微简单一些！
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, finally, we could write the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们可以写成以下形式：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alternatively, we could write the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写成以下形式：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Do you really think that's an advance? Our new versions of `isNegativeBalance()`
    don't make a reference to their argument and are fully pointfree, but the idea
    of using pointfree style should be to help improve the clarity and readability
    of your code, and not to produce obfuscation and opaqueness! I doubt anybody would
    look at our new versions of the function and consider them to be an advantage
    over the original, for any possible reason.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的认为这是一个进步吗？我们的`isNegativeBalance()`的新版本没有引用它们的参数，并且完全是点无码的，但使用点无码风格的想法应该是为了帮助提高代码的清晰度和可读性，而不是产生混淆和不透明性！我怀疑任何人看到我们函数的新版本并认为它们比原来的有任何优势。
- en: 'If you find that your code is becoming harder to understand, and that''s only
    due to your intent on using poin-free programming, stop and roll back your changes.
    Remember our doctrine for the book: we want to do FP, but we don''t want to go
    overboard with it -- and using pointfree style is not a requirement!'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的代码变得难以理解，而这只是因为你想使用点无码编程，那就停下来，撤销你的更改。记住我们书中的原则：我们想要进行FP，但我们不想过分使用它--使用点无码风格并不是一个要求！
- en: Composing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: '*Composing* is quite similar to pipelining, but has its roots in mathematical
    theory. The concept of composition is simple - a sequence of function calls, in
    which the output of one function is the input for the next one - but the order
    is reversed from the one in pipelining. In the latter, the first function to be
    applied is the leftmost one, but in composition, you start with the rightmost
    one. Let''s investigate this a bit more.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合*与管道非常相似，但它源自数学理论。组合的概念很简单 - 一系列函数调用，其中一个函数的输出是下一个函数的输入 - 但顺序与管道相反。在后者中，要应用的第一个函数是最左边的，但在组合中，你从最右边开始。让我们更深入地研究一下这个问题。'
- en: When you define the composition of, say, three functions, as (*f∘* *g∘* *h*)
    and apply it to *x*, this is equivalent to what you would write as *f*(*g*(*h*(*x*))).
    It's important to note that, as with pipelining, the arity of the first function
    to be applied can be anything, but all the other functions must be unary. Also,
    apart from the difference as to the sequence of function evaluations, composing
    is an important tool in FP, because it also abstracts implementation details (putting
    your focus on what you need to accomplish, rather than on the specific details
    for achieving that) thus letting you work in a more declarative fashion.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义三个函数的组合，比如(*f∘* *g∘* *h*)并将其应用于*x*时，这等同于你写成*f*(*g*(*h*(*x*)))。重要的是要注意，与管道相同，第一个要应用的函数的arity可以是任何值，但所有其他函数必须是一元的。此外，除了函数评估的顺序不同之外，组合是FP中的一个重要工具，因为它也抽象了实现细节（让你专注于你需要完成的任务，而不是为了实现这个任务而专注于具体的细节），因此让你以更声明式的方式工作。
- en: If it helps, you can read (*f∘* *g∘* *h*) as *f after g after h*, so it becomes
    clear that *h* is the first function to be applied, and *f* is the last.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助的话，你可以将(*f∘* *g∘* *h*)看作是*f在g之后在h之后*，这样就清楚了*h*是要应用的第一个函数，*f*是最后一个。
- en: Given the similarity to pipelining, it will be no surprise that implementing
    composition won't be very hard. However, there will still be some important and
    interesting details.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与管道的相似性，实现组合并不会太难，但仍然有一些重要和有趣的细节。
- en: Some examples of composition
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些组合的例子
- en: It may not be a surprise to you, but we have already seen several examples of
    composition -- or, at the very least, cases in which the solutions we achieved
    were functionally equivalent to using composition. Let's review some of these,
    and also work with some new examples.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也许对你来说并不奇怪，但我们已经看到了几个组合的例子，或者至少是功能上等价于使用组合的情况。让我们回顾一些这些例子，并且也用一些新的例子来工作。
- en: Unary operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一元运算符
- en: 'In the *Logically negating a function* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a `not()` function that,
    given another function, would logically invert its result. We used that function
    in order to negate a check for negative balances; sample code could be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)的*逻辑否定函数*部分，*生成函数 - 高阶函数*，我们写了一个`not()`函数，给定另一个函数，它会逻辑地反转其结果。我们使用该函数来否定对负余额的检查；示例代码可能如下：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In another section of that very same chapter, *Turning operations into functions*,
    I left you the challenge of writing a `unaryOp()` function that would provide
    unary functions equivalent to common JS operators. So, if you are able to write
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章的另一部分，*将操作转换为函数*，我给你留下了一个挑战，写一个`unaryOp()`函数，它将提供与常见JS运算符等价的一元函数。所以，如果你能写出以下内容：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, assuming the existence of a `compose()` function, you could have also
    written the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设存在一个`compose()`函数，你也可以写成以下形式：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Which one do you prefer? It's a matter of taste, really -- but I think the second
    version makes it clearer what we are trying to do. With the `not()` function,
    you have to check what it does in order to understand the general code. With composition,
    you still need to know what `logicalNot()` is, but the global construct is open
    to see.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢哪一个？这实际上是一个品味的问题，但我认为第二个版本更清楚地表达了我们想要做的事情。使用`not()`函数，你必须检查它的作用才能理解整个代码。而使用组合，你仍然需要知道`logicalNot()`是什么，但整体结构是可以看到的。
- en: 'To see just one more example in the same vein, you could have managed to get
    the same results as in the *Inverting results* section, in the same chapter. Remember,
    we had a function that could compare strings according to the Spanish language
    rules, but we wanted to invert the sense of the comparison, to sort in descending
    order:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章的*反转结果*部分，你也可以看到另一个例子。记住，我们有一个函数可以根据西班牙语规则比较字符串，但我们想要反转比较的意义，以降序排序：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Counting files
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算文件
- en: 'We can also go back to our pipeline. We had written a single-line function
    to count the `odt` files in a given path:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以回到我们的管道。我们已经写了一个单行函数来计算给定路径中的`odt`文件：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Disregarding (at least for the moment) the observation that this code is not
    so clear as the pipeline version that we got to develop later, we could have also
    written this function with composition:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不考虑这段代码不如后来我们开发的管道版本清晰的观察，我们也可以用组合来编写这个函数：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We could have also written the function in pointfree fashion, without specifying
    the `path` parameter, with `const countOdtFiles2 = compose(count, filterOdt, getDir)`
    but I wanted to better parallel the previous definition.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以pointfree的方式编写这个函数，不指定`path`参数，使用`const countOdtFiles2 = compose(count,
    filterOdt, getDir)`，但我想更好地与之前的定义相对应。
- en: 'It would also be possible to see this written in *one-liner* fashion:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以以*一行*的方式来看待这个问题：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Even if it's not so clear as the pipeline version (and that's just my opinion,
    which may be biased by my liking of Linux!), this declarative implementation makes
    it clear that we depend on combining three distinct functions to get our result
    -- that's easy to see, and applies the idea of building large solutions out of
    simpler pieces of code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它不像流水线版本那样清晰（这只是我的观点，可能受我对Linux的喜好影响！），这种声明式实现清楚地表明我们依赖于组合三个不同的函数来获得我们的结果--这很容易看出，并应用了将大型解决方案构建成更简单的代码片段的思想。
- en: Finding unique words
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找唯一单词
- en: 'Finally, let''s go for another example, which, I agree, could also have been
    used for pipelining. Suppose you have a text, and you want to extract all unique
    words from it: how would you go about it? If you think about it in steps (instead
    of trying to create a full solution in a single bit step) you would probably come
    up with a solution similar to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们举一个例子，我同意，这也可以用于流水线处理。假设你有一段文本，你想从中提取所有唯一的单词：你会怎么做？如果你考虑它的步骤（而不是试图一次性创建一个完整的解决方案），你可能会想出类似这样的解决方案：
- en: Ignore all non-alphabetic characters
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略所有非字母字符
- en: Put everything in uppercase
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容转换为大写
- en: Split the text into words
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本拆分为单词
- en: Create a set of words
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单词集合
- en: Why a set? Because it automatically discards repeated values; check out [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)
    for more on this. By the way, we will be using the `Array.from()` method to produce
    an array out of our set; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用集合？因为它会自动丢弃重复的值；请查看[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)了解更多信息。顺便说一句，我们将使用`Array.from()`方法将我们的集合转换为数组；请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)。
- en: 'Now, in FP way, let''s solve each problem:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以FP方式解决每个问题：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With these functions, the result can be written as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些函数，结果可以写成如下形式：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since you don't get to see the arguments to any of the composed functions, you
    really don't need to show the parameter for `getUniqueWords()` either, and so
    pointfree style is a natural in this case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你看不到组合函数的参数，你真的不需要显示`getUniqueWords()`的参数，所以在这种情况下，点无风格是自然的。
- en: 'We can test our function out; let''s apply this function to the first two sentences
    of Abraham Lincoln''s address at Gettysburg, from November 19, 1863, and print
    out the 43 different words (trust me, I counted them!) they comprised:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试我们的函数；让我们将这个函数应用于亚伯拉罕·林肯于1863年11月19日在葛底斯堡的演讲的前两句话，并打印出由43个不同单词组成的句子（相信我，我数过了！）：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Of course, you might have written `getUniqueWords()` in possibly shorter ways,
    but the point I'm making is that by composing your solution out of several shorter
    steps, your code is clearer and easier to grasp. However, if you wish to say that
    a pipelined solution seems better, then it's just a matter of opinion!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能已经以可能更短的方式编写了`getUniqueWords()`，但我要说的是，通过将解决方案组合成几个较短的步骤，你的代码更清晰，更容易理解。然而，如果你希望说流水线处理的解决方案似乎更好，那只是一种观点！
- en: Composing with higher order functions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶函数进行组合
- en: 'It''s pretty obvious that composing by hand could easily be done in a similar
    fashion as we saw above with pipelining. For example, the unique word counting
    function that we wrote a couple of sections earlier, could be written in simple
    JS style:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，手动组合可以像我们上面看到的流水线处理一样轻松地完成。例如，我们在前面的几节中编写的唯一单词计数函数可以用简单的JS风格编写：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, it could be written more concisely (and more obscurely!) in
    *one-liner* style:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可以以更简洁（更晦涩！）的*一行*风格编写：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, as with pipelining, let's go look for a more general solution, that
    won't require writing a special function each time we want to compose some other
    functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与流水线处理一样，让我们寻找一个更通用的解决方案，这样就不需要每次想要组合其他函数时都写一个特殊的函数。
- en: 'Composing two functions is quite easy, and requires just a small change with
    regard to our `pipeTwo()` function, which we saw earlier in this chapter:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 组合两个函数非常容易，只需要对我们在本章前面看到的`pipeTwo()`函数进行一点小改动：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The only difference is that, with piping, you apply the leftmost function first,
    and with composing, you start with the rightmost one. This variation suggests
    we could have used the `flipTwo()` higher-order function from the *Parameters
    order* section of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application.* Is it clearer?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，使用流水线处理时，你首先应用最左边的函数，而使用组合时，你从最右边的函数开始。这种变化表明我们可以使用来自[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)
    *转换函数-柯里化和部分应用*部分的`flipTwo()`高阶函数。这样清楚吗？
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In any case, if we wanted to compose more than two functions, we could have
    also taken advantage of the associative property, to write something like the
    following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果我们想要组合超过两个函数，我们也可以利用结合律，编写类似以下的内容：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Even though this works, let's go for a better solution -- and we can provide
    at least two. The first way has to do with the fact that pipelining and composing
    work *in reverse* of each other. We apply functions from left to right when pipelining
    and from right to left when composing. Thus, we can achieve the same result as
    with composition, by reversing the order of functions and doing pipelining instead;
    a very functional solution, which I really like!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样可以运行，但让我们寻找更好的解决方案--我们可以提供至少两种。第一种方法与流水线和组合工作*相反*有关。当我们进行流水线处理时，我们从左到右应用函数，而在组合时，我们从右到左应用函数。因此，我们可以通过颠倒函数的顺序并进行流水线处理来实现与组合相同的结果；这是一个非常实用的解决方案，我非常喜欢！
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The only tricky part is the usage of the spread operator before calling `pipeline()`.
    After reversing the `fns` array, we must once again spread its elements, to correctly
    call `pipeline()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一棘手的部分是在调用`pipeline()`之前使用展开运算符。在反转`fns`数组之后，我们必须再次展开其元素，以正确调用`pipeline()`。
- en: 'The other solution, less declarative, is by using `.reduceRight()` so instead
    of reversing the list of functions, we reverse the order of processing them:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太声明式的解决方案是使用`.reduceRight()`，所以我们不是反转函数列表，而是反转处理它们的顺序：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Why/how does this work? Let''s follow the inner working of this call. We can
    replace `pipeTwo()` with its definition, to make this clearer:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么/如何这个工作？让我们跟随这个调用的内部工作。我们可以用它的定义替换`pipeTwo()`，以使这更清晰：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: OK, let's see!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看！
- en: Since no initial value is provided, the first time `f()` is `removeNonAlpha()`
    and `g()` is `toUpperCase()`, so the first intermediate result is a function `(...args)
    => toUpperCase(removeNonAlpha(...args))`; let's call it `step1()`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有提供初始值，第一次`f()`是`removeNonAlpha()`，`g()`是`toUpperCase()`，所以第一个中间结果是一个函数`(...args)
    => toUpperCase(removeNonAlpha(...args))`；让我们称之为`step1()`。
- en: The second time, `f()` is `step1()` from the previous step, and `g()` is `splitInWords()`,
    so the new result is a function `(...args) => splitInWords(step1(...args)))`,
    which we can call `step2()`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次，`f()`是前一步的`step1()`，`g()`是`splitInWords()`，所以新的结果是一个函数`(...args) => splitInWords(step1(...args)))`，我们可以称之为`step2()`
- en: The third time around, in the same fashion, we get `(...args) => arrayToSet(step2(...args))))`,
    which we call `step3()`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次，以同样的方式，我们得到`(...args) => arrayToSet(step2(...args))))`，我们称之为`step3()`
- en: Finally, the last time, the result is `(...args) => setToList(step3(...args))`,
    a function `step4()`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次，结果是`(...args) => setToList(step3(...args))`，一个名为`step4()`的函数
- en: The final result correctly works out to be a function that receives `(...args)`,
    and starts by applying `removeNonAlpha()` to it, then `toUpperCase()`, and so
    on, finishing by applying `setToList()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果正确地成为一个接收`(...args)`的函数，并首先应用`removeNonAlpha()`，然后是`toUpperCase()`，以此类推，最后应用`setToList()`。
- en: It may be a surprise that we can also make this work with `.reduce()` -- can
    you see why? The reasoning is similar to what we did, so we'll let it be *an exercise
    for the reader*!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 也许令人惊讶的是，我们也可以用`.reduce()`来实现这个功能--你能看出为什么吗？推理与我们所做的类似，所以我们将其留给读者作为*一个练习*！
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After working out how `compose3()` works, you might want to write a version
    of `pipeline()` that uses `.reduceRight()`, just for symmetry, to round things
    out!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚`compose3()`的工作原理后，您可能想编写一个使用`.reduceRight()`的`pipeline()`版本，只是为了对称地完成一切！
- en: We can end this section by mentioning that in terms of testing and debugging,
    we can apply the same ideas as for debugging; only remember that composition *goes
    the other way*! We won't gain anything by providing yet more examples of the same
    kind, so let's consider now a common way of chaining operations when using objects
    and see if it's advantageous or not, given our growing FP knowledge and experience.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提及，就测试和调试而言，我们可以应用与调试相同的思想；只是记住组合*走另一条路*！我们不会通过提供更多相同类型的示例来获得任何好处，所以现在让我们考虑一种在使用对象时链接操作的常见方式，并看看它是否有利，鉴于我们不断增长的FP知识和经验。
- en: Testing composed functions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组合函数
- en: Let's finish this chapter by giving some consideration to testing for pipelined
    or composed functions. Given that the mechanism for both operations is similar,
    we will give examples for both of them and they won't differ, other than the logical
    differences due to the left-to-right or right-to-left order of function evaluation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑对流水线化或组合函数进行测试来完成本章。鉴于这两种操作的机制相似，我们将为它们都提供示例，它们不会有区别，除了由于函数评估的从左到右或从右到左的逻辑差异。
- en: 'When it comes to pipelining, we can start by seeing how to test the `pipeTwo()`
    function, because the setup will be similar for `pipeline()`. We need to create
    some spies and then check whether they were called the right number of times and
    whether they received the correct arguments each time. We will set the spies so
    they will provide a known answer to a call, so we can see if the output of a function
    becomes the input of the next in the pipeline:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线方面，我们可以从看如何测试`pipeTwo()`函数开始，因为设置将类似于`pipeline()`。我们需要创建一些间谍，然后检查它们是否被正确调用了正确次数，以及每次是否收到了正确的参数。我们将设置间谍，以便它们提供对调用的已知答案，这样我们就可以看到函数的输出是否成为管道中下一个函数的输入：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There isn't much to test, given that our function always receives two functions
    as parameters. The only difference between tests is that one shows a pipeline
    applied to a single argument and the other shows application to several arguments.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的函数始终接收两个函数作为参数，没有太多需要测试的。测试之间唯一的区别是一个显示了对单个参数应用的管道，另一个显示了对多个参数应用。
- en: 'Moving on to `pipeline()`, tests would be quite similar. We can, though, add
    a test for a single-function pipeline (border case!) and another with four functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`pipeline()`，测试会相当类似。不过，我们可以为单函数管道添加一个测试（边界情况！），另一个测试包含四个函数：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, for composition, the style is the same (except that the order of function
    evaluation is reversed) so let''s just see a single test -- I just changed the
    order of the functions in the preceding test:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于组合，风格是一样的（除了函数评估的顺序相反），所以让我们只看一个测试--我只是改变了前一个测试中函数的顺序：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, to test the `chainify()` function, I opted to use the `City` object
    I created above -- I didn''t want to mess with mocks, stubs, spies, and the like,
    but rather wanted to ensure that the code worked in normal conditions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试`chainify()`函数，我选择使用上面创建的`City`对象--我不想搞乱模拟、存根、间谍之类的东西，而是想确保代码在正常情况下能够工作：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The final result of all the tests is shown in the following figure:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试的最终结果显示在下图中：
- en: '![](assets/227d5add-a038-4d6d-815d-844f02424a28.png)Figure 8.3\. A successful
    run of testing for composed functions.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/227d5add-a038-4d6d-815d-844f02424a28.png)图8.3。组合函数测试的成功运行。'
- en: Questions
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '8.1\. **Headline capitalization**. Let''s define *headline-style capitalization*
    to require that a sentence is all written in lowercase, except the first letter
    of each word. (The real definition of this style is more complicated, so let''s
    simplify it for this question.) Write a function `headline(sentence)` that will
    receive a string as an argument and return an appropriately capitalized version.
    Spaces separate words. Build this function by composing smaller functions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1\. **标题大写**。让我们定义*标题风格大写*，要求一个句子全部用小写书写，除了每个单词的第一个字母。（这种风格的真正定义更复杂，所以让我们简化这个问题。）编写一个函数`headline(sentence)`，它将接收一个字符串作为参数，并返回一个适当大写的版本。空格分隔单词。通过组合较小的函数来构建这个函数：
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '8.2\. **Pending tasks**. A web service returns a result such as follows, showing,
    person by person, all their assigned tasks. Tasks may be finished (`done===true`)
    or pending (`done===false`). Your goal is to produce an array with the IDs of
    the pending tasks for a given person, identified by name, which should match the
    `responsible` field. Solve this by using composition or pipelining:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2\. **待办任务**。一个web服务返回一个结果，如下所示，逐个人显示他们所有分配的任务。任务可能已完成（`done===true`）或待办（`done===false`）。你的目标是为给定的人（通过名字识别）生成一个待办任务ID数组，该数组应该与`responsible`字段匹配。通过使用组合或管道解决这个问题：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Make sure your code doesn't throw an exception if, for example, the person you
    are looking for doesn't appear in the web service result!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代码不会抛出异常，例如，如果你要查找的人在web服务结果中没有出现！
- en: In the last chapter of the book, *Going Further On*, we will see a different
    way of solving this, by using `Maybe` monads, that will greatly simplify the problem
    of dealing with possibly missing data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后一章，*更进一步*，我们将看到另一种解决这个问题的方法，通过使用`Maybe`单子，这将大大简化处理可能缺失的数据的问题。
- en: 8.3\. **Thinking in abstract terms**. Suppose you are looking through somewhat
    old code and you find a function that looks like the following one. (I'm keeping
    names vague and abstract, so you can focus on the structure and not on the actual
    functionality.) Can you transform this to Pointfree style?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3\. **以抽象方式思考**。假设你正在查看一些旧代码，你发现一个函数看起来像下面这样。（我保持名称模糊和抽象，这样你可以专注于结构而不是实际功能。）你能把这个转换成Pointfree风格吗？
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen ways of creating new functions by joining several
    other functions in different ways, through pipelining (with a variant that we
    don't recommend, chaining) and composition.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了通过不同方式将几个其他函数连接起来创建新函数的方法，通过管道化（还有一个我们不推荐的变体，链式）和组合。
- en: In [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, we will move on to function design, and study the usage of recursion,
    which classically is a basic tool in functional programming and allows for very
    clean algorithm designs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)中，*设计函数 - 递归*，我们将继续进行函数设计，并学习递归的使用，这在函数式编程中经典上是一种基本工具，并且允许非常干净的算法设计。
