- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Design Patterns and .NET 5 Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式和.NET 5实现
- en: Design patterns can be defined as ready-to-use architectural solutions for common
    problems you encounter during software development. They are essential for understanding
    the .NET Core architecture and useful for solving ordinary problems that we face
    when designing any piece of software. In this chapter, we will look at the implementation
    of some design patterns. It is worth mentioning that this book does not explain
    all the known patterns we can use. The focus here is to explain the importance
    of studying and applying them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以被定义为常见问题的现成架构解决方案，在软件开发过程中遇到这些问题是必不可少的。它们对于理解.NET Core架构至关重要，并且对于解决我们在设计任何软件时面临的普通问题非常有用。在本章中，我们将看一些设计模式的实现。值得一提的是，本书并未解释我们可以使用的所有已知模式。重点在于解释学习和应用它们的重要性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding design patterns and their purpose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Understanding the available design patterns in .NET 5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解.NET 5中可用的设计模式
- en: By the end of this chapter, you will have learned about some of the use cases
    from **WWTravelClub** that you can implement with design patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学习到一些可以用设计模式实现的**WWTravelClub**的用例。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For completing this chapter, you will need the free Visual Studio 2019 Community
    Edition or better, with all the database tools installed, and a free Azure account.
    The *Creating an Azure account* subsection of *Chapter 1*, *Understanding the
    Importance of Software Architecture*, explains how to create one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要免费的Visual Studio 2019社区版或更高版本，安装了所有数据库工具，以及一个免费的Azure账户。*第1章*的*理解软件架构的重要性*中的*创建Azure账户*小节解释了如何创建账户。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的示例代码。
- en: Understanding design patterns and their purpose
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Deciding the design of a system is challenging, and the responsibility associated
    with this task is enormous. As software architects, we must always keep in mind
    that features such as great reusability, good performance, and good maintainability
    are important to deliver a good solution. This is where design patterns help and
    accelerate the design process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 决定系统设计是具有挑战性的，与此任务相关的责任是巨大的。作为软件架构师，我们必须始终牢记，诸如良好的可重用性、良好的性能和良好的可维护性等功能对于提供良好的解决方案至关重要。这就是设计模式帮助并加速设计过程的地方。
- en: 'As we mentioned previously, design patterns are solutions that have already
    been discussed and defined so that they can solve common software architectural
    problems. This approach grew in popularity after the release of the book *Design
    Patterns – Elements of Reusable Object-Oriented Software*, where the **Gang of
    Four** (**GoF**) divided these patterns into three types: creational, structural,
    and behavioral.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，设计模式是已经讨论和定义的解决常见软件架构问题的解决方案。这种方法在《设计模式-可复用面向对象软件的元素》一书发布后变得越来越受欢迎，**四人帮**（**GoF**）将这些模式分为三种类型：创建型、结构型和行为型。
- en: 'A little bit later, Uncle Bob introduced the SOLID principles to the developer
    community, giving us the opportunity to efficaciously organize the functions and
    data structures of each system. The SOLID design principles indicate how the components
    of software should be designed and connected. It is worth mentioning that, compared
    to the design patterns presented by GoF, the SOLID principles do not deliver code
    recipes. Instead, they give you the basic principles to follow when you design
    your solutions, keeping the software''s structure strong and reliable. They can
    be defined as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，Bob大叔向开发者社区介绍了SOLID原则，使我们有机会有效地组织每个系统的函数和数据结构。SOLID设计原则指示软件组件应该如何设计和连接。值得一提的是，与GoF提出的设计模式相比，SOLID原则并不提供代码配方。相反，它们给出了在设计解决方案时要遵循的基本原则，保持软件结构的强大和可靠。它们可以被定义如下：
- en: '**Single Responsibility**: A module or function should be responsible for a single
    purpose'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：一个模块或函数应该负责一个单一的目的'
- en: '**Open-Closed**: A software artifact should be open for extension but closed
    for modification'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：软件构件应该对扩展开放，但对修改关闭'
- en: '**Liskov Substitution**: The behavior of a program needs to remain unchanged
    when you substitute one of its components for another component that has been
    defined by a supertype of the primer object'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：当你用一个由原始对象的超类型定义的另一个组件替换一个组件时，程序的行为需要保持不变'
- en: '**Interface Segregation**: Creating huge interfaces will cause dependencies
    to occur while you are building concrete objects, but these are harmful to the
    system architecture'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：创建庞大的接口会导致依赖关系的发生，而在构建具体对象时，这对系统架构是有害的'
- en: '**Dependency Inversion**: The most flexible systems are the ones where object
    dependencies only refer to abstractions'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**：最灵活的系统是那些对象依赖仅指向抽象的系统'
- en: As technologies and software problems change, more patterns are conceived. The
    advance of cloud computing has brought a bunch of them, all of which can be found
    at [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/).
    The reason why new patterns emerge is related to the challenges we face when new
    solutions are developed. Today, availability, data management, messaging, monitoring,
    performance, scalability, resiliency, and security are aspects we must deal with
    when delivering cloud solutions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术和软件问题的变化，会产生更多的模式。云计算的发展带来了大量模式，所有这些模式都可以在[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)找到。新模式出现的原因与我们在开发新解决方案时面临的挑战有关。今天，可用性、数据管理、消息传递、监控、性能、可伸缩性、弹性和安全性是我们在交付云解决方案时必须处理的方面。
- en: 'The reason why you should always consider developing using design patterns
    is quite simple—as a software architect, you cannot spend time reinventing the
    wheel. However, there is another great reason for using and understanding them:
    you will find many of these patterns already implemented in .NET 5.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终考虑使用设计模式的原因非常简单——作为软件架构师，你不能花时间重新发明轮子。然而，使用和理解它们的另一个很好的原因是：你会发现许多这些模式已经在.NET
    5中实现了。
- en: In the next few subsections, we will cover some of the most well-known patterns.
    However, the idea of this chapter is to let you know that they exist and need
    to be studied so that you can accelerate and simplify your project. Moreover,
    each pattern will be presented with a C# code snippet so that you can easily implement
    them in your projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将介绍一些最著名的模式。然而，本章的目的是让你知道它们的存在，并且需要学习它们，以便加速和简化你的项目。此外，每个模式都将以C#代码片段的形式呈现，以便你可以在你的项目中轻松实现它们。
- en: Builder pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建造者模式
- en: There are cases where you will have a complex object with different behaviors
    due to its configuration. Instead of setting this object up while using it, you
    may want to decouple its configuration from its usage, using a customized configuration
    that is already built. This way, you have different representations of the instances
    you are building. This is where you should use the Builder pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你会有一个由于其配置而具有不同行为的复杂对象。你可能希望将该对象的配置与其使用分离，使用已经构建好的自定义配置。这样，你就有了正在构建的实例的不同表示。这就是你应该使用建造者模式的地方。
- en: 'The following class diagram shows the pattern that has been implemented for
    a scenario from this book''s use case. The idea behind this design choice is to
    simplify the way rooms from WWTravelClub are described:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的类图显示了为本书使用案例中的场景实现的模式。这个设计选择背后的想法是简化对WWTravelClub房间的描述方式：
- en: '![](img/B16756_11_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_01.png)'
- en: 'Figure 11.1: Builder pattern'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：建造者模式
- en: 'As shown in the following code, the code for this is implemented in a way where
    the configurations of the instances are not set in the main program. Instead,
    you just build the objects using the `Build()` method. This example is simulating
    the creation of different room styles (a single room and a family room) in WWTravelClub:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码所示，这个代码是以一种不在主程序中设置实例的配置的方式实现的。相反，你只需使用`Build()`方法构建对象。这个例子模拟了在WWTravelClub中创建不同房间样式（单人房和家庭房）的过程：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result of this implementation is quite simple but clarifies the reason
    why you need to implement a pattern:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的结果非常简单，但澄清了为什么需要实现模式：
- en: '![](img/B16756_11_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_02.png)'
- en: 'Figure 11.2: Builder pattern sample result'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：建造者模式示例结果
- en: As soon as you have the implementation, evolving this code becomes simpler and
    easier. For example, if you need to build a different style of room, you must
    just create a new builder for that type of room, and you will be able to use it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了实现，进化这段代码就变得更简单、更容易。例如，如果你需要构建不同风格的房间，你只需为该类型的房间创建一个新的建造者，然后你就可以使用它了。
- en: 'The reason why this implementation becomes quite simple is related to the usage
    of chaining methods, as we can see in the `Room` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现变得非常简单的原因与在`Room`类中使用链式方法有关：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Fortunately, if you need to increase the configuration settings for the product,
    all the concrete classes you used previously will be defined in the Builder interface
    and stored there so that you can update them with ease.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果需要增加产品的配置设置，之前使用的所有具体类都将在建造者接口中定义并存储在那里，以便你可以轻松更新它们。
- en: We will also see a great implementation of the Builder pattern in .NET 5 in
    the *Understanding the available design patterns in .NET 5* section. There, you
    will be able to understand how Generic Host was implemented using `HostBuilder`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在.NET 5中看到建造者模式的一个很好的实现，在*了解.NET 5中可用的设计模式*部分。在那里，你将能够了解如何使用`HostBuilder`实现了通用主机。
- en: Factory pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Factory pattern is useful in situations where you have multiple objects
    from the same abstraction, and you do not know which needs to be created by the
    time you start coding. This means you will have to create the instance according
    to a certain configuration or according to where the software is living now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式在有多个来自相同抽象的对象，并且在编码开始时不知道需要创建哪个对象的情况下非常有用。这意味着你将不得不根据特定的配置或软件当前所处的位置来创建实例。
- en: 'For instance, let us check out the WWTravelClub sample. Here, there is a user
    story that describes that this application will have customers from all over the
    world paying for their trips. However, in the real world, there are different
    payment services available for each country. The process of paying is similar
    for each country, but this system will have more than one payment service available.
    A good way to simplify this payment implementation is by using the Factory pattern.
    The following diagram shows the basic idea of its architectural implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看WWTravelClub示例。在这里，有一个用户故事描述了该应用程序将有来自世界各地的客户支付他们的旅行。然而，在现实世界中，每个国家都有不同的付款服务可用。每个国家的支付过程都类似，但该系统将有多个可用的付款服务。简化此付款实现的一种好方法是使用工厂模式。以下图表显示了其架构实现的基本思想：
- en: '![](img/B16756_11_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_03.png)'
- en: 'Figure 11.3: Factory pattern'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：工厂模式
- en: 'Notice that, since you have an interface that describes what the payment service
    for the application is, you can use the Factory pattern to change the concrete
    class according to the services that are available:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于您有一个描述应用程序的付款服务的接口，您可以使用工厂模式根据可用的服务更改具体类：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once again, the service's usage has been simplified due to the implemented pattern.
    If you had to use this code in a real-world application, you would change the
    instance's behavior by defining the service you need in the Factory pattern.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于实现的模式，服务的使用变得更加简单。如果您必须在真实世界的应用程序中使用此代码，您可以通过在工厂模式中定义所需的服务来更改实例的行为。
- en: Singleton pattern
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: When you implement Singleton in your application, you will have a single instance
    of the object implemented in the entire solution. This can be considered as one
    of the most used patterns in every application. The reason is simple—there are
    many use cases where you need some classes to have just one instance. Singletons
    solve this by providing a better solution than a global variable does.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用程序中实现单例时，您将在整个解决方案中实现对象的单个实例。这可以被认为是每个应用程序中最常用的模式之一。原因很简单-有许多用例需要一些类只有一个实例。单例通过提供比全局变量更好的解决方案来解决这个问题。
- en: 'In the Singleton pattern, the class is responsible for creating and delivering
    a single object that will be used by the application. In other words, the Singleton
    class creates a single instance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例模式中，类负责创建和提供应用程序将使用的单个对象。换句话说，单例类创建一个单一实例：
- en: '![](img/B16756_11_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_04.png)'
- en: 'Figure 11.4: Singleton pattern'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：单例模式
- en: 'To do so, the object that is created is `static` and is delivered in a static
    property or method. The following code implements the Singleton pattern, which
    has a `Message` property and a `Print()` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，创建的对象是`static`，并在静态属性或方法中提供。以下代码实现了具有`Message`属性和`Print()`方法的单例模式：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Its usage is simple—you just need to call the static property every time you
    need to use the Singleton object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用很简单-每次需要使用单例对象时，只需调用静态属性：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One of the places where you may use this pattern is when you need to deliver
    the app configuration in a way that can be easily accessed from anywhere in the
    solution. For instance, let us say you have some configuration parameters that
    are stored in a table that your app needs to query at several decision points.
    Instead of querying the configuration table directly, you can create a Singleton
    class to help you:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能使用此模式的一个场景是需要以可以轻松从解决方案的任何地方访问的方式提供应用程序配置。例如，假设您有一些配置参数存储在应用程序需要在多个决策点查询的表中。您可以创建一个单例类来帮助您，而不是直接查询配置表。
- en: '![](img/B16756_11_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_05.png)'
- en: 'Figure 11.5: Singleton pattern usage'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：单例模式的使用
- en: 'Moreover, you will need to implement a cache in this Singleton, thus improving
    the performance of the system, since you will be able to decide whether the system
    will check each configuration in the database every time it needs it or if the
    cache will be used. The following screenshot shows the implementation of the cache
    where the configuration is loaded every 5 seconds. The parameter that is being
    read in this case is just a random number:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要在此单例中实现缓存，从而提高系统的性能，因为您可以决定系统是否每次需要时都会检查数据库中的每个配置，还是使用缓存。以下屏幕截图显示了缓存的实现，其中配置每5秒加载一次。在这种情况下读取的参数只是一个随机数：
- en: '![](img/B16756_11_06.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_06.png)'
- en: 'Figure 11.6: Cache implementation inside the Singleton pattern'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：单例模式内部的缓存实现
- en: This is great for the application's performance. Besides, using parameters in
    several places in your code is simpler since you do not have to create configuration
    instances everywhere in the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应用程序的性能非常有利。此外，在代码中的多个地方使用参数更简单，因为您不必在代码的各处创建配置实例。
- en: It is worth mentioning that due to the dependency injection implementation in
    .NET 5, Singleton pattern usage became less common, since you can set dependency
    injection to handle your Singleton objects. We will cover dependency injection
    in .NET 5 in later sections of this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，由于.NET 5中的依赖注入实现，单例模式的使用变得不太常见，因为您可以设置依赖注入来处理您的单例对象。我们将在本章的后面部分介绍.NET
    5中的依赖注入。
- en: Proxy pattern
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object. One of the biggest reasons why you should do this is related
    to the cost of creating the object that is being controlled. For instance, if
    the controlled object takes too long to be created or consumes too much memory,
    a proxy can be used to guarantee that the largest part of the object will only
    be created when it is required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式用于在需要提供控制对另一个对象访问的对象时使用。为什么要这样做的最大原因之一与创建被控制对象的成本有关。例如，如果被控制的对象创建时间过长或消耗过多内存，可以使用代理来确保只有在需要时才会创建对象的大部分。
- en: 'The following class diagram is of a **Proxy** pattern implementation for loading
    pictures from **Room**, but only when requested:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图是**代理**模式实现从**Room**加载图片的示例，但只有在请求时：
- en: '![](img/B16756_11_07.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_07.png)'
- en: 'Figure 11.7: Proxy pattern implementation'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：代理模式实现
- en: 'The client of this proxy will request its creation. Here, the proxy will only
    gather basic information (`Id`, `FileName`, and `Tags`) from the real object and
    will not query `PictureData`. When `PictureData` is requested, the proxy will
    load it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该代理的客户端将请求其创建。在这里，代理只会从真实对象中收集基本信息（`Id`，`FileName`和`Tags`），而不会查询`PictureData`。当请求`PictureData`时，代理将加载它：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `PictureData` is requested again, since image data is already in place,
    the proxy will guarantee that image reloading will not be repeated. The following
    screenshot shows the result of running the preceding code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次请求`PictureData`，由于图像数据已经就位，代理将保证不会重复加载图像。以下截图显示了运行上述代码的结果：
- en: '![](img/B16756_11_08.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_08.png)'
- en: 'Figure 11.8: Proxy pattern result'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：代理模式结果
- en: 'This technique can be referred to as another well-known pattern: **lazy loading**.
    In fact, the Proxy pattern is a way of implementing lazy loading. Another approach
    for implementing lazy loading is the usage of the `Lazy<T>` type. For instance,
    in Entity Framework Core 5, as discussed in *Chapter 8*, *Interacting with Data
    in C# – Entity Framework Core*, you can turn on lazy loading using proxies. You
    can find out more about this at [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以称为另一个众所周知的模式：**惰性加载**。事实上，代理模式是实现惰性加载的一种方式。实现惰性加载的另一种方法是使用`Lazy<T>`类型。例如，在Entity
    Framework Core 5中，正如*第8章*，*在C#中与数据交互-Entity Framework Core*中讨论的那样，你可以使用代理打开惰性加载。你可以在[https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading)找到更多信息。
- en: Command pattern
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: There are many cases where you need to execute a **command** that will affect
    the behavior of an object. The Command pattern can help you with this by encapsulating this
    kind of request in an object. The pattern also describes how to handle undo/redo
    support for the request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，你需要执行一个会影响对象行为的**命令**。命令模式可以通过封装这种请求到一个对象中来帮助你。该模式还描述了如何处理请求的撤销/重做支持。
- en: For instance, let us imagine that, on the WWTravelClub website, users might
    have the ability to evaluate the packages by specifying whether they like, dislike,
    or even love their experience.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象一下，在WWTravelClub网站上，用户可能有能力通过指定他们喜欢、不喜欢，甚至是喜爱他们的体验来评估套餐。
- en: 'The following class diagram is an example of what can be implemented to create
    this rating system with the Command pattern:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图是一个示例，可以实现使用命令模式创建此评分系统：
- en: '![](img/B16756_11_09.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_09.png)'
- en: 'Figure 11.9: Command pattern'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：命令模式
- en: Notice the way this pattern works—if you need a different command, such as `Hate`,
    you do not need to change the code and classes that use the command. The `Undo`
    method can be added in a similar way to the `Redo` method. The full code sample
    for this is available in this book's GitHub repository.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种模式的工作方式——如果你需要一个不同的命令，比如`Hate`，你不需要更改使用命令的代码和类。`Undo`方法可以以类似的方式添加到`Redo`方法。这方面的完整代码示例可以在本书的GitHub存储库中找到。
- en: It might also help to mention that ASP.NET Core MVC uses the command pattern
    for its `IActionResult` hierarchy. Besides, the business operation described in
    *Chapter 12*, *Understanding the Different Domains in Software Solutions*, will
    make use of this pattern to execute business rules.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，ASP.NET Core MVC使用命令模式来处理其`IActionResult`层次结构。此外，*第12章*，*理解软件解决方案中的不同领域*中描述的业务操作将使用该模式来执行业务规则。
- en: Publisher/Subscriber pattern
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布者/订阅者模式
- en: Providing information from an object to a group of other objects is common in
    all applications. The Publisher/Subscriber pattern is almost mandatory when there
    is a large volume of components (subscribers) that will receive a message containing
    the information that was sent by the object (publisher).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的信息提供给一组其他对象在所有应用程序中都很常见。当有大量组件（订阅者）将接收包含对象发送的信息的消息时，发布者/订阅者模式几乎是必不可少的。
- en: 'The concept here is quite simple to understand and is shown in the following
    diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的概念非常简单易懂，并且在下图中有所展示：
- en: '![](img/B16756_11_10.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_10.png)'
- en: 'Figure 11.10: Publisher/Subscriber sample case'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：发布者/订阅者示例案例
- en: When you have an indefinite number of different possible subscribers, it is
    essential to decouple the component that broadcasts information from the components
    that consume it. The Publisher/Subscriber pattern does this for us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有无数个可能的订阅者时，将广播信息的组件与消费信息的组件解耦是至关重要的。发布者/订阅者模式为我们做到了这一点。
- en: Implementing this pattern is complex, since distributing environments is not
    a trivial task. Therefore, it is recommended that you consider already existing
    technologies for implementing the message broker that connects the input channel
    to the output channels, instead of building it from scratch. Azure Service Bus
    is a reliable implementation of this pattern, so all you need to do is connect
    to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这种模式是复杂的，因为分发环境并不是一个简单的任务。因此，建议您考虑已经存在的技术来实现连接输入通道和输出通道的消息代理，而不是从头开始构建它。Azure
    Service Bus是这种模式的可靠实现，所以你只需要连接到它。
- en: RabbitMQ, which we have mentioned in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*, is another service that can be used to implement
    a message broker, but it is a lower-level implementation of the pattern and requires
    several related tasks, such as retries, in case errors have to be coded manually.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*中提到的RabbitMQ，*将微服务架构应用于企业应用程序*，是另一个可以用来实现消息代理的服务，但它是该模式的较低级别实现，并且需要进行多个相关任务，例如手动编码重试以处理错误。
- en: Dependency Injection pattern
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: The Dependency Injection pattern is considered a good way to implement the Dependency
    Inversion principle. One useful side effect is that it forces any implementation
    to follow all the other SOLID principles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式被认为是实现依赖反转原则的一种好方法。一个有用的副作用是，它强制任何实现遵循所有其他SOLID原则。
- en: The concept is quite simple. Instead of creating instances of the objects that
    the component depends on, you just need to define their dependencies, declare
    their interfaces, and enable the reception of the objects by **injection**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常简单。您只需要定义它们的依赖关系，声明它们的接口，并通过**注入**启用对象的接收，而不是创建组件所依赖的对象的实例。
- en: 'There are three ways to perform dependency injection:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以执行依赖注入：
- en: Use the constructor of the class to receive the objects
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类的构造函数接收对象
- en: Tag some class properties to receive the objects
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一些类属性以接收对象
- en: Define an interface with a method to inject all the necessary components
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个具有注入所有必要组件的方法的接口
- en: 'The following diagram shows the implementation of the Dependency Injection
    pattern:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了依赖注入模式的实现：
- en: '![](img/B16756_11_11.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_11_11.png)'
- en: 'Figure 11.11: Dependency Injection pattern'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：依赖注入模式
- en: Apart from this, Dependency Injection can be used with an **Inversion of Control**
    (**IoC**) container. This container enables the automatic injection of dependencies
    whenever they are asked for. There are several IoC container frameworks available
    on the market, but with .NET Core, there is no need to use third-party software
    since it contains a set of libraries to solve this in the `Microsoft.Extensions.DependencyInjection`
    namespace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，依赖注入还可以与**控制反转**（**IoC**）容器一起使用。该容器在被要求时自动注入依赖项。市场上有几个IoC容器框架可用，但是在.NET
    Core中，无需使用第三方软件，因为它包含一组库来解决`Microsoft.Extensions.DependencyInjection`命名空间中的问题。
- en: 'This IoC container is responsible for creating and disposing of the objects
    that are requested. The implementation of Dependency Injection is based on constructor
    types. There are three options for the injected component''s lifetime:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个IoC容器负责创建和处理被请求的对象。依赖注入的实现基于构造函数类型。对于被注入组件的生命周期，有三个选项：
- en: '**Transient**: The objects are created each time they are requested.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**：每次请求时都会创建对象。'
- en: '**Scoped**: The objects are created for each scope defined in the application.
    In a web app, a **scope** is identified with a web request.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：为应用程序中定义的每个作用域创建对象。在Web应用程序中，**作用域**是通过Web请求标识的。'
- en: '**Singleton**: Each object has the same application lifetime, so a single object
    is reused to serve all the requests for a given type. If your object contains
    state, you should not use this one, unless it is thread-safe.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：每个对象具有相同的应用程序生命周期，因此重用单个对象来为给定类型的所有请求提供服务。如果您的对象包含状态，则不应使用此对象，除非它是线程安全的。'
- en: The way you are going to use these options depends on the business rules of
    the project you are developing. It is also a matter of how you are going to register
    the services of the application. You need to be careful in deciding the correct
    one, since the behavior of the application will change according to the type of
    object you are injecting.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您将如何使用这些选项取决于您正在开发的项目的业务规则。这也取决于您将如何注册应用程序的服务。在决定正确的选项时，您需要小心，因为应用程序的行为将根据您注入的对象类型而改变。
- en: Understanding the available design patterns in .NET 5
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解.NET 5中可用的设计模式
- en: As we discovered in the previous sections, C# allows us to implement any of
    the patterns. .NET 5 provides many implementations in its SDK that follow all
    the patterns we have discussed, such as Entity Framework Core proxy lazy loading.
    Another good example that has been available since .NET Core 2.1 is .NET Generic
    Host.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们发现C#允许我们实现任何模式。 .NET 5在其SDK中提供了许多实现，遵循我们讨论过的所有模式，例如Entity Framework
    Core代理延迟加载。自.NET Core 2.1以来可用的另一个很好的例子是.NET通用主机。
- en: In *Chapter 15*, *Presenting ASP.NET Core MVC*, we will detail the hosting that's
    available for web apps in .NET 5\. This web host helps us since the startup of
    the app and lifetime management is set up alongside it. The idea of .NET Generic
    Host is to enable this pattern for applications that do not need HTTP implementation.
    With this Generic Host, any .NET Core program can have a startup class where we
    can configure the dependency injection engine. This can be useful for creating
    multi-service apps.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第15章*中，*介绍ASP.NET Core MVC*，我们将详细介绍.NET 5中Web应用程序可用的托管。这个Web主机在应用程序的启动和生命周期管理方面对我们很有帮助。.NET通用主机的想法是为不需要HTTP实现的应用程序启用这种模式。通过这个通用主机，任何.NET
    Core程序都可以有一个启动类，我们可以在其中配置依赖注入引擎。这对于创建多服务应用程序非常有用。
- en: You can find out more about .NET Generic Host at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host),
    which contains some sample code and is the current recommendation from Microsoft.
    The code provided in the GitHub repository is simpler, but it focuses on the creation
    of a console app that can run a service for monitoring. The great thing about
    this is the way the console app is set up to run, where the builder configures
    the services that will be provided by the application, and the way logging will
    be managed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)找到更多关于.NET通用主机的信息，其中包含一些示例代码，并且是微软目前的推荐。GitHub存储库中提供的代码更简单，但它侧重于创建一个可以运行监视服务的控制台应用程序。这种方法的伟大之处在于控制台应用程序的设置方式，生成器配置了应用程序提供的服务，以及日志记录的管理方式。
- en: 'This is shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中显示：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code gives us an idea of how .NET Core uses design patterns. Using
    the Builder pattern, .NET Generic Host allows you to set the classes that will
    be injected as services. Apart from this, the Builder pattern helps you configure
    some other features, such as the way logs will be shown/stored. This configuration
    allows the services to inject `ILogger<out TCategoryName>` objects into any instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码让我们了解了.NET Core如何使用设计模式。使用生成器模式，.NET通用主机允许您设置将作为服务注入的类。除此之外，生成器模式还帮助您配置其他一些功能，例如日志的显示/存储方式。此配置允许服务将`ILogger<out
    TCategoryName>`对象注入到任何实例中。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we understood why design patterns help with the maintainability
    and reusability of the parts of the system you are building. We also looked at
    some typical use cases and code snippets that you can use in your projects. Finally,
    we presented .NET Generic Host, which is a good example of how .NET uses design
    patterns to enable code reusability and enforce best practices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了为什么设计模式有助于系统部分的可维护性和可重用性。我们还看了一些典型的用例和代码片段，您可以在项目中使用。最后，我们介绍了.NET通用主机，这是.NET使用设计模式实现代码重用和执行最佳实践的一个很好的例子。
- en: All this content will help you while architecting new software or even maintaining
    an existing one, since design patterns are already-known solutions for some real-life
    problems in software development.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容都将帮助您在设计新软件或维护现有软件时，因为设计模式已经是软件开发中一些现实问题的已知解决方案。
- en: In the next chapter, we will cover the domain-driven design approach. We will
    also learn how to use the SOLID design principles so that we can map different
    domains to our software solutions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍领域驱动设计方法。我们还将学习如何使用SOLID设计原则，以便将不同的领域映射到我们的软件解决方案中。
- en: Questions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are design patterns?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: What is the difference between design patterns and design principles?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计模式和设计原则之间有什么区别？
- en: When is it a good idea to implement the Builder pattern?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现生成器模式是一个好主意？
- en: When is it a good idea to implement the Factory pattern?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现工厂模式是一个好主意？
- en: When is it a good idea to implement the Singleton pattern?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现单例模式是一个好主意？
- en: When is it a good idea to implement the Proxy pattern?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现代理模式是一个好主意？
- en: When is it a good idea to implement the Command pattern?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现命令模式是一个好主意？
- en: When is it a good idea to implement the Publisher/Subscriber pattern?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现发布者/订阅者模式是一个好主意？
- en: When is it a good idea to implement the Dependency Injection pattern?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时实现依赖注入模式是一个好主意？
- en: Further reading
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and websites where you can find out more regarding
    what was covered in this chapter:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些书籍和网站，您可以在其中找到有关本章内容的更多信息：
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*,
    Martin, Robert C., Pearson Education, 2018.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*，Martin,
    Robert C., Pearson Education, 2018.'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, Erica Gamma
    et al., Addison-Wesley, 1994.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Design Patterns: Elements of Reusable Object-Oriented Software*，Erica Gamma等人，Addison-Wesley，1994年。'
- en: '*Design Principles and Design Patterns*, Martin, Robert C., 2000.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Design Principles and Design Patterns*，Martin, Robert C., 2000.'
- en: 'If you need to get more info about design patterns and architectural principles,
    please check these links:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要获取有关设计模式和架构原则的更多信息，请查看以下链接：
- en: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-pr)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-pr)'
- en: 'If you want to check specific cloud design patterns, you can find them at:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想查看特定的云设计模式，可以在以下链接找到：
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/)'
- en: 'If you want to better understand the idea of Generic Host, follow this link:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想更好地理解通用主机的概念，请访问此链接：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host
- en: 'There is a very good explanation about service bus messaging at this link:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此链接中有关于服务总线消息传递的非常好的解释：
- en: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-su)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-su)'
- en: 'You can learn more about dependency injection by checking these links:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过查看这些链接来了解更多关于依赖注入的信息：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
- en: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
