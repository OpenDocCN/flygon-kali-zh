- en: Deploying Our Microservices Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker部署我们的微服务
- en: In this chapter, we will start using Docker and put our microservices into containers!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用Docker，并将我们的微服务放入容器中！
- en: By the end of this chapter, we will have run fully automated tests of our microservice
    landscape that start all our microservices as Docker containers, requiring no
    other infrastructure than a Docker engine. We will have also run a number of tests
    to verify that the microservices work together as expected and finally shut down
    all the microservices, leaving no traces of the tests we executed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将对我们的微服务架构运行完全自动化的测试，启动所有微服务作为Docker容器，不需要其他基础设施，只需一个Docker引擎。我们还将运行一些测试来验证微服务按预期一起工作，并最终关闭所有微服务，不留下我们执行的测试的任何痕迹。
- en: Being able to test a number of cooperating microservices in this way is very
    useful. As developers, we can verify that it works on our local developer machines.
    We can also run exactly the same tests in a build server to automatically verify
    that changes to the source code won't break the tests at a system level. Additionally,
    we don't need to have a dedicated infrastructure allocated to run these types
    of tests. In the upcoming chapters, we will see how we can add databases and queue
    managers to our test landscape, all of which will run as Docker containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式测试一系列合作的微服务非常有用。作为开发人员，我们可以验证它在我们的本地开发机器上是否有效。我们还可以在构建服务器上运行完全相同的测试，自动验证对源代码的更改不会在系统级别破坏测试。此外，我们无需专门的基础设施来运行这些类型的测试。在接下来的章节中，我们将看到如何将数据库和队列管理器添加到我们的测试架构中，所有这些都将作为Docker容器运行。
- en: This does not, however, replace the need for automated unit and integrations
    tests, which test individual microservices in isolation. They are as important
    as ever.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不取代自动化单元测试和集成测试的需要，这些测试在隔离的情况下测试单个微服务。它们仍然像以往一样重要。
- en: For production usage, as we mentioned earlier in this book, we need a container
    orchestrator such as Kubernetes. We will go back to container orchestrators and
    Kubernetes later in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产使用，正如本书前面提到的，我们需要像Kubernetes这样的容器编排器。我们将在本书的后面回到容器编排器和Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to Docker.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker简介。
- en: Docker and Java. Java hasn't been very friendly to containers historically,
    but that changed with Java 10\. Let's see how Docker and Java fit together on
    this topic!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和Java。历史上，Java对容器并不友好，但随着Java 10的改变，情况也有所改善。让我们看看Docker和Java在这个主题上是如何结合的！
- en: Using Docker with one microservice.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker管理一个微服务。
- en: Managing a landscape of microservices using Docker Compose.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose管理微服务架构。
- en: Testing them all together automatically.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动测试它们全部一起运行。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave but should be straightforward to modify if you want to run
    them on another platform such as Linux or Windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在使用macOS Mojave的MacBook Pro上运行的，但如果您想在其他平台（如Linux或Windows）上运行它们，应该很容易修改。
- en: Apart from the technical requirements from the previous chapter, we need to
    have Docker installed. Docker Community Edition can be downloaded from [https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community)[.](https://store.docker.com/search?type=edition&offering=community)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一章的技术要求外，我们需要安装Docker。可以从[https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community)下载Docker社区版。
- en: 'To be able to run the examples in this book, it is recommended that you configure
    Docker so that you can use all the CPUs except one (allocating all CPUs to Docker
    can make the computer unresponsive when tests are running) and at least 6 GB of
    memory. This can be configured in the Advanced tab in the Preferences settings
    for Docker, as illustrated by the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中的示例，建议您配置Docker，以便可以使用除一个CPU之外的所有CPU（将所有CPU分配给Docker可能会在运行测试时使计算机无响应），并且至少6GB的内存。这可以在Docker的首选项设置的高级选项卡中进行配置，如下截图所示：
- en: '![](img/5fe1ee81-076f-4652-b550-bd63ba45cc3e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fe1ee81-076f-4652-b550-bd63ba45cc3e.png)'
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter04)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行本书中描述的命令，请将源代码下载到一个文件夹，并设置一个环境变量`$BOOK_HOME`，指向该文件夹。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested to run on Java 12\. This
    chapter uses Spring Boot 2.1.0 (and Spring 5.1.2), the latest available version
    of Spring Boot at the time of writing this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并经过测试可在Java 12上运行。本章使用的是Spring Boot 2.1.0（和Spring 5.1.2），这是撰写本章时可用的最新版本的Spring
    Boot。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter04` but
    in many cases have been edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter04`中的源代码，但在许多情况下已经进行了编辑，以删除源代码的无关部分，如注释、导入和日志语句。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add support for Docker, you can compare
    it with the source code for [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml),
    *Creating a Set of Cooperating Microservices*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter03/2-basic-rest-services` and `$BOOK_HOME/Chapter04`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章对源代码所做的更改，也就是说，看看为Docker添加支持需要做什么，你可以将其与[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)的源代码进行比较，*创建一组协作微服务*。你可以使用你喜欢的`diff`工具比较这两个文件夹，`$BOOK_HOME/Chapter03/2-basic-rest-services`和`$BOOK_HOME/Chapter04`。
- en: Introduction to Docker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: 'As we already mentioned in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml),
    *Introduction to Spring Boot*, Docker made the concept of containers as a lightweight
    alternative to virtual machines very popular in 2013\. Containers are actually
    processed in a Linux host that uses Linux namespaces to provide isolation between
    containers of global system resources, such as users, processes, filesystems,
    and networking. **Linux Control Groups** (also knows as **cgroups**) are used
    to limit the amount of CPU and memory that a container is allowed to consume.
    Compared to a virtual machine that uses a hypervisor to run a complete copy of
    an operating system in each virtual machine, the overhead in a container is a
    fraction of the overhead in a virtual machine. This leads to much faster startup
    times and significantly lower overhead in terms of CPU and memory usage. The isolation
    that''s provided for a container, however, is not considered to be as secure as
    the isolation that''s provided for a virtual machine. With the release of Windows
    Server 2016 and Windows 10 Pro (1607 Anniversary Update), Microsoft supports the
    usage of Docker on Windows as well. Take a look at the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml)中已经提到的，*Spring Boot简介*，Docker在2013年将容器的概念作为虚拟机的轻量替代品而广泛流行。容器实际上是在使用Linux命名空间提供容器之间的隔离的Linux主机中进行处理的，这些隔离包括全局系统资源，如用户、进程、文件系统和网络。**Linux控制组**（也称为**cgroups**）用于限制容器允许消耗的CPU和内存量。与在每个虚拟机中运行完整操作系统副本的虚拟机相比，容器中的开销是虚拟机中开销的一小部分。这导致启动时间更快，CPU和内存使用方面的开销显著降低。然而，容器提供的隔离并不被认为与虚拟机提供的隔离一样安全。随着Windows
    Server 2016和Windows 10 Pro（1607周年更新）的发布，微软也支持在Windows上使用Docker。看一下下面的图表：
- en: '![](img/caee1a35-71e9-4b6c-953f-b00a2d6eaca3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caee1a35-71e9-4b6c-953f-b00a2d6eaca3.png)'
- en: The preceding diagram illustrates the difference between the resource usage
    of virtual machines and containers, visualizing that the same type of server can
    run significantly more containers than virtual machines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表说明了虚拟机和容器的资源使用之间的差异，可视化显示了相同类型的服务器可以运行比虚拟机多得多的容器。
- en: Running our first Docker commands
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个Docker命令
- en: 'Let''s try to start a container by launching an Ubuntu server in one using
    Docker''s `run` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用Docker的`run`命令在一个容器中启动Ubuntu服务器：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the preceding command, we ask Docker to create a container that runs Ubuntu,
    based on the latest version that's available of the official Docker image for
    Ubuntu. The `-it` option is used so that we can interact with the container using
    Terminal, and the `--rm` option tells Docker to remove the container once we exit
    the Terminal session; otherwise, the container will remain in the Docker engine
    with an `Exited` state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述命令，我们要求Docker创建一个运行Ubuntu的容器，基于Ubuntu官方Docker镜像的最新版本。使用`-it`选项是为了我们可以使用终端与容器进行交互，`--rm`选项告诉Docker在我们退出终端会话后删除容器；否则，容器将以`Exited`状态保留在Docker引擎中。
- en: The first time we use a Docker image that we haven't built ourselves, Docker
    will download it from a Docker registry, which is Docker Hub by default ([https://hub.docker.com](https://hub.docker.com)).
    This will take some time, but for subsequent usage of that Docker image, the container
    will start in just a few seconds!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用我们没有自己构建的Docker镜像时，Docker会从Docker注册表（默认为Docker Hub）下载，这会花费一些时间，但对于后续使用该Docker镜像，容器将在几秒钟内启动！
- en: 'Once the Docker image has been downloaded and the container has been started
    up, the Ubuntu server should respond with a prompt such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Docker镜像被下载并且容器启动起来，Ubuntu服务器应该会响应一个提示，比如下面这样：
- en: '![](img/39044aaf-927e-4210-9731-1a3f10fedd10.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39044aaf-927e-4210-9731-1a3f10fedd10.png)'
- en: 'We can try out the container by asking what version of Ubuntu it runs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过询问Ubuntu运行的版本来尝试容器：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It should respond with something like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该会回应类似以下的内容：
- en: '![](img/60a69639-0969-4d0f-ab2c-f8a2582d51eb.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a69639-0969-4d0f-ab2c-f8a2582d51eb.png)'
- en: We can leave the container with an `exit` command and verify that the Ubuntu
    container no longer exits with the `docker ps -a` command. We need to use the `-a` option
    to see stopped containers; otherwise, only running containers are displayed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`exit`命令离开容器，并使用`docker ps -a`命令验证Ubuntu容器不再以`Exited`状态退出。我们需要使用`-a`选项来查看已停止的容器；否则，只会显示正在运行的容器。
- en: 'If you favor CentOS over Ubuntu, feel free to try the same with the `docker
    run --rm -it centos` command. Once the CoreOS server has started running in its
    container you can, for example, ask what version of CoreOS that it runs with the `cat
    /etc/redhat-release` command. It should respond with something like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢CentOS而不是Ubuntu，可以尝试使用`docker run --rm -it centos`命令。一旦CoreOS服务器在其容器中开始运行，你可以通过`cat
    /etc/redhat-release`命令询问它运行的CoreOS版本。它应该会回应类似以下的内容：
- en: '![](img/0bc608f2-03e6-40ec-a0b4-d343d9eff2b3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bc608f2-03e6-40ec-a0b4-d343d9eff2b3.png)'
- en: Leave the container with the `exit` command to remove it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exit`命令离开容器以删除它。
- en: 'If, at some point, you find that you have a lot of unwanted containers in the
    Docker engine and you want to get a clean sheet, that is, get rid of them all,
    you can run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时候，您发现Docker引擎中有很多不需要的容器，并且想要清理干净，即摆脱它们，您可以运行以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `docker rm -f` command stops and removes the containers whose container
    IDs are specified to the command. The `docker ps -aq` command lists the container
    IDs of all the running and stopped containers in the Docker engine. The `-q` option
    reduces the output from the `docker ps` command so that it only lists the container
    IDs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker rm -f`命令停止并删除指定容器ID的容器。`docker ps -aq`命令列出Docker引擎中所有正在运行和停止的容器的容器ID。`-q`选项将`docker
    ps`命令的输出减少，以便仅列出容器ID。'
- en: After understanding what Docker is, next we can move on to understand the problems
    which we might face while running Java in Docker.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Docker是什么之后，接下来我们可以继续了解在Docker中运行Java时可能会遇到的问题。
- en: Challenges with running Java in Docker
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行Java的挑战
- en: When it comes to Java, over the past few years, there have been a number of
    attempts to get Java working in Docker in a good way. Currently, the official
    Docker image for Java is based on OpenJDK: [https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/).
    We will use Java SE 12 with the Docker tag `openjdk:12.0.2`, that is, Java SE
    v12.0.2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就Java而言，过去几年来，有许多尝试让Java以良好的方式在Docker中运行。目前，Java的官方Docker镜像基于OpenJDK：[https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/)。我们将使用带有Docker标签`openjdk:12.0.2`的Java
    SE 12，即Java SE v12.0.2。
- en: Java has historically not been very good at honoring the quotas specified for
    a Docker container using Linux cgroups; it has simply ignored these settings.
    So, instead of allocating memory inside the JVM in relation to the memory available
    in the container, Java allocated memory as if it had access to all the memory
    in the Docker host, which obviously isn't good! In the same way, Java allocated
    CPU-related resources such as thread pools in relation to the total number of
    available CPU cores in the Docker host instead of the number of CPU cores that
    were made available for the container JVM was running in. In Java SE 9, some initial
    support was provided, which was also back-ported to later versions of Java SE
    8\. In Java 10, however, much-improved support for CPU and memory constraints
    was put in place.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Java在使用Linux cgroups为Docker容器指定配额方面历来表现不佳；它简单地忽略了这些设置。因此，Java不是根据容器中可用的内存分配内部JVM内存，而是像访问Docker主机中的所有内存一样分配内存，这显然是不好的！同样，Java分配CPU相关资源（如线程池）时，也是根据Docker主机中可用的CPU核心总数而不是为容器JVM提供的CPU核心数量。在Java
    SE 9中，提供了一些初始支持，这也被回溯到了Java SE 8的后续版本。然而，在Java 10中，对CPU和内存约束的支持得到了很大的改进。
- en: Let's try it out!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下！
- en: First, we will try out Java commands locally, without Docker, since that tells
    us how much memory and the number of CPU cores that the JVM sees. Next, we will
    try the commands in Docker using Java SE 12 to verify that it honors the constraints
    we set on the Docker container it runs in. Finally, we will also try out a Java
    SE 9 container and see how it fails to honor the constraints and what problems
    it can result in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在本地尝试Java命令，不使用Docker，因为这告诉我们JVM看到了多少内存和CPU核心的数量。接下来，我们将在Docker中使用Java
    SE 12尝试这些命令，以验证它是否遵守我们在Docker容器中运行的约束。最后，我们还将尝试Java SE 9容器，看看它如何无法遵守约束以及可能导致的问题。
- en: Java without Docker
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有Docker的Java
- en: Before we jump in to Docker, let's try the Java commands without Docker to familiarize
    ourselves with the Java commands!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入Docker之前，让我们尝试一下不使用Docker的Java命令，以熟悉Java命令！
- en: 'Let''s start by finding out how many available processors, that is, CPU cores,
    Java sees when running outside of Docker. We can do this by sending the `Runtime.getRuntime().availableprocessors()` Java
    statement to the Java CLI tool `jshell`, like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先找出在Docker之外运行时Java看到的可用处理器数量，即CPU核心。我们可以通过将`Runtime.getRuntime().availableprocessors()`
    Java语句发送到Java CLI工具`jshell`来实现这一点，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`jshell` requires Java SE 9 or later!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`jshell`需要Java SE 9或更高版本！'
- en: 'On my machine, I get the following response:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我得到以下响应：
- en: '![](img/47ae0858-fb1f-43ec-988a-303e04880a4d.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47ae0858-fb1f-43ec-988a-303e04880a4d.png)'
- en: Okay, `12` cores is as expected, since the processor in my laptop is a six-core Intel
    Core i9 CPU with hyper-threading (the operating system sees two virtual cores
    for each physical core).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`12`个核心是预期的，因为我的笔记本电脑上的处理器是一个六核的Intel Core i9 CPU，支持超线程（操作系统看到每个物理核心的两个虚拟核心）。
- en: 'In terms of the amount of available memory, let''s ask the JVM for the maximum
    size that it thinks it can allocate for the heap. We can achieve this by asking
    the JVM for extra runtime information using the `-XX:+PrintFlagsFinal` Java option
    and then using the `grep` command to filter out the `MaxHeapSize` parameter, like
    so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就可用内存的数量而言，让我们询问JVM认为它可以为堆分配的最大大小。我们可以通过使用`-XX:+PrintFlagsFinal` Java选项询问JVM额外的运行时信息，然后使用`grep`命令过滤出`MaxHeapSize`参数，如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On my machine, I get the following response:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我得到以下响应：
- en: '![](img/98ea076e-f964-4885-b262-e8020b7b702c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98ea076e-f964-4885-b262-e8020b7b702c.png)'
- en: '`8589934592` bytes happens to be exactly 8 GB, that is, *8 * 1,024^3*. Given
    that we don''t specify any max heap size for the JVM using the `-Xmx` parameter,
    the JVM will set the max value to one quarter of the available memory. Since my laptop
    has 32 GB of memory and *32/4=8*, this is also as expected!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`8589934592`字节恰好是8 GB，即*8 * 1,024^3*。鉴于我们没有使用`-Xmx`参数为JVM指定最大堆大小，JVM将最大值设置为可用内存的四分之一。由于我的笔记本电脑有32
    GB内存，*32/4=8*，这也是预期的！'
- en: 'Let''s wrap this up by verifying that we can lower the maximum heap size with the `-Xmx` parameter
    to, for example, 200 MB:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过验证我们可以使用`-Xmx`参数将最大堆大小降低到例如200 MB来结束这一切：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The JVM will respond with *209,715,200* bytes, that is, *200 ** *1,024^3* bytes
    = 200 MB, as expected!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将以*209,715,200*字节，即*200 ** *1,024^3*字节= 200 MB的预期值进行响应！
- en: Now that we have seen how the Java commands work without Docker, let's try this
    with Docker!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了没有Docker的情况下Java命令是如何工作的，现在让我们尝试使用Docker！
- en: Java in Docker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker中的Java
- en: Let's look at how Java SE 12 responds to limits we set on a container it runs
    in!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java SE 12如何响应我们在其中运行的容器上设置的限制！
- en: Since I'm using Docker for macOS, I'm actually running the Docker engine on
    a virtual machine on my MacBook Pro as the Docker host. I have configured Docker
    for macOS so that it allows the Docker host to use all 12 cores in my macOS but
    only use up to 16 GB of memory. All in all, the Docker host has 12 cores and 16
    GB of memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在macOS上使用Docker，实际上是在我的MacBook Pro上的虚拟机上运行Docker引擎作为Docker主机。我已经配置了Docker
    for macOS，以便允许Docker主机使用macOS中的所有12个核心，但最多只能使用16GB内存。总的来说，Docker主机有12个核心和16GB内存。
- en: CPU
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU
- en: 'Let''s start by applying no constraints, that is, the same test that we did
    without Docker:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先不应用任何约束，也就是说，进行与没有Docker时相同的测试：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command will send the `Runtime.getRuntime().availableProcessors()` string
    to the Docker container that will process the string using `jshell`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将发送`Runtime.getRuntime().availableProcessors()`字符串到Docker容器，然后使用`jshell`处理该字符串。
- en: 'It will respond with the same result, that is, `$1 ==> 12` in my case. Let''s
    move on and restrict the Docker container to only be allowed to use three CPU
    cores using the `--cpus 3` Docker option and ask the JVM about how many available
    processors it sees:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回相同的结果，也就是在我的情况下是`$1 ==> 12`。让我们继续，并使用`--cpus 3` Docker选项将Docker容器限制为只能使用三个CPU核心，并询问JVM它看到了多少可用处理器：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The JVM now responds with `$1 ==> 3`, that is, Java SE 12 honors the settings
    in the container and will, therefore, be able to configure CPU-related resources
    such as thread pools correctly!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JVM现在返回`$1 ==> 3`，也就是说，Java SE 12遵守了容器中的设置，因此能够正确配置与CPU相关的资源，如线程池！
- en: 'Let''s also try to specify a relative share of the available CPUs instead of
    an exact number of CPUs. 1,024 shares correspond to one core by default, so if
    we want to limit the container to two cores, we set the `--cpu-shares` Docker
    option to 2,048, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也尝试指定可用CPU的相对份额，而不是确切的CPU数量。默认情况下，1,024份额对应一个核心，因此如果我们想将容器限制为两个核心，我们将`--cpu-shares`
    Docker选项设置为2,048，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The JVM will respond with `$1 ==> 2`, that is, Java SE 12 honors the relative
    `share` option as well!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将返回`$1 ==> 2`，也就是说，Java SE 12也遵守了相对`share`选项！
- en: While the `--cpus` option is a hard constraint, the `--cpu-shares` option only
    applies when the Docker host is under high load. This means that a container can
    consume more CPU than what the `share` option indicates whether CPU capacity is
    available.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`--cpus`选项是一个硬约束，但`--cpu-shares`选项仅在Docker主机负载较高时适用。这意味着容器可以消耗比`share`选项指示的更多的CPU容量。
- en: Let's try out limiting the amount of memory next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们尝试限制内存的数量。
- en: Memory
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: 'With no memory constraints, Docker will allocate one-fourth of the memory to
    the container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有内存限制的情况下，Docker将向容器分配四分之一的内存：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It will respond with 4,202,692,608 bytes, which equals 4 GB, that is, *8 * 1024^3*.
    Since my Docker host has 16 GB of memory, this is correct, that is, *16/4 = 4*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回4,202,692,608字节，相当于4GB，即*8 * 1024^3*。由于我的Docker主机有16GB内存，这是正确的，即*16/4 =
    4*。
- en: 'However, if we constrain the Docker container to only use up to 1 GB of memory
    using the `-m=1024M` Docker option, we will see a lower memory allocation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`-m=1024M` Docker选项将Docker容器限制在最多使用1GB内存，我们将看到更低的内存分配：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The JVM will respond with 268,435,456 bytes, which equals 256 MB, that is, *2 *
    1024^2* bytes. 256 MB is one-fourth of 1 GB, so again, this is as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将返回268,435,456字节，相当于256MB，即*2 * 1024^2*字节。256MB是1GB的四分之一，因此这也是预期的结果。
- en: 'We can, as usual, set the max heap size ourselves. For example, if we want
    to allow the heap to use 800 MB of the total 1 GB we have, we can specify that
    using the `-Xmx800m` Java option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像往常一样自己设置最大堆大小。例如，如果我们想要允许堆使用总共1GB中的800MB，我们可以使用`-Xmx800m` Java选项来指定：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The JVM will respond with 838,860,800 bytes = *800 * 1024^2* bytes = 800 MB,
    as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将返回838,860,800字节= *800 * 1024^2*字节= 800MB，这是预期的。
- en: Let's conclude with some out of memory tests to ensure that this really works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一些内存不足的测试来结束，以确保这确实有效。
- en: Let's allocate some memory using `jshell` in a JVM that runs in a container
    that has been given 1 GB of memory; that is, it has a max heap size of 256 MB.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个被分配了1GB内存的容器中使用`jshell`来分配一些内存；也就是说，它的最大堆大小为256MB。
- en: 'First, try to allocate a byte array of 100 MB:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试分配一个100MB的字节数组：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command will respond with `$1 ==>`, meaning that it worked fine!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回`$1 ==>`，这意味着它运行正常！
- en: Normally, `jshell` will print out the value resulting from the command, but
    100 MB of bytes all set to zero is a bit too much printout, and so we get nothing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`jshell`将打印出命令产生的值，但是100MB的字节全都设置为零有点太多了，所以我们什么也没得到。
- en: 'Now, let''s try to allocate a byte array that is larger than the max heap size,
    for example, 500 MB:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试分配一个大于最大堆大小的字节数组，例如500MB：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JVM sees that it can''t perform the action since it honors the container
    settings of max memory and responds immediately with `Exception java.lang.OutOfMemoryError:
    Java heap space`. Great!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'JVM发现它无法执行该操作，因为它遵守了最大内存的容器设置，并立即返回`Exception java.lang.OutOfMemoryError: Java
    heap space`。太好了！'
- en: What would happen in this case if we use a JVM that doesn't honor the container
    settings of max memory?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们使用一个不遵守最大内存容器设置的JVM会发生什么呢？
- en: Let's find out by using Java SE 9!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Java SE 9来找出！
- en: Problems with Docker and Java SE 9 (or older)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和Java SE 9（或更早版本）存在的问题
- en: First, try out limiting a Java SE 9 JVM to three CPU cores using `openjdk:9-jdk` image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试使用`openjdk:9-jdk`镜像将Java SE 9 JVM限制为三个CPU核心。
- en: 'Java 9 fails to obey the three-CPU limit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9未能遵守三个CPU限制：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It responds with `$1 ==> 12` on my machine, that is, it ignores the limitation
    of three CPU cores.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，它返回`$1 ==> 12`，也就是说，它忽略了三个CPU核心的限制。
- en: 'We will see the same result, that is, `$1 ==> 12`, if we try out the `--cpu-shares`
    option:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试`--cpu-shares`选项，我们将看到相同的结果，即`$1 ==> 12`：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s try to limit the memory to 1 GB:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将内存限制为1 GB：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, Java SE 9 does not honor the memory constraint that we set in Docker;
    that is, it reports a max heap size of 4,202,692,608 bytes = *4 GB – 4 * 1024^3*
    bytes. Here, Java 9 calculated the available memory when given the memory in the
    Docker host, not in the actual container!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Java SE 9不遵守我们在Docker中设置的内存约束；也就是说，它报告的最大堆大小为4,202,692,608字节= *4 GB
    - 4 * 1024^3*字节。在这里，Java 9在给定Docker主机中的内存时计算可用内存，而不是在实际容器中！
- en: So, what happens if we repeat the memory allocation tests that we did for Java
    SE 12?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们重复为Java SE 12进行内存分配测试会发生什么呢？
- en: 'Let''s try out the first test, that is, allocating a 100 MB array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第一个测试，即分配一个100 MB的数组：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The command responds with `$1 ==> byte[100000000] { 0, 0, 0, ...`, so that worked
    fine!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的响应是`$1 ==> byte[100000000] { 0, 0, 0, ...`，所以这个测试很好！
- en: 'Now, let''s move on to the really interesting test: what if we allocate a byte
    array of 500 MB that doesn''t fit in the memory that was allocated to the container
    by Docker?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行真正有趣的测试：如果我们分配一个500 MB的字节数组，它不适合Docker为容器分配的内存，会发生什么？
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From a Java perspective, this should work. Since Java thinks the total memory
    is 16 GB, it has set the max heap size to 4 GB, so it happily starts to allocate
    500 MB for the byte array. But after a while, the total size of the JVM exceeds
    1 GB and Docker will kill the container with no mercy, resulting in a confusing
    exception such as `State engine terminated`. We basically have no clue what went
    wrong, even though we can guess that we ran out of memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java的角度来看，这应该是有效的。由于Java认为总内存为16 GB，因此将最大堆大小设置为4 GB，因此它愉快地开始为字节数组分配500 MB。但是过了一会儿，JVM的总大小超过了1
    GB，Docker将无情地终止容器，导致一个令人困惑的异常，比如`State engine terminated`。我们基本上不知道出了什么问题，尽管我们可以猜到我们已经耗尽了内存。
- en: So, to summarize, if you plan to do any serious work with Docker and Java, ensure
    that you use Java SE 10 or later!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，如果您计划在Docker和Java中进行任何严肃的工作，请确保使用Java SE 10或更高版本！
- en: To be fair to Java SE 9, it should be mentioned that Java SE 9 contains some
    initial support for cgroups. If you specify the Java options `-XX:+UnlockExperimentalVMOptions` and `-XX:+UseCGroupMemoryLimitForHeap`,
    it will honor parts of the cgroup constraints, but not all of them, and it should
    be noted that this is only experimental. Due to this, it should be avoided in
    production environments. Simply use Java SE 10 or later in Docker!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公平对待Java SE 9，应该提到Java SE 9包含对cgroups的一些初始支持。如果您指定Java选项`-XX:+UnlockExperimentalVMOptions`和`-XX:+UseCGroupMemoryLimitForHeap`，它将遵守cgroup约束的部分，但不是全部，并且应该注意这只是实验性的。因此，在生产环境中应避免使用。在Docker中简单地使用Java
    SE 10或更高版本！
- en: Using Docker with one microservice
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一个微服务的Docker
- en: Now that we understand how Java works, we can start using Docker with one of
    our microservices. Before we can run our microservice as a Docker container, we
    need to package it in a Docker image. To build a Docker image, we need a Dockerfile,
    so we will start with that. Next, we need a Docker-specific configuration for
    our microservice. Since a microservice that runs in a container is isolated from
    other microservices, for example, has its own IP address, hostname, and ports,
    it needs a different configuration compared to when it's running on the same host
    with other microservices. For example, since the other microservices no longer
    run on the same host, no port conflicts will occur. When running in Docker, we
    can use the default port `8080` for all our microservices without any risk of
    port conflicts. On the other hand, if we need to talk to the other microservices,
    we can no longer use localhost like we could when we ran them on the same host.
    The source code in the microservices will not be affected by running the microservices
    in containers, only their configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Java的工作原理，我们可以开始使用Docker来运行我们的一个微服务。在我们可以将微服务作为Docker容器运行之前，我们需要将其打包成Docker镜像。要构建Docker镜像，我们需要一个Dockerfile，所以我们将从那里开始。接下来，我们需要一个特定于Docker的微服务配置。由于在容器中运行的微服务与其他微服务隔离，例如具有自己的IP地址、主机名和端口，因此与在同一主机上运行时相比，它需要不同的配置。例如，由于其他微服务不再在同一主机上运行，因此不会发生端口冲突。在Docker中运行时，我们可以在所有微服务中使用默认端口`8080`，而不会有任何端口冲突的风险。另一方面，如果我们需要与其他微服务通信，我们就不能像在同一主机上运行时那样使用localhost了。在容器中运行微服务不会影响源代码，只会影响它们的配置。
- en: To handle the different configurations that are required when running locally
    without Docker and when running the microservices as Docker containers, we will
    use Spring profiles. Since [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating
    a Set of Cooperating Microservices*, we have been using the default Spring profile
    for running locally without Docker, so we will create a Spring profile named `docker`
    for when we run our microservices as containers in Docker.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理在本地运行时不需要Docker和在Docker容器中运行微服务时需要的不同配置，我们将使用Spring配置文件。自从[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)
    *创建一组协作微服务*以来，我们一直在使用本地运行时的默认Spring配置文件，因此我们将为在Docker中作为容器运行时创建一个名为`docker`的Spring配置文件。
- en: Changes in source code
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码中的更改
- en: We will use the `product` microservice, which can be found in the source code
    at `$BOOK_HOME/Chapter04/microservices/product-service/`. In the next section,
    we will apply this to the other microservices as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`product`微服务，在源代码中可以找到`$BOOK_HOME/Chapter04/microservices/product-service/`。在下一节中，我们将对其他微服务也应用这一点。
- en: 'First, we add the Spring profile for Docker at the end of the property file
    `$BOOK_HOME/Chapter04/microservices/product-service/src/main/resources/application.yml`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在属性文件`$BOOK_HOME/Chapter04/microservices/product-service/src/main/resources/application.yml`的末尾添加Docker的Spring配置文件：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Spring profiles can be used to specify environment-specific configuration, which
    in this case is a configuration that is to only be used when running the microservice
    in a Docker container. Other examples are configurations that are specific to
    `dev`, `test`, and production environments. Values in a profile override the default
    values, that is, values from the default profile. Using `.yaml` files, multiple
    Spring profiles can be placed in the same file, separated by ``---``.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring配置文件可用于指定特定于环境的配置，这种情况下是在Docker容器中运行微服务时才使用的配置。其他示例是特定于`dev`、`test`和生产环境的配置。配置文件中的值会覆盖默认值，即默认配置文件中的值。使用`.yaml`文件，可以将多个Spring配置文件放在同一个文件中，用`---`分隔。
- en: The only parameter we will change is the port that's being used; that is, we
    will use the default port `8080` when running the microservice in a container.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改变的唯一参数是正在使用的端口；也就是说，在容器中运行微服务时，我们将使用默认端口`8080`。
- en: 'Next, we will create the `Dockerfile` that we will use to build the Docker
    image, `$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`. It looks
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`Dockerfile`，用于构建Docker镜像，`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`。它看起来像这样：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some things to take note of are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些事项如下：
- en: We will base our Docker image on the official Docker image for OpenJDK and use
    the Java SE v12.0.2.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将基于OpenJDK的官方Docker镜像构建我们的Docker镜像，并使用Java SE v12.0.2。
- en: We will expose port `8080` to other Docker containers.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将端口`8080`暴露给其他Docker容器。
- en: We add our `fat-jar` file to the Docker image from the Gradle build library, `build/libs`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从Gradle构建库`build/libs`中将我们的`fat-jar`文件添加到Docker镜像中。
- en: We will specify the command to be used by Docker when a container is started
    up using this Docker image, that is, `java -jar /app.jar`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将指定Docker在启动容器时使用的命令，即`java -jar /app.jar`。
- en: After taking into account these changes in source code
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了源代码中的这些更改之后
- en: Building a Docker image
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: 'To build the Docker image, we need to build our deployment artifact, that is,
    the fat-file, for `product-service`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Docker镜像，我们需要构建我们的部署文件，即`product-service`的`fat-file`：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we only want to build `product-service` and the projects it depends on,
    `api` and `util`, we don't use the normal `build` command, which builds all the
    microservices, but a variant that tells Gradle to only build `product-service`: `:microservices:product-service:build`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想构建`product-service`及其依赖的项目`api`和`util`，我们不使用普通的`build`命令，该命令会构建所有微服务，而是使用一个变体，告诉Gradle只构建`product-service`：`:microservices:product-service:build`。
- en: 'We can find the `fat-jar` file in the Gradle build library, `build/libs`. For
    example, the `ls -l microservices/product-service/build/libs` command will report
    something like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Gradle构建库`build/libs`中找到`fat-jar`文件。例如，`ls -l microservices/product-service/build/libs`命令会报告类似以下内容：
- en: '![](img/2af54aa7-9e16-41b1-964a-021bda81ebd5.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2af54aa7-9e16-41b1-964a-021bda81ebd5.png)'
- en: As you can see, the JAR file is close to 20 MB in size – no wonder they are
    called `fat-jar` files!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JAR文件的大小接近20MB，难怪它们被称为`fat-jar`文件！
- en: If you are curious about its actual content, you can view it by using the `unzip
    -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`
    command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对其实际内容感到好奇，可以使用`unzip -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`命令查看。
- en: 'Next, we will build the Docker image and name it `product-service`, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建Docker镜像并命名为`product-service`，如下所示：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Docker will use the Dockerfile in the current directory to build the Docker
    image. The image will be tagged with the name `product-service` and stored locally
    inside the Docker engine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将使用当前目录中的Dockerfile来构建Docker镜像。镜像将被标记为名称`product-service`，并存储在Docker引擎内部。
- en: 'Verify that we got a Docker image, as expected, by using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令验证我们是否得到了预期的Docker镜像：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The expected output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![](img/81cd92d2-7f8a-42a7-8e75-bfd20c69a1a6.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81cd92d2-7f8a-42a7-8e75-bfd20c69a1a6.png)'
- en: So now that we have built the image, lets see how we can start the service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了镜像，让我们看看如何启动服务。
- en: Starting up the service
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'Let''s start up the `product` microservice as a container by using the following
    command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令将`product`微服务作为容器启动：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is what we can infer from the preceding code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中我们可以推断出以下内容：
- en: '`docker run`: The Docker run command will start the container and display log
    output in Terminal. Terminal will be locked as long as the container runs.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run`：Docker run命令将启动容器并在终端中显示日志输出。只要容器运行，终端就会被锁定。'
- en: We have seen the `--rm` option already; it will tell Docker to clean up the
    container once we stop the execution from Terminal using *Ctrl + C*.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了`--rm`选项；它会告诉Docker在我们使用*Ctrl + C*从终端停止执行后清理容器。
- en: The `-p8080:8080` option maps port `8080` in the container to port `8080` in
    the Docker host, which makes it possible to call it from the outside. In the case
    of Docker for macOS, which runs Docker in a local Linux virtual machine, the port
    will also be port-forwarded to macOS, which is made available on localhost. We
    can only have one container mapping to a specific port in the Docker host!
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-p8080:8080`选项将容器中的端口`8080`映射到Docker主机中的端口`8080`，这样就可以从外部调用它。在macOS上运行Docker的情况下，它会在本地Linux虚拟机中运行Docker，端口也会被转发到macOS，可以在localhost上使用。我们只能有一个容器映射到Docker主机上的特定端口！'
- en: With the `-e` option, we can specify environment variables for the container,
    which in this case is `SPRING_PROFILES_ACTIVE=docker`. The `SPRING_PROFILES_ACTIVE` environment
    variable is used to tell Spring what profile to use. In our case, we want Spring
    to use the `docker` profile.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-e`选项，我们可以为容器指定环境变量，在这种情况下是`SPRING_PROFILES_ACTIVE=docker`。`SPRING_PROFILES_ACTIVE`环境变量用于告诉Spring使用哪个配置文件。在我们的情况下，我们希望Spring使用`docker`配置文件。
- en: Finally, we have `product-service`, which is the name of the Docker image that
    Docker will use to start the container.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`product-service`，这是Docker将用于启动容器的Docker镜像的名称。
- en: 'The expected output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![](img/6418f725-7182-4415-a87c-283962b36cad.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6418f725-7182-4415-a87c-283962b36cad.png)'
- en: 'This is what we infer from the preceding output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从前面的输出中推断出的：
- en: 'The profile that''s used by Spring is `docker`. Look for `The following profiles
    are active: docker` in the output to verify this.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spring使用的配置文件是`docker`。在输出中查找`The following profiles are active: docker`以验证这一点。'
- en: 'The port that''s allocated by the container is `8080`. Look for `Netty started
    on port(s): 8080` in the output to verify this.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '容器分配的端口是`8080`。在输出中查找`Netty started on port(s): 8080`以验证这一点。'
- en: The microservice is ready to accept requests once the log message `Started ProductServiceApplication` has
    been written!
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦日志消息`Started ProductServiceApplication`被写入，微服务就准备好接受请求了！
- en: 'Try out the following code in another Terminal window:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中尝试以下代码：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we can use port `8080` on localhost, as explained previously!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在本地主机上使用端口`8080`，就像之前解释的那样！
- en: 'The following is the expected output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![](img/da91fca5-5223-4ded-b277-26ef0ea17866.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da91fca5-5223-4ded-b277-26ef0ea17866.png)'
- en: This is similar to the output we received from the previous chapter, but with
    one major difference; we have the content of `"service Address":"aebb42b32fef/172.17.0.2:8080"`,
    the port is `8080`, as expected, and the IP address, `172.17.0.2`, is an IP address
    that's been allocated to the container from an internal network in Docker – but
    where did the hostname, `aebb42b32fef`, come from?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们从上一章收到的输出类似，但有一个主要区别；我们有`"service Address":"aebb42b32fef/172.17.0.2:8080"`的内容，端口是`8080`，正如预期的那样，IP地址`172.17.0.2`是从Docker内部网络中分配给容器的IP地址-但主机名`aebb42b32fef`是从哪里来的呢？
- en: 'Ask Docker for all the running containers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 询问Docker所有正在运行的容器：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will see something like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到类似以下的内容：
- en: '![](img/ab9eb9ee-8dc6-4e0c-bcd2-14269175f84c.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab9eb9ee-8dc6-4e0c-bcd2-14269175f84c.png)'
- en: As we can see from the preceding output that, the hostname is equivalent to
    the ID of the container, which is good to know if you want to understand what
    container actually responded to your request!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中我们可以看到，主机名等同于容器的ID，这对于了解哪个容器实际上响应了你的请求是很有用的！
- en: Wrap this up by stopping the container in Terminal with the *Ctrl + C* command.
    With this done, we can now move on to running the container detached while being
    detached.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中使用*Ctrl + C*命令停止容器来结束这一切。完成后，我们现在可以继续在分离状态下运行容器。
- en: Running the container detached
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器分离
- en: Okay, that was great, but what if we don't want to hang the Terminal windows
    from where we started the container?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那很棒，但是如果我们不想让我们启动容器的终端窗口挂起呢？
- en: It's time to start the container as detached, that is, running the container
    without locking Terminal!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候以分离状态启动容器了，也就是说，运行容器而不锁定终端！
- en: 'We can do this by adding the `-d` option and at the same time giving it a name
    using the `--name` option. The `--rm` option is no longer required since we will
    stop and remove the container explicitly when we are done with it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`-d`选项并同时使用`--name`选项来为其命名。由于我们完成后将明确停止和删除容器，因此不再需要`--rm`选项：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run the `docker ps` command again, we will see our new container, called `my-prd-srv`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行`docker ps`命令，我们将看到我们的新容器，名为`my-prd-srv`：
- en: '![](img/a683c0b3-0d98-4e01-afad-b521ee76cd42.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a683c0b3-0d98-4e01-afad-b521ee76cd42.png)'
- en: But how do we get the log output from our container?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何获取容器的日志输出呢？
- en: 'Meet the Docker `logs` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 遇见Docker的`logs`命令：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `-f` option tells the command to follow the log output, that is, not end
    the command when all the current log output has been written to Terminal, but
    also wait for more output. If you expect a lot of old log messages that you don't
    want to see, you can also add the `--tail 0` option so that you only see new log
    messages. Alternatively, you can use the `--since` option and use either an absolute
    timestamp or a relative time, for example, `--since 5m`, to see log messages that
    are at most five minutes old.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`选项告诉命令跟踪日志输出，即不在当前日志输出写入终端时结束命令，而是等待更多输出。如果你期望看到很多旧的日志消息，你也可以添加`--tail
    0`选项，这样你只会看到新的日志消息。或者，你可以使用`--since`选项，并使用绝对时间戳或相对时间，例如`--since 5m`，以查看最多五分钟前的日志消息。'
- en: Try this out with a new `curl` request. You should see that a new log message
    has been written to the log output in Terminal!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用新的`curl`请求。你会看到一个新的日志消息已经被写入终端的日志输出中！
- en: 'Wrap this up by stopping and removing the container:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过停止和删除容器来结束这一切：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `-f` option forces Docker to remove the container, even if it is running.
    Docker will automatically stop the container before it removes it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`选项强制Docker删除容器，即使它正在运行。Docker将在删除容器之前自动停止容器。'
- en: Now that we know how to use Docker with a microservice, we can now see how to
    manage a microservices landscape with the help of Docker Compose and see the changes
    in it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用Docker来管理微服务，我们现在可以看到如何使用Docker Compose来管理微服务景观，并查看其中的更改。
- en: Managing a landscape of microservices using Docker Compose
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose管理微服务的景观
- en: We've already seen how we can run a single microservice as a Docker container,
    but what about managing a whole system landscape of microservices?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将单个微服务作为Docker容器运行，但是如何管理整个微服务系统的景观呢？
- en: As we mentioned earlier, this is the purpose of `docker-compose`. By using single
    commands, we can build, start, log, and stop a group of cooperating microservices
    running as Docker containers!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这就是`docker-compose`的目的。通过使用单个命令，我们可以构建、启动、记录和停止作为Docker容器运行的一组协作微服务！
- en: Changes in the source code
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的更改
- en: To be able to use Docker Compose, we need to create a configuration file, `docker-compose.yml`,
    that describes the microservices Docker Compose will manage for us. We also need
    to set up Dockerfiles for the remaining microservices and add a Docker-specific
    Spring profile to each of them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用Docker Compose，我们需要创建一个配置文件`docker-compose.yml`，描述Docker Compose将为我们管理的微服务。我们还需要为其余的微服务设置Dockerfiles，并为每个微服务添加一个特定于Docker的Spring配置文件。
- en: 'All four microservices have their own Dockerfile, but they all look the same
    as the preceding one. You can find them here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 四个微服务都有自己的Dockerfile，但它们看起来都与前面的相同。您可以在这里找到它们：
- en: '`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/product-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/recommendation-service/Dockerfile`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/recommendation-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/review-service/Dockerfile`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/review-service/Dockerfile`'
- en: '`$BOOK_HOME/Chapter04/microservices/product-composite-service/Dockerfile`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$BOOK_HOME/Chapter04/microservices/product-composite-service/Dockerfile`'
- en: When it comes to the Spring profiles, the three core services, `product`, `recommendation`,
    and `review-service`, have the same `docker` profile, which only specifies that
    the default port `8080` should be used when running as a container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring配置文件方面，三个核心服务`product`、`recommendation`和`review-service`都具有相同的`docker`配置文件，该配置文件仅指定在作为容器运行时应使用默认端口`8080`。
- en: 'For `product-composite-service`, things are a bit more complicated since it
    needs to know where to find the core services. When we ran all the services on
    localhost, it was configured to use localhost and individual port numbers, `7001`-`7003`,
    for each core service. When running in Docker, each service will have its own
    hostname but will be accessible on the same port number, `8080`. Here, the `docker`
    profile for `product-composite-service` looks as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite-service`，情况会有点复杂，因为它需要知道在哪里找到核心服务。当我们在本地主机上运行所有服务时，它被配置为使用本地主机和各个端口号`7001`-`7003`，每个核心服务一个端口号。在Docker中运行时，每个服务将有自己的主机名，但将在相同的端口号`8080`上可访问。在这里，`product-composite-service`的`docker`配置文件如下：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See `$BOOK_HOME/Chapter04/microservices/product-composite-service/src/main/resources/application.yml` for
    details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅`$BOOK_HOME/Chapter04/microservices/product-composite-service/src/main/resources/application.yml`。
- en: Where did the hostnames, products, recommendations, and reviews come from?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名`products`、`recommendations`和`reviews`是从哪里来的？
- en: 'These are specified in the `docker-compose.yml` file, which is located in the
    `$BOOK_HOME/Chapter04` folder. It looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都在位于`$BOOK_HOME/Chapter04`文件夹中的`docker-compose.yml`文件中指定。它看起来像这样：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For each microservice, we specify the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们指定以下内容：
- en: The name of the microservice. This will also be the hostname of the container
    in the internal Docker network.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的名称。这也将是内部Docker网络中容器的主机名。
- en: A build directive that specifies where to find the Dockerfile that was used
    to build the Docker image.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定构建指令，指定用于构建Docker镜像的Dockerfile的位置。
- en: A memory limit of 350 MB. This ensures that all containers in this and the upcoming
    chapters will fit in the 6 GB of memory that we allocated to the Docker engine
    in the *Technical requirements* section.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 350 MB的内存限制。这确保了本章和接下来的章节中的所有容器都适合我们在*技术要求*部分中分配给Docker引擎的6GB内存中。
- en: The environment variables that will be set up for the container. In our case,
    we used these to specify what Spring profile to use.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将为容器设置的环境变量。在我们的情况下，我们使用这些来指定要使用的Spring配置文件。
- en: For the `product-composite` service, we will also specify port mappings, that
    is, we will expose its port to the outside of Docker. The other microservices
    will not be accessible from the outside. Next, we will see how to start up a microservice
    landscape.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite`服务，我们还将指定端口映射，即，我们将其端口暴露到Docker的外部。其他微服务将无法从外部访问。接下来，我们将看到如何启动微服务景观。
- en: Starting up the microservice landscape
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动微服务景观
- en: 'With all the necessary code changes in place, we can build our Docker images,
    start up the microservice landscape, and run some tests to verify that it works
    as expected. For this, we need to do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有必要的代码更改就位后，我们可以构建我们的Docker镜像，启动微服务景观，并运行一些测试以验证其是否按预期工作。为此，我们需要执行以下操作：
- en: 'First, we build our deployment artifacts with Gradle and then the Docker images
    with Docker Compose:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用Gradle构建我们的部署工件，然后使用Docker Compose构建Docker镜像：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we need to verify that we can see our Docker images, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要验证我们是否可以看到我们的Docker镜像，如下所示：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should see the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '![](img/75213781-b3ea-4f66-84b9-62727717d4c5.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75213781-b3ea-4f66-84b9-62727717d4c5.png)'
- en: 'Start up the microservices landscape with the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务景观：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-d` option means the same as for Docker, as described previously.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项的含义与之前描述的Docker相同。'
- en: 'We can follow the startup by monitoring the output that''s written to each
    container log with the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过监视写入每个容器日志的输出来跟踪启动情况，使用以下命令：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `docker compose logs` command supports the same `-f` and `--tail` options
    as `docker logs`, as described earlier.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker compose logs`命令支持与`docker logs`相同的`-f`和`--tail`选项，如前面所述。'
- en: The Docker Compose `logs` command also supports restricting the log output to
    a group of containers. Simply add the names of the containers you want to see
    the log output of after the `logs` command. For example, to only see log output
    from the `product` and `review` service, use `docker-compose logs -f product review`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose的`logs`命令还支持将日志输出限制为一组容器。只需在`logs`命令后添加要查看日志输出的容器的名称。例如，要仅查看`product`和`review`服务的日志输出，请使用`docker-compose
    logs -f product review`。
- en: 'When all four microservices have reported that they have started up, we are
    ready to try out the microservices landscape. Look for the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当四个微服务都报告已启动时，我们准备尝试微服务景观。寻找以下内容：
- en: '![](img/760e3b57-8782-48c5-90ef-7ec483ef7f0e.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/760e3b57-8782-48c5-90ef-7ec483ef7f0e.png)'
- en: Note that each log message is prefixed with the name of the container that produces
    the output!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每条日志消息都以产生输出的容器的名称为前缀！
- en: 'Now, we are ready to run some tests to verify that this works as expected. The
    only change we need to make when calling the composite service in Docker from
    when we ran it directly on the localhost, as we did in the previous chapter, is
    the port number. We now use port `8080`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备运行一些测试，以验证这是否按预期工作。在从本地主机直接运行复合服务时，我们在上一章中所做的唯一更改是端口号。我们现在使用端口`8080`：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will get the same type of response:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到相同类型的响应：
- en: '![](img/ea65b614-de1e-426a-83dc-b750d6cef6be.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea65b614-de1e-426a-83dc-b750d6cef6be.png)'
- en: 'However, there''s one big difference – the hostnames and ports reported by
    `serviceAddresses` in the response:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一个很大的区别-响应中`serviceAddresses`报告的主机名和端口：
- en: '![](img/60a1a060-0f7d-4bb9-9088-89a1c926ae2b.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a1a060-0f7d-4bb9-9088-89a1c926ae2b.png)'
- en: Here, we can see the hostnames and IP addresses that have been allocated to
    each of the Docker containers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到已分配给每个Docker容器的主机名和IP地址。
- en: 'We''re done; now only one step is left:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了；现在只剩下一步：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command will shut down the microservices landscape.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将关闭微服务景观。
- en: Testing them all together automatically
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动测试它们全部一起
- en: Docker Compose is really helpful when it comes to manually managing a group
    of microservices! In this section, we will take this one step further and integrate
    Docker Compose into our test script, `test-em-all.bash`. The test script will
    automatically start up the microservice landscape, run all the required tests
    to verify that the microservice landscape works as expected, and finally tear
    it down, leaving no traces behind.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动管理一组微服务时，Docker Compose真的很有帮助！在本节中，我们将进一步将Docker Compose集成到我们的测试脚本`test-em-all.bash`中。测试脚本将自动启动微服务景观，运行所有必需的测试以验证微服务景观是否按预期工作，最后将其拆除，不留痕迹。
- en: The test script can be found at `$BOOK_HOME/Chapter04/test-em-all.bash`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本可以在`$BOOK_HOME/Chapter04/test-em-all.bash`找到。
- en: 'Before the test script runs the test suite, it will check for the presence
    of a `start` argument in the invocation of the test script. If found, it will
    restart the containers with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本运行测试套件之前，它将检查测试脚本调用中是否存在`start`参数。如果找到，它将使用以下代码重新启动容器：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After that, the test script will wait for the `product-composite` service to
    respond with OK:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，测试脚本将等待`product-composite`服务响应OK：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `waitForService` bash function can be implemented like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService` bash函数可以这样实现：'
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, all the tests are executed like they were previously. Afterward, they
    will tear down the landscape if it finds the `stop` argument in the invocation
    of the test scripts:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，所有测试都像以前一样执行。之后，如果在测试脚本的调用中找到`stop`参数，它将拆除景观：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the test script will not tear down the landscape if some tests fail;
    it will simply stop, leaving the landscape up for error analysis!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果某些测试失败，测试脚本不会拆除景观；它将简单地停止，使景观保持错误分析状态！
- en: The test script has also changed the default port from `7000`, which we used
    when we ran the microservices without Docker, to `8080`, which is used by our
    Docker containers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本还将默认端口从我们在没有Docker时使用的`7000`更改为我们的Docker容器使用的`8080`。
- en: 'Let''s try it out! To start the landscape, run the tests and tear it down afterward,
    like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下！启动景观，运行测试，然后拆除，就像这样：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is some sample output from a test run (with output from the specific
    tests that were deleted):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试运行的一些示例输出（包括已删除的特定测试的输出）：
- en: '![](img/16df5488-1e1d-45e3-850e-fad5f66cdbaf.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16df5488-1e1d-45e3-850e-fad5f66cdbaf.png)'
- en: After testing these, we can now move on to see how to troubleshoot tests that
    fail.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这些之后，我们现在可以继续查看如何排除失败的测试。
- en: Troubleshooting a test run
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除测试运行问题
- en: 'If the tests that were running `./test-em-all.bash start stop` fail, following
    these steps can help you identify the problem and resume the tests once the problem
    has been fixed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`./test-em-all.bash start stop`的测试失败，遵循以下步骤可以帮助您识别问题并在问题解决后恢复测试：
- en: 'First, check the status of the running microservices with the following command:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查正在运行的微服务的状态：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If all the microservices are up and running and healthy, you will receive the
    following output:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有微服务都正常运行并且健康，您将收到以下输出：
- en: '![](img/8cdb0618-6760-4126-a3f5-abb60989b739.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cdb0618-6760-4126-a3f5-abb60989b739.png)'
- en: 'If any of the microservices do not have a status of `Up`, check its log output
    for any errors by using the `docker-compose logs` command. For example, you would
    use the following code if you wanted to check the log output for the `product`
    service:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何微服务的状态不是`Up`，请使用`docker-compose logs`命令检查其日志输出是否有错误。例如，如果您想要检查`product`服务的日志输出，可以使用以下代码：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If errors in the log output indicate that Docker is running out of disk space,
    parts of it can be reclaimed with the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果日志输出中的错误表明Docker的磁盘空间不足，可以使用以下命令回收部分空间：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If required, you can restart a failed microservice with the `docker-compose
    up -d --scale` command. For example, you would use the following code if you wanted
    to restart the `product` service:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，您可以使用`docker-compose up -d --scale`命令重新启动失败的微服务。例如，如果您想重新启动`product`服务，可以使用以下代码：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If a microservice is missing, for example, due to a crash, you start it up
    with the `docker-compose up -d --scale` command. For example, you would use the
    following code for the `product` service:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果某个微服务丢失，例如由于崩溃，您可以使用`docker-compose up -d --scale`命令启动它。例如，如果您想要重新启动`product`服务，可以使用以下代码：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once all the microservices are up and running and healthy, run the test script
    again, but without starting the microservices:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有微服务都正常运行并且健康，再次运行测试脚本，但不启动微服务：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The tests should run fine!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该正常运行！
- en: 'Finally, a tip about a combined command that builds runtime artifacts and Docker
    images from source and then runs all the tests in Docker:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于一个组合命令的提示，该命令从源代码构建运行时构件和Docker镜像，然后在Docker中运行所有测试：
- en: '`./gradlew clean build && docker-compose build && ./test-em-all.bash start
    stop`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`./gradlew clean build && docker-compose build && ./test-em-all.bash start
    stop`'
- en: This is perfect if you want to check that everything works before you push new
    code to your Git repository or as part of a build pipeline in your build server!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在将新代码推送到Git存储库之前检查一切是否正常，或者作为构建服务器中构建流水线的一部分，这非常完美！
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how Docker can be used to simplify testing a landscape
    of cooperating microservices.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到Docker如何简化测试一组合作的微服务。
- en: We learned how Java SE since v10 honors constraints that we put on containers
    regarding how much CPU and memory they are allowed to use.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到自Java SE v10以来，它遵守我们对容器使用的CPU和内存量设置的限制。
- en: We have also seen how little it takes to make it possible to run a Java-based
    microservice as a Docker container. Thanks to Spring profiles, we can run the
    microservice in Docker without having to make any code changes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了只需很少的工作就可以将基于Java的微服务作为Docker容器运行。由于Spring配置文件，我们可以在Docker中运行微服务，而无需进行任何代码更改。
- en: Finally, we have seen how Docker Compose can help us manage a landscape of cooperating
    microservices with single commands, either manually or, even better, automatically,
    when integrated with a test script such as `test-em-all.bash`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经看到Docker Compose如何帮助我们使用单个命令手动或自动管理一组合作的微服务，当与诸如`test-em-all.bash`的测试脚本集成时，甚至更好。
- en: In the next chapter, we will study how we can add a documentation of the API
    using OpenAPI/Swagger descriptions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用OpenAPI/Swagger描述添加API的文档。
- en: Questions
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the major differences between a virtual machine and a Docker container?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟机和Docker容器之间的主要区别是什么？
- en: What is the purpose of namespaces and cgroups in Docker?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker中命名空间和cgroups的目的是什么？
- en: What happens with a Java application that doesn't honor the max memory settings
    in a container and allocates more memory than it is allowed to?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个Java应用程序不遵守容器中的最大内存设置，并分配了比允许的更多的内存，会发生什么？
- en: How can we make a Spring-based application run as a Docker container without
    requiring modifications of its source code?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使基于Spring的应用程序作为Docker容器运行，而无需修改其源代码？
- en: Why will the following Docker Compose code snippet not work?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下Docker Compose代码片段不起作用？
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
