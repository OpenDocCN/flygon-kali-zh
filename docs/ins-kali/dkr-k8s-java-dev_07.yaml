- en: Introduction to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: 'After reading [Chapter 6](text00108.html) , *Running Containers with Java Applications*
    , you now have a lot of knowledge about using Docker to package your Java applications.
    It''s now time to move even further and focus on what we are missing--the container
    management and orchestration. There are some suitable tools on the market, such
    as Nomad, Docker Swarm, Apache Mesos, or AZK, for example. In this chapter, we
    will focus on probably the most popular one, Kubernetes. Kubernetes (sometimes
    referred to as k8s) is an open source orchestration system for Docker containers,
    created by Google in 2015\. The first unified container management system developed
    at Google was the system, internally called, Borg; Kubernetes is its descendant.
    The list of topics covered in this chapter will be:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第6章](text00108.html)，*使用Java应用程序运行容器*，现在您对使用Docker打包Java应用程序有了很多知识。现在是时候更进一步，专注于我们所缺少的内容--容器管理和编排。市场上有一些合适的工具，例如Nomad、Docker
    Swarm、Apache Mesos或AZK等。在本章中，我们将重点介绍可能是最受欢迎的工具之一，Kubernetes。Kubernetes（有时简称为k8s）是由Google于2015年创建的用于Docker容器的开源编排系统。Google开发的第一个统一容器管理系统是内部称为Borg的系统；Kubernetes是它的后代。本章涵盖的主题列表将是：
- en: Why and when we need container management
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么以及何时需要容器管理
- en: An introduction to Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: Basic Kubernetes concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Kubernetes概念
- en: Let's begin with answering the question, why do we even need Kubernetes? We
    will look at the reasoning behind container management and orchestration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回答为什么我们需要Kubernetes这个问题开始。我们将探讨容器管理和编排背后的原因。
- en: Why do we need Kubernetes?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要Kubernetes？
- en: As you already know, Docker containers provide great flexibility for running
    Java services packaged into small, independent pieces of software. Docker containers
    make components of your application portable--you can move individual services
    across different environments without needing to worry about the dependencies
    or the underlying operating system. As long as the operating system is able to
    run the Docker engine, your Java containers can run on this system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，Docker容器为运行打包成小型独立软件的Java服务提供了极大的灵活性。Docker容器使应用程序的组件可移植--您可以在不需要担心依赖项或底层操作系统的情况下，在不同的环境中移动单个服务。只要操作系统能够运行Docker引擎，您的Java容器就可以在该系统上运行。
- en: Also, as you remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , the Docker concept of isolating containers is far from the traditional virtualization.
    The difference is that Docker containers utilize the resources of the host operating
    system--they are light, fast, and easy to spin up. It's all very nice, but there
    are some risks. Your application consists of multiple, independent microservices.
    The number of services can, and probably will, grow in time. Also, if your application
    starts to experience a higher load, it would be nice to increase the number of
    containers with the same service, just to distribute the load. It doesn't mean
    you only need to use your own server infrastructure--your containers can go to
    the cloud. Today we have a lot of cloud providers, such as Google or Amazon. By
    having the possibility to run your containers in the cloud, it gives you a lot
    of advantages. First, you don't need to manage your own servers. Second, in most
    clouds, you pay only for the real usage. If there's a peak in the load, the cost
    of the cloud service will increase, of course, as you will be using more computing
    power. But if there is no load, you will pay nothing. This is easy to say, but
    monitoring your server usage, especially with an application or applications running
    with a huge number of components, can be tricky. You will need to look at the
    bill from the cloud company carefully and make sure that you don't have a container
    sitting in the cloud spinning and doing nothing. If the specific service is not
    that important for your application and does not need to respond fast, you can
    move it to the cheapest machine. On the other hand, if another service experiences
    higher loads and it's critical, you will want to move it to a more powerful machine
    or spin up more instances of it. Best of all, by using Kubernetes, it can be automated.
    By having the right tool for managing Docker containers, this can be done on the
    fly. Your application can adapt itself in a very agile way--the end users will
    probably not even be aware of where an application they're using resides. Container
    management and monitoring software can greatly reduce the hardware costs by better
    utilizing the hardware you are paying for. Kubernetes handles scheduling onto
    nodes in a compute cluster and actively manages workloads to ensure that their
    state matches the user's declared intentions. Using the concepts of labels and
    Pods (which we are going to cover later in this chapter), Kubernetes groups the
    containers which make up an application into logical units for easy management
    and discovery.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如你在[第1章](text00022.html)中所记得的，*Docker简介*，Docker隔离容器的概念远非传统虚拟化。区别在于Docker容器利用主机操作系统的资源--它们轻便、快速且易于启动。这一切都很好，但也存在一些风险。你的应用由多个独立的微服务组成。服务的数量可能会随着时间增长。此外，如果你的应用开始承受更大的负载，增加相同服务的容器数量以分担负载会很好。这并不意味着你只需要使用自己的服务器基础设施--你的容器可以部署到云端。今天我们有很多云服务提供商，比如谷歌或亚马逊。在云端运行你的容器，会给你带来很多优势。首先，你不需要管理自己的服务器。其次，在大多数云端，你只需为实际使用付费。如果负载增加，云服务的成本当然会增加，因为你将使用更多的计算能力。但如果没有负载，你将付出零成本。这说起来容易，但监控服务器使用情况，尤其是在应用或应用程序运行的组件数量庞大时，可能会有些棘手。你需要仔细查看云公司的账单，并确保你没有一个容器在云端空转。如果特定服务对你的应用不那么重要，也不需要快速响应，你可以将其迁移到最便宜的机器上。另一方面，如果另一个服务承受更大的负载并且至关重要，你可能会希望将其迁移到更强大的机器上或增加更多实例。最重要的是，通过使用Kubernetes，这可以自动化。通过拥有管理Docker容器的正确工具，这可以实时完成。你的应用可以以非常灵活的方式自适应--最终用户可能甚至不会意识到他们使用的应用程序位于何处。容器管理和监控软件可以通过更好地利用你支付的硬件大大降低硬件成本。Kubernetes处理在计算集群中的节点上进行调度，并积极管理工作负载，以确保它们的状态与用户声明的意图相匹配。使用标签和Pods的概念（我们将在本章后面介绍），Kubernetes将组成应用程序的容器分组为逻辑单元，以便进行简单的管理和发现。
- en: Having your application in the form of a set of containers running in a managed
    environment also changes the perspective on software development. You can work
    on a new version of the service and when it's ready, you can do a rolling update
    on the fly. This also means focusing on the application over the machines it runs
    on and this, as a result, allows developer teams to operate in a much more flexible,
    smaller, and modular manner. It allows the software development to be truly agile,
    which is what we always wanted. Microservices are small and independent, and the
    build and deployment times are dramatically lower. Also, the risk of doing releases
    is smaller so you can release smaller changes more often, minimizing the possibility
    of a huge failure which may happen if you release everything in one go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序以一组容器的形式运行在受管理的环境中，也改变了对软件开发的视角。你可以在服务的新版本上进行工作，当准备好时，可以实现动态滚动更新。这也意味着专注于应用程序而不是运行在其上的机器，这结果允许开发团队以更加灵活、更小、更模块化的方式运作。它使得软件开发真正地变得敏捷，这正是我们一直想要的。微服务是小型且独立的，构建和部署时间大大缩短。此外，发布的风险也更小，因此你可以更频繁地发布较小的更改，最大程度地减少一次性发布所有内容可能导致的巨大失败的可能性。
- en: 'Before we begin with basic Kubernetes concepts, let''s summarize what Kubernetes
    gives us in a list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍基本的Kubernetes概念之前，让我们总结一下Kubernetes给我们带来了什么：
- en: Deploying applications quickly and predictably
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速、可预测地部署应用程序
- en: Scaling on the fly
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态扩展
- en: Releasing new features seamlessly
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝发布新功能
- en: Fail-proofing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防故障
- en: Limiting hardware usage only to required resources
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将硬件使用限制在所需的资源上
- en: Agile application development
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷的应用程序开发
- en: Portability between operating systems, hosts, and cloud providers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统、主机和云提供商之间的可移植性
- en: This is a list of features that cannot be easily beaten. To understand how this
    is being achieved, we need to understand the core Kubernetes concepts. So far,
    we know only one single concept coming from Docker--the container--which is a
    portable, independent unit of software. The container can contain anything we
    want, be it a database or a Java REST microservice. Let's get to know the remaining
    pieces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列无法轻易超越的功能。要理解如何实现这一点，我们需要了解核心的Kubernetes概念。到目前为止，我们只知道来自Docker的一个概念--容器--它是一个可移植的、独立的软件单元。容器可以包含任何我们想要的东西，无论是数据库还是Java
    REST微服务。让我们来了解剩下的部分。
- en: Basic Kubernetes concepts
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的Kubernetes概念
- en: 'A cluster is a group of nodes; they can be physical servers or virtual machines
    that have the Kubernetes platform installed. The basic Kubernetes architecture
    is presented in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是一组节点；它们可以是安装了Kubernetes平台的物理服务器或虚拟机。基本的Kubernetes架构如下图所示：
- en: '![](Image00080.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00080.jpg)'
- en: As you can see, the Kubernetes cluster consists of a Master node and a number
    of worker nodes with some components inside. While it may look scary and complicated
    at first glance, it will be easier to understand if we describe the concepts one
    by one, starting with the Pod.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Kubernetes集群由一个主节点和若干个工作节点以及一些组件组成。虽然乍一看可能会让人感到害怕和复杂，但如果我们逐个描述这些概念，从Pod开始，就会更容易理解。
- en: Pods
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pods
- en: 'The Pod consists of one or more Docker containers. This is the basic unit of
    the Kubernetes platform and an elementary piece of execution that Kubernetes works
    with. A diagram of the Pod is presented as following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Pod由一个或多个Docker容器组成。这是Kubernetes平台的基本单元，也是Kubernetes处理的基本执行单元。Pod的图示如下：
- en: '![](Image00081.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00081.jpg)'
- en: Containers running in the same Pod share the same common network namespace,
    disk, and security context. In fact, the communication over localhost is recommended
    between containers running on the same Pod. Each container can also communicate
    with any other Pod or service within the cluster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一Pod中运行的容器共享相同的网络命名空间、磁盘和安全上下文。事实上，建议在同一Pod中运行的容器之间使用localhost进行通信。每个容器还可以与集群中的任何其他Pod或服务进行通信。
- en: As you remember from [Chapter 2](text00037.html) , *Networking and Persistent
    Storage* , you can mount volumes within Docker containers. Kubernetes also supports
    the concept of a volume. Volumes that are attached to the Pod may be mounted inside
    of one or more containers running on this Pod. Kubernetes supports a lot of different
    volume types as a native support for mounting GitHub repositories, network disks,
    local hard drives, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第2章](text00037.html)中记得的，*网络和持久存储*，您可以在Docker容器中挂载卷。Kubernetes还支持卷的概念。附加到Pod的卷可以在此Pod上运行的一个或多个容器内挂载。Kubernetes支持许多不同类型的卷，作为原生支持挂载GitHub存储库、网络磁盘、本地硬盘等。
- en: 'If your application needs a distributed storage and needs to handle large amounts
    of data, you are not limited only to local hard drives. Kubernetes also supports
    Volume Providers. Currently, the list of available Persistent Volume Providers
    includes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要分布式存储并且需要处理大量数据，您不仅仅局限于本地硬盘。Kubernetes还支持卷提供程序。目前，可用的持久卷提供程序列表包括：
- en: '**GCE** : Which is a Google Cloud platform'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCE：谷歌云平台
- en: '**AWS** : Amazon Web Services'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS：亚马逊网络服务
- en: '**GlusterFS** : A scalable network filesystem. Using GlusterFS, which is free
    and an open source software, you can use your existing storage hardware to create
    large, distributed storage solutions'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlusterFS：可扩展的网络文件系统。使用免费的开源软件GlusterFS，您可以利用现有的存储硬件创建大型分布式存储解决方案
- en: '**OpenStack Cinder** : A block storage service for users of the OpenStack Nova
    compute platform'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack Cinder：用于OpenStack Nova计算平台用户的块存储服务
- en: '**CephRBD** : A **Reliable Autonomic Distributed Object Store** (**RADOS**
    ), which provides your applications with object, block, and file system storage
    in a single unified storage cluster'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CephRBD：可靠的自主分布式对象存储（RADOS），为您的应用程序提供单一统一存储集群中的对象、块和文件系统存储
- en: QuoByte
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QuoByte
- en: Kube-Aliyun
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kube-Aliyun
- en: 'Network namespace and volumes are not the only properties of the Pod. As you
    can see on the Pod''s diagram, a Pod can have labels and annotations attached.
    Labels are very important in Kubernetes. They are key/value pairs that are attached
    to objects, in this case to Pods. The idea behind labels is that they can be used
    to identify objects--labels are meaningful and relevant to users. An example of
    the label may be:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 网络命名空间和卷不是Pod的唯一属性。正如您在Pod的图表中所看到的，Pod可以附加标签和注释。标签在Kubernetes中非常重要。它们是附加到对象（在本例中是Pod）的键/值对。标签的理念是它们可以用于标识对象--标签对用户来说是有意义和相关的。标签的一个示例可能是：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Later on, we will be using label selectors to select objects (such as Pods)
    having the specified label. Via a label selector, which is the core grouping primitive
    in Kubernetes, the client or user can identify an object or a set of objects.
    A selector, similar to a label, is also a key-value expression to identify resources
    using matching labels. For example, the selector expression `app = my-rest-service`
    would select all Pods with the label `app = my-rest-service` . Annotations, on
    the other hand, are a kind of metadata you can attach to Pods. They are not intended
    to be identifying attributes; they are such properties that can be read by tools
    of libraries. There are no rules as to what an annotation should contain--it's
    up to you. The annotation can contain information such as the build or release
    version, a timestamp, Git branch name, Git `pull` request number, or just anything,
    as a mobile number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将使用标签选择器来选择具有指定标签的对象（如Pods）。通过标签选择器，在Kubernetes中是核心分组原语，客户端或用户可以识别对象或一组对象。选择器类似于标签，也是用于使用匹配标签识别资源的键值表达式。例如，选择器表达式`app
    = my-rest-service`将选择所有具有标签`app = my-rest-service`的Pods。另一方面，注释是一种可以附加到Pods的元数据。它们不是用于识别属性；它们是可以被工具或库读取的属性。关于注释应包含什么的规则没有规定--这取决于您。注释可以包含诸如构建或发布版本、时间戳、Git分支名称、Git`pull`请求编号或任何其他内容，如手机号码。
- en: Labels are intended for identifying information about Kubernetes objects such
    as Pods. Annotations are just metadata attached to an object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标签用于识别有关Kubernetes对象（如Pods）的信息。注释只是附加到对象的元数据。
- en: We've said before that a Pod is a basic unit of execution in Kubernetes. It
    can contain multiple containers. A real-life example of having a Pod with more
    than one Docker container could be our Java REST microservice Pod. For example
    purposes in previous chapters, our microservice has been storing its database
    data in memory. In real life, the data should probably go to the real database.
    Our Pod would probably have a container with Java JRE and the Spring Boot application
    itself, together with the second container with a PostgreSQL database, which the
    microservice uses to store its data. Two of those containers makes a Pod--a single,
    decoupled unit of execution that contains everything our REST service needs to
    operate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，Pod是Kubernetes中的执行的基本单位。它可以包含多个容器。具有多个Docker容器的Pod的现实生活示例可能是我们的Java REST微服务Pod。例如，在之前的章节中，我们的微服务一直将其数据库数据存储在内存中。在现实生活中，数据可能应该存储在真正的数据库中。我们的Pod可能会有一个包含Java
    JRE和Spring Boot应用程序本身的容器，以及第二个包含PostgreSQL数据库的容器，微服务使用它来存储数据。这两个容器组成一个Pod--一个单一的、解耦的执行单元，包含我们的REST服务运行所需的一切。
- en: 'The Pod''s definition is a JSON or YAML file called a `Pod` manifest. Take
    a look at a simple example with one container:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的定义是一个名为`Pod`清单的JSON或YAML文件。看一个包含一个容器的简单示例：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same `pod` manifest in a JSON file will look the same as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON文件中相同的`pod`清单看起来与以下内容相同：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The container's `image` is a Docker image name. The `containerPort` exposes
    that port from the REST service container so we can connect to the service at
    the Pod's IP. By default, as you remember from [Chapter 1](text00022.html) , *Introduction
    to Docker* , the entry point defined in the `image` is what will run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的`image`是Docker镜像名称。`containerPort`公开来自REST服务容器的端口，因此我们可以连接到Pod的IP上的服务。默认情况下，正如您从[第1章](text00022.html)中记得的那样，*Docker简介*中定义的`image`中的入口点将运行。
- en: It's very important to be aware that a Pod's life is fragile. Because the Pods
    are treated as stateless, independent units, if one of them is unhealthy or is
    just being replaced with a newer version, the Kubernetes Master doesn't have mercy
    on it--it just kills it and disposes of it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要意识到Pod的生命周期是脆弱的。因为Pod被视为无状态、独立的单元，如果其中一个不健康或者只是被新版本替换，Kubernetes Master不会对其手下留情--它只会将其杀死并处理掉。
- en: 'In fact, Pods have a strictly defined lifecycle. The following list describes
    the phases of a Pod''s life:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Pod有一个严格定义的生命周期。以下列表描述了Pod生命周期的各个阶段：
- en: '`pending` : This phase means that the Pod has been accepted by the Kubernetes
    system, but one or more of the Docker container images has not been created. Pods
    can be in this phase for a while--if the image needs to be downloaded from the
    internet, for example.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`挂起`：这个阶段意味着Pod已经被Kubernetes系统接受，但一个或多个Docker容器镜像尚未被创建。Pod可能会在这个阶段停留一段时间--例如，如果需要从互联网下载镜像。'
- en: '`running` : The Pod has been put onto a node and all of the Pod''s Docker containers
    have been created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行中`：Pod已经放置到一个节点上，并且Pod的所有Docker容器都已经被创建。'
- en: '`succeeded` : All Docker containers in the Pod have been terminated with a
    success status.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`成功`：Pod中的所有Docker容器都已成功终止。'
- en: '`failed` : All Docker containers in the Pod have been terminated, but at least
    one container has terminated with a failure status or was terminated by the system.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`失败`：Pod中的所有Docker容器都已终止，但至少一个容器以失败状态终止或被系统终止。'
- en: '`unknown` : This typically indicates a problem with communication to the host
    of the Pod; for some reason, the state of the Pod could not be retrieved.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未知`：这通常表示与Pod主机的通信出现问题；由于某种原因，无法检索Pod的状态。'
- en: When a Pod is being brought down, it's not only because it has failed. More
    often, if our application needs to handle an increased load, we need to have more
    Pods running. On the other hand, if the load decreases or there is no load at
    all, there's no point in having a lot of Pods running--we can dispose of them.
    Of course, we could start and stop Pods manually, but it's always better to automate.
    This brings us to the concept of ReplicaSets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Pod被关闭时，不仅仅是因为它失败了。更常见的情况是，如果我们的应用程序需要处理增加的负载，我们需要运行更多的Pod。另一方面，如果负载减少或根本没有负载，那么运行大量Pod就没有意义--我们可以处理掉它们。当然，我们可以手动启动和停止Pod，但自动化总是更好。这就引出了ReplicaSets的概念。
- en: ReplicaSets
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplicaSets
- en: 'ReplicaSets is the concept used in scaling your application by using replication.
    What is Kubernetes replication useful for? Typically, you would want to replicate
    your containers (which are, in fact, your application) for several reasons, including:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSets是使用复制来扩展应用程序的概念。Kubernetes复制有什么用处？通常情况下，您会希望复制您的容器（实际上就是您的应用程序）出于几个原因，包括：
- en: '**Scaling** : When load increases and becomes too heavy for the number of existing
    instances, Kubernetes enables you to easily scale up your application, creating
    additional instances as needed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：当负载增加并对现有实例的数量造成过重负荷时，Kubernetes使您能够轻松地扩展应用程序，根据需要创建额外的实例。'
- en: '**Load balancing** : We can easily distribute traffic to different instances
    to prevent overloading of a single instance or node. Load balancing comes out
    of the box because of Kubernetes'' architecture and it''s very convenient.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：我们可以轻松地将流量分发到不同的实例，以防止单个实例或节点过载。负载均衡是因为Kubernetes的架构而自带的，非常方便。'
- en: '**Reliability and fault tolerance** : By having multiple versions of an application,
    you prevent problems if one or more fail. This is particularly true if the system
    replaces any containers that fail.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和容错性**：通过拥有应用程序的多个版本，可以防止一个或多个失败时出现问题。如果系统替换任何失败的容器，这一点尤为重要。'
- en: Replication is appropriate for numerous use cases, including microservice-based
    applications where multiple, independent small services provide very specific
    functionality, or cloud native applications that are based on the theory that
    any component can fail at any time. Replication is a perfect solution for implementing
    them, as multiple instances naturally fit into the architecture.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 复制适用于许多用例，包括基于微服务的应用程序，其中多个独立的小型服务提供非常具体的功能，或者基于云原生应用程序，该应用程序基于任何组件随时可能失败的理论。
    复制是实现它们的完美解决方案，因为多个实例自然适合于架构。
- en: A ReplicaSet ensures that a specified number of Pod clones, known as replicas,
    are running at any given time. It there are too many, they will be shut down.
    If there is a need for more, for example some of them died because of an error
    or crash, or maybe there's a higher load, some more Pods will be brought to life.
    ReplicaSets are used by Deployments. Let's see what Deployments are.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet确保在任何给定时间运行指定数量的Pod克隆，称为副本。 如果有太多，它们将被关闭。 如果需要更多，例如由于错误或崩溃而死亡了一些，或者可能有更高的负载，将会启动一些更多的Pod。
    ReplicaSets由部署使用。 让我们看看部署是什么。
- en: Deployment
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: The Deployment is responsible for creating and updating instances of your application.
    Once the Deployment has been created, the Kubernetes Master schedules the application
    instances onto individual nodes in the cluster. A Deployment is a higher level
    of abstraction; it manages ReplicaSets when doing Pod orchestration, creation,
    deletion, and updates. A Deployment provides declarative updates for Pods and
    ReplicaSets. The Deployment allows for easy updating of a Replica Set as well
    as the ability to roll back to a previous deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 部署负责创建和更新应用程序的实例。 一旦部署已创建，Kubernetes Master将应用程序实例调度到集群中的各个节点。 部署是一个更高级别的抽象层；
    在进行Pod编排、创建、删除和更新时，它管理ReplicaSets。 部署为Pod和ReplicaSets提供声明性更新。 部署允许轻松更新Replica
    Set，以及能够回滚到先前的部署。
- en: 'You just specify the number of replicas you need and the container to run within
    each Pod and the Deployment controller will spin them up. The example Deployment
    manifest definition in the YAML file looks the same as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需指定所需的副本数量和每个Pod中要运行的容器，部署控制器将启动它们。 YAML文件中的示例部署清单定义看起来与以下内容相同：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous example, the Deployment Controller will create a ReplicaSet
    containing three Pods running our Java REST service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，部署控制器将创建一个包含三个运行我们的Java REST服务的Pod的ReplicaSet。
- en: The Deployment is a kind of control structure that takes care of the spinning
    up or down of Pods. A Deployment takes care of the state of a Pod or group of
    pods by creating or shutting down replicas. Deployments also manage updates to
    Pods. Deployments are a higher abstraction, which create ReplicaSets resources.
    ReplicaSets watch over the Pods and make sure the correct number of replicas are
    always running. When you want to update a Pod, you will need to modify the Deployment
    manifest. This modification will create a new ReplicaSet, which will be scaled
    up while the previous ReplicaSet will be scaled down, providing no down-time deployment
    of your application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是一种控制结构，负责启动或关闭Pod。 部署通过创建或关闭副本来管理Pod或一组Pod的状态。 部署还管理对Pod的更新。 部署是一个更高的抽象层，它创建ReplicaSets资源。
    ReplicaSets监视Pod，并确保始终运行正确数量的副本。 当您想要更新Pod时，您需要修改部署清单。 此修改将创建一个新的ReplicaSet，该ReplicaSet将扩展，而先前的ReplicaSet将缩减，从而实现应用程序的无停机部署。
- en: The main purpose of Deployments is to do rolling updates and rollbacks. A rolling
    update is the process of updating an application to a newer version, in a serial,
    one-by-one fashion. By updating one instance at a time, you are able to keep the
    application up and running. If you were to just update all instances at the same
    time, your application would likely experience downtime. In addition, performing
    a rolling update allows you to catch errors during the process so that you can
    roll back before it affects all of your users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的主要目的是进行滚动更新和回滚。滚动更新是以串行、逐个更新应用程序到新版本的过程。通过逐个更新实例，您可以保持应用程序的运行。如果您一次性更新所有实例，您的应用程序很可能会出现停机时间。此外，执行滚动更新允许您在过程中捕获错误，以便在影响所有用户之前进行回滚。
- en: Deployment also allows us to do an easy rollback. To do the rollback, we simply
    set the revision that we want to roll back to. Kubernetes will scale up the corresponding
    ReplicaSet and scale down the current one, and this will result in a rollback
    to a specified revision of our service. In fact, we will be using Deployments
    heavily in [Chapter 8](text00159.html) , *Using Kubernetes with Java* , to roll
    out an update of our service to the cluster.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还允许我们轻松回滚。要执行回滚，我们只需设置要回滚到的修订版本。Kubernetes将扩展相应的副本集并缩减当前的副本集，这将导致服务回滚到指定的修订版本。实际上，在《第8章》*使用Java与Kubernetes*中，我们将大量使用部署来向集群推出服务的更新。
- en: Replication is a large part of Kubernetes' features. As you can see, the life
    of a Pod is delicate and ephemeral. Because Pods and their clones come and go
    all the time, we need something permanent and tangible, something that will stay
    forever so our application's users (or other Pods as well) can discover and call.
    This brings us to the concept of Kubernetes services. Let's focus on them now.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是Kubernetes功能的重要部分。正如您所看到的，Pod的生命周期是脆弱且短暂的。因为Pod及其克隆品一直在出现和消失，我们需要一些永久和有形的东西，一些将永远存在，这样我们的应用程序用户（或其他Pod）可以发现并调用。这就引出了Kubernetes服务的概念。让我们现在专注于它们。
- en: Services
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Kubernetes services group one or more Pods into an internal or external process
    that needs to be long-running and externally accessible, as our Java REST API
    endpoint or a database host, for example. This is where the labels we gave to
    our Pods become very important; a service finds Pods to group by looking for a
    specific label. We use label selectors to select Pods with particular labels and
    apply services or ReplicaSets to them. Other applications can find our service
    through Kubernetes service discovery.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务将一个或多个Pod组合成一个内部或外部进程，需要长时间运行并且可以外部访问，例如我们的Java REST API端点或数据库主机。这就是我们为Pods分配标签非常重要的地方；服务通过寻找特定标签来查找要分组的Pods。我们使用标签选择器来选择具有特定标签的Pods，并将服务或副本集应用于它们。其他应用程序可以通过Kubernetes服务发现找到我们的服务。
- en: 'A service is Kubernetes'' abstraction to provide a network connection to one
    or more Pods. While (as you remember from the chapter about Docker networking),
    by default, Docker uses host-private networking, containers can communicate with
    other containers only if they are on the same host machine. In Kubernetes, cluster
    Pods can communicate with other Pods, regardless of which host they land on. This
    is possible because of the services. Each service is given its own IP address
    and port which remains constant for the lifetime of the service. Services have
    an integrated load-balancer that will distribute network traffic to all Pods.
    While a Pod''s life can be fragile as they are being spun up or down depending
    on your application needs, the service is a more constant concept. Each Pod gets
    its own IP address, but when it dies and another one is being brought to life,
    the IP address can be different. This could potentially become a problem--if a
    set of Pods provides functionality to other Pods inside the Kubernetes cluster,
    one can lose track of the other one''s IP address. Services, by having a lifetime-assigned
    IP address, solves this issue. The Service abstraction enables decoupling. Let''s
    say we have our Java REST service running on top of the Spring Boot application.
    We need a way to route HTTP requests, such as `GET` or `POST` , from the internet
    to our Docker containers. We will do it by setting up a Kubernetes service that
    uses a load balancer to route requests coming from a public IP address to one
    of the containers. We will group the containers with the REST service into a Pod
    and name it, let''s say, Our little REST service. Then we will define a Kubernetes
    service that will serve port `8080` to any of the containers in the Our little
    REST service Pod. Kubernetes will then use a load balancer to divide the traffic
    between the specified containers. Let''s summarize the Kubernetes service features:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是Kubernetes提供网络连接到一个或多个Pod的抽象。正如你从关于Docker网络的章节中记得的那样，默认情况下，Docker使用主机私有网络，容器只能在它们位于同一主机上时才能相互通信。在Kubernetes中，集群Pod可以与其他Pod通信，无论它们降落在哪个主机上。这是可能的，因为有了服务。每个服务都有自己的IP地址和端口，其在服务的生命周期内保持不变。服务具有集成的负载均衡器，将网络流量分发到所有Pod。虽然Pod的生命周期可能很脆弱，因为它们根据应用程序的需要被启动或关闭，但服务是一个更为持续的概念。每个Pod都有自己的IP地址，但当它死亡并且另一个被带到生活时，IP地址可能会不同。这可能会成为一个问题--如果一组Pod在Kubernetes集群内为其他Pod提供功能，一个可能会丢失另一个的IP地址。通过分配寿命的IP地址，服务解决了这个问题。服务抽象实现了解耦。假设我们的Java
    REST服务运行在Spring Boot应用程序之上。我们需要一种方式将来自互联网的HTTP请求，比如`GET`或`POST`，路由到我们的Docker容器。我们将通过设置一个使用负载均衡器将来自公共IP地址的请求路由到其中一个容器的Kubernetes服务来实现。我们将把包含REST服务的容器分组到一个Pod中，并命名为，比如，我们的小REST服务。然后我们将定义一个Kubernetes服务，它将为我们的小REST服务Pod中的任何容器提供端口`8080`。Kubernetes将使用负载均衡器在指定的容器之间分配流量。让我们总结一下Kubernetes服务的特点：
- en: Services are persistent and permanent
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是持久和永久的
- en: They provide discovery
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供发现
- en: They offer load balancing
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供负载均衡
- en: They expose a stable network IP address
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们暴露了一个稳定的网络IP地址
- en: They find Pods to group by usage of labels
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过标签的使用来查找要分组的Pod
- en: 'We have said that there is a service discovery mechanism built-in. Kubernetes
    supports two primary modes of finding a service: environment variables and DNS.
    Service discovery is the process of figuring out how to connect to a service.
    Kubernetes contains a built-in DNS server for that purpose: the kube-dns.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过有一个内置的服务发现机制。Kubernetes支持两种主要的查找服务的模式：环境变量和DNS。服务发现是找出如何连接到服务的过程。Kubernetes包含一个专门用于此目的的内置DNS服务器：kube-dns。
- en: kube-dns
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-dns
- en: Kubernetes offers a DNS cluster add-on, started automatically each time the
    cluster is started up. The DNS service runs as a cluster service itself--its SkyDNS--a
    distributed service for announcement and discovery of services built on top of
    `etcd` (you will get to know what etcd is later in this chapter). It utilizes
    DNS queries to discover available services. It supports forward lookups (A records),
    service lookups (SRV records), and reverse IP address lookups (PTR records). Actually,
    the service is the only type of object to which Kubernetes assigns DNS names;
    Kubernetes generates an internal DNS entry that resolves to a service's IP address.
    Services are assigned a DNS A record for a name in the form `service-name.namespace-name.svc.cluster.local`
    . This resolves to the cluster IP of the service. For example, for a service named
    `my-rest-service` , the DNS add-on will make sure that the service will be available
    for other Pods (and other services) in the cluster via the `my-rest-service.default.svc.cluster.local`
    hostname. The DNS-based service discovery provides a flexible and generic way
    to connect to services across the cluster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了一个DNS集群附加组件，每次集群启动时都会自动启动。DNS服务本身作为一个集群服务运行--它的SkyDNS--一个建立在`etcd`之上的服务的公告和发现的分布式服务（您将在本章后面了解到etcd是什么）。它利用DNS查询来发现可用的服务。它支持前向查找（A记录）、服务查找（SRV记录）和反向IP地址查找（PTR记录）。实际上，服务是Kubernetes分配DNS名称的唯一类型对象；Kubernetes生成一个解析为服务IP地址的内部DNS条目。服务被分配一个DNS
    A记录，格式为`service-name.namespace-name.svc.cluster.local`。这将解析为服务的集群IP。例如，对于一个名为`my-rest-service`的服务，DNS附加组件将确保该服务通过`my-rest-service.default.svc.cluster.local`主机名对集群中的其他Pod（和其他服务）可用。基于DNS的服务发现提供了一种灵活和通用的方式来连接整个集群中的服务。
- en: Note that when using the `hostNetwork=true` option, Kubernetes will use the
    host's DNS servers and will not use the cluster's DNS server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用`hostNetwork=true`选项时，Kubernetes将使用主机的DNS服务器，而不使用集群的DNS服务器。
- en: There's one more concept that will appear from time to time during our Kubernetes
    journey--a namespace. Let's find out what it's for.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Kubernetes之旅中，还有一个概念会不时出现--命名空间。让我们找出它的用途。
- en: Namespace
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace functions as a grouping mechanism inside of Kubernetes. Pods, volumes,
    ReplicaSets, and services can easily cooperate within a namespace, but the namespace
    provides an isolation from the other parts of the cluster. What would be the possible
    use case for such isolation? Well, namespaces let you manage different environments
    within the same cluster. For example, you can have different test and staging
    environments in the same cluster of machines.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间在Kubernetes内部作为一个分组机制。Pods、卷、ReplicaSets和服务可以在命名空间内轻松合作，但命名空间提供了与集群其他部分的隔离。这种隔离的可能用例是什么？好吧，命名空间让您在同一组机器的集群中管理不同的环境。例如，您可以在同一组机器的集群中拥有不同的测试和暂存环境。
- en: This could potentially save some resources in your infrastructure, but it can
    be dangerous; without namespaces, it would be risky to roll out a new version
    of your software to test the environment, having the pre-release version running
    on the same cluster. By having namespaces available, you can act on different
    environments in the same cluster without worrying about affecting other environments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会节省一些资源在您的基础设施中，但它可能是危险的；没有命名空间，将在同一集群上运行预发布版本的软件的新版本可能会有风险。有了可用的命名空间，您可以在同一集群中对不同的环境进行操作，而不必担心影响其他环境。
- en: Because Kubernetes uses the `default` namespace, using namespaces is optional,
    but recommended.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Kubernetes使用`default`命名空间，所以使用命名空间是可选的，但建议使用。
- en: We have all the Kubernetes abstractions explained--we know that there are Pods,
    ReplicaSets, Deployments, and services. Now it's time to move to the physical,
    execution layer of Kubernetes' architecture. All those little, fragile Pods need
    to live somewhere. They live in nodes, which we are going to learn about now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了所有Kubernetes的抽象概念--我们知道有Pods、ReplicaSets、部署和服务。现在是时候转向Kubernetes架构的物理执行层了。所有这些小而脆弱的Pod都需要存在的地方。它们存在于我们现在要了解的节点中。
- en: Nodes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: A node is a work horse in Kubernetes' architecture. It may be a virtual or physical
    machine, depending on your infrastructure. A worker node runs the tasks as instructed
    by the Master node, which we will explain very soon. Nodes (in the earlier Kubernetes
    life, they were called Minions) can run one or more Pods. They provide an application-specific
    virtual host in a containerized environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是Kubernetes架构中的工作马。它可以是虚拟机器或物理机器，这取决于您的基础设施。工作节点按照主节点的指示运行任务，我们很快会解释主节点是什么。节点（在早期的Kubernetes生命周期中，它们被称为Minions）可以运行一个或多个Pod。它们在容器化环境中提供特定于应用程序的虚拟主机。
- en: When a worker node dies, the Pods running on the node die as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作节点死机时，运行在该节点上的Pod也会死机。
- en: 'The following diagram shows the contents of a node:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了节点的内容：
- en: '![](Image00082.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00082.jpg)'
- en: As you can see in the previous diagram, a node in Kubernetes has some processes
    running inside, and each is very important. Let's explain their purposes, one
    by one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，Kubernetes中的节点内部运行着一些非常重要的进程。让我们逐一解释它们的目的。
- en: Kubelet
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubelet
- en: 'Kubelet is probably the most important controller in Kubernetes. It''s a process
    that responds to the commands coming from the Master node (we are going to explain
    what the Master node is in a second). Each node has this process listening. The
    Master calls it to manage Pods and their containers. The Kubelet runs Pods (which,
    as you already know, are collections of containers that share an IP and volumes).
    The Kubelet ([https://kubernetes.io/v1.0/docs/admin/kubelet/](https://kubernetes.io/v1.0/docs/admin/kubelet/)
    ) is responsible for what''s running on an individual machine and it has one job:
    given a set of containers to run, to make sure they are all running. To rephrase,
    a Kubelet is the name of the agent and a node is what we call the machine the
    agent runs on. It''s worth knowing that each Kubelet also has an internal `HTTP`
    server which listens for HTTP requests and responds to a simple API call to submit
    a new manifest.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet可能是Kubernetes中最重要的控制器。它是一个进程，响应来自主节点的命令（我们将在一秒钟内解释主节点是什么）。每个节点都有这个进程在监听。主节点调用它来管理Pod及其容器。Kubelet运行Pod（正如您已经知道的，它们是共享IP和卷的容器集合）。Kubelet（[https://kubernetes.io/v1.0/docs/admin/kubelet/](https://kubernetes.io/v1.0/docs/admin/kubelet/)）负责在单个机器上运行的内容，它有一个任务：确保所有容器都在运行。换句话说，Kubelet是代理的名称，节点是代理运行的机器的名称。值得知道的是，每个Kubelet还有一个内部的`HTTP`服务器，它监听HTTP请求并响应简单的API调用以提交新的清单。
- en: Proxy
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: A proxy is a network proxy that creates a virtual IP address which clients can
    access. The network calls will be transparently proxied to the Pods in a Kubernetes
    service. A service, as you already know, provides a way to group Pods into kind
    of a single business process, which can be reached under a common access policy.
    By having a proxy run on a node, we can call the service IP address. Technically,
    a node's proxy is a `kube-proxy` ([https://kubernetes.io/docs/admin/kube-proxy/](https://kubernetes.io/docs/admin/kube-proxy/)
    ) process which programs `iptables` rules to trap access to the service IP address.
    The Kubernetes network proxy runs on each node. Without it, we would not be able
    to access the service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一个创建虚拟IP地址的网络代理，客户端可以访问该地址。网络调用将被透明地代理到Kubernetes服务中的Pod。正如您已经知道的那样，服务提供了一种将Pod分组成单一业务流程的方式，可以在共同的访问策略下访问。通过在节点上运行代理，我们可以调用服务IP地址。从技术上讲，节点的代理是一个`kube-proxy`
    ([https://kubernetes.io/docs/admin/kube-proxy/](https://kubernetes.io/docs/admin/kube-proxy/))
    进程，它编程`iptables`规则来捕获对服务IP地址的访问。Kubernetes网络代理在每个节点上运行。没有它，我们将无法访问服务。
- en: '`kube-proxy` knows only UDP and TCP, does not understand HTTP, provides load
    balancing, and is just used to reach services.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-proxy`只知道UDP和TCP，不理解HTTP，提供负载平衡，只用于访问服务。'
- en: Docker
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Finally, each node needs something to run. It will be a Docker container runtime,
    which is responsible for pulling the images and running containers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个节点都需要运行一些东西。这将是一个Docker容器运行时，负责拉取镜像并运行容器。
- en: 'All those nodes, as any other group of workers in the real world, need a manager.
    In Kubernetes, the role of the node manager is being performed by one special
    node: the Master node.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些节点，就像现实世界中的任何其他工作人员组一样，都需要一个管理者。在Kubernetes中，节点管理器的角色由一个特殊的节点执行：主节点。
- en: The Master node
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点
- en: 'The Master node does not run any containers--it just handles and manages the
    cluster. The Master is the central control point that provides a unified view
    of the cluster. There is a single Master node that controls multiple worker nodes,
    which actually run our containers. The Master automatically handles the scheduling
    of the Pods across the worker nodes in the cluster -by taking into account the
    available resources on each node. The structure of the Master node is presented
    in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点不运行任何容器--它只处理和管理集群。主节点是提供集群统一视图的中央控制点。有一个单独的主节点控制多个工作节点，实际上运行我们的容器。主节点自动处理跨集群工作节点的Pod调度-考虑到每个节点上的可用资源。主节点的结构如下图所示：
- en: '![](Image00083.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00083.jpg)'
- en: Let's dissect the Master node piece by piece, starting with `etcd` .
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解析主节点，从`etcd`开始。
- en: etcd
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd
- en: 'Kubernetes stores all of its cluster state in [`etcd`](https://github.com/coreos/etcd)
    , a distributed data store with a strong consistency model. `etcd` is a distributed,
    reliable key-value store for the most critical data of a distributed system, with
    a focus on being:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将其所有集群状态存储在[`etcd`](https://github.com/coreos/etcd)，这是一个具有强一致性模型的分布式数据存储。`etcd`是一个分布式、可靠的关键值存储，用于分布式系统的最关键数据，重点是：
- en: '**Simple** : Well-defined, user-facing API'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单**：定义明确的面向用户的API'
- en: '**Secure** : Automatic TLS with optional client cert authentication'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：自动TLS，可选客户端证书认证'
- en: '**Fast** : Benchmarked for 10,000 writes/sec'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：经过基准测试，每秒10,000次写入'
- en: '**Reliable** : Properly distributed using Raft'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠**：使用Raft正确分布'
- en: This state includes what nodes exist in the cluster, what Pods should be running,
    which nodes they are running on, and a whole lot more. The whole cluster state
    is stored in an instance of `etcd` . This provides a way to store configuration
    data reliably. Another crucial component running on the Master node is the API
    server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态包括集群中存在哪些节点，应该运行哪些Pod，它们运行在哪些节点上，以及更多其他信息。整个集群状态存储在一个`etcd`实例中。这提供了一种可靠地存储配置数据的方式。另一个在主节点上运行的关键组件是API服务器。
- en: The API server
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API服务器
- en: One of the main components residing on the Master node is the API server. It's
    so important that sometimes, you may find out that the Master node is being referred
    to as the API server in general. Technically, it's a process named `kube-apiserver`
    which accepts and responds to `HTTP` `REST` requests using JSON. It's main purpose
    is to validate and configure data for the API objects which are Pods, services,
    ReplicaSets, and others. The API server provides the frontend to the cluster's
    shared state through which all other components interact. The API server is the
    central management entity and is the only Kubernetes component that connects to
    etcd. All the other components must go through the API server to work with the
    cluster state. We will cover the Kubernetes API in detail in [Chapter 9](text00180.html)
    , *Working With Kubernetes API* .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点上驻留的主要组件之一是API服务器。它非常重要，以至于有时候，您可能会发现主节点通常被称为API服务器。从技术上讲，它是一个名为`kube-apiserver`的进程，它接受并响应使用JSON的`HTTP`
    `REST`请求。它的主要目的是验证和配置API对象的数据，这些对象包括Pod、服务、ReplicaSets等。API服务器通过提供集群的共享状态的前端，使所有其他组件进行交互。API服务器是中央管理实体，是唯一连接到etcd的Kubernetes组件。所有其他组件必须通过API服务器来处理集群状态。我们将在[第9章](text00180.html)中详细介绍Kubernetes
    API，*使用Kubernetes API*。
- en: The Master node does not run any containers--it just handles and manages the
    whole cluster. The nodes that actually run the containers are the worker nodes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点不运行任何容器--它只处理和管理整个集群。实际运行容器的节点是工作节点。
- en: The scheduler
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器
- en: As we have said before, if you create a Deployment, the Master will schedule
    the distribution of application instances onto individual nodes in the cluster.
    Once the application instances are up and running, the Deployment Controller will
    be continuously monitoring those instances. This is kind of a self-healing mechanism--if
    a node goes down or is deleted, the Deployment Controller replaces it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，如果您创建一个部署，主节点将安排将应用实例分布到集群中的各个节点上。一旦应用实例启动并运行，部署控制器将持续监视这些实例。这是一种自我修复机制--如果一个节点宕机或被删除，部署控制器将替换它。
- en: Now that we know what the Kubernetes specific components are that form it's
    architecture, let's look what tools are available for us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了构成Kubernetes架构的特定组件是什么，让我们看看有哪些工具可供我们使用。
- en: Available tools
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用工具
- en: 'There are a couple of tools we will be using throughout the rest of the book.
    Let''s start with the most important one: `kubectl` .'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用一些工具。让我们从最重要的工具`kubectl`开始。
- en: kubectl
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl
- en: '`kubectl` is a command-line interface for running commands against Kubernetes
    clusters. In fact, this is the command used most often when working with Kubernetes.
    In [Chapter 8](text00159.html) , *Using Kubernetes with Java* , we will go through
    the command''s syntax and possible usages. Using `kubectl` , you will be interacting
    with your cluster. Of course, having the API exposed by the Master node and the
    API server, we could do it using an `HTTP` client of our choice, but using `kubectl`
    is a lot faster and more convenient. `kubectl` provides a lot of functionalities,
    such as listing resources, showing detailed information about the resources, prints
    log, managing cluster, and executing commands on a container in a Pod.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`是针对Kubernetes集群运行命令的命令行界面。事实上，这是在使用Kubernetes时最常用的命令。在[第8章](text00159.html)，*使用Java与Kubernetes*中，我们将介绍命令的语法和可能的用法。使用`kubectl`，您将与您的集群进行交互。当然，通过主节点和API服务器公开的API，我们可以使用我们选择的`HTTP`客户端来执行，但使用`kubectl`更快速和更方便。`kubectl`提供了许多功能，例如列出资源、显示有关资源的详细信息、打印日志、管理集群以及在Pod中执行容器上的命令。'
- en: Dashboard
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板
- en: Kubernetes Dashboard is a nice, clean web-based UI for Kubernetes clusters.
    Using the Dashboard, you can manage and troubleshoot the cluster itself as well
    as the applications running in it. You could say it's the Kubernetes user interface.
    For those who prefer to use the graphical UI, the Dashboard can be a handy tool
    for deploying containerized applications and getting an overview of applications
    running on your cluster, as well as for creating or modifying individual resources
    such as Deployments, Pods, and services. For example, you can scale a Deployment,
    initiate a rolling update, restart a Pod, or deploy new applications using a deploy
    wizard. We will also use the Dashboard in [Chapter 8](text00159.html) , *Using
    Kubernetes with Java* .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板是一个漂亮、干净的基于Web的UI，用于Kubernetes集群。使用仪表板，您可以管理和排除集群本身以及其中运行的应用程序。你可以说它是Kubernetes的用户界面。对于那些喜欢使用图形界面的人来说，仪表板可以是一个方便的工具，用于部署容器化应用程序并概览集群中运行的应用程序，以及创建或修改诸如部署、Pod和服务等个别资源。例如，您可以扩展部署，启动滚动更新，重新启动Pod，或使用部署向导部署新应用程序。我们还将在[第8章](text00159.html)，*使用Java与Kubernetes*中使用仪表板。
- en: Minikube
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minikube
- en: Running a cluster seems to be a complicated process that needs a lot of setup.
    This is not necessarily the truth. Actually, it's quite easy to have the Kubernetes
    cluster up and running on the local machine, for learning, testing, and development
    purposes. The `minikube` tool, available at GitHub at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)
    , allows you to set up the local cluster on your own machine. It's available for
    all major platforms, which includes Linux, macOS, and Windows. The cluster started
    will of course be a single node cluster, but it's more than enough to start doing
    real-life Kubernetes examples. In fact, in [Chapter 8](text00159.html) , *Using
    Kubernetes with Java* , before we start deploying our `REST` service into the
    cluster, we are going to run Kubernetes locally.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行集群似乎是一个需要大量设置的复杂过程。这并不一定是事实。实际上，在本地机器上轻松运行Kubernetes集群以进行学习、测试和开发是相当容易的。在GitHub上提供的`minikube`工具[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)允许您在自己的机器上设置本地集群。它适用于所有主要平台，包括Linux、macOS和Windows。启动的集群当然将是单节点集群，但这已经足够开始进行实际的Kubernetes示例。实际上，在[第8章](text00159.html)，*使用Java与Kubernetes*中，在我们开始将我们的`REST`服务部署到集群之前，我们将在本地运行Kubernetes。
- en: Apart from those mentioned previously, you may find a lot of other tools and
    utilities that work very well with Kubernetes on the internet.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的之外，您可能会在互联网上找到许多其他与Kubernetes非常配合的工具和实用程序。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced a lot of new concepts. Let's briefly summarize what
    we have learned about the Kubernetes architecture.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多新概念。让我们简要总结一下我们对Kubernetes架构的了解。
- en: 'Kubernetes (k8s) is an open source platform for automating container operations
    such as deployment, scheduling, and scalability across a cluster of nodes. Using
    Kubernetes, you can:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（k8s）是一个用于自动化容器操作的开源平台，如部署、调度和在节点集群中扩展。使用Kubernetes，您可以：
- en: Automate the deployment and replication of containers
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署和复制容器
- en: Scale up and down containers on the fly
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在飞行中扩展和缩小容器
- en: Organize containers in groups and provide load balancing between them
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器组织成组，并在它们之间提供负载平衡
- en: Easily roll out new versions of application containers
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松推出应用程序容器的新版本
- en: Provide fault tolerance mechanisms to your application--if a container dies
    it gets replaced
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序提供容错机制——如果一个容器死了，它会被替换
- en: 'Kubernetes consists of:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes包括：
- en: '**A Cluster** : A group of nodes.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群**：一组节点。'
- en: '**Nodes** : Physical or virtual machines that act as workers. Each node runs
    the kubelet, proxy, and a Docker engine process.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：作为工作者的物理或虚拟机。每个节点运行kubelet、代理和Docker引擎进程。'
- en: '**The Master node** : Provides a unified view into the cluster. It delivers
    the Kubernetes API server. The API server provides a `REST` endpoint that can
    be used to interact with the cluster. The Master also includes the controllers
    used to create and replicate Pods.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主节点**：提供对集群的统一视图。它提供了Kubernetes API服务器。API服务器提供了一个`REST`端点，可用于与集群交互。主节点还包括用于创建和复制Pods的控制器。'
- en: '**Pods** : Scheduled to nodes. Each Pod runs a single container or a group
    of containers and volumes. Containers in the same Pod share the same network namespace
    and volumes and can communicate with each other using localhost. Their life is
    fragile; they will be born and die all the time.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pods**：被调度到节点。每个Pod运行一个单独的容器或一组容器和卷。同一Pod中的容器共享相同的网络命名空间和卷，并可以使用本地主机相互通信。它们的生命是脆弱的；它们会不断诞生和死亡。'
- en: '**Labels** : Pods have labels, with key/value pairs attached. Labels are used
    to precisely select Pods.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：Pods具有附加的键/值对标签。标签用于精确选择Pods。'
- en: '**Services** : An abstraction that defines a set of Pods and a policy to access
    them. Services find their group of Pods by using label selectors. Because the
    IP of the single Pod can change, the service provides a permanent IP address for
    its client to use.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：定义一组Pods和访问它们的策略的抽象。服务通过使用标签选择器来找到它们的Pod组。因为单个Pod的IP可能会改变，所以服务为其客户端提供了一个永久的IP地址。'
- en: That was a piece of theory that may be a bit overwhelming. Don't worry, in [Chapter
    8](text00159.html) , *Using Kubernetes with Java* , we are going to run the local
    Kubernetes cluster. Our plan will consist of creating a local Kubernetes cluster
    using `minikube` . We will then deploy and manage Docker containers with our Java
    REST microservice. By doing some practical, hands-on actions, the Kubernetes architecture
    will be a lot more clear. Running a local Kubernetes is not the only thing we
    are going to do. Later on, in [Chapter 10](text00205.html) , *Deploying Java on
    Kubernetes in the Cloud* , we will put our application in the real cloud--a place
    where Kubernetes really shines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人不知所措的理论。别担心，在[第8章](text00159.html)，*使用Java与Kubernetes*中，我们将运行本地Kubernetes集群。我们的计划将包括使用`minikube`创建本地Kubernetes集群。然后，我们将使用我们的Java
    REST微服务部署和管理Docker容器。通过一些实际的、动手操作，Kubernetes架构将会更加清晰。运行本地Kubernetes并不是我们要做的唯一的事情。稍后，在[第10章](text00205.html)，*在云中部署Java到Kubernetes*中，我们将把我们的应用程序放在真正的云端——那是Kubernetes真正发光的地方。
