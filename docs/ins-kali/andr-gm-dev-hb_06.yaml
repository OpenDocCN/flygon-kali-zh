- en: Chapter 6. Improving Performance of 2D/3D Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。提高2D/3D游戏性能
- en: Once upon a time, gaming on the mobile platform was limited to black-and-white
    pixel games, and other mediums of gaming were also heavily dependent on pixel
    graphics. Times have changed now. 3D games are running on handhelds with ease.
    However, the requirement of 2D assets has not changed yet. Even in a hardcore
    3D game, 2D assets are mandatory. Few games are fully 2D.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，移动平台上的游戏局限于黑白像素游戏，其他游戏媒介也严重依赖像素图形。现在时代已经改变。3D游戏在手持设备上轻松运行。然而，对2D资产的需求尚未改变。即使在
    hardcore 3D 游戏中，2D资产也是必需的。很少有游戏是完全2D的。
- en: 'We will discuss the performance of 2D and 3D games here with the help of the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下主题的帮助下讨论2D和3D游戏的性能：
- en: 2D game development constraints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D游戏开发的限制
- en: 3D game development constraints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D游戏开发的限制
- en: The rendering pipeline in Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android的渲染管道
- en: Rendering through OpenGL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过OpenGL渲染
- en: Optimizing 2D assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化2D资产
- en: Optimizing 3D assets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化3D资产
- en: Common game development mistakes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的游戏开发错误
- en: 2D/3D performance comparison
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D/3D性能比较
- en: 2D game development constraints
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D游戏开发的限制
- en: 'From the perspective of 2D game development, the main constraints are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从2D游戏开发的角度来看，主要的限制如下：
- en: 2D art assets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D艺术资产
- en: 2D rendering system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D渲染系统
- en: 2D mapping
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D映射
- en: 2D physics
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D物理
- en: 2D art assets
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D艺术资产
- en: Art asset constraints are mainly limited to graphical or visual assets, which
    include images, sprites, and fonts. It is not difficult to understand that a larger
    asset will take more time to process and render than a smaller asset, resulting
    in less performance quality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资产的限制主要限于图形或视觉资产，包括图像、精灵和字体。不难理解，较大的资产将比较小的资产需要更多的时间来处理和渲染，从而导致性能质量较低。
- en: Sets of 2D art assets
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一组2D艺术资产
- en: It is not possible to deliver maximum display quality with a single set of assets
    in Android game development. This is the reason most Android game developers choose
    high-resolution assets as their base build. This normally performs well for high-configuration
    hardware platforms, but does not provide quality performance on low-configuration
    devices. Many developers opt for the option of porting for multiple resolution
    hardware platforms. This again takes time to complete the project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android游戏开发中，不可能通过一组资产提供最大的显示质量。这是大多数Android游戏开发人员选择高分辨率资产作为基础构建的原因。这通常对高配置硬件平台表现良好，但在低配置设备上无法提供良好的性能。许多开发人员选择为多分辨率硬件平台进行移植的选项。这再次需要时间来完成项目。
- en: Same asset set for multiple resolutions
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多分辨率使用相同的资产集
- en: Many times, developers choose to ignore a set of hardware platforms. Mostly,
    in the mobile gaming industry, it is a common practice to choose higher resolution
    art assets and fit them into lower resolution devices by scaling down. Nowadays,
    most hardware platforms have better RAM. Hence, this process has become convenient
    for developers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，开发人员选择忽略一组硬件平台。在移动游戏行业中，选择更高分辨率的艺术资产并将其缩小适应较低分辨率设备是一种常见做法。如今，大多数硬件平台都有更好的RAM。因此，这个过程对开发人员来说变得更加方便。
- en: Number of assets drawn on screen
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕上绘制的资产数量
- en: Game performance does not always depend on the asset size; it also depends on
    the number of assets that are being drawn on screen. The concept of a sprite sheet
    has evolved to reduce the number of drawing elements on screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏性能并不总是取决于资产大小；它还取决于屏幕上绘制的资产数量。精灵表的概念已经发展，以减少屏幕上绘制元素的数量。
- en: Generally, the system issues a call for a draw instruction for a single art
    asset. As the number of assets increases, it takes more such draw instructions
    to complete the rendering in each game loop cycle. Obviously, this process slows
    down the processor, and the game performance becomes poor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统会为单个艺术资产发出绘制指令。随着资产数量的增加，需要更多这样的绘制指令才能在每个游戏循环周期内完成渲染。显然，这个过程会减慢处理器的速度，游戏性能变差。
- en: A sprite sheet can consist of multiple assets within a single image. So, it
    takes only one draw instruction to render all the assets of the sprites. However,
    the physical size of the sprite sheet is restricted. The maximum size varies for
    different devices with different hardware platforms. Most conveniently, 1024x1024
    sprites are the safest option to use, as they are supported by almost all the
    available devices in the current scenario.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表可以包含单个图像中的多个资产。因此，只需要一个绘制指令就可以渲染精灵的所有资产。然而，精灵表的物理大小是受限制的。不同硬件平台的设备的最大尺寸各不相同。最方便的是，1024x1024的精灵是目前几乎所有可用设备支持的最安全选项。
- en: Use of font files
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字体文件
- en: 'Almost every game uses custom or special fonts other than the default system
    font of Android. In those cases, the font source file has to be included in the
    game build. There are multiple ways to use different fonts. We will discuss three
    of them here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个游戏都使用除了Android默认系统字体之外的自定义或特殊字体。在这些情况下，字体源文件必须包含在游戏构建中。有多种使用不同字体的方法。我们将在这里讨论其中三种：
- en: Sprite font
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵字体
- en: Bitmap font
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图字体
- en: TrueType font
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrueType字体
- en: Sprite font
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 精灵字体
- en: This is a typical old school technique but is still effective in some cases.
    The developer creates a sprite sheet that contains all the necessary characters.
    All the characters are mapped within a data file. This mapping is used to clip
    each character and form words accordingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的老派技术，但在某些情况下仍然有效。开发人员创建一个包含所有必要字符的精灵表。所有字符都在数据文件中映射。这种映射用于裁剪每个字符并相应地形成单词。
- en: 'Here are some advantages of this font:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些优点包括：
- en: Developers have total control of mapping
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员完全控制映射
- en: Character stylization can be customized as per requirement
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符风格可以根据需求定制
- en: Fast processing speed can be achieved; however, it will depend on development
    efficiency
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以实现快速处理速度；但这将取决于开发效率
- en: 'Here are some disadvantages of this font:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些缺点包括：
- en: They increase development overhead
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们增加了开发开销
- en: The system efficiency entirely depends on the developer's skill set
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统效率完全取决于开发人员的技能
- en: It is very difficult to map characters in the case of multi-language support
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多语言支持的情况下很难映射字符
- en: Any change takes a lot of iteration to achieve perfection
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何更改都需要大量迭代才能达到完美
- en: This style is not usually used nowadays as we have many designer and stylish
    fonts available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式现在通常不再使用，因为我们有许多设计师和时尚字体可用。
- en: Bitmap font
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位图字体
- en: The bitmap font system is inherited from the sprite font. It is updated with
    a predefined mapping style and a library to support development process. It also
    uses one or more sprite sheets with one data file. The working principle of bitmap
    font is the same as sprite font. There are a lot of tools available to create
    such fonts with a bit of stylization directly from the TrueType font.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 位图字体系统是从精灵字体继承而来的。它更新了预定义的映射样式和支持开发过程的库。它还使用一个或多个精灵表和一个数据文件。位图字体的工作原理与精灵字体相同。有很多工具可以直接从TrueType字体创建这样的字体，并进行一些样式化。
- en: 'Here are some advantages of this font:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些优点包括：
- en: It is compatible with any existing codebase, irrespective of the rendering framework,
    whether it is OpenGL, DirectX, Direct Draw, or GDI+
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与任何现有的代码库兼容，无论渲染框架是OpenGL、DirectX、Direct Draw还是GDI+
- en: It is easy to integrate
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于集成
- en: It can manipulate the style of the existing TrueType font
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以操纵现有TrueType字体的样式
- en: 'Here are some disadvantages of this font:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些缺点包括：
- en: The same disadvantages of the sprite font are applicable here, only with less
    development overhead
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵字体的相同缺点在这里也适用，只是开发开销更小
- en: Scaling up the bitmap font results in blurry output
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大位图字体会导致模糊的输出
- en: TrueType font
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TrueType字体
- en: This is the universal format of font that is supported by most platforms, including
    Android. It is the fastest way to integrate various fonts in games.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数平台支持的通用字体格式，包括Android。这是在游戏中集成各种字体的最快速的方法。
- en: 'Here are some advantages of this font:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些优点包括：
- en: Universal font style
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用字体样式
- en: Maximum platform support
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的平台支持
- en: Easy multi-language implementation
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于多语言实现
- en: This is a vector font, so it has no scaling issue
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种矢量字体，所以它没有缩放问题
- en: Easy special character availability
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于获得特殊字符
- en: 'Here are some disadvantages of this font:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字体的一些缺点包括：
- en: Using this font style may cost a few kilobytes extra to the game
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种字体样式可能会使游戏多花费几千字节
- en: Not all scripting languages are supported by TTF
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有脚本语言都受TTF支持
- en: 2D rendering system
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D渲染系统
- en: Android provides a scope to render 2D assets onto the canvas through an API
    framework. Canvas can be used with `Drawable` objects in `View` or `SurfaceView`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了通过API框架将2D资产渲染到画布的范围。画布可以与`View`或`SurfaceView`中的`Drawable`对象一起使用。
- en: Canvas acts as an interface of the actual drawing surface upon which all the
    graphical objects can be drawn. Draw on the canvas happens within the `onDraw()`
    callback method. The developer just needs to specify graphical objects along with
    their position on the canvas.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 画布充当实际绘图表面的接口，所有的图形对象都可以在其上绘制。在`onDraw()`回调方法中绘制画布上的图形对象。开发人员只需指定图形对象及其在画布上的位置。
- en: 'Canvas itself has a set of default drawing methods to render almost each type
    of graphical objects. Here are some examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 画布本身具有一组默认的绘图方法，可以渲染几乎每种类型的图形对象。以下是一些例子：
- en: The `drawBitmap()` method is used to draw image objects in the bitmap format.
    However, images need not be in bitmap format.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawBitmap()`方法用于以位图格式绘制图像对象。但是，图像不需要以位图格式。'
- en: The `drawRect()` and `drawLine()` methods are used to draw primitive shapes
    on the canvas.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawRect()`和`drawLine()`方法用于在画布上绘制原始形状。'
- en: The `drawText()` method can be used to render text on canvas using a specific
    font style.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawText()`方法可用于使用特定字体样式在画布上渲染文本。'
- en: Canvas can be used within a view in the Android architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 画布可以在Android架构中的视图中使用。
- en: 2D mapping
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D映射
- en: '2D mapping is based on a simple 2D coordinate system. The only difference is
    the opposite *y* axis in comparison with the conventional coordinate system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 2D映射基于简单的2D坐标系。唯一的区别是与传统坐标系相比相反的*y*轴：
- en: '![2D mapping](img/B05069_06_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![2D映射](img/B05069_06_01.jpg)'
- en: In Android 2D, the origin is located in the top-left corner of the canvas. All
    the geometrical calculations are based on this mapping. However, it has no direct
    effect on the performance like the 2D canvas-based application has. Many developers
    are used to mapping their graphic assets based on the conventional system, and
    they reverse the vertical axis to render it on the canvas. This requires some
    additional calculation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 2D中，原点位于画布的左上角。所有的几何计算都是基于这种映射的。然而，它对性能没有直接影响，就像基于2D画布的应用程序一样。许多开发人员习惯于根据传统系统映射他们的图形资产，并颠倒垂直轴以在画布上渲染它。这需要一些额外的计算。
- en: There is one more performance constraint regarding the 2D rendering systems.
    A common development approach across the world is to have a minimum set of graphic
    assets and use them as much as possible. Often, this leads to rendering the same
    pixel multiple times. This affects the processing speed and hence the FPS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于2D渲染系统还有一个性能约束。全球通用的开发方法是拥有一组最小的图形资产，并尽可能多地使用它们。经常会导致同一像素多次渲染。这会影响处理速度，从而影响FPS。
- en: 'For example, bitmap **A**, bitmap **B**, bitmap **C**, and bitmap **D** are
    being rendered on a canvas in such a way that **A**, **B**, and **C** overlap
    each other, and **D** remains separate. The following happens:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，位图**A**、位图**B**、位图**C**和位图**D**以一种使**A**、**B**和**C**重叠在一起，而**D**保持独立的方式在画布上呈现。以下情况发生：
- en: Pixels in the region **R0** where only one bitmap is drawn will be rendered
    once
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在只绘制一个位图的区域**R0**中的像素将被渲染一次
- en: Pixels in region **R1** where two bitmaps are overlapping will be rendered twice
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个位图重叠的区域**R1**中的像素将被渲染两次
- en: Pixels in region **R2** where three bitmaps are overlapping will be rendered
    three times
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在区域**R2**中，三个位图重叠的像素将被渲染三次
- en: 'This is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里显示：
- en: '![2D mapping](img/B05069_06_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![2D映射](img/B05069_06_02.jpg)'
- en: Now, in regions **R1** and **R2**, all the pixels are rendered multiple times.
    In this system, the pixel data information will append to the previous data, resulting
    in the final pixel value. In this system, the processing overhead increases. Hence,
    performance decreases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在区域**R1**和**R2**，所有像素都被渲染多次。在这个系统中，像素数据信息将附加到先前的数据上，导致最终像素值。在这个系统中，处理开销增加。因此，性能下降。
- en: 'Even today, it is a common practice for 2D game programming. The reasons are
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，这仍然是2D游戏编程的常见做法。原因如下：
- en: Transparency blending
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度混合
- en: Modular graphical assets
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化图形资源
- en: Low build size
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低构建大小
- en: Easy construction of screens by overlapping multiple assets
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过叠加多个资源轻松构建屏幕
- en: Sometimes, there may be a scenario where a device has a very low-performing
    graphics processor, and rendering the same pixel multiple times has a major impact
    on performance. In this scenario, the double buffer mechanism helps a lot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会出现设备的图形处理器性能非常低，多次渲染同一个像素对性能有很大影响。在这种情况下，双缓冲机制会有很大帮助。
- en: 'The double buffering system refers to creating a buffered displayable asset
    in which the display screen is created using graphic assets. Then, this buffered
    object is drawn on the screen only once. It prevents the following issues:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 双缓冲系统是指创建一个缓冲的可显示资源，使用图形资源创建显示屏，然后只在屏幕上绘制一次这个缓冲对象。它可以防止以下问题：
- en: Flickering of screen
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕闪烁
- en: Multiple draws of one pixel
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个像素的多次绘制
- en: Tearing of assets
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的撕裂
- en: 2D physics
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D物理
- en: 2D physics takes only the *x-y* plane into consideration for all the calculations.
    There are plenty of 2D physics engines available in market. **Box2D** is the most
    popular one. A physics engine consists of every mechanism and calculation of real-time
    physics.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 2D物理只考虑*x-y*平面上的所有计算。市场上有很多2D物理引擎可用。**Box2D**是最流行的一个。物理引擎包括实时物理的每一个机制和计算。
- en: Real-time physics calculation is much complicated than is required in games.
    Let's discuss a few available physics engines.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实时物理计算比游戏所需的要复杂得多。让我们讨论一下一些可用的物理引擎。
- en: Box2D
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box2D
- en: 'Box2D is an open source physics engine based on C++. It consists of almost
    every aspect of solid physics that can be used in various games. A few of its
    mentionable features are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D是一个基于C++的开源物理引擎。它包括几乎可以用于各种游戏的固体物理的每一个方面。它的一些值得一提的特性如下：
- en: Dynamic collision detection of rigid bodies
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体的动态碰撞检测
- en: Collision state callbacks, such as collision enter, exit, stay, and so on
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞状态回调，如碰撞进入、退出、停留等
- en: Polygonal collision
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形碰撞
- en: Vertical, horizontal, and projectile motion
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直、水平和抛射运动
- en: Friction physics
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩擦物理
- en: Torque and momentum physics
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭矩和动量物理
- en: Gravity effects based on pivot point and joints
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于枢轴点和关节的重力效应
- en: LiquidFun
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LiquidFun
- en: 'LiquidFun is a physics engine with all aspects of liquid physics. This engine
    is actually based on Box2D. Google released this open source physics engine to
    cover the liquid physics formula and mechanism. LiquidFun can be used for Android,
    iOS, Windows, and a few other popular platforms. LiquidFun supports every feature
    of Box2D, along with liquid particle physics. This includes the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: LiquidFun是一个液体物理的物理引擎。这个引擎实际上是基于Box2D的。谷歌发布了这个开源物理引擎来覆盖液体物理的公式和机制。LiquidFun可以用于Android、iOS、Windows和其他一些流行的平台。LiquidFun支持Box2D的每一个特性，以及液体粒子物理。这包括以下内容：
- en: Wave simulation
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波浪模拟
- en: Liquid fall and particle simulation
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 液体下落和粒子模拟
- en: Liquid stir simulation
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 液体搅拌模拟
- en: Solid and liquid dynamic collision
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固体和液体动态碰撞
- en: Liquid mixing
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 液体混合
- en: Performance impact on games
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对游戏性能的影响
- en: Collision detection is a costly process. Multi-edge and polygonal collisions
    increase the process overhead. The number of rigid bodies and collision surfaces
    have the maximum impact on performance. This is why liquid physics is slower than
    solid physics.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测是一个昂贵的过程。多边缘和多边形碰撞会增加处理开销。刚体和碰撞表面的数量对性能有最大的影响。这就是为什么液体物理比固体物理慢的原因。
- en: 'Let''s have a look at the major impacts:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下主要影响：
- en: Each transformation of any rigid body requires a refresh on the collision check
    of the entire system
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何刚体的每次变换都需要刷新整个系统的碰撞检查
- en: The physics engine is responsible for repetitive transform change, which is
    responsible for heavy processes
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引擎负责重复的变换，这导致了繁重的过程
- en: Each and every possible force on the rigid body is calculated in the physics
    engine. Not all the games require every calculation. Game development does not
    always required real-time implementation of physics. However, real-time visualization
    is required for games.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎计算刚体上的每一个可能的力。并不是所有的游戏都需要进行每一项计算。游戏开发并不总是需要实时实现物理。然而，游戏需要实时可视化。
- en: 2D collision detection
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D碰撞检测
- en: Most games use the box-colliding system to detect most collisions. Rectangular
    collision detection is the cheapest possible method, which can be used inside
    games to detect collisions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏使用盒子碰撞系统来检测大多数碰撞。矩形碰撞检测是最便宜的方法，可以在游戏内用于检测碰撞。
- en: Sometimes, triangular and circular collision detection is also used for 2D games
    for collision detection accuracy. There needs to be a balance of using such methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，三角形和圆形碰撞检测也用于2D游戏以提高碰撞检测的准确性。需要在使用这些方法之间取得平衡。
- en: 'For example, if we need to detect the collision between two circles, we can
    opt for any of these systems:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要检测两个圆之间的碰撞，我们可以选择以下任何一个系统：
- en: Considering each circle a rectangle and detecting the collision between them
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个圆视为矩形并检测它们之间的碰撞
- en: Considering one circle a rectangle and detecting the collision between the circle
    and rectangle
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个圆视为矩形，并检测圆和矩形之间的碰撞
- en: Applying the actual circular collision detection method
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用实际的圆形碰撞检测方法
- en: 'Let''s consider two circles having origins *O1* and *O2* and diameters *R1*
    and *R2*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个圆，它们的原点分别是*O1*和*O2*，直径分别是*R1*和*R2*：
- en: '*O1* is located at *(Ox1, Oy1)*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*O1*位于*(Ox1, Oy1)*'
- en: '*O2* is located at *(Ox2, Oy2)*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*O2*位于*(Ox2, Oy2)*'
- en: Rectangle collision
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形碰撞
- en: 'If we imagine the circles as rectangles on a 2D canvas, then it will look like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象圆在2D画布上是矩形，那么它会是这样的：
- en: '![Rectangle collision](img/B05069_06_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![矩形碰撞](img/B05069_06_03.jpg)'
- en: Rectangular collision detection refers to this formula.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形碰撞检测指的是这个公式。
- en: 'Input feed will be as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输入反馈将如下：
- en: '*xMin1 = x1* (minimum co-ordinate on *x* axis of first rectangle)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*xMin1 = x1*（第一个矩形在*x*轴上的最小坐标）'
- en: '*yMin1 = y1* (minimum co-ordinate on *y* axis of the first rectangle)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*yMin1 = y1*（第一个矩形在*y*轴上的最小坐标）'
- en: '*xMax1 = x1m* (maximum co-ordinate on *x* axis of the first rectangle)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*xMax1 = x1m*（第一个矩形在*x*轴上的最大坐标）'
- en: '*yMax1 = y1m* (maximum co-ordinate on *y* axis of the first rectangle)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*yMax1 = y1m*（第一个矩形在*y*轴上的最大坐标）'
- en: '*xMin2 = x2* (minimum co-ordinate on *x* axis of the second rectangle)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*xMin2 = x2*（第二个矩形在*x*轴上的最小坐标）'
- en: '*yMin2 = y2* (minimum co-ordinate on *y* axis of the second rectangle)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*yMin2 = y2*（第二个矩形在*y*轴上的最小坐标）'
- en: '*xMax2 = x2m* (maximum co-ordinate on *x* axis of the second rectangle)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*xMax2 = x2m*（第二个矩形在*x*轴上的最大坐标）'
- en: '*yMax2 = y2m* (maximum co-ordinate on *y* axis of the second rectangle)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*yMax2 = y2m*（第二个矩形在*y*轴上的最大坐标）'
- en: 'In the given circumstances, we will have the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的情况下，我们将有以下情况：
- en: '*x1 = Ox1 – (R1 / 2)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*x1 = Ox1 – (R1 / 2)*'
- en: '*y1 = Oy1 – (R1 / 2)*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*y1 = Oy1 – (R1 / 2)*'
- en: '*x1m = Ox1 + (R1 / 2) = x1 + R1*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*x1m = Ox1 + (R1 / 2) = x1 + R1*'
- en: '*y1m = Oy1 + (R1 / 2) = y1 + R1*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*y1m = Oy1 + (R1 / 2) = y1 + R1*'
- en: '*x2 = Ox2 – (R2 / 2)*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*x2 = Ox2 – (R2 / 2)*'
- en: '*y2 = Oy2 – (R2 / 2)*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*y2 = Oy2 – (R2 / 2)*'
- en: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
- en: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
- en: 'The condition for colliding or not colliding these two rectangles will be as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个矩形是否碰撞的条件如下：
- en: '[PRE0]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rectangle and circle collision
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形和圆的碰撞
- en: 'Now, considering only the second circle as a rectangle, we will have this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只考虑第二个圆作为矩形，我们会得到这样：
- en: '![Rectangle and circle collision](img/B05069_06_04.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![矩形和圆的碰撞](img/B05069_06_04.jpg)'
- en: 'As we have already discussed the general idea of the coordinate system for
    the same system, we can directly derive the values:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论了相同系统的坐标系的一般概念，我们可以直接推导出数值：
- en: '*Px1 = Ox2 – (R2 / 2)*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Px1 = Ox2 – (R2 / 2)*'
- en: '*Py1 = Oy2 – (R2 / 2)*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*Py1 = Oy2 – (R2 / 2)*'
- en: '*Px2 = Ox2 – (R2 / 2)*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*Px2 = Ox2 – (R2 / 2)*'
- en: '*Py2 = Oy2 + (R2 / 2)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Py2 = Oy2 + (R2 / 2)*'
- en: '*Px3 = Ox2 + (R2 / 2)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*Px3 = Ox2 + (R2 / 2)*'
- en: '*Py3 = Oy2 + (R2 / 2)*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*Py3 = Oy2 + (R2 / 2)*'
- en: '*Px4 = Ox2 + (R2 / 2)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Px4 = Ox2 + (R2 / 2)*'
- en: '*Py4 = Oy2 – (R2 / 2)*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Py4 = Oy2 – (R2 / 2)*'
- en: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*x2m = Ox2 + (R2 / 2) = x2 + R2*'
- en: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*y2m = Oy2 + (R2 / 2) = y2 + R2*'
- en: '*radius1 = (R1 / 2)*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*radius1 = (R1 / 2)*'
- en: '*distanceP1 = squareRoot(((Px1 – Ox1)* (Px1 – Ox1)) + ((Py1 – Oy1)* (Py1 –
    Oy1)))*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*distanceP1 = squareRoot(((Px1 – Ox1)* (Px1 – Ox1)) + ((Py1 – Oy1)* (Py1 –
    Oy1)))*'
- en: '*distanceP2 = squareRoot(((Px2 – Ox1)* (Px2 – Ox1)) + ((Py2 – Oy1)* (Py2 –
    Oy1)))*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*distanceP2 = squareRoot(((Px2 – Ox1)* (Px2 – Ox1)) + ((Py2 – Oy1)* (Py2 –
    Oy1)))*'
- en: '*distanceP3 = squareRoot(((Px3 – Ox1)* (Px3 – Ox1)) + ((Py3 – Oy1)* (Py3 –
    Oy1)))*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*distanceP3 = squareRoot(((Px3 – Ox1)* (Px3 – Ox1)) + ((Py3 – Oy1)* (Py3 –
    Oy1)))*'
- en: '*distanceP4 = squareRoot(((Px4 – Ox1)* (Px4 – Ox1)) + ((Py4 – Oy1)* (Py4 –
    Oy1)))*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*distanceP4 = squareRoot(((Px4 – Ox1)* (Px4 – Ox1)) + ((Py4 – Oy1)* (Py4 –
    Oy1)))*'
- en: 'The colliding and non-colliding condition would be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞和非碰撞条件如下：
- en: '[PRE1]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Circle and circle collision
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆和圆的碰撞
- en: 'Finally, the actual collision detection system is between the circle and circle
    collision:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的碰撞检测系统是圆和圆的碰撞：
- en: '![Circle and circle collision](img/B05069_06_05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![圆和圆的碰撞](img/B05069_06_05.jpg)'
- en: Logically, this is the simplest procedure to find out the circular collision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，这是找出圆形碰撞的最简单的方法。
- en: 'First, calculate the distance between the two origins of the circles:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算两个圆的原点之间的距离：
- en: '*originDistance = squareRoot ( ((Ox2 – Ox1)* (Ox2 – Ox1)) + ((Ox2 – Ox1)* (Ox2
    – Ox1)))*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*originDistance = squareRoot ( ((Ox2 – Ox1)* (Ox2 – Ox1)) + ((Ox2 – Ox1)* (Ox2
    – Ox1)))*'
- en: 'Now, we need to check whether the distance is less than or equal to the sum
    of the radius of the two circles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要检查距离是否小于或等于两个圆的半径之和：
- en: '[PRE2]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Performance comparison
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能比较
- en: For the first approach, it will take a minimum clock cycle to execute the checking.
    However, it is not that accurate. Particularly when developers work with a bigger
    circle, the lack in accuracy becomes visible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，执行检查需要最少的时钟周期。然而，它并不那么准确。特别是当开发人员使用更大的圆时，缺乏准确性就会变得明显。
- en: The third approach is perfectly accurate, but takes more time to process. In
    the case of many circles colliding in runtime, this process and mathematical calculation
    may cause performance delay.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是完全准确的，但处理时间更长。在运行时有许多圆相互碰撞的情况下，这个过程和数学计算可能会导致性能延迟。
- en: The second approach is, overall, the worst possible way to solve this problem.
    However, this approach may be used in a very specific situation. When a developer
    wants to detect circle and rectangle collisions accurately, then only this approach
    can be tried.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，第二种方法是解决这个问题的最糟糕的方式。然而，在非常特定的情况下，可以使用这种方法。当开发人员想要准确检测圆和矩形的碰撞时，只有这种方法才能尝试。
- en: Detecting these sorts of collision may have multiple solutions. The approaches
    and solutions you have learned here are few of the most efficient solutions from
    the point of view of performance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 检测这种类型的碰撞可能有多种解决方案。在性能方面，您在这里学到的方法和解决方案是最有效的几种解决方案之一。
- en: When detecting rectangle and circle collisions accurately, there is one more
    popular approach by creating a bigger round rectangle by increasing the width
    and height by the diameter of the circle. This procedure is heavier but more accurate.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在准确检测矩形和圆形碰撞时，还有一种更流行的方法，即通过增加圆的直径来创建一个更大的圆角矩形，增加宽度和高度。这个过程更重，但更准确。
- en: 3D game development constraints
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D游戏开发的限制
- en: 3D game development in Android native is very complicated. The Android framework
    does not support direct 3D game development platforms. 2D game development is
    directly supported by Android Canvas. The developer requires OpenGL support to
    develop 3D games for Android.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Android本地的3D游戏开发非常复杂。Android框架不支持直接的3D游戏开发平台。Android Canvas直接支持2D游戏开发。开发人员需要OpenGL支持才能为Android开发3D游戏。
- en: Development is supported by Android NDK, which is based on C++. We will discuss
    a few constraints of 3D development for Android with OpenGL support.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 开发受到Android NDK的支持，它基于C++。我们将讨论一下在Android上使用OpenGL支持的3D开发的一些限制。
- en: Android provides the OpenGL library for development. The developer needs to
    set up scenes, light, and camera first to start any development process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了OpenGL库进行开发。开发人员需要首先设置场景、光线和摄像机才能开始任何开发过程。
- en: Vertices and triangles
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点和三角形
- en: Vertex refers to a point in 3D space. In Android, `Vector3` can be used to define
    the vertices. A triangle is formed by three such vertices. Any triangle can be
    projected onto a 2D plane. Any 3D object can be simplified to a collection of
    triangles surrounding its surface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点指的是3D空间中的一个点。在Android中，`Vector3`可以用来定义顶点。三角形由三个这样的顶点组成。任何三角形都可以投影到一个2D平面上。任何3D对象都可以简化为围绕其表面的三角形集合。
- en: For example, a cube surface is a collection of two triangles. Hence, a cube
    can be formed of 12 triangles as it has six surfaces. The number of triangles
    has a heavy impact on the rendering time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个立方体表面是两个三角形的集合。因此，一个立方体可以由12个三角形组成，因为它有六个表面。三角形的数量对渲染时间有很大影响。
- en: 3D transformation matrix
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D变换矩阵
- en: Each 3D object has its own transformation. `Vector` can be used to indicate
    its position, scaling, and rotation. Generally, this is referred through a matrix
    called a transform matrix. A transformation matrix is 4 x 4 in dimension.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个3D对象都有自己的变换。`Vector`可以用来指示其位置、缩放和旋转。通常，这通过一个称为变换矩阵的矩阵来表示。变换矩阵的维度为4 x 4。
- en: 'Let''s assume the matrix to be *T*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设矩阵为*T*：
- en: '![3D transformation matrix](img/B05069_06_06.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换矩阵](img/B05069_06_06.jpg)'
- en: 'Here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: '*{a, b, c, e, f, g, i, j, k}* represents linear transformation'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{a, b, c, e, f, g, i, j, k}*代表线性变换'
- en: '*{d, h, l}* represents perspective transformation'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{d, h, l}*代表透视变换'
- en: '*{m, n, o}* represents translations along the *x*, *y*, and *z* axes'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{m, n, o}*代表绕*x*、*y*和*z*轴的平移'
- en: '*{a, f, k}* represents local scaling along the *x*, *y*, and *z* axes'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{a, f, k}*代表沿*x*、*y*和*z*轴的局部缩放'
- en: '*{p}* represents overall scaling'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{p}*代表整体缩放'
- en: '*{f, g, i, k}* represents rotation along the *x* axis where *a = 1*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{f, g, i, k}*代表绕*x*轴的旋转，其中*a = 1*'
- en: '*{a, c, i, k}* represents rotation along the *y* axis where *f = 1*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{a, c, i, k}*代表绕*y*轴的旋转，其中*f = 1*'
- en: '*{a, b, e, f}* represents rotation along the *z* axis where *k = 1*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*{a, b, e, f}*代表绕*z*轴的旋转，其中*k = 1*'
- en: Any 3D object can be translated using this matrix and a respective transform
    3D vector. Naturally, matrix calculation is heavier than 2D simple linear calculation.
    As the number of vertices increases, the number of calculations increases as well.
    This results in performance drop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 任何3D对象都可以使用这个矩阵和相应的变换3D向量进行平移。自然地，矩阵计算比2D简单线性计算更重。随着顶点数量的增加，计算数量也会增加。这会导致性能下降。
- en: 3D object and polygon count
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D对象和多边形数量
- en: 'Any 3D model or object has surfaces referred to as polygons. Fewer of polygons
    implies fewer of triangles, which directly decreases the vertices count:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 任何3D模型或对象都有被称为多边形的表面。较少的多边形意味着较少的三角形，这直接减少了顶点数量：
- en: '![3D object and polygon count](img/B05069_06_07.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![3D对象和多边形数量](img/B05069_06_07.jpg)'
- en: This is a simple example of a polygonal distribution of a 3D object surface.
    A six-sided polygon has four triangles and six vertices. Each vertex is a 3D vector.
    Every processor takes time to process each vertex. It is recommended that you
    keep a check on the total polygon count, which will be drawn in each draw cycle.
    Many games suffer a significant amount of FPS drop because of a high and unmanaged
    polygon count.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的多边形分布的3D对象表面的例子。一个六边形有四个三角形和六个顶点。每个顶点都是一个3D向量。每个处理器都需要时间来处理每个顶点。建议您检查每个绘制周期中将绘制的总多边形数量。许多游戏因多边形数量过高和无法管理而遭受显著的FPS下降。
- en: Android is specifically a mobile OS. Most of the time, it has limited device
    configuration. Often, managing the poly count of 3D games for Android becomes
    a problem for developers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Android是专门针对移动操作系统的。大多数情况下，它具有有限的设备配置。通常，管理Android上3D游戏的多边形数量成为开发人员的问题。
- en: 3D rendering system
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D渲染系统
- en: Android uses OpenGL to provide a 3D rendering platform with both framework and
    NDK. The Android framework provides `GLSurfaceView` and `GLSurfaceView.Renderer`
    to render 3D objects in Android. They are responsible for generating the model
    on screen. We have already discussed the 3D rendering pipeline through OpenGL.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用OpenGL提供了一个3D渲染平台，包括框架和NDK。Android框架提供了`GLSurfaceView`和`GLSurfaceView.Renderer`来渲染Android中的3D对象。它们负责在屏幕上生成模型。我们已经通过OpenGL讨论了3D渲染管线。
- en: '3D rendering maps all the objects on a 3D world coordinate system following
    the right-hand thumb system:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 3D渲染将所有对象映射到一个3D世界坐标系，遵循右手拇指系统：
- en: '![3D rendering system](img/B05069_06_09.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![3D渲染系统](img/B05069_06_09.jpg)'
- en: 3D mesh
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D网格
- en: A 3D mesh is created with vertices, triangles, and surfaces. A mesh is created
    to determine the shape of the object. A texture is applied to the mesh to create
    the complete model.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 3D网格是由顶点、三角形和表面创建的。网格用于确定物体的形状。纹理被应用到网格上以创建完整的模型。
- en: Creating a mesh is the trickiest part of 3D model creation, as basic optimization
    can be applied here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网格是3D模型创建中最棘手的部分，因为基本的优化可以在这里应用。
- en: 'Here is the procedure of creating the mesh:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建网格的过程：
- en: '![3D mesh](img/B05069_06_10.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![3D网格](img/B05069_06_10.jpg)'
- en: A 3D model can contain more than one mesh, and they may even be interchangeable.
    A mesh is responsible for the model detailing quality and for the rendering performance
    of the model. For Android development, it is recommended that you keep a certain
    limit of vertices and triangles for meshes to render performance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个3D模型可以包含多个网格，它们甚至可以互换。网格负责模型的细节质量和渲染性能。对于Android开发，建议对网格的顶点和三角形数量保持一定限制，以提高渲染性能。
- en: Materials, shaders, and textures
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料、着色器和纹理
- en: 'After the formation of the model structure through the mesh, the texture is
    applied on it to create the final model. However, the texture is applied through
    a material and manipulated by shaders:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过网格形成模型结构后，纹理被应用于其上，以创建最终模型。然而，纹理是通过材质应用并由着色器操纵的：
- en: '![Materials, shaders, and textures](img/B05069_06_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![材料、着色器和纹理](img/B05069_06_11.jpg)'
- en: Textures
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理
- en: Textures are 2D images applied to the model to increase detailing and view the
    quality of a model. This image is mapped through the surfaces of the mesh so that
    each surface renders a particular clip of the texture.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理是应用于模型的2D图像，以增加模型的细节和视图质量。这个图像被映射到网格的表面上，以便每个表面渲染纹理的特定部分。
- en: Shaders
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色器
- en: Shaders are used to manipulate the quality, color, and other attributes of the
    texture to make it more realistic. Most of the time, it is not possible to create
    a texture with all the attributes properly set. A 3D model visibility is dependent
    on light source, intensity, color, and material type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器用于操纵纹理的质量、颜色和其他属性，使其更加逼真。大多数情况下，不可能创建具有所有属性正确设置的纹理。3D模型的可见性取决于光源、强度、颜色和材质类型。
- en: Materials
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材料
- en: The material determines the texture attribute and shader property. The material
    can be termed as a container for the shader and texture before applying it to
    the mesh to create the model.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 材料确定纹理属性和着色器属性。在将其应用于网格以创建模型之前，材料可以被称为着色器和纹理的容器。
- en: Collision detection
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'Collision detection for 3D Android games can be categorized into two types:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 3D Android游戏的碰撞检测可以分为两种类型：
- en: Primitive colliders
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始碰撞器
- en: Mesh colliders
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格碰撞器
- en: Primitive colliders
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始碰撞器
- en: These colliders consist of basic 3D elements such as cubes, spheres, cylinders,
    prisms, and so on. This collision detection system follows certain geometric patterns
    and rules. That's why it is comparatively less complicated than the arbitrary
    mesh collider.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些碰撞器由立方体、球体、圆柱体、棱柱体等基本的3D元素组成。这种碰撞检测系统遵循一定的几何模式和规则。这就是为什么它相对于任意网格碰撞器来说比较简单的原因。
- en: Most of the time, the developer assigns primitive colliders to many models to
    increase the performance of the game. This approach is obviously less accurate
    than actual collider.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，开发人员会为许多模型分配原始碰撞器，以提高游戏的性能。这种方法显然不如实际的碰撞器精确。
- en: Mesh colliders
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格碰撞器
- en: Mesh colliders can detect actual arbitrary collision detection. This collision
    detection technique is process heavy. There are few algorithms to minimize the
    process overhead. **quadtree**, **kd-tree**, and **AABB tree** are a few examples
    of such collision detection techniques. However, they do not minimize the CPU
    overhead significantly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 网格碰撞器可以检测实际的任意碰撞检测。这种碰撞检测技术处理开销很大。有一些算法可以减少处理开销。四叉树、kd树和AABB树是这种碰撞检测技术的几个例子。然而，它们并不能显著减少CPU开销。
- en: The oldest but most accurate method is triangle to triangle collision detection
    for each surface. To simplify this method, each mesh block is converted to boxes.
    A special AABB tree or quadtree is generated to reduce the vertex check.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最古老但最准确的方法是对每个表面进行三角形到三角形的碰撞检测。为了简化这种方法，每个网格块都被转换为盒子。生成特殊的AABB树或四叉树以减少顶点检查。
- en: This can be further reduced to **octree** vertex mapping by merging two box
    colliders. In this way, the developer can reduce the collision check to reduce
    CPU overhead.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过合并两个盒子碰撞器来进一步减少到八叉树顶点映射。通过这种方式，开发人员可以减少碰撞检查以减少CPU开销。
- en: Ray casting
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射线投射
- en: 'Ray casting is a geometric system to detect the surfaces of 3D graphical objects.
    This system is used to solve the geometric problems of 3D computer graphics. In
    the case of 3D games, all 3D objects are projected in a 2D view. It is not possible
    to determine depth without ray casting in the case of a 2D electronic display:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 射线投射是一种几何系统，用于检测3D图形对象的表面。这个系统用于解决3D计算机图形的几何问题。在3D游戏中，所有3D对象都被投影到2D视图中。在2D电子显示器的情况下，没有射线投射是无法确定深度的：
- en: '![Ray casting](img/B05069_06_12.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![射线投射](img/B05069_06_12.jpg)'
- en: Each ray from the origin projected on different objects can detect the shape
    of the object, distance from the plane, collision detection, rotation, and scaling
    of the objects, and so on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从原点发射的每条射线都可以检测不同对象上的形状、距离、碰撞检测、旋转和缩放等信息。
- en: In the case of Android games, ray casting is vastly used to handle touch input
    on the screen. Most of the games use this method to manipulate the behavior of
    3D objects used in the game.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android游戏中，射线投射被广泛用于处理屏幕上的触摸输入。大多数游戏使用这种方法来操纵游戏中使用的3D对象的行为。
- en: From the point of view of development performance, ray casting is a quite costly
    system to use in a major scale. This requires a series of geometrical calculation,
    resulting in a processing overhead. As the number of rays increases, the process
    gets heavier.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发性能的角度来看，射线投射是一个在大规模使用时成本相当高的系统。这需要一系列几何计算，导致处理开销。随着射线数量的增加，处理过程变得更加繁重。
- en: It is always a best practice to keep a control on using multiple rays casting
    at one point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个点上使用多个射线投射时，始终要控制好。
- en: Concept of "world"
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “世界”的概念
- en: The word "world" in 3D games is a real-time simulation of the actual world with
    a regional limitation. The world is created with 3D models, which refer to actual
    objects in the real world. The scope of the game world is finite. This world follows
    a particular scale, position, and rotation with respective cameras.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 3D游戏中的“世界”是实际世界的实时模拟，具有区域限制。世界是用3D模型创建的，这些模型指的是现实世界中的实际物体。游戏世界的范围是有限的。这个世界遵循特定的比例、位置和旋转，以及相应的摄像机。
- en: The concept of camera is a must for simulating such a world. Multiple cameras
    can be used to render different perspectives of the same world.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机的概念对于模拟这样一个世界是必不可少的。可以使用多个摄像机来渲染同一个世界的不同视角。
- en: 'In the gaming industry, a game world is created according to requirements.
    This means that the worlds of different games are different. But a few of the
    parameters remain the same. These parameters are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，游戏世界是根据需求创建的。这意味着不同游戏的世界是不同的。但是一些参数保持不变。这些参数如下：
- en: Finite elements
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限元素
- en: Light source
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光源
- en: Camera
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机
- en: Elements of the game world
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏世界的元素
- en: 'A world consists of the elements that are required in game design. Each game
    may require different elements. However, there are two things that are common
    across the games: sky and terrain. Most of the elements are usually placed on
    the terrain, and the light source is in the sky. However, many games offer different
    light sources at different scopes of the game.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 世界由游戏设计中所需的元素组成。每个游戏可能需要不同的元素。然而，跨游戏的两个共同点是天空和地形。大多数元素通常放置在地形上，光源在天空中。然而，许多游戏在游戏的不同范围内提供不同的光源。
- en: 'Elements can be divided into two categories: movable objects and static objects.
    A game''s rigid bodies are associated with such elements. Normally, static objects
    do not support motion physics.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可以分为两类：可移动对象和静态对象。游戏的刚体与这些元素相关联。通常，静态对象不支持运动物理学。
- en: Optimizing objects in the world is necessary for performance. Each object has
    a certain number of vertices and triangles. We have already discussed the processing
    overhead of the vertices of 3D objects. Generally, world optimization is basically
    the optimization of each element in the world.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对世界中的对象进行优化对性能至关重要。每个对象都有一定数量的顶点和三角形。我们已经讨论了3D对象顶点的处理开销。一般来说，世界优化基本上是对世界中每个元素的优化。
- en: Light sources in the game world
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏世界中的光源
- en: A game world must have one or more light sources. Lights are used to expose
    the elements in the world. Multiple light sources have a great visual impact on
    the user experience.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界必须有一个或多个光源。光源用于暴露世界中的元素。多个光源对用户体验有很大的视觉影响。
- en: The game development process always requires at least one good light artist.
    Modern games use light maps to amplify the visual quality. The light and shadow
    play in the game world is entirely dependent on light mapping.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发过程总是需要至少一个优秀的光照艺术家。现代游戏使用光照图来增强视觉质量。游戏世界中的光与影是完全依赖于光照图的。
- en: There is no doubt that light is a mandatory element in the game world. However,
    the consequence of processing light and shadow is a large amount of processing.
    All the vertices need to be processed according to a light source with a particular
    shader. Use of extensive light sources results in low performance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，光是游戏世界中的必要元素。然而，处理光和阴影的后果是大量的处理。所有顶点都需要根据特定的着色器处理光源。使用大量光源会导致性能低下。
- en: 'Light sources can be of the following types:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 光源可以是以下类型：
- en: Area light
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域光
- en: Spot light
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚光灯
- en: Point light
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点光源
- en: Directional light
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定向光
- en: Ambient light
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境光
- en: Volume light
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体积光
- en: '**Area light**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**区域光**'
- en: 'This kind of light source is used to light a rectangular or circular region.
    By nature, it is a directional light and lights the area with equal intensity:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种光源用于照亮矩形或圆形区域。本质上，它是定向光，以相等的强度照亮区域：
- en: '![Light sources in the game world](img/B05069_06_13.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_13.jpg)'
- en: '**Spot light**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚光灯**'
- en: 'A spot light is used to focus on a particular object in a conical directional
    shape:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 聚光灯用于以圆锥形方向聚焦于特定对象：
- en: '![Light sources in the game world](img/B05069_06_14.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_14.jpg)'
- en: '**Point light**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**点光源**'
- en: 'A point light illuminates in all directions of the source. A typical example
    is a bulb illumination:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 点光源照亮光源的所有方向。一个典型的例子是灯泡的照明：
- en: '![Light sources in the game world](img/B05069_06_15.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_15.jpg)'
- en: '**Directional light**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**定向光**'
- en: 'A directional light is a set of parallel light beams projected on a place in
    a 3D world. A typical example is sunlight:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 定向光是投射在3D世界中某个地方的一组平行光束。一个典型的例子是阳光：
- en: '![Light sources in the game world](img/B05069_06_16.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_16.jpg)'
- en: '**Ambient light**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境光**'
- en: 'An ambient light is a set of arbitrary light beams in any direction. Usually,
    the intensity of this kind of light source is low. As a light beam does not follow
    a particular direction, and it does not generate any shadows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光是任意方向上的一组光束。通常，这种光源的强度较低。由于光束没有特定的方向，并且不会产生任何阴影：
- en: '![Light sources in the game world](img/B05069_06_17.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_17.jpg)'
- en: '**L1**, **L2**, **L3**, and **L4** are ambient light sources here.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**L1**、**L2**、**L3**和**L4**在这里是环境光源。'
- en: '**Volume light**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**体积光**'
- en: 'A volume light is a modified type of point light. This kind of light source
    can be converted into a set of light beams within a defined geometrical shape.
    Any light beam is a perfect example of such a light source:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 体积光是修改后的点光源类型。这种光源可以转换为在定义的几何形状内的一组光束。任何光束都是这种光源的完美例子：
- en: '![Light sources in the game world](img/B05069_06_18.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的光源](img/B05069_06_18.jpg)'
- en: Cameras in the game world
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏世界中的相机
- en: The camera is the last but the most important element of the game world. A camera
    is responsible for the rendering of the game screen. It also determines the elements
    to be added in the rendering pipeline.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 相机是游戏世界中最后但最重要的元素。相机负责渲染游戏屏幕。它还确定要添加到渲染管线中的元素。
- en: There are two types of camera used in a game.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中使用的相机有两种类型。
- en: '**Perspective camera**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**透视相机**'
- en: 'This type of camera is typically used to render 3D objects. The visible scale
    and depth is fully dependent on this type of camera. The developer manipulates
    the field of view and near/far range to control the rendering pipeline:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的相机通常用于渲染3D对象。可见的比例和深度完全取决于这种类型的相机。开发人员通过操纵视野和近/远范围来控制渲染管线：
- en: '![Cameras in the game world](img/B05069_06_19.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的相机](img/B05069_06_19.jpg)'
- en: '**Orthographic camera**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**正交相机**'
- en: 'This type of camera is used to render objects from a 2D perspective, irrespective
    of the objects. An orthographic camera renders objects on the same plane, irrespective
    of the depth. The developer manipulates effective width and height of the camera
    to control the 2D rendering pipeline. This camera is typically used for 2D games
    and to render 2D objects in a 3D game:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的相机用于从2D透视渲染对象，而不考虑对象。正交相机在同一平面上渲染对象，而不考虑深度。开发人员操纵相机的有效宽度和高度来控制2D渲染管线。这种相机通常用于2D游戏和在3D游戏中渲染2D对象：
- en: '![Cameras in the game world](img/B05069_06_20.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![游戏世界中的相机](img/B05069_06_20.jpg)'
- en: Besides this, the game camera can also be categorized by their nature and purpose.
    Here are the most common variations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，游戏相机也可以根据其性质和目的进行分类。以下是最常见的变化。
- en: '**Fixed camera**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**固定相机**'
- en: A fixed camera does not rotate, translate, or scale during the execution. Typically,
    2D games use such cameras. A fixed camera is the most convenient camera in terms
    of processing speed. A fixed camera does not have any runtime manipulation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 固定相机在执行过程中不会旋转、平移或缩放。通常，2D游戏使用这样的相机。固定相机在处理速度方面是最方便的相机。固定相机没有任何运行时操作。
- en: '**Rotating camera**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**旋转相机**'
- en: This camera has a rotating feature during runtime. This type of camera is effective
    in the case of sports simulation or surveillance simulation games.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相机在运行时具有旋转功能。这种相机类型在体育模拟或监控模拟游戏中非常有效。
- en: '**Moving camera**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动相机**'
- en: A camera can be said to be moving when the translation can be changed during
    runtime. This type of camera is typically used for an aerial view of the game.
    A typical use of this sort of camera is for games such as *Age Of Empires*, *Company
    Of Heroes*, *Clash Of Clans*, and so on.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当平移在运行时可以改变时，相机可以被称为移动。这种类型的相机通常用于游戏的俯视图。这种相机的典型用途是像《帝国时代》、《英雄公司》、《部落冲突》等游戏。
- en: '**Third-person camera**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三人称相机**'
- en: This camera is mainly the part of gameplay design. This is a moving camera,
    but this camera follows a particular object or character. The character is supposed
    to be the user character, so all the actions and movements are tracked by this
    camera including the character and object. Mostly, this camera can be rotated
    or pushed according to the actions of the player.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相机主要是游戏设计的一部分。这是一个移动相机，但这个相机跟随特定的对象或角色。角色应该是用户角色，因此所有的动作和移动都由这个相机跟踪，包括角色和对象。大多数情况下，这个相机可以根据玩家的动作进行旋转或推动。
- en: '**First-person camera**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一人称相机**'
- en: When the player plays as the main character, this camera is used to implement
    a typical view of the eyes of the player. The camera moves or translates according
    to the actions of the player.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家扮演主角时，这个相机用于实现玩家眼睛的典型视图。相机根据玩家的动作移动或平移。
- en: The rendering pipeline in Android
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的渲染管线
- en: Let's now have a look at the types of rendering pipeline in Android.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看Android中的渲染管线类型。
- en: The 2D rendering pipeline
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D渲染管线
- en: In the case of the 2D Android drawing system through Canvas, all the assets
    are first drawn on the canvas, and the canvas is rendered on screen. The graphic
    engine maps all the assets within the finite Canvas according to the given position.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android的2D绘图系统中，所有资产首先绘制在画布上，然后画布被渲染在屏幕上。图形引擎根据给定位置在有限的画布上映射所有资产。
- en: Often, developers use small assets separately that cause a mapping instruction
    to execute for each asset. It is always recommended that you use sprite sheets
    to merge as many small assets as possible. A single draw call can then be applied
    to draw every object on the Canvas.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员单独使用小资产，导致每个资产执行映射指令。建议您尽可能使用精灵表来合并尽可能多的小资产。然后可以应用单个绘制调用来在画布上绘制每个对象。
- en: Now, the question is how to create the sprite and what the other consequences
    are. Previously, Android could not support images or sprites of a size more than
    1024 x 1024 pixels. Since Android 2.3, the developer can use a 4096 x 4096 sprite.
    However, using such sprites can cause permanent memory occupancy during the scopes
    of all the small assets. Many low-configuration Android devices do not support
    such large images to be loaded during an application. It is a best practice that
    developers limit themselves to 2048 x 2048 pixels. This will reduce memory usage
    peak, as well as significant amounts of draw calls to the canvas.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是如何创建精灵以及其他后果是什么。以前，Android不能支持尺寸超过1024 x 1024像素的图像或精灵。自Android 2.3以来，开发人员可以使用4096
    x 4096的精灵。然而，使用这样的精灵可能会导致所有小资产的永久内存占用。许多低配置的Android设备不支持在应用程序加载期间加载如此大的图像。最佳做法是开发人员限制自己在2048
    x 2048像素。这将减少内存使用峰值，以及对画布的大量绘制调用。
- en: The 3D rendering pipeline
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D渲染管线
- en: Android uses OpenGL to render assets on the screen. So, the rendering pipeline
    for Android 3D is basically the OpenGL pipeline.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用OpenGL在屏幕上渲染资产。因此，Android 3D的渲染管线基本上是OpenGL管线。
- en: 'Let''s have look at the OpenGL rendering system:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看OpenGL渲染系统：
- en: '![The 3D rendering pipeline](img/B05069_06_21.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![3D渲染管线](img/B05069_06_21.jpg)'
- en: 'Now, let''s have a detailed look at each step of the preceding rendering flow
    diagram:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看一下前述渲染流程图的每个步骤：
- en: The **vertex shader** processes individual vertices with vertex data.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点着色器**处理具有顶点数据的单个顶点。'
- en: The **control shader** is responsible for controlling vertex data and patches
    for the tessellation.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制着色器**负责控制顶点数据和镶嵌的补丁。'
- en: The **polygon arrangement** system arranges the polygon with each pair of intersecting
    lines created by vertices. Thus, it creates the edges without repeating vertices.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多边形排列**系统使用由顶点创建的每对相交线排列多边形。因此，它创建边缘而不重复顶点。'
- en: '**Tessellation** is the process of tiling the polygons in a shape without overlap
    or any gaps.'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**镶嵌**是在不重叠或有任何间隙的情况下对多边形进行平铺的过程。'
- en: The **geometry shader** is responsible for optimizing the primitive shape. Thus
    triangles are generated.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**几何着色器**负责优化原始形状。因此会生成三角形。'
- en: After constructing the polygons and shapes, the model is **clipped** for optimization.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建多边形和形状之后，模型被**裁剪**以进行优化。
- en: '**Vertex post processing** is used to filter out unnecessary data.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点后处理**用于过滤掉不必要的数据。'
- en: The mesh is then **rasterized**.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后对网格进行光栅化。
- en: The **fragment shader** is used to process fragments generated from rasterization.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**片段着色器**用于处理光栅化生成的片段。'
- en: All the pixels are **mapped** after fragmentation and **processed** with the
    processed data.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有像素在分割后都经过映射，并使用处理后的数据进行处理。
- en: The mesh is added to the **frame buffer** for final rendering.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格被添加到**帧缓冲区**进行最终渲染。
- en: Optimizing 2D assets
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化2D资源
- en: Any digital game cannot be made without 2D art assets. There must be 2D assets
    in some form inside the game. So, as far as game component optimization is concerned,
    every 2D asset should also be optimized. Optimization of 2D assets means these
    three main things.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字游戏都无法在没有2D艺术资源的情况下制作。游戏内必须以某种形式存在2D资源。因此，就游戏组件优化而言，每个2D资源也应该被优化。优化2D资源意味着这三个主要方面。
- en: Size optimization
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小优化
- en: Each asset frame should only contain the effective pixels to be used in games.
    Unnecessary pixels increase the asset size and memory use during runtime.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资产帧应该只包含在游戏中使用的有效像素。不必要的像素会增加资产大小，并在运行时增加内存使用。
- en: Data optimization
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据优化
- en: Not all images require full data information for pixels. A significant amount
    of data might be stored in each pixel, depending on the image format. For example,
    full screen opaque images should never contain transparency data. Similarly, depending
    on the color set, images must be formatted in 8-bit, 16-bit, or 24-bit format.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有图像都需要像素的完整数据信息。根据图像格式，每个像素可能存储大量数据。例如，全屏不透明图像永远不应该包含透明数据。同样，根据颜色集，图像必须以8位、16位或24位格式进行格式化。
- en: Image optimization tools can be used to perform such optimizations.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图像优化工具可用于执行此类优化。
- en: Process optimization
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程优化
- en: The larger the amount of data compressed during optimization, the more time
    it takes to decompress it and load it to memory. So, image optimization has a
    direct effect on the processing speed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化期间压缩的数据量越大，解压缩和加载到内存所需的时间就越长。因此，图像优化直接影响处理速度。
- en: From another point of view, creating an image atlas or sprite sheet is another
    way to reduce the processing time of images.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，创建图像图集或精灵表是减少图像处理时间的另一种方法。
- en: Optimizing 3D assets
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化3D资源
- en: A 3D art asset has two parts to be optimized. A 2D texture part is to be optimized
    in the same 2D optimization style. The only thing the developer needs to consider
    is after optimization, the shader should have the same effect on the structure.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 3D艺术资源有两个部分需要优化。 2D纹理部分需要以相同的2D优化风格进行优化。开发人员需要考虑的唯一一件事是，在优化后，着色器对结构应该有相同的效果。
- en: The rest of the 3D asset optimization entirely depends on the number of vertices
    and the model polygon.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的3D资产优化完全取决于顶点数量和模型多边形。
- en: Limiting the polygon count
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制多边形数量
- en: It is very obvious that a large number of polygons used to create a mesh can
    create more details. However, we all know that Android is a mobile OS, and it
    always has hardware limitations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，使用大量多边形来创建网格可以创建更多细节。但是，我们都知道Android是一个移动操作系统，它总是有硬件限制。
- en: The developer should count the number of polygons used in the mesh and the total
    number of polygons rendered on the screen in a single draw cycle. There is always
    a limitation depending on the hardware configuration.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该计算网格中使用的多边形数量以及在单个绘制周期内屏幕上呈现的多边形总数。根据硬件配置，总会有限制。
- en: So, limiting the polygon and vertex count per mesh is always an advantage in
    order to achieve a certain frame rate or performance.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，限制每个网格的多边形和顶点数量总是有利于实现特定的帧速率或性能。
- en: Model optimization
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型优化
- en: Models are created with more than one mesh. Using a separate mesh in the final
    model always results in heavy processing. This is a major effort for the game
    artist. Multiple overlaps can occur if multiple meshes are used. This increases
    vertex processing.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是用多个网格创建的。在最终模型中使用单独的网格总是会导致大量处理。这对游戏艺术家来说是一项重大工作。如果使用多个网格，可能会发生多重重叠。这会增加顶点处理。
- en: Rigging is another essential part of finalizing the model. A good rigger defines
    the skeleton with the minimum possible joints for minimum processing.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是最终确定模型的另一个重要部分。一个好的绑定者会为最少的处理定义骨骼。
- en: Common game development mistakes
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的游戏开发错误
- en: It is not always possible to look into each and every performance aspect at
    every development stage. It is a very common practice to use assets and write
    code in a temporary mode and use it in the final game.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个开发阶段都不可能查看每个性能方面。在临时模式下使用资产和编写代码，并在最终游戏中使用它是一种非常常见的做法。
- en: This affects the overall performance and future maintenance procedure. Here
    are few of the most common mistakes made during game development.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响整体性能和未来的维护程序。以下是在游戏开发过程中常见的一些错误。
- en: Use of non-optimized images
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未优化的图像
- en: An artist creates art assets, and the developer directly integrates those into
    the game for the debug build. However, most of the time, those assets are never
    optimized, even for the release candidate.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家创建艺术资产，开发人员直接将其集成到游戏中进行调试构建。然而，大部分时间，这些资产甚至没有针对发布候选版本进行优化。
- en: This is the reason there may be plenty of high-bit images where the asset contains
    limited information. Alpha information may be found in opaque images.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么可能会有大量高位图像，其中资产包含有限的信息。Alpha信息可能存在于不透明图像中。
- en: Use of full utility third-party libraries
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用完整的实用第三方库
- en: The modern day development style does not require each and every development
    module to be written from scratch. Most of the developers use a predefined third-party
    library for common utility mechanisms.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发风格不要求每个开发模块都从头开始编写。大多数开发人员使用预定义的第三方库来进行常见的实用机制。
- en: Most of the time, these packages come with most of the possible methods, and
    among them, very few are actually used in games. Developers, most of the time,
    use these packages without any filtration. A lot of unused data occupies memory
    during runtime in such cases.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些包含大部分可能方法的包，而其中很少有实际在游戏中使用。开发人员大多数情况下在没有任何过滤的情况下使用这些包。在这种情况下，大量未使用的数据会在运行时占用内存。
- en: Often, a third-party library comes without an editing facility. In this case,
    the developer should choose such packages very carefully, depending on their specific
    requirements.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第三方库没有编辑功能。在这种情况下，开发人员应根据其特定需求非常谨慎地选择这些包。
- en: Use of unmanaged networking connections
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未经管理的网络连接
- en: In modern Android games, the use of Internet connectivity is very common. Many
    games use server-based gameplay. In such cases, the entire game runs on the server
    with frequent data transfers between the server and the client device. Each data
    transfer process takes time, and the connectivity drains the battery charge significantly.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代安卓游戏中，使用互联网连接非常普遍。许多游戏使用基于服务器的游戏玩法。在这种情况下，整个游戏在服务器上运行，并且服务器和客户端设备之间频繁传输数据。每个数据传输过程都需要时间，连接会显著消耗电池电量。
- en: Badly managed networking states often freeze the application. A significant
    amount of data is handled, especially for real-time multiplayer games. In this
    case, a request and response queue should be created and managed properly. However,
    the developer often skips this part to save development time.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕管理的网络状态经常会冻结应用程序。特别是对于实时多人游戏，处理大量数据。在这种情况下，应该创建并正确管理请求和响应队列。然而，开发人员经常跳过这一部分以节省开发时间。
- en: Another aspect of unmanaged connections is unnecessary packet data transferred
    between the server and client. So, there is an extra parsing process involved
    each time data is transferred.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 未经管理的连接的另一个方面是服务器和客户端之间不必要的数据包传输。因此，每次传输数据时都涉及额外的解析过程。
- en: Using substandard programming
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用次标准的编程
- en: We have already discussed programming styles and standards. The modular programming
    approach may increase a few extra processes, but the longer management of programming
    demands modular programming. Otherwise, developers end up repeating code, and
    this increases process overhead.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了编程风格和标准。模块化编程方法可能会增加一些额外的过程，但长期管理编程需要模块化编程。否则，开发人员最终会重复代码，这会增加过程开销。
- en: Memory management also demands a good programming style. In few cases, the developer
    allocates memory but often forgets to free the memory. This causes a lot of memory
    leakage. At times, the application crashes due to insufficient memory.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理也需要良好的编程风格。在一些情况下，开发人员分配内存但经常忘记释放内存。这会导致大量内存泄漏。有时，应用程序由于内存不足而崩溃。
- en: 'Substandard programming includes the following mistakes:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 次标准的编程包括以下错误：
- en: Declaring the same variables multiple times
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次声明相同的变量
- en: Creating many static instances
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建许多静态实例
- en: Writing non-modular coding
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写非模块化的编码
- en: Improper singleton class creation
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的单例类创建
- en: Loading objects at runtime
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时加载对象
- en: Taking a shortcut
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采取捷径
- en: This is the funniest fact among ill-practiced development styles. Taking a shortcut
    during development is very common among game developers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不良开发风格中最有趣的事实。在开发过程中采取捷径在游戏开发人员中非常普遍。
- en: Making games is mostly about logical development. There may be multiple ways
    of solving a logical problem. Very often, the developer chooses the most convenient
    way to solve such problems. For example, the developer mostly uses the bubble
    sorting method for most of the sorting requirements, despite knowing that it is
    the most inefficient sorting process.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏主要是逻辑开发。解决逻辑问题可能有多种方法。开发人员经常选择最方便的方式来解决这些问题。例如，开发人员大多数情况下使用冒泡排序方法来满足大部分排序需求，尽管知道这是最低效的排序过程。
- en: Using such shortcuts multiple times in a game may cause a visible process delay,
    which directly affects the frame rate.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中多次使用这样的捷径可能会导致可见的进程延迟，直接影响帧率。
- en: 2D/3D performance comparison
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D/3D性能比较
- en: Android game development in 2D and 3D is different. It is a fact that 3D game
    processing is heavier than 2D games. However, the game scale is always the deciding
    factor.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 2D和3D的安卓游戏开发是不同的。事实上，3D游戏处理比2D游戏更加繁重。然而，游戏规模始终是决定因素。
- en: Different look and feel
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的外观和感觉
- en: 3D look and feel is way different than 2D. The use of a particle system in 3D
    games is very common to provide visual effects. In the case of 2D games, sprite
    animation and other transformations are used to show such effects.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 3D的外观和感觉与2D完全不同。在3D游戏中使用粒子系统来提供视觉效果非常普遍。在2D游戏中，使用精灵动画和其他转换来展示这些效果。
- en: Another difference between 2D and 3D look and feel is dynamic light and shadow.
    Dynamic light is always a factor for greater visual quality. Nowadays, most 3D
    games use dynamic lighting, which has a significant effect on game performance.
    In the case of 2D games, light management is done through assets. So, there is
    no extra processing in 2D games for light and shadow.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 2D和3D外观的另一个区别是动态光和阴影。动态光始终是更高视觉质量的一个因素。如今，大多数3D游戏使用动态光照，这对游戏性能有显著影响。在2D游戏中，光管理是通过资源完成的。因此，在2D游戏中没有额外的光和阴影处理。
- en: In 2D games, the game screen is rendered on a Canvas. There is only one fixed
    point of view. So, the concept of camera is limited to a fixed camera. However,
    in 3D games, it is a different case. Multiple types of camera can be implemented.
    Multiple cameras can be used together for a better feel of the game. Rendering
    objects through multiple cameras causes more process overhead. Hence, it decreases
    the frame rate of the game.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D游戏中，游戏屏幕是在画布上渲染的。只有一个固定的视角。因此，摄像头的概念局限于固定摄像头。然而，在3D游戏中，情况就不同了。可以实现多种类型的摄像头。可以同时使用多个摄像头以获得更好的游戏体验。通过多个摄像头渲染对象会导致更多的处理开销。因此，它会降低游戏的帧率。
- en: There is a significant performance difference between using 2D physics and 3D
    physics. A 3D physics engine is far more process heavy than a 2D physics engine.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用2D物理和3D物理之间存在显著的性能差异。3D物理引擎比2D物理引擎要重得多。
- en: 3D processing is way heavier than 2D processing
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D处理比2D处理要重得多
- en: It is a common practice in the gaming industry to accept less FPS in 3D games
    in comparison to 2D games. In Android, the standard accepted FPS for 2D games
    is around 60 FPS, whereas a 3D game is acceptable even if it runs at as low as
    40 FPS.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，接受3D游戏的FPS比2D游戏要少是一种常见做法。在Android中，2D游戏的标准接受的FPS约为60 FPS，而3D游戏即使以低至40
    FPS的速度运行也是可以接受的。
- en: 'The logical reason behind this is that 3D games are way heavier than 2D games
    in terms of process. The main reasons are as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的逻辑原因是，从处理的角度来看，3D游戏比2D游戏要重得多。主要原因如下：
- en: '**Vertex processing**: In 3D games, each vertex is processed on the OpenGL
    layer during rendering. So, increasing the number of vertices leads to heavier
    processing.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点处理**：在3D游戏中，每个顶点在渲染过程中在OpenGL层上进行处理。因此，增加顶点数量会导致更重的处理。'
- en: '**Mesh rendering**: A mesh consists of multiple vertices and many polygons.
    Processing a mesh increases the rendering overhead as well.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格渲染**：网格由多个顶点和许多多边形组成。处理网格会增加渲染开销。'
- en: '**3D collision system**: A 3D dynamic collision detection system demands each
    vertex of the collider to be calculated for collision. This calculation is usually
    done by the GPU.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D碰撞系统**：3D动态碰撞检测系统要求对每个碰撞体的顶点进行计算以进行碰撞。这个计算通常由GPU完成。'
- en: '**3D physics implementation**: 3D transformation calculation completely depends
    on matrix manipulation, which is always heavy.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D物理实现**：3D变换计算完全取决于矩阵操作，这总是很重的。'
- en: '**Multiple camera use**: Use of multiple cameras and dynamically setting up
    the rendering pipeline takes more memory and clock cycles.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多摄像头使用**：使用多个摄像头并动态设置渲染管线需要更多的内存和时钟周期。'
- en: Device configuration
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备配置
- en: Android has a wide range of device configuration options supported by the platform.
    In the previous chapters, we have already seen such variations. Running the same
    game on different configurations does not produce the same result.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台支持各种设备配置选项。在前几章中，我们已经看到了这样的变化。在不同配置上运行相同的游戏不会产生相同的结果。
- en: Performance depends on the following factors.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 性能取决于以下因素。
- en: Processor
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理器
- en: There are many processors used for Android devices in terms of the number of
    cores and the speed of each core. Speed decides the number of instructions that
    can be executed in a single cycle. There was a time when Android used to have
    a single core CPU with speed less than 500 MHz. Now we have multicore CPUs with
    more than 2 GHz speed on each core.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备中使用了许多处理器，涉及核心数量和每个核心速度。速度决定了在单个周期内可以执行的指令数量。曾经有一段时间，Android使用的是速度低于500
    MHz的单核CPU。现在我们有了每个核心超过2 GHz速度的多核CPU。
- en: RAM
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RAM
- en: Availability of RAM is another factor that decides performance. Heavy games
    require a greater amount of RAM during runtime. If RAM is limited, then frequent
    loading/unloading processes affect performance.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 可用RAM是决定性能的另一个因素。重型游戏在运行时需要更多的RAM。如果RAM有限，频繁的加载/卸载过程会影响性能。
- en: GPU
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPU
- en: GPU decides the rendering speed. It acts as the processing unit for graphical
    objects. A more powerful processor can process more rendering instructions, resulting
    in better performance.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: GPU决定了渲染速度。它充当了图形对象的处理单元。更强大的处理器可以处理更多的渲染指令，从而提高性能。
- en: Display quality
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示质量
- en: Display quality is actually inversely proportional to the performance. Better
    display quality has to be backed by better GPU, CPU, and RAM, because better displays
    always consist of bigger resolution, with better dpi and more color support.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 显示质量实际上与性能成反比。更好的显示质量必须由更好的GPU、CPU和RAM支持，因为更好的显示总是由更大的分辨率、更好的dpi和更多的颜色支持组成。
- en: 'We can see various devices with different display quality. Android itself has
    divided the assets by this feature:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到各种不同显示质量的设备。Android本身已经根据这个特性划分了资源：
- en: '**LDPI**: Lowest dpi display for Android (~120 dpi)'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDPI**：Android的最低dpi显示（~120 dpi）'
- en: '**MDPI**: Medium dpi display for Android (~160 dpi)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MDPI**：Android的中等dpi显示（~160 dpi）'
- en: '**HDPI**: High dpi display for Android (~240 dpi)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDPI**：Android的高dpi显示（~240 dpi）'
- en: '**XHDPI**: Extra high dpi display for Android (~320 dpi)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XHDPI**：Android的额外高dpi显示（~320 dpi）'
- en: '**XXHDPI**: Extra extra high dpi display for Android (~480 dpi)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XXHDPI**：Android的额外额外高dpi显示（~480 dpi）'
- en: '**XXXHDPI**: Extra extra extra high dpi display for Android (~640 dpi)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XXXHDPI**：Android的额外额外额外高dpi显示（~640 dpi）'
- en: It can be easily predicted that the list will include more options in the near
    future, with the advancement of hardware technology.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地预测，随着硬件技术的进步，列表将在不久的将来包含更多选项。
- en: Battery capacity
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电池容量
- en: Battery capacity is an odd factor in the performance of the application. More
    powerful CPUs, GPUs, and RAM demand more power. If the battery is incapable of
    delivering power, then processing units cannot run at their peak efficiency.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 电池容量是应用性能中的一个奇怪因素。更强大的CPU、GPU和RAM需要更多的电力。如果电池无法提供电力，那么处理单元就无法以最高效率运行。
- en: 'To summarize these factors, we can easily make a few relational equations with
    performance:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这些因素，我们可以很容易地用性能做出一些关系方程：
- en: CPU is directly proportional to performance
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU与性能成正比
- en: GPU is directly proportional to performance
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU与性能成正比
- en: RAM is directly proportional to performance
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM与性能成正比
- en: Display quality is inversely proportional to performance
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示质量与性能成反比
- en: Battery capacity is directly proportional to performance
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池容量与性能成正比
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The scope of 3D games is increasing day by day with more quality and performance.
    However, this requires hardware support for the running Android platform. Old
    devices are not obsolete yet.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更高质量和性能的3D游戏范围不断扩大。然而，这需要硬件支持运行Android平台。旧设备尚未过时。
- en: It becomes a serious problem when the same application runs on various devices.
    This becomes a challenge for developers to run the same application across devices.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一应用在不同设备上运行时，这就成为一个严重的问题。这对开发人员来说是一个挑战，要在不同设备上运行同一应用。
- en: There are many technical differences between 2D and 3D games in terms of rendering,
    processing, and assets. The developer should always use an optimized approach
    to create assets and write code. One more way of gaining performance is to port
    the games for different hardware systems for both 2D and 3D games.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染、处理和资产方面，2D和3D游戏之间存在许多技术差异。开发人员应始终使用优化的方法来创建资产和编写代码。另一种提高性能的方法是为2D和3D游戏的不同硬件系统移植游戏。
- en: We can see a revolutionary upgrade in hardware platforms since the last decade.
    Accordingly, the nature of games has also changed. However, the scope of 2D games
    is still there with a large set of possibilities.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 自上个十年以来，硬件平台已经有了革命性的升级。相应地，游戏的性质也发生了变化。然而，2D游戏的范围仍然存在着大量的可能性。
- en: There are many frameworks and engines available for developing 2D and 3D games.
    Support for multiple operating systems has also increased its value for both 2D
    and 3D games.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于开发2D和3D游戏的框架和引擎。对多个操作系统的支持也增加了对2D和3D游戏的价值。
- en: Improving performance is more of a logical task than a technical one. There
    are a few tools available to do the job, but it is the developer's decision to
    choose them. So, selecting the right tool for the right purpose is necessary,
    and there should be a different approach to making 2D and 3D games.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 提高性能更多是一个逻辑任务，而不是技术任务。有一些可用的工具来完成这项工作，但选择权在开发人员手中。因此，选择合适的工具是必要的，制作2D和3D游戏应该有不同的方法。
- en: We have already discussed the rendering processes in both 2D and 3D development.
    We will further enhance rendering with the help of shaders in Android and try
    to explore various techniques of optimizing Android games later in this book.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了2D和3D开发中的渲染过程。我们将在本书的后面进一步利用Android中的着色器来增强渲染，并尝试探索优化Android游戏的各种技术。
