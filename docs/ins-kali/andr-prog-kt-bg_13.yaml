- en: Chapter 13. Bringing Android Widgets to Life
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。让Android小部件活起来
- en: Now that we have a good overview of both the layout and coding of an Android
    app, as well as our newly acquired insight into **object-oriented programming**
    (**OOP**) and how we can manipulate the UI from our Kotlin code, we are ready
    to experiment with more widgets from the Android Studio palette.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Android应用的布局和编码有了很好的概述，以及我们对面向对象编程（OOP）的新见解以及如何从Kotlin代码中操作UI，我们准备从Android
    Studio调色板中尝试更多的小部件。
- en: At times, OOP is a tricky thing, and this chapter introduces some topics that
    can be awkward for beginners. However, by gradually learning these new concepts
    and practicing them repeatedly, they will, over time, become our friend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，面向对象编程是一件棘手的事情，本章介绍了一些对初学者来说可能很尴尬的话题。然而，通过逐渐学习这些新概念并反复练习，它们将随着时间成为我们的朋友。
- en: In this chapter, we will diversify a lot by going back to the Android Studio
    palette and looking at half a dozen widgets that we have either not seen at all
    or have not used fully yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过回到Android Studio调色板并查看半打小部件来扩大范围，这些小部件我们要么根本没有见过，要么还没有完全使用过。
- en: Once we have done so, we will put them all into a layout and practice manipulating
    them with our Kotlin code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，我们将把它们全部放入布局，并练习用我们的Kotlin代码操纵它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Refresh our memories on declaring and initializing layout widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新我们对声明和初始化布局小部件的记忆
- en: See how to create widgets with just Kotlin code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何只用Kotlin代码创建小部件
- en: Take a look at the `EditText`, `ImageView`, `RadioButton` (and `RadioGroup`),
    `Switch`, `CheckBox`, and `TextClock` widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看`EditText`，`ImageView`，`RadioButton`（和`RadioGroup`），`Switch`，`CheckBox`和`TextClock`小部件
- en: Learn how to use lambda expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用lambda表达式
- en: Make a widget demo mini app using all the preceding widgets and plenty of lambda
    expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有前述小部件和大量lambda表达式制作小部件演示迷你应用程序
- en: Let's start with a quick recap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速回顾一下。
- en: Declaring and initializing the objects from the layout
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化来自布局的对象
- en: We know that when we call `setContentView` in the `onCreate` function, Android
    inflates all the widgets and layouts, and turns them into *real* instances on
    the Heap.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当我们在`onCreate`函数中调用`setContentView`时，Android会膨胀所有小部件和布局，并将它们转换为堆上的*真实*实例。
- en: 'We know that to use a widget from the Heap, we must have an object of the correct
    type by using its unique `id` property. Sometimes, we must specifically obtain
    a widget from a layout. For example, to get a reference to a `TextView` class
    with an `id` property of `txtTitle` and assign it to a new object called `myTextView`,
    we can do the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道要使用来自堆的小部件，我们必须具有正确类型的对象，通过其唯一的`id`属性。有时，我们必须明确从布局中获取小部件。例如，要获取具有`id`属性`txtTitle`并将其分配给一个名为`myTextView`的新对象的`TextView`类的引用，我们可以这样做：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The left-hand side of the declaration of the `myTextView` instance should look
    familiar to all the instances of other classes that we declared throughout the
    previous three chapters. What is new here is that we are relying on the return
    value of a function to supply the instance. The `findViewById` function does indeed
    return an instance that was created on the Heap when the layout was inflated.
    The required instance is identified by the function argument that matches the
    `id` property of the widget in the layout. The curious-looking `<TextView>` syntax
    is a **cast** or conversion to `TextView` because the function returns the super-class
    type, `View`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`myTextView`实例声明的左侧应该对前三章中声明的其他类的实例都很熟悉。这里的新东西是我们依赖函数的返回值来提供实例。`findViewById`函数确实返回在膨胀布局时在堆上创建的实例。所需的实例由与布局中小部件的`id`属性匹配的函数参数标识。看起来奇怪的`<TextView>`语法是`TextView`的**转换**，因为函数返回超类类型`View`。'
- en: 'Now, using our `myTextView` instance variable, we can do anything that the
    `TextView` class was designed to do; for example, we can set the text to appear
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用我们的`myTextView`实例变量，我们可以做任何`TextView`类设计的事情；例如，我们可以设置文本如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can make it disappear like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以让它消失，就像这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now change its text again and make it reappear, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次更改其文本并使其重新出现，如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is worth mentioning that we can manipulate any property in Kotlin that we
    can set using XML code in the previous chapters. Furthermore, we have hinted at,
    but not actually seen, that we can create widgets from nothing, using just code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们可以在Kotlin中操纵任何在以前章节中使用XML代码设置的属性。此外，我们已经暗示过，但实际上还没有看到，我们可以只使用代码从无中创建小部件。
- en: Creating UI widgets from pure Kotlin without XML
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从纯Kotlin创建UI小部件而不使用XML
- en: 'We can also create widgets from Kotlin objects that are not a reference to
    an object in our layout. We can declare, instantiate, and set a widget''s attributes,
    all in code, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从不是指向布局中对象的Kotlin对象创建小部件。我们可以在代码中声明、实例化和设置小部件的属性，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code creates a new `Button` instance. The only caveat is that
    the `Button` instance must be part of a layout before it can be seen by the user.
    So, we can either get a reference to a layout element from our XML layout in the
    same way that we previously did using the `findViewById` function, or we can create
    a new one in code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的`Button`实例。唯一的注意事项是`Button`实例必须是布局的一部分，才能被用户看到。因此，我们可以通过与以前使用`findViewById`函数相同的方式从XML布局中获取对布局元素的引用，或者可以在代码中创建一个新的布局。
- en: 'If we assume that we have a `LinearLayout` in our XML with an `id` property
    equal to `linearLayout1`, we can incorporate our `Button` instance from the preceding
    line of code in it, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的XML中有一个`id`属性等于`linearLayout1`的`LinearLayout`，我们可以将前一行代码中的`Button`实例合并到其中，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can even create an entire layout in pure Kotlin code by first creating a
    new layout, then all the widgets that we want to add, and finally calling `setContentView`
    on the layout that has our required widgets in it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过首先创建一个新布局，然后添加所有我们想要添加的小部件，最后在具有所需小部件的布局上调用`setContentView`来纯粹使用Kotlin代码创建整个布局。
- en: 'In the following piece of code, we create a layout in pure Kotlin, albeit a
    very simple one with a single `Button` instance inside a `LinearLayout`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们使用纯Kotlin创建了一个布局，尽管它非常简单，只有一个`LinearLayout`内部有一个`Button`实例：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is probably obvious, but it is still worth mentioning that designing a detailed
    and nuanced layout in Kotlin only is significantly more awkward, harder to visualize,
    and not the way it is most commonly done. There are times, however, when we will
    find it useful to do things this way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是显而易见的，但仍然值得一提的是，仅使用Kotlin设计详细和微妙的布局会更加麻烦，更难以可视化，而且不是最常见的方式。然而，有时我们会发现以这种方式做事情是有用的。
- en: We are getting quite advanced now with layouts and widgets. It is evident, however,
    that there are a lot of other widgets (and UI elements) from the palette that
    we have not explored or interacted with (other than just dumping them in a layout
    and not doing anything with them); so, let's fix that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经相当高级了，涉及到布局和小部件。然而，很明显，调色板中还有许多其他小部件（和UI元素）我们尚未探索或交互（除了将它们放在布局中并没有做任何处理）；所以，让我们解决这个问题。
- en: Exploring the palette – part 1
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索调色板-第1部分
- en: Let's take a whirlwind tour of some of the previously unexplored and unused
    items from the palette, and then we can drag a number of them onto a layout and
    see what useful functions they might have. We can then implement a project to
    put them all to use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下调色板中以前未探索和未使用的项目，然后我们可以将其中一些拖放到布局中，看看它们可能具有的有用功能。然后我们可以实现一个项目来利用它们。
- en: We have already explored `Button` and `TextView` in the previous chapter. Now
    let's take a closer look at some more widgets alongside them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中探索了`Button`和`TextView`。现在让我们更仔细地看看它们旁边的一些小部件。
- en: The EditText widget
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditText小部件
- en: The `EditText` widget does as its name suggests. If we make an `EditText` widget
    available to our users, then they will indeed be able to *edit* the *text* in
    it. We saw this in an earlier chapter, but we didn't achieve anything with it.
    What we didn't see was how to capture the information from within it, or where
    we could type this text-capturing code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText`小部件就像其名称所示。如果我们向用户提供`EditText`小部件，他们确实可以编辑其中的文本。我们在早期章节中看到了这一点，但我们并没有做任何处理。我们没有看到的是如何捕获其中的信息，或者我们可以在哪里输入这个捕获文本的代码。'
- en: 'The next block of code assumes that we have declared an object of type `EditText`
    and have used it to get a reference to an `EditText` widget in our XML layout.
    We might write something similar to the following code for a button click, perhaps
    a "submit" button for a form, but it can go anywhere we deem it necessary in our
    app:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一个块假设我们已经声明了一个类型为`EditText`的对象，并使用它来获取XML布局中`EditText`小部件的引用。我们可能会为按钮点击编写类似以下代码的内容，也许是表单的“提交”按钮，但它可以放在我们应用程序中认为必要的任何地方：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will see an `EditText` widget in a real context in the next app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个应用程序中看到`EditText`小部件的真实情境。
- en: The ImageView widget
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageView小部件
- en: 'We have already put an image onto our layout a couple of times so far, but
    we haven''t got a reference to one from our code or done anything with it before.
    The process of getting a reference to an `ImageView` widget is the same as it
    is to any other widget:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在布局上放置了几次图像，但在代码中我们还没有引用过它，也没有做任何处理。获取`ImageView`小部件的引用的过程与获取其他小部件的引用相同：
- en: Declare an object.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个对象。
- en: 'Get a reference using the `findViewById` function and a valid `id` property,
    as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`findViewById`函数和有效的`id`属性获取引用，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can go on to do some interesting things with our image by using code
    that is similar to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用类似以下的代码对图像进行一些有趣的操作：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The odd-looking `f` value simply lets the compiler know that the value is type
    `Float`, as required by the `alpha` property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来奇怪的`f`值只是让编译器知道该值是`Float`类型，这是`alpha`属性所需的。
- en: In the preceding code, we use the `alpha` property from `imageView`. The `alpha`
    property requires a value between 0 and 1\. 0 is completely transparent, while
    1 indicates no transparency at all. We will use some of the features of `ImageView`
    in our next app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`imageView`的`alpha`属性。`alpha`属性需要一个介于0和1之间的值。0表示完全透明，而1表示完全不透明。我们将在下一个应用程序中使用`ImageView`的一些功能。
- en: RadioButtons and RadioGroups
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RadioButtons和RadioGroups
- en: 'A `RadioButton` widget is used when there are two or more mutually exclusive
    options for the user to choose from. This means that when one option is chosen,
    the other options are not; such as on an old-fashioned radio. Take a look at a
    simple `RadioGroup` widget with a few `RadioButton` widgets in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要从两个或多个互斥的选项中进行选择时，使用`RadioButton`小部件。这意味着选择一个选项时，其他选项将不被选择；就像在老式收音机上一样。请看下面截图中带有几个`RadioButton`小部件的简单`RadioGroup`小部件：
- en: '![RadioButtons and RadioGroups](img/B12806_13_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![RadioButtons and RadioGroups](img/B12806_13_01.jpg)'
- en: 'When the user makes a choice, the other options will automatically be deselected.
    We control `RadioButton` widgets by placing them within a `RadioGroup` widget
    in our UI layout. We can, of course, use the visual designer to simply drag a
    bunch of `RadioButtons` onto a `RadioGroup`. When we do, the XML code will look
    something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户做出选择时，其他选项将自动取消选择。我们通过将`RadioButton`小部件放置在UI布局中的`RadioGroup`小部件中来控制`RadioButton`小部件。当然，我们可以使用可视化设计工具简单地将一堆`RadioButtons`拖放到`RadioGroup`上。这样做时，XML代码将如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice, as highlighted in the previous code, that each `RadioButton` widget
    and the `RadioGroup` widget has an appropriate `id` attribute set. We can then
    get a reference to them as we might expect, as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如前面的代码所强调的，每个`RadioButton`小部件和`RadioGroup`小部件都设置了适当的`id`属性。然后我们可以像预期的那样引用它们，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In practice, however, we can manage almost everything from the `RadioGroup`
    reference alone.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，我们几乎可以仅通过`RadioGroup`的引用来管理所有事情。
- en: You might be thinking how do we know when they have been clicked on, or that
    keeping track of which one is selected might be awkward? We need some help from
    the Android API and Kotlin in the form of **lambdas**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道他们何时被点击，或者跟踪哪一个被选中可能会很麻烦？我们需要一些来自Android API和Kotlin的帮助，以**lambda**的形式。
- en: Lambdas
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: When a `RadioButton` widget is part of `RadioGroup,` the visual appearance of
    them is coordinated for us. All we need to do is react when any given `RadioButton`
    widget is pressed. Of course, as with any other button, we need to know when they
    have been clicked on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`RadioButton`小部件是`RadioGroup`的一部分时，它们的视觉外观会被协调。我们所需要做的就是在任何给定的`RadioButton`小部件被按下时做出反应。当然，与任何其他按钮一样，我们需要知道它们何时被点击。
- en: A `RadioButton` widget behaves differently to a regular `Button` widget and
    simply listening for clicks in `onClick` (after implementing `OnClickListener`)
    will not work because the `RadioButton` class is not designed that way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadioButton`小部件的行为与常规的`Button`小部件不同，只是在`onClick`中监听点击（在实现`OnClickListener`之后）是行不通的，因为`RadioButton`类不是设计成那样的。'
- en: 'What we need to do is use another Kotlin feature. We need an instance of a
    special interface, for the sole purpose of listening for clicks on `RadioGroup`.
    The next block of code assumes that we have a reference to a `RadioGroup` instance
    called `radioGroup`; here is the code to examine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是使用另一个Kotlin特性。我们需要一个特殊接口的实例，唯一的目的是监听`RadioGroup`上的点击。下面的代码块假设我们有一个名为`radioGroup`的`RadioGroup`实例的引用；以下是要检查的代码：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code, specifically `setOnChekedChangeListener` from its opening
    curly brace (`{`) to the closing curly brace (`}`), is what is known as a lambda.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码，特别是从其开头的大括号（`{`）到结束的大括号（`}`）的`setOnChekedChangeListener`，被称为lambda。
- en: Lambdas are a wide-ranging topic and they will be further explored as we progress.
    They are used in Kotlin to avoid unnecessary typing. The compiler knows that `setOnCheckedChangeListener`
    requires a special interface as an argument, and it handles this for us behind
    the scenes. Furthermore, the compiler knows that the interface has one abstract
    function that we must override. The code that is between the opening and closing
    curly brackets is where our implementation of the function goes. The curious-looking
    `group, checkedId ->` parameters are the parameters of this function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是一个广泛的话题，随着我们的进展，它们将进一步探讨。它们在Kotlin中用于避免不必要的输入。编译器知道`setOnCheckedChangeListener`需要一个特殊的接口作为参数，并在幕后为我们处理这个问题。此外，编译器知道该接口有一个我们必须重写的抽象函数。在大括号的开头和结尾之间的代码是我们实现函数的地方。看起来奇怪的`group,
    checkedId ->`参数是这个函数的参数。
- en: Assume, for the purpose of further discussion, that the preceding code was written
    in the `onCreate` function. Note that the code within the curly braces does not
    run when `onCreate` is called; it simply prepares the instance (`radioGroup`)
    so that it is ready to handle any clicks. We will now discuss this in more detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步讨论的目的，假设前面的代码是在`onCreate`函数中编写的。请注意，当调用`onCreate`时，大括号内的代码不会运行；它只是准备好实例（`radioGroup`），以便它准备好处理任何点击。我们现在将更详细地讨论这一点。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This unseen interface is known as an **anonymous** class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看不见的接口被称为**匿名**类。
- en: What we are doing is adding a listener to `radioGroup`, which has very much
    the same effect as when we implemented `View.OnClickListener` in [Chapter 12,](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability") *Connecting Our
    Kotlin to the UI and Nullability*. Only this time, we are declaring and instantiating
    a listener interface, and preparing it to listen to `radioGroup`, while simultaneously
    overriding the required function, which, in this case (although we can't see the
    name), is `onCheckedChanged`. This is like the `RadioGroup` equivalent of `onClick`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向`radioGroup`添加一个监听器，这与我们在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")中实现`View.OnClickListener`的效果是非常相似的，只是这一次，我们声明并实例化了一个监听器接口，并准备让它监听`radioGroup`，同时重写所需的函数，这种情况下（虽然我们看不到名称），是`onCheckedChanged`。这就像`RadioGroup`中的`onClick`等效。
- en: If we use the preceding code to create and instantiate a class that listens
    for clicks to our `RadioGroup`, in the `onCreate` function, it will listen and
    respond for the entire life of the Activity. All we need to learn about now is
    how to handle the clicks in the `onCheckedChanged` function that we are overriding.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用上面的代码来创建和实例化一个类，监听我们的`RadioGroup`的点击，在`onCreate`函数中，它将在整个Activity的生命周期内监听和响应。现在我们需要学习的是如何在我们重写的`onCheckedChanged`函数中处理点击。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Some students find the preceding code straightforward and others find it a
    little overwhelming. It is not an indication of your intelligence level that determines
    the way that you perceive it, but a matter of how your brain likes to learn. There
    are two ways that you can tackle the information in this chapter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有些学生觉得前面的代码很简单，而其他人觉得有点压力山大。这并不是决定你如何看待它的智力水平的指标，而是你的大脑喜欢学习的方式。你可以用两种方式来处理本章的信息：
- en: Accept that the code works, move on, and revisit exactly how things work later
    in your programming career.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接受代码的工作，继续前进，并在以后的编程生涯中重新审视事物的工作原理。
- en: Insist on becoming expert on the topics in this chapter and devote a lot of
    time to mastering them before moving on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持成为本章主题的专家，并在继续前进之前花费大量时间来掌握它们。
- en: I strongly recommend option 1\. Some topics can't be mastered until other topics
    are understood. But a problem arises when, to move on to the latter, you first
    need to have an introduction to the former. The problem becomes circular and unsolvable
    if you insist on complete mastery at all times. Sometimes, it is important to
    just accept that there is more under the surface. If you can simply accept that
    the code we just looked at does work behind the scenes, and that the code within
    the curly braces is what happens when the radio button is clicked on; then, you
    are ready to proceed. You can now go and do a web search for lambdas; however,
    be prepared for many hours of theory. We will revisit lambdas again in this chapter
    and throughout the book while focusing on practical application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐选项1。有些主题在理解其他主题之前是无法掌握的。但是，当你需要先介绍前者才能继续后者时，问题就会出现。如果你坚持要时刻完全掌握，问题就会变得循环和无法解决。有时，重要的是要接受表面下还有更多。如果你能简单地接受我们刚刚看到的代码确实在幕后起作用，并且花括号内的代码是单击单选按钮时发生的事情；那么，你就准备好继续了。现在你可以去搜索lambda表达式；但是，要准备好花费很多时间来学习理论。在本章和整本书中，我们将重点关注实际应用，再次讨论lambda表达式。
- en: Writing the code for the overridden function
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写重写函数的代码
- en: Notice that one of the parameters of this function that is passed in when the
    `radioGroup` instance is pressed is `checkedId`. This parameter is an `Int` type
    and it holds the `id` property of the currently selected `RadioButton`. This is
    just what we need – almost.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`radioGroup`实例被按下时传入此函数的一个参数是`checkedId`。此参数是一个`Int`类型，并且它保存当前选定的`RadioButton`的`id`属性。这几乎正是我们需要的。
- en: It might be surprising that `checkedId` is an `Int` type. Android stores all
    IDs as `Int`, even though we declare them with alphanumeric characters such as
    `radioButton1` or `radioGroup`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 也许令人惊讶的是，`checkedId`是一个`Int`类型。即使我们用字母数字字符声明它们，如`radioButton1`或`radioGroup`，Android也将所有ID存储为`Int`。
- en: All our human-friendly names are converted to `Int` when the app is compiled.
    So, how do we know which `Int` type refers to an ID such as `radioButton1` or
    `radioButton2`?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序编译时，所有我们熟悉的人性化名称都会转换为`Int`。那么，我们怎么知道`Int`类型是指`radioButton1`或`radioButton2`这样的ID呢？
- en: 'What we need to do is get a reference to the actual object that the `Int` type
    is an ID for, using the `Int id` property and then ask the object for its human-friendly
    `id` value. We will do so as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是获取`Int`类型作为ID的实际对象的引用，使用`Int id`属性，然后询问对象其人性化的`id`值。我们将这样做：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can retrieve the familiar `id` property that we used for the currently-selected
    `RadioButton` widget, for which we now have a reference stored in `rb`, with the
    `id` property''s getter function, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`rb`中存储的引用来检索我们熟悉的`id`属性，该属性用于当前选定的`RadioButton`小部件，使用`id`属性的getter函数，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We could, therefore, handle `RadioButton` clicks by using a `when` block with
    a branch for each possible `RadioButton` that could be pressed, and `rb.id` as
    the condition.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过使用`when`块处理`RadioButton`的点击，每个可能被按下的`RadioButton`都有一个分支，`rb.id`作为条件。
- en: 'The following code shows the entire contents of the `onCheckedChanged` function
    that we have just discussed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们刚刚讨论的`onCheckedChanged`函数的全部内容：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Seeing this in action in the next working mini-app, where we can press the buttons
    for real, will make this clearer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个工作迷你应用程序中看到这一点的实际效果，我们可以按下按钮，这将使情况更加清晰。
- en: Let's continue with our palette exploration.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索调色板。
- en: Exploring the palette – part 2, and more lambdas
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索调色板-第2部分，以及更多的lambda。
- en: Now that we have seen how lambdas and anonymous classes and interfaces work,
    specifically with `RadioGroup` and `RadioButton`, we can now continue exploring
    the palette and look at working with some more UI widgets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了lambda和匿名类和接口如何工作，特别是与`RadioGroup`和`RadioButton`一起，我们现在可以继续探索调色板，并查看如何使用更多的UI小部件。
- en: The Switch widget
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Switch`小部件'
- en: The `Switch` widget is just like a `Button` widget except that it has two fixed
    states that can be read and responded to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`小部件就像`Button`小部件一样，只是它有两个固定的状态，可以读取和响应。'
- en: An obvious use for the `Switch` widget is to show and hide something. Remember
    that in our Kotlin Meet UI app in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*
    we used a `Button` to show and hide a `TextView` widget?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`小部件的一个明显用途是显示和隐藏某些内容。还记得我们在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")的Kotlin
    Meet UI应用程序中使用`Button`来显示和隐藏`TextView`小部件吗？'
- en: 'Each time we hid or showed the `TextView` widget, we changed the `text` property
    on the `Button` to make it evident what would happen if it was clicked on again.
    What might have been more intuitive for the user, and more straightforward for
    us as programmers, would have been to use a `Switch` widget, as illustrated in
    the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们隐藏或显示`TextView`小部件时，我们都会更改`Button`上的`text`属性，以表明如果再次单击它会发生什么。对于用户来说，以及对于我们作为程序员来说，更直观的做法可能是使用`Switch`小部件，如下面的屏幕截图所示：
- en: '![The Switch widget](img/B12806_13_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Switch小部件](img/B12806_13_02.jpg)'
- en: The following code assumes that we already have an object called `mySwitch`,
    which is a reference to a `Switch` object in the layout. We could show and hide
    a `TextView` widget just as we did in our *Kotlin Meet UI* app in [Chapter 12](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码假设我们已经有一个名为`mySwitch`的对象，它是布局中`Switch`对象的引用。我们可以像在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")中的*Kotlin
    Meet UI*应用程序中那样显示和隐藏`TextView`小部件。
- en: To listen for, and respond to, clicks/switching, we again use an anonymous class.
    This time, however, we use the `CompoundButton` version of `OnCheckedChangeListener`.
    As before, these details are inferred, and we can use very similar and simple
    code as when we handled the radio button widgets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 监听并响应点击/切换，我们再次使用匿名类。然而，这次我们使用`CompoundButton`版本的`OnCheckedChangeListener`。与之前一样，这些细节是推断出来的，我们可以使用非常类似和简单的代码，就像处理单选按钮小部件时一样。
- en: We need to override the `onCheckedChanged` function and that function has a
    `Boolean` parameter, `isChecked`. The `isChecked` variable is simply false for
    off and true for on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`onCheckedChanged`函数，该函数有一个`Boolean`参数`isChecked`。`isChecked`变量对于关闭是false，对于打开是true。
- en: 'This is how we can more intuitively replace this text by hiding or showing
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以更直观地通过隐藏或显示代码来替换这段文字的方法：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the anonymous class or lambda code still looks a little odd, don't worry
    because it will become more familiar the more we use it. And we will do so again
    now when we look at `CheckBox`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匿名类或lambda代码看起来有点奇怪，不要担心，因为随着我们的使用，它会变得更加熟悉。现在我们再次看看`CheckBox`时，我们将这样做。
- en: The CheckBox widget
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框小部件
- en: 'With a `CheckBox` widget, we simply detect its state (checked or unchecked)
    at a given moment – such as at the moment when a specific button is clicked on.
    The following code gives us a glimpse of how this might happen, again using an
    anonymous class and lambda to act as a listener:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CheckBox`小部件，我们只需在特定时刻（例如在单击特定按钮时）检测其状态（选中或未选中）。以下代码让我们可以看到这可能会发生的情况，再次使用匿名类和lambda作为监听器：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we assume that `myCheckBox` has been declared and initialized,
    and then use the same type of anonymous class as we did for `Switch` to detect
    and respond to clicks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们假设`myCheckBox`已经被声明和初始化，然后使用与我们用于`Switch`相同类型的匿名类来检测和响应点击。
- en: The TextClock widget
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextClock小部件
- en: 'In our next app, we will use the `TextClock` widget to show off some of its
    features. We will need to add the XML code directly to the layout as this widget
    is not available to drag and drop from the palette. This is what the `TextClock`
    widget looks like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个应用程序中，我们将使用`TextClock`小部件展示一些其特性。由于这个小部件无法从调色板中拖放，我们需要直接将XML代码添加到布局中。这就是`TextClock`小部件的样子：
- en: '![The TextClock widget](img/B12806_13_03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![TextClock小部件](img/B12806_13_03.jpg)'
- en: 'As an example of using `TextClock`, this is how we will set its time to the
    same time as it is in Brussels, Europe:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`TextClock`的示例，这是我们将如何将其时间设置为与欧洲布鲁塞尔相同的时间：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code assumes that `tClock` is a reference to a `TextClock` widget
    in the layout.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码假设`tClock`是布局中`TextClock`小部件的引用。
- en: With all this extra information, let's make an app to use the Android widgets
    more practically than what we have so far.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些额外的信息，让我们制作一个应用程序，比我们迄今为止所做的更实用地使用Android小部件。
- en: The widget exploration app
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件探索应用程序
- en: We have just discussed six widgets – `EditText`, `ImageView`, `RadioButton`
    (and `RadioGroup`), `Switch`, `CheckBox`, and `TextClock`. Let's make a working
    app and do something practical with each of them. We will also use a `Button`
    widget and a `TextView` widget again as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了六个小部件——`EditText`、`ImageView`、`RadioButton`（和`RadioGroup`）、`Switch`、`CheckBox`和`TextClock`。让我们制作一个可用的应用程序，并对每个小部件进行一些实际操作。我们还将再次使用`Button`小部件和`TextView`小部件。
- en: In this layout, we will use `LinearLayout` as the layout type that holds everything,
    and within `LinearLayout`, we will use multiple `RelativeLayout` instances.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此布局中，我们将使用`LinearLayout`作为容纳一切的布局类型，并在`LinearLayout`内部使用多个`RelativeLayout`实例。
- en: '`RelativeLayout` has been superseded by `ConstraintLayout`, but they are still
    commonly used and are worth playing around with. You will see as you build layouts
    within `RelativeLayout` that the UI elements behave very much the same as `ConstraintLayout`,
    but that the underlying XML is different. It is not necessary to learn this XML
    in detail, rather, using `RelativeLayout` will allow us to show the interesting
    way that Android Studio enables you to convert these layouts to `ConstraintLayout`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`已被`ConstraintLayout`取代，但它们仍然常用，并且值得尝试。当您在`RelativeLayout`中构建布局时，您会发现UI元素的行为与`ConstraintLayout`非常相似，但底层的XML不同。不需要详细了解这个XML，而是使用`RelativeLayout`将允许我们展示Android
    Studio如何使您能够将这些布局转换为`ConstraintLayout`的有趣方式。'
- en: Remember that you can refer to the completed code in the download bundle. This
    app can be found in the `Chapter13/Widget Exploration` folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以参考下载包中的完整代码。此应用程序可以在`Chapter13/Widget Exploration`文件夹中找到。
- en: Setting up the widget exploration project and UI
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置小部件探索项目和UI
- en: 'First, we will set up a new project and prepare the UI layout. These steps
    will get all the widgets on the screen and the `id` properties set, ready to grab
    a reference to them. It will help to have a look at the target layout up and running,
    before we get started, and it is shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个新项目并准备UI布局。这些步骤将在屏幕上放置所有小部件并设置`id`属性，准备好引用它们。在开始之前，看一下目标布局并运行它会有所帮助，如下截图所示：
- en: '![Setting up the widget exploration project and UI](img/B12806_13_04.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![设置小部件探索项目和UI](img/B12806_13_04.jpg)'
- en: 'Here is how this app will demonstrate these widgets:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将演示这些小部件的工作原理：
- en: The radio buttons allow the user to change the time that is displayed on the
    clock to a choice of four time zones.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮允许用户更改显示在时钟上的时间，以选择四个时区中的一个。
- en: The **Capture** button, when clicked on, will change the `text` property of
    the `TextView` widget (on the right) to whatever is currently in the `EditText`
    widget (on the left).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**Capture**按钮将更改右侧`TextView`小部件的`text`属性为当前左侧`EditText`小部件中的内容。
- en: The three `CheckBox` widgets will add and remove visual effects from the Android
    robot image. In the previous screenshot, the image is resized (made bigger) and
    has a color tint applied.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个`CheckBox`小部件将向Android机器人图像添加和删除视觉效果。在先前的截图中，图像被调整大小（变大）并应用了颜色着色。
- en: The `Switch` widget will turn on and off the `TextView` widget that displays
    information entered in the `EditText` widget (which is captured at the click of
    a button).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Switch`小部件将打开和关闭`TextView`小部件，后者显示在`EditText`小部件中输入的信息（在单击按钮时捕获）。'
- en: 'The exact layout positions are not essential, but the `id` properties specified
    must match exactly. So, let''s perform the following steps to set up a new project
    and prepare the UI layout:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的布局位置并不重要，但指定的“id”属性必须完全匹配。因此，让我们执行以下步骤来设置一个新项目并准备UI布局：
- en: 'Create a new project called `Widget Exploration` and use the **Empty Activity**
    project template with its usual settings except for one small change. Set the
    **Minimum API level** option to `API 17: Android 4.2 (Jelly Bean)` and keep all
    the other settings at their default settings. We are using API 17 because one
    of the features of the `TextClock` widget requires us to. We still support in
    excess of 98% of all Android devices.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“Widget Exploration”的新项目，并使用**空活动**项目模板及其通常的设置，除了一个小改变。将**最低API级别**选项设置为`API
    17：Android 4.2（Jelly Bean）`，并将所有其他设置保持为默认设置。我们使用API 17是因为`TextClock`小部件的一个功能需要我们这样做。我们仍然支持超过98%的所有Android设备。
- en: Let's create a new layout file as we want our new layout to be based on `LinearLayout`.
    Right-click on the `layout` folder in the project explorer and select **New**
    | **Layout resource file** from the pop-up menu.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的布局文件，因为我们希望我们的新布局基于`LinearLayout`。在项目资源管理器中右键单击`layout`文件夹，然后从弹出菜单中选择**新建**
    | **布局资源文件**。
- en: In the **New resource file** window, enter `exploration_layout.xml` in the **File
    name** field and then enter `LinearLayout` in the **Root element** field; now
    click on **OK**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新资源文件**窗口中，在**文件名**字段中输入`exploration_layout.xml`，然后在**根元素**字段中输入`LinearLayout`；现在点击**确定**。
- en: In the **Attributes** window, change the `orientation` property of the `LinearLayout`
    to **horizontal**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**窗口中，将`LinearLayout`的`orientation`属性更改为**horizontal**。
- en: Using the drop-down controls above the design view, make sure you have selected
    a tablet in landscape orientation.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设计视图上方的下拉控件，确保选择了横向方向的平板电脑。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a reminder of how to make a tablet emulator, refer to [Chapter 3,](ch03.html
    "Chapter 3. Exploring Android Studio and the Project Structure") *Exploring Android
    Studio and the Project Structure*. For advice on how to manipulate the orientation
    of the emulator, refer to [Chapter 5,](ch05.html "Chapter 5. Beautiful Layouts
    with CardView and ScrollView") *Beautiful Layouts with CardView and ScrollView*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解如何创建平板电脑模拟器，请参阅[第3章](ch03.html "第3章。探索Android Studio和项目结构")*探索Android Studio和项目结构*。如需关于如何操作模拟器方向的建议，请参阅[第5章](ch05.html
    "第5章。使用CardView和ScrollView创建美观布局")*使用CardView和ScrollView创建美观布局*。
- en: We can now begin to create our layout. Drag and drop three **RelativeLayout**
    layouts from the **Legacy** category of the palette onto the design to create
    the three vertical divisions of our design. You will probably find it easier to
    use the **Component Tree** window for this step.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始创建我们的布局。从工具栏的**Legacy**类别中将三个**RelativeLayout**布局拖放到设计中，以创建我们设计的三个垂直分区。在这一步骤中，您可能会发现使用**组件树**窗口更容易。
- en: Set the **weight** property for each of the `RelativeLayout` widgets in turn
    to `.33`. We now have three equal vertical divisions, just like in the following
    screenshot:![Setting up the widget exploration project and UI](img/B12806_13_05.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次为每个`RelativeLayout`小部件设置**weight**属性为`.33`。现在我们有了三个相等的垂直分区，就像下面的截图一样：![设置小部件探索项目和UI](img/B12806_13_05.jpg)
- en: Check that the **Component Tree** window looks like the following screenshot:![Setting
    up the widget exploration project and UI](img/B12806_13_06.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查**组件树**窗口是否如下截图所示：![设置小部件探索项目和UI](img/B12806_13_06.jpg)
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to use `ConstraintLayout` instead of `RelativeLayout`, then the
    following instructions will be nearly identical. Just remember to set the final
    position of your UI by clicking the **Infer Constraints** button, or by setting
    the constraints manually, as discussed in [Chapter 4,](ch04.html "Chapter 4. Getting
    Started with Layouts and Material Design") *Getting Started with Layouts and Material
    Design*. Alternatively, you can build the layout exactly as detailed in this tutorial
    and you can use the **Convert to Constraint layout** feature that is discussed
    later in this chapter. This is excellent for using layouts you have and want to
    use, but prefer to use the faster-running `ConstraintLayout`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用`ConstraintLayout`而不是`RelativeLayout`，那么以下说明将几乎相同。只需记住通过单击**推断约束**按钮或手动设置约束来设置UI的最终位置，如[第4章](ch04.html
    "第4章。开始使用布局和Material Design")*开始使用布局和Material Design*中所讨论的那样。或者，您可以按照本教程中详细说明的方式构建布局，并使用稍后在本章中讨论的**转换为Constraint布局**功能。这对于使用您已有并希望使用的布局非常有用，但更倾向于使用运行速度更快的`ConstraintLayout`。
- en: Drag a **Switch** widgetnear the top-center of the right-hand `RelativeLayout`
    widget and just below, drag a **TextView** from the palette. The right-hand side
    of your layout should now look like the following screenshot:![Setting up the
    widget exploration project and UI](img/B12806_13_07.jpg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Switch**小部件拖放到右侧`RelativeLayout`小部件的顶部中心位置，然后在其下方从工具栏中拖放一个**TextView**。您的布局右侧现在应如下截图所示：![设置小部件探索项目和UI](img/B12806_13_07.jpg)
- en: Drag three **CheckBox** widgets, one above the other, and then an **ImageView**
    widget underneath them onto the central `RelativeLayout`. In the resulting pop-up
    **Resources** dialog window, choose **Project** | **ic_launcher** to use the Android
    icon as the image for the `ImageView` widget. The central column should now appear
    as follows:![Setting up the widget exploration project and UI](img/B12806_13_08.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个**CheckBox**小部件依次拖放在一起，然后将一个**ImageView**小部件拖放到它们下方的中央`RelativeLayout`上。在弹出的**资源**对话框中，选择**项目**
    | **ic_launcher**以将Android图标用作`ImageView`小部件的图像。中央列现在应如下所示：![设置小部件探索项目和UI](img/B12806_13_08.jpg)
- en: Drag a **RadioGroup** widget to the left-hand `RelativeLayout`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**RadioGroup**小部件拖放到左侧的`RelativeLayout`上。
- en: Add four **RadioButton** widgets within the **RadioGroup** widget. This step
    will be easier by using the **Component Tree** window.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**RadioGroup**小部件内添加四个**RadioButton**小部件。使用**组件树**窗口可以更轻松地完成此步骤。
- en: Underneath the **RadioGroup** widget, drag a **Plain Text** widget from the
    **Text** category of the palette. Remember, despite its name, that this is a widget
    that allows the user to type some text into it. Soon, we will see how to capture
    and use the entered text.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**RadioGroup**小部件下方，从调色板的**文本**类别中拖动一个**纯文本**小部件。请记住，尽管它的名字是这样，但这是一个允许用户在其中输入一些文本的小部件。很快，我们将看到如何捕获和使用输入的文本。
- en: Add a **Button** widget to the right of the **Plain Text** widget. Your left-hand
    `RelativeLayout` should look like this screenshot:![Setting up the widget exploration
    project and UI](img/B12806_13_09.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**纯文本**小部件的右侧添加一个**Button**小部件。您的左侧`RelativeLayout`应如下截图所示：
- en: 'The **Component Tree** window will look like the following screenshot at this
    stage:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此时**组件树**窗口将如下截图所示：
- en: '![Setting up the widget exploration project and UI](img/B12806_13_10.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![设置小部件探索项目和UI](img/B12806_13_10.jpg)'
- en: 'Now add the following attributes to the widgets that we have just laid out:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们可以开始使用所有这些小部件与我们的Kotlin代码。现在为刚刚布置的小部件添加以下属性： '
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some of the attributes might already be correct by default.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '| CheckBox (top) | id | `checkBoxTransparency` |'
- en: '| Widget type | Property | Value to set to |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Widget type | Property | 要设置的值 |'
- en: '| --- | --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| RadioGroup | `id` | `radioGroup` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| RadioGroup | `id` | `radioGroup` |'
- en: '| RadioButton (top) | `id` | `radioButtonLondon` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: 请注意，一些属性可能已经默认正确。
- en: '| RadioButton (top) | `text` | `London` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (top) | `text` | `London` |'
- en: '| RadioButton (top) | `checked` | Select the "tick" icon for true |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (top) | `checked` | 选择“勾”图标为true |'
- en: '| RadioButton (second) | `id` | `radioButtonBeijing` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (second) | `id` | `radioButtonBeijing` |'
- en: '| RadioButton (second) | `text` | `Beijing` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (second) | `text` | `Beijing` |'
- en: '| RadioButton (third) | `id` | `radioButtonNewYork` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (third) | `id` | `radioButtonNewYork` |'
- en: '| RadioButton (third) | `text` | `New York` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (third) | `text` | `New York` |'
- en: '| RadioButton (bottom) | id | `radioButtonEuropeanEmpire` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| CheckBox (bottom) | id | `checkBoxReSize` |'
- en: '| RadioButton (bottom) | text | `European Empire` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (bottom) | text | `European Empire` |'
- en: '| EditText | id | `editText` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| EditText | id | `editText` |'
- en: '| Button | id | `button` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| Button | id | `button` |'
- en: '| Button | text | `Capture` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Button | text | `Capture` |'
- en: '| CheckBox (top) | text | `Transparency` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| CheckBox (top) | text | `Transparency` |'
- en: '| CheckBox (top) | id | `checkBoxTransparency` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| RadioButton (bottom) | id | `radioButtonEuropeanEmpire` |'
- en: '| CheckBox (middle) | text | `Tint` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| CheckBox (middle) | text | `Tint` |'
- en: '| CheckBox (middle) | id | `checkBoxTint` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| CheckBox (middle) | id | `checkBoxTint` |'
- en: '| CheckBox (bottom) | text | `Resize` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| CheckBox (bottom) | text | `Resize` |'
- en: '| CheckBox (bottom) | id | `checkBoxReSize` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '![设置小部件探索项目和UI](img/B12806_13_09.jpg)'
- en: '| ImageView | id | `imageView` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| ImageView | id | `imageView` |'
- en: '| Switch | id | `switch1` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| Switch | id | `switch1` |'
- en: '| Switch | enabled | Select the "tick" icon for true |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| Switch | enabled | 选择“勾”图标为true |'
- en: '| Switch | clickable | Select the "tick" icon for true |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Switch | clickable | 选择“勾”图标为true |'
- en: '| TextView | id | `textView` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| TextView | id | `textView` |'
- en: '| TextView | textSize | `34sp` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| TextView | textSize | `34sp` |'
- en: '| TextView | layout_width | `match_parent` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| TextView | layout_width | `match_parent` |'
- en: '| TextView | layout_height | `match_parent` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| TextView | layout_height | `match_parent` |'
- en: 'Now switch to the **Text** tab to view the XML code for the layout. Find the
    end of the first (left-hand) `RelativeLayout` column as shown in the following
    code listing. I have added an XML comment and highlighted it in the following
    code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在切换到**文本**选项卡，查看布局的XML代码。找到第一个（左侧）`RelativeLayout`列的末尾，如下面的代码清单所示。我已经在下面的代码中添加了一个XML注释并对其进行了突出显示：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After the `<!--Insert TextClock Here-->` comment, insert the following XML
    code for the `TextClock` widget. Note that the comment was added by me in the
    previous listing to show you where to put the code. The comment will not be present
    in your code. We did things this way because `TextClock` is not available directly
    from the palette. Here is the code to add after the comment:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<!--Insert TextClock Here-->`注释之后，插入以下`TextClock`小部件的XML代码。请注意，注释是我在上一个清单中添加的，以指示您放置代码的位置。您的代码中不会出现该注释。我们之所以这样做是因为`TextClock`不能直接从调色板中获取。以下是在注释之后添加的代码：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Switch to the **Design** tab and tweak your layout to resemble the following
    reference diagram as closely as possible, but if you have the appropriate types
    of UI with the correct `id` attributes, then the code will still work even if
    the layout isn't identical:![Setting up the widget exploration project and UI](img/B12806_13_11.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**设计**选项卡，并调整布局，使其尽可能接近以下参考图表，但如果您具有正确的UI类型和正确的`id`属性，则即使布局不完全相同，代码仍将正常工作：![设置小部件探索项目和UI](img/B12806_13_11.jpg)
- en: We have just set the required attributes for our layout. There is nothing new
    that we haven't done before, except that some of the widget types are new to us
    and the layout is slightly more intricate.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了布局所需的属性。除了一些小部件类型对我们来说是新的，布局稍微更加复杂之外，我们并没有做过什么新的事情。
- en: Now we can get on with using all these widgets with our Kotlin code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '| RadioButton (top) | `id` | `radioButtonLondon` |'
- en: Coding the widget exploration app
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写小部件探索应用程序
- en: 'The first part of the Kotlin code that we need to change is to make sure that
    our new layout is displayed. We can do so by changing the call to the `setContentView`
    function in the `onCreate` function to look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改的Kotlin代码的第一部分是确保我们的新布局被显示出来。我们可以通过将`onCreate`函数中对`setContentView`函数的调用更改为以下内容来实现：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are many `import` statements that are needed for this app, so let''s
    add them all up front to save us from having to keep mentioning them as we proceed.
    Add the following `import` statements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序需要很多`import`语句，所以让我们一开始就把它们全部添加上，以免在进行过程中不断提到它们。添加以下`import`语句：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code also includes the `…exploration_layout.*` code (as highlighted
    in the preceding code) to automatically enable us to use the `id` attributes that
    we have just configured as the instance names in our Kotlin code. This saves us
    from using the `findViewByID` function multiple times. It will not always be possible
    to do things this way and knowing how to use the `findViewByID` function as we
    discussed earlier in the Declaring and initializing the objects from the layout
    section will sometimes be necessary.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还包括`…exploration_layout.*`代码（如前面的代码中所突出显示的）以自动启用我们刚刚配置的`id`属性作为我们Kotlin代码中的实例名称。这样可以避免多次使用`findViewByID`函数。这种方式并不总是可行的，有时需要知道如何使用`findViewByID`函数，就像我们在“在布局部分声明和初始化对象”中讨论的那样。
- en: Coding the CheckBox widget
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码CheckBox小部件
- en: Now we can create a lambda to listen for and handle clicks on the checkboxes.
    The following three blocks of code implement an anonymous class for each of the
    checkboxes in turn. What is different in each of them, however, is how we respond
    to a click, and we will discuss each of these in turn.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个lambda来监听和处理复选框的点击。以下三个代码块依次实现了每个复选框的匿名类。然而，它们各自不同的地方在于我们如何响应点击，我们将依次讨论每一个。
- en: Changing transparency
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变透明度
- en: The first checkbox is labeled **Transparency** and we use the `alpha` property
    on the `imageView` instance to change how transparent (that is, see-through) it
    is. The `alpha` property requires a floating-point value between 0 and 1 as an
    argument.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个复选框标记为**Transparency**，我们使用`imageView`实例上的`alpha`属性来改变其透明度。`alpha`属性需要一个介于0和1之间的浮点值作为参数。
- en: 0 is invisible and 1 has no transparency at all. So, when this checkbox is checked,
    we set the `alpha` property to `.1`, so that the image is barely visible; then,
    when it is unchecked, we set it to `1`, which is completely visible with no transparency.
    The `Boolean isChecked` parameter of `onCheckedChanged` function contains a true
    or false value as to whether the checkbox is checked or not.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 0是不可见的，1完全不透明。因此，当选中此复选框时，我们将`alpha`属性设置为`.1`，使图像几乎不可见；然后，当取消选中时，我们将其设置为`1`，即完全可见且没有透明度。`onCheckedChanged`函数的`Boolean
    isChecked`参数包含一个true或false值，表示复选框是否被选中。
- en: 'Add the following code after the call to the `setContentView` function in the
    `onCreate` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中的`setContentView`函数调用之后添加以下代码：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next anonymous class, we handle the checkbox labeled **Tint**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个匿名类中，我们处理标记为**Tint**的复选框。
- en: Changing color
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变颜色
- en: In the `onCheckedChanged` function, we use the `setColorFilter` function on
    `imageView` to overlay a color layer on the image. When `isChecked` is true, we
    layer a color, and when `isChecked` is false, we remove it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCheckedChanged`函数中，我们使用`setColorFilter`函数在`imageView`上叠加一个颜色层。当`isChecked`为true时，我们叠加一个颜色，当`isChecked`为false时，我们移除它。
- en: The `setColorFilter` function takes a color in the **ARGB** (**alpha**, **red**,
    **green**, and **blue**) format as an argument. The color is provided by the `argb`
    function of the `Color` class. The four arguments of the `argb` function are values
    for alpha, red, green, and blue. These four values create a color. In our case,
    the `150, 255, 0, 0` value creates a strong red tint, while the `0, 0, 0, 0` value
    creates no tint at all.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`setColorFilter`函数以**ARGB**（**alpha**，**red**，**green**和**blue**）格式的颜色作为参数。颜色由`Color`类的`argb`函数提供。`argb`函数的四个参数分别是alpha、red、green和blue的值。这四个值创建了一种颜色。在我们的例子中，`150,
    255, 0, 0`的值创建了强烈的红色色调，而`0, 0, 0, 0`的值则完全没有色调。'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To understand more about the `Color` class, check out the Android developer
    site at [http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html),
    and to understand the RGB color system more, take a look at Wikipedia here: [https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`Color`类的信息，请访问Android开发者网站：[http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html)，要更多了解RGB颜色系统，请查看维基百科：[https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model)。
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中的上一个代码块之后添加以下代码：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we will see how to scale the UI by playing with the size of the `ImageView`
    widget.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何通过调整`ImageView`小部件的大小来缩放UI。
- en: Changing size
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变大小
- en: In the anonymous class that handles the **Resize** labeled checkbox, we use
    the `scaleX` and `scaleY` properties to resize the robot image. When we set `scaleX`
    to 2 and `scaleY` to 2on `imageView`, we will double the size of the image, while
    setting the values to 1 will return the image to its normal size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理**Resize**标记的复选框的匿名类中，我们使用`scaleX`和`scaleY`属性来调整机器人图像的大小。当我们将`scaleX`设置为2，`scaleY`设置为2时，我们将使图像的大小加倍，而将值设置为1将使图像恢复到其正常大小。
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中的上一个代码块之后添加以下代码：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we will handle the three radio buttons.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理这三个单选按钮。
- en: Coding the RadioButton widgets
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码RadioButton小部件
- en: As they are part of a `RadioGroup` widget, we can handle them much more succinctly
    than we did with the `CheckBox` objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是`RadioGroup`小部件的一部分，我们可以处理它们比处理`CheckBox`对象时更简洁。
- en: First, we make sure they are clear to start with by calling `clearCheck()` on
    the `radioGroup` instance. Then, we create our anonymous class of the `OnCheckedChangeListener`
    type and override the `onCheckedChanged` function with a short and sweet lambda.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过在`radioGroup`实例上调用`clearCheck()`来确保它们一开始是清除的。然后，我们创建了`OnCheckedChangeListener`类型的匿名类，并重写了`onCheckedChanged`函数，使用了一个简短而甜美的lambda。
- en: This function will be called when any `RadioButton` from the `RadioGroup` widget
    is clicked on. All we need to do is get the `id` property of the `RadioButton`
    widget that was clicked on and respond accordingly. We will achieve this by using
    a `when` statement with three possible paths of execution – one for each `RadioButton`
    widget.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当从RadioGroup小部件中点击任何`RadioButton`时，将调用此函数。我们需要做的就是获取被点击的`RadioButton`小部件的`id`属性，并做出相应的响应。我们将使用`when`语句来实现三条可能的执行路径
    - 每个`RadioButton`小部件对应一条。
- en: 'Remember that when we first discussed `RadioButton,` the `id` property supplied
    in the `checkedId` parameter of `onCheckedChanged` was an `Int` type. This is
    why we must first create a new `RadioButton` object from `checkedId`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们首次讨论`RadioButton`时，在`onCheckedChanged`的`checkedId`参数中提供的`id`属性是`Int`类型。这就是为什么我们必须首先从`checkedId`创建一个新的`RadioButton`对象的原因：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can use the `id` property''s getter of the new `RadioButton` object
    as the condition for `when`, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用新的`RadioButton`对象的`id`属性的getter作为`when`的条件，如下所示：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, in each branch, we use the `timeZone` property's setter with the correct
    Android time zone code as an argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个分支中，我们使用`timeZone`属性的setter，并将正确的Android时区代码作为参数。
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can see all the Android time zone codes at [https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596)上查看所有Android时区代码。
- en: 'Add the following code, which incorporates everything that we have just discussed.
    Add it in the `onCreate` function after the previous code that we entered for
    handling the checkboxes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，其中包含我们刚刚讨论的所有内容。将其添加到处理复选框的先前代码之后的`onCreate`函数中：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now it's time for something a little bit new.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试一些稍微新的东西了。
- en: Using a lambda for handling clicks on a regular Button widget
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用lambda来处理常规Button小部件的点击
- en: In the next block of code that we will write, we will use a lambda to implement
    an anonymous class to handle the clicks on a regular `Button` widget. We call
    `button.setOnclickListener`, as we have done previously. This time, however, instead
    of passing `this` as an argument, we create a brand-new class of the type `View.OnClickListener`
    and override the `onClick` function as the argument, just as we did with our other
    anonymous classes. In the same way as our previous classes, the code is inferred
    and we have short, snappy code where our code isn't cluttered with too many details.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要编写的下一个代码块中，我们将使用lambda来实现一个匿名类来处理常规`Button`小部件的点击。我们调用`button.setOnclickListener`，就像我们之前做过的那样。但是这一次，我们不是将`this`作为参数传递，而是创建一个全新的`View.OnClickListener`类型的类，并覆盖`onClick`函数作为参数，就像我们之前的其他匿名类一样。与我们之前的类一样，代码是被推断的，我们有简短、简洁的代码，其中我们的代码没有被太多的细节所淹没。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This method is preferable in this situation because there is only one button.
    If we had lots of buttons, then having `MainActivity` implement `View.OnClickListener`
    and then overriding `onClick` to handle all clicks in one function would probably
    be preferable, as we have done previously.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这种方法是可取的，因为只有一个按钮。如果我们有很多按钮，那么让`MainActivity`实现`View.OnClickListener`，然后覆盖`onClick`以处理所有点击的函数可能更可取，就像我们之前做过的那样。
- en: In the `onClick` function, we use the `text` property's setter to set the `text`
    property on `textView`, and then the getter of the `text` property of the `editText`
    instance to get whatever text (if any) the user has entered in the `EditText`
    widget.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClick`函数中，我们使用`text`属性的setter来设置`textView`上的`text`属性，然后使用`editText`实例的`text`属性的getter来获取用户在`EditText`小部件中输入的任何文本（如果有的话）。
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中的上一个代码块之后添加以下代码：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we will handle the Switch widget.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理Switch小部件。
- en: Coding the Switch widget
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Switch小部件的代码
- en: Next, we create yet another anonymous class to listen for and handle changes
    to our `Switch` widget.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个匿名类来监听和处理我们的`Switch`小部件的更改。
- en: When the `isChecked` variable is `true`, we show the `TextView` widget, and
    when it is false, we hide it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isChecked`变量为`true`时，我们显示`TextView`小部件，当它为false时，我们隐藏它。
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中的上一个代码块之后添加以下代码：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we can run our app and try out all the features.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的应用程序并尝试所有功能。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Android emulators can be rotated into landscape mode by pressing the *Ctrl*
    +*F11* keyboard combination on Windows, or *Ctrl* +*fn*+*F11* on a macOS.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可以通过按*Ctrl* +*F11*键组合或在macOS上按*Ctrl* +*fn*+*F11*将Android模拟器旋转为横向模式。
- en: Running the Widget Exploration app
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Widget Exploration应用程序
- en: 'Try checking the radio buttons to see the time zone change on the clock. In
    the following image, I have photoshopped a few cropped screenshots to show that
    the time changes when a new time zone is selected:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试选中单选按钮，看看时区在时钟上的变化。在下面的图片中，我用Photoshop剪裁了一些截图，以显示选择新时区时时间的变化：
- en: '![Running the Widget Exploration app](img/B12806_13_12.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![运行Widget Exploration应用程序](img/B12806_13_12.jpg)'
- en: Enter different values into the `EditText` widget, and then click the button
    to see it grab the text and display it on itself, as demonstrated in the screenshot
    at the start of this tutorial.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EditText`小部件中输入不同的值，然后单击按钮，以查看它获取文本并在自身上显示它，就像本教程开头的截图中演示的那样。
- en: 'Change what the image in the app looks like with different combinations of
    checked and unchecked checkboxes and hide and show the `TextView` widget by using
    the `Switch` widget above it. The following screenshot displays two combinations
    of the checkboxes and the switch widget photoshopped together for demonstration
    purposes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用上面的`Switch`小部件，通过不同的复选框的选中和未选中的组合以及显示和隐藏`TextView`小部件来改变应用程序中的图像。以下截图显示了两种复选框和开关小部件的组合，用于演示目的：
- en: '![Running the Widget Exploration app](img/B12806_13_13.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![运行Widget Exploration应用程序](img/B12806_13_13.jpg)'
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Transparency doesn't show very clearly in a print book, so I didn't check that
    box. Be sure to try this out on an emulator or real device.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度在印刷书中并不是很清晰，所以我没有勾选那个框。一定要在模拟器或真实设备上试一下。
- en: Converting layouts to ConstraintLayout
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将布局转换为ConstraintLayout
- en: 'Finally, as promised, this is how we can convert the layout to the faster-running
    `ConstraintLayout`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如承诺的那样，这就是我们如何将布局转换为运行更快的`ConstraintLayout`：
- en: Switch back to the **Design** tab
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回**设计**选项卡
- en: Right-click on the parent layout – in this case, `LinearLayout` – and select
    **Convert LinearLayout to ConstraintLayout**, as shown in the following screenshot:![Converting
    layouts to ConstraintLayout](img/B12806_13_14.jpg)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击父布局 - 在这种情况下是`LinearLayout` - 并选择**将LinearLayout转换为ConstraintLayout**，如下面的截图所示：![将布局转换为ConstraintLayout](img/B12806_13_14.jpg)
- en: Now you can convert any old `RelativeLayout` layouts to the newer and faster
    `ConstraintLayout` widget, as well as build your own `RelativeLayout`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将任何旧的`RelativeLayout`布局转换为更新更快的`ConstraintLayout`小部件，同时构建你自己的`RelativeLayout`。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have learned a lot in this chapter. As well as exploring a plethora of widgets,
    we learned how to implement widgets in Kotlin code without any XML, we used our
    first anonymous classes using short, snappy code in the form of a lambda to handle
    clicks on a selection of widgets, and we put all our new widget prowess into a
    working app.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多。除了探索了大量的小部件，我们还学会了如何在Kotlin代码中实现小部件而不需要任何XML，我们使用了我们的第一个匿名类，使用简短、简洁的代码形式的lambda来处理小部件的点击，我们将所有新的小部件技能都应用到了一个工作中的应用程序中。
- en: Now let's move on to look at another way that we can significantly enhance our
    UI.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续看另一种显著增强我们UI的方法。
- en: In the next chapter, we will see a completely new UI element that we can't just
    drag and drop from the palette, but we will still have plenty of help from the
    Android API. We will learn about **dialog windows**. We will also make a start
    on our most significant app to date called Note to self. It is a memo, to-do,
    and personal note app.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一个全新的UI元素，我们不能只从调色板中拖放，但我们仍然会得到来自Android API的大量帮助。我们将学习有关**对话框窗口**的知识。我们还将开始制作迄今为止最重要的应用程序，名为Note
    to self。这是一个备忘录、待办事项和个人笔记应用程序。
