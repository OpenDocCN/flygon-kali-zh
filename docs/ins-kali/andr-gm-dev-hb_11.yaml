- en: Chapter 11. Android Game Development Using C++ and OpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。使用C ++和OpenGL进行Android游戏开发
- en: We have already seen the differences between an Android application and an Android
    game. The Android SDK is very capable of taking care of both. Certainly, the question
    that arises is "What is the requirement of a separate development toolset in native
    languages such as C and C++?" Compared to Java, C and C++ are much more difficult
    to manage and write code in. The answer lies in the question itself. The Java
    architecture runs on JVM, which is associated with the Android operating system.
    This creates an extra latency, which has a performance lag. The scale of the lag
    depends on the scale of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Android应用程序和Android游戏之间的区别。 Android SDK非常擅长处理这两者。当然，引起的问题是“在本地语言（如C和C
    ++）中需要单独的开发工具集是什么要求？”与Java相比，C和C ++更难管理和编写代码。答案就在问题本身。 Java架构在JVM上运行，与Android操作系统相关联。这会产生额外的延迟，导致性能滞后。滞后的规模取决于应用程序的规模。
- en: A highly CPU-intensive application may cause a significant amount of visible
    lag in Java architecture. Native language code can be processed faster. Moreover,
    native code can be varied depending on the CPU/platform architecture, which is
    not possible in the case of the Java architecture used by the Android SDK.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 高度CPU密集型的应用程序可能会在Java架构中导致大量可见的延迟。本地语言代码可以更快地处理。此外，本地代码可以根据CPU /平台架构的不同而变化，而在Android
    SDK使用的Java架构中是不可能的。
- en: Android uses the OpenGL rendering system. So, an application made in OpenGL
    can also choose Android as the target platform. Native code helps directly structure
    the application using OpenGL.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用OpenGL渲染系统。因此，使用OpenGL制作的应用程序也可以选择Android作为目标平台。本地代码有助于直接使用OpenGL构建应用程序。
- en: 'We will have a detailed look at these aspects in this chapter through the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主题在本章中详细了解这些方面：
- en: Introduction to the 3Android NDK
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍3Android NDK
- en: C++ for games—pros and cons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的C ++-优缺点
- en: Native code performance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地代码性能
- en: Introduction to OpenGL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL简介
- en: Rendering using OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL进行渲染
- en: Different CPU architecture support
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的CPU架构支持
- en: Introduction to the Android NDK
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android NDK简介
- en: Android is actually based on the Java architecture. However, part of an Android
    application can be developed using native languages such as C and C++. This is
    where the Android NDK comes into the picture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android实际上是基于Java架构的。但是，Android应用程序的一部分可以使用C和C ++等本地语言开发。这就是Android NDK出现的地方。
- en: The Android NDK is a toolset used to develop a module of an application that
    will interact with hardware much faster. It is a well-known fact that C and C++
    have the ability to interact with a native component directly, which reduces the
    latency between the application and hardware.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK是一个工具集，用于开发将与硬件交互得更快的应用程序模块。众所周知，C和C ++能够直接与本地组件交互，从而减少应用程序和硬件之间的延迟。
- en: How the NDK works
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NDK的工作原理
- en: An Android native code segment interacts with main application through the **Java
    Native Interface** (**JNI**). The Android NDK comes with a build script that converts
    native code into binary and includes it in the main Android application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Android本地代码段通过**Java本机接口**（**JNI**）与主应用程序进行交互。 Android NDK附带一个构建脚本，将本地代码转换为二进制代码并将其包含在主Android应用程序中。
- en: This binary is basically a native code library that can be used in any Android
    application as per requirement. An NDK build script creates `.so` files and adds
    them to the application path.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该二进制代码基本上是一个本地代码库，可以根据需要在任何Android应用程序中使用。 NDK构建脚本创建`.so`文件并将其添加到应用程序路径中。
- en: 'The Android build process creates Dalvik Executable files (`.dex`) to run on
    the Dalvik Virtual Machine (or ART) of the Android OS. The Java executable recognizes
    the native library and loads the implemented methods. The native methods are declared
    with the `native` keyword:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android构建过程创建Dalvik可执行文件（`.dex`）以在Android OS的Dalvik虚拟机（或ART）上运行。 Java可执行文件识别本地库并加载已实现的方法。本地方法使用`native`关键字声明：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The method always has public access, because the native library is always treated
    as an external source. Here, the developer should always keep in mind that there
    should never be multiple definitions of a method for the same declaration collectively
    for all the included native libraries. This will always create a compilation error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法始终具有公共访问权限，因为本地库始终被视为外部来源。在这里，开发人员应始终牢记，对于所有包含的本地库的同一声明，永远不应该有多个方法的定义。这将始终创建编译错误。
- en: 'The native building process can build the native project into two types of
    libraries:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本地构建过程可以将本地项目构建为两种类型的库：
- en: Native shared library
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地共享库
- en: Native static library
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地静态库
- en: Native shared library
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地共享库
- en: The native build script creates `.so` files from C++ files, which is termed
    as the native shared library. However, it is not always shared between applications
    in the true sense. An Android application is a Java application, but a native
    application can be triggered through a native shared library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本地构建脚本从C ++文件创建`.so`文件，称为本地共享库。但是，它并不总是在真正意义上在应用程序之间共享。 Android应用程序是一个Java应用程序，但是本地应用程序可以通过本地共享库触发。
- en: For game development, if the game is written in a native language, then the
    game code is included in the shared library.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏开发，如果游戏是用本地语言编写的，则游戏代码将包含在共享库中。
- en: Native static library
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地静态库
- en: Native static libraries are basically collections of compiled objects and represented
    by `.a` files. These libraries are included in other libraries. A compiler can
    remove unused code during compilation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本地静态库基本上是已编译对象的集合，并由`.a`文件表示。这些库包含在其他库中。编译器可以在编译过程中删除未使用的代码。
- en: Build dependency
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建依赖
- en: 'Android SDK is capable of building and packaging an Android application project
    into an APK file with the support of Java. However, the NDK is not sufficient
    to build and package APK files. Here are the dependencies for creating an Android
    application APK other than the NDK:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK能够使用Java构建和打包Android应用程序项目为APK文件。然而，NDK不足以构建和打包APK文件。除了NDK之外，创建Android应用程序APK的依赖如下：
- en: Android SDK
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android SDK
- en: C++ compiler
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编译器
- en: Python
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Gradle
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle
- en: Cygwin
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cygwin
- en: Java
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: Android SDK
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android SDK
- en: Android applications are basically Java applications. Hence, it is absolute
    necessary to have Android SDK in order to create an Android application package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序基本上是Java应用程序。因此，有必要拥有Android SDK来创建Android应用程序包。
- en: C++ compiler
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++编译器
- en: A native Android application is written in C++, so a C++ compiler is required
    to compile the code base on the development platform. C++ compilers are platform
    dependent, so it may not be the same C++ compiler on each platform.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本机Android应用程序是用C++编写的，因此需要C++编译器在开发平台上编译代码库。C++编译器是平台相关的，因此可能不是每个平台上都是相同的C++编译器。
- en: For example, on a Windows machine, the C++11 compiler is used currently in the
    development industry, whereas the GC++ compiler is used on Linux machines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Windows机器上，目前在开发行业中使用C++11编译器，而在Linux机器上使用GC++编译器。
- en: These may create different code bases for the actual development project in
    terms of syntax and API calls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会在语法和API调用方面为实际开发项目创建不同的代码库。
- en: Python
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: Python is a separate development language. It can be used to create applications
    for Android and can support multiple platforms by converting the source into native
    language. In the case of Android NDK development, Python is used for the conversion
    of C++ code to native binary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种独立的开发语言。它可以用于创建Android应用程序，并通过将源代码转换为本机语言来支持多个平台。在Android NDK开发的情况下，Python用于将C++代码转换为本机二进制。
- en: Gradle
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gradle
- en: Gradle is used by the build script and the Android native build tool to convert
    native code to a shared library. It also provides a virtual Unix environment to
    make application packages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle被构建脚本和Android本机构建工具使用，将本机代码转换为共享库。它还提供了一个虚拟的Unix环境来制作应用程序包。
- en: Cygwin
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cygwin
- en: Android requires a Unix environment to build an NDK application project. The
    Windows system does not have a Unix environment. Cygwin is required to provide
    a virtual Unix environment to support the building platform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Android需要一个Unix环境来构建NDK应用程序项目。Windows系统没有Unix环境。需要Cygwin来提供虚拟的Unix环境来支持构建平台。
- en: Java
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: Last but not least is the requirement of Java to create an Android application
    package. However, Java is always required for any type of Android development.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是需要Java来创建Android应用程序包。然而，对于任何类型的Android开发，都需要Java。
- en: Native project build configuration
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本机项目构建配置
- en: 'An Android project needs the following configurations in order to create an
    application package from native source code. A native project build depends on
    the configuration defined in these two files:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从本机源代码创建应用程序包，Android项目需要以下配置。本机项目构建取决于这两个文件中定义的配置：
- en: '`Android.mk`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android.mk`'
- en: '`Application.mk`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.mk`'
- en: Android.mk configuration
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android.mk配置
- en: '**Location**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置**'
- en: The `Android.mk` file can be located at `<Application Project Path>/jni/`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`文件可以在`<应用程序项目路径>/jni/`中找到。'
- en: '**Configuration options**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置选项**：'
- en: 'The `Android.mk` file contains the following options to create an application
    package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`文件包含以下选项来创建应用程序包：'
- en: '`CLEAR_VARS`: This clears the local and user-defined variables. This option
    is invoked by the `include $(CLEAR_VARS)` syntax.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLEAR_VARS`：这清除本地和用户定义的变量。这个选项由`include $(CLEAR_VARS)`语法调用。'
- en: '`BUILD_SHARED_LIBRARY`: This includes all local files, defined in `LOCAL_MODULE`
    and `LOCAL_SRC_FILES`, in a shared library. It is invoked by the `include $(BUILD_SHARED_LIBRARY)`
    syntax.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_SHARED_LIBRARY`：这包括所有本地文件，在`LOCAL_MODULE`和`LOCAL_SRC_FILES`中定义，以共享库的形式。它由`include
    $(BUILD_SHARED_LIBRARY)`语法调用。'
- en: '`BUILD_STATIC_LIBRARY`: This specifies static libraries to create `.a` files
    used by the shared libraries. It is invoked by the `include $(BUILD_STATIC_LIBRARY)`
    syntax.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_STATIC_LIBRARY`：这指定静态库以创建由共享库使用的`.a`文件。它由`include $(BUILD_STATIC_LIBRARY)`语法调用。'
- en: '`PREBUILT_SHARED_LIBRARY`: This indicates a prebuilt shared library at a specific
    path to build a dependent shared library from local includes. It is invoked by
    the `include $(PREBUILT_SHARED_LIBRARY)` syntax.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_SHARED_LIBRARY`：这表示特定路径上的预构建共享库，用于从本地包含构建依赖的共享库。它由`include $(PREBUILT_SHARED_LIBRARY)`语法调用。'
- en: '`PREBUILT_STATIC_LIBRARY`: This indicates a prebuild static library at a specific
    path to build a dependent shared library from local includes. It is invoked by
    the `include $(PREBUILT_STATIC_LIBRARY)` syntax.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_STATIC_LIBRARY`：这表示特定路径上的预构建静态库，用于从本地包含构建依赖的共享库。它由`include $(PREBUILT_STATIC_LIBRARY)`语法调用。'
- en: '`TARGET_ARCH`: This indicates the basic type of processor architecture family
    such as ARM, x86, and so on.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_ARCH`：这表示基本处理器架构系列，如ARM、x86等。'
- en: '`TARGET_PLATFORM`: This defines the target Android platform. The mentioned
    platform must be installed in the development system through the Android SDK manager.
    It indicates the Android API level in order to create the application package.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_PLATFORM`：这定义目标Android平台。所述平台必须通过Android SDK管理器安装在开发系统中。它指示Android
    API级别以创建应用程序包。'
- en: '`TARGET_ARCH_ABI`: This indicates the specific ABI for target processor architecture,
    such as armeabi, armeabi-v7, x86, and so on.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGET_ARCH_ABI`：这表示目标处理器架构的特定ABI，如armeabi、armeabi-v7、x86等。'
- en: '`LOCAL_PATH`: This points to the current file directory. This variable does
    not get cleared by the `CLEAR_VARS` command. It is invoked by the `LOCAL_PATH
    := $ (call my-dir)` syntax.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PATH`：这指向当前文件目录。这个变量不会被`CLEAR_VARS`命令清除。它由`LOCAL_PATH := $ (call my-dir)`语法调用。'
- en: '`LOCAL_MODULE`: This indicates all the unique local module names. It is invoked
    by the `LOCAL_MODULE := "<module name>"` syntax.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`：这表示所有唯一的本地模块名称。它由`LOCAL_MODULE := "<模块名称>"`语法调用。'
- en: '`LOCAL_MODULE_FILENAME`: This indicates the library name that contains the
    defined `LOCAL_MODULE`. It is invoked by the `LOCAL_MODULE_FILENAME := "<module
    library file name>"` syntax.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE_FILENAME`：这表示包含已定义`LOCAL_MODULE`的库名称。它由`LOCAL_MODULE_FILENAME
    := "<模块库文件名>"`语法调用。'
- en: '`LOCAL_SRC_FILES`: This indicates all the native source code file paths to
    be compiled into a shared library. It is invoked by the `LOCAL_SRC_FILES := <Local
    source file path>` syntax.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`：这表示要编译为共享库的所有本地源代码文件路径。它由`LOCAL_SRC_FILES := <本地源文件路径>`语法调用。'
- en: There are other optional configurations that can be set in this file, such as
    `LOCAL_C_INCLUDES`, `LOCAL_CFLAGS`, `LOCAL_CPP_EXTENSION`, `LOCAL_CPP_FEATURES`,
    `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES`, and `LOCAL_EXPORT_CFLAGS`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可选配置可以在此文件中设置，例如`LOCAL_C_INCLUDES`、`LOCAL_CFLAGS`、`LOCAL_CPP_EXTENSION`、`LOCAL_CPP_FEATURES`、`LOCAL_SHARED_LIBRARIES`、`LOCAL_STATIC_LIBRARIES`和`LOCAL_EXPORT_CFLAGS`。
- en: Application.mk configuration
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Application.mk配置
- en: '**Location**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置**'
- en: The `Application.mk` file can be located at `<Application Project Path>/jni/`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`文件可以位于`<应用程序项目路径>/jni/`。'
- en: '**Configuration options**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置选项**'
- en: 'The `Application.mk` file contains the following options to create an application
    package:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`文件包含以下选项以创建应用程序包：'
- en: '`APP_PROJECT_PATH`: This is the absolute path to the project root directory.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PROJECT_PATH`：这是项目根目录的绝对路径。'
- en: '`APP_OPTIM`: This indicates the optional setting to create the build package
    as release or debug.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_OPTIM`：这表示可选设置，用于将构建包创建为发布版或调试版。'
- en: '`APP_CFLAGS`: This defines a set of C-compiler flags for the build instead
    of changing in the `Android.mk` file.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_CFLAGS`：这定义了一组C编译器标志，用于构建而不是在`Android.mk`文件中更改。'
- en: '`APP_CPPFLAGS`: This defines a set of C++-compiler flags for the build instead
    of changing in the `Android.mk` file.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_CPPFLAGS`：这定义了一组C++编译器标志，用于构建而不是在`Android.mk`文件中更改。'
- en: '`APP_BUILD_SCRIPT`: This is an optional setting to specify a build script other
    than the default `jni/Android.mk` script.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_BUILD_SCRIPT`：这是一个可选设置，用于指定除默认的`jni/Android.mk`脚本之外的构建脚本。'
- en: '`APP_ABI`: This option specifies the set of ABIs to be optimized for the Android
    application package. Here is the complete list and keywords for each ABI support:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_ABI`：此选项指定要为Android应用程序包进行优化的ABI集。以下是每个ABI支持的完整列表和关键字：'
- en: 'ARMv5: `armeabi`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv5：`armeabi`
- en: 'ARMv7: `armeabi-v7a`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv7：`armeabi-v7a`
- en: 'ARMv8: `arm64-v8a`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv8：`arm64-v8a`
- en: 'Intel 32-bit: `x86`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel 32位：`x86`
- en: 'Intel 64-bit: `x86_64`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel 64位：`x86_64`
- en: 'MIPS 32-bit: `mips`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS 32位：`mips`
- en: 'MIPS 64-bit: `mips64`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS 64位：`mips64`
- en: 'ALL-SET: `all`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALL-SET：`all`
- en: '`APP_PLATFORM`: This option specifies the target Android platform.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PLATFORM`：此选项指定目标Android平台。'
- en: '`NDK_TOOLCHAIN_VERSION`: This option specifies the version of the GCC compiler.
    By default, versions 4.9 and 4.8 are used for compilation in 64 bit and 32 bit,
    respectively.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NDK_TOOLCHAIN_VERSION`：此选项指定GCC编译器的版本。默认情况下，64位和32位分别使用版本4.9和4.8进行编译。'
- en: '`APP_STL`: This is an optional configuration to link alternative C++ implementations.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_STL`：这是一个可选的配置，用于链接替代C++实现。'
- en: '`APP_LDFLAGS`: In the case of building a shared library and executables, this
    option is used to link flags to the build system to link the application.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_LDFLAGS`：在构建共享库和可执行文件的情况下，此选项用于将链接标志链接到构建系统以链接应用程序。'
- en: C++ for games – pros and cons
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于游戏的C++-优点和缺点
- en: There is a never-ending debate between C++ and Java. However, we will not go
    into the controversy and will try to look at them from the perspective of game
    development. C++ has a slight performance edge over Java, and Java is known for
    its simplicity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++和Java之间有一个永无止境的争论。然而，我们不会讨论争议，而是试图从游戏开发的角度来看待它们。C++在性能上略优于Java，而Java以其简单性而闻名。
- en: There may be many programmers who are more comfortable in C++ than Java, or
    vice versa. In game development, personal choice of programming language does
    not matter. Hence, using NDK or SDK has to be determined depending on the requirements.
    It is always recommended that you use the Android SDK to develop an application
    rather than using the NDK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有许多程序员更喜欢C++而不是Java，或者反之亦然。在游戏开发中，编程语言的个人选择并不重要。因此，使用NDK或SDK必须根据需求来确定。建议您始终使用Android
    SDK来开发应用程序，而不是使用NDK。
- en: Let's discuss the advantages and disadvantages of using native language for
    game programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用本地语言进行游戏编程的优缺点。
- en: Advantages of using C++
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用C++的优势
- en: 'Let''s first have a look at the positive side of using C++ for game programming
    through the following points:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从以下几点来看看使用C++进行游戏编程的积极方面：
- en: Universal game programming language
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用游戏编程语言
- en: Cross platform portability
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台可移植性
- en: Faster execution
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的执行
- en: CPU architecture support
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU架构支持
- en: Universal game programming language
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用游戏编程语言
- en: In the case of game development, C++ is widely used for many platforms, especially
    for consoles and PC game development. This is the reason many game engines opted
    for C++ as the primary programming language.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的情况下，C++被广泛用于许多平台，特别是用于主机和PC游戏开发。这就是为什么许多游戏引擎选择C++作为主要编程语言的原因。
- en: Sometimes, it is difficult to learn many programming languages to work on different
    platforms with different architecture. C++ provides a most common solution to
    this problem, as most of the programmers are familiar with C++ library and API
    use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，学习许多编程语言以在不同架构的不同平台上工作是困难的。C++提供了这个问题的最常见解决方案，因为大多数程序员都熟悉C++库和API的使用。
- en: Cross-platform portability
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨平台可移植性
- en: The same C++ code is compiled into a library targeting a specific operating
    platform. Thus, the same project can be compiled for different platforms. Hence,
    it is super easy to port a game to various platforms if it is written in C++.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的C++代码被编译为针对特定操作平台的库。因此，同一个项目可以编译为不同的平台。因此，如果游戏是用C++编写的，那么将游戏移植到各种平台就会变得非常容易。
- en: For example, the famous and effective cross-platform game engine Cocos2d-x uses
    C++ as the development language. Hence, the same game is easily ported for many
    platforms such as Android, iOS, Mac OS, and Windows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，著名而有效的跨平台游戏引擎Cocos2d-x使用C++作为开发语言。因此，相同的游戏可以轻松移植到许多平台，如Android、iOS、Mac OS和Windows。
- en: Faster execution
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快的执行
- en: C++ is well capable of interacting with platform hardware, and writing games
    in C++ helps boost their performance. However, in the case of Android, the performance
    boost is hardly noticeable if the game is not CPU intensive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++能够很好地与平台硬件交互，并且使用C++编写游戏有助于提高性能。然而，在Android的情况下，如果游戏不是CPU密集型，性能提升几乎是不可察觉的。
- en: CPU architecture support
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU架构支持
- en: C++ code can be compiled for specific target CPU architectures such as x86,
    ARM, Neon, or MIPS. This specification indicates better performance on that particular
    processor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码可以针对特定的目标CPU架构进行编译，如x86、ARM、Neon或MIPS。这种规范表明在特定处理器上有更好的性能。
- en: Compiler configuration for CPU architecture in Android NDK ensures the best
    possible result in each platform. However, it is not always necessary to define
    each and every platform to avoid extra compilation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android NDK中为CPU架构配置编译器确保在每个平台上获得最佳结果。然而，并不总是需要为避免额外的编译而定义每个平台。
- en: Disadvantages of using C++
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用C++的缺点
- en: 'Now, let''s discuss the other side of the coin through these points:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下几点来讨论问题的另一面：
- en: High program complexity
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高程序复杂性
- en: Platform-dependent compiler
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖平台的编译器
- en: Manual memory management
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动内存管理
- en: High program complexity
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高程序复杂性
- en: C++ comes with extra program complexity. In the case of Java programming, JVM
    takes care of memory completely and follows the OOP concept. C++ lags in providing
    this feature. Thus, it becomes extra overhead for the developer to take care of
    every programming aspect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C++带来了额外的程序复杂性。在Java编程的情况下，JVM完全负责内存管理，并遵循面向对象的概念。C++在提供这一特性方面存在不足。因此，开发人员需要额外的工作来处理每个编程方面。
- en: C++ itself has a complex architecture compared to Java. The chances of facing
    exceptions and errors increases if C++ is used.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相比，C++本身的架构更加复杂。如果使用C++，面临异常和错误的机会会增加。
- en: Platform-dependent compiler
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖平台的编译器
- en: Going cross platform is easy when using C++. However, configuring the build
    script can be a pain in most of the cases. It is a very common scenario that the
    same game fails to run on a ported platform due to the wrong configuration. Moreover,
    it becomes difficult to find out the issue as the game is successfully running
    on some other platform.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++进行跨平台开发很容易。然而，在大多数情况下，配置构建脚本可能会很麻烦。同样的游戏由于错误的配置而无法在移植的平台上运行是非常常见的情况。此外，由于游戏在其他平台上成功运行，因此很难找出问题所在。
- en: Most of the time, different platforms use different C++ compilers. So, it requires
    an extra effort to identify platform-specific code and find out an alternative
    for each platform, if required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数情况下，不同的平台使用不同的C++编译器。因此，需要额外的努力来识别特定于平台的代码，并在必要时为每个平台找到替代方案。 '
- en: Manual memory management
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动内存管理
- en: Java does not require memory management to be implemented by the developer,
    and the memory is efficiently managed by JVM (DVM in the case of Android). So,
    there is no chance of facing memory leakage or fragmentation. JVM runs the garbage
    collector to free the unused memory automatically. However, garbage collector
    invocation costs a bit of performance, and frequent garbage collector calls can
    cause a severe drop in performance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java不需要开发人员实现内存管理，内存由JVM（在Android的情况下是DVM）高效管理。因此，不会出现内存泄漏或碎片化的情况。JVM会运行垃圾收集器来自动释放未使用的内存。然而，垃圾收集器的调用会消耗一些性能，频繁的垃圾收集器调用可能会导致严重的性能下降。
- en: The developer should use optimum memory, because the garbage collector cannot
    identify unused memory block if there is any active reference in the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该使用最佳内存，因为如果代码中有任何活动引用，垃圾收集器无法识别未使用的内存块。
- en: Conclusion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: C++ has its own advantages. However, when it comes to game programming for Android,
    it does not help much in the technical sense. So, if we compare the amount of
    effort and risk taken by opting for C++ than coding in Java for Android, Java
    should always be preferred for Android. DVM runs Java code efficiently enough
    to achieve reasonable performance on Android devices. Moreover, the Android NDK
    library is not actually designed to develop a standalone Android application.
    Even though it has native activity support, which acts as a middle layer between
    DVM and native application written in C++, it does not help much.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: C++有其自身的优势。然而，当涉及到为Android进行游戏编程时，在技术上并没有太大帮助。因此，如果我们比较选择C++和在Android上使用Java编码所需的工作量和风险，Java应该始终优先考虑。DVM能够有效地运行Java代码，以在Android设备上实现合理的性能。此外，Android
    NDK库实际上并不是为开发独立的Android应用程序而设计的。尽管它具有本地活动支持，作为DVM和用C++编写的本地应用程序之间的中间层，但并没有太大帮助。
- en: If the developer chooses not to go for cross platform and keeps the game scope
    within Android only, then it is recommended that you use Android SDK rather Android
    NDK. It will decrease the development hustle and complexity with a negligible
    amount of performance loss.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发人员选择不跨平台，并将游戏范围限制在Android上，那么建议您使用Android SDK而不是Android NDK。这将减少开发的麻烦和复杂性，同时性能损失可以忽略不计。
- en: Native code performance
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地代码性能
- en: As we already know, native code can run faster with better processing speed.
    This can be further optimized for a specific CPU architecture. The main reason
    behind this performance boost is the use of pointers in memory operations. However,
    it depends on the developer and the coding style.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，本地代码可以以更快的处理速度运行。这可以进一步针对特定的CPU架构进行优化。这种性能提升的主要原因是在内存操作中使用指针。但是，这取决于开发人员和编码风格。
- en: Let's look at a simple example where we can have a better understanding of performance
    gain in native language.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，我们可以更好地理解本地语言中的性能增益。
- en: 'Consider this Java code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段Java代码：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the address of 1000 fields in the array is handled by JVM (DVM
    in the case of an Android Dalvik system). So, the interpreter parses to the *i^(th)*
    position and performs an assignment operation each time, which takes a lot of
    time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数组中1000个字段的地址由JVM（在Android Dalvik系统中为DVM）处理。因此，解释器每次解析到第*i*个位置并执行赋值操作，这需要很长时间。
- en: 'Now, let''s implement the same functionality using native C/C++ language and
    use pointers:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用本地C/C++语言实现相同的功能并使用指针：
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the interpreter does not need to parse to the target memory
    location. The address of the location is pointed out by `ptrArray`. Hence, the
    value can be directly assigned to the memory location.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，解释器不需要解析到目标内存位置。`ptrArray`指出了位置的地址。因此，值可以直接赋给内存位置。
- en: Especially for multi-dimensional arrays, a significant performance gain can
    be observed in the case of properly written native code for the same functionality.
    Other important use of native code is binary data processing and image processing,
    where a huge amount of data is processed at a time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于多维数组，在正确编写的本地代码中可以观察到显著的性能增益，用于相同功能。本地代码的另一个重要用途是二进制数据处理和图像处理，在这些情况下，大量数据一次性处理。
- en: Rendering using OpenGL
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL进行渲染
- en: Android uses OpenGL for rendering. Android SDK libraries include the OpenGL
    libraries, specially optimized for Android. Android started supporting OpenGL
    from API level 4 and then increased its support as the level increased. Currently,
    the maximum supported version of OpenGL is OpenGL ES 3.1 from API level 21.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用OpenGL进行渲染。Android SDK库包括专门针对Android进行优化的OpenGL库。Android从API级别4开始支持OpenGL，然后随着级别的增加而增加其支持。目前，OpenGL的最大支持版本是从API级别21开始的OpenGL
    ES 3.1。
- en: OpenGL versions
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenGL版本
- en: 'Different OpenGL versions have a different set of features. Versions 1.0 and
    2.0 have a lot of differences in terms of coding style, API convenience, functionality,
    and feature support. Let''s discuss the following OpenGL ES versions that are
    significant to Android development:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的OpenGL版本具有不同的功能集。版本1.0和2.0在编码风格、API便利性、功能和特性支持方面有很多不同之处。让我们讨论一下对Android开发具有重要意义的以下OpenGL
    ES版本：
- en: OpenGL ES 1.x
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 1.x
- en: OpenGL ES 2.0
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 2.0
- en: OpenGL ES 3.0
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0
- en: OpenGL ES 3.1
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.1
- en: OpenGL 1.x
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenGL 1.x
- en: OpenGL version 1.x has been supported from Android API level 4 with a shared
    OpenGL ES 1.x library, `libGLESv1.so`. The headers `gl.h` and `glext.h` contain
    all the necessary APIs for OpenGL functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android API级别4开始支持OpenGL版本1.x，使用共享的OpenGL ES 1.x库`libGLESv1.so`。头文件`gl.h`和`glext.h`包含了OpenGL功能所需的所有必要API。
- en: OpenGL 2.0
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenGL 2.0
- en: 'In the current industry, a developer prefers to use OpenGL ES 2.0 for games,
    because almost every device supports this OpenGL version, and it provides vertex
    and fragment shaders useful for games. OpenGL ES 2.0 can be used in Android native
    development projects by including the `libGLESv2.so` shared library in the project,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前行业中，开发人员更倾向于在游戏中使用OpenGL ES 2.0，因为几乎每台设备都支持这个OpenGL版本，并且它提供了对游戏有用的顶点和片段着色器。OpenGL
    ES 2.0可以通过在项目中包含`libGLESv2.so`共享库来用于Android本地开发项目，如下所示：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The headers are `gl2.h` and `gl2ext.h`. OpenGL ES 2.0 is supported from Android
    API level 5.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是`gl2.h`和`gl2ext.h`。OpenGL ES 2.0从Android API级别5开始支持。
- en: OpenGL 3.0
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenGL 3.0
- en: 'From Android API level 21, OpenGL ES 3.0 is supported. The developer can include
    `libGLESv3.so` to use OpenGL 3.1, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android API级别21开始，支持OpenGL ES 3.0。开发人员可以包含`libGLESv3.so`来使用OpenGL 3.1，如下所示：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The headers are `gl3.h` and `gl3ext.h`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是`gl3.h`和`gl3ext.h`。
- en: OpenGL 3.1
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenGL 3.1
- en: 'From Android API level 21, OpenGL ES 3.1 is supported. The developer can include
    `libGLESv3.so` to use OpenGL 3.1, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android API级别21开始，支持OpenGL ES 3.1。开发人员可以包含`libGLESv3.so`来使用OpenGL 3.1，如下所示：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The headers are `gl31.h` and `gl3ext.h`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是`gl31.h`和`gl3ext.h`。
- en: OpenGL ES 3.0 and OpenGL ES 3.1 are not supported by many Android devices. If
    a developer intends to use them, then there should be an OpenGL version check
    before using the version. Also, proper version of OpenGL ES must be used to run
    the game on that particular device. The latest Android N has support for OpenGL
    ES 3.2.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Android设备不支持OpenGL ES 3.0和OpenGL ES 3.1。如果开发人员打算使用它们，则在使用版本之前应该进行OpenGL版本检查。此外，必须使用适当的OpenGL
    ES版本在特定设备上运行游戏。最新的Android N支持OpenGL ES 3.2。
- en: Detecting and setting the OpenGL version
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测和设置OpenGL版本
- en: 'This piece of Android Java code can be used to implement proper OpenGL ES support
    for an Android game:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Android Java代码可以用来为Android游戏实现适当的OpenGL ES支持：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Texture compression and OpenGL
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理压缩和OpenGL
- en: 'Texture compression has a significant effect on the rendering process handled
    by OpenGL. It can increase or decrease performance for different types of texture
    compression. Let''s have a quick look at some of the important texture compression
    formats:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理压缩对由OpenGL处理的渲染过程有重要影响。它可以增加或减少不同类型的纹理压缩的性能。让我们快速看一下一些重要的纹理压缩格式：
- en: ATC
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ATC
- en: PVRTC
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PVRTC
- en: DXTC
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DXTC
- en: ATC
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ATC
- en: ATI texture compression is often called ATITC. This compression supports RGB
    with and without an alpha channel. This is the most common and widely used compression
    technique for Android.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ATI纹理压缩通常称为ATITC。该压缩支持RGB和带或不带alpha通道。这是Android最常见和广泛使用的压缩技术。
- en: PVRTC
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PVRTC
- en: Power VR texture compression uses 2-bit and 4-bit pixel compression with or
    without an alpha channel. This is used by many game developers across the globe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Power VR纹理压缩使用2位和4位像素压缩，带有或不带有alpha通道。这被全球许多游戏开发人员使用。
- en: DXTC
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DXTC
- en: DXTC is also called S3 texture compression, which is also used for OpenGL. This
    uses a 4-bit or 8-bit ARGB channel.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DXTC也被称为S3纹理压缩，也用于OpenGL。这使用4位或8位ARGB通道。
- en: OpenGL manifest configuration
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenGL清单配置
- en: Android requires the version definition of OpenGL used in the application, along
    with other required options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Android需要应用程序中使用的OpenGL版本定义，以及其他所需选项。
- en: 'Here is the version declaration syntax for OpenGL ES:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是OpenGL ES的版本声明语法：
- en: '[PRE7]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are the target version options:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是目标版本选项：
- en: '`0x00010000` for version 1.0'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00010000`代表版本1.0'
- en: '`0x00010001` for version 1.1'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00010001`代表版本1.1'
- en: '`0x00020000` for version 2.0'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00020000`代表版本2.0'
- en: '`0x00030000` for version 3.0'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00030000`代表版本3.0'
- en: '`0x00030001` for version 3.1'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00030001`代表版本3.1'
- en: '`0x00030002` for version 3.2'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x00030002`代表版本3.2'
- en: 'Here is the optional setting for texture compression declaration:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是纹理压缩声明的可选设置：
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These are the compression type options:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是压缩类型选项：
- en: '`GL_OES_compressed_ETC1_RGB8_texture`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_OES_compressed_ETC1_RGB8_texture`'
- en: '`GL_OES_compressed_paletted_texture`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_OES_compressed_paletted_texture`'
- en: '`GL_EXT_texture_compression_s3tc`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_s3tc`'
- en: '`GL_IMG_texture_compression_pvrtc`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_IMG_texture_compression_pvrtc`'
- en: '`GL_EXT_texture_compression_dxt1`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_dxt1`'
- en: '`GL_EXT_texture_compression_dxt2`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_dxt2`'
- en: '`GL_EXT_texture_compression_dxt3`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_dxt3`'
- en: '`GL_EXT_texture_compression_dxt4`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_dxt4`'
- en: '`GL_EXT_texture_compression_dxt5`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_dxt5`'
- en: '`GL_AMD_compressed_3DC_texture`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_AMD_compressed_3DC_texture`'
- en: '`GL_EXT_texture_compression_latc`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_EXT_texture_compression_latc`'
- en: '`GL_AMD_compressed_ATC_texture`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_AMD_compressed_ATC_texture`'
- en: '`GL_ATI_texture_compression_atitc`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_ATI_texture_compression_atitc`'
- en: However, not all texture compressions are supported by every device. The developer
    should always choose the target texture compression depending on the hardware
    and Android version requirement.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有设备都支持所有纹理压缩。开发人员应根据硬件和Android版本要求始终选择目标纹理压缩。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google does the filtration process of devices automatically if the target device
    does not support the declared texture format or formats.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标设备不支持声明的纹理格式，则Google会自动进行设备过滤。
- en: Choosing the target OpenGL ES version
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择目标OpenGL ES版本
- en: 'As you have already learned, not all devices support all OpenGL versions. So,
    it is very important to choose the correct OpenGL version before developing the
    game. Here are a few factors that should be evaluated while choosing the OpenGL
    version:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经了解的，不是所有设备都支持所有OpenGL版本。因此，在开发游戏之前选择正确的OpenGL版本非常重要。在选择OpenGL版本时，应评估以下几个因素：
- en: Performance
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Texture support
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理支持
- en: Device support
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备支持
- en: Rendering feature
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染特性
- en: Programming comfort
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程舒适性
- en: Performance
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: It is noticed that OpenGL version 3.x is faster than OpenGL version 2.x, which
    is way faster than OpenGL 1.x. So, it is always better to use the latest possible
    version in the game.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到OpenGL版本3.x比OpenGL版本2.x更快，后者比OpenGL 1.x更快。因此，在游戏中始终最好使用最新可能的版本。
- en: Texture support
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理支持
- en: Texture compression support varies with OpenGL versions. Older versions support
    older texture compression factors. Also, Android version support is not universal
    for all OpenGL versions. Again, it is better to use the latest possible version
    for texture support.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理压缩支持因OpenGL版本而异。旧版本支持旧的纹理压缩因素。此外，Android版本支持并非所有OpenGL版本都通用。因此，最好使用最新可能的版本来支持纹理。
- en: Device support
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备支持
- en: This constraint keeps a developer's feet on the ground. The latest versions
    of OpenGL are not supported by all devices. So, in order to target a bigger range
    of devices, the user should change the OpenGL version to 2.0 as most devices support
    this version.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制使开发人员脚踏实地。并非所有设备都支持最新版本的OpenGL。因此，为了针对更广泛的设备范围，用户应将OpenGL版本更改为2.0，因为大多数设备支持这个版本。
- en: Rendering feature
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染特性
- en: As the version of OpenGL increases, the feature list becomes an important factor
    while choosing the OpenGL version. The developer must know the support required
    for developing the application and accordingly, they must choose the version.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 随着OpenGL版本的增加，功能列表成为选择OpenGL版本的重要因素。开发人员必须了解开发应用程序所需的支持，并相应地选择版本。
- en: Programming comfort
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程舒适性
- en: There is a huge coding style and API change among the versions of OpenGL. The
    developer should choose the version if it can actually be developed in the company
    with ease.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL的各个版本之间存在巨大的编码风格和API更改。开发人员应该选择版本，如果可以在公司轻松开发。
- en: Different CPU architecture support
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的CPU架构支持
- en: The developer has the opportunity to optimize an Android application for a separate
    processor architecture. At a high-level point of view, it is a great feature.
    However, this feature comes at a significant cost. Let's have a look at the details
    of this feature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员有机会为单独的处理器架构优化Android应用程序。从高层次的角度来看，这是一个很好的功能。然而，这个功能是以巨大的成本为代价的。让我们来看看这个功能的细节。
- en: Available CPU architectures
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的CPU架构
- en: 'Here are the architectures currently supported by the NDK build:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是NDK构建当前支持的架构：
- en: ARM
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM
- en: x86
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86
- en: Neon
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neon
- en: MIPS
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS
- en: ARM
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARM
- en: '**ARM** stands for **Acorn RISC Machine**. This is a **RISC** (**Reduced Instruction
    Set Computing**) based processor, mainly targeting embedded or mobile computing.
    As the base says, it is highly efficient for an operating system such as Android.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARM**代表**Acorn RISC Machine**。这是一个基于**RISC**（**Reduced Instruction Set Computing**）的处理器，主要针对嵌入式或移动计算。正如其基础所说，它对于Android等操作系统非常高效。'
- en: 'Currently, most used processors of the Android platform are from the ARM family.
    It can be further sub-categorized as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Android平台上使用最多的处理器来自ARM家族。它可以进一步细分如下：
- en: ARMv5TE
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv5TE
- en: ARMv7
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv7
- en: ARMv8
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv8
- en: x86
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86
- en: Intel introduced the **x86** architecture for processors. At first, these processors
    were mainly used for desktop/laptop PCs. However, they were optimized to be used
    in mobile devices in the form of Celeron or Atom processors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔推出了处理器的**x86**架构。最初，这些处理器主要用于台式机/笔记本电脑。然而，它们经过优化后也可以用于移动设备，以Celeron或Atom处理器的形式。
- en: 'Two types of x86 architecture can be set for the Android NDK build:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK构建可以设置两种类型的x86架构：
- en: i686
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: i686
- en: x86-64
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86-64
- en: Neon
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Neon
- en: The **Neon** architecture is based on ARM technology to optimize it further
    for mobile computation. The Android build also can be optimized for this specific
    architecture. All Cortex processors are basically Neon-based processors.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Neon**架构是基于ARM技术的，以进一步优化移动计算。Android构建也可以针对这种特定架构进行优化。所有Cortex处理器基本上都是基于Neon的处理器。'
- en: MIPS
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MIPS
- en: '**MIPS** stands for **Microprocessor without Interlocked** **Pipeline Stages**.
    There is a variation of 32- and 64-bit processors in this category. As the name
    says, this architecture is used in microprocessors in embedded devices for small-scale
    computation. Later, it was introduced to Android with a 64-bit architecture. However,
    this type of processor is rarely used in Android systems today.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**MIPS**代表**无互锁流水线级**微处理器。在这个类别中有32位和64位处理器的变体。正如名称所示，这种架构用于嵌入式设备中的微处理器进行小规模计算。后来，它以64位架构引入到Android中。然而，这种类型的处理器在今天的Android系统中很少使用。'
- en: Advantages and disadvantages of integrating multiple architecture support
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成多种架构支持的优缺点
- en: Android mobile devices have different configurations in terms of memory and
    processing capacity. Including separate architecture support may increase the
    performance that comes with greater build size.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Android移动设备在内存和处理能力方面有不同的配置。包括单独的架构支持可能会增加与更大的构建大小相对应的性能。
- en: The native build tool builds a separate shared library for each target processor
    and includes it in the build package.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本地构建工具为每个目标处理器构建一个单独的共享库，并将其包含在构建包中。
- en: Here are some advantages and disadvantages of providing separate processor architecture
    support.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供单独处理器架构支持的一些优缺点。
- en: 'Let''s see the advantages first:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先看看优点：
- en: '**Faster operation**: Separate architecture for a separate processor results
    in a faster processing speed of game instructions. If the processor architecture
    is supported by the Android application, then the processor does not need to perform
    any conversions and can run the instructions at a faster speed.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的操作**：为单独的处理器提供单独的架构会导致游戏指令的处理速度更快。如果处理器架构受到Android应用的支持，那么处理器就不需要执行任何转换，并且可以以更快的速度运行指令。'
- en: '**Optimum use of processor**: The operating system always looks for the specific
    architecture for an integrated processor. The same architecture makes optimum
    use of the processor.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器的最佳使用**：操作系统总是寻找集成处理器的特定架构。相同的架构可以最佳地利用处理器。'
- en: '**Minimum power consumption**: Optimum processing directly implies optimum
    and minimum power usage for processing.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低功耗：最佳处理直接意味着最佳和最低的处理功耗。
- en: '**Optimum memory usage**: The processor does not need to use extra runtime
    memory to execute instructions if the same processor architecture is supported
    by the Android application.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳内存使用**：如果Android应用支持相同的处理器架构，处理器就不需要使用额外的运行时内存来执行指令。'
- en: 'Let''s see the disadvantages now:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看缺点：
- en: '**Larger build size**: Using a separate shared library for a separate architecture
    increases the build package size significantly. The entire native instruction
    code is rewritten in a separate shared library with different processor optimization.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更大的构建大小**：为单独的架构使用单独的共享库会显著增加构建包的大小。整个本地指令代码都会在具有不同处理器优化的单独共享库中重新编写。'
- en: '**Reduced target device count**: If the size of the APK is large, it creates
    more problems to accommodate it for a low storage device. Hence, device support
    becomes less.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少目标设备数量**：如果APK的大小很大，将其适应低存储设备会带来更多问题。因此，设备支持变得更少。'
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at Android NDK briefly in this chapter and cleared a few doubts on
    native development. There are many developers who think that developing games
    in a native language gives enormous processing power. This is, however, not always
    true. Processing and performance depend on the development style and standard.
    In most common scenarios, the difference between native development and SDK development
    is negligible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中简要介绍了Android NDK，并解决了一些关于本地开发的疑惑。有许多开发人员认为用本地语言开发游戏可以获得巨大的处理能力。然而，这并不总是正确的。处理和性能取决于开发风格和标准。在大多数常见情况下，本地开发和SDK开发之间的差异是可以忽略不计的。
- en: OpenGL works with Android in any scenario. The backend rendering is based on
    OpenGL for both NDK and SDK. We have already discussed all the technical aspects
    of OpenGL. Here, you learned which version of OpenGL works with Android and what
    we should use. Clearly, OpenGL ES 2.0 is a good choice as most Android devices
    support it. On the other hand, OpenGL ES 1.0 is obsolete, and OpenGL ES 3.0 is
    not supported by most Android devices yet.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL在任何情况下都可以与Android一起工作。后端渲染基于OpenGL，无论是NDK还是SDK。我们已经讨论了OpenGL的所有技术方面。在这里，您了解了哪个版本的OpenGL适用于Android以及我们应该使用哪个版本。显然，OpenGL
    ES 2.0是一个不错的选择，因为大多数Android设备都支持它。另一方面，OpenGL ES 1.0已经过时，而OpenGL ES 3.0尚未得到大多数Android设备的支持。
- en: Until now, we have covered almost every aspect of Android game development.
    However, finishing the implementation for the game does not define the completion
    of the development cycle. Developers need to polish the game after it comes to
    a release-ready state to improve its overall quality. We will discuss game polishing
    in the next chapter to indicate the completion of the game development process.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了Android游戏开发的几乎所有方面。然而，完成游戏的实现并不意味着开发周期的完成。开发人员需要在游戏达到发布准备状态后对其进行打磨，以提高其整体质量。我们将在下一章讨论游戏的打磨，以表示游戏开发过程的完成。
