- en: Chapter 2. Starting a Native Android Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开始一个本机Android项目
- en: '*A man with the most powerful tools in hand is unarmed without the knowledge
    of their usage. Make, GCC, Ant, Bash, Eclipse…—any new Android programmer needs
    to deal with this technological ecosystem. Luckily, some of these names may already
    sound familiar. Indeed, Android is based on many open source components, laid
    together by the Android Development Kits and their specific tool-set: ADB, AAPT,
    AM, NDK-Build, NDK-GDB... Mastering them will give us the power to create, build,
    deploy and debug our own Android applications.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*手中拥有最强大的工具的人，如果不了解它们的使用方法，就是手无寸铁。Make，GCC，Ant，Bash，Eclipse……任何新的Android程序员都需要处理这个技术生态系统。幸运的是，其中一些名字可能已经听起来很熟悉。的确，Android基于许多开源组件，由Android开发工具包及其特定的工具集组合在一起：ADB，AAPT，AM，NDK-Build，NDK-GDB……掌握它们将赋予我们创建、构建、部署和调试自己的Android应用程序的能力。*'
- en: Before diving deeper into native code in the next chapter, let's discover these
    tools by starting a new concrete Android project that includes native C/C++ code.
    Despite Android Studio being the new official Android IDE, its lack of support
    for native code encourages us to focus mainly on Eclipse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章深入研究本机代码之前，让我们通过启动一个包含本机C/C++代码的新的具体Android项目来了解这些工具。尽管Android Studio是新的官方Android
    IDE，但它对本机代码的支持不足，这鼓励我们主要专注于Eclipse。
- en: 'Therefore, in this chapter, we are going to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将：
- en: Build an official sample application and deploy it on an Android device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建官方示例应用程序并将其部署到Android设备上
- en: Create our first native Android project using Eclipse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse创建我们的第一个本机Android项目
- en: Interface Java with C/C++ using Java Native Interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java本机接口将Java与C/C++接口
- en: Debug a native Android application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试本机Android应用程序
- en: Analyze a native crash dump
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析本机崩溃转储
- en: Set up a Gradle project with native code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本机代码设置Gradle项目
- en: By the end of this chapter, you should know how to start a new native Android
    project on your own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您应该知道如何自己启动一个新的本机Android项目。
- en: Building NDK sample applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建NDK示例应用程序
- en: The simplest way to get started with your new Android development environment
    is to compile and deploy some of the samples provided with the Android NDK. A
    possible (and *polygonful*!) choice is the **San Angeles** demo, created in 2004
    by Jetro Lauha and later ported to OpenGL ES (more information at [http://jet.ro/visuals/4k-intros/san-angeles-observation/](http://jet.ro/visuals/4k-intros/san-angeles-observation/)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开始您的新Android开发环境的最简单方法是编译和部署Android NDK提供的一些示例之一。一个可能的（且多边形丰富的！）选择是2004年由Jetro
    Lauha创建的**San Angeles**演示，并后来移植到OpenGL ES（更多信息请访问[http://jet.ro/visuals/4k-intros/san-angeles-observation/](http://jet.ro/visuals/4k-intros/san-angeles-observation/)）。
- en: Time for action – compiling and deploying San Angeles sample
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动-编译和部署圣安吉利斯示例
- en: 'Let''s use Android SDK and NDK tools to build a working APK:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Android SDK和NDK工具构建一个可工作的APK：
- en: Open a command-line prompt and go to the San Angeles sample directory inside
    the Android NDK. All further steps have to be performed from this directory.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行提示符并转到Android NDK中的San Angeles示例目录。所有进一步的步骤都必须从此目录执行。
- en: 'Generate San Angeles project files with the `android` command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`android`命令生成San Angeles项目文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_19.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动-编译和部署圣安吉利斯示例](img/1529_02_19.jpg)'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may get the following error upon executing this command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此命令时，您可能会收到以下错误：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that you have not installed all the Android SDK platforms as specified
    in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Environment"), *Setting Up
    Your Environment*. In which case, either install them using the `Android manager
    tool` or specify your own project target, for example, `android update project
    --target 18 -p ./`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您尚未安装[第1章](ch01.html "第1章。设置您的环境")中指定的所有Android SDK平台，*设置您的环境*。在这种情况下，可以使用`Android管理器工具`安装它们，或者指定您自己的项目目标，例如`android
    update project --target 18 -p ./`。
- en: Compile San Angeles native library with `ndk-build`:![Time for action – compiling
    and deploying San Angeles sample](img/1529_02_20.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ndk-build`编译San Angeles本机库：![采取行动-编译和部署圣安吉利斯示例](img/1529_02_20.jpg)
- en: 'Build and package San Angeles application in **Debug** mode:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以**调试**模式构建和打包San Angeles应用程序：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_21.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动-编译和部署圣安吉利斯示例](img/1529_02_21.jpg)'
- en: 'Make sure your Android device is connected or the emulator is started. Then
    deploy the generated package:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Android设备已连接或模拟器已启动。然后部署生成的软件包：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_22.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动-编译和部署圣安吉利斯示例](img/1529_02_22.jpg)'
- en: 'Launch `SanAngeles` application on your device or emulator:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备或模拟器上启动`SanAngeles`应用程序：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_23.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![采取行动-编译和部署圣安吉利斯示例](img/1529_02_23.jpg)'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt Publishing图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，直接将文件发送到您的电子邮件。
- en: '*What just happened?*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: The old-school San Angeles demo, full of flat-shaded polygons and nostalgia,
    is now running on your device. With only a few command lines, involving most of
    the tools needed for the Android development, a full application including native
    C/C++ code has been generated, compiled, built, packaged, deployed, and launched.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个老派的San Angeles演示，充满了平面着色的多边形和怀旧，现在正在您的设备上运行。只需几条命令行，涉及到Android开发所需的大部分工具，就生成、编译、构建、打包、部署和启动了一个包含本机C/C++代码的完整应用程序。
- en: '![What just happened?](img/1529_02_24.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/1529_02_24.jpg)'
- en: Let's see this process in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这个过程。
- en: Generating project files with Android manager
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Android管理器生成项目文件
- en: 'We generated project files from an existing code base thanks to the Android
    manager. The following bullet points give more information regarding this process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Android管理器从现有代码库生成了项目文件。以下要点提供了有关此过程的更多信息：
- en: '`build.xml`: This is the Ant file that describes how to compile and package
    the final application APK file (which stands for *Android PacKage*). This build
    file contains mainly links to properties and core Android Ant build files.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.xml`：这是描述如何编译和打包最终应用程序APK文件（代表*Android PacKage*）的Ant文件。此构建文件主要包含到属性和核心Android
    Ant构建文件的链接。'
- en: '`local.properties`: This file contains the Android SDK location. Every time
    your SDK location changes, this file should be regenerated.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local.properties`：此文件包含Android SDK位置。每当您的SDK位置更改时，应重新生成此文件。'
- en: '`proguard-project.txt`: This file contains a default configuration for **Proguard**,
    a code optimizer and obfuscator for Java code. More information about it can be
    found at [http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proguard-project.txt`：此文件包含**Proguard**的默认配置，Proguard是用于Java代码的代码优化器和混淆器。有关它的更多信息可以在[http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html)找到。'
- en: '`project.properties`: This file contains the application target Android SDK
    version. This file is generated by default from a pre-existing `default.properties`
    file in the `project` directory. If no `default.properties` exists, then an additional
    `–target <API Target>` flag (for example, `--target 4` for Android 4 Donut) must
    be appended to the `android create` command.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.properties`：此文件包含应用程序目标Android SDK版本。此文件默认从`project`目录中预先存在的`default.properties`文件生成。如果不存在`default.properties`，则必须在`android
    create`命令后附加一个额外的`–target <API Target>`标志（例如，`--target 4`表示Android 4 Donut）。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Target SDK version is different from the minimum SDK version. The first version
    describes the latest Android version for which an application is built, whereas
    the latter indicates the minimum Android version on which the application is allowed
    to run. Both can be declared optionally in `AndroidManifest.xml` file (clause
    `<uses-sdk>`) but only the target SDK version is "duplicated" in `project.properties`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标SDK版本与最低SDK版本不同。第一个版本描述了构建应用程序的最新Android版本，而后者指示应用程序允许在其中运行的最低Android版本。两者都可以选择性地在`AndroidManifest.xml`文件（子句`<uses-sdk>`）中声明，但只有目标SDK版本在`project.properties`中是“重复的”。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When creating an Android application, choose carefully the minimum and target
    Android API you want to support, as this can dramatically change your application
    capabilities as well as your audience wideness. Indeed, as a result of fragmentation,
    targets tend to move a lot and faster in Android!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Android应用程序时，仔细选择要支持的最低和目标Android API，因为这可能会极大地改变您的应用程序功能以及您的受众范围。实际上，由于碎片化的结果，Android中的目标倾向于频繁移动和快速变化！
- en: An application that does not target the latest Android version does not mean
    it will not run on it. However, it will not have access to all the latest features
    nor all of the latest optimizations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不针对最新的Android版本的应用程序并不意味着它无法在其上运行。但是，它将无法访问所有最新功能和所有最新优化。
- en: 'The Android manager is the main entry point for an Android developer. Its responsibilities
    are bound to SDK version updates, virtual devices management, and projects management.
    They can be listed exhaustively from the command line by executing `android –help`.
    Since we have already looked at SDK and AVD management in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Environment"), *Setting Up Your Environment*, let''s
    focus on its project management capabilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Android管理器是Android开发人员的主要入口点。其职责涉及SDK版本更新、虚拟设备管理和项目管理。可以通过执行`android –help`命令行详尽列出它们。由于我们已经在[第1章](ch01.html
    "第1章。设置您的环境")中查看了SDK和AVD管理，*设置您的环境*，让我们专注于其项目管理能力：
- en: '`android create project` allows creating new Android projects ex-nihilo from
    the command line. Generated projects contain only Java files but no NDK-related
    files. A few additional options must be specified to allow for proper generation,
    such as:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create project`允许从命令行创建新的Android项目。生成的项目只包含Java文件，而不包含NDK相关文件。必须指定一些附加选项才能进行正确的生成，例如：'
- en: '| Option | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-a` | Main activity name |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 主要活动名称 |'
- en: '| `-k` | Application package |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `-k` | 应用程序包 |'
- en: '| `-n` | Project name |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 项目名称 |'
- en: '| `-p` | Project path |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | 项目路径 |'
- en: '| `-t` | Target SDK version |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 目标SDK版本 |'
- en: '| `-g` and `-v` | To generate Gradle build file instead of Ant and specifying
    its plugin version |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `-g` 和 `-v` | 生成Gradle构建文件而不是Ant，并指定其插件版本 |'
- en: 'An example of command line to create a new project is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目的命令行示例如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`android update project` creates project files from existing sources, as shown
    in the previous tutorial. However, if they already exist it can also upgrade the
    project target to new SDK versions (that is, the `project.properties` file) and
    update the Android SDK location (that is, the `local.properties` file). The available
    flags are slightly different:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android update project`从现有源代码创建项目文件，如前面的教程所示。但是，如果它们已经存在，它还可以将项目目标升级到新的SDK版本（即`project.properties`文件），并更新Android
    SDK位置（即`local.properties`文件）。可用的标志略有不同：'
- en: '| Option | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-l` | Library projects to add |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 要添加的库项目 |'
- en: '| `-n` | Project name |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 项目名称 |'
- en: '| `-p` | Project path |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | 项目路径 |'
- en: '| `-t` | Target SDK version |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 目标SDK版本 |'
- en: '| `-s` | To update projects in subfolders |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 更新子文件夹中的项目 |'
- en: 'We can also append a new library project with the `-l` flag, for example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-l`标志附加一个新的库项目，例如：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`android create lib-project` and `android update lib-project` manage library
    projects. These kinds of projects are not well adapted for native C/C++ development,
    especially when it comes to debugging, since NDK has its own way of reusing native
    libraries.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create lib-project`和`android update lib-project`管理库项目。这些类型的项目对于本机C/C++开发来说并不适合，特别是在调试方面，因为NDK有自己的重用本机库的方式。'
- en: '`android create test-project`, `android update test-project`, and `android
    create uitest-project` manage unit test and UI test projects.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create test-project`，`android update test-project`和`android create
    uitest-project`管理单元测试和UI测试项目。'
- en: More details about all these options can be found on the Android developer website
    at [http://developer.android.com/tools/help/android.html](http://developer.android.com/tools/help/android.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有这些选项的更多详细信息可以在Android开发人员网站上找到[http://developer.android.com/tools/help/android.html](http://developer.android.com/tools/help/android.html)。
- en: Compiling native code with NDK-Build
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NDK-Build编译本机代码
- en: 'After generating project files, we then compile our first native C/C++ library
    (also called *module*) using `ndk-build`. This command, the most essential one
    to know for NDK development, is basically a Bash script, which:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生成项目文件后，我们使用`ndk-build`编译我们的第一个本机C/C++库（也称为*模块*）。这个命令是NDK开发中最基本的命令，基本上是一个Bash脚本，它：
- en: Sets up the Android native compilation toolchain based on either GCC or CLang.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于GCC或CLang设置Android本机编译工具链。
- en: 'Wraps `Make` to control native code construction with the help of user-defined
    `Makefiles`: `Android.mk` and optional `Application.mk`. By default, `NDK-`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户定义的`Makefiles`：`Android.mk`和可选的`Application.mk`包装`Make`以控制本机代码的构建。默认情况下，`NDK-`
- en: '`Build` looks for in the `jni` project directory, where native C/C++ are often
    located by convention.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build`在`jni`项目目录中查找，本机C/C++通常按约定存放在其中。'
- en: 'NDK-Build generates intermediate object files from C/C++ source files (in the
    `obj` directory) and produces the final binary library (`.so`) in the `libs` directory.
    NDK-related build files can be erased with the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NDK-Build从C/C++源文件（在`obj`目录中）生成中间对象文件，并在`libs`目录中生成最终的二进制库（`.so`）。可以使用以下命令删除与NDK相关的构建文件：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For more information about NDK-Build and Makefiles, see [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NDK-Build和Makefiles的更多信息，请参见[第9章](ch09.html "第9章。将现有库移植到Android")，“将现有库移植到Android”。
- en: Building and packaging an application with Ant
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ant构建和打包应用程序
- en: 'An Android application is not composed of native C/C++ code only, but also
    of Java code. Thus, we have:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序不仅由本机C/C++代码组成，还包括Java代码。因此，我们有：
- en: Built Java sources located in the `src` directory with `Javac`(Java Compiler).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Javac`（Java编译器）构建位于`src`目录中的Java源代码。
- en: Dexed generated Java bytecode, that is, transforming it into Android Dalvik
    or ART bytecode with DX. Indeed, both Dalvik and ART Virtual Machines (more about
    these later in this chapter) operate on a specific bytecode, which is stored in
    an optimized format called **Dex**.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成的Java字节码Dex化，即将其转换为Android Dalvik或ART字节码。实际上，Dalvik和ART虚拟机（本章后面将更多介绍）都是基于特定字节码运行的，该字节码存储在一种称为**Dex**的优化格式中。
- en: Packaged Dex files, Android manifest, resources (images, and so on), and native
    libraries in the final APK file with AAPT, also known as the **Android Asset Packaging
    Tool**.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AAPT在最终APK文件中打包Dex文件、Android清单、资源（图像等）和本机库，也称为**Android Asset Packaging Tool**。
- en: 'All these operations are summarized in one call to Ant: `ant debug`. The result
    is an APK packaged in debug mode and generated in the `bin` directory. Other build
    modes are available (for example, release mode) and can be listed with `ant help`.
    If you would like to erase temporary Java-related build files (for example, the
    `Java .class`), then simply run the following command line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都总结在一个Ant调用中：`ant debug`。结果是以调试模式打包的APK，并生成在`bin`目录中。还有其他可用的构建模式（例如，发布模式），可以使用`ant
    help`列出。如果要删除临时的与Java相关的构建文件（例如，`Java .class`），只需运行以下命令：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Deploying an application package with Ant
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ant部署应用程序包
- en: 'A packaged application can be deployed as is with Ant through **ADB**. The
    available options for deployment are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的应用程序可以通过**ADB**直接部署。部署的可用选项如下：
- en: '`ant installd` for debug mode'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ant installd`用于调试模式'
- en: '`ant installr` for release mode'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ant installr`用于发布模式'
- en: 'Beware that an APK cannot overwrite an older APK of the same application if
    they come from a different source. In such a case, remove the previous application
    first by executing the following command line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果来自不同来源的APK不能覆盖同一应用程序的旧APK。在这种情况下，首先执行以下命令删除先前的应用程序：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Installation and uninstallation can also be performed directly through ADB,
    for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和卸载也可以直接通过ADB执行，例如：
- en: '`adb install` <path to application APK>: For installing an application for
    the first time (for example, `bin/DemoActivity-debug.apk` for our sample).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb install` <应用程序APK路径>：用于首次安装应用程序（例如，我们示例中的`bin/DemoActivity-debug.apk`）。'
- en: '`adb install -r` <path to application APK>: For reinstalling an application
    and to keep its data stored on the device.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb install -r` <应用程序APK路径>：用于重新安装应用程序并保留其数据存储在设备上。'
- en: '`adb uninstall` <application package name>: For uninstalling an application
    identified by its Application package name (for example, `com.example.SanAngeles`
    for our sample).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb uninstall` <应用程序包名称>：用于卸载由其应用程序包名称标识的应用程序（例如，我们示例中的`com.example.SanAngeles`）。'
- en: Launching an application with ADB Shell
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ADB Shell启动应用程序
- en: 'Finally, we launched the application thanks to the **Activity Manager** (**AM**).
    AM command parameters that are used to start San Angeles come from the `AndroidManifest.xml`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过**Activity Manager**（**AM**）启动了应用程序。用于启动San Angeles的AM命令参数来自`AndroidManifest.xml`文件：
- en: '`com.example.SanAngeles` is the application package name (the same we use to
    uninstall an application as previously shown).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.example.SanAngeles`是应用程序包名称（与之前显示的卸载应用程序时使用的相同）。'
- en: '`com.example.SanAngeles.DemoActivity` is the launched Activity canonical class
    name (that is, a simple class name concatenated to its package). Here is a brief
    example of how these are used:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.example.SanAngeles.DemoActivity`是启动的Activity规范类名（即，简单类名连接到其包）。以下是这些用法的简要示例：'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because it is located on your device, AM needs to be run through ADB. To do
    so, the latter features a limited Unix-like shell, which features some classic
    commands such as `ls`, `cd`, `pwd`, `cat`, `chmod`, or `ps` as well as a few Android
    specific ones as shown in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它位于您的设备上，所以AM需要通过ADB运行。为此，后者具有一个受限的类Unix shell，其中包含一些经典命令，如`ls`，`cd`，`pwd`，`cat`，`chmod`或`ps`，以及一些Android特定命令，如下表所示：
- en: '| `am` | The Activity Manager which not only starts Activities but can also
    kill them, broadcast intent, start/stop profiler, and so on. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '`am` | 活动管理器不仅可以启动活动，还可以终止它们，广播意图，启动/停止分析器等。'
- en: '| `dmesg` | To dump kernel messages. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`dmesg` | 转储内核消息。'
- en: '| `dumpsys` | To dump the system state. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`dumpsys` | 用于转储系统状态。'
- en: '| `logcat` | To display device log messages. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '`logcat` | 显示设备日志消息。'
- en: '| `run-as <user id> <command>` | To run a command with the `user id` privilege.
    `user id` can be an application package name, which gives access to application
    files (for example, `run-as com.example.SanAngeles ls`). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '`run-as <user id> <command>` | 以`user id`特权运行命令。`user id`可以是应用程序包名称，这样可以访问应用程序文件（例如，`run-as
    com.example.SanAngeles ls`）。'
- en: '| `sqlite3 <db file>` | To open an SQLite Database (it can be combined with
    `run-as`). |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '`sqlite3 <db file>` | 打开SQLite数据库（可以与`run-as`结合使用）。'
- en: 'ADB can be started in one of the following ways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ADB可以通过以下方式之一启动：
- en: With a command in parameter, as shown in step 5 with AM, in which case Shell
    runs a single command and immediately exits.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数的命令，如步骤5中所示的AM，此时Shell运行单个命令并立即退出。
- en: With the `adb shell` command without a parameter, in which case you can use
    it as a classic Shell (and, for example, call `am` and any other command).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`adb shell`命令没有参数的情况下，您可以将其用作经典Shell（例如，调用`am`和任何其他命令）。
- en: ADB Shell is a real '*Swiss Army knife*', which allows advanced manipulations
    on your device, especially with the root access. For example, it becomes possible
    to observe applications deployed in their "sandbox" directory (that is, the `/data/data`
    directory) or to list and kill the currently running processes. Without root access
    to your phone, possible actions are more limited. For more information, have a
    look at [http://developer.android.com/tools/help/adb.html](http://developer.android.com/tools/help/adb.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ADB Shell是一个真正的“瑞士军刀”，允许在您的设备上进行高级操作，特别是具有root访问权限。例如，可以观察部署在其“沙箱”目录（即`/data/data`目录）中的应用程序，或者列出和终止当前正在运行的进程。如果没有root访问权限，手机上的可能操作将更有限。有关更多信息，请访问[http://developer.android.com/tools/help/adb.html](http://developer.android.com/tools/help/adb.html)。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you know a bit about the Android ecosystem, you may have heard about rooted
    phones and non-rooted phones. **Rooting** a phone means getting administrative
    privilege, generally using hacks. Rooting a phone is useful to install a custom
    ROM version (optimized or modified, for example, **Cyanogen**) or to perform any
    sort of (especially dangerous) manipulations that a root user can do (for example,
    accessing and deleting any file). Rooting is not an illegal operation as such,
    as you are modifying YOUR device. However, not all manufacturers appreciate this
    practice, which usually voids the warranty.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Android生态系统有所了解，可能已经听说过rooted手机和非rooted手机。对手机进行**Root**意味着获得管理特权，通常使用黑客方法。对手机进行Root对于安装自定义ROM版本（优化或修改，例如**Cyanogen**）或执行任何类型的（尤其是危险的）操作非常有用，这些操作是根用户可以执行的（例如，访问和删除任何文件）。Rooting本身并不是非法操作，因为您正在修改您的设备。但是，并非所有制造商都欣赏这种做法，这通常会使保修失效。
- en: More about Android tooling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关Android工具的更多信息
- en: Building San Angeles sample application gives you a glimpse of what Android
    tools can do. However, behind their somewhat 'rustic' look, more is possible.
    Information can be found on the Android developer website at [http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构建San Angeles示例应用程序可以让您一窥Android工具的功能。但是，在它们略显“原始”的外观背后，还有更多可能性。有关Android开发者网站上的信息，请访问[http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html)。
- en: Creating your first native Android project
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个本机Android项目
- en: In the first part of the chapter, we saw how to use Android command-line tools.
    However, developing with Notepad or VI is not really attractive. Coding should
    be fun! And to make it so, we need our preferred IDE to perform boring or unpractical
    tasks. So now we will see how to create a native Android project using Eclipse.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分中，我们看到了如何使用Android命令行工具。但是，使用记事本或VI进行开发并不真的有吸引力。编码应该是有趣的！为了使其如此，我们需要我们喜欢的IDE来执行乏味或不切实际的任务。现在我们将看到如何使用Eclipse创建本机Android项目。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part1`的名称提供。
- en: Time for action – creating a native Android project
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建本机Android项目
- en: 'Eclipse provides a wizard to help us set up our project:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse提供了一个向导来帮助我们设置项目：
- en: Launch Eclipse. In the main menu, go to **File** | **New** | **Project…**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse。在主菜单中，转到**文件** | **新建** | **项目…**。
- en: Then, in the opened **New project** wizard, **go to Android** | **Android Application
    Project** and click on **Next**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在打开的**新项目**向导中，**转到Android** | **Android应用程序项目**并单击**下一步**。
- en: In the next screen, enter project properties as follows and click on **Next**
    again:![Time for action – creating a native Android project](img/1529_02_01.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，输入项目属性如下，然后再次单击**下一步**：![行动时间-创建本机Android项目](img/1529_02_01.jpg)
- en: Click on **Next** twice, leaving default options, to go to the **Create activity**
    wizard screen. Select **Blank activity with Fragment** and click on **Next**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**下一步**两次，保留默认选项，转到**创建活动**向导屏幕。选择**带片段的空白活动**，然后单击**下一步**。
- en: Finally, in the **Blank Activity** screen, enter activity properties as follows:![Time
    for action – creating a native Android project](img/1529_02_02.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**空白活动**屏幕上，输入活动属性如下：![操作时间-创建本机Android项目](img/1529_02_02.jpg)
- en: Click on **Finish** to validate. After a few seconds, the wizard disappears
    and the project **Store** is displayed in Eclipse.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Finish**进行验证。几秒钟后，向导消失，项目**Store**显示在Eclipse中。
- en: Add native C/C++ support to the project. Select the project **Store** in the
    **Package Explorer** view and from its right-click context menu, go to **Android
    Tools** | **Add Native Support...**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加本机C/C++支持。在**Package Explorer**视图中选择项目**Store**，然后从其右键单击上下文菜单中转到**Android
    Tools** | **Add Native Support...**。
- en: In the opened **Add Android Native Support** popup, set the library name to
    `com_packtpub_store_Store` and click on **Finish**.![Time for action – creating
    a native Android project](img/1529_02_03.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的**Add Android Native Support**弹出窗口中，将库名称设置为`com_packtpub_store_Store`，然后单击**Finish**。![操作时间-创建本机Android项目](img/1529_02_03.jpg)
- en: The `jni` and `obj` directories are created in the project directory. The first
    directory contains one makefile `Android.mk` and one C++ source file `com_packtpub_store_Store.cpp`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中创建了`jni`和`obj`目录。第一个目录包含一个makefile `Android.mk`和一个C++源文件`com_packtpub_store_Store.cpp`。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After adding native support, Eclipse may automatically switch your perspective
    to C/C++. Therefore, in case your development environment does not look as usual,
    simply check your perspective in the Eclipse's top-right corner. You can work
    on an NDK project from either a Java or C/C++ perspective without any trouble.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加本机支持后，Eclipse可能会自动切换到C/C++透视图。因此，如果您的开发环境看起来不像平常那样，请简单地检查Eclipse右上角的透视图。您可以在Java或C/C++透视图中轻松地处理NDK项目，而不会遇到任何问题。
- en: 'Create a new Java class `Store` in `src/com/packtpub/store/Store.java`. From
    within a static block, load the `com_packtpub_store_Store` native library:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/com/packtpub/store/Store.java`中创建一个新的Java类`Store`。从静态块中加载`com_packtpub_store_Store`本机库：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Edit `src/com/packtpub/store/StoreActivity.java`. Declare and initialize a
    new instance of `Store` in activity''s `onCreate()`. Since we do not need them,
    remove the `onCreateOptionsMenu()` and `onOptionsItemSelected()` methods that
    may have been created by the Eclipse project creation wizard:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/com/packtpub/store/StoreActivity.java`。在活动的`onCreate()`中声明并初始化`Store`的新实例。由于我们不需要它们，删除可能由Eclipse项目创建向导创建的`onCreateOptionsMenu()`和`onOptionsItemSelected()`方法。
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Connect your device or emulator and launch the application. Select `Store` in
    the **Package Explorer** view and then navigate to **Run** | **Run As** | **Android
    Application** from the Eclipse main menu. Alternatively, click on the **Run**
    button in the Eclipse toolbar.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接您的设备或模拟器并启动应用程序。在Eclipse主菜单中选择**Package Explorer**视图中的`Store`，然后导航到**Run**
    | **Run As** | **Android Application**。或者，单击Eclipse工具栏中的**Run**按钮。
- en: Select the application type **Android Application** and click on **OK** to get
    the following screen:![Time for action – creating a native Android project](img/1529_02_04.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应用程序类型**Android Application**，然后单击**OK**，以获得以下屏幕：![操作时间-创建本机Android项目](img/1529_02_04.jpg)
- en: '*What just happened?*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: In only a few steps, our first native Android project has been created and launched
    thanks to Eclipse.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需几个步骤，我们的第一个本机Android项目已经由Eclipse创建并启动。
- en: The Android project creation wizard helps get you started quickly. It generates
    the minimum code for a simple Android application. However, by default, new Android
    projects support Java and only Java.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android项目创建向导帮助您快速入门。它为简单的Android应用程序生成最少的代码。但是，默认情况下，新的Android项目仅支持Java。
- en: 'With the help of ADT, an Android Java project is easily turned into a hybrid
    project with native C/C++ support. It generates the minimum files necessary for
    an NDK-Build to compile a native library:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 借助ADT，Android Java项目很容易转变为具有本机C/C++支持的混合项目。它生成了NDK-Build编译本机库所需的最少文件：
- en: '`Android.mk` is a Makefile describing which source files to compile and how
    to generate the final native library.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.mk`是一个Makefile，描述要编译哪些源文件以及如何生成最终的本机库。'
- en: '`com_packtpub_store_Store.cpp` is an almost empty file containing a single
    include. We are going to explain this in the next part of this chapter.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`com_packtpub_store_Store.cpp`是一个几乎空白的文件，包含一个单一的包含。我们将在本章的下一部分中解释这一点。'
- en: Once the project is set up, dynamically loading a native library is done in
    a single call to `System.loadLibrary()`. This is easily done in a static block,
    which ensures that the library is loaded once and for all, before a class is initialized.
    Beware that this works only if the container class is loaded from a single Java
    ClassLoader (which is usually the case).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目设置好，动态加载本机库只需调用一次`System.loadLibrary()`。这在静态块中很容易实现，可以确保在初始化类之前加载库。请注意，这仅在容器类从单个Java
    ClassLoader加载时才有效（通常是这种情况）。
- en: Working with an IDE like Eclipse really offers a huge productivity boost and
    makes programming much more comfortable! But if you are a command-line aficionado
    or would like to train your command-line skills, the first part, *Building NDK
    sample applications*, can easily be applied here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 像Eclipse这样的IDE确实提供了巨大的生产力提升，并使编程更加舒适！但是，如果您是命令行爱好者，或者想要锻炼命令行技能，第一部分*构建NDK示例应用程序*可以轻松应用于此处。
- en: Introducing Dalvik and ART
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Dalvik和ART
- en: It is not possible to talk about Android without mentioning a few words about
    **Dalvik** and **ART**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论Android时不可能不提及**Dalvik**和**ART**。
- en: Dalvik is a **Virtual Machine** on which the Dex bytecode is interpreted (not
    native code!). It is at the core of any application running on Android. Dalvik
    has been conceived to fit the constrained requirements of mobile devices. It is
    specifically optimized to use less memory and CPU. It sits on top of the Android
    kernel, which provides the first layer of abstraction over the hardware (process
    management, memory management, and so on).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik是一个**虚拟机**，用于解释Dex字节码（而不是本机代码！）。它是Android上运行任何应用程序的核心。Dalvik被设计来满足移动设备的受限要求。它经过专门优化，以使用更少的内存和CPU。它位于提供对硬件的第一层抽象的Android内核之上（进程管理，内存管理等）。
- en: ART is the new Android runtime environment, which has replaced Dalvik since
    the Android 5 Lollipop. It has improved performances a lot compared to Dalvik.
    Indeed, where Dalvik interprets bytecode `Just-In-Time` upon application startup,
    ART, on the other hand, precompiles bytecode `Ahead-Of-Time` into native code
    during application installation. ART is backward compatible with applications
    packaged for former Dalvik VMs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ART是新的Android运行时环境，自Android 5 Lollipop以来已经取代了Dalvik。与Dalvik相比，它的性能有了很大的改进。事实上，Dalvik在应用程序启动时解释字节码`Just-In-Time`，而ART则在应用程序安装期间将字节码`Ahead-Of-Time`预编译为本机代码。ART向后兼容以前为Dalvik
    VM打包的应用程序。
- en: Android has been designed with speed in mind. Because most users do not want
    to wait for their application to be loaded while others are still running, the
    system is able to instantiate multiple Dalvik or ART VMs quickly, thanks to the
    **Zygote** process. Zygote, (whose name comes from the very first biologic cell
    of an organism from which daughter cells get reproduced), starts when the system
    boots up. It preloads (or "warms up") all core libraries shared among applications
    as well as the Virtual Machine instance. To launch a new application, Zygote is
    simply forked and the initial Dalvik instance gets copied as a consequence. Memory
    consumption is lowered by sharing as many libraries as possible between processes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Android被设计为速度优先。因为大多数用户不希望在其他应用程序仍在运行时等待其应用程序加载，所以系统能够快速实例化多个Dalvik或ART VM，这要归功于**Zygote**进程。Zygote（其名称来自生物体的第一个细胞，从中产生子细胞）在系统启动时启动。它预加载（或“预热”）所有应用程序之间共享的核心库以及虚拟机实例。要启动新应用程序，只需分叉Zygote，然后初始Dalvik实例会被复制。通过在进程之间共享尽可能多的库，可以降低内存消耗。
- en: Dalvik and ART are themselves made of native C/C++ code compiled for the target
    Android platform (ARM, X86, and so on). This means that interfacing these VMs
    with native C/C++ libraries is easily possible provided that it is compiled with
    the same **Application Binary Interface** (**ABI**) (which basically describes
    the application or library binary format). This is the role devoted to the Android
    NDK. For more information, have a look at the **Android Open Source Project**
    (**AOSP**), that is, the Android source code at [https://source.android.com/](https://source.android.com/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik和ART本身由为目标Android平台（ARM、X86等）编译的本机C/C++代码组成。这意味着只要使用相同的**应用程序二进制接口**（**ABI**）（基本上描述了应用程序或库的二进制格式），就可以轻松地将这些VM与本机C/C++库进行接口。这就是Android
    NDK的作用。有关更多信息，请查看**Android开源项目**（**AOSP**），即[https://source.android.com/](https://source.android.com/)上的Android源代码。
- en: Interfacing Java with C/C++
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java与C/C++进行接口
- en: Native C/C++ code has the ability to unleash the power of your application.
    To do so, Java code needs to invoke and run its native counterpart. In this part,
    we are going to interface Java and native C/C++ code together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本机C/C++代码有能力释放您的应用程序的功能。为此，Java代码需要调用并运行其本机对应项。在本部分中，我们将把Java和本机C/C++代码进行接口。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part2`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part2`的名称提供。
- en: Time for action – calling C code from Java
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-从Java调用C代码
- en: 'Let''s create our first native method and call it from the Java side:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个本机方法，并从Java端调用它：
- en: 'Open `src/com/packtpub/store/Store.java` and declare one native method to query
    the `Store`. This method returns `int` with the number of entries in it. There
    is no need to define a method body:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/com/packtpub/store/Store.java`并声明一个本机方法来查询`Store`。此方法返回`int`，其中包含其中的条目数。无需定义方法体：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open `src/com/packtpub/store/StoreActivity.java` and initialize the store.
    Use its `getCount()` method value to initialize the application title:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/com/packtpub/store/StoreActivity.java`并初始化商店。使用其`getCount()`方法的值来初始化应用程序标题：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generate a JNI header file from the `Store` class. Go to the Eclipse main menu
    and go to **Run** | **External Tools** | **External Tools Configurations…**. Create
    a new **Program** configuration with the following parameters described in the
    following screenshot:![Time for action – calling C code from Java](img/1529_02_05.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Store`类生成一个JNI头文件。转到Eclipse主菜单，然后转到**运行** | **外部工具** | **外部工具配置…**。使用以下参数创建一个新的**程序**配置，如下截图所示：![行动时间-从Java调用C代码](img/1529_02_05.jpg)
- en: '**Location** refers to the `javah` absolute path, which is OS specific. On
    Windows, you can enter `${env_var:JAVA_HOME}\bin\javah.exe`. On Mac OS X and Linux,
    it is usually `/usr/bin/javah`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置**是指`javah`的绝对路径，这是特定于操作系统的。在Windows上，您可以输入`${env_var:JAVA_HOME}\bin\javah.exe`。在Mac
    OS X和Linux上，它通常是`/usr/bin/javah`。'
- en: 'In the **Refresh** tab, check **Refresh resources upon completion** and select
    **Specific resources**. Using the **Specify Resources…** button, select the `jni`
    folder. Finally, click on **Run** to execute `javah`. A new file `jni/com_packtpub_store_Store.h`
    will then be generated. This contains a prototype for the native method `getCount()`
    expected on the Java side:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**刷新**选项卡中，选中**完成后刷新资源**并选择**特定资源**。使用**指定资源…**按钮，选择`jni`文件夹。最后，单击**运行**以执行`javah`。然后将生成一个名为`jni/com_packtpub_store_Store.h`的新文件。其中包含了在Java端期望的本机方法`getCount()`的原型：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now implement `jni/com_packtpub_store_Store.cpp` so that it returns
    `0` when invoked. The method signature originates from the generated header file
    (you can replace any previous code) except that the parameter names have been
    explicitly specified:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现`jni/com_packtpub_store_Store.cpp`，使其在调用时返回`0`。方法签名源自生成的头文件（可以替换任何先前的代码），只是参数名称已经明确指定：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and run the application.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Java now talks C/C++! In the previous part, we created a hybrid Android project.
    In this part, we interfaced Java with native code. This cooperation is established
    through **Java Native Interfaces** (**JNI**). JNI is the bridge, which binds Java
    to C/C++. This occurs in three main steps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Java现在与C/C++通信！在上一部分中，我们创建了一个混合Android项目。在本部分中，我们将Java与本地代码进行了接口。这种合作是通过**Java本地接口**（**JNI**）建立的。JNI是将Java与C/C++绑定的桥梁。这发生在三个主要步骤中。
- en: 'Defining native method prototypes on the Java side, marked with the native
    keyword. Such methods have no body, like an abstract method, because they are
    implemented on the native side. Native methods can have parameters, a return value,
    visibility (private, protected, package protected, or public), and can be static:
    such as the usual Java methods.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java端定义本地方法原型，标有本地关键字。这些方法没有主体，就像抽象方法一样，因为它们是在本地端实现的。本地方法可以有参数、返回值、可见性（private、protected、package
    protected或public），并且可以是静态的：就像通常的Java方法一样。
- en: Native methods can be called from anywhere in Java code, provided that containing
    a native library has been loaded before they are called. Failure to do so results
    in an exception of type `java.lang.UnsatisfiedLinkError`, which is raised when
    the native method is invoked for the first time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法可以从Java代码的任何地方调用，前提是在调用它们之前已经加载了包含本地库。如果没有这样做，第一次调用本地方法时会引发`java.lang.UnsatisfiedLinkError`类型的异常。
- en: Using `javah` to generate a header file with corresponding native C/C++ prototypes.
    Although it is not compulsory, the `javah` tool provided by the JDK is extremely
    useful to generate native prototypes. Indeed, the JNI convention is tedious and
    error-prone (more about this in [Chapter 3](ch03.html "Chapter 3. Interfacing
    Java and C/C++ with JNI"), *Interfacing Java and C/C++ with JNI*). The JNI code
    is generated from the `.class` file, which means your Java code must be compiled
    first.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`javah`生成具有相应本地C/C++原型的头文件。虽然这不是强制性的，但JDK提供的`javah`工具非常有用，可以生成本地原型。事实上，JNI约定是繁琐且容易出错的（关于这一点，[第3章](ch03.html
    "第3章。使用JNI接口Java和C/C++")中有更多介绍，*使用JNI接口Java和C/C++*）。JNI代码是从`.class`文件生成的，这意味着您的Java代码必须首先编译。
- en: Writing native C/C++ code implementation to perform expected operations. Here,
    we simply return `0` when the `Store` library is queried. Our native library is
    compiled in the `libs/armeabi` directory (the one for ARM processors) and is named
    `libcom_packtpub_store_Store.so`. Temporary files generated during compilation
    are located in the `obj/local` directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 编写本地C/C++代码实现所需的操作。在这里，当查询`Store`库时，我们简单地返回`0`。我们的本地库编译在`libs/armeabi`目录（用于ARM处理器的目录）中，命名为`libcom_packtpub_store_Store.so`。在编译过程中生成的临时文件位于`obj/local`目录中。
- en: Despite its apparent simplicity, interfacing Java with C/C++ is much more involved
    than what it seems superficially. How to write JNI code on the native side is
    explored in more detail in [Chapter 3](ch03.html "Chapter 3. Interfacing Java
    and C/C++ with JNI"), *Interfacing Java and C/C++ with JNI*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很简单，但在Java与C/C++之间进行接口的工作比表面上看起来要复杂得多。如何在本地端编写JNI代码在[第3章](ch03.html "第3章。使用JNI接口Java和C/C++")中有更详细的探讨，*使用JNI接口Java和C/C++*。
- en: Debugging native Android applications
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试本地Android应用程序
- en: 'Before diving deeper into JNI, there is one last important tool that any Android
    developer needs to know how to use: the **Debugger**. The official NDK one is
    the GNU Debugger also known as **GDB**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究JNI之前，有一个最后重要的工具，任何Android开发人员都需要知道如何使用：**调试器**。官方NDK调试器是GNU调试器，也称为**GDB**。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part3`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part3`的名称提供。
- en: Time for action – debugging a native Android application
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行操作-调试本地Android应用程序
- en: 'Create file `jni/Application.mk` with the following content:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`jni/Application.mk`，内容如下：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These are not the only ABIs provided by the NDK; more processor architectures
    such as MIPS or variants such as 64 bits or hard floats exist. The ones used here
    are the main ones you should be concerned with. They can easily be tested on an
    emulator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是NDK提供的唯一ABI；还有更多的处理器架构，如MIPS或64位或硬浮点等变体。这里使用的是您应该关注的主要处理器架构。它们可以很容易地在模拟器上进行测试。
- en: Open **Project Properties**, go to **C/C++ Build**, uncheck **Use default build
    command** and enter `ndk-build NDK_DEBUG=1`:![Time for action – debugging a native
    Android application](img/1529_02_06.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**项目属性**，转到**C/C++构建**，取消选中**使用默认构建命令**，输入`ndk-build NDK_DEBUG=1`：![进行操作-调试本地Android应用程序](img/1529_02_06.jpg)
- en: In `jni/com_packtpub_store_Store.cpp`, place a breakpoint inside the `Java_com_packtpub_store_Store_getCount()`method
    by double-clicking on the Eclipse editor gutter.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_store_Store.cpp`中，通过双击Eclipse编辑器的边栏，在`Java_com_packtpub_store_Store_getCount()`方法内设置断点。
- en: Select the `Store` project in the **Package Explorer** or **Project Explorer**
    view and go to **Debug As** | **Android Native Application**. The application
    starts, but you will probably find that nothing happens. Indeed, the breakpoint
    is likely to be reached before the GDB Debugger could attach to the application
    process.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Package Explorer**或**Project Explorer**视图中选择`Store`项目，然后转到**Debug As** |
    **Android Native Application**。应用程序启动，但您可能会发现没有任何反应。实际上，断点很可能会在GDB调试器附加到应用程序进程之前被触发。
- en: Leave the application and reopen it from your device application menu. This
    time, Eclipse stops at the native breakpoint. Look at your device screen. The
    UI should be frozen because the main application thread is paused in native code.![Time
    for action – debugging a native Android application](img/1529_02_08.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设备应用程序菜单中离开应用程序并重新打开它。这次，Eclipse会在本地断点处停止。看看你的设备屏幕。UI应该被冻结，因为主应用程序线程在本地代码中暂停。![执行操作-调试本地Android应用程序](img/1529_02_08.jpg)
- en: Inspect variables in the **Variables** view and check the call stack in the
    **Debug** view. In the **Expressions** view, enter `*pEnv.functions` and open
    result expression to see the various functions provided by the `JNIEnv` object.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Variables**视图中检查变量，并在**Debug**视图中检查调用堆栈。在**Expressions**视图中，输入`*pEnv.functions`并打开结果表达式，以查看`JNIEnv`对象提供的各种函数。
- en: '**Step Over** current instruction from the Eclipse toolbar or with the shortcut,
    *F6* (you can also use **Step Into** with the shortcut, *F7*). The following instructions
    will be highlighted:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Eclipse工具栏或快捷键*F6*（也可以使用**Step Into**快捷键*F7*）中**跳过**当前指令。以下指令将被突出显示：
- en: '**Resume** the execution from the Eclipse toolbar or with the shortcut, *F8*.
    The application screen is displayed on your device again.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Eclipse工具栏或快捷键*F8*中**恢复**执行。应用程序屏幕再次显示在您的设备上。
- en: '**Terminate** the application from the Eclipse toolbar or with the shortcut,
    *Ctrl*+*F2*. The application is killed and the **Debug** view is emptied.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**应用程序从Eclipse工具栏或快捷键*Ctrl*+*F2*。应用程序被终止，**Debug**视图被清空。'
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: This useful productivity tool that is a debugger is now an asset in our toolbox.
    We can easily stop or resume program execution at any point, step into, over or
    out of native instructions, and inspect any variable. This ability is made available
    to developers thanks to NDK-GDB, which is a wrapper script around the command-line
    debugger GDB (which can be cumbersome to use by hand). Hopefully, GDB is supported
    by Eclipse CDT and by extension Eclipse ADT.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有用的生产工具，即调试器，现在是我们工具箱中的一个资产。我们可以轻松地在任何点停止或恢复程序执行，步入、跳过或跳出本地指令，并检查任何变量。这种能力是由NDK-GDB提供给开发人员的，它是围绕命令行调试器GDB的包装脚本（手动使用可能很麻烦）。希望GDB得到Eclipse
    CDT和扩展Eclipse ADT的支持。
- en: On Android, and more generally on embedded devices, GDB is configured in client/server
    mode, while a program runs on a device as a server (`gdbserver`, which is generated
    by NDK-Build in the `libs` directory). A remote client, that is, a developer's
    workstation with Eclipse, connects and sends remote debugging commands to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，更一般地说，在嵌入式设备上，GDB以客户端/服务器模式配置，而程序在设备上作为服务器运行（由NDK-Build在`libs`目录中生成的`gdbserver`）。远程客户端，即开发人员的工作站与Eclipse连接并发送远程调试命令。
- en: Defining NDK application-wide settings
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义NDK应用程序范围的设置
- en: 'To help NDK-Build and NDK-GDB do their work, we created a new `Application.mk`
    file. This file should be considered as a global Makefile defining application-wide
    compilation settings, such as the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助NDK-Build和NDK-GDB完成它们的工作，我们创建了一个新的`Application.mk`文件。这个文件应该被视为一个全局的Makefile，定义应用程序范围的编译设置，例如以下内容：
- en: '`APP_PLATFORM`: Android API that the application targets. This information
    should be a duplication of `minSdkVersion` in the `AndroidManifest.xml` file.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PLATFORM`：应用程序目标的Android API。这个信息应该是`AndroidManifest.xml`文件中`minSdkVersion`的重复。'
- en: '`APP_ABI`: CPU architectures that the application targets. An Application Binary
    Interface specifies the binary code format (instruction set, calling conventions,
    and so on) that makes executable and library binaries. ABIs are thus strongly
    related to processors. ABI can be tweaked with additional settings such as `LOCAL_ARM_CODE`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_ABI`：应用程序目标的CPU架构。应用程序二进制接口指定了可执行文件和库二进制文件的二进制代码格式（指令集、调用约定等），与处理器密切相关。ABI可以通过附加设置进行调整，例如`LOCAL_ARM_CODE`。'
- en: 'The main ABIs that are currently supported by the Android NDK are as shown
    in the following table:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Android NDK支持的主要ABI如下表所示：
- en: '| **armeabi** | This is the default option, which should be compatible with
    all ARM devices. Thumb is a special instruction set that encodes instructions
    on 16 bits instead of 32 to improve code size (useful for devices with constrained
    memory). The instruction set is severely restricted compared to ArmEABI. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi** | 这是默认选项，应该与所有ARM设备兼容。Thumb是一种特殊的指令集，它将指令编码为16位而不是32位，以改善代码大小（对于内存受限的设备很有用）。与ArmEABI相比，指令集受到严格限制。'
- en: '| **armeabi****with LOCAL_ARM_CODE = arm** | (Or Arm v5) Should run on all
    ARM devices. Instructions are encoded on 32 bits but may be more concise than
    Thumb code. Arm v5 does not support advanced extensions such as floating point
    acceleration and is thus slower than Arm v7. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi****with LOCAL_ARM_CODE = arm** | （或Arm v5）应该在所有ARM设备上运行。指令编码为32位，但可能比Thumb代码更简洁。Arm
    v5不支持浮点加速等高级扩展，因此比Arm v7慢。'
- en: '| **armeabi-v7a** | Supports extensions such as Thumb-2 (similar to Thumb but
    with additional 32-bit instructions) and VFP, plus some optional extensions such
    as NEON. Code compiled for Arm V7 will not run on Arm V5 processors. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi-v7a** | 支持Thumb-2（类似于Thumb但具有额外的32位指令）和VFP等扩展，以及一些可选的扩展，如NEON。为Arm
    V7编译的代码将无法在Arm V5处理器上运行。'
- en: '| **armeabi-v7a-hard** | This ABI is an extension of the armeabi-v7a that supports
    hardware floats instead of soft floats. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi-v7a-hard** | 这个ABI是对armeabi-v7a的扩展，支持硬件浮点而不是软件浮点。'
- en: '| **arm64-v8a** | This is dedicated to the new 64-bit processor architecture.
    64-bit ARM processors are backward compatible with older ABIs. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **arm64-v8a** | 这是专门针对新的64位处理器架构。64位ARM处理器向后兼容旧的ABI。'
- en: '| **x86 and x86_64** | For "PC-like" processor architectures (that is, Intel/AMD).
    These are the ABIs used on the emulator in order to get hardware acceleration
    on a PC. Although most Android devices are ARM, some of them are now X86-based.
    The x86 ABI is for 32-bit processors and x86_64 is for 64-bit processors. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **x86和x86_64** | 用于“类似PC”的处理器架构（即英特尔/AMD）。这些是在模拟器上使用的ABI，以便在PC上获得硬件加速。尽管大多数Android设备都是ARM架构，但其中一些现在是基于X86的。x86
    ABI用于32位处理器，x86_64用于64位处理器。|'
- en: '| **mips and mips 64** | For processors made by MIPS Technologies, now property
    of Imagination Technologies well-known for the PowerVR graphics processors. Almost
    no device uses these at the time of writing this book. The mips ABI is for 32-bit
    processors and mips64 is for 64-bit processors. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **mips和mips 64** | 用于MIPS Technologies制造的处理器，现在归Imagination Technologies所有，以其PowerVR图形处理器而闻名。在撰写本书时，几乎没有设备使用这些。mips
    ABI用于32位处理器，mips64用于64位处理器。'
- en: '| **all, all32 and all64** | This is a shortcut to build an ndk library for
    all 32-bit or 64-bit ABIs. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **all, all32和all64** | 这是一个快捷方式，用于为所有32位或64位ABI构建ndk库。'
- en: Each library and intermediate object file is recompiled for each ABI. They are
    stored in their own respective directory which can be found in the `obj` and `libs`
    folders.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库和中间对象文件都会为每个ABI重新编译。它们存储在自己的目录中，可以在`obj`和`libs`文件夹中找到。
- en: A few more flags can be used inside `Application.mk`. We will discover more
    about this in detail in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries
    to Android"), *Porting Existing Libraries to Android*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.mk`中可以使用更多的标志。我们将在[第9章](ch09.html "第9章 移植现有库到Android")中详细了解更多关于这个的内容，*将现有库移植到Android*。
- en: The `Application.mk` flags are not the only ones necessary to ensure the NDK
    debugger work; `NDK_DEBUG=1` must also be passed manually to NDK-Build so that
    it compiles Debug binaries and generates GDB setup files (`gdb.setup` and `gdbserver`)
    correctly. Note that this should probably be considered more as a defect in Android
    development tools rather than a real configuration step, since it should normally
    handle the debugging flag automatically.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`标志不是确保NDK调试器工作所必需的唯一标志；还必须手动传递`NDK_DEBUG=1`给NDK-Build，以便它正确地编译调试二进制文件并生成GDB设置文件（`gdb.setup`和`gdbserver`）。请注意，这可能更应该被视为Android开发工具中的一个缺陷，而不是一个真正的配置步骤，因为它应该自动处理调试标志。'
- en: NDK-GDB day-to-day
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NDK-GDB日常
- en: Debugger support in the NDK and Eclipse is quite recent and has improved a lot
    among NDK releases (for example, debugging purely native threads was not working
    before). However, although it is now quite usable, debugging on Android can sometimes
    be buggy, unstable, and rather slow (because it needs to communicate with the
    remote Android device).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: NDK和Eclipse中的调试器支持是相当新的，并且在NDK的发布中得到了很大的改进（例如，在之前无法正常工作的纯本地线程调试）。然而，尽管现在它已经相当可用，但在Android上调试有时可能会出现错误、不稳定和相当慢（因为它需要与远程Android设备通信）。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: NDK-GDB might sometimes appear crazy and stop at a breakpoint with a completely
    unusual stack trace. This could be related to GDB not being able to correctly
    determine current ABI while debugging. To fix this issue, put only your corresponding
    device ABI in the `APP_ABI` clause and remove or comment any other.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: NDK-GDB有时可能会看起来很疯狂，并在完全不寻常的堆栈跟踪处停在断点上。这可能与GDB无法正确确定当前ABI而进行调试有关。为了解决这个问题，在`APP_ABI`子句中只放入对应的设备ABI，并删除或注释掉其他的。
- en: 'NDK Debugger can also be tricky to use, such as when debugging native startup
    code. Indeed, GDB does not start fast enough to activate breakpoints. A simple
    way to overcome this problem is to make native code sleep for a few seconds when
    an application starts. To leave GDB enough time to attach an application process,
    we can do, for example, the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: NDK调试器在使用时也可能会很棘手，比如在调试本地启动代码时。事实上，GDB启动速度不够快，无法激活断点。克服这个问题的一个简单方法是在应用程序启动时让本地代码休眠几秒钟。为了给GDB足够的时间来附加应用程序进程，我们可以做如下操作：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another solution is to launch a Debug session and then simply leave and re-launch
    the application from your device, as we have seen in the previous tutorial. This
    is possible because the Android application life cycle is such that an application
    survives when it is in the background, until the memory is needed. This trick
    only works if your application does not crash during startup though.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是启动调试会话，然后简单地离开并从设备上重新启动应用程序，就像我们在之前的教程中看到的那样。这是可能的，因为Android应用程序的生命周期是这样的，当应用程序在后台时会保持存活，直到需要内存。不过，这个技巧只有在应用程序启动时不崩溃时才有效。
- en: Analyzing native crash dumps
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析本地崩溃转储
- en: 'Every developer has one day experienced an unexpected crash in its application.
    Do not be ashamed, it has happened to all of us. And as a newcomer in Android
    native development, this situation will happen again, many times. Debuggers are
    a tremendous tool to look for problems in your code. Sadly, however they work
    in "real-time", when a program runs. They become sterile with fatal bugs that
    cannot be reproduced easily. Hopefully, there is a tool for that: **NDK-Stack**.
    NDK-Stack helps you read a crash dump to analyze an application''s stack-trace
    at the moment it crashed.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发人员都曾经经历过应用程序意外崩溃的情况。不要感到羞愧，这种情况发生在我们所有人身上。作为Android本地开发的新手，这种情况将再次发生，很多次。调试器是在代码中寻找问题的绝佳工具。然而，它们在程序运行时是“实时”工作的。它们对于无法轻松重现的致命错误变得无能为力。幸运的是，有一个工具可以解决这个问题：**NDK-Stack**。NDK-Stack帮助您读取崩溃转储，以分析应用程序在崩溃时的堆栈跟踪。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Crash`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Crash`的名称提供。
- en: Time for action – analyzing a native crash dump
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-分析本地崩溃转储
- en: 'Let''s make our application crash to see how to read a crash dump:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让我们的应用程序崩溃，看看如何读取崩溃转储：
- en: 'Simulate a fatal bug in `jni/com_packtpub_store_Store.cpp`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟`jni/com_packtpub_store_Store.cpp`中的致命错误：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open the **LogCat** view in Eclipse, select the **All Messages (no filter)**
    option, and then run the application. A crash dump appears in the logs. This is
    not pretty! If you look carefully through it, you should find a `backtrace` section
    with a snapshot of the call-stack at the moment the application crashed. However,
    it does not give the line of code involved:![Time for action – analyzing a native
    crash dump](img/1529_02_07.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**LogCat**视图，选择**所有消息（无过滤器）**选项，然后运行应用程序。崩溃转储将出现在日志中。这不太好看！如果仔细查看，您应该会发现一个带有应用程序崩溃时调用堆栈快照的`backtrace`部分。但它不会给出涉及的代码行：![Time
    for action – analyzing a native crash dump](img/1529_02_07.jpg)
- en: 'From a command-line prompt, go to the project directory. Find the line of code
    implied in the crash by running NDK-Stack with `logcat` as the input. NDK-Stack
    needs the `obj` files corresponding to the device ABI on which the application
    crashed, for example:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行提示符，转到项目目录。通过使用`logcat`作为输入运行NDK-Stack来找到崩溃中涉及的代码行。NDK-Stack需要与应用程序崩溃的设备ABI对应的`obj`文件，例如：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Time for action – analyzing a native crash dump](img/1529_02_09.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – analyzing a native crash dump](img/1529_02_09.jpg)'
- en: '*What just happened?*'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: NDK-Stack utility provided with the Android NDK can help you locate the source
    of an application crash. This tool is an inestimable help and should be considered
    as your first-aid kit when a bad crash happens. However, if it can point you toward
    the *where*, it is another kettle of fish to find out the *why*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK提供的NDK-Stack实用程序可以帮助您定位应用程序崩溃的源头。当发生严重崩溃时，此工具是无法估量的帮助，并且应该被视为您的急救工具包。然而，如果它可以指向*何处*，找出*为什么*就是另一回事了。
- en: '**Stack-trace** is only a small part of a crash dump. Deciphering the rest
    of a dump is rarely necessary but understanding its meaning is good for general
    culture.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**只是崩溃转储的一小部分。解析转储的其余部分很少是必要的，但了解其含义对于一般文化是有好处的。'
- en: Deciphering crash dumps
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析崩溃转储
- en: 'Crash dumps are not only dedicated to overly talented developers seeing a red-dressed
    girl in binary code, but also to those who have a minimum knowledge of assemblers
    and the way processors work. The goal of this trace is to give as much information
    as possible on the current state of the program at the time it crashed. It contains:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃转储不仅适用于过于有才华的开发人员在二进制代码中看到穿着红衣的女孩，也适用于那些对汇编语言和处理器工作方式有最基本了解的人。此跟踪的目标是在程序崩溃时尽可能提供关于程序当前状态的信息。它包括：
- en: '1st line: **Build Fingerprint** is a kind of identifier indicating the device/Android
    release currently running. This information is interesting when analyzing dumps
    from various origins.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行：**构建指纹**是一种标识符，指示当前运行的设备/Android版本。在分析来自各种来源的转储时，此信息很有趣。
- en: '3rd line: The **PID** or process identifier uniquely identifies an application
    on the Unix system, and the **TID**, which is the thread identifier. The thread
    identifier can be the same as the process identifier when a crash occurs on the
    main thread.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3行：**PID**或进程标识符在Unix系统上唯一标识应用程序，**TID**是线程标识符。当主线程发生崩溃时，线程标识符可以与进程标识符相同。
- en: '4th line: The crash origin represented as a **Signal** is a classic segmentation
    fault (**SIGSEGV**).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4行：以**信号**表示的崩溃源是经典的分段错误（**SIGSEGV**）。
- en: '**Processor Register** values. A register holds values or pointers on which
    the processor can work immediately.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器寄存器**值。寄存器保存处理器可以立即处理的值或指针。'
- en: '**Backtrace** (that is the stack-trace) with the method calls that lead to
    the crash.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回溯**（即堆栈跟踪）以导致崩溃的方法调用。'
- en: '**Raw stack** is similar to the backtrace but with stack parameters and variables.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始堆栈**类似于回溯，但带有堆栈参数和变量。'
- en: Some **Memory Words** around the main register (provided for ARM processors
    only). The first column indicates memory-line locations, while others columns
    indicate memory values represented in hexadecimal.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主寄存器周围的一些**内存字**（仅适用于ARM处理器）。第一列表示内存行位置，而其他列表示以十六进制表示的内存值。
- en: 'Processor registers are different between processor architectures and versions.
    ARM processors provide:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器寄存器在处理器架构和版本之间是不同的。 ARM处理器提供：
- en: '| **rX** | **Integer Registers** where a program puts values it works on. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **rX** | **整数寄存器**，程序放置其正在处理的值。 |'
- en: '| **dX** | **Floating Point Registers** where a program puts values it works
    on. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **dX** | **浮点寄存器**，程序放置其正在处理的值。 |'
- en: '| **fp (or r11)** | **Frame Pointer** holds the current stack frame location
    during a routine call (in conjunction with the Stack Pointer). |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **fp（或r11）** | **帧指针** 在例程调用期间保存当前堆栈帧位置（与堆栈指针一起）。 |'
- en: '| **ip (or r12)** | **Intra Procedure Call Scratch Register** may be used with
    some sub-routine calls; for example, when the linker needs a veneer (a small piece
    of code) to aim at a different memory area when branching. Indeed, a branch instruction
    to jump somewhere else in memory requires an offset argument relative to the current
    location, allowing a branching range of a few MB only, not the full memory. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **ip（或r12）** | **程序内调用暂存寄存器** 可能与某些子例程调用一起使用；例如，当链接器需要一个缀片（一小段代码）瞄准不同的内存区域时。实际上，跳转到内存中的其他位置的分支指令需要相对于当前位置的偏移参数，允许跳转范围仅为几MB，而不是整个内存。'
- en: '| **sp (or r13)** | **Stack Pointer** holds the location of the top of the
    stack. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **sp（或r13）** | **堆栈指针** 保存堆栈顶部的位置。 |'
- en: '| **lr (or r14)** | **Link Register** saves a program counter value temporarily
    so that it can restore it later. A typical example of its use is as a function
    call, which jumps somewhere in the code and then goes back to its previous location.
    Of course, several chained sub-routine calls require the Link Register to be stacked.
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **lr（或r14）** | **链接寄存器** 临时保存程序计数器的值，以便以后可以恢复它。其典型用法是作为函数调用，它跳转到代码中的某个位置，然后返回到先前的位置。当然，多个链接的子例程调用需要将链接寄存器堆叠。'
- en: '| **pc (or r15)** | **Program Counter** holds the address of the next instruction
    to be executed. The program counter is just incremented when executing a sequential
    code to fetch the next instruction but it is altered by branching instructions
    (if/else, a C/C++ function calls, and so on). |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **pc（或r15）** | **程序计数器**保存下一条指令的地址。程序计数器在执行顺序代码以获取下一条指令时只是递增，但它会被分支指令（if/else，C/C++函数调用等）改变。
    |'
- en: '| **cpsr** | **Current Program Status Register** contains a few flags about
    the current processor working mode and some additional bit flags for condition
    codes (such as N for an operation that resulted in a negative value, Z for a 0
    or equality result, and so on), interrupts, and instruction sets (Thumb or ARM).
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **cpsr** | **当前程序状态寄存器**包含有关当前处理器工作模式的一些标志，以及一些附加的条件代码位标志（例如对于产生负值的操作为N，对于0或相等结果为Z等），中断和指令集（Thumb或ARM）。
    |'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that the use of registers is mainly a convention. For example, Apple
    iOS uses `r7` as a Frame Pointer instead of `r12` on ARMs. So always be very careful
    when writing or reusing assembly code!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，寄存器的使用主要是一种约定。例如，苹果iOS使用`r7`作为帧指针，而不是在ARM上使用`r12`。因此，在编写或重用汇编代码时一定要非常小心！
- en: 'On the other hand, X86 processors provide:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，X86处理器提供：
- en: '| **eax** | **Accumulator Register** is used, for example, for arithmetic or
    I/O operations. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **eax** | **累加器寄存器**用于算术或I/O操作。 |'
- en: '| **ebx** | **Base Register** is a data pointer for memory access. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **ebx** | **基寄存器**是用于内存访问的数据指针。 |'
- en: '| **ecx** | **Counter Register** is used for iterative operations such as loop
    counter. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **ecx** | **计数器寄存器**用于迭代操作，例如循环计数器。 |'
- en: '| **edx** | **Data Register** is a secondary Accumulator Register used in conjunction
    with `eax`. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **edx** | **数据寄存器**是与`eax`一起使用的辅助累加器寄存器。 |'
- en: '| **esi** | **Source Index Register** is used for memory array copying in conjunction
    with `edi`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **esi** | **源索引寄存器**用于与`edi`一起进行内存数组复制。 |'
- en: '| **edi** | **Destination Index Register** is used for memory array copying
    in conjunction with `esi`. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **edi** | **目的索引寄存器**用于与`esi`一起进行内存数组复制。 |'
- en: '| **eip** | **Instruction Pointer** holds offset of the next instruction. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **eip** | **指令指针**保存下一条指令的偏移量。 |'
- en: '| **ebp** | **Base Pointer** holds the current stack frame location during
    a routine call (in conjunction with the Stack Pointer). |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **ebp** | **基指针**在例程调用期间保存当前堆栈帧的位置（与堆栈指针一起）。 |'
- en: '| **esp** | **Stack Pointer** holds the location of the top of the stack. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **esp** | **堆栈指针**保存堆栈顶部的位置。 |'
- en: '| **xcs** | **Code Segment** helps in addressing the memory segment in which
    the program runs. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **xcs** | **代码段**有助于寻址程序运行的内存段。 |'
- en: '| **xds** | **Data Segment** helps addressing a data memory segment. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **xds** | **数据段**有助于寻址数据内存段。 |'
- en: '| **xes** | **Extra Segment** is an additional register to address a memory
    segment. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **xes** | **额外段**是用于寻址内存段的附加寄存器。 |'
- en: '| **xfs** | **Additional Segment** which is a general purpose data segment.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **xfs** | **附加段**是一个通用数据段。 |'
- en: '| **xss** | **Stack segment** holds the Stack memory segment. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **xss** | **堆栈段**保存堆栈内存段。 |'
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Many X86 registers are a **legacy**, which means that they lost the initial
    purpose they were created for. Take their descriptions with some caution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多X86寄存器都是**遗留**的，这意味着它们失去了最初创建的目的。对它们的描述要谨慎对待。
- en: Deciphering stack-traces is not an easy task and requires time and expertise.
    Don't bother too much if you do not understand every part of it yet. This is necessary
    as a last resort only.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 解密堆栈跟踪并不是一项容易的任务，需要时间和专业知识。如果您尚未完全理解其中的每个部分，不要太过担心。这只是最后的手段。
- en: Setting up a Gradle project to compile native code
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Gradle项目以编译本机代码
- en: Android Studio is now the new officially supported Android IDE, in place of
    Eclipse. It comes with **Gradle**, which is the new official Android build system.
    Gradle introduces a Groovy-based specific language to define the project configuration
    easily. Although its support of the NDK is still preliminary, it keeps improving
    and is becoming more and more useable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio现在是新的官方支持的Android IDE，取代了Eclipse。它配备了**Gradle**，这是新的官方Android构建系统。Gradle引入了一种基于Groovy的特定语言，以便轻松定义项目配置。尽管其对NDK的支持仍处于初步阶段，但它不断改进，变得越来越可用。
- en: Let's now see how to create an Android Studio project with Gradle that compiles
    native code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Gradle创建一个Android Studio项目，该项目可以编译本机代码。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Gradle_Auto`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Gradle_Auto`的名称提供。
- en: Time for action – creating a native Android project
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作-创建本机Android项目
- en: 'Gradle-based projects can be created easily through Android Studio:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Gradle的项目可以通过Android Studio轻松创建：
- en: Launch Android Studio. On the welcome screen, select **New Project…** (or go
    to **File** | **New Project…** if a project is already opened).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Android Studio。在欢迎屏幕上，选择**新项目…**（或转到**文件** | **新项目…**如果已经打开了项目）。
- en: From the **New Project** wizard, enter the following configuration and click
    on **Next**:![Time for action – creating a native Android project](img/1529_02_51.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**新项目**向导中，输入以下配置并点击**下一步**：![执行操作-创建本机Android项目](img/1529_02_51.jpg)
- en: 'Then, select the minimum SDK (for example, API 14: Ice Scream Sandwich) and
    click on **Next**.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择最低的SDK（例如API 14：冰淇淋三明治）并点击**下一步**。
- en: Select **Blank Activity with Fragment** and click on **Next**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**带片段的空白活动**，然后点击**下一步**。
- en: Finally, enter **Activity Name** and **Layout Name** names as follows and click
    on **Finish**:![Time for action – creating a native Android project](img/1529_02_52.jpg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输入**Activity Name**和**Layout Name**名称如下，然后点击**完成**：![执行操作-创建本机Android项目](img/1529_02_52.jpg)
- en: Android Studio should then open the project:![Time for action – creating a native
    Android project](img/1529_02_55.jpg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后Android Studio应该打开项目：![执行操作-创建本机Android项目](img/1529_02_55.jpg)
- en: Modify `StoreActivity.java` and create `Store.java` in the same way as we did
    in the *Interfacing Java with C/C++* section in this chapter (Step 1 and 2).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`StoreActivity.java`并以与本章*将Java与C/C++接口*部分相同的方式创建`Store.java`（步骤1和2）。
- en: Create the `app/src/main/jni` directory. Copy the C and Header files we created
    in the *Interfacing Java with C/C++* section in this chapter (Step 4 and 5).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`app/src/main/jni`目录。将我们在本章*将Java与C/C++接口*部分中创建的C和头文件复制进去（步骤4和5）。
- en: 'Edit `app/build.gradle` that has been generated by Android Studio. In `defaultConfig`,
    insert a `ndk` section to configure the module (that is, a library) name:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑由Android Studio生成的`app/build.gradle`。在`defaultConfig`中，插入一个`ndk`部分来配置模块（即库）名称：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and install the project on your device by clicking on **installDebug**
    in the **Gradle tasks** view of Android Studio.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Android Studio的**Gradle任务**视图中单击**installDebug**来编译并安装项目到您的设备。
- en: Tip
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If Android Studio complains that it cannot find the NDK, make sure the `local.properties`
    file in the project's root directory contains both `sdk.dir` and `ndk.dir` properties
    that can point to your Android SDK and NDK location.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Android Studio抱怨找不到NDK，请确保项目根目录中的`local.properties`文件包含`sdk.dir`和`ndk.dir`属性，这些属性可以指向您的Android
    SDK和NDK位置。
- en: '*What just happened?*'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created our first Android Studio project that compiles native code through
    Gradle. NDK properties are configured in a section specific to `ndk` in the `build.gradle`
    file (for example, the module name).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的第一个Android Studio项目，通过Gradle编译本机代码。 NDK属性在`build.gradle`文件的`ndk`部分（例如，模块名称）中进行了配置。
- en: 'Multiple settings are available as shown in the following table:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如下表所示，有多个设置可用：
- en: '| Property | Description |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **abiFilter** | The list of ABIs to compile for; by default, all. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **abiFilter** | 要编译的ABI列表；默认情况下为全部。 |'
- en: '| **cFlags** | Custom flags to pass to the compiler. More about this in [Chapter
    9](ch09.html "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing
    Libraries to Android*. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **cFlags** | 自定义标志传递给编译器。有关更多信息，请参阅[第9章](ch09.html "第9章。将现有库移植到Android")，“将现有库移植到Android”。
    |'
- en: '| **ldLibs** | Custom flags to pass to the linker. More about this in [Chapter
    9](ch09.html "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing
    Libraries to Android*. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **ldLibs** | 自定义标志传递给链接器。有关更多信息，请参阅[第9章](ch09.html "第9章。将现有库移植到Android")，“将现有库移植到Android”。
    |'
- en: '| **moduleName** | This is the name of the module to be built. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **moduleName** | 这是要构建的模块的名称。 |'
- en: '| **stl** | This is the STL library to use for compilation. More about this
    in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **stl** | 这是用于编译的STL库。有关更多信息，请参阅[第9章](ch09.html "第9章。将现有库移植到Android")，“将现有库移植到Android”。
    |'
- en: You might have noticed that we have not reused the `Android.mk` and `Application.mk`
    files. This is because Gradle generates the build files automatically if given
    an input to `ndk-build` at compilation time. In our example, you can see the generated
    `Android.mk` for the `Store` module in the `app/build/intermediates/ndk/debug`
    directory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们没有重用`Android.mk`和`Application.mk`文件。这是因为如果在编译时向`ndk-build`提供输入，Gradle会自动生成构建文件。在我们的示例中，您可以在`app/build/intermediates/ndk/debug`目录中看到为`Store`模块生成的`Android.mk`。
- en: NDK automatic Makefile generation makes it easy to compile native NDK code on
    simple projects. However, if you want more control on your native build, you can
    create your own Makefiles like the ones created in the Interfacing Java with C/C++
    section in this chapter. Let's see how to do this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: NDK自动生成Makefile使得在简单项目上编译本机NDK代码变得容易。但是，如果您想对本机构建进行更多控制，可以创建自己的Makefile，就像在本章的*将Java与C/C++接口*部分中创建的那样。让我们看看如何做到这一点。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Gradle_Manual`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Gradle_Manual`的名称提供。
- en: Time for action – using your own Makefiles with Gradle
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动-使用自己的Makefile与Gradle
- en: 'Using your own handmade makefiles with Gradle is a bit tricky but not too complicated:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自己手工制作的Makefile与Gradle有点棘手，但并不太复杂：
- en: Copy the `Android.mk` and `Application.mk` files we created in the *Interfacing
    Java with C/C++* section in this chapter into the `app/src/main/jni` directory.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在本章*将Java与C/C++接口*部分中创建的`Android.mk`和`Application.mk`文件复制到`app/src/main/jni`目录中。
- en: Edit `app/build.gradle`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`app/build.gradle`。
- en: 'Add an import for the `OS` "Class" and remove the first `ndk` section we created
    in the previous section:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`OS`“Class”的导入，并删除我们在上一节中创建的第一个`ndk`部分：
- en: '[PRE22]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Still in the android section of `app/build.gradle`., insert a `sourceSets.main`
    section with the following:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`app/build.gradle`的android部分。在`sourceSets.main`部分插入以下内容：
- en: '`jniLibs.srcDir`, which defines where Gradle will find the generated libraries.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jniLibs.srcDir`，定义Gradle将查找生成的库的位置。'
- en: '`jni.srcDirs`, which is set to an empty array to disable native code compilation
    through Gradle.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jni.srcDirs`，设置为空数组以通过Gradle禁用本机代码编译。'
- en: '[PRE23]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, create a new Gradle task `ndkBuild` that will manually trigger the
    `ndk-build` command, specifying the custom directory `src/main` as the compilation
    directory.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的Gradle任务`ndkBuild`，它将手动触发`ndk-build`命令，并指定自定义目录`src/main`作为编译目录。
- en: 'Declare a dependency between the `ndkBuild` task and the Java compilation task
    to automatically trigger native code compilation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`ndkBuild`任务与Java编译任务之间的依赖关系，以自动触发本机代码编译：
- en: '[PRE24]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compile and install the project on your device by clicking on **installDebug**
    in the **Gradle tasks** view of Android Studio.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Android Studio的**Gradle任务**视图中单击**installDebug**来编译并安装项目到您的设备。
- en: '*What just happened?*'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The Makefile generation and native source compilation performed by the Android
    Gradle plugin can easily be disabled. The trick is to simply indicate that no
    native source directory is available. We can then use the power of Gradle, which
    allows defining easily custom build tasks and dependencies between them, to execute
    the `ndk-build` command. This trick allows using our own NDK makefiles, giving
    us more flexibility in the way we build native code.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Android Gradle插件执行的Makefile生成和本地源代码编译可以很容易地被禁用。诀窍就是简单地指示没有可用的本地源代码目录。然后我们可以利用Gradle的强大功能，轻松定义自定义构建任务和它们之间的依赖关系，来执行`ndk-build`命令。这个技巧允许我们使用自己的NDK
    makefiles，使我们在构建本地代码的方式上更加灵活。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Creating, compiling, building, packaging, and deploying an application project
    are not the most exciting tasks, but they cannot be avoided. Mastering them will
    allow you to be productive and focused on the real objective: **producing code**.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、编译、构建、打包和部署应用项目并不是最令人兴奋的任务，但是它们是必不可少的。掌握它们将使你能够高效地专注于真正的目标：**编写代码**。
- en: In summary, we built our first sample application using command-line tools and
    deploying it on an Android device. We also created our first native Android project
    using Eclipse and interfaced Java with C/C++ using Java Native Interfaces. We
    debugged a native Android application with NDK-GDB and analyzed a native crash
    dump to find its origin in the source code. Finally, we created a similar project
    using Android Studio and built it with Gradle.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们使用命令行工具构建了我们的第一个示例应用，并将其部署到了Android设备上。我们还使用Eclipse创建了我们的第一个本地Android项目，并使用Java
    Native Interfaces将Java与C/C++进行了接口。我们使用NDK-GDB调试了一个本地Android应用，并分析了本地崩溃转储以找到其在源代码中的起源。最后，我们使用Android
    Studio创建了一个类似的项目，并使用Gradle进行了构建。
- en: This first experiment with the Android NDK gives you a good overview of the
    way native development works. In the next chapter, we are going to focus on the
    code and dive more deeply into the JNI protocol.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个与Android NDK的第一个实验为你提供了一个很好的概述，展示了本地开发的工作方式。在下一章中，我们将专注于代码，并深入研究JNI协议。
