- en: '05'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '05'
- en: Building Your Own Types with Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程构建自己的类型
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP** ). You will learn about all the different categories of members that
    a type can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, out variables, inferred
    tuple names, and default literals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用**面向对象编程**（**OOP**）创建自己的类型。您将了解类型可以具有的所有不同类别的成员，包括用于存储数据的字段和执行操作的方法。您将使用面向对象编程的概念，如聚合和封装。您还将了解语言功能，如元组语法支持、输出变量、推断的元组名称和默认文字。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Talking about OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谈论面向对象编程
- en: Building class libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建类库
- en: Storing data with fields
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字段存储数据
- en: Writing and calling methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和调用方法
- en: Controlling access with properties and indexers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和索引器控制访问
- en: Pattern matching with objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的模式匹配
- en: Working with records
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录
- en: Talking about OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谈论面向对象编程
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but this can also be something more abstract.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的对象是一种事物，比如汽车或人，而编程中的对象通常代表现实世界中的某些东西，比如产品或银行账户，但这也可以是更抽象的东西。
- en: In C#, we use the `class` (mostly) or `struct` (sometimes) C# keywords to define
    a type of object. You will learn about the difference between classes and structs
    in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* . You can think
    of a type as being a blueprint or template for an object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们使用`class`（大多数情况）或`struct`（有时）关键字来定义对象的类型。您将在*第6章*中了解类和结构之间的区别，*实现接口和继承类*。您可以将类型视为对象的蓝图或模板。
- en: 'The concepts of OOP are briefly described here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要描述了面向对象编程的概念：
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName` , as well as actions, such as `Deposit` and `Withdraw` . When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**是与对象相关的数据和操作的组合。例如，`BankAccount`类型可能具有数据，如`Balance`和`AccountName`，以及操作，如`Deposit`和`Withdraw`。在封装时，您通常希望控制可以访问这些操作和数据的内容，例如，限制外部如何访问或修改对象的内部状态。'
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine` .'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**是关于对象由什么组成。例如，`Car`由不同的部分组成，如四个`Wheel`对象，几个`Seat`对象和一个`Engine`。'
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver''s
    `Seat` and then become the car''s `Driver` —two separate objects that are aggregated
    together to form a new component.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**是关于可以与对象组合的内容。例如，`Person`不是`Car`对象的一部分，但他们可以坐在驾驶座上，然后成为汽车的`Driver`——两个单独的对象聚合在一起形成一个新的组件。'
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass** . All functionality in the base class is inherited
    by and becomes available in the **derived** class. For example, the base or super
    `Exception` class has some members that have the same implementation across all
    exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members only relevant to when a SQL database exception occurs, like
    a property for the database connection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**是通过让**子类**从**基类**或**超类**派生代码来重用代码。基类中的所有功能都被派生类继承并在派生类中可用。例如，基类或超`Exception`类具有一些成员，这些成员在所有异常中具有相同的实现，而子类或派生`SqlException`类继承这些成员，并具有仅在发生SQL数据库异常时相关的额外成员，比如数据库连接的属性。'
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept.
    If a class is not explicitly **abstract** , then it can be described as being
    **concrete** . Base or superclasses are often abstract, for example, the superclass
    `Stream` is abstract, and its subclasses, like `FileStream` and `MemoryStream`
    , are concrete. Only concrete classes can be used to create objects; abstract
    classes can only be used as the base for other classes because they are missing
    some implementation. Abstraction is a tricky balance. If you make a class more
    abstract, more classes will be able to inherit from it, but at the same time,
    there will be less functionality to share.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**是捕捉对象的核心思想并忽略细节或具体内容。C#有`abstract`关键字来正式化这个概念。如果一个类没有明确的**abstract**，那么它可以被描述为**具体**。基类或超类通常是抽象的，例如，超类`Stream`是抽象的，它的子类，如`FileStream`和`MemoryStream`，是具体的。只有具体类才能用来创建对象；抽象类只能用作其他类的基础，因为它们缺少一些实现。抽象是一个棘手的平衡。如果你使一个类更抽象，更多的类将能够从它继承，但与此同时，将会有更少的功能可共享。'
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性是允许派生类覆盖继承的操作以提供自定义行为。
- en: Building class libraries
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建类库
- en: Class library assemblies group types together into easily deployable units (DLL
    files). Apart from when you learned about unit testing, you have only created
    console applications or .NET Interactive notebooks to contain your code. To make
    the code that you write reusable across multiple projects, you should put it in
    class library assemblies, just like Microsoft does.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类库程序集将类型组合成易于部署的单元（DLL文件）。除了学习单元测试时，您只创建了控制台应用程序或.NET交互式笔记本来包含您的代码。为了使您编写的代码可以在多个项目中重用，您应该将其放入类库程序集中，就像微软一样。
- en: Creating a class library
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类库
- en: 'The first task is to create a reusable .NET class library:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建一个可重用的.NET类库：
- en: 'Use your preferred coding tool to create a new class library, as defined in
    the following list:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个新的类库，如下列表所示：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter05`'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter05`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Open the `PacktLibrary.csproj` file, and note that by default class libraries
    target .NET 6 and therefore can only work with other .NET 6-compatible assemblies,
    as shown in the following markup:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PacktLibrary.csproj` 文件，并注意默认情况下类库的目标是.NET 6，因此只能与其他.NET 6兼容的程序集一起使用，如下标记的部分所示：
- en: '```cs'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <TargetFramework>net6.0
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>enable</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: </Project>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Modify the framework to target .NET Standard 2.0 and remove the entries that
    enable nullable and implicit usings, as shown highlighted in the following markup:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改框架以目标为.NET Standard 2.0，并删除启用可空和隐式使用的条目，如下标记的部分所示：
- en: '```cs'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: '**<TargetFramework>netstandard**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**<TargetFramework>netstandard**'
- en: '**2.0**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.0**'
- en: '**</TargetFramework>**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**</TargetFramework>**'
- en: </PropertyGroup>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: </Project>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Save and close the file.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭文件。
- en: Delete the file named `Class1.cs` .
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除名为 `Class1.cs` 的文件。
- en: 'Compile the project so that other projects can reference it later:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目，以便其他项目以后可以引用它：
- en: 'In Visual Studio Code, enter the following command: `dotnet build` .'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，输入以下命令：`dotnet build`。
- en: In Visual Studio, navigate to **Build** | **Build PacktLibrary** .
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**生成** | **生成PacktLibrary**。
- en: '**Good Practice** : To use the latest C# language and .NET platform features,
    put types in a .NET 6 class library. To support legacy .NET platforms like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a.NET Standard
    2.0 class library.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了使用最新的C#语言和.NET平台功能，将类型放入.NET 6类库中。为了支持像.NET Core、.NET Framework和Xamarin这样的旧版.NET平台，将可能重用的类型放入.NET
    Standard 2.0类库中。'
- en: Defining a class in a namespace
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命名空间中定义类
- en: 'The next task is to define a class that will represent a person:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是定义一个代表人的类：
- en: Add a new class file named `Person.cs` .
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Person.cs` 的新类文件。
- en: Statically import `System.Console` .
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态导入 `System.Console`。
- en: Set the namespace to `Packt.Shared` .
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间设置为 `Packt.Shared`。
- en: '**Good Practice** : We''re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person` , `BankAccount` , and `WondersOfTheWorld`
    and they do not have a typical domain so we will use the more generic `Packt.Shared`
    .'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们这样做是因为将类放入一个逻辑命名的命名空间中很重要。一个更好的命名空间名称应该是特定于领域的，例如，`System.Numerics`
    用于与高级数字相关的类型。在这种情况下，我们将创建的类型是 `Person`，`BankAccount` 和 `WondersOfTheWorld`，它们没有典型的领域，所以我们将使用更通用的
    `Packt.Shared`。'
- en: 'Your class file should now look like the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您的类文件现在应该如下面的代码所示：
- en: '```cs'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: using
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: static
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: System.Console;
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: namespace
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Person
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: '{'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note that the C# keyword `public` is applied before class. This keyword is an
    **access modifier** , and it allows for any other code to access this class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在类之前应用了C#关键字 `public`。这个关键字是一个**访问修饰符**，它允许任何其他代码访问这个类。
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal` . We need this class to be accessible outside the assembly,
    so we must make sure it is `public` .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有明确应用 `public` 关键字，那么它只能在定义它的程序集内部访问。这是因为类的隐式访问修饰符是 `internal`。我们需要这个类在程序集外部可访问，所以我们必须确保它是
    `public`。
- en: Simplifying namespace declarations
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化命名空间声明
- en: 'To simplify your code if you are targeting .NET 6.0 and therefore using C#
    10 or later, you can end a namespace declaration with a semi-colon and remove
    the braces, as shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标是.NET 6.0，并且因此使用C# 10或更高版本，您可以在命名空间声明的末尾加上分号并删除大括号，如下面的代码所示，以简化您的代码：
- en: '```cs'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: namespace
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ; // the class in this file is in this namespace
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 此文件中的类在此命名空间中
- en: public
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Person
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: '{'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is known as a file-scoped namespace declaration. You can only have one
    file-scoped namespace per file. We will use this in a class library that targets
    .NET 6.0 later in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为文件范围的命名空间声明。您只能在一个文件中有一个文件范围的命名空间。我们将在本章后面的一个目标为.NET 6.0的类库中使用这个。
- en: '**Good Practice** : Put each type that you create in its own file so that you
    can use file-scoped namespace declarations.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：将创建的每种类型放在自己的文件中，以便您可以使用文件范围的命名空间声明。'
- en: Understanding members
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解成员
- en: 'This type does not yet have any members encapsulated within it. We will create
    some over the following pages. Members can be fields, methods, or specialized
    versions of both. You''ll find a description of them here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型目前还没有任何封装在其中的成员。我们将在接下来的页面上创建一些成员。成员可以是字段、方法或两者的专门版本。您可以在这里找到它们的描述：
- en: '**Fields** are used to store data. There are also three specialized categories
    of field, as shown in the following bullets:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段** 用于存储数据。还有三种专门的字段类别，如下面的项目所示：'
- en: '**Constant** : The data never changes. The compiler literally copies the data
    into any code that reads it.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：数据永远不会改变。编译器会将数据直接复制到读取它的任何代码中。'
- en: '**Read-only** : The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读**：在类实例化后数据不能更改，但数据可以在实例化时计算或从外部来源加载。'
- en: '**Event** : The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6* , *Implementing Interfaces
    and Inheriting Classes* .'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：数据引用一个或多个你希望在发生某些事情时执行的方法，比如点击按钮或响应来自其他代码的请求。事件将在*第6章*，*实现接口和继承类*中介绍。'
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4* , *Writing, Debugging, and Testing Functions*
    . There are also four specialized categories of method:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**用于执行语句。在*第4章*，*编写、调试和测试函数*中学习函数时，你看到了一些示例。方法还有四个专门的类别：'
- en: '**Constructor** : The statements execute when you use the `new` keyword to
    allocate memory to instantiate a class.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：当使用`new`关键字分配内存来实例化一个类时执行语句。'
- en: '**Property** : The statements execute when you get or set data. The data is
    commonly stored in a field but could be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：当获取或设置数据时执行语句。数据通常存储在字段中，但也可以存储在外部或在运行时计算。属性是封装字段的首选方式，除非需要公开字段的内存地址。'
- en: '**Indexer** : The statements execute when you get or set data using "array"
    syntax `[]` .'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引器**：当使用“数组”语法`[]`获取或设置数据时执行语句。'
- en: '**Operator** : The statements execute when you use an operator like `+` and
    `/` on operands of your type.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作符**：当在你的类型的操作数上使用操作符如`+`和`/`时执行语句。'
- en: Instantiating a class
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: In this section, we will make an instance of the `Person` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建`Person`类的一个实例。
- en: Referencing an assembly
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用一个程序集
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实例化一个类之前，我们需要从另一个项目引用包含它的程序集。我们将在控制台应用程序中使用这个类：
- en: Use your preferred coding tool to add a new console app to the `Chapter05` workspace/solution
    named `PeopleApp` .
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编码工具向`Chapter05`工作区/解决方案添加一个新的控制台应用程序，命名为`PeopleApp`。
- en: 'If you are using Visual Studio Code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用Visual Studio Code：
- en: Select `PeopleApp` as the active OmniSharp project. When you see the pop-up
    warning message saying that required assets are missing, click **Yes** to add
    them.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`PeopleApp`作为活动的OmniSharp项目。当看到弹出的警告消息说需要的资源丢失时，点击**是**来添加它们。
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibrary` , as shown
    highlighted in the following markup:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`PeopleApp.csproj`以添加对`PacktLibrary`的项目引用，如下标记中所示：
- en: '```cs'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>enable</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<ProjectReference Include=**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ProjectReference Include=**'
- en: '**"../PacktLibrary/PacktLibrary.csproj"**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**"../PacktLibrary/PacktLibrary.csproj"**'
- en: '**/>**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: </Project>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In a terminal, enter a command to compile the `PeopleApp` project and its dependency
    `PacktLibrary` project, as shown in the following command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入一个命令来编译`PeopleApp`项目及其依赖的`PacktLibrary`项目，如下命令所示：
- en: '```cs'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: dotnet build
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet build
- en: '```'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you are using Visual Studio:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用Visual Studio：
- en: Set the startup project for the solution to the current selection.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解决方案的启动项目设置为当前选择。
- en: In **Solution Explorer** , select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…** , check the box to select the `PacktLibrary` project,
    and then click **OK** .
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，选择`PeopleApp`项目，导航到**项目**|**添加项目引用…**，选中`PacktLibrary`项目的复选框，然后点击**确定**。
- en: Navigate to **Build** | **Build PeopleApp** .
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**生成**|**生成PeopleApp**。
- en: Importing a namespace to use a type
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入一个命名空间以使用类型
- en: 'Now, we are ready to write statements to work with the `Person` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备编写语句来处理`Person`类：
- en: In the `PeopleApp` project/folder, open `Program.cs` .
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目/文件夹中，打开`Program.cs`。
- en: 'At the top of the `Program.cs` file, delete the comment, and add statements
    to import the namespace for our `Person` class and statically import the `Console`
    class, as shown in the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的顶部，删除注释，并添加语句来导入我们`Person`类的命名空间并静态导入`Console`类，如下代码所示：
- en: '```cs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: Packt.Shared;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared;
- en: using
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: System.Console;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: '```'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句：
- en: Create an instance of the `Person` type.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Person`类型的一个实例。
- en: Output the instance using a textual description of itself.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出实例并使用其自身的文本描述。
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data. We could use `var` in place of the `Person` class name, but then we would
    need to specify `Person` after the `new` keyword, as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`关键字为对象分配内存并初始化任何内部数据。我们可以在`new`关键字的位置使用`var`代替`Person`类名，但然后我们需要在`new`关键字之后指定`Person`，如下代码所示：'
- en: '```cs'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // var bob = new Person(); // C# 1.0 or later
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: // var bob = new Person(); // C# 1.0 or later
- en: Person bob = new
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Person bob = new
- en: (); // C# 9.0 or later
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (); // C# 9.0 or later
- en: WriteLine(bob.ToString());
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.ToString());
- en: '```'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You might be wondering, "Why does the `bob` variable have a method named `ToString`
    ? The `Person` class is empty!" Don't worry, we're about to find out!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“为什么`bob`变量有一个名为`ToString`的方法？`Person`类是空的！”别担心，我们马上就会找出答案！
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下输出所示：
- en: '```cs'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Packt.Shared.Person
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared.Person
- en: '```'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding objects
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解对象
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object` .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的`Person`类没有明确选择从某个类型继承，但所有类型最终都直接或间接地继承自一个名为`System.Object`的特殊类型。
- en: The implementation of the `ToString` method in the `System.Object` type simply
    outputs the full namespace and type name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Object`类型中`ToString`方法的实现只是输出完整的命名空间和类型名称。'
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原始的`Person`类中，我们本可以明确告诉编译器`Person`继承自`System.Object`类型，如下面的代码所示：
- en: '```cs'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Person
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': System.Object'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ：System.Object
- en: '```'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When class B inherits from class A, we say that A is the base or superclass
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass and `Person` is the derived or subclass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当B类继承自A类时，我们说A是基类或超类，B是派生类或子类。在这种情况下，`System.Object`是基类或超类，`Person`是派生类或子类。
- en: 'You can also use the C# alias keyword `object` , as shown in the following
    code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用C#别名关键字`object`，如下面的代码所示：
- en: '```cs'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ：对象
- en: '```'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Inheriting from System.Object
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从System.Object继承
- en: 'Let''s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确地让我们的类继承自`object`，然后回顾一下所有对象都具有哪些成员：
- en: Modify your `Person` class to explicitly inherit from `object` .
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的`Person`类，明确地从`object`继承。
- en: Click inside the `object` keyword and press F12 , or right-click on the `object`
    keyword and choose **Go to Definition** .
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`object`关键字内部，然后按F12，或右键单击`object`关键字，选择**转到定义**。
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don''t need to understand the details of yet, but notice that
    it has a method named `ToString` , as shown in *Figure 5.1* :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到Microsoft定义的`System.Object`类型及其成员。这是您暂时不需要了解细节的内容，但请注意它有一个名为`ToString`的方法，如*图5.1*所示：
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00064.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件描述自动生成](img/Image00064.jpg)'
- en: 'Figure 5.1: System.Object class definition'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：System.Object类定义
- en: '**Good Practice** : Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object` .'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：假设其他程序员知道，如果没有指定继承，该类将继承自`System.Object`。'
- en: Storing data within fields
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字段内存储数据
- en: In this section, we will be defining a selection of fields in the class to store
    information about a person.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义类中的一些字段，以存储有关一个人的信息。
- en: Defining fields
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义字段
- en: Let's say that we have decided that a person is composed of a name and a date
    of birth. We will encapsulate these two values inside a person, and the values
    will be visible outside it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经决定一个人由姓名和出生日期组成。我们将把这两个值封装在一个人内部，并且这些值将对外部可见。
- en: 'Inside the `Person` class, write statements to declare two public fields for
    storing a person''s name and date of birth, as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`类内部，编写语句来声明两个公共字段，用于存储一个人的姓名和出生日期，如下面的代码所示：
- en: '```cs'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ：对象
- en: '{'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // fields
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: //字段
- en: public
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Name;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Name;
- en: public
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: DateTime DateOfBirth;
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime DateOfBirth;
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can use any type for a field, including arrays and collections such as lists
    and dictionaries. These would be used if you needed to store multiple values in
    one named field. In this example, a person only has one name and one date of birth.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何类型的字段，包括数组和集合，如列表和字典。如果您需要在一个命名字段中存储多个值，那么可以使用这些。在这个例子中，一个人只有一个姓名和一个出生日期。
- en: Understanding access modifiers
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解访问修饰符
- en: Part of encapsulation is choosing how visible the members are.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的一部分是选择成员的可见性。
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn't, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与类一样，我们明确地将`public`关键字应用于这些字段。如果我们没有这样做，那么它们将隐式地对类私有，这意味着它们只能在类内部访问。
- en: 'There are four access modifier keywords, and two combinations of access modifier
    keywords that you can apply to a class member, like a field or method, as shown
    in the following table:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个访问修饰符关键字，以及两种访问修饰符关键字的组合，你可以应用到类的成员，比如字段或方法，如下表所示：
- en: '| Access Modifier | Description |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | 描述 |'
- en: '| `private` | Member is accessible inside the type only. This is the default.
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 成员只能在类型内部访问。这是默认值。'
- en: '| `internal` | Member is accessible inside the type and any type in the same
    assembly. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '`internal` | 成员在类型内部和同一程序集中的任何类型中都可以访问。'
- en: '| `protected` | Member is accessible inside the type and any type that inherits
    from the type. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `protected` | 成员在类型内部和任何继承自该类型的类型中都可以访问。'
- en: '| `public` | Member is accessible everywhere. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 成员可以在任何地方访问。'
- en: '| `internal``protected` | Member is accessible inside the type, any type in
    the same assembly, and any type that inherits from the type. Equivalent to a fictional
    access modifier named `internal_or_protected` . |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `internal``protected` | 成员在类型内部、同一程序集中的任何类型以及继承自该类型的任何类型中都可以访问。相当于一个名为`internal_or_protected`的虚构访问修饰符。'
- en: '| `private``protected` | Member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected` . This combination is only available
    with C# 7.2 or later. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `private``protected` | 成员在类型内部和任何继承自该类型并且在同一程序集中的类型中都可以访问。相当于一个名为`internal_and_protected`的虚构访问修饰符。此组合仅适用于C#
    7.2或更高版本。'
- en: '**Good Practice** : Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private` . Additionally, fields should usually be `private` or `protected`
    , and you should then create `public` properties to get or set the field values.
    This is because it controls access. You will do this later in the chapter.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：明确地将访问修饰符应用于所有类型成员，即使您想要使用成员的隐式访问修饰符，即`private`。此外，字段通常应该是`private`或`protected`，然后您应该创建`public`属性来获取或设置字段值。这是因为它控制访问。您将在本章后面做到这一点。'
- en: Setting and outputting field values
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和输出字段值
- en: 'Now we will use those fields in your code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在您的代码中使用这些字段：
- en: At the top of `Program.cs` , make sure the `System` namespace is imported. We
    need to do this to use the `DateTime` type.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，确保导入`System`命名空间。我们需要这样做才能使用`DateTime`类型。
- en: 'After instantiating `bob` , add statements to set his name and date of birth,
    and then output those fields formatted nicely, as shown in the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`bob`后，添加语句设置他的姓名和出生日期，然后输出这些字段的格式化内容，如下面的代码所示：
- en: '```cs'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bob.Name = "Bob Smith"
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: bob.Name = "Bob Smith"
- en: ;
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: bob.DateOfBirth = new
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: bob.DateOfBirth = new
- en: DateTime(1965
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime（1965
- en: ', 12'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ，12
- en: ', 22'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ，22
- en: ); // C# 1.0 or later
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ）// C# 1.0或更高版本
- en: 'WriteLine(format: "{0} was born on {1:dddd, d MMMM yyyy}"'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "{0} was born on {1:dddd, d MMMM yyyy}"'
- en: ','
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: bob.Name,'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 参数0：bob.Name，
- en: 'arg1: bob.DateOfBirth);'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 参数1：bob.DateOfBirth);
- en: '```'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We could have used string interpolation too, but for long strings it will wrap
    over multiple lines, which can be harder to read in a printed book. In the code
    examples in this book, remember that `{0}` is a placeholder for `arg0` , and so
    on.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符串插值，但对于长字符串，它会跨多行，这在打印的书中可能更难阅读。在本书的代码示例中，请记住`{0}`是`arg0`的占位符，依此类推。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Bob Smith was born on Wednesday, 22 December 1965
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith was born on Wednesday, 22 December 1965
- en: '```'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Your output may look different based on your locale, that is, language and culture.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的区域设置（即语言和文化），您的输出可能会有所不同。
- en: The format code for `arg1` is made of several parts. `dddd` means the name of
    the day of the week. `d` means the number of the day of the month. `MMMM` means
    the name of the month. Lowercase `m` is used for minutes in time values. `yyyy`
    means the full number of the year. `yy` would mean the two-digit year.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg1`的格式代码由几部分组成。`dddd`表示星期几的名称。`d`表示月份的日期。`MMMM`表示月份的名称。小写的`m`用于时间值中的分钟。`yyyy`表示完整的年份。`yy`表示两位数的年份。'
- en: You can also initialize fields using a shorthand **object initializer** syntax
    using curly braces. Let's see how.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用简写的**对象初始化程序**语法使用大括号初始化字段。让我们看看。
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different format code for the date of birth when writing her to
    the console, as shown in the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有代码下面添加语句以创建另一个名为Alice的新人。请注意，在将她写入控制台时，日期格式代码不同，如下面的代码所示：
- en: '```cs'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person alice = new
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Person alice = new
- en: ()
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = "Alice Jones"
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Name = "Alice Jones"
- en: ','
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: DateOfBirth = new
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: DateOfBirth = new
- en: (1998
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: （1998
- en: ', 3'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ，3
- en: ', 7'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ，7
- en: ) // C# 9.0 or later
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ）// C# 9.0或更高版本
- en: '};'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'WriteLine(format: "{0} was born on {1:dd MMM yy}"'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "{0} was born on {1:dd MMM yy}"'
- en: ','
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: alice.Name,'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 参数0：alice.Name，
- en: 'arg1: alice.DateOfBirth);'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参数1：alice.DateOfBirth);
- en: '```'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Alice Jones was born on 07 Mar 98
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Alice Jones was born on 07 Mar 98
- en: '```'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Storing a value using an enum type
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举类型存储值
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
    At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We are able to store this data by defining an `enum` type.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个值需要是有限选项集中的一个。例如，世界上有七个古代奇迹，一个人可能有一个最喜欢的。其他时候，一个值需要是有限选项集的组合。例如，一个人可能有一个想要参观的古代世界奇迹清单。我们可以通过定义`enum`类型来存储这些数据。
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型是存储一个或多个选择的非常有效的方式，因为在内部，它使用整数值与`string`描述的查找表相结合：'
- en: Add a new file to the `PacktLibrary` project named `WondersOfTheAncientWorld.cs`
    .
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中添加一个名为`WondersOfTheAncientWorld.cs`的新文件。
- en: 'Modify the `WondersOfTheAncientWorld.cs` file, as shown in the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WondersOfTheAncientWorld.cs`文件，如下面的代码所示：
- en: '```cs'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: enum
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举
- en: WondersOfTheAncientWorld
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: WondersOfTheAncientWorld
- en: '{'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: GreatPyramidOfGiza,
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 吉萨的金字塔，
- en: HangingGardensOfBabylon,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 巴比伦空中花园，
- en: StatueOfZeusAtOlympia,
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 奥林匹亚宙斯神像，
- en: TempleOfArtemisAtEphesus,
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以弗所的阿尔忒弥斯神庙，
- en: MausoleumAtHalicarnassus,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Halicarnassus陵墓，
- en: ColossusOfRhodes,
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 罗得岛的巨像，
- en: LighthouseOfAlexandria
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 亚历山大灯塔
- en: '}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : If you use are writing code in a .NET Interactive notebook,
    then the code cell containing the `enum` must be above the code cell defining
    the `Person` class.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：如果您在.NET交互式笔记本中编写代码，则包含`enum`的代码单元格必须位于定义`Person`类的代码单元格之上。'
- en: 'In the `Person` class, add the following statement to your list of fields:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中，将以下语句添加到字段列表中：
- en: '```cs'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: WondersOfTheAncientWorld FavoriteAncientWonder;
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: WondersOfTheAncientWorld FavoriteAncientWonder;
- en: '```'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add the following statements:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加以下语句：
- en: '```cs'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bob.FavoriteAncientWonder = WondersOfTheAncientWorld.StatueOfZeusAtOlympia;
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: bob.FavoriteAncientWonder = WondersOfTheAncientWorld.StatueOfZeusAtOlympia;
- en: WriteLine(
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(
- en: 'format: "{0}''s favorite wonder is {1}. Its integer is {2}."'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："{0}的最喜欢的奇迹是{1}。它的整数是{2}。"
- en: ','
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: bob.Name,'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 参数0：bob.Name，
- en: 'arg1: bob.FavoriteAncientWonder,'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 参数1：bob.FavoriteAncientWonder，
- en: 'arg2: (int'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 参数2：（整数
- en: )bob.FavoriteAncientWonder);
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ）bob.FavoriteAncientWonder);
- en: '```'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Bob Smith's favorite wonder is StatueOfZeusAtOlympia. Its integer is 2.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃·史密斯最喜欢的奇迹是奥林匹亚宙斯神像。它的整数值为 2。
- en: '```'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned starting at `0` , so the third world wonder
    in our `enum` has a value of `2` . You can assign `int` values that are not listed
    in the `enum` . They will output as the `int` value instead of a name since a
    match will not be found.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 值在内部存储为 `int` 以提高效率。`int` 值会自动从 `0` 开始分配，因此我们 `enum` 中的第三个世界奇迹的值为 `2`。您可以分配未在
    `enum` 中列出的 `int` 值。它们将输出为 `int` 值而不是名称，因为找不到匹配项。'
- en: Storing multiple values using an enum type
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举类型存储多个值
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum` , and collections will be explained later in this chapter, but there
    is a better way. We can combine multiple choices into a single value using `enum`
    **flags** :'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桶列表，我们可以创建一个 `enum` 实例的数组或集合，集合将在本章后面进行解释，但有一个更好的方法。我们可以使用 `enum` **flags**
    将多个选择组合成单个值：
- en: 'Modify the `enum` by decorating it with the `[System.Flags]` attribute, and
    explicitly set a `byte` value for each wonder that represents different bit columns,
    as shown highlighted in the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `[System.Flags]` 属性修饰 `enum`，并为每个奇迹设置一个代表不同位列的 `byte` 值，如下面的代码中所示的高亮部分所示，修改
    `enum`：
- en: '```cs'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '**[**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**[**'
- en: '**System.Flags**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Flags**'
- en: '**]**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**]**'
- en: public
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: enum
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: enum
- en: WondersOfTheAncientWorld
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 古代世界奇迹
- en: '**:**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**:**'
- en: '**byte**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**byte**'
- en: '{'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '**None                     =**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**None                     =**'
- en: '**0b**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0000_0000,**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0000_0000,**'
- en: '**// i.e. 0**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 0**'
- en: GreatPyramidOfGiza
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 吉萨大金字塔
- en: '**=**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0000_0001,**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0000_0001,**'
- en: '**// i.e. 1**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 1**'
- en: HangingGardensOfBabylon
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 巴比伦空中花园
- en: '**=**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0000_0010,**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0000_0010,**'
- en: '**// i.e. 2**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 2**'
- en: StatueOfZeusAtOlympia
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 奥林匹亚宙斯神像
- en: '**=**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0000_0100,**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0000_0100,**'
- en: '**// i.e. 4**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 4**'
- en: TempleOfArtemisAtEphesus
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以弗所的阿尔忒弥斯神庙
- en: '**=**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0000_1000,**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0000_1000,**'
- en: '**// i.e. 8**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 8**'
- en: MausoleumAtHalicarnassus
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 哈里卡纳索斯陵墓
- en: '**=**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0001_0000,**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0001_0000,**'
- en: '**// i.e. 16**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 16**'
- en: ColossusOfRhodes
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 罗得峡谷巨像
- en: '**=**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0010_0000,**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0010_0000,**'
- en: '**// i.e. 32**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 32**'
- en: LighthouseOfAlexandria
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 亚历山大灯塔
- en: '**=**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**=**'
- en: '**0b**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**0b**'
- en: '**_0100_0000**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**_0100_0000**'
- en: '**// i.e. 64**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 即 64**'
- en: '}'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We are assigning explicit values for each choice that would not overlap when
    looking at the bits stored in memory. We should also decorate the `enum` type
    with the `System.Flags` attribute so that when the value is returned it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个选择分配了明确的值，这些值在存储在内存中的位时不会重叠。我们还应该使用 `System.Flags` 属性修饰 `enum` 类型，以便当返回值时，它可以自动与多个值匹配，作为逗号分隔的
    `string` 返回，而不是返回一个 `int` 值。
- en: Normally, an `enum` type uses an `int` variable internally, but since we don't
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`enum` 类型在内部使用 `int` 变量，但由于我们不需要那么大的值，我们可以通过使用 `byte` 变量来减少 75% 的内存需求，即每个值使用
    1 个字节而不是 4 个字节。
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1` . In other words, we would store the value
    `18` :'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要指示我们的桶列表包括 *巴比伦空中花园* 和 *哈里卡纳索斯陵墓* 这两个古代世界奇迹，那么我们希望 `16` 和 `2` 位设置为 `1`。换句话说，我们将存储值
    `18`：
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
- en: 'In the `Person` class, add the following statement to your list of fields,
    as shown in the following code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person` 类中，将以下语句添加到字段列表中，如下面的代码所示：
- en: '```cs'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: WondersOfTheAncientWorld BucketList;
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 古代世界奇迹 BucketList;
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to set the bucket list using the `|` operator
    (bitwise logical OR) to combine the enum values. We could also set the value using
    the number 18 cast into the enum type, as shown in the comment, but we shouldn''t
    because that would make the code harder to understand, as shown in the following
    code:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句使用 `|` 运算符（按位逻辑或）来组合枚举值来设置桶列表。我们也可以使用将数字 18 转换为枚举类型来设置值，如注释中所示，但我们不应该这样做，因为这会使代码难以理解，如下面的代码所示：
- en: '```cs'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bob.BucketList =
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: bob.BucketList =
- en: WondersOfTheAncientWorld.HangingGardensOfBabylon
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 古代世界奇迹.巴比伦空中花园
- en: '| WondersOfTheAncientWorld.MausoleumAtHalicarnassus;'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '| 古代世界奇迹.哈里卡纳索斯陵墓;'
- en: // bob.BucketList = (WondersOfTheAncientWorld)18;
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: // bob.BucketList = (WondersOfTheAncientWorld)18;
- en: WriteLine($"
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{bob.Name}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Name}'
- en: '''s bucket list is'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 的桶列表是
- en: '{bob.BucketList}'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.BucketList}'
- en: '"'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Bob Smith's bucket list is HangingGardensOfBabylon, MausoleumAtHalicarnassus
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃·史密斯的桶列表是巴比伦空中花园，哈里卡纳索斯陵墓
- en: '```'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用 `enum` 值存储离散选项的组合。如果有多达八个选项，从 `byte` 派生一个 `enum` 类型，如果有多达 16 个选项，从
    `ushort` 派生一个 `enum` 类型，如果有多达 32 个选项，从 `uint` 派生一个 `enum` 类型，如果有多达 64 个选项，从 `ulong`
    派生一个 `enum` 类型。'
- en: Storing multiple values using collections
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合存储多个值
- en: 'Let''s now add a field to store a person''s children. This is an example of
    aggregation because children are instances of a class that is related to the current
    person but are not part of the person itself. We will use a generic `List<T>`
    collection type that can store an ordered collection of any type. You will learn
    more about collections in *Chapter 8* , *Working with Common .NET Types* . For
    now, just follow along:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个字段来存储一个人的孩子。这是聚合的一个例子，因为孩子是与当前人相关的类的实例，但不是人本身的一部分。我们将使用泛型`List<T>`集合类型，它可以存储任何类型的有序集合。您将在*第8章*
    *使用常见的.NET类型*中了解更多关于集合的知识。现在，只需跟着做：
- en: 'In `Person.cs` , import the `System.Collections.Generic` namespace, as shown
    in the following code:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，导入`System.Collections.Generic`命名空间，如下面的代码所示：
- en: '```cs'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Collections.Generic; // List<T>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: System.Collections.Generic; // List<T>
- en: '```'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Declare a new field in the `Person` class, as shown in the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中声明一个新字段，如下面的代码所示：
- en: '```cs'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: List
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: List
- en: <
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: Person
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: Children
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Children
- en: = new
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: = new
- en: List<Person>();
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person>();
- en: '```'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '`List<Person>` is read aloud as "list of Person," for example, "the type of
    the property named `Children` is a list of `Person` instances." We explicitly
    changed the class library to target .NET Standard 2.0 (that uses the C# 7 compiler),
    so we cannot use target-typed new to initialize the `Children` field. If we had
    left it targeting .NET 6.0, then we could use target-typed new, as shown in the
    following code:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<Person>`读作"Person列表"，例如，"名为`Children`的属性的类型是`Person`实例的列表"。我们明确地将类库更改为目标.NET
    Standard 2.0（使用C# 7编译器），因此我们不能使用目标类型的新来初始化`Children`字段。如果我们将其保留为.NET 6.0目标，那么我们可以使用目标类型的新，如下面的代码所示：'
- en: '```cs'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: List<Person> Children = new
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> Children = new
- en: ();
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: '```'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We must ensure the collection is initialized to a new instance of a list of
    `Person` before we can add items to it, otherwise, the field will be `null` and
    it will throw runtime exceptions when we try to use any of its members like `Add`
    .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保集合在我们添加项目之前被初始化为`Person`列表的新实例，否则，该字段将为`null`，当我们尝试使用其成员（如`Add`）时，它将抛出运行时异常。
- en: Understanding generic collections
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解泛型集合
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2.0\. It's a fancy term for making a collection
    **strongly typed** , that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类型中的尖括号是C#中称为**泛型**的功能，它是在2005年的C# 2.0中引入的。这是一个用于使集合**强类型**的花哨术语，也就是说，编译器明确知道可以存储在集合中的对象类型。泛型提高了代码的性能和正确性。'
- en: '**Strongly typed** has a different meaning to **statically typed** . The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**强类型**与**静态类型**有不同的含义。旧的`System.Collection`类型是静态类型，包含弱类型的`System.Object`项。新的`System.Collection.Generic`类型是静态类型，包含强类型的`<T>`实例。'
- en: Ironically, the term *generics* means we can use a more specific static type!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，术语*泛型*意味着我们可以使用更具体的静态类型！
- en: 'In `Program.cs` , add statements to add two children for `Bob` and then show
    how many children he has and what their names are, as shown in the following code:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句为`Bob`添加两个孩子，然后显示他有多少孩子以及他们的名字，如下面的代码所示：
- en: '```cs'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bob.Children.Add(new
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: bob.Children.Add(new
- en: Person { Name = "Alfred"
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Person { Name = "Alfred"
- en: '}); // C# 3.0 and later'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '}); // C# 3.0及更高版本'
- en: bob.Children.Add(new
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: bob.Children.Add(new
- en: () { Name = "Zoe"
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Zoe"
- en: '}); // C# 9.0 and later'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '}); // C# 9.0及更高版本'
- en: WriteLine(
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(
- en: $"
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{bob.Name}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Name}'
- en: has
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: has
- en: '{bob.Children.Count}'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Children.Count}'
- en: children:"
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: children:"
- en: );
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: for
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: childIndex = 0
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: childIndex = 0
- en: ; childIndex < bob.Children.Count; childIndex++)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ; childIndex < bob.Children.Count; childIndex++)
- en: '{'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{bob.Children[childIndex].Name}'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Children[childIndex].Name}'
- en: '"'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an extra challenge, change the `for` statement to output the same information
    using `foreach` .
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`foreach`语句来枚举集合。作为额外的挑战，将`for`语句更改为使用`foreach`输出相同的信息。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Bob Smith has 2 children:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith有2个孩子：
- en: Alfred
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Alfred
- en: Zoe
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Zoe
- en: '```'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Making a field static
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使字段静态化
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的字段都是**实例**成员，这意味着对于创建的类的每个实例，每个字段都存在不同的值。`alice`和`bob`变量具有不同的`Name`值。
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望定义一个字段，该字段只有一个值，该值在所有实例之间共享。
- en: 'These are called **static** *members* because fields are not the only members
    that can be static. Let''s see what can be achieved using `static` fields:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为**静态** *成员*，因为字段不是唯一可以是静态的成员。让我们看看可以使用`static`字段实现什么：
- en: In the `PacktLibrary` project, add a new class file named `BankAccount.cs` .
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`BankAccount.cs`的新类文件。
- en: 'Modify the class to give it three fields, two instance fields and one static
    field, as shown in the following code:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类以给它三个字段，两个实例字段和一个静态字段，如下面的代码所示：
- en: '```cs'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: BankAccount
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: BankAccount
- en: '{'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: AccountName; // instance member
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: AccountName; // 实例成员
- en: public
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: decimal
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: Balance; // instance member
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Balance; // 实例成员
- en: public
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: decimal
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: InterestRate; // shared member
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: InterestRate; // 共享成员
- en: '}'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Each instance of `BankAccount` will have its own `AccountName` and `Balance`
    values, but all instances will share a single `InterestRate` value.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankAccount`的每个实例都将有自己的`AccountName`和`Balance`值，但所有实例将共享一个`InterestRate`值。'
- en: 'In `Program.cs` , add statements to set the shared interest rate and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '```cs'
- en: '```cs'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: BankAccount.InterestRate = 0.012
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: M; // store a shared value
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: BankAccount jonesAccount = new
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: (); // C# 9.0 and later
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: jonesAccount.AccountName = "Mrs. Jones"
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Name}'
- en: ;
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: is a
- en: jonesAccount.Balance = 2400
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: BankAccount gerrierAccount = new
- en: ;
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'WriteLine(format: "{0} earned {1:C} interest."'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ','
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: gerrierAccount.AccountName,'
- en: 'arg0: jonesAccount.AccountName,'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg1: jonesAccount.Balance * BankAccount.InterestRate);'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数初始化字段
- en: BankAccount gerrierAccount = new
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: ();
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一个语句将 Bob 的姓名和家乡星球写入控制台，如下面的代码所示：
- en: gerrierAccount.AccountName = "Ms. Gerrier"
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: ;
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：出于两个重要原因，使用只读字段而不是常量字段是更好的选择：该值可以在运行时计算或加载，并且可以使用任何可执行语句来表示。因此，只读字段可以使用构造函数或字段赋值来设置。对字段的每个引用都是一个活动引用，因此任何将来的更改都将由调用代码正确反映出来。'
- en: gerrierAccount.Balance = 98
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取常量字段的值，必须写类的名称，而不是类的实例的名称。在 `Program.cs` 中，添加一个语句将 Bob 的姓名和物种写入控制台，如下面的代码所示：
- en: ;
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: BankAccount jonesAccount = new
- en: 'WriteLine(format: "{0} earned {1:C} interest."'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: jonesAccount.Balance = 2400
- en: ','
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明 `static` `readonly` 字段，其值将在类型的所有实例之间共享。
- en: 'arg0: gerrierAccount.AccountName,'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'arg1: gerrierAccount.Balance * BankAccount.InterestRate);'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "{0} earned {1:C} interest."'
- en: '```'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith is a Homo Sapien
- en: '`:C` is a format code that tells .NET to use the currency format for the numbers.
    In *Chapter 8* , *Working with Common .NET Types* , you will learn how to control
    the culture that determines the currency symbol. For now, it will use the default
    for your operating system installation. I live in London, UK, hence my output
    shows British Pounds (£).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: readonly
- en: 'Run the code and view the additional output:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ;
- en: '```cs'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: gerrierAccount.Balance = 98
- en: Mrs. Jones earned £28.80 interest.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 类型中 `const` 字段的示例包括 `System.Int32.MaxValue` 和 `System.Math.PI`，因为这两个值都永远不会改变，如
    *图 5.2* 中所示：
- en: Ms. Gerrier earned £1.18 interest.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并查看额外的输出：
- en: '```'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Ms. Gerrier earned £1.18 interest.
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Making a field constant
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '```'
- en: 'If the value of a field will never ever change, you can use the `const` keyword
    and assign a literal value at compile time:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Species = "Homo Sapien"
- en: 'In `Person.cs` , add the following code:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使字段只读
- en: '```cs'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: // constants
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: jonesAccount.AccountName,'
- en: public
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Mrs. Jones earned £28.80 interest.
- en: const
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith was born on Earth
- en: string
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: jonesAccount.Balance * BankAccount.InterestRate);'
- en: Species = "Homo Sapien"
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来设置共享的利率，然后创建两个 `BankAccount` 类型的实例，如下面的代码所示：
- en: ;
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：常量并不总是两个重要原因的最佳选择：该值必须在编译时知道，并且必须能够表示为文字 `string`、`Boolean` 或数字值。对
    `const` 字段的每个引用都将在编译时替换为文字值，因此，如果值在将来的版本中更改，而您没有重新编译任何引用它的程序集以获取新值，则不会反映出这种更改。'
- en: '```'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: HomePlanet = "Earth"
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs` , add a statement to
    write Bob''s name and species to the console, as shown in the following code:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "{0} earned {1:C} interest."'
- en: '```cs'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: WriteLine($"
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '{bob.Name}'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 使字段成为常量
- en: is a
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: '{Person.Species}'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 5.2: Examples of constants'
- en: '"'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: );
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '```'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BankAccount.InterestRate = 0.012
- en: '```cs'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Bob Smith is a Homo Sapien
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: gerrierAccount.Balance * BankAccount.InterestRate);'
- en: '```'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2* :'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`:C` 是一个格式代码，告诉 .NET 使用货币格式来显示数字。在 *第 8 章* *使用常见的 .NET 类型* 中，您将学习如何控制决定货币符号的文化。现在，它将使用您操作系统安装的默认值。我住在英国伦敦，因此我的输出显示英镑
    (£)。'
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00065.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: 字段不是唯一可以是静态的成员。构造函数、方法、属性和其他成员也可以是静态的。
- en: 'Figure 5.2: Examples of constants'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: M; // store a shared value
- en: '**Good Practice** : Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string` , `Boolean` , or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: Making a field read-only
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ;
- en: 'Often a better choice for fields that should not change is to mark them as
    read-only:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Person.cs` , add a statement to declare an instance read-only field to
    store a person''s home planet, as shown in the following code:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (); // C# 9.0 and later
- en: '```cs'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // read-only fields
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于不应更改的字段，更好的选择是将它们标记为只读：
- en: readonly
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面、文本、应用程序、电子邮件描述自动生成](img/Image00065.jpg)'
- en: HomePlanet = "Earth"
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '{bob.Name}'
- en: ;
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段的值永远不会改变，您可以使用 `const` 关键字并在编译时分配一个文字值：
- en: 'In `Program.cs` , add a statement to write Bob''s name and home planet to the
    console, as shown in the following code:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '{Person.Species}'
- en: '```cs'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: WriteLine($"
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: // 只读字段
- en: '{bob.Name}'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加一个语句来声明一个实例只读字段，用于存储一个人的家乡星球，如下面的代码所示：
- en: was born on
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 出生在
- en: '{bob.HomePlanet}'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '"'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: jonesAccount.AccountName = "Mrs. Jones"
- en: );
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '```'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gerrierAccount.AccountName = "Ms. Gerrier"
- en: '```cs'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Bob Smith was born on Earth
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: // 常量
- en: '```'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加以下代码：
- en: '**Good Practice** : Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the field is a live reference, so any
    future changes will be correctly reflected by the calling code.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: const
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Initializing fields with constructors
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '{bob.HomePlanet}'
- en: Fields often need to be initialized at runtime. You do this in a constructor
    that will be called when you make an instance of the class using the `new` keyword.
    Constructors execute before any fields are set by the code that is using the type.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 字段通常需要在运行时初始化。您可以在构造函数中执行此操作，当您使用 `new` 关键字创建类的实例时，将调用构造函数。构造函数在任何字段由使用类型的代码设置之前执行。
- en: 'In `Person.cs` , add statements after the existing read-only `HomePlanet` field
    to define a second read-only field and then set the `Name` and `Instantiated`
    fields in a constructor, as shown highlighted in the following code:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，在现有的只读 `HomePlanet` 字段之后添加语句，以定义第二个只读字段，然后在构造函数中设置 `Name` 和
    `Instantiated` 字段，如下所示：
- en: '```cs'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // read-only fields
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: // 只读字段
- en: public
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: readonly
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: readonly
- en: string
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: HomePlanet = "Earth"
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: HomePlanet = "Earth"
- en: ;
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '**public**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**public**'
- en: '**readonly**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读**'
- en: '**DateTime Instantiated;**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**DateTime Instantiated;**'
- en: '**// constructors**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 构造函数**'
- en: '**public**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**public**'
- en: '**Person**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**Person**'
- en: '**()**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**()**'
- en: '**{**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**// set default values for fields**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 为字段设置默认值**'
- en: '**// including read-only fields**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 包括只读字段**'
- en: '**Name =**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**Name =**'
- en: '**"Unknown"**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Unknown"**'
- en: '**;**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**;**'
- en: '**Instantiated = DateTime.Now;**'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '**Instantiated = DateTime.Now;**'
- en: '**}**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来实例化一个新的人，然后输出其初始字段值，如下所示：
- en: '```cs'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person blankPerson = new
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Person blankPerson = new
- en: ();
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: 'WriteLine(format:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format:'
- en: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
- en: ','
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: blankPerson.Name,'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: blankPerson.Name,'
- en: 'arg1: blankPerson.HomePlanet,'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: blankPerson.HomePlanet,'
- en: 'arg2: blankPerson.Instantiated);'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg2: blankPerson.Instantiated);'
- en: '```'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Unknown of Earth was created at 11:58:12 on a Sunday
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Unknown of Earth was created at 11:58:12 on a Sunday
- en: '```'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Defining multiple constructors
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义多个构造函数
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 类型中可以有多个构造函数。这对鼓励开发人员为字段设置初始值特别有用：
- en: 'In `Person.cs` , add statements to define a second constructor that allows
    a developer to set initial values for the person''s name and home planet, as shown
    in the following code:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句来定义允许开发人员为人的名称和家乡设置初始值的第二个构造函数，如下所示：
- en: '```cs'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: Person
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: (
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: initialName,
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: initialName,
- en: string
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: homePlanet
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: homePlanet
- en: )
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = initialName;
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: Name = initialName;
- en: HomePlanet = homePlanet;
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: HomePlanet = homePlanet;
- en: Instantiated = DateTime.Now;
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: Instantiated = DateTime.Now;
- en: '}'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来使用带有两个参数的构造函数创建另一个人，如下所示：
- en: '```cs'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person gunny = new
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: Person gunny = new
- en: '(initialName: "Gunny"'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '(initialName: "Gunny"'
- en: ', homePlanet: "Mars"'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: ', homePlanet: "Mars"'
- en: );
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'WriteLine(format:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format:'
- en: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '"{0} of {1} was created at {2:hh:mm:ss} on a {2:dddd}."'
- en: ','
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: gunny.Name,'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: gunny.Name,'
- en: 'arg1: gunny.HomePlanet,'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: gunny.HomePlanet,'
- en: 'arg2: gunny.Instantiated);'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg2: gunny.Instantiated);'
- en: '```'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果：
- en: '```cs'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Gunny of Mars was created at 11:59:25 on a Sunday
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: Gunny of Mars was created at 11:59:25 on a Sunday
- en: '```'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Constructors are a special category of method. Let's look at methods in more
    detail.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是方法的一种特殊类别。让我们更详细地看一下方法。
- en: Writing and calling methods
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和调用方法
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法** 是执行一系列语句的类型的成员。它们是属于类型的函数。'
- en: Returning values from methods
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从方法返回值
- en: 'Methods can return a single value or return nothing:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以返回单个值，也可以不返回任何内容：
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一些操作但不返回值的方法在方法名称之前用 `void` 类型表示。
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一些操作并返回值的方法在方法名称之前用返回值的类型表示。
- en: 'For example, in the next task, you will create two methods:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下一个任务中，您将创建两个方法：
- en: '`WriteToConsole` : This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteToConsole`：这将执行一个操作（向控制台写入一些文本），但不会从方法中返回任何内容，由 `void` 关键字表示。'
- en: '`GetOrigin` : This will return a text value, indicated by the `string` keyword.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOrigin`：这将返回一个文本值，由 `string` 关键字表示。'
- en: 'Let''s write the code:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: 'In `Person.cs` , add statements to define the two methods that I described
    earlier, as shown in the following code:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句来定义我之前描述的两个方法，如下所示：
- en: '```cs'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // methods
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: WriteToConsole
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: WriteToConsole
- en: ()
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{Name}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: was born on a
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: was born on a
- en: '{DateOfBirth:dddd}'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '{DateOfBirth:dddd}'
- en: ."
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: GetOrigin
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: GetOrigin
- en: ()
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: was born on
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: was born on
- en: '{HomePlanet}'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '{HomePlanet}'
- en: ."
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: ;
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to call the two methods, as shown in the following
    code:'
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来调用两个方法，如下所示：
- en: '```cs'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bob.WriteToConsole();
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: bob.WriteToConsole();
- en: WriteLine(bob.GetOrigin());
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.GetOrigin());
- en: '```'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Bob Smith was born on a Wednesday.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith was born on a Wednesday.
- en: Bob Smith was born on Earth.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith was born on Earth.
- en: '```'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Combining multiple returned values using tuples
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元组组合多个返回值
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example, a complex type,
    such as `Person` , or a collection type, such as `List<Person>` .
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法只能返回一个具有单一类型的值。该类型可以是简单类型，例如上一个示例中的 `string`，也可以是复杂类型，例如 `Person`，或者是集合类型，例如
    `List<Person>`。
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个名为`GetTheData`的方法，该方法需要返回一个`string`值和一个`int`值。我们可以定义一个名为`TextAndNumber`的新类，其中包含一个`string`字段和一个`int`字段，并返回该复杂类型的实例，如下面的代码所示：
- en: '```cs'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: TextAndNumber
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 文本和数字
- en: '{'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Text;
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 文本;
- en: public
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: int
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Number;
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 数字;
- en: '}'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: LifeTheUniverseAndEverything
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 生活宇宙和一切
- en: '{'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: TextAndNumber
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: TextAndNumber
- en: GetTheData
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: GetTheData
- en: ()
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: new
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: TextAndNumber
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: TextAndNumber
- en: '{'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Text = "What's the meaning of life?"
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: Text=“生活的意义是什么？”
- en: ','
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: Number = 42
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 数字= 42
- en: '};'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But defining a class just to combine two values together is unnecessary, because
    in modern versions of C# we can use **tuples** . Tuples are an efficient way to
    combine two or more values into a single unit. I pronounce them as tuh-ples but
    I have heard other developers pronounce them as too-ples. To-may-toe, to-mah-toe,
    po-tay-toe, po-tah-toe, I guess.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅为了将两个值组合在一起而定义一个类是不必要的，因为在现代版本的C#中，我们可以使用**元组**。元组是将两个或更多值组合成单个单元的有效方法。我把它们发音为tuh-ples，但我听说其他开发人员把它们发音为too-ples。我猜是西红柿，土豆，土豆，土豆，我猜。
- en: Tuples have been a part of some languages such as F# since their first version,
    but .NET only added support for them with .NET 4.0 in 2010 using the `System.Tuple`
    type.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 元组自从第一个版本以来一直是一些语言的一部分，比如F#，但是.NET直到2010年才使用`System.Tuple`类型添加了对它们的支持。
- en: Language support for tuples
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组的语言支持
- en: It was only with C# 7.0 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()` and at the same time, .NET added a new `System.ValueTuple`
    type that is more efficient in some common scenarios than the old .NET 4.0 `System.Tuple`
    type. The C# tuple syntax uses the more efficient one.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2017年的C# 7.0，C#才使用括号字符`（）`添加了元组的语言语法支持，同时.NET添加了一个新的`System.ValueTuple`类型，该类型在某些常见情况下比旧的.NET
    4.0`System.Tuple`类型更有效。 C#元组语法使用更有效的语法。
- en: 'Let''s explore tuples:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索元组：
- en: 'In `Person.cs` , add statements to define a method that returns a tuple that
    combines a `string` and `int` , as shown in the following code:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句来定义一个返回组合`string`和`int`的元组的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: (string
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: ', int'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ，int
- en: ) GetFruit()
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ）获取水果（）
- en: '{'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: ("Apples"
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: （“苹果”
- en: ', 5'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ，5
- en: );
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to call the `GetFruit` method and then output
    the tuple''s fields automatically named `Item1` and `Item2` , as shown in the
    following code:'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句调用`GetFruit`方法，然后自动输出元组的字段，名称为`Item1`和`Item2`，如下面的代码所示：
- en: '```cs'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: (string
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: ', int'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: ，int
- en: ) fruit = bob.GetFruit();
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: ）水果=鲍勃。获取水果（）;
- en: WriteLine($"
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“
- en: '{fruit.Item1}'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruit.Item1}'
- en: ','
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: '{fruit.Item2}'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruit.Item2}'
- en: there are."
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 有。
- en: );
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Apples, 5 there are.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果，5个。
- en: '```'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Naming the fields of a tuple
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给元组的字段命名
- en: To access the fields of a tuple, the default names are `Item1` , `Item2` , and
    so on.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组的字段，默认名称为`Item1`，`Item2`等。
- en: 'You can explicitly specify the field names:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以明确指定字段名称：
- en: 'In `Person.cs` , add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句来定义一个返回具有命名字段的元组的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: (string
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: Name, int
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，int
- en: Number) GetNamedFruit()
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 数字）GetNamedFruit（）
- en: '{'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '{```'
- en: return
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '(Name: "Apples"'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: （名称：“苹果”
- en: ', Number: 5'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: ，数字：5
- en: );
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to call the method and output the tuple''s
    named fields, as shown in the following code:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来调用该方法并输出元组的命名字段，如下面的代码所示：
- en: '```cs'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: fruitNamed = bob.GetNamedFruit();
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: fruitNamed= bob.GetNamedFruit（）;
- en: WriteLine($"There are
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“有
- en: '{fruitNamed.Number}'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruitNamed.Number}'
- en: '{fruitNamed.Name}'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruitNamed.Name}'
- en: ."
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 。”
- en: );
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: There are 5 Apples.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 有5个苹果。
- en: '```'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Inferring tuple names
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断元组名称
- en: If you are constructing a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference** .
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在从另一个对象构造元组，则可以使用C# 7.1中引入的名为**元组名称推断**的功能。
- en: 'In `Program.cs` , create two tuples, made of a `string` and `int` value each,
    as shown in the following code:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建两个元组，每个元组由一个`string`和`int`值组成，如下面的代码所示：
- en: '```cs'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: thing1 = ("Neville"
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: thing1=（“内维尔”
- en: ', 4'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: ，4
- en: );
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“
- en: '{thing1.Item1}'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '{thing1.Item1}'
- en: has
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{thing1.Item2}'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '{thing1.Item2}'
- en: children."
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们。”
- en: );
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: var
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: thing2 = (bob.Name, bob.Children.Count);
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: thing2=（bob.Name，bob.Children.Count）;
- en: WriteLine($"
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“
- en: '{thing2.Name}'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '{thing2.Name}'
- en: has
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{thing2.Count}'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '{thing2.Count}'
- en: children."
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们。”
- en: );
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In C# 7.0, both things would use the `Item1` and `Item2` naming schemes. In
    C# 7.1 and later, `thing2` can infer the names `Name` and `Count` .
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，两者都将使用`Item1`和`Item2`命名方案。在C# 7.1及更高版本中，`thing2`可以推断出名称`Name`和`Count`。
- en: Deconstructing tuples
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构元组
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples, but without a named variable
    for the tuple, as shown in the following code:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将元组解构为单独的变量。解构声明具有与命名字段元组相同的语法，但没有元组的命名变量，如下面的代码所示：
- en: '```cs'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // store return value in a tuple variable with two fields
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: //将返回值存储在具有两个字段的元组变量中
- en: (string
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: TheName, int
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: TheName，int
- en: TheNumber) tupleWithNamedFields = bob.GetNamedFruit();
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: TheNumber）tupleWithNamedFields= bob.GetNamedFruit（）;
- en: // tupleWithNamedFields.TheName
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: // tupleWithNamedFields.TheName
- en: // tupleWithNamedFields.TheNumber
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: // tupleWithNamedFields.TheNumber
- en: // deconstruct return value into two separate variables
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: //解构返回值为两个单独的变量
- en: (string
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: name, int
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，int
- en: number) = GetNamedFruit();
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 数字）= GetNamedFruit（）;
- en: // name
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: //名称
- en: // number
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: //数字
- en: '```'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This has the effect of splitting the tuple into its parts and assigning those
    parts to new variables.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: This has the effect of splitting the tuple into its parts and assigning those
    parts to new variables.
- en: 'In `Program.cs` , add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  id: totrans-846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
- en: '```cs'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: (string
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: (string
- en: fruitName, int
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: fruitName, int
- en: fruitNumber) = bob.GetFruit();
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: fruitNumber) = bob.GetFruit();
- en: 'WriteLine($"Deconstructed:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"Deconstructed:'
- en: '{fruitName}'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruitName}'
- en: ','
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '{fruitNumber}'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '{fruitNumber}'
- en: '"'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Run the code and view the result, as shown in the following output:'
- en: '```cs'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Deconstructed: Apples, 5'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 'Deconstructed: Apples, 5'
- en: '```'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Deconstructing types
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Deconstructing types
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods named `Deconstruct` that break down the object into parts. Let''s implement
    some for the `Person` class:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods named `Deconstruct` that break down the object into parts. Let''s implement
    some for the `Person` class:'
- en: 'In `Person.cs` , add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Person.cs` , add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
- en: '```cs'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // deconstructors
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: // deconstructors
- en: public
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Deconstruct
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: Deconstruct
- en: (
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: out
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: string
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: name,
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: name,
- en: out
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: DateTime dob
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime dob
- en: )
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: name = Name;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: name = Name;
- en: dob = DateOfBirth;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: dob = DateOfBirth;
- en: '}'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Deconstruct
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Deconstruct
- en: (
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: out
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: string
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: name,
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: name,
- en: out
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: DateTime dob,
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime dob,
- en: out
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: WondersOfTheAncientWorld fav
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: WondersOfTheAncientWorld fav
- en: )
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: name = Name;
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: name = Name;
- en: dob = DateOfBirth;
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: dob = DateOfBirth;
- en: fav = FavoriteAncientWonder;
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: fav = FavoriteAncientWonder;
- en: '}'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to deconstruct `bob` , as shown in the following
    code:'
  id: totrans-899
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to deconstruct `bob` , as shown in the following
    code:'
- en: '```cs'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // Deconstructing a Person
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: // Deconstructing a Person
- en: var
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: (name1, dob1) = bob;
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: (name1, dob1) = bob;
- en: 'WriteLine($"Deconstructed:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"Deconstructed:'
- en: '{name1}'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '{name1}'
- en: ','
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '{dob1}'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '{dob1}'
- en: '"'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: var
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: (name2, dob2, fav2) = bob;
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: (name2, dob2, fav2) = bob;
- en: 'WriteLine($"Deconstructed:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"Deconstructed:'
- en: '{name2}'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '{name2}'
- en: ','
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '{dob2}'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '{dob2}'
- en: ','
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '{fav2}'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '{fav2}'
- en: '"'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-921
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Run the code and view the result, as shown in the following output:'
- en: '```cs'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00'
- en: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00, StatueOfZeusAtOlympia'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 'Deconstructed: Bob Smith, 22/12/1965 00:00:00, StatueOfZeusAtOlympia'
- en: B
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: B
- en: '```'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Defining and passing parameters to methods
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Defining and passing parameters to methods
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method, as you saw earlier in this chapter with constructors. Let''s see more
    examples:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method, as you saw earlier in this chapter with constructors. Let''s see more
    examples:'
- en: 'In `Person.cs` , add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  id: totrans-929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Person.cs` , add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
- en: '```cs'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: SayHello
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: SayHello
- en: ()
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: says 'Hello!'"
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: says 'Hello!'"
- en: ;
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: SayHelloTo
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: SayHelloTo
- en: (
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: name
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: name
- en: )
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: says 'Hello
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: says 'Hello
- en: '{name}'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '{name}'
- en: '!''"'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '!''"'
- en: ;
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to call the two methods and write the return
    value to the console, as shown in the following code:'
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to call the two methods and write the return
    value to the console, as shown in the following code:'
- en: '```cs'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(bob.SayHello());
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.SayHello());
- en: WriteLine(bob.SayHelloTo("Emily"
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.SayHelloTo("Emily"
- en: ));
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '```'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result:'
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Run the code and view the result:'
- en: '```cs'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Bob Smith says 'Hello!'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith says 'Hello!'
- en: Bob Smith says 'Hello Emily!'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: Bob Smith says 'Hello Emily!'
- en: '```'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name and type of any parameters, and the return type of the method, as shown
    in *Figure 5.3* :'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 'When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name and type of any parameters, and the return type of the method, as shown
    in *Figure 5.3* :'
- en: '![Graphical user interface, text, website Description automatically generated](img/Image00066.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text, website Description automatically generated](img/Image00066.jpg)'
- en: 'Figure 5.3: An IntelliSense tooltip for a method with no overloads'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 5.3: An IntelliSense tooltip for a method with no overloads'
- en: Overloading methods
  id: totrans-973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Overloading methods
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
- en: A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods cannot differ only in the return type.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods cannot differ only in the return type.
- en: In `Person.cs` , change the name of the `SayHelloTo` method to `SayHello` .
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: In `Person.cs` , change the name of the `SayHelloTo` method to `SayHello` .
- en: In `Program.cs` , change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has one additional overload,
    1/2, as well as 2/2, as shown in *Figure 5.4* :![Graphical user interface Description
    automatically generated with medium confidence](img/Image00067.jpg)
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: In `Program.cs` , change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has one additional overload,
    1/2, as well as 2/2, as shown in *Figure 5.4* :![Graphical user interface Description
    automatically generated with medium confidence](img/Image00067.jpg)
- en: 'Figure 5.4: An IntelliSense tooltip for an overloaded method'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 5.4: An IntelliSense tooltip for an overloaded method'
- en: '**Good Practice** : Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**Good Practice** : Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
- en: Passing optional and named parameters
  id: totrans-980
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Passing optional and named parameters
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
- en: 'We will now create a method with three optional parameters:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个具有三个可选参数的方法：
- en: 'In `Person.cs` , add statements to define the method, as shown in the following
    code:'
  id: totrans-983
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句来定义方法，如下面的代码所示：
- en: '```cs'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 串
- en: OptionalParameters
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: OptionalParameters
- en: (
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 串
- en: command  =
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 命令  =
- en: '"Run!"'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '"运行！"'
- en: ','
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: double
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 双
- en: number =
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 =
- en: '0.0'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '0.0'
- en: ','
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: bool
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: active =
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 =
- en: 'true'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: )
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: string
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 串
- en: .Format(
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: .Format(
- en: 'format: "command is {0}, number is {1}, active is {2}"'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："命令是{0}，数字是{1}，活动是{2}"
- en: ','
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: command,'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：命令，
- en: 'arg1: number,'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：数字，
- en: 'arg2: active);'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: arg2：活动）;
- en: '}'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  id: totrans-1012
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一条语句来调用该方法并将其返回值写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(bob.OptionalParameters());
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.OptionalParameters());
- en: '```'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Watch IntelliSense appear as you type the code. You will see a tooltip, showing
    the three optional parameters with their default values, as shown in *Figure 5.5*
    :![Graphical user interface, text, application, chat or text message Description
    automatically generated](img/Image00068.jpg)
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您键入代码时，IntelliSense会出现。您将看到一个工具提示，显示三个可选参数及其默认值，如*图5.5*所示：![图形用户界面，文本，应用程序，聊天或文本消息自动生成的描述](img/Image00068.jpg)
- en: 'Figure 5.5: IntelliSense showing optional parameters as you type code'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：IntelliSense在键入代码时显示可选参数
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1018
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: command is Run!, number is 0, active is True
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是运行！，数字是0，活动是真的
- en: '```'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  id: totrans-1022
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一条语句，传递 `command` 参数的 `string` 值和 `number` 参数的 `double` 值，如下面的代码所示：
- en: '```cs'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(bob.OptionalParameters("Jump!"
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.OptionalParameters("跳！"
- en: ', 98.5'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: ， 98.5
- en: ));
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '```'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and see the result, as shown in the following output:'
  id: totrans-1028
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: command is Jump!, number is 98.5, active is True
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是跳！，数字是98.5，活动是真的
- en: '```'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true` .
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 和 `number` 参数的默认值已被替换，但 `active` 的默认值仍然是 `true`。'
- en: Naming parameter values when calling methods
  id: totrans-1033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法时命名参数值
- en: Optional parameters are often combined with naming parameters when you call
    the method, because naming a parameter allows the values to be passed in a different
    order than how they were declared.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用方法时，可选参数通常与命名参数结合使用，因为命名参数允许以与声明顺序不同的顺序传递值。
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  id: totrans-1035
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一条语句，传递 `command` 参数的 `string` 值和 `number` 参数的 `double` 值，但使用命名参数，以便可以交换它们通过的顺序，如下面的代码所示：
- en: '```cs'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(bob.OptionalParameters(
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.OptionalParameters(
- en: 'number: 52.7'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 数字：52.7
- en: ', command: "Hide!"'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: ，命令："隐藏！"
- en: ));
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '```'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: command is Hide!, number is 52.7, active is True
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是隐藏！，数字是52.7，活动是真的
- en: '```'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can even use named parameters to skip over optional parameters.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用命名参数跳过可选参数。
- en: 'In `Program.cs` , add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  id: totrans-1047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一条语句，使用位置顺序传递 `command` 参数的 `string` 值，跳过 `number` 参数，并使用命名的
    `active` 参数，如下面的代码所示：
- en: '```cs'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(bob.OptionalParameters("Poke!"
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(bob.OptionalParameters("戳！"
- en: ', active: false'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: ，活动：假
- en: ));
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '```'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: command is Poke!, number is 0, active is False
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是戳！，数字是0，活动是假的
- en: '```'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Controlling how parameters are passed
  id: totrans-1057
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制参数传递方式
- en: 'When a parameter is passed into a method, it can be passed in one of three
    ways:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数传递到方法中时，可以以三种方式之一传递：
- en: 'By **value** (this is the default): Think of these as being *in-only* .'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按**值**（这是默认值）：把这些看作是*仅输入*。
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*
    .'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按**引用**作为 `ref` 参数：把这些看作是*输入和输出*。
- en: 'As an `out` parameter: Think of these as being *out-only* .'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `out` 参数：把这些看作是*仅输出*。
- en: 'Let''s see some examples of passing parameters in and out:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些传递参数的示例：
- en: 'In `Person.cs` , add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，添加语句来定义一个具有三个参数的方法，一个 `in` 参数，一个 `ref` 参数和一个 `out` 参数，如下面的方法所示：
- en: '```cs'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: PassingParameters
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: PassingParameters
- en: (
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x,
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: x，
- en: ref
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: ref
- en: int
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: y,
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: y，
- en: out
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: int
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: z
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: z
- en: )
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // out parameters cannot have a default
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: // out 参数不能有默认值
- en: // AND must be initialized inside the method
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: // 必须在方法内初始化
- en: z = 99
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: z = 99
- en: ;
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // increment each parameter
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: // 递增每个参数
- en: x++;
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: y++;
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: y++;
- en: z++;
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: z++;
- en: '}'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  id: totrans-1089
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句来声明一些 `int` 变量并将它们传递到方法中，如下面的代码所示：
- en: '```cs'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: a = 10
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: a = 10
- en: ;
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: b = 20
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: b = 20
- en: ;
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: c = 30
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: c = 30
- en: ;
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine($"Before: a ='
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"之前：a =
- en: '{a}'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: ', b ='
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: ， b =
- en: '{b}'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: ', c ='
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: ， c =
- en: '{c}'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '{c}'
- en: '"'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: bob.PassingParameters(a, ref
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: bob.PassingParameters(a, ref
- en: b, out
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: b，out
- en: c);
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: c）;
- en: 'WriteLine($"After: a ='
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"之后：a =
- en: '{a}'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: ', b ='
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: ', b ='
- en: '{b}'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: ', c ='
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: ， c =
- en: '{c}'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '{c}'
- en: '"'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Before: a = 10, b = 20, c = 30'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前：a = 10，b = 20，c = 30
- en: 'After: a = 10, b = 21, c = 100'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 之后：a = 10，b = 21，c = 100
- en: '```'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `x` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10` .
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，通过参数传递变量时，传递的是其当前值，而不是变量本身。因此，`x`具有`a`变量的值的副本。`a`变量保留其原始值`10`。
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `b` . The `b` variable
    gets incremented when the `y` parameter gets incremented.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为`ref`参数传递时，会传递对变量的引用到方法中。因此，`y`是对`b`的引用。当`y`参数增加时，`b`变量也会增加。
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `c` . The value of the
    `c` variable gets replaced by whatever code executes inside the method. We could
    simplify the code in the `Main` method by not assigning the value `30` to the
    `c` variable since it will always be replaced anyway.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量作为`out`参数传递时，会传递对变量的引用到方法中。因此，`z`是对`c`的引用。`c`变量的值将被方法内部执行的任何代码替换。我们可以简化`Main`方法中的代码，不给`c`变量赋值`30`，因为它总是会被替换。
- en: Simplified out parameters
  id: totrans-1128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的out参数
- en: In C# 7.0 and later, we can simplify code that uses the out variables.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0及更高版本中，我们可以简化使用out变量的代码。
- en: 'In `Program.cs` , add statements to declare some more variables including an
    `out` parameter named `f` declared inline, as shown in the following code:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来声明一些更多的变量，包括内联声明的`out`参数`f`，如下面的代码所示：
- en: '```cs'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: d = 10
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: d = 10
- en: ;
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: e = 20
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: e = 20
- en: ;
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: ；
- en: 'WriteLine($"Before: d ='
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"之前：d =
- en: '{d}'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '{d}'
- en: ', e ='
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: ，e =
- en: '{e}'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '{e}'
- en: ', f doesn''t exist yet!"'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: ，f尚不存在！"
- en: );
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // simplified C# 7.0 or later syntax for the out parameter
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: //简化的C# 7.0或更高版本的out参数语法
- en: bob.PassingParameters(d, ref
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: bob.PassingParameters(d, ref
- en: e, out
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: e, out
- en: int
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: f);
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: f);
- en: 'WriteLine($"After: d ='
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"之后：d =
- en: '{d}'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '{d}'
- en: ', e ='
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: ，e =
- en: '{e}'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '{e}'
- en: ', f ='
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: ', f ='
- en: '{f}'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '{f}'
- en: '"'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding ref returns
  id: totrans-1158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解ref返回
- en: In C# 7.0 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing around
    placeholders into big data structures, but it's beyond the scope of this book.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0或更高版本中，`ref`关键字不仅用于将参数传递给方法；它还可以应用于`return`值。这允许外部变量引用内部变量，并在方法调用后修改其值。这在高级场景中可能很有用，例如将占位符传递到大型数据结构中，但这超出了本书的范围。
- en: Splitting classes using partial
  id: totrans-1160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用partial拆分类
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理具有多个团队成员的大型项目时，或者在处理特别大型和复杂的类实现时，能够将类的定义分割到多个文件中是很有用的。您可以使用`partial`关键字来实现这一点。
- en: Imagine we want to add statements to the `Person` class that are automatically
    generated by a tool like an object-relational mapper that reads schema information
    from a database. If the class is defined as `partial` , then we can split the
    class into an autogenerated code file and a manually edited code file.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向`Person`类添加语句，这些语句是由像对象关系映射器这样的工具自动生成的，该工具从数据库中读取模式信息。如果类被定义为`partial`，那么我们可以将类分成自动生成的代码文件和手动编辑的代码文件。
- en: 'Let''s write some code that simulates this example:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些模拟这个例子的代码：
- en: 'In `Person.cs` , add the `partial` keyword, as shown highlighted in the following
    code:'
  id: totrans-1164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加`partial`关键字，如下面的代码中所示：
- en: '```cs'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: '**partial**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '**partial**'
- en: class
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 人
- en: '{'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '```'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the `PacktLibrary` project/folder, add a new class file named `PersonAutoGen.cs`
    .
  id: totrans-1175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目/文件夹中，添加一个名为`PersonAutoGen.cs`的新类文件。
- en: 'Add statements to the new file, as shown in the following code:'
  id: totrans-1176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句到新文件，如下面的代码所示：
- en: '```cs'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: '{'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: partial
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 部分
- en: class
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 人
- en: '{'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为本章编写的其余代码将在`PersonAutoGen.cs`文件中编写。
- en: Controlling access with properties and indexers
  id: totrans-1190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性和索引器控制访问
- en: 'Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way: properties.'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您创建了一个名为`GetOrigin`的方法，该方法返回一个包含人的姓名和出生地的`string`。像Java这样的语言经常这样做。C#有更好的方法：属性。
- en: A property is simply a method (or a pair of methods) that acts and looks like
    a field when you want to get or set a value, thereby simplifying the syntax.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 属性只是一个方法（或一对方法），当您想要获取或设置一个值时，它的行为和外观就像一个字段，从而简化了语法。
- en: Defining read-only properties
  id: totrans-1193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义只读属性
- en: A `readonly` property only has a `get` implementation.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`属性只有一个`get`实现。'
- en: 'In `PersonAutoGen.cs` , in the `Person` class, add statements to define three
    properties:'
  id: totrans-1195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，在`Person`类中，添加语句来定义三个属性：
- en: The first property will perform the same role as the `GetOrigin` method using
    the property syntax that works with all versions of C# (although, it uses the
    string interpolation syntax from C# 6 and later).
  id: totrans-1196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个属性将使用适用于所有C#版本的属性语法执行与`GetOrigin`方法相同的角色（尽管它使用了C# 6及更高版本的字符串插值语法）。
- en: The second property will return a greeting message using the lambda expression
    body `=>` syntax from C# 6 and later.
  id: totrans-1197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个属性将使用C# 6及更高版本的lambda表达式体`=>`语法返回问候消息。
- en: The third property will calculate the person's age.
  id: totrans-1198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个属性将计算人的年龄。
- en: 'Here''s the code:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '```cs'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // a property defined using C# 1 - 5 syntax
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: //使用C# 1-5语法定义的属性
- en: public
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Origin
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 出身地
- en: '{'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: $"
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: was born on
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 出生于
- en: '{HomePlanet}'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '{HomePlanet}'
- en: '"'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ;
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // two properties defined using C# 6+ lambda expression body syntax
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用C# 6+ lambda表达式体语法定义了两个属性
- en: public
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Greeting => $"
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: Greeting => $"
- en: '{Name}'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: says 'Hello!'"
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: says 'Hello!'"
- en: ;
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Age => System.DateTime.Today.Year - DateOfBirth.Year;
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: Age => System.DateTime.Today.Year - DateOfBirth.Year;
- en: '```'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : This isn''t the best way to calculate someone''s age, but
    we aren''t learning how to calculate an age from a date of birth. If you need
    to do that properly, read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '**Good Practice**：这不是计算某人年龄的最佳方法，但我们并不是在学习如何从出生日期计算年龄。如果您需要正确地这样做，请阅读以下链接的讨论：[https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
- en: 'In `Program.cs` , add the statements to get the properties, as shown in the
    following code:'
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来获取属性，如下面的代码所示：
- en: '```cs'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person sam = new
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: Person sam = new
- en: ()
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = "Sam"
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: Name = "Sam"
- en: ','
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: DateOfBirth = new
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: DateOfBirth = new
- en: (1972
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: (1972
- en: ', 1'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: ', 1'
- en: ', 27'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: ', 27'
- en: )
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '};'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine(sam.Origin);
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(sam.Origin);
- en: WriteLine(sam.Greeting);
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(sam.Greeting);
- en: WriteLine(sam.Age);
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(sam.Age);
- en: '```'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Sam was born on Earth
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: Sam was born on Earth
- en: Sam says 'Hello!'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: Sam says 'Hello!'
- en: '49'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: '```'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The output shows 49 because I ran the console application on August 15, 2021
    when Sam was 49 years old.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示49，因为我在2021年8月15日运行了控制台应用程序，当时Sam已经49岁了。
- en: Defining settable properties
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可设置的属性
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可设置的属性，您必须使用较旧的语法，并提供一对方法——不仅仅是`get`部分，还有一个`set`部分：
- en: 'In `PersonAutoGen.cs` , add statements to define a `string` property that has
    both a `get` and `set` method (also known as a getter and setter), as shown in
    the following code:'
  id: totrans-1255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个具有`get`和`set`方法（也称为getter和setter）的`string`属性，如下面的代码所示：
- en: '```cs'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: FavoriteIceCream { get
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: FavoriteIceCream { get
- en: ; set
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; } // auto-syntax
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: ; } // auto-syntax
- en: '```'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although you have not manually created a field to store the person's favorite
    ice cream, it is there, automatically created by the compiler for you.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您没有手动创建一个字段来存储人的最喜欢的冰淇淋，但它是自动由编译器为您创建的。
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value for the property.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当属性被设置时，您需要更多的控制。在这种情况下，您必须使用更详细的语法，并手动创建一个`private`字段来存储属性的值。
- en: 'In `PersonAutoGen.cs` , add statements to define a `string` field and `string`
    property that has both a `get` and `set` , as shown in the following code:'
  id: totrans-1265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个具有`get`和`set`的`string`字段和`string`属性，如下面的代码所示：
- en: '```cs'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: private
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: string
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: favoritePrimaryColor;
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: favoritePrimaryColor;
- en: public
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: FavoritePrimaryColor
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: FavoritePrimaryColor
- en: '{'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: favoritePrimaryColor;
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: favoritePrimaryColor;
- en: '}'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: switch
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: switch
- en: (value
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: (value
- en: .ToLower())
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: .ToLower())
- en: '{'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: case
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: case
- en: '"red"'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '"red"'
- en: ':'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: case
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: case
- en: '"green"'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '"green"'
- en: ':'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: case
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: case
- en: '"blue"'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '"blue"'
- en: ':'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: favoritePrimaryColor = value
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: favoritePrimaryColor = value
- en: ;
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: ;
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: default
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: default
- en: ':'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: throw
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: throw
- en: new
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: System.ArgumentException(
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: System.ArgumentException(```
- en: $"
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: value
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: value
- en: '}'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: is not a primary color. "
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: is not a primary color. "
- en: +
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '"Choose from: red, green, blue."'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '"Choose from: red, green, blue."'
- en: );
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in setters and getters to simplify your implementations.'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '**Good Practice**：避免向您的getter和setter添加太多代码。这可能表明您的设计存在问题。考虑添加私有方法，然后在setter和getter中调用它们，以简化您的实现。'
- en: 'In `Program.cs` , add statements to set Sam''s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  id: totrans-1316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来设置Sam最喜欢的冰淇淋和颜色，然后将它们写出来，如下面的代码所示：
- en: '```cs'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: sam.FavoriteIceCream = "Chocolate Fudge"
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: sam.FavoriteIceCream = "Chocolate Fudge"
- en: ;
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"Sam's favorite ice-cream flavor is
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's favorite ice-cream flavor is
- en: '{sam.FavoriteIceCream}'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam.FavoriteIceCream}'
- en: ."
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: sam.FavoritePrimaryColor = "Red"
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: sam.FavoritePrimaryColor = "Red"
- en: ;
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"Sam's favorite primary color is
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's favorite primary color is
- en: '{sam.FavoritePrimaryColor}'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam.FavoritePrimaryColor}'
- en: ."
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Sam's favorite ice-cream flavor is Chocolate Fudge.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's favorite ice-cream flavor is Chocolate Fudge.
- en: Sam's favorite primary color is Red.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's favorite primary color is Red.
- en: '```'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If you try to set the color to any value other than red, green, or blue, then
    the code will throw an exception. The calling code could then use a `try` statement
    to display the error message.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将颜色设置为除红色、绿色或蓝色之外的任何值，那么代码将抛出异常。调用代码可以使用`try`语句来显示错误消息。
- en: '**Good Practice** : Use properties instead of fields when you want to validate
    what value can be stored when you want to data bind in XAML, which we will cover
    in *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* (available
    at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ), and when you want to read and write to a field without using a method pair
    like `GetAge` and `SetAge` .'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '**Good Practice**：当您想要验证可以存储什么值时，请使用属性而不是字段，当您想要在XAML中进行数据绑定时，请使用属性，我们将在*第19章*中介绍，*使用.NET
    MAUI构建移动和桌面应用程序*（可在[https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)找到），以及当您想要读取和写入字段而不使用`GetAge`和`SetAge`这样的方法对时。'
- en: Requiring properties to be set during instantiation
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要求在实例化期间设置属性
- en: 'C# 10 introduces the `required` modifier. If you use it on a property, the
    compiler will ensure that you set the property to a value when you instantiate
    it, as shown in the following code:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了`required`修饰符。如果您在属性上使用它，编译器将确保在实例化时将属性设置为一个值，如下面的代码所示：
- en: '```cs'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Book
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: Book
- en: '{'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam['
- en: public
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: required string
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: required string
- en: Isbn { get
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: Isbn { get
- en: ; set
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Title { get
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: Title { get
- en: ; set
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: '}'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you attempt to instantiate a `Book` without setting the `Isbn` property
    you will see a compiler error, as shown in the following code:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试实例化`Book`而没有设置`Isbn`属性，您将看到编译器错误，如下面的代码所示：
- en: '```cs'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Book novel = new
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: Book novel = new
- en: ();
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: '```'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `required` keyword might not make it into the final release version of .NET
    6 so treat this section as theoretical.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`关键字可能不会出现在.NET 6的最终版本中，因此将此部分视为理论性的。'
- en: Defining indexers
  id: totrans-1363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义索引器
- en: Indexers allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an **indexer** so that the calling code
    can access individual characters in the `string` .
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器允许调用代码使用数组语法来访问属性。例如，`string`类型定义了一个**索引器**，以便调用代码可以访问`string`中的单个字符。
- en: 'We will define an indexer to simplify access to the children of a person:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个索引器，以简化对人的子代的访问：
- en: 'In `PersonAutoGen.cs` , add statements to define an indexer to get and set
    a child using the index of the child, as shown in the following code:'
  id: totrans-1366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句来定义一个索引器，以使用子代的索引，如下面的代码所示：
- en: '```cs'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // indexers
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: // 索引器
- en: public
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: Person this
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: Person this
- en: '[int'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '[int'
- en: index]
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: index]
- en: '{'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Children[index]; // pass on to the List<T> indexer
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: Children[index]; // 传递给List<T>索引器
- en: '}'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Children[index] = value
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: Children[index] = value
- en: ;
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重载索引器，以便不同类型可以用于它们的参数。例如，除了传递`int`值外，您还可以传递`string`值。
- en: 'In `Program.cs` , add statements to add two children to `Sam` , and then access
    the first and second child using the longer `Children` field and the shorter indexer
    syntax, as shown in the following code:'
  id: totrans-1387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来向`Sam`添加两个子代，然后使用更长的`Children`字段和更短的索引器语法访问第一个和第二个子代，如下面的代码所示：
- en: '```cs'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: sam.Children.Add(new
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: sam.Children.Add(new
- en: () { Name = "Charlie"
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Charlie"
- en: '});'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: sam.Children.Add(new
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: sam.Children.Add(new
- en: () { Name = "Ella"
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Ella"
- en: '});'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: WriteLine($"Sam's first child is
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's first child is
- en: '{sam.Children['
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam.Children['
- en: '0'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '].Name}'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '].Name}'
- en: '"'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"Sam's second child is
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's second child is
- en: '{sam.Children['
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam.Children['
- en: '1'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '].Name}'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '].Name}'
- en: '"'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"Sam's first child is
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's first child is
- en: '{sam['
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam['
- en: '0'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '].Name}'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '].Name}'
- en: '"'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"Sam's second child is
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Sam's second child is
- en: '{sam['
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '{sam['
- en: '1'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '].Name}'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '].Name}'
- en: '"'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Sam's first child is Charlie
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's first child is Charlie
- en: Sam's second child is Ella
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's second child is Ella
- en: Sam's first child is Charlie
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's first child is Charlie
- en: Sam's second child is Ella
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: Sam's second child is Ella
- en: '```'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Pattern matching with objects
  id: totrans-1427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pattern matching with objects
- en: In *Chapter 3* , *Controlling Flow, Converting Types, and Handling Exceptions*
    , you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*控制流、类型转换和异常处理*中，您已经了解了基本的模式匹配。在本节中，我们将更详细地探讨模式匹配。
- en: Creating and referencing a .NET 6 class library
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和引用.NET 6类库
- en: The enhanced pattern matching features are only available in modern .NET class
    libraries that support C# 9 or later.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的模式匹配功能仅适用于支持C# 9或更高版本的现代.NET类库。
- en: Use your preferred coding tool to add a new class library named `PacktLibraryModern`
    to the workspace/solution named `Chapter05` .
  id: totrans-1431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具向工作区/解决方案中添加一个名为`Chapter05`的新类库`PacktLibraryModern`。
- en: 'In the `PeopleApp` project, add a reference to the `PacktLibraryModern` class
    library, as shown highlighted in the following markup:'
  id: totrans-1432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加对`PacktLibraryModern`类库的引用，如下标记所示：
- en: '```cs'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>enable</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: <ItemGroup>
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <ProjectReference Include="../PacktLibrary/PacktLibrary.csproj"
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: <ProjectReference Include="../PacktLibrary/PacktLibrary.csproj"
- en: />
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: '**<ProjectReference**'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ProjectReference**'
- en: '**Include=**'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '**Include=**'
- en: '**"../PacktLibraryModern/PacktLibraryModern.csproj"**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**"../PacktLibraryModern/PacktLibraryModern.csproj"**'
- en: '**/>**'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: </ItemGroup>
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: </Project>
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `PeopleApp` project.
  id: totrans-1453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目。
- en: Defining flight passengers
  id: totrans-1454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义航班乘客
- en: In this example, we will define some classes that represent various types of
    passengers on a flight and then we will use a switch expression with pattern matching
    to determine the cost of their flight.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一些代表飞行中各种类型乘客的类，然后我们将使用模式匹配的switch表达式来确定他们航班的费用。
- en: In the `PacktLibraryModern` project/folder, rename the file `Class1.cs` to `FlightPatterns.cs`
    .
  id: totrans-1456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目/文件夹中，将文件`Class1.cs`重命名为`FlightPatterns.cs`。
- en: 'In `FlightPatterns.cs` , add statements to define three types of passengers
    with different properties, as shown in the following code:'
  id: totrans-1457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FlightPatterns.cs`中，添加语句来定义三种不同属性的乘客类型，如下面的代码所示：
- en: '```cs'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ; // C# 10 file-scoped namespace
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: ; // C# 10文件范围的命名空间
- en: public
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: BusinessClassPassenger
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: BusinessClassPassenger
- en: '{'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: override
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: override
- en: string
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: ToString
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: ToString
- en: ()
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"Business Class"
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: $"Business Class"
- en: ;
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: FirstClassPassenger
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger
- en: '{'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: AirMiles { get
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: AirMiles { get
- en: ; set
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: override
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: override
- en: string
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: ToString
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: ToString
- en: ()
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"First Class with
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: $"First Class with
- en: '{AirMiles:N0}'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '{AirMiles:N0}'
- en: air miles"
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: air miles"
- en: ;
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: CoachClassPassenger
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger
- en: '{'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: double
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: CarryOnKG { get
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: CarryOnKG { get
- en: ; set
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: override
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: override
- en: string
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: ToString
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: ToString
- en: ()
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"Coach Class with
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: $"教练舱，带有
- en: '{CarryOnKG:N2}'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '{CarryOnKG:N2}'
- en: KG carry on"
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 公斤随身携带"
- en: ;
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to define an object array containing five
    passengers of various types and property values, and then enumerate them, outputting
    the cost of their flight, as shown in the following code:'
  id: totrans-1522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来定义一个包含五个不同类型和属性值的乘客的对象数组，然后枚举它们，输出他们的飞行费用，如下面的代码所示：
- en: '```cs'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: object
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '[] passengers = {'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '[] 乘客 = {'
- en: new
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: FirstClassPassenger { AirMiles = 1
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger { AirMiles = 1
- en: _419 },
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: _419 },
- en: new
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: FirstClassPassenger { AirMiles = 16
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger { AirMiles = 16
- en: _562 },
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: _562 },
- en: new
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: BusinessClassPassenger(),
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: BusinessClassPassenger(),
- en: new
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: CoachClassPassenger { CarryOnKG = 25.7
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger { CarryOnKG = 25.7
- en: '},'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: CoachClassPassenger { CarryOnKG = 0
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger { CarryOnKG = 0
- en: '},'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '};'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: foreach
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (object
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: (object
- en: passenger in
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: passenger in
- en: passengers)
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: passengers)
- en: '{'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: decimal
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: flightCost = passenger switch
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: flightCost = passenger switch
- en: '{'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: FirstClassPassenger p when
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger p when
- en: p.AirMiles > 35000
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: p.AirMiles > 35000
- en: => 1500
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: => 1500
- en: M,
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: FirstClassPassenger p when
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger p when
- en: p.AirMiles > 15000
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: p.AirMiles > 15000
- en: => 1750
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: => 1750
- en: M,
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: FirstClassPassenger _                         => 2000
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger _                         => 2000
- en: M,
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: BusinessClassPassenger _                      => 1000
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: BusinessClassPassenger _                      => 1000
- en: M,
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: CoachClassPassenger p when
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger p when
- en: p.CarryOnKG < 10.0
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: p.CarryOnKG < 10.0
- en: => 500
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: => 500
- en: M,
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: CoachClassPassenger _                         => 650
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger _                         => 650
- en: M,
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: _                                             => 800
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: _                                             => 800
- en: M
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: M
- en: '};'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine($"Flight costs
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"飞行费用
- en: '{flightCost:C}'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '{flightCost:C}'
- en: for
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: '{passenger}'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '{passenger}'
- en: '"'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'While reviewing the preceding code, note the following:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查前面的代码时，请注意以下内容：
- en: To pattern match on the properties of an object, you must name a local variable
    that can then be used in an expression like `p` .
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对对象的属性进行模式匹配，必须命名一个局部变量，然后可以在表达式中使用`p`。
- en: To pattern match on a type only, you can use `_` to discard the local variable.
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅对类型进行模式匹配，可以使用`_`来丢弃局部变量。
- en: The switch expression also uses `_` to represent its default branch.
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: switch表达式还使用`_`来表示其默认分支。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Flight costs £2,000.00 for First Class with 1,419 air miles
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行费用为£2,000.00，头等舱带有1,419英里
- en: Flight costs £1,750.00 for First Class with 16,562 air miles
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行费用为£1,750.00，头等舱带有16,562英里
- en: Flight costs £1,000.00 for Business Class
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行费用为£1,000.00，商务舱
- en: Flight costs £650.00 for Coach Class with 25.70 KG carry on
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行费用为£650.00，教练舱带有25.70公斤的随身携带
- en: Flight costs £500.00 for Coach Class with 0.00 KG carry on
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 飞行费用为£500.00，教练舱带有0.00公斤的随身携带
- en: '```'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Enhancements to pattern matching in C# 9 or later
  id: totrans-1590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 9或更高版本中的模式匹配增强
- en: 'The previous examples worked with C# 8\. Now we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    when doing type matching:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例适用于C# 8。现在我们将看一些C# 9及更高版本的增强功能。首先，当进行类型匹配时，您不再需要使用下划线来丢弃：
- en: 'In `Program.cs` , comment out the C# 8 syntax and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested switch expression
    and the new support for conditionals like `>` , as shown in the following code:'
  id: totrans-1592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉C# 8的语法，并添加C# 9及更高版本的语法，以修改头等舱乘客的分支，使用嵌套的switch表达式和新的条件支持，如下面的代码所示：
- en: '```cs'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: decimal
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: decimal
- en: flightCost = passenger switch
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: flightCost = passenger switch
- en: '{'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /* C# 8 syntax
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: /* C# 8语法
- en: FirstClassPassenger p when p.AirMiles > 35000 => 1500M,
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger p when p.AirMiles > 35000 => 1500M,
- en: FirstClassPassenger p when p.AirMiles > 15000 => 1750M,
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger p when p.AirMiles > 15000 => 1750M,
- en: FirstClassPassenger                           => 2000M, */
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger                           => 2000M, */
- en: // C# 9 or later syntax
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: // C# 9或更高版本的语法
- en: FirstClassPassenger p => p.AirMiles switch
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger p => p.AirMiles switch
- en: '{'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '35000'
  id: totrans-1604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '35000'
- en: => 1500
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: => 1500
- en: M,
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: '15000'
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '15000'
- en: => 1750
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: => 1750
- en: M,
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: _       => 2000
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: _       => 2000
- en: M
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: M
- en: '},'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: BusinessClassPassenger                        => 1000
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: BusinessClassPassenger                        => 1000
- en: M,
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: CoachClassPassenger p when
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger p when
- en: p.CarryOnKG < 10.0
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: p.CarryOnKG < 10.0
- en: => 500
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: => 500
- en: M,
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: M，
- en: CoachClassPassenger                           => 650
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: CoachClassPassenger                           => 650
- en: M,
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: _                                             => 800
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: _                                             => 800
- en: M
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: M
- en: '};'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '```'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Run the code to view the results, and note they are the same as before.
  id: totrans-1625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，并注意它们与以前相同。
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested switch expression, as shown in the following code:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用关系模式与属性模式结合，以避免嵌套的switch表达式，如下面的代码所示：
- en: '```cs'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'FirstClassPassenger { AirMiles: > 35000'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 'FirstClassPassenger { AirMiles: > 35000'
- en: '} => 1500'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '} => 1500'
- en: ','
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'FirstClassPassenger { AirMiles: > 15000'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 'FirstClassPassenger { AirMiles: > 15000'
- en: '} => 1750'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '} => 1750'
- en: M,
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: FirstClassPassenger => 2000
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: FirstClassPassenger => 2000
- en: M,
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: M,
- en: '```'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Working with records
  id: totrans-1637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理记录
- en: Before we dive into the new records language feature of C# 9 and later, let
    us see some other related new features.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究C# 9及更高版本的新记录语言功能之前，让我们看一些其他相关的新功能。
- en: Init-only properties
  id: totrans-1639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅初始化属性
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中始终使用对象初始化语法来实例化对象并设置初始属性。这些属性也可以在实例化后更改。
- en: 'Sometimes you want to treat properties like `readonly` fields so they can be
    set during instantiation but not after. The new `init` keyword enables this. It
    can be used in place of the `set`  keyword:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望将属性视为`readonly`字段，以便在实例化期间进行设置，但在之后不进行设置。新的`init`关键字使这成为可能。它可以用来代替`set`关键字：
- en: In the `PacktLibraryModern` project/folder, add a new file named `Records.cs`
    .
  id: totrans-1642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目/文件夹中，添加一个名为`Records.cs`的新文件。
- en: 'In `Records.cs` , define an immutable person class, as shown in the following
    code:'
  id: totrans-1643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Records.cs` , define an immutable person class, as shown in the following
    code:'
- en: '```cs'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ; // C# 10 file-scoped namespace
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: ; // C# 10 file-scoped namespace
- en: public
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: ImmutablePerson
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutablePerson
- en: '{'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? FirstName { get'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '? FirstName { get'
- en: ; init
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? LastName { get'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '? LastName { get'
- en: ; init
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: '}'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to instantiate a new immutable person and
    then try to change one of its properties, as shown in the following code:'
  id: totrans-1664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to instantiate a new immutable person and
    then try to change one of its properties, as shown in the following code:'
- en: '```cs'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: ImmutablePerson jeff = new
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutablePerson jeff = new
- en: ()
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: FirstName = "Jeff"
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: FirstName = "Jeff"
- en: ','
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: LastName = "Winger"
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: LastName = "Winger"
- en: '};'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: jeff.FirstName = "Geoff"
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: jeff.FirstName = "Geoff"
- en: ;
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  id: totrans-1676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Compile the console app and note the compile error, as shown in the following
    output:'
- en: '```cs'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Program.cs(254,7): error CS8852: Init-only property or indexer ''ImmutablePerson.FirstName''
    can only be assigned in an object initializer, or on ''this'' or ''base'' in an
    instance constructor or an ''init'' accessor. [/Users/markjprice/Code/Chapter05/PeopleApp/PeopleApp.csproj]'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 'Program.cs(254,7): error CS8852: Init-only property or indexer ''ImmutablePerson.FirstName''
    can only be assigned in an object initializer, or on ''this'' or ''base'' in an
    instance constructor or an ''init'' accessor. [/Users/markjprice/Code/Chapter05/PeopleApp/PeopleApp.csproj]'
- en: '```'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  id: totrans-1680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Comment out the attempt to set the `FirstName` property after instantiation.
- en: Understanding records
  id: totrans-1681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Understanding records
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **records** . These are defined by using the `record` keyword
    instead of the `class` keyword. That can make the whole object immutable, and
    it acts like a value when compared. We will discuss equality and comparisons of
    classes, records, and value types in more detail in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: Init-only properties provide some immutability to C#. You can take the concept
    further by using **records** . These are defined by using the `record` keyword
    instead of the `class` keyword. That can make the whole object immutable, and
    it acts like a value when compared. We will discuss equality and comparisons of
    classes, records, and value types in more detail in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
- en: 'Records should not have any state (properties and fields) that changes after
    instantiation. Instead, the idea is that you create new records from existing
    ones with any changed state. This is called non-destructive mutation. To do this,
    C# 9 introduced the `with` keyword:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 'Records should not have any state (properties and fields) that changes after
    instantiation. Instead, the idea is that you create new records from existing
    ones with any changed state. This is called non-destructive mutation. To do this,
    C# 9 introduced the `with` keyword:'
- en: 'In `Records.cs` , add a record named `ImmutableVehicle` , as shown in the following
    code:'
  id: totrans-1684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Records.cs` , add a record named `ImmutableVehicle` , as shown in the following
    code:'
- en: '```cs'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: record
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: record
- en: ImmutableVehicle
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableVehicle
- en: '{'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Wheels { get
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: Wheels { get
- en: ; init
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? Color { get'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '? Color { get'
- en: ; init
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? Brand { get'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '? Brand { get'
- en: ; init
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: '}'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to create a `car` and then a mutated copy
    of it, as shown in the following code:'
  id: totrans-1707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to create a `car` and then a mutated copy
    of it, as shown in the following code:'
- en: '```cs'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: ImmutableVehicle car = new
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableVehicle car = new
- en: ()
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Brand = "Mazda MX-5 RF"
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: Brand = "Mazda MX-5 RF"
- en: ','
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: Color = "Soul Red Crystal Metallic"
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: Color = "Soul Red Crystal Metallic"
- en: ','
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: Wheels = 4
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: Wheels = 4
- en: '};'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: ImmutableVehicle repaintedCar = car
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableVehicle repaintedCar = car
- en: with
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '{ Color = "Polymetal Grey Metallic"'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '{ Color = "Polymetal Grey Metallic"'
- en: '};'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine($"Original car color was
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"Original car color was
- en: '{car.Color}'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '{car.Color}'
- en: ."
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"New car color is
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"New car color is
- en: '{repaintedCar.Color}'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '{repaintedCar.Color}'
- en: ."
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code to view the results, and note the change to the car color in the
    mutated copy, as shown in the following output:'
  id: totrans-1731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Run the code to view the results, and note the change to the car color in the
    mutated copy, as shown in the following output:'
- en: '```cs'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Original car color was Soul Red Crystal Metallic.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: Original car color was Soul Red Crystal Metallic.
- en: New car color is Polymetal Grey Metallic.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: New car color is Polymetal Grey Metallic.
- en: '```'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Positional data members in records
  id: totrans-1736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Positional data members in records
- en: The syntax for defining a record can be greatly simplified using positional
    data members.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: The syntax for defining a record can be greatly simplified using positional
    data members.
- en: Simplifying data members in records
  id: totrans-1738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Simplifying data members in records
- en: 'Instead of using object initialization syntax with curly braces, sometimes
    you might prefer to provide a constructor with positional parameters as you saw
    earlier in this chapter. You can also combine this with a deconstructor for splitting
    the object into individual parts, as shown in the following code:'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 'Instead of using object initialization syntax with curly braces, sometimes
    you might prefer to provide a constructor with positional parameters as you saw
    earlier in this chapter. You can also combine this with a deconstructor for splitting
    the object into individual parts, as shown in the following code:'
- en: '```cs'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: record
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: record
- en: ImmutableAnimal
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableAnimal
- en: '{'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Name { get
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: Name { get
- en: ; init
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Species { get
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: Species { get
- en: ; init
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: ; init
- en: ; }
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: ImmutableAnimal
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableAnimal
- en: (
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: name,
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: name,
- en: string
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: species
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: species
- en: )
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = name;
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: Name = name;
- en: Species = species;
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: Species = species;
- en: '}'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Deconstruct
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: Deconstruct
- en: (
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: out
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: string
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: name,
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: name,
- en: out
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: out
- en: string
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: species
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: species
- en: )
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: name = Name;
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: name = Name;
- en: species = Species;
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: species = Species;
- en: '}'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 'The properties, constructor, and deconstructor can be generated for you:'
- en: 'In `Records.cs` , add statements to define another record using simplified
    syntax known as positional records, as shown in the following code:'
  id: totrans-1785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Records.cs` , add statements to define another record using simplified
    syntax known as positional records, as shown in the following code:'
- en: '```cs'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // simpler way to define a record
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: // simpler way to define a record
- en: // auto-generates the properties, constructor, and deconstructor
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: // auto-generates the properties, constructor, and deconstructor
- en: public
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: record
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: record
- en: ImmutableAnimal
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableAnimal
- en: (
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Name,
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: Name,
- en: string
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: Species
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: Species
- en: )
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  id: totrans-1800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'In `Program.cs` , add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
- en: '```cs'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: ImmutableAnimal oscar = new
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableAnimal oscar = new
- en: ("Oscar"
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: ("Oscar"
- en: ', "Labrador"'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: ', "Labrador"'
- en: );
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: var
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: (who, what) = oscar; // calls Deconstruct method
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: (who, what) = oscar; // calls Deconstruct method
- en: WriteLine($"
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{who}'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '{谁}'
- en: is a
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个
- en: '{what}'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '{什么}'
- en: ."
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the application and view the results, as shown in the following output:'
  id: totrans-1815
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Oscar is a Labrador.
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 奥斯卡是一只拉布拉多犬。
- en: '```'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You will see records again when we look at C# 10 support for creating `struct`
    records in *Chapter 6* , *Implementing Interfaces and Inheriting Classes* .
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 *第 6 章* *实现接口和继承类* 中查看 C# 10 支持创建 `struct` 记录时，您将再次看到记录。
- en: Practicing and exploring
  id: totrans-1820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试您的知识和理解，进行一些实践，并深入研究本章的主题。
- en: Exercise 5.1 – Test your knowledge
  id: totrans-1822
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What are the six combinations of access modifier keywords and what do they do?
  id: totrans-1824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有六种访问修饰符关键字的组合，它们分别是什么？
- en: What is the difference between the `static` , `const` , and `readonly` keywords
    when applied to a type member?
  id: totrans-1825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static` 、 `const` 和 `readonly` 关键字在应用于类型成员时有什么区别？'
- en: What does a constructor do?
  id: totrans-1826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数是做什么的？
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  id: totrans-1827
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您想要存储组合值时，为什么应该将 `[Flags]` 属性应用于 `enum` 类型？
- en: Why is the `partial` keyword useful?
  id: totrans-1828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 `partial` 关键字有用？
- en: What is a tuple?
  id: totrans-1829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是元组？
- en: What does the `record` keyword do?
  id: totrans-1830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`record` 关键字是做什么的？'
- en: What does overloading mean?
  id: totrans-1831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载是什么意思？
- en: What is the difference between a field and a property?
  id: totrans-1832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段和属性之间有什么区别？
- en: How do you make a method parameter optional?
  id: totrans-1833
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使方法参数可选？
- en: Exercise 5.2 – Explore topics
  id: totrans-1834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.2 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接，了解本章涵盖的主题的更多细节：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
- en: Summary
  id: totrans-1837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about making your own types using OOP. You learned
    about some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions, and you used OOP concepts,
    such as aggregation and encapsulation. You saw examples of how to use modern C#
    features like relational and property pattern matching enhancements, init-only
    properties, and records.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了使用面向对象编程制作自己的类型。您了解了类型可以具有的不同成员类别，包括用于存储数据的字段和用于执行操作的方法，并且您使用了面向对象编程的概念，如聚合和封装。您看到了如何使用现代
    C# 功能，如关系和属性模式匹配增强、仅初始化属性和记录。
- en: In the next chapter, you will take these concepts further by defining delegates
    and events, implementing interfaces, and inheriting from existing classes.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将进一步了解这些概念，包括定义委托和事件、实现接口以及继承现有类。
