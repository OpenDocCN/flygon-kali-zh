- en: Tools, Frameworks, and Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具、框架和环境
- en: '"We become what we behold. We shape our tools and then our tools shape us."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们成为我们所看到的。我们塑造我们的工具，然后我们的工具塑造我们。”
- en: – Marshall McLuhan
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 马歇尔·麦克卢汉'
- en: As every soldier knows his weapons, a programmer must be familiar with the development
    ecosystem and those tools that make programming much easier. Whether you are already
    using any of these tools at work or home, it is worth taking a look at many of
    them and comparing their features, advantages, and disadvantages. Let's get an
    overview of what we can find nowadays about the following topics and construct
    a small project to get familiar with some of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每个士兵都了解他的武器一样，程序员必须熟悉开发生态系统和使编程更加容易的工具。无论您是否已经在工作或家中使用这些工具中的任何一个，都值得看看它们的特点、优势和劣势。让我们概述一下我们现在可以找到的关于以下主题的内容，并构建一个小项目来熟悉其中一些。
- en: We won't go into the details of those tools and frameworks, since that will
    be done later on in the following chapters. The goal is to get you up and running,
    and provide you with a short overview of what they do and how.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍这些工具和框架，因为这将在接下来的章节中进行。我们的目标是让您快速上手，并为您提供它们的简要概述以及它们的功能和使用方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Git
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Virtual machines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机
- en: Build tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具
- en: The integrated development environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: Unit testing frameworks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: Hamcrest and AssertJ
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hamcrest和AssertJ
- en: Code coverage tools
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖工具
- en: Mocking frameworks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟框架
- en: User interface testing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面测试
- en: Behavior-driven development
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: Git
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: Git is the most popular revision control system. For that reason, all the code
    used in this book is stored in Bitbucket ([https://bitbucket.org/](https://bitbucket.org/)).
    If you don't have it already, install Git. Distributions for all the popular operating
    systems can be found at: [http://git-scm.com](http://git-scm.com).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Git是最流行的版本控制系统。因此，本书中使用的所有代码都存储在Bitbucket（[https://bitbucket.org/](https://bitbucket.org/)）中。如果您还没有安装Git，请安装Git。所有流行操作系统的发行版都可以在以下网址找到：[http://git-scm.com](http://git-scm.com)。
- en: Many graphical interfaces are available for Git; some of them being Tortoise
    ([https://code.google.com/p/tortoisegit](https://code.google.com/p/tortoisegit)),
    Source Tree ([https://www.sourcetreeapp.com](https://www.sourcetreeapp.com)),
    and Tower ([http://www.git-tower.com/](http://www.git-tower.com/)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Git有许多图形界面可用；其中一些是Tortoise（[https://code.google.com/p/tortoisegit](https://code.google.com/p/tortoisegit)）、Source
    Tree（[https://www.sourcetreeapp.com](https://www.sourcetreeapp.com)）和Tower（[http://www.git-tower.com/](http://www.git-tower.com/)）。
- en: Virtual machines
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机
- en: Even though they are outside the topic of this book, virtual machines are a
    powerful tool and a first-class citizen in a good development environment. They
    provide dynamic and easy-to-use resources in isolated systems so they can be used
    and dropped at the time we need them. This helps developers to focus on their
    tasks instead of wasting their time creating or installing required services from
    scratch. This is the reason why virtual machines have found room in here. We want
    to take advantage of them to keep you focused on the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们不是本书的主题，但虚拟机是一个强大的工具，在良好的开发环境中是一等公民。它们在隔离系统中提供动态和易于使用的资源，因此可以在需要时使用和丢弃。这有助于开发人员专注于他们的任务，而不是浪费时间从头开始创建或安装所需的服务。这就是为什么虚拟机在这里找到了位置的原因。我们希望利用它们让您专注于代码。
- en: In order to have the same environment no matter the OS you're using, we'll be
    creating virtual machines with Vagrant and deploying required applications with
    Docker. We chose Ubuntu as a base operating system in our examples, just because
    it is a popular, commonly used Unix-like distribution. Most of these technologies
    are platform-independent, but occasionally you won't be able to follow the instructions
    found here because you might be using some other operating system. In that case,
    your task is to find what the differences are between Ubuntu and your operating
    system and act accordingly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在使用不同操作系统时拥有相同的环境，我们将使用Vagrant创建虚拟机，并使用Docker部署所需的应用程序。我们选择Ubuntu作为我们示例中的基本操作系统，只是因为它是一种流行的常用的类Unix发行版。大多数这些技术都是跨平台的，但偶尔您可能无法按照这里找到的说明进行操作，因为您可能使用其他操作系统。在这种情况下，您的任务是找出Ubuntu和您的操作系统之间的差异，并相应地采取行动。
- en: Vagrant
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vagrant
- en: Vagrant is the tool we are going to use for creating the development environment
    stack. It is an easy way to initialize ready-to-go virtual machines with minimum
    effort using preconfigured boxes. All boxes and configurations are placed in one
    file, called the `Vagrant` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是我们将用于创建开发环境堆栈的工具。这是一种简单的方法，可以使用预配置的虚拟机初始化准备就绪的虚拟机，而只需付出最少的努力。所有的虚拟机和配置都放在一个文件中，称为“Vagrant”文件。
- en: Here is an example of creating a simple Ubuntu box. We made an extra configuration
    for installing MongoDB using Docker (the usage of Docker will be explained shortly).
    We assume that you have VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))
    and Vagrant ([https://www.vagrantup.com](https://www.vagrantup.com)) installed
    on your computer and that you have internet access.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建一个简单Ubuntu虚拟机的示例。我们额外配置了使用Docker安装MongoDB（Docker的使用将很快解释）。我们假设您的计算机上已安装了VirtualBox（[https://www.virtualbox.org](https://www.virtualbox.org)）和Vagrant（[https://www.vagrantup.com](https://www.vagrantup.com)），并且您有互联网访问。
- en: 'In this particular case, we are creating an instance of Ubuntu 64-bits using
    the Ubuntu box (`ubuntu/trusty64`) and specifying that the VM should have 1 GB
    of RAM:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们正在创建一个Ubuntu 64位实例，使用Ubuntu box（`ubuntu/trusty64`）并指定VM应该有1GB的RAM：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Further on, we''re exposing MongoDB''s default port in the Vagrant machine
    and running it using Docker:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在Vagrant机器中公开MongoDB的默认端口，并使用Docker运行它：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, in order to speed up the Vagrant setup, we're caching some resources.
    You should install the plugin called `cachier`. For further information, visit: [https://github.com/fgrehm/vagrant-cachier](https://github.com/fgrehm/vagrant-cachier).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了加快Vagrant的设置速度，我们正在缓存一些资源。您应该安装名为`cachier`的插件。有关更多信息，请访问：[https://github.com/fgrehm/vagrant-cachier](https://github.com/fgrehm/vagrant-cachier)。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now it''s time to see it working. It usually takes a few minutes to run it
    for the first time because the base box and all the dependencies need to be downloaded
    and installed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看它运行了。第一次运行通常需要几分钟，因为需要下载和安装基本框和所有依赖项：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When this command is run, you should see the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，您应该看到以下输出：
- en: '![](img/beed715c-3901-41ea-8d2a-97d563266fc0.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beed715c-3901-41ea-8d2a-97d563266fc0.png)'
- en: Be patient until the execution is finished. Once done, you'll have a new virtual
    machine with Ubuntu, Docker, and one MongoDB instance up and running. The best
    part is that all this was accomplished with a single command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待执行完成。完成后，您将拥有一个新的Ubuntu虚拟机，其中已经安装了Docker和一个MongoDB实例。最棒的部分是所有这些都是通过一个命令完成的。
- en: 'To see the status of the currently running VM, we can use the `status` argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前运行的VM的状态，可以使用`status`参数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The virtual machine can be accessed either through `ssh` or by using Vagrant
    commands, as in the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`ssh`或使用Vagrant命令访问虚拟机，如以下示例：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, to stop the virtual machine, exit from it and run the `vagrant halt`
    command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要停止虚拟机，请退出虚拟机并运行`vagrant halt`命令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the list of Vagrant boxes or further details about configuring Vagrant,
    visit: [https://www.vagrantup.com](https://www.vagrantup.com).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下网址获取Vagrant框的列表或有关配置Vagrant的更多详细信息：[https://www.vagrantup.com](https://www.vagrantup.com)。
- en: Docker
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Once the environment is set, it is time to install the services and the software
    that we need. This can be done using Docker, a simple and portable way to ship
    and run many applications and services in isolated containers. We will use it
    to install the required databases, web servers, and all the other applications
    required throughout this book, in a virtual machine created using Vagrant. In
    fact, the Vagrant VM that was previously created already has an example of getting
    an instance of MongoDB up and running using Docker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境后，是时候安装我们需要的服务和软件了。这可以通过Docker来完成，Docker是一种简单且便携的方式，可以在隔离的容器中运行许多应用程序和服务。我们将使用它来安装所需的数据库、Web服务器以及本书中需要的所有其他应用程序，这些都将在使用Vagrant创建的虚拟机中进行。事实上，之前创建的Vagrant虚拟机已经有一个使用Docker运行MongoDB实例的示例。
- en: 'Let''s bring up the VM again (we stopped it previously with the `vagrant halt`
    command) and also MongoDB:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次启动VM（我们之前使用`vagrant halt`命令停止了它），还有MongoDB：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With `docker start`, we started the container; with `docker ps`, we listed all
    the running processes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker start`启动了容器；使用`docker ps`列出了所有正在运行的进程。
- en: By using this kind of procedure, we are able to reproduce a full-stack environment
    in the blink of an eye. You may be wondering if this is as awesome as it sounds.
    The answer is yes, it is. Vagrant and Docker allow developers to focus on what
    they are supposed to do and forget about complex installations and tricky configurations.
    Furthermore, we made an extra effort to provide you with all the necessary steps
    and resources to reproduce and test all the code examples and demonstrations in
    this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种程序，我们能够在眨眼之间复制一个全栈环境。您可能想知道这是否像听起来的那样令人敬畏。答案是肯定的，它确实如此。Vagrant和Docker允许开发人员专注于他们应该做的事情，而不必担心复杂的安装和棘手的配置。此外，我们额外努力为您提供了在本书中复制和测试所有代码示例和演示所需的所有步骤和资源。
- en: Build tools
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工具
- en: With time, code tends to grow both in complexity and size. This occurs in the
    software industry by its nature. All products evolve constantly and new requirements
    are made and implemented across a product's life. Build tools offer a way to make
    managing the project life cycle as straightforward as possible, by following a
    few code conventions, such as the organization of your code, in a specific way,
    and by the usage of naming a convention for your classes or a determined project
    structure formed by different folders and files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，代码往往会在复杂性和规模上增长。这是软件行业的本质。所有产品都在不断发展，并且在产品的整个生命周期中都会实施新的要求。构建工具提供了一种尽可能简化项目生命周期管理的方法，通过遵循一些代码约定，例如以特定方式组织代码，并使用命名约定为您的类或由不同文件夹和文件组成的确定项目结构。
- en: Some of you might be familiar with Maven or Ant. They are a great couple of
    Swiss army knives for handling projects, but we are here to learn so we decided
    to use Gradle. Some of the advantages of Gradle are its reduced boilerplate code,
    resulting in a much shorter file and a more readable configuration file. Among
    others, Google uses it as its build tool. It is supported by IntelliJ IDEA and
    is quite easy to learn and work with. Most of the functionalities and tasks are
    obtained by adding plugins.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉Maven或Ant。它们是处理项目的绝佳工具，但我们在这里是为了学习，所以决定使用Gradle。Gradle的一些优点是减少了样板代码，使文件更短、配置文件更易读。此外，Google将其用作构建工具。它得到了IntelliJ
    IDEA的支持，非常容易学习和使用。通过添加插件，大多数功能和任务都可以实现。
- en: Mastering Gradle is not the goal of this book. So, if you want to learn more
    about this awesome tool, take a tour through its website ([http://gradle.org/](http://gradle.org/))
    and read about the plugins you can use and the options you can customize. For
    a comparison of different Java build tools, visit: [https://technologyconversations.com/2014/06/18/build-tools/](https://technologyconversations.com/2014/06/18/build-tools/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 精通Gradle不是本书的目标。因此，如果您想了解更多关于这个令人敬畏的工具，请访问其网站（[http://gradle.org/](http://gradle.org/)）并阅读您可以使用的插件和可以自定义的选项。要比较不同的Java构建工具，请访问：[https://technologyconversations.com/2014/06/18/build-tools/](https://technologyconversations.com/2014/06/18/build-tools/)。
- en: Before proceeding forward, make sure that Gradle is installed on your system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保Gradle已安装在您的系统上。
- en: 'Let''s analyze the relevant parts of a `build.gradle` file. It holds project
    information in a concise way, using Groovy as the descriptor language. This is
    our project''s build file, autogenerated with IntelliJ:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析 `build.gradle` 文件的相关部分。它以 Groovy 作为描述语言，以简洁的方式保存项目信息。这是我们的项目构建文件，由 IntelliJ
    自动生成：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A Java plugin is applied since it is a Java project. It brings common Java
    tasks, such as build, package, test, and so on. The source compatibility is set
    to JDK 7\. The compiler will complain if we try to use the Java syntax that is
    not supported by this version:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 Java 项目，所以应用了 Java 插件。它带来了常见的 Java 任务，如构建、打包、测试等。源兼容性设置为 JDK 7。如果我们尝试使用此版本不支持的
    Java 语法，编译器将会报错：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Maven Central ([http://search.maven.org/](http://search.maven.org/)) holds
    all our project dependencies. This section tells Gradle where to pull them from.
    The Maven Central repository is enough for this project, but you can add your
    custom repositories, if any. Nexus and Ivy are also supported:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Maven Central（[http://search.maven.org/](http://search.maven.org/)）保存了我们的所有项目依赖项。本节告诉
    Gradle 从哪里获取它们。Maven Central 仓库对于这个项目已经足够了，但如果有的话，您可以添加自定义仓库。Nexus 和 Ivy 也受支持：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Last, but not least, this is how project dependencies are declared. IntelliJ
    decided to use JUnit as the testing framework.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是项目依赖项的声明方式。IntelliJ 决定使用 JUnit 作为测试框架。
- en: 'Gradle tasks are easy to run. For example, to run tests from the command prompt,
    we can simply execute the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 任务很容易运行。例如，要从命令提示符中运行测试，我们可以简单地执行以下操作：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This can be accomplished from IDEA by running the `test` task from the Gradle
    Tool Window that can be accessed from View|Tool Windows|Gradle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从 IDEA 中运行 Gradle 工具窗口中的 `test` 任务来完成。
- en: The tests result is stored in the HTML files that are located in the `build/reports/tests`
    directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果存储在位于 `build/reports/tests` 目录中的 HTML 文件中。
- en: 'The following is the test report generated by running `gradle test` against
    the sample code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过运行 `gradle test` 生成的测试报告：
- en: '![](img/3faba178-b0f0-487c-bf82-a7656f5e7f51.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3faba178-b0f0-487c-bf82-a7656f5e7f51.png)'
- en: The integrated development environment
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: As many tools and technologies will be covered, we recommend using IntelliJ
    IDEA as the tool for code development. The main reason is that this **integrated
    development environment** (**IDE**) works without any tedious configuration. The
    Community Edition (IntelliJ IDEA CE) comes with a bunch of built-in features and
    plugins that make coding easy and efficient. It automatically recommends plugins
    that can be installed depending on the file extension. As IntelliJ IDEA is the
    choice we made for this book, you will find references and steps referring to
    its actions or menus. Readers should find a proper way to emulate those steps
    if they are using other IDEs. Refer to: [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)
    for instructions on how to download and install IntelliJ IDEA.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将涵盖许多工具和技术，我们建议使用 IntelliJ IDEA 作为代码开发工具。主要原因是这个**集成开发环境**（**IDE**）可以在没有繁琐配置的情况下工作。社区版（IntelliJ
    IDEA CE）带有许多内置功能和插件，使编码变得简单高效。它会根据文件扩展名自动推荐可以安装的插件。由于我们选择了 IntelliJ IDEA 作为本书的工具，因此您将在引用和步骤中找到与其操作或菜单相关的内容。如果读者使用其他
    IDE，应该找到模拟这些步骤的正确方法。请参阅：[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)
    了解如何下载和安装 IntelliJ IDEA 的说明。
- en: The IDEA demo project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDEA 演示项目
- en: Let's create the base layout of the demo project. This project will be used
    throughout this chapter to illustrate all the topics that are covered. Java will
    be the programming language and Gradle ([http://gradle.org/](http://gradle.org/))
    will be used to run different sets of tasks, such as building, testing, and so
    on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建演示项目的基本布局。本章将使用该项目来说明所有涉及的主题。Java 将是编程语言，Gradle（[http://gradle.org/](http://gradle.org/)）将用于运行不同的任务集，如构建、测试等。
- en: 'Let us import into IDEA the repository that contains examples from this chapter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 IDEA 中导入包含本章示例的存储库：
- en: Open IntelliJ IDEA, select Check out from Version Control, and click on Git.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IntelliJ IDEA，选择从版本控制中检出，然后点击 Git。
- en: Type `https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit.git` in the
    Git repository URL and click on Clone. Confirm for the rest of the IDEA questions
    until a new project is created with code cloned from the Git repository.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Git 存储库 URL 中输入 `https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit.git`，然后点击克隆。确认
    IDEA 的其余问题，直到从 Git 存储库克隆出带有代码的新项目。
- en: 'The imported project should look similar to the following image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的项目应该看起来类似于以下图片：
- en: '![](img/4f24bf69-eaa5-4aac-8877-275f383e142f.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f24bf69-eaa5-4aac-8877-275f383e142f.png)'
- en: Now that we have got the project set up, it's time to take a look at unit-testing
    frameworks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了项目，是时候来看一下单元测试框架了。
- en: Unit-testing frameworks
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: In this section, two of the most used Java frameworks for unit testing are shown
    and briefly commented on. We will focus on their syntax and main features by comparing
    a test class written using both JUnit and TestNG. Although there are slight differences,
    both frameworks offer the most commonly used functionalities, and the main difference
    is how tests are executed and organized.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，展示并简要评论了两个最常用的 Java 单元测试框架。我们将通过比较使用 JUnit 和 TestNG 编写的测试类来重点关注它们的语法和主要特性。尽管存在细微差异，但这两个框架都提供了最常用的功能，主要区别在于测试的执行和组织方式。
- en: Let's start with a question. What is a test? How can we define it?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个问题开始。什么是测试？我们如何定义它？
- en: A test is a repeatable process or method that verifies the correct behavior
    of a tested target in a determined situation with a determined input expecting
    a predefined output or interactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个可重复的过程或方法，用于验证在确定的情况下，对于确定的输入，期望预定义的输出或交互的被测试目标的正确行为。
- en: In the programming approach, there are several types of tests depending on their
    scope—functional tests, acceptance tests, and unit tests. Further on, we will
    explore each of those types of tests in more detail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程方法中，根据其范围，有几种类型的测试——功能测试、验收测试和单元测试。接下来，我们将更详细地探讨每种类型的测试。
- en: 'Unit testing is about testing small pieces of code. Let''s see how to test
    a single Java class. The class is quite simple, but enough for our interest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是关于测试小代码片段的。让我们看看如何测试一个单独的Java类。这个类非常简单，但足够我们的兴趣：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: JUnit
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit
- en: JUnit ([http://junit.org/](http://junit.org/)) is a simple and easy-to-learn
    framework for writing and running tests. Each test is mapped as a method, and
    each method should represent a specific known scenario in which a part of our
    code will be executed. The code verification is made by comparing the expected
    output or behavior with the actual output.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit（[http://junit.org/](http://junit.org/)）是一个简单易学的编写和运行测试的框架。每个测试都被映射为一个方法，每个方法都应该代表一个特定的已知场景，在这个场景中，我们的代码的一部分将被执行。代码验证是通过比较预期输出或行为与实际输出来完成的。
- en: The following is the test class written with JUnit. There are some scenarios
    missing, but for now we are interested in showing what tests look like. We will
    focus on better ways to test our code and on best practices later in this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用JUnit编写的测试类。有一些场景缺失，但现在我们只关注展示测试的样子。我们将在本书的后面专注于测试代码的更好方法和最佳实践。
- en: 'Test classes usually consist of three stages: set up, test, and tear down.
    Let''s start with methods that set up data needed for tests. A setup can be performed
    on a class or method level:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类通常包括三个阶段：设置、测试和拆卸。让我们从为测试设置所需数据的方法开始。设置可以在类或方法级别上执行：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `@BeforeClass` annotation specifies a method that will be run once before
    any of the test methods in the class. It is a useful way to do some general set
    up that will be used by most (if not all) tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BeforeClass`注解指定一个方法，在类中的任何测试方法之前运行一次。这是一个有用的方法，可以进行一些通用设置，大多数（如果不是全部）测试都会用到。'
- en: The `@Before` annotation specifies a method that will be run before each test
    method. We can use it to set up test data without worrying that the tests that
    are run afterwards will change the state of that data. In the preceding example,
    we're instantiating the `Friendships` class and adding five sample entries to
    the `Friendships` list. No matter what changes will be performed by each individual
    test, this data will be recreated over and over until all the tests are performed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before`注解指定一个方法，在每个测试方法之前运行。我们可以使用它来设置测试数据，而不必担心之后运行的测试会改变该数据的状态。在前面的示例中，我们实例化了`Friendships`类，并向`Friendships`列表添加了五个样本条目。无论每个单独的测试将进行何种更改，这些数据都将一遍又一遍地重新创建，直到所有测试都完成。'
- en: Common examples of usage of those two annotations are the setting up of database
    data, the creation of files needed for tests, and so on. Later on, we'll see how
    external dependencies can and should be avoided using mocks. Nevertheless, functional
    or integration tests might still need those dependencies and the `@Before` and
    `@BeforeClass` annotations are a good way to set them up.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个注解的常见用法包括设置数据库数据、创建测试所需的文件等。稍后，我们将看到如何使用模拟来避免外部依赖。然而，功能测试或集成测试可能仍然需要这些依赖，`@Before`和`@BeforeClass`注解是设置它们的好方法。
- en: 'Once the data is set up, we can proceed with the actual tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据设置好后，我们可以进行实际的测试：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are using a few of the many different types of asserts.
    We're confirming that `Alex` does not have any friends, while `Joe` is a very
    popular guy with five friends (`Audrey`, `Peter`, `Michael`, `Britney`, and `Paul`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一些不同类型的断言。我们确认`Alex`没有任何朋友，而`Joe`是一个非常受欢迎的人，有五个朋友（`Audrey`、`Peter`、`Michael`、`Britney`和`Paul`）。
- en: 'Finally, once the tests are finished, we might need to perform some cleanup:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦测试完成，我们可能需要进行一些清理工作：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our example, in the `Friendships` class, we have no need to clean up anything.
    If there were such a need, those two annotations would provide that feature. They
    work in a similar fashion to the `@Before` and `@BeforeClass` annotations. `@AfterClass`
    is run once all tests are finished. The `@After` annotation is executed after
    each test. This runs each test method as a separate class instance. As long as
    we are avoiding global variables and external resources, such as databases and
    APIs, each test is isolated from the others. Whatever was done in one, does not
    affect the rest.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在`Friendships`类中，我们不需要清理任何东西。如果有这样的需要，这两个注解将提供该功能。它们的工作方式类似于`@Before`和`@BeforeClass`注解。`@AfterClass`在所有测试完成后运行一次。`@After`注解在每个测试后执行。这将每个测试方法作为一个单独的类实例运行。只要我们避免全局变量和外部资源，比如数据库和API，每个测试都是与其他测试隔离的。在一个测试中所做的任何事情都不会影响其他测试。
- en: The complete source code can be found in the `FriendshipsTest` class at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`FriendshipsTest`类中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)。
- en: TestNG
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestNG
- en: In TestNG ([http://testng.org/doc/index.html](http://testng.org/doc/index.html)),
    tests are organized in classes, just as in the case of JUnit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在TestNG（[http://testng.org/doc/index.html](http://testng.org/doc/index.html)）中，测试被组织在类中，就像JUnit一样。
- en: 'The following Gradle configuration (`build.gradle`) is required in order to
    run TestNG tests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行TestNG测试，需要以下Gradle配置（`build.gradle`）：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unlike JUnit, TestNG requires additional Gradle configuration that tells it
    to use TestNG to run tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与JUnit不同，TestNG需要额外的Gradle配置，告诉它使用TestNG来运行测试。
- en: 'The following test class is written with TestNG and is a reflection of what
    we did earlier with JUnit. Repeated imports and other boring parts are omitted
    with the intention of focusing on the relevant parts:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的测试类是用TestNG编写的，反映了我们之前用JUnit做的事情。重复的导入和其他无聊的部分被省略了，以便专注于相关部分：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You probably already noticed the similarities between JUnit and TestNG. Both
    are using annotations to specify what the purposes of certain methods are. Besides
    different names (`@Beforeclass` versus `@BeforeMethod`), there is no difference
    between the two. However, unlike Junit, TestNG reuses the same test class instance
    for all test methods. This means that the test methods are not isolated by default,
    so more care is needed in the `before` and `after` methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了JUnit和TestNG之间的相似之处。两者都使用注解来指定某些方法的目的。除了不同的名称（`@Beforeclass`与`@BeforeMethod`），两者之间没有区别。然而，与JUnit不同，TestNG会为所有测试方法重用相同的测试类实例。这意味着测试方法默认情况下不是隔离的，因此在`before`和`after`方法中需要更多的注意。
- en: 'Asserts are very similar as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 断言也非常相似：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only notable difference when compared with JUnit is the order of the `assert`
    variables. While the JUnit assert's order of arguments is **optional message**,
    **expected values**, and **actual values**, TestNG's order is an actual value,
    expected value, and optional message. Besides the difference in the order of arguments
    we're passing to the `assert` methods, there are almost no differences between
    JUnit and TestNG.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与JUnit相比，唯一显著的区别是`assert`变量的顺序。虽然JUnit的断言参数顺序是**可选消息**、**预期值**和**实际值**，TestNG的顺序是实际值、预期值和可选消息。除了我们传递给`assert`方法的参数顺序不同之外，JUnit和TestNG之间几乎没有区别。
- en: You might have noticed that `@Test` is missing. TestNG allows us to set it on
    the class level and thus convert all public methods into tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到缺少`@Test`。TestNG允许我们在类级别上设置它，从而将所有公共方法转换为测试。
- en: The `@After` annotations are also very similar. The only notable difference
    is the TestNG `@AfterMethod` annotation that acts in the same way as the JUnit
    `@After` annotation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`@After`注解也非常相似。唯一显著的区别是TestNG的`@AfterMethod`注解，其作用方式与JUnit的`@After`注解相同。'
- en: As you can see, the syntax is pretty similar. Tests are organized in to classes
    and test verifications are made using assertions. That is not to say that there
    are no more important differences between those two frameworks; we'll see some
    of them throughout this book. I invite you to explore JUnit ([http://junit.org/](http://junit.org/))
    and TestNG ([http://testng.org/](http://testng.org/)) by yourself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，语法非常相似。测试被组织成类，并且使用断言进行测试验证。这并不是说这两个框架之间没有更重要的区别；我们将在本书中看到其中一些区别。我邀请您自行探索JUnit（[http://junit.org/](http://junit.org/)）和TestNG（[http://testng.org/](http://testng.org/)）。
- en: The complete source code with the preceding examples can be found at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng](https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的完整源代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng](https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng)找到。
- en: The assertions we have written until now have used only the testing frameworks.
    However, there are some test utilities that can help us make them nicer and more
    readable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的断言只使用了测试框架。然而，有一些测试工具可以帮助我们使它们更加美观和易读。
- en: Hamcrest and AssertJ
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hamcrest和AssertJ
- en: In the previous section, we gave an overview of what a unit test is and how
    it can be written using two of the most commonly used Java frameworks. Since tests
    are an important part of our projects, why not improve the way we write them?
    Some cool projects emerged, aiming to empower the semantics of tests by changing
    the way that assertions are made. As a result, tests are more concise and easier
    to understand.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们概述了单元测试是什么，以及如何使用两个最常用的Java框架编写单元测试。由于测试是我们项目的重要组成部分，为什么不改进我们编写测试的方式呢？一些很酷的项目出现了，旨在通过改变断言的方式来增强测试的语义。结果，测试更加简洁易懂。
- en: Hamcrest
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hamcrest
- en: '**Hamcrest** adds a lot of methods called **matchers**. Each matcher is designed
    to perform a comparison operation. It is extensible enough to support custom matchers
    created by yourself. Furthermore, JUnit supports Hamcrest natively since its core
    is included in the JUnit distribution. You can start using Hamcrest effortlessly.
    However, we want to use the full-featured project so we will add a test dependency
    to Gradle''s file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hamcrest**添加了许多称为**匹配器**的方法。每个匹配器都设计用于执行比较操作。它足够灵活，可以支持自己创建的自定义匹配器。此外，JUnit自带对Hamcrest的支持，因为其核心包含在JUnit分发中。您可以轻松开始使用Hamcrest。但是，我们希望使用功能齐全的项目，因此我们将在Gradle的文件中添加一个测试依赖项：'
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us compare one assert from JUnit with the equivalent one from Hamcrest:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将JUnit中的一个断言与Hamcrest中的等效断言进行比较：
- en: 'The JUnit `assert`:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit的`assert`：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Hamcrest `assert`:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hamcrest的`assert`：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, Hamcrest is a bit more expressive. It has a much bigger range
    of asserts that allows us to avoid some boilerplate code and, at the same time,
    makes code easier to read and is more expressive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Hamcrest更具表现力。它具有更大范围的断言，可以避免一些样板代码，同时使代码更易于阅读和更具表现力。
- en: 'Here''s another example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: 'JUnit `assert`:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit的`assert`：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Hamcrest `assert`:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hamcrest的`assert`：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You'll notice two differences. The first is that, unlike JUnit, Hamcrest works
    almost always with direct objects. While in the case of JUnit, we needed to get
    the integer size and compare it with the expected number (`5`); Hamcrest has a
    bigger range of asserts so we can simply use one of them (`hasSize`) together
    with the actual object (`List`). Another difference is that Hamcrest has the inverse
    order with the actual value being the first argument (like TestNG).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到两个区别。首先是，与JUnit不同，Hamcrest几乎总是直接使用对象。在JUnit的情况下，我们需要获取整数大小并将其与预期数字（`5`）进行比较；而Hamcrest具有更大范围的断言，因此我们可以简单地使用其中一个（`hasSize`）与实际对象（`List`）一起使用。另一个区别是，Hamcrest具有与实际值相反的顺序，实际值是第一个参数（就像TestNG一样）。
- en: Those two examples are not enough to show the full potential offered by Hamcrest.
    Later on in this book, there will be more examples and explanations of Hamcrest.
    Visit [http://hamcrest.org/](http://hamcrest.org/) and explore its syntax.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子还不足以展示Hamcrest所提供的全部潜力。在本书的后面，将会有更多关于Hamcrest的例子和解释。访问[http://hamcrest.org/](http://hamcrest.org/)并探索其语法。
- en: The complete source code can be found in the `FriendshipsHamcrestTest` class
    in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)
    repositories.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`FriendshipsHamcrestTest`类中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)。
- en: AssertJ
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AssertJ
- en: '**AssertJ** works in a similar way to Hamcrest. A major difference is that
    AssertJ assertions can be concatenated.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**AssertJ**的工作方式类似于Hamcrest。一个主要的区别是AssertJ断言可以连接起来。'
- en: 'To work with AssertJ, the dependency must be added to Gradle''s dependencies:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用AssertJ，必须将依赖项添加到Gradle的依赖项中：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s compare JUnit asserts with AssertJ:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将JUnit断言与AssertJ进行比较：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The same two asserts can be concatenated to a single one in AssertJ:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在AssertJ中，相同的两个断言可以连接成一个：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This was a nice improvement. There was no need to have two separate asserts,
    nor was there a need to create a new list with expected values. Moreover, AssertJ
    is more readable and easier to understand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的改进。不需要有两个单独的断言，也不需要创建一个包含预期值的新列表。此外，AssertJ更易读，更容易理解。
- en: The complete source code can be found in the `FriendshipsAssertJTest` class
    at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`FriendshipsAssertJTest`类中找到，网址为[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)。
- en: Now that we have the tests up and running, we might want to see what the code
    coverage is that is generated by our tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了运行的测试，我们可能想要查看我们的测试生成的代码覆盖率是多少。
- en: Code coverage tools
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率工具
- en: The fact that we wrote tests does not mean that they are good, nor that they
    cover enough code. As soon as we start writing and running tests, the natural
    reaction is to start asking questions that were not available before. What parts
    of our code are properly tested? What are the cases that our tests did not take
    into account? Are we testing enough? These and other similar questions can be
    answered with code coverage tools. They can be used to identify the blocks or
    lines of code that were not covered by our tests; they can also calculate the
    percentage of code covered and provide other interesting metrics.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写测试并不意味着它们很好，也不意味着它们覆盖了足够的代码。一旦我们开始编写和运行测试，自然的反应就是开始提出以前无法回答的问题。我们的代码的哪些部分得到了适当的测试？我们的测试没有考虑到哪些情况？我们测试得足够吗？这些和其他类似的问题可以通过代码覆盖率工具来回答。它们可以用于识别我们的测试未覆盖的代码块或行；它们还可以计算代码覆盖的百分比并提供其他有趣的指标。
- en: They are powerful tools used to obtain metrics and show relations between tests
    and implementation code. However, as with any other tool, their purpose needs
    to be clear. They do not provide information about quality, but only about which
    parts of our code have been tested.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是用于获取指标并显示测试和实现代码之间关系的强大工具。然而，与任何其他工具一样，它们的目的需要明确。它们不提供关于质量的信息，而只提供我们的代码中已经测试过的部分。
- en: Code coverage shows whether the code lines are reached during test execution,
    but it is not a guarantee of good testing practices because test quality is not
    included in these metrics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率显示测试执行期间是否到达了代码行，但这并不是良好测试实践的保证，因为测试质量不包括在这些指标中。
- en: Let's take a look at one of the most popular tools used to calculate code coverage.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用于计算代码覆盖率的最流行的工具之一。
- en: JaCoCo
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JaCoCo
- en: Java Code Coverage (JaCoCo) is a well-known tool for measuring test coverage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码覆盖率（JaCoCo）是一个用于测量测试覆盖率的知名工具。
- en: 'To use it in our project, we need to add a few lines to our Gradle configuration
    file, that is, `build.gradle`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用它，我们需要在Gradle配置文件`build.gradle`中添加几行：
- en: 'Add the Gradle `plugin` for JaCoCo:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为JaCoCo添加Gradle`plugin`：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To see the JaCoCo results, run the following from your command prompt:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看JaCoCo的结果，请从命令提示符中运行以下命令：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The same Gradle tasks can be run from the Gradle Tasks IDEA Tool Window.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的Gradle任务可以从Gradle任务IDEA工具窗口运行。
- en: 'The end result is stored in the `build/reports/jacoco/test/html` directory.
    It''s an HTML file that can be opened in any browser:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果存储在`build/reports/jacoco/test/html`目录中。这是一个可以在任何浏览器中打开的HTML文件：
- en: '![](img/2d6b19f8-0fbc-4101-88d0-46a046cd900a.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d6b19f8-0fbc-4101-88d0-46a046cd900a.png)'
- en: Further chapters of this book will explore code coverage in more detail. Until
    then, go to [http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/) for
    more information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的后续章节将更详细地探讨代码覆盖率。在那之前，可以访问[http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)获取更多信息。
- en: Mocking frameworks
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟框架
- en: Our project looks cool, but it's too simple and it is far from being a real
    project. It still doesn't use external resources. A database is required by Java
    projects so we'll try to introduce it, as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目看起来很酷，但它太简单了，远非一个真正的项目。它仍然没有使用外部资源。Java项目需要数据库，因此我们将尝试引入它。
- en: What is the common way to test code that uses external resources or third-party
    libraries? Mocks are the answer. A mock object, or simply a mock, is a simulated
    object that can be used to replace real ones. They are very useful when objects
    that depend on external resources are deprived of them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用外部资源或第三方库的代码的常见方法是什么？模拟是答案。模拟对象，或者简单地说是模拟，是一个可以用来替代真实对象的模拟对象。当依赖外部资源的对象被剥夺时，它们非常有用。
- en: In fact, you don't need a database at all while you are developing the application.
    Instead, you can use mocks to speed up development and testing and use a real
    database connection only at runtime. Instead of spending time setting up a database
    and preparing test data, we can focus on writing classes and think about them
    later on during integration time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在开发应用程序时根本不需要数据库。相反，您可以使用模拟来加快开发和测试，并且只在运行时使用真实的数据库连接。我们可以专注于编写类并在集成时考虑它们，而不是花时间设置数据库和准备测试数据。
- en: 'For demonstration purposes, we''ll introduce two new classes: the `Person`
    class and the `FriendCollection` class that are designed to represent persons
    and database object mapping. Persistence will be done with MongoDB ([https://www.mongodb.org/](https://www.mongodb.org/)).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将介绍两个新类：`Person`类和`FriendCollection`类，它们旨在表示人和数据库对象映射。持久性将使用MongoDB进行（[https://www.mongodb.org/](https://www.mongodb.org/)）。
- en: Our sample will have two classes. `Person` will represent database object data;
    `FriendCollection` will be our data access layer. The code is, hopefully, self-explanatory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将有两个类。`Person`将表示数据库对象数据；`FriendCollection`将是我们的数据访问层。代码是自解释的。
- en: 'Let''s create and use the `Person` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并使用`Person`类：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create and use the `FriendsCollection` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并使用`FriendsCollection`类：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In addition, some new dependencies have been introduced so the Gradle dependencies
    block needs to be modified, as well. The first one is the MongoDB driver, which
    is required to connect to the database. The second is Jongo, a small project that
    makes accessing Mongo collections pretty straightforward.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还引入了一些新的依赖项，因此Gradle依赖块需要进行修改。第一个是MongoDB驱动程序，它用于连接到数据库。第二个是Jongo，一个使访问Mongo集合非常简单的小项目。
- en: 'The Gradle dependencies for `mongodb` and `jongo` are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongodb`和`jongo`的Gradle依赖如下：'
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are using a database so the `Friendships` class should also be modified.
    We should change a map to `FriendsCollection` and modify the rest of the code
    to use it. The end result is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用数据库，因此`Friendships`类也应该被修改。我们应该将一个映射更改为`FriendsCollection`并修改其余代码以使用它。最终结果如下：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The complete source code can be found in the `FriendsCollection` and `FriendshipsMongo`
    classes in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)
    repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)存储库中的`FriendsCollection`和`FriendshipsMongo`类中找到。
- en: Now that we have our `Friendships` class working with MongoDB, let's take a
    look at one possible way to test it by using mocks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`Friendships`类已经可以与MongoDB一起工作，让我们看看如何使用模拟来测试它的一种可能方式。
- en: Mockito
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito
- en: Mockito is a Java framework that allows easy creation of the test double.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito是一个允许轻松创建测试替身的Java框架。
- en: 'The Gradle dependency is the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle依赖如下：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Mockito runs through the JUnit runner. It creates all the required mocks for
    us and injects them into the class with tests. There are two basic approaches;
    instantiating mocks by ourselves and injecting them as class dependencies via
    a class constructor or using a set of annotations. In the next example, we are
    going to see how it is done using annotations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito通过JUnit运行。它为我们创建了所有必需的模拟对象，并将它们注入到具有测试的类中。有两种基本方法；通过自己实例化模拟对象并通过类构造函数将它们注入为类依赖项，或者使用一组注解。在下一个示例中，我们将看到如何使用注解来完成。
- en: 'In order for a class to use Mockito annotations, it needs to be run with `MockitoJUnitRunner`.
    Using the runner simplifies the process because you just simply add annotations
    to objects to be created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个类使用Mockito注解，它需要使用`MockitoJUnitRunner`运行。使用该运行程序简化了该过程，因为您只需向要创建的对象添加注解即可：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In your test class, the tested class should be annotated with `@InjectMocks`.
    This tells Mockito which class to inject mocks into:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试类中，被测试的类应该用`@InjectMocks`注解。这告诉Mockito要将模拟对象注入哪个类：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From then on, we can specify which specific methods or objects inside the class,
    in this case `FriendshipsMongo`, will be substituted with mocks:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们可以指定在类内部的特定方法或对象，即`FriendshipsMongo`，将被替换为模拟对象：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, `FriendsCollection` inside the `FriendshipsMongo` class will
    be mocked.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`FriendshipsMongo`类中的`FriendsCollection`将被模拟。
- en: 'Now, we can specify what should be returned when `friends` is invoked:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指定在调用`friends`时应返回什么：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we're telling Mockito to return the `joe` object whenever `friends.findByName("Joe")`
    is invoked. Later on, we're verifying with `assertThat` that this assumption is
    correct.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们告诉Mockito当调用`friends.findByName("Joe")`时返回`joe`对象。稍后，我们使用`assertThat`来验证这个假设是正确的。
- en: 'Let''s try to do the same test as we did previously in the class that was without
    MongoDB:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在之前没有MongoDB的类中做与之前相同的测试：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A lot of things happened in this small test. First, we're specifying that `joe`
    is a spy. In Mockito, spies are real objects that use real methods unless specified
    otherwise. Then, we're telling Mockito to return `joe` when the `friends` method
    calls `getFriends`. This combination allows us to return the `expected` list when
    the `getFriends` method is invoked. Finally, we're asserting that the `getFriendsList`
    returns the expected list of names.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小测试中发生了很多事情。首先，我们指定`joe`是一个间谍。在Mockito中，间谍是真实对象，除非另有规定，否则使用真实方法。然后，我们告诉Mockito当`friends`方法调用`getFriends`时返回`joe`。这种组合允许我们在调用`getFriends`方法时返回`expected`列表。最后，我们断言`getFriendsList`返回预期的名称列表。
- en: The complete source code can be found in the `FriendshipsMongoAssertJTest` class
    in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit) repository.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)存储库中的`FriendshipsMongoAssertJTest`类中找到。
- en: We'll use Mockito later on; throughout this book, you'll get your chance to
    become more familiar with it and with mocking in general. More information about
    Mockito can be found at [http://mockito.org/](http://mockito.org/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面使用Mockito；在本书中，您将有机会更加熟悉它和一般的模拟。有关Mockito的更多信息，请访问[http://mockito.org/](http://mockito.org/)。
- en: EasyMock
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EasyMock
- en: EasyMock is an alternative mocking framework. It is very similar to Mockito.
    However, the main difference is that EasyMock does not create `spy` objects but
    mocks. Other differences are syntactical.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: EasyMock是一种替代的模拟框架。它与Mockito非常相似。然而，主要区别在于EasyMock不创建`spy`对象，而是模拟对象。其他区别是语法上的。
- en: 'Let''s see an example of EasyMock. We''ll use the same set of test cases as
    those that were used for the Mockito examples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个EasyMock的例子。我们将使用与Mockito示例相同的一组测试用例：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Essentially, the runner does the same as the Mockito runner:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，运行器与Mockito运行器的功能相同：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `@TestSubject` annotation is similar to Mockito's `@InjectMocks`, while
    the `@Mock` annotation denotes an object to be mocked in a similar fashion to
    Mockito's `@Mock`. Furthermore, the type `NICE` tells the mock to return empty.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TestSubject`注解类似于Mockito的`@InjectMocks`，而`@Mock`注解表示要以类似于Mockito的方式模拟的对象。此外，类型`NICE`告诉模拟返回空值。'
- en: 'Let''s compare one of the asserts we did with Mockito:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下我们用Mockito做的一个断言：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Besides small differences in syntax, the only disadvantage of EasyMock is that
    the additional instruction `replay` was needed. It tells the framework that the
    previously specified expectation should be applied. The rest is almost the same.
    We're specifying that `friends.findByName` should return the `joe` object, applying
    that expectation and, finally, asserting whether the actual result is as expected.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法上的小差异外，EasyMock唯一的缺点是需要额外的指令`replay`。它告诉框架应用先前指定的期望。其余几乎相同。我们指定`friends.findByName`应返回`joe`对象，应用该期望，并最后断言实际结果是否符合预期。
- en: 'In the EasyMock version, the second test method that we used with Mockito is
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在EasyMock版本中，我们使用Mockito的第二个测试方法如下：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Again, there are almost no differences when compared to Mockito, except that
    EasyMock does not have spies. Depending on the context, that might be an important
    difference.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mockito相比，EasyMock几乎没有区别，只是EasyMock没有间谍。根据上下文，这可能是一个重要的区别。
- en: Even though both frameworks are similar, there are small details that make us
    choose Mockito as a framework, which will be used throughout this book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个框架都很相似，但有一些细节使我们选择Mockito作为框架，这将在本书中使用。
- en: Visit [http://easymock.org/](http://easymock.org/) for more information about
    this asserts library.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此断言库的更多信息，请访问[http://easymock.org/](http://easymock.org/)。
- en: The complete source code can be found in the `FriendshipsMongoEasyMockTest`
    class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit) repository.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`FriendshipsMongoEasyMockTest`类中找到，该类位于[https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)存储库中。
- en: Extra power for mocks
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟的额外功能
- en: Both projects introduced earlier do not cover all types of methods or fields.
    Depending on the applied modifiers, such as static or final, a class, method,
    or field, can be out of range for Mockito or EasyMock. In such cases, we can use
    PowerMock to extend the mocking framework. This way, we can mock objects that
    can only be mocked in a tricky manner. However, one should be cautious with PowerMock
    since the necessity to use many of the features it provides is usually a sign
    of poor design. If you're working on a legacy code, PowerMock might be a good
    choice. Otherwise, try to design your code in such a way that PowerMock is not
    needed. We'll show you how to do that later on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面介绍的两个项目都不涵盖所有类型的方法或字段。根据应用的修饰符，如静态或最终，类、方法或字段可能超出Mockito或EasyMock的范围。在这种情况下，我们可以使用PowerMock来扩展模拟框架。这样，我们可以模拟只能以棘手方式模拟的对象。但是，使用PowerMock时应该谨慎，因为使用它提供的许多功能通常是设计不良的标志。如果您正在处理遗留代码，PowerMock可能是一个不错的选择。否则，尽量设计您的代码，以便不需要PowerMock。我们稍后会向您展示如何做到这一点。
- en: For more information, visit [https://code.google.com/p/powermock/](https://code.google.com/p/powermock/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问[https://code.google.com/p/powermock/](https://code.google.com/p/powermock/)。
- en: User interface testing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面测试
- en: Even though unit testing can and should cover the major part of the application,
    there is still a need to work on functional and acceptance tests. Unlike unit
    tests, they provide higher-level verifications, and are usually performed at entry
    points, and rely heavily on user interfaces. At the end, we are creating applications
    that are, in most cases, used by humans, so being confident of our application's
    behavior is very important. This comfort status can be achieved by testing what
    the application is expected to do, from the point of view of real users.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试可以并且应该覆盖应用程序的主要部分，但仍然需要进行功能和验收测试。与单元测试不同，它们提供了更高级别的验证，并且通常在入口点执行，并且严重依赖于用户界面。最终，我们创建的应用程序在大多数情况下都是由人类使用的，因此对应用程序行为的信心非常重要。通过测试应用程序从真实用户的角度来看应该做什么，可以实现这种舒适状态。
- en: Here, we'll try to provide an overview of functional and acceptance testing
    through a user interface. We'll use the web as an example, even though there are
    many other types of user interfaces, such as desktop applications, smartphone
    interfaces, and so on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试通过用户界面提供功能和验收测试的概述。我们将以网络为例，尽管还有许多其他类型的用户界面，如桌面应用程序、智能手机界面等。
- en: Web-testing frameworks
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web测试框架
- en: The application classes and data sources have been tested throughout this chapter,
    but there is still something missing; the most common user entry point—the web.
    Most enterprise applications such as intranets or corporate sites are accessed
    using a browser. For this reason, testing the web provides significant value,
    helping us to make sure that it is doing what it is expected to do.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中已经测试了应用程序类和数据源，但仍然缺少一些东西；最常见的用户入口点——网络。大多数企业应用程序，如内部网或公司网站，都是使用浏览器访问的。因此，测试网络提供了重要的价值，帮助我们确保它正在按预期进行操作。
- en: Furthermore, companies are investing a lot of time performing long and heavy
    manual tests every time the application changes. This is a big waste of time since
    a lot of those tests can be automatized and executed without supervision, using
    tools such as Selenium or Selenide.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，公司正在花费大量时间进行长时间和繁重的手动测试，每次应用程序更改时都要进行测试。这是一种浪费时间，因为其中许多测试可以通过工具（如Selenium或Selenide）进行自动化和无人监督地执行。
- en: Selenium
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium
- en: Selenium is a great tool for web testing. It uses a browser to run verifications
    and it can handle all the popular browsers, such as Firefox, Safari, and Chrome.
    It also supports headless browsers to test web pages with much greater speed and
    less resources consumption.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个用于Web测试的强大工具。它使用浏览器来运行验证，并且可以处理所有流行的浏览器，如Firefox、Safari和Chrome。它还支持无头浏览器，以更快的速度和更少的资源消耗测试网页。
- en: There is a `SeleniumIDE` plugin that can be used to create tests by recording
    actions performed by the user. Currently, it is only supported by Firefox. Sadly,
    even though tests generated this way provide very fast results, they tend to be
    very brittle and cause problems in the long run, especially when some part of
    a page changes. For this reason, we'll stick with the code written without the
    help from that plugin.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`SeleniumIDE`插件，可以用来通过记录用户执行的操作来创建测试。目前，它只支持Firefox。遗憾的是，尽管以这种方式生成的测试提供了非常快速的结果，但它们往往非常脆弱，并且在长期内会引起问题，特别是当页面的某些部分发生变化时。因此，我们将坚持不使用该插件的帮助编写的代码。
- en: The simplest way to execute Selenium is to run it through `JUnitRunner`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Selenium最简单的方法是通过`JUnitRunner`运行它。
- en: 'All Selenium tests start by initializing `WebDriver`, the class used for communication
    with browsers:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Selenium测试都是通过初始化`WebDriver`开始的，这是用于与浏览器通信的类：
- en: 'Let''s start by adding the Gradle dependency:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加Gradle依赖开始：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As an example, we''ll create a test that searches Wikipedia. We''ll use a Firefox
    driver as our browser of choice:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们将创建一个搜索维基百科的测试。我们将使用Firefox驱动程序作为我们的首选浏览器：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`WebDriver` is an interface that can be instantiated with one of the many drivers
    provided by Selenium:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebDriver`是一个可以用Selenium提供的众多驱动程序之一实例化的接口：'
- en: 'To open a URL, the instruction would be the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开一个URL，指令如下：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once the page is opened, we can search for an input element by its name and
    then type some text:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面打开后，我们可以通过其名称搜索输入元素，然后输入一些文本：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once we type our search query, we should find and click the Go button:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们输入我们的搜索查询，我们应该找到并点击Go按钮：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once we reach our destination, it is time to validate that, in this case, the
    page title is correct:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到达目的地，就是验证，在这种情况下，页面标题是否正确的时候了：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, the `driver` should be closed once we''re finished using it:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们使用完毕，`driver`应该被关闭：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That's it. We have a small but valuable test that verifies a single use case.
    While
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们有一个小但有价值的测试，可以验证单个用例。虽然
- en: there is much more to be said about Selenium, hopefully, this has provided you
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Selenium还有很多要说的，希望这为您提供了
- en: with enough information to realize the potential behind it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有足够的信息来认识到它的潜力。
- en: Visit [http://www.seleniumhq.org/](http://www.seleniumhq.org/) for further information
    and more complex uses of `WebDriver`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://www.seleniumhq.org/](http://www.seleniumhq.org/)获取更多信息和更复杂的`WebDriver`使用。
- en: The complete source code can be found in the `SeleniumTest` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web) repository.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`SeleniumTest`类中的[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中找到。
- en: While Selenium is the most commonly used framework to work with browsers, it
    is still very low-level and requires a lot of tweaking. Selenide was born out
    of the idea that Selenium would be much more useful if there was a higher-level
    library that could implement some of the common patterns and solve often-repeated
    needs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Selenium是最常用的与浏览器一起工作的框架，但它仍然是非常低级的，需要大量的调整。Selenide的诞生是基于这样一个想法，即如果有一个更高级的库可以实现一些常见模式并解决经常重复的需求，那么Selenium将会更有用。
- en: Selenide
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenide
- en: 'What we have seen about Selenium is very cool. It brings the opportunity to
    probe that our application is doing things well, but sometimes it is a bit tricky
    to configure and use. Selenide is a project based on Selenium that offers a good
    syntax for writing tests and makes them more readable. It hides the usage of `WebDriver`
    and configurations from you, while still maintaining a high-level of customization:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Selenium我们所看到的非常酷。它为我们提供了探测应用程序是否正常运行的机会，但有时配置和使用起来有点棘手。Selenide是一个基于Selenium的项目，提供了一个良好的语法来编写测试，并使它们更易读。它为您隐藏了`WebDriver`和配置的使用，同时仍然保持了高度的定制性：
- en: 'Like all the other libraries we have used until now, the first step is to add
    the Gradle dependency:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们到目前为止使用的所有其他库一样，第一步是添加Gradle依赖：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's see how we can write the previous Selenium test using Selenide
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Selenide编写之前的Selenium测试
- en: 'instead. The syntax might be familiar to for those who know JQuery ([https://jquery.com/](https://jquery.com/)):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 相反。语法可能对那些了解JQuery的人来说很熟悉([https://jquery.com/](https://jquery.com/))：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This was a more expressive way to write a test. On top of a more fluent syntax,
    there are some things that happen behind this code and would require additional
    lines of Selenium. For example, a click action will wait until an element in question
    is available, and will fail only if the predefined period of time has expired.
    Selenium, on the other hand, would fail immediately. In today's world, with many
    elements being loaded dynamically through JavaScript, we cannot expect everything
    to appear at once. Hence, this Selenide feature proves to be useful and saves
    us from using repetitive boilerplate code. There are many other benefits Selenide
    brings to the table. Due to the benefits that Selenide provides when compared
    with Selenium, it will be our framework of choice throughout this book. Furthermore,
    there is a whole chapter dedicated to web testing using this framework. Visit [http://selenide.org/](http://selenide.org/)
    for more information on ways to use web drivers in your tests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更具表现力的测试编写方式。除了更流畅的语法之外，这段代码背后还发生了一些事情，需要额外的Selenium代码行。例如，单击操作将等待直到相关元素可用，并且只有在预定义的时间段过期时才会失败。另一方面，Selenium会立即失败。在当今世界，许多元素通过JavaScript动态加载，我们不能指望一切立即出现。因此，这个Selenide功能被证明是有用的，并且可以避免使用重复的样板代码。Selenide带来了许多其他好处。由于Selenide相对于Selenium提供的好处，它将成为我们在整本书中选择的框架。此外，有一个完整的章节专门介绍了使用这个框架进行Web测试。访问[http://selenide.org/](http://selenide.org/)获取有关在测试中使用Web驱动程序的更多信息。
- en: No matter whether tests were written with one framework or another, the effect
    is the same. When tests are run, a Firefox browser window will emerge and execute
    all steps defined in the test sequentially. Unless a headless browser was chosen
    as your driver of choice, you will be able to see what is going on throughout
    the test. If something goes wrong, a failure trace is available. On top of that,
    we can take browser screenshots at any point. For example, it is a common practice
    to record the situation at the time of a failure.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无论测试是用一个框架还是另一个框架编写的，效果都是一样的。运行测试时，Firefox浏览器窗口将出现并按顺序执行测试中定义的所有步骤。除非选择了无头浏览器作为您的驱动程序，否则您将能够看到测试过程。如果出现问题，将提供失败跟踪。除此之外，我们可以在任何时候拍摄浏览器截图。例如，在失败时记录情况是一种常见做法。
- en: The complete source code can be found in the `SelenideTest` class in the
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`SelenideTest`类中找到
- en: '[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    仓库中。'
- en: Armed with a basic knowledge of web-testing frameworks, it is time to take a
    short look at BDD.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了基本的Web测试框架知识，现在是时候简要了解一下BDD了。
- en: Behavior-driven development
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavior-driven development** (**BDD**) is an agile process designed to keep
    the focus on stakeholder value throughout the whole project. The premise of BDD
    is that the requirement has to be written in a way that everyone, be it the business
    representative, analyst, developer, tester, manager, and so on, understands it.
    The key is to have a unique set of artifacts that are understood and used by everyone—a
    collection of user stories. Stories are written by the whole team and used as
    both requirements and executable test cases. It is a way to perform TDD with a
    clarity that cannot be accomplished with unit testing. It is a way to describe
    and test functionality in (almost) natural language and make it runnable and repeatable.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是一种旨在在整个项目过程中保持对利益相关者价值的关注的敏捷过程。BDD的前提是，需求必须以每个人都能理解的方式编写，无论是业务代表、分析师、开发人员、测试人员、经理等等。关键在于拥有一组独特的工件，每个人都能理解和使用——一系列用户故事。故事由整个团队编写，并用作需求和可执行测试用例。这是一种以无法通过单元测试实现的清晰度执行TDD的方式。这是一种以（几乎）自然语言描述和测试功能的方式，并使其可运行和可重复。'
- en: A story is composed of scenarios. Each scenario represents a concise behavioral
    use case and is written in natural language using steps. Steps are a sequence
    of the preconditions, events, and outcomes of a scenario. Each step must start
    with the words `Given`, `When`, or `Then`. `Given` is for preconditions, `When`
    is for actions, and `Then` is for performing validations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个故事由场景组成。每个场景代表一个简洁的行为用例，并使用步骤以自然语言编写。步骤是场景的前提条件、事件和结果的序列。每个步骤必须以`Given`、`When`或`Then`开头。`Given`用于前提条件，`When`用于操作，`Then`用于执行验证。
- en: This was only a brief introduction. There is a whole chapter, [Chapter 8](bc95db7c-af59-4643-9f40-b004910ac22f.xhtml),
    *BDD – Working Together with the Whole Team*, dedicated to this topic. Now it
    is time to introduce JBehave and Cucumber as two of the many available frameworks
    for writing and executing stories.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简要介绍。有一个完整的章节，[第8章](bc95db7c-af59-4643-9f40-b004910ac22f.xhtml)，*BDD -
    与整个团队一起工作*，专门介绍了这个主题。现在是时候介绍JBehave和Cucumber作为许多可用框架之一，用于编写和执行故事。
- en: JBehave
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JBehave
- en: 'JBehave is a Java BDD framework used for writing acceptance tests that are
    able to be executed and automated. The steps used in stories are bound to Java
    code through several annotations provided by the framework:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: JBehave是一个用于编写可执行和自动化的验收测试的Java BDD框架。故事中使用的步骤通过框架提供的几个注解绑定到Java代码：
- en: 'First of all, add JBehave to Gradle dependencies:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将JBehave添加到Gradle依赖项中：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s go through a few example steps:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过一些示例步骤：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the `Given` type of step. It represents a precondition that needs to
    be fulfilled for some actions to be performed successfully. In this particular
    case, it will open a Wikipedia page. Now that we have our precondition specified,
    it is time to define some actions:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`Given`类型的步骤。它代表需要满足的前提条件，以便成功执行一些操作。在这种情况下，它将打开一个维基百科页面。现在我们已经指定了我们的前提条件，是时候定义一些操作了：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, actions are defined with the `When` annotation. In our case,
    we can use those steps to set some value to a field or click on a specific button.
    Once actions are performed, we can deal with validations. Note
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，操作是使用`When`注释定义的。在我们的情况下，我们可以使用这些步骤来为字段设置一些值或单击特定按钮。一旦操作完成，我们可以处理验证。注意
- en: 'that steps can be more flexible by introducing parameters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入参数，步骤可以更加灵活：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Validations are declared using the `Then` annotation. In this example, we are
    validating the page title as expected.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Then`注释声明验证。在这个例子中，我们正在验证页面标题是否符合预期。
- en: These steps can be found in the `WebSteps` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中的`WebSteps`类中找到。
- en: 'Once we have defined our steps, it is time to use them. The following story
    combines those steps in order to validate a desired behavior:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的步骤，就是使用它们的时候了。以下故事结合了这些步骤，以验证所需的行为：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It starts with naming the scenario. The name should be as concise as possible,
    but enough to identify the user case unequivocally; it is for informative purposes
    only:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它以命名场景开始。名称应尽可能简洁，但足以明确识别用户案例；仅供信息目的：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we are using the same steps text that we defined earlier. The
    code related to those steps will be executed in a sequential order. If any of
    them are halted, the execution is halted and the scenario itself is considered
    failed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在使用之前定义的相同步骤文本。与这些步骤相关的代码将按顺序执行。如果其中任何一个被停止，执行也将停止，该场景本身被视为失败。
- en: Even though we defined our steps ahead of stories, it can be done the other
    way around with a story being defined first and the steps following. In that case,
    the status of a scenario would be pending, meaning that the required steps are
    missing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在故事之前定义了我们的步骤，但也可以反过来，先定义故事，然后是步骤。在这种情况下，场景的状态将是挂起的，这意味着缺少所需的步骤。
- en: This story can be found in the `wikipediaSearch.story` file in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中的`wikipediaSearch.story`文件中找到。
- en: 'To run this story, execute the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个故事，执行以下操作：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'While the story is running, we can see that actions are taking place in the
    browser. Once it is finished, a report with the results of an execution is generated.
    It can be found in `build/reports/jbehave`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 故事运行时，我们可以看到浏览器中正在发生的操作。一旦完成，将生成执行结果的报告。它可以在`build/reports/jbehave`中找到：
- en: '![](img/dca745ce-04ef-448e-a573-18d765ad28e2.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dca745ce-04ef-448e-a573-18d765ad28e2.png)'
- en: JBehave story execution report
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JBehave故事执行报告
- en: For brevity, we excluded the `build.gradle` code to run JBehave stories. The
    completed source code can be found in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们排除了运行JBehave故事的`build.gradle`代码。完成的源代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中找到。
- en: For further information on JBehave and its benefits, visit [http://jbehave.org/](http://jbehave.org/).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JBehave及其优势的更多信息，请访问[http://jbehave.org/](http://jbehave.org/)。
- en: Cucumber
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cucumber
- en: Cucumber was originally a Ruby BDD framework. These days it supports several
    languages including Java. It provides functionality that is very similar to JBehave.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber最初是一个Ruby BDD框架。如今它支持包括Java在内的多种语言。它提供的功能与JBehave非常相似。
- en: Let's see the same examples written in Cucumber.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用Cucumber写的相同的例子。
- en: 'The same as any other dependency we have used until now, Cucumber needs to
    be added to `build.gradle` before we can start using it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们到目前为止使用的任何其他依赖项一样，Cucumber需要在我们开始使用它之前添加到`build.gradle`中：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will create the same steps as we did with JBehave, using the Cucumber way:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Cucumber的方式创建与JBehave相同的步骤：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only noticeable difference between these two frameworks is the way Cucumber
    defines steps text. It uses regular expressions to match variables types, unlike
    JBehave which deduces them from a method signature.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架之间唯一显着的区别是Cucumber定义步骤文本的方式。它使用正则表达式来匹配变量类型，而JBehave则是根据方法签名推断它们。
- en: 'The steps code can be found in the `WebSteps` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤代码可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中的`WebSteps`类中找到：
- en: 'Let''s see how the story looks when written using the Cucumber syntax:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Cucumber语法编写的故事是什么样子的：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that there are almost no differences. This story can be found in the `wikipediaSearch.feature`
    file in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，几乎没有区别。这个故事可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中的`wikipediaSearch.feature`文件中找到。
- en: 'As you might have guessed, to run a Cucumber story, all you need to do is run
    the following Gradle task:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到，要运行Cucumber故事，您只需要运行以下Gradle任务：
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The result reports are located in the `build/reports/cucumber-report` directory.
    This is the report for the preceding story:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 结果报告位于`build/reports/cucumber-report`目录中。这是前面故事的报告：
- en: '![](img/00ef22c3-dab2-47a2-a9b5-9677e2487c12.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00ef22c3-dab2-47a2-a9b5-9677e2487c12.png)'
- en: Cucumber story execution report
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber故事执行报告
- en: The full code example can be found in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码示例可以在[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)存储库中找到。
- en: For a list of languages supported by Cucumber or for any other details, visit [https://cukes.info/](https://cukes.info/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Cucumber支持的语言列表或任何其他详细信息，请访问[https://cukes.info/](https://cukes.info/)。
- en: Since both JBehave and Cucumber offer a similar set of features, we decided
    to use JBehave throughout the rest of this book. There is a whole chapter dedicated
    to BDD and JBehave.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JBehave和Cucumber都提供了类似的功能，我们决定在本书的其余部分中都使用JBehave。还有一个专门的章节介绍BDD和JBehave。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a break from TDD and introduced many tools and frameworks
    that will be used for code demonstrations in the rest of the chapters. We set
    up everything from version control, virtual machines, building tools, and IDEs,
    until we reached frameworks that are commonly used as today's testing tools.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们暂时停止了TDD，并介绍了许多在接下来的章节中用于代码演示的工具和框架。我们从版本控制、虚拟机、构建工具和IDE一直设置到如今常用的测试工具框架。
- en: We are big proponents of the open source movement. Following this spirit, we
    made a special effort to select free tools and frameworks in every category.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是开源运动的坚定支持者。秉承这种精神，我们特别努力地选择了每个类别中的免费工具和框架。
- en: Now that we have set up all the tools that we will need, in the next chapter,
    we will go deeper into TDD, starting with the Red-Green-Refactor procedure-TDD's
    cornerstone.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了所有需要的工具，在下一章中，我们将深入探讨TDD，从Red-Green-Refactor过程-TDD的基石开始。
