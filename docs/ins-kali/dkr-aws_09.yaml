- en: Managing Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理秘密
- en: Secrets management is a critical security and operational requirement for modern
    applications and systems. Credentials such as usernames and passwords are commonly
    used to authenticate access to resources that may contain private and sensitive
    data, and it is very important that you can implement a secrets management solution
    that is able to provide these credentials to your applications in a secure manner
    that does not expose them to unauthorized parties.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '秘密管理是现代应用程序和系统的关键安全和运营要求。诸如用户名和密码之类的凭据通常用于验证对可能包含私人和敏感数据的资源的访问，因此非常重要的是，您能够实现一个能够以安全方式向您的应用程序提供这些凭据的秘密管理解决方案，而不会将它们暴露给未经授权的方。 '
- en: Secrets management for container-based applications is challenging, in part
    due to the ephemeral nature of containers and the fundamental requirement to run
    your containers on disposable and repeatable infrastructure. Gone are the days
    of long-lived servers where you could store secrets in a local file – now your
    servers are ECS container instances that can come and go, and you need to have
    some mechanism to be able to dynamically inject secrets into your application
    at runtime. A naive solution that we have used to date in this book is to use
    environment variables to inject your secrets directly into your application; however,
    this approach is considered insecure as it often exposes your secrets in plain
    text via various operational data sources. A more robust solution is to implement
    a secure credential store where your applications can dynamically retrieve their
    secrets in a secure manner – however, setting up your own credential store can
    be costly, time consuming, and introduce significant operational overheads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的应用程序的秘密管理具有挑战性，部分原因是容器的短暂性质以及在一次性和可重复基础设施上运行容器的基本要求。长期存在的服务器已经过去了，您可以在本地文件中存储秘密
    - 现在您的服务器是可以来来去去的 ECS 容器实例，并且您需要一些机制能够在运行时动态地将秘密注入到您的应用程序中。我们迄今为止在本书中使用的一个天真的解决方案是使用环境变量直接将您的秘密注入到您的应用程序中；然而，这种方法被认为是不安全的，因为它经常会通过各种运营数据源以纯文本形式暴露您的秘密。一个更健壮的解决方案是实现一个安全的凭据存储，您的应用程序可以以安全的方式动态检索其秘密
    - 然而，设置您自己的凭据存储可能会很昂贵、耗时，并引入重大的运营开销。
- en: In this chapter, you will implement a simple yet effective secrets management
    solution powered by two key AWS services—the  AWS Secrets Manager, and the Key
    Management Service or KMS. These services will provide you with a cloud-based
    secure credential store that is easy to manage, cost effective and is fully integrated
    with standard AWS security controls such as IAM policies and roles. You will learn
    how to integrate any application that supports configuration via environment variables
    with your secrets management solution, by creating an entry point script in your
    Docker images that uses the AWS CLI to dynamically retrieve and inject secrets
    securely into your internal container environments, and also learn how you can
    expose secrets to other resources in your CloudFormation stacks, when you are
    using CloudFormation to deploy your environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将实现一个简单而有效的秘密管理解决方案，由两个关键的 AWS 服务提供支持 - AWS Secrets Manager 和密钥管理服务或 KMS。这些服务将为您提供一个基于云的安全凭据存储，易于管理、成本效益，并且完全集成了标准的
    AWS 安全控制，如 IAM 策略和角色。您将学习如何将支持通过环境变量进行配置的任何应用程序与您的秘密管理解决方案集成，方法是在您的 Docker 映像中创建一个入口脚本，该脚本使用
    AWS CLI 动态地检索和安全地注入秘密到您的内部容器环境中，并且还将学习如何在使用 CloudFormation 部署您的环境时，将秘密暴露给 CloudFormation
    堆栈中的其他资源。
- en: 'The following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题将被涵盖：
- en: Creating KMS keys
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 KMS 密钥
- en: Creating secrets using the AWS Secrets Manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Secrets Manager 创建秘密
- en: Injecting secrets at container startup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器启动时注入秘密
- en: Provisioning secrets using CloudFormation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CloudFormation提供秘密
- en: Deploying secrets to AWS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密部署到AWS
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists technical requirements to complete this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: Administrator access to an AWS account
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对AWS帐户具有管理员访问权限
- en: Local AWS profile configured as per instructions in Chapter 3
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据第3章的说明配置本地AWS配置文件
- en: AWS CLI version 1.15.71 or higher
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI版本1.15.71或更高版本
- en: Chapter 8 needs to be completed along with a successfully deployed sample application
    to AWS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第8章需要完成，并成功部署示例应用程序到AWS
- en: The following GitHub URL contains the code samples used in this chapter – [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub URL包含本章中使用的代码示例 - [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2LzpEY2](http://bit.ly/2LzpEY2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2LzpEY2](http://bit.ly/2LzpEY2)'
- en: Creating KMS keys
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建KMS密钥
- en: A key building block of any secrets management solution is the ability to encrypt
    your credentials using encryption keys, which ensures the privacy and confidentiality
    of your credentials. The AWS Key Management Service (KMS) is a managed service
    that allows you to create and control encryption keys, and provides a simple,
    low-cost solution that takes away many of the operational challenges of managing
    your encryption keys. Key features of KMS include centralized key management,
    compliance with a number of industry standards, built-in auditing and integration
    with other AWS services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何秘密管理解决方案的关键构建块是使用加密密钥加密您的凭据，这确保了您的凭据的隐私和保密性。AWS密钥管理服务（KMS）是一项托管服务，允许您创建和控制加密密钥，并提供了一个简单、低成本的解决方案，消除了许多管理加密密钥的操作挑战。KMS的关键功能包括集中式密钥管理、符合许多行业标准、内置审计和与其他AWS服务的集成。
- en: When building a secrets management solution that uses AWS Secrets Manager, you
    should create, at a minimum, at least one KMS key in your local AWS account and
    region that is used to encrypt your secrets. AWS does provide a default KMS key
    that you can use with AWS Secrets Manager, so this is not a strict requirement,
    however, in general, you should be comfortable with creating your own KMS keys
    based upon your security requirements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建使用AWS Secrets Manager的秘密管理解决方案时，您应该在本地AWS帐户和区域中创建至少一个KMS密钥，用于加密您的秘密。AWS确实提供了一个默认的KMS密钥，您可以在AWS
    Secrets Manager中使用，因此这不是一个严格的要求，但是一般来说，根据您的安全要求，您应该能够创建自己的KMS密钥。
- en: You can easily create KMS keys using the AWS console and CLI, however in keeping
    with the general theme of adopting infrastructure as code, we will create a new
    KMS key using CloudFormation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用AWS控制台和CLI轻松创建KMS密钥，但是为了符合采用基础设施即代码的一般主题，我们将使用CloudFormation创建一个新的KMS密钥。
- en: 'The following example demonstrates creating a KMS key and KMS alias in a new
    CloudFormation template file that you can place at the root of the todobackend-aws
    repository, which we will call `kms.yml`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在新的CloudFormation模板文件中创建KMS密钥和KMS别名，您可以将其放在todobackend-aws存储库的根目录下，我们将其称为`kms.yml`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating KMS resources using CloudFormation
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation创建KMS资源
- en: In the preceding example, you create two resources—an `AWS::KMS::Key` resource
    called `KmsKey` that creates a new KMS key, and an `AWS::KMS::Alias` resource
    called `KmsKeyAlias`, which creates an alias or friendly name for the key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您创建了两个资源——一个名为`KmsKey`的`AWS::KMS::Key`资源，用于创建新的KMS密钥，以及一个名为`KmsKeyAlias`的`AWS::KMS::Alias`资源，用于为密钥创建别名或友好名称。
- en: The `KmsKey` resource includes a `KeyPolicy` property, which defines a resource
    policy that grants root account access to the key. This is a requirement for any
    KMS key that you create, in order to ensure you always have at least some means
    to access the key, which you may have used to encrypt valuable data that would
    cause considerable cost to the business if the key was inaccessible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`KmsKey`资源包括一个`KeyPolicy`属性，该属性定义了授予根帐户对密钥访问权限的资源策略。这是您创建的任何KMS密钥的要求，以确保您始终至少有一些方法访问密钥，您可能已经使用该密钥加密了有价值的数据，如果密钥不可访问，这将给业务带来相当大的成本。 '
- en: If you create a KMS key via the AWS console or CLI, the root account access
    policy will be automatically created for you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过AWS控制台或CLI创建KMS密钥，根帐户访问策略将自动为您创建。
- en: One interesting feature of the CloudFormation template in the preceding example
    is the creation of a CloudFormation export, which is created whenever you add
    the `Export` property to a CloudFormation output. In the preceding example, the
    `KmsKey` output exports the ARN of the `KmsKey` resource as specified by the `Value`
    property, and the `Export` property creates a CloudFormation export that you can
    reference in other CloudFormation stacks to inject the value of the export, rather
    than having to explicitly specify the value of the export. You will see how to
    leverage this CloudFormation export later on in this chapter, so don't worry if
    this doesn't quite make sense right now.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，CloudFormation模板的一个有趣特性是创建了一个CloudFormation导出，每当您将`Export`属性添加到CloudFormation输出时就会创建。在前面的示例中，`KmsKey`输出将`Value`属性指定的`KmsKey`资源的ARN导出，而`Export`属性创建了一个CloudFormation导出，您可以在其他CloudFormation堆栈中引用它，以注入导出的值，而不必明确指定导出的值。稍后在本章中，您将看到如何利用这个CloudFormation导出，所以如果现在还不太明白，不用担心。
- en: 'With the configuration of the preceding example in place, assuming you have
    placed this template in a file called `kms.yml`, you can now deploy the new stack,
    which will result in the creation of a new KMS key and KMS resource:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面示例中的配置，假设您已经将此模板放在名为`kms.yml`的文件中，现在可以部署新的堆栈，这将导致创建新的KMS密钥和KMS资源：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Deploying KMS Keys using CloudFormation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署KMS密钥
- en: 'In the preceding example, after the CloudFormation stack is created, notice
    that the `aws cloudformation list-exports` command now lists a single export with
    a name of `secrets-key`. The value of this export is the ARN of the KMS Key resource
    in your stack, and you can now use the `Fn::ImportValue` intrinsic function in
    other CloudFormation stacks to import this value by simply referencing the export
    name of `secrets-key` (for example, `Fn::ImportValue: secrets-key`).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，在创建CloudFormation堆栈之后，请注意`aws cloudformation list-exports`命令现在列出了一个名为`secrets-key`的单个导出。此导出的值是您堆栈中KMS密钥资源的ARN，您现在可以在其他CloudFormation堆栈中使用`Fn::ImportValue`内部函数来导入此值，只需简单地引用`secrets-key`的导出名称（例如，`Fn::ImportValue:
    secrets-key`）。'
- en: Be careful with your use of CloudFormation exports. These exports are intended
    for referencing resources that are static in nature whose value that you are exporting
    will never change in the future. Once a CloudFormation export is referenced by
    another stack you cannot change the value of that export, nor delete the resource
    or stack that the export belongs to. CloudFormation exports are useful for resources
    such as IAM roles, KMS keys and network infrastructure (for example, VPCs and
    subnets), which often are very static in nature and do not change once implemented.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CloudFormation导出时要小心。这些导出是用于引用静态资源的，您导出的值在未来永远不会改变。一旦另一个堆栈引用了CloudFormation导出，您就无法更改该导出的值，也无法删除导出所属的资源或堆栈。CloudFormation导出对于诸如IAM角色、KMS密钥和网络基础设施（例如VPC和子网）等静态资源非常有用，一旦实施后就不会改变。
- en: Encrypting and decrypting data using KMS
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用KMS加密和解密数据
- en: Now that you have created a KMS key, you can use this key to encrypt and decrypt
    data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个KMS密钥，您可以使用这个密钥来加密和解密数据。
- en: 'The following example demonstrates encrypting a simple plain text value using
    the AWS CLI:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用AWS CLI加密简单纯文本值：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Encrypting Data Using a KMS Key
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用KMS密钥加密数据
- en: 'In the preceding example, note that you must specify the KMS key ID or alias
    using the `--key-id` flag, and whenever you use a KMS key alias, you always prefix
    the alias with `alias/<alias-name>`. The encrypted data is returned as a Base64-encoded
    binary blob in the `CiphertextBlob` property, which conveniently also encodes
    the key ID of the encrypted KMS key into the encrypted data, meaning the KMS service
    can decrypt the ciphertext blob without requiring you to explicitly specific the
    encrypting KMS key ID:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意您必须使用`--key-id`标志指定KMS密钥ID或别名，并且每当使用KMS密钥别名时，您总是要使用`alias/<alias-name>`作为前缀。加密数据以Base64编码的二进制块形式返回到`CiphertextBlob`属性中，这也方便地将加密的KMS密钥ID编码到加密数据中，这意味着KMS服务可以解密密文块，而无需您明确指定加密的KMS密钥ID：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Decrypting Data Using a KMS Key
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用KMS密钥解密数据
- en: 'In the preceding example, you encrypt some data, this time using the AWS CLI
    query and text output options to capture the `CiphertextBlob` property value in
    a bash variable called `ciphertext`. You then use the `aws kms decrypt` command
    to pass in the cipher text as a blob file using bash process substitution to feed
    the Base64 decoded value of the cipher text into the binary file URI indicator
    (`fileb://`). Notice that the returned `Plaintext` value is not the `Hello World`
    value that you originally encrypted—this is because the `Plaintext` value is in
    a Base64 encoded format, and the following example takes the `aws kms decrypt`
    command a step further to return the original plaintext value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您加密了一些数据，这次使用AWS CLI查询和文本输出选项来捕获`CiphertextBlob`属性值，并将其存储在名为`ciphertext`的bash变量中。然后，您使用`aws
    kms decrypt`命令将密文作为二进制文件传递，使用bash进程替换将密文的Base64解码值传递到二进制文件URI指示器（`fileb://`）中。请注意，返回的`Plaintext`值不是您最初加密的`Hello
    World`值，这是因为`Plaintext`值是以Base64编码格式，下面的示例进一步使用`aws kms decrypt`命令返回原始明文值：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Decrypting Data Using a KMS Key and Returning the Plaintext ValueThe `base64
    --decode` command in the previous two examples are used to decode Base64 values
    on MacOS and most Linux platforms. On some Linux platforms such as Alpine Linux,
    the `--decode` flag is not recognized and you instead must use the `base64 -d`
    command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用KMS密钥解密数据并返回明文值在前两个示例中，`base64 --decode`命令用于解码MacOS和大多数Linux平台上的Base64值。在一些Linux平台（如Alpine
    Linux）上，`--decode`标志不被识别，您必须使用`base64 -d`命令。
- en: Creating secrets using the AWS Secrets Manager
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS Secrets Manager创建秘密
- en: You have established a KMS key that can be used to encrypt and decrypt data,
    and you can now integrate this key with the AWS Secrets Manager service, which
    is a managed service launched in March 2018 that enables you to easily and cost
    effectively incorporate secrets management into your applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经建立了一个可以用于加密和解密数据的KMS密钥，现在您可以将此密钥与AWS Secrets Manager服务集成，这是一个在2018年3月推出的托管服务，可以让您轻松且具有成本效益地将秘密管理集成到您的应用程序中。
- en: Creating secrets using the AWS console
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建秘密
- en: Although we have focused on creating AWS resources via CloudFormation in the
    past few chapters, unfortunately at the time of writing, CloudFormation does not
    support AWS Secrets Manager resources, so if you are using AWS tools you need
    to provision your secrets via the AWS console or AWS CLI.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在过去的几章中我们专注于通过CloudFormation创建AWS资源，但不幸的是，在撰写本文时，CloudFormation不支持AWS Secrets
    Manager资源，因此如果您使用AWS工具，您需要通过AWS控制台或AWS CLI来配置您的秘密。
- en: 'To create a new secret via the AWS console, select AWS Secrets Manager from
    the services list and click on the **Store a new secret** button. Select a secret
    type of **Other type of secrets**, specify a secret key and value, and select
    the `secrets-key` KMS key you created earlier in this chapter as demonstrated
    in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过AWS控制台创建新秘密，请从服务列表中选择AWS Secrets Manager，然后单击**存储新秘密**按钮。选择**其他类型的秘密**作为秘密类型，指定秘密键和值，并选择您在本章前面创建的`secrets-key`
    KMS密钥，如下面的屏幕截图所示：
- en: '![](assets/770663ce-e078-403a-ad44-11ed6bd3815f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/770663ce-e078-403a-ad44-11ed6bd3815f.png)'
- en: Creating a New Secret using AWS Secrets Manager
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS Secrets Manager创建新秘密
- en: In the earlier example, notice that AWS Secrets Manager allows you to store
    multiple key/value pairs in a single secret. This is important as you often want
    to inject secrets as environment variables, so storing secrets in a key/value
    format allows you to specify the environment variable name as the key, and secret
    as the value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意AWS Secrets Manager允许您在单个秘密中存储多个键/值对。这很重要，因为您经常希望将秘密注入为环境变量，因此以键/值格式存储秘密允许您将环境变量名称指定为键，将秘密指定为值。
- en: 'After clicking Next, you can configure a secret name and optional description:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单击下一步后，您可以配置秘密名称和可选描述：
- en: '![](assets/3000a2a3-9520-40df-b976-da5096b821c8.png)Configuring Secret Name
    and Description'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3000a2a3-9520-40df-b976-da5096b821c8.png)配置秘密名称和描述'
- en: In the preceding screenshot, you configure the secret to be called `todobackend/credentials`,
    which we will use later on in this chapter for the todobackend application. Once
    you have configured a secret name and description, you can click **Next**, skip
    the **Configure automatic rotation** section and finally click the **Store** button
    to complete creation of the secret.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您配置了要称为`todobackend/credentials`的秘密，我们将在本章后面用于todobackend应用程序。一旦您配置了秘密名称和描述，您可以单击**下一步**，跳过**配置自动轮换**部分，最后单击**存储**按钮以完成秘密的创建。
- en: Creating secrets using the AWS CLI
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI创建秘密
- en: 'You can also create secrets via the AWS CLI by using the `aws secretsmanager
    create-secret` command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`aws secretsmanager create-secret`命令通过AWS CLI创建秘密：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating a Secret Using the AWS CLI
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI创建秘密
- en: In the preceding example, notice that you specify the secret string as a JSON
    object, which provides the key/value format you saw earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意您将秘密字符串指定为JSON对象，这提供了您之前看到的键/值格式。
- en: Retrieving secrets using the AWS CLI
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI检索秘密
- en: 'You can retrieve secrets via the AWS CLI by using the `aws secretsmanager get-secret-value`
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`aws secretsmanager get-secret-value`命令通过AWS CLI检索秘密：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Obtain a Secret Value Using the AWS CLI
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI获取秘密值
- en: Later on in this chapter, you will create a custom entrypoint script for the
    sample application container, which will use the command in the preceding example
    to inject secrets into the application container environment on startup.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，您将为示例应用程序容器创建一个自定义入口脚本，该脚本将使用上面示例中的命令在启动时将秘密注入到应用程序容器环境中。
- en: Updating secrets using the AWS CLI
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI更新秘密
- en: Recall from Chapter 8, that the Django framework that powers the todobackend
    application requires an environment variable called `SECRET_KEY` to be configured,
    which is used for various cryptographic operations. Earlier in this chapter, when
    you created the **todobackend/credentials** secret, you only created a single
    key/value pair for the `MYSQL_PASSWORD` variable that is used for the database
    password.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第8章，驱动todobackend应用程序的Django框架需要配置一个名为`SECRET_KEY`的环境变量，用于各种加密操作。在本章早些时候，当您创建**todobackend/credentials**秘密时，您只为用于数据库密码的`MYSQL_PASSWORD`变量创建了一个键/值对。
- en: 'Let''s see how we can now update the **todobackend/credentials** secret to
    add in a value for the `SECRET_KEY` variable. You can update secrets by running
    the `aws secretsmanager update-secret` command, referencing the ID of the secret
    and specifying the new secret value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何现在更新**todobackend/credentials**秘密以添加`SECRET_KEY`变量的值。您可以通过运行`aws secretsmanager
    update-secret`命令来更新秘密，引用秘密的ID并指定新的秘密值：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Updating a Secret Value Using the AWS CLI
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI更新秘密值
- en: In the preceding example, notice that you can use the `aws secretsmanager get-random-password`
    command to generate a random password for you, which is ideal for the `SECRET_KEY`
    variable. It is important that you exclude quote and quotation characters using
    the `--exclude-characters` from this secret, as these characters will generally
    cause problems with bash scripts that process these values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，请注意您可以使用`aws secretsmanager get-random-password`命令为您生成一个随机密码，这对于`SECRET_KEY`变量非常理想。重要的是，您要使用`--exclude-characters`排除引号和引号字符，因为这些字符通常会导致处理这些值的bash脚本出现问题。
- en: You then run the `aws secretsmanager update-secret` command, specifying the
    correct KMS key ID and providing an updated JSON object that includes both the
    `MYSQL_PASSWORD` and `SECRET_KEY` key/value pairs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`aws secretsmanager update-secret`命令，指定正确的KMS密钥ID，并提供一个更新的JSON对象，其中包括`MYSQL_PASSWORD`和`SECRET_KEY`键/值对。
- en: Deleting and restoring secrets using the AWS CLI
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI删除和恢复秘密
- en: 'Deleting secrets can be achieved by running the `aws secretsmanager delete-secret`
    command, as demonstrated in the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行`aws secretsmanager delete-secret`命令来删除秘密，如下例所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Deleting a Secret Value Using the AWS CLI
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI删除秘密值
- en: 'Note that AWS Secrets Manager does not immediately delete your secret, and
    instead schedules the secret for deletion in 30 days. During this time the secret
    is inaccessible, however it can be restored before the schedule deletion date
    as demonstrated in the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，AWS Secrets Manager不会立即删除您的秘密，而是在30天内安排删除该秘密。在此期间，该秘密是不可访问的，但可以在安排的删除日期之前恢复，如下例所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Restoring a Secret Value Using the AWS CLI
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI恢复秘密值
- en: You can see that after deleting the secret you are unable to access the secret,
    however once you restore the secret using the `aws secretsmanager restore-secret`
    command, you are once again able to access your secret.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在删除秘密后，您无法访问该秘密，但是一旦使用`aws secretsmanager restore-secret`命令恢复秘密，您就可以再次访问您的秘密。
- en: Injecting secrets at container startup
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器启动时注入秘密
- en: One challenge with secrets management in Docker is passing secrets to your containers
    in a secure fashion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中管理秘密的一个挑战是以安全的方式将秘密传递给容器。
- en: 'The following diagram illustrates a somewhat naive but understandable approach
    that uses environment variables to inject your secrets directly as plaintext values,
    which is the approach we took in Chapter 8:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了一种有些天真但可以理解的方法，即使用环境变量直接注入你的秘密作为明文值，这是我们在第8章中采取的方法：
- en: '![](assets/b8598acf-a39f-4589-a201-c349a97e31bd.png)Injecting passwords via
    environment variables'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b8598acf-a39f-4589-a201-c349a97e31bd.png)通过环境变量注入密码'
- en: This approach is simple to configure and understand, however it is not considered
    best practice from a security perspective. When you take such an approach, you
    can view your credentials in plaintext by inspecting the ECS task definition,
    and if you run `docker inspect` commands on your ECS container instances, you
    can also view your credentials in plaintext. You may also inadvertently end up
    logging your secrets using this approach, which could be shared inadvertently
    with unauthorized third parties, so clearly this approach is not considered good
    practice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单易配置和理解，但从安全角度来看并不被认为是最佳实践。当你采用这种方法时，你可以通过检查ECS任务定义来以明文查看你的凭据，如果你在ECS容器实例上运行`docker
    inspect`命令，你也可以以明文查看你的凭据。你也可能无意中使用这种方法记录你的秘密，这可能会无意中与未经授权的第三方共享，因此显然这种方法并不被认为是良好的实践。
- en: An alternative approach that is considered much more secure is to store your
    secrets in a secure credential store, and have your application retrieve the secret
    when it starts up or whenever it requires the secret. AWS Secrets Manager is an
    example of a secure credential store that provides such a capability, and obviously
    this is the solution we will focus on in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种被认为更安全的替代方法是将你的秘密存储在安全的凭据存储中，并在应用程序启动时或在需要秘密时检索秘密。AWS Secrets Manager就是一个提供这种能力的安全凭据存储的示例，显然这是我们在本章将重点关注的解决方案。
- en: 'When you store your secrets in a secure credential store such as AWS Secrets
    Manager, you have two general approaches to obtain your secrets as illustrated
    in the following diagram:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将你的秘密存储在安全的凭据存储中，比如AWS Secrets Manager时，你有两种一般的方法来获取你的秘密，如下图所示：
- en: '**Application injects secrets:** With this approach, your applications include
    support for directly interfacing with your credential store.  Here, your application
    may look for a secret with a static name, or may have the secret name injecting
    via an environment variable. In the example of AWS Secrets Manager, this means
    your application code would use the AWS SDK to make the appropriate API calls
    to the AWS Secrets Manager to retrieve secret values.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序注入秘密：** 采用这种方法，你的应用程序包括直接与凭据存储进行接口的支持。在这里，你的应用程序可能会寻找一个静态名称的秘密，或者可能会通过环境变量注入秘密名称。在AWS
    Secrets Manager的示例中，这意味着你的应用代码将使用AWS SDK来进行适当的API调用，以从AWS Secrets Manager检索秘密值。'
- en: '**Entrypoint script injects secrets:** With this approach, you configure the
    name of the secret(s) that your application requires as a standard environment
    variable, with an entrypoint script that runs before your application, retrieving
    the secret(s) from AWS Secrets Manager and injecting them into the internal container
    environment as environment variables. Although this might sound like a similar
    approach to configuring environment variables at an ECS task definition level,
    the difference is that this happens inside the container after externally configured
    environment variables are applied, meaning they are not exposed to the ECS console
    or `docker inspect` commands:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Entrypoint脚本注入秘密：**使用这种方法，您可以将应用程序需要的秘密的名称配置为标准环境变量，然后在应用程序之前运行entrypoint脚本，从AWS
    Secrets Manager中检索秘密，并将它们作为环境变量注入到内部容器环境中。尽管这听起来与在ECS任务定义级别配置环境变量的方法类似，但不同之处在于这发生在容器内部，而外部配置的环境变量应用后，这意味着它们不会暴露给ECS控制台或`docker
    inspect`命令：'
- en: '![](assets/1f2b0532-b097-4637-861e-d3492194ff46.png)Using a Credential Store
    to Store and Retrieve Passwords'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1f2b0532-b097-4637-861e-d3492194ff46.png)使用凭据存储存储和检索密码'
- en: The approach where your application injects secrets is generally considered
    the best approach from a security perspective, however it does require the application
    to explicitly support interacting with the credential store that you use, meaning
    additional development and cost is required to support such an approach.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序注入秘密的方法通常从安全角度被认为是最佳方法，但这需要应用程序明确支持与您使用的凭据存储进行交互，这意味着需要额外的开发和成本来支持这种方法。
- en: The entrypoint script approach is considered less secure because you are exposing
    a secret outside the application, however the visibility of the secret is only
    within the container itself and is not visible externally. Using an entrypoint
    script does provide the benefit of not requiring applications to specifically
    support interacting with a credential store, making it a much more universal solution
    for providing secrets at runtime in a manner that is secure enough for most organizations,
    and this is the approach we will now focus on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: entrypoint脚本方法被认为不太安全，因为您在应用程序外部暴露了一个秘密，但秘密的可见性仅限于容器本身，不会在外部可见。使用entrypoint脚本确实提供了一个好处，即不需要应用程序专门支持与凭据存储进行交互，使其成为为大多数组织提供运行时秘密的更通用解决方案，而且足够安全，这是我们现在将要关注的方法。
- en: Creating an entrypoint script
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个entrypoint脚本
- en: The Docker `ENTRYPOINT` directive configures the very first command or script
    that is executed by the container. When configured in conjunction with the `CMD`
    directive, the `ENTRYPOINT` command or script is executed, with the `CMD` commands
    passed as arguments to the entrypoint script. This establishes a very common pattern
    of an entrypoint performing initialization tasks such as injecting secrets into
    the environment, which then invokes the application based on the command arguments
    passed to the script.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的`ENTRYPOINT`指令配置了容器执行的第一个命令或脚本。当与`CMD`指令一起配置时，`ENTRYPOINT`命令或脚本被执行，`CMD`命令作为参数传递给`entrypoint`脚本。这建立了一个非常常见的模式，即entrypoint执行初始化任务，例如将秘密注入到环境中，然后根据传递给脚本的命令参数调用应用程序。
- en: 'The following example demonstrates creating an entrypoint script for the todobackend
    sample application, that you should place in the root of the todobackend repository:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了为todobackend示例应用程序创建entrypoint脚本，您应该将其放在todobackend存储库的根目录中：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating an Entrypoint Script in the Todobackend Repository
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Todobackend存储库中创建一个entrypoint脚本
- en: 'The following example shows the content of the entrypoint script, which injects
    secrets from AWS Secrets Manager into the environment:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了入口脚本的内容，该脚本将从AWS Secrets Manager中注入秘密到环境中：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Defining an Entrypoint Script that Injects Secrets into the Environment
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个将秘密注入到环境中的入口脚本
- en: 'In the preceding example, an array called `secrets` is created from the `SECRETS`
    environment variable, which is expected to include the names of one or more secrets
    in a space delimited format that should be processed.  For example, you could
    process two secrets called `db/credentials` and `app/credentials` by setting the
    `SECRETS` environment variable as demonstrated in the example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，从`SECRETS`环境变量创建了一个名为`secrets`的数组，该数组预计以空格分隔的格式包含一个或多个秘密的名称，这些秘密应该被处理。例如，您可以通过在示例中演示的方式设置`SECRETS`环境变量来处理名为`db/credentials`和`app/credentials`的两个秘密：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Defining Multiple Secrets
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 定义多个秘密
- en: Referring back to the preceding example, the script then loops through each
    secret in the array, using the `aws secretsmanager get-secret-value` command to
    obtain the `SecretString` value of each secret, and then passes each value to
    the `jq` utility to parse the `SecretString` value as a JSON object and generate
    a shell expression that will export each secret key and value as an environment
    variable. Note that the `jq` expression has a lot of escaping involved to ensure
    special characters are interpreted literally, but the essence of this expression
    is to output `export *key*='*value*'` for each key/value pair in the credential.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的例子，然后脚本通过循环遍历数组中的每个秘密，使用`aws secretsmanager get-secret-value`命令获取每个秘密的`SecretString`值，然后将每个值传递给`jq`实用程序，将`SecretString`值解析为JSON对象，并生成一个shell表达式，将每个秘密键和值导出为环境变量。请注意，`jq`表达式涉及大量的转义，以确保特殊字符被解释为文字，但这个表达式的本质是为凭据中的每个键值对输出`export
    *key*='*value*'`。
- en: 'To understand this further, you can run the same command at the command line
    using the `todobackend/credentials` secret you created earlier:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解这一点，您可以在命令行上使用您之前创建的`todobackend/credentials`秘钥运行相同的命令：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Generating a Shell Expression to Export Secrets into the Environment
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个将秘钥导出到环境中的Shell表达式
- en: In the preceding example, notice that the output is the individual `export`
    commands you would execute to inject the secret key/value pairs into the environment.
    Each environment variable value is also single quoted, to ensure bash treats all
    special characters as literal values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，请注意输出是您将执行的单独的`export`命令，以将秘密键值对注入到环境中。每个环境变量值也被单引号引起来，以确保bash将所有特殊字符视为文字值。
- en: Referring back to the previous example, the `eval $vars` statement in the for
    loop simply evaluates the generated export statements as shell commands, which
    results in each key/value pair being injected into the local environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的例子，在for循环中的`eval $vars`语句简单地将生成的导出语句作为shell命令进行评估，这导致每个键值对被注入到本地环境中。
- en: Capturing the output of the `aws secretsmanager ...` command substitution in
    a separate variable ensures any errors that occur in this command substitution
    will be relayed back to your entrypoint script. You might be tempted to just run
    a single `eval $(aws secretsmanager ..)` statement in the for loop, however taking
    such an approach would mean if the `aws secretsmanager ...` command substitution
    exits with an error, your entrypoint script will not be aware of this error and
    will continue executing, which may lead to strange behavior for your application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的变量中捕获`aws secretsmanager ...`命令替换的输出，可以确保任何在此命令替换中发生的错误将被传递回您的入口脚本。您可能会尝试在for循环中只运行一个`eval
    $(aws secretsmanager ..)`语句，但采用这种方法意味着如果`aws secretsmanager ...`命令替换退出并出现错误，您的入口脚本将不会意识到这个错误，并且将继续执行，这可能会导致应用程序出现奇怪的行为。
- en: Once the loop is complete, the final `exec "$@"` statement hands off control
    to the arguments passed to the entrypoint script—these arguments are represented
    by the special `$@` shell variable. For example, if your entrypoint script was
    invoked as `entrypoint python3 manage.py migrate --noinput`, then the `$@` shell
    variable would hold the arguments `python3 manage.py migrate --noinput` and the
    final `exec` command would launch and hand off control to the `python3 manage.py
    migrate --noinput` command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，最终的`exec "$@"`语句将控制权交给传递给入口脚本的参数，这些参数由特殊的`$@` shell变量表示。例如，如果您的入口脚本被调用为`entrypoint
    python3 manage.py migrate --noinput`，那么`$@` shell变量将保存参数`python3 manage.py migrate
    --noinput`，最终的`exec`命令将启动并将控制权交给`python3 manage.py migrate --noinput`命令。
- en: It is very important to use the `exec "$@"` approach in your container entrypoint
    scripts, as `exec` ensures that the parent process of your container becomes whatever
    the command arguments that were passed to the entrypoint. If you didn't use `exec`
    and just ran the commands, the parent bash process that is running the script
    would remain the parent process of your container, and the bash process (rather
    than your application) would received subsequent signals to terminate the container
    when the container is stopped. You typically want your application to receive
    these signals, so that your application can gracefully clean up before terminating.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器入口脚本中使用`exec "$@"`方法非常重要，因为`exec`确保容器的父进程成为传递给入口点的命令参数。如果您没有使用`exec`，只是运行命令，那么运行脚本的父bash进程将保持为容器的父进程，并且在停止容器时，bash进程（而不是您的应用程序）将接收到后续的信号以终止容器。通常希望您的应用程序接收这些信号，以便在终止之前优雅地清理。
- en: Adding an entrypoint script to a Dockerfile
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Dockerfile添加入口脚本
- en: 'Now that you have established an entrypoint script in your todobackend repository,
    you need to add this script to the existing Dockerfile and ensure the script is
    specified as the entrypoint using the `ENTRYPOINT` directive:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在todobackend存储库中建立了一个入口脚本，您需要将此脚本添加到现有的Dockerfile，并确保使用`ENTRYPOINT`指令指定脚本作为入口点：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add an Entrypoint Script to a Dockerfile
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 向Dockerfile添加入口脚本
- en: In the preceding example, notice that you modify the first `RUN` directive to
    ensure the AWS CLI is installed, by adding the highlighted `pip3 --no-cache install
    awscli` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，请注意您修改第一个`RUN`指令以确保安装了AWS CLI，方法是添加`pip3 --no-cache install awscli`命令。
- en: Finally, you copy the entrypoint script to `/usr/bin/entrypoint`, ensure the
    script has the executable flag set, and specify the script as the entrypoint for
    the image. Note that you must configure the `ENTRYPOINT` directive in the exec
    style format, to ensure the command that you run in your container is passed as
    arguments to the entrypoint script (see first note at [https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将入口脚本复制到`/usr/bin/entrypoint`，确保脚本具有可执行标志，并将脚本指定为镜像的入口点。请注意，您必须以exec样式格式配置`ENTRYPOINT`指令，以确保您在容器中运行的命令作为参数传递给入口脚本（请参阅[https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd)中的第一个注释）。
- en: 'With your Dockerfile now updated, you need to commit your changes, rebuild
    and publish your Docker image changes as demonstrated in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的Dockerfile已更新，您需要提交更改，重新构建并发布Docker镜像更改，如下例所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Publishing the Updated Docker Image
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 发布更新的Docker镜像
- en: In the preceding example, when the Docker image is published, take note of the
    Docker tag for the app service (this is `5fdbe62` in my example, the actual hash
    will vary for you), which you recall from Chapter 1, specifies the Git commit
    hash of your source code repository. You will need this tag later on in this chapter
    to ensure you can deploy your changes to your todobackend application running
    in AWS.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，当Docker镜像发布时，请注意应用程序服务的Docker标签（在我的示例中为`5fdbe62`，实际哈希值会因人而异），您可以从第1章中回忆起，它指定了源代码库的Git提交哈希。您将在本章后面需要此标签，以确保您可以部署您的更改到在AWS中运行的todobackend应用程序。
- en: Provisioning secrets using CloudFormation
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation提供秘密
- en: You have created a secret in AWS Secrets Manager and have added support for
    injecting secrets securely into your containers using an entrypoint script. Recall
    that the entrypoint script looks for an environment variable called `SECRETS`,
    and the `ApplicationTaskDefinition` and `MigrateTaskDefinition` resources in your
    CloudFormation template for the todobackend stack are currently injecting the
    application database directly. In order to support using secrets in your stack,
    you need to configure your ECS task definitions to include the `SECRETS` environment
    variable, configured with the name(s) of your secrets, and you also need to ensure
    your container have appropriate IAM permissions to retrieve and decrypt your secrets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您已在AWS Secrets Manager中创建了一个秘密，并已添加了支持使用入口脚本将秘密安全地注入到容器中的功能。请记住，入口脚本会查找一个名为`SECRETS`的环境变量，而您CloudFormation模板中的`ApplicationTaskDefinition`和`MigrateTaskDefinition`资源目前正在直接注入应用程序数据库。为了支持在您的堆栈中使用秘密，您需要配置ECS任务定义，以包括`SECRETS`环境变量，并配置其名称为您的秘密名称，并且您还需要确保您的容器具有适当的IAM权限来检索和解密您的秘密。
- en: Another consideration is how the password for your `ApplicationDatabase` resource
    is configured—this is currently configured to use a password input via stack parameters;
    however, your database now needs to be able to somehow obtain its password from
    your newly created secret.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是您的`ApplicationDatabase`资源的密码是如何配置的——目前配置为使用堆栈参数输入的密码；但是，您的数据库现在需要能够以某种方式从您新创建的秘密中获取其密码。
- en: Configuring ECS task definitions to use secrets
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ECS任务定义以使用秘密
- en: Let's first deal with reconfiguring the ECS task definitions to use your newly
    created secret.  Your containers now include an entrypoint script that will retrieve
    secrets from AWS Secrets Manager, and before you update the various ECS task definitions
    to import the names of your secrets as an environment variable, you need to ensure
    your containers have the correct permissions to do this.  Although you could add
    such permissions to the ECS container instance role that is applied at an EC2
    instance level, a more secure approach is to create specific IAM roles that you
    can assign to your containers, given you might be sharing your ECS clusters with
    multiple applications and don't want to grant access to your secrets from any
    container that runs on the cluster.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要处理重新配置ECS任务定义以使用您新创建的秘密。您的容器现在包括一个入口脚本，该脚本将从AWS Secrets Manager中检索秘密，并且在更新各种ECS任务定义以将您的秘密名称导入为环境变量之前，您需要确保您的容器具有执行此操作的正确权限。虽然您可以将此类权限添加到应用于EC2实例级别的ECS容器实例角色，但更安全的方法是创建特定的IAM角色，您可以将其分配给您的容器，因为您可能会与多个应用程序共享ECS集群，并且不希望从在集群上运行的任何容器中授予对您秘密的访问权限。
- en: 'ECS includes a feature called IAM roles for tasks ([https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html)),
    which allows you to grant IAM permissions at an ECS task definition level, and
    is useful in our scenario of wanting to only grant access to the todobackend secret
    to the todobackend application. The following example demonstrates creating an
    IAM role that grants these privileges:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ECS包括一个名为IAM任务角色的功能（[https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html)），它允许您在ECS任务定义级别授予IAM权限，并且在我们只想要将对todobackend秘密的访问权限授予todobackend应用程序的情况下非常有用。以下示例演示了创建授予这些特权的IAM角色：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating an IAM Task Role
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建IAM任务角色
- en: In the preceding example, you create a new resource called `ApplicationTaskRole`,
    which includes an `AssumeRolePolicyDocument` property that defines the trusted
    entities that can assume the role.  Notice that the principal here is the `ecs-tasks.amazonaws.com`
    service, which is the service context that your containers assume when they attempt
    to access AWS resources using permissions granted by the IAM role. The role includes
    a policy that grants the permission `secretsmanager:GetSecretValue`, which as
    you might expect allows you to retrieve secret values, and this permission is
    constrained to the ARN of all secrets that are named with a prefix of `todobackend/`.
    If you refer back to the previous example when you created a test secret via the
    AWS CLI, you can see that the ARN of the secret includes a random value at the
    end of the ARN, hence you need to use wildcards in your ARN to ensure you have
    permissions regardless of this random suffix.  Note that the role also includes
    the `Decrypt` permission on the `secrets-key` KMS key, and you use the `!ImportValue`
    or `Fn::ImportValue` intrinsic function to import the ARN of the KMS key you exported
    back in the very first example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您创建了一个名为`ApplicationTaskRole`的新资源，其中包括一个`AssumeRolePolicyDocument`属性，该属性定义了可以承担该角色的受信任实体。请注意，这里的主体是`ecs-tasks.amazonaws.com`服务，这是您的容器在尝试使用IAM角色授予的权限访问AWS资源时所假定的服务上下文。该角色包括一个授予`secretsmanager:GetSecretValue`权限的策略，这允许您检索秘密值，这个权限被限制为所有以`todobackend/`为前缀命名的秘密的ARN。如果您回顾一下之前的示例，当您通过AWS
    CLI创建了一个测试秘密时，您会发现秘密的ARN包括ARN末尾的随机值，因此您需要在ARN中使用通配符，以确保您具有权限，而不考虑这个随机后缀。请注意，该角色还包括对`secrets-key`
    KMS密钥的`Decrypt`权限，并且您使用`!ImportValue`或`Fn::ImportValue`内部函数来导入您在第一个示例中导出的KMS密钥的ARN。
- en: 'With the `ApplicationTaskRole` resource in place, the following example demonstrates
    reconfiguring the `ApplicationTaskDefinition` and `MigrateTaskDefinition` resources
    in the `stack.yml` file located in the todobackend-aws repository:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`ApplicationTaskRole`资源，以下示例演示了如何重新配置`stack.yml`文件中的`todobackend-aws`存储库中的`ApplicationTaskDefinition`和`MigrateTaskDefinition`资源：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Configuring ECS Task Definitions to use Secrets
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置ECS任务定义以使用秘密
- en: In the preceding example, you configure each task definition to use an IAM task
    role via the `TaskRoleArn` property, which references the `ApplicationTaskRole`
    resource you created in the previous example. You next add the `SECRETS` environment
    variable that the new entrypoint script in your Docker image expects, and remove
    the previous `MYSQL_PASSWORD` and `SECRET_KEY` variables that are now retrieved
    from the AWS Secrets Manager service. Notice that you need to include an environment
    variable called `AWS_DEFAULT_REGION`, as this is required by the AWS CLI to determine
    which region you are located in.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您配置每个任务定义使用IAM任务角色通过`TaskRoleArn`属性，该属性引用了您在上一个示例中创建的`ApplicationTaskRole`资源。接下来，您添加新入口脚本在您的Docker镜像中期望的`SECRETS`环境变量，并删除先前从AWS
    Secrets Manager服务中检索的`MYSQL_PASSWORD`和`SECRET_KEY`变量。请注意，您需要包括一个名为`AWS_DEFAULT_REGION`的环境变量，因为这是AWS
    CLI所需的，以确定您所在的区域。
- en: 'Because you are no longer injecting a database password into your stack as
    a parameter, you need to also update the `dev.cfg` file in the todobackend-aws
    repository, and also specify the updated Docker image tag that you published back
    in the earlier example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您不再将数据库密码作为参数注入到堆栈中，您还需要更新todobackend-aws存储库中的`dev.cfg`文件，并且还要指定您在之前示例中发布的更新的Docker镜像标记：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Updating input parameters
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更新输入参数
- en: In the preceding example, the `DatabasePassword=my-super-secret-password` line
    has been removed, and the value of the `ApplicationImageTag` parameter has been
    updated, referencing the commit hash that is tagged on your newly updated Docker
    image.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`DatabasePassword=my-super-secret-password`行已被删除，并且`ApplicationImageTag`参数的值已被更新，引用了您新更新的Docker镜像上标记的提交哈希。
- en: Exposing secrets to other resources
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向其他资源公开秘密
- en: You have updated your ECS task definitions such that your application containers
    will now pull secrets from AWS Secrets Manager and inject them as environment
    variables. This works fine for your Docker images, as you have full control over
    how your images behave and can add features such as entrypoint scripts to inject
    secrets appropriately. For other resources that depend on these secrets, you don't
    have such a capability—for example, the `ApplicationDatabase` resource in your
    stack defines an RDS instance that as of the time of writing, does not include
    native support for AWS Secrets Manager.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您已更新了ECS任务定义，使您的应用容器现在将从AWS Secrets Manager中提取秘密并将它们注入为环境变量。这对于您的Docker镜像效果很好，因为您可以完全控制您的镜像的行为，并且可以添加诸如入口脚本之类的功能来适当地注入秘密。对于依赖这些秘密的其他资源，您没有这样的能力，例如，您堆栈中的`ApplicationDatabase`资源定义了一个RDS实例，截至撰写本文时，它不包括对AWS
    Secrets Manager的本地支持。
- en: One solution to this problem is to create a CloudFormation custom resource,
    whose job is to query the AWS Secrets Manager service and return the secret value
    associated with a given secret.  Because custom resources can have data properties
    attached to them, you can then reference these properties in other resources,
    providing a simple mechanism to inject your secrets into any CloudFormation resource
    that does not natively support AWS Secrets Manager. If you are wondering about
    the security of such an approach, the CloudFormation custom resource response
    specification ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html))
    includes a property called `NoEcho`, which instructs CloudFormation to not expose
    data properties via the console or in logging information.  By setting this property,
    you can therefore ensure you secrets are not inadvertently exposed by querying
    the CloudFormation API or by reviewing CloudFormation logs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是创建一个CloudFormation自定义资源，其工作是查询AWS Secrets Manager服务并返回与给定秘密相关的秘密值。因为自定义资源可以附加数据属性，所以您可以在其他资源中引用这些属性，提供一个简单的机制将您的秘密注入到任何不原生支持AWS
    Secrets Manager的CloudFormation资源中。如果您对这种方法的安全性有疑问，CloudFormation自定义资源响应规范（[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html)）包括一个名为`NoEcho`的属性，该属性指示CloudFormation不通过控制台或日志信息公开数据属性。通过设置此属性，您可以确保您的秘密不会因查询CloudFormation
    API或审查CloudFormation日志而无意中暴露。
- en: Creating a Secrets Manager Lambda function
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Secrets Manager Lambda函数
- en: 'The following example demonstrates adding a Lambda function resource to your
    CloudFormation stack that queries the AWS Secrets Manager service and returns
    a secret value given a target secret name and target key within the key/value
    pairs within the secret value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了向您的CloudFormation堆栈添加一个Lambda函数资源，该函数查询AWS Secrets Manager服务，并返回给定秘密名称和秘密值内键/值对中的目标键的秘密值：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Adding a Secrets Manager CloudFormation Custom Resource Function
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个Secrets Manager CloudFormation自定义资源函数
- en: The configuring of the preceding example is very similar to the configuration
    you performed back in Chapter 8, when you created the `EcsTaskRunner` custom resource
    function.  Here, you create a `SecretsManager` Lambda function with an associated
    `SecretsManagerRole` IAM role that grants the ability to retrieve and decrypt
    secrets from AWS Secrets Manager in a similar fashion to the `ApplicationTaskRole`
    created earlier, along with a `SecretsManagerLogGroup` resource to collect logs
    from the Lambda function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的配置与您在第8章中执行的配置非常相似，当时您创建了`EcsTaskRunner`自定义资源函数。在这里，您创建了一个`SecretsManager`
    Lambda函数，配有一个关联的`SecretsManagerRole` IAM角色，该角色授予了从AWS Secrets Manager检索和解密密钥的能力，类似于之前创建的`ApplicationTaskRole`，以及一个`SecretsManagerLogGroup`资源，用于收集来自Lambda函数的日志。
- en: The function code is simpler than the ECS task runner code, and expects a single
    property called `SecretId` to be passed to the custom resource, which specifies
    the ID or name of the secret. The function obtains the secret from the AWS Secrets
    Manager, and then loads the secret key/value pairs as a JSON object into a variable
    called `credentials` using the `json.loads` method.  The function then returns
    the `credentials` variable to CloudFormation, which means each credential can
    be access by other resources in your stack. Notice that you use a `with` statement
    to ensure the response data that is printed by the `cfnresponse.send` method is
    suppressed by setting the `sys.stdout` property to `/dev/null`, given the response
    data includes secret values that you don't want to expose in plaintext. This approach
    does require some care, and you need to restore the `sys.stdout` property to its
    default state (as represented by the `sys.__stdout__` property) at the beginning
    of the `handler` method, as your Lambda function runtime may be cached across
    multiple invocations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数代码比 ECS 任务运行器代码更简单，期望传递一个名为 `SecretId` 的属性给自定义资源，该属性指定秘密的 ID 或名称。函数从 AWS Secrets
    Manager 获取秘密，然后使用 `json.loads` 方法将秘密键值对加载为名为 `credentials` 的 JSON 对象变量。然后，函数将
    `credentials` 变量返回给 CloudFormation，这意味着每个凭据都可以被堆栈中的其他资源访问。请注意，您使用 `with` 语句来确保由
    `cfnresponse.send` 方法打印的响应数据被抑制，通过将 `sys.stdout` 属性设置为 `/dev/null`，因为响应数据包含您不希望以明文形式暴露的秘密值。这种方法需要一些小心，您需要在
    `handler` 方法的开头将 `sys.stdout` 属性恢复到其默认状态（由 `sys.__stdout__` 属性表示），因为您的 Lambda
    函数运行时可能会在多次调用之间被缓存。
- en: The custom resource function code could be extended to also provision secrets
    into AWS Secrets Manager. For example, you could take as an input the KMS encrypted
    value of a intended secret value or even generate a random secret value, and then
    provision and expose this credential to other resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源函数代码可以扩展到将秘密部署到 AWS Secrets Manager。例如，您可以将预期的秘密值的 KMS 加密值作为输入，甚至生成一个随机的秘密值，然后部署和公开此凭据给其他资源。
- en: Creating a secrets custom resource
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个秘密自定义资源
- en: 'Now that you have a Lambda function in place for your custom resource, you
    can create the actual custom resource that will provide access to secrets stored
    in AWS Secrets Manager. The following example demonstrates adding a custom resource
    for the **todobackend/credentials** secret that you created earlier in this chapter,
    which is then accessed from your `ApplicationDatabase` resource:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为自定义资源准备了一个 Lambda 函数，您可以创建实际的自定义资源，该资源将提供对存储在 AWS Secrets Manager 中的秘密的访问。以下示例演示了在本章前面创建的
    **todobackend/credentials** 密钥的自定义资源，然后从您的 `ApplicationDatabase` 资源中访问该密钥：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding a Secrets Manager Custom Resource
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 Secrets Manager 自定义资源
- en: In the preceding example, you create a custom resource called `Secrets` which
    references the `SecretsManager` function via the `ServiceToken` property, and
    then passes the name of the credential to retrieve via the `SecretId` property.
    The `MasterUserPassword` property on the existing `ApplicationDatabase` resource
    is then updated to reference the `MYSQL_PASSWORD` key that is accessible via the
    `Secrets` resource, which returns the correct password value stored in the **todobackend/credentials**
    secret.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您创建了一个名为 `Secrets` 的自定义资源，它通过 `ServiceToken` 属性引用 `SecretsManager` 函数，然后通过
    `SecretId` 属性传递要检索的凭据的名称。然后，现有的 `ApplicationDatabase` 资源上的 `MasterUserPassword`
    属性被更新为引用通过 `Secrets` 资源可访问的 `MYSQL_PASSWORD` 键，该键返回存储在 **todobackend/credentials**
    密钥中的正确密码值。
- en: Deploying secrets to AWS
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将秘密部署到 AWS
- en: 'At this point, you are ready to deploy your changes to your CloudFormation
    stack, which you can do using the `aws cloudformation deploy` command we have
    used throughout the past few chapters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已准备好部署对CloudFormation堆栈的更改，您可以使用我们在过去几章中使用的`aws cloudformation deploy`命令来执行：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Deploying CloudFormation stack changes
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 部署CloudFormation堆栈更改
- en: 'The deployment will affect a number of resources as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 部署将影响以下资源：
- en: The resources supporting the custom resource will first be created, along with
    changes to the ECS task definitions being applied.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自定义资源的资源将首先被创建，同时将应用于ECS任务定义的更改。
- en: The custom resource called `Secrets` will be created, which once created will
    expose the key/value pairs of the **todobackend/credentials** secret to other
    CloudFormation resources.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为`Secrets`的自定义资源将被创建，一旦创建，将公开**todobackend/credentials**密钥的键/值对给其他CloudFormation资源。
- en: The `ApplicationDatabase` resource will be updated, with the `MasterPassword`
    property updated based upon the value of the `MYSQL_PASSWORD` variable in the **todobackend/credentials**
    secret.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationDatabase`资源将被更新，`MasterPassword`属性将根据**todobackend/credentials**密钥中`MYSQL_PASSWORD`变量的值进行更新。'
- en: The `MigrateTask` custom resource will be updated given the changes to the associated `MigrateTaskDefinition`,
    and run a new task that uses the entrypoint script in the updated todobackend
    image to export each of the key/value pairs in the **todobackend/credentials**
    secret into the environment, which includes the `MYSQL_PASSWORD` variable required
    for accessing the application database.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MigrateTask`自定义资源将根据与关联的`MigrateTaskDefinition`的更改进行更新，并运行一个新任务，该任务使用更新后的todobackend镜像中的入口脚本将**todobackend/credentials**密钥中的每个键/值对导出到环境中，其中包括访问应用程序数据库所需的`MYSQL_PASSWORD`变量。'
- en: The `ApplicationService` resource will be updated given the changes to the associated `ApplicationTaskDefinition`,
    and similar to the `MigrateTask` each application instance will now inject the
    environment variables associated with the **todobackend/credentials** secret upon
    startup. The update will trigger your a rolling deployment of the `ApplicationService`,
    which will bring the new version of your application into service, and then drain
    and remove the old version of your application without causing any outages.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationService`资源将根据与关联的`ApplicationTaskDefinition`的更改进行更新，并且类似于`MigrateTask`，每个应用程序实例现在在启动时将注入与**todobackend/credentials**密钥相关的环境变量。更新将触发`ApplicationService`的滚动部署，这将使新版本的应用程序投入使用，然后排空和移除旧版本的应用程序，而不会造成任何中断。'
- en: Assuming the deployment is successful, you should be able to verify your application
    is still working successfully, and that you can list, add and remove todo items.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设部署成功，您应该能够验证应用程序仍然成功运行，并且可以列出、添加和删除待办事项。
- en: 'You should also verify that your `SecretsManagerFunction` resource is not logging
    the plaintext values of your secrets—the following screenshot shows the log output
    from this function, and you can see does suppress logging of the success response
    that is sent back to CloudFormation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该验证您的`SecretsManagerFunction`资源未记录秘密的明文值—以下屏幕截图显示了此功能的日志输出，并且您可以看到它抑制了发送回CloudFormation的成功响应的日志记录：
- en: '![](assets/25145a22-a7df-45d4-bf25-3c5f3a9aa41b.png)Viewing Log Output from
    the Secrets Manager Function'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/25145a22-a7df-45d4-bf25-3c5f3a9aa41b.png)查看Secrets Manager功能的日志输出'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Secrets management is a challenge for the ephemeral nature of Docker applications,
    where the notion of preconfigured long-running servers with credentials stored
    in a configuration file is no longer an option, and injecting passwords directly
    as externally configured environment variables is considered a bad security practice.
    This requires a secrets management solution where your applications can dynamically
    fetch secrets from a secure credential store, and in this chapter you successfully
    implemented such a solution using the AWS Secrets Manager and KMS services.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密管理对于短暂的Docker应用程序来说是一个挑战，其中预先配置的长时间运行的服务器并不再是一个选项，因为凭据存储在配置文件中，直接将密码作为外部配置的环境变量注入被认为是一种糟糕的安全实践。这需要一个秘密管理解决方案，使您的应用程序可以动态地从安全凭据存储中获取秘密，在本章中，您成功地使用AWS
    Secrets Manager和KMS服务实现了这样的解决方案。
- en: You learned how to create a KMS key, which encrypts and decrypts confidential
    information, and is used by AWS Secrets Manager to ensure the privacy and confidentiality
    of secrets it stores. You next were introduced to the AWS Secrets Manager and
    learned how to create secrets using both the AWS console and AWS CLI. You learned
    how you can store multiple key/value pairs in your secrets, and were introduced
    to features such as deletion protection, where AWS Secrets Manager allows you
    to restore a previously deleted secret for up to 30 days.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何创建KMS密钥，用于加密和解密机密信息，并由AWS Secrets Manager使用，以确保其存储的秘密的隐私和保密性。接下来，您将介绍AWS
    Secrets Manager，并学习如何使用AWS控制台和AWS CLI创建秘密。您学会了如何在秘密中存储多个键/值对，并介绍了诸如删除保护之类的功能，其中AWS
    Secrets Manager允许您在30天内恢复先前删除的秘密。
- en: With a credential store in place for your sample application, you learned how
    you can use entrypoint scripts in your containers to dynamically fetch and inject
    secret values at container startup, using a simple bash script in conjunction
    with the AWS CLI to inject one or more secret values as variables into your internal
    container environment. Although this approach is considered less secure than your
    applications fetching secrets directly, it does have the advantage that it can
    be applied to any application that supports environment variables for configuration,
    making it a much more universal solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了样本应用程序的凭据存储位置，您学会了如何在容器中使用入口点脚本，在容器启动时动态获取和注入秘密值，使用简单的bash脚本与AWS CLI结合，将一个或多个秘密值作为变量注入到内部容器环境中。尽管这种方法被认为比应用程序直接获取秘密不太安全，但它的优势在于可以应用于支持环境变量配置的任何应用程序，使其成为一个更加通用的解决方案。
- en: After publishing updated Docker images for your application, you updated your
    ECS task definitions to inject the names of the secrets each of your containers
    should retrieve, and then created a simple custom resource that is able to expose
    your secrets to other types of AWS resources that don't support AWS Secrets Manager
    natively, and don't have mechanisms such as container entrypoint scripts to retrieve
    secrets. You ensured this custom resource was configured such that it does not
    disclose your credentials via logs or other forms of operational events, and updated
    your application database resource to retrieve the database password for the application
    via this custom resource.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您的应用程序发布更新的Docker镜像后，您更新了ECS任务定义，以注入每个容器应检索的秘密的名称，然后创建了一个简单的自定义资源，能够将您的秘密暴露给不支持AWS
    Secrets Manager的其他类型的AWS资源，并且没有机制（如容器入口点脚本）来检索秘密。您确保配置了此自定义资源，以便它不会通过日志或其他形式的操作事件透露您的凭据，并更新了应用程序数据库资源，以通过此自定义资源检索应用程序的数据库密码。
- en: With a secrets management solution in place, you have addressed a core security
    concern from previous chapters, and in the next chapter, you will learn how you
    can address another security concern for your applications, which is to be able
    to independently isolate network access and apply network access rules on a per
    container or ECS task definition basis.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个安全管理解决方案，您已经解决了前几章的核心安全问题，在下一章中，您将学习如何解决应用程序的另一个安全问题，即能够独立隔离网络访问并在每个容器或ECS任务定义基础上应用网络访问规则。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True/False: The KMS service requires you to supply your own private key information.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：KMS服务要求您提供自己的私钥信息。
- en: What feature of KMS allows you to specify a logical name for your key, rather
    than the UUID-based identifier of the key?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: KMS的哪个特性允许您为密钥指定逻辑名称，而不是基于UUID的标识符？
- en: You want to avoid manually configuring the ARN of a KMS key that you use in
    multiple CloudFormation stacks.  Assuming you defined the KMS key in a separate
    CloudFormation stack, what CloudFormation feature can you use to solve this problem?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想避免手动配置在多个CloudFormation堆栈中使用的KMS密钥的ARN。假设您在单独的CloudFormation堆栈中定义了KMS密钥，您可以使用哪个CloudFormation功能来解决这个问题？
- en: 'True/False: When you delete a secret from AWS Secrets Manager you can never
    recover the secret.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：当您从AWS Secrets Manager中删除一个秘密时，您永远无法恢复该秘密。
- en: Which tools would you typically use in an entrypoint script to retrieve a secret
    from AWS Secrets Manager and transform the key/value pairs in the secret to be
    suitable for exporting to the container environment?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在入口脚本中，您通常会使用哪些工具来从AWS Secrets Manager检索秘密并将秘密中的键/值对转换为适合导出到容器环境的形式？
- en: You receive an error in a container entrypoint script indicating you do not
    have sufficient permissions to access a secret.  You check the IAM role and confirm
    it has a single permission `secretsmanager:GetSecretValue` allowed for the secret. 
    What other permission do you need to grant to resolve this issue?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器入口脚本中收到一个错误，指示您没有足够的权限访问一个秘密。您检查了IAM角色，并确认它对该秘密允许了一个单一的`secretsmanager:GetSecretValue`权限。您需要授予哪些其他权限来解决这个问题？
- en: Which CloudFormation custom resource property should you set when dealing with
    sensitive data that should not be exposed as plaintext values?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理不应公开为明文值的敏感数据时，应设置哪个CloudFormation自定义资源属性？
- en: You receive an error "You must configure a region" in a container entrypoint
    script that accesses AWS resources.  What environment variable should you add
    to your container?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问AWS资源的容器入口脚本中收到错误消息“您必须配置区域”。您应该向容器添加哪个环境变量？
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about what the topics
    covered in this chapter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: CloudFormation KMS Key Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation KMS密钥资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html)
- en: CloudFormation KMS Alias Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation KMS别名资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html)
- en: AWS KMS Developer Guide: [https://docs.aws.amazon.com/kms/latest/developerguide/overview.html](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS KMS开发人员指南：[https://docs.aws.amazon.com/kms/latest/developerguide/overview.html](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html)
- en: AWS CLI KMS Reference: [https://docs.aws.amazon.com/cli/latest/reference/kms/index.html](https://docs.aws.amazon.com/cli/latest/reference/kms/index.html)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI KMS 参考：[https://docs.aws.amazon.com/cli/latest/reference/kms/index.html](https://docs.aws.amazon.com/cli/latest/reference/kms/index.html)
- en: AWS Secrets Manager User Guide: [https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 用户指南：[https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)
- en: AWS CLI Secrets Manager Reference: [https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html](https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI Secrets Manager 参考：[https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html](https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html)
- en: AWS Python SDK Secrets Manager Reference: [http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html](http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Python SDK Secrets Manager 参考：[http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html](http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html)
- en: CloudFormation Exports: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation 导出：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html)
- en: General Discussion on Docker Secrets Management: [https://github.com/moby/moby/issues/13490](https://github.com/moby/moby/issues/13490)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Secrets Management 的一般讨论：[https://github.com/moby/moby/issues/13490](https://github.com/moby/moby/issues/13490)
