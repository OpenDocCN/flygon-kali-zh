- en: Assessments
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: One outcome of bad code is that you can end up with a really badly written piece
    of code that is hard to understand. This can often lead to programmer stress and
    software that is buggy, hard to maintain, and hard to test and extend.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 糟糕代码的一个结果是，你可能最终得到一段非常糟糕的难以理解的代码。这往往会导致程序员压力和软件出现错误，难以维护、测试和扩展。
- en: One outcome of good code is that it is easy to read and understand, as you know
    the programmer's intent. This leads to less stress for programmers who must debug
    the code, test it, and extend it.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好代码的一个结果是它易于阅读和理解，因为你知道程序员的意图。这会减轻程序员在调试、测试和扩展代码时的压力。
- en: When you break a large project up into modular components and libraries, each
    module can be worked on by separate teams concurrently. Small modules are easy
    to test, code, document, deploy, extend, and maintain.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将一个大项目分解成模块化的组件和库时，每个模块可以由不同的团队同时进行工作。小模块易于测试、编码、文档化、部署、扩展和维护。
- en: '**DRY** stands for **Don''t Repeat Yourself**. Look for repeatable code, and
    refactor it so that you remove duplicate code. The advantage of this is smaller
    programs, because if such code contains bugs, you only have to change it in one
    place.'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DRY**代表**Don''t Repeat Yourself**。寻找可重复的代码，并重构它，以便删除重复的代码。这样做的好处是程序更小，因为如果这样的代码包含错误，你只需要在一个地方进行更改。'
- en: KISS means simple code that will not confuse programmers, especially if you
    have juniors on your team. KISS code is easy to read and write tests for.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: KISS意味着简单的代码不会让程序员困惑，特别是如果你的团队中有初级程序员。KISS代码易于阅读和编写测试。
- en: '**S** is the **Single Responsibility Principle**, **O** is the **Open/Closed
    Principle**, **L** is **Liskov Substitution**, **I** is the **Interface Segregation
    Principle**, and **D** is the **Dependency Inversion Principle**.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**S**是**Single Responsibility Principle**，**O**是**Open/Closed Principle**，**L**是**Liskov
    Substitution**，**I**是**Interface Segregation Principle**，**D**是**Dependency Inversion
    Principle**。'
- en: '**YAGNI** is short for **You Aren''t Going to Need It**. In other words, don''t
    add code you don''t need. Only add the code you absolutely need, and no more.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**YAGNI**是**You Aren''t Going to Need It**的缩写。换句话说，不要添加不需要的代码。只添加绝对需要的代码，不要多余。'
- en: Occam's Razor is the principle that states: *Entities must not be multiplied
    without necessity.* *Deal only in facts. Only make assumptions if absolutely necessary*.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀原则是指：*实体不应该被无必要地增加。* *只处理事实。只有在绝对必要的情况下才做假设*。
- en: Chapter 2
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: The two roles in the peer code review are reviewer and reviewee.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同行代码审查中的两个角色是审阅者和被审阅者。
- en: The project manager agrees on the people that will be involved in the peer code
    review.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目经理同意参与同行代码审查的人员。
- en: You can save your reviewer time and effort prior to requesting a peer code review
    by making sure your code and tests all work, that you perform code analysis on
    your project and fix any issues raised, and that your code adheres to the company
    coding guidelines.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求同行代码审查之前，通过确保你的代码和测试都能正常工作，对项目进行代码分析并修复任何问题，以及确保你的代码符合公司的编码准则，可以节省审阅者的时间和精力。
- en: When reviewing code, look out for naming, formatting, programming styles, potential
    bugs, correctness of code and tests, security, and performance issues.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在审查代码时，要注意命名、格式、编程风格、潜在错误、代码和测试的正确性、安全性和性能问题。
- en: The three categories of feedback are positive, optional, and critical.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反馈的三个类别是积极的、可选的和关键的。
- en: Chapter 3
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: We can place our code in individual source files in folder structures and wrap
    classes, interfaces, structs, and enums in namespaces that map to the folder structure.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码放在文件夹结构中的单独源文件中，并将类、接口、结构和枚举包装在映射到文件夹结构的命名空间中。
- en: A class should have only one responsibility.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类应该只有一个职责。
- en: You can comment in your code for document generators using XML comments placed
    directly above the public member to be documented.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在代码中添加注释，用于文档生成器，放置在要记录的公共成员的正上方的XML注释。
- en: Cohesion is the logical grouping together of code that works on the same responsibility.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内聚性是将处理相同职责的代码逻辑分组在一起。
- en: Coupling refers to the dependencies between classes.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 耦合指的是类之间的依赖关系。
- en: Cohesion should be high.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内聚性应该很高。
- en: Coupling should be low.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 耦合应该很低。
- en: You can use DI and IoC to design for change.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用DI和IoC来设计变更。
- en: '**DI** stands for **Dependency Injection**.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DI**代表**Dependency Injection**。'
- en: '**IoC** stands for **Inversion of Control**.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IoC**代表**Inversion of Control**。'
- en: Immutable objects are type-safe and so can be safely passed between threads.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可变对象是类型安全的，因此可以在线程之间安全地传递。
- en: Objects should expose methods and properties and hide data.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象应该暴露方法和属性，并隐藏数据。
- en: Data structures should expose data and have no methods.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据结构应该暴露数据，不应该有方法。
- en: Chapter 4
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: Methods with no parameters are called niladic methods.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有参数的方法称为niladic方法。
- en: Methods with only one parameter are called monadic methods.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个参数的方法称为单元方法。
- en: Methods with two parameters are called dyadic methods.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有两个参数的方法称为二元方法。
- en: Methods with three parameters are called triadic methods.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有三个参数的方法称为三元方法。
- en: Methods with more than three parameters are called polyadic methods.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有三个以上参数的方法称为多元方法。
- en: You should avoid duplicate code. It is not a productive way to program, can
    make programs unnecessarily large, and has the propensity to proliferate the same
    exception throughout your codebase.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该避免重复的代码。这不是一种有效的编程方式，会使程序变得不必要地庞大，并有可能在整个代码库中扩散相同的异常。
- en: Functional programming is a software coding methodology that treats computations
    as the mathematical evaluation of computations that does not modify state.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程是一种将计算视为不修改状态的数学计算的软件编码方法。
- en: The advantages of functional programming include safe code in multithreaded
    applications and smaller, more meaningful methods that are easy to read and understand.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程的优势包括在多线程应用中的安全代码和更小、更有意义的易于阅读和理解的方法。
- en: Input and output can be a problem for functional programs as it relies on side-effects.
    Functional programming does not allow for side-effects.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入和输出对于函数式程序可能会产生问题，因为它依赖于副作用。函数式编程不允许副作用。
- en: WET code is the opposite of DRY in that code is written each time it is needed.
    This produces duplication, and the same exception can occur in multiple locations
    within a program, making maintenance and support more difficult.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WET代码是DRY的反义词，因为每次需要时都会编写代码。这会产生重复，并且相同的异常可能会在程序的多个位置发生，使得维护和支持更加困难。
- en: DRY code is the opposite of WET in that code is only ever written once and is
    reused wherever it is needed. This reduces the code base and exception footprint,
    thus making programs easier to read and maintain.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY代码是WET的反义词，因为代码只会被写一次，并在需要时被重复使用。这减少了代码库和异常足迹，使得程序更易于阅读和维护。
- en: You DRY out WET code by removing duplicate code using refactoring.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重构来消除重复的代码，使WET代码变DRY。
- en: Long methods are cumbersome and prone to exceptions. The smaller they are, the
    easier they are to read and maintain. There is also less chance of the programmer
    introducing bugs, especially of a logical nature.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长方法笨重且容易出现异常。它们越小，阅读和维护就越容易。程序员引入逻辑错误的机会也更小。
- en: To avoid having to use try/catch blocks, you can write argument validators.
    You would then call the validators at the top of your method. If the parameters
    fail validation, then the appropriate exception is thrown, and the method is not
    executed.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免使用try/catch块，你可以编写参数验证器。然后在方法的开头调用验证器。如果参数未通过验证，则会抛出适当的异常，并且方法不会被执行。
- en: Chapter 5
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: A checked exception is an exception that is checked at compile time.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已检查的异常是在编译时检查的异常。
- en: An unchecked exception is an exception that is not checked or simply ignored
    at compile time.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未经检查的异常是在编译时未经检查或简单忽略的异常。
- en: An overflow exception is raised when high-order bits cannot be assigned to the
    destination type. In checked mode, `OverflowException` is raised. In unchecked
    mode, high-order bits that cannot be assigned are simply ignored.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当高阶位无法分配给目标类型时，会引发溢出异常。在检查模式下，会引发`OverflowException`。在未经检查的模式下，无法分配的高阶位会被简单忽略。
- en: An attempt made to access a property or a method on a null object.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '尝试访问空对象的属性或方法。 '
- en: Implement a `Validator` class and an `Attribute` class that checks the parameter
    for null, and that throws `ArgumentNullException`. You would use the `Validator`
    class at the top of your methods so that you don't get halfway through the method
    before the exception is raised.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`Validator`类和一个`Attribute`类，检查参数是否为空，并抛出`ArgumentNullException`。你会在方法的开头使用`Validator`类，这样在方法执行到一半之前就会引发异常。
- en: '**Business Rule Exception** (**BRE**).'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**业务规则异常**（**BRE**）。'
- en: BREs are bad practice because they expect exceptions to be raised in order to
    control program flow.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BREs是一种不好的做法，因为它们期望异常被引发以控制程序流程。
- en: Correct programming should never control the flow of a computer program by expecting
    exceptions as output. So, given that BREs are bad as they expect exceptional output
    and use it to control program flow, a better solution is to use conditional programming.
    With a conditional program, you use Boolean logic. Boolean logic allows for two
    possible paths of execution, and never raises exceptions. Conditional checks are
    explicit and make the programs easier to read and maintain. You can also easily
    extend such code, whereas with BREs, you can't.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的编程不应该通过期望异常作为输出来控制计算机程序的流程。因此，鉴于BRE是不好的，因为它们期望异常输出并用它来控制程序流程，更好的解决方案是使用条件编程。在条件程序中，你使用布尔逻辑。布尔逻辑允许两种可能的执行路径，并且不会引发异常。条件检查是显式的，并且使程序更易于阅读和维护。你还可以轻松地扩展这样的代码，而对于BRE，你无法这样做。
- en: First, start with error trapping for known types of exceptions such as `ArgumentNullExceptions`
    and `OverflowExceptions` using known exception types in the Microsoft .NET Framework.
    But when these are insufficient and don't provide enough data for your particular
    situation, then you would write and use your own custom exceptions and apply meaningful
    exception messages.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从已知的异常类型开始进行错误捕获，比如使用Microsoft .NET Framework中已知的异常类型`ArgumentNullExceptions`和`OverflowExceptions`。但是当这些不够用，并且不能为特定情况提供足够的数据时，你会编写并使用自定义异常，并应用有意义的异常消息。
- en: 'Your custom exception must inherit from `System.Exception`, and implement three
    constructors: the default construct, a constructor that accepts a text message,
    and a constructor that accepts a text message and an inner exception.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的自定义异常必须继承自`System.Exception`，并实现三个构造函数：默认构造函数，接受文本消息的构造函数，以及接受文本消息和内部异常的构造函数。
- en: Chapter 6
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: A good unit test must be atomic, deterministic, repeatable, and fast.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的单元测试必须是原子的、确定性的、可重复的和快速的。
- en: A good unit test must not be inconclusive.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的单元测试不应该是不确定的。
- en: Test-driven development.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试驱动开发。
- en: Behavioral-driven development.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为驱动开发。
- en: A small unit of code whose only purpose is to test a single unit of code that
    only does one thing.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个小的代码单元，其唯一目的是测试只执行一件事的单个代码单元。
- en: A fake object used by the unit test to test the public methods and properties
    of a real object, but without testing the method or property dependencies.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试使用的虚假对象，用于测试真实对象的公共方法和属性，但不测试方法或属性的依赖关系。
- en: A fake object is the same as a mock object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个虚假对象与一个模拟对象相同。
- en: MSTest, NUnit, and xUnit.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MSTest、NUnit和xUnit。
- en: Rhino Mocks and Moq.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rhino Mocks和Moq。
- en: SpecFlow.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpecFlow。
- en: Unnecessary comments, dead code, and redundant tests.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不必要的注释、死代码和冗余测试。
- en: Chapter 7
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: The testing of a complete system from end to end. This can be performed manually,
    automatically, or by using both methods.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头到尾测试完整系统。这可以手动、自动或两种方法结合进行。
- en: Integration testing.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试。
- en: Manual testing of all features, all our unit tests should pass, and we should
    write automation tests to test the commands and data that are passed between two
    modules.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有功能的手动测试，所有单元测试都应通过，并且我们应编写自动化测试来测试两个模块之间传递的命令和数据。
- en: 'Factories are classes that implement the factory method pattern whose intention
    is to allow the creation of objects without specifying their classes. We would
    use them in the following scenarios:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂是实现工厂方法模式的类，其意图是允许创建对象而不指定它们的类。我们会在以下情况下使用它们：
- en: The class is unable to anticipate the type of object that must be instantiated.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类无法预测必须实例化的对象类型。
- en: The subclass must specify the type of object to instantiate.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类必须指定要实例化的对象类型。
- en: The class controls the instantiation of its objects.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类控制其对象的实例化。
- en: DI is a method of producing loosely coupled code that is easy to maintain and
    extend.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DI是一种产生松散耦合代码的方法，易于维护和扩展。
- en: Using a container makes the management of dependency objects easy.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用容器可以轻松管理依赖对象。
- en: Chapter 8
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: A thread is a process.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程是一个进程。
- en: One.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个。
- en: Background threads and foreground threads.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后台线程和前台线程。
- en: The background thread.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后台线程。
- en: The foreground thread.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前台线程。
- en: '`Thread.Sleep(500);`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep(500);`'
- en: '`var thread = new Thread(Method1);`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var thread = new Thread(Method1);`'
- en: Set `IsBackground` equal to `true`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsBackground`设置为`true`。
- en: A deadlock is a situation when two threads are blocked and waiting on the other
    thread to release the resource.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁是两个线程被阻塞并等待另一个线程释放资源的情况。
- en: '`Monitor.Exit(objectName);`'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Monitor.Exit(objectName);`'
- en: Multiple threads using the same resource generate different outputs based on
    the timings of each thread.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同资源的多个线程根据每个线程的时间产生不同的输出。
- en: Use the TPL with `ContinueWith()`, and use `Wait()` to wait until the task has
    finished before exiting the method.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TPL与`ContinueWith()`，并使用`Wait()`在退出方法之前等待任务完成。
- en: Using a member variable that is shared by other methods, and passing in reference
    variables.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其他方法共享的成员变量，并传递引用变量。
- en: Yes.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。
- en: The ThreadPool.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程池。
- en: It is an object that cannot be modified once it has been constructed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种一旦构建就无法修改的对象。
- en: They allow you to safely share data between threads.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们允许您在线程之间安全共享数据。
- en: Chapter 9
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Application Programming Interface.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序编程接口。
- en: Representational State Transfer.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表述性状态转移。
- en: Uniform interface, client-server, stateless, cacheable, layered system, optional
    executable code.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统一接口、客户端-服务器、无状态、可缓存、分层系统、可选可执行代码。
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**).'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态的引擎**（**HATEOAS**）。'
- en: RapidApi.com.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RapidApi.com。
- en: Authorization and authentication.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权和认证。
- en: Claims are statements that an entity makes about itself. These claims are then
    validated against a data store. They are particularly useful in role-based security
    to check whether the entity making the claim is authorized in regard to that claim.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明是实体对自身的陈述。然后根据数据存储对这些声明进行验证。它们在基于角色的安全性中特别有用，用于检查作出声明的实体是否对该声明有授权。
- en: Making API requests and examining their responses.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出API请求并检查它们的响应。
- en: Because you can change your data store in keeping with your requirements.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为您可以根据需求更改数据存储。
- en: Chapter 10
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: The correct partitioning of software into logical namespaces, interfaces, and
    classes, which aids the testing of software.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将软件正确分区为逻辑命名空间、接口和类，有助于测试软件。
- en: By understanding APIs, you can KISS your code and keep it DRY by not reinventing
    the wheel and writing code that already exists. This saves time, energy, and money.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过了解API，您可以通过不重复发明轮子并编写已经存在的代码来简化代码并使其保持干燥。这样可以节省时间、精力和金钱。
- en: Structs.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构。
- en: Third-party APIs are written by software developers, and so subject to human
    error that introduces bugs. By testing third-party APIs, you can be confident
    they work as expected, and if not, then you can have the code fixed or write a
    wrapper for it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方API由软件开发人员编写，因此容易出现引入错误的人为错误。通过测试第三方API，您可以确信它们按预期工作，如果不是，则可以修复代码或为其编写包装器。
- en: Your APIs are prone to errors. By testing them in keeping with the specification
    and its acceptance criteria, you can be sure you are delivering what the business
    wants at the agreed level of quality ready for public release.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的API容易出错。通过根据规范及其验收标准测试它们，您可以确保以商业期望的质量水平交付准备进行公开发布。
- en: The specification and acceptance criteria provide the normal program flow. From
    them, you can determine what to test in regard to the normal flow of execution,
    and you can determine what exceptional circumstances will be encountered and test
    for them.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规范和验收标准提供了正常程序流程。通过它们，您可以确定在执行的正常流程方面进行测试，并确定将遇到什么异常情况并对其进行测试。
- en: Namespaces, interfaces, and classes.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间、接口和类。
- en: Chapter 11
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: Cross-cutting concerns are those concerns that not part of the business requirements
    that form the core concerns, but that must be addressed in all areas of the code. **AOP**
    stands for **Aspect-Oriented Programming**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 横切关注点是不属于核心关注点的业务需求的关注点，但必须在代码的所有领域中进行处理。**AOP**代表**面向切面编程**。
- en: An aspect is an attribute that, when applied to a class, method, property, or
    parameter, injects code at compile time. You apply an aspect in square brackets
    before the item it is being applied to.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方面是应用于类、方法、属性或参数时，在编译时注入代码的属性。您在应用属性之前在方括号中应用属性。
- en: An attribute gives semantic meaning to an item. You apply an attribute in square
    brackets before the item it is being applied to.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性为项目赋予语义含义。您在应用属性之前在方括号中应用属性。
- en: Attributes give the code semantic meaning, while aspects remove the boilerplate
    code so that it is injected at compile time.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性赋予代码语义含义，而方面则消除样板代码，使其在编译时注入。
- en: When the code is being built, the compiler will insert the boilerplate code
    that the aspect hides from the programmer. This process is known as code weaving.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码正在构建时，编译器将插入切面隐藏程序员的样板代码。这个过程被称为代码编织。
- en: Chapter 12
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: Code metrics are several source code measurements that enable us to identify
    how complex our software is, and how maintainable it is. Such measurements enable
    us to identify areas of code that can be made less complex and more maintainable
    through refactoring.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码度量是几个源代码测量，使我们能够确定软件的复杂程度和可维护性。这些测量使我们能够确定可以通过重构使代码更简单和更易维护的代码区域。
- en: Cyclomatic complexity, maintainability index, depth of inheritance, class coupling,
    lines of source code, and lines of executable code.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圈复杂度，可维护性指数，继承深度，类耦合，源代码行数和可执行代码行数。
- en: Code analysis is the static analysis of source code with the intention of identifying
    design flaws, issues with globalization, security problems, issues with performance,
    and interoperability problems.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分析是对源代码的静态分析，目的是识别设计缺陷，全球化问题，安全问题，性能问题和互操作性问题。
- en: Quick actions are single commands identified by a screwdriver or lightbulb that
    will suppress warnings, add using statements, import missing libraries and add
    the using statements, correct errors, and implement language usage improvements
    aimed at simplifying code and reducing the number of lines in a method.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速操作是由螺丝刀或灯泡标识的单个命令，它将抑制警告，添加使用语句，导入缺少的库并添加使用语句，纠正错误，并实现旨在简化代码并减少方法中行数的语言使用改进。
- en: JetBrains' dotTrace utility is a profiling tool used for the purpose of profiling
    source code and compiled assemblies to identify potential issues with the software.
    With it you can perform sampling, tracing, line-by-line, and timeline profiling.
    You can profile execution time, thread time, real-time CPU instructions, and thread
    cycle time.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JetBrains的dotTrace实用程序是用于对源代码和编译的程序集进行性能分析的工具，以识别软件的潜在问题。您可以执行采样，跟踪，逐行和时间线分析。您可以分析执行时间，线程时间，实时CPU指令和线程周期时间。
- en: JetBrains' ReSharper utility is a code refactoring tool that helps developers
    identify and fix code issues and implement language features to improve and speed
    up the programmer's programming experience.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JetBrains的ReSharper实用程序是一个代码重构工具，它帮助开发人员识别和修复代码问题，并实现语言特性以改进和加快程序员的编程体验。
- en: The decompilation of source code can be used to retrieve lost source code, generate
    PDBs for debugging, and for learning. You can also use the decompiler to see how
    well you have obfuscated your code to make it hard for hackers and other people
    to steal your code secrets.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码的反编译可用于检索丢失的源代码，为调试生成PDB，并用于学习。您还可以使用反编译器查看您的代码混淆得有多好，以使黑客和其他人难以窃取您的代码秘密。
- en: Chapter 13
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: Application-level, class-level, and method-level.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用级别，类级别和方法级别。
- en: Boolean blindness, combinatorial explosion, contrived complexity, data clump,
    deodorant comments, duplicate code, lost intent, mutation of variables, oddball
    solution, shotgun surgery, solution sprawl, and uncontrolled side effects.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔盲目，组合爆炸，人为复杂，数据团，除臭剂注释，重复代码，意图丢失，变量突变，古怪解决方案，散弹手术，解决方案蔓延和不受控制的副作用。
- en: Cyclomatic complexity, divergent change, downcasting, excessive literal use,
    feature envy, inappropriate intimacy, indecent exposure, large class (also known
    as God object), lazy class (also known as freeloader and lazy object), middleman
    class, an orphan class of variables and constants, primitive obsession, refused
    bequest, speculative generality, Tell, don't ask!, and temporary field.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圈复杂度，分歧变更，向下转型，过多的文字使用，特征嫉妒，不当亲密，不雅曝光，大类（也称为上帝对象），懒惰类（也称为吃白食者和懒惰对象），中间人类，变量和常量的孤立类，原始偏执，拒绝遗赠，推测性泛化，告诉，不要问！和临时字段。
- en: Black sheep, cyclomatic complexity, contrived complexity, dead code, excessive
    data return, feature envy, identifier size, inappropriate intimacy, long line
    aka God line, lazy method, long method (God method), long parameter list (too
    many parameters), message chains, middleman method, oddball solutions, and speculative
    generality.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 害群之马，圈复杂度，人为复杂，死代码，过多的数据返回，特征嫉妒，标识符大小，不当亲密，长行（也称为上帝行），懒惰方法，长方法（上帝方法），长参数列表（太多参数），消息链，中间人方法，古怪解决方案和推测性泛化。
- en: Use LINQ instead of loops. Make classes responsible for only one thing. Make
    methods do only one thing. Replace long lists of parameters with parameter objects.
    Use creational design patterns to improve the efficiency of expensive object creation
    and utilization. Keep methods to 10 lines or less. Use AOP to remove boilerplate
    code from methods. Decouple objects and make them testable. Make code highly cohesive.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LINQ而不是循环。使类只负责一件事。使方法只做一件事。用参数对象替换长参数列表。使用创建性设计模式来提高昂贵对象的创建和利用效率。保持方法不超过10行。使用AOP从方法中删除样板代码。解耦对象并使它们可测试。使代码高度内聚。
- en: A value that represents the amount of branching and looping.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代表分支和循环数量的值。
- en: Reduce the amount of branching and looping that takes place until such time
    as the cyclomatic complexity value becomes 10 or less.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少分支和循环的数量，直到圈复杂度值变为10或更少。
- en: Making things more complicated than they need to be.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使事情变得比必要的更复杂。
- en: '**Keep It Simple, Stupid** (**KISS**).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保持简单，愚蠢**（**KISS**）。'
- en: The same thing is done by different methods with different parameter combinations.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用不同的方法和不同的参数组合做同样的事情。
- en: Create generic methods that can perform the same task on the different data
    types so that you only have the one method with one set of parameters.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建通用方法，可以对不同数据类型执行相同的任务，这样你只需要一个方法和一组参数。
- en: Fix the bad code and remove the comment.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复糟糕的代码并删除注释。
- en: Ask for help.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻求帮助。
- en: Stack Overflow.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆栈溢出。
- en: A long parameter list can be replaced with a parameter object.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长参数列表可以用参数对象替换。
- en: Refactor it into smaller methods that do only one thing, and remove boilerplate
    code into aspects using AOP.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重构为只执行一件事的较小方法，并使用AOP将样板代码移入方面。
- en: No more than 10 lines.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不超过10行。
- en: 0-10; anything beyond that and you are asking for trouble.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 0-10；超过这个范围，您就会自找麻烦。
- en: One.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一。
- en: Variables, classes, properties, and methods that are not used. Get rid of them.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未使用的变量、类、属性和方法。摆脱它们。
- en: Choose the best method of implementation, and then refactor the code to use
    just that method of implementation.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最佳的实现方法，然后重构代码以只使用该实现方法。
- en: Refactor the temporary field and the methods that operate on it into their own
    class.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时字段和操作它的方法重构为它们自己的类。
- en: The same set of variables used in different classes. Refactor the variables
    into a class of their own, and then reference the class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同类中使用相同的变量集。将变量重构为它们自己的类，然后引用该类。
- en: A class inherits from another class but does not use all its methods.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类继承自另一个类，但不使用其所有方法。
- en: The Law of Demeter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迪米特法则。
- en: Only allow classes to speak to their immediate neighbors.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只允许类与其直接邻居交谈。
- en: A class or method spending too much time inside another class or method.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类或方法在另一个类或方法中花费太多时间。
- en: Refactor dependencies in their own class or method.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将依赖关系重构为它们自己的类或方法。
- en: The factory method.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂方法。
- en: Inherit from a base class, and then create the new class that inherits from
    the base.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基类继承，然后创建从基类继承的新类。
- en: Single responsibility is implemented in different methods of different classes
    across different layers of the application. Refactor the responsibility into its
    own class so that it is only in a single location.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一责任在应用程序的不同层中的不同类的不同方法中实现。将责任重构为自己的类，以便它只存在于一个位置。
- en: The data should be placed in the same object that operates on it.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据应该放在操作数据的同一个对象中。
- en: When you create an object that asks another object for data so that it can perform
    operations on it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您创建一个对象，该对象请求另一个对象的数据，以便它可以对其执行操作。
- en: A single change requires changes in multiple locations. Remove duplication,
    remove the coupling, and improve cohesion.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一更改需要在多个位置进行更改。消除重复，消除耦合，提高内聚性。
- en: Lost intent is when the reason for the class or method is unclear because there
    are lots of unrelated items clumped together. Refactor the code so that all methods
    are in the right class. That way, the intent of the class and the methods becomes
    clear.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 失去意图是因为类或方法的原因不清楚，因为有许多不相关的项目被聚集在一起。重构代码，使得所有方法都在正确的类中。这样，类和方法的意图就变得清晰了。
- en: You can refactor loops with LINQ queries. LINQ is a functional language that
    does not alter location variables and can perform much faster than loops.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用LINQ查询重构循环。LINQ是一种不改变位置变量并且比循环执行得快得多的函数语言。
- en: Chapter 14
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: '**GoF** is short for **Gang-of-Four** patterns. These are 23 patterns that
    are grouped into creational, structural, and behavioral design patterns. They
    are considered the foundation of all software design patterns. They work together
    to produce clean object-oriented code.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GoF**是**Gang-of-Four**模式的缩写。这些模式被分为创建、结构和行为设计模式。它们被认为是所有软件设计模式的基础。它们共同工作以产生清晰的面向对象的代码。'
- en: Creational patterns enable abstraction and inheritance to provide an object-oriented
    way of removing code duplication and improving performance when object creation
    is expensive. The creational patterns are abstract factory, factory method, singleton,
    prototype, and builder.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模式使抽象和继承能够以面向对象的方式消除代码重复，并在对象创建昂贵时提高性能。创建模式包括抽象工厂、工厂方法、单例、原型和生成器。
- en: Structural patterns enable the correct management of relationships between objects.
    We can use structural patterns to enable incompatible interfaces to work together,
    decouple abstractions from their implementations, and improve performance. The
    structural patterns are adapter, bridge, composite, decorator, façade, flyweight,
    and proxy.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构模式使对象之间的关系得到正确管理。我们可以使用结构模式使不兼容的接口一起工作，将抽象与其实现解耦，并提高性能。结构模式包括适配器、桥接、组合、装饰器、外观、享元和代理。
- en: Behavioral patterns govern how objects interact and communicate with each other.
    We can use them to produce pipelines, encapsulate commands and information to
    be executed at a future point in time, mediate between objects, observe state
    changes in objects, and more. The behavior patterns are chain of responsibility,
    command, interpreter, iterator, mediator, memento, observer, state, strategy,
    template method, and visitor.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为模式规定对象如何相互交互和通信。我们可以使用它们来生成管道，封装命令和将来执行的信息，调解对象之间的关系，观察对象的状态变化，等等。行为模式包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法和访问者。
- en: Yes.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。
- en: The singleton only allows a single instance of an object throughout the lifetime
    of the application. The object is globally accessible to all objects that need
    it. We use this pattern when we need to ensure we have one centralized point of
    object creation and object access.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例只允许在应用程序的整个生命周期中存在一个对象实例。该对象对所有需要它的对象都是全局可访问的。当我们需要确保有一个集中的对象创建和对象访问点时，我们使用此模式。
- en: We use factory methods when we have a need to create objects without specifying
    the exact class to be instantiated.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们需要创建对象而不指定要实例化的确切类时，我们使用工厂方法。
- en: Façade.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外观。
- en: Use the flyweight design pattern.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用享元设计模式。
- en: Bridge.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桥接。
- en: Use the builder pattern.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成器模式。
- en: You would use the chain of responsibility pattern, as you can have a pipeline
    of handlers, each of which performs a task. If they are unable to handle the task,
    the handlers pass the task to their successor to handle.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用责任链模式，因为您可以拥有一系列处理程序，每个处理程序执行一个任务。如果它们无法处理任务，处理程序将将任务传递给它们的后继者来处理。
