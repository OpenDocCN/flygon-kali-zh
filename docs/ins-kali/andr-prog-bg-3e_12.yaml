- en: '*Chapter 12*: The Stack, the Heap, and the Garbage Collector'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：栈、堆和垃圾收集器'
- en: By the end of this chapter, the missing link between Java and our XML layouts
    will be fully revealed, leaving us with the power to add all kinds of widgets
    to our apps as we have done before, but this time, we will be able to control
    them through our Java code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，Java和我们的XML布局之间的缺失链接将被完全揭示，让我们有能力像以前一样向我们的应用程序添加各种小部件，但这一次，我们将能够通过我们的Java代码来控制它们。
- en: In this chapter, we will get to take control of some simple UI elements such
    as `Button` and `TextView` and in the next chapter, we will take things further
    and manipulate a whole range of UI elements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将控制一些简单的UI元素，如`Button`和`TextView`，在下一章中，我们将进一步操作一系列UI元素。
- en: To enable us to understand what is happening, we need to find out a bit more
    about the memory in an Android device and two areas of it – the **Stack** and
    the **Heap**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们理解发生了什么，我们需要更多地了解Android设备的内存以及其中的两个区域 - **栈**和**堆**。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Android UI elements are classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android UI元素是类
- en: Garbage collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Our UI is on the heap?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的UI在堆上？
- en: Special types of classes, including inner and anonymous
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊类型的类，包括内部和匿名
- en: Back to that news flash.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 回到那个新闻快讯。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012)。
- en: All the Android UI elements are classes too
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有的Android UI元素也是类
- en: When our app is run and the `setContentView` method is called from the `onCreate`
    method, the layout is `inflated` from the XML and instances of the UI classes
    are loaded into memory as usable objects. They are stored in a part of the memory
    called the heap. The heap is managed by the **Android Runtime** (**ART**) system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序运行并且从`onCreate`方法中调用`setContentView`方法时，布局从XML中`inflated`，UI类的实例被加载到内存中作为可用对象。它们存储在一个称为堆的内存部分中。堆由**Android
    Runtime**（**ART**）系统管理。
- en: Re-introducing references
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新介绍引用
- en: But where are all these UI objects/classes? We certainly can't see them in our
    code. And how on earth do we get our hands on them?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是所有这些UI对象/类在哪里？我们在代码中肯定看不到它们。我们怎么能得到它们？
- en: The ART inside every Android device takes care of memory allocation to our apps.
    In addition, it stores different types of variables in different places.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备内部的ART负责为我们的应用程序分配内存。此外，它将不同类型的变量存储在不同的位置。
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the **Stack**. We can stick to our existing warehouse analogy
    when talking about the Stack. We already know how we can manipulate variables
    on the Stack with straightforward expressions. So, let's talk about the heap and
    what is stored there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法中声明和初始化的变量存储在被称为**栈**的内存区域。在谈论栈时，我们可以继续使用我们现有的仓库类比。我们已经知道如何使用简单的表达式在栈上操作变量。所以，让我们谈谈堆和那里存储的东西。
- en: Important fact
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事实
- en: All objects of classes are reference type variables and are just references
    to the actual objects that are stored on the heap – they are not the actual objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类的对象都是引用类型变量，只是指向存储在堆上的实际对象的引用 - 它们不是实际的对象。
- en: Think of the heap as a separate area of the same warehouse. The heap has lots
    of floor space for odd-shaped objects, racks for smaller objects, lots of long
    rows with smaller-sized cubby holes, and so on. This is where objects are stored.
    The problem is we have no direct access to the heap. Think of it as a restricted
    access part of the warehouse. You can't actually go there but you can *refer*
    to what is stored there. Let's look at what exactly a reference variable is.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 把堆想象成同一个仓库的另一个区域。堆有大量的地板空间用于奇形怪状的对象，用于较小对象的货架，有很多长排有较小尺寸的小隔间等等。这就是对象存储的地方。问题是我们无法直接访问堆。把它想象成仓库的受限区域。你实际上不能去那里，但你可以*引用*那里存储的东西。让我们看看引用变量到底是什么。
- en: It is a variable that we refer to and use via a reference. A reference can be
    loosely but usefully defined as an address or location. The reference (address
    or location) of the object is on the Stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过引用引用和使用的变量。引用可以宽松但有用地定义为地址或位置。对象的引用（地址或位置）在栈上。
- en: So, when we use the dot operator, we are asking Android to perform a task *at*
    a specific location, a location that is stored in the reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用点运算符时，我们要求Android在一个特定的位置执行任务，这个位置存储在引用中。
- en: Why would we ever want a system like this? Just give me my objects on the Stack
    already. Here is why.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要一个这样的系统？直接把我的对象放在栈上。原因如下。
- en: A quick break to throw out the trash
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速休息一下，扔掉垃圾
- en: This is what the whole stack and heap thing does for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个栈和堆的作用。
- en: As we know, the ART system keeps track of all our objects for us and stores
    them in a devoted area of our warehouse called the heap. Regularly, while our
    app is running, ART will scan the stack, the regular racks of our warehouse, and
    match up references to objects that are on the heap. And any objects it finds
    without a matching reference, it destroys. Or in Java terminology, it **garbage
    collects**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，ART系统为我们跟踪所有的对象，并将它们存储在我们仓库的一个专门区域，称为堆。在我们的应用程序运行时，ART会定期扫描栈，我们仓库的常规货架，并匹配指向堆上对象的引用。它发现没有匹配引用的对象，就会销毁它。或者用Java术语来说，它进行**垃圾回收**。
- en: Think of a very discerning refuse vehicle driving through the middle of our
    heap, scanning objects to match up to references (on the stack). No reference?
    You're garbage now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一辆非常挑剔的垃圾车驶过我们堆的中间，扫描对象以匹配引用（在栈上）。没有引用？你现在是垃圾。
- en: If an object has no reference variable, we can't possibly do anything with it
    anyway because we have no way to access it/refer to it. This system of garbage
    collection helps our apps run more efficiently by freeing up unused memory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象没有引用变量，我们无法做任何事情，因为我们无法访问它。垃圾收集系统通过释放未使用的内存帮助我们的应用程序更有效地运行。
- en: If this task was left to us, our apps would be much more complicated to code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个任务留给我们，我们的应用程序将更加复杂。
- en: So, variables declared in a method are local, on the stack, and only visible
    within the method they were declared in. A member variable (in an object) is on
    the heap and can be referenced from anywhere there is a reference to it and the
    access specification (encapsulation) allows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在方法中声明的变量是局部变量，位于堆栈上，并且仅在它们声明的方法内部可见。成员变量（在对象中）位于堆上，并且可以在任何有引用到它的地方引用它，并且访问规范（封装）允许。
- en: Seven facts about the stack and the heap
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于堆栈和堆的七个事实
- en: 'Let''s take a quick look at what we learned about the stack and the heap:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们对堆栈和堆的了解：
- en: Local variables and methods are on the stack and local variables are local to
    the specific method within which they were declared.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量和方法位于堆栈上，局部变量局限于它们声明的特定方法。
- en: Instance/class variables are on the heap (with their objects) but the reference
    *to* the object (its address), is a local variable on the stack.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例/类变量在堆上（与它们的对象一起），但对对象的引用（其地址）是堆栈上的局部变量。
- en: We control what goes on the stack. We can use the objects on the heap but only
    by referencing them.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们控制堆栈上的内容。我们可以使用堆上的对象，但只能通过引用它们。
- en: The heap is kept clear and up to date by the garbage collector.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集器通过清除和更新堆来保持堆的清晰。
- en: You don't delete objects but the ART system sends the garbage collector when
    it thinks it is appropriate. An object is garbage collected when there is no longer
    a valid reference to it. So, when a reference variable, either local or instance,
    is removed from the stack, then its related object becomes viable for garbage
    collection. And when the ART system decides the time is right (usually very promptly),
    it will free up the RAM memory to avoid running out.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您不会删除对象，但ART系统在认为适当时会发送垃圾收集器。当不再有有效引用时，对象将被垃圾收集。因此，当引用变量（局部或实例）从堆栈中移除时，其相关对象变得可供垃圾收集。当ART系统决定时机合适（通常非常迅速），它将释放RAM内存以避免耗尽。
- en: If we try to reference an object that doesn't exist, we will get a **NullPointerException**
    and the app will crash.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试引用一个不存在的对象，我们将得到一个**NullPointerException**，应用程序将崩溃。
- en: Let's move on and see exactly what this information buys us in terms of taking
    control of our UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看这些信息对我们控制UI有什么好处。
- en: So how does this heap thing help me?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么这个堆的东西如何帮助我呢？
- en: 'Any UI element that has its `id` attribute set in the XML layout can have its
    reference retrieved from the heap using the `findViewById` method, which is part
    of the Activity/ `AppCompatActivity` class. As it is part of the class that we
    extend in all our apps, we have access to it, as this code shows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML布局中设置了`id`属性的任何UI元素都可以使用`findViewById`方法从堆中检索到其引用，该方法是Activity/`AppCompatActivity`类的一部分。由于它是我们在所有应用程序中扩展的类的一部分，因此我们可以访问它，正如这段代码所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code assumes that within the XML layout there is a `Button` widget
    with its `id` attribute set to `myButton`. The `myButton` object now directly
    refers to the widget in the XML layout with the `id` attribute set to `myButton`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设在XML布局中有一个`Button`小部件，其`id`属性设置为`myButton`。`myButton`对象现在直接引用XML布局中`id`属性设置为`myButton`的小部件。
- en: Note that the `findViewById` method is also polymorphic and any class that extends
    the `View` class can be retrieved from the UI and it just so happened that *everything*
    in the UI palette extends `View`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`findViewById`方法也是多态的，任何扩展`View`类的类都可以从UI中检索，并且碰巧*UI*面板中的所有内容都扩展了`View`。
- en: 'The sharp-minded reader might notice that we don''t use a cast to make sure
    we are getting a `Button` object (as opposed to a `TextView` or some other `View`
    descendant) as we did when retrieving an `Elephant` instance descended from an
    abstract `Animal`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能会注意到，我们在检索从抽象`Animal`继承的`Elephant`实例时，不使用强制转换来确保我们得到一个`Button`对象（而不是`TextView`或其他`View`后代）：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The reason for this is that the `View` class uses Java''s **generics automatic
    type inference**. This is an advanced topic that we won''t be covering in this
    book, but it means that the cast is automatic, and we don''t need to write more
    lengthy code like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`View`类使用了Java的**泛型自动类型推断**。这是一个我们不会在本书中涵盖的高级主题，但它意味着强制转换是自动的，我们不需要编写更多的冗长代码，如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This ability to grab a reference to anything in the UI is exciting because
    it means we can start using all the methods that these objects have. Here are
    some examples of the methods we can use for `Button` objects:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取UI中任何东西的引用的能力令人兴奋，因为这意味着我们可以开始使用这些对象具有的所有方法。以下是一些我们可以用于`Button`对象的方法的示例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `Button` class alone has around 50 methods!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`类本身有大约50个方法！'
- en: If you think, after 11 chapters, we are finally going to start doing some neat
    stuff with Android, you are right!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为在经过11章之后，我们终于要开始在Android上做一些有趣的事情，那么您是对的！
- en: Using buttons and TextView widgets from our layout
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的布局中使用按钮和TextView小部件
- en: To follow along with this project, create a new Android Studio project, call
    it `Java Meet UI`, choose the Empty Activity template, and leave all the other
    options at their defaults. As usual, you can find the Java code and the XML layout
    code in the [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)`/Java Meet
    UI` folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个项目，创建一个新的Android Studio项目，称之为`Java Meet UI`，选择空活动模板，并将所有其他选项保持默认。通常情况下，您可以在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)`/Java
    Meet UI`文件夹中找到Java代码和XML布局代码。
- en: 'First, let''s build a simple UI by following these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照以下步骤构建一个简单的UI：
- en: In the editor window of Android Studio, switch to `activity_main.xml` and make
    sure you are on the **Design** tab.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio的编辑窗口中，切换到`activity_main.xml`，确保你在**设计**选项卡上。
- en: Delete the autogenerated **TextView**, the one that reads "Hello world!".
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除自动生成的**TextView**，即那个写着“Hello world!”的。
- en: Add a **TextView** widget at the top center of the layout.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局的顶部中心添加一个**TextView**小部件。
- en: Set its `0`, its `40sp`. Pay careful attention to the case of the `id` property's
    value. It has an uppercase `V`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为`0`，`40sp`。注意`id`属性值的大小写。它有一个大写的`V`。
- en: Now drag and drop six buttons on the layout so it looks as close as possible
    to this next screenshot. The exact layout isn't important:![Figure 12.1 – Layout
    setup
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在布局上拖放六个按钮，使其尽可能接近下一个屏幕截图。确切的布局并不重要：![图12.1 - 布局设置
- en: '](img/Figure_12.1_B16773.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16773.jpg)'
- en: Figure 12.1 – Layout setup
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 布局设置
- en: When the layout is how you want it, click the **Infer Constraints** button to
    constrain all the UI items.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当布局设置好后，点击**推断约束**按钮来约束所有的UI项目。
- en: Edit the properties of each button in turn (left to right, then top to bottom)
    and set the `text` and `id` properties as shown in the next table. The image that
    follows the table should make it clear which button has which values.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次编辑每个按钮的属性（从左到右，从上到下），并按照下表中所示设置`text`和`id`属性。表后面的图片应该清楚地显示了哪个按钮有哪些值。
- en: '![](img/01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01.jpg)'
- en: 'When you''re done, your layout should look like the next screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的布局应该看起来像下一个屏幕截图：
- en: '![Figure 12.2 – Final layout'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 - 最终布局'
- en: '](img/Figure_12.2_B16773.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B16773.jpg)'
- en: Figure 12.2 – Final layout
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 最终布局
- en: The precise position and text on the buttons are not very important but the
    values given to the `id` properties must be the same as those in the table. The
    reason for this is we will be using these IDs to get a reference to the buttons
    and the `TextView` in this layout, from our Java code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮上的精确位置和文本并不是很重要，但是`id`属性的值必须与表中的值相同。原因是我们将使用这些ID来从我们的Java代码中获取对这个布局中的按钮和`TextView`的引用。
- en: Switch to the **MainActivity.java** tab in the editor and we will write the
    code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到编辑器中的**MainActivity.java**选项卡，我们将编写代码。
- en: 'Amend this line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这一行：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You will need to import the `View` class. Be sure to do this before continuing
    with the next step or you will get confusing results.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入`View`类。确保在继续下一步之前做到这一点，否则你会得到混乱的结果。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the entire line we just amended is underlined in red showing an
    error. Now, because we have made `MainActivity` into an `OnClickListener` by adding
    it as an interface, we must implement the abstract method required by `OnClickListener`.
    The method is called `onClick`. When we add the `onClick` method, the error will
    be gone.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们刚刚修改的整行都被下划线标出了错误。现在，因为我们已经将`MainActivity`转换为`OnClickListener`，通过将其添加为一个接口，我们必须实现`OnClickListener`所需的抽象方法。这个方法叫做`onClick`。当我们添加`onClick`方法时，错误就会消失。
- en: We can get Android Studio to add it for us by left-clicking anywhere on the
    line with an error and then using the keyboard combination *Alt* + *Enter*. Left-click
    the **Implement methods** option as shown in the next screenshot.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让Android Studio为我们添加它，方法是在带有错误的行的任何地方左键单击，然后使用键盘组合*Alt* + *Enter*。左键单击**实现方法**选项，如下一个屏幕截图所示。
- en: '![Figure 12.3 – Implement methods'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - 实现方法'
- en: '](img/Figure_12.3_B16773.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B16773.jpg)'
- en: Figure 12.3 – Implement methods
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 实现方法
- en: Now, left-click `onClick` method. The error is gone, and we can carry on adding
    code. We also have an empty `onClick` method and we will soon see what we will
    do with that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，左键单击`onClick`方法。错误已经消失，我们可以继续添加代码。我们还有一个空的`onClick`方法，很快我们将看到我们将如何处理它。
- en: Now we will declare an `int` type variable called `value` and initialize it
    to `0`. We will also declare six `Button` objects and a `TextView` object. We
    will give them the exact same Java variable names we gave the `id` property values
    in our UI layout. This name association is not needed but it is useful to keep
    track of which `Button` in our Java code will be holding a reference to which
    `Button` from our XML UI layout.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明一个名为`value`的`int`类型变量，并将其初始化为`0`。我们还将声明六个`Button`对象和一个`TextView`对象。我们将给它们与我们UI布局中的`id`属性值完全相同的Java变量名。这种名称关联并不是必需的，但它对于跟踪我们的Java代码中的哪个`Button`将持有对我们的XML
    UI布局中的哪个`Button`的引用是有用的。
- en: Furthermore, we are declaring them all with the `private` access specification
    because we know they will not be needed outside of this class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将它们全部声明为`private`访问权限，因为我们知道它们在这个类之外不会被需要。
- en: Before you go ahead and type the code, note that all these variables are members
    of the `MainActivity` class. This means we enter all the code shown next, immediately
    after the class declaration (which we amended in the previous step).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续输入代码之前，请注意所有这些变量都是`MainActivity`类的成员。这意味着我们在上一步修改的类声明之后立即输入所有下面显示的代码。
- en: Making all these variables into members/fields means they have a class scope
    and we can access them from anywhere within the `MainActivity` class. This will
    be essential for this project because we will need to use them in the `onCreate`
    method and in our new `onClick` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些变量都变成成员/字段意味着它们具有类范围，我们可以在`MainActivity`类的任何地方访问它们。这对这个项目非常重要，因为我们需要在`onCreate`方法和我们的新`onClick`方法中使用它们。
- en: 'Enter this next code that we have just discussed, after the opening curly brace
    `{` of the `MainActivity` class and before the `onCreate` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的开头大括号`{`后和`onCreate`方法前输入我们刚刚讨论过的下面的代码：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to use the *ALT* + *Enter* keyboard combination to import new classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用*ALT* + *Enter*键盘组合来导入新的类。
- en: '`import android.widget.Button;`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.Button;`'
- en: '`import android.widget.TextView;`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.widget.TextView;`'
- en: Next, we want to prepare all our variables ready for action. The best place
    for this to happen is in the `onCreate` method because we know that will be called
    by Android just before the app is shown to the user. This code uses the `findViewById`
    method to associate each of our Java objects with an item from our UI layout.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要准备好所有的变量以准备行动。这样做的最佳位置是`onCreate`方法，因为我们知道这将在应用程序显示给用户之前由Android调用。这段代码使用`findViewById`方法将我们的每个Java对象与UI布局中的一个项目关联起来。
- en: It does so by returning a reference to the object associated with the UI widget
    on the heap. It "knows" which one we are after because we use the `id` attribute
    value as an argument. For example, `...(R.id.btnAdd)` will return the `Button`
    widget with the text **ADD** that we created in our layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过返回与堆上的UI小部件关联的对象的引用来实现。它“知道”我们要找的是哪一个，因为我们使用`id`属性值作为参数。例如，`...(R.id.btnAdd)`将返回我们在布局中创建的文本为**ADD**的`Button`小部件。
- en: 'Enter the following code, just after the call to `setContentView` in the `onCreate`
    method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的`setContentView`调用后，输入以下代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have a reference to all our `Button` widgets and our `TextView` widget
    so now we can start using their methods. In the code that follows, we use the
    `setOnClickListener` method on each of the `Button` references to make Android
    pass any clicks from the user onto our `onClick` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了对所有`Button`小部件和`TextView`小部件的引用，所以现在我们可以开始使用它们的方法。在接下来的代码中，我们使用`setOnClickListener`方法在每个`Button`引用上，使Android将用户的任何点击传递到我们的`onClick`方法。
- en: This works because when we implemented the `View.OnClickListener` interface,
    our `MainActivity` class effectively *became* an `OnClickListener`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是因为当我们实现`View.OnClickListener`接口时，我们的`MainActivity`类实际上*成为了*一个`OnClickListener`。
- en: So, all we have to do is call `setOnClickListener` on each button in turn. As
    a reminder, the `this` argument is a reference to `MainActivity`. So, the method
    call says, "Hey Android, I want an `OnClickListener` and I want it to be the `MainActivity`
    class."
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需依次在每个按钮上调用`setOnClickListener`。作为提醒，`this`参数是对`MainActivity`的引用。因此，方法调用表示：“嘿，Android，我想要一个`OnClickListener`，我希望它是`MainActivity`类。”
- en: Android now knows which class to call `onClick` on. This next code wouldn't
    work if we hadn't implemented the interface first. Also, we must set up these
    listeners before the Activity starts, which is why we do it in `onCreate.`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Android知道要在哪个类上调用`onClick`。如果我们没有先实现接口，下面的代码将无法工作。此外，我们必须在Activity启动之前设置这些监听器，这就是为什么我们在`onCreate`中这样做的原因。
- en: Soon, we will add code to the `onClick` method to handle what happens when a
    button is clicked and we will see how we differentiate between all the different
    buttons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将添加代码到`onClick`方法中，以处理当按钮被点击时发生的情况，并且我们将看到如何区分所有不同的按钮。
- en: 'Add this code after the previous code, inside the `onCreate` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码之后，在`onCreate`方法内添加以下代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now scroll down to the `onClick` method that Android Studio added for us after
    we implemented the `OnClickListener` interface. Add the `float size;` variable
    declaration and an empty `switch` block inside it so it looks like this next code.
    The new code to add is highlighted:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在滚动到Android Studio在我们实现`OnClickListener`接口后为我们添加的`onClick`方法。在其中添加`float size;`变量声明和一个空的`switch`块，使其看起来像下面的代码。要添加的新代码已经突出显示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that `switch` will check for a `case` to match the condition inside
    the `switch` statement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`switch`将检查是否有一个`case`与`switch`语句内的条件匹配。
- en: 'In the previous code, the `switch` condition is `view.getId()`. Let''s step
    through and explain this. The `view` variable is a reference to an object of type
    `View`, which was passed into the `onClick` method by Android:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码中，`switch`条件是`view.getId()`。让我们逐步解释一下。`view`变量是一个指向`View`类型对象的引用，它是由Android通过`onClick`方法传递的：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`View` is the parent class for `Button`, `TextView`, and more. So, perhaps
    as we might expect, calling `view.getId()` will return the `id` attribute of the
    UI widget that has been clicked and triggered the call to `onClick` in the first
    place.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`是`Button`、`TextView`等的父类。因此，或许正如我们所期望的那样，调用`view.getId()`将返回被点击并触发对`onClick`的调用的UI小部件的`id`属性。'
- en: All we need to do then is provide a `case` statement (and appropriate action)
    for each of the `Button` references we want to respond to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需要为我们想要响应的每个`Button`引用提供一个`case`语句（和适当的操作）。
- en: 'The next code we will see is the first three `case` statements. They handle
    `R.id.btnAdd`, `R.id.btnTake`, and `R.id.btnReset` cases:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到的是前三个`case`语句。它们处理`R.id.btnAdd`、`R.id.btnTake`和`R.id.btnReset`情况：
- en: The code in the `R.id.btnAdd` case simply increments the `value` variable, then
    it does something new.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R.id.btnAdd`情况下的代码简单地增加了`value`变量，然后做了一些新的事情。'
- en: 'It calls the `setText` method on the `txtValue` object. Here is the argument:
    `(""+ value)`. This argument uses an empty string and adds (concatenates) whatever
    value is stored in `value` to it. This has the effect of causing our `TextView
    txtValue` to display whatever value is stored in `value`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用`txtValue`对象上的`setText`方法。这是参数：`(""+ value)`。这个参数使用一个空字符串，并将存储在`value`中的任何值添加（连接）到其中。这会导致我们的`TextView
    txtValue`显示存储在`value`中的任何值。
- en: The `R.id.btnTake`) does exactly the same, only subtracts one from `value` instead
    of adding one.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R.id.btnTake`)做的事情完全相同，只是从`value`中减去1而不是加1。'
- en: The third case statement handles the `value` to zero and again updates the `text`
    attribute of `txtValue`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个`case`语句处理将`value`归零，并再次更新`txtValue`的`text`属性。
- en: Then, at the end of each `case`, there is a `break` statement. At this point,
    the `switch` block is exited, the `onClick` method returns, and life goes back
    to normal – until the user's next click.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个`case`的末尾，都有一个`break`语句。在这一点上，`switch`块被退出，`onClick`方法返回，生活恢复正常-直到用户的下一次点击。
- en: 'Enter this code that we have just discussed inside the `switch` block after
    the opening curly brace `{`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在左花括号`{`后的`switch`块中输入我们刚讨论过的代码：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next two `case` statements handle the `R.id.btnGrow` and `R.id.btnShrink`.
    What is new and more interesting are the two new methods that are used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个`case`语句处理`R.id.btnGrow`和`R.id.btnShrink`。新的更有趣的是使用的两种新方法。
- en: The `getTextScaleX` method returns the horizontal scale of the text within the
    object it is used on. We can see that the object it is used on is our `TextView
    txtValue`. The `size =` at the start of the line of code assigns that returned
    value to our `float` variable `size`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTextScaleX`方法返回其所用对象中文本的水平比例。我们可以看到它所用的对象是我们的`TextView txtValue`。代码行开头的`size
    =`将返回的值赋给我们的`float`变量`size`。'
- en: The next line of code in each `case` statement changes the horizontal scale
    of the text using `setTextScaleX`. When the `size + 1`, and when the `size - 1`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`case`语句的下一行代码改变了文本的水平比例，使用了`setTextScaleX`。当`size + 1`时，当`size - 1`时。
- en: The overall effect is to allow these two buttons to grow and shrink the text
    in the `txtValue` widget by a scale of 1 on each click.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总体效果是允许这两个按钮通过每次点击来增大或缩小`txtValue`小部件中的文本比例1。
- en: 'Enter the next two `case` statements that we have just discussed below the
    previous code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输入我们刚讨论过的下面的下一个两个`case`语句：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our final `case` statement, which we will code next, we have an `if-else`
    block. The condition takes a little bit of explaining so let''s have sight of
    it in advance:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下面要编写的最后一个`case`语句中，我们有一个`if-else`块。条件需要稍微解释一下，所以让我们提前看一下：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The condition to be evaluated is `txtValue.getVisibility() == View.VISIBLE`.
    The first part of that condition before the `==` operator returns the `visibility`
    attribute of our `txtValue TextView`. The return value will be one of three possible
    constant values as defined in the `View` class. They are `View.VISIBLE`, `View.INVISIBLE`,
    and `View.GONE`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估的条件是`txtValue.getVisibility() == View.VISIBLE`。在`==`运算符之前的条件的第一部分返回我们的`txtValue
    TextView`的`visibility`属性。返回值将是`View`类中定义的三个可能的常量值之一。它们是`View.VISIBLE`，`View.INVISIBLE`和`View.GONE`。
- en: If `TextView` is visible to the user on the UI, the method returns `View.VISIBLE`,
    the condition is evaluated as `true`, and the `if` block is executed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`TextView`在UI上对用户可见，则该方法返回`View.VISIBLE`，条件将被评估为`true`，并且`if`块将被执行。
- en: Inside the `if` block, we use the `setVisibility` method on the `txtValue` object
    and make it invisible to the user with the `View.INVISIBLE` argument.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内，我们在`txtValue`对象上使用`setVisibility`方法，并使用`View.INVISIBLE`参数使其对用户不可见。
- en: In addition to this, we change the text on the `btnHide` widget to `setText`
    method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们将`btnHide`小部件上的文本更改为`setText`方法。
- en: After the `if` block has executed, `txtValue` is invisible and we have a button
    on our UI that says `if` statement will be false and the `else` block will execute.
    In the `else` block, we reverse the situation. We set `txtValue` back to `View.VISIBLE`
    and the `text` property on `btnHide` back to **HIDE**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块执行完毕后，`txtValue`是不可见的，我们的UI上有一个按钮显示为`if`语句将为false，`else`块将执行。在`else`块中，我们将情况反转。我们将`txtValue`设置回`View.VISIBLE`，并将`btnHide`上的`text`属性设置为**HIDE**。
- en: 'If this is in any way unclear, just enter the code, run the app, and revisit
    this last code and explanation once you have seen it in action:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这有任何不清楚的地方，只需输入代码，运行应用程序，然后在看到它实际运行后再回顾这段代码和解释：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have the UI and the code in place, so it is time to run the app and try out
    all the buttons.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了UI和代码，所以现在是时候运行应用程序，尝试所有的按钮了。
- en: Running the app
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Run the app in the usual way. Notice that the `value` by one in either direction
    and then display the result in the `TextView` widget. In this next screenshot,
    I have clicked the **ADD** button three times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式运行应用程序。注意，`value`向任一方向增加或减少1，然后在`TextView`小部件中显示结果。在下一个截图中，我点击了**ADD**按钮三次。
- en: '![Figure 12.4  –  Add button example'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4  -  添加按钮示例'
- en: '](img/Figure_12.4_B16773.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.4_B16773.jpg)'
- en: Figure 12.4 – Add button example
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 添加按钮示例
- en: Notice that the `value` variable to 0 and displays it on the `TextView` widget.
    In this next screenshot, I have clicked the **GROW** button eight times.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将`value`变量设置为0，并在`TextView`小部件上显示它。在下一个截图中，我点击了**GROW**按钮八次。
- en: '![Figure 12.5 – Grow button example'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 - 增长按钮示例'
- en: '](img/Figure_12.5_B16773.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.5_B16773.jpg)'
- en: Figure 12.5 – Grow button example
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 增长按钮示例
- en: Finally, the `TextView` but changes its own text to `TextView` if tapped again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TextView`小部件在再次点击时将其自身文本更改为`TextView`。
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: I will not bother you by showing you an image of something that is hidden. Be
    sure to try the app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会打扰你展示一张隐藏的图片。一定要尝试这个应用程序。
- en: Notice that there was no need for the `Log` or `Toast` classes in this app as
    we are finally manipulating the UI using our Java code. Let's dig even deeper
    into manipulating the UI with our code by exploring inner and anonymous classes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个应用程序中不需要`Log`或`Toast`类，因为我们最终是使用我们的Java代码操纵UI。让我们通过探索内部和匿名类来更深入地使用我们的代码操纵UI。
- en: Inner and anonymous classes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部和匿名类
- en: Before we go ahead to the next chapter and build apps with loads of different
    widgets that will put into practice and reinforce everything we have learned in
    this chapter, we will have a very brief introduction to **Anonymous** and **Inner**
    classes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一章并构建具有大量不同小部件的应用程序之前，这些小部件将实践和强化我们在本章学到的一切，我们将对**匿名**和**内部**类进行非常简要的介绍。
- en: When we implemented our basic classes demo app in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we declared and implemented the class in a separate
    file to our `MainActivity` class. That file had to have the same name as the class.
    This is the way to create a regular class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*中实现了我们的基本类演示应用程序，面向对象编程时，我们在一个单独的文件中声明和实现了该类，该文件必须与我们的`MainActivity`类具有相同的名称。这是创建常规类的方法。
- en: We can also declare and implement classes within a class. Other than *how* we
    do this, the only question remaining, of course, is why would we do this?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在一个类中声明和实现其他类。除了*如何*我们这样做之外，当然，唯一剩下的问题是为什么我们要这样做？
- en: When we implement an inner class, the inner class can access the member variables
    of the enclosing class and the enclosing class can access the members of the inner
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现内部类时，内部类可以访问封闭类的成员变量，封闭类也可以访问内部类的成员。
- en: This often makes the structure of our code more straightforward. So inner classes
    are sometimes the way to go.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常使我们的代码结构更加直观。因此，内部类有时是解决问题的方法。
- en: In addition, we can also declare and implement an entire class within a method
    of one of our classes. When we do so, we use a slightly different syntax and do
    not use a name with the class. This is an **anonymous** class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在我们的类的方法中声明和实现一个完整的类。当我们这样做时，我们使用稍微不同的语法，并且不使用类名。这就是**匿名**类。
- en: We will see both inner and anonymous classes in action throughout the rest of
    the book and we will thoroughly discuss them when we use them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将看到内部类和匿名类的实际应用，并在使用它们时进行彻底讨论。
- en: Frequently asked questions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: I don't get it all and actually I have more questions now than I had at the
    start of the chapter. What should I do?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我并没有完全理解，实际上我现在有比章节开始时更多的问题。我该怎么办？
- en: You know enough about OOP to make considerable progress with Android and any
    other type of Java programming. If you are desperate to know more about OOP right
    now, there are plenty of books that discuss nothing but OOP. However, practice
    and familiarity with the syntax will go a long way to achieving the same thing
    and will be more fun. This is exactly what we will do for the rest of the book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了足够的面向对象编程知识，可以在Android和其他类型的Java编程中取得相当大的进步。如果你现在迫切想了解更多关于面向对象编程的知识，有很多书籍专门讨论面向对象编程。然而，实践和熟悉语法将有助于达到相同的效果，并且更有趣。这正是我们将在本书的其余部分做的事情。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finally had some real interaction between our code and our
    UI. It turns out that every time we add a widget to our UI, we are adding an instance
    of a class that we can access with a reference in our Java code. All these objects
    are stored in a separate area of memory called the heap – along with any classes
    of our own.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于让我们的代码和UI进行了一些真正的交互。事实证明，每当我们向我们的UI添加一个小部件时，我们都在添加一个我们可以在Java代码中引用的类的实例。所有这些对象都存储在内存的一个单独区域中，称为堆
    - 以及我们自己的任何类。
- en: We are now in a position where we can learn about and do cool things with some
    of the more interesting widgets. We will look at loads of them in the next chapter,
    and then keep introducing further new widgets throughout the rest of the book
    as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以学习并使用一些更有趣的小部件。我们将在下一章中看到大量的小部件，然后在本书的其余部分继续介绍更多新的小部件。
