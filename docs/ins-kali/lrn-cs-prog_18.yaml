- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节1
- en: The first version of the C# language, 1.0, was released in 2002, bundled with
    .NET Framework 1.0 and Visual Studio .NET 2002\. The current version of the language,
    at the time of writing this book, is C# 8.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#语言的第一个版本1.0于2002年发布，与.NET Framework 1.0和Visual Studio .NET 2002捆绑在一起。在撰写本书时，该语言的当前版本是C#
    8。
- en: 'The CLI is a specification that describes how a runtime environment can be
    used on different computer platforms without being rewritten for specific architectures.
    The CLI describes four major components: The **Common Type System** (**CTS**),
    the **Common Language Specification** (**CLS**), the **Virtual Execution System**
    (**VES**), and the metadata of a program''s structure and content.'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CLI是一种规范，描述了如何在不为特定架构重写的情况下，在不同的计算机平台上使用运行时环境。CLI描述了四个主要组件：**公共类型系统**（**CTS**）、**公共语言规范**（**CLS**）、**虚拟执行系统**（**VES**）以及程序结构和内容的元数据。
- en: The CIL is a platform-neutral intermediate language that represents the intermediate
    language binary instruction set defined by the CLI. When you compile your program's
    source code, the compiler translates it into the CIL bytecode and produces a CLI
    assembly. When the CLI assembly is executed, the bytecode is passed through the
    Just-In-Time compiler to generate native code, which is then executed by the computer's
    processor.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CIL是一个平台中立的中间语言，代表了CLI定义的中间语言二进制指令集。当您编译程序的源代码时，编译器将其转换为CIL字节码，并生成CLI程序集。当执行CLI程序集时，字节码通过即时编译器传递，以生成本机代码，然后由计算机处理器执行。
- en: To view the content of an assembly you must use a disassembler. Examples of
    disassemblers are ildasm.exe, distributed with .NET Framework, or ILSpy, an open
    source .NET assembly browser and decompiler.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看程序集的内容，您必须使用反汇编器。反汇编器的示例包括与.NET Framework一起分发的ildasm.exe，或者ILSpy，一个开源的.NET程序集浏览器和反编译器。
- en: The Common Language Runtime is. NET Framework's implementation of the VES. The
    CLR provides services such as memory management, type safety, garbage collection,
    exception handling, thread management, and others.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共语言运行时是.NET Framework对VES的实现。CLR提供诸如内存管理、类型安全、垃圾回收、异常处理、线程管理等服务。
- en: The BCL is a component of the standard libraries that provides types to represent
    the CLI built-in types, simple file access, custom attributes, string handling,
    formatting, collections, streams, and others.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BCL是标准库的一个组件，提供了用于表示CLI内置类型、简单文件访问、自定义属性、字符串处理、格式化、集合、流等类型。
- en: The current major .NET frameworks are .NET Framework, .NET Core, and Xamarin.
    Because Microsoft plans to make .NET Core the one framework to use for building
    applications for desktop, server, web, cloud, and mobile; .NET Framework is put
    on maintenance mode and will only include security updates.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前的主要.NET框架是.NET Framework、.NET Core和Xamarin。由于微软计划使.NET Core成为用于构建桌面、服务器、Web、云和移动应用程序的唯一框架；.NET
    Framework被放置在维护模式，并且只包括安全更新。
- en: 'Assemblies are the basic unit for deployment, versioning, and security. They
    come in two forms: executables (`.exe`) and dynamic-link libraries (`.dll`). An
    assembly is a collection of types, resources, and meta-information that forms
    a logical unit of functionality. The identity of an assembly is composed of the
    name, version, culture, and a public key token.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序集是部署、版本控制和安全性的基本单位。它们有两种形式：可执行文件（`.exe`）和动态链接库（`.dll`）。程序集是类型、资源和元信息的集合，形成一个逻辑功能单元。程序集的标识由名称、版本、文化和公钥令牌组成。
- en: The GAC is a machine-wide code cache that enables the sharing of assemblies
    between applications. Its default location is `%windir%\Microsoft.NET\assembly`.
    The Runtime Package Store is the equivalent for .NET Core applications. It enables
    faster deployment and lower disk space requirements. Typically, this store is
    available at `/usr/local/share/dotnet/store` on macOS and Linux and `C:/Program
    Files/dotnet/store` on Windows.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GAC是一个机器范围的代码缓存，它可以在应用程序之间共享程序集。其默认位置是`%windir%\Microsoft.NET\assembly`。Runtime
    Package Store是.NET Core应用程序的等效物。它可以实现更快的部署和更低的磁盘空间要求。通常，该存储在macOS和Linux上可用于`/usr/local/share/dotnet/store`，在Windows上可用于`C:/Program
    Files/dotnet/store`。
- en: The minimum a C# program must contain in order to compile and execute is a class
    that contains a static method called `Main()`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了编译和执行，C#程序必须包含一个包含名为`Main()`的静态方法的类。
- en: Chapter 2
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节2
- en: The built-in integral types in C# are `byte`, `sbyte`, `ushort`, `short`, `uint`,
    `int`, `ulong`, and `long`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中的内置整数类型是`byte`、`sbyte`、`ushort`、`short`、`uint`、`int`、`ulong`和`long`。
- en: The `float` and `double` types represent numbers using the inverse powers of
    2 for the fractional part. Therefore, they cannot represent exactly numbers such
    as 1.23 or 19.99, but only an approximation of them. Although `double` has 15
    digits of precision, compared to `float,` which has only 7; precision loss accumulates
    when performing repeated calculations. The `decimal` type uses a decimal representation
    of real numbers, which is much slower to compute, but provides better precision.
    The `decimal` type has 28 digits of precision and is suitable for categories of
    applications, such as financial applications, where this is key.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`float`和`double`类型使用2的倒数来表示数字的小数部分。因此，它们无法准确表示诸如1.23或19.99之类的数字，而只能近似表示它们。尽管`double`具有15位精度，而`float`只有7位；但在执行重复计算时，精度损失会累积。`decimal`类型使用实数的十进制表示，计算速度要慢得多，但提供更好的精度。`decimal`类型具有28位精度，适用于金融应用等类别的应用程序，这是关键。'
- en: Strings can be concatenated using the `+` operator. Apart from concatenation,
    you can compose strings using the `String.Format()` static method, or with string
    interpolation, which is a syntactic shortcut for this method.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串可以使用`+`运算符进行连接。除了连接，您还可以使用`String.Format()`静态方法或字符串插值来组成字符串，这是该方法的一种语法快捷方式。
- en: Some characters have a special meaning within a string. These are called escape
    sequences and are prefixed with a backlash (`\`). Examples include single quotes
    (`\'`), double quotes (`\"`), newline characters (`\n`), and backslashes (`\\`).
    Verbatim strings are strings that are prefixed with the `@` token. For verbatim
    strings, the compiler does not interpret escape sequences. This makes it easier
    to write multi-line texts or file paths, for instance.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些字符在字符串中具有特殊含义。这些称为转义序列，并以反斜杠（`\`）为前缀。例如单引号（`\'`）、双引号（`\"`）、换行字符（`\n`）和反斜杠（`\\`）。逐字字符串是以`@`标记为前缀的字符串。对于逐字字符串，编译器不解释转义序列。这使得编写多行文本或文件路径变得更容易。
- en: Implicitly typed variables are declared using the `var` keyword instead of an
    actual type and must be initialized during declaration. The compiler infers the
    actual type from the value or expression used for their initialization.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐式类型变量使用`var`关键字声明，而不是实际类型，并且必须在声明时初始化。编译器从用于初始化它们的值或表达式中推断出实际类型。
- en: Value types and reference types are the two main categories of types in C# and
    .NET. A variable of a value type stores the value directly. A variable of a reference
    type stores a reference to (the address of) a memory location containing the actual
    object. Value types have value semantics (in simple terms, when you copy an object,
    its value is copied), and reference types have value semantics (when you copy
    an object, its reference is copied). Typically, value types are stored on a stack
    and reference types on the heap, but this is an implementation detail and not
    a characteristic of the types.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值类型和引用类型是C#和.NET中的两种主要类型类别。值类型的变量直接存储值。引用类型的变量存储指向（地址）包含实际对象的内存位置的引用。值类型具有值语义（简单来说，当你复制一个对象时，它的值被复制），引用类型具有值语义（当你复制一个对象时，它的引用被复制）。通常，值类型存储在堆栈上，引用类型存储在堆上，但这是一个实现细节，而不是类型的特征。
- en: Boxing is the process of storing a value type inside an `object`, and unboxing
    is the opposite operation of converting the value of an `object` to a value type.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装箱是将值类型存储在`object`中的过程，拆箱是将`object`的值转换为值类型的相反操作。
- en: A nullable type is an instance of `System.Nullable<T>`, a generic value type
    that can represent the values of an underlying `T` type that can only be a value
    type, as well as an additional null value. A nullable integer variable can be
    declared either as `Nullable<int>` or `int?`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可空类型是`System.Nullable<T>`的实例，它是一个可以表示基础`T`类型的值的泛型值类型，该类型只能是值类型，以及额外的空值。可空整数变量可以声明为`Nullable<int>`或`int?`。
- en: There are three types of arrays in C#. The first type is one-dimensional arrays,
    which are arrays of a single dimension. An example is `int[6]`, which is an array
    of 6 integers. The second type is multi-dimensional arrays, which are arrays of
    two or more dimensions, up to a maximum of 32\. An example is `int[2,3]`, which
    is an array of integers with 2 lines and 3 columns. The third type is jagged arrays,
    which are arrays of arrays. A jagged array is a one-dimensional array whose elements
    are other arrays, and each can be of another dimension.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中有三种类型的数组。第一种类型是一维数组，它是单维数组。例如`int[6]`，它是一个包含6个整数的数组。第二种类型是多维数组，它是两个或更多维度的数组，最多32个。例如`int[2,3]`，它是一个具有2行3列的整数数组。第三种类型是交错数组，它是数组的数组。交错数组是一个一维数组，其元素是其他数组，每个数组可以是另一个维度。
- en: The system-defined type conversions are implicit conversion (such as from `int`
    to `double`), and explicit conversion (such as from `double` to `int`). Explicit
    type conversions are also called casts and are necessary when conversion between
    two types bears the risk of losing information. User-defined conversions are possible
    by defining implicit or explicit operators for a certain type or with helper classes.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统定义的类型转换有隐式转换（例如从`int`到`double`），显式转换（例如从`double`到`int`）。显式类型转换也称为强制转换，在两种类型之间进行转换时可能会丢失信息时是必要的。用户定义的转换可以通过为某种类型定义隐式或显式操作符或使用辅助类来实现。
- en: Chapter 3
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: The selection statements in the C# language are `if` and `switch`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#语言中的选择语句是`if`和`switch`。
- en: The `default` case of a `switch` statement can appear anywhere on the list.
    It is always evaluated last after all the case labels have been evaluated.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句的`default`情况可以出现在列表的任何位置。在所有情况标签被评估之后，它总是最后被评估。'
- en: A `for` loop allows us to execute a block of code as long as a Boolean expression
    evaluates to true. A `foreach` loop allows us to iterate through the elements
    of a collection that implements the `IEnumerable` interface.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`循环允许我们执行一段代码，只要布尔表达式评估为true。`foreach`循环允许我们遍历实现`IEnumerable`接口的集合的元素。'
- en: The `while` loop is an entry controlled loop. That means it executes a block
    of statements as long as a specified Boolean expression evaluates to true. The
    expression is checked before the block is executed. The `do-while` loop is an
    exit-controlled loop. This means the Boolean expression will be checked at the
    end of the loop. This ensures that the `do-while` loop will always be executed
    at least once, even if the condition evaluates to false in the first iteration.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`循环是一个入口控制循环。这意味着只要指定的布尔表达式评估为true，它就会执行一系列语句。在执行块之前检查表达式。`do-while`循环是一个出口控制循环。这意味着布尔表达式将在循环结束时被检查。这确保了`do-while`循环至少会执行一次，即使条件在第一次迭代中评估为false。'
- en: To return from a function, you can use `return`, `yield`, or `throw`. The first
    two denote a normal return. The `throw` statement represents a return due to an
    erroneous situation in the execution flow.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从函数返回，可以使用`return`、`yield`或`throw`。前两个表示正常返回。`throw`语句表示由于执行流中的错误情况而返回。
- en: 'A `break` statement can be used to exit from a `switch` case or to terminate
    the execution of a loop. It works for all loops: `for`, `while`, `do-while`, and
    `foreach`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`break`语句可用于退出`switch`情况或终止循环的执行。它适用于所有循环：`for`、`while`、`do-while`和`foreach`。'
- en: It indicates that the method, operator, or `get` accessor where it appears preceding
    a `return` or `break` statement is an iterator. The sequence returned from an
    iterator method can be consumed using a `foreach` statement. The `yield` statement
    makes it possible to return values as they are produced and consume them as they
    are available, which is especially useful in an asynchronous context.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它表示方法、运算符或`get`访问器是一个迭代器，它出现在`return`或`break`语句之前。从迭代器方法返回的序列可以使用`foreach`语句消耗。`yield`语句使得可以在生成时返回值并在可用时消耗它们，这在异步上下文中特别有用。
- en: You can catch all the exceptions from a function call either with `catch(Exception)`,
    in which case you have access to information about the exception, or with a simple
    `catch` statement (without specifying an exception type), in which case you do
    not get any information about the exception.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过`catch(Exception)`捕获函数调用的所有异常，这样您就可以访问有关异常的信息，或者使用简单的`catch`语句（不指定异常类型），这样您就无法获取有关异常的任何信息。
- en: The `finally` block contains code that will execute after the `try` section.
    This happens regardless of whether the execution resumed normally or the control
    left the `try` block because of a `break`, `continue`, `goto`, or `return` statement.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`块包含在`try`部分之后执行的代码。无论执行是否正常恢复或控制是否因`break`、`continue`、`goto`或`return`语句而离开`try`块，都会发生这种情况。'
- en: The base class for all the exception types in .NET is the `System.Exception`
    class.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中所有异常类型的基类是`System.Exception`类。
- en: Chapter 4
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: A class is a template or a blueprint that specifies the form of an object. It
    contains both data and code that operates on that data. An object is an instance
    of a class. A class is introduced with the `class` keyword and defines a reference
    type. A structure is introduced with the `struct` keyword and defines a value
    type. Unlike classes, structures do not support inheritance and cannot have an
    explicit default constructor, and fields cannot be initialized during declaration
    unless they are declared `const` or `static`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类是指定对象形式的模板或蓝图。它包含操作该数据的数据和代码。对象是类的一个实例。类是用`class`关键字引入的，并定义了一个引用类型。结构是用`struct`关键字引入的，并定义了一个值类型。与类不同，结构不支持继承，不能有显式的默认构造函数，并且除非它们被声明为`const`或`static`，否则字段不能在声明时初始化。
- en: A read-only field is a field defined with the `readonly` specifier. Such a field
    can only be initialized in a constructor and its value cannot be changed later.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只读字段是使用`readonly`修饰符定义的字段。这样的字段只能在构造函数中初始化，其值以后不能被改变。
- en: Expression body definitions are an alternative syntax, typically for methods
    and properties, that simply consist of evaluating an expression and perhaps returning
    the result of the evaluation. These have the form `member => expression`. They
    are supported for all class members, not just methods, but also fields, properties,
    indexers, constructors, and finalizers. The type of the result value of the expression
    evaluation must match the return type of the method.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式体定义是一种替代语法，通常用于方法和属性，它们只是评估表达式并可能返回评估结果。它们的形式是`member => expression`。它们支持所有类成员，不仅仅是方法，还有字段、属性、索引器、构造函数和终结器。表达式评估的结果值的类型必须与方法的返回类型匹配。
- en: A default constructor is a constructor of a class that does not have any parameters.
    On the other hand, a static constructor is a constructor defined with the `static`
    keyword that has no parameters or access modifiers and cannot be called by the
    user. A static constructor is called by the CLR automatically in a static class
    when the first static member of the class is accessed for the first time, or in
    a non-static class when the class is instantiated for the first time. Static constructors
    are useful for initializing static fields.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认构造函数是一个没有任何参数的类的构造函数。另一方面，静态构造函数是用`static`关键字定义的构造函数，没有参数或访问修饰符，并且不能被用户调用。当首次访问类的第一个静态成员时，CLR会自动调用静态构造函数，或者在首次实例化类时，CLR会自动调用静态构造函数。静态构造函数用于初始化静态字段。
- en: Auto-implemented properties are properties for which the compiler will provide
    a private field and the implementation of the `get` and `set` accessors.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动实现属性是编译器将提供私有字段和`get`和`set`访问器的属性。
- en: An indexer is a class member that allows an object to be indexed like an array.
    An indexer defines a `get` and `set` accessor like properties do. An indexer does
    not have an explicit name. It is created by using the `this` keyword. An indexer
    has one or more parameters that can be of any type.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器是一个类成员，允许对象像数组一样被索引。索引器定义了`get`和`set`访问器，就像属性一样。索引器没有显式的名称。它是通过使用`this`关键字创建的。索引器有一个或多个可以是任何类型的参数。
- en: A static class is a class declared with the `static` keyword. It can only contain
    static members and cannot be instantiated. Static class members are accessed using
    the class name and not through an object. A static class is basically the same
    as a non-static class with a private constructor and all members are declared
    as `static`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态类是用`static`关键字声明的类。它只能包含静态成员，不能被实例化。静态类成员是使用类名而不是通过对象访问的。静态类基本上与非静态类相同，具有私有构造函数，并且所有成员都声明为`static`。
- en: The available parameter specifiers are `ref`, `out`, and `in`. The `ref` specifier
    modifies a parameter so that it becomes an alias for an argument, which must be
    a variable. It allows us to create a call-by-reference mechanism, rather than
    the implicit call-by-value one. The `in` specifier is similar in that it causes
    the argument to be passed by reference, but it does not allow the function to
    modify it. It is basically identical to `readonly ref`. The `out` keyword also
    defines a call-by-reference mechanism, but it requires a function to initialize
    a parameter before the function returns. It guarantees that a variable is assigned
    a value during the specified function call.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可用的参数修饰符是`ref`、`out`和`in`。`ref`修饰符修改参数，使其成为参数的别名，参数必须是一个变量。它允许我们创建按引用调用的机制，而不是隐式的按值调用。`in`修饰符类似，它导致参数按引用传递，但不允许函数修改它。它基本上与`readonly
    ref`相同。`out`关键字也定义了按引用调用的机制，但它要求函数在返回之前初始化参数。它保证在指定的函数调用期间变量被赋值。
- en: A method with a variable number of arguments must have a parameter that is a
    single-dimensional array preceded by the `params` keyword. This does not have
    to be the only parameter of the function, but it must be the last.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有可变数量参数的方法必须具有一个参数，该参数是由`params`关键字引导的一维数组。这不必是函数的唯一参数，但必须是最后一个参数。
- en: An enumeration is a set of named integral constants. You must use the `enum`
    keyword to declare an enumeration. An enumeration is a value type. Enumerations
    are useful when we want to use a limited number of integral values for some particular
    purpose.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举是一组命名的整数常量。您必须使用`enum`关键字声明枚举。枚举是值类型。当我们想要为特定目的使用有限数量的整数值时，枚举非常有用。
- en: Chapter 5
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Object-oriented programming is a paradigm that allows us to write a program
    around objects. Its core principles are abstraction, encapsulation, inheritance,
    and polymorphism.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象编程是一种范例，允许我们围绕对象编写程序。它的核心原则是抽象、封装、继承和多态。
- en: Encapsulation allows us to hide the data inside a class from the outside world.
    Encapsulation is important because it reduces the dependencies between different
    components by defining minimal public interfaces for them. It also increases code
    reusability and security and makes code easier to unit test.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装允许我们将类内部的数据隐藏在外部世界之外。封装很重要，因为它通过为不同组件定义最小的公共接口来减少它们之间的依赖关系。它还增加了代码的可重用性和安全性，并使代码更容易进行单元测试。
- en: Inheritance is a mechanism through which a class can inherit the properties
    and functionalities of another class. C# supports single inheritance but only
    for reference types.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承是一种机制，通过它一个类可以继承另一个类的属性和功能。C#支持单继承，但仅适用于引用类型。
- en: A virtual method is a method that has an implementation in a base class but
    can be overridden in derived classes, which is helpful for changing or extending
    implementation details. The implementation in the base class is defined with the
    `virtual` keyword. The implementation in a derived class is called an overridden
    method and is defined with the `override` keyword.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚方法是在基类中具有实现但可以在派生类中被重写的方法，这有助于更改或扩展实现细节。基类中的实现使用`virtual`关键字定义。派生类中的实现称为重写方法，并使用`override`关键字定义。
- en: You can prevent a virtual member from being overridden in a derived class by
    declaring it with the `sealed` keyword.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用`sealed`关键字声明虚成员来防止派生类中的成员被重写。
- en: An abstract class cannot be instantiated, which means we cannot create the object
    of an abstract class. An abstract class is declared using the `abstract` keyword.
    They can have both abstract and non-abstract members. An abstract member cannot
    be private and cannot have an implementation. An abstract class must provide an
    implementation for all the members of all the interfaces it implements (if any).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化，这意味着我们不能创建抽象类的对象。抽象类使用`abstract`关键字声明。它们可以有抽象成员和非抽象成员。抽象成员不能是私有的，也不能有实现。抽象类必须为它实现的所有接口的所有成员提供实现（如果有的话）。
- en: An interface defines a contract that is supported by all the types that implement
    the interface. An interface is a type introduced with the `interface` keyword
    and contains a set of members that must be implemented by any class or struct
    that implements the interface. Typically, an interface contains only declarations
    of members, but not implementations. Beginning with C# 8, interfaces can contain
    default methods.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口定义了一个由所有实现接口的类型支持的契约。接口是使用`interface`关键字引入的类型，包含一组必须由实现接口的任何类或结构实现的成员。通常，接口只包含成员的声明，而不包含实现。从C#
    8开始，接口可以包含默认方法。
- en: 'There are two types of polymorphism: compile-time polymorphism, represented
    by method overloading, and runtime polymorphism. Runtime polymorphism has two
    aspects. On one hand, objects of derived classes can be seamlessly used as objects
    of base classes in arrays or other types of collections, method parameters, and
    other places. On the other hand, classes can define virtual methods that can be
    overridden in derived classes. At runtime, the CLR will invoke the implementation
    of the virtual member corresponding to the runtime type of the object. An object''s
    declared type and its runtime type differ when objects of derived classes are
    used in places of objects of base classes.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种类型的多态性：编译时多态性，由方法重载表示，以及运行时多态性。运行时多态性有两个方面。一方面，派生类的对象可以无缝地用作基类的对象，放在数组或其他类型的集合、方法参数和其他位置。另一方面，类可以定义虚方法，可以在派生类中重写。在运行时，CLR将调用与对象的运行时类型相对应的虚成员的实现。当派生类的对象在基类的对象位置上使用时，对象的声明类型和运行时类型不同。
- en: Overloaded methods are methods with the same name but with parameters of different
    types or different numbers of parameters. The return type is not considered for
    method overloading. Operators can also be overloaded. A type can provide a custom
    implementation for an overloadable operator when one or both operands are of that
    type. The `operator` keyword is used to declare an operator. Such methods must
    be `public` and `static`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载方法是具有相同名称但具有不同类型或不同数量参数的方法。返回类型不考虑方法重载。运算符也可以重载。当一个或两个操作数是该类型时，类型可以为重载运算符提供自定义实现。使用`operator`关键字声明运算符。这样的方法必须是`public`和`static`。
- en: 'The SOLID principles are the following: **Single responsibility principle (S)**,
    **Open-close principle (O)**, **Liskov substitution principle (L)**, **Interface
    segregation principle (I)**, and **Dependency injection principle (D)**.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOLID原则包括：**单一责任原则（S）**，**开闭原则（O）**，**里氏替换原则（L）**，**接口隔离原则（I）**和**依赖注入原则（D）**。
- en: Chapter 6
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Generics are types parametrized with other types. Generics provide reusability,
    promote type safety, and can provide better performance (by avoiding the need
    for boxing and unboxing for value types).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用是用其他类型参数化的类型。通用提供可重用性，促进类型安全，并且可以提供更好的性能（通过避免值类型的装箱和拆箱）。
- en: A type used for parameterizing a generic type or method is called a type parameter.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于为通用类型或方法参数化的类型称为类型参数。
- en: Generic classes are defined in the same way as non-generic classes except for
    a list of one or more type parameters, specified within angle brackets (such as
    `<T>`) after the class name. The same is true for generic methods; the type parameters
    are specified after the class name.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用类的定义方式与非通用类相同，只是在类名后的尖括号内（如`<T>`）指定一个或多个类型参数的列表。通用方法也是如此；类型参数在类名后指定。
- en: Classes can be derived from generic types. Structures do not support explicit
    inheritance, but they can implement any number of generic interfaces.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类可以派生自通用类型。结构不支持显式继承，但可以实现任意数量的通用接口。
- en: A constructed type is a type that is constructed from a generic type by replacing
    the type parameters with actual types. For instance, for a `Shape<T>` generic
    type, the `Shape<int>` is a constructed type.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造类型是从通用类型构造的类型，通过用实际类型替换类型参数。例如，对于`Shape<T>`通用类型，`Shape<int>`是一个构造类型。
- en: A covariant type parameter is a type parameter declared with the `out` keyword.
    Such a type parameter allows an interface method to have a return type that is
    more derived than the specified type parameter.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协变类型参数是使用`out`关键字声明的类型参数。这样的类型参数允许接口方法具有比指定类型参数更派生的返回类型。
- en: A contravariant type parameter is a type parameter declared with the `in` keyword.
    Such a type parameter allows an interface method to have a parameter that is less
    derived than the specified type parameter.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆变类型参数是使用`in`关键字声明的类型参数。这样的类型参数允许接口方法具有比指定类型参数更不派生的参数。
- en: Type parameter constraints are restrictions specified for type parameters that
    inform the compiler about what kind of capabilities the type parameters must have.
    Applying a constraint limits the types that can be used for constructing a type
    from a generic one.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数约束是为类型参数指定的限制，通知编译器类型参数必须具有什么样的能力。应用约束会限制可以用于从通用类型构造类型的类型。
- en: The `new()` type constraint specifies that a type must provide a public default
    constructor.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new()`类型约束指定类型必须提供公共默认构造函数。'
- en: The type parameter constraint introduced in C# 8 is `notnull`. It can only be
    used in a nullable context, otherwise the compiler generates a warning. It specifies
    that the type parameter must be a non-nullable type. It can be a non-nullable
    reference type (in C#8) or a non-nullable value type.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 8中引入的类型参数约束是`notnull`。它只能在可空上下文中使用，否则编译器会生成警告。它指定类型参数必须是非空类型。它可以是非空引用类型（在C#8中）或非空值类型。
- en: Chapter 7
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: The BCL namespace containing the generic collections is `System.Collections.Generic`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含通用集合的BCL命名空间是`System.Collections.Generic`。
- en: The base interface for all the other interfaces that define functionalities
    for generic collections is `IEnumerable<T>`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于通用集合功能的所有其他接口的基本接口是`IEnumerable<T>`。
- en: Generic collections are preferred over non-generic ones because they offer the
    benefit of type safety, have better performance for value types (because they
    avoid boxing and unboxing), and, in some cases, they provide functionalities not
    available in the non-generic collections.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用集合优于非通用集合，因为它们提供类型安全性的好处，对值类型有更好的性能（因为它们避免了装箱和拆箱），并且在某些情况下，它们提供非通用集合中不可用的功能。
- en: The `List<T>` generic class represents a collection of elements that can be
    accessed by their index. `List<T>` is very similar to arrays, except that the
    size of the collection is not fixed but is variable and it can grow or decrease
    as elements are added or removed. You add elements with `Add()`, `AddRange()`,
    `Insert()`, and `InsertRange()`. You can remove elements with `Remove()`, `RemoveAt()`,
    `RemoveRange()`, `RemoveAll()`, and `Clear()`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<T>`通用类表示可以通过它们的索引访问的元素集合。`List<T>`与数组非常相似，只是集合的大小不是固定的，而是可变的，可以随着元素的添加或删除而增长或减少。您可以使用`Add()`，`AddRange()`，`Insert()`和`InsertRange()`添加元素。您可以使用`Remove()`，`RemoveAt()`，`RemoveRange()`，`RemoveAll()`和`Clear()`删除元素。'
- en: The `Stack<T>` generic class represents a collection with last-in, first-out
    semantics. Elements are added to the top with the `Push()` method and removed
    from the top with the `Pop()` method.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stack<T>`通用类表示具有后进先出语义的集合。元素使用`Push()`方法添加到顶部，并使用`Pop()`方法从顶部移除。'
- en: The `Queue<T>` generic class represents a collection with first-in, first-out
    semantics. The `Dequeue()` method removes and returns the item from the front
    of the queue. The `Peek()` method returns the item from the front of the queue
    without removing it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Queue<T>`泛型类表示具有先进先出语义的集合。`Dequeue()`方法从队列的前端移除并返回项目。`Peek()`方法返回队列前端的项目，但不移除它。'
- en: The `LinkedList<T>` generic class represents a double linked list. Its elements
    are of the `LinkedListNode<T>` type. To add elements to the linked list you can
    use the `AddFirst()`, `AddLast()`, `AddAfter()`, and `AddBefore()` methods.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`泛型类表示双向链表。它的元素是`LinkedListNode<T>`类型。要向链表添加元素，可以使用`AddFirst()`、`AddLast()`、`AddAfter()`和`AddBefore()`方法。'
- en: The `Dictionary<TKey, TValue>` generic class represents a collection of key-value
    pairs that allows fast lookup based on a key. The elements of this dictionary
    class are of the `KeyValuePair<TKey, TValue>` type.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`泛型类表示键值对的集合，允许基于键进行快速查找。这个字典类的元素是`KeyValuePair<TKey,
    TValue>`类型。'
- en: The `HashSet<T>` generic class represents a set of distinct items that can be
    in any order but are stored contiguously. A hash set is logically similar to a
    dictionary where the values are also the keys. However, unlike `Dictionary<TKey,
    TValue>`, `HashSet<T>` is a non-associative container.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HashSet<T>`泛型类表示一组不同的项目，可以以任何顺序存储在一起。哈希集在逻辑上类似于字典，其中值也是键。但是，与`Dictionary<TKey,
    TValue>`不同，`HashSet<T>`是一个非关联容器。'
- en: '`BlockingCollection<T>` is a class that implements the producer-consumer pattern
    defined by the `IProducerConsumerCollection<T>` interface. It is actually a simple
    wrapper over the `IProducerConsumerCollection<T>` interface and does not have
    internal underlying storage but must be provided with one (a collection that implements
    the `IProducerConsumerCollection<T>` interface). If no implementation is provided,
    it uses the `ConcurrentQueue<T>` class by default. It is suitable for scenarios
    when bounding and blocking are necessary.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlockingCollection<T>`是一个实现了`IProducerConsumerCollection<T>`接口定义的生产者-消费者模式的类。它实际上是`IProducerConsumerCollection<T>`接口的一个简单包装器，没有内部基础存储，但必须提供一个（实现了`IProducerConsumerCollection<T>`接口的集合）。如果没有提供实现，它默认使用`ConcurrentQueue<T>`类。它适用于需要边界和阻塞的场景。'
- en: Chapter 8
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: A callback is a function (or more generally, any executable code) that is passed
    as a parameter to another function in order to be called immediately (synchronous
    callbacks) or at a later time (asynchronous callbacks). A delegate is a strongly
    typed callback.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调是作为参数传递给另一个函数以立即调用（同步回调）或在以后调用（异步回调）的函数的函数（或更一般地说，任何可执行代码）。委托是一种强类型的回调。
- en: A delegate is defined using the `delegate` keyword. The declaration looks like
    a function signature, but the compiler actually introduces a class that can hold
    references to methods whose signatures match the signature of the delegate. Events
    are variables of a delegate type declared with the `event` keyword.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`delegate`关键字定义委托。声明看起来像函数签名，但实际上编译器引入了一个可以持有方法引用的类，其签名与委托的签名匹配。事件是使用`event`关键字声明的委托类型的变量。
- en: 'There are two kinds of tuples in C#: reference tuples, represented by the `System.Tuple`
    class, and value tuples, represented by the `System.ValueTuple` structure. The
    reference tuples can only hold up to eight elements, while the latter can hold
    a sequence of any number of elements, although at least two are required. Value
    tuples may have compile-type named fields, and have a simpler but richer syntax
    for creating, assigning, deconstructing, and comparing values.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中有两种元组：引用元组，由`System.Tuple`类表示，和值元组，由`System.ValueTuple`结构表示。引用元组最多只能容纳八个元素，而值元组可以容纳任意数量的元素，但至少需要两个。值元组可以具有编译时命名字段，并且具有更简单但更丰富的语法来创建、赋值、解构和比较值。
- en: Named tuples are value tuples that have names for their fields. These names
    are synonyms for the fields `Item1`, `Item2`, and so on, but are only available
    at source-code level.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名元组是具有字段名称的值元组。这些名称是字段`Item1`、`Item2`等的同义词，但仅在源代码级别可用。
- en: Pattern matching is the process of checking whether a value has a particular
    shape as well as extracting information out of the value when the matching is
    successful. It can be used with `is` and `switch` expressions.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式匹配是检查值是否具有特定形状以及在匹配成功时从值中提取信息的过程。它可以与`is`和`switch`表达式一起使用。
- en: A null value does not match a type pattern, regardless of the type of the variable.
    A `switch` case label with a pattern matching for null can be added in a `switch`
    expression with type pattern matching to specifically handle null values. When
    using the `var` pattern, a null value always matches. Therefore, when using the
    `var` pattern, you must add an explicit null check because the value may be null.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空值不匹配类型模式，无论变量的类型如何。可以在具有类型模式匹配的`switch`表达式中添加一个用于匹配空值的`switch` case标签，以专门处理空值。使用`var`模式时，空值始终匹配。因此，在使用`var`模式时，必须添加显式的空值检查，因为值可能为空。
- en: The .NET class that provides support for working with regular expressions is
    the `Regex` class from the `System.Text.RegularExpressions` namespace. By default,
    it uses the UTF-8 encoding for the string to match.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中用于处理正则表达式的类是`System.Text.RegularExpressions`命名空间中的`Regex`类。默认情况下，它使用UTF-8编码进行字符串匹配。
- en: The `Match()` method checks an input string for substrings that match a regular
    expression and returns the first match. The `Matches()` method does the same search
    but returns all the matches.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Match()`方法检查输入字符串中与正则表达式匹配的子字符串，并返回第一个匹配项。`Matches()`方法执行相同的搜索，但返回所有匹配项。'
- en: Extension methods are methods that extend the functionalities of a type without
    changing its source code. They are useful because they allow extensions without
    changing the implementation, creating a derived type, or recompiling the code,
    in general.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法是扩展类型功能而不改变其源代码的方法。它们很有用，因为它们允许扩展而不改变实现，创建派生类型或重新编译代码，一般来说。
- en: Extension methods are defined as static methods of a static, non-nested, non-generic
    class and their first parameter is of the type they extend, preceded by the `this`
    keyword.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法被定义为静态方法，属于静态、非嵌套、非泛型类，它们的第一个参数是它们扩展的类型，前面加上`this`关键字。
- en: Chapter 9
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: The stack is a relatively small segment of memory allocated by the compiler
    that keeps track of the memory necessary for running the application. The stack
    hasLIFO semantics and grows and shrinks as the program execution is invoking functions
    or returning from functions. The heap, on the other hand, is a large segment of
    memory that the program may use to allocate memory at runtime, and which, in .NET,
    is managed by the CLR. Objects of value types are, typically, allocated on the
    stack, and objects of reference types are allocated on the heap.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈是编译器分配的相对较小的内存段，用于跟踪运行应用程序所需的内存。栈具有LIFO语义，并随着程序执行调用函数或从函数返回而增长和缩小。另一方面，堆是程序可能在运行时用来分配内存的大内存段，在.NET中由CLR管理。通常，值类型的对象分配在栈上，引用类型的对象分配在堆上。
- en: The managed heap has three memory segments called generations. They are named
    generation 0, 1, and 2\. Generation 0 contains small, and usually short-lived,
    objects such as local variables or objects instantiated for the lifetime of a
    function call. Generation 1 contains small objects that have survived a garbage
    collection of memory from generation 0\. Generation 2 contains long-lived small
    objects that have survived a garbage collection of memory from generation 1 and
    large objects (which are always allocated on this segment).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托管堆有三个内存段，称为代。它们被命名为代0、1和2。代0包含小的、通常是短寿命的对象，比如局部变量或在函数调用的生命周期内实例化的对象。代1包含在代0的内存回收中幸存下来的小对象。代2包含在代1的内存回收中幸存下来的长寿命小对象和大对象（总是分配在这个段上）。
- en: Garbage collection has three phases. First, the garbage collector builds a graph
    of all live objects in order to figure out what is still in use and what may be
    deleted. Second, references to objects that will be compacted are updated. Third,
    the dead objects are removed, and the surviving objects are compacted. Typically,
    the large object heap containing large objects is not compacted because moving
    large chunks of data incurs performance costs.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集有三个阶段。首先，垃圾收集器构建所有活动对象的图形，以便找出仍在使用的对象和可能被删除的对象。其次，将要压缩的对象的引用被更新。第三，死对象被移除，幸存的对象被压缩。通常，包含大对象的大对象堆不会被压缩，因为移动大块数据会产生性能成本。
- en: A finalizer is a special method of a class (has the same name as the class but
    prefixed with `~`) that should dispose of unmanaged resources that the class has
    ownership of. This method is called by the garbage collector when the object is
    collected. This process is non-deterministic, which is the key difference between
    finalization and disposal. The latter is a deterministic process that occurs during
    the explicit invocation of the `Dispose()` method (for classes that implement
    the `IDisposable` interface).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终结器是一个类的特殊方法（与类名相同，但前缀为`~`），应该处理类拥有所有权的非托管资源。当对象被回收时，垃圾收集器会调用这个方法。这个过程是非确定性的，这是终结和处理之间的关键区别。后者是一个确定性的过程，发生在显式调用`Dispose()`方法时（对于实现了`IDisposable`接口的类）。
- en: The `GC.SuppressFinalize()` method requests the CRL not to invoke the finalizer
    of the specified object. This is typically called when implementing the `IDisposable`
    interface, so that unmanaged resources are not disposed of twice.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GC.SuppressFinalize()`方法请求CRL不要调用指定对象的终结器。通常在实现`IDisposable`接口时调用这个方法，以便非托管资源不会被处理两次。'
- en: '`IDisposable` is an interface with a single method called `Dispose()` that
    defines a pattern for the deterministic disposal of objects.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IDisposable`是一个接口，有一个名为`Dispose()`的方法，定义了对象的确定性处理的模式。'
- en: The `using` statement represents short-hand syntax for the deterministic disposal
    of objects of types that implement the `IDisposable` interface. The `using` statement
    introduces a scope for the variable defined in the statement and ensures the object
    is properly disposed of before the scope is exited. The actual disposal details
    depend on whether the resource is a value type, a nullable value type, a reference
    type, or a dynamic type.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`using`语句表示对实现`IDisposable`接口的类型的对象进行确定性处理的简写语法。`using`语句引入了在语句中定义的变量的作用域，并确保在退出作用域之前正确处理对象。实际的处理细节取决于资源是值类型、可空值类型、引用类型还是动态类型。'
- en: A function from a native DLL can be invoked in C# using Platform Invocation
    Services, or P/Invoke. To do so, you must define a `static` `extern` method that
    matches the signature of the native function (using equivalent managed types for
    its parameters). This managed function must be decorated with the `DllImport`
    attribute, which defines the necessary information for the runtime to call the
    native function.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用平台调用服务（Platform Invocation Services，或P/Invoke）在C#中调用来自本机DLL的函数。为此，必须定义一个与本机函数签名匹配的`static`
    `extern`方法（使用等效的托管类型作为其参数）。这个托管函数必须用`DllImport`属性修饰，该属性定义了运行时调用本机函数所需的信息。
- en: Unsafe code is code for which the CLR cannot verify its safety. Unsafe code
    enables the use of pointer types and supports pointer arithmetic. Unsafe code
    is not necessarily dangerous, but it is your entire responsibility to ensure that
    you do not introduce pointer errors or security risks. The typical scenarios for
    using unsafe code are calling functions exported from a native DLL or COM server
    that require pointer types as parameters, and optimizing some algorithms where
    performance is critical.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不安全代码是CLR无法验证其安全性的代码。不安全代码使得可以使用指针类型并支持指针算术。不安全代码不一定是危险的，但您完全有责任确保不会引入指针错误或安全风险。使用不安全代码的典型场景包括调用从本机DLL或COM服务器导出的需要指针类型作为参数的函数，并优化一些性能关键的算法。
- en: Unsafe code is defined with the `unsafe` keyword, which can be applied to types
    (classes, structures, interfaces, and delegates), type members (methods, fields,
    properties, events, indexers, operators, instance constructors, and static constructors),
    and statement blocks.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`unsafe`关键字定义不安全代码，可以应用于类型（类、结构、接口和委托）、类型成员（方法、字段、属性、事件、索引器、运算符、实例构造函数和静态构造函数）和语句块。
- en: Chapter 10
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: 'The main characteristics of functional programming are immutability (objects
    have states that do not change) and side-effect free functions (functions do not
    modify values or states outside their local scope). Advantages of functional programming
    include the following: first, the code is easier to understand and maintain because
    functions do not change states and only depend on the arguments they receive.
    Second, the code is easier to test for the same reason. Third, it is simpler and
    more efficient to implement concurrency because data is immutable and functions
    don''t have side effects, which avoids data races.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程的主要特征是不可变性（对象具有不变的状态）和无副作用的函数（函数不修改值或状态在它们的局部范围之外）。函数式编程的优点包括以下几点：首先，代码更容易理解和维护，因为函数不改变状态，只依赖于它们接收的参数。其次，由于同样的原因，代码更容易测试。第三，实现并发更简单和更有效，因为数据是不可变的，函数没有副作用，避免了数据竞争。
- en: A higher-order function is a function that takes one or more functions as arguments,
    returns a function, or both.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶函数是一个接受一个或多个函数作为参数、返回一个函数或两者兼有的函数。
- en: C# provides the ability to pass functions as arguments, return functions from
    functions, assign functions to variables, store them in data structures, define
    anonymous functions, nest functions, and test references to functions for equality.
    All these characteristics make C# a language that is said to treat functions as
    first-class citizens.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#提供了将函数作为参数传递、从函数返回函数、将函数分配给变量、将函数存储在数据结构中、定义匿名函数、嵌套函数以及测试函数引用是否相等的能力。所有这些特性使C#成为一种被称为将函数视为一等公民的语言。
- en: Lambda expressions are a convenient way to write anonymous functions. This is
    a block of code, either an expression or one or more statements that behave like
    a function and can be assigned to a delegate. As a result, a lambda expression
    can be passed as an argument to a function or returned from a function. They are
    a convenient way to write LINQ queries, pass functions to higher-order functions
    (including code that should be executed asynchronously by `Task.Run()`), and create
    expression trees. A lambda expression has two parts separated by the lambda declaration
    operator, `=>`. The left part is the list of parameters, and the right part is
    an expression or a statement. An example of a lambda expression is `n => n%2==1`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式是一种方便的编写匿名函数的方式。这是一段代码，可以是一个表达式或一个或多个行为像函数一样的语句，并且可以被分配给一个委托。因此，lambda表达式可以作为参数传递给函数或从函数返回。它们是编写LINQ查询、将函数传递给高阶函数（包括应该由`Task.Run()`异步执行的代码）以及创建表达式树的一种方便的方式。Lambda表达式由lambda声明运算符`=>`分隔成两部分。左部是参数列表，右部是一个表达式或一个语句。Lambda表达式的一个例子是`n
    => n%2==1`。
- en: 'The rules that apply to variable scope in lambda expressions are as follows:
    first, the variables that are introduced in a lambda expression are not visible
    outside the lambda. Second, a lambda cannot capture `in`, `ref`, or `out` parameters
    from the enclosing method. Third, variables that are captured by a lambda are
    not garbage collected until the delegate that the lambda is assigned to is garbage
    collected, even if they would otherwise go out of scope. Fourth, and last, a return
    statement of a lambda expression refers solely to the anonymous method that the
    lambda represents and does not cause the enclosing method to return.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式中变量作用域的规则如下：首先，lambda表达式中引入的变量在lambda之外是不可见的。其次，lambda不能捕获封闭方法中的`in`、`ref`或`out`参数。第三，lambda捕获的变量在委托被垃圾回收之前不会被垃圾回收，即使它们本来应该超出作用域。第四，最后，lambda表达式的返回语句仅与lambda所代表的匿名方法有关，并不会导致封闭方法返回。
- en: LINQ is a set of technologies that enable developers to query a multitude of
    data sources in a consistent manner. The LINQ standard query operators are a set
    of extension methods that operate on sequences that implement either `IEnumerable<T>`
    or `IQueryable<T>`. LINQ query syntax is basically syntactic sugar for the standard
    query operators. The compiler transforms queries written in query syntax into
    queries using the standard query operators. Query syntax is simpler and easier
    to read than the standard query operators, but they are semantically equivalent.
    However, not all the standard query operators have an equivalent in query syntax.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ是一组技术，使开发人员能够以一致的方式查询多种数据源。LINQ标准查询操作符是一组在实现`IEnumerable<T>`或`IQueryable<T>`的序列上操作的扩展方法。LINQ查询语法基本上是标准查询操作符的语法糖。编译器将用查询语法编写的查询转换为使用标准查询操作符的查询。查询语法比标准查询操作符更简单、更易读，但它们在语义上是等价的。然而，并非所有的标准查询操作符在查询语法中都有等价物。
- en: The `Select()` method projects each element of a sequence into a new form. This
    requires a selector, which is a transformation function, to produce a new value
    for each element of the collection. However, when the elements of the collection
    are themselves collections, it is often necessary to flatten them to a single
    collection. This is what the `SelectMany()` method is doing.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Select()`方法将序列的每个元素投影到一个新形式中。这需要一个选择器，即一个转换函数，为集合的每个元素产生一个新值。然而，当集合的元素本身是集合时，通常需要将它们展平为单个集合。这就是`SelectMany()`方法所做的事情。'
- en: Partial function application is the process of taking a function with *N* parameters
    and one argument and returning another function with *N-1* parameters after fixing
    the argument into one of the function's parameters. This technique is the opposite
    of currying, which is the process of taking a function with *N* arguments and
    decomposing it into *N* functions that take one argument.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部分函数应用是将具有*N*个参数和一个参数的函数进行处理，并在将参数固定为函数的一个参数后返回另一个具有*N-1*个参数的函数的过程。这种技术是柯里化的相反，柯里化是将具有*N*个参数的函数进行处理，并将其分解为接受一个参数的*N*个函数的过程。
- en: A monoid is an algebraic structure with a single associative binary operation
    and an identity element. Any C# type that has those two elements is a monoid.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幺半群是具有单一可结合二元运算和单位元素的代数结构。任何具有这两个元素的C#类型都是幺半群。
- en: 'A monad is a container that encapsulates some functionality on top of the value
    that it wraps. A monad has two operations: the first one that transforms a value,
    `v,` into a container that wraps it (`v -> C(v)`). In functional programming,
    this function is called a return. The second one that flattens two containers
    into a single container (`C(C(v)) -> C(v)`). In functional programming, this is
    called a bind. An example of a monad is `IEnumerable<T>` with the LINQ query operator
    `SelectMany()`.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单子是封装在值之上的一些功能的容器。单子有两个操作：第一个将一个值`v`转换为封装它的容器（`v -> C(v)`）。在函数式编程中，这个函数被称为返回。第二个将两个容器展平为一个单一的容器（`C(C(v))
    -> C(v)`）。在函数式编程中，这被称为绑定。一个单子的例子是带有LINQ查询运算符`SelectMany()`的`IEnumerable<T>`。
- en: Chapter 11
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: The unit of deployment in .NET is the assembly. An assembly is a file (either
    an executable or a dynamic-link library) that contains the MSIL code, as well
    as metadata about the content of the assembly, and, optionally, resources.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET中，部署的单位是程序集。程序集是一个文件（可执行文件或动态链接库），其中包含MSIL代码以及有关程序集内容的元数据，以及可选的资源。
- en: Reflection is the process of runtime type discovery and the ability to make
    changes to them. This means that we can retrieve information about types, their
    members, and their attributes at runtime. Reflection makes it possible to easily
    build extensible applications; to execute types and members that are private or
    have other access levels that makes them inaccessible otherwise, which is useful
    for testing; to modify existing types or creating entirely new types at runtime
    and execute code using them; and, in general, to change a system behavior at runtime,
    usually with the use of attributes.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射是运行时类型发现和对其进行更改的过程。这意味着我们可以在运行时检索有关类型、其成员和属性的信息。反射使得可以轻松构建可扩展的应用程序；执行私有或具有其他访问级别的类型和成员，否则这些类型和成员将无法访问，这对于测试很有用；在运行时修改现有类型或创建全新类型并使用它们执行代码；以及通常在运行时更改系统行为，通常使用属性。
- en: The type that provides meta-information about types is `System.Type`. An instance
    of this type can be created with the `GetType()` method, the `Type.GetType()`
    static method, or with the C# `typeof` operator.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供有关类型的元信息的类型是`System.Type`。可以使用`GetType()`方法、`Type.GetType()`静态方法或C#的`typeof`运算符创建此类型的实例。
- en: A shared assembly is intended to be used by several applications and is usually
    located under the **Global Assembly Cache (GAC)**, a system repository for assemblies.
    A private assembly is intended to be used by a single application and is stored
    in the application directory or one of its sub-directories. Shared assemblies
    must be strongly named and enforce version constraints; these requirements are
    not necessary for private assemblies.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共享程序集旨在被多个应用程序使用，通常位于全局程序集缓存（GAC）下，这是程序集的系统存储库。私有程序集旨在被单个应用程序使用，并存储在应用程序目录或其子目录中。共享程序集必须具有强名称并强制版本约束；这些要求对于私有程序集并非必需。
- en: 'In .NET, an assembly can be loaded in one of the following contexts: the load
    context (which contains assemblies loaded from the GAC, the app directory, or
    its subdirectories), the load-from context (which contains assemblies loaded from
    other paths than the previously mentioned), the reflection-only context (which
    contains assemblies loaded for reflection purposes only), or no context at all
    (such as when an assembly is loaded from an array of bytes).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET中，程序集可以在以下上下文中加载：加载上下文（包含从GAC、应用程序目录或其子目录加载的程序集）、从其他路径加载的程序集的加载上下文、仅用于反射目的加载的反射上下文，或者根本没有上下文（例如从字节数组加载程序集时）。
- en: Early binding is the process of creating an assembly dependency (reference)
    during compile time. This offers the compiler full access to the types available
    in the assembly. Late binding is the process of loading assemblies at runtime,
    in which case the compiler has no access to the content of the assembly. However,
    this is important for building extensible applications.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早期绑定是在编译时创建程序集依赖关系（引用）的过程。这使得编译器可以完全访问程序集中可用的类型。晚期绑定是在运行时加载程序集的过程，在这种情况下，编译器无法访问程序集的内容。然而，这对于构建可扩展的应用程序非常重要。
- en: The Dynamic Language Runtime is a component of the .NET platform that defines
    a runtime environment that adds a set of services on top of the CLR in order to
    enable dynamic languages to run on the CLR and to add dynamic features to statically
    typed languages.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态语言运行时是.NET平台的一个组件，它定义了一个运行时环境，该环境在CLR之上添加了一组服务，以便使动态语言能够在CLR上运行，并为静态类型的语言添加动态特性。
- en: The `dynamic` type is a static type, meaning variables of this type are assigned
    the `dynamic` type at compile time. However, they bypass static type checking.
    That means the actual type of the object is only known at runtime and the compiler
    cannot know and cannot enforce any checks on operations performed on objects of
    this type. You can invoke any methods with any parameters and the compiler will
    not check and complain; however, if the operation is not valid, an exception will
    be thrown at runtime. The `dynamic` type is often used to simplify the consumption
    of COM objects when an interop assembly is not available.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dynamic`类型是静态类型，意味着在编译时将变量分配给`dynamic`类型。但是，它们绕过了静态类型检查。这意味着对象的实际类型只在运行时才知道，编译器无法知道也无法强制执行对该类型对象执行的任何操作。您可以调用任何带有任何参数的方法，编译器不会检查也不会抱怨；但是，如果操作无效，运行时将抛出异常。`dynamic`类型通常用于在Interop程序集不可用时简化对COM对象的使用。'
- en: Attributes are types that derive from the `System.Attribute` abstract class
    and provide meta-information about assemblies, types, and members. This meta-information
    is consumed by the compiler, the CLR, or tools that use reflection services to
    read them. Attributes are specified in square brackets, such as in `[SerializableAttribute]`.
    The naming convention for attributes is that the type names are always suffixed
    with the word `Attribute`. The C# language provides a syntactic shortcut that
    allows specifying the name of the attribute without the suffix `Attribute`, such
    as in `[Serializable]`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性是从`System.Attribute`抽象类派生的类型，提供有关程序集、类型和成员的元信息。这些元信息由编译器、CLR或使用反射服务读取它们的工具消耗。属性在方括号中指定，例如`[SerializableAttribute]`。属性的命名约定是类型名称总是以`Attribute`一词结尾。C#语言提供了一种语法快捷方式，允许在不带后缀`Attribute`的情况下指定属性的名称，例如`[Serializable]`。
- en: To create user-defined attributes you must derive from the `System.Attribute`
    type and follow the naming convention of suffixing the type with the word `Attribute`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建用户定义的属性，必须从`System.Attribute`类型派生，并遵循将类型后缀命名为`Attribute`的命名约定。
- en: Chapter 12
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: When you need to execute some long-running, CPU-intensive code, manually creating
    a dedicated thread is the preferred choice. Another option is to create a Task
    with `TaskCreationOptions.LongRunning` or, in most advanced scenarios, to write
    a custom task scheduler.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要执行一些长时间运行的、CPU密集型的代码时，手动创建一个专用线程是首选。另一个选项是使用`TaskCreationOptions.LongRunning`创建一个任务，或者在大多数高级场景下，编写一个自定义任务调度程序。
- en: The most performant synchronization techniques are those not using kernel objects
    but user-mode objects. In order to atomically write both a file and some value
    in memory, the Critical Section is the most appropriate technique and is available
    through the `lock` keyword of the C# language.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有效的同步技术是不使用内核对象而是用户模式对象的技术。为了原子地在文件和内存中写入某个值，关键部分是最合适的技术，并且通过C#语言的`lock`关键字可用。
- en: The `Task.Delay` API is the most appropriate delay because it *schedules* the
    code in the continuation after the specified number of milliseconds, letting the
    thread be reused in the meantime. Conversely, the operating system `Sleep` API
    is exposed in .NET as `Thread.Sleep`, which suspends the thread execution for
    the given number of milliseconds, but it makes the thread unavailable from being
    reused.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task.Delay` API是最合适的延迟，因为它在指定的毫秒数后*调度*继续执行的代码，同时让线程在此期间被重用。相反，操作系统的`Sleep`
    API在.NET中暴露为`Thread.Sleep`，它会暂停线程的执行一定的毫秒数，但会使线程无法被重用。'
- en: The Task library offers the `WaitHandle.WaitAny` and `WaitHandle.WaitAll` methods,
    which respectively call the continuation code as soon as *any* or *all* of the
    operations have completed. The task results can be accessed as soon as the returned
    tasks have completed.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Task库提供了`WaitHandle.WaitAny`和`WaitHandle.WaitAll`方法，分别在*任何*或*所有*操作完成时立即调用继续执行的代码。可以在返回的任务完成后立即访问任务结果。
- en: The `TaskCompletionSource` is a class used to create and control the `Task`.
    It can be used to transform any asynchronous behavior, such as a CLR event, in
    a Task-based operation. The client code, instead of subscribing to the event,
    can therefore await the task obtained from the `TaskCompletionSource`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource`是一个用于创建和控制`Task`的类。它可以用于将任何异步行为（如CLR事件）转换为基于任务的操作。客户端代码可以等待从`TaskCompletionSource`获得的任务，而不是订阅事件。'
- en: The `Task` library provides the pre-built `Task.CompletedTask` to return an
    empty `Task`, and the methods `Task.FromResult`, `Task.FromCanceled` and `Task.FromException`
    to create tasks that either return a result, report a cancellation, or throw an
    exception.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task`库提供了预构建的`Task.CompletedTask`来返回一个空的`Task`，以及`Task.FromResult`、`Task.FromCanceled`和`Task.FromException`方法来创建返回结果、报告取消或抛出异常的任务。'
- en: Long-running tasks may be created by specifying `TaskCreationOptions.LongRunning`
    in the `Task` constructor.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Task`构造函数中指定`TaskCreationOptions.LongRunning`可以创建长时间运行的任务。
- en: The need to use `Control.Invoke` (or `Dispatcher.Invoke` in WPF) can be verified
    with `Control.InvokeRequired` (or `Dispatcher.CheckAccess()` in WPF) and depends
    on whether the library used to access the resource already marshaled the result
    in the main thread. If the library already embraced the tasks and the library
    author did not call `Task.ConfigureAwait(false)`, you can consume the result directly
    because the continuation executed after the `await` keyword is invoked in the
    main thread thanks to the synchronization context provided by the UI framework.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要使用`Control.Invoke`（或WPF中的`Dispatcher.Invoke`）可以通过`Control.InvokeRequired`（或WPF中的`Dispatcher.CheckAccess()`）进行验证，并取决于用于访问资源的库是否已经在主线程中调度了结果。如果库已经包含了任务，并且库作者没有调用`Task.ConfigureAwait(false)`，那么可以直接使用结果，因为在`await`关键字之后执行的继续操作是由UI框架提供的同步上下文在主线程中调用的。
- en: The `ConfigureAwait` method is useful to avoid useless marshaling operations
    that would occur when a synchronization context is in use in the process. This
    is normally created by UI frameworks and ASP.NET applications. The primary users
    of `ConfigureAwait` are library developers who don't need to access the application
    objects that can only be used from the main thread.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConfigureAwait`方法可用于避免在进程中使用同步上下文时发生的无用调度操作。这通常由UI框架和ASP.NET应用程序创建。`ConfigureAwait`的主要用户是不需要访问只能从主线程使用的应用程序对象的库开发人员。'
- en: You have to verify whether the asynchronous operation has completed in the main
    thread first (for example, by using `Control.InvokeRequired` in Windows Forms
    or `Dispatcher.CheckAccess()` in WPF). If it completed in a different thread,
    you need to access the UI by means of `Control.Invoke` or `Dispatcher.Invoke`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先必须验证异步操作是否在主线程中完成（例如，通过在Windows Forms中使用`Control.InvokeRequired`或在WPF中使用`Dispatcher.CheckAccess()`）。如果在不同的线程中完成，需要通过`Control.Invoke`或`Dispatcher.Invoke`访问UI。
- en: Chapter 13
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: The most important classes in the `System.IO` namespace for working with system
    objects are `Path` for paths, `File` and `FileInfo` for files, and `Directory`
    and `DirectoryInfo` for directories.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.IO`命名空间中与系统对象一起工作的最重要的类是`Path`用于路径，`File`和`FileInfo`用于文件，`Directory`和`DirectoryInfo`用于目录。'
- en: The preferred way of concatenating paths is by using the `Path.Combine()` static
    method.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接路径的首选方法是使用`Path.Combine()`静态方法。
- en: The path of the temporary folder of the current user can be retrieved with the
    `Path.GetTempPath()` static method.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`Path.GetTempPath()`静态方法检索当前用户的临时文件夹的路径。
- en: The `File` and `FileInfo` classes provide similar functionalities but `File`
    is a static class and `FileInfo` is a non-static class. Likewise, `Directory`
    is a static class and `DirectoryInfo` is a non-static class, although their functionalities
    are similar.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File`和`FileInfo`类提供类似的功能，但`File`是一个静态类，`FileInfo`是一个非静态类。同样，`Directory`是一个静态类，`DirectoryInfo`是一个非静态类，尽管它们的功能类似。'
- en: To create directories, you can use the `Create()` and `CreateSubdirectory()`
    methods. The former creates a directory when its direct parent exists. The latter
    creates a subdirectory and all the other subdirectories in a hierarchy up to the
    root, if necessary. To enumerate directories, use the `EnumerateDirectories()`
    method, which retrieves an enumerable collection of directories that can be enumerated
    before the whole collection is returned. There are multiple overloads for the
    various search options.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建目录，可以使用`Create()`和`CreateSubdirectory()`方法。前者在其直接父目录存在时创建目录。后者创建一个子目录，以及必要时一直到根目录的所有其他子目录。要枚举目录，使用`EnumerateDirectories()`方法，它检索一个可枚举的目录集合，在整个集合返回之前可以枚举。有多个重载用于各种搜索选项。
- en: The three categories of streams in .NET are backing stores (streams that represent
    a source or destination of a sequence of bytes), decorators (streams that read
    or write data from or to another stream, transforming it in some way), and adapters
    (not actually streams, but wrappers that help us work with sources of data at
    a higher level than bytes).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中流的三个类别是后备存储（表示字节序列的源或目的地的流）、装饰器（从另一个流中读取或写入数据，以某种方式转换它）、适配器（实际上不是流，而是帮助我们以比字节更高级别的方式处理数据源的包装器）。
- en: The base class for streams in .NET is the `System.IO.Stream` class. This is
    an abstract class that provides methods and properties for reading from and writing
    to a stream. Many of these are abstract and are implemented in derived classes.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中流的基类是`System.IO.Stream`类。这是一个提供从流中读取和写入的方法和属性的抽象类。其中许多是抽象的，并在派生类中实现。
- en: By default, both `BinaryReader` and `BinaryWriter` handle strings using the
    UTF-8 encoding. However, they both have overloaded constructors that allow the
    specifying of another encoding using the `System.Text.Encoding` class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`BinaryReader`和`BinaryWriter`都使用UTF-8编码处理字符串。但是，它们都有重载的构造函数，允许使用`System.Text.Encoding`类指定另一个编码。
- en: The `XmlSerializer` class, from the `System.Xml.Serialization` namespace, can
    be used to serialize and deserialize data. `XmlSerializer` works by serializing
    to XML all the public properties and fields of a type. It uses some default settings,
    such as types becoming nodes, and properties and fields becoming elements. The
    name of a type, property, or field becomes the name of the node or element and
    the value of a field, or property, its text.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.Xml.Serialization`命名空间中的`XmlSerializer`类可用于序列化和反序列化数据。`XmlSerializer`通过将类型的所有公共属性和字段序列化为XML来工作。它使用一些默认设置，例如类型变为节点，属性和字段变为元素。类型、属性或字段的名称成为节点或元素的名称，字段或属性的值成为其文本。'
- en: The JSON serializer shipped with .NET Core is called `System.Text.Json`. For
    .NET Framework and .NET Standard projects, it is available as a NuGet package,
    with the same name. You can use the `JsonSerializer.Serialize()` static method
    to serialize data and the `JsonSerializer.Deserialize<T>()` static method to deserialize
    data. You can use specific attributes to control the serialization process. On
    the other hand, if you want more control over what is written or read, you can
    use the `Utf8JsonWriter` and `Utf8JsonReader` classes.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core附带的JSON序列化器称为`System.Text.Json`。对于.NET Framework和.NET Standard项目，它作为NuGet包提供，名称相同。您可以使用`JsonSerializer.Serialize()`静态方法来序列化数据，使用`JsonSerializer.Deserialize<T>()`静态方法来反序列化数据。您可以使用特定属性来控制序列化过程。另一方面，如果您想更多地控制写入或读取的内容，可以使用`Utf8JsonWriter`和`Utf8JsonReader`类。
- en: Chapter 14
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: The code that may potentially throw an exception must be put inside a `try`
    block.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能会引发异常的代码必须放在`try`块中。
- en: Inside the `catch` block, you may primarily want to try to recover the error.
    The recovery strategy may be very different and may vary from reporting a friendly
    error to the user to repeating the operation with different parameters. Logging
    is another typical operation done in the `catch` block.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`块中，您可能主要想尝试恢复错误。恢复策略可能非常不同，可能从向用户报告友好的错误到使用不同参数重复操作。记录是`catch`块中执行的另一个典型操作。
- en: The exception type specified in the `catch` block captures exceptions matching
    the same type or any derived types. For this reason, the ones lower in the hierarchy
    must be specified last. In any case, the C# compiler will generate an error whenever
    the order is not correct.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`块中指定的异常类型捕获与相同类型或任何派生类型匹配的异常。因此，层次结构中较低的异常必须最后指定。在任何情况下，如果顺序不正确，C#编译器将生成错误。
- en: By specifying the variable name in the `catch` statement, you get access to
    the exception object. It provides important information such as the message and
    other information that is very precious when logging an error. The exception object
    can also be used as the inner exception parameter when creating a new, more specific
    exception.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`catch`语句中指定变量名，您可以访问异常对象。它提供了诸如消息和其他信息的重要信息，在记录错误时非常宝贵。异常对象还可以在创建新的更具体的异常时用作内部异常参数。
- en: After examining the exception object, you may realize that you can't do anything
    to recover the operation. In this case, it is more appropriate to let the exception
    continue bouncing to the callers. This can be done with the use of the parameterless
    `throw` statement, or by creating and throwing a new exception by passing the
    exception object in the constructor.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查异常对象后，您可能会意识到无法对操作进行任何恢复。在这种情况下，更合适的是让异常继续传递给调用者。这可以通过使用无参数的`throw`语句来完成，或者通过在构造函数中传递异常对象来创建并抛出新异常。
- en: The `finally` block is used to declare a block of code that must be executed
    regardless of whether the code specified in the `try` block failed or completed
    successfully.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`块用于声明一个无论`try`块中指定的代码是失败还是成功都必须执行的代码块。'
- en: You can specify a `finally` block without `catch` whenever you don't need to
    be notified about the failure of the code inside the `try` block. The `finally`
    code will be executed in any case.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您不需要被通知`try`块内部代码的失败时，可以指定一个不带`catch`的`finally`块。`finally`代码将在任何情况下执行。
- en: First-chance exceptions represent the exceptions at a very early stage, as soon
    as they are thrown and before jumping to their handlers, if any. The debugger
    may stop at them, giving a more accurate indication about a potential bug.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次异常代表异常在非常早期阶段的情况，即它们被抛出并在跳转到其处理程序之前。调试器可能会在这些异常处停止，从而更准确地指示潜在的错误。
- en: The Visual Studio debugger allows us to select the first-chance exceptions we
    want to stop at. This can be done using the **Exception Settings** window.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio调试器允许我们选择我们想要在其中停止的首次异常。这可以通过**异常设置**窗口完成。
- en: The `UnhandledException` event is fired right before the application is going
    to crash. This event can be used to provide better advice to the user, to log
    the error, or even to automatically restart the application.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序即将崩溃之前触发`UnhandledException`事件。此事件可用于向用户提供更好的建议，记录错误，甚至自动重新启动应用程序。
- en: Chapter 15
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: By enabling the C# 8 nullable reference types feature and decorating the reference
    types in your code, you will dramatically reduce the occurrence of `NullReferenceException`
    exceptions in your code.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启用C# 8可空引用类型功能并在代码中装饰引用类型，您将大大减少代码中`NullReferenceException`异常的发生。
- en: The new succinct syntax to access the last item in an array is `[^1]`, which
    makes use of the `System.Index` type.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问数组中的最后一项的新简洁语法是`[^1]`，它利用了`System.Index`类型。
- en: In a switch expression, the discard (`_`) character is equivalent to `default`,
    which is typically used in the switch statement.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在switch表达式中，丢弃（`_`）字符等同于`default`，通常用于switch语句中。
- en: C# 8 introduced the asynchronous dispose feature to provide an asynchronous
    behavior when disposing resources. This way, we can await the asynchronous closing
    operation from the `DisposeAsync` method and avoid the danger of using the `Task.Wait`
    method inside `Dispose`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 8引入了异步处理特性，以在处理资源时提供异步行为。这样，我们可以等待`DisposeAsync`方法的异步关闭操作，避免在`Dispose`中使用`Task.Wait`方法的危险。
- en: The null coalescing assignment `??=` is used to avoid the execution of the code
    on the right side (in our example, the `GetOrders()` method) of the assignment
    when the left side (`orders`) is not null.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空合并赋值`??=`用于在左侧（在我们的示例中为`orders`）不为null时避免执行赋值右侧（`GetOrders()`方法）的代码。
- en: In order to be iterated with `async foreach`, a sequence must exhibit an asynchronous
    behavior that cannot be done using the `IEnumerable` and `IEnumerator` interfaces
    and their generic counterparts. The new `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>`
    interfaces were specifically designed to support the asynchronous behavior that
    is used by the `async foreach` statement.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够与“async foreach”一起迭代，一个序列必须表现出一种无法使用“IEnumerable”和“IEnumerator”接口及其通用对应项来完成的异步行为。新的“IAsyncEnumerable<T>”和“IAsyncEnumerator<T>”接口专门设计用于支持“async
    foreach”语句使用的异步行为。
- en: Chapter 16
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: The `global.json` file is used to determine which SDK will be used in a given
    directory tree. You can create this file in the solution root folder (or any parent
    folders) by using the `dotnet new globaljson` command and editing it manually
    to match one of the versions returned by the `dotnet --info` command.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`global.json`文件用于确定在给定目录树中将使用哪个SDK。您可以使用`dotnet new globaljson`命令在解决方案根文件夹（或任何父文件夹）中创建此文件，并手动编辑它以匹配`dotnet
    --info`命令返回的版本之一。'
- en: The `Path.Combine` method is the best way to concatenate paths on both Windows
    and Linux, both of which use different path separators. This method is also very
    convenient to avoid mistakes when concatenating relative paths and doubling or
    omitting the separators.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Path.Combine`方法是在Windows和Linux上连接路径的最佳方法，两者使用不同的路径分隔符。这种方法也非常方便，可以避免在连接相对路径时出现错误，并且可以避免重复或省略分隔符。'
- en: Libraries conforming to the .NET Standard specification are binary compatible
    with any framework supporting it. When you need to share code among different
    frameworks, verify which is the most recent version of .NET Standard supported
    by them and create a library that uses it. If the APIs you need to use are not
    supported by the required version of .NET Standard, you can change strategy and
    create separate libraries and package them together in a single NuGet package.
    The package manifest will need to associate each assembly to the specific framework,
    platform, or architecture the library can run on.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符合.NET Standard规范的库与支持它的任何框架都是二进制兼容的。当您需要在不同的框架之间共享代码时，请验证它们支持的最新版本的.NET Standard，并创建一个使用它的库。如果您需要使用的API不受所需版本的.NET
    Standard支持，您可以改变策略，创建单独的库，并将它们打包在一个单独的NuGet包中。包清单将需要将每个程序集与库可以运行的特定框架、平台或架构相关联。
- en: Thanks to the new project file format, it is now possible to copy the desired
    `PackageReference` tags from one project to another. This can also be done in
    Visual Studio when the solution is opened and, as soon as the file is saved, the
    NuGet packages will be restored automatically.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新的项目文件格式，现在可以从一个项目复制所需的“PackageReference”标签到另一个项目。当解决方案打开时，也可以在Visual Studio中执行此操作，并且一旦文件保存，NuGet包将自动恢复。
- en: After analyzing the architectural implications, the very first step is upgrading
    the current solution to the latest version of .NET Framework, at least version
    4.7.2.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分析了架构影响之后，第一步是将当前解决方案升级到最新版本的.NET Framework，至少是4.7.2版本。
- en: To minimize the startup time, .NET Core 3 offers two new publishing options.
    The first is **AOT** compilation, which immediately generates the assembly code,
    dramatically reducing the need for the **JIT** compiler. The second is enabling
    the **Quick JIT** compiler, which is used at runtime and is faster than the traditional
    **JIT** compiler, but generates less-optimized code.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最小化启动时间，.NET Core 3提供了两个新的发布选项。第一个是**AOT**编译，它立即生成程序集代码，大大减少了对**JIT**编译器的需求。第二个是启用**Quick
    JIT**编译器，它在运行时使用，比传统的**JIT**编译器更快，但生成的代码不太优化。
- en: Chapter 17
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: Unit testing is a type of software testing where individual units of code are
    tested in order to validate whether they are working as they were designed to
    work. Unit testing helps to identify and fix bugs early in the development cycle,
    therefore helping to save time and money. It helps developers to better understand
    the code and allows them to make changes easier. It helps with code reuse by requiring
    the code to be more modular in order to test it better. It can act as project
    documentation. It also helps with debugging because when tests fail, only the
    latest changes need to be checked and debugged.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是一种软件测试类型，其中测试单个代码单元，以验证它们是否按照设计要求工作。单元测试有助于在开发周期的早期识别和修复错误，因此有助于节省时间和金钱。它有助于开发人员更好地理解代码，并允许他们更容易地进行更改。它通过要求代码更模块化来帮助代码重用。它可以作为项目文档。它还有助于调试，因为当测试失败时，只需要检查和调试最新的更改。
- en: Visual Studio tools for unit testing are the **Test Explorer** (where you can
    view, run, debug, and analyze tests), the Microsoft unit testing framework for
    managed code, code coverage tools (which determine the amount of code that unit
    tests are covering), and the Microsoft Fakes isolation framework (which allows
    you to create substitutes for classes and methods).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于单元测试的Visual Studio工具包括**Test Explorer**（您可以在其中查看、运行、调试和分析测试）、用于托管代码的Microsoft单元测试框架、代码覆盖工具（确定单元测试覆盖的代码量）和Microsoft
    Fakes隔离框架（允许您为类和方法创建替代品）。
- en: The **Test Explorer** in Visual Studio allows you to view available unit tests,
    grouped by different levels (projects, classes, and so on). You can run and debug
    the unit tests from the **Test Explorer**, and you can view the results from their
    execution.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio中的**Test Explorer**允许您查看可用的单元测试，按不同级别（项目、类等）分组。您可以从**Test Explorer**运行和调试单元测试，并查看它们的执行结果。
- en: To specify that a class contains unit tests, you must decorate it with the `TestClass`
    attribute. Methods containing unit tests must be decorated with the `TestMethod`
    attribute.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指定一个类包含单元测试，必须使用`TestClass`属性对其进行修饰。包含单元测试的方法必须使用`TestMethod`属性进行修饰。
- en: The class to use for performing assertions is called `Assert` and is available
    in the `Microsoft.VisualStudio.TestTools.UnitTesting` namespace. It contains many
    static methods, such as `AreEqual()`, `AreNotEqual()`, `IsTrue()`, `IsFalse()`,
    `AreSame()`, `AreNotSame()`, `IsNull()`, and `IsNotNull()`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于执行断言的类称为`Assert`，并且位于`Microsoft.VisualStudio.TestTools.UnitTesting`命名空间中。它包含许多静态方法，例如`AreEqual()`、`AreNotEqual()`、`IsTrue()`、`IsFalse()`、`AreSame()`、`AreNotSame()`、`IsNull()`和`IsNotNull()`。
- en: Code coverage can be determined based on the available unit tests from the **Test
    Explorer** or from the **Test** top-level menu. The results are available in the
    **Code Coverage Results** pane.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率可以根据**测试资源管理器**或**测试**顶级菜单中的可用单元测试来确定。结果可在**代码覆盖率结果**窗格中查看。
- en: You can provide fixtures that execute once per class by providing methods decorated
    with the `ClassInitialize` and the `ClassCleanup` attributes. The former executes
    once per class before all the tests are executed, and the latter once after all
    the tests are executed. For fixtures that execute before and after each unit test,
    you must provide methods decorated with the `TestInitialize` and `TestCleanup`
    attributes.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过提供使用`ClassInitialize`和`ClassCleanup`属性修饰的方法来提供每个类执行一次的固定装置。前者在执行所有测试之前每个类执行一次，后者在执行所有测试之后执行一次。对于在每个单元测试之前和之后执行的固定装置，您必须提供使用`TestInitialize`和`TestCleanup`属性修饰的方法。
- en: Data-driven unit testing means writing unit tests that fetch testing data from
    an external source (such as a file or a database). The test method is then executed
    once for each row in the data source.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据驱动的单元测试意味着编写从外部源（如文件或数据库）获取测试数据的单元测试。然后，测试方法针对数据源中的每一行执行一次。
- en: The `DynamicData` attribute allows you to specify a method or property of the
    unit testing class as the source of data. The `DataSource` attribute allows you
    to specify an external source of data.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DynamicData`属性允许您指定单元测试类的方法或属性作为数据源。`DataSource`属性允许您指定外部数据源。'
- en: The external sources of data supported by the Microsoft unit testing framework
    for data-driven tests are SQL databases, CSV files, Excel documents, and XML documents.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Microsoft单元测试框架支持的数据驱动测试的外部数据源包括SQL数据库、CSV文件、Excel文档和XML文档。
