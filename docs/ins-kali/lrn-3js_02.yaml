- en: Chapter 2. Basic Components That Make Up a Three.js Scene
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。构成Three.js场景的基本组件
- en: 'In the previous chapter, you learned the basics of Three.js. We showed a couple
    of examples, and you created your first complete Three.js scene. In this chapter,
    we''ll dive a bit deeper into Three.js and explain the basic components that make
    up a Three.js scene. In this chapter, you''ll explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Three.js的基础知识。我们展示了一些例子，您创建了您的第一个完整的Three.js场景。在本章中，我们将深入了解Three.js，并解释构成Three.js场景的基本组件。在本章中，您将探索以下主题：
- en: The components that are used in a Three.js scene
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js场景中使用的组件
- en: What you can do with the `THREE.Scene` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`THREE.Scene`对象做什么
- en: How geometries and meshes are related
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何体和网格之间的关系
- en: The difference between the orthographic and perspective cameras
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交相机和透视相机之间的区别
- en: We start with looking at how you can create a scene and add objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下如何创建一个场景并添加对象。
- en: Creating a scene
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个场景
- en: 'In the previous chapter, you created `THREE.Scene`, so you already know the
    basics of Three.js. We saw that for a scene to show anything, we need three types
    of components:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您创建了`THREE.Scene`，所以您已经了解了Three.js的基础知识。我们看到，为了让场景显示任何内容，我们需要三种类型的组件：
- en: '| Component | Description |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Camera | This determines what is rendered on the screen. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 相机 | 这决定了屏幕上的渲染内容。 |'
- en: '| Lights | These have an effect on how materials are shown and used when creating
    shadow effects (discussed in detail in [Chapter 3](ch03.html "Chapter 3. Working
    with the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*). |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 灯光 | 这些对材质的显示和创建阴影效果有影响（在[第3章](ch03.html "第3章。在Three.js中使用不同的光源")中详细讨论，“在Three.js中使用不同的光源”）。
    |'
- en: '| Objects | These are the main objects that are rendered from the perspective
    of the camera: cubes, spheres, and the like. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 这些是从相机的透视角度渲染的主要对象：立方体、球体等。 |'
- en: '`THREE.Scene` serves as the container for all these different objects. This
    object itself doesn''t have that many options and functions.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene`作为所有这些不同对象的容器。这个对象本身并没有太多的选项和功能。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`THREE.Scene` is a structure that is sometimes also called a scene graph. A
    scene graph is a structure that can hold all necessary information of a graphical
    scene. In Three.js, this means that `THREE.Scene` contains all the objects, lights,
    and other objects necessary for rendering. What is interesting to note is that
    a scene graph, as the name implies, isn''t just an array of objects; a scene graph
    consists of a set of nodes in a tree structure. Each object you can add to the
    scene in Three.js, and even `THREE.Scene` itself, extends from a base object named
    `THREE.Object3D`. A `THREE.Object3D` object can also have its own children, which
    you can use to create a tree of objects that Three.js will interpret and render.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene`是一种有时也被称为场景图的结构。场景图是一种可以容纳图形场景所有必要信息的结构。在Three.js中，这意味着`THREE.Scene`包含了所有渲染所需的对象、灯光和其他对象。有趣的是，需要注意的是，场景图并不只是对象的数组；场景图由树结构中的一组节点组成。在Three.js中，您可以添加到场景中的每个对象，甚至`THREE.Scene`本身，都是从名为`THREE.Object3D`的基本对象扩展而来。`THREE.Object3D`对象也可以有自己的子对象，您可以使用它们来创建一个Three.js将解释和渲染的对象树。'
- en: Basic functionality of a scene
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的基本功能
- en: 'The best way to explore the functionality of a scene is by looking at an example.
    In the source code for this chapter, you can find the `01-basic-scene.html` example.
    I''ll use this example to explain the various functions and options a scene has.
    When we open this example in the browser, the output will look somewhat like what''s
    shown in the next screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 探索场景功能的最佳方法是查看一个例子。在本章的源代码中，您可以找到`01-basic-scene.html`的例子。我将使用这个例子来解释场景具有的各种功能和选项。当我们在浏览器中打开这个例子时，输出将看起来有点像下一个截图中显示的内容：
- en: '![Basic functionality of a scene](graphics/2215OS_02_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](graphics/2215OS_02_01.jpg)'
- en: 'This looks pretty much like the examples we saw in the previous chapter. Even
    though the scene looks pretty empty, it already contains a couple of objects.
    Looking at the following source, we can see that we used the `scene.add(object)`
    function from the `THREE.Scene` object to add `THREE.Mesh` (the ground plane you
    see), `THREE.SpotLight`, and `THREE.AmbientLight`. The `THREE.Camera` object is
    added automatically by Three.js when you render the scene, but it is good practice
    to add it to the scene manually, especially when you''re working with multiple
    cameras. Take a look at the following source code for this scene:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像我们在上一章中看到的例子。即使场景看起来相当空，它已经包含了一些对象。从下面的源代码中可以看出，我们使用了`THREE.Scene`对象的`scene.add(object)`函数来添加`THREE.Mesh`（您看到的地面平面）、`THREE.SpotLight`和`THREE.AmbientLight`。当您渲染场景时，`THREE.Camera`对象会被Three.js自动添加，但是在使用多个相机时，手动将其添加到场景中是一个好的做法。查看下面这个场景的源代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before we look deeper into the `THREE.Scene` object, I''ll first explain what
    you can do in the demo, and after that, we''ll look at some code. Open the `01-basic-scene.html`
    example in your browser and look at the controls in the upper-right corner, as
    you can see in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究`THREE.Scene`对象之前，我将首先解释您可以在演示中做什么，之后我们将查看一些代码。在浏览器中打开`01-basic-scene.html`的例子，并查看右上角的控件，如下截图所示：
- en: '![Basic functionality of a scene](graphics/2215OS_02_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](graphics/2215OS_02_02.jpg)'
- en: 'With these controls, you can add a cube to the scene, remove the cube that
    was last added to the scene, and show all the current objects that the scene contains
    in the console of your browser. The last entry in the controls section shows the
    current number of objects in the scene. What you''ll probably notice when you
    start up the scene is that there are already four objects in the scene. These
    are the ground plane, the ambient light, and the spotlight, as well as the camera
    we mentioned earlier. We''ll look at each of the functions in the control section
    and start with the easiest one, `addCube`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些控件，你可以向场景中添加一个立方体，移除最后添加到场景中的立方体，并在浏览器的控制台中显示场景当前包含的所有对象。控件部分的最后一个条目显示了场景中对象的当前数量。当你启动场景时，你可能会注意到场景中已经有四个对象。这些是地面平面、环境光、聚光灯以及我们之前提到的摄像机。我们将查看控制部分中的每个功能，并从最简单的`addCube`开始：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This piece of code should already be pretty easy to read by now. Not many new
    concepts are introduced here. When you hit the **addCube** button, a new `THREE.BoxGeometry`
    object is created whose width, height, and depth are set to a random value between
    1 and 3\. Besides a random size, the cube also gets a random color and a random
    position.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段代码应该已经很容易阅读了。这里没有引入太多新概念。当你点击**addCube**按钮时，会创建一个新的`THREE.BoxGeometry`对象，其宽度、高度和深度设置为1到3之间的随机值。除了随机大小，立方体还会获得随机颜色和随机位置。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A new element that we introduce here is that we also give the cube a name using
    its `name` attribute. Its name is set to `cube-`, appended with the number of
    objects currently in the scene (`scene.children.length`). A name is very useful
    for debugging purposes but can also be used to directly access an object from
    your scene. If you use the `THREE.Scene.getObjectByName(name)` function, you can
    directly retrieve a specific object and, for instance, change its location without
    having to make the JavaScript object a global variable. You might wonder what
    the last line does. The `numberOfObjects` variable is used by our control GUI
    to list the number of objects in the scene. So, whenever we add or remove an object,
    we set this variable to the updated count.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入的一个新元素是，我们还使用其`name`属性为立方体命名。它的名称设置为`cube-`，后面跟着当前场景中的对象数量（`scene.children.length`）。名称对于调试非常有用，但也可以用于直接访问你场景中的对象。如果你使用`THREE.Scene.getObjectByName(name)`函数，你可以直接检索特定对象，并且例如，改变它的位置，而不必使JavaScript对象成为全局变量。你可能会想知道最后一行代码是做什么的。`numberOfObjects`变量被我们的控制GUI用来列出场景中的对象数量。因此，每当我们添加或移除一个对象时，我们都会将这个变量设置为更新后的计数。
- en: 'The next function we can call from the control GUI is `removeCube`. As the
    name implies, clicking on the **removeCube** button removes the last added cube
    from the scene. In code, it looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从控制GUI中调用的下一个函数是`removeCube`。顾名思义，点击**removeCube**按钮会从场景中移除最后添加的立方体。在代码中，它看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To add an object to the scene, we use the `add` function. To remove an object
    from the scene, we use, not very surprisingly, the `remove` function. Since Three.js
    stores its children as a list (new ones are added at the end), we can use the
    `children` property, which contains an array of all the objects in the scene,
    from the `THREE.Scene` object to get the last object that was added. We also need
    to check whether that object is a `THREE.Mesh` object to avoid removing the camera
    and the lights. After we've removed the object, we once again update the GUI property,
    `numberOfObjects`, that holds the number of objects in the scene.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要向场景中添加对象，我们使用`add`函数。要从场景中移除对象，我们使用，不太意外地，`remove`函数。由于Three.js将其子对象存储为列表（新对象添加到末尾），我们可以使用`children`属性，该属性包含场景中所有对象的数组，从`THREE.Scene`对象中获取最后添加的对象。我们还需要检查该对象是否是`THREE.Mesh`对象，以避免移除摄像机和灯光。在我们移除对象之后，我们再次更新GUI属性`numberOfObjects`，该属性保存了场景中对象的数量。
- en: 'The final button on our GUI is labeled **outputObjects**. You probably already
    clicked on this and nothing seemed to happen. This button prints out all the objects
    that are currently in our scene to the web browser console, as shown in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI上的最后一个按钮标有**outputObjects**。你可能已经点击过这个按钮，但似乎什么也没发生。这个按钮会将当前场景中的所有对象打印到网页浏览器控制台中，如下面的截图所示：
- en: '![Basic functionality of a scene](graphics/2215OS_02_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](graphics/2215OS_02_03.jpg)'
- en: 'The code to output information to the console log makes use of the built-in
    `console` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息输出到控制台日志的代码使用了内置的`console`对象：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is great for debugging purposes, and especially when you name your objects,
    it''s very useful to find issues and problems with a specific object in your scene.
    For instance, the properties of `cube-17` look like this (if you already know
    the name beforehand, you could also use `console.log(scene.getObjectByName("cube-17")`
    to output only that single object):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试非常有用，特别是当你给你的对象命名时，它非常有用，可以帮助你找到场景中特定对象的问题。例如，`cube-17`的属性看起来像这样（如果你事先知道名称，也可以使用`console.log(scene.getObjectByName("cube-17")`来仅输出单个对象）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Until now, we''ve seen the following scene-related functionality:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了以下与场景相关的功能：
- en: '`THREE.Scene.Add`: This adds an object to the scene'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.Add`：向场景中添加对象'
- en: '`THREE.Scene.Remove`: This removes an object from the scene'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.Remove`：从场景中移除对象'
- en: '`THREE.Scene.children`: This gets a list of all the children in the scene'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.children`：获取场景中所有子对象的列表'
- en: '`THREE.Scene.getObjectByName`: This gets a specific object, by name, from the
    scene'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.getObjectByName`：通过名称从场景中获取特定对象'
- en: These are the most important scene-related functions, and most often, you won't
    need any more than this. There are, however, a couple of helper functions that
    could come in handy, and I'd like to show them based on the code that handles
    the cube rotation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最重要的与场景相关的功能，通常情况下，你不会需要更多。然而，还有一些辅助功能可能会派上用场，我想根据处理立方体旋转的代码来展示它们。
- en: 'As you saw in the previous chapter, we used a *render loop* to render the scene.
    Let''s look at that loop for this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中看到的，我们使用了*渲染循环*来渲染场景。让我们看看这个示例的循环：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we see the `THREE.Scene.traverse()` function being used. We can pass a
    function to the `traverse()` function that will be called for each child of the
    scene. If a child itself has children, remember that a `THREE.Scene` object can
    contain a tree of objects. The `traverse()` function will also be called for all
    the children of that object. You traverse through the complete scene graph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了使用`THREE.Scene.traverse()`函数。我们可以将一个函数传递给`traverse()`函数，该函数将对场景的每个子对象调用。如果子对象本身有子对象，请记住`THREE.Scene`对象可以包含一个对象树。`traverse()`函数也将对该对象的所有子对象调用。您可以遍历整个场景图。
- en: We use the `render()` function to update the rotation for each of the cubes
    (note that we explicitly ignore the ground plane). We could also have done this
    by iterating ourselves over the `children` property array using a `for` loop since
    we've only added objects to `THREE.Scene` and haven't created a nested structure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`render()`函数来更新每个立方体的旋转（请注意，我们明确忽略了地面平面）。我们也可以通过使用`for`循环迭代`children`属性数组来自己完成这个操作，因为我们只是将对象添加到了`THREE.Scene`中，并没有创建嵌套结构。
- en: 'Before we dive into the details of `THREE.Mesh` and `THREE.Geometry`, I''d
    like to show two interesting properties that you can set on the `THREE.Scene`
    object: `fog` and `overrideMaterial`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论`THREE.Mesh`和`THREE.Geometry`的细节之前，我想展示一下可以在`THREE.Scene`对象上设置的两个有趣的属性：`fog`和`overrideMaterial`。
- en: Adding fog to the scene
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加雾效
- en: 'The **fog** property lets you add a fog effect to the complete scene; the farther
    off an object is, the more it will be hidden from sight, as shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fog`属性可以向整个场景添加雾效果；物体离得越远，就会越隐匿不见，如下面的截图所示：
- en: '![Adding fog to the scene](graphics/2215OS_02_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加雾效](graphics/2215OS_02_04.jpg)'
- en: 'Enabling fog is really easy in Three.js. Just add the following line of code
    after you''ve defined your scene:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中启用雾效果非常简单。只需在定义场景后添加以下代码行：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we define a white fog (`0xffffff`). The preceding two properties can
    be used to tune how the mist appears. The `0.015` value sets the `near` property,
    and the `100` value sets the `far` property. With these properties, you can determine
    where the mist starts and how fast it gets denser. With the `THREE.Fog` object,
    the fog increases linearly. There is also a different way to set the mist for
    the scene; for this, use the following definition:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个白色的雾（`0xffffff`）。前两个属性可以用来调整雾的外观。`0.015`值设置了`near`属性，`100`值设置了`far`属性。使用这些属性，您可以确定雾从哪里开始以及它变得多快密。使用`THREE.Fog`对象，雾是线性增加的。还有一种不同的设置场景雾的方法；为此，请使用以下定义：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, we don't specify `near` and `far`, but just the color (`0xffffff`)
    and the mist's density (`0.01`). It's best to experiment a bit with these properties
    to get the effect you want. Note that with `THREE.FogExp2`, the fog doesn't increase
    linearly but grows exponentially denser with the distance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不指定`near`和`far`，而只指定颜色（`0xffffff`）和雾的密度（`0.01`）。最好稍微尝试一下这些属性，以获得想要的效果。请注意，使用`THREE.FogExp2`时，雾不是线性增加的，而是随着距离呈指数增长。
- en: Using the overrideMaterial property
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用overrideMaterial属性
- en: The last property we discuss for the scene is **overrideMaterial**. When you
    use this property, all the objects in the scene will use the material that is
    set to the `overrideMaterial` property and ignore the material that is set on
    the object itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论场景的最后一个属性是`overrideMaterial`。当使用此属性时，场景中的所有对象将使用设置为`overrideMaterial`属性的材质，并忽略对象本身设置的材质。
- en: 'Use it like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用它：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon using the `overrideMaterial` property as shown in the preceding code,
    the scene will be rendered as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中使用`overrideMaterial`属性后，场景将呈现如下截图所示：
- en: '![Using the overrideMaterial property](graphics/2215OS_02_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用overrideMaterial属性](graphics/2215OS_02_05.jpg)'
- en: In the preceding figure, you can see that all the cubes are rendered using the
    same material and the same color. In this example, we used a `THREE.MeshLambertMaterial`
    object as the material. With this material type, we can create non-shiny-looking
    objects that respond to the lights that are present in the scene. In [Chapter
    4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working with Three.js
    Materials*, you'll learn more about this material.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到所有的立方体都使用相同的材质和颜色进行渲染。在这个示例中，我们使用了`THREE.MeshLambertMaterial`对象作为材质。使用这种材质类型，我们可以创建看起来不那么闪亮的对象，这些对象会对场景中存在的灯光做出响应。在[第4章](ch04.html
    "第4章。使用Three.js材质")中，*使用Three.js材质*，您将了解更多关于这种材质的信息。
- en: 'In this section, we looked at the first of the core concepts of Three.js: `THREE.Scene`.
    The most important thing to remember about the scene is that it is basically a
    container for all the objects, lights, and cameras you want to use when rendering.
    The following table summarizes the most important functions and attributes of
    the `THREE.Scene` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了Three.js的核心概念之一：`THREE.Scene`。关于场景最重要的一点是，它基本上是一个容器，用于渲染时要使用的所有对象、灯光和相机。以下表格总结了`THREE.Scene`对象的最重要的函数和属性：
- en: '| Function/Property | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 函数/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add(object)` | This is used to add an object to the scene. You can also
    use this function, as we''ll see later on, to create groups of objects. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `add(object)` | 用于将对象添加到场景中。您还可以使用此函数，正如我们稍后将看到的，来创建对象组。 |'
- en: '| `children` | This returns a list of all the objects that have been added
    to the scene, including the camera and lights. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `children` | 返回已添加到场景中的所有对象的列表，包括相机和灯光。 |'
- en: '| `getObjectByName(name, recursive)` | When you create an object, you can give
    it a distinct name. The scene object has a function that you can use to directly
    return an object with a specific name. If you set the recursive argument to `true`,
    Three.js will also search through the complete tree of objects to find the object
    with the specified name. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `getObjectByName(name, recursive)` | 当您创建一个对象时，可以为其指定一个独特的名称。场景对象具有一个函数，您可以使用它直接返回具有特定名称的对象。如果将recursive参数设置为`true`，Three.js还将搜索整个对象树以找到具有指定名称的对象。'
- en: '| `remove(object)` | If you have a reference to an object in the scene, you
    can also remove it from the scene using this function. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `remove(object)` | 如果您有场景中对象的引用，也可以使用此函数将其从场景中移除。 |'
- en: '| `traverse(function)` | The children property returns a list of all the children
    in the scene. With the traverse function, we can also access these children. With
    traverse, all the children are passed in to the supplied function one by one.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `traverse(function)` | children属性返回场景中所有子对象的列表。使用traverse函数，我们也可以访问这些子对象。通过traverse，所有子对象都会逐个传递给提供的函数。
    |'
- en: '| `fog` | This property allows you to set the fog for the scene. The fog will
    render a haze that hides faraway objects. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 此属性允许您为场景设置雾。雾会渲染出一个隐藏远处物体的薄雾。 |'
- en: '| `overrideMaterial` | With this property, you can force all the objects in
    the scene to use the same material. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `overrideMaterial` | 使用此属性，您可以强制场景中的所有对象使用相同的材质。 |'
- en: In the next section, we'll take a closer look at the objects that you can add
    to the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地了解您可以添加到场景中的对象。
- en: Geometries and meshes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何图形和网格
- en: 'In each of the examples until now, you''ve seen geometries and meshes being
    used. For instance, to add a sphere to the scene, we did the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每个示例中，您都看到了使用几何图形和网格。例如，要将一个球体添加到场景中，我们做了以下操作：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We defined the shape of the object and its geometry (`THREE.SphereGeometry`),
    we defined what this object looks like (`THREE.MeshBasicMaterial`) and its material,
    and we combined these two in a mesh (`THREE.Mesh`) that can be added to a scene.
    In this section, we'll take a closer look at what a geometry is and what a mesh
    is. We'll start with the geometry.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了对象的形状和其几何图形（`THREE.SphereGeometry`），我们定义了这个对象的外观（`THREE.MeshBasicMaterial`）和其材质，并将这两者组合成一个网格（`THREE.Mesh`），可以添加到场景中。在本节中，我们将更详细地了解几何图形和网格是什么。我们将从几何图形开始。
- en: The properties and functions of a geometry
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何图形的属性和函数
- en: 'Three.js comes with a large set of geometries out of the box that you can use
    in your 3D scene. Just add a material, create a mesh, and you''re pretty much
    done. The following screenshot, from example `04-geometries`, shows a couple of
    the standard geometries available in Three.js:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js自带了一大堆可以在3D场景中使用的几何图形。只需添加一个材质，创建一个网格，基本上就完成了。以下截图来自示例`04-geometries`，显示了Three.js中可用的一些标准几何图形：
- en: '![The properties and functions of a geometry](graphics/2215OS_02_06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![几何图形的属性和函数](graphics/2215OS_02_06.jpg)'
- en: In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 6](ch06.html "Chapter 6. Advanced Geometries
    and Binary Operations"), *Advanced Geometries and Binary Operations*, we'll explore
    all the basic and advanced geometries that Three.js has to offer. For now, we'll
    look in greater detail at what a geometry actually is.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。学习使用几何图形")和[第6章](ch06.html "第6章。高级几何图形和二进制操作")中，我们将探索Three.js提供的所有基本和高级几何图形。现在，我们将更详细地了解几何图形的实际含义。
- en: 'A geometry in Three.js, and in most other 3D libraries, is basically a collection
    of points in a 3D space, also called vertices, and a number of faces connecting
    those points together. Take, for example, a cube:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，以及大多数其他3D库中，几何图形基本上是3D空间中点的集合，也称为顶点，以及连接这些点的一些面。例如，一个立方体：
- en: A cube has eight corners. Each of these corners can be defined as an *x*, *y*,
    and *z* coordinate. So each cube has eight points in a 3D space. In Three.js,
    these points are called vertices, and a single one is called a vertex.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立方体有八个角。每个角可以定义为*x*、*y*和*z*坐标。因此，每个立方体在3D空间中有八个点。在Three.js中，这些点被称为顶点，单个点被称为顶点。
- en: A cube has six sides, with a vertex at each corner. In Three.js, a face always
    consists of three vertices that make a triangle. So, in the case of a cube, each
    side consists of two triangles to make the complete side.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立方体有六个面，每个角有一个顶点。在Three.js中，一个面始终由三个顶点组成一个三角形。因此，在立方体的情况下，每个面由两个三角形组成，以形成完整的面。
- en: 'When you use one of the geometries provided by Three.js, you don''t have to
    define all the vertices and faces yourself. For a cube, you only need to define
    the width, height, and depth. Three.js uses that information and creates a geometry
    with eight vertices at the correct position and the correct number of faces (12
    in the case of a cube). Even though you''d normally use the geometries provided
    by Three.js or generate them automatically, you can still create geometries completely
    by hand using vertices and faces. This is shown in the following lines of code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Three.js提供的几何图形之一时，您不必自己定义所有顶点和面。对于一个立方体，您只需要定义宽度、高度和深度。Three.js使用这些信息，在正确的位置创建一个具有八个顶点和正确数量的面（在立方体的情况下为12个）的几何图形。即使您通常会使用Three.js提供的几何图形或自动生成它们，您仍然可以使用顶点和面完全手工创建几何图形。以下代码行显示了这一点：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code shows how to create a simple cube. We define the points that make
    up this cube in the `vertices` array. These points are connected to create triangular
    faces and are stored in the `faces` array. For instance, `new THREE.Face3(0,2,1)`
    creates a triangular face using the points `0`, `2`, and `1` from the `vertices`
    array. Note that you have to take care of the sequence of the vertices used to
    create `THREE.Face`. The order in which they are defined determines whether Three.js
    thinks it is a front-facing face (a face facing the camera) or a back-facing face.
    If you create the faces, you should use a clockwise sequence for front-facing
    faces and a counterclockwise sequence if you want to create a back-facing face.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何创建一个简单的立方体。我们在`vertices`数组中定义了构成这个立方体的点。这些点连接在一起形成三角形面，并存储在`faces`数组中。例如，`new
    THREE.Face3(0,2,1)`使用`vertices`数组中的点`0`、`2`和`1`创建了一个三角形面。请注意，你必须注意用于创建`THREE.Face`的顶点的顺序。定义它们的顺序决定了Three.js认为它是一个正面面（面向摄像机的面）还是一个背面面。如果你创建面，应该对正面面使用顺时针顺序，对背面面使用逆时针顺序。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this example, we used a `THREE.Face3` element to define the six sides of
    the cube, with two triangles for each face. In previous versions of Three.js,
    you could also use a quad instead of a triangle. A quad uses four vertices instead
    of three to define the face. Whether using quads or triangles is better is a heated
    debate raging in the 3D modeling world. Basically though, using quads is often
    preferred during modeling since they can be more easily enhanced and smoothed
    than triangles. For render and game engines though, working with triangles is
    often easier since every shape can be rendered very efficiently as a triangle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`THREE.Face3`元素来定义立方体的六个面，每个面有两个三角形。在Three.js的早期版本中，你也可以使用四边形而不是三角形。四边形使用四个顶点而不是三个来定义面。在3D建模世界中，使用四边形还是三角形更好是一个激烈的争论。基本上，使用四边形在建模过程中通常更受欢迎，因为它们比三角形更容易增强和平滑。然而，在渲染和游戏引擎中，使用三角形通常更容易，因为每个形状都可以被渲染为三角形。
- en: Using these vertices and faces, we can now create a new instance of `THREE.Geometry`
    and assign the vertices to the `vertices` attribute and the faces to the `faces`
    attribute. The last step that we need to take is call `computeFaceNormals()` on
    the geometry we created. When we call this function, Three.js determines the *normal*
    vector for each of the faces. This is the information Three.js uses to determine
    how to color the faces based on the various lights in the scene.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些顶点和面，我们现在可以创建一个`THREE.Geometry`的新实例，并将顶点分配给`vertices`属性，将面分配给`faces`属性。我们需要采取的最后一步是在我们创建的几何形状上调用`computeFaceNormals()`。当我们调用这个函数时，Three.js确定了每个面的*法向*向量。这是Three.js用来根据场景中的各种光源确定如何给面上色的信息。
- en: 'With this geometry, we can now create a mesh just as we saw earlier. I''ve
    created an example that you can use to play around with the position of the vertices,
    and which also shows the individual faces. In example `05-custom-geometry`, you
    can change the position of all the vertices of a cube and see how the faces react.
    This is shown in the following screenshot (should the control GUI be in the way,
    you can hide it by pressing *H*):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个几何形状，我们现在可以创建一个网格，就像我们之前看到的那样。我创建了一个例子，你可以用来玩弄顶点的位置，并显示各个面。在例子`05-custom-geometry`中，你可以改变立方体所有顶点的位置，看看面的反应。下面是一个截图（如果控制GUI挡住了视线，你可以通过按下*H*键来隐藏它）：
- en: '![The properties and functions of a geometry](graphics/2215OS_02_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![几何形状的属性和函数](graphics/2215OS_02_07.jpg)'
- en: 'This example, which uses the same setup as all our other examples, has a render
    loop. Whenever you change one of the properties in the drop-down control box,
    the cube is rendered based on the changed position of one of the vertices. This
    isn''t something that works out of the box. For performance reasons, Three.js
    assumes that the geometry of a mesh won''t change during its lifetime. For most
    geometries and use cases, this is a very valid assumption. To get our example
    to work, however, we need to make sure the following is added to the code in the
    render loop:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了与我们其他例子相同的设置，有一个渲染循环。每当你改变下拉控制框中的属性时，立方体就会根据一个顶点的改变位置进行渲染。这并不是一件轻而易举的事情。出于性能原因，Three.js假设网格的几何形状在其生命周期内不会改变。对于大多数的几何形状和用例来说，这是一个非常合理的假设。然而，为了让我们的例子工作，我们需要确保以下内容被添加到渲染循环的代码中：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first line, we point the vertices of the mesh you see on screen to an
    array of updated vertices. We don't need to reconfigure the faces since they are
    still connected to the same points as they were before. After we've set the updated
    vertices, we need to tell the geometry that the vertices need to be updated. We
    do this by setting the `verticesNeedUpdate` property of the geometry to `true`.
    Finally, we do a recalculation of the faces to update the complete model using
    the `computeFaceNormals` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们将屏幕上看到的网格的顶点指向一个更新后的顶点数组。我们不需要重新配置面，因为它们仍然连接到与之前相同的点。设置更新后的顶点后，我们需要告诉几何形状顶点需要更新。我们通过将几何形状的`verticesNeedUpdate`属性设置为`true`来做到这一点。最后，我们通过`computeFaceNormals`函数对面进行重新计算，以更新完整的模型。
- en: 'The last geometry functionality we''ll look at is the `clone()` function. We
    mentioned that the geometry defines the form and shape of an object, and combined
    with a material, we create an object that can be added to the scene to be rendered
    by Three.js. With the `clone()` function, as the name implies, we can make a copy
    of the geometry, and for instance, use it to create a different mesh with a different
    material. In the same example, `05-custom-geometry`, you can see a **clone** button
    at the top of the control GUI, as can be seen in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个几何功能是`clone()`函数。我们提到几何图形定义了对象的形状和形状，结合材质，我们创建了一个可以添加到场景中由Three.js渲染的对象。使用`clone()`函数，正如其名称所示，我们可以复制几何图形，并且例如，使用它来创建一个具有不同材质的不同网格。在相同的示例`05-custom-geometry`中，你可以在控制GUI的顶部看到一个**clone**按钮，如下面的截图所示：
- en: '![The properties and functions of a geometry](graphics/2215OS_02_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![几何图形的属性和函数](graphics/2215OS_02_08.jpg)'
- en: 'If you click on this button, a clone (a copy) will be made of the geometry
    as it currently is, a new object is created with a different material, and it
    is added to the scene. The code for this is rather simple but is made a bit more
    complex because of the materials I used. Let''s take a step back and first look
    at how the green material for the cube was created, as shown in the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个按钮，将会克隆（复制）当前的几何图形，创建一个新的对象并添加到场景中。这段代码相当简单，但由于我使用的材质而变得有些复杂。让我们退一步，首先看一下立方体的绿色材质是如何创建的，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, I didn't use a single material, but I used an array of two materials.
    The reason is that besides showing a transparent green cube, I also wanted to
    show you the wireframe since that shows up very clearly where the vertices and
    faces are located.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我并没有使用单一的材质，而是使用了一个包含两种材质的数组。原因是除了显示一个透明的绿色立方体，我还想向你展示线框，因为线框非常清楚地显示了顶点和面的位置。
- en: 'Three.js, of course, supports using multiple materials when creating a mesh.
    You can use the `SceneUtils.createMultiMaterialObject` function for this, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建网格时，Three.js当然支持使用多种材质。你可以使用`SceneUtils.createMultiMaterialObject`函数来实现这一点，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What Three.js does in this function is that it doesn''t create one `THREE.Mesh`
    object, but it creates one for each material you specified and puts these meshes
    in a group (a `THREE.Object3D` object). This group can be used in the same manner
    as you''ve used the scene object. You can add meshes, get objects by name, and
    so on. For instance, to make sure all the children of the group cast shadows,
    you do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在这里所做的是不仅创建一个`THREE.Mesh`对象，而是为你指定的每种材质创建一个，并将这些网格放在一个组中（一个`THREE.Object3D`对象）。这个组可以像你使用场景对象一样使用。你可以添加网格，通过名称获取对象等。例如，为了确保组的所有子对象都投射阴影，你可以这样做：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s get back to the `clone()` function we were discussing:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们正在讨论的`clone()`函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This piece of JavaScript is called when the **clone** button is clicked on.
    Here, we clone the geometry of the first child of our cube. Remember, the mesh
    variable contains two children; it contains two meshes, one for each material
    we specified. Based on this cloned geometry, we create a new mesh, aptly named
    `mesh2`. We move this new mesh using translate functions (more on this in [Chapter
    5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning to Work
    with Geometries*), remove the previous clone (if present), and add the clone to
    the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**clone**按钮时，将调用这段JavaScript代码。在这里，我们克隆了我们的立方体的第一个子对象的几何图形。记住，网格变量包含两个子对象；它包含两个网格，一个用于我们指定的每种材质。基于这个克隆的几何图形，我们创建一个新的网格，恰当地命名为`mesh2`。我们使用平移函数移动这个新的网格（关于这一点我们将在[第5章](ch05.html
    "第5章。学习使用几何图形")中详细讨论），移除之前的克隆（如果存在），并将克隆添加到场景中。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In the previous section, we used `createMultiMaterialObject` from the `THREE.SceneUtils`
    object to add a wireframe to the geometry we created. Three.js also provides an
    alternative way of adding a wireframe using `THREE.WireFrameHelper`. To use this
    helper, first instantiate the helper like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用了`THREE.SceneUtils`对象的`createMultiMaterialObject`来为我们创建的几何图形添加线框。Three.js还提供了另一种使用`THREE.WireFrameHelper`添加线框的方法。要使用这个辅助程序，首先要像这样实例化辅助程序：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You provide the mesh you want to show the wireframe for and the color of the
    wireframe. Three.js will now create a helper object that you can add to the scene,
    `scene.add(helper)`. Since this helper internally is just a `THREE.Line` object,
    you can style how the wireframe appears. For instance, to set the width of the
    wireframe lines, use `helper.material.linewidth = 2;`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '你提供你想要显示线框的网格和线框的颜色。Three.js现在将创建一个你可以添加到场景中的辅助对象，`scene.add(helper)`。由于这个辅助对象内部只是一个`THREE.Line`对象，你可以设置线框的外观。例如，要设置线框线的宽度，使用`helper.material.linewidth
    = 2;`。 '
- en: That's enough on geometries for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于几何图形的内容就到此为止。
- en: Functions and attributes for meshes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格的函数和属性
- en: 'We''ve already learned that to create a mesh, we need a geometry and one or
    more materials. Once we have a mesh, we add it to the scene and it''s rendered.
    There are a couple of properties that you can use to change where and how this
    mesh appears on the scene. In this first example, we''ll look at the following
    set of properties and functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了创建网格时需要一个几何图形和一个或多个材质。一旦我们有了网格，我们将其添加到场景中并进行渲染。有一些属性可以用来改变这个网格在场景中的位置和外观。在这个第一个示例中，我们将看到以下一组属性和函数：
- en: '| Function/Property | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 功能/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `position` | This determines the position of this object relative to the
    position of its parent. Most often, the parent of an object is a `THREE.Scene`
    object or a `THREE.Object3D` object. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这确定了这个对象相对于其父对象位置的位置。大多数情况下，对象的父对象是一个`THREE.Scene`对象或一个`THREE.Object3D`对象。
    |'
- en: '| `rotation` | With this property, you can set the rotation of an object around
    any of its axes. Three.js also provides specific functions for rotations around
    an axis: `rotateX()`, `rotateY()`, and `rotateZ()`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `rotation` | 通过这个属性，您可以设置对象围绕任意轴的旋转。Three.js还提供了围绕轴旋转的特定函数：`rotateX()`、`rotateY()`和`rotateZ()`。
    |'
- en: '| `scale` | This property allows you to scale the object around its *x*, *y*,
    and *z* axes. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `scale` | 这个属性允许您沿着*x*、*y*和*z*轴缩放对象。 |'
- en: '| `translateX(amount)` | This property moves the object the specified amount
    over the *x* axis. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `translateX(amount)` | 这个属性将对象沿着*x*轴移动指定的距离。 |'
- en: '| `translateY(amount)` | This property moves the object the specified amount
    over the *y* axis. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `translateY(amount)` | 这个属性将对象沿着*y*轴移动指定的距离。 |'
- en: '| `translateZ(amount)` | This property moves the object the specified amount
    over the *z* axis.For the translate functions, you could also use the `translateOnAxis(axis,
    distance)` function, which allows you to translate the mesh a distance along a
    specific axis. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `translateZ(amount)` | 这个属性将对象沿着*z*轴移动指定的距离。对于平移函数，您还可以使用`translateOnAxis(axis,
    distance)`函数，它允许您沿着特定轴平移网格一定距离。'
- en: '| `visible` | If you set this property to `false`, `THREE.Mesh` won''t be rendered
    by Three.js. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果将此属性设置为`false`，`THREE.Mesh`将不会被Three.js渲染。 |'
- en: 'As always, we have an example ready for you that will allow you to play around
    with these properties. If you open up `06-mesh-properties.html` in your browser,
    you get a drop-down menu where you can alter all these properties and directly
    see the result, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们为您准备了一个示例，让您可以尝试这些属性。如果您在浏览器中打开`06-mesh-properties.html`，您将获得一个下拉菜单，您可以在其中改变所有这些属性，并直接看到结果，如下面的截图所示：
- en: '![Functions and attributes for meshes](graphics/2215OS_02_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](graphics/2215OS_02_09.jpg)'
- en: 'Let me walk you through them, and I''ll start with the position property. We''ve
    already seen this property a couple of times, so let''s quickly address this.
    With this property, you set the *x*, *y*, and *z* coordinates of the object. This
    position is relative to its parent object, which is normally the scene you add
    the object to, but could also be a `THREE.Object3D` object or another `THREE.Mesh`
    object. We''ll get back to this in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, when we look at
    grouping objects. We can set an object''s position property in three different
    ways. We can set each coordinate directly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带您了解一下，我将从位置属性开始。我们已经看到这个属性几次了，所以让我们快速解决这个问题。通过这个属性，您可以设置对象的*x*、*y*和*z*坐标。这个位置是相对于其父对象的，通常是您将对象添加到的场景，但也可以是`THREE.Object3D`对象或另一个`THREE.Mesh`对象。当我们查看分组对象时，我们将在[第5章](ch05.html
    "第5章。学习使用几何图形")中回到这一点，*学习使用几何图形*。我们可以以三种不同的方式设置对象的位置属性。我们可以直接设置每个坐标：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, we can also set all of them at once, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以一次性设置它们所有，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is also a third option. The `position` property is a `THREE.Vector3`
    object. That means, we can also do the following to set this object:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三个选项。`position`属性是一个`THREE.Vector3`对象。这意味着，我们也可以这样设置这个对象：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I want to make a quick sidestep before looking at the other properties of this
    mesh. I mentioned that this position is set relative to the position of its parent.
    In the previous section on `THREE.Geometry`, we used `THREE.SceneUtils.createMultiMaterialObject`
    to create a multi-material object. I explained that this doesn't really return
    a single mesh but a group that contains a mesh based on the same geometry for
    each material; in our case, it's a group that contains two meshes. If we change
    the position of one of these meshes that is created, you can clearly see that
    it really is two distinct `THREE.Mesh` objects. However, if we now move the group
    around, the offset will remain the same, as shown in the following screenshot.
    In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, we look deeper into parent-child relations and how grouping
    affects transformation, such as scaling, rotation, and translation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此网格的其他属性之前，我想快速地侧重一下。我提到这个位置是相对于其父级的位置。在上一节关于`THREE.Geometry`的部分中，我们使用了`THREE.SceneUtils.createMultiMaterialObject`来创建一个多材质对象。我解释说，这实际上并不返回一个单一的网格，而是一个包含基于相同几何形状的每种材质的网格的组合；在我们的情况下，它是一个包含两个网格的组合。如果我们改变其中一个创建的网格的位置，您可以清楚地看到它实际上是两个不同的`THREE.Mesh`对象。然而，如果我们现在移动这个组合，偏移量将保持不变，如下面的截图所示。在[第5章](ch05.html
    "第5章。学习使用几何图形")中，*学习使用几何图形*，我们将更深入地研究父子关系以及分组如何影响缩放、旋转和平移等变换。
- en: '![Functions and attributes for meshes](graphics/2215OS_02_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](graphics/2215OS_02_10.jpg)'
- en: 'OK, next on the list is the `rotation` property. You''ve already seen this
    property being used a couple of times in this chapter and the previous chapter.
    With this property, you set the rotation of the object around one of its axes.
    You can set this value in the same manner as we did the position. A complete rotation,
    as you might remember from math class, is *2 x π*. You can configure this in Three.js
    in a couple of different ways:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来列表中的是`rotation`属性。在本章和上一章中，您已经看到了这个属性被使用了几次。通过这个属性，您可以设置对象围绕其中一个轴的旋转。您可以以与设置位置相同的方式设置这个值。完整的旋转，您可能还记得数学课上学过，是*2
    x π*。您可以在Three.js中以几种不同的方式配置这个属性：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to use degrees (from 0 to 360) instead, we''ll have to convert
    those to radians. This can be easily done like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用度数（从0到360）而不是弧度，我们需要将其转换为弧度。可以像这样轻松地完成这个转换：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can play around with this property using the `06-mesh-properties.html` example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`06-mesh-properties.html`示例来尝试这个属性。
- en: 'The next property on our list is one we haven''t talked about: `scale`. The
    name pretty much sums up what you can do with this property. You can scale the
    object along a specific axis. If you set the scale to values smaller than one,
    the object will shrink, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个属性是我们还没有讨论过的：`scale`。名称基本上总结了您可以使用此属性做什么。您可以沿着特定轴缩放物体。如果将缩放设置为小于1的值，物体将缩小，如下面的屏幕截图所示：
- en: '![Functions and attributes for meshes](graphics/2215OS_02_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](graphics/2215OS_02_11.jpg)'
- en: 'When you use values larger than one, the object will become larger, as shown
    in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用大于1的值时，物体将变大，如下面的屏幕截图所示：
- en: '![Functions and attributes for meshes](graphics/2215OS_02_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](graphics/2215OS_02_12.jpg)'
- en: 'The next part of the mesh that we''ll look at in this chapter is the **translate**
    functionality. With translate, you can also change the position of an object,
    but instead of defining the absolute position where you want the object to be,
    you define where the object should move to, relative to its current position.
    For instance, we have a sphere that is added to a scene, and its position has
    been set to `(1,2,3)`. Next, we translate the object along its *x* axis: `translateX(4)`.
    Its position will now be `(5,2,3)`. If we want to restore the object to its original
    position, we do this: `translateX(-4)`. In the `06-mesh-properties.html` example,
    there is a menu tab called **translate**. From there, you can experiment with
    this functionality. Just set the translate values for *x*, *y*, and *z* and hit
    the **translate** button. You''ll see the object being moved to a new position
    based on these three values.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要看的网格的下一个部分是**translate**功能。使用translate，您也可以改变物体的位置，但是不是定义物体应该在的绝对位置，而是定义物体相对于当前位置应该移动到哪里。例如，我们有一个添加到场景中的球体，其位置已设置为`(1,2,3)`。接下来，我们沿着*x*轴平移物体：`translateX(4)`。它的位置现在将是`(5,2,3)`。如果我们想将物体恢复到原始位置，我们可以这样做：`translateX(-4)`。在`06-mesh-properties.html`示例中，有一个名为**translate**的菜单选项。从那里，您可以尝试这个功能。只需设置*x*、*y*和*z*的平移值，然后点击**translate**按钮。您将看到物体根据这三个值被移动到一个新的位置。
- en: 'The last property you can use from the menu in the top-right corner is the
    **visible** property. If you click on the **visible** menu item, you''ll see that
    the cube becomes invisible, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在右上角菜单中可以使用的最后一个属性是**visible**属性。如果单击**visible**菜单项，您会看到立方体变得不可见，如下所示：
- en: '![Functions and attributes for meshes](graphics/2215OS_02_13.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](graphics/2215OS_02_13.jpg)'
- en: When you click on it another time, the cube becomes visible again. For more
    information on meshes, geometries, and what you can do with these objects, look
    at [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 7](ch07.html "Chapter 7. Particles, Sprites,
    and the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次单击它时，立方体将再次可见。有关网格、几何体以及您可以对这些对象进行的操作的更多信息，请参阅[第5章](ch05.html "第5章。学习使用几何体")、*学习使用几何体*和[第7章](ch07.html
    "第7章。粒子、精灵和点云")、*粒子、精灵和点云*。
- en: Different cameras for different uses
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同用途的不同摄像机
- en: 'There are two different camera types in Three.js: the orthographic camera and
    the perspective camera. In [Chapter 3](ch03.html "Chapter 3. Working with the
    Different Light Sources Available in Three.js"), *Working with the Different Light
    Sources Available in Three.js*, we''ll have a much more detailed look at how to
    work with these cameras, so in this chapter, I''ll stick to the basics. The best
    way to explain the differences between these cameras is by looking at a couple
    of examples.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js中有两种不同的摄像机类型：正交摄像机和透视摄像机。在[第3章](ch03.html "第3章。使用Three.js中可用的不同光源")、*使用Three.js中可用的不同光源*中，我们将更详细地了解如何使用这些摄像机，因此在本章中，我将坚持基础知识。解释这些摄像机之间的区别的最佳方法是通过几个示例来看。
- en: Orthographic camera versus perspective camera
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正交摄像机与透视摄像机
- en: 'In the examples for this chapter, you can find a demo called `07-both-cameras.html`.
    When you open this example, you''ll see something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，您可以找到一个名为`07-both-cameras.html`的演示。当您打开此示例时，您将看到类似于这样的东西：
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](graphics/2215OS_02_14.jpg)'
- en: This is called a perspective view and is the most natural view. As you can see
    from this figure, the farther away the cubes are from the camera, the smaller
    they are rendered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为透视视图，是最自然的视图。从这个图中可以看出，物体距离摄像机越远，呈现的越小。
- en: 'If we change the camera to the other type supported by Three.js, the orthographic
    camera, you''ll see the following view of the same scene:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将摄像机更改为Three.js支持的另一种类型，即正交摄像机，您将看到相同场景的以下视图：
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](graphics/2215OS_02_15.jpg)'
- en: With the orthographic camera, all the cubes are rendered the same size; the
    distance between an object and the camera doesn't matter. This is often used in
    2D games such as *SimCity 4* and old versions of *Civilization*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正交摄像机，所有的立方体都以相同的大小呈现；物体与摄像机之间的距离并不重要。这在2D游戏中经常使用，比如*模拟城市4*和*文明*的旧版本。
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](graphics/2215OS_02_16.jpg)'
- en: 'In our examples, we''ll use the perspective camera the most since it best resembles
    the real world. Switching cameras is really very easy. The following piece of
    code is called whenever you hit the switch camera button on the `07-both-cameras`
    example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将最常使用透视摄像机，因为它最接近现实世界。切换摄像机非常容易。每当您在`07-both-cameras`示例上点击切换摄像机按钮时，都会调用以下代码片段：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this table, you can see that there is a difference in the way we create
    the camera. Let''s look at `THREE.PerspectiveCamera` first. This camera takes
    the following arguments:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，你可以看到我们创建相机的方式有所不同。让我们先看一下`THREE.PerspectiveCamera`。这个相机接受以下参数：
- en: '| Argument | Description |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fov` | **FOV** stands for **Field Of View**. This is the part of the scene
    that can be seen from the position of the camera. Humans, for instance, have an
    almost 180-degree FOV, while some birds might even have a complete 360-degree
    FOV.But since a normal computer screen doesn''t completely fill our vision, normally
    a smaller value is chosen. Most often, for games, a FOV between 60 and 90 degrees
    is chosen.*Good default: 50* |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `fov` | **FOV**代表**视野**。这是从相机位置可以看到的场景的一部分。例如，人类几乎有180度的视野，而一些鸟类甚至可能有完整的360度视野。但由于普通电脑屏幕无法完全填满我们的视野，通常会选择一个较小的值。大多数情况下，游戏中选择的FOV在60到90度之间。*良好的默认值：50*
    |'
- en: '| `aspect` | This is the aspect ratio between the horizontal and vertical sizes
    of the area where we''re to render the output. In our case, since we use the entire
    window, we just use that ratio. The aspect ratio determines the difference between
    the horizontal FOV and the vertical FOV, as you can see in the following image.*Good
    default: window.innerWidth / window.innerHeight* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `aspect` | 这是我们要渲染输出的区域的水平和垂直尺寸之间的纵横比。在我们的情况下，由于我们使用整个窗口，我们只使用该比率。纵横比决定了水平FOV和垂直FOV之间的差异，如你可以在下图中看到的那样。*良好的默认值：window.innerWidth
    / window.innerHeight* |'
- en: '| `near` | The `near` property defines from how close to the camera Three.js
    should render the scene. Normally, we set this to a very small value to directly
    render everything from the position of the camera.*Good default: 0.1* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `near` | `near`属性定义了Three.js应该从相机位置渲染场景的距离。通常情况下，我们将其设置为一个非常小的值，直接从相机位置渲染所有东西。*良好的默认值：0.1*
    |'
- en: '| `far` | The `far` property defines how far the camera can see from the position
    of the camera. If we set this too low, a part of our scene might not be rendered,
    and if we set it too high, in some cases, it might affect the rendering performance.*Good
    default: 1000* |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `far` | `far`属性定义了相机从相机位置能看到的距离。如果我们设置得太低，可能会导致我们的场景的一部分不被渲染，如果设置得太高，在某些情况下可能会影响渲染性能。*良好的默认值：1000*
    |'
- en: '| `zoom` | The `zoom` property allows you to zoom in and out of the scene.
    When you use a number lower than `1`, you zoom out of the scene, and if you use
    a number higher than `1`, you zoom in. Note that if you specify a negative value,
    the scene will be rendered upside down.*Good default value: 1* |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `zoom` | `zoom`属性允许你放大或缩小场景。当你使用小于`1`的数字时，你会缩小场景，如果你使用大于`1`的数字，你会放大。请注意，如果你指定一个负值，场景将被倒置渲染。*良好的默认值：1*
    |'
- en: 'The following image gives a good overview of how these properties work together
    to determine what you see:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像很好地概述了这些属性如何共同确定你所看到的内容：
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![正交相机与透视相机](graphics/2215OS_02_17.jpg)'
- en: The `fov` property of the camera determines the horizontal FOV. Based on the
    `aspect` property, the vertical FOV is determined. The `near` property is used
    to determine the position of the near plane, and the `far` property determines
    the position of the far plane. The area between the near plane and the far plane
    will be rendered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的`fov`属性确定了水平FOV。基于`aspect`属性，确定了垂直FOV。`near`属性用于确定近平面的位置，`far`属性确定了远平面的位置。在近平面和远平面之间的区域将被渲染。
- en: 'To configure the orthographic camera, we need to use other properties. The
    orthographic projection isn''t interested either in the aspect ratio to use or
    with what FOV we look at the scene since all the objects are rendered at the same
    size. What you do when you define an orthographic camera is define the cuboid
    area that needs to be rendered. The properties for the orthographic camera reflect
    this, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置正交相机，我们需要使用其他属性。正交投影对使用的纵横比或我们观察场景的FOV都不感兴趣，因为所有的物体都以相同的大小渲染。当你定义一个正交相机时，你所做的就是定义需要被渲染的长方体区域。正交相机的属性反映了这一点，如下所示：
- en: '| Argument | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `left` | This is described in the Three.js documentation as *Camera frustum
    left plane*. You should see this as what is the left-hand border of what will
    be rendered. If you set this value to `-100`, you won''t see any objects that
    are farther to the left-hand side. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `left` | 这在Three.js文档中被描述为*相机截头锥左平面*。你应该把它看作是将要被渲染的左边界。如果你将这个值设置为`-100`，你就看不到任何在左侧更远处的物体。
    |'
- en: '| `right` | The `right` property works in a way similar to the `left` property,
    but this time, to the other side of the screen. Anything farther to the right
    won''t be rendered. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `right` | `right`属性的工作方式类似于`left`属性，但这次是在屏幕的另一侧。任何更远的右侧都不会被渲染。 |'
- en: '| `top` | This is the top position to be rendered. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `top` | 这是要渲染的顶部位置。 |'
- en: '| `bottom` | This is the bottom position to be rendered. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `bottom` | 这是要渲染的底部位置。 |'
- en: '| `near` | From this point, based on the position of the camera, the scene
    will be rendered. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `near` | 从这一点开始，基于相机的位置，场景将被渲染。 |'
- en: '| `far` | To this point, based on the position of the camera, the scene will
    be rendered. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `far` | 到这一点，基于相机的位置，场景将被渲染。 |'
- en: '| `zoom` | This allows you to zoom in and out of the scene. When you use a
    number lower than `1`, you''ll zoom out of the scene; if you use a number higher
    than `1`, you''ll zoom in. Note that if you specify a negative value, the scene
    will be rendered upside down. The default value is `1`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `zoom` | 这允许你放大或缩小场景。当你使用小于`1`的数字时，你会缩小场景；如果你使用大于`1`的数字，你会放大。请注意，如果你指定一个负值，场景将被倒置渲染。默认值为`1`。
    |'
- en: 'All these properties can be summarized in the following figure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性可以总结在下图中：
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![正交相机与透视相机](graphics/2215OS_02_18.jpg)'
- en: Looking at specific points
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察特定点
- en: 'Until now, you''ve seen how to create a camera and what the various arguments
    mean. In the previous chapter, you also saw that you need to position your camera
    somewhere in the scene, and that the view from that camera is rendered. Normally,
    the camera is pointed to the center of the scene: position (0,0,0). We can, however,
    easily change what the camera is looking at, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了如何创建摄像机以及各种参数的含义。在上一章中，您还看到需要将摄像机定位在场景中的某个位置，并且从摄像机的视角进行渲染。通常，摄像机指向场景的中心：位置（0,0,0）。然而，我们可以很容易地改变摄像机的观察对象，如下所示：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I''ve added an example where the camera moves, and the point it is looking
    at is marked with a red dot, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个示例，其中摄像机移动，它所看的点用红点标记如下：
- en: '![Looking at specific points](graphics/2215OS_02_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![观察特定点](graphics/2215OS_02_19.jpg)'
- en: If you open the `08-cameras-lookat` example, you'll see the scene moving from
    left to right. The scene isn't really moving. The camera is looking at different
    points (see the red dot in the center), which gives the effect that the scene
    is moving from left to right. In this example, you can also switch cameras to
    the orthographic one. There, you see that changing the point the camera looks
    at has pretty much the same effect as with `THREE.PerspectiveCamera`. The interesting
    part to notice, though, is that with `THREE.OrthographicCamera`, you can clearly
    see that the sizes of all the cubes stay the same regardless of where the camera
    is looking.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`08-cameras-lookat`示例，您将看到场景从左向右移动。实际上场景并没有移动。摄像机正在看不同的点（请参见中心的红点），这会产生场景从左向右移动的效果。在这个示例中，您还可以切换到正交摄像机。在那里，您会发现改变摄像机观察的点几乎与`THREE.PerspectiveCamera`具有相同的效果。然而，值得注意的是，使用`THREE.OrthographicCamera`，您可以清楚地看到无论摄像机看向何处，所有立方体的大小都保持不变。
- en: '![Looking at specific points](graphics/2215OS_02_20.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![观察特定点](graphics/2215OS_02_20.jpg)'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'When you use the `lookAt` function, you point the camera at a specific position.
    You can also use this to make the camera follow an object around the scene. Since
    every `THREE.Mesh` object has a position that is a `THREE.Vector3` object, you
    can use the `lookAt` function to point to a specific mesh in the scene. All you
    need to do is this: `camera.lookAt(mesh.position)`. If you call this in the render
    loop, you''ll make the camera follow an object as it moves through the scene.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`lookAt`函数时，您将摄像机对准特定位置。您还可以使用它来使摄像机在场景中跟随物体移动。由于每个`THREE.Mesh`对象都有一个`THREE.Vector3`对象的位置，您可以使用`lookAt`函数指向场景中的特定网格。您只需要这样做：`camera.lookAt(mesh.position)`。如果您在渲染循环中调用此函数，您将使摄像机跟随物体在场景中移动。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We discussed a lot of items in this second introduction chapter. We showed all
    the functions and properties of `THREE.Scene` and explained how you can use these
    properties to configure your main scene. We also showed you how you can create
    geometries. You can either create them from scratch using a `THREE.Geometry` object
    or use any of the built-in geometries Three.js provides. Finally, we showed you
    how you can configure the two cameras Three.js provides. `THREE.PerspectiveCamera`
    renders a scene using a real-world perspective, and `THREE.OrthographicCamera`
    provides a fake 3D effect also often seen in games. We've also introduced how
    geometries work in Three.js. You can now easily create your own geometries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这第二个介绍章节中讨论了很多内容。我们展示了`THREE.Scene`的所有函数和属性，并解释了如何使用这些属性来配置您的主场景。我们还向您展示了如何创建几何体。您可以使用`THREE.Geometry`对象从头开始创建它们，也可以使用Three.js提供的任何内置几何体。最后，我们向您展示了如何配置Three.js提供的两个摄像机。`THREE.PerspectiveCamera`使用真实世界的透视渲染场景，而`THREE.OrthographicCamera`提供了在游戏中经常看到的虚假3D效果。我们还介绍了Three.js中几何体的工作原理。您现在可以轻松地创建自己的几何体。
- en: In the next chapter, we'll look at the various light sources that are available
    in Three.js. You'll learn how the various light sources behave, how to create
    and configure them, and how they affect specific materials.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看Three.js中可用的各种光源。您将了解各种光源的行为，如何创建和配置它们以及它们如何影响特定材质。
