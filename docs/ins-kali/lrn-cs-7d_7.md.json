["```cs\npublic class BaseClass\n{\n   private const string AuthorName = \"Gaurav Aroraa\";\n   public class DeriveClass: BaseClass\n   {\n      public void Display()\n      {\n         Write(\"This is from inherited Private member:\");\n         WriteLine($\"{nameof(AuthorName)}'{AuthorName}'\");\n         ReadLine();\n      }\n   }\n}\nBaseClass is to have one private member, AuthorName, and this will be available in DeriveClass, as DeriveClass is a nested class of BaseClass. You can also see this in compile time while moving the cursor over to the usage of the private AuthorName member. See the following screenshot:\n```", "```cs\nnamespace Day07\n{\n   public class MemberVisibility\n   {\n      private void InternalMemberExample()\n      {\n         var childClass = new Lib.ChildClass();\n         WriteLine(\"Calling from derived class that\n         belongs to same assembly of BaseClass\");\n         childClass.Display();\n      }\n   }\n}\n```", "```cs\npublic class ChilClassYounger : ChildClass\n{\n   private string _copyEditor = \"Diwakar Shukla\";\n   public new void Display()\n   {\n      WriteLine($\"This is from ChildClassYounger: copy\n      editor is '{_copyEditor}'\");\n      WriteLine(\"This is from ChildClass:\");\n      base.Display();\n   }\n}\nChildClassYoung has a Display() method that displays the console output. ChildClass also has a public Display() method that also displays the console output. In our derived class, we can reuse the Display() method of ChildClass because it is declared as public. After running the previous code, it will give the following output:\n```", "```cs\npublic class Person\n{\n   public string FirstName { get; set; } = \"Gaurav\";\n   public string LastName { get; set; } = \"Aroraa\";\n   public int Age { get; set; } = 43;\n   public string Name => $\"{FirstName} {LastName}\";\n   public virtual void Detail()\n   {\n      WriteLine(\"Person's Detail:\");\n      WriteLine($\"Name: {Name}\");\n      WriteLine($\"Age: {Age}\");\n      ReadLine();\n   }\n}\npublic class Author:Person\n{\n   public override void Detail()\n   {\n      WriteLine(\"Author's detail:\");\n      WriteLine($\"Name: {Name}\");\n      WriteLine($\"Age: {Age}\");\n      ReadLine();\n   }\n}\npublic class Editor : Person\n{\n   public override void Detail()\n   {\n    WriteLine(\"Editor's detail:\");\n    WriteLine($\"Name: {Name}\");\n    WriteLine($\"Age: {Age}\");\n    ReadLine();\n   }\n}\npublic class Reviewer : Person\n{\n   public override void Detail()\n   {\n      WriteLine(\"Reviewer's detail:\");\n      WriteLine($\"Name: {Name}\");\n      WriteLine($\"Age: {Age}\");\n      ReadLine();\n   }\n}\n```", "```cs\nprivate static void InheritanceImplementationExample()\n{\n   WriteLine(\"Inheritance implementation\");\n   WriteLine();\n   var person = new Person();\n   WriteLine(\"Parent class Person:\");\n   person.Detail();\n   var author = new Author();\n   WriteLine(\"Derive class Author:\");\n   Write(\"First Name:\");\n   author.FirstName = ReadLine();\n   Write(\"Last Name:\");\n   author.LastName = ReadLine();\n   Write(\"Age:\");\n   author.Age = Convert.ToInt32(ReadLine());\n   author.Detail();\n   //code removed\n}\n```", "```cs\npublic interface IBook\n{\n   string Title { get; set; }\n   string Isbn { get; set; }\n   bool Ispublished { get; set; }\n   void Detail();\n}\nIBook interface, which is related to book details. This interface is intended to collect book details, such as Title, ISBN, and whether the book is published. It has a method that provides the complete book details.\n```", "```cs\npublic class Author:Person, IBook\n{\n   public string Title { get; set; }\n   public string Isbn { get; set; }\n   public bool Ispublished { get; set; }\n   public override void Detail()\n   {\n      WriteLine(\"Author's detail:\");\n      WriteLine($\"Name: {Name}\");\n      WriteLine($\"Age: {Age}\");\n      ReadLine();\n   }\n   void IBook.Detail()\n   {\n      WriteLine(\"Book details:\");\n      WriteLine($\"Author Name: {Name}\");\n      WriteLine($\"Author Age: {Age}\");\n      WriteLine($\"Title: {Title}\");\n      WriteLine($\"Isbn: {Isbn}\");\n      WriteLine($\"Published: {(Ispublished ? \"Yes\" :\n      \"No\")}\");\n      ReadLine(); \n   } \n} \nIBook interface. Our derived class Author inherits the Person base class and implements the IBook interface. In the preceding code, a notable point is that both the class and interface have the Detail() method. Now, it depends on which method we want to modify or which method we want to reuse. If we try to modify the Detail() method of the Person class, then we need to override or hide it (using the new keyword). On the other hand, if we want to use the interface's method, we need to explicitly call the IBook.Detail() method. When you call interface methods explicitly, modifiers are not required; hence, there is no need to put a public modifier here. This method implicitly has public visibility:\n```", "```cs\n//multiple Inheritance\nWriteLine(\"Book details:\");\nWrite(\"Title:\");\nauthor.Title = ReadLine();\nWrite(\"Isbn:\");\nauthor.Isbn = ReadLine();\nWrite(\"Published (Y/N):\");\nauthor.Ispublished = ReadLine() == \"Y\";((IBook)author).Detail(); //\nwe need to cast as both Person class and IBook has same named methods\nAuthor class with IBook:\n```", "```cs\npublic class AbstractionImplementation\n{\npublic void Display()\n{\nBookAuthor author = new BookAuthor();\nauthor.GetDetail();\nBookEditor editor = new BookEditor();\neditor.GetDetail();\nBookReviewer reviewer = new BookReviewer();\nreviewer.GetDetail();\n}\n}\n```", "```cs\npublic abstract class Team\n{\npublic abstract void GetDetail();\n}\n```", "```cs\npublic class BookAuthor : Team\n{\npublic override void GetDetail() => Display();\nprivate void Display()\n{\nWriteLine(\"Author detail\");\nWrite(\"Enter Author Name:\");\nvar name = ReadLine();\nWriteLine($\"Book author is: {name}\");\n}\n}\n```", "```cs\npublic class BookEditor : Team\n{\npublic override void GetDetail() => Display();\nprivate void Display()\n{\nWriteLine(\"Editor detail\");\nWrite(\"Enter Editor Name:\");\nvar name = ReadLine();\nWriteLine($\"Book editor is: {name}\");\n}\n}\npublic class BookReviewer : Team\n{\npublic override void GetDetail() => Display();\nprivate void Display()\n{\nWriteLine(\"Reviewer detail\");\nWrite(\"Enter Reviewer Name:\");\nvar name = ReadLine();\nWriteLine($\"Book reviewer is: {name}\");\n}\n}\n```", "```cs\ninternal class Writer\n{\n   private string _title;\n   private string _isbn;\n   private string _name;\n   public void SetName(string fname, string lName)\n   {\n      if (string.IsNullOrEmpty(fname) ||\n      string.IsNullOrWhiteSpace(lName))\n      throw new ArgumentException(\"Name can not be\n      blank.\");\n      _name = $\"{fname} {lName}\";\n   }\n   public void SetTitle(string title)\n   {\n      if (string.IsNullOrWhiteSpace(title))\n      throw new ArgumentException(\"Book title can not be\n      blank.\");\n      _title = title;\n   }\n   public void SetIsbn(string isbn)\n   {\n      if (!string.IsNullOrEmpty(isbn))\n      {\n         if (isbn.Length == 10 | isbn.Length == 13)\n         {\n            if (!ulong.TryParse(isbn, out _))\n            throw new ArgumentException(\"The ISBN can\n            consist of numeric characters only.\");\n         }\n         else\n      throw new ArgumentException(\"ISBN should be 10 or 13\n      characters numeric string only.\");\n      }\n    _isbn = isbn;\n   }\n   public override string ToString() => $\"Author '{_name}'\n   has authored a book '{_title}' with ISBN '{_isbn}'\";\n  }\n```", "```cs\npublic class EncapsulationImplementation\n{\n   public void Display()\n   {\n      WriteLine(\"Encapsulation example\");\n      Writer writer = new Writer();\n      Write(\"Enter First Name:\");\n      var fName = ReadLine();\n      Write(\"Enter Last Name:\");\n      var lName = ReadLine();\n      writer.SetName(fName,lName);\n      Write(\"Book title:\");\n      writer.SetTitle(ReadLine());\n      Write(\"Enter ISBN:\");\n      writer.SetIsbn(ReadLine());\n      WriteLine(\"Complete details of book:\");\n      WriteLine(writer.ToString());\n   }\n}\n```", "```cs\npublic class Math\n{\n    public int Add(int num1, int num2) =>   num1 + num2;\n    public double Add(double num1, double num2) => num1 + num2;\n}\n```", "```cs\npublic class CompileTimePolymorphismImplementation\n{\n   public void Run()\n   {\n      Write(\"Enter first number:\");\n      var num1 = ReadLine();\n      Write(\"Enter second number:\");\n      var num2 = ReadLine();\n      Math math = new Math();\n      var sum1 = math.Add(FloatToInt(num1),\n      FloatToInt(num1));\n      var sum2 = math.Add(ToFloat(num1), ToFloat(num2));\n      WriteLine(\"Using Addd(int num1, int num2)\");\n      WriteLine($\"{FloatToInt(num1)} + {FloatToInt(num2)}\n      = {sum1}\");\n      WriteLine(\"Using Add(double num1, double num2)\");\n      WriteLine($\"{ToFloat(num1)} + {ToFloat(num2)} =\n      {sum2}\");\n   }\n   private int FloatToInt(string num) =>\n   (int)System.Math.Round(ToFloat(num), 0);\n   private float ToFloat(string num) = \n   float.Parse(num);\n}\n```", "```cs\ninternal abstract class Team\n{\n   public abstract string Detail();\n}\ninternal class Author : Team\n{\n   private readonly string _name;\n   public Author(string name) => _name = name;\n   public override string Detail()\n   {\n      WriteLine(\"Author Team:\");\n      return $\"Member name: {_name}\";\n   }\n}\nTeam is having an abstract method Detail() that is overridden.\n```", "```cs\npublic class RunTimePolymorphismImplementation\n{\n   public void Run()\n   {\n      Write(\"Enter name:\");\n      var name = ReadLine();\n      Author author = new Author(name);\n      WriteLine(author.Detail());\n   }\n}\nAuthor class and produces the following output:\n```", "```cs\ninternal class Team\n{\n   protected string Name;\n   public Team(string name)\n   {\n      Name = name;\n   }\n   public virtual string Detail() => Name;\n}\ninternal class Author : Team\n{\n   public Author(string name) : base(name)\n   {}\n   public override string Detail() => Name;\n}\ninternal class Editor : Team\n{\n   public Editor(string name) : base(name)\n   {}\n   public override string Detail() => Name;\n}\ninternal class Client\n{\n   public void ShowDetail(Team team) =>\n   WriteLine($\"Member: {team.Detail()}\");\n}\nTeam and perform the operation by knowing the type of a class at runtime.\n```", "```cs\npublic class PolymorphismImplementation\n{\n   public void Build()\n   {\n      List<Team> teams = new List<Team> {new Author(), new\n      Editor(), new Reviewer()};\n      foreach (Team team in teams)\n      team.BuildTeam();\n   }\n}\npublic class Team\n{\n   public string Name { get; private set; }\n   public string Title { get; private set; }\n   public virtual void BuildTeam()\n   {\n      Write(\"Name:\");\n      Name = ReadLine();\n      Write(\"Title:\");\n      Title = ReadLine();\n      WriteLine();\n      WriteLine($\"Name:{Name}\\nTitle:{Title}\");\n      WriteLine();\n   }\n}\ninternal class Author : Team\n{\n   public override void BuildTeam()\n   {\n      WriteLine(\"Building Author Team\");\n      base.BuildTeam();\n   }\n}\ninternal class Editor : Team\n{\n   public override void BuildTeam()\n   {\n      WriteLine(\"Building Editor Team\");\n      base.BuildTeam();\n   }\n}\ninternal class Reviewer : Team\n{\n   public override void BuildTeam()\n   {\n      WriteLine(\"Building Reviewer Team\");\n      base.BuildTeam();\n   }\n}\n```"]