- en: Angular Cloud-Based Mapping with Firebase
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firebase进行Angular基于云的地图
- en: We have spent quite a few chapters writing our own backend systems for returning
    information to the client. In the last few years, there has been a trend toward
    using third-party cloud systems. Cloud systems can help lower the costs of writing
    applications, because other companies provide all of the infrastructure that we
    need to use and take care of testing, upgrades, and so on. In this chapter, we
    are going to look at using cloud infrastructure from the Bing mapping team and
    Firebase to provide data storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们花了相当多的时间编写我们自己的后端系统，以返回信息给客户端。在过去的几年里，有一种趋势是使用第三方云系统。云系统可以帮助降低编写应用程序的成本，因为其他公司提供了我们需要使用的所有基础设施，并负责测试、升级等。在本章中，我们将研究如何使用必应地图团队和Firebase的云基础设施来提供数据存储。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Signing up to Bing mapping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册必应地图
- en: The implications of billable cloud features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计费云功能的含义
- en: Signing up to Firebase
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册Firebase
- en: Adding a map component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加地图组件
- en: Using map search features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图搜索功能
- en: Using `EventEmitter` to notify parent components of child component events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`来通知父组件子组件事件
- en: Reacting to mapping events to add and remove your own points of interest
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应地图事件以添加和删除自己的兴趣点
- en: Overlaying map search results on the map
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上叠加搜索结果
- en: Tidying up event handlers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整理事件处理程序
- en: Saving data to Cloud Firestore
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到Cloud Firestore
- en: Configuring Cloud Firestore authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Cloud Firestore身份验证
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07)下载。
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下载项目后，您将需要使用`npm install`命令安装软件包要求。
- en: Modern applications and the move to cloud services
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代应用程序和转向云服务
- en: Throughout this book, we have been concentrating on writing applications where
    we control the infrastructure on which the application runs and where the data
    is physically stored. Over the last few years, the trend has been to move away
    from this type of application toward a model where other companies provide this
    infrastructure through something called **cloud-based services**. *Cloud services*
    has become a catch-all marketing term to describe the trend of using on-demand
    services from other companies, relying on them to provide application features,
    security, scaling, backup features, and so on. The idea behind this is that we
    can reduce capital costs by letting others take care of these features for us,
    freeing us to write applications that make use of these features in a mix-and-match
    fashion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在专注于编写应用程序，其中我们控制应用程序运行的基础设施以及数据的物理存储位置。在过去的几年里，趋势是摆脱这种类型的应用程序，转向其他公司通过所谓的**基于云的服务**提供这种基础设施的模式。*云服务*已经成为一个用来描述使用其他公司的按需服务的总称营销术语，依赖于它们提供应用程序功能、安全性、扩展性、备份功能等。其背后的想法是，我们可以通过让其他人为我们处理这些功能来减少资本成本，从而使我们能够编写利用这些功能的应用程序。
- en: In this chapter, we are going to look at using cloud-based services from Microsoft
    and Google, so we will look at the process of signing up to these services, the
    implications of using them, and how to make use of them in our final Angular application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究如何使用微软和谷歌的基于云的服务，因此我们将研究注册这些服务的过程，使用它们的含义，以及如何在我们最终的Angular应用程序中使用它们。
- en: Project overview
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: For our last Angular application, we are going to go to town and use Bing mapping
    services to display the types of maps we are used to using on a daily basis to
    search for locations. We will go even further and use Microsoft's Local Insights
    services to search for a particular business type in the currently visible map
    area. This is one of the two applications that excited me the most when I was
    putting together the plan for this book because I have a love for map-based systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们最后的Angular应用程序，我们将使用必应地图服务来展示我们日常使用的地图类型，以搜索位置。我们将进一步使用微软的本地洞察服务来搜索当前可见地图区域内的特定业务类型。这是我在为这本书制定计划时最激动人心的两个应用程序之一，因为我对基于地图的系统情有独钟。
- en: As well as displaying maps, we are going to be able to select points of interest
    on the map by clicking directly on the map. These points will be represented by
    colored pins. We will save the location of these points, along with their name,
    in a cloud-based database from Google.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示地图，我们还可以通过直接点击地图上的点来选择地图上的兴趣点。这些点将由彩色图钉表示。我们将保存这些点的位置和名称，以及它们在谷歌的基于云的数据库中。
- en: This application should take about an hour to complete, as long as you work
    alongside the code on GitHub.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序应该需要大约一个小时来完成，只要你在GitHub上的代码旁边工作。
- en: Throughout this chapter, we will no longer provide details about how to add
    packages using `npm`, or how to create Angular applications, components, or the
    like, as you should be familiar with how to do this by this point.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不再提供如何使用`npm`添加软件包，或者如何创建Angular应用程序、组件等的详细信息，因为到这个时候你应该已经熟悉如何做这些了。
- en: 'When completed, the application should look like this (maybe not zoomed into
    Newcastle upon Tyne, though):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，应用程序应该看起来像这样（也许不要放大到纽卡斯尔）：
- en: '![](assets/a0f765d2-db52-41cc-88eb-8488d2516510.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a0f765d2-db52-41cc-88eb-8488d2516510.png)'
- en: Getting started with Bing mapping in Angular
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Angular中的必应地图
- en: This is our last Angular application, so we will start off by creating it in
    the same way we created applications in previous chapters. Again, we are going
    to use Bootstrap, rather than Angular Material.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最后一个Angular应用程序，所以我们将以与之前章节中创建应用程序相同的方式开始。同样，我们将使用Bootstrap，而不是Angular Material。
- en: 'The packages we are going to concentrate on in this chapter are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中要专注的包如下：
- en: '`bootstrap`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`'
- en: '`bingmaps`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bingmaps`'
- en: '`firebase`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firebase`'
- en: '`guid-typescript`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guid-typescript`'
- en: Since we are going to be hooking our code up to cloud-based services, we will
    have to sign up to them first. In this section, we will look at what we need to
    do to sign up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将把我们的代码连接到基于云的服务，我们首先必须注册它们。在本节中，我们将看看我们需要做什么来注册。
- en: Signing up to Bing mapping
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册必应地图
- en: 'If we want to use Bing Maps, we have to sign up to Bing Map Services. Navigate
    to [https://www.bingmapsportal.com](https://www.bingmapsportal.com) and click
    the Sign in button. This requires a Windows account, so if you don''t have one,
    you will need to set one up. For now, we are going to assume that you have a Windows
    account available:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用必应地图，我们必须注册必应地图服务。导航到[https://www.bingmapsportal.com](https://www.bingmapsportal.com)并单击“登录”按钮。这需要一个Windows帐户，所以如果你没有一个，你需要设置一个。现在，我们假设你有一个Windows帐户可用：
- en: '![](assets/082d18cf-f170-4e4b-b7e7-0efef3da47b2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/082d18cf-f170-4e4b-b7e7-0efef3da47b2.png)'
- en: 'When we sign in, we need to create a key that our application will use to identify
    itself to the Bing Map Services so that they know who we are and can keep track
    of our map usage. From the My account option, select My Keys:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们登录时，我们需要创建一个密钥，我们的应用程序将使用它来向必应地图服务标识自己，以便他们知道我们是谁，并可以跟踪我们的地图使用情况。从“我的帐户”选项中，选择“我的密钥”：
- en: '![](assets/871b25e0-38ce-4aef-a2e5-975fe4c172d0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/871b25e0-38ce-4aef-a2e5-975fe4c172d0.png)'
- en: 'When the keys screen appears, you will see a link called Click here to create
    a new key. Clicking the link will show the following screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当密钥屏幕出现时，你会看到一个名为“点击此处创建新密钥”的链接。点击链接将显示以下屏幕：
- en: '![](assets/c03c1b67-b41c-45c7-977e-d4058f3f05ff.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c03c1b67-b41c-45c7-977e-d4058f3f05ff.png)'
- en: Most of the information on this screen is fairly self-explanatory. The application
    name is used if we have multiple keys and we need to search for them. The URL
    doesn't have to be set, but I like to do this if I am deploying to different web
    applications. It's a handy way to remember which key is associated with which
    application. Since we aren't going to be going for the paid-for enterprise service,
    the only key type that we have available is Basic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕上的大部分信息都相当容易理解。应用程序名称用于在我们有多个密钥并且需要搜索它们时使用。URL不需要设置，但如果我部署到不同的Web应用程序，我喜欢这样做。这是一个方便的方式来记住哪个密钥与哪个应用程序相关联。由于我们不打算使用付费企业服务，我们唯一可用的密钥类型是基本的。
- en: The Application type is probably the most important field on here, from our
    point of view. There are a number of application types that we can choose from,
    each of which has limitations around the number of transactions that it can accept.
    We are going to stick with Dev/Test, which limits us to 125,000 billable transactions,
    cumulatively, over a year-long period.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序类型可能是这里最重要的字段，从我们的角度来看。我们可以选择多种应用程序类型，每种类型都有关于它可以接受的交易数量的限制。我们将坚持使用Dev/Test，它限制我们在一年的时间内累计的可计费交易次数为125,000次。
- en: When we use the Local Insights code in this chapter, this will generate billable
    transactions. If you don't want to run the risk of incurring any costs, I would
    recommend that you disable the code that does this searching.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章中使用本地洞察代码时，这将生成可计费的交易。如果你不想承担任何费用的风险，我建议你禁用执行此搜索的代码。
- en: When we click Create, our map key is created, and is available by clicking the
    Show key or Copy key links in the table that appears. We have now set up everything
    that we need for the map key, so let's move on to signing up to the database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“创建”时，我们的地图密钥被创建，并且可以通过点击表中出现的“显示密钥”或“复制密钥”链接来获取。现在我们已经设置好了地图密钥所需的一切，让我们继续注册数据库。
- en: Signing up to Firebase
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册Firebase
- en: 'Firebase requires a Google account. Assuming we have one available, we can
    access the features of Firebase at [https://console.firebase.google.com/](https://console.firebase.google.com/).
    When this screen appears, click the Add project button to start the process of
    adding Firebase support:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase需要一个Google帐户。假设我们有一个可用的Google帐户，我们可以在[https://console.firebase.google.com/](https://console.firebase.google.com/)上访问Firebase的功能。当出现这个屏幕时，点击“添加项目”按钮开始添加Firebase支持的过程：
- en: '![](assets/1d9dd8ac-8931-4642-88ce-77e2c20ff855.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d9dd8ac-8931-4642-88ce-77e2c20ff855.png)'
- en: 'Choose a meaningful name for the project. Before we can create the project,
    we should read the terms and conditions for using Firebase and tick the checkbox
    if we agree with them. Note that if we choose to share usage statistics for Google
    Analytics, we should read the appropriate terms and conditions and check the controller-controller
    terms checkbox as well:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目选择一个有意义的名称。在我们创建项目之前，我们应该阅读使用Firebase的条款和条件，并在同意时勾选复选框。请注意，如果我们选择共享Google
    Analytics的使用统计数据，我们应该阅读适当的条款和条件，并勾选控制器-控制器条款复选框：
- en: '![](assets/ae904ea1-6b3a-4983-8162-a7d375eb5e19.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae904ea1-6b3a-4983-8162-a7d375eb5e19.png)'
- en: 'Having clicked Create project, we now have access to the Firebase project.
    While Firebase, as a cloud services provider, is more than just a database, offering
    storage, hosting, and so on, we are just going to use the Database option. When
    we click the Database link, we are presented with the Cloud Firestore screen,
    where we need to click Create database to start the process of creating the database:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建项目”后，我们现在可以访问Firebase项目。虽然Firebase作为云服务提供商不仅仅是一个数据库，还提供存储、托管等功能，但我们只是使用数据库选项。当我们点击数据库链接时，会出现Cloud
    Firestore屏幕，我们需要点击“创建数据库”来开始创建数据库的过程：
- en: '![](assets/f550f6f4-904d-429c-b822-81af8bd6ac94.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f550f6f4-904d-429c-b822-81af8bd6ac94.png)'
- en: Whenever I refer to Firebase in this chapter, I am using this as a shorthand
    way of saying that this is the Firestore feature of the Firebase cloud platform.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我在本章中提到Firebase时，我是在简单地说这是Firebase云平台的Firestore功能。
- en: While we are creating the database, we will need to choose the level of security
    that we want to apply to our database. We have two options here. We can start
    with the database locked so that reading and writing is disabled. Access to the
    database will then have to be enabled by writing rules that the database will
    check to determine whether or not a write is allowed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库时，我们需要选择要应用于我们的数据库的安全级别。我们在这里有两个选项。我们可以从数据库被锁定开始，以便禁用读写。然后，通过编写数据库将检查以确定是否允许写入的规则来启用对数据库的访问。
- en: 'For our purposes, though, we are going to start in test mode, which allows
    unlimited reads and writes to the database:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了我们的目的，我们将以测试模式开始，这允许对数据库进行无限读写：
- en: '![](assets/78fe0e8c-0642-4993-a5c7-305d5fdbd2d7.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/78fe0e8c-0642-4993-a5c7-305d5fdbd2d7.png)'
- en: Like Bing mapping, Firebase has usage limitations and cost implications. We
    are creating a Spark plan datastore, which is the free Firebase version. This
    version comes with hard limits, such as only being able to store 1 GB of data
    per month, with 50,000 reads a day and 20,000 writes a day. For details around
    pricing and limitations, please read [https://firebase.google.com/pricing](https://firebase.google.com/pricing)/.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与Bing地图类似，Firebase有使用限制和成本影响。我们正在创建一个Spark计划数据存储，这是免费的Firebase版本。这个版本有硬性限制，比如每月只能存储1GB的数据，每天可以读取50000次，每天可以写入20000次。有关定价和限制的详细信息，请阅读[https://firebase.google.com/pricing](https://firebase.google.com/pricing)/。
- en: 'Once we have clicked Enable and have a database available, we need to be able
    to get access to the key and project details that Firebase creates for us. To
    find this, click the Project overview link on the menu. The </> button pops up
    a screen that shows the details we will need to copy for our project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击了启用并有一个可用的数据库，我们需要能够访问Firebase为我们创建的密钥和项目详细信息。要找到这些信息，请点击菜单上的项目概述链接。按钮弹出一个屏幕，显示我们需要复制到我们的项目的详细信息：
- en: '![](assets/85b83eb6-5b9f-44b1-a89c-344c0bca061e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85b83eb6-5b9f-44b1-a89c-344c0bca061e.png)'
- en: We now have our cloud infrastructure set up and have the keys and details we
    need available. We are now ready to write our application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置好了云基础设施，并且有了我们需要的密钥和详细信息。我们现在准备编写我们的应用程序。
- en: Creating a Bing Maps application using Angular and Firebase
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular和Firebase创建Bing Maps应用程序
- en: One of the fastest-growing application types over the last few years has been
    the explosion of mapping applications, whether for your satnav system or running
    Google Maps on your phone. Underneath these applications lie mapping services
    that have been developed by companies such as Microsoft or Google. We are going
    to use the Bing Maps services to add mapping support to our application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，增长最快的应用程序类型之一是地图应用程序的爆炸，无论是用于您的卫星导航系统还是在手机上运行Google地图。在这些应用程序的底层，有由微软或谷歌等公司开发的地图服务。我们将使用Bing地图服务来为我们的应用程序添加地图支持。
- en: 'Our mapping application has the following requirements:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地图应用程序有以下要求：
- en: Clicking on a location will add that location as a point of interest
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击位置将把该位置添加为兴趣点
- en: When a point of interest is added, an information box will be displayed, showing
    details about it
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加兴趣点时，将显示一个信息框，显示有关它的详细信息
- en: Clicking on a point of interest again will delete it
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次点击兴趣点将删除它
- en: Points of interest will be saved to a database
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兴趣点将被保存到数据库中
- en: The user will be able to move the point of interest, updating details in the
    database
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够移动兴趣点，更新数据库中的详细信息
- en: Where available, business information will be automatically retrieved and displayed
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可用的情况下，将自动检索并显示商业信息
- en: Adding the map component
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地图组件
- en: We are going to create two Angular components for this step—one called `MappingcontainerComponent`,
    and another called `MapViewComponent`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这一步创建两个Angular组件，一个叫做`MappingcontainerComponent`，另一个叫做`MapViewComponent`。
- en: I broke these up because I wanted to use `MappingcontainerComponent` to contain
    the bootstrap infrastructure, while `MapViewComponent` will just contain the map
    itself. If you want to, you can combine these together, but for the purposes of
    establishing a clear delineation to describe what is going on with each part,
    it was easier for me to create two components here. This does mean that we need
    to introduce some coordination between the two components, which will reinforce
    the `EventEmitter` behavior we covered in [Chapter 5](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml),
    *Angular ToDo App with GraphQL and Apollo*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我将它们分开，因为我想使用`MappingcontainerComponent`来包含引导程序基础设施，而`MapViewComponent`将只包含地图本身。如果你愿意，你可以将它们合并在一起，但是为了清晰地描述每个部分的情况，对我来说在这里创建两个组件更容易。这意味着我们需要在这两个组件之间引入一些协调，这将加强我们在[第5章](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml)中介绍的`EventEmitter`行为，*Angular
    ToDo App with GraphQL and Apollo*。
- en: Before we add any body to these components, we have some models and services
    that we need to write to provide the infrastructure that our map and data access
    will need.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这些组件添加任何内容之前，我们需要编写一些模型和服务，以提供我们的地图和数据访问所需的基础设施。
- en: Points of interest
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兴趣点
- en: Each point of interest is represented by a pin, and can be represented as latitude
    and longitude coordinates, along with its name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个兴趣点都由一个图钉表示，并且可以表示为纬度和经度坐标，以及它的名称。
- en: Latitude and longitude are geographic terms that are used to identify exactly
    where something is on the planet. Latitude tells us how far north or south something
    is from the equator, with the equator being 0\. This means that a positive number
    indicates we are north of the equator, and a negative number means we are going
    south from the equator. Longitude tells us how far east or west we are from the
    vertically centered line of the earth which, by convention, runs through Greenwich
    in London. Again, if we are moving east, the numbers are positive, while moving
    west from the line at Greenwich means the numbers will be negative.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度和经度是地理术语，用于准确标识地球上的位置。纬度告诉我们某物距赤道有多远，纬度为0。这意味着正数表示我们在赤道以北，负数表示我们在赤道以南。经度告诉我们我们距离地球的中心线有多远，按照惯例，这条线穿过伦敦的格林威治。同样，如果我们向东移动，数字是正数，而从格林威治线向西移动意味着数字将是负数。
- en: 'The model that represents this looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表示此模型如下所示：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be referring to both pins and points of interest throughout this section.
    They both represent the same thing, so we will be using them interchangeably.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将引用图钉和兴趣点。它们都代表同一件事，因此我们将交替使用它们。
- en: 'When we create an instance of this, we are going to use a GUID to represent
    it. Since the GUID is unique, we use it as a convenient way to find the point
    of interest when we move or remove it. This isn''t the exact representation of
    the way we are going to store our model in the database because this identifier
    is intended to make sense for tracking the pins on the map, not for tracking the
    pins in the database. To that end, we are going to add a separate model that we
    will use to store the model item in the database:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个实例时，我们将使用GUID来表示它。由于GUID是唯一的，我们将其用作查找兴趣点的便捷方式。这并不是我们将在数据库中存储模型的确切表示，因为此标识符旨在用于跟踪地图上的图钉，而不是用于跟踪数据库中的图钉。为此，我们将添加一个单独的模型，用于在数据库中存储模型项：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create this as an interface because Firebase expects to receive data only,
    with no class infrastructure surrounding it. We could have created `PinModel`
    as an interface as well, but the syntax for instantiating it is slightly more
    cumbersome, which is why we chose to create it as a class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其创建为接口，因为Firebase只希望接收数据，而不希望有围绕它的类基础设施。我们也可以将`PinModel`创建为接口，但是实例化它的语法稍微麻烦一些，这就是为什么我们选择将其创建为类的原因。
- en: With the models in place, we are now ready to hook up to Firebase. Rather than
    using the Firebase `npm` directly, we are going to use the official Angular Firebase
    library, called `AngularFire`. The `npm` reference for this is `@angular/fire`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些模型，我们现在准备连接到Firebase。我们将使用官方的Angular Firebase库`AngularFire`，而不是直接使用Firebase的`npm`。这个库的`npm`引用是`@angular/fire`。
- en: 'When we set up our Firebase datastore, we got the settings that we need to
    create a uniquely identified connection to it. We are going to copy these settings
    into our `environment.ts` and `environment.prod.ts` files. When we publish an
    application to production, Angular remaps `environment.prod.ts` to the environment
    file so that we can have separate dev and production settings:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置我们的Firebase数据存储时，我们得到了需要创建一个唯一标识连接的设置。我们将把这些设置复制到我们的`environment.ts`和`environment.prod.ts`文件中。当我们将应用程序发布到生产环境时，Angular会将`environment.prod.ts`重新映射到环境文件，以便我们可以拥有单独的开发和生产设置：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's generally bad practice to use the same endpoints for dev and production
    systems, so you could create a separate Firebase instance to hold the production
    mapping information and store that in `environment.prod.ts`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不建议在开发和生产系统中使用相同的端点，因此您可以创建一个单独的Firebase实例来保存生产映射信息，并将其存储在`environment.prod.ts`中。
- en: In `app.module`, we are going to import the `AngularFire` modules and then reference
    them in the imports. When we reference `AngularFireModule`, we call the static
    `initializeApp` method that will use the `environment.firebase` setting to establish
    a connection to Firebase.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.module`中，我们将导入`AngularFire`模块，然后在导入中引用它们。当我们引用`AngularFireModule`时，我们调用静态的`initializeApp`方法，该方法将使用`environment.firebase`设置来建立与Firebase的连接。
- en: 'First, the `import` statements are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`import`语句如下：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we set up the Angular `imports`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置Angular的`imports`：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Firebase''s functionality, it''s helpful to have a service as a single
    point of implementation for interacting with the database itself. That''s why
    we are going to create a `FirebaseMapPinsService`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Firebase的功能，有一个服务作为与数据库交互的单一实现点是有帮助的。这就是为什么我们将创建一个`FirebaseMapPinsService`：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside this class, we are going to use a feature from `AngularFire` called
    `AngularFirestoreCollection`. Firebase exposes the `Query` and `CollectionReference`
    types to perform CRUD operations on the underlying data from the database. `AngularFirestoreCollection`
    wraps this behavior into a handy stream for us. We set the generic type to `PinModelData`
    to say what data will be saved to the database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将使用`AngularFire`的一个功能，称为`AngularFirestoreCollection`。Firebase公开了`Query`和`CollectionReference`类型，以对数据库中的基础数据执行CRUD操作。`AngularFirestoreCollection`将此行为封装成一个方便的流。我们将通用类型设置为`PinModelData`，以说明将保存到数据库中的数据是什么：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our service is going to provide a model that creates an observable of a `PinModelData`
    array that hooks into the `pins` property. The way that we hook this all together
    lies inside the constructor that receives the `AngularFirestore`. The `pins` collection
    is associated with the underlying collection by passing in the name of the collection
    that will be stored in the database (which saves the data as documents in JSON).
    Our `Observable` listens to `valueChanges` on the collection, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将提供一个模型，创建一个`PinModelData`数组的可观察对象，连接到`pins`属性。我们将这一切连接在一起的方式在构造函数中，该构造函数接收`AngularFirestore`。通过传递将存储在数据库中的集合名称，`pins`集合与底层集合相关联（将数据保存为JSON文档）。我们的`Observable`监听集合上的`valueChanges`，如下所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One of the decisions I took when designing this application was that removing
    a pin from the UI should result in removing the associated point of interest from
    the database. Since it isn''t being referenced by anything else, we don''t need
    to keep it as reference data. Deleting the data is as simple as using `doc` to
    get the underlying document record from the datastore using the `storageId`, and
    then deleting it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计这个应用程序时，我做出的一个决定是，从UI中删除标记应该导致从数据库中删除相关的兴趣点。由于它没有被任何其他东西引用，我们不需要将其保留为引用数据。删除数据就像使用“doc”从数据存储中获取基础文档记录一样简单，然后将其删除：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the user adds a point of interest, we want to create a corresponding entry
    in the database, but when they move the pin, we want to update the record. Rather
    than using separate `Add` and `Update` methods, we can combine the logic into
    one method because we know that a record that has an empty `storageId` has not previously been
    saved to the database. Therefore, we give it a unique ID using the Firebase `createId`
    method. If `storageId` is present, then we want to update it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户添加一个兴趣点时，我们希望在数据库中创建相应的条目，但当他们移动标记时，我们希望更新记录。我们可以将逻辑合并到一个方法中，因为我们知道一个具有空“storageId”的记录之前没有保存到数据库中。因此，我们使用Firebase的“createId”方法为其提供一个唯一的ID。如果“storageId”存在，那么我们就要更新它：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Representing the map pins
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示地图标记
- en: 'It''s all very well us being able to save the pins to the database, but we
    also need a way to represent the pins on the map so that we can show them during
    the map session and move them as needed. This class will also act as the connection
    to the data service. The class that we are going to write will demonstrate a neat
    little trick introduced in TypeScript 3, called **rest tuples**, and starts off
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很好地将标记保存到数据库中，但我们还需要一种方法来表示地图上的标记，以便在地图会话期间显示它们并根据需要移动它们。这个类还将作为与数据服务的连接。我们将要编写的类将演示TypeScript
    3中引入的一个巧妙的小技巧，称为**rest tuples**，并且起始如下：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first feature we are going to introduce deals with adding the data for
    a pin when the user clicks on the map. The signature for this method looks a little
    bit strange, so we''ll take a minute or so to cover how it works. This is what
    the signature looks like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要引入的第一个功能涉及在用户点击地图时添加标记的数据。这个方法的签名看起来有点奇怪，所以我们将花一两分钟来解释它是如何工作的。签名看起来像这样：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we see `...args` as the last (or only) parameter, our immediate thought
    here is that we are going to be using a REST parameter. If we break the parameter
    list down from the start, we can think of this as starting off like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到`...args`作为最后（或唯一）参数时，我们立刻想到的是我们将使用REST参数。如果我们从开始就分解参数列表，我们可以将其看作是这样开始的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That almost looks like it makes sense, but there''s another REST parameter
    in there. This basically says that we can have any number of numbers at the end
    of the tuple. The reason that we have to apply `...` to this, rather than just
    applying `number[]`, is because we need to spread the elements out. If we just
    used the array format, we would have to push elements into this array in the calling
    code. With the REST parameter in the tuple, we can pull the data out, save it
    to the database, and add it to our `pins` array, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎看起来是有道理的，但在那里还有另一个REST参数。这基本上意味着我们可以在元组的末尾有任意数量的数字。我们必须对此应用“...”，而不仅仅是应用“number[]”，是因为我们需要展开元素。如果我们只使用数组格式，我们将不得不在调用代码中将元素推入这个数组。有了元组中的REST参数，我们可以取出数据，保存到数据库中，并将其添加到我们的“pins”数组中，就像这样：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The implication of using a tuple like this is that the calling code has to make
    sure that it is putting values into the correct location.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的元组的含义是，调用代码必须确保将值放入正确的位置。
- en: 'When we get to the code to call this, we can see that our method is called
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达调用这个代码的地方时，我们可以看到我们的方法是这样调用的：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the user moves a pin on the map, we will use a similar trick to update
    its location. All we need to do is find the model in our array and update its
    values. We even have to update the name because the act of moving the pin will
    change the address of the pin. We call the same `Save` method on our data service
    just like we did in our `Add` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在地图上移动标记时，我们将使用类似的技巧来更新其位置。我们所需要做的就是在数组中找到模型并更新其数值。我们甚至需要更新名称，因为移动标记的行为将改变标记的地址。我们在数据服务上调用相同的“Save”方法，就像我们在“Add”方法中所做的那样：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Other classes will need access to the data from the database too. We face two
    choices here—we could either have other classes also use the Firebase map service
    and potentially miss out calls to this class, or we could make this class the
    sole point of access to the map service. We are going to rely on this class to
    be the single point of contact with `FirebaseMapPinsService`, which means that
    we need to expose the `model` through a `Load` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类也需要访问数据库中的数据。我们在这里面临两个选择——我们可以让其他类也使用Firebase地图服务，并且可能错过对这个类的调用，或者我们可以使这个类成为地图服务的唯一访问点。我们将依赖这个类成为与“FirebaseMapPinsService”的唯一联系点，这意味着我们需要通过“Load”方法公开“model”：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Removing a point of interest uses a much simpler method signature than adding
    or moving one. All we need is the client-side `id` of the record, which we use
    to find the `PinModelData` item and call `Delete` to remove from Firebase. Once
    we have deleted the record, we find the local index of this record and remove
    it by splicing the array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 删除兴趣点使用的方法签名比添加或移动兴趣点简单得多。我们只需要记录的客户端端“id”，然后使用它来找到“PinModelData”项目并调用“Delete”从Firebase中删除。一旦我们删除了记录，我们就会找到这条记录的本地索引，并通过对数组进行拼接来删除它：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Trying interesting things with map searches
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试有趣的地图搜索
- en: When it comes to getting the name of the location where the user has placed
    the pin, or moved it to, we want this to happen automatically. We really don't
    want the user to have to type in this value when mapping can pick this for us
    automatically. This means that we are going to have to use mapping features to
    get this information for us.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到获取用户放置或移动图钉的位置名称时，我们希望这是自动发生的。我们真的不希望用户在映射时必须手动输入这个值，映射可以自动为我们选择。这意味着我们将不得不使用映射功能来为我们获取这些信息。
- en: 'Bing mapping has a number of optional modules, which we can opt into using,
    that give us the ability to do things such as searches based on location. In order
    to do this, we are going to create a class called `MapGeocode` that will do the
    searching for us:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 必应地图有许多可选模块，我们可以选择使用，这些模块使我们能够进行基于位置的搜索等操作。为了做到这一点，我们将创建一个名为`MapGeocode`的类，它将为我们进行搜索：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may notice that, for some of our classes, we are creating them without creating
    services. This implies that we are going to have to take care of manually instantiating
    the class ourselves. That is fine since we can control the lifetime of our class
    manually. If you want to, when you are recreating the code, you could convert
    classes such as `MapGeocode` into a service and inject it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，对于我们的一些类，我们是在没有创建服务的情况下创建它们的。这意味着我们将不得不手动实例化这个类。这没问题，因为我们可以手动控制我们类的生命周期。如果你愿意，在重新创建代码时，你可以将`MapGeocode`等类转换为服务并注入它。
- en: 'Since search is an optional feature, we need to load it in. To do that, we
    are going to pass in our map and use `loadModule` to load the `Microsoft.Maps.Search`
    module, passing in a new instance of `SearchManager` as the option:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于搜索是一个可选功能，我们需要加载它。为此，我们将传入我们的地图并使用`loadModule`来加载`Microsoft.Maps.Search`模块，传入`SearchManager`的新实例作为选项：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All that remains for us to do is write a method to perform the lookup. Since
    this could be a lengthy operation, we need to make this a `Promise` type, returning
    the string that will be populated with the name. Inside this `Promise`, we create
    a request containing the location and a callback that, when executed by the `reverseGeocode`
    method, will update the callback in the `Promise` with the name of the location.
    With this in place, we call `searchManager.reverseGeocode` to perform the search:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的所有事情就是编写一个执行查找的方法。由于这可能是一个耗时的操作，我们需要将其设置为`Promise`类型，返回将被填充为名称的字符串。在这个`Promise`中，我们创建一个包含位置的请求和一个回调，当`reverseGeocode`方法执行时，将使用位置的名称更新`Promise`中的回调。有了这个，我们调用`searchManager.reverseGeocode`来执行搜索：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Names matter in coding. In mapping, when we geocode, we convert a physical address
    into a location. The act of converting a location into an address is called **reverse
    geocoding**. That is why our method has the rather cumbersome name of `ReverseGeocode`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码中，名称很重要。在地图制作中，当我们进行地理编码时，我们将物理地址转换为位置。将位置转换为地址的行为称为**反向地理编码**。这就是为什么我们的方法有一个相当繁琐的名字`ReverseGeocode`。
- en: There is another type of search that we need to consider. We want a search that
    uses the visible map area (the viewport) to identify coffee shops in that area.
    To do this, we are going to use Microsoft's new Local Insights API to search for
    things such as businesses in a given area. There is a limitation to this implementation
    right now, in that Local Insights are only available for US addresses, but there
    are plans to roll this feature out across other countries and continents.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种类型的搜索需要考虑。我们希望进行一种使用可见地图区域（视口）来识别该区域内的咖啡店的搜索。为此，我们将使用微软的新Local Insights
    API来搜索特定区域内的企业等内容。目前这种实现有一个限制，即Local Insights仅适用于美国地址，但计划在其他国家和地区推出此功能。
- en: 'To show that we can still use mapping in services, we are going to create a
    `PointsOfInterestService` that accepts an `HttpClient`, which we will use to get
    the results of the REST call:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们仍然可以在服务中使用地图，我们将创建一个`PointsOfInterestService`，它接受一个`HttpClient`，我们将使用它来获取REST调用的结果：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The REST call endpoint accepts a query that tells us what type of businesses
    we are interested in, the location to use to perform the search, and the map key.
    Again, our search functionality could be long-running, so we will return a `Promise`,
    this time of a custom `PoiPoint` that returns the latitude and longitude, as well
    as the name of the business:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: REST调用端点接受一个查询，告诉我们我们感兴趣的企业类型，用于执行搜索的位置以及地图密钥。同样，我们的搜索功能可能是长时间运行的，所以我们将返回一个`Promise`，这次是一个自定义的`PoiPoint`，返回纬度和经度，以及企业的名称：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we call the API, we are going to use `http.get`, which returns an observable.
    We are going to `pipe` the result and `map` it using `MapData`. We will `subscribe`
    to the result and parse the results down (note that we don''t really know the
    returning type, so we will leave this as `any`). The returning type can contain
    multiple `resourceSets`, mostly for if we were going to have multiple types of
    query at once here, but we only have to concern ourselves with the initial `resourceSet`,
    which we will then use to extract the resources. The following code shows the
    format of the elements we are interested in from this search. When we have finished
    parsing our results, we are going to unsubscribe from the search subscription
    and call back on the `Promise` with the points we have just added:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用API时，我们将使用`http.get`，它返回一个observable。我们将使用`pipe`和`map`来使用`MapData`对结果进行转换。我们将订阅结果并解析结果（注意我们并不真正知道返回类型，所以我们将其留空为`any`）。返回类型可以包含多个`resourceSets`，大多用于一次性进行多种类型的查询，但我们只需要关注初始的`resourceSet`，然后用它来提取资源。以下代码显示了我们从这次搜索中感兴趣的元素的格式。当我们完成解析结果后，我们将取消订阅搜索订阅，并在`Promise`上回调刚刚添加的点：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our query, we are simply going to search at a point—we can easily extend
    this to search in a bounding box restricted to our view, if we wanted to, by accepting
    the map bounding box and changing `userLocation` to `userMapView=${boundingBox{0}},${boundingBox{1}},${boundingBox{2}},${boundingBox{3}}`
    (where `boundingBox` is a rectangle). For further details about extending the
    search, see [https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10)](https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的查询中，我们只是在一个点上搜索——如果需要的话，我们可以很容易地扩展到在我们的视图范围内搜索一个边界框，方法是接受地图边界框并将`userLocation`更改为`userMapView=${boundingBox{0}},${boundingBox{1}},${boundingBox{2}},${boundingBox{3}}`（其中`boundingBox`是一个矩形）。有关扩展搜索的更多细节，请参见[https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10)](https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10))。
- en: Now that we have the map searching functionality and the database functionality
    done, wouldn't it be great to actually put a map on the screen? Let's take care
    of that now.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了地图搜索功能和数据库功能，是时候在屏幕上实际放置地图了。让我们现在来处理这个问题。
- en: Adding Bing Maps to the screen
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Bing地图添加到屏幕上
- en: 'Like we covered previously, we are going to use two components to display the
    maps. Let''s start with the `MapViewComponent`. The HTML template for this control
    is really straightforward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的那样，我们将使用两个组件来显示地图。让我们从`MapViewComponent`开始。这个控件的HTML模板非常简单：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Yes, that really is all there is to our HTML. What goes on behind it is a bit
    more complicated, and this is where we are going to learn how Angular lets us
    hook into standard DOM events. We normally don''t show the whole `@Component`
    element because it is pretty much boilerplate code, but in this case, we are going
    to have to do something a little bit different. Here''s the first part of our
    component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这确实是我们的HTML的全部内容。它背后发生的事情要复杂一些，这就是我们将学习Angular如何让我们连接到标准DOM事件的地方。我们通常不显示整个`@Component`元素，因为它几乎是样板代码，但在这种情况下，我们将不得不做一些稍微不同的事情。这是我们组件的第一部分：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `@Component` section, we hook the window load event up to the `Loaded`
    method. We will add this method shortly, but for now, it's important to know that
    this is how we hook a component up to an event from the host. Inside the component,
    we use an `@ViewChild` to hook up to the `div` in our template. Basically, this
    allows us to reference an element inside our view by name so that we can work
    with it in some arbitrary way.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`部分，我们将窗口加载事件挂钩到`Loaded`方法。我们很快会添加这个方法，但现在知道这是我们如何将组件挂钩到主机事件的方式很重要。在组件内部，我们使用`@ViewChild`来挂钩到我们模板中的`div`。基本上，这允许我们通过名称引用视图内的元素，以便我们可以以某种任意的方式处理它。
- en: 'The reason we added a `Loaded` method is because Bing Maps have a particularly
    nasty habit of not working properly in browsers such as Chrome or Firefox unless
    we hook the map up in the `window.load` event. We are going to host the map inside
    the `div` statement we added to the template using a series of map load options,
    which includes the map credentials and the default zoom level:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`Loaded`方法的原因是因为Bing地图有一个特别讨厌的习惯，即在Chrome或Firefox等浏览器中不正常工作，除非我们在`window.load`事件中挂接地图。我们将在模板中添加一个`div`语句来托管地图，使用一系列地图加载选项，包括地图凭据和默认缩放级别：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to choose a particular type of map type to display, we can set this
    in the map load options as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想选择特定类型的地图类型来显示，我们可以在地图加载选项中设置如下：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `MapViewComponent` is going to be hosted inside another component, so we
    will create an `EventEmitter` that we can use to notify the parent. We already
    added the emit code in our `Loaded` method, passing the map we just loaded back
    to the parent:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MapViewComponent`将托管在另一个组件内部，因此我们将创建一个`EventEmitter`，我们可以用它来通知父组件。我们已经在我们的`Loaded`方法中添加了发射代码，将刚加载的地图传回给父组件：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s add the parent container now. Most of the template is just taken up
    with creating the Bootstrap containers with the rows and columns. Inside the `div` column, we
    are going to host the child component we just created. Again, we can see that
    we use the `EventEmitter`, so when the map is emitted, it triggers the `MapLoaded`
    event:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加父容器。大部分模板只是用来创建带有行和列的Bootstrap容器。在`div`列内，我们将托管刚刚创建的子组件。同样，我们可以看到我们使用了`EventEmitter`，所以当地图被发射时，它触发`MapLoaded`事件：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Most of the mapping container code should be familiar territory to us by now.
    We inject `FirebaseMapPinsService` and `PointsOfInterestService`, which we use
    to create a `MapEvents` instance in the `MapLoaded` method. In other words, when
    the `atp-map-view` component hits `window.load`, the populated Bing map comes
    back through:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数映射容器代码现在应该是我们熟悉的领域。我们注入`FirebaseMapPinsService`和`PointsOfInterestService`，我们用它们在`MapLoaded`方法中创建`MapEvents`实例。换句话说，当`atp-map-view`组件触发`window.load`时，填充的Bing地图就会回来：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A note on displaying the map—we really need to set the height of `html` and
    `body` so that it stretches to the full height of the browser window. Set this
    in the `styles.scss` file, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于显示地图的说明——我们确实需要设置`html`和`body`的高度，以使其延伸到浏览器窗口的全高。在`styles.scss`文件中设置如下：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The map events and setting pins
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图事件和设置标记
- en: 'We have maps, and we have the logic to save points of interest to databases
    and to move them in memory. The one thing we don''t have is the code to handle
    the user actually creating and managing the pins from the map itself. It''s time
    to rectify that situation and add in a `MapEvents` class that will handle this
    for us. Just like the `MapGeocode`, `PinModel`, and `PinsModel` classes, this
    class is a standalone implementation. Let''s start by adding the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有地图，我们有逻辑来将兴趣点保存到数据库并在内存中移动它们。我们唯一没有的是处理用户实际从地图本身创建和管理标记的代码。现在是时候纠正这种情况并添加一个`MapEvents`类来为我们处理这个问题。就像`MapGeocode`、`PinModel`和`PinsModel`类一样，这个类是一个独立的实现。让我们从添加以下代码开始：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Infobox` is the box that appears when we add a point of interest to the screen.
    We could add a new one when each point of interest is added, but this would be
    a waste of resources. Instead, we are going to add a single `Infobox` and reuse
    it when we add new points on the screen. To do this, we are going to add a helper
    method that checks whether the `Infobox` has been set or not previously. If it
    has not been set before, we will instantiate a new instance of the `Infobox`,
    taking in the pin location, the title, and description. We will be supplying the
    name of the point as the description. We need to set the map instance that this
    will appear on using `setMap`. When we reuse this `Infobox`, all we need to do
    is set the same values in the options and then set the visibility to `true`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infobox`是在将兴趣点添加到屏幕上时出现的框。我们可以在添加每个兴趣点时添加一个新的，但这将是一种资源浪费。相反，我们将添加一个单独的`Infobox`，并在添加新点时重用它。为此，我们将添加一个辅助方法，检查之前是否已设置`Infobox`。如果之前没有设置，我们将实例化`Infobox`的新实例，输入图钉位置、标题和描述。我们将使用`setMap`来设置此`Infobox`将出现在的地图实例。当我们重用这个`Infobox`时，我们只需要在选项中设置相同的值，然后将可见性设置为`true`：'
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are a couple of helper methods we still need to add to this class before
    we add the ability to select points from the map. The first one we are going to
    add takes the points of interest from the Local Insights search and adds them
    to the map. Here, we can see that the way that we add a pin is to create a green
    `Pushpin`, which then gets added onto our Bing map at the correct `Location`.
    We also add an event handler that reacts to a click on the pin and shows the `Infobox`
    using the method we just added:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加从地图中选择点的能力之前，我们还需要向这个类添加一些辅助方法。我们要添加的第一个方法是从本地见解搜索中获取兴趣点并将它们添加到地图上。在这里，我们可以看到我们添加图钉的方式是创建一个绿色的`Pushpin`，然后将其添加到我们的Bing地图上的正确`Location`。我们还添加了一个事件处理程序，以响应对图钉的点击，并使用我们刚刚添加的方法显示`Infobox`：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next helper method is more complicated, so we will add it in stages. The
    `AddPushPin` code is going to be called when the user clicks on the map. The signature
    looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个辅助方法更复杂，所以我们将分阶段添加它。当用户在地图上单击时，将调用`AddPushPin`代码。签名如下：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first thing that we are going to do in this method is create a `Guid` to
    use when we add a `PinsModel` entry and add a draggable `Pushpin` at the click
    location:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们要做的第一件事是创建一个`Guid`，用于在添加`PinsModel`条目时使用，并在点击位置添加一个可拖动的`Pushpin`：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this in place, we are going to call the `ReverseGeocode` method we wrote
    earlier. When we get the result from this, we will add our `PinsModel` entry and
    push the `Pushpin` onto the map before we show the `Infobox`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个方法，我们将调用之前编写的`ReverseGeocode`方法。当我们从中获取结果时，我们将添加我们的`PinsModel`条目，并在显示`Infobox`之前将`Pushpin`推到地图上：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We haven''t finished with this method yet. As well as adding a `Pushpin`, we
    also have to be able to drag it so that the user can choose a new location for
    it when they drag the pin. We are going to use the `dragend` event to move the
    pin. Again, the hard work we put in earlier pays dividends, because we have a
    simple mechanism to `Move` the `PinsModel` and display our `Infobox`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成这个方法。除了添加一个`Pushpin`，我们还必须能够拖动它，以便用户在拖动图钉时选择一个新的位置。我们将使用`dragend`事件来移动图钉。同样，我们之前付出的辛苦工作得到了回报，因为我们有一个简单的机制来`Move`
    `PinsModel`并显示我们的`Infobox`：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, when the user clicks a pin, we want to remove the pin from the `PinsModel`
    and the map. When we added the event handlers for `dragend` and `click`, we saved
    the handlers to variables so that we can use them to remove the event handlers
    from the map events. Tidying up after ourselves is good practice, especially when
    dealing with things like event handlers:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户点击图钉时，我们希望从`PinsModel`和地图中删除图钉。当我们为`dragend`和`click`添加事件处理程序时，我们将处理程序保存到变量中，以便我们可以使用它们从地图事件中删除事件处理程序。自我整理是一个好习惯，特别是在处理事件处理程序之类的事情时：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Well, that''s our helper methods in place. All we need to do now is update
    the constructor to add the ability to `click` on the map to set a point of interest
    and search for Local Insights when the viewport that the user is looking at changes.
    Let''s start with responding to the user clicking on the map:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们的辅助方法已经就位。现在我们只需要更新构造函数，以便在地图上单击以设置兴趣点并在用户查看的视口发生变化时搜索本地见解。让我们从响应用户在地图上单击开始：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We don't need to store the handler as a variable here because we are associating
    it with something that won't be removed at any stage while the application is
    live in the browser; namely, the map itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要将处理程序存储为变量，因为我们将其与在浏览器中运行时不会被移除的东西关联起来，即地图本身。
- en: 'When the user moves the map around so that they can see other areas, we need
    to perform the Local Insights search and, based on the results that come back,
    add the points of interest. We attach an event handler to the map `viewchangeend`
    event to trigger this search:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动地图以便查看其他区域时，我们需要执行本地见解搜索，并根据返回的结果添加兴趣点。我们将事件处理程序附加到地图`viewchangeend`事件以触发此搜索：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We keep seeing that preparing methods beforehand can save us so much time later
    on. We are simply leveraging the `PointsOfInterestService.Search` method to do
    our Local Insights search for us, and then pumping the results into our `AddPoi`
    method if we get any back. If we don't want to perform the Local Insights search,
    we can simply remove this event handler and won't need to do any searching.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断看到事先准备方法可以节省我们很多时间。我们只是利用`PointsOfInterestService.Search`方法来进行本地见解搜索，然后将结果传递给我们的`AddPoi`方法。如果我们不想执行本地见解搜索，我们可以简单地删除此事件处理程序，而无需进行任何搜索。
- en: 'The only thing that we have left to do is handle the loading in of our pins
    from the database. The code here is a variation of the code we have seen already
    for adding the `click` and `dragend` handlers, but we don''t need to perform the
    geocoding, since we already have the name of each point of interest. Therefore,
    we aren''t going to reuse the `AddPushPin` method. Instead, we will opt to do
    this whole section inline. The load subscription looks as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一剩下要做的就是处理从数据库加载我们的标记。这里的代码是我们已经看到的用于添加`click`和`dragend`处理程序的代码的变体，但我们不需要执行地理编码，因为我们已经有了每个兴趣点的名称。因此，我们不打算重用`AddPushPin`方法。相反，我们将选择在整个部分内联执行。加载订阅如下所示：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The point to note with this code snippet is that, since we are dealing with
    a subscription, once we have completed the subscription, we `unsubscribe` from
    it. The subscription should return an array of `PinModelData` items that we iterate
    over, adding in the elements as needed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，由于我们正在处理订阅，一旦完成订阅，我们就会从中`取消订阅`。订阅应返回一个`PinModelData`项目数组，我们可以遍历并根据需要添加元素。
- en: That's it. We now have a working mapping solution in place. This was one of
    the chapters I was looking forward to writing the most because I love mapping
    applications. I hope you have as much fun with this as I have. Before we leave
    this chapter, though, if you want to prevent people from getting unsecured access
    to the data, you can apply that knowledge in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们现在已经有了一个可用的映射解决方案。这是我最期待写的章节之一，因为我喜欢映射应用程序。我希望你和我一样享受这个过程。然而，在我们离开这一章之前，如果你想防止人们未经授权访问数据，你可以在下一节中应用这些知识。
- en: Securing the database
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护数据库
- en: This section is an optional overview of what we would need to do to provide
    security for the database. As you may remember, when we created our Firestore
    database, we set it up so that access was available to anyone, completely unrestricted.
    That's fine while you're developing a small test application, but it's generally
    not what you are going to want to deploy as a commercial application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是提供数据库安全性所需的可选概述。您可能还记得，当我们创建Firestore数据库时，我们设置了访问权限，以便任何人都可以完全不受限制地访问。在开发小型测试应用程序时这没问题，但通常不适用于商业应用程序的部署。
- en: We are going to change the configuration of our database so that we only allow
    read/write access if the authorization ID is set. To do this, select the Rules
    tab in the Database and add `if request.auth.uid != null;` to the rules list.
    The format of `match /{document=**}` simply means that this rule applies to any
    document in the list. It is possible to set up rules that would only apply to
    certain documents, but that doesn't make much sense in the context of an application
    like this.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改数据库的配置，以便只有在授权ID设置时才允许读/写访问。为此，请在数据库中选择“规则”选项卡，并将`if request.auth.uid !=
    null;`添加到规则列表中。`match /{document=**}`的格式简单地意味着这个规则适用于列表中的任何文档。可以设置只适用于特定文档的规则，但在这样的应用程序环境中并没有太多意义。
- en: 'Note that doing this means that we would have to add in authentication, just
    like we did in [Chapter 6](9b60d7b2-7831-4125-b975-4a10c32b1cae.xhtml), *Building
    a Chat Room Application Using Socket.IO*. Setting this up is outside the scope
    of this chapter, but copying over the navigation and providing login features
    from the previous chapter should be straightforward:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这样做意味着我们必须添加身份验证，就像我们在[第6章](9b60d7b2-7831-4125-b975-4a10c32b1cae.xhtml)中所做的那样，*使用Socket.IO构建聊天室应用程序*。设置这一点超出了本章的范围，但从上一章复制导航并提供登录功能应该很简单：
- en: '![](assets/7bd73cd5-8073-493f-aefe-9725e47bee1c.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7bd73cd5-8073-493f-aefe-9725e47bee1c.png)'
- en: This has been quite a journey. We have gone through the process of signing up
    for different online services and brought mapping features into our code. At the
    same time, we have seen how we can scaffold an Angular application with TypeScript
    support, without having to generate and register services. You should now be able
    to take this code and look to add the mapping features that you really want.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当漫长的旅程。我们经历了注册不同在线服务的过程，并将映射功能引入了我们的代码。与此同时，我们还看到了如何使用TypeScript支持在Angular应用程序中搭建脚手架，而无需生成和注册服务。现在，您应该能够拿起这段代码，并尝试添加您真正想要的映射功能。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reached the conclusion of projects that work with Angular,
    which we introduced using cloud services from Microsoft and Google in the form
    of Bing Maps and Firebase cloud services for storing data. We signed up to these
    services and obtained the relevant information from them in order to set up client
    access to them. In the course of writing our code, we have created classes to
    work with the Firestore database and interact with Bing Maps to do things such
    as search for addresses based on user clicks, leading to us adding pins to a map,
    as well as searching for coffee shops using Local Insights.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经完成了使用Microsoft和Google的云服务引入Angular项目的工作，这些云服务以Bing Maps和Firebase云服务的形式存储数据。我们注册了这些服务，并从中获取了相关信息，以便为客户端访问它们。在编写代码的过程中，我们创建了与Firestore数据库一起工作的类，并与Bing
    Maps交互，执行诸如基于用户点击搜索地址、在地图上添加标记以及使用本地洞察力搜索咖啡店等操作。
- en: Continuing our journey of TypeScript, we introduced rest tuples. We also saw
    how to add code to Angular components to react to browser host events.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的TypeScript之旅，我们介绍了rest元组。我们还看到如何向Angular组件添加代码以响应浏览器主机事件。
- en: In the next chapter, we are going to revisit React. This time, we will be creating
    a limited microservice CRM that uses Docker to contain the various microservices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重新审视React。这一次，我们将创建一个使用Docker包含各种微服务的有限微服务CRM。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does Angular allow us to interact with a host element?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular如何允许我们与主机元素交互？
- en: What are latitude and longitude?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纬度和经度是什么？
- en: What is the purpose of reverse geocoding?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆地理编码的目的是什么？
- en: What service are we using to store our data?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪项服务来存储我们的数据？
