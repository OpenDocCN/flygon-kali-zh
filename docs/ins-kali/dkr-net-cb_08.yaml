- en: Chapter 8. Working with Flannel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Flannel
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Installing and configuring Flannel
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Flannel
- en: Integrating Flannel with Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Flannel与Docker集成
- en: Using the VXLAN backend
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VXLAN后端
- en: Using the host gateway backend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机网关后端
- en: Specifying Flannel options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定Flannel选项
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Flannel is a third-party network solution for Docker that was developed by the
    team at **CoreOS**. Flannel was one of the earlier projects that aimed to give
    each container a uniquely routable IP address. This removes the requirement for
    inter-host container-to-container communication to use published ports. Much like
    some of the other solutions we've reviewed, Flannel uses a key-value store to
    keep track of allocations and various other configuration settings. However, unlike
    Weave, Flannel offers no direct integration with the Docker service offering no
    plugin. Rather, Flannel relies on you telling Docker to use the Flannel network
    to provision containers. In this chapter, we'll walk through how to install Flannel
    as well as walk through its various configuration options.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel是由**CoreOS**团队开发的Docker的第三方网络解决方案。Flannel是早期旨在为每个容器提供唯一可路由IP地址的项目之一。这消除了跨主机容器到容器通信需要使用发布端口的要求。与我们审查过的其他一些解决方案一样，Flannel使用键值存储来跟踪分配和各种其他配置设置。但是，与Weave不同，Flannel不提供与Docker服务的直接集成，也不提供插件。相反，Flannel依赖于您告诉Docker使用Flannel网络来配置容器。在本章中，我们将介绍如何安装Flannel以及其各种配置选项。
- en: Installing and configuring Flannel
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Flannel
- en: In this recipe, we'll walk through the installation of Flannel. Flannel requires
    the installation of a key store and Flannel service. Due to the dependencies of
    each of these, they need to be configured as actual services on the Docker hosts.
    To do this, we'll leverage `systemd` unit files to define each respective service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将介绍安装Flannel。Flannel需要安装一个密钥存储和Flannel服务。由于每个服务的依赖关系，它们需要在Docker主机上配置为实际服务。为此，我们将利用`systemd`单元文件来定义每个相应的服务。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we''ll be using the same lab topology we used in [Chapter
    3](ch03.html "Chapter 3. User-Defined Networks"), *User-Defined Networks*, where
    we discussed user-defined overlay networks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用与[第3章](ch03.html "第3章。用户定义的网络")中使用的相同的实验拓扑，*用户定义的网络*，在那里我们讨论了用户定义的覆盖网络：
- en: '![Getting ready](graphics/B05453_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B05453_08_01.jpg)'
- en: You'll need a couple of hosts, preferably with some of them being on different
    subnets. It is assumed that the Docker hosts used in this lab are in their default
    configuration. In some cases, the changes we make may require you to have root-level
    access to the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一对主机，最好其中一些位于不同的子网上。假设在这个实验中使用的Docker主机处于它们的默认配置中。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: As mentioned, Flannel relies on a key-value store to provide information to
    all the nodes participating in the Flannel network. In other examples, we've run
    a container-based key-value store such as Consul to provide this functionality.
    Since Flannel was built by CoreOS, we'll be leveraging their key-value store named
    `etcd`. And while `etcd` is offered in a container format, we can't easily use
    the container-based version due to some of the prerequisites required for Flannel
    to work. That being said, we'll be downloading the binaries for both `etcd` and
    Flannel and running them as services on our hosts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Flannel依赖于一个键值存储来向参与Flannel网络的所有节点提供信息。在其他示例中，我们运行了基于容器的键值存储，如Consul，以提供此功能。由于Flannel是由CoreOS构建的，我们将利用他们的键值存储`etcd`。虽然`etcd`以容器格式提供，但由于Flannel工作所需的一些先决条件，我们无法轻松使用基于容器的版本。也就是说，我们将下载`etcd`和Flannel的二进制文件，并在我们的主机上将它们作为服务运行。
- en: 'Let''s start with `etcd` since it''s a perquisite for Flannel. The first thing
    you need to do is download the code. In this example, we''ll be leveraging `etcd`
    version 3.0.12 and running the key-value store on the host `docker1`. To download
    the binary, we''ll run this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`etcd`开始，因为它是Flannel的先决条件。你需要做的第一件事是下载代码。在这个例子中，我们将利用`etcd`版本3.0.12，并在主机`docker1`上运行键值存储。要下载二进制文件，我们将运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once downloaded, we can extract the binaries from the archive using this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，我们可以使用以下命令从存档中提取二进制文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And then we can move the binaries we need into the correct location to make
    them executable. In this case, the location is `/usr/bin` and the binaries we
    want are the `etcd` service itself as well as its command-line tool named `etcdctl`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将需要的二进制文件移动到正确的位置，使它们可以执行。在这种情况下，位置是`/usr/bin`，我们想要的二进制文件是`etcd`服务本身以及其命令行工具`etcdctl`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have all the pieces in place, the last thing we need to do is to
    create a service on the system that will take care of running `etcd`. Since our
    version of Ubuntu is using `systemd`, we''ll need to create a unit file for the
    `etcd` service. To create the service definition, you can create a service unit
    file in the `/lib/systemd/system/` directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有的部件都放在了正确的位置，我们需要做的最后一件事就是在系统上创建一个服务，来负责运行`etcd`。由于我们的Ubuntu版本使用`systemd`，我们需要为`etcd`服务创建一个unit文件。要创建服务定义，您可以在`/lib/systemd/system/`目录中创建一个服务unit文件：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you can create a service definition to run `etcd`. An example unit file
    for the `etcd` service is shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个运行`etcd`的服务定义。`etcd`服务的一个示例unit文件如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that `systemd` can be configured in many different ways based on
    your requirements. The unit file given earlier demonstrates one way to configure
    `etcd` as a service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`systemd`可以根据您的要求以许多不同的方式进行配置。前面给出的unit文件演示了配置`etcd`作为服务的一种方式。
- en: 'Once the unit file is in place, we can reload `systemd` and then enable and
    start the service:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦unit文件就位，我们可以重新加载`systemd`，然后启用并启动服务：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If for some reason the service doesn''t start or stay started, you can check
    the status of the service by using the `systemctl status etcd` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因服务无法启动或保持启动状态，您可以使用`systemctl status etcd`命令来检查服务的状态：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Later on, if you're having issues with Flannel-enabled nodes being able to talk
    to `etcd`, check and make sure that `etcd` is allowing access on all interfaces
    (`0.0.0.0`) as shown in the preceding bolded output. This is defined in the sample
    unit file provided, but if not defined, `etcd` will default to only listen on
    the local loopback interface (`127.0.0.1`). This will prevent remote servers from
    accessing the service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，如果您在使用启用Flannel的节点与`etcd`通信时遇到问题，请检查并确保`etcd`允许在所有接口（`0.0.0.0`）上访问，如前面加粗的输出所示。这在示例单元文件中有定义，但如果未定义，`etcd`将默认仅在本地环回接口（`127.0.0.1`）上侦听。这将阻止远程服务器访问该服务。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the key-value store configuration is being done explicitly to demonstrate
    Flannel, we won't be covering the basics of key-value stores. These configuration
    options are enough to get you up and running on a single node and are not intended
    to be used in a production environment. Please make sure that you understand how
    `etcd` works before using it in a production setting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于键值存储配置是明确为了演示Flannel而进行的，我们不会涵盖键值存储的基础知识。这些配置选项足以让您在单个节点上运行，并且不打算在生产环境中使用。在将其用于生产环境之前，请确保您了解`etcd`的工作原理。
- en: 'Once the `etcd` service is started, we can then use the `etcdctl` command-line
    tool to configure some of the base settings in Flannel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了`etcd`服务，我们就可以使用`etcdctl`命令行工具来配置Flannel的一些基本设置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll discuss these configuration options in a later recipe, but for now, just
    know that the subnet we defined as the `Network` parameter defines the Flannel
    global scope.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后的教程中讨论这些配置选项，但现在只需知道我们定义为`Network`参数的子网定义了Flannel的全局范围。
- en: 'Now that we have `etcd` configured, we can focus on configuring Flannel itself.
    The configuration of Flannel as a service on the system is very similar to what
    we just did for `etcd`. The major difference is that we''ll be doing this same
    configuration on all four lab hosts, whereas the key-value store was only configured
    on a single host. We''ll show the installation of Flannel on a single host, `docker4`,
    but you''ll need to repeat these steps on each host in your lab environment that
    you wish to be a member of the Flannel network:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了`etcd`，我们可以专注于配置Flannel本身。将Flannel配置为系统服务与我们刚刚为`etcd`所做的非常相似。主要区别在于我们将在所有四个实验室主机上进行相同的配置，而键值存储只在单个主机上配置。我们将展示在单个主机`docker4`上安装Flannel，但您需要在实验室环境中的每个主机上重复这些步骤，以便成为Flannel网络的成员：
- en: 'First, we''ll download the Flannel binary. In this example, we''ll be using
    version 0.5.5:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将下载Flannel二进制文件。在本例中，我们将使用版本0.5.5：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need to extract the files from the archive and move the `flanneld`
    binary to the correct location. Note that there is no command-line tool to interact
    with Flannel as there was with `etcd`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从存档中提取文件并将`flanneld`二进制文件移动到正确的位置。请注意，与`etcd`一样，没有命令行工具与Flannel交互：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As with `etcd`, we want to define a `systemd` unit file so that we can run
    `flanneld` as a service on each host. To create the service definition, you can
    create another service unit file in the `/lib/systemd/system/` directory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与`etcd`一样，我们希望定义一个`systemd`单元文件，以便我们可以在每个主机上将`flanneld`作为服务运行。要创建服务定义，您可以在`/lib/systemd/system/`目录中创建另一个服务单元文件：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you can create a service definition to run `etcd`. An example unit file
    for the `etcd` service is shown as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个运行`etcd`的服务定义。`etcd`服务的示例单元文件如下所示：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the unit file is in pace, we can reload `systemd` and then enable and
    start the service:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单元文件就位，我们可以重新加载`systemd`，然后启用并启动服务：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If, for some reason, the service doesn''t start or stay started, you can check
    the status of the service using the `systemctl status flanneld` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因服务无法启动或保持启动状态，您可以使用`systemctl status flanneld`命令来检查服务的状态：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see similar output in your log indicating that Flannel found a lease
    within the global scope allocation you configured in `etcd`. These leases are
    local to each host and I often refer to them as local scopes or networks. The
    next step is to complete this configuration on the remaining hosts. By checking
    the Flannel log on each host, I can tell what subnets were allocated to each host.
    In my case, this is what I ended up with:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在日志中看到类似的输出，表明Flannel在您配置的`etcd`全局范围分配中找到了一个租约。这些租约对每个主机都是本地的，我经常将它们称为本地范围或网络。下一步是在其余主机上完成此配置。通过检查每个主机上的Flannel日志，我可以知道为每个主机分配了哪些子网。在我的情况下，我得到了以下结果：
- en: '`docker1`: `10.100.93.0/24`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker1`：`10.100.93.0/24`'
- en: '`docker2`: `10.100.58.0/24`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker2`：`10.100.58.0/24`'
- en: '`docker3`: `10.100.90.0/24`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker3`：`10.100.90.0/24`'
- en: '`docker4`: `10.100.15.0/24`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker4`：`10.100.15.0/24`'
- en: At this point, Flannel is fully configured. In the next recipe, we'll discuss
    how to configure Docker to consume the Flannel network.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Flannel已经完全配置好了。在下一个教程中，我们将讨论如何配置Docker来使用Flannel网络。
- en: Integrating Flannel with Docker
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Flannel与Docker集成
- en: As we mentioned earlier, there is currently no direct integration between Flannel
    and Docker. That being said, we'll need to find a way to get the containers onto
    the Flannel network without Docker directly knowing that's what's happening. In
    this recipe, we'll show how this is done, discuss some of the perquisites that
    led to our current configuration, and see how Flannel handles host-to-host communication.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，目前Flannel和Docker之间没有直接集成。也就是说，我们需要找到一种方法将容器放入Flannel网络，而Docker并不直接知道正在发生的事情。在这个教程中，我们将展示如何做到这一点，讨论导致我们当前配置的一些先决条件，并了解Flannel如何处理主机之间的通信。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off the lab described in the previous recipe.
    In some cases the changes we make may require you to have root-level access to
    the system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建上一个教程中描述的实验室。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the previous recipe, we configured Flannel, but we didn''t examine what
    the Flannel configuration actually did from a network perspective. Let''s take
    a quick look at the configuration of one of our Flannel-enabled hosts to see what''s
    changed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们配置了Flannel，但我们并没有从网络的角度实际检查Flannel配置到底做了什么。让我们快速查看一下我们的一个启用了Flannel的主机的配置，看看发生了什么变化：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll note the addition of a new interface named `flannel0`. You''ll also
    note that it has an IP address within the `/24` local scope that was assigned
    to this host. If we dig a little deeper, we can use `ethtool` to determine that
    this interface is a virtual `tun` interface:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到一个名为`flannel0`的新接口的添加。您还会注意到它具有分配给此主机的`/24`本地范围内的IP地址。如果我们深入挖掘一下，我们可以使用`ethtool`来确定这个接口是一个虚拟的`tun`接口。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Flannel creates this interface on each host where the Flannel service is running.
    Note that the subnet mask of the `flannel0` interface is a `/16`, which covers
    the entire global scope allocation we defined in `etcd`. Despite allocating the
    host a `/24` scope, the host believes that the entire `/16` is reachable through
    the `flannel0` interface:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel在运行Flannel服务的每个主机上创建了这个接口。请注意，`flannel0`接口的子网掩码是`/16`，它覆盖了我们在`etcd`中定义的整个全局范围分配。尽管为主机分配了`/24`范围，但主机认为整个`/16`都可以通过`flannel0`接口访问：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Having the interface present creates this route, which ensures that traffic
    headed to any of the assigned local scopes on other hosts goes through the `flannel0`
    interface. We can prove that this works by pinging the other `flannel0` interfaces
    on the other hosts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了接口后，就会创建这条路由，确保前往其他主机上分配的本地范围的流量通过`flannel0`接口。我们可以通过ping其他主机上的其他`flannel0`接口来证明这一点：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the physical network has no knowledge of the `10.100.0.0/16` network
    space, Flannel must encapsulate the traffic as it traverses the physical network.
    In order to do this, it needs to know what physical Docker host has a given scope
    assigned to it. Recall from the Flannel logs we examined in the previous recipe
    that Flannel chose an external interface for each host based on the host''s default
    route:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物理网络对`10.100.0.0/16`网络空间一无所知，Flannel必须在流经物理网络时封装流量。为了做到这一点，它需要知道哪个物理Docker主机分配了给定的范围。回想一下我们在上一篇示例中检查的Flannel日志，Flannel根据主机的默认路由为每个主机选择了一个外部接口：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This information, along with the scope assigned to each host, is registered
    in the key-value store. Using this information, Flannel can determine which host
    has which scope assigned and can use the external interface of that host as a
    destination to send the encapsulated traffic towards.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息以及分配给每个主机的范围都在键值存储中注册。使用这些信息，Flannel可以确定哪个主机分配了哪个范围，并可以使用该主机的外部接口作为发送封装流量的目的地。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flannel supports multiple backends or transport mechanisms. By default, it encapsulates
    traffic in UDP on port `8285`. In the upcoming recipes, we'll discuss other backend
    options.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel支持多个后端或传输机制。默认情况下，它会在端口`8285`上使用UDP封装流量。在接下来的示例中，我们将讨论其他后端选项。
- en: 'Now that we know how Flannel works, we need to sort out how to get the actual
    Docker containers onto the Flannel network. The easiest way to do this is to have
    Docker use the assigned scope as the subnet for the `docker0` bridge. Flannel
    writes the scope information out to a file saved in `/run/flannel/subnet.env`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了Flannel的工作原理，我们需要解决如何将实际的Docker容器放入Flannel网络中。最简单的方法是让Docker使用分配的范围作为`docker0`桥接的子网。Flannel将范围信息写入一个文件，保存在`/run/flannel/subnet.env`中：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using this information, we can configure Docker to use the correct subnet for
    its bridge interface. Flannel offers two ways to do this. The first involves generating
    a new Docker configuration file using a script that was included along with the
    Flannel binary. The script allows you to output a new Docker configuration file
    that uses the information from the `subnet.env` file. For example, we can use
    the script to generate a new configuration as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些信息，我们可以配置Docker使用正确的子网作为其桥接接口。Flannel提供了两种方法来实现这一点。第一种方法涉及使用随Flannel二进制文件一起提供的脚本生成新的Docker配置文件。该脚本允许您输出一个使用`subnet.env`文件中信息的新Docker配置文件。例如，我们可以使用该脚本生成一个新的配置，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In systems that don''t leverage `systemd` Docker will, in most cases, automatically
    check the file `/etc/default/docker` for service-level options. This means that
    we could simply have Flannel write the earlier-mentioned configuration file out
    to `/etc/default/docker`, which will allow Docker to consume the new settings
    when the service reloads. However, since our system uses `systemd`, this method
    would require updating our Docker drop-in file (`/etc/systemd/system/docker.service.d/docker.conf`)
    to look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用`systemd`的系统中，Docker在大多数情况下会自动检查`/etc/default/docker`文件以获取服务级选项。这意味着我们可以简单地让Flannel将前面提到的配置文件写入`/etc/default/docker`，这样当服务重新加载时，Docker就可以使用新的设置。然而，由于我们的系统使用`systemd`，这种方法需要更新我们的Docker
    drop-in文件(`/etc/systemd/system/docker.service.d/docker.conf`)，使其如下所示：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The bolded lines indicate that the service should check the file `etc/default/docker`
    and then load the variable `$DOCKER_OPTS` to be passed to the service at runtime.
    If you use this method, it might be wise to define all your service-level options
    in `etc/default/docker` for the sake of simplicity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 加粗的行表示服务应该检查文件`etc/default/docker`，然后加载变量`$DOCKER_OPTS`以在运行时传递给服务。如果您使用此方法，为了简单起见，定义所有服务级选项都在`etc/default/docker`中可能是明智的。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: It should be noted that this first approach relies on running the script to
    generate the configuration file. If you are running the script manually to generate
    the file, there's a chance that the configuration file will get out of date if
    the Flannel configuration changes. The second approach shown later is more dynamic
    since the `/run/flannel/subnet.env` file is updated by the Flannel service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这种第一种方法依赖于运行脚本来生成配置文件。如果您手动运行脚本来生成文件，则有可能如果Flannel配置更改，配置文件将过时。稍后显示的第二种方法更加动态，因为`/run/flannel/subnet.env`文件由Flannel服务更新。
- en: 'Although the first approach certainly works, I prefer to use a slightly different
    method where I just load the variables from the `/run/flannel/subnet.env` file
    and consume them within the drop-in file. To do this, we change our Docker drop-in
    file to look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一种方法当然有效，但我更喜欢使用一个略有不同的方法，我只是从`/run/flannel/subnet.env`文件中加载变量，并在drop-in文件中使用它们。为了做到这一点，我们将我们的Docker
    drop-in文件更改为如下所示：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By specifying `/run/flannel/subnet.env` as an `EnvironmentFile`, we make the
    variables defined in the file available for consumption within the service definition.
    Then, we just use them as options to pass to the service when it starts. If we
    make these changes on our Docker host, reload the `systemd` configuration, and
    restart the Docker service, we should see that our `docker0` interface now reflects
    the Flannel subnet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`/run/flannel/subnet.env`指定为`EnvironmentFile`，我们使文件中定义的变量可供服务定义中使用。然后，我们只需在服务启动时将它们用作选项传递给服务。如果我们在我们的Docker主机上进行这些更改，重新加载`systemd`配置，并重新启动Docker服务，我们应该看到我们的`docker0`接口现在反映了Flannel子网：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also manually update the Docker service-level parameters yourself based
    on the Flannel configuration. Just make sure that you use the information from
    the `/run/flannel/subnet.env` file. Regardless of which method you choose, make
    sure that the `docker0` bridge is using the configuration specified by Flannel
    on all four of the Docker hosts. Our topology should now look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据Flannel配置手动更新Docker服务级参数。只需确保您使用`/run/flannel/subnet.env`文件中的信息。无论您选择哪种方法，请确保`docker0`桥在所有四个Docker主机上都使用Flannel指定的配置。我们的拓扑现在应该是这样的：
- en: '![How to do it…](graphics/B05453_08_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_08_02.jpg)'
- en: 'Since each Docker host only uses the Flannel-assigned scope for its subnet,
    each host believes the remaining subnets included in the global Flannel network
    are still reachable through the `flannel0` interface. Only the specific `/24`
    for the assigned local scope is reachable through the `docker0` bridge locally:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Docker主机只使用其子网的Flannel分配范围，因此每个主机都认为全局Flannel网络中包含的剩余子网仍然可以通过`flannel0`接口访问。只有分配的本地范围的特定`/24`可以通过`docker0`桥在本地访问：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can verify the operation of Flannel at this point by running two different
    containers on two different hosts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在两个不同的主机上运行两个不同的容器来验证Flannel的操作：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now reach the services running on each container directly by IP address.
    First, find the IP address of one of the containers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过IP地址直接访问每个容器上运行的服务。首先，找到一个容器的IP地址：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, access the service from the second container:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从第二个容器访问服务：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Connectivity is working as expected. Now that we have the entire Flannel configuration
    working with Docker, it's important to call out the order in which we did things.
    Other solutions we've looked at were able to containerize certain pieces of their
    solution. For instance, Weave was able to offer their services in a container
    format rather than requiring local services as we did with Flannel. With Flannel,
    each component has a perquisite in order to work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 连接正常工作。现在我们已经将整个Flannel配置与Docker一起工作，重要的是要指出我们做事情的顺序。我们查看的其他解决方案能够将其解决方案的某些部分容器化。例如，Weave能够以容器格式提供其服务，而不需要像我们使用Flannel那样需要本地服务。对于Flannel，每个组件都有一个先决条件才能工作。
- en: For instance, we need the `etcd` service running before Flannel will register.
    That by itself is not a huge concern and, if both `etcd` and Flannel ran in containers,
    you could solve that piece pretty easily. However, since the changes Docker needs
    to make to its bridge IP address are done at the service level, Docker needs to
    know about the Flannel scope before starting. This means that we can't run the
    `etcd` and Flannel services inside Docker containers because we can't start Docker
    without the information that Flannel generates based on reading keys from `etcd`.
    In this case, the prerequisites for each component are important to understand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要在Flannel注册之前运行`etcd`服务。这本身并不是一个很大的问题，如果`etcd`和Flannel都在容器中运行，你可以相当容易地解决这个问题。然而，由于Docker需要对其桥接IP地址进行的更改是在服务级别完成的，所以Docker在启动之前需要知道有关Flannel范围的信息。这意味着我们不能在Docker容器中运行`etcd`和Flannel服务，因为我们无法在没有从`etcd`读取密钥生成的Flannel信息的情况下启动Docker。在这种情况下，了解每个组件的先决条件是很重要的。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When running Flannel in CoreOS, they are able to run these components in containers.
    The solution for this is detailed in their documentation at this line under the
    *under the hood* section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoreOS中运行Flannel时，他们能够在容器中运行这些组件。解决方案在他们的文档中详细说明了这一点，在*底层*部分的这一行：
- en: '[https://coreos.com/flannel/docs/latest/flannel-config.html](https://coreos.com/flannel/docs/latest/flannel-config.html)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://coreos.com/flannel/docs/latest/flannel-config.html](https://coreos.com/flannel/docs/latest/flannel-config.html)'
- en: Using the VXLAN backend
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VXLAN后端
- en: As mentioned earlier, Flannel supports multiple different backend configurations.
    A backend is considered to be the means by which Flannel passes traffic between
    Flannel-enabled hosts. By default, this is done through UDP as we saw in the previous
    recipe. However, Flannel also supports VXLAN. The advantage to using VXLAN over
    UDP is that newer hosts support VXLAN in the kernel. In this recipe, we'll demonstrate
    how to change the Flannel backend type to VXLAN.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Flannel支持多种不同的后端配置。后端被认为是Flannel在启用Flannel的主机之间传递流量的手段。默认情况下，这是通过UDP完成的，就像我们在前面的示例中看到的那样。然而，Flannel也支持VXLAN。使用VXLAN而不是UDP的优势在于，较新的主机支持内核中的VXLAN。在这个示例中，我们将演示如何将Flannel后端类型更改为VXLAN。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is assumed that you're building off the lab described in the previous recipes
    in this chapter. You'll need Flannel-enabled hosts that are integrated with Docker
    as described in the first two recipes of this chapter. In some cases, the changes
    we make may require you to have root-level access to the system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建本章前面示例中描述的实验室。您将需要与Docker集成的启用了Flannel的主机，就像本章的前两个示例中描述的那样。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The type of backend you wish to use is defined when you first instantiate your
    network within `etcd`. Since we didn''t specify a type when we defined the network
    `10.100.0.0/16`, Flannel defaulted to using the UDP backend. This can be changed
    by updating the configuration we initially set in `etcd`. Recall that our Flannel
    network was first defined with this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你首次在`etcd`中实例化网络时，你希望使用的后端类型是被定义的。由于我们在定义网络`10.100.0.0/16`时没有指定类型，Flannel默认使用UDP后端。这可以通过更新我们最初在`etcd`中设置的配置来改变。回想一下，我们的Flannel网络是通过这个命令首次定义的：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note how we used the `mk` command of `etcdctl` to make the key. If we wanted
    to change the backend type to VXLAN, we could run this command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`etcdctl`的`mk`命令来创建键。如果我们想将后端类型更改为VXLAN，我们可以运行这个命令：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that, since we''re updating the object, we now use the `set` command in
    place of `mk`. While sometimes hard to see when in plain text form, the properly
    formatted JSON that we''re passing to `etcd` looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们正在更新对象，我们现在使用`set`命令代替`mk`。虽然在纯文本形式下有时很难看到，但我们传递给`etcd`的格式正确的JSON看起来像这样：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This defines the type of this backend to be VXLAN. While the preceding configuration
    by itself would be sufficient to change the backend type, there are sometimes
    additional parameters that we can specify as part of the backend. For instance,
    when defining the type as VXLAN, we can also specify a **VXLAN Identifier** (**VNI**)
    and a UDP port. If not specified, the VNI defaults to `1` and the port defaults
    to the `8472`. For the sake of demonstration, we''ll apply the defaults as part
    of our configuration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义这个后端的类型为VXLAN。虽然前面的配置本身足以改变后端类型，但有时我们可以指定作为后端的一部分的额外参数。例如，当将类型定义为VXLAN时，我们还可以指定**VXLAN标识符**（**VNI**）和UDP端口。如果未指定，VNI默认为`1`，端口默认为`8472`。为了演示，我们将默认值作为我们配置的一部分应用：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This in properly formatted JSON looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这在格式正确的JSON中看起来像这样：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we run the command the local `etcd` instances configuration will be updated.
    We can verify that `etcd` has the proper configuration by querying `etcd` through
    the `etcdctl` command-line tool. To read the configuration, we can use the `etcdctl
    get` subcommand:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行命令，本地`etcd`实例的配置将被更新。我们可以通过`etcdctl`命令行工具查询`etcd`，以验证`etcd`是否具有正确的配置。要读取配置，我们可以使用`etcdctl
    get`子命令：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Although we''ve successfully updated `etcd`, the Flannel services on each node
    will not act on this new configuration. This is because the Flannel service on
    each host only reads these variables when the service starts. In order for this
    change to take effect, we need to restart the Flannel service on each node:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已成功更新了`etcd`，但每个节点上的Flannel服务不会根据这个新配置进行操作。这是因为每个主机上的Flannel服务只在服务启动时读取这些变量。为了使这个更改生效，我们需要重新启动每个节点上的Flannel服务：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make sure that you restart the Flannel service on each host. Hosts will not
    be able to communicate if some are using the VXLAN backend and others are using
    the UDP backend. Once restarted, we can check our Docker host''s interfaces once
    again:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您重新启动每个主机上的Flannel服务。如果有些主机使用VXLAN后端，而其他主机使用UDP后端，主机将无法通信。重新启动后，我们可以再次检查我们的Docker主机的接口：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we can see that the host now has a new interface named `flannel.1`. If
    we check the interface with `ethtool`, we can see that it is using the VXLAN driver:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到主机现在有一个名为`flannel.1`的新接口。如果我们使用`ethtool`检查接口，我们可以看到它正在使用VXLAN驱动程序：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we should still be able to access the services using the Flannel IP addresses:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而且我们应该仍然能够使用Flannel IP地址访问服务：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you were to specify a different VNI, the Flannel interface would be defined
    as `flannel.<VNI number>`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您指定了不同的VNI，Flannel接口将被定义为`flannel.<VNI编号>`。
- en: It is important to know that Flannel does not take care of cleaning up artifacts
    from older configurations. For instance, if you change the VXLAN ID in `etcd`
    and restart the Flannel service, you will end up with two interfaces on the same
    network. You'll want to manually delete the old interface that was named using
    the old VNI. In addition, if you change the subnet allocated to Flannel, you'll
    want to restart the Docker service after you restart the Flannel service. Recall
    that Docker reads configuration variables from Flannel when the Docker service
    loads. If those change you'll need to reload the configuration for them to take
    effect.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Flannel不会清理旧配置的遗留物。例如，如果您更改了`etcd`中的VXLAN ID并重新启动Flannel服务，您将得到两个接口在同一个网络上。您需要手动删除使用旧VNI命名的旧接口。此外，如果更改了分配给Flannel的子网，您需要在重新启动Flannel服务后重新启动Docker服务。请记住，Docker在加载Docker服务时从Flannel读取配置变量。如果这些变化，您需要重新加载配置才能生效。
- en: Using the host gateway backend
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机网关后端
- en: As we've seen already, Flannel supports two types of overlay network. Using
    either UDP or VXLAN encapsulation, Flannel can build an overlay network between
    Docker hosts. The obvious advantage to this is that you can provision networks
    across disparate Docker nodes without having to touch the physical underlay network.
    However, some types of overlay networks also introduce a significant performance
    penalty, especially for processes that perform encapsulation in user space. Host
    gateway mode aims to solve that problem by not using an overlay network. This,
    however, comes with its own limitations. In this recipe, we'll review what host
    gateway mode can provide as well as show how to configure it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，Flannel支持两种类型的覆盖网络。使用UDP或VXLAN封装，Flannel可以在Docker主机之间构建覆盖网络。这样做的明显优势是，您可以在不触及物理底层网络的情况下，在不同的Docker节点之间提供网络。然而，某些类型的覆盖网络也会引入显著的性能惩罚，特别是对于在用户空间执行封装的进程。主机网关模式旨在通过不使用覆盖网络来解决这个问题。然而，这也带来了自己的限制。在这个示例中，我们将回顾主机网关模式可以提供什么，并展示如何配置它。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be slightly modifying the lab we''ve been using up until
    this point. The lab topology will look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将稍微修改我们一直在使用的实验室。实验室拓扑将如下所示：
- en: '![Getting ready](graphics/B05453_08_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B05453_08_03.jpg)'
- en: 'In this case, the hosts `docker3` and `docker4` now have IP addresses on the
    same subnet as `docker1` and `docker2`. That is, all of the hosts are now layer
    2 adjacent to each other and can talk directly without the need to route through
    a gateway. Once you have your hosts reconfigured in this topology, we''ll want
    to wipe the Flannel configuration. To do that, perform these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主机`docker3`和`docker4`现在具有与`docker1`和`docker2`相同子网的IP地址。也就是说，所有主机现在都是相互的二层邻接，并且可以直接通信，无需通过网关进行路由。一旦您将主机在此拓扑中重新配置，我们将希望清除Flannel配置。要做到这一点，请执行以下步骤：
- en: 'On the host running the `etcd` service:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行`etcd`服务的主机上：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On all of the hosts running the Flannel service:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有运行Flannel服务的主机上：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll note that we passed the `systemctl` command with the `--no-block` parameter
    when we started `flanneld`. Since we deleted the Flannel configuration from `etcd`,
    the Flannel service is searching for configuration to use for initialization.
    Due to the way the service is defined (as type notify), passing this parameter
    is required to prevent the command from hanging on the CLI.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在启动`flanneld`时传递了`systemctl`命令和`--no-block`参数。由于我们从`etcd`中删除了Flannel配置，Flannel服务正在搜索用于初始化的配置。由于服务的定义方式（类型为通知），传递此参数是必需的，以防止命令在CLI上挂起。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'At this point, your Flannel nodes will be searching for their configuration.
    Since we deleted the `etcd` data store, the key that tells the Flannel nodes how
    to configure the service is currently missing, and the Flannel service will continue
    to poll the `etcd` host until we make the appropriate configuration. We can verify
    this by checking the logs on one of the hosts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的Flannel节点将正在搜索其配置。由于我们删除了`etcd`数据存储，目前缺少告诉Flannel节点如何配置服务的密钥，Flannel服务将继续轮询`etcd`主机，直到我们进行适当的配置。我们可以通过检查其中一个主机的日志来验证这一点：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s important to note that at this point Flannel has already decided what
    its external endpoint IP address will be by seeing which interface supports the
    default route for the host:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，此时Flannel已经通过查看哪个接口支持主机的默认路由来决定其外部端点IP地址：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since that happens to be `eth0`, Flannel picks that interface''s IP address
    as its external address. To configure host gateway mode, we can put the following
    configuration into `etcd`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这恰好是`eth0`，Flannel选择该接口的IP地址作为其外部地址。要配置主机网关模式，我们可以将以下配置放入`etcd`：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we''ve seen before, we still specify a network. The only difference is that
    we supply a `type` of `host-gw`. The command to insert this into `etcd` looks
    like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们以前看到的，我们仍然指定一个网络。唯一的区别是我们提供了`type`为`host-gw`。将其插入`etcd`的命令如下：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After we insert this configuration, the Flannel nodes should all pick up the
    new configuration. Let''s examine the service logs for Flannel on the host `docker4`
    to verify this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们插入此配置后，Flannel节点应该都会接收到新的配置。让我们检查主机`docker4`上Flannel的服务日志以验证这一点：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `journalctl` command is useful for seeing all the logs related to a service
    being managed by `systemd`. In the preceding example, we passed the `-r` parameter
    to show the logs in reverse order ( the most current on top). We also passed the
    `-u` parameter to specify which service we want to see the logs for.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`journalctl`命令对于查看由`systemd`管理的服务的所有日志非常有用。在前面的示例中，我们传递了`-r`参数以倒序显示日志（最新的在顶部）。我们还传递了`-u`参数以指定我们要查看日志的服务。'
- en: 'The oldest log entry we see is this host''s Flannel service picking and registering
    a scope within the `10.100.0.0/16` subnet. This works in the same manner as it
    did with both the UDP and the VXLAN backend. The next three log entries show Flannel
    detecting the registrations of the other three Flannel nodes scopes. Since `etcd`
    is tracking each Flannel node''s external IP address, as well as their registered
    scope, all of the Flannel hosts now know what external IP address can be used
    to reach each registered Flannel scope. In overlay mode (UDP or VXLAN), this external
    IP address was used as the destination for encapsulated traffic. In host gateway
    mode, this external IP address is used as route destination. If we inspect the
    routing table, we can see a route entry for each host:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的最旧的日志条目是这个主机的Flannel服务在`10.100.0.0/16`子网内选择并注册范围。这与UDP和VXLAN后端的工作方式相同。接下来的三个日志条目显示Flannel检测到其他三个Flannel节点范围的注册。由于`etcd`正在跟踪每个Flannel节点的外部IP地址，以及它们注册的范围，所有Flannel主机现在都知道可以用什么外部IP地址来到达每个注册的Flannel范围。在覆盖模式（UDP或VXLAN）中，此外部IP地址被用作封装流量的目的地。在主机网关模式中，此外部IP地址被用作路由目的地。如果我们检查路由表，我们可以看到每个主机的路由条目：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this configuration, Flannel simply relies on basic routing to provide reachability
    to all the Flannel registered scopes. In this case, the host `docker4` has routes
    to all the other Docker hosts in order to reach their Flannel network scope:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置中，Flannel只是依赖基本路由来提供对所有Flannel注册范围的可达性。在这种情况下，主机`docker4`有路由到所有其他Docker主机的路由，以便到达它们的Flannel网络范围：
- en: '![How to do it…](graphics/B05453_08_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_08_04.jpg)'
- en: Not only is this far less complex than dealing with overlay networks, but it
    can also be much more performant than requiring each host to do encapsulation
    for the overlay network. The downside of this approach is that each host needs
    to have an interface on the same network in order for this to work. If the hosts
    are not on the same network, Flannel cannot add these routes because it would
    require the upstream network device (the host's default gateway) to also have
    routing information about how to reach the remote host. And while the Flannel
    node can point a static route at its default gateway, the physical network has
    no knowledge of the `10.100.0.0/16` network and will fail to deliver the traffic.
    The net effect is that host gateway mode limits the location of where you can
    place Flannel-enabled Docker hosts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅比处理覆盖网络要简单得多，而且比要求每个主机为覆盖网络进行封装要更高效。这种方法的缺点是每个主机都需要在同一网络上有一个接口才能正常工作。如果主机不在同一网络上，Flannel无法添加这些路由，因为这将需要上游网络设备（主机的默认网关）也具有有关如何到达远程主机的路由信息。虽然Flannel节点可以在其默认网关上指定静态路由，但物理网络对`10.100.0.0/16`网络一无所知，并且无法传递流量。其结果是主机网关模式限制了您可以放置启用Flannel的Docker主机的位置。
- en: Finally, it's important to point out that Flannel may have changed state after
    the Docker service was already running. If that's the case, you'll want to restart
    Docker to make sure that it picks up the new variables from Flannel. If you rebooted
    your hosts when you reconfigured their network interfaces, you probably just need
    to start the Docker service. The service likely failed to load when the system
    booted because of the lack of Flannel configuration information which should now
    be present.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要指出，Flannel在Docker服务已经运行后可能已经改变状态。如果是这种情况，您需要重新启动Docker，以确保它从Flannel中获取新的变量。如果在重新配置网络接口时重新启动了主机，则可能只需要启动Docker服务。系统启动时，服务可能因缺少Flannel配置信息而未能加载，现在应该已经存在。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flannel also has backends for various cloud providers such as GCE and AWS. You
    can view their documentation to find more specific information about those backend
    types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel还为各种云提供商（如GCE和AWS）提供了后端。您可以查看它们的文档，以获取有关这些后端类型的更多具体信息。
- en: Specifying Flannel options
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定Flannel选项
- en: In addition to configuring different backend types you can also specify other
    options both through `etcd` as well as through the Flannel client itself. These
    options allow you to limit the IP allocation scopes as well as specify a specific
    interface to use as a Flannel node's external IP endpoint. In this recipe, we'll
    review the additional configuration options available to you both locally and
    globally.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置不同的后端类型，您还可以通过`etcd`和Flannel客户端本身指定其他选项。这些选项允许您限制IP分配范围，并指定用作Flannel节点外部IP端点的特定接口。在本教程中，我们将审查您在本地和全局都可以使用的其他配置选项。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'We will keep building off the lab in the previous chapter where we configured
    the host gateway backend. However, the lab topology is going to revert to the
    previous configuration with Docker hosts `docker3` and `docker4` being in the
    `192.168.50.0/24` subnet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建上一章中的实验，在那里我们配置了主机网关后端。但是，实验拓扑将恢复到以前的配置，其中Docker主机`docker3`和`docker4`位于`192.168.50.0/24`子网中：
- en: '![Getting ready](graphics/B05453_08_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![做好准备](graphics/B05453_08_05.jpg)'
- en: 'Once you have your hosts configured in this topology, we''ll want to wipe out
    the Flannel configuration. To do that, perform these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在这个拓扑中配置了您的主机，我们将想要清除Flannel配置。为此，请执行以下步骤：
- en: 'On the host running the `etcd` service:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行`etcd`服务的主机上：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On all the hosts running the Flannel service:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有运行Flannel服务的主机上：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In some cases, the changes we make may require you to have root-level access
    to the system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The previous recipes showed several examples of how to specify an overall Flannel
    network or global scope as well change the backend network type. We also saw some
    backend network types allowed for additional configuration options. In addition
    to the options we''ve seen, we can also configure other parameters globally that
    dictate how Flannel works overall. There are three other main parameters that
    can influence the scopes assigned to the Flannel nodes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何指定整体Flannel网络或全局范围，并改变后端网络类型。我们还看到一些后端网络类型允许额外的配置选项。除了我们已经看到的选项之外，我们还可以全局配置其他参数，来决定Flannel的整体工作方式。有三个其他主要参数可以影响分配给Flannel节点的范围：
- en: '`SubnetLen`: This parameter is specified in the form of an integer and dictates
    the size of the scope assigned to each node. As we''ve seen, this defaults to
    a `/24`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubnetLen`: 此参数以整数形式指定，并规定了分配给每个节点的范围的大小。正如我们所见，这默认为`/24`'
- en: '`SubnetMin`: This parameter is specified in the form of a string and dictates
    the beginning IP range in which the scope allocations should begin'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubnetMin`: 此参数以字符串形式指定，并规定了范围分配应该开始的起始IP范围'
- en: '`SubnetMax`: This parameter is specified in the form of a string and dictates
    the end of the IP range at which the subnet allocation should end'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubnetMax`: 此参数以字符串形式指定，并规定了子网分配应该结束的IP范围的末端'
- en: 'Using these options in combination with the `Network` flag gives us quite a
    bit of flexibility when we assign networks. For instance, let''s use this configuration:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些选项与`Network`标志结合使用时，我们在分配网络时具有相当大的灵活性。例如，让我们使用这个配置：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This defines that each Flannel node should get a scope allocation of a `/25`,
    the first subnet should start at `10.100.0.0`, and the last subnet should end
    at `10.100.1.0`. You might have noticed that, in this case, we only have space
    for three subnets within that allocation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了每个Flannel节点应该获得一个`/25`的范围分配，第一个子网应该从`10.100.0.0`开始，最后一个子网应该结束于`10.100.1.0`。您可能已经注意到，在这种情况下，我们只有空间来容纳三个子网：
- en: '`10.100.0.0/25`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.100.0.0/25`'
- en: '`10.100.0.128./25`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.100.0.128./25`'
- en: '`10.100.1.0/25`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.100.1.0/25`'
- en: 'This was done intentionally to show what happens when Flannel runs out of space
    in the global scope. Let''s now put this configuration in `etcd` using this command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是故意为了展示当Flannel在全局范围内空间不足时会发生什么。现在让我们使用这个命令将这个配置放入`etcd`中：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once in place, you should see that the majority of the hosts receive local
    scope allocations. However, if we check our hosts, we''ll see that one has failed
    to receive an allocation. In my case, that''s the host `docker4`. We can see this
    within the Flannel services logs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦放置，您应该会看到大多数主机接收到本地范围的分配。但是，如果我们检查我们的主机，我们会发现有一个主机未能接收到分配。在我的情况下，那就是主机`docker4`。我们可以在Flannel服务的日志中看到这一点：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since we only allowed space for three allocations in the global scope, the fourth
    host is unable to receive a local scope and will continue to request one until
    one becomes available. This could be remedied by updating the `SubnetMax` parameter
    to `10.100.1.128` and restarting the Flannel service on the host that failed to
    receive a local scope allocation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在全局范围内只允许了三个分配空间，第四个主机无法接收本地范围，并将继续请求，直到有一个可用。这可以通过更新`SubnetMax`参数为`10.100.1.128`并重新启动未能接收本地范围分配的主机上的Flannel服务来解决。
- en: As I mentioned, there are also configuration parameters that we can pass to
    the Flannel service on each host.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，我们还可以将配置参数传递给每个主机上的Flannel服务。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Flannel client supports a variety of parameters, all of which can be viewed
    by running `flanneld --help`. These cover new and upcoming features as well as
    configurations related to SSL-based communication, which will be important to
    review when running these types of services on infrastructure you don't control.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Flannel客户端支持各种参数，所有这些参数都可以通过运行`flanneld --help`来查看。这些参数涵盖了新的和即将推出的功能，以及与基于SSL的通信相关的配置，在在运行这些类型的服务时，这些配置将是重要的。
- en: 'From a network perspective, perhaps the most valuable configuration option
    would be the `--iface` parameter, which allows you to specify which host interface
    you wish to use as Flannel''s external endpoint. To view the importance of this,
    let''s look at a quick example of our multihost lab topology:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络的角度来看，也许最有价值的配置选项是`--iface`参数，它允许您指定要用作Flannel外部端点的主机接口。为了了解其重要性，让我们看一个我们的多主机实验室拓扑的快速示例：
- en: '![How to do it…](graphics/B05453_08_06.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_08_06.jpg)'
- en: 'If you recall, in host gateway mode Flannel requires that all the Flannel nodes
    be layer 2 adjacent or on the same network. In this case, there are two hosts
    on the `10.10.10.0/24` network on the left and two hosts on the `192.168.50.0/24`
    network on the right. In order to talk to each other, they need to route through
    the multilayer switch. A scenario like this typically calls for an overlay backend
    mode that would tunnel the container traffic across the multilayer switch. However,
    if host gateway mode is a requirement for performance or other reasons, you might
    still be able to use it if you can provide additional interfaces to your hosts.
    For instance, imagine that these hosts were really virtual machines, and it was
    relatively easy for us to provision another interface on each host, call it `eth1`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在主机网关模式下，Flannel要求所有Flannel节点都是二层相邻的，或者在同一个网络上。在这种情况下，左侧有两个主机在`10.10.10.0/24`网络上，右侧有两个主机在`192.168.50.0/24`网络上。为了彼此通信，它们需要通过多层交换机进行路由。这种情况通常需要一个覆盖后端模式，可以通过多层交换机隧道传输容器流量。然而，如果主机网关模式是性能或其他原因的要求，如果您可以为主机提供额外的接口，您可能仍然可以使用它。例如，想象一下，这些主机实际上是虚拟机，相对容易为我们在每个主机上提供另一个接口，称之为`eth1`：
- en: '![How to do it…](graphics/B05453_08_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_08_07.jpg)'
- en: 'This interface could be dedicated to Flannel traffic allowing each host to
    still be layer 2 adjacent for the sake of Flannel traffic while still maintaining
    their existing default route through `eth0`. However, just provisioning the interface
    is not enough. Recall that Flannel by default picks its external endpoint interface
    by referencing the default route of the host. Since the default route is unchanged
    in this model, Flannel will be unable to add the appropriate routes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口可以专门用于Flannel流量，允许每个主机仍然在Flannel流量的情况下保持二层相邻，同时保持它们通过`eth0`的现有默认路由。然而，仅仅配置接口是不够的。请记住，Flannel默认通过引用主机的默认路由来选择其外部端点接口。由于在这种模型中默认路由没有改变，Flannel将无法添加适当的路由：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since Flannel is still using the `eth0` interface as its external endpoint IP
    address, it knows that the hosts on the other subnet aren't directly reachable.
    We can fix this by telling Flannel to use the `eth1` interface by passing the
    `--iface` option to the Flannel service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flannel仍然使用`eth0`接口作为其外部端点IP地址，它知道另一个子网上的主机是无法直接到达的。我们可以通过向Flannel服务传递`--iface`选项来告诉Flannel使用`eth1`接口来解决这个问题。
- en: 'For instance, we can change the Flannel configuration by updating the Flannel
    service definition (`/lib/systemd/system/flanneld.service`) to look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过更新Flannel服务定义（`/lib/systemd/system/flanneld.service`）来更改Flannel配置，使其如下所示：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With this configuration, Flannel will use the `eth1` interface for its external
    endpoint, allowing all the hosts to communicate directly across the `10.11.12.0/24`
    network. You can then load the new configuration by reloading the `systemd` configuration
    and restarting the service on all hosts:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，Flannel将使用“eth1”接口作为其外部端点，从而使所有主机能够直接在“10.11.12.0/24”网络上进行通信。然后，您可以通过重新加载“systemd”配置并在所有主机上重新启动服务来加载新配置：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Keep in mind that Flannel uses the external endpoint IP address to keep track
    of Flannel nodes. Changing this means that Flannel will allocate a new scope to
    each Flannel node. It''s best to configure these options before joining a Flannel
    node. In our case, since `etcd` is already configured, we''ll want to once again
    delete the existing `etcd` configuration and reconfigure it in order for the scope
    to become available:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Flannel使用外部端点IP地址来跟踪Flannel节点。更改这意味着Flannel将为每个Flannel节点分配一个新的范围。最好在加入Flannel节点之前配置这些选项。在我们的情况下，由于“etcd”已经配置好，我们将再次删除现有的“etcd”配置，并重新配置它，以便范围变得可用。
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you check a host, you should now see that it has three Flannel routes—one
    for each assigned scope of the other three hosts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查主机，现在应该看到它有三个Flannel路由——每个路由对应其他三个主机的分配范围之一：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In addition, if you'll be using Flannel through NAT, you might also want to
    look at the `--public-ip` option, which allows you to define a node's public IP
    address. This is particularly relevant in cloud environments where the server's
    real IP address may be hidden behind NAT.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您将通过NAT使用Flannel，您可能还想查看“--public-ip”选项，该选项允许您定义节点的公共IP地址。这在云环境中尤为重要，因为服务器的真实IP地址可能被隐藏在NAT后面。
