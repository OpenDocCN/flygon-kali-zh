- en: Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '**Regular expressions** (**regex**) are something of a mystery to many developers.
    We admit that they are something that we use often enough to warrant a deeper
    understanding of how they work. On the flip side, there are so many tried and
    tested regex patterns on the Internet, that just reusing one that already exists
    is easier than trying to create one yourself most times. The subject of regex
    is much larger than what can be explained in a single chapter in this book.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**（**regex**）对许多开发人员来说是一种神秘。我们承认，我们经常使用它们，以至于需要更深入地了解它们的工作原理。另一方面，互联网上有许多经过验证的正则表达式模式，只需重复使用已经存在的模式比尝试自己创建一个更容易。正则表达式的主题远远超出了本书中的单一章节所能解释的范围。'
- en: 'Therefore, in this chapter, we will merely introduce some of the concepts of
    regex. For a deeper understanding of regex, further study is needed. For the purpose
    of this book, however, we will take a closer look at how regular expression are
    created and how they can be applied to some common programming problems. In this
    chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们只是介绍了一些正则表达式的概念。要更深入地了解正则表达式，需要进一步学习。然而，为了本书的目的，我们将更仔细地看看如何创建正则表达式以及如何将其应用于一些常见的编程问题。在本章中，我们将涵盖以下内容：
- en: Getting started with regex - Matching a valid date
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用正则表达式-匹配有效日期
- en: Sanitize input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理输入
- en: Dynamic regex matching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A regular expression is a pattern that describes a string through the use of
    special characters that denote a specific bit of text to match. The use of regular
    expression is not a new concept in programming. For regex to work, it needs to
    use a regex engine that does all the heavy lifting.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是通过使用特殊字符描述字符串的模式，这些特殊字符表示需要匹配的特定文本。正则表达式的使用在编程中并不是一个新概念。为了使正则表达式工作，它需要使用一个执行所有繁重工作的正则表达式引擎。
- en: In the .NET Framework, Microsoft has provided for the use of regex. To use regex,
    you will need to import the `System.Text.RegularExpressions` assembly to your
    project. This will allow the compiler to use your regex pattern and apply it to
    the specific text you need to match.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，微软提供了正则表达式的使用。要使用正则表达式，您需要将`System.Text.RegularExpressions`程序集导入到您的项目中。这将允许编译器使用您的正则表达式模式并将其应用于您需要匹配的特定文本。
- en: Secondly, regex have a specific set of metacharacters that hold special meaning
    to the regex engine. These characters are `[ ]`, `{ }`, `( )`, `*`, `+`, , `?`,
    `|`, `$`, `.`, and `^`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，正则表达式有一组特殊含义的元字符，这些字符是`[ ]`, `{ }`, `( )`, `*`, `+`, , `?`, `|`, `$`, `.`,
    和 `^`。
- en: The use of the curly brackets `{ }`, for example, enables developers to specify
    the number of times a specific set of characters need to occur. Using square brackets,
    on the other hand, defines exactly what needs to be matched.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用花括号`{ }`使开发人员能够指定特定字符集需要出现的次数。另一方面，使用方括号则确切地定义了需要匹配的内容。
- en: If we, for example, specified `[abc]`, the pattern would look for lowercase
    As, Bs, and Cs. regex, therefore, also allows you to define a range, for example,
    `[a-c]`, which is interpreted in exactly the same way as the `[abc]` pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们指定了`[abc]`，那么模式将寻找小写的A、B和C。因此，正则表达式还允许您定义一个范围，例如`[a-c]`，这与`[abc]`模式的解释方式完全相同。
- en: Regular expressions then also allow you to define characters to exclude using
    the `^` character. Therefore, typing `[^a-c]` would find lowercase D through Z
    because the pattern is telling the regex engine to exclude lowercase As, Bs, and
    Cs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还允许您使用`^`字符定义要排除的字符。因此，键入`[^a-c]`将找到小写的D到Z，因为模式告诉正则表达式引擎排除小写的A、B和C。
- en: Regular expressions also define `d` and `D` a type of shortcut for `[0-9]` and
    `[^0-9]`, respectively. Therefore, `d` matches all numeric values, and `D` matches
    all non-numeric values. Another shortcut is `w` and `W`, which match any character
    from lowercase A to Z, irrespective of the case, all numeric values from 0 to
    9, and the underscore character. Therefore, `w` is `[a-zA-Z0-9_]`, while `W` is
    `[^a-zA-Z0-9_]`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还定义了`d`和`D`作为`[0-9]`和`[^0-9]`的一种快捷方式。因此，`d`匹配所有数字值，而`D`匹配所有非数字值。另一个快捷方式是`w`和`W`，它们匹配从小写A到Z的任何字符，不考虑大小写，从0到9的所有数字值，以及下划线字符。因此，`w`是`[a-zA-Z0-9_]`，而`W`是`[^a-zA-Z0-9_]`。
- en: The basics of regex are rather easy to understand, but there is a lot more that
    you can do with regex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的基础相当容易理解，但您还可以做很多其他事情。
- en: Getting started with regex - Matching a valid date
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用正则表达式-匹配有效日期
- en: 'If you haven''t done so already, create a new console application and add a
    class to the project called `RegExDemo`. Your code at this moment should look
    something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请创建一个新的控制台应用程序，并在项目中添加一个名为`RegExDemo`的类。此时您的代码应该看起来像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the purpose of this book, we are using a console application to illustrate
    the use of regex. In reality, you would probably not have this logic mixed in
    between your production code, because this would result in code being rewritten.
    The best place to add something such as regex is in a helper class within an extension
    method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们使用控制台应用程序来说明正则表达式的使用。实际上，您可能不会将这种逻辑混在生产代码之间，因为这将导致代码被重写。添加类似正则表达式的最佳位置是在扩展方法中的帮助类中。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the console application, add the following `using` statement so that we
    can use the regex assembly in .NET:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下`using`语句，以便我们可以在.NET中使用正则表达式程序集：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will create a regex to validate a date pattern of yyyy-mm-dd, yyyy/mm/dd,
    or yyyy.mm.dd. At first, the regex will look daunting, but bear with me. When
    you have completed the code and run the application, we will dissect the regex.
    Hopefully, the expression logic will become clear.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个正则表达式来验证yyyy-mm-dd、yyyy/mm/dd或yyyy.mm.dd的日期模式。一开始，正则表达式看起来可能令人生畏，但请耐心等待。当您完成代码并运行应用程序时，我们将解析这个正则表达式。希望表达式逻辑会变得清晰。
- en: 'Inside the `RegExDemo` class, create a new method called `ValidDate()` that
    takes a string as the parameter. This string will be the date pattern we want
    to validate:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RegExDemo`类中，创建一个名为`ValidDate()`的新方法，该方法以字符串作为参数。这个字符串将是我们想要验证的日期模式：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following regex pattern to your method to a variable in the method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下正则表达式模式添加到方法中的变量中：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, add the regex to match the supplied string parameter:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加正则表达式以匹配提供的字符串参数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you have done this, your method should look like this:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成这些操作后，您的方法应该如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Going back to your console application, add the following code and debug your
    application by clicking on Start:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到您的控制台应用程序，添加以下代码并通过单击“开始”调试您的应用程序：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will notice that if you add the `using static System.Console;` namespace,
    you then just need to call `Read()` instead of `Console.Read()`. This new feature
    where you could import static namespaces was added in C# 6.0.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，如果您添加了`using static System.Console;`命名空间，那么您只需要调用`Read()`而不是`Console.Read()`。这种新功能，您可以导入静态命名空间，是在C#
    6.0中添加的。
- en: 'The date strings are passed to the regex, and the pattern is matched against
    the date string in the parameter. The output is displayed in the console application:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期字符串被传递给正则表达式，并且模式与参数中的日期字符串匹配。输出显示在控制台应用程序中：
- en: '![](img/image_05_008.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_008.png)'
- en: If you look at the output carefully, you will notice that there is a mistake.
    We are validating the date string in the format yyyy-mm-dd, yyyy/mm/dd, and yyyy.mm.dd.
    If we use this logic, our regex has incorrectly flagged a valid date as invalid.
    This is the date `2016.4.10`, which is April 10, 2016, and is in fact quite valid.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细观察输出，您会注意到有一个错误。我们正在验证格式为yyyy-mm-dd、yyyy/mm/dd和yyyy.mm.dd的日期字符串。如果我们使用这个逻辑，我们的正则表达式错误地将一个有效的日期标记为无效。这是日期`2016.4.10`，它是2016年4月10日，实际上是有效的。
- en: We will explain shortly why the date `1800-01-21` is invalid.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会解释日期`1800-01-21`为什么无效。
- en: 'Go back to your `ValidDate()` method and change the regular expression to read
    as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的`ValidDate()`方法，并将正则表达式更改为如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the console application again and look at the output:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序并查看输出：
- en: '![](img/image_05_009.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_009.png)'
- en: This time the regex worked for all the given date strings. But what exactly
    did we do? This is how it works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这次正则表达式对所有给定的日期字符串都起作用了。但我们到底做了什么？它是如何工作的。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a closer look at the two expressions used in the previous code
    example. Comparing them with each other, you can see the change we made in yellow:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看前面代码示例中使用的两个表达式。将它们与彼此进行比较，您可以看到我们在黄色中所做的更改：
- en: '![](img/image_05_010.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_010.png)'
- en: 'Before we get to what that change means, let''s break up the expression and
    view the individual components. Our regex is basically saying that we must match
    all string dates that start with 19 or 20 and have the following separators:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解这个变化意味着什么之前，让我们分解表达式并查看各个组件。我们的正则表达式基本上是在说，我们必须匹配所有以19或20开头并具有以下分隔符的字符串日期：
- en: Dash (`-`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号（-）
- en: Decimal (`.`)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数点（.）
- en: Forward slash (`/`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜杠（/）
- en: To understand the expression better, we need to understand the following format
    of the expression *<Valid Years><Valid Separators><Valid Months><Valid Separators><Valid
    Days>*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解表达式，我们需要了解表达式<有效年份><有效分隔符><有效月份><有效分隔符><有效日期>的以下格式。
- en: We also need to be able to tell the regex engine to consider one *OR* another
    pattern. The word *OR* is symbolized by the `|` metacharacter. To make the regex
    engine consider the word *OR* without splitting up the whole expression, we wrap
    it in the parenthesis `()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够告诉正则表达式引擎考虑一个*或*另一个模式。单词*或*由`|`元字符表示。为了使正则表达式引擎在不分割整个表达式的情况下考虑*或*这个词，我们将其包装在括号`()`中。
- en: 'Here are the symbols used in the regex:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是正则表达式中使用的符号：
- en: '| **The conditional OR** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: 条件性或描述
- en: '| `&#124;` | This denotes the *OR* metacharacter. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| |这表示*或*元字符。'
- en: '| **The year portion** | **Description** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: 年份部分描述
- en: '| `(19&#124;20)` | Only allow 19 or 20 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: (19|20)只允许19或20
- en: '| `dd` | Matches two single digits between 0 and 9\. To match only one digit
    between 0 and 9, you would use `d`. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: dd匹配0到9之间的两个个位数。要匹配0到9之间的一个数字，您将使用d。
- en: '| **The valid separator character set** | **Description** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: 有效分隔符字符集描述
- en: '| `[-./]` | Matches any of the following characters in the character set. These
    are our valid separators. To match a space date separator, you would change this
    to `[- ./]`, where you add a space anywhere in the character set. We added the
    space between the dash and the decimal. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '[-./]匹配字符集中的任何一个字符。这些是我们的有效分隔符。要匹配空格日期分隔符，您可以将其更改为[- ./]，在字符集中的任何位置添加一个空格。我们在破折号和小数点之间添加了空格。'
- en: '| **Valid digits for months and days** | **Description** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: 月份和日期的有效数字描述
- en: '| `0[1-9]` | Matches any part starting with zero followed by any digit between
    1 and 9\. This will match 01, 02, 03, 04, 05, 06, 07, 08, and 09. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: 0[1-9]匹配以零开头，后跟1到9之间的任意数字。这将匹配01、02、03、04、05、06、07、08和09。
- en: '| `1[0-2]` | Matches any part starting with 1 followed by any digit between
    0 and 2\. This will match 10, 11, or 12. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: 1[0-2]匹配以1开头，后跟0到2之间的任意数字。这将匹配10、11或12。
- en: '| `[1-9]` | Matches any digit between 1 and 9. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '[1-9]匹配1到9之间的任意数字。'
- en: '| `[12][0-9]` | Matches any part starting with 1 or 2 followed by any digit
    between 0 and 9\. This will match all number strings between 10 and 29. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '[12][0-9]匹配以1或2开头，后跟0到9之间的任意数字。这将匹配所有10到29之间的数字字符串。'
- en: '| `3[01]` | Matches any part starting with 3 and followed by 0 or 1\. This
    will match 30 or 31. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: 3[01]匹配以3开头，后跟0或1。这将匹配30或31。
- en: '| **Start and end of string** | **Description** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: 字符串的开始和结束描述
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: ^告诉正则表达式引擎从给定字符串的开头开始匹配。
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 告诉正则表达式引擎停止匹配给定字符串的末尾。 |'
- en: 'The first regex we created, interprets as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个正则表达式解释如下：
- en: '`^`: Start at the beginning of the string to match'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 从字符串开头开始匹配'
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(19|20)`: 检查字符串是否以19或20开头'
- en: '`dd`: After the check, follows two single digits between 0 and 9'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd`: 检查后，跟着两个0到9之间的单个数字'
- en: '`[-./]`: The year portion ends followed by a date separators'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 年份部分结束，后跟日期分隔符'
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, *OR* digits starting with 1, followed
    by any digit between 0 and 2'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|1[0-2])`: 通过查找以0开头的数字，后跟1到9之间的数字，*或*以1开头的数字，后跟0到2之间的任意数字'
- en: '`[-./]`: The month logic ends followed by a date separator'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 月份逻辑结束，后跟日期分隔符'
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, OR digits starting with
    1 or 2, followed by any digit between 0 and 9, OR a digit matching 3, followed
    by any digit between 0 and 1'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|[12][0-9]|3[01])`: 然后，通过查找以0开头的数字，后跟1到9之间的数字，或者以1或2开头的数字，后跟0到9之间的任意数字，或者匹配3的数字，后跟0到1之间的任意数字，找到日期逻辑'
- en: '`$`: Do this until the end of the string'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 这样做直到字符串的末尾'
- en: Our first regex was incorrect because our month logic was incorrect. Our month
    logic dictates to find the month logic by looking for digits starting with a 0
    followed by any digit between 1 and 9 or digits starting with a 1 followed by
    any digit between 0 and 2 `(0[1-9]|1[0-2])`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个正则表达式是不正确的，因为我们的月份逻辑是错误的。我们的月份逻辑规定，通过查找以0开头的数字，后跟1到9之间的任意数字，或者以1开头的数字，后跟0到2之间的任意数字`(0[1-9]|1[0-2])`。
- en: This will then find 01, 02, 03, 04, 05, 06, 07, 08, 09, or 10, 11, 12\. The
    date that it didn't match was `2016.4.10` (the date separators don't make a difference
    here). This is because our month came through as a single digit, and we were looking
    for months where the single digits started with a zero. To fix this, we had to
    modify the expression of the month logic to include single digits only between
    1 and 9\. We did this by adding `[1-9]` to the expression at the end.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会找到01、02、03、04、05、06、07、08、09或10、11、12。它没有匹配的日期是`2016.4.10`（日期分隔符在这里没有区别）。这是因为我们的月份是单个数字，而我们正在寻找以零开头的月份。为了解决这个问题，我们必须修改月份逻辑的表达式，以包括只有1到9之间的单个数字。我们通过在表达式末尾添加`[1-9]`来实现这一点。
- en: 'The modified regex then read as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的正则表达式如下：
- en: '`^`: Start at the beginning of the string to match'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 从字符串开头开始匹配'
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(19|20)`: 检查字符串是否以19或20开头'
- en: '`dd`: After the check, follows two single digits between 0 and 9'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd`: 检查后，跟着两个0到9之间的单个数字'
- en: '`[-./]`: The year portion ends followed by a date separator'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 年份部分结束，后跟日期分隔符'
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, OR digits starting with 1, followed
    by any digit between 0 and 2 or any single digits between 1 and 9'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|1[0-2])`: 通过查找以0开头的数字，后跟1到9之间的任意数字，或者以1开头的数字，后跟0到2之间的任意数字或1到9之间的任意单个数字，找到月份逻辑'
- en: '`[-./]`: The month logic ends followed by a date separator'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[-./]`: 月份逻辑结束，后跟日期分隔符'
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, OR digits starting with
    1 or 2, followed by any digit between 0 and 9, OR a digit matching 3, followed
    by any digit between 0 and 1'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0[1-9]|[12][0-9]|3[01])`: 然后，通过查找以0开头的数字，后跟1到9之间的数字，或者以1或2开头的数字，后跟0到9之间的任意数字，或者匹配3的数字，后跟0到1之间的任意数字，找到日期逻辑'
- en: '`$`: Do this until the end of the string'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 这样做直到字符串的末尾'
- en: This is a basic regex, and we say basic because there is a lot more we can do
    to make the expression better. We can include logic to consider alternative date
    formats such as mm-dd-yyyy or dd-mm-yyyy. We can add logic to check February and
    validate that it contains only 28 days, unless it is a leap year, in which case
    we need to allow the twenty-ninth day of February. Furthermore, we can also extend
    the regex to check that January, March, May, July, August, October, and December
    have 31 days while April, June, September, and November contain only 30 days.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的正则表达式，我们说基本是因为我们可以做很多事情来使表达式更好。我们可以包含逻辑来考虑替代日期格式，如mm-dd-yyyy或dd-mm-yyyy。我们可以添加逻辑来检查二月，并验证它是否只包含28天，除非是闰年，那么我们需要允许二月的第二十九天。此外，我们还可以扩展正则表达式，以检查一月、三月、五月、七月、八月、十月和十二月是否有31天，而四月、六月、九月和十一月只有30天。
- en: Sanitizing input
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理输入
- en: Sometimes, you will need to sanitize input. This could be to prevent SQL injections
    or ensure that an entered URL is valid. In this recipe, we will look at replacing
    the bad words in a string with asterisks. We are sure that there are more elegant
    and code-efficient methods of writing sanitation logic using regex (especially
    when we have a large collection of blacklist words), but we want to illustrate
    a concept here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要清理输入。这可能是为了防止SQL注入或确保输入的URL有效。在本教程中，我们将查看如何用星号替换字符串中的不良词汇。我们确信有更优雅和代码高效的方法来使用正则表达式编写清理逻辑（特别是当我们有一个大量的黑名单词汇集合时），但我们想在这里阐明一个概念。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t done so already:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已将正确的程序集添加到您的类中。在您的代码文件顶部，如果尚未这样做，请添加以下行代码：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new method in your `RegExDemo` class called `SanitizeInput()` and
    let it accept a string parameter:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`RegExDemo`类中创建一个名为`SanitizeInput()`的新方法，并让它接受一个字符串参数：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a list of type `List<string>` to the method that contains the bad words
    we want to remove from the input:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法中添加一个`List<string>`类型的列表，其中包含我们要从输入中删除的不良词汇：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In reality, you might make use of a database call to read the blacklisted words
    from a table in the database. You would usually not hardcode them in a list like
    this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可能会利用数据库调用从数据库表中读取黑名单单词。您通常不会像这样硬编码它们在一个列表中。
- en: 'Start constructing the regex that we will use to look for the blacklisted words.
    You concatenate the words with the `|` (OR) metacharacter so that the regex will
    match any of the words. When the list is complete, you can append the `b` expression
    to either side of the regex. This denotes a word boundary and, therefore, will
    only match whole words:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始构造我们将用来查找黑名单单词的正则表达式。您使用`|`（OR）元字符将单词连接起来，以便正则表达式将匹配任何一个单词。当列表完成后，您可以在正则表达式的两侧附加`b`表达式。这表示一个词边界，因此只匹配整个单词：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will add the `Regex.Replace()` method that takes the input and
    looks for the occurrence of the words defined in the pattern, while ignoring case
    and replacing the bad words with `*****`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加`Regex.Replace()`方法，该方法接受输入并查找模式中定义的单词的出现，同时忽略大小写，并用`*****`替换不良单词：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you have completed this, your `SanitizeInput()` method will look like
    this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您的`SanitizeInput()`方法将如下所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the console application, add the following code to call the `SanitizeInput()`
    method and run your application (if you have already instantiated an instance
    of `RegExDemo` in the previous recipe, you don''t need to do it again):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下代码调用`SanitizeInput()`方法并运行您的应用程序（如果您已经在上一个示例中实例化了`RegExDemo`的实例，则不需要再次实例化）：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you run your application, you will see the following in the console window:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序时，您将在控制台窗口中看到以下内容：
- en: '![](img/image_05_011.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_011.png)'
- en: Let's take a closer look at the regular expression generated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下生成的正则表达式。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s step through the code to understand what is happening. We need to get
    a regex that looks like this: `b(wordToMatch1|wordToMatch2|wordToMatch3)b`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解代码的执行过程。我们需要得到一个看起来像这样的正则表达式：`b(wordToMatch1|wordToMatch2|wordToMatch3)b`。
- en: 'What this basically says is "find me any of the words and only whole words
    which are denoted by `b`". When we look at the list we created, we will see the
    words we want to remove from the input string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是说“找到任何单词，只有被`b`标记的整个单词”。当我们查看我们创建的列表时，我们会看到我们想要从输入字符串中删除的单词：
- en: '![](img/image_05_012.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_012.png)'
- en: 'We then created a simple loop that will create the list of words to match using
    the OR metacharacter. We ended up with a `BadWord1|BadWord2|BadWord3` pattern
    after the `foreach` loop has completed. However, this is still not a valid regex:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个简单的循环，使用OR元字符创建要匹配的单词列表。在`foreach`循环完成后，我们得到了一个`BadWord1|BadWord2|BadWord3`模式。然而，这仍然不是一个有效的正则表达式：
- en: '![](img/image_05_013.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_013.png)'
- en: To complete the pattern resulting in the valid regex, we need to add the `b`
    expression on either side of the pattern to tell the regex engine to only match
    whole words. As you can see, we are using string interpolation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成生成有效的正则表达式的模式，我们需要在模式的两侧添加`b`表达式，告诉正则表达式引擎只匹配整个单词。正如您所看到的，我们正在使用字符串插值。
- en: 'It is here, however, that we need to be very careful. Start off by writing
    the code to complete the pattern without the `@` sign as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里我们需要非常小心。首先编写代码，完成模式而不使用`@`符号，如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run your console application, you will see that the bad words are not
    matched and filtered out. This is because we have not escaped the character before
    `b`. The compiler, therefore, interprets this line of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行控制台应用程序，您会看到不良单词没有被匹配和过滤掉。这是因为我们没有转义`b`之前的字符。因此，编译器解释这行代码：
- en: '![](img/image_05_014.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_014.png)'
- en: The generated expression `[](BadWord1| BadWord2| BadWord3)[]` is not a valid
    expression and will, therefore, not sanitize the input string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的表达式`[](BadWord1| BadWord2| BadWord3)[]`不是一个有效的表达式，因此不会对输入字符串进行消毒。
- en: 'To correct this, we need to add the `@` symbol before the string to tell the
    compiler to treat the string as a literal. This means any escape sequences are
    ignored. The correctly formatted line of code looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要纠正这个问题，我们需要在字符串前面添加`@`符号，告诉编译器将字符串视为文字。这意味着任何转义序列都将被忽略。正确格式化的代码行如下：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you do this, the string for the pattern is interpreted literally by the
    compiler, and the correct regex pattern generated:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您这样做，模式的字符串将被编译器直接解释，正确的正则表达式模式将被生成：
- en: '![](img/image_05_015.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_015.png)'
- en: 'With our correct regex pattern, we called the `Regex.Replace()` method. It
    takes the input to check, the regex to match, the text to replace the matched
    words with, and optionally allows for the ignoring of the case:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们正确的正则表达式模式，我们调用了`Regex.Replace()`方法。它接受要检查的输入，要匹配的正则表达式，要替换匹配单词的文本，并且可选地允许忽略大小写。
- en: '![](img/image_05_016.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_016.png)'
- en: 'When the string returns to the calling code in the console application, the
    string will be sanitized properly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串返回到控制台应用程序中的调用代码时，字符串将被正确消毒：
- en: '![](img/image_05_017.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_017.png)'
- en: Regex can become quite complex and can be used to perform a multitude of tasks
    to format and validate input and other text.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可能会变得非常复杂，并且可以用于执行多种任务，以格式化和验证输入和其他文本。
- en: Dynamic regex matching
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配
- en: What does dynamic regex matching even mean? Well, it isn't an official term,
    but it is a term we use to explain a regex that uses variables at runtime to generate
    a specific expression. Assume for a minute that you are working on a document-management
    system that needs to implement versioning of documents for a company called ACME
    Corporation. To do this, the system validates that the document has a valid filename.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 动态正则表达式匹配到底是什么意思？嗯，这不是一个官方术语，但这是一个我们用来解释在运行时使用变量生成特定表达式的正则表达式的术语。假设您正在开发一个需要为ACME公司实现文档版本管理的文档管理系统。为了做到这一点，系统验证文档是否具有有效的文件名。
- en: A business rule states that the filename of any file uploaded on a specific
    day must be prefixed with `acm` (for ACME) and today's date in the yyyy-mm-dd
    format. They can be only text files, Word documents (only `.docx`) and Excel documents
    (only `.xlsx`). Any documents not conforming to this file format are processed
    by another method that takes care of archive and invalid documents.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个业务规则规定，上传在特定日期的任何文件的文件名必须以`acm`（ACME）和今天的日期以yyyy-mm-dd格式为前缀。它们只能是文本文件、Word文档（仅限`.docx`）和Excel文档（仅限`.xlsx`）。任何不符合此文件格式的文档都将由另一种方法处理，该方法负责存档和无效文档的处理。
- en: The only task that your method needs to perform is to process fresh documents
    as version one documents.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您的方法需要执行的唯一任务是将新文档处理为版本一文档。
- en: In a production system, further logic will probably be needed to determine whether
    the same document has been uploaded previously on the same day. This, however,
    is beyond the scope of this chapter. We are just trying to set the scene.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，可能需要进一步的逻辑来确定是否在同一天之前已经上传了相同的文档。然而，这超出了本章的范围。我们只是试图搭建场景。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已将正确的程序集添加到您的类中。如果还没有这样做，请在代码文件的顶部添加以下代码行：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A really nice way to do this is to use an extension method. This way, you can
    call the extension method directly on the filename variable and have it validated.
    In your console application, start off by adding a new class called `CustomRegexHelper`
    with `public static` modifier:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非常好的方法是使用扩展方法。这样，您可以直接在文件名变量上调用扩展方法并进行验证。在控制台应用程序中，首先添加一个名为`CustomRegexHelper`的新类，带有`public
    static`修饰符：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the usual extension method code to the `CustomRegexHelper` class and call
    the `ValidAcmeCompanyFilename` method:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通常的扩展方法代码添加到`CustomRegexHelper`类中，并调用`ValidAcmeCompanyFilename`方法：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside your `ValidAcmeCompanyFilename` method, add the following regex. We
    will explain the makeup of this regex in the *How it works...* section of this
    recipe:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`ValidAcmeCompanyFilename`方法中，添加以下正则表达式。我们将在本食谱的*工作原理...*部分解释这个正则表达式的构成：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you completed this, your extension method should look like this:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您的扩展方法应该如下所示：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Back in the console application, create a method with `void` return type called
    `DemoExtensionMethod()`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到控制台应用程序，在`void`返回类型的方法中创建名为`DemoExtensionMethod()`的方法：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add some output text to show the current date and the valid filename types:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些输出文本，显示当前日期和有效的文件名类型：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, add the filename checking code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加文件名检查代码：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will note that the `if` statement contains the call to the extension method
    on the variable that contains the filename:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到`if`语句包含对包含文件名的变量的扩展方法的调用：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have completed this, your method should look like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已完成此操作，您的方法应该如下所示：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Going back to the console application, add the following code that simply calls
    the `void` method. This is just to simulate the versioning method talked about
    earlier:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到控制台应用程序，添加以下代码，简单地调用`void`方法。这只是为了模拟之前讨论的版本方法：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you are done, run your console application:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行您的控制台应用程序：
- en: '![](img/image_05_018.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_018.png)'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s have a closer look at the regex generated. The line of code we are looking
    at is the `return` statement in the extension method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下生成的正则表达式。我们正在看的代码行是扩展方法中的`return`语句：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To appreciate what is happening, we need to break this expression up into the
    different components:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，我们需要将这个表达式分解成不同的组件：
- en: '| **The conditional OR** | **Description** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **条件OR** | **描述** |'
- en: '| `&#124;` | This denotes the *OR* metacharacter. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这表示*OR*元字符。 |'
- en: '| **The file prefix and separator** | **Description** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **文件前缀和分隔符** | **描述** |'
- en: '| `acm` | The file must begin with the text `acm`. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `acm` | 文件名必须以文本`acm`开头。 |'
- en: '| `[_]` | The only valid separator between the date components and the prefix
    in the file name is an underscore. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `[_]` | 文件名中日期组件和前缀之间唯一有效的分隔符是下划线。 |'
- en: '| **The date parts** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **日期部分** | **描述** |'
- en: '| `{DateTime.Now.Year}` | The interpolated year part of the date for the file
    name. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Year}` | 文件名的日期部分的插值年份。 |'
- en: '| `{DateTime.Now.Month}` | The interpolated month part of the date for the
    file name. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Month}` | 文件名的日期部分的插值月份。 |'
- en: '| `0[{DateTime.Now.Month}]` | The interpolated month part of the date with
    a leading zero for the file name. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `0[{DateTime.Now.Month}]` | 文件名的日期部分的插值月份，带有前导零。 |'
- en: '| `{DateTime.Now.Day}` | The interpolated day part of the date for the file
    name. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `{DateTime.Now.Day}` | 文件名的日期部分的插值天数。 |'
- en: '| `0[{DateTime.Now.Day}]` | The interpolated day part of the date with a leading
    zero for the file name. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `0[{DateTime.Now.Day}]` | 文件名的日期部分的插值天数，带有前导零。 |'
- en: '| **Valid file formats** | **Description** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **有效文件格式** | **描述** |'
- en: '| `(.txt&#124;.docx&#124;.xlsx)` | Match any of these file extensions for text
    documents, Word documents, or Excel documents. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `(.txt&#124;.docx&#124;.xlsx)` | 匹配这些文件扩展名中的任何一个，用于文本文档、Word文档或Excel文档。 |'
- en: '| **Start and end of string** | **Description** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **字符串的开始和结束** | **描述** |'
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 告诉正则表达式引擎从给定字符串的开头开始匹配 |'
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 告诉正则表达式引擎停在给定字符串的末尾进行匹配 |'
- en: Creating the regex in this manner allows us to always have it stay up to date.
    As we have to always match the current date to the file being validated, this
    creates a unique challenge that is easily overcome using string interpolation,
    `DateTime`, and regex *OR* statements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建正则表达式允许我们始终使其保持最新。由于我们必须始终将当前日期与正在验证的文件进行匹配，这就产生了一个独特的挑战，可以很容易地通过使用字符串插值、`DateTime`和正则表达式的*OR*语句来克服。
- en: Having a look at some of the more useful bits of regex, you will see that this
    chapter has not even begun to scratch the surface of what can be accomplished.
    There is a whole lot more to explore and learn. There are many resources on the
    Internet as well as some free (some online) and commercial tools that will assist
    you in creating regex.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览一些更有用的正则表达式，你会发现这一章甚至还没有开始探讨可以实现的内容。还有很多东西可以探索和学习。互联网上有许多资源，还有一些免费（一些在线）和商业工具可以帮助你创建正则表达式。
