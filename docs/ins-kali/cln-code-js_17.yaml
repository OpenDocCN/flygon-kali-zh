- en: The Landscape of Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的景观
- en: At the beginning of this book, we set out the primary tenets of clean code.
    Among these was reliability. There truly is no greater way to confirm reliability
    than to expose your code base to continued and multivariate usage. This means
    having real users sit in front of your software and use it, for real. Only via
    this type of exposure can we understand whether our code truly fulfills its purpose.
    However, it is usually unreasonable, and possibly even dangerous, to conduct such
    real-life tests constantly. If code is changed, it is possible for a piece of
    functionality that a user relies on to falter or regress. To prevent such cases,
    and to generally confirm that our expectations are met, we write tests. Without
    a good suite of tests, we are passively and arrogantly closing our eyes and hoping
    that nothing goes wrong.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们阐明了清晰代码的主要原则。其中之一是可靠性。确认可靠性的最佳方法莫过于让您的代码库持续和多样化地接受使用。这意味着真正的用户坐在您的软件前并使用它。只有通过这种类型的暴露，我们才能了解我们的代码是否真正实现了它的目的。然而，经常进行这种现实生活测试通常是不合理的，甚至可能是危险的。如果代码发生变化，用户依赖的某个功能可能出现故障或退化。为了防止这种情况，并且通常确认我们的期望是否得到满足，我们编写测试。如果没有一套好的测试，我们就
    passively and arrogantly closing our eyes and hoping that nothing goes wrong。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a test?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: Types of testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类型
- en: '**Test-Driven Development** (**TDD**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）'
- en: What is a test?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: A software test is an automated procedure that makes assertions about a piece
    of code and then reports the success of those assertions back to you. A test may
    make assertions about anything from an individual function to the behavior of
    an entire feature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个自动化的程序，它对一段代码进行断言，然后将这些断言的成功报告给您。测试可以对任何东西进行断言，从一个单独的函数到整个功能的行为。
- en: 'Tests, much like the rest of our code, deal in layers of abstraction and granularity.
    If we were to test a car abstractly, we may simply seek to assert the following
    attributes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，就像我们的其他代码一样，涉及抽象和细节的层次。如果我们要抽象地测试一辆汽车，我们可能只是寻求断言以下属性：
- en: It has four wheels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有四个轮子
- en: It has a steering wheel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个方向盘
- en: It drives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能开车
- en: It has a working horn
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个工作的喇叭
- en: Obviously, this is not a very useful set of assertions for car engineers, as
    these attributes are either incredibly obvious or insufficiently described. The
    assertion It drives is important, but without extra detail, all it expresses is
    a generic business-oriented objective. It's similar to a project manager asking
    for a software engineer to ensure that a user-login portal, for example, can allow
    users to log in successfully. It is the engineer's job to not only implement the
    user-login portal but to derive working tests that successfully investigate the
    truth of the assertion users can log in successfully. And it is not always easy
    to derive good tests from generic statements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这对汽车工程师来说并不是一个非常有用的断言集，因为这些属性要么非常明显，要么描述不足。断言“它能开车”很重要，但如果没有额外的细节，它所表达的只是一个通用的业务目标。这类似于项目经理要求软件工程师确保用户登录门户，例如，可以让用户成功登录。工程师的工作不仅是实现用户登录门户，还要得出成功调查断言用户可以成功登录的工作测试。从通用陈述中得出好的测试并不总是容易的。
- en: 'To correctly engineer a test, we must take the generic and abstract requirements
    and distill them to their granular and unabstracted details. In the case of us
    asserting that our car *has a working horn*, for example, we can distill it like
    so:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地设计一个测试，我们必须将通用和抽象的要求提炼到它们的细节和非抽象的细节。例如，当我们断言我们的汽车“有一个工作的喇叭”时，我们可以这样提炼：
- en: When the driver raises at least one hand and directs the hand to depress by
    2 cm the center of the steering wheel for a period of 1 second, a loud sound of
    fixed frequency at 400 Hz will be emitted by the car at approximately 107 decibels
    for 1 second.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当驾驶员至少举起一只手并指示手按下方向盘中心1秒钟，汽车将发出大约107分贝的固定频率为400赫兹的响亮声音1秒钟。
- en: When we start to add crucial detail to our assertions, they become useful to
    us. We can use them as both guides of implementation and confirmations of functionality.
    Even with this added detail though, our statement is only an assertion or a *requirement*.
    Such requirements are a useful step in the design of software. In fact, we should
    be very reluctant to even begin implementing software until we have such levels
    of specificity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始为我们的断言添加关键细节时，它们对我们变得有用。我们可以将它们用作实施的指南和功能的确认。即使有了这些额外的细节，我们的陈述仍然只是一个断言或*要求*。这些要求是软件设计中的一个有用步骤。事实上，我们应该非常不愿意在具体性达到这种程度之前开始实施软件。
- en: 'If a client were to ask you to implement a payment form, for example, it would
    be wise to gather the exact requirements: what types of payments shall it accept?
    What other customer information requires collection? What regulations or constraints
    are we beholden to in our storage of this data? These expanded requirements then
    become the yardstick via which we, and the client, will measure completeness.
    It follows naturally that we can then implement these requirements as individual
    tests to confirm their existence in the software.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果客户要求您实施一个付款表单，收集确切的要求是明智的：它应接受哪些类型的付款？还需要收集哪些其他客户信息？我们在存储这些数据时受到什么法规或约束？这些扩展的要求随后成为我们和客户将衡量完整性的标准。因此，我们可以将这些要求作为单独的测试来实施，以确认它们在软件中的存在。
- en: 'A good testing methodology will involve tests for all distinct parts of a code
    base and will provide the following benefits:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的测试方法将涉及对代码库所有不同部分的测试，并将提供以下好处：
- en: '**Prove fulfillment**: Tests allow us to prove to ourselves and our stakeholders
    that expectations and requirements are fulfilled.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证明实现**：测试使我们能够向自己和利益相关者证明期望和要求得到满足。'
- en: '**Have** **confidence**: Tests allow us and our colleagues to have confidence
    in our code base—both that it works correctly and that it can accommodate changes
    without faults arising unbeknownst to us.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有** **信心**：测试使我们和我们的同事对我们的代码库有信心，既能正确运行，又能容纳变化而不会出现我们不知道的故障。'
- en: '**Share** **knowledge**: Tests allow us to share vital knowledge about how
    parts of our code operate together. In a sense, they are a form of documentation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分享** **知识**：测试允许我们分享关于代码部分如何运作的重要知识。在某种意义上，它们是一种文档形式。'
- en: There are many second-order effects of a good testing methodology as well. The
    increased confidence in the code base by your colleagues will mean you can be
    more productive and make more significant changes more quickly, cutting costs
    and pain in the long run. The sharing of knowledge can enable both your colleagues
    and your users to perform their actions quicker, with more understanding and less
    overhead in time and expense. The ability to prove fulfillment enables teams and
    individuals to better communicate the value of their work to stakeholders, managers,
    and users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的测试方法还有许多二阶效应。同事对代码库的增加信心将意味着您可以更快地进行更大的变更，从而在长远来看削减成本和痛苦。知识的共享可以使您的同事和用户更快地执行操作，更加理解，减少时间和费用的开销。证明实现目标的能力使团队和个人能够更好地向利益相关者、管理者和用户传达他们工作的价值。
- en: Now that we've discussed the obvious benefits of tests, we can discuss how we
    should go about authoring them. At the core of every test is a set of assertions,
    so we'll now explore what we mean by assertion and how we can use assertions to
    encode our expectations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了测试的明显好处，我们可以讨论如何编写测试。每个测试的核心都是一组断言，所以我们现在将探讨我们所说的断言以及如何使用断言来编码我们的期望。
- en: The simple assertion
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的断言
- en: There are many tools, terms, and paradigms of testing. The existence of so much
    complexity can seem intimidating but it's important to remember that, at the core,
    testing is really just about making assertions about how something works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有许多工具、术语和测试范式。这么多复杂性的存在可能看起来令人生畏，但重要的是要记住，从本质上讲，测试实际上只是关于对某些东西的工作方式进行断言。
- en: 'Assertions can be made programmatically by expressing either `SUCCESS` or `FAILURE` depending
    on a specific outcome, as in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过表达特定结果来以编程方式进行断言，如下例所示，要么是`SUCCESS`，要么是`FAILURE`：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we will receive a our `FAILURE!` log if our `sum` function is not giving
    the expected output. We can abstract this pattern of success and failure by implementing
    an `assert` function, like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们的`sum`函数没有给出预期的输出，我们将收到`FAILURE!`的日志。我们可以通过实现一个`assert`函数来抽象这种成功和失败的模式，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can then be used to make a series of assertions with added descriptions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用这个日志进行一系列的断言并添加描述：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the fundamental core of any testing framework or library. They all
    have a mechanism for making assertions and reporting both the success and failure
    of those assertions. It is also normal for testing libraries to provide a mechanism
    to wrap up or contain related assertions and, together, call them a *test* or
    *test case*. We can do something similar by providing a test function that allows
    you to pass a description and a function (to contain assertions):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何测试框架或库的基本核心。它们都有一种机制来进行断言，并报告这些断言的成功和失败。测试库通常也提供一种机制来包装或包含相关的断言，并一起称之为*测试*或*测试用例*。我们可以通过提供一个测试函数来做类似的事情，允许您传递描述和函数（包含断言）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then use it like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用它：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The produced testing log from running this would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后生成的测试日志如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From a technical perspective, the pure action of authoring assertions and simple
    tests is not too challenging. Writing a test for a singular function is rarely
    hard. However, to write entire test suites and to thoroughly test all parts of
    a code base, we must utilize several more complicated testing mechanisms and methodologies
    to help us out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，编写断言和简单测试并不太具有挑战性。为单个函数编写测试很少会很困难。然而，要编写完整的测试套件并彻底测试代码库的所有部分，我们必须利用更复杂的测试机制和方法来帮助我们。
- en: Many moving parts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许多移动部件
- en: To recall the car analogy, let's imagine that we have a car sitting in front
    of us, and we wish to test its horn. The horn is not a standalone piece of machinery.
    It is embedded within the car and dependent on a power source separate to itself.
    In fact, what we may discover is that we must first start the car up via the ignition
    before the horn will work. And the success of an ignition is itself dependent
    upon several other components, including a working ignition switch, fuel in the
    tank, a working fuel filter, and a non-drained battery. The functionality of the
    horn is therefore dependent upon a series of many moving parts. So, our test of
    the horn becomes not only a test of the horn itself but effectively a test of
    almost the entire car! This is not ideal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回想汽车类比，让我们想象我们面前有一辆汽车，我们希望测试它的喇叭。喇叭不是一个独立的机械部件。它嵌入在汽车内部，并且依赖于一个与其本身分离的电源。事实上，我们可能会发现，在喇叭工作之前，我们必须先通过点火启动汽车。而点火的成功本身取决于其他几个组件，包括工作的点火开关、油箱中的燃料、工作的燃油过滤器和未耗尽的电池。因此，喇叭的功能取决于许多移动部件。因此，我们对喇叭的测试不仅仅是对喇叭本身的测试，而实际上是对几乎整个汽车的测试！这并不理想。
- en: To get around this issue, we could hook the horn up to a separate power supply
    just for testing purposes. By doing this, we are isolating the horn, enabling
    the test to only reflect the functionality of the horn itself. In the testing
    world, this **stand-in** power supply we're using might be called a **stub** or
    a **mock**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以将喇叭连接到一个单独的电源供应上，只用于测试目的。通过这样做，我们隔离了喇叭，使测试只反映喇叭本身的功能。在测试世界中，我们使用的这个**替身**电源供应可能被称为**存根**或**模拟**。
- en: In the software world, both *stubs* and *mocks* are a type of stand-in abstraction
    for the *real* abstraction that provides appropriate outputs without carrying
    out the real work of the replaced abstraction. An example would be a `makeCreditCardPayment`
    stub, which returns `SUCCESS` without creating a real-world payment. This would
    be used in the context of testing e-commerce functionality, possibly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，*存根*和*模拟*都是一种代替*真实*抽象的类型，它提供适当的输出，而不执行被替换抽象的真实工作。一个例子是`makeCreditCardPayment`存根，它返回`SUCCESS`，而不创建真实的支付。这可能在测试电子商务功能的上下文中使用。
- en: 'Our approach of isolating the power supply of the horn is unfortunately flawed.
    Even if our test is successful—and the horn works—we haven''t guaranteed that
    the horn will still work when hooked up to the real power supply within the car.
    The isolated test of the horn is still, arguably, useful because it tells us about
    any failures within the horn''s specific circuitry and mechanism, but it is not
    sufficient on its own. We need to test how the horn will work when it is embedded
    in the real-life situation of having to depend on other components. In software,
    we call such real-life tests **integration tests** or **end-to-end tests**, while
    the isolated tests are typically called **unit tests**. An effective testing methodology
    will always include both types:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们隔离喇叭电源的方法不幸地存在缺陷。即使我们的测试成功了，喇叭能够工作，我们也没有保证喇叭连接到汽车真正的电源时仍然能够工作。对喇叭的隔离测试仍然有用，因为它告诉我们喇叭特定电路和机制内的任何故障，但它本身是不够的。我们需要测试喇叭在实际情况下的工作情况，即依赖其他组件。在软件中，我们称这样的实际测试为**集成测试**或**端到端测试**，而隔离测试通常称为**单元测试**。有效的测试方法将始终包括这两种类型：
- en: '![](assets/7daaa2d6-8926-4891-9f93-731f9ee697fd.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7daaa2d6-8926-4891-9f93-731f9ee697fd.png)'
- en: There is a risk when isolating individuals parts for testing, of creating an
    unrealistic scenario in which you end up not actually testing the true functionality
    of a code base, but instead testing the efficacy of your mocks. Here, in our car
    analogy, isolating the horn by supplying it with a *mock* power supply enables
    us to purely test the horn's circuitry and sound-making mechanism and gives us
    a clear path to debugging issues if the test fails. But we need to complement
    this test with several integration tests so that we can be confident that the
    entire system works correctly. Even if we have a thousand unit tests for all parts
    of a system, there is no guarantee of a working system without testing the integration
    of all of these parts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时隔离各个部分存在风险，可能会创建一个不真实的场景，最终你实际上并没有测试代码库的真实功能，而是测试了你的模拟的有效性。在这里，以我们的汽车类比为例，通过提供一个*模拟*电源来隔离喇叭，使我们能够纯粹地测试喇叭的电路和发声机制，并为我们提供了一条明确的调试路径，如果测试失败的话。但我们需要通过几个集成测试来补充这个测试，以便我们可以确信整个系统正常工作。即使我们对系统的所有部分进行了一千次单元测试，也不能保证没有测试所有这些部分的集成的工作系统。
- en: Types of testing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: To ensure a thoroughly tested code base, we must engage in different types of
    testing. As touched on already, the *unit* test enables us to test isolated parts,
    while the various combinations of parts can be tested via either **integration**,
    **functional**, or **E2E** tests. It's useful first to understand what we mean
    when we talk about a *part* or a *unit*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保代码库经过了彻底的测试，我们必须进行不同类型的测试。正如前面提到的，*单元*测试使我们能够测试隔离的部分，而各种部分的组合可以通过**集成**、**功能**或**端到端**测试进行测试。首先了解我们谈论*部分*或*单元*时的含义是很有用的。
- en: 'When we talk about a unit of code, there is admittedly a fuzziness to the concept.
    Typically, it will be a piece of code that has a singular responsibility within
    a system. When a user wishes to perform an action via our software, they will,
    in fact, be activating a series of parts of our code, all working together to
    give the user the output they desire. Consider an app in which users can create
    and share images. A typical user experience (a flow or journey) may involve a
    few distinct steps that all involve different parts of the code base. Every action
    the *User* performs, often without them knowing, will encapsulate a series of
    code actions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码的一个单元时，概念上有一些模糊。通常，它将是系统内具有单一职责的代码片段。当用户希望通过我们的软件执行操作时，实际上他们将激活我们代码的一系列部分，所有这些部分一起工作以给用户提供他们所需的输出。考虑一个用户可以创建和分享图像的应用程序。典型的用户体验（流程或旅程）可能涉及几个不同的步骤，所有这些步骤都涉及代码库的不同部分。用户执行的每个操作，通常在他们不知情的情况下，都将包含一系列代码操作：
- en: '(User) Create a new image by uploading a photo stored on the desktop:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （用户）通过上传存储在桌面上的照片创建新图像：
- en: (Code) Upload the photo via `<form>`
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）通过`<form>`上传照片
- en: (Code) Save photo to a CDN
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）将照片保存到CDN
- en: (Code) Show the bitmap within `<canvas>` so that filters can be applied
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）在`<canvas>`中显示位图，以便应用滤镜
- en: '(User) Apply a filter to the image:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （用户）对图像应用滤镜：
- en: (Code) Apply the filter via `<canvas>` pixel manipulation
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）通过`<canvas>`像素操作应用滤镜
- en: (Code) Update image stored on the CDN
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）更新存储在CDN上的图像
- en: (Code) Re-download saved image
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）重新下载保存的图像
- en: '(User) Share the image with friends:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （用户）与朋友分享图像：
- en: (Code) Find the user's *friends* in the database
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）在数据库中查找用户的*朋友*
- en: (Code) Add the image to each friend's feed
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）将图像添加到每个朋友的动态中
- en: (Code) Send the *push notification* to all friends
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （代码）向所有朋友发送*推送通知*
- en: 'Together, all of these steps, combined with all other steps a user could potentially
    take, can be considered a system. And a fully-tested system might involve **unit**
    tests for each individual step, **integration** tests for each pair of steps,
    and **functional** or **End-to-End** (**E2E**) tests for every combination of
    steps that together form a *user flow* or *user journey*. We can visualize the
    types of tests that may need to exist as part of a system as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤，再加上用户可能采取的所有其他步骤，可以被视为一个系统。一个经过充分测试的系统可能涉及对每个单独步骤进行**单元**测试，对每对步骤进行**集成**测试，以及对形成*用户流*或*用户旅程*的每个步骤组合进行**功能**或**端到端**（**E2E**）测试。我们可以将可能需要作为系统一部分存在的测试类型可视化如下：
- en: '![](assets/132ddbe3-92d9-4e98-b072-55279e538f7d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/132ddbe3-92d9-4e98-b072-55279e538f7d.png)'
- en: Here, we can see one **Start** point and two **End** points, indicating two
    distinct *user journeys*. Each dot can be thought of as a single area of responsibility
    or *unit* that is activated as part of these journeys. As you can see, a unit
    test is only concerned with a single area of responsibility. The integration test
    is concerned with two (or more) neighboring areas that integrate. And an E2E or
    functional test is concerned with all of the areas involved in a singular user
    journey. In the former example of our image-sharing app, we can imagine that we
    may have specific unit tests for actions such as uploading a photo to the CDN or
    sending push notifications, an integration test that tests the integration of
    the friends database, and an E2E test that tests the entire flow from creating
    to sharing a new image. Each of these testing methodologies would be vital in
    ensuring a truly well-tested system, and each has its own unique benefits as well
    as pitfalls and challenges to overcome.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个**开始**点和两个**结束**点，表示两个不同的*用户旅程*。每个点可以被视为一个单独的责任区域或*单元*，作为这些旅程的一部分被激活。正如您所看到的，单元测试只关注一个单一的责任区域。集成测试关注两个（或更多）相邻的整合区域。而E2E或功能测试关注涉及单一用户旅程的所有区域。在我们图像分享应用的前面例子中，我们可以想象我们可能有特定的单元测试，例如将照片上传到CDN或发送推送通知的操作，一个测试朋友数据库整合的集成测试，以及一个测试从创建到分享新图像的整个流程的E2E测试。这些测试方法对确保一个真正经过充分测试的系统至关重要，每种方法都有其独特的好处以及需要克服的缺点和挑战。
- en: Unit testing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: As we described with our car analogy, a unit test is a test that deals with
    an isolated *unit* of code. This will usually be either a singular function or
    module that will make one or more simple assertions about the operation of the
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在汽车类比中所描述的，单元测试是处理孤立的代码*单元*的测试。这通常是一个单一的函数或模块，将对代码的操作进行一个或多个简单的断言。
- en: 'Here are some examples of singular unit test scenarios:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些单一单元测试场景的示例：
- en: You have a `Button` component that should contain the value `Submit My Data` and
    should have a class of `btn_success`. You can assert these characteristics via
    a simple unit test that checks the attributes of the produced DOM element.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个`Button`组件，应该包含值`Submit My Data`，并且应该有一个`btn_success`类。您可以通过简单的单元测试来断言这些特征，检查生成的DOM元素的属性。
- en: You have a task-scheduling utility that will perform a given action at the requested
    time. You can assert that it does so by giving it a task to perform at a specific
    time and then checking for the successful execution of that task.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个任务调度实用程序，它将在请求的时间执行给定的操作。您可以通过给它一个在特定时间执行的任务，然后检查该任务的成功执行来断言它是否这样做。
- en: You have a REST API endpoint of `/todo/list/item/{ID}` that retrieves a specific
    item from a database. You can assert that the route works correctly by mocking
    the database abstraction (providing fake data) and then asserting that requesting
    the URL returns your data correctly.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个REST API端点`/todo/list/item/{ID}`，它从数据库中检索特定的项目。您可以通过模拟数据库抽象（提供虚假数据），然后断言请求URL是否正确返回您的数据来断言该路由是否正常工作。
- en: 'There are several benefits of testing individually-isolated units of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个测试代码单元的几个好处：
- en: '**Completeness**: A given unit will typically have a small number of clearly
    defined requirements. As such, it''s easy to ensure that you''re testing the full
    gamut of a unit''s functionality. All input variations can be tested quite easily.
    The very limits of each unit can also be tested, including the often complex minutiae
    of how something operates.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性：** 给定的单元通常会有一小部分明确定义的要求。因此，很容易确保您正在测试单元功能的全部范围。所有输入变化都可以很容易地进行测试。还可以测试每个单元的极限，包括通常复杂的操作细节。'
- en: '**Reportability:** When a given unit test fails, you can quite easily discern
    the exact nature and circumstance of the failure, meaning quicker debugging and
    fixing of the underlying problem. This is in contrast to integration tests, which,
    as we will discover, may have far more generic reporting that doesn''t indicate
    the exact point of failure in the code.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可报告性：** 当给定的单元测试失败时，您可以很容易地辨别失败的确切性质和情况，这意味着更快地调试和修复潜在问题。这与我们将发现的集成测试形成对比，后者可能具有更通用的报告，无法指示代码中失败的确切点。'
- en: '**Comprehension:** Unit tests are a useful and self-contained form of documentation
    for given modules or functions. The narrowness and specificity of unit tests help
    us to fully understand how something works, easing maintainability. This is especially
    useful when there isn''t up-to-date documentation elsewhere.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解：** 单元测试是给定模块或函数的有用且独立的文档形式。单元测试的狭窄性和特定性帮助我们充分理解某些东西的工作原理，从而便于维护。当其他地方没有最新的文档时，这是特别有用的。'
- en: '*Completeness* here is similar to the popular concept of *test covera**ge*.
    The crucial difference is that while coverage is about maximizing the amount of
    code within a code base that is tested, completeness is about maximizing the coverage
    of each individual unit, so that the entire input space of the unit is expressed.
    Test coverage, as a metric, only tells us whether things are tested, not whether
    they''re well-tested.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*完整性*在这里类似于流行的*测试覆盖率*概念。关键的区别在于，虽然覆盖率是关于最大化测试代码库中的代码量，完整性是关于最大化每个单元的覆盖率，以便表达单元的整个输入空间。作为一个度量标准，测试覆盖率只告诉我们是否进行了测试，而不告诉我们是否测试得很好。'
- en: 'There are, however, challenges that come unit-testing as well:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单元测试也存在挑战：
- en: '**Mocking correctly**: Creating properly isolated unit tests sometimes means
    we have to constructs mocks or stubs of other units, as discussed in our former
    car analogy. It''s sometimes challenging to create realistic mocks and to ensure
    that you''re not introducing new areas of complexity and potential failures.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确模拟**：创建正确隔离的单元测试有时意味着我们必须构建其他单元的模拟或存根，就像我们之前讨论的汽车类比一样。创建逼真的模拟并确保你没有引入新的复杂性和潜在故障有时是具有挑战性的。'
- en: '**Testing realistic inputs**: Writing unit tests that provide a wide variety
    of realistic inputs is key although it can be challenging. It''s quite easy to
    fall into a trap of writing tests that appear to give confidence but in fact don''t
    test the kinds of situations that would arise when the code is in production.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试真实输入**：编写提供各种真实输入的单元测试是关键，尽管这可能是具有挑战性的。很容易陷入编写看似给予信心但实际上不测试代码在生产中可能出现的情况的测试的陷阱。'
- en: '**Testing true units and not combinations**: If not carefully constructed,
    unit tests can begin to bloat and become integration tests. Sometimes, a test
    can seem very simple on the surface but in fact depends on a series of integrations
    beneath the surface. To re-use our car analogy, an example of this would be if
    we were to attempt to make a simple unit test asserting the sound of the car horn
    without first isolating its circuitry. We''d unknowingly be creating an E2E test.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试真正的单元而不是组合**：如果不小心构建，单元测试可能会变得臃肿并变成集成测试。有时，一个测试在表面上看起来非常简单，但实际上取决于表面下一系列的集成。举个例子，如果我们试图在隔离其电路之前进行简单的单元测试来断言汽车喇叭的声音，那么我们将不知不觉地创建一个端到端测试。'
- en: The unit test, as the most granular type of test, is vital to any code base.
    It is perhaps easiest to think of it as a type of double-entry bookkeeping system.
    When you make a change, you must reflect that change via an assertion. This implementation-then-testing
    cycle is best done in proximity—one after the other—perhaps via TDD, which will
    be discussed later. The unit test is your way of confirming to yourself that you
    truly wrote the code you intended to write. It provides a level of certainty and
    reliability that your team and stakeholders will be hugely grateful for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最细粒度的测试类型，单元测试对于任何代码库都是至关重要的。最容易将其视为一种复式记账系统。当你进行更改时，你必须通过断言来反映这种变化。这种实现-测试循环最好是在接近的时间内进行——一个接一个地进行——可能通过TDD，这将在后面讨论。单元测试是你确认自己真正写了你打算写的代码的方式。它提供了一定程度的确定性和可靠性，你的团队和利益相关者会非常感激。
- en: Integration testing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing, as the name suggests, deals with integrations of distinct
    *units *of code. An integration test will provide a more useful signal about how
    your software will operate in production than simple unit tests. In our car analogy,
    an integration test might assert the functionality of the horn, based on how it
    operates with the car's own power supply, instead of providing a mock power supply.
    It may however still be a partially isolated test, ensuring it does not involve
    all components within the car.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试，顾名思义，涉及到代码的不同*单元*的集成。与简单的单元测试相比，集成测试将为您提供有关您的软件在生产中的运行方式的更有用的信号。在我们的汽车类比中，集成测试可能会根据它与汽车自己的电源供应的操作方式来断言喇叭的功能，而不是提供模拟电源供应。然而，它可能仍然是一个部分隔离的测试，确保它不涉及汽车内的所有组件。
- en: 'Here are a couple of examples of possible integration tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的集成测试的一些例子：
- en: You have a `Button` component that should add an item to a list when clicked.
    A possible integration test would be to render the component in the real DOM and
    check that a simulated `click` event correctly adds the item to the list. This
    tests the integration between the `Button` component, the DOM, and the logic that
    determines when items are added to the list.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个`Button`组件，当点击时应该向列表中添加一个项目。一个可能的集成测试是在真实DOM中渲染组件，并检查模拟的`click`事件是否正确地将项目添加到列表中。这测试了`Button`组件、DOM和确定何时向列表中添加项目的逻辑之间的集成。
- en: You have a REST API route of `/users/get/{ID}`, which should return user profile
    data from the database. A possible integration test would be to create a genuine
    database entry with ID of `456` and then request that data back via `/users/get/456`.
    This tests the integration between the HTTP routing abstraction and the database
    layer.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个REST API路由`/users/get/{ID}`，它应该从数据库中返回用户配置文件数据。一个可能的集成测试是创建一个ID为`456`的真实数据库条目，然后通过`/users/get/456`请求数据。这测试了HTTP路由抽象和数据库层之间的集成。
- en: 'There are quite a few advantages of integrating modules and testing their behavior
    together:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 集成模块和测试它们的行为一起有很多优势：
- en: '**Get better coverage**: Integration tests have one or more integrated modules
    as their test subject, and so by having such tests, we can increase our ''test
    coverage'' throughout our code base, meaning we are increasing the amount of our
    code that is exposed to tests and therefore increasing the likelihood that we''ll
    be able to catch faults.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获得更好的覆盖率**：集成测试将一个或多个集成模块作为测试对象，因此通过这样的测试，我们可以增加代码库中的“测试覆盖率”，这意味着我们正在增加代码的测试覆盖范围，从而增加我们捕捉故障的可能性。'
- en: '**Clearly see faults**: Emulating, at least in part, the integration of modules
    that we would see in production enables us to see real integration faults and
    failures as they may naturally occur. A clear view of these faults enables us
    to iterate with fixes quickly and retain a reliable system.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰地看到故障**：在一定程度上模拟我们在生产中可能看到的模块集成，使我们能够看到实际发生的集成故障和失败。对这些故障的清晰视图使我们能够快速进行修复并保持可靠的系统。'
- en: '**Expose bad expectations**: Integration tests allow us to challenge the assumptions
    we may have made when building individual units of code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴露错误的期望**：集成测试使我们能够挑战在构建单个代码单元时可能做出的假设。'
- en: 'So,while unit tests give us a narrow and detailed view of the input and output
    of specific modules and functions, integration tests allow us to see how all of
    these modules work together and, by doing so, provide us with a view into potential
    problems of integration. This is incredibly useful, but there are traps and challenges
    to writing integration tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然单元测试给我们提供了对特定模块和函数的输入和输出的狭窄和详细的视图，但集成测试使我们能够看到所有这些模块如何一起工作，并通过这样做，为我们提供了对集成潜在问题的视图。这是非常有用的，但编写集成测试也存在陷阱和挑战：
- en: '**Isolating integrations** (avoiding big bang tests): When implementing integration
    tests, it is sometimes easier to avoid isolating individual integrations and instead
    just test a large part of the system with all of its integrations intact. This
    is more akin to an E2E test and is certainly useful, but it''s important to also
    have isolated integrations so you can get granular insight into potential failures.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离集成**（避免大爆炸测试）：在实施集成测试时，有时更容易避免隔离单个集成，而是只测试系统的一个大部分，所有集成都完整。这更类似于端到端测试，当然很有用，但同样重要的是也要有隔离的集成，以便您可以更精确地了解潜在的失败。'
- en: '**Realistic integrations** (for example, database server and client): When
    picking and isolating integrations to test, it is sometimes difficult to create
    realistic circumstances. An example would be testing how your REST API integrates
    with your database server but instead of having a separate database server for
    testing purposes, you just have a local one. This is still an insightful test
    but because it does not emulate the remoteness of the database server (that would
    exist in production) you may get a false sense of confidence. There may be failures
    lurking, undetected.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实的集成**（例如，数据库服务器和客户端）：在选择和隔离要测试的集成时，有时很难创建真实的情况。例如，测试您的REST API如何与数据库服务器集成，但是在测试目的上没有单独的数据库服务器，只有一个本地数据库服务器。这仍然是一个有见地的测试，但因为它没有模拟数据库服务器的远程性（在生产中存在），您可能会产生错误的信心。可能会有潜在的失败潜伏，未被发现。'
- en: The integration test provides vital insight at the crucial points of interfacing
    and I/O that govern how all of the individual parts of a code base work together
    as a system. Integration tests often provide the most signal about potential faults
    in a system, as they are both usually quick to run and highly transparent upon
    failures (unlike potentially clunky E2E tests). Naturally, integration tests can
    only tell you things about the points of integrations they encapsulate. For more
    complete confidence in the functionality of a system, it's always a good idea
    to employ E2E testing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试在决定代码库的所有单独部分如何作为一个系统一起工作的关键接口和I/O的关键点提供了重要的洞察。集成测试通常提供了关于系统潜在故障的最明显的信号，因为它们通常运行速度快，并且在失败时非常透明（不像潜在笨重的端到端测试）。当然，集成测试只能告诉您它们封装的集成点的信息。为了更完全地对系统功能的信心，始终使用端到端测试是一个好主意。
- en: E2E and functional testing
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端和功能测试
- en: E2E testing is a more extreme form of integration test where, instead of testing
    individual integrations between modules, we'll test the entire system, usually
    by executing a series of actions that would happen in reality to produce a given
    result. These tests are sometimes also called **functional tests** because they
    are interested in testing areas of functionality from the user's perspective.
    Well-constructed E2E tests give us confidence that our entire system is working
    correctly, but are most valuable when combined with more granular unit and integration
    tests so that faults can be more quickly and precisely identified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是集成测试的一种更极端的形式，它不是测试模块之间的单个集成，而是测试整个系统，通常通过执行一系列在现实中会发生的操作来产生给定的结果。这些测试有时也被称为**功能测试**，因为它们致力于从用户的角度测试功能区域。构建良好的端到端测试使我们确信整个系统正常工作，但当与更粒度的单元和集成测试结合使用时，可以更快速和准确地识别故障。
- en: 'Here''s a quick lowdown of the benefits of writing E2E tests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是编写端到端测试的好处的简要概述：
- en: '**Correctness and health**: E2E tests give you a clear insight into the general
    health of a system. Since many individual parts will effectively be tested via
    the typical E2E test, its success can give you a good indication that things are
    okay in production. Granular unit or integration tests, while very useful in their
    own way, don''t give you this kind of systemic insight.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性和健康**：端到端测试为您提供了对系统整体健康状况的清晰洞察。由于许多单独的部分将通过典型的端到端测试进行有效测试，其成功可以给您一个良好的指示，表明在生产中一切都正常。粒度单元或集成测试虽然在其自身的方式上非常有用，但无法给您这种系统洞察力。'
- en: '**Realistic effects**: Via E2E tests we can tryout more realistic circumstances,
    emulating the way our code will run in the wild. By emulating the flow of a typical
    user, an E2E test can highlight potential issues that more granular unit or integration
    tests might not reveal. An example of this would be when there are race conditions
    or other timing issues that can only be revealed when a code base is made to run
    as one consolidated system.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实的效果**：通过端到端测试，我们可以尝试更真实的情况，模拟我们的代码在野外运行的方式。通过模拟典型用户的流程，端到端测试可以突出显示更粒度的单元或集成测试可能无法揭示的潜在问题。例如，当存在竞争条件或其他时间问题时，只有当代码库作为一个整体系统运行时才能揭示这些问题。'
- en: '**More holistic view**: E2E tests give developers a holistic view of a system,
    enabling them to reason more accurately about how distinct modules work together
    to produce a working user flow. This can be incredibly valuable when trying to
    build a full understanding of how a system operates. Much like both unit and integration
    tests, E2E tests can serve as a form of documentation.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更全面的视角**：E2E测试为开发人员提供了系统的视角，使他们能够更准确地推断出不同模块如何共同产生工作的用户流程。当试图建立对系统操作方式的全面理解时，这是非常有价值的。与单元测试和集成测试一样，E2E测试也可以作为一种文档形式。'
- en: 'There are challenges involved in crafting E2E tests, however:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，制作E2E测试也存在挑战：
- en: '**Performance and time costs**: E2E tests, because they involve the activation
    of many individual pieces of code immersed in realistic environments, can be quite
    expensive in terms of time and hardware resources. The time that E2E tests take
    to run can impede development, and so it''s not rare for teams to avoid E2E tests
    for fear of a slowed development cycle.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和时间成本**：E2E测试涉及激活许多个别代码片段并置身于真实环境中，因此在时间和硬件资源方面可能会非常昂贵。E2E测试运行所需的时间可能会妨碍开发，因此团队为了避免开发周期变慢，避免E2E测试并不罕见。'
- en: '**Realistic steps**: Accurately emulating real-life circumstances in an E2E
    test can be a challenge. Using fake or made-up situations and data can still provide
    a realistic enough test but can also provide you a false sense of confidence.
    Since E2E tests are scripted, it''s quite common to not only rely on fake data
    but to have actions conducted in an unrealistically fast or direct manner, missing
    out on possible insights you could gain by creating more human circumstances (repeat
    after me: *always think of the user*).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实的步骤**：在E2E测试中准确模拟真实生活中的情况可能是一种挑战。使用虚假或捏造的情况和数据仍然可以提供足够真实的测试，但也可能给你一种虚假的信心。由于E2E测试是脚本化的，不仅依赖于虚假数据是相当常见的，而且还可能以一种不真实的快速或直接的方式进行操作，错过了通过创建更人性化情况获得的可能的见解（重复：*永远考虑用户*）。'
- en: '**Complex tooling**: The point of an E2E test is to realistically emulate a
    user flow as it would exist in the wild. To accomplish this, we need good tooling
    that enables us to set up realistic environments (for example, headless and scriptable
    browser instances). Such tooling can be buggy or complicated to use and can introduce
    yet another variable to the testing process that can result in unrealistic failures
    (tools can give you false signals about whether things are really working).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的工具**：E2E测试的目的是真实地模拟用户在实际环境中的流程。为了实现这一点，我们需要良好的工具，使我们能够建立真实的环境（例如，无头浏览器和可编写脚本的浏览器实例）。这样的工具可能存在bug或者使用起来很复杂，并且可能会引入另一个变量到测试过程中，导致不真实的失败（工具可能会给出关于事物是否真正工作的错误信号）。'
- en: E2E testing, although challenging to get right, can provide a level of insight
    and confidence that is hard to get from only unit and integration tests. In terms
    of automated testing procedures, E2E testing is the closest we can reasonably
    get to getting our software in front of real users. It is the least granular and
    most systemic way of discerning whether our software works in the way our users
    expect it to, which, after all, is what we're most interested in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管E2E测试很难做到完美，但它可以提供一种洞察和信心，这是仅仅通过单元测试和集成测试很难获得的。在自动化测试程序方面，E2E测试是我们可以合理获得软件真实用户反馈的最接近方式。这是最不精细、最系统化的方式来判断我们的软件是否按照用户的期望工作，这毕竟是我们最感兴趣的。
- en: Test-Driven Development
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: TDD is a paradigm in which we write tests before implementation. In doing so,
    our tests end up informing and affecting the design of our implementation and
    its interface. By doing this, we begin to see tests as not only a form of documentation
    but a form of specification. Via our tests, we can designate how we wish something
    to work, writing assertions as if the functionality existed, and then we can iteratively
    build out the implementation such that all of our tests eventually pass.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种在实现之前编写测试的范式。通过这样做，我们的测试最终会影响我们实现的设计和接口。通过这样做，我们开始将测试视为不仅是一种文档形式，而且是一种规范形式。通过我们的测试，我们可以指定我们希望某些功能的工作方式，编写断言，就好像功能已经存在一样，然后我们可以逐步构建实现，使我们所有的测试最终都通过。
- en: 'To illustrate TDD, let''s imagine that we wish to implement a word-counting
    function. Before implementing it, we can begin to write some assertions about
    how we wish for it to work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明TDD，让我们想象一下我们希望实现一个单词计数功能。在实现之前，我们可以开始写一些关于它如何工作的断言：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a rather simple function and so we''ve been able to express most of
    its functionality in just three assertions. There are naturally other edge cases
    but we''ve pieced together enough expectations that we can begin to implement
    the function. Here is our first attempt:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数，所以我们只用了三个断言来表达它的大部分功能。当然还有其他边缘情况，但我们已经拼凑出了足够的期望，可以开始实现这个函数了。这是我们的第一次尝试：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Immediately running this implementation via our small test suite, we receive
    the following results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 立即通过我们的小测试套件运行这个实现，我们收到了以下结果：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Hyphenated words` test is failing. TDD, by its nature, expects iterative
    failure and refactor to bring an implementation inline with a test suite. Given
    this particular failure, we can simply add a hyphen to our regular expression''s
    character class (between the `[...]` delimiters):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`连字符单词`测试失败了。TDD的本质是期望通过迭代的失败和重构来使实现与测试套件保持一致。鉴于这个特定的失败，我们可以简单地在正则表达式的字符类中添加一个连字符（在`[...]`分隔符之间）：'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produces the following test logs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下的测试日志：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Success! Via incremental iteration, although simplified for the sake of illustration,
    we have implemented something via TDD.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！通过逐步迭代，尽管为了说明简化，我们已经通过TDD实现了一些东西。
- en: 'As you may have observed, TDD is not a particular type or style of test, but
    rather it is a paradigm for *when*, *how*, and *why* we go about testing. The
    traditional view of testing as an afterthought is limited and often can force
    us into a position where we simply don''t have time to write a good test suite.
    TDD, however, forces us to lead with a solid test suite, giving us a few notable
    benefits:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经观察到的，TDD并不是一种特定类型或风格的测试，而是一种关于*何时*、*如何*和*为什么*进行测试的范式。传统观点认为测试是事后的想法，这种观点是有限的，通常会迫使我们处于这样一种境地：我们根本没有时间编写一个好的测试套件。然而，TDD迫使我们以一个完整的测试套件为先导，给我们带来了一些显著的好处：
- en: It guides implementation
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它指导实施
- en: It prioritizes the user
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它优先考虑用户
- en: It forces complete test coverage
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制进行完整的测试覆盖
- en: It forces single responsibility
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它强制单一责任
- en: It enables quick problem domain discovery
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够快速发现问题领域
- en: It gives you immediate feedback
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给予你即时反馈
- en: TDD is an especially useful paradigm when getting started with testing as it
    will force you to take a step back before implementing something and really consider
    what you're trying to do. This planning stage is really helpful in ensuring that
    our code fully aligns with user expectations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在开始测试时是一种特别有用的范式，因为它会迫使你在实施之前退后一步，真正考虑你想要做什么。这个规划阶段对于确保我们的代码与用户期望完全一致非常有帮助。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the concept of testing and how it relates to
    software. While brief and introductory, these foundational concepts are crucial
    if we're going to approach testing with an aim toward reliability and maintainability.
    Testing, like many other concerns in the software world, can be liable to cargo
    culting, so it's crucial to retain a perspective on the fundamentals and the theory
    behind the tests we write. Testing, at its core, is about proving expectations
    and protecting against faults. We've covered the differences between unit, integration,
    and E2E tests, discussing both the advantages and challenges inherent in each.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了测试的概念以及它与软件的关系。虽然简短和入门级，但这些基础概念对于我们以可靠性和可维护性为目标进行测试是至关重要的。测试，就像软件世界中的许多其他问题一样，可能会容易地变成一种迷信，因此保持对我们编写的测试背后的基本原理和理论的视角至关重要。测试，本质上是关于证明期望和防范故障的。我们已经讨论了单元测试、集成测试和端到端测试之间的区别，讨论了每种测试中固有的优势和挑战。
- en: In the next chapter, we'll look into how we can take this knowledge and apply
    it to crafting clean tests alongside real-life examples. Specifically, we will
    cover what measures and guiding principles we can use to ensure that our tests
    and the assertions within them are reliable, intuitive, and maximally useful.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将这些知识应用于制定干净的测试和实际示例。具体来说，我们将介绍我们可以使用哪些措施和指导原则来确保我们的测试和其中的断言是可靠的、直观的和最大程度有用的。
