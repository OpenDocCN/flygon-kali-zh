- en: Chapter 11. Coding Best Practice and Testing the Functional Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。编码最佳实践和测试函数式代码
- en: 'We developed a functional application in the previous chapter. To create better
    code in the functional approach, we have to follow the best practice rules and
    implement them in our code. In this chapter, we are going to discuss the concept
    of the functional approach, which is a pure function and makes our function similar
    to a mathematical function. The topics that will be covered in this chapter are
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了一个函数式应用程序。为了在函数式方法中创建更好的代码，我们必须遵循最佳实践规则并在我们的代码中实现它们。在本章中，我们将讨论函数式方法的概念，即纯函数，并使我们的函数类似于数学函数。本章将涵盖以下主题：
- en: Preventing dishonest signatures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止不诚实的签名
- en: Creating immutable classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不可变类
- en: Avoiding `Temporal Coupling`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免“时间耦合”
- en: Dealing with the side-effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理副作用
- en: Separating the code into a `Domain Logic` and the `Mutable Shell`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码分离为`领域逻辑`和`可变外壳`
- en: Testing the functional code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数式代码
- en: Coding best practices in functional C#
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式C#中的编码最佳实践
- en: The functional approach has the concept of a pure function. This means that
    the function will produce the same result as long as we pass the exact same input.
    Now, let's start our discussion to create the better functional code by following
    the coding best practices outlined here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法有纯函数的概念。这意味着只要我们传递完全相同的输入，函数将产生相同的结果。现在，让我们开始讨论按照这里概述的编码最佳实践来创建更好的函数式代码。
- en: Preventing dishonest signatures
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止不诚实的签名
- en: 'As we discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional
    Style in C#") , *Tasting Functional Style in C#* , we use the mathematical approach
    to constructing our code in functional programming. In other words, functional
    programming is programming with mathematical functions. There are two requirements
    that mathematical functions must fit, they are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](text00016.html#ch01 "第1章。在C#中尝试函数式风格")中讨论的，*在C#中尝试函数式风格*，我们使用数学方法来构建我们的函数式编程代码。换句话说，函数式编程是使用数学函数进行编程。数学函数必须符合两个要求，它们是：
- en: A mathematical function should always return the same result whenever we supply
    the same arguments.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数应该在我们提供相同参数时始终返回相同的结果。
- en: The signature of the mathematical function should deliver all the information
    for the possible accepted input values and the possible produced output.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数的签名应该提供所有可能接受的输入值和可能产生的输出的信息。
- en: 'Now let''s take a look at the following code snippet, which we can find in
    the `HonestSignature.csproj` project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下以下的代码片段，我们可以在`HonestSignature.csproj`项目中找到：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By examining the preceding `SumUp()` function, we can say that we will retrieve
    the same output every time we pass the same inputs. Now let''s examine the following
    `GenerateRandom()` function, which we can also find in the `HonestSignature.csproj`
    project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查前面的`SumUp()`函数，我们可以说每次传递相同的输入时，我们将获得相同的输出。现在让我们检查以下的`GenerateRandom()`函数，我们也可以在`HonestSignature.csproj`项目中找到：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From the preceding code, we can see that we will retrieve different output
    although we pass the same input continually. Suppose we have the following `RunGenerateRandom()`
    function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到，尽管我们不断传递相同的输入，但我们将获得不同的输出。假设我们有以下的`RunGenerateRandom()`函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the preceding `RunGenerateRandom()` function, we will get the following
    output on the console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`RunGenerateRandom()`函数，将在控制台上得到以下输出：
- en: '![Preventing dishonest signatures](img/Image00114.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![防止不诚实的签名](img/Image00114.jpg)'
- en: From the preceding code snippet, we invoke the `GenerateRandom()` function 10
    times by passing the exact same argument, that is, 100\. As you can see in the
    preceding figure, the function returns a different output for each of the 10 invocations.
    So, we have to avoid functions such as the `GenerateRandom()` function in order
    to create a pure function since it is not a mathematical function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们通过传递完全相同的参数，即100，10次调用了`GenerateRandom()`函数。正如您在前面的图中所看到的，该函数对于这10次调用的每一次返回了不同的输出。因此，我们必须避免类似`GenerateRandom()`函数这样的函数，以创建纯函数，因为它不是数学函数。
- en: 'Now let''s take a look at the following `Divide()` function, which will divide
    the first argument by the second argument:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下以下的`Divide()`函数，它将第一个参数除以第二个参数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Divide()` function looks similar to the `SumUp()` function since the signature
    of the `Divide()` function accepts any two integers and returns another integer.
    So if we pass the exact same argument, it will return the same output. However,
    how about if we pass 1 and 0 as input parameters? The `Divide()` function will
    throw a `DivideByZeroException` error instead of returning an integer value. In
    this case, we can conclude that the signature of the function does not deliver
    enough information about the result of the operation. It looks like the function
    can handle any two parameters of the integer type, but it actually cannot. To
    solve this problem, we can refactor the preceding `Divide()` function to the following
    one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Divide()`函数看起来与`SumUp()`函数相似，因为`Divide()`函数的签名接受任意两个整数并返回另一个整数。因此，如果我们传递完全相同的参数，它将返回相同的输出。但是，如果我们将1和0作为输入参数传递会怎样呢？`Divide()`函数将抛出`DivideByZeroException`错误，而不是返回一个整数值。在这种情况下，我们可以得出结论，函数的签名没有提供关于操作结果的足够信息。它看起来函数可以处理任意两个整数类型的参数，但实际上却不能。为了解决这个问题，我们可以将前面的`Divide()`函数重构为以下函数：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding `Divide()` function, we add the `nullable` type
    by adding a question mark after `int` so that the return of the function can be
    null. We also add an `if` statement to make sure that `DivideByZeroException`
    error will never be thrown.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的`Divide()`函数中所看到的，我们通过在`int`后添加问号来添加`nullable`类型，以便函数的返回可以为null。我们还添加了一个`if`语句，以确保永远不会抛出`DivideByZeroException`错误。
- en: Refactoring a mutable class into an immutable one
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可变类重构为不可变类
- en: Immutability is very important in functional programming, since a mutable operation
    will make our code dishonest. As we discussed previously, we need to prevent dishonest
    operations in order to create our pure function approach. Immutability is applied
    to a data structure - for instance, a class means that the objects of this class
    cannot be changed during their lifetime. In other words, we can say that a class
    is mutable if the instances of the class can be changed in some way, while it
    is immutable if we cannot modify the instance of that class once we create it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，不可变性非常重要，因为可变操作会使我们的代码不诚实。正如我们之前讨论过的，我们需要防止不诚实的操作，以便创建我们的纯函数方法。不可变性应用于数据结构
    - 例如，类意味着该类的对象在其生命周期内不能被更改。换句话说，我们可以说如果类的实例在某种方式上可以被更改，那么该类是可变的，而如果我们创建实例后就无法修改该类的实例，则它是不可变的。
- en: 'Now, let''s take a look at the following code, which can be found in the `Immutability.csproj`
    project to continue our discussion:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码，它可以在`Immutability.csproj`项目中找到，以继续我们的讨论：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the preceding code, we have a simple composition. The `UserMembership`
    class consists of the `_user` and `_memberSince` properties. We can also see that
    the `User` class is immutable since all the properties are defined as read-only.
    Because of immutability, the only way for the `UserMembership` method to update
    the `_user` field is to create a new `User` instance and replace the old one with
    it. Note that the `Use` r class itself doesn't contain the state here, whereas
    the `UserMembership` class does. We can say that the `UpdateUser` method leaves
    a side-effect by changing the object's state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们有一个简单的组合。`UserMembership`类由`_user`和`_memberSince`属性组成。我们还可以看到`User`类是不可变的，因为所有属性都被定义为只读。由于不可变性，`UserMembership`方法更新`_user`字段的唯一方法是创建一个新的`User`实例并用它替换旧的实例。请注意，`User`类本身在这里不包含状态，而`UserMembership`类包含。我们可以说`UpdateUser`方法通过更改对象的状态留下了副作用。
- en: 'Now let''s refactor the `UpdateUser` method and make it immutable. The following
    code is the result of refactoring the `UpdateUser` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重构`UpdateUser`方法并使其不可变。以下代码是重构`UpdateUser`方法的结果：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `UpdateUser()` method no longer updates the structure of
    the `UserMembership` class. Instead, it creates a new `UserMembership` instance
    and returns it as a result of the operation. By refactoring the `UpdateUser` method,
    we have eliminated the side-effect from the method. Now it's clear what the actual
    output of the operation is. The usage of immutable data makes the code more readable
    and also helps to provide a good understanding of what is going on right away
    without too much effort.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所看到的，`UpdateUser()`方法不再更新`UserMembership`类的结构。相反，它创建一个新的`UserMembership`实例并将其作为操作的结果返回。通过重构`UpdateUser`方法，我们已经从方法中消除了副作用。现在清楚了操作的实际输出是什么。使用不可变数据使代码更易读，也有助于立即了解发生了什么，而不需要太多的努力。
- en: Avoiding mutability and temporal coupling
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免可变性和时间耦合
- en: 'Sometimes, the use of the methods with side-effects will damage readability.
    The invocation of one method is coupled with the other''s method invocation. To
    make things clear, let''s take a look at the following code, which we can find
    in the `TemporalCoupling.csproj` project:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用具有副作用的方法会损害可读性。一个方法的调用与另一个方法的调用耦合在一起。为了明确事情，让我们看一下以下代码，我们可以在`TemporalCoupling.csproj`项目中找到：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the preceding code, you can see that we have a `MembershipDatabase` class,
    which processes a new member. It retrieves input parameters named `memberName`
    and `addressString` and uses them to insert a new member in the database. The
    `Process()` method in the `MembershipDatabase` class invokes the `CreateAddress`
    method first, which will create the address and then save it to the private field.
    The `CreateMember()` method then retrieves the address and uses it to instantiate
    a new `Member` parameter, which is saved in another private field named `member`
    . The last method, the `SaveMember()` method, saves the member to the database
    (in this example, we use `list` ). There is a problem here. The invocations in
    the `Process()` method are coupled with temporal coupling. We have to always invoke
    these three methods in the right order for this code to work properly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，您可以看到我们有一个`MembershipDatabase`类，它处理一个新成员。它检索名为`memberName`和`addressString`的输入参数，并使用它们在数据库中插入一个新成员。`MembershipDatabase`类中的`Process()`方法首先调用`CreateAddress`方法，该方法将创建地址，然后将其保存到私有字段中。然后`CreateMember()`方法检索地址并使用它来实例化一个新的`Member`参数，该参数保存在另一个名为`member`的私有字段中。最后的方法`SaveMember()`方法将成员保存到数据库（在此示例中，我们使用`list`）。这里有一个问题。`Process()`方法中的调用与时间耦合在一起。我们必须始终以正确的顺序调用这三个方法，以使此代码正常工作。
- en: If we don't place the method in the right order - for instance, if we put the
    `CreateAddress()` method invocation, after the `CreateMember()` method invocation
    the resulting member instance will be invalid since the member will not retrieve
    the required dependency address. Likewise, if we put the `SaveMember()` method
    invocation above others, it will throw `NullReferenceException` because, when
    it tries to save a member, the member instance would still be null.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不按正确顺序放置方法 - 例如，如果我们在`CreateMember()`方法调用之后放置`CreateAddress()`方法调用，则由于成员将无法检索所需的依赖地址，结果成员实例将无效。同样，如果我们将`SaveMember()`方法调用放在其他方法之上，它将抛出`NullReferenceException`，因为当它尝试保存成员时，成员实例仍将为null。
- en: Temporal coupling is a consequence of the method's signature dishonesty. The
    `CreateAddress()` method has an output, creating an `address` instance, but this
    output is hidden under a side-effect because we mutate the `Address` field in
    the `MembershipDatabase` class. The `CreateMember()` method hides the result of
    the operation as well. It saves `member` to the private field, but it also hides
    some of its input. From the signature of the `CreateMember()` method, we might
    think that it needs only the name parameter in order to create `member` while
    it actually refers to a global state, the `address` field.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 时间耦合是方法签名不诚实的结果。`CreateAddress()`方法有一个输出，创建一个`address`实例，但这个输出被隐藏在副作用下，因为我们改变了`MembershipDatabase`类中的`Address`字段。`CreateMember()`方法也隐藏了操作的结果。它保存了`member`到私有字段，但也隐藏了一些输入。从`CreateMember()`方法的签名来看，我们可能会认为它只需要名称参数来创建`member`，但实际上它引用了一个全局状态，即`address`字段。
- en: 'This happens to the `SaveMember()` method as well. To remove the temporal coupling,
    we have to specify all of the input and output in the method''s signatures explicitly
    or, in other words, move all side-effects and dependencies to the signature level.
    Now, let''s refactor the preceding side-effect - containing code to the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveMember()`方法也发生了同样的情况。为了消除时间耦合，我们必须在方法的签名中明确指定所有的输入和输出，或者换句话说，将所有的副作用和依赖关系移到签名级别。现在，让我们将前面包含副作用的代码重构为以下代码：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the highlighted code, we can see that we have refactored the `CreateAddress()`
    , `CreateMember()` , `SaveMember()` , and `Process()` methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，我们可以看到我们已经重构了`CreateAddress()`、`CreateMember()`、`SaveMember()`和`Process()`方法。
- en: The `CreateAddress()` method now returns `Address` instead of saving it to the
    private field. In the `CreateMember()` method, we add a new parameter, `address`
    , and also change the returning type. For the `SaveMember()` method, instead of
    referring to the customer private field, we now specify it as a dependency in
    the method's signature. In the `Process()` method, we can now remove the fields,
    and we have successfully removed the temporal coupling with this change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateAddress()`方法现在返回`Address`而不是将其保存到私有字段中。在`CreateMember()`方法中，我们添加了一个新的参数`address`，并且也改变了返回类型。对于`SaveMember()`方法，我们现在在方法的签名中指定它作为一个依赖项，而不是引用私有字段。在`Process()`方法中，我们现在可以移除字段，并且成功地消除了时间耦合。'
- en: Now, it's impossible for us to put the `CreateAddress()` invocation method after
    the `CreateMember()` invocation method because the code will not be compiled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们无法在`CreateMember()`调用方法之后放置`CreateAddress()`调用方法，因为代码将无法编译。
- en: Dealing with the side-effects
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理副作用
- en: 'Although we need to create a pure function in functional programming, we cannot
    avoid the side-effects completely. As you can see in the preceding `MembershipDatabase`
    class, we have the `SaveMember()` method, which will save the member field into
    the database. The following code snippet will explain this clearly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在函数式编程中我们需要创建一个纯函数，但我们无法完全避免副作用。正如你在前面的`MembershipDatabase`类中所看到的，我们有`SaveMember()`方法，它将会把member字段保存到数据库中。下面的代码片段将清楚地解释这一点：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To deal with the side-effects, we can use the **command-query separation** (
    **CQS** ) principle to separate methods that generate side-effects and methods
    that don't. We can call commands for methods that incur side-effects and queries
    for methods that don't. If the method alters a piece of state, it should be the
    void type method. Otherwise, it should return something. Using this CQS principle,
    we can identify the purpose of a method by just looking at its signature. If the
    method returns a value, it will be a query and it won't mutate anything. If the
    method returns nothing, it must be a command and will leave some side-effects
    in the system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理副作用，我们可以使用**命令查询分离**（**CQS**）原则来区分产生副作用和不产生副作用的方法。我们可以为产生副作用的方法调用命令，而对于不产生副作用的方法调用查询。如果方法改变了某个状态，它应该是void类型的方法。否则，它应该返回某些东西。使用这个CQS原则，我们可以通过查看方法的签名来确定方法的目的。如果方法返回一个值，它将是一个查询，不会改变任何东西。如果方法没有返回值，它必须是一个命令，并且会在系统中留下一些副作用。
- en: From the preceding `MembershipDatabase` class, we now can identify that the
    `Process()` and `SaveMember()` methods are commands types and will leave some
    side-effects since they return nothing. In contrast, the `CreateAddress()` and
    `CreateMember()` methods are queries and won't mutate anything since they return
    something.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`MembershipDatabase`类中，我们现在可以确定`Process()`和`SaveMember()`方法是命令类型，并且会产生一些副作用，因为它们没有返回值。相比之下，`CreateAddress()`和`CreateMember()`方法是查询，不会改变任何东西，因为它们有返回值。
- en: Separating the code from domain logic and mutable shell
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码与领域逻辑和可变外壳分离
- en: Sometimes, when our code processes a business transaction, it mutates some data
    several times. In the world of object-oriented programming languages, this is
    quite a common pattern. We can then separate our code into domain logic and the
    mutable shell. In domain logic, we simplify the code and write the business logic
    in a functional way using mathematical functions. As a result, this domain logic
    will become easy to test. In the mutable shell, we place a mutable expression;
    we will do this after we finish with the business logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们的代码处理业务交易时，会多次改变一些数据。在面向对象编程语言的世界中，这是一个很常见的模式。然后我们可以将我们的代码分成领域逻辑和可变外壳。在领域逻辑中，我们简化代码，使用数学函数以函数式的方式编写业务逻辑。结果，这个领域逻辑将变得容易测试。在可变外壳中，我们放置一个可变表达式；在完成业务逻辑后，我们将这样做。
- en: Examining the code containing side-effects
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查包含副作用的代码
- en: 'Now, let''s examine the following code, which contains many side-effects that
    we are going to refactor, and we can find it in the `DomainLogicAndMutatingState.csproj`
    project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查下面的代码，其中包含了许多我们将要重构的副作用，并且可以在`DomainLogicAndMutatingState.csproj`项目中找到它：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the preceding code, it is written in a straightforward way.
    We are going to separate its responsibilities into two parts: an immutable core
    that contains all the domain logic and a mutable shell that contains all the mutable
    expression.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，它是以一种直接的方式编写的。我们将把它的责任分成两部分：一个包含所有领域逻辑的不可变核心，以及一个包含所有可变表达式的可变外壳。
- en: 'The `Librarianship` class will keep track of all the borrowers in a library
    and takes note of the book-returning date. The class uses a log file to store
    the borrower''s name, the title of the borrowed book, and the returning date.
    The pattern of the log file content is the index number, a semicolon, the borrower
    name and then the semicolon again, the book title and then the semicolon, and
    lastly, the returning date. The following is a sample of the log file content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Librarianship`类将跟踪图书馆中所有借阅者，并记录归还日期。该类使用日志文件存储借阅者的姓名、借阅书籍的标题和归还日期。日志文件内容的模式是索引号、分号、借阅者姓名，然后再次是分号、书名，然后是分号，最后是归还日期。以下是日志文件内容的示例：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class must be able to add a new line in the log file, such as what we can
    see in the `AddRecord()` method. But before we invoke the method, we have to specify
    the value for the `_maxEntriesPerFile` field when we construct the class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该类必须能够在日志文件中添加新行，就像我们在`AddRecord()`方法中看到的那样。但在调用该方法之前，我们必须在构造类时为`_maxEntriesPerFile`字段指定值。
- en: 'The value of the `_maxEntriesPerFile` field will be used when we invoke the
    `AddRecord()` method. If `_maxEntriesPerFile` is greater than the current total
    lines of the log file, it will insert the visitor identity into the log file using
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`_maxEntriesPerFile`字段的值将在调用`AddRecord()`方法时使用。如果`_maxEntriesPerFile`大于日志文件的当前总行数，它将使用以下代码将访客身份插入日志文件中：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Otherwise, if the current total number of lines of the log file has reached
    `_maxEntriesPerFile` , then `AddRecord()` method creates a new log file, as shown
    in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果日志文件的当前总行数已达到`_maxEntriesPerFile`，则`AddRecord()`方法将创建一个新的日志文件，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the preceding code snippet, we find the `GetNewFileName()` method to generate
    a new log file name based on the current log file name. The implementation of
    the `GetNewFileName()` method is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们发现了`GetNewFileName()`方法，它根据当前日志文件名生成一个新的日志文件名。`GetNewFileName()`方法的实现如下：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the preceding `GetNewFileName()` method's implementation, we can see that
    the pattern of the log file name is `LibraryLog _0001.txt` , `LibraryLog _0002.txt`
    , and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`GetNewFileName()`方法的实现中，我们可以看到日志文件名的模式是`LibraryLog _0001.txt`，`LibraryLog
    _0002.txt`等。
- en: 'The `AddRecord(` ) method will also create a new log file if the specified
    log file name is not found. The implementation of this task is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddRecord()`方法还将在找不到指定的日志文件名时创建一个新的日志文件。该任务的实现如下：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The class also has the `RemoveRecord()` method to remove the visitor identity
    from the log file. The implementation of the method is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还有`RemoveRecord()`方法，用于从日志文件中删除访客身份。该方法的实现如下：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `RemoveRecord()` method''s implementation, you can see that it removes
    the selected visitor from the available log file in the selected directory, as
    shown in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RemoveRecord()`方法的实现中，您可以看到它从所选目录中的可用日志文件中删除所选访客，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If `linesToKee` p contains no data, we can securely delete the file using the
    following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`linesToKee` p不包含数据，我们可以使用以下代码安全地删除文件：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, we just need to remove the visitor identity from the log file using
    the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们只需要使用以下代码从日志文件中删除访客身份：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now it''s time to try our `Librarianship` class. First, we will prepare a data
    list that contains the author and the title of the books, as shown in the following
    code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试我们的`Librarianship`类了。首先，我们将准备一个包含书籍作者和标题的数据列表，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And we have the `Book` structure as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下`Book`结构：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will invoke the following `LibrarianshipInvocation()` method to consume
    the `Librarianship` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用以下`LibrarianshipInvocation()`方法来使用`Librarianship`类：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in the preceding `LibrarianshipInvocation()` method, we call
    the `GetLastLogFile()` method to find the last available log file. The implementation
    of the method is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的`LibrarianshipInvocation()`方法中所看到的，我们调用`GetLastLogFile()`方法来查找最后一个可用的日志文件。该方法的实现如下：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we call the `GetLastLogFile()` method, it will look for all files that
    have the `LibraryLog_????.txt` pattern in the directory we specified. It will
    then return the last member of the string array. If the string array contains
    no data, it will return `LibraryLog_0001.txt` as the default log file name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`GetLastLogFile()`方法时，它将查找指定目录中具有`LibraryLog_????.txt`模式的所有文件。然后它将返回字符串数组的最后一个成员。如果字符串数组不包含数据，它将返回`LibraryLog_0001.txt`作为默认的日志文件名。
- en: 'If we run the `LibrarianshipInvocation()` method, we will see nothing, but
    we will get a new `LibraryLog_0001.txt` file containing the following text:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`LibrarianshipInvocation()`方法，我们将看不到任何内容，但是我们将得到一个包含以下文本的新的`LibraryLog_0001.txt`文件：
- en: '![Examining the code containing side-effects](img/Image00115.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![检查包含副作用的代码](img/Image00115.jpg)'
- en: From the preceding output file log, we can see that we have successfully created
    the `Librarianship` class as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出文件日志中，我们可以看到我们已成功创建了`Librarianship`类，就像预期的那样。
- en: Refactoring the AddRecord() method
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构`AddRecord()`方法
- en: 'Now it''s time to refactor the `Librarianship` class for it to become immutable.
    First, we will make the `AddRecord()` method a mathematical function. To do that,
    we have to make sure that it doesn''t access the disk directly, which we do when
    we use the `File.Exists()` , `File.ReadAllLines()` , `File.AppendAllLines()` ,
    and `File.WriteAllLines()` methods. We will refactor the `AddRecord()` method
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候重构 `Librarianship` 类，使其成为不可变的。首先，我们将把 `AddRecord()` 方法变成一个数学函数。为了做到这一点，我们必须确保它不直接访问磁盘，而我们在使用
    `File.Exists()` 、`File.ReadAllLines()` 、`File.AppendAllLines()` 和 `File.WriteAllLines()`
    方法时会这样做。我们将重构 `AddRecord()` 方法如下：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see in the preceding code, we modify the `AddRecord()` method signature
    so that it doesn''t pass any filenames now and passes a `FileContent` data type
    instead, which is structured with the following implementation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们修改了 `AddRecord()` 方法的签名，以便它现在不再传递任何文件名，而是传递了一个结构化的 `FileContent`
    数据类型，其实现如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the `FileContent` structure will now handle the filename and
    its content. And the `AddRecord()` method also returns the `FileAction` data type
    now. The implementation of the `FileAction` data type is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`FileContent` 结构现在将处理文件名及其内容。`AddRecord()` 方法现在也返回 `FileAction` 数据类型。`FileAction`
    数据类型的实现如下：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the `ActionType` enumeration is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionType` 枚举如下：'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also have a new data type, which is `DataEntry` . The implementation of
    the `DataEntry` structure is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个新的数据类型，即 `DataEntry`。`DataEntry` 结构的实现如下：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `DataEntry` structure will handle all the data that we want to write in
    the log file. And if we examine the `AddRecord()` method again, we don't find
    the procedure to make sure the log file exists since that will be done in a separate
    process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataEntry` 结构将处理我们想要写入日志文件的所有数据。如果我们再次检查 `AddRecord()` 方法，我们不会找到确保日志文件存在的过程，因为这将在一个单独的过程中完成。'
- en: 'We notice that the `AddRecord()` method invokes two new methods: the `Parse()`
    and `Serialize()` methods. The `Parse()` method is used to parse all the lines
    in the log file content and then form the list of `DataEntry` based on the content
    of the log file. The implementation of the method is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到 `AddRecord()` 方法调用了两个新方法：`Parse()` 和 `Serialize()` 方法。`Parse()` 方法用于解析日志文件内容中的所有行，然后根据日志文件的内容形成
    `DataEntry` 列表。该方法的实现如下：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the other hand, the `Serialize()` method is used to serialize the `DataEntry`
    list into the string array. The implementation of the method is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Serialize()` 方法用于将 `DataEntry` 列表序列化为字符串数组。该方法的实现如下：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Refactoring the RemoveRecord() method
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构 `RemoveRecord()` 方法
- en: 'Now, we go back to our `Librarianship` class and refactor the `RemoveRecord()`
    method. The implementation will be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到我们的 `Librarianship` 类，并重构 `RemoveRecord()` 方法。实现如下：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `RemoveRecord()` method now has a new signature. It passes an array of
    `FileContent` instead of the directory name only. It also returns a read-only
    list of `FileAction` . The `RemoveRecord()` method also needs an additional `RemoveRecordIn()`
    method, which is used to get the specified filename and file content to target
    the record that will be removed. The implementation of the `RemoveRecordIn()`
    method is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveRecord()` 方法现在有一个新的签名。它传递了一个 `FileContent` 数组，而不仅仅是目录名称。它还返回一个只读的 `FileAction`
    列表。`RemoveRecord()` 方法还需要一个额外的 `RemoveRecordIn()` 方法，用于获取指定的文件名和文件内容，以定位将被移除的记录。`RemoveRecordIn()`
    方法的实现如下：'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And now, we have the domain logic code, which is totally immutable and can run
    this domain logic in a unit testing environment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了完全不可变的领域逻辑代码，并且可以在单元测试环境中运行这个领域逻辑。
- en: Running domain logic in unit testing
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试中运行领域逻辑
- en: Domain logic is an immutable source that is a pure function, so we can run the
    unit testing over and over again without having to change the testing rules. Here,
    we are going to test the `AddRecord()` and `RemoveRecord()` methods in the `LibrarianshipImmutable`
    class. We will have five tests for these two methods. For the `AddRecord()` method,
    we will test if the file is overflow. For the `RemoveRecord()` method, we will
    test whether the selected record that we want to remove is available. Then, the
    file becomes empty if the selected record is empty or if the selected record is
    not available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 领域逻辑是一个不可变的源，是一个纯函数，因此我们可以一遍又一遍地运行单元测试，而不必改变测试规则。在这里，我们将在 `LibrarianshipImmutable`
    类中测试 `AddRecord()` 和 `RemoveRecord()` 方法。我们将为这两种方法进行五次测试。对于 `AddRecord()` 方法，我们将测试文件是否溢出。对于
    `RemoveRecord()` 方法，我们将测试我们想要移除的选定记录是否可用。然后，如果选定的记录为空或不可用，文件将变为空。
- en: Testing the AddRecord() method
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 `AddRecord()` 方法
- en: 'Now let''s take a look at the following `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()`
    test method, which will add a record to the existing log file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下以下的 `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()` 测试方法，它将向现有的日志文件添加一条记录：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()` test method, first,
    we create a `LibraryLog_0001.txt` file containing `1;Arthur Jackson;Responsive
    Web Design;9/26/2016` and then we add a new record, as shown in the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()` 测试方法中，首先，我们创建一个包含 `1;Arthur
    Jackson;Responsive Web Design;9/26/2016` 的 `LibraryLog_0001.txt` 文件，然后添加一个新记录，如下所示：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From now on, we have to ensure that `action.The type` has to be `ActionType.Update`
    , `action.FileName` has to be `LibraryLog_0001.txt` , and the `action.Content`
    has to be two lines, with the first line as `1;Arthur Jackson;Responsive Web Design;9/26/2016`
    and the second line as `2;Maddox Webb;AngularJS by Example;9/27/2016` .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们必须确保 `action.The type` 必须是 `ActionType.Update`，`action.FileName` 必须是
    `LibraryLog_0001.txt`，`action.Content` 必须是两行，第一行为 `1;Arthur Jackson;Responsive
    Web Design;9/26/2016`，第二行为 `2;Maddox Webb;AngularJS by Example;9/27/2016`。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `Assert.AreEqual()` method is used to verify that the specified values are
    equal. Unfortunately, the use of this method will not override the array data.
    To compare the array, we need to use the `CollectionAssert.AreEqual()` method,
    which will verify that two specified collections are equal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert.AreEqual()` 方法用于验证指定的值是否相等。不幸的是，使用这个方法不会覆盖数组数据。要比较数组，我们需要使用 `CollectionAssert.AreEqual()`
    方法，它将验证两个指定的集合是否相等。'
- en: 'Another unit testing is the `AddRecord_LinesHasReachMaxEntriesPerFileTest()`
    testing method. The implementation of this testing is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个单元测试是 `AddRecord_LinesHasReachMaxEntriesPerFileTest()` 测试方法。该测试的实现如下：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this testing method, we want to ensure that a new log file is created if
    the current log file lines have reached `maxEntriesPerFile` . First, we instantiate
    `LibrarianshipImmutable` and fill the `maxEntriesPerFile` field with `3` and then
    we fill the log file with the three visitors, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们希望确保如果当前日志文件行数达到 `maxEntriesPerFile`，则会创建一个新的日志文件。首先，我们实例化 `LibrarianshipImmutable`
    并将 `maxEntriesPerFile` 字段填充为 `3`，然后我们用以下代码填充日志文件的三个访客：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, we add a new record using the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用以下代码添加一个新记录：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have to ensure that `action.Type` is `ActionType.Update` , and it creates
    a new log file named `LibraryLog_0002.txt` . Also, the content of the new log
    file is `1;Haiden Brown;Practical Data Science;9/29/2016` .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须确保 `action.Type` 是 `ActionType.Update`，并创建一个名为 `LibraryLog_0002.txt`
    的新日志文件。此外，新日志文件的内容是 `1;Haiden Brown;Practical Data Science;9/29/2016`。
- en: Testing the RemoveRecord() method
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 `RemoveRecord()` 方法
- en: 'As we discussed earlier, we have three tests for the `RemoveRecord()` method.
    First, we are going to test removing a record from the files in the directory.
    The code will be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们对 `RemoveRecord()` 方法有三个测试。首先，我们将测试从目录中的文件中删除记录。代码如下：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this `RemoveRecord_FilesIsAvailableInDirectoryTest()` test method, we first
    create a `LibraryLog_0001.txt` file containing three records. We then remove the
    first record and make sure that `LibraryLog_0001.txt` will contain only two remaining
    logs with the proper order number.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RemoveRecord_FilesIsAvailableInDirectoryTest()` 测试方法中，我们首先创建一个包含三条记录的 `LibraryLog_0001.txt`
    文件。然后，我们移除第一条记录，并确保 `LibraryLog_0001.txt` 只包含两条剩余的记录，并且顺序正确。
- en: 'The other test is `RemoveRecord_FileBecomeEmptyTest()` with the following implementation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试是 `RemoveRecord_FileBecomeEmptyTest()`，具体实现如下：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `RemoveRecord_FileBecomeEmptyTest()` testing method will make sure that
    the log file is deleted if it is empty after the record is removed. First, we
    create a new log file with one record, and then we remove it using the `RemoveRecord()`
    method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveRecord_FileBecomeEmptyTest()` 测试方法将确保如果记录被移除后日志文件为空，则日志文件将被删除。首先，我们创建一个包含一条记录的新日志文件，然后使用
    `RemoveRecord()` 方法将其移除。'
- en: 'The last test for the `RemoveRecord()` method is `RemoveRecord_SelectedRecordIsUnavailableTest()`
    , which will remove nothing if the selected record is unavailable. The implementation
    of the testing method is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveRecord()` 方法的最后一个测试是 `RemoveRecord_SelectedRecordIsUnavailableTest()`，如果选定的记录不可用，则不会删除任何内容。测试方法的实现如下：'
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we create the log file containing Sofia Hamilton as the visitor
    name, but we try to remove the visitor named Arthur Jackson. In this case, the
    `RemoveRecord()` method will remove nothing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了包含 Sofia Hamilton 作为访客名称的日志文件，但我们尝试移除名为 Arthur Jackson 的访客。在这种情况下，`RemoveRecord()`
    方法将不会移除任何内容。
- en: Executing the test
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Now, it''s time to run the unit testing for all five testing methods. And here
    is what we will get after we run the test:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候运行所有五个测试方法的单元测试了。运行测试后，我们将得到以下结果：
- en: '![Executing the test](img/Image00116.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![执行测试](img/Image00116.jpg)'
- en: Adding the mutable shell into code
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可变外壳添加到代码中
- en: So far, we have successfully created the immutable core and covered unit tests.
    For now, we are ready to a implement the mutable shell for the rest of the code
    that is accessing the disk. We will create two classes, `FileProcessor` and `AppService`
    . The `FileProcessor` class will do all the disk interaction. The `AppService`
    class will be a bridge between the `LibrarianshipImmutable` class and the `FileProcessor`
    class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建了不可变核心并覆盖了单元测试。现在，我们准备为访问磁盘的其余代码实现可变外壳。我们将创建两个类，`FileProcessor`
    和 `AppService`。`FileProcessor` 类将处理所有磁盘交互。`AppService` 类将是 `LibrarianshipImmutable`
    类和 `FileProcessor` 类之间的桥梁。
- en: 'Now, let''s take a look at the following `FileProcessor` class implementation,
    which we can find in the `FileProcessor.cs` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看以下 `FileProcessor` 类的实现，我们可以在 `FileProcessor.cs` 文件中找到：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are four methods in the preceding `FileProcessor` class; they are `ReadFile()`
    , `ReadDirectory()` , and two `ApplyChanges()` methods with different signatures.
    The `ReadFile()` method is used to read the selected file and form it into the
    `FileContent` data type. The `ReadDirectory()` method is used to read all the
    files in the selected directory and form them into the `FileContent` data array.
    The `ApplyChanges()` method is used to make an execution to the selected file.
    If the action is `Create` or `Update` , then the `File.WriteAllLines()` method
    will be called. If the action is `Delete` , then the `File.Delete()` method will
    be invoked. Otherwise, the `InvalidOperationException` exception will be thrown.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `FileProcessor` 类中有四个方法；它们是 `ReadFile()`、`ReadDirectory()` 和两个具有不同签名的 `ApplyChanges()`
    方法。`ReadFile()` 方法用于读取所选文件并将其形成为 `FileContent` 数据类型。`ReadDirectory()` 方法用于读取所选目录中的所有文件并将它们形成为
    `FileContent` 数据数组。`ApplyChanges()` 方法用于对所选文件进行执行。如果操作是 `Create` 或 `Update`，则将调用
    `File.WriteAllLines()` 方法。如果操作是 `Delete`，则将调用 `File.Delete()` 方法。否则，将抛出 `InvalidOperationException`
    异常。
- en: 'After we finish with the `FileProcessor` class, it''s time to create the `AppService`
    class. The implementation of the class is as follows, and we can find it in the
    `AppService.cs` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 `FileProcessor` 类后，现在是时候创建 `AppService` 类了。该类的实现如下，并且我们可以在 `AppService.cs`
    文件中找到它：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we discussed previously, the AppService class is used as the bridge between
    the `LibrarianshipImmutable` class and the `FileProcessor` class. We have the
    two methods in this AppService class that have completely the same signature with
    methods in the `LibrarianshipImmutable` class; they are the `AddRecord()` and
    `RemoveRecord()` methods. And as a bridge, we can see that in the class constructor,
    the `LibrarianshipImmutable` and `FileProcessor` class constructors are invoked
    to create a new instance. By calling the `AddRecord(` ) method in the `AppService`
    class, we actually invoke the `AddRecord()` method in the `LibrarianshipImmutable`
    class and then we call the `ApplyChange()` method in the `FileProcessor` class.
    Likewise, the invocation of the `RemoveRecord()` method in the `AppService` class
    will invoke the `RemoveRecord()` method in the `LibrarianshipImmutable` class
    and then the `ApplyChange()` method in the `FileProcessor` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，AppService类被用作`LibrarianshipImmutable`类和`FileProcessor`类之间的桥梁。在这个AppService类中有两个方法，它们的签名与`LibrarianshipImmutable`类中的方法完全相同；它们是`AddRecord()`和`RemoveRecord()`方法。作为桥梁，我们可以看到在类构造函数中，调用了`LibrarianshipImmutable`和`FileProcessor`类的构造函数来创建一个新实例。通过在`AppService`类中调用`AddRecord()`方法，我们实际上调用了`LibrarianshipImmutable`类中的`AddRecord()`方法，然后调用了`FileProcessor`类中的`ApplyChange()`方法。同样，调用`AppService`类中的`RemoveRecord()`方法将调用`LibrarianshipImmutable`类中的`RemoveRecord()`方法，然后调用`FileProcessor`类中的`ApplyChange()`方法。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The honest signature is important not only in functional approach but also every
    time we code, since, basically, the signature has to deliver all the information
    about the possible accepted input values and possible produced output. By implementing
    honest signature, we will be aware of the value we pass into the method parameter.
    We have to ensure that we have an immutable class as well in order to get functional
    because mutable operations will make our code dishonest.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实的签名不仅在功能方法中很重要，而且每次编码时都很重要，因为基本上，签名必须提供关于可能接受的输入值和可能产生的输出的所有信息。通过实现诚实的签名，我们将意识到我们传递给方法参数的值。我们必须确保我们也有一个不可变的类，以便实现功能，因为可变操作会使我们的代码不诚实。
- en: Although we have to avoid side-effects in our pure function, it's nearly impossible
    to really avoid side-effects in our code. What we can do then is deal with it.
    We can use the **command-query separation** ( **CQS** ) principle to separate
    methods that generate side-effects and methods that don't. If the method returns
    a value, it will be a query and doesn't mutate anything. If the method returns
    nothing, it must be a command and will leave some side-effects in the system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们必须避免在纯函数中产生副作用，但在我们的代码中真正避免副作用几乎是不可能的。那么我们能做的就是处理它。我们可以使用**命令查询分离**（**CQS**）原则来分离生成副作用和不生成副作用的方法。如果方法返回一个值，它将是一个查询，不会改变任何东西。如果方法不返回任何内容，它必须是一个命令，并将在系统中留下一些副作用。
- en: We can also separate our code into domain logic and the mutable shell in order
    to deal with the side-effects. The domain logic will be our core program, and
    it must be immutable. All mutable processing will be stored in the mutable shell.
    By creating the domain logic, we can easily run unit testing on it. We don't need
    to modify the test scenario or run the mock test for domain logic since it is
    a pure function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们的代码分为领域逻辑和可变外壳，以处理副作用。领域逻辑将是我们的核心程序，必须是不可变的。所有可变处理将存储在可变外壳中。通过创建领域逻辑，我们可以很容易地对其进行单元测试。我们不需要修改测试方案或运行领域逻辑的模拟测试，因为它是一个纯函数。
