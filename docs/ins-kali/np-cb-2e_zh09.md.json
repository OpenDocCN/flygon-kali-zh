["```py\n        $ python setup.py install\n\n        ```", "```py\n    $ easy_install cython\n    $ sudo pip install cython\n\n    ```", "```py\n    def say_hello():\n      print \"Hello World!\"\n    ```", "```py\n    from distutils.core import setup\n    from distutils.extension import Extension\n    from Cython.Distutils import build_ext\n\n    ext_modules = [Extension(\"hello\", [\"hello.pyx\"])]\n\n    setup(\n            name = 'Hello world app',\n            cmdclass = {'build_ext': build_ext},\n            ext_modules = ext_modules\n         )\n    ```", "```py\n    $ python setup.py build_ext --inplace\n\n    ```", "```py\n    running build_ext\n    cythoning hello.pyx to hello.c\n    building 'hello' extension\n    creating build\n\n    ```", "```py\n    from hello import say_hello\n    ```", "```py\n    import numpy as np\n\n    def pos_confidence(numbers):\n       diffs = np.diff(numbers)\n       n = float(len(diffs))\n       p = len(diffs[diffs > 0])/n\n       confidence = np.sqrt(p * (1 - p)/ n)\n\n       return (p, confidence)\n    ```", "```py\n    from distutils.core import setup\n    from distutils.extension import Extension\n    from Cython.Distutils import build_ext\n\n    ext_modules = [Extension(\"binomial_proportion\", [\"binomial_proportion.pyx\"])]\n\n    setup(\n            name = 'Binomial proportion app',\n            cmdclass = {'build_ext': build_ext},\n            ext_modules = ext_modules\n         )\n    ```", "```py\n    from matplotlib.finance import quotes_historical_yahoo\n    from datetime import date\n    import numpy\n    import sys\n    from binomial_proportion import pos_confidence\n\n    #1\\. Get close prices.\n    today = date.today()\n    start = (today.year - 1, today.month, today.day)\n\n    quotes = quotes_historical_yahoo(sys.argv[1], start, today)\n    close =  numpy.array([q[4] for q in quotes])\n    print pos_confidence(close)\n    ```", "```py\n    (0.56746031746031744, 0.031209043355655924)\n\n    ```", "```py\n    from libc.math cimport log\n    import numpy as np\n\n    def logrets(numbers):\n       logs = [log(x) for x in numbers] \n       return np.diff(logs)\n    ```", "```py\n    from matplotlib.finance import quotes_historical_yahoo\n    from datetime import date\n    import numpy as np\n    from log_returns import logrets\n    import matplotlib.pyplot as plt\n\n    today = date.today()\n    start = (today.year - 1, today.month, today.day)\n\n    quotes = quotes_historical_yahoo('AAPL', start, today)\n    close =  np.array([q[4] for q in quotes])\n    plt.plot(logrets(close))\n    plt.title('Logreturns of AAPL for the previous year')\n    plt.xlabel('Days')\n    plt.ylabel('Log returns')\n    plt.grid()\n    plt.show()\n    ```", "```py\n        from __future__ import print_function\n        import numpy as np\n        import cProfile\n        import pstats\n\n        def approx_e(n=40, display=False):\n           # array of [1, 2, ... n-1]\n           arr = np.arange(1, n)\n\n           # calculate the factorials and convert to floats\n           arr = arr.cumprod().astype(float)\n\n           # reciprocal 1/n\n           arr = np.reciprocal(arr)\n\n           if display:\n            print(1 + arr.sum())\n\n        # Repeat multiple times because NumPy is so fast\n        def run(repeat=2000):\n            for i in range(repeat):\n                approx_e()\n\n        cProfile.runctx(\"run()\", globals(), locals(), \"Profile.prof\")\n\n        s = pstats.Stats(\"Profile.prof\")\n        s.strip_dirs().sort_stats(\"time\").print_stats()\n\n        approx_e(display=True)\n        ```", "```py\n     8004 function calls in 0.016 seconds\n\n     Ordered by: internal time\n\n     ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     2000    0.007    0.000    0.015    0.000 numpy_approxe.py:6(approx_e)\n     2000    0.004    0.000    0.004    0.000 {method 'cumprod' of 'numpy.ndarray' objects}\n     2000    0.002    0.000    0.002    0.000 {numpy.core.multiarray.arange}\n     2000    0.002    0.000    0.002    0.000 {method 'astype' of 'numpy.ndarray' objects}\n     1    0.001    0.001    0.016    0.016 numpy_approxe.py:20(run)\n     1    0.000    0.000    0.000    0.000 {range}\n     1    0.000    0.000    0.016    0.016 <string>:1(<module>)\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\n    2.71828182846\n\n    ```", "```py\n    def approx_e(int n=40, display=False):\n        cdef double sum = 0.\n        cdef double factorial = 1.\n        cdef int k\n\n        for k in xrange(1,n+1):\n            factorial *= k\n            sum += 1/factorial\n\n        if display:\n            print(1 + sum)\n    ```", "```py\n    import pstats\n    import cProfile\n    import pyximport\n    pyximport.install()\n\n    import approxe\n\n    # Repeat multiple times because Cython is so fast\n    def run(repeat=2000):\n        for i in range(repeat):\n            approxe.approx_e()\n\n    cProfile.runctx(\"run()\", globals(), locals(), \"Profile.prof\")\n\n    s = pstats.Stats(\"Profile.prof\")\n    s.strip_dirs().sort_stats(\"time\").print_stats()\n\n    approxe.approx_e(display=True)\n    ```", "```py\n     2004 function calls in 0.001 seconds\n\n     Ordered by: internal time\n\n     ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     2000    0.001    0.000    0.001    0.000 {approxe.approx_e}\n     1    0.000    0.000    0.001    0.001 cython_profile.py:9(run)\n     1    0.000    0.000    0.000    0.000 {range}\n     1    0.000    0.000    0.001    0.001 <string>:1(<module>)\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\n    2.71828182846\n\n    ```", "```py\n    import numpy\n    cimport numpy\n\n    def ramanujan_factorial(numpy.ndarray n):\n       sqrt_pi = numpy.sqrt(numpy.pi, dtype=numpy.float64)\n       cdef numpy.ndarray root = (8 * n + 4) * n + 1 \n       root = root * n + 1/30.\n       root = root ** (1/6.)\n       return sqrt_pi * calc_eton(n) * root\n\n    def stirling_factorial(numpy.ndarray n):\n        return numpy.sqrt(2 * numpy.pi * n) * calc_eton(n)\n\n    def calc_eton(numpy.ndarray n):\n        return (n/numpy.e) ** n\n    ```", "```py\n    from distutils.core import setup\n    from distutils.extension import Extension\n    from Cython.Distutils import build_ext\n    import numpy\n\n    ext_modules = [Extension(\"factorial\", [\"factorial.pyx\"], include_dirs = [numpy.get_include()])] \n\n    setup(\n            name = 'Factorial app',\n            cmdclass = {'build_ext': build_ext},\n            ext_modules = ext_modules\n         )\n    ```", "```py\n    from factorial import ramanujan_factorial\n    from factorial import stirling_factorial\n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    N = 50\n    numbers = np.arange(1, N)\n    factorials = np.cumprod(numbers, dtype=float)\n\n    def error(approximations):\n       return (factorials - approximations)/factorials\n\n    plt.plot(error(ramanujan_factorial(numbers)), 'b-', label='Ramanujan')\n    plt.plot(error(stirling_factorial(numbers)), 'ro', label='Stirling')\n    plt.title('Factorial approximation relative errors')\n    plt.xlabel('n')\n    plt.ylabel('Relative error')\n    plt.grid()\n    plt.legend(loc='best')\n    plt.show()\n    ```"]