- en: Chapter 2. Walkthrough Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。委托演练
- en: 'In the previous chapter, we applied delegates in the code we created. When
    we discussed the concept of functional programming, we applied one of the built-in
    delegates that C# has. In this chapter, we are going to delve into the delegates
    that will be used a lot in functional C# programming by discussing the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在创建的代码中应用了委托。当我们讨论函数式编程的概念时，我们应用了C#中具有的内置委托之一。在本章中，我们将通过讨论以下主题深入探讨在函数式C#编程中经常使用的委托：
- en: The definition, syntax, and use of delegates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托的定义、语法和用法
- en: Combining delegates into multicast delegates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将委托组合成多播委托
- en: Using built-in delegates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置委托
- en: Understanding the variance in delegates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解委托中的差异
- en: Introducing delegates
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍委托
- en: A delegate is a data type in C# that encapsulates a method that has particular
    parameters and return types (signatures). In other words, a delegate will define
    the parameters and the return type of a method. Delegates are similar to function
    pointers in C/C++ since both stores the reference to the method with a particular
    signature. Like a function pointer in C/C++, a delegate keeps a memory address
    of the method it refers to. The compiler will complain if it refers to a function
    with a different signature. However, because of the unmanaged nature of the C++
    language, one can point functions to arbitrary locations (by casting).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是C#中的一种数据类型，它封装了具有特定参数和返回类型（签名）的方法。换句话说，委托将定义方法的参数和返回类型。委托类似于C/C++中的函数指针，因为两者都存储对具有特定签名的方法的引用。与C/C++中的函数指针一样，委托保留了它所引用的方法的内存地址。如果它引用具有不同签名的函数，编译器将发出警告。然而，由于C++语言的非托管性质，可以将函数指针指向任意位置（通过转换）。
- en: 'Let''s take a look at the following delegate syntax:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下委托语法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the explanation for each element of the preceding delegate syntax:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述委托语法中每个元素的解释：
- en: '**AccessModifier** : This is the modifier that is used to set the accessibility
    of the delegate. It can be public, private, internal, or protected. However, we
    can omit it, and if we do that, the default modifier will be internal.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符：这是用于设置委托可访问性的修饰符。它可以是public、private、internal或protected。但是，我们可以省略它，如果这样做，那么默认的修饰符将是internal。
- en: '**delegate** : This is the keyword we need in order to initialize a delegate.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托：这是我们需要的关键字，以初始化委托。
- en: '**ReturnType** : This is a returning data type of the method we assign to this
    delegate.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型：这是我们分配给此委托的方法的返回数据类型。
- en: '**DelegateName** : This is the identity of the delegate.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托名称：这是委托的标识。
- en: '**parameters** : This is the list of parameters that the method we assign to
    this delegate takes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：这是我们分配给此委托的方法所需的参数列表。
- en: 'By referring to the preceding syntax, we can initialize the delegate, for instance,
    `SingleStringDelegate` :'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用上述语法，我们可以初始化委托，例如`SingleStringDelegate`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we have the preceding delegate, we can assign a method possessing the
    same signature to the delegate. The method can be as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有了上述委托，我们可以将具有相同签名的方法分配给委托。方法可以如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, the method can be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，方法可以如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since both methods have an identical signature, we can assign them to `SingleStringDelegate`
    using the following syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个方法具有相同的签名，我们可以使用以下语法将它们分配给`SingleStringDelegate`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding syntax is used to assign the `AssignData()` method to a variable
    typed `SingleStringDelegate` , and for the `WriteToConsole()` method, we can use
    the following syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法用于将`AssignData()`方法分配给类型为`SingleStringDelegate`的变量，并且对于`WriteToConsole()`方法，我们可以使用以下语法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is common to name a delegate type ending with the word `Delegate` —for example,
    `SingleStringDelegate` —in order to be able to distinguish the delegate name and
    the method name. However, it is not mandatory and we can omit this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，委托类型的名称以单词`Delegate`结尾，例如`SingleStringDelegate`，以便能够区分委托名称和方法名称。但这不是强制性的，我们可以省略这一点。
- en: Simple delegates
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单委托
- en: 'For further discussion on delegates, let''s take a look at the following method,
    which we can find at `SimpleDelegates.csproj` :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步讨论委托，让我们看一下以下方法，我们可以在`SimpleDelegates.csproj`中找到：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Rectangle()` method in the preceding code can be assigned to the delegate
    variable given in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以将`Rectangle()`方法分配给以下代码中给定的委托变量：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following method can also be assigned to the `AreaCalculatorDelegate` delegate
    because the signature of the method is what the delegate type expects:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方法的签名是委托类型所期望的，因此也可以将以下方法分配给`AreaCalculatorDelegate`委托：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To assign a method to a delegate, we just need to create a variable of the
    delegate data type which has signature compatibility with the method to be assigned.
    The following is the `Main()` method, which will create the delegate variable
    and invoke the method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法分配给委托，我们只需要创建一个具有与要分配的方法兼容签名的委托数据类型的变量。以下是`Main()`方法，它将创建委托变量并调用方法：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From the preceding code, we create two variables named `rect` and `sqr` whose
    type is `AreaCalculatorDelegate` . Here is the code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们创建了两个名为`rect`和`sqr`的变量，它们的类型是`AreaCalculatorDelegate`。以下是代码片段：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we have assigned the `rect` and `sqr` variables to the `Rectangle()`
    and `Square()` methods, we can invoke these methods using the delegate variable.
    Let''s take a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将`rect`和`sqr`变量分配给`Rectangle()`和`Square()`方法，我们可以使用委托变量调用这些方法。让我们看一下以下代码片段：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We assign variable `i` and `j` with the result of `rect()` and `sqr()` . Although
    both of them are variable names, they refer to the method address location. One
    invokes a method referred by these variables to execute the logic contained. We
    are effectively executing the two `Console.WriteLine()` methods to produce the
    following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量`i`和`j`分配为`rect()`和`sqr()`的结果。虽然它们都是变量名，但它们指的是方法的地址位置。通过调用这些变量引用的方法来执行其中包含的逻辑。我们有效地执行了两个`Console.WriteLine()`方法来产生以下输出：
- en: '![Simple delegates](img/Image00010.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![简单委托](img/Image00010.jpg)'
- en: It is now clear to the reader that why we display the output shown in the preceding
    screenshot. The `rect` and `sqr` variables now store the reference to `Rectangle()`
    and `Square()` methods respectively. We are effectively calling the `Rectangle()`
    method while invoking the `rect` delegate and `Square()` method, all the while
    invoking the `sqr` delegate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读者清楚为什么我们显示了前面截图中的输出。`rect`和`sqr`变量现在分别存储对`Rectangle()`和`Square()`方法的引用。我们在调用`rect`委托时有效地调用`Rectangle()`方法，同时调用`sqr`委托时调用`Square()`方法。
- en: Multicast delegates
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播委托
- en: We have just discussed a simple delegate where we assign a particular method
    to a delegate variable. We can call it a unicast delegate. However, the delegates
    can actually invoke multiple methods using one variable. For this purpose, we
    can call it a multicast delegate. In the case of multicast delegate, it is like
    a list of delegates stored inside an internal list. When we invoke a multicast
    delegate, the delegates in the list are synchronously called in the correct order.
    There are several ways to create a multicast delegate. The two we will discuss
    in detail are the `Delegate.Combine()` and `Delegate.Remove()` methods and the
    `+=` and `-=` (increment and decrement) operators.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了一个简单的委托，我们将特定方法分配给委托变量。我们可以称之为单播委托。然而，委托实际上可以使用一个变量调用多个方法。为此，我们可以称之为多播委托。在多播委托的情况下，它就像一个存储在内部列表中的委托列表。当我们调用多播委托时，列表中的委托按正确的顺序同步调用。创建多播委托有几种方法。我们将详细讨论两种方法：`Delegate.Combine()`和`Delegate.Remove()`方法以及`+=`和`-=`（增加和减少）运算符。
- en: Using the Delegate.Combine() and Delegate.Remove() methods
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`Delegate.Combine()`和`Delegate.Remove()`方法
- en: 'Let''s first examine the following code, creating a multicast delegate using
    the `Delegate.Combine()` method. Suppose we have a delegate named `CalculatorDelegate`
    , as follows, which we can find at `CombineDelegates.csproj` :'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查以下代码，使用`Delegate.Combine()`方法创建一个多播委托。假设我们有一个名为`CalculatorDelegate`的委托，如下所示，我们可以在`CombineDelegates.csproj`中找到：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we have the following four methods that have the same signature as the
    `CalculatorDelegate` signature:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有以下四种方法，它们与`CalculatorDelegate`签名相同：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are four methods, and they are `Add()` , `Subtract()` , `Multiply()`
    , and `Division()` . We are going to cast these methods in a single variable-typed
    delegate. Now, take a look at the following `CombineDelegate()` method to achieve
    this goal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法，它们是`Add()`，`Subtract()`，`Multiply()`和`Division()`。我们将把这些方法转换为一个单一变量类型的委托。现在，看一下以下的`CombineDelegate()`方法来实现这个目标：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we run this method, the following output will be displayed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个方法，将显示以下输出：
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00011.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用Delegate.Combine()和Delegate.Remove()方法](img/Image00011.jpg)'
- en: 'We have successfully invoked four methods by calling a single delegate. The
    delegate we called in the preceding code is in the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用单个委托，我们已成功调用了四种方法。我们在前面的代码中调用的委托在以下代码片段中：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Actually `calcMultiples` delegate has stored four delegates variables internally,
    corresponding to each of the method which we combined. Thanks to the `Delegate.Combine()`
    method, we can combine the delegates using the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`calcMultiples`委托在内部存储了四个委托变量，对应于我们组合的每个方法。由于`Delegate.Combine()`方法，我们可以使用以下语法组合委托：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also create the array of delegates by calling `GetInvocationList()` from
    the delegate variable. By retrieving the delegate array, we can iterate over the
    array like we do for ordinary arrays. We can retrieve the `Length` property to
    count how many delegates are there in the invocation list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从委托变量调用`GetInvocationList()`来创建委托数组。通过检索委托数组，我们可以像对待普通数组一样迭代数组。我们可以检索`Length`属性来计算调用列表中有多少个委托。
- en: 'In multicast delegates, we are able to combine as well remove delegates from
    the invocation list. Let''s take a look at the following `RemoveDelegate()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在多播委托中，我们能够组合以及从调用列表中删除委托。让我们看一下以下的`RemoveDelegate()`方法：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run the preceding method, the following output will be displayed in the
    console:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的方法，将在控制台中显示以下输出：
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00012.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用Delegate.Combine()和Delegate.Remove()方法](img/Image00012.jpg)'
- en: 'Similar to the `CombineDelegate()` method, we combine the four methods into
    a single variable-typed delegate in the `RemoveDelegate()` method. The `calcDelegates3`
    delegate is the delegate that keeps the four methods. Indeed, when we invoke `calcDelegates3`
    , it calls the four methods in a proper order. Next, in the `RemoveDelegate()`
    method, we invoke the `Delegate.Remove()` method in order to remove the selected
    delegate in the invocation list. Based on the preceding code, the syntax is as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CombineDelegate()`方法类似，我们在`RemoveDelegate()`方法中将四种方法组合成一个单一变量类型的委托。`calcDelegates3`委托是保存这四种方法的委托。实际上，当我们调用`calcDelegates3`时，它按正确的顺序调用这四种方法。接下来，在`RemoveDelegate()`方法中，我们调用`Delegate.Remove()`方法来从调用列表中删除选定的委托。根据前面的代码，语法如下：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code snippet is used to remove the `mulDel` delegate variable
    from the invocation list. As we can see in the preceding figure displaying the
    output of the `RemoveDelegate()` invocation, the `Multiply()` method is no longer
    invoked right after it's removed from invocation list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段用于从调用列表中移除`mulDel`委托变量。正如我们在前面的图中看到的，`RemoveDelegate()`调用的输出显示，一旦`Multiply()`方法从调用列表中移除，它就不再被调用。
- en: 'An invocation list associated with a delegate can contain duplicate entries.
    This means that we can add the same method to the invocation list more than once.
    Now let''s try to insert the duplicate entries into the invocation list by adding
    the `DuplicateEntries()` method to the project, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与委托相关联的调用列表可以包含重复的条目。这意味着我们可以多次将相同的方法添加到调用列表中。现在让我们尝试通过将`DuplicateEntries()`方法添加到项目中来将重复的条目插入调用列表中，如下所示：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s run the `DuplicateEntries()` method, and the console will show the
    following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行`DuplicateEntries()`方法，控制台将显示以下输出：
- en: '![Using the Delegate.Combine() and Delegate.Remove() methods](img/Image00013.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Delegate.Combine()和Delegate.Remove()方法](img/Image00013.jpg)'
- en: 'By examining the preceding code, we can see that the `duplicateDelegates2`
    variable contains three invocation methods, which are `addDel` , `subDel` , and
    `mulDel` . Look at the following code snippet for more details:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查前面的代码，我们可以看到`duplicateDelegates2`变量包含三个调用方法，分别是`addDel`，`subDel`和`mulDel`。请查看以下代码片段以获取更多详细信息：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, we add `subDel` and `addDel` to the invocation list like we do in the
    following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们像在下面的代码片段中那样，将`subDel`和`addDel`添加到调用列表中：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, the invocation list of `duplicateDelegates4` contains two duplicate methods.
    However, when we invoke the `DuplicateEntries()` method, `addDel` and `subDel`
    are invoked twice and the invocation order is just like the order in which we
    add the delegate to the invocation list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`duplicateDelegates4`的调用列表包含两个重复的方法。然而，当我们调用`DuplicateEntries()`方法时，`addDel`和`subDel`被调用两次，调用顺序就像我们将委托添加到调用列表中的顺序一样。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Delegate.Combine()` and `Delegate.Remove()` static methods will return
    the `Delegate` data type instead of the instance of `Delegate` itself. As a result,
    casting the return of both methods to the expected instance delegate is required
    when using them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delegate.Combine()`和`Delegate.Remove()`静态方法将返回`Delegate`数据类型，而不是`Delegate`本身的实例。因此，在使用它们时需要将这两种方法的返回强制转换为预期的实例委托。'
- en: Using += and -= operators
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用+=和-=运算符
- en: 'It''s quite easy to create multicast delegates using `+=` and `-=` operators
    since that will be like treating any data types in C#. We can also use the `+`
    and `-` operators to add and remove delegates in an invocation list. Here is the
    sample code we can find at `AddSubtractDelegates.csproj` in order to combine delegates
    and remove select delegates from the invocation list using the operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+=`和`-=`运算符创建多播委托非常容易，因为这样做就像处理C#中的任何数据类型一样。我们还可以使用`+`和`-`运算符向调用列表中添加和移除委托。以下是我们可以在`AddSubtractDelegates.csproj`中找到的示例代码，以便使用运算符合并委托并从调用列表中移除选择的委托：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also have the four methods that we use in the preceding project, `CombineDelegates.csproj`
    : `Add()` , `Subtract()` , `Multiply()` , and `Division()` . We will get the following
    output if we run the `AddSubtractDelegate()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有在前面的项目`CombineDelegates.csproj`中使用的四个方法：`Add()`，`Subtract()`，`Multiply()`和`Division()`。如果我们运行`AddSubtractDelegate()`方法，将得到以下输出：
- en: '![Using += and -= operators](img/Image00014.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用+=和-=运算符](img/Image00014.jpg)'
- en: 'In the starting lines of the `AddSubtractDelegate()` method, we create four
    variables typed `CalculatorDelegate` for each of the four methods we have, just
    like we did in the previous project. We then create one more variable named `multiDel`
    in order to generate the multicast delegate. Here, we can see that we add the
    delegate to the multicast delegate variable using the operator only, in which
    we use the `+` and `+=` operators. Let''s take a look at the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddSubtractDelegate()`方法的起始行中，我们为我们拥有的四个方法创建了四个类型为`CalculatorDelegate`的变量，就像我们在之前的项目中所做的一样。然后，我们创建了一个名为`multiDel`的变量，以生成多播委托。在这里，我们可以看到我们只使用运算符将委托添加到多播委托变量中，其中我们使用了`+`和`+=`运算符。让我们看一下以下代码片段：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the preceding code snippet, after combining all four delegates into the
    `multiDel` delegate, we call the `multiDel` delegate, and what we get based on
    the output console display is the program to invoke the four methods in a proper
    order. The four methods are `Add()` , `Subtract()` , `Multiply()` , and `Division()`
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，将所有四个委托合并到`multiDel`委托中后，我们调用`multiDel`委托，根据输出控制台显示的内容，程序会按适当的顺序调用这四个方法。这四个方法分别是`Add()`，`Subtract()`，`Multiply()`和`Division()`。
- en: 'To remove the delegate from the invocation list, we use the `-` and `-=` operators
    in the preceding code. Let''s take a look at the following code snippet to examine
    what we have to do in order to remove the delegate:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要从调用列表中移除委托，我们在前面的代码中使用`-`和`-=`运算符。让我们看一下以下代码片段，以查看我们需要做什么才能移除委托：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we have removed the `subDel` and `mulDel` delegates from the invocation
    list, the program only calls two methods, the `Add()` and `Division()` methods,
    when we invoke the `mulDel` delegate. This proves that we have successfully removed
    the delegate from the invocation list using the `-` and `-=` operators.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经从调用列表中移除了`subDel`和`mulDel`委托，所以当我们调用`mulDel`委托时，程序只调用两个方法，即`Add()`和`Division()`方法。这证明我们已成功使用`-`和`-=`运算符从调用列表中移除了委托。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using `+=` and `-=` to assign a multicast delegate doesn't fit the functional
    programming approach since it breaks the immutability concept. However, we can
    still use the `+` and `-` operators to add a delegate to the invocation list and
    remove the delegate from the invocation list consecutively in a functional approach.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+=`和`-=`运算符来分配多播委托不符合函数式编程的方法，因为这会破坏不可变性概念。然而，我们仍然可以使用`+`和`-`运算符以函数式方法连续地向调用列表中添加委托和从调用列表中移除委托。
- en: Built-in delegates
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置委托
- en: In C#, not only are we able to declare a delegate, but we are also able to use
    the built-in delegate from the C# standard library. This built-in delegate also
    applies to the generic data type, so let's discuss the generic delegate prior
    to discussing the built-in delegate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们不仅能够声明一个委托，还能够使用C#标准库中的内置委托。这个内置委托也适用于泛型数据类型，因此在讨论内置委托之前，让我们先讨论泛型委托。
- en: Generic delegates
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型委托
- en: 'A delegate type can use a generic type as its parameter. Using the generic
    type, we can put off the specification of one or more types in parameters or return
    values until the delegate is initialized into a variable. In other words, we do
    not specify the data types of the delegate''s parameters and return values when
    we define a delegate type. To discuss this in more detail, let''s take a look
    at the following code, which we can find at `GenericDelegates.csproj` :'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类型可以使用泛型类型作为其参数。使用泛型类型，我们可以推迟一个或多个参数或返回值的类型规定，直到委托被初始化为变量。换句话说，当我们定义委托类型时，我们不指定委托参数和返回值的数据类型。为了更详细地讨论这一点，让我们看一下下面的代码，我们可以在`GenericDelegates.csproj`中找到：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have a delegate name, `FormulaDelegate` , using the generic data type. As
    we can see, there is a `T` symbol, which represents the data type we will define
    when declaring the variable typed `FormulaDelegate` . We continue by adding the
    following two methods that have completely different signatures:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`FormulaDelegate`的委托，使用了泛型数据类型。正如我们所看到的，有一个`T`符号，代表了在声明变量类型为`FormulaDelegate`时我们将定义的数据类型。我们继续添加以下两个完全不同签名的方法：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s take a look at the following code in order to explain how we declare
    the variable-typed delegate and invoke the method from the delegate:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下以下代码，以解释我们如何声明变量类型的委托并从委托中调用方法：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following result will be displayed in the console when we run the `GenericDelegateInvoke()`
    method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`GenericDelegateInvoke()`方法时，控制台将显示以下结果：
- en: '![Generic delegates](img/Image00015.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Generic delegates](img/Image00015.jpg)'
- en: 'From the preceding code, we can declare two methods that have different signature
    using only one delegate type. The `intAddition` delegate refers to the `AddInt()`
    method, which applies the `int` data type in its parameters and return value,
    while the `doubleAddition` delegate refers to the `AddDouble()` method, which
    applies the `double` data type in its parameters and return value. However, in
    order for the delegate to know the data type of the method it refers, we have
    to define the data type in angular brackets (`<>` ) when we initialize the delegate.
    The following code snippet is the delegate initialization that uses the generic
    data type (symbolized by the angular brackets):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以声明两个具有不同签名的方法，只使用一个委托类型。`intAddition`委托引用了`AddInt()`方法，该方法在其参数和返回值中应用了`int`数据类型，而`doubleAddition`委托引用了`AddDouble()`方法，该方法在其参数和返回值中应用了`double`数据类型。然而，为了使委托知道它所引用的方法的数据类型，我们必须在初始化委托时在尖括号(`<>`)中定义数据类型。以下代码片段是使用泛型数据类型进行委托初始化的委托初始化：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because we have defined the data type, the delegate can match the data type
    of the method it refers. That's why, from the output console, we can invoke the
    two methods that have different signatures.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经定义了数据类型，所以委托可以匹配它所引用的方法的数据类型。这就是为什么从输出控制台中，我们可以调用具有不同签名的两个方法。
- en: 'We have successfully used a generic type for delegates, applying one generic
    template. The following code, which we can find at `MultiTemplateDelegates.csproj`
    , shows us that the delegate can also apply the multigeneric template in one delegate
    declaration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功使用了一个泛型类型的委托，应用了一个泛型模板。下面的代码，我们可以在`MultiTemplateDelegates.csproj`中找到，向我们展示了委托还可以在一个委托声明中应用多个泛型模板：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code will create a new delegate named `AdditionDelegate` , which
    has two parameters with two different data types. `T1` and `T2` represent the
    data type that will be defined in the variable-typed delegate declaration. Now,
    let''s create two methods that have different signatures, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个名为`AdditionDelegate`的新委托，它有两个具有两种不同数据类型的参数。`T1`和`T2`代表将在变量类型的委托声明中定义的数据类型。现在，让我们创建两个具有不同签名的方法，如下所示：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To refer the `AdditionDelegate` delegate to the `AddIntDouble()` and `AddFloatDouble()`
    methods and invoke the delegate, we can create the `VoidDelegateInvoke()` method,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`AdditionDelegate`委托引用到`AddIntDouble()`和`AddFloatDouble()`方法并调用委托，我们可以创建`VoidDelegateInvoke()`方法，如下所示：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we run the `VoidDelegateInvoke()` method, we will see the following output
    on our console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`VoidDelegateInvoke()`方法，我们将在控制台上看到以下输出：
- en: '![Generic delegates](img/Image00016.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Generic delegates](img/Image00016.jpg)'
- en: From the preceding console output, it can be seen that we have successfully
    invoked the `intDoubleAdd` and `floatDoubleAdd` delegates although they have different
    method signatures. This is possible since we apply the `T1` and `T2` template
    in the `AdditionDelegate` delegate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的控制台输出可以看到，尽管它们具有不同的方法签名，但我们已成功调用了`intDoubleAdd`和`floatDoubleAdd`委托。这是可能的，因为我们在`AdditionDelegate`委托中应用了`T1`和`T2`模板。
- en: 'Let''s try to create the multitemplate delegate again, but this time, we use
    the method that has a return value. The declaration of the delegate will be as
    follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试创建多模板委托，但这次我们使用具有返回值的方法。委托的声明将如下所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we add the two methods `AddIntDoubleConvert()` and `AddFloatDoubleConvert()`
    to our project:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向我们的项目添加了两个方法`AddIntDoubleConvert()`和`AddFloatDoubleConvert()`：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to use the `AddAndConvert` delegate, we can create the `ReturnValueDelegateInvoke()`
    method, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`AddAndConvert`委托，我们可以创建`ReturnValueDelegateInvoke()`方法，如下所示：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we invoke the `ReturnValueDelegateInvoke()` method, we get the following
    output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`ReturnValueDelegateInvoke()`方法时，我们得到以下输出：
- en: '![Generic delegates](img/Image00017.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Generic delegates](img/Image00017.jpg)'
- en: Again, we successfully invoke the two different signature methods using a multitemplate
    generic type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们成功地使用多模板泛型类型调用了两种不同签名的方法。
- en: The Action and Func delegates
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Action和Func委托
- en: 'Let''s go back to the following delegate declaration we discussed earlier in
    the chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前面在本章中讨论的以下委托声明：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'C# has a built-in delegate that can take a maximum of 16 parameters and return
    void. It is called the `Action` delegate. In other words, the `Action` delegate
    will point to a method that return nothing and takes zero, one, or more input
    parameters. Due to the existence of the `Action` delegate, we no longer need to
    declare a delegate, and we can immediately assign any method to the delegate.
    We can modify the preceding `MultiTemplateDelegates.csproj` project and remove
    the `AdditionDelegate` delegate since we will now use the `Action` delegate. Then,
    the `ActionDelegateInvoke()` method in `MultiTemplateDelegates.csproj` will be
    modified to become `ActionDelegateInvoke()` with the following implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: C#有一个内置委托，最多可以接受16个参数并返回void。它被称为`Action`委托。换句话说，`Action`委托将指向一个不返回任何内容并且接受零个、一个或多个输入参数的方法。由于存在`Action`委托，我们不再需要声明一个委托，可以立即将任何方法分配给该委托。我们可以修改前面的`MultiTemplateDelegates.csproj`项目，并删除`AdditionDelegate`委托，因为我们现在将使用`Action`委托。然后，`MultiTemplateDelegates.csproj`中的`ActionDelegateInvoke()`方法将被修改为`ActionDelegateInvoke()`，并具有以下实现：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can find the preceding code in the `ActionFuncDelegates.csproj` project.
    As we can see, now we apply the `Action` delegate to replace the `AdditionDelegate`
    delegate in the `MultiTemplateDelegates.csproj` project, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`ActionFuncDelegates.csproj`项目中找到前面的代码。正如我们所看到的，现在我们应用`Action`委托来替换`MultiTemplateDelegates.csproj`项目中的`AdditionDelegate`委托，如下所示：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'C# has another built-in delegate that has a return value by taking a maximum
    of 16 parameters. They are `Func` delegates. Let''s go back to the `MultiTemplateDelegates.csproj`
    project and find the following delegate:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C#还有另一个内置委托，它通过最多16个参数返回一个返回值。它们是`Func`委托。让我们回到`MultiTemplateDelegates.csproj`项目，并找到以下委托：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can remove the preceding delegate since it matches the declaration of the
    `Func` delegate. So, we can modify the `ReturnValueDelegateInvoke()` method in
    the `MultiTemplateDelegates.csproj` project for it to become the `FuncDelegateInvoke()`
    method with the following implementation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除之前的委托，因为它与`Func`委托的声明匹配。因此，我们可以修改`MultiTemplateDelegates.csproj`项目中的`ReturnValueDelegateInvoke()`方法，使其成为以下实现的`FuncDelegateInvoke()`方法：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we  no longer need the `AddAndConvert` delegate anymore since we have
    applied the `Func` delegate, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再需要`AddAndConvert`委托，因为我们已经应用了`Func`委托，如下所示：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the `Action` and `Func` built-in delegates, the code becomes shorter and
    the definition of the delegate becomes easier and quicker.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`Action`和`Func`委托，代码变得更短，委托的定义也变得更容易和更快。
- en: Distinguishing variance in delegates
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分委托中的变化
- en: A generic delegate has the ability to be assigned by a method that has an unmatched
    signature to the delegate. We can call this variance in delegates. There are two
    variances in delegates, and they are covariance and contravariance. Covariance
    allows a method to have a return type that is more derived (subtype) than the
    return type that is defined in the delegate. On the other hand, contravariance
    allows a method to have parameter types that are less derived (supertype) than
    the parameter types that are defined in the delegate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型委托具有被分配给具有不匹配签名的方法的能力。我们可以称之为委托的变化。委托中有两种变化，它们是协变和逆变。协变允许方法具有比在委托中定义的返回类型更派生（子类型）的返回类型。另一方面，逆变允许方法具有比在委托中定义的参数类型更不派生（超类型）的参数类型。
- en: Covariance
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协变
- en: 'The following is an example of covariance in delegates, which we can find in
    the `Covariance.csproj` project. First, we initialize the following delegate:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是委托中协变的示例，我们可以在`Covariance.csproj`项目中找到。首先，我们初始化以下委托：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We now have a delegate returning the `TextWriter` data type. Then, we also
    create the `StreamWriterMethod()` method returning the `StreamWriter` object,
    which has the following implementation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个返回`TextWriter`数据类型的委托。然后，我们还创建了返回`StreamWriter`对象的`StreamWriterMethod()`方法，其实现如下：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We create the `StringWriterMethod()` method as well, returning the `StringWriter`
    object with the following implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了`StringWriterMethod()`方法，返回`StringWriter`对象，并具有以下实现：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we have two methods returning different objects, `StreamWriter` and `StringWriter`
    . The return value data type of these methods is also different, with the `CovarianceDelegate`
    delegate returning the `TextWriter` object. However, since `StreamWriter` and
    `StringWriter` are derived from the `TextWriter` object, we can apply covariance
    in assigning these two methods to the `CovarianceDelegate` delegate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个返回不同对象的方法，`StreamWriter`和`StringWriter`。这些方法的返回值数据类型也不同，`CovarianceDelegate`委托返回`TextWriter`对象。然而，由于`StreamWriter`和`StringWriter`都是从`TextWriter`对象派生出来的，我们可以应用协变将这两种方法分配给`CovarianceDelegate`委托。
- en: 'Here is the `CovarianceStreamWriterInvoke()` method implementation, which assigns
    the `StreamWriterMethod()` method to the `CovarianceDelegate` delegate:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CovarianceStreamWriterInvoke()`方法的实现，它将`StreamWriterMethod()`方法分配给`CovarianceDelegate`委托：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `StreamWriterMethod()` method, we create `StreamWriter` , writing content
    to the console using the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StreamWriterMethod()`方法中，我们创建`StreamWriter`，使用以下代码将内容写入控制台：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, in the `CovarianceStreamWriterInvoke()` method, we call this code in
    order to write the content to the console:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`CovarianceStreamWriterInvoke()`方法中，我们调用此代码以将内容写入控制台：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we run the `CovarianceStreamWriterInvoke()` method, the following output
    will be displayed in the console:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`CovarianceStreamWriterInvoke()`方法，将在控制台中显示以下输出：
- en: '![Covariance](img/Image00018.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Covariance](img/Image00018.jpg)'
- en: From the preceding output console, we serve the list of directories we have
    inside the Visual Studio 2015 installation path. Indeed, you might have a different
    list if you installed a different version of Visual Studio.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出控制台中，我们提供了Visual Studio 2015安装路径中的目录列表。实际上，如果您安装了不同版本的Visual Studio，则可能会有不同的列表。
- en: 'Now, we are going to utilize the `StringWriterMethod()` method to create a
    `CovarianceDelegate` delegate. We create the `CovarianceStringWriterInvoke()`
    method, which has the following implementation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用`StringWriterMethod()`方法创建一个`CovarianceDelegate`委托。我们创建了`CovarianceStringWriterInvoke()`方法，其实现如下：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have generated `StringWriter` in the `StringWriterMethod()` method using
    the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`StringWriterMethod()`方法中使用以下代码生成了`StringWriter`：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we call the following code to write the string to the console:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用以下代码将字符串写入控制台：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we run the `CovarianceStringWriterInvoke()` method, the string we have defined
    in the `arrString` string array in the `StringWriterMethod()` method will be displayed,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`CovarianceStringWriterInvoke()`方法，那么在`StringWriterMethod()`方法中定义的字符串数组`arrString`中定义的字符串将被显示，如下所示：
- en: '![Covariance](img/Image00019.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![协变性](img/Image00019.jpg)'
- en: 'Now, from our discussion on covariance, we have proved the covariance in delegates.
    The `CovarianceDelegate` delegate returning `TextWriter` can be assigned to the
    method returning `StreamWriter` and `StringWriter` . The following code snippet
    is taken from several preceding codes to conclude the covariance in delegates:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从我们对协变性的讨论中，我们已经证明了委托中的协变性。返回`TextWriter`的`CovarianceDelegate`委托可以分配给返回`StreamWriter`和`StringWriter`的方法。以下代码片段摘自前面的几个代码，以总结委托中的协变性：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Contravariance
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变性
- en: 'Now, let''s continue our discussion on variance in delegates by discussing
    contravariance. The following is the `ContravarianceDelegate` delegate declaration,
    which we can find in the `Contravariance.csproj` project:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论委托中的协变性，讨论逆变性。以下是`Contravariance.csproj`项目中可以找到的`ContravarianceDelegate`委托声明：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding delegate is going to be assigned to the following method, which
    has the `TextWriter` data type parameter, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述委托将被分配给以下具有`TextWriter`数据类型参数的方法，如下所示：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The assignment will be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 分配将如下所示：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we run the `ContravarianceTextWriterInvoke()` method, the console will display
    the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`ContravarianceTextWriterInvoke()`方法，控制台将显示以下输出：
- en: '![Contravariance](img/Image00020.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![逆变性](img/Image00020.jpg)'
- en: 'From the preceding output, we have successfully assigned a method, taking the
    `TextWriter` parameter to the delegate taking the `StreamWriter` parameter. This
    happens because `StreamWriter` is derived from `TextWriter` . Let''s take a look
    at the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们已成功将一个接受`TextWriter`参数的方法分配给了一个接受`StreamWriter`参数的委托。这是因为`StreamWriter`是从`TextWriter`派生出来的。让我们看一下以下代码片段：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code snippet is taken from the code we discussed in contravariance.
    Here, we can see that `contravDelegate` , a variable typed `ContravarianceDelegate`
    , can be assigned to the `TextWriterMethod()` method even though they both have
    different signatures. This is because `StreamWriter` is derived from the `TextWriter`
    object. Since the `TextWriterMethod()` method can work with a `TextWriter` data
    type, it will surely be able to work with a `StreamWriter` data type as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段摘自我们讨论逆变性的代码。在这里，我们可以看到`contravDelegate`，一个类型为`ContravarianceDelegate`的变量，可以分配给`TextWriterMethod()`方法，即使它们具有不同的签名。这是因为`StreamWriter`是从`TextWriter`对象派生出来的。由于`TextWriterMethod()`方法可以使用`TextWriter`数据类型，因此它肯定也能够使用`StreamWriter`数据类型。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A delegate is useful in order to encapsulate a method. It is like any data type
    in C# in which a variable can be initialized to have the delegate data type. Since
    it similar to data types, increment and decrement operations can be applied to
    the delegate, making it possible to create a multicast delegate from several delegates.
    However, one thing to remember, since the `Delegate.Combine()` and `Delegate.Remove()`
    methods return the `Delegate` data type, is that we have to cast the return of
    both methods to the expected instance delegate when using them. Compared to the
    `+=` and `-=` operators use, however, since they are implemented at the language
    level in the compiler and the delegate type is known, there's no need to cast
    the result of the increment and decrement delegate operation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 委托在封装方法时非常有用。它就像C#中的任何数据类型，其中变量可以初始化为具有委托数据类型。由于它类似于数据类型，可以对委托应用增量和减量操作，从而可以从多个委托创建多播委托。然而，需要记住的一件事是，由于`Delegate.Combine()`和`Delegate.Remove()`方法返回`Delegate`数据类型，所以在使用它们时，我们必须将这两种方法的返回值转换为预期的实例委托。然而，与`+=`和`-=`运算符相比，由于它们是在编译器的语言级别实现的，并且委托类型是已知的，因此在增量和减量委托操作的结果上不需要进行转换。
- en: C# also has built-in delegates, `Action` and `Func` , which make the code shorter,
    and the definition of the delegate becomes easier and quicker. As a result, the
    code gets simpler to be analyzed. Also, there are two variances in the use of
    delegates; covariance and contravariance, which will allow us to assign a method
    to the delegate. Covariance allows a method to have a return type that is more
    derived than the return type that is defined in the delegate, while contravariance
    allows a method to have the parameter types that are less derived than the parameter
    types that are defined in the delegate.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C#还具有内置的委托`Action`和`Func`，这使得代码更简洁，委托的定义变得更容易和更快。因此，代码变得更简单，更容易分析。此外，委托的使用中有两种变化；协变性和逆变性，这将允许我们将方法分配给委托。协变性允许方法具有比委托中定义的返回类型更派生的返回类型，而逆变性允许方法具有比委托中定义的参数类型更不派生的参数类型。
- en: We now have a better understanding about delegates. Let's move on to the next
    chapter, where we are going to leverage the power of delegates to express anonymous
    methods using the lambda expression.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对代理有了更好的理解。让我们继续下一章，我们将利用代理的力量来使用lambda表达式来表达匿名方法。
