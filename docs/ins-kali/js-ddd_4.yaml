- en: Chapter 4. Modeling the Actors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。建模参与者
- en: We are now ready to dive head first into development, and we have a solid structure
    in place to help us deal with the arising changes that will come no matter what.
    It is time to think more about what the different components of our system are
    and how they interact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好全力投入开发工作，我们已经建立了一个坚实的结构，以帮助我们处理即将出现的变化。是时候更多地考虑我们系统的不同组件以及它们是如何相互作用的了。
- en: Interaction in systems happens on multiple levels. The operating system interacts
    with the language runtime, the runtime interacts with our code, and then inside
    our code we create objects calling back out and calling other processes and so
    on. We have already seen how our domain objects can interact with the underlying
    framework and we can imagine how the code calls different libraries. When structuring
    interactions, it is important to know about the seams that exist and to create
    new ones where necessary. When calling other code, it is pretty clear where our
    code ends and where the library code starts. When we are creating code, it is
    easy to muddle responsibilities, but the better we can separate them, the better
    we can evolve our code in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的交互发生在多个层面。操作系统与语言运行时进行交互，运行时与我们的代码进行交互，然后在我们的代码内部，我们创建对象进行回调和调用其他进程等。我们已经看到我们的领域对象如何与底层框架进行交互，我们可以想象代码如何调用不同的库。在构建交互时，了解存在的接缝并在必要时创建新的接缝是很重要的。在调用其他代码时，很明显我们的代码在哪里结束，库代码在哪里开始。在创建代码时，很容易混淆责任，但我们能够更好地分离它们，我们就能更好地发展我们的代码。
- en: 'Almost all aspects of computer science deal with interactions between different
    components in some way or other, and so multiple techniques exist to make sure
    those interactions work well. In this chapter, we are focusing on the actors of
    the system and their interactions, and will go into the details of:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎计算机科学的所有方面都以某种方式处理不同组件之间的交互，因此存在多种技术来确保这些交互良好地进行。在本章中，我们将重点关注系统的参与者及其交互，并将详细介绍：
- en: Using object-oriented programming techniques to model domain actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象编程技术来对领域参与者进行建模
- en: Testing domain objects in isolation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隔离中测试领域对象
- en: Identifying and naming roles in the domain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在领域中识别和命名角色
- en: The shoulders of giants
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巨人的肩膀
- en: 'One of the best known models of how interactions can be modeled and worked
    on is the **OSI**/**ISO** model that describes the interaction of layers in the
    networking stack. It comprises seven layers, each with a well-defined interface
    to be communicated with by the layer above, and to communicate with the layer
    below. Furthermore, each layer defines a protocol that allows it to communicate
    with a layer of the same level. With this in place, there is a very clear API
    to communicate with the layer and it is also clear how the layer can call back
    out to the system, therefore making it easy to replace parts of the system. The
    following diagram shows this how it is described in the OSI/ISO model. Each layer
    is defined by a protocol that allows instances on each side to communicate at
    their layer, as we move up the stack protocols are wrapped and unwrapped by the
    given instances:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何建模和处理交互的最著名的模型之一是描述网络堆栈中各层交互的OSI/ISO模型。它包括七层，每一层都有一个明确定义的接口，可以由上一层进行通信，并与下一层进行通信。此外，每一层都定义了一个协议，允许它与同一级别的层进行通信。有了这个，就有了一个非常清晰的API来与层进行通信，也清楚了层如何回调到系统，因此很容易替换系统的部分。下图显示了OSI/ISO模型中的描述。每一层都由一个协议定义，允许每一侧的实例在其层进行通信，随着堆栈的上升，协议由给定的实例进行包装和解包：
- en: '![The shoulders of giants](graphics/B03704_04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![巨人的肩膀](graphics/B03704_04_01.jpg)'
- en: This model has not been adopted across the board of course, with TCP/IP focusing
    on five layers, and it has even been stated that too much layering can be considered
    harmful. But even those who are not in favor of the OSI/ISO model consider the
    basic idea valuable, and isolating communication is one of the basics of making
    the Internet work, so to speak. Each layer is replaceable, be it completely or
    just for a specific case, which is a powerful thing to have in any system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种模型并没有被全面采用，TCP/IP专注于五层，甚至有人说过分的分层可能是有害的。但即使那些不赞成OSI/ISO模型的人也认为基本思想是有价值的，隔离通信是使互联网运行的基础之一。每一层都是可替换的，无论是完全替换还是只针对特定情况，这对任何系统来说都是一件强大的事情。
- en: Bringing this over to the world of modeling applications means that our objects
    should communicate at their layer in the business domain. In terms of domain-driven
    design, it is okay for an aggregate to interact with other aggregates to fulfill
    its purpose, but it is not okay for a service to reach into a entity without considering
    the aggregate. Reaching into different parts of an application without considering
    the appropriate APIs causes coupling two models together. In our dungeon, having
    a dungeon master of a foreign dungeon communicate directly with a prisoner is
    also a bad idea, marking the prisoner as a spy and getting him killed immediately,
    most likely. This not only causes problems due to tight coupling, but also opens
    the application up to security problems. There have been many instances of, for
    example, SQL injection attacks because a model accessing the database reached
    directly for the data passed in an HTTP request without a layer to mitigate the
    access.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一点引入到建模应用程序的世界意味着我们的对象应该在业务领域的层面进行通信。在领域驱动设计方面，允许一个聚合与其他聚合进行交互以实现其目的是可以的，但是一个服务在不考虑聚合的情况下直接访问实体是不可以的。在不考虑适当的API的情况下访问应用程序的不同部分会导致两个模型之间的耦合。在我们的地牢中，让外来地牢的地牢主直接与囚犯进行交流也是一个坏主意，这会让囚犯被标记为间谍并立即被杀害，这不仅会因为紧密耦合而导致问题，还会让应用程序暴露于安全问题。例如，由于模型访问数据库直接获取HTTP请求中传递的数据而没有层来减轻访问，曾经发生过许多SQL注入攻击的实例。
- en: 'Communication like this, where one object communicates with another part of
    the object graph, ignoring the gating interfaces, is a well understood problem
    and is solidified as the *Law of Demeter*, which states:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通信，其中一个对象与对象图的另一部分进行通信，忽略了门控接口，这是一个众所周知的问题，并被确定为*迪米特法则*，该法则规定：
- en: '|   | *Each unit should have only limited knowledge about other units: only
    units "closely" related to the current unit.* |   |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|   | *每个单元应该只对其他单元有限的了解：只有与当前单元“密切”相关的单元。* |   |'
- en: '|   | --*Law of Demeter* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|   | --*迪米特法则* |'
- en: 'Often this is paraphrased in object-oriented language to say that a method
    should only have one dot. Having a method like the following on the orc master
    for example, violates this. The following code shows implementing an accessor
    for the available weapons in a dungeon, by reaching far into the objects controlled
    by the dungeon and its descendants:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这在面向对象的语言中被改述为一个方法只应该有一个点。例如，像兽人大师上的以下方法违反了这一点。以下代码显示了通过深入到地牢及其后代控制的对象中实现了一个获取地牢中可用武器的访问器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, the orc master reaches each orc via its dungeon and asks it directly
    for the type of his weapon. This binds the orc master not only to the inner implementation
    of the dungeon, but also the orc and even the weapon itself; if any of those elements
    change, the method has to change as well. This not only makes the object itself
    harder to change, but the system overall is more rigid now and not as malleable
    under refactoring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，兽人大师通过其地牢直接接触每个兽人，并直接询问他的武器类型。这不仅将兽人大师绑定到地牢的内部实现，还绑定到兽人甚至武器本身；如果这些元素中的任何一个发生变化，方法也必须发生变化。这不仅使对象本身更难以改变，而且整个系统现在更加僵化，在重构下不太灵活。
- en: 'Code like the preceding is imperative in its operation on the data structures,
    where object-oriented code focuses on a more declarative style to reduce the amount
    of coupling. Declarative means the code tells objects what needs to be done and
    lets them handle the operations needed to achieve the goal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的代码一样，它在操作数据结构时是命令式的，而面向对象的代码则专注于更声明式的风格，以减少耦合的数量。声明式意味着代码告诉对象需要做什么，并让它们处理实现目标所需的操作：
- en: '|   | *Procedural code gets information then makes decisions. Object-oriented
    code tells objects to do things.* |   |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   | *过程式代码获取信息然后做决定。面向对象的代码告诉对象要做事情。* |   |'
- en: '|   | --*Alec Sharp* |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Alec Sharp* |'
- en: Communication should not cross boundaries randomly, but in a well-defined and
    reasonable way to keep software malleable. This also means that when developing
    software, we need to be aware of the components and interfaces, identifying them
    as we have done already, and be aware as new ones arise from the code we are writing.
    The same is true for commands and events that represent messages being sent in
    our domain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通信不应该随意跨越边界，而应该以明确定义和合理的方式保持软件的可塑性。这也意味着在开发软件时，我们需要意识到组件和接口，像我们已经做过的那样识别它们，并意识到新的组件和接口从我们正在编写的代码中出现。对于在我们的领域中发送的命令和事件代表的消息也是如此。
- en: Even when thinking about the software under development very intensively beforehand
    and drawing diagrams like we have done, it is almost inevitable you'll miss certain
    abstractions that become clear when development has started. The code and the
    test we write should make the interfaces clear, and to take advantage of this
    fact a common way is to exercise the code under development as early as possible,
    and let it "tell" you about its dependents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在非常集中地思考正在开发的软件并绘制像我们已经做过的那样的图表时，几乎不可避免地会错过某些在开发开始时变得清晰的抽象。我们编写的代码和测试应该使接口清晰，并利用这一事实的一种常见方式是尽早执行正在开发的代码，并让它“告诉”你关于它的依赖项。
- en: The Different approaches to development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发的不同方法
- en: 'Now that we are writing the code to solve problems in our domain, we can approach
    problems in different ways: one way is to start at the topmost level we have so
    far discovered and let this guide us down to our lower level objects and abstractions,
    or we can start with the components we identified, flush them out and build up
    the system. Both approaches are valid and are commonly referred to as "outside-in"
    or "inside-out" development. The advantage of inside-out is that we always have
    a running working system because we build the dependents first and build up the
    system. The disadvantage being that it is easier to lose sight of the bigger picture
    and get lost in the details.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在编写代码来解决领域中的问题，我们可以以不同的方式来解决问题：一种方式是从我们迄今为止发现的最高级别开始，让这指导我们下到我们的较低级别对象和抽象，或者我们可以从我们识别的组件开始，完善它们并建立系统。这两种方法都是有效的，通常被称为“自外向内”或“自内向外”开发。自内向外的优势在于我们始终有一个运行的工作系统，因为我们首先构建依赖项并建立系统。缺点是很容易失去对整体情况的视野，并在细节中迷失方向。
- en: What is common to the approaches is that they follow a style based on test-driven
    development. We are building the tests to let us guide the design and show us
    when we are done. We start using our code first to get a feel for how it would
    behave later, and implement what we think the behavior should be. This can be
    done by first focusing on the small, easier to grasp components to gain confidence
    in them, as it is done in the *inside-out* approach. Another way to approach it
    is to ask the big questions at the start, drilling down into more detail as we
    move along, as in the *outside-in* approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的共同之处在于它们遵循基于测试驱动开发的风格。我们正在构建测试来指导设计，并在完成时向我们展示。我们首先使用我们的代码来感受它以后的行为，并实现我们认为行为应该是什么。这可以通过首先专注于小而容易理解的组件来获得对它们的信心，就像*自内向外*方法中所做的那样。另一种方法是在开始时提出重要问题，随着我们的深入，逐渐进入更多细节，就像*自外向内*方法中所做的那样。
- en: For this project, it feels more appropriate to start on the outside because
    we explored and got a feel for what the stakeholders want, but are not so clear
    about the exact components and their behavior; after all we are in a world we
    are not entirely familiar with. Especially in an unfamiliar world, we are very
    prone to start building pieces we never needed. Right now we don't know a lot
    about the messaging system between dungeons for example. We could start trying
    to build an abstraction here and allow us to control as much as possible, but,
    on the other hand, it might turn out that we only send one message a week and
    having this pop up on the dungeon master's screen to have him do it by hand is
    perfectly reasonable. In these kinds of evaluations, we have to keep in mind that
    our overarching goal should always be to deliver value and save money, and that
    can mean *not* building things. So how can we go about creating software without
    the underlying structure being in place?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，从外部开始可能更合适，因为我们探索并了解了利益相关者的需求，但对于确切的组件及其行为并不太清楚；毕竟我们处在一个我们并不完全熟悉的世界中。特别是在一个陌生的世界中，我们很容易开始构建我们从未需要过的部分。现在我们对例如地牢之间的消息系统了解不多。我们可以开始尝试在这里构建一个抽象，让我们尽可能地控制，但另一方面，结果可能是我们每周只发送一条消息，并且让地牢主人手动完成这个任务是完全合理的。在这种评估中，我们必须牢记我们的总体目标应始终是提供价值和节省金钱，这可能意味着*不*构建东西。那么我们如何在没有基础结构的情况下创建软件呢？
- en: Introducing mocks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍模拟对象
- en: When trying to model a system from the outside in, there is a need have objects
    stand in for what is eventually going to be the lower level implementation. This
    happens on every level and the concept of modeling the API first trickles down
    to the lower layers. We previously started building the prisoner transfer service,
    with dependency being on the prisoner and a dungeon; those again will have dependents
    that, when flushing out the objects, will need to be designed in similar ways.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在从外部建模系统时，需要让对象代表最终将成为较低级别实现的对象。这在每个级别上都会发生，而首先对API进行建模的概念会向下渗透到较低层。我们之前开始构建了囚犯转移服务，依赖于囚犯和地牢；这些又将有依赖项，当完善对象时，需要以类似的方式设计。
- en: The objects that enable this are called **mocks**; they are objects that provide
    a static implementation of a certain concept and can assert that they are called
    correctly. Mocks implement the protocol a certain object should follow. In a dynamic
    language, such as JavaScript, this is both easy and hard. Different JavaScript
    testing frameworks approach this differently; some use mock objects as described,
    while some provide spies that call through to the real object but monitor those
    calls for correctness. Both approaches work well and there are advantages to each.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的对象称为**模拟**；它们是提供某个概念的静态实现并断言它们是否被正确调用的对象。模拟实现了某个对象应该遵循的协议。在JavaScript这样的动态语言中，这既容易又困难。不同的JavaScript测试框架以不同的方式处理这个问题；有些使用如上所述的模拟对象，而有些提供间谍，它们调用真实对象但监视这些调用的正确性。这两种方法都很有效，各有优势。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on spies can be found at [http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/](http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关间谍的更多信息可以在[http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/](http://derickbailey.com/2014/04/23/mock-objects-in-nodejs-tests-with-jasmine-spies/)找到。
- en: 'Creating a mock can be a simple as:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟可以很简单：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even though this is not a very advanced mock, it contains what we need. This
    object can now stand in for anything that requires the specific API of providing
    a function called `aFunction`. It is also possible to check whether a function
    has been called by checking the called variable after the test has been run. These
    checks can be done with the `assert` library provided directly by the runtime
    without the need for additional testing frameworks. In the following code, we
    use our very simple mock we created above to assert that a function is indeed
    called at a given time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是一个非常高级的模拟，但它包含了我们需要的内容。这个对象现在可以代替任何需要提供名为`aFunction`的特定API的东西。还可以通过在测试运行后检查调用变量来检查函数是否已被调用。这些检查可以使用运行时直接提供的`assert`库来完成，而无需额外的测试框架。在下面的代码中，我们使用我们上面创建的非常简单的模拟来断言在特定时间调用了一个函数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we use the `Object.create` method to create a new instance of
    our `myMock` object, exercise it, and verify it worked correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Object.create`方法创建一个新的`myMock`对象实例，对其进行操作，并验证其是否正常工作。
- en: 'How to create mock objects is quite specific to the circumstances when they
    are needed and multiple libraries implement their creation. One library that is
    quite commonly used is **Sinon.JS,** and it provides many different ways to verify
    functionality, implement stubs, mocks, and spies. Combined with Mocha as our testing
    framework, we can create a mock test by creating the object we want to mock and
    letting Sinon.JS mock due the heavy lifting of verification for us. We can now
    describe the behavior of the API in very readable terms, using the combined features
    of Mocha to provide the behavioral descriptions and Sinon.JS to provide advanced
    mocking and verification. Here''s an example of this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建模拟对象非常具体，取决于需要它们的情况，多个库实现了它们的创建。一个非常常用的库是**Sinon.JS**，它提供了许多不同的方法来验证功能，实现存根、模拟和间谍。结合我们的测试框架Mocha，我们可以通过创建我们想要模拟的对象，并让Sinon.JS来进行验证的繁重工作，来创建一个模拟测试。现在我们可以用Mocha的组合特性提供行为描述，使用Sinon.JS提供高级模拟和验证。以下是一个例子：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The concept of a mock on the surface is quite simple, but its usage can be difficult
    as it can be hard to discover where the right place for a mock actually is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的概念表面上很简单，但它的使用可能很困难，因为很难发现模拟的正确位置在哪里。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on mocks, visit [http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html](http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关模拟的更多信息，请访问[http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html](http://www.mockobjects.com/2009/09/brief-history-of-mock-objects.html)。
- en: Why and why not to mock
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟的原因和不模拟的原因
- en: '|   | *Our initial description had focused too much on implementation, the
    critical idea was that the technique emphasizes the roles that objects play for
    each other.* |   |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| | *我们最初的描述过于关注实现，关键的想法是该技术强调了对象在彼此之间扮演的角色。* | |'
- en: '|   | --*A Brief History of Mock Objects – Steve Freeman* |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| | --*模拟对象的简史-Steve Freeman* |'
- en: Mock objects stand in for other objects in a system during testing, and sometimes
    even during development. There are multiple reasons to do this, for example, the
    underlying structure is not implemented yet, or the call would be really expensive
    both in a cost of time during development or even in money calling to an API that
    charges by the amount of calls. For developers it can be very convenient to be
    able to run the tests offline as well, and there are more reasons why somebody
    would want to not call the real system but something in its place.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象在测试期间代替系统中的其他对象，有时甚至在开发期间也是如此。有多种原因可以这样做，例如底层结构尚未实现，或者调用在开发过程中的时间成本或者甚至是通过调用按调用次数收费的API而非常昂贵。对于开发人员来说，能够离线运行测试非常方便，还有更多的原因可以解释为什么有人不想调用真实系统而是调用其替代物。
- en: This kind of practice is normally referred to as **stubbing out** an external
    dependency. When combined with making assertions about this dependency, this stub
    becomes a mock, which is often helpful during development to ensure that some
    code is called correctly, at the right time and, of course, when testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法通常被称为**stubbing out**外部依赖关系。当与对这种依赖关系进行断言相结合时，这个存根就成为了模拟对象，在开发过程中通常有助于确保某些代码在正确的时间被正确调用，当然也有助于测试。
- en: It is very easy to fall into the trap of creating very specific mock objects,
    mocking inner dependencies of other objects, and so forth. The important thing
    to keep in mind is that a mock should always represent a role in the system. Various
    other objects in the real world can play this role, but they can be represented
    in one mock. In classical object-oriented terms, this would mean that we are mocking
    interfaces not classes. In JavaScript, there are no interfaces so we need to select
    the right objects to mock. The object, or part of the object that is our mock,
    needs to only represent what is essential to the test, and nothing more. This
    comes naturally when we drive our design through tests, but we need to keep an
    eye on this as the software evolves and changes, as changes might result in our
    tests overspecifying an object through a mock.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易陷入创建非常具体的模拟对象的陷阱，模拟其他对象的内部依赖关系等。要牢记的重要事情是，模拟应始终代表系统中的一个角色。现实世界中的各种其他对象可以扮演这个角色，但它们可以在一个模拟中表示。在经典的面向对象术语中，这意味着我们模拟接口而不是类。在JavaScript中，没有接口，所以我们需要选择合适的对象进行模拟。我们的模拟对象或对象的一部分只需要表示测试所需的内容，而不需要其他。当我们通过测试驱动我们的设计时，这是很自然的，但随着软件的发展和变化，我们需要注意这一点，因为变化可能导致我们的测试通过模拟过度规定一个对象。
- en: Who is involved in the prisoner transfer?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁参与了囚犯的转移？
- en: 'In the previous sections, we did a lot of exploring in the domain to get a
    view of what has to be done to make actions in the system happen. With this knowledge,
    we can now get a clear-cut concept of how a prisoner transfer should happen. The
    tests we created earlier specify some behavior and collaborators we are aware
    of in the domain. We represent them as basic JavaScript objects that contain the
    properties necessary to satisfy the tests; we, for example, know that a dungeon
    needs a message inbox to be notified, but we don''t know any properties for the
    prisoner yet. The following code provides some simple functions to let us describe
    the type of object we are using, as the code grows and our knowledge of what makes
    a prisoner or a dungeon gets solidified we can fill those out to continue to be
    stand-ins for the respective objects during our tests:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们在领域中进行了大量探索，以了解使系统中的操作发生所必须做的事情。有了这些知识，我们现在可以清楚地概念化囚犯转移应该如何进行。我们之前创建的测试指定了一些行为和我们在领域中知道的协作者。我们将它们表示为基本的JavaScript对象，其中包含满足测试所需的属性；例如，我们知道地牢需要一个消息收件箱来通知，但我们还不知道囚犯的任何属性。以下代码提供了一些简单的函数，让我们描述我们正在使用的对象类型，随着代码的增长和我们对囚犯或地牢的了解得到巩固，我们可以填写这些内容，以继续在测试期间代表相应的对象。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So far, the prisoner as well as the dungeon are specific JavaScript objects
    created just to represent what we need at this moment. Looking further into the
    details, other actors are involved as well, namely the orc guarding the prisoner
    along the way, as well as the transfer carriage. Of course, those again have dependencies:
    the carriage consists of the driver, the wooden carriage working as a mobile cell
    for the prisoner, as well as the horses that pull it. All those pieces are potentially
    scarce resources that we need to acquire. Here is where domain modeling comes
    in again; in the context of our application we can stay away from looking at them
    as separate things because if either is missing the whole object won''t be able
    to function. We can focus on which roles the different objects play and acquire
    them as aggregates where it fits our model.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，囚犯和地牢都是特定的JavaScript对象，只是为了代表我们此刻需要的东西。进一步了解细节，还涉及其他参与者，即在途中看守囚犯的兽人，以及转移马车。当然，这些又有依赖关系：马车由驾驶员、作为囚犯移动牢房的木制马车以及拉动它的马组成。所有这些部分都是我们需要获取的潜在稀缺资源。这就是域建模再次发挥作用的地方；在我们的应用程序的上下文中，我们可以不把它们看作独立的东西，因为如果其中任何一个缺失，整个对象将无法正常运行。我们可以专注于不同对象扮演的角色，并将它们作为聚合物获取，以符合我们的模型。
- en: Different objects and their roles
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的对象及其角色
- en: The carriage is one of those described roles; we do not care at this moment
    what the carriage consists of but treat it as one thing that fulfills some purpose
    in our system. The carriage as a whole is an aggregate we only want to inspect
    from the outside for now and don't care much about its internals. Right there,
    the carriages public API shows a seam that that we need to account for when we
    model. We might care about horses being a separate thing later, for example, to
    model a messenger where we want to allocate horses for both carriages as well
    as messengers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 马车是其中一个描述的角色；我们现在不关心马车由什么组成，而是将其视为在我们的系统中实现某种目的的一个东西。马车作为一个整体是一个聚合体，我们现在只想从外部检查它，不太关心它的内部。在这里，马车的公共API显示了一个我们在建模时需要考虑的接缝。例如，我们可能会在以后关心马匹作为一个单独的东西，以建模一个信使，我们希望为马车和信使都分配马匹。
- en: An aggregate is not a way to limit the share ability of resources but a concept
    to make dealing with the comprised object less complex. It does not change the
    fact that a carriage without horses is useless, and that something else also might
    need to acquire horses as a resource. The carriage is a role in our system. It
    provides a public API and takes care of its own internal data and dependencies.
    It is an aggregate in itself on a smaller scale.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合体不是限制资源共享的一种方式，而是一个概念，使得处理包含的对象变得不那么复杂。这并不改变没有马匹的马车是无用的这一事实，也可能有其他东西需要获取马匹作为资源。马车是我们系统中的一个角色。它提供了一个公共API，并处理自己的内部数据和依赖关系。它本身就是一个较小规模的聚合体。
- en: The idea to discover such seams is a fundamental idea when it comes to building
    systems using mocks and stubs. By mocking out roles in the system, we can interact
    with the role before it really exists and explore its functionality without being
    hampered by the internal implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 发现这样的接缝是在构建使用模拟和存根的系统时的一个基本思想。通过在系统中模拟角色，我们可以在它真正存在之前与角色进行交互，并探索其功能，而不受内部实现的限制。
- en: Naming objects according to the domain
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据领域命名对象
- en: '|   | *There are only two hard things in Computer Science: cache invalidation
    and naming things.* |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| *在计算机科学中只有两件难事：缓存失效和命名事物。* |'
- en: '|   | --*Phil Karlton* |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --*Phil Karlton* |'
- en: When exploring roles in a domain, the most complicated thing is most often the
    fact that we need to name the role that we try to establish in the system. When
    we are able to name a thing, we can naturally associate it with the role it plays
    in a system. When building a software system and being able to point out the roles
    by giving them concrete names, we make it easy for every developer working on
    the system to know where to put functionality related to the part they need to
    work on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索领域中的角色时，最复杂的事情往往是我们需要为系统中尝试建立的角色命名。当我们能够为一件事命名时，我们自然可以将其与它在系统中扮演的角色联系起来。在构建软件系统并能够通过给它们具体的名称指出角色时，我们使得每个在系统上工作的开发人员都能够知道在哪里放置与他们需要工作的部分相关的功能。
- en: Previously, we introduced the concept of a carriage, comprising the cart itself,
    horses to tow it, and a driver. This is one example of naming a concept according
    to the domain. In the world of the orc dungeons, the concept of a carriage is
    very clear, and what is needed to run it is very clear. By using the language
    of the stakeholders in the system, we are increasing the teams' language and enabling
    all the stakeholders to participate. We saw this before when identifying the parts
    of the domain; we now make sure we continue to increase the language while creating
    abstractions. This allows us to hide certain details behind a common role.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了马车的概念，包括马车本身、拉车的马匹和驾驶员。这是一个根据领域命名概念的例子。在兽人地牢的世界中，马车的概念非常清晰，运行所需的东西也很清晰。通过使用系统利益相关者的语言，我们增加了团队的语言能力，使所有利益相关者都能参与其中。在确定领域的部分时，我们确保继续增加语言，同时创建抽象。这使我们能够将某些细节隐藏在一个常见的角色后面。
- en: The traps of common names like *Manager
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见名称陷阱，比如*Manager
- en: 'The carriage we introduced a concept, well known in the domain, is a good abstraction
    to have; as software developers, however, we are prone to keep reusing elements
    we have seen before in other applications. When naming roles, it is very easy
    to fall into a pattern of naming. Very often, we see `Manager` objects that really
    only exist for the lack of a better name about the role they fulfill:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍的马车概念是一个很好的抽象；然而，作为软件开发人员，我们很容易重复使用我们在其他应用程序中看到的元素。在命名角色时，很容易陷入一种模式。我们经常看到只是因为缺乏更好的名称而存在的“Manager”对象：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this object fulfills the same responsibility as the object we named
    `carriage` before, finding out what it does is no longer obvious by the name.
    Even though it is clear to the developers on the team what this object is meant
    to do, the other stakeholders will be confused. This drives a separation in the
    team and will not foster involvement in the development process by non-developers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个对象承担的责任与我们之前命名为“马车”的对象相同，但通过名称找出它的功能已不再明显。即使团队中的开发人员清楚这个对象的用途，其他利益相关者也会感到困惑。这会导致团队内部的分裂，并不会促进非开发人员参与开发过程。
- en: Naming an object as a manager often means naming it after what it does at this
    moment instead of the role it fulfills in the system in general. Naming an object
    this way makes it hard to abstract away the details within it. To know what a
    `Manager` object does always means knowing what it is managing and how its internal
    details work to make sense of it. The abstraction leaks to other parts of the
    system, and everybody using the manager will look into the parts it is managing
    and the details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象命名为经理通常意味着根据它目前的功能而不是它在系统中的角色来命名它。以这种方式命名对象使得很难将其中的细节抽象出来。了解“Manager”对象的功能总是意味着知道它在管理什么以及它的内部细节如何运作才能理解它。抽象泄漏到系统的其他部分，每个使用经理的人都会查看它所管理的部分和细节。
- en: The pain of manager objects often becomes very clear in the context of writing
    tests. When we want to test a manager and we don't see a clear abstraction, we
    need to care about the internal dependencies and therefore need to hold on to
    them in our tests. This makes tests look complicated and the setup starts to trump
    the actual assertion part. With objects named after generic roles, we get objects
    serving the purpose of very generic roles and therefore move away from domain-specific
    objects. This can cause pain as those generic objects are only made specific by
    their internal implementation, and therefore are bad representatives of the role
    they are supposed to play.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象的痛苦在编写测试的情境中往往变得非常明显。当我们想要测试一个管理器，而我们看不到一个清晰的抽象时，我们需要关心内部依赖关系，因此需要在我们的测试中保持它们。这使得测试看起来复杂，设置开始超过实际的断言部分。通过以通用角色命名的对象，我们得到了为非常通用的角色提供服务的对象，因此远离了特定于领域的对象。这可能会带来痛苦，因为这些通用对象只能通过其内部实现来具体化，因此它们是应该扮演的角色的不良代表。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you have trouble coming up with a name for an object, try naming it something
    obviously silly first and let the exploration of the domain guide you to a more
    specific and meaningful name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在为一个对象想不出名字时，试着先给它取一个明显愚蠢的名字，然后让对领域的探索引导你找到一个更具体和有意义的名字。
- en: Readability of method names
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法名的可读性
- en: 'In **Object-oriented Programming** (**OOP**), an object holds data and is responsible
    for the actions most closely related to the data it holds. Functions operating
    on the data, such as computing new data from the internal state of the object,
    are called queries. Examples for such a function are ones that compute compound
    data, like the full name of an orc from its set first name and last name:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在**面向对象编程**（**OOP**）中，对象保存数据，并负责与其保存的数据最密切相关的操作。操作数据的函数，如从对象的内部状态计算新数据的函数，称为查询。这样的函数的例子是计算复合数据的函数，例如根据其设置的名和姓计算兽人的全名：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the other hand, if an object is not immutable, there need to be functions
    to modify its internal state. Functions that change the internal state of an object
    are called commands; they allow external objects to send commands to the object
    to change its behavior. The following is an example of this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果对象不是不可变的，就需要有函数来修改其内部状态。改变对象内部状态的函数称为命令；它们允许外部对象向对象发送命令以改变其行为。以下是一个例子：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As commands change their internal state, it needs to be very clear what is happening
    and the object should have as much control as possible over what to actually do
    in the case of the command, so the command tells the object what to do and does
    not ask it for its state to modify it. Making this happen means we want to instruct
    the object to accomplish a task, without inspecting its properties. The opposite
    is checking object properties and based on those, making a decision in place of
    the object responsible for the properties. The *Tell, Don't Ask* principle is
    an important principle of OOP. The preceding example follows this concept, by
    not creating a setter to *attack* the property, we make sure the `Orc` object
    is in control of its internal state. Making domain-specific commands read like
    what they do, instead of creating an extensive amount of setter/getter methods,
    helps readability as well as making sure that the state is well managed. In object
    orientation, we want the object to be responsible for its state and the methods
    that operate on that state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着命令改变其内部状态，需要非常清楚地知道发生了什么，并且对象应尽可能多地控制在命令的情况下实际要做什么，因此命令告诉对象要做什么，而不是询问它的状态以修改它。实现这一点意味着我们希望指示对象完成任务，而不是检查其属性。相反的是检查对象属性，并基于这些属性做出决定，代替负责属性的对象。*告诉，不要问*原则是面向对象编程的重要原则。前面的例子遵循了这个概念，通过不创建一个setter来*attack*属性，我们确保`Orc`对象控制其内部状态。使特定于域的命令读起来像它们所做的那样，而不是创建大量的setter/getter方法，有助于可读性，同时确保状态得到良好管理。在面向对象的方法中，我们希望对象负责其状态和操作该状态的方法。
- en: Not only are the objects part of a consistent naming scheme that allows us to
    model the domain. When we are modeling functionality and we want it to read clearly,
    we need to make the method names readable as well. In the previous example, the
    `TransportManager` only method is `initializeTransport` and it more or less repeats
    the name of the object. This pattern is very common when objects are `Managers`
    or `Executors`, or alike, but it does not help readability. This is the same trap
    as creating setters that are called outside the context of setting a value to
    initialize the object. The method needs to tell what the command does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不仅是一致命名方案的一部分，允许我们对领域进行建模。当我们在建模功能时，希望它读起来清晰，我们还需要使方法名可读。在前面的例子中，`TransportManager`的唯一方法是`initializeTransport`，它或多或少地重复了对象的名称。当对象是`Managers`或`Executors`等时，这种模式非常常见，但它并不有助于可读性。这与创建在设置对象的上下文之外调用的setter方法一样。方法需要告诉命令做什么。
- en: An object named after a role in the system allows much better readability of
    methods. The domain name `Carriage` makes the method name `transport` much more
    understandable because it comes naturally with the concept of a carriage in the
    domain.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个以系统中的角色命名的对象可以更好地提高方法的可读性。域名`Carriage`使方法名`transport`更容易理解，因为它自然地与领域中的马车概念联系在一起。
- en: With all this, it now comes the point where we need to think about how we model
    the objects to ease testing as well as development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，现在到了我们需要考虑如何对对象进行建模以便于测试和开发的时候了。
- en: Objects first
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先是对象
- en: When building the dungeon manager, we set out to create a maintainable and evolvable
    piece of software. The core principles of OOP are there to help us out when dealing
    with objects, but JavaScript is special when it comes to object orientation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建地牢管理器时，我们致力于创建一个易于维护和可扩展的软件。面向对象编程的核心原则在处理对象时有助于我们，但是当涉及到面向对象编程时，JavaScript是特殊的。
- en: As many JavaScript programmers will most certainly have heard, JavaScript uses
    prototypical inheritance and, more importantly, has not really got a concept of
    classes, only instances.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如许多JavaScript程序员肯定已经听说的那样，JavaScript使用原型继承，更重要的是，它实际上没有类的概念，只有实例。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though the next version of JavaScript, **ECMAScript 6**, introduces the
    class `keyword`, the core language design does not change. Classes are really
    just syntactic sugar over the prototypical inheritance present in JavaScript right
    now. If you want to know more about ES6, follow the blog [http://www.2ality.com/](http://www.2ality.com/)
    by Alex Rauschmayer, who describes and follows the evolving JavaScript language
    closely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript的下一个版本**ECMAScript 6**引入了`class`关键字，但核心语言设计并没有改变。类实际上只是JavaScript当前原型继承的一种语法糖。如果想了解更多关于ES6的信息，请关注Alex
    Rauschmayer的博客[http://www.2ality.com/](http://www.2ality.com/)，他密切描述和跟踪JavaScript语言的发展。
- en: Of course, this does not make JavaScript the worst language to perform the task
    we are trying to achieve because this lack does not limit the power of the language
    in any way, but really makes it a superset of classical object-oriented languages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着JavaScript是执行我们试图实现的任务的最糟糕的语言，因为这种缺乏并不以任何方式限制语言的能力，而是使其真正成为经典面向对象语言的超集。
- en: Let's first do a quick recap of how object orientation works in JavaScript and
    how we can use the power of the language to help us out in modeling the system
    that we have been drafting out so far.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先快速回顾一下JavaScript中的对象导向是如何工作的，以及我们如何利用语言的力量来帮助我们建模到目前为止已经起草出来的系统。
- en: The basics of objects in JavaScript
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中对象的基础
- en: 'In Object-oriented languages such as Ruby or even Java, objects are based on
    classes. Even though it might be possible to create a plain object, it is not
    the norm. Taking Ruby as an example to create an object with a method like our
    carriage, you would write something like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby或者甚至Java等面向对象的语言中，对象是基于类的。尽管可能可以创建一个普通对象，但这并不是常态。以Ruby为例，要创建一个像我们的carriage这样的方法，你会写出类似这样的代码：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In JavaScript, for very simple objects and also, very importantly, for the
    tests, we don''t need to have a class first to have an object like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对于非常简单的对象，以及非常重要的测试，我们不需要先有一个类来创建这样的对象：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will do the same thing without the necessity of creating
    a class along with the object first. This can be very powerful especially when
    modeling a new API, because it allows very lightweight usage and generation during
    this phase of development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在不必先创建类和对象的情况下执行相同的操作。这在建模新API时非常强大，因为它允许在开发阶段非常轻量地使用和生成。
- en: 'Besides the availability of plain objects that are constructed via `{}`, JavaScript
    allows functions to be used as objects. Using functions as object constructors
    means very much the same flexibility as classes in classical object orientation
    would. Functions in JavaScript are objects that encapsulate their internal state
    and the state of any variables they reference at the time of their creation from
    the outside world. Due to those properties, functions in JavaScript are the basic
    building blocks to be used to create objects, and special support via the keyword
    `new` is part of the language:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过`{}`构造的普通对象之外，JavaScript还允许函数被用作对象。在JavaScript中使用函数作为对象构造函数意味着与经典对象导向中的类一样灵活。JavaScript中的函数是封装其内部状态以及它们在创建时引用的任何变量的对象。由于这些属性，JavaScript中的函数是用于创建对象的基本构建块，并且通过关键字`new`的特殊支持是语言的一部分：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks a lot like the Ruby code and behaves very similarly to it. Constructors
    are a special beast in JavaScript and much has been written about their usage
    or non-usage. In a lot of cases, the idea of a class of objects being related
    by common functionality is a good idiom to use, and modern JavaScript engines
    were built with this is mind. So don't fear constructors, but be aware of their
    special use of the keyword `new` and the confusion they might cause around new
    developers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像Ruby代码，并且行为与其非常相似。构造函数在JavaScript中是一个特殊的存在，关于它们的使用或不使用已经有很多文章写过。在很多情况下，对象类的共同功能是一个很好的习惯用法，并且现代JavaScript引擎是以此为初衷构建的。所以不要害怕构造函数，但要注意它们对`new`关键字的特殊使用以及它们可能对新开发人员造成的困惑。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A lot has been written about the problems with `new` in JavaScript. For more
    information and the best information about the internals of JavaScript as a language,
    read *JavaScript: The Good Parts*, *Douglas Crockford*, *O''Reilly*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '关于JavaScript中`new`的问题已经有很多文章写过。要了解更多关于JavaScript语言内部的信息和最佳信息，请阅读《JavaScript:
    The Good Parts》，作者Douglas Crockford，O''Reilly出版社。'
- en: Inheritance and why you won't need it
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承以及为什么你不需要它
- en: Of course, just the construction of classes and their usage is only a part of
    being an OO (object-oriented) language. Especially in Java, it is very common
    to build quite complex inheritance hierarchies that allow common functionality
    to be shared across objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅构建类和它们的使用只是成为面向对象语言的一部分。特别是在Java中，构建相当复杂的继承层次结构是非常常见的，允许共同功能在对象之间共享。
- en: The basic concept of inheritance is that all the methods of the parent are also
    available on the child.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的基本概念是父类的所有方法也都可以在子类上使用。
- en: Modeling patterns beyond inheritance
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模模式超越继承
- en: '|   | *Favor ''object composition'' over ''class inheritance''.* |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   | *更倾向于''对象组合''而不是''类继承''。* |   |'
- en: '|   | --*Gang of Four 1995:20* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   | --*《设计模式》1995:20* |'
- en: Even though inheritance is possible in JavaScript, it is not necessarily the
    best route to go down for designing when an application like it is stated in the
    *Gang of Four*. Inheritance creates a very strong bond between the parent class
    and its children; this in itself means a leak of knowledge in parts of the system
    that it should not. Inheritance is the strongest possible form of coupling between
    two objects, and coupling itself should always be a very deliberate choice. Deep
    inheritance trees quickly make a piece of software very resistant to change as
    the changes tend to ripple through the whole system. There is a bigger problem
    so as well—as JavaScript does not do compile time checking of the interface and
    relationships, it is easier for those parts to get out of sync, and cause bugs
    in the system, than in more static languages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在JavaScript中可以实现继承，但这并不一定是设计应用程序时最好的方法，就像《四人帮》中所说的那样。继承在父类和子类之间创建了非常强的联系；这本身意味着系统的某些部分泄漏了不应该知道的知识。继承是两个对象之间最强的耦合形式，耦合本身应该是一个非常慎重的选择。深层次的继承树很快会使软件变得非常难以改变，因为改变往往会在整个系统中产生连锁反应。还有一个更大的问题——由于JavaScript不会对接口和关系进行编译时检查，所以这些部分很容易不同步，导致系统中出现错误，而在更静态的语言中则不会出现这种情况。
- en: For those reasons, and also due to the fact that classical inheritance is rarely
    needed in a dynamic language like JavaScript, inheritance is almost never used.
    There are other patterns that have been hinted at already to counter the need
    for inheritance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，也由于在像JavaScript这样的动态语言中很少需要经典继承，继承几乎从不使用。已经有其他模式来对抗继承的需求。
- en: The object composition
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象组合
- en: 'What can we do when we don''t want to share functionality via inheritance?
    The easiest way to go is to pass the object that already implements the functionality
    we need and use it directly, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想通过继承共享功能时，最简单的方法是传递已经实现我们需要的功能的对象，并直接使用它，例如：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A notification is a very simple object that manages the notifications for a
    part of the system; it does not concern itself greatly with how notifications
    are saved for later processing but simply delegates this to a store object that
    by default is implemented as an array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是一个非常简单的对象，它管理系统的一部分的通知；它并不关心通知如何保存以供以后处理，而只是将这个任务委托给默认情况下实现为数组的存储对象。
- en: Delegating to native types is normally done a lot, but this for all other objects
    that are created by the programmer. Composition like this has the big advantage
    that it eases testing especially when the dependencies are passed in, like in
    the example just given, we can simply replace the store object in our tests with
    something that ensures the right calls have been made.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给原生类型通常会经常发生，但这对于程序员创建的所有其他对象来说都是如此。这种组合有一个很大的优势，特别是在依赖项被传入时，它可以很容易地进行测试，就像刚才给出的例子中，我们可以在测试中用确保正确调用的东西替换存储对象。
- en: Polymorphism without inheritance
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有继承的多态性
- en: '|   | *When I see a bird that walks like a duck and swims like a duck and quacks
    like a duck, I call that bird a duck.* |   |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|   | *当我看到一只走起来像鸭子、游泳像鸭子、嘎嘎叫的鸟时，我就称那只鸟为鸭子。* |   |'
- en: '|   | --*Michael Heim* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Michael Heim* |'
- en: 'Another reason for inheritance in languages such as Java is the need for polymorphism.
    The idea is that a method should be implemented differently in different objects.
    In classical inheritance combined with type checking, this means that the objects
    on which the method is called need to have a common ancestor or interface because
    the type checker will complain otherwise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java等语言中继承的另一个原因是多态性的需求。这个想法是一个方法在不同的对象中应该有不同的实现。在经典继承结合类型检查的情况下，这意味着调用方法的对象需要有一个共同的祖先或接口，因为否则类型检查器会抱怨：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can pass both a `SwordMaster` class or an `AxeMaster` class to somebody
    in need in order for an orc to guard them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`SwordMaster`类或`AxeMaster`类传递给需要的人，以便兽人保护他们：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This kind of overhead is not needed in a language that supports duck typing.
    In JavaScript, we can just write this without the need for an interface, both
    orcs can just be plain JavaScript objects, as shown in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持鸭子类型的语言中不需要这种开销。在JavaScript中，我们可以直接写这个，而不需要接口，两个兽人可以直接作为普通的JavaScript对象，就像下面的例子中所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Master` object being guarded can now just call the method needed on each
    guard without the need for a matching type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被守护的“大师”对象现在可以直接调用每个守卫所需的方法，而无需匹配类型：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Duck typing means that an object is defined by what it can do rather than what
    it is. We already saw this behavior when building our own very simple mocks. As
    long as the method is defined on the object, it doesn't matter what its type is
    when we call it, so there is really no need to have a common ancestor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型意味着一个对象的定义取决于它能做什么，而不是它是什么。当构建我们自己的非常简单的模拟时，我们已经看到了这种行为。只要方法在对象上被定义，当我们调用它时，它的类型就不重要，因此没有必要有一个共同的祖先。
- en: Due to the very dynamic nature of JavaScript and the availability of duck typing,
    the need for inheritance is very much obviated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的非常动态的特性和鸭子类型的可用性，继承的需求很大程度上被消除了。
- en: Applying object design to the domain
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象设计应用到领域中
- en: With an understanding of conceptual object design, we need to apply all the
    concepts to our domain. We continue modeling the prisoner transfer we started.
    So far, we have an entry point to the application module that will ultimately
    handle this. From the tests, we know that the prisoner transfer relies on a prisoner
    and a dungeon object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了概念性对象设计之后，我们需要将所有概念应用到我们的领域中。我们继续对我们开始的囚犯转移进行建模。到目前为止，我们有一个应用模块的入口点，最终将处理这个问题。从测试中，我们知道囚犯转移依赖于囚犯和地牢对象。
- en: Building a system on simple objects
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在简单对象上构建系统
- en: So let's walk through what the prisoner transfer needs to do and what its collaborators
    are. Previously, we identified that the prisoner transfer will need a prisoner,
    obviously, and a target dungeon to transfer to, and the prisoner transfer should
    manage everything else. It is important to think about what the minimal input
    is from a user perspective to limit the API surface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看看囚犯转移需要做什么，以及它的合作者是谁。之前，我们确定囚犯转移显然需要囚犯和目标地牢进行转移，而囚犯转移应该管理其他一切。重要的是要考虑从用户角度来看最小的输入是什么，以限制API的表面。
- en: Of course the prisoner transfer, which is a service in DDD speak, needs more
    collaborators to really fulfill its purpose. First is a reference to the local
    dungeon to acquire resources such as orcs to act as keepers, carriages to move
    the prisoner, and possibly more. A goal of a managed transfer is also to notify
    the other dungeon, so we also need the means to notify them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，囚犯转移，在领域驱动设计中是一个服务，需要更多的合作者来真正实现其目的。首先是参考本地地牢以获取资源，例如兽人充当看守，马车运送囚犯，可能还有其他资源。管理转移的目标还包括通知其他地牢，因此我们还需要通知它们的手段。
- en: 'As we found out in the previous chapters, the concept of notifications is not
    well understood yet, so for now we can assume that there will be a service that
    allows us to send a message to a target, for a specific reason. We can program
    against the abstraction of a messaging service, allowing us to further specify
    what we are going to need out of the system. Bringing all this together and flushing
    it out brings us to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中发现的那样，通知的概念尚未被很好地理解，因此我们现在可以假设将有一个服务，允许我们向目标发送消息，出于特定的原因。我们可以针对消息服务的抽象进行编程，从而进一步指定我们将从系统中需要什么。将所有这些结合起来并加以完善，将我们带到了以下结论：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All calls are just simple calls to objects that can have a stand-in of a simple
    plain JavaScript object during the tests:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有调用都只是对对象的简单调用，在测试期间可以使用简单的普通JavaScript对象代替：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Returning plain objects with the functionality needed, which we will ultimately
    make their own modules based on the design being mocked up now, is all there is
    to creating the roles of the collaborators:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有所需功能的普通对象，最终我们将根据现在设计的模拟创建它们自己的模块，这就是创建合作者角色的全部内容。
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This top-level design really brings us along the way to create the underlying
    functionality. We can already see very clearly what we need from a notification
    system, and flushing out the transfer itself to perform its duties will tell us
    a lot more about the other collaborators as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顶层设计确实帮助我们创建基础功能。我们已经非常清楚地看到了我们从通知系统中需要什么，以及如何使转移本身执行其职责将告诉我们更多关于其他合作者的信息。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you have a solid foundation on how we can model
    the prisoner transfer inside the system. We used a very simple design with the
    least amount of tooling overhead possible. Our system leverages the dynamic nature
    of JavaScript to create simple stubs for objects we haven't created, yet, and
    we were able to validate the first understanding we discussed in our previous
    research.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您对我们如何在系统内建模囚犯转移有了坚实的基础。我们使用了非常简单的设计，尽可能减少了工具开销。我们的系统利用了JavaScript的动态特性，为我们尚未创建的对象创建了简单的存根，并且我们能够验证我们在先前研究中讨论的第一个理解。
- en: In the next chapter, we are going to further explore the other roles in the
    system. We focus on classifying them in domain-driven design terms so we can reuse
    the patterns explored by others in the space. We are also going to focus more
    on the language to foster further communication and how it can work with those
    patterns to allow very clear communication in the domain.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨系统中的其他角色。我们将专注于用领域驱动设计术语对它们进行分类，以便我们可以重用空间中其他人探索的模式。我们还将更加关注语言，以促进进一步的沟通，以及如何与这些模式一起工作，以在领域中实现非常清晰的沟通。
