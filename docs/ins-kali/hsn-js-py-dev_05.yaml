- en: Data and Your Friend, JSON
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和你的朋友，JSON
- en: It's time to learn the specifics of how JavaScript deals with data internally.
    Most of these structures are (nearly) identical to Python, but there are differences
    in syntax and usage. We touched on them in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar*, but now it's time to take a deeper dive into how we work with data and
    use methods and properties. Understanding how to work with data is foundational
    to using JavaScript, especially when doing advanced work such as working with
    APIs and Ajax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习JavaScript如何内部处理数据的具体细节了。这些结构大多数（几乎）与Python相同，但在语法和用法上有所不同。我们在[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中提到过，*Nitty-Gritty
    Grammar*，但现在是时候深入了解如何处理数据、使用方法和属性了。了解如何处理数据是使用JavaScript的基础，特别是在进行高级工作，比如处理API和Ajax时。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Data types – both JavaScript and Python are dynamically typed!
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型 - JavaScript和Python都是动态类型的！
- en: Exploring data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据类型
- en: Arrays and sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和集合
- en: Objects and JSON
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和JSON
- en: The HTTP verbs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP动词
- en: API calls from the frontend – Ajax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端的API调用 - Ajax
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Clone or download the repository for this book from GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers) and look
    through the `Chapter-4` material.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub上克隆或下载本书的存储库[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers)，并查看`Chapter-4`的材料。
- en: Data types – both JavaScript and Python are dynamically typed!
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型 - JavaScript和Python都是动态类型的！
- en: 'In [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty Grammar**,*
    we discussed using `typeof()` to ascertain what a variable''s data type is and
    using `let` and `const` to define them. There''s an interesting fact about JavaScript
    that Python shares: both are dynamically typed. As opposed to statically typed
    languages such as Java, JavaScript''s variable types can change over the course
    of a program. This is one reason why `typeof()` can come in handy.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中，*Nitty-Gritty Grammar*，我们讨论了使用`typeof()`来确定变量的数据类型，并使用`let`和`const`来定义它们。关于JavaScript有一个有趣的事实，它与Python共享：它们都是动态类型的。与Java等静态类型语言相反，JavaScript的变量类型可以在程序运行过程中改变。这就是为什么`typeof()`会有用的一个原因。
- en: 'Let''s take a look at a quick example contrasting JavaScript with Java:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的例子，对比JavaScript和Java：
- en: '| **Java** | **JavaScript** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **Java** | **JavaScript** |'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If we tried to run the Java code, we'd get an error stating that the types are
    incompatible. In Java, *variables* have a type. When we run the JavaScript code,
    however, everything's just fine. In JavaScript, *values* have a type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行Java代码，我们会得到一个错误，指出类型不兼容。在Java中，*变量*有一个类型。然而，当我们运行JavaScript代码时，一切都很顺利。在JavaScript中，*值*有一个类型。
- en: It's also important to know that JavaScript is *weakly typed*, which means that
    implicit conversion between data types is allowed in most cases. If we recall
    the loose and strict equality operators from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, weak typing is why current best practices specify using
    strict equality checking wherever possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还要知道JavaScript是*弱类型*的，这意味着在大多数情况下允许数据类型之间的隐式转换。如果我们回想一下[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中的宽松和严格相等运算符，*Nitty-Gritty
    Grammar*，弱类型是为什么当前的最佳实践规定在尽可能使用严格相等检查。
- en: 'If we take a look at a few languages on the scales of strong/weak and dynamic/static,
    we can plot the languages on an axis like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下一些语言在强/弱和动态/静态方面的比较，我们可以将这些语言绘制在这样一个轴上：
- en: '![](assets/bb1f8ae0-83e2-4a6b-8bb6-1a37426c00a2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb1f8ae0-83e2-4a6b-8bb6-1a37426c00a2.png)'
- en: Figure 4.1 – Axes of typing
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 类型的轴
- en: JavaScript style usually advocates for descriptive names rather than shorthand
    names. One of the reasons why this is acceptable is that often, JavaScript code
    is *minified* before it goes to production. It's not exactly like compiling, but
    it does condense whitespace and rename variables to be condensed. We'll discuss
    some of these build processes in [Chapter 16](e9e24fd5-967a-4853-88af-15a31a29f5cd.xhtml), *Enter
    Webpack, *when we discuss webpack.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript风格通常倡导使用描述性名称而不是简写名称。这是可以接受的原因之一是，通常情况下，JavaScript代码在进入生产之前会被*缩小*。这并不完全像编译，但它确实压缩空白并重命名变量以被压缩。当我们讨论webpack时，我们将在[第16章](e9e24fd5-967a-4853-88af-15a31a29f5cd.xhtml)，*进入webpack*中讨论一些这些构建过程。
- en: 'OK, so JavaScript is dynamically and weakly typed. What does that mean in practice?
    The short answer is this: be careful! It''s very easy to get your types mixed
    up in a comparison operator or, even worse, accidentally cast a variable to a
    different type. It gives us much more flexibility as we''re writing our program,
    but it can also be a curse. Some developers like to use Hungarian notation ([https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation))
    to help differentiate variable types, but this isn''t common practice in JavaScript.
    Probably the best way to help yourself and your colleagues keep your types correct
    is to be explicit with your variable names.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以JavaScript是动态和弱类型的。这在实践中意味着什么？简短的答案是：要小心！在比较运算符中很容易混淆类型，甚至更糟糕的是，意外地将变量转换为不同的类型。在编写程序时，这给了我们更多的灵活性，但它也可能是一个诅咒。一些开发人员喜欢使用匈牙利命名法（[https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation)）来帮助区分变量类型，但这在JavaScript中并不常见。帮助自己和同事保持正确类型的最好方法可能是在变量名中明确表示类型。
- en: Exploring data types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据类型
- en: 'Let''s take a deeper dive into the primitive data types because they''ll be
    crucial to our work in JavaScript. We not only need to know *what* we''re using,
    but the *why* is also important. Our **primitives** are the building blocks of
    the rest of the language: Booleans, numbers, and strings. The rest of JavaScript
    is built upon these primitive data types. We''ll start with Booleans.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究原始数据类型，因为它们对我们在JavaScript中的工作至关重要。我们不仅需要知道我们正在使用的*是什么*，而且*为什么*也很重要。我们的**原始数据类型**是语言其余部分的构建块：布尔值、数字和字符串。JavaScript的其余部分都是建立在这些原始数据类型之上的。我们将从布尔值开始。
- en: Booleans
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: The **Boolean** is possibly the simplest and most universal data type since
    it's inherently tied to the 1s and 0s of binary logic. In JavaScript, a Boolean
    is written simply as `true` or `false`. It's not recommended to use `1` or `0`
    for Boolean values, as they'll be interpreted as numbers and thus fail strict
    equality. Boolean values are a specific data type, as opposed to in Python, where,
    at the core of the language, Boolean inherits from a number.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔值**可能是最简单和最通用的数据类型，因为它与二进制逻辑的1和0紧密相关。在JavaScript中，布尔值简单地写为`true`或`false`。不建议使用`1`或`0`作为布尔值，因为它们将被解释为数字，从而导致严格的相等失败。布尔值是一种特定的数据类型，与Python不同，在语言的核心部分，布尔值继承自数字。'
- en: 'Remember in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar,* where we learned that almost everything in JavaScript is an object?
    The same applies to Booleans. As you can see in the following screenshot, if you
    bring up the JavaScript console in your browser, chances are that it will autocomplete
    for you to see the methods available to you for Booleans:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中的*Nitty-Gritty Grammar*吗，我们在那里学到几乎所有JavaScript中的东西都是对象吗？布尔值也是如此。正如您在下面的屏幕截图中所看到的，如果您在浏览器中打开JavaScript控制台，很可能会自动完成，以便查看对于布尔值可用的方法：
- en: '![](assets/77521c80-1b46-4b99-a80e-590a5e05874c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/77521c80-1b46-4b99-a80e-590a5e05874c.png)'
- en: Figure 4.2 – Boolean autocomplete in Chrome
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - Chrome中的布尔自动完成
- en: Now, I doubt any of these methods are particularly useful to you, but it's a
    handy way to check what methods are available to you for a given variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我怀疑这些方法中没有一个对您特别有用，但这是一个方便的方法，可以检查对于给定变量可用的方法。
- en: Booleans only get us so far—it's time to look at **numbers** next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值只能带我们走这么远 - 是时候看看**数字**了。
- en: Numbers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'JavaScript doesn''t have a conception of different types of numbers such as
    integers, floats, or doubles—everything is simply a number. All the basic arithmetic
    methods are built-in, and the `Math` object provides the rest of the functionality
    you''d expect to find built into a programming language. Here''s an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有整数、浮点数或双精度等不同类型的数字概念 - 一切都只是一个数字。所有基本算术方法都是内置的，`Math`对象提供了您期望在编程语言中找到的其余功能。这是一个例子：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use scientific notation, as shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用科学计数法，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Numbers in JavaScript are not just any old numbers, but are, inherently, floats.
    To be technical, they are stored as double-precision floating-point numbers following
    the international IEEE 754 standard. However, this does lead to a couple of…interesting…quirks.
    Keep this in mind if you get strange results, such as in the following screenshot
    from the JavaScript console:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的数字不仅仅是任意的数字，而是固有的浮点数。从技术上讲，它们存储为遵循国际IEEE 754标准的双精度浮点数。然而，这确实导致了一些…有趣的…怪癖。如果您得到奇怪的结果，例如下面来自JavaScript控制台的屏幕截图中的结果，请记住这一点：
- en: '![](assets/e62bdb66-7599-428a-bda8-57b9f3e55912.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e62bdb66-7599-428a-bda8-57b9f3e55912.png)'
- en: Figure 4.3 – Floating-point precision error
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 浮点精度错误
- en: 'A rule of thumb is to think about what precision you want your calculations
    to be. You can use the `toPrecision()` method of a number to specify your precision
    and then the `parseFloat()` function, like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是考虑您希望进行计算的精度。您可以使用数字的`toPrecision()`方法指定您的精度，然后使用`parseFloat()`函数，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`toPrecision()` returns a string, which may seem counter-intuitive at first,
    but there''s a good reason for it. Let''s say you needed your number to have two
    decimal places (for example, to display dollars and cents). If you used `toPrecision()`
    on a number and it returned a number, if you were to do more calculations on the
    integer, it would render only the integer unless you manipulated the decimal places
    as well. There is some method to the madness.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`toPrecision()`返回一个字符串，这乍一看可能有些反直觉，但这有一个很好的理由。假设您需要您的数字有两位小数（例如，显示美元和美分）。如果您在数字上使用`toPrecision()`并返回一个数字，如果您对整数进行更多计算，它将仅呈现整数，除非您也操纵小数位。这其中是有一些方法的。'
- en: Next up: **strings**. We need to add some content to our programs!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是：**字符串**。我们需要向我们的程序添加一些内容！
- en: Strings
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Ah, the venerable string data type. It has some of the basics you''d expect,
    such as a `length` property and the `slice()` and `split()` methods, but two that
    always trip me up are `substr()` and `substring()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，可敬的字符串数据类型。它具有一些您期望的基本功能，例如`length`属性和`slice()`和`split()`方法，但总是让我困惑的两个是`substr()`和`substring()`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The difference between the two methods is that the first one specifies `(start,
    length)`, while the second specifies `(start, end index)`. A handy way to remember
    the difference is that `.substring()` has an "i" in the name, correlating with
    index—the place in the string at which to stop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法之间的区别在于第一个指定了`(start, length)`，而第二个指定了`(start, end index)`。记住区别的一个方便方法是`.substring()`在名称中有一个"i"，与索引相关
    - 在字符串中停止的位置。
- en: 'A new addition in ES6 that makes our life easier is template literals. Take
    a look at this log:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ES6中的一个新添加使我们的生活更轻松，那就是模板文字。看看这个日志：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It will work, but it''s a little clunky. Let''s use template literals:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但有点笨重。让我们使用模板文字：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two important things to note in this example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有两个重要的事情需要注意：
- en: The string starts and ends with a backtick, not a quote.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串以反引号开始和结束，而不是引号。
- en: The variables to insert are encased in `${ }`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要插入的变量被包含在`${ }`中。
- en: Template literals are handy, but they're not required. As you research code
    online when you run into problems, you will definitely see examples of the older,
    string-concatenated way of writing. However, keep in mind that this is an option
    for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字很方便，但不是必需的。当您遇到问题时，在网上研究代码时，您肯定会看到以前的字符串连接方式的示例。但是，请记住，这对您来说也是一种选择。
- en: Let's try our hand at an exercise!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个练习！
- en: Exercise – a basic calculator
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习-基本计算器
- en: With our knowledge of Booleans, numbers, and strings, let's build a basic calculator.
    Begin by cloning the repository at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们对布尔值、数字和字符串的了解，让我们构建一个基本的计算器。首先克隆存储库[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code)。
- en: 'You can safely ignore the HTML and CSS for the most part, but a readthrough
    of the HTML will help. Let''s take a look at the JavaScript:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以大部分时间安全地忽略HTML和CSS，但是阅读HTML将有所帮助。让我们来看看JavaScript：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is not an easy exercise for a beginner to JavaScript, so don't be afraid
    to check out the solution code and reverse-engineer it: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code)[.](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于初学JavaScript的人来说并不是一个容易的练习，所以不要害怕查看解决方案代码并进行逆向工程：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code)。
- en: Next, let's explore **arrays** and a new addition to ES6: **sets**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索**数组**和ES6的一个新添加：**集合**。
- en: Arrays and sets
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和集合
- en: Any programming language has some conception of an array or a *collection of
    item**s *that all share some common features or use. JavaScript has a few of them: **arrays **and **sets**.
    Both of these structures contain items, and in many ways, they are similar in
    usage, too, in that they can be enumerated, iterated over, and displayed for purposes
    of logical construction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言都有一些关于数组或*项目集合*的概念，它们都共享一些共同的特征或用途。JavaScript有一些这样的概念：**数组**和**集合**。这两种结构都包含项目，并且在许多方面它们的使用方式也相似，因为它们可以被枚举、迭代和显示以进行逻辑构建。
- en: Let's first look at arrays.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看数组。
- en: Arrays
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays can contain different data types. This is a fully viable array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含不同的数据类型。这是一个完全可行的数组：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It contains strings, numbers, Booleans, `null`, and an object. This is fine!
    While in practice you may not be mixing data types, there's nothing preventing
    you from doing so.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含字符串、数字、布尔值、`null`和一个对象。这没问题！虽然在实践中，您可能不会混合数据类型，但没有什么可以阻止您这样做。
- en: 'There is a quirk about using `typeof()` on arrays: since they''re not true
    primitives, `typeof(myArray)` will return `object`. You should keep that in mind
    as you write JavaScript.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typeof()`对数组有一个怪癖：因为它们不是真正的原始值，`typeof(myArray)`将返回`object`。在编写JavaScript时，您应该记住这一点。
- en: As we saw before in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, `.push()` and `.pop()` are two of the most useful array
    methods, to add and remove items from an array, respectively. There are a good
    number of other methods available, though. Let's take a look at a few.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml)中看到的，*Nitty-Gritty Grammar*，`.push()`和`.pop()`是最有用的数组方法之一，分别用于向数组添加和删除项目。还有很多其他可用的方法。让我们来看看其中的一些。
- en: 'To create an array, we can do so as in the previous code or simply as `const
    myArray = []`. Now, while we can modify the values inside an array, we can declare
    it as a `const` because, for most purposes, we wouldn''t want to let the program
    completely redefine it. We can still manipulate the values inside the array; we
    just don''t want to destroy and recreate it. Let''s continue with our array with
    items from the preceding example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数组，我们可以像以前的代码一样做，也可以简单地写成`const myArray = []`。现在，虽然我们可以修改数组中的值，但我们可以将其声明为`const`，因为在大多数情况下，我们不希望让程序完全重新定义它。我们仍然可以操作数组中的值；我们只是不想破坏和重新创建它。让我们继续使用前面示例中的数组项：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember that arrays are zero-indexed, so our counting begins at `0`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组是从零开始索引的，所以我们的计数从`0`开始。
- en: 'To remove an element from the end of an array, we use `.pop()`, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组末尾删除一个元素，我们使用`.pop()`，如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To remove an object from the beginning of an array, use `.shift()`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组开头删除一个对象，使用`.shift()`，如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Be aware that all of these methods introduced so far mutate the original array
    directly. `.pop()` and `.shift()` return the excised value, not the array itself.
    This distinction is important because not all array methods behave this way. Let''s
    take a look at `slice` and `splice`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，到目前为止介绍的所有这些方法都会直接改变原始数组。`.pop()`和`.shift()`返回被删除的值，而不是数组本身。这种区别很重要，因为并非所有的数组方法都是这样的。让我们来看看`slice`和`splice`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can look up the parameters for these two methods on the **MDN Web Docs**
    site. For the purposes of introducing these methods, just be aware that the behavior
    of methods on a variable can change from mutational to stable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**MDN Web Docs**网站上查找这两种方法的参数。为了介绍这些方法，只需知道变量上的方法的行为可以从变异变为稳定。
- en: Sets are closely related to arrays but have some slight differences. Let's take
    a look.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集合与数组密切相关，但有一些细微的差别。让我们来看看。
- en: Sets
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are a compound data type introduced in ES6\. A set is an array with duplicates
    removed and that prohibits adding duplicates. Try the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是ES6中引入的一种复合数据类型。集合是一个删除了重复项并禁止添加重复项的数组。尝试以下代码：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`myArray` will have a length of 8, while `mySet` will have a length of 7—even
    *after* trying to add `''goodbye''`. JavaScript''s `.add()` method of a set will
    first test to be sure a unique value is being added. Note the `new` keyword and
    the capitalization of the data type; this is not unique to creating sets, but
    it is important. In ES5 and before, it was common practice to declare new variables
    this way, but that practice is now considered legacy except for in a few instances.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`myArray`的长度为8，而`mySet`的长度为7——即使在尝试添加`''goodbye''`之后也是如此。JavaScript的集合`.add()`方法首先会测试确保正在添加的是唯一值。请注意`new`关键字和数据类型的大写；这不是创建集合的唯一方式，但很重要。在ES5及之前，声明新变量的常见做法是这样的，但现在除了少数情况外，这种做法被认为是遗留的。'
- en: There's a common introductory-level JavaScript question in interviews that asks
    you to deduplicate an array. You can use a **set** to do this in one fell swoop
    instead of iterating through the array and checking each value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，有一个常见的初级JavaScript问题，要求你对数组进行去重。您可以使用**set**一次性完成这个操作，而不是遍历数组并检查每个值。
- en: While there are many possible solutions to deduplicating an array without using
    sets, let's take a look at a fairly basic example that uses the `.sort()` method.
    As you can expect from the name, this method will sort an array in ascending order.
    This approach is best used if you know the array will contain the same data type
    of strings or numbers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多可能的解决方案可以在不使用集合的情况下对数组进行去重，但让我们看一个使用`.sort()`方法的相当基本的例子。正如您可以从名称中期望的那样，这个方法将按升序对数组进行排序。如果您知道数组将包含相同数据类型的字符串或数字，则最好使用这种方法。
- en: 'Consider the following array:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数组：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We know a deduplicated, sorted array should look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道去重、排序后的数组应该如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can test it as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样测试：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s try it without using sets. Here is one approach that uses a deduplicating
    function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试不使用集合。这是一种使用去重函数的方法：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go ahead and take a look: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 继续看一下：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html)。
- en: 'What''s the output? We should get an array with a length of 3, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是什么？我们应该得到一个长度为3的数组，如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The raw approach is a bit more complex, right? Sets are a much more user-friendly
    way of deduplicating an array. Objects are another type of collection in JavaScript.
    As promised, here's a deeper dive into them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原始方法稍微复杂一些，对吧？集合是一种更加用户友好的数组去重方式。对象是JavaScript中的另一种集合类型。正如承诺的那样，这里有一个更深入的介绍。
- en: Objects and JSON
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和JSON
- en: 'Objects! Objects are at the core of JavaScript. As mentioned before in [Chapter
    3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty Grammar*, almost
    everything in JavaScript is, at its core, an object. Objects may be intimidating
    at first, but they''re easy enough to grasp in theory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对象！对象是JavaScript的核心。如前所述，在《第3章》*Nitty-Gritty Grammar*中，几乎JavaScript中的所有东西，从本质上讲，都是对象。对象可能一开始会让人望而生畏，但在理论上它们很容易理解：
- en: 'Here''s the skeleton of an object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对象的骨架：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An object is a collection of *key/value pairs*. They''re useful for many reasons,
    especially to contain and organize data. Let''s look at the example of Captain
    Picard from the [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一组*键/值对*。它们有很多用途，特别是用来包含和组织数据。让我们来看一下《第3章》中关于Captain Picard的例子，*Nitty-Gritty
    Grammar*：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we saw, we can use dot notation to access the properties of an object, like
    so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以使用点表示法来访问对象的属性，就像这样：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can also use other data types as values, as with `captain.seniorStaff`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其他数据类型用作值，就像`captain.seniorStaff`一样。
- en: 'As with everything else, objects also have their own methods. One of the most
    handy ones is `.hasOwnProperty()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他所有东西一样，对象也有自己的方法。其中最方便的之一是`.hasOwnProperty()`：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s try our array deduplication again, but this time, let''s leverage
    objects to create a hashmap:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试数组去重，但这次让我们利用对象来创建一个哈希映射：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s take a peek: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html).
    Now, it''s not immediately obvious, but this approach is nearly twice as fast
    as the deduplication method we explored before. Why? In short, an object''s values
    can be accessed immediately in O(1) time versus iterating through the whole array
    in O(n). If you''re unfamiliar with Big O notation, which is a fuzzy way to calculate
    code complexity, here''s a good primer: [https://www.topcoder.com/blog/big-o-notation-primer/](https://www.topcoder.com/blog/big-o-notation-primer/).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html)。现在，这种方法几乎比我们之前探讨的去重方法快了近一倍，虽然这并不是立即显而易见的。为什么呢？简而言之，对象的值可以立即在O(1)时间内访问，而不是在O(n)时间内遍历整个数组。如果您对大O符号不熟悉，这是一种计算代码复杂性的模糊方式，这里有一个很好的入门：[https://www.topcoder.com/blog/big-o-notation-primer/](https://www.topcoder.com/blog/big-o-notation-primer/)。
- en: Let's take a side-by-side comparison of the two approaches with an array of
    length 24,975.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将两种方法与一个长度为24,975的数组进行对比。
- en: The first implementation, [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html), will
    result in a time between 5 and 8 milliseconds (your mileage may vary).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实现，[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html)，将在5到8毫秒之间（结果可能有所不同）。
- en: However, by using a hashmap with an object, we can reduce our runtime by at
    least a few milliseconds: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用带有对象的哈希映射，我们可以将运行时间减少至少几毫秒：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html)。
- en: Now, a few milliseconds may seem insignificant (and impossible to distinguish
    with the eye) but think about an operation that needs to run over and over against
    datasets of a similar length. The savings add up.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几毫秒可能看起来微不足道（并且不可能用肉眼区分），但想想一个需要反复运行的操作，针对相似长度的数据集。节省的时间会累积起来。
- en: You can take a peek at [https://stackoverflow.com/a/9229821/2581282](https://stackoverflow.com/a/9229821/2581282)
    for some more ideas and explanations for this problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看[https://stackoverflow.com/a/9229821/2581282](https://stackoverflow.com/a/9229821/2581282)了解更多关于这个问题的想法和解释。
- en: Next, we're going to examine something that makes JavaScript...well, *JavaScript!*
    Its notion of inheritance and classes is quite different from other languages.
    Let's dive in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究一些使JavaScript...嗯，*JavaScript*！它的继承和类的概念与其他语言有很大不同。让我们深入了解一下。
- en: Prototypal inheritance
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型继承
- en: 'Inheritance in JavaScript really is one of its major strengths. Instead of
    classical class-based inheritance, JavaScript uses **prototypal** inheritance.
    (Protip: it''s pronounced *pro-to-TYPE-al* not *pro-to-TYPICAL.*) That''s because
    it uses the object''s prototype as a template. Do you remember previously when
    we worked with the methods of a string and a number in the console and found a
    bunch of methods available to us even on a simple data type? Well, we can go further
    than that.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的继承确实是它的主要优势之一。JavaScript使用**原型**继承，而不是经典的基于类的继承。（专业提示：它的发音是*pro-to-TYPE-al*而不是*pro-to-TYPICAL*。）这是因为它使用对象的原型作为模板。你还记得之前我们在控制台中使用字符串和数字的方法，并发现即使在简单的数据类型上，我们也有许多可用的方法吗？嗯，我们可以做得更多。
- en: 'Fundamental to the concept of prototypal inheritance in JavaScript is the prototype
    chain, which tells us what we have access to in terms of methods. Let''s take
    a look at a diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的原型继承概念中，原型链是基本的，它告诉我们在方法方面我们可以访问什么。让我们看一下图表：
- en: '![](assets/81656623-0365-4bb7-81ad-178cea0103d9.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81656623-0365-4bb7-81ad-178cea0103d9.png)'
- en: Figure 4.4 – The prototype chain
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 原型链
- en: 'So, what does this mean? Consider `Alice`: we can see that this variable is
    a string as it descends from the `String` prototype. So, translated into code,
    we can say the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么？考虑`Alice`：我们可以看到这个变量是一个字符串，因为它是从`String`原型继承而来的。因此，翻译成代码，我们可以这样说：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What will we get in the console? Simply `Alice`. We've given the *property*
    of `name` to our `Alice` string object. Now, let's take a look at this mysterious
    `sayHello()` method in the prototype. What do you think would happen if we executed
    the following?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台中会得到什么？只是`Alice`。我们给了我们的`Alice`字符串对象`name`的*属性*。现在，让我们来看看原型中这个神秘的`sayHello()`方法。如果我们执行以下操作，你认为会发生什么？
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you guessed that we would get an undefined error on the `sayHello()` function,
    you'd be correct. We haven't defined it yet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜到我们在`sayHello()`函数上会得到一个未定义的错误，那么你是正确的。我们还没有定义它。
- en: 'Here''s how we do so by modifying the `String` prototype:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过修改`String`原型来实现的：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, in our console, we will get `My name is Alice`. OK, so what happened?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的控制台中，我们将得到`My name is Alice`。好的，发生了什么？
- en: By directly modifying the `String` prototype and adding a `sayHello()` method,
    we can use this method on any string and access its properties. Just like we used
    dot notation before, we can use the `this` keyword to refer to properties of the
    object within which we are working. Consequently, `this.name` works inside our
    prototype and equals `Alice.name`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接修改`String`原型并添加一个`sayHello()`方法，我们可以在任何字符串上使用这个方法并访问它的属性。就像我们之前使用点表示法一样，我们可以使用`this`关键字来引用我们正在工作的对象的属性。因此，在我们的原型中，`this.name`有效并等于`Alice.name`。
- en: 'Now, you may be thinking *this seems a little dangerous*. We''re modifying
    a base data type, and if we attempted to call `.sayHello()` on a string that *doesn''t*
    have a `name` property, we''ll get a nice huge error. You''re correct! There''s
    a better way to do this that still utilizes the concept of prototypal inheritance.
    Take a peek at this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想*这似乎有点危险*。我们正在修改一个基本数据类型，如果我们尝试在*没有*`name`属性的字符串上调用`.sayHello()`，我们将得到一个很大的错误。你是对的！有一种更好的方法可以做到这一点，而且仍然利用了原型继承的概念。看一下这个：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we would expect, we get `My name is Alice.` and `My name is Bob.`. We didn't
    need to define `sayHello()` twice; rather, `Alice` and `Bob` *inherited* the method
    from `Person`. Efficiency!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，我们得到了`My name is Alice.`和`My name is Bob.`。我们不需要两次定义`sayHello()`；相反，`Alice`和`Bob`从`Person`那里*继承*了这个方法。效率！
- en: Now we're going to talk about Jason. Jason who? No, no, the object-based data
    structure called **JSON** is what we're going to examine next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要谈谈杰森。杰森是谁？不，不，我们要检查的是基于对象的数据结构称为**JSON**。
- en: JSON
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: '**JSON** (pronounced *jay-sohn* or *jason*) stands for **JavaScript Object
    Notation**. If you''ve seen it in the field before, you may know that it''s often
    used as a convenient transfer format with APIs. We''ll discuss APIs a little more
    in a bit, but for now, let''s understand what JSON is and why it''s useful.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**（发音为*jay-sohn*或*jason*）代表**JavaScript对象表示法**。如果你以前在现场看到过它，你可能知道它经常被用作方便的API传输格式。我们稍后会更详细地讨论API，但现在让我们了解一下JSON是什么，以及它为什么有用。'
- en: 'Let''s take a look at what it looks like. We''ll be using the **Star Wars API**
    (**SWAPI**) ([https://swapi.dev](https://swapi.dev)) as a convenient read-only
    API. Take a peek at this example result: [https://swapi.dev/api/people/1/?format=json](https://swapi.dev/api/people/1/?format=json):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是什么样子的。我们将使用**星球大战API**（**SWAPI**）([https://swapi.dev](https://swapi.dev))作为一个方便的只读API。看一下这个例子的结果：[https://swapi.dev/api/people/1/?format=json](https://swapi.dev/api/people/1/?format=json)：
- en: '![](assets/120bc245-bca3-4ee3-9307-b2bdc4966f25.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/120bc245-bca3-4ee3-9307-b2bdc4966f25.png)'
- en: Figure 4.5 – SWAPI people instance
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - SWAPI人物实例
- en: 'One of the great things about JSON is that it''s fairly legible, as it doesn''t
    have lots of nodes and formatting like XML. However, in its raw format, as in
    the preceding screenshot, it''s still a jumble. Browsers have great tools to parse
    JSON into a legible tree. Take a minute to find and install one for your browser
    and then visit the previous API call. Now, your response should be formatted as
    in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的一个很棒的地方是它相当易读，因为它没有像XML那样有很多节点和格式。然而，在它的原始格式中，就像前面的截图一样，它仍然是一团糟。浏览器有很好的工具可以将JSON解析成易读的树形结构。花点时间找一个安装到你的浏览器上，然后访问之前的API调用。现在，你的响应应该格式化如下截图所示：
- en: '![](assets/660ec1ae-7931-4696-b340-89ecda9ba8e0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/660ec1ae-7931-4696-b340-89ecda9ba8e0.png)'
- en: Figure 4.6 – SWAPI formatted
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 - SWAPI格式化
- en: That's a lot more legible now. Say hi to Luke Skywalker!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更容易阅读了。向卢克·天行者问好！
- en: 'One of the design decisions made by the authors of this API was to include
    in each result only the unique data of the resource in the result. For example,
    for `homeworld`, it doesn''t spell out "Tatooine" but rather provides a **URI**
    (**U****niform Resource Identifier**) for a *planet* resource. We can see that
    `homeworld` and its data are key-value pairs, just like other objects, `films`
    is an array of strings, and the entire dataset is an object with curly braces
    at the beginning and end. That''s all there is to JSON: properly formatted JavaScript
    objects.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API的作者之一的设计决定是，每个结果中只包含资源的唯一数据。例如，对于`homeworld`，它不会明确写出“塔图因”，而是提供了一个**URI**（**U****niform
    Resource Identifier**）用于一个*planet*资源。我们可以看到`homeworld`及其数据是键值对，就像其他对象一样，`films`是一个字符串数组，整个数据集是一个用大括号括起来的对象。这就是JSON的全部内容：格式正确的JavaScript对象。
- en: Now it's time to dive into a couple of pieces of information about how the internet
    works to inform our use of JavaScript, APIs, and the greater web in general.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解一些关于互联网如何工作的信息，以便更好地使用JavaScript、API和整个网络。
- en: The HTTP verbs
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP动词
- en: 'Let''s take a quick look at the HTTP verbs that allow us to communicate back
    and forth with APIs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下允许我们与API来回通信的HTTP动词：
- en: '| **HTTP Verb** | **CRUD Equivalent** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **CRUD等效** |'
- en: '| POST | Create |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| POST | 创建 |'
- en: '| GET | Read |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| GET | 读取 |'
- en: '| PUT | Update/Replace |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 更新/替换 |'
- en: '| PATCH | Update/Modify |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | 更新/修改 |'
- en: '| DELETE | Delete |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 删除 |'
- en: While the actual verbs used in an API depend on the API's design, these are
    the standard REST terms that many APIs today use. **REST** stands for **REpresentational**
    **State** **Transfer** and is a standard description of how to format APIs. Now,
    REST or RESTful APIs don't always have to communicate with JSON—REST is agnostic
    to format. Let's take a look at API calls in practice.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然API中使用的实际动词取决于API的设计，但这些是许多API今天使用的标准REST术语。**REST**代表**REpresentational**
    **State** **Transfer**，是关于如何格式化API的标准描述。现在，REST或RESTful API并不总是要使用JSON进行通信 - REST对格式是不可知的。让我们看看实际中的API调用。
- en: API calls from the frontend – Ajax
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端的API调用 - Ajax
- en: '**Ajax** (also spelled AJAX) stands for **Asynchronous JavaScript and XML**.
    These days, however, you''re more likely to work with JSON than XML, so the name
    is a bit misleading. On to code: take a look at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html).
    Open this locally, and in your developer tools, you should see a JSON object as
    follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax**（也拼写为AJAX）代表**异步JavaScript和XML**。然而，现在，你更可能使用JSON而不是XML，所以这个名字有点误导。现在看代码：看一下[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html)。在本地打开这个链接，在你的开发者工具中，你应该看到一个JSON对象，如下所示：'
- en: '![](assets/3bf95b87-4173-419f-9bd5-b7d93eb3ff40.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3bf95b87-4173-419f-9bd5-b7d93eb3ff40.png)'
- en: Figure 4.7 – SWAPI Ajax result
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 - SWAPI Ajax结果
- en: 'Congratulations! You''ve made your first Ajax call! Let''s break down the following
    code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了你的第一个Ajax调用！让我们来分解一下下面的代码：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`fetch` is a fairly new API in ES6 that essentially replaces the older, more
    complicated way of making Ajax calls with `XMLHttpRequest`. As you can see, the
    syntax is fairly concise. What might not be obvious is the role that the `.then()`
    functions play—or even what they are.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`是ES6中一个相当新的API，它基本上取代了使用`XMLHttpRequest`进行Ajax调用的旧方法，这种语法相当简洁。也许不太明显的是`.then()`函数的作用，甚至它们是什么。'
- en: '`.then()` is an example of a Promise. We won''t discuss Promises at length
    right now, but the basic premise hinges upon the asynchronous part of JavaScript.
    Essentially, a Promise says: "Execute this code, and I promise that at a later
    time, I''ll provide you with more data. Don''t block code execution here."'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`.then()`是Promise的一个例子。我们现在不会详细讨论Promise，但基本前提是建立在JavaScript的异步部分。基本上，Promise说：“执行这段代码，我保证以后会提供更多的数据给你。不要在这里阻塞代码执行。”'
- en: Open [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html)
    locally in your browser. You should see Loading Data… for a quick second, and
    then the JSON displayed. You can use your browser's developer tools to throttle
    your internet connection to see this in action.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中本地打开[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html)。你应该会看到“加载数据…”一闪而过，然后显示JSON。您可以使用浏览器的开发者工具来限制您的互联网连接，以查看它的运行情况。
- en: 'Here''s the JavaScript code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JavaScript代码：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Don't worry too much about the `document.querySelector` lines—we'll cover those
    in detail in [Chapter 6](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml), *The Document
    Object Model (DOM)*. For now, just understand that they're used to place information
    in an HTML document. Let's throttle our connection using the developer tools down
    to Slow 3G or similar. When we refresh, we should see a flash of Awaiting Headline…,
    then Luke Skywalker, followed by Loading Data…, and *then*, a few seconds later,
    the JSON as text.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心`document.querySelector`行——我们将在[第6章](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml)中详细介绍这些内容，*文档对象模型（DOM）*。现在，只需了解它们用于在HTML文档中放置信息。让我们使用开发者工具将连接节流到慢3G或类似的速度。当我们刷新时，我们应该看到“等待标题…”的闪烁，然后是“卢克·天行者”，接着是“加载数据…”，*然后*，几秒钟后，JSON作为文本。
- en: So, how does this work? The line of code to change Awaiting Headline… to Luke
    Skywalker comes after the Ajax call. So why does the headline change *before*
    the data section? The answer is *Promises*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？将代码行从“等待标题…”更改为“卢克·天行者”是在Ajax调用之后。那么为什么标题在数据部分之前就改变了呢？答案是*Promise*。
- en: Using `fetch`, we establish that we're inherently using asynchronous data, and
    thus the `.then()` statements tell us what we can do *after* the Promised statement
    resolves. It frees the program to continue on to other parts of the program. In
    fact, we could make multiple fetch calls that may return at various times, and
    still not block our user's use of the program. Asynchronicity is a fundamental
    concept when working with modern JavaScript, so take your time understanding it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fetch`，我们确定我们本质上使用的是异步数据，因此`.then()`语句告诉我们在承诺语句解析*之后*我们可以做什么。它使程序可以继续进行程序的其他部分。事实上，我们可以进行多次fetch调用，这些调用可能在不同的时间返回，但仍然不会阻止用户使用程序。异步性是使用现代JavaScript时的一个基本概念，所以请花时间理解它。
- en: Next, let's get some experience with actually *using *APIs! It's time to really
    get our hands dirty and interact with not just local code but also external code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过实际*使用*API来获得一些经验！现在是真正动手并与不仅是本地代码而且外部代码互动的时候了。
- en: SWAPI lab
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SWAPI实验室
- en: Let's get some hands-on practice with this API. What we're going to do is fairly
    inelegant for the moment, but it will show us how to use asynchronous behavior
    to our advantage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个API进行一些实践。我们现在要做的事情可能有些不够优雅，但它将向我们展示如何利用异步行为来获得优势。
- en: 'You should expect to see something like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该期望看到类似于这样的东西：
- en: '![](assets/d0bfb7d6-c598-4c5d-a379-56e4e22f3dd7.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0bfb7d6-c598-4c5d-a379-56e4e22f3dd7.png)'
- en: Figure 4.8 – SWAPI Promises result
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – SWAPI Promises result
- en: Keep in mind that since we're using Promises and have to iterate over the `films`
    array, the order of films may vary. You can choose to order them by film number
    if you wish.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于我们使用了Promise并且必须迭代`films`数组，电影的顺序可能会有所不同。如果愿意，您可以选择按电影编号排序它们。
- en: 'This lab will require nested Promises and some syntaxes we haven''t covered
    yet, so give yourself plenty of time to experiment if you''d like to do this lab:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室将需要嵌套的Promise和一些我们尚未涵盖的语法，所以如果你想做这个实验，请给自己足够的时间来实验：
- en: 'Starter code: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code)
- en: 'Solution code: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code)
- en: As with any lab, keep in mind that the solution code won't match your code,
    but is meant as a resource for thought processes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何实验室一样，请记住解决方案代码可能与您的代码不匹配，但它是作为思考过程的资源。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Data is at the heart of every program, and your JavaScript programs are no
    different:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是每个程序的核心，你的JavaScript程序也不例外：
- en: JavaScript is loosely typed, which means variable types can mutate if needed.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是弱类型的，这意味着变量类型可以根据需要变化。
- en: Booleans are simple true/false statements.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值是简单的真/假语句。
- en: Numbers are non-differentiated between integers, floats, or other types of numbers.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字之间没有区分整数、浮点数或其他类型的数字。
- en: Arrays and sets can contain a lot of data and make organizing our data easier.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和集合可以包含大量数据，并且使我们组织数据更容易。
- en: Objects are key-value pairs that efficiently store data for O(1) retrieval.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是高效存储数据的键值对。
- en: API calls are actually not that scary!
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API调用实际上并不可怕！
- en: We've taken a closer look at data types, APIs, and JSON. What we've discovered
    is that data is very flexible in JavaScript, up to and including manipulating
    the prototypes of the objects themselves. Taking a look at JSON and APIs, we've
    successfully used `fetch()` to perform our first API calls.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仔细研究了数据类型、API和JSON。我们发现JavaScript中的数据非常灵活，甚至可以操作对象本身的原型。通过查看JSON和API，我们成功地使用`fetch()`执行了我们的第一个API调用。
- en: In the next chapter, we'll dive further into writing JavaScript to make a more
    interesting application, as well as understanding the details of how to construct
    one!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步深入编写 JavaScript，制作一个更有趣的应用程序，并了解如何构建一个应用程序的细节！
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'For the following questions, select the correct option:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下问题，请选择正确的选项：
- en: 'JavaScript is inherently:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 本质上是：
- en: Synchronous
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步的
- en: Asynchronous
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步的
- en: Both
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都是
- en: 'A `fetch()` call returns a:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetch()` 调用返回：'
- en: '`then`'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`然后`'
- en: '`next`'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个
- en: '`finally`'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`最后`'
- en: Promise
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 承诺
- en: 'With prototypal inheritance, we can (select all):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过原型继承，我们可以（全选）：
- en: Add methods to a base data type.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向基本数据类型添加方法。
- en: Subtract methods from a base data type.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基本数据类型中减去方法。
- en: Rename our data type.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名我们的数据类型。
- en: Cast our data into another format.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的数据转换为另一种格式。
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the preceding code, what will be the expected output?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上面的代码中，预期输出是什么？
- en: '`1`'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '`false`'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`0`'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`true`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, what's the best way to output `Will Riker`?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的代码中，输出 `Will Riker` 的最佳方法是什么？
- en: '`Riker.sayHello()`'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Riker.sayHello()`'
- en: '`console.log(Riker.name)`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`console.log(Riker.name)`'
- en: '`console.log(Riker.this.name)`'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`console.log(Riker.this.name)`'
- en: '`Officer.Riker.name()`'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Officer.Riker.name()`'
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information on statically versus dynamically typed languages, you can
    refer to [https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b](https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有关静态与动态类型语言的更多信息，您可以参考 [https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b](https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b)。
- en: To find out more about Hungarian notation, refer to [https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于匈牙利命名法的信息，请参考 [https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation)。
