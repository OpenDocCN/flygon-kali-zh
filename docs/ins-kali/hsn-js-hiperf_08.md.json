["```js\n{\n    \"name\" : \"Bob\",\n    \"birth\" : \"01/02/1993\",\n    \"address\" : {\n        \"zipcode\" : 11111,\n        \"street\" : \"avenue of av.\",\n        \"streetnumber\" : 123,\n        \"state\" : \"CA\",\n        \"country\" : \"US\"\n    },\n    \"contact\" : {\n        \"primary\" : \"111-222-3333\",\n        \"secondary\" : \"444-555-6666\",\n        \"email\" : \"bob@example.com\"\n    }\n}\n```", "```js\nconst send = new Array(100);\nsend.fill(json);\nconsole.log('size of over the wire buffer is: ',\n Buffer.from(JSON.stringify(send)).byteLength);\n```", "```js\ngzipSync(Buffer.from(JSON.stringify(send))).byteLength\n```", "```js\nexport const encodeString = function(str) {\n    const buf = Buffer.from(str);\n    const len = Buffer.alloc(4);\n    len.writeUInt32BE(buf.byteLength);\n    return Buffer.concat([Buffer.from([0x03]), len, buf]);\n}\nexport const encodeNumber = function(num) {\n    const type = Math.round(num) === num ? 0x01 : 0x02;\n    const buf = Buffer.alloc(4);\n    buf.writeInt32BE(num);\n    return Buffer.concat([Buffer.from([type]), buf]); \n}\n```", "```js\nexport const CONSTANTS = {\n    object : 0x04,\n    number : 0x01,\n    floating : 0x02,\n    string : 0x03,\n    header : 0x10,\n    body : 0x11\n}\n```", "```js\nimport { Transform } from 'stream';\nimport { encodeString, encodeNumber } from './helper.js';\n\nexport default class SimpleSchemaWriter extends Transform {\n}\n```", "```js\n// inside our SimpleSchemaWriter class\nconstructor(opts={}) {\n    opts.writableObjectMode = true;\n    super(opts);\n}\n```", "```js\n// inside of our SimpleSchemaWriter class\n#encode = function(data) {\n    return typeof data === 'string' ?\n            encodeString(data) :\n            typeof data === 'number' ?\n            encodeNumber(data) :\n            null;\n}\n```", "```js\n_transform(chunk, encoding, callback) {\n    const buf = [];\n    buf.push(Buffer.from([0x10]));\n    for(const key of Object.keys(chunk)) { \n        const item = this.#encode(key);\n        if(item === null) {\n            return callback(new Error(\"Unable to parse!\"))\n        }\n        buf.push(item);\n    }\n    buf.push(Buffer.from([0x10])); \n    buf.push(Buffer.from([0x11]));\n    for(const val of Object.values(chunk)) { \n        const item = this.#encode(val);\n        if(item === null) {\n            return callback(new Error(\"Unable to parse!\"))\n        }\n        buf.push(item);\n    }\n    buf.push(Buffer.from([0x11]));\n    this.push(Buffer.concat(buf)); \n    callback();\n}\n```", "```js\nimport { CONSTANTS } from './helper.js';\n\nexport const decodeString = function(buf) {\n    if(buf[0] !== CONSTANTS.string) {\n        return false;\n    }\n    const len = buf.readUInt32BE(1);\n    return buf.slice(5, 5 + len).toString('utf8');\n}\nexport const decodeNumber = function(buf) {\n    return buf.readInt32BE(1);\n}\n```", "```js\nimport { Transform } from 'stream'\nimport { decodeString, decodeNumber, CONSTANTS } from './helper.js'\n\nexport default class SimpleSchemaReader extends Transform {\n    #obj = {}\n    #inHeaders = false\n    #inBody = false\n    #keys = []\n    #currKey = 0\n}\n```", "```js\n#decode = function(chunk, index, type='headers') { \n        const item = chunk[index] === CONSTANTS.string ?\n            decodeString(chunk.slice(index)) :\n            decodeNumber(chunk.slice(index, index + 5));\n\n        if( type === 'headers' ) {\n            this.#obj[item] = null;\n        } else {\n            this.#obj[this.#keys[this.#currKey]] = item;\n        }\n        return chunk[index] === CONSTANTS.string ?\n            index + item.length + 5 :\n            index + 5;\n    }\n    constructor(opts={}) {\n        opts.readableObjectMode = true;\n        super(opts);\n    }\n    _transform(chunk, encoding, callback) {\n        let index = 0; //1\n        while(index <= chunk.byteLength ) {\n        }\n    }\n```", "```js\n// in the while loop\nconst byte = chunk[index];\nif( byte === CONSTANTS.header ) { \n    this.#inHeaders = !this.#inHeaders\n    index += 1;\n    continue;\n} else if( byte === CONSTANTS.body ) { \n    this.#inBody = !this.#inBody\n    if(!this.#inBody ) { \n        this.push(this.#obj);\n        this.#obj = {};\n        this.#keys = [];\n        this.#currKey = 0;\n        return callback();\n    } else {\n        this.#keys = Object.keys(this.#obj); \n    }\n    index += 1;\n    continue;\n}\nif( this.#inHeaders ) { \n    index = this.#decode(chunk, index);\n} else if( this.#inBody ) {\n    index = this.#decode(chunk, index, 'body');\n    this.#currKey += 1;\n} else {\n    callback(new Error(\"Unknown state!\"));\n}\n```", "```js\nconst keys = ['item1', 'item2', 'item3'];\nconst values = [1, 'what', 2.2];\nconst tempObj = {};\nfor(let i = 0; i < keys.length; i++) {\n    tempObj[keys[i]] = null;\n}\nfor(let i = 0; i < values.length; i++) {\n    tempObj[keys[i]] = values[i];\n}\n```", "```js\nimport encoder from './encoder.js'\nimport decoder from './decoder.js'\nimport json from './test.json'\n\nconst enc = new encoder();\nconst dec = new decoder();\nenc.pipe(dec);\ndec.on('data', (obj) => {\n    console.log(obj);\n});\nenc.write(json);\n```", "```js\n{\n    \"item1\" : \"item\",\n    \"item2\" : 12,\n    \"item3\" : 3.3\n}\n```", "```js\n{\n    \"item1\" : \"item\",\n    \"item2\" : 120000000,\n    \"item3\" : 3.3,\n    \"item4\" : 120000000,\n    \"item5\" : 120000000,\n    \"item6\" : 120000000\n}\n```", "```js\n> npm install what-the-pack\n```", "```js\nimport MessagePack from 'what-the-pack';\nimport json from '../schema/test.json';\n\nconst { encode, decode } = MessagePack.initialize(2**22);\nconst encoded = encode(json);\nconst decoded = decode(encoded);\nconsole.log(encoded.byteLength, Buffer.from(JSON.stringify(decoded)).byteLength);\nconsole.log(encoded, decoded);\n```", "```js\npackage exampleProtobuf;\nsyntax = \"proto3\";\n\nmessage TestData {\n    string item1 = 1;\n    int32  item2 = 2;\n    float  item3 = 3;\n}\n```", "```js\nprotobuf.load('test.proto', function(err, root) {\n    if( err ) throw err;\n    const TestTypeProto = \n     root.lookupType(\"exampleProtobuf.TestData\");\n    if( TestTypeProto.verify(json) ) {\n        throw Error(\"Invalid type!\");\n    }\n    const message2 = TestTypeProto.create(json);\n    const buf2 = TestTypeProto.encode(message2).finish();\n    const final2 = TestTypeProto.decode(buf2);\n    console.log(buf2.byteLength, \n     Buffer.from(JSON.stringify(final2)).byteLength);\n    console.log(buf2, final2);\n});\n```", "```js\nconst TestType = new protobuf.Type(\"TestType\");\nTestType.add(new protobuf.Field(\"item1\", 1, \"string\"));\nTestType.add(new protobuf.Field(\"item2\", 2, \"int32\"));\nTestType.add(new protobuf.Field(\"item3\", 3, \"float\"));\n```"]