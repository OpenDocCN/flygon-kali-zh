- en: Chapter 8. Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 反应扩展
- en: 'In this chapter we will look at another interesting .NET library that helps
    us create asynchronous programs, the Reactive Extensions (or Rx). You will learn
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看另一个有趣的.NET库，它可以帮助我们创建异步程序，即反应扩展（或Rx）。您将学习以下配方：
- en: Converting a collection to asynchronous `Observable`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合转换为异步`Observable`
- en: Writing custom `Observable`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义`Observable`
- en: Using `Subjects`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Subjects`
- en: Creating an `Observables` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Observables`对象
- en: Using LINQ queries against an `Observable` collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ查询对`Observable`集合
- en: Creating asynchronous operations with Rx
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rx创建异步操作
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As we have already learned, there are several approaches to create asynchronous
    programs in .NET and C#. One of them is event-based asynchronous pattern, which
    was already mentioned in the previous chapters. The initial goal of introducing
    events was to simplify implementation of the `Observer` design pattern. This pattern
    is common for implementing notifications between objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经了解的，有几种方法可以在.NET和C#中创建异步程序。其中之一是基于事件的异步模式，这在前几章中已经提到过。引入事件的最初目标是简化实现`Observer`设计模式。这种模式通常用于在对象之间实现通知。
- en: When we discussed the Task Parallel Library, we noticed that the event's main
    shortcoming is their inability to be effectively composed with each other. The
    other drawback is that the Event-based Asynchronous Pattern is not supposed to
    be used to deal with the sequence of notifications. Imagine that we have `IEnumerable<string>`
    that gives us string values. However, when we iterate over it, we do not know
    how much time one iteration will take. It could be slow, and if we use the regular
    `foreach` or other synchronous iteration constructs, we will block our thread
    until we have the next value. This situation is called the **pull-based** approach
    when we as a client pull values from the producer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论任务并行库时，我们注意到事件的主要缺点是它们无法有效地相互组合。另一个缺点是基于事件的异步模式不应该用来处理通知的顺序。想象一下，我们有一个`IEnumerable<string>`给我们字符串值。然而，当我们遍历它时，我们不知道一个迭代会花费多少时间。它可能很慢，如果我们使用常规的`foreach`或其他同步迭代结构，我们将阻塞我们的线程，直到我们有下一个值。这种情况被称为**拉取式**方法，当我们作为客户端从生产者那里拉取值时。
- en: The opposite approach is the **push-based** approach when the producer notifies
    the client about new values. This allows offloading the work to the producer,
    while the client is free to do anything else in the time it waits for another
    value. Therefore, the goal is to get something like the asynchronous version of
    `IEnumerable`, which produces a sequence of values and notifies the consumer about
    each item in the sequence, when the sequence completes, or when an exception has
    been thrown.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是**推送式**方法，当生产者通知客户端有新值时。这允许将工作卸载给生产者，而客户端在等待另一个值时可以自由做任何其他事情。因此，目标是获得类似于异步版本的`IEnumerable`，它产生一系列值，并在序列中的每个项目完成时通知消费者，或者在抛出异常时通知消费者。
- en: The .NET Framework starting from version 4.0 contains the definition of the
    interfaces `IObservable<out T>` and `IObserver<in T>` that together represent
    the asynchronous push-based collection and its client. They are coming from the
    library called Reactive Extensions (or simply Rx) that was created inside Microsoft
    to help effectively compose the sequence of events and actually all other types
    of asynchronous programs using the observable collections. The interfaces were
    included into the .Net Framework, but their implementations and all other mechanics
    are still distributed separately in the Rx library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework从4.0版本开始包含了接口`IObservable<out T>`和`IObserver<in T>`的定义，它们一起代表了异步推送式集合及其客户端。它们来自一个名为Reactive
    Extensions（简称Rx）的库，该库是在微软内部创建的，旨在帮助有效地组合事件序列以及实际上所有其他类型的使用可观察集合的异步程序。这些接口被包含在.NET
    Framework中，但它们的实现和所有其他机制仍然分别在Rx库中分发。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reactive Extensions is a cross-platform library in the first place. There are
    libraries for .NET 3.5, Silverlight, and Windows Phone. It is also available in
    JavaScript, Ruby, and Python. It is also open source; you can find Reactive extensions
    source code for .NET on the CodePlex website and other implementations on GitHub.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 反应扩展首先是一个跨平台库。有.NET 3.5、Silverlight和Windows Phone的库。它也可用于JavaScript、Ruby和Python。它也是开源的；你可以在CodePlex网站上找到.NET的反应扩展源代码，也可以在GitHub上找到其他实现。
- en: The most amazing thing is that the observable collections are compatible with
    LINQ, and therefore, we are able to use declarative queries to transform and compose
    those collections in an asynchronous manner. This also makes it possible to use
    the extension methods to add functionality to the Rx programs the same way it
    is used in the usual LINQ providers. Reactive extensions also support transition
    from all asynchronous programming patterns (including the Asynchronous Programming
    Model, the Event-based Asynchronous Pattern, and the Task Parallel Library) to
    observable collections, and it supports its own way of running asynchronous operations,
    which is still quite similar to TPL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人惊讶的是，可观察集合与LINQ兼容，因此我们能够使用声明性查询以异步方式转换和组合这些集合。这也使得可以使用扩展方法来为Rx程序添加功能，就像在通常的LINQ提供程序中使用的方式一样。反应扩展还支持从所有异步编程模式（包括异步编程模型、基于事件的异步模式和任务并行库）过渡到可观察集合，并支持其自己的运行异步操作的方式，这仍然与TPL非常相似。
- en: The Reactive Extensions library is a very powerful and complex instrument, worthy
    of writing a separate book. In this chapter I would like to review the most useful
    scenario, that is, how to work with asynchronous event sequences effectively.
    We will observe key types of the Reactive Extensions framework, learn to create
    sequences and manipulate them in different ways, and finally, check how we could
    use Reactive Extensions to run asynchronous operations and manage their options.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Extensions库是一个非常强大和复杂的工具，值得写一本单独的书。在本章中，我想回顾最有用的场景，即如何有效地处理异步事件序列。我们将观察Reactive
    Extensions框架的关键类型，学习如何创建序列并以不同的方式操纵它们，最后，检查我们如何使用Reactive Extensions来运行异步操作并管理它们的选项。
- en: Converting a collection to asynchronous Observable
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集合转换为异步Observable
- en: This recipe walks through how to create an observable collection from an `Enumerable`
    class and how to process it asynchronously.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇将介绍如何从`Enumerable`类创建一个可观察集合，并异步处理它。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本篇，您需要Visual Studio 2012。不需要其他先决条件。本篇的源代码可以在`BookSamples\Chapter8\Recipe1`中找到。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to create an observable collection from an `Enumerable` class
    and process it asynchronously, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何从`Enumerable`类创建一个可观察集合并异步处理它，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Add reference to the **Reactive Extensions Main Library** NuGet package.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对**Reactive Extensions Main Library** NuGet包添加引用。
- en: Right-click on the **References** folder in the project and select the **Manage
    NuGet Packages…** menu option.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中右键单击**引用**文件夹，然后选择**管理NuGet包...**菜单选项。
- en: 'Now add your preferred reference to the **Reactive Extensions - Main Library**
    NuGet package. You can use search in the **Manage NuGet Packages** dialog, as
    shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加您首选的**Reactive Extensions - Main Library** NuGet包引用。您可以在**管理NuGet包**对话框中使用搜索，如下面的屏幕截图所示：
- en: '![How to do it...](img/7644OT_08_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7644OT_08_01.jpg)'
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We simulate a slow enumerable collection with the `EnumerableEventSequence`
    method. Then we iterate it in the usual `foreach` cycle and we can see that it
    is actually slow; we wait for each iteration to complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EnumerableEventSequence`方法模拟一个慢的可枚举集合。然后我们在通常的`foreach`循环中对其进行迭代，我们可以看到它实际上是慢的；我们等待每次迭代完成。
- en: We then convert this enumerable collection to `Observable` with the help of
    the `ToObservable` extension method from the Reactive Extensions library. Next,
    we subscribe to the updates of this observable collection, providing the `Console.Write`
    method as the action, which will be executed on each update of the collection.
    As a result we get exactly the same behavior as before; we wait for each iteration
    to complete, because we use the main thread to subscribe to the updates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Reactive Extensions库中的`ToObservable`扩展方法将这个可枚举集合转换为`Observable`。接下来，我们订阅这个可观察集合的更新，提供`Console.Write`方法作为操作，这将在每次集合更新时执行。结果我们得到了与之前完全相同的行为；我们等待每次迭代完成，因为我们使用主线程订阅更新。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We wrap the subscription objects into using statements. Although it is not always
    necessary, disposing off the subscriptions is a good practice that will avoid
    you lifetime-related bugs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将订阅对象包装到使用语句中。虽然这并不总是必要的，但处理订阅是一个良好的实践，可以避免生命周期相关的错误。
- en: To make the program asynchronous, we use the `SubscribeOn` method providing
    it with the TPL task pool scheduler. This scheduler will place the subscription
    to the TPL task pool, offloading the work from the main thread. This allows us
    to keep the UI responsive and do something else, while the collection updates.
    To check this behavior, you could remove the last `Console.ReadLine` call from
    the code. When doing so we finish our main thread immediately, which forces all
    background threads (including the TPL task pool worker threads) to end as well,
    and we will get no output from the asynchronous collection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序异步，我们使用`SubscribeOn`方法，并提供TPL任务池调度程序。这个调度程序将订阅到TPL任务池，从主线程卸载工作。这使我们能够保持UI的响应性，并在集合更新时做其他事情。要检查这种行为，您可以从代码中删除最后一个`Console.ReadLine`调用。这样做会立即结束我们的主线程，这将迫使所有后台线程（包括TPL任务池工作线程）也结束，并且我们将得不到异步集合的输出。
- en: If we are using any UI framework, we have to interact with the UI controls only
    from within the UI thread. To achieve this, we should use the `ObserveOn` method
    with the corresponding scheduler. For Windows Presentation Foundation, we have
    the `DispatcherScheduler` class and the `ObserveOnDispatcher` extension method
    defined in a separate NuGet package named Rx-XAML, or Reactive Extensions XAML
    support library. For other platforms there are corresponding separate NuGet packages
    as well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任何UI框架，我们必须只在UI线程内与UI控件交互。为了实现这一点，我们应该使用相应的调度程序的`ObserveOn`方法。对于Windows
    Presentation Foundation，我们有`DispatcherScheduler`类和在名为Rx-XAML的单独NuGet包中定义的`ObserveOnDispatcher`扩展方法，或者Reactive
    Extensions XAML支持库。对于其他平台，也有相应的单独NuGet包。
- en: Writing custom Observable
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义Observable
- en: This recipe will describe how to implement the `IObservable<in T>` and `IObserver<out
    T>` interfaces to get the custom Observable sequence and properly consume it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇将描述如何实现`IObservable<in T>`和`IObserver<out T>`接口以获取自定义的Observable序列并正确消耗它。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe2`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，您需要Visual Studio 2012。不需要其他先决条件。此配方的源代码可以在`BookSamples\Chapter8\Recipe2`中找到。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To understand implementing the `IObservable<in T>` and `IObserver<out T>` interfaces
    to get the custom Observable sequence and consume it, perform the following steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何实现`IObservable<in T>`和`IObserver<out T>`接口以获取自定义的Observable序列并消费它，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Add reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe, for details
    on how to do this.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对**Reactive Extensions Main Library** NuGet包的引用。有关如何执行此操作的详细信息，请参阅*将集合转换为异步可观察对象*配方。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here we implement our observer first, simply printing out to the console the
    information about the next item from the observable collection, error, or sequence
    completion. It is a very simple consumer code and there is nothing special about
    it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先实现了我们的观察者，简单地将来自可观察集合的下一个项目的信息打印到控制台上，错误，或者序列完成。这是一个非常简单的消费者代码，没有什么特别之处。
- en: The interesting part is our observable collection implementation. We accept
    an enumeration of numbers into a constructor, and do not check it for null on
    purpose. When we have a subscribing observer, we iterate over this collection
    and notify the observer about each item in the enumeration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是我们的可观察集合实现。我们在构造函数中接受一个数字的枚举，并且故意不检查它是否为空。当我们有一个订阅的观察者时，我们遍历这个集合，并通知观察者枚举中的每个项目。
- en: Then we demonstrate the actual subscription. As we can see, the asynchrony is
    achieved by calling the `SubscribeOn` method, which is an extension method to
    `IObservable` and contains asynchronous subscription logic. We do not care about
    asynchrony in our observable collection; we use standard implementation from the
    Reactive Extensions library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们演示了实际的订阅。正如我们所看到的，通过调用`SubscribeOn`方法实现了异步，这是一个扩展方法，包含了异步订阅逻辑。我们不关心可观察集合中的异步性；我们使用了Reactive
    Extensions库中的标准实现。
- en: When we subscribe to the normal observable collection, we just get all the items
    from it. It is now asynchronous, so we need to wait for some time for the asynchronous
    operation to complete, and only then print the message and wait for the user input.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅普通的可观察集合时，我们只会得到其中的所有项目。现在它是异步的，所以我们需要等待一段时间，等待异步操作完成，然后才打印消息并等待用户输入。
- en: Finally we try to subscribe to the next observable collection, where we are
    iterating over a null enumeration and therefore getting a null reference exception.
    We see that the exception has been properly handled and the `OnError` method was
    executed to print out the error details.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试订阅下一个可观察集合，我们正在遍历一个空枚举，因此会得到一个空引用异常。我们看到异常已经被正确处理，并且执行了`OnError`方法来打印出错误详情。
- en: Using Subjects
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Subjects
- en: This recipe shows how to use the Subject type family from the Reactive Extensions
    library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用Reactive Extensions库中的Subject类型家族。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe3`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此配方，您需要Visual Studio 2012。不需要其他先决条件。此配方的源代码可以在`BookSamples\Chapter8\Recipe3`中找到。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To understand the use of the Subject type family from the Reactive Extensions
    library, perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使用Reactive Extensions库中的Subject类型家族，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对**Reactive Extensions Main Library** NuGet包的引用。有关如何执行此操作的详细信息，请参阅*将集合转换为异步可观察对象*配方。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this program we look through different variants of a Subject type family.
    Subject represents both the `IObservable` and `IObserver` implementations. This
    is useful in different proxy scenarios when we want to translate events from multiple
    sources to one stream, or vice versa, to broadcast event sequence to multiple
    subscribers. Subjects are also very convenient for experimenting with Reactive
    Extensions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们查看了Subject类型家族的不同变体。Subject代表了`IObservable`和`IObserver`的实现。在不同的代理场景中，当我们想要将来自多个来源的事件转换为一个流，或者反之亦然，将事件序列广播给多个订阅者时，这是非常有用的。Subject也非常方便用于对反应扩展进行实验。
- en: Let's start with the basic Subject type. It retranslates event sequence to subscribers
    as soon as they subscribe to it. In our case, the `A` string will not be printed
    out because the subscription happened after it was transmitted. Besides that,
    when we call the `OnCompleted`, or `OnError` methods on `Observable`, it stops
    further translation of event sequence, so the last string will also not be printed
    out.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的Subject类型开始。它会在订阅者订阅后立即将事件序列重新传递给订阅者。在我们的情况下，`A`字符串不会被打印出来，因为订阅发生在它被传输之后。此外，当我们在`Observable`上调用`OnCompleted`或`OnError`方法时，它会停止进一步传递事件序列，因此最后一个字符串也不会被打印出来。
- en: The next type, `ReplaySubject`, is quite flexible and allows us to implement
    three additional scenarios. First, it can cache all the events from the beginning
    of their broadcasting, and if we subscribe later, we will get all the preceding
    events first. This behavior is illustrated in the second example. Here, we shall
    have all four strings on the console, because the first event will be cached and
    translated to the latter subscriber.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类型`ReplaySubject`非常灵活，允许我们实现三种额外的场景。首先，它可以缓存从它们广播开始的所有事件，如果我们稍后订阅，我们将首先得到所有先前的事件。这种行为在第二个例子中有所体现。在这里，我们将在控制台上看到所有四个字符串，因为第一个事件将被缓存并转换给后来的订阅者。
- en: Then we can specify the buffer size and the time window size for `ReplaySubject`.
    In the next example, we set the subject to have a buffer for two events. If more
    events are broadcasted, only the last two will be retranslated to the subscriber.
    So here we will not see the first string, because we have `B` and `C` in the subject
    buffer when subscribing to it. The same is the case with a time window. We can
    specify that the Subject caches only events that happened less than a certain
    time ago, discarding the older ones. Therefore, in the fourth example, we shall
    see only the last two events; the older events did not fit into the time-window
    limit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以为`ReplaySubject`指定缓冲区大小和时间窗口大小。在下一个例子中，我们将主题设置为具有两个事件的缓冲区。如果广播了更多的事件，只有最后两个事件将被重新传递给订阅者。因此，在这里我们将看不到第一个字符串，因为当订阅它时，我们的主题缓冲区中有`B`和`C`。时间窗口也是一样的。我们可以指定主题只缓存在某个时间之前发生的事件，丢弃较旧的事件。因此，在第四个例子中，我们将只看到最后两个事件；较旧的事件不符合时间窗口限制。
- en: '`AsyncSubject` is something like a `Task` type from the Task Parallel Library.
    It represents a single asynchronous operation. If there are several events published,
    it waits for the event sequence completion and provides only the last event to
    the subscriber.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject`类似于任务并行库中的`Task`类型。它表示单个异步操作。如果有多个事件被发布，它会等待事件序列完成，并且只向订阅者提供最后一个事件。'
- en: '`BehaviorSubject` is quite similar to the `ReplaySubject` type, but it caches
    only one value and allows specifying a default value in case we did not send any
    notifications yet. In our last example, we shall see all the strings printed out,
    because we provided a default value, and all other events happened already after
    the subscription. If we move `behaviorSubject.OnNext("B");` line upwards below
    the `Default` event, it will replace the default value in the output.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`与`ReplaySubject`类型非常相似，但它只缓存一个值，并允许在我们尚未发送任何通知的情况下指定默认值。在我们的最后一个例子中，我们将看到所有的字符串被打印出来，因为我们提供了一个默认值，并且所有其他事件都发生在订阅之后。如果我们将`behaviorSubject.OnNext("B");`行向上移动到`Default`事件下面，它将替换输出中的默认值。'
- en: Creating an Observable object
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Observable对象
- en: This recipe will describe different ways to create an `Observable` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将描述创建`Observable`对象的不同方法。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need a running Visual Studio 2012\. No
    other prerequisites are required. The source code for this recipe could be found
    at `BookSamples\Chapter8\Recipe4`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤，你需要一个运行中的Visual Studio 2012。不需要其他先决条件。这个步骤的源代码可以在`BookSamples\Chapter8\Recipe4`中找到。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To understand different ways of creating an `Observable` object, perform the
    following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解创建`Observable`对象的不同方法，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: Add reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous Observable* recipe for details
    on how to do this.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对**Reactive Extensions Main Library** NuGet包的引用。有关如何执行此操作的详细信息，请参考*将集合转换为异步Observable*步骤。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we walk through different scenarios of creating `observables`. Most of
    this functionality is provided as static factory methods of the `Observable` type.
    The first two samples show how we can create an `Observable` method that produces
    a single value and one that produces no value. In the next example we use `Observable.Throw`
    to construct an `Observable` class that triggers the `OnError` handler of its
    observers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍创建`observables`的不同场景。大部分这些功能都是`Observable`类型的静态工厂方法提供的。前两个示例展示了如何创建一个产生单个值的`Observable`方法和一个不产生值的方法。在下一个示例中，我们使用`Observable.Throw`来构造一个触发其观察者的`OnError`处理程序的`Observable`类。
- en: The `Observable.Repeat` method represents an endless sequence. There are different
    overloads of this method; here, we constructed an endless sequence by repeating
    42 values. Then we use LINQ's `Take` method to take five elements from this sequence.
    `Observable.Range` represents a range of values, pretty much like `Enumerable.Range`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Repeat`方法表示一个无限序列。这个方法有不同的重载；在这里，我们通过重复42个值来构造一个无限序列。然后我们使用LINQ的`Take`方法从这个序列中取出五个元素。`Observable.Range`表示一个值的范围，就像`Enumerable.Range`一样。'
- en: The `Observable.Create` method supports more custom scenarios. There are a lot
    of overloads allowing us to use cancellation tokens and tasks, but let's look
    at the simplest one. It accepts a function, which accepts an instance of observer,
    and returns an `IDisposable` object representing a subscription. If we had any
    resources to cleanup, we would be able to provide the cleanup logic here, but
    we just return an empty disposable as we actually do not need it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Create`方法支持更多的自定义场景。有很多重载允许我们使用取消标记和任务，但让我们看看最简单的一个。它接受一个函数，该函数接受一个观察者实例，并返回一个表示订阅的`IDisposable`对象。如果我们有任何需要清理的资源，我们可以在这里提供清理逻辑，但我们只返回一个空的可处置对象，因为实际上我们并不需要它。'
- en: '`Observable.Generate` is another way to create a custom sequence. We must provide
    an initial value for a sequence, then a predicate that determines if we should
    generate more items, or complete the sequence. Then we provide an iteration logic,
    which is incrementing a counter in our case. The last parameter is a selector
    function, allowing us to customize the results.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.Generate`是创建自定义序列的另一种方法。我们必须为序列提供一个初始值，然后提供一个确定是否应生成更多项或完成序列的谓词。然后我们提供一个迭代逻辑，在我们的情况下是递增计数器。最后一个参数是一个选择器函数，允许我们自定义结果。'
- en: The last two methods deal with timers. `Observable.Interval` starts producing
    timer tick events with the `TimeSpan` period, and `Observable.Timer` specifies
    the startup time as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种方法处理定时器。`Observable.Interval`开始生成具有`TimeSpan`周期的定时器滴答事件，而`Observable.Timer`也指定了启动时间。
- en: Using LINQ queries against the observable collection
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对可观察集合使用LINQ查询
- en: This recipe shows how to use LINQ to query an asynchronous sequence of events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用LINQ来查询异步事件序列。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe5`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个示例，您需要Visual Studio 2012。不需要其他先决条件。此示例的源代码可以在`BookSamples\Chapter8\Recipe5`中找到。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand using LINQ queries against the observable collection, perform
    the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解针对可观察集合使用LINQ查询，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对**Reactive Extensions Main Library** NuGet包的引用。有关如何执行此操作的详细信息，请参阅*将集合转换为异步可观察*配方。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ability to use LINQ against the `Observable` event sequences is the main
    advantage of the Reactive Extensions framework. There are many different useful
    scenarios; unfortunately, it is impossible to show all of them here. I tried to
    provide a simple, yet very illustrative example, which does not have many complex
    details and shows the very essence of how a LINQ query could work when applied
    to asynchronous observable collections.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 针对`Observable`事件序列使用LINQ的能力是Reactive Extensions框架的主要优势。有许多不同的有用场景；不幸的是，这里不可能展示所有这些场景。我尝试提供一个简单但非常有说明性的示例，它没有太多复杂的细节，展示了当应用于异步可观察集合时，LINQ查询的工作原理的本质。
- en: First, we create an `Observable` event that generates a sequence of numbers,
    one number every 50 milliseconds, and we start from the initial value of zero,
    taking twenty-one of those events. Then, we compose LINQ queries to this sequence.
    First, we select only the even numbers from the sequence, then only the odd numbers,
    and then we concatenate these two sequences.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`Observable`事件，每50毫秒生成一个数字序列，从零开始，取其中的21个事件。然后，我们对这个序列进行LINQ查询。首先，我们只选择序列中的偶数，然后只选择奇数，然后我们连接这两个序列。
- en: The final query shows how to use a very useful method `Do`, which allows introducing
    side effects and, for example, logging each value from the resulting sequence.
    To run all queries, we create nested subscriptions, and because the sequences
    are initially asynchronous, we have to be very careful about the subscription's
    lifetime. The outer scope represents a subscription to the timer, the inner subscriptions
    deal with the combined sequence query and the side effects query, respectively.
    If we press *Enter* too early, we just unsubscribe from the timer and thus stop
    the demo.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的查询显示了如何使用非常有用的方法`Do`，它允许引入副作用，例如记录结果序列中的每个值。为了运行所有查询，我们创建了嵌套的订阅，因为序列最初是异步的，所以我们必须非常小心地处理订阅的生命周期。外部范围表示对定时器的订阅，内部订阅处理组合序列查询和副作用查询。如果我们过早按*Enter*键，我们只需取消订阅定时器，从而停止演示。
- en: When we run the demo, we see the actual process of how different queries interact
    in real time. We can see that our queries are lazy, and they start running only
    when we subscribe to their results. The timer events sequence is printed in the
    first column. When the even numbers query gets an even number, it prints it out
    as well using the `---` prefix to distinguish this sequence result from the first
    one. The final query results are printed to the right column.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行演示时，我们可以看到不同查询如何实时交互的实际过程。我们可以看到我们的查询是惰性的，它们只有在我们订阅它们的结果时才开始运行。定时器事件序列打印在第一列中。当偶数查询得到偶数时，它也打印出来，使用`---`前缀来区分这个序列结果和第一个序列结果。最终的查询结果打印到右列中。
- en: When the program runs, we can see that the timer sequence, the even numbers
    sequence, and the side effect sequence are running in parallel. Only the concatenation
    waits until the even numbers sequence is complete. If we do not concatenate those
    sequences, we will have four parallel sequences of events interacting with each
    other in the most effective way! This shows the real power of Reactive Extensions,
    and could be a good start to learn this library in depth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们可以看到定时器序列、偶数序列和副作用序列并行运行。只有连接等待偶数序列完成。如果我们不连接这些序列，我们将有四个并行事件序列相互交互的最有效方式！这显示了Reactive
    Extensions的真正力量，并且可能是深入学习这个库的良好起点。
- en: Creating asynchronous operations with Rx
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有Rx的异步操作
- en: This recipe shows how to create `Observable` from the asynchronous operations
    defined in other programming patterns.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何从其他编程模式中定义的异步操作中创建`Observable`。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe6`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照此示例操作，您需要Visual Studio 2012。不需要其他先决条件。此示例的源代码可以在`BookSamples\Chapter8\Recipe6`中找到。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to create asynchronous operations with Rx, perform the following
    steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用Rx创建异步操作，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对**Reactive Extensions Main Library** NuGet包添加引用。有关如何执行此操作的详细信息，请参阅*将集合转换为异步可观察对象*的示例。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows how to convert different types of asynchronous operations
    to an `Observable` class. The first code snippet in step 5 uses the `Observable.Start`
    method, which is quite similar to `Task.Run` from TPL. It starts an asynchronous
    operation that gives out a string result and then completes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了如何将不同类型的异步操作转换为`Observable`类。步骤5中的第一个代码片段使用了`Observable.Start`方法，这与TPL中的`Task.Run`非常相似。它启动一个给出字符串结果然后完成的异步操作。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I would strongly suggest using Task Parallel Library for asynchronous operations.
    Reactive Extensions supports this scenario as well, but to avoid ambiguity it
    is much better to stick with tasks when speaking about separate asynchronous operations
    and go with Rx only when we need to work with sequences of events. Another suggestion
    is to convert every type of separate asynchronous operation to tasks and only
    then convert a task to an `observable` class, if you need it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议使用任务并行库进行异步操作。Reactive Extensions也支持这种情况，但为了避免歧义，最好在单独的异步操作时坚持使用任务，并且只有在需要处理事件序列时才使用Rx。另一个建议是将每种类型的单独异步操作转换为任务，然后只有在需要时将任务转换为`observable`类。
- en: Then, we do the same with tasks and convert a task to an `Observable` method
    by simply calling the `ToObservable` extension method. The next code snippet shown
    in step 5 is about converting Asynchronous Programming Model pattern to `Observable`.
    Normally, you would convert APM to a task, and then a task to `Observable`. However,
    there is a direct conversion, and this example illustrates how to run an asynchronous
    delegate and wrap it into an `Observable` operation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用任务做同样的事情，并通过简单调用`ToObservable`扩展方法将任务转换为`Observable`方法。步骤5中显示的下一个代码片段是关于将异步编程模型模式转换为`Observable`。通常，您会将APM转换为任务，然后将任务转换为`Observable`。但是，这里有一个直接的转换，这个示例说明了如何运行一个异步委托并将其包装成`Observable`操作。
- en: The next part of the code snippet in step 5 shows that we are able to `await`
    an `Observable` operation. As we are not able to use the `async` modifier on an
    entry method such as `Main`, we introduce a separate method that returns a task
    and waits for this resulting task to complete inside the `Main` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5中代码片段的下一部分显示我们能够`await`一个`Observable`操作。由于我们无法在`Main`等入口方法上使用`async`修饰符，因此我们引入一个返回任务并等待结果任务完成的单独方法到`Main`方法中。
- en: The last part of this code snippet in step 5 is the same, but now we convert
    Event-based Asynchronous Pattern directly to an `Observable` class. We create
    a timer and consume its events for 5 seconds. We then dispose the timer to clean
    up the resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5中代码片段的最后部分是相同的，但现在我们直接将基于事件的异步模式转换为`Observable`类。我们创建一个计时器，并在5秒内使用其事件。然后我们释放计时器以清理资源。
