["```cs\nnamespace CalculatorImperative \n{ \n  partial class Form1 \n  { \n    private System.Windows.Forms.Button btn0; \n    private System.Windows.Forms.Button btn1; \n    private System.Windows.Forms.Button btn2; \n    private System.Windows.Forms.Button btn3; \n    private System.Windows.Forms.Button btn4; \n    private System.Windows.Forms.Button btn5; \n    private System.Windows.Forms.Button btn6; \n    private System.Windows.Forms.Button btn7; \n    private System.Windows.Forms.Button btn8; \n    private System.Windows.Forms.Button btn9; \n    private System.Windows.Forms.Button btnSwitchSign; \n    private System.Windows.Forms.Button btnDecimal; \n    private System.Windows.Forms.Button btnAdd; \n    private System.Windows.Forms.Button btnDivide; \n    private System.Windows.Forms.Button btnMultiply; \n    private System.Windows.Forms.Button btnSubstract; \n    private System.Windows.Forms.Button btnEquals; \n    private System.Windows.Forms.Button btnSqrt; \n    private System.Windows.Forms.Button btnPercent; \n    private System.Windows.Forms.Button btnInverse; \n    private System.Windows.Forms.Button btnDelete; \n    private System.Windows.Forms.Button btnClearAll; \n    private System.Windows.Forms.Button btnClearEntry; \n    private System.Windows.Forms.TextBox txtScreen; \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  partial class Form1 \n  { \n    private void InitializeComponent() \n    { \n      this.btn0.Name = \"btn0\"; \n      this.btn0.Click += \n        new System.EventHandler(this.btnNumber_Click); \n      this.btn1.Name = \"btn1\"; \n\n      // The rest of code can be found  \n      // in the downloaded source code \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void btnNumber_Click(object sender, EventArgs e) \n    { \n      Button btnNum = sender as Button; \n      int numValue; \n      switch (btnNum.Name) \n      { \n        case \"btn1\": \n          numValue = 1; \n          break; \n        case \"btn2\": \n          numValue = 2; \n          break; \n        case \"btn3\": \n          numValue = 3; \n          break; \n        case \"btn4\": \n          numValue = 4; \n          break; \n        case \"btn5\": \n          numValue = 5; \n          break; \n        case \"btn6\": \n          numValue = 6; \n          break; \n        case \"btn7\": \n          numValue = 7; \n          break; \n        case \"btn8\": \n          numValue = 8; \n          break; \n        case \"btn9\": \n          numValue = 9; \n          break; \n        default: \n          numValue = 0; \n          break; \n      } \n      CalcEngine.AppendNum(numValue); \n      UpdateScreen(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void btnFunction_Click(object sender, EventArgs e) \n    { \n      Button btnFunction = sender as Button; \n      string strValue; \n      switch (btnFunction.Name) \n      { \n        case \"btnSqrt\": \n          strValue = \"sqrt\"; \n          break; \n        case \"btnPercent\": \n          strValue = \"percent\"; \n          break; \n        case \"btnInverse\": \n          strValue = \"inverse\"; \n          break; \n        case \"btnDelete\": \n          strValue = \"delete\"; \n          break; \n        case \"btnSwitchSign\": \n          strValue = \"switchSign\"; \n          break; \n        case \"btnDecimal\": \n          strValue = \"decimal\"; \n          break; \n        default: \n          strValue = \"\"; \n          break; \n      } \n      CalcEngine.FunctionButton(strValue); \n      UpdateScreen(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void btnOperator_Click(object sender, EventArgs e) \n    { \n      Button btnOperator = sender as Button; \n      string strOperator = \"\"; \n      switch (btnOperator.Name) \n      { \n        case \"btnAdd\": \n          strOperator = \"add\"; \n          break; \n        case \"btnSubtract\": \n          strOperator = \"subtract\"; \n          break; \n        case \"btnMultiply\": \n          strOperator = \"multiply\"; \n          break; \n        case \"btnDivide\": \n          strOperator = \"divide\"; \n          break; \n      } \n      CalcEngine.PrepareOperation( \n        strOperator); \n      UpdateScreen(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void btnClear_Click(object sender, EventArgs e) \n    { \n      if (sender is System.Windows.Forms.Button) \n      { \n        Button btnClear = sender as Button; \n        switch (btnClear.Name) \n        { \n          case \"btnClearAll\": \n            CalcEngine.ClearAll(); \n            UpdateScreen(); \n            break; \n          case \"btnClearEntry\": \n            CalcEngine.Clear(); \n            UpdateScreen(); \n            break; \n        } \n      } \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void btnEquals_Click(object sender, EventArgs e) \n    { \n      //Attempt to solve the math \n      if (!CalcEngine.Solve()) \n      { \n        btnClearAll.PerformClick(); \n      } \n      UpdateScreen(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private void UpdateScreen() \n    { \n      txtScreen.Text = FormatDisplay( \n        Convert.ToString( \n        CalcEngine.GetDisplay())); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  public partial class Form1 : Form \n  { \n    private string FormatDisplay( \n      string str) \n    { \n      String dec = \"\"; \n      int totalCommas = 0; \n      int pos = 0; \n      bool addNegative = false; \n\n      if (str.StartsWith(\"-\")) \n      { \n        str = str.Remove(0, 1); \n        addNegative = true; \n      } \n\n      if (str.IndexOf(\".\") > -1) \n      { \n        dec = str.Substring( \n          str.IndexOf(\".\"), \n        str.Length - str.IndexOf(\".\")); \n        str = str.Remove( \n          str.IndexOf(\".\"), \n          str.Length - str.IndexOf(\".\")); \n      } \n\n      if (Convert.ToDouble(str) < \n        Math.Pow(10, 19)) \n      { \n        if (str.Length > 3) \n        { \n          totalCommas = \n            (str.Length - (str.Length % 3)) / 3; \n\n          if (str.Length % 3 == 0) \n          { \n            totalCommas--; \n          } \n\n          pos = str.Length - 3; \n          while (totalCommas > 0) \n          { \n            str = str.Insert(pos, \",\"); \n            pos -= 3; \n            totalCommas--; \n          } \n        } \n      } \n\n      str += \"\" + dec; \n      if (str.IndexOf(\".\") == -1) \n      { \n        str = str + \".\"; \n      } \n\n      if (str.IndexOf(\".\") == 0) \n      { \n        str.Insert(0, \"0\"); \n      } \n      else if (str.IndexOf(\".\") == \n        str.Length - 2 &&  \n        str.LastIndexOf(\"0\") ==  \n        str.Length - 1) \n      { \n        str = str.Remove(str.Length - 1); \n      } \n\n      if (addNegative) \n      { \n        str = str.Insert(0, \"-\"); \n      } \n\n      return str; \n    } \n  } \n} \n\n```", "```cs\nif (str.StartsWith(\"-\")) \n{ \n  str = str.Remove(0, 1); \n  addNegative = true; \n} \n\n```", "```cs\nif (str.IndexOf(\".\") > -1) \n{ \n  dec = str.Substring( \n    str.IndexOf(\".\"), \n    str.Length - str.IndexOf(\".\")); \n  str = str.Remove( \n    str.IndexOf(\".\"), \n    str.Length - str.IndexOf(\".\")); \n} \n\n```", "```cs\nif (Convert.ToDouble(str) <  \n  Math.Pow(10, 19)) \n{ \n  if (str.Length > 3) \n  { \n    totalCommas = \n      (str.Length - (str.Length % 3)) / 3; \n\n    if (str.Length % 3 == 0) \n    { \n      totalCommas--; \n    } \n\n    pos = str.Length - 3; \n    while (totalCommas > 0) \n    { \n      str = str.Insert(pos, \",\"); \n      pos -= 3; \n      totalCommas--; \n    } \n  } \n} \n\n```", "```cs\nstr += \"\" + dec; \nif (str.IndexOf(\".\") == -1) \n{ \n  str = str + \".\"; \n} \n\n```", "```cs\nif (str.IndexOf(\".\") == 0) \n{ \n  str.Insert(0, \"0\"); \n} \nelse if (str.IndexOf(\".\") == \n  str.Length - 2 && \n  str.LastIndexOf(\"0\") == \n  str.Length - 1) \n{ \n  str = str.Remove(str.Length - 1); \n} \n\n```", "```cs\nif (addNegative) \n{ \n  str = str.Insert(0, \"-\"); \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // This is the behind the scenes number  \n    // that represents what will be on the display  \n    // and what number to store as last input \n    private static string m_input; \n\n    // Sign of the number (positive or negative) \n    private static string m_sign; \n\n    // Current operator selected (+, -, * or /) \n    public static String m_operator; \n\n    // Last result displayed \n    private static String m_lastNum; \n\n    // Last input made \n    private static String m_lastInput; \n\n    // If the calculator should start a new input \n    // after a number is hit \n    public static bool m_wait; \n\n    // If the user is entering in decimal values \n    public static bool m_decimal; \n\n    // If the last key that was hit was the equals button \n    private static bool m_lastHitEquals;  \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    static CalcEngine() \n    { \n      // \".\" is used to represent no input \n      // which registers as 0 \n      m_input = \".\"; \n\n      m_sign = \"+\"; \n      m_operator = null; \n      m_lastNum = null; \n      m_lastInput = null; \n      m_wait = false; \n      m_decimal = false; \n      m_lastHitEquals = false; \n    } \n  } \n} \n\n```", "```cs\nswitch (btnClear.Name) \n{ \n  case \"btnClearAll\": \n    CalcEngine.ClearAll(); \n    UpdateScreen(); \n    break; \n  case \"btnClearEntry\": \n    CalcEngine.Clear(); \n    UpdateScreen(); \n    break; \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // Resets all variables \n    public static void ClearAll() \n    { \n      //Reset the calculator \n      m_input = \".\"; \n      m_lastNum = null; \n      m_lastInput = null; \n      m_operator = null; \n      m_sign = \"+\"; \n      m_wait = false; \n      m_decimal = false; \n      m_lastHitEquals = false; \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    static CalcEngine() \n    { \n      ClearAll(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // For Clear Entry,  \n    // just reset appropriate variable \n    public static void Clear() \n    { \n      //Just clear the current input \n      m_sign = \"+\"; \n      m_input = \".\"; \n      m_decimal = false; \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // Appends number to the input \n    public static void AppendNum( \n      double numValue) \n    { \n      if (numValue == Math.Round(numValue) && \n        numValue >= 0) \n      { \n         // The rest of code can be found  \n         // in the downloaded source code \n      } \n      // If they're trying to append a decimal or negative,  \n      // that's impossible so just replace the entire input \n      // with that value \n      else \n      { \n         // The rest of code can be found  \n         // in the downloaded source code \n      } \n    } \n  } \n} \n\n```", "```cs\nif (numValue == Math.Round(numValue) && \n    numValue >= 0) \n\n```", "```cs\nif (!IsEmpty()) \n{ \n  // if decimal is turned on \n  if (m_decimal) \n  { \n    m_input += \"\" + numValue; \n  } \n  else \n  { \n    m_input = m_input.Insert( \n      m_input.IndexOf(\".\"), \"\" + numValue); \n  } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // Indicate that user doesn't input value yet \n    private static bool IsEmpty() \n    { \n      if (m_input.Equals(\".\") || m_wait) \n        return true; \n      else \n        return false; \n    } \n  } \n} \n\n```", "```cs\nif (m_lastHitEquals)  \n{ \n  ClearAll(); \n  m_lastHitEquals = false; \n} \n\nif (m_decimal) \n{ \n  m_input = \".\" + numValue; \n} \nelse \n{ \n  m_input = numValue + \".\"; \n} \nm_wait = false; \n\n```", "```cs\nif (m_input.IndexOf(\"0\", 0, 1) == 0 && \n  m_input.IndexOf(\".\") > 1) \n{ \n  //Get rid of any extra zeroes  \n  //that may have been prepended \n  m_input = m_input.Remove(0, 1); \n} \n\n```", "```cs\nif (m_input.Contains(\".\") && \n  !(m_input.EndsWith(\"0\") && \n  m_input.IndexOf(\".\") == \n  m_input.Length - 2)) \n{ \n  m_decimal = true; \n} \n\nif (m_input.Contains(\"-\")) \n{ \n  m_sign = \"-\"; \n} \nelse \n{ \n  m_sign = \"+\"; \n} \n\n```", "```cs\n// Start over if the last key hit  \n// was the equals button  \n// and no operators were chosen \nif (m_lastHitEquals)  \n{ \n  ClearAll(); \n  m_lastHitEquals = false; \n} \nm_input = \"\" + numValue; \n\n// Reformat \nm_input = FormatInput(m_input); \nif (!m_input.Contains(\".\")) \n{ \n  m_input += \".\"; \n} \n\n```", "```cs\n// Get rid of any extra zeroes \n// that may have been prepended or appended \nif (m_input.IndexOf(\"0\", 0, 1) == 0 && \n  m_input.IndexOf(\".\") > 1) \n{ \n  m_input = m_input.Remove(0, 1); \n} \n\nif (m_input.EndsWith(\"0\") &&  \n  m_input.IndexOf(\".\") == m_input.Length - 2) \n{ \n  m_input.Remove(m_input.Length - 1); \n} \n\nm_wait = false; \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n  internal class CalcEngine \n  { \n    // Handles operation functions \n    public static void PrepareOperation( \n      string strOperator) \n    { \n      switch (strOperator) \n      { \n         // The rest of code can be found  \n         // in the downloaded source code \n      } \n    } \n  } \n} \n\n```", "```cs\n// If this is the first number  \n// that user inputs \nif (m_lastNum == null || \n  m_wait) \n{ \n  if (m_lastNum != null && \n    !m_operator.Equals(\"+\") && \n    !m_lastHitEquals && \n    !m_wait) \n  Solve(); \n  m_operator = \"+\"; \n  m_lastNum = \"\" + FormatInput(m_input); \n  m_sign = \"+\"; \n  m_decimal = false; \n  m_wait = true; \n} \n\n```", "```cs\nelse \n{ \n    if (!m_wait) \n        Solve(); \n    m_operator = \"+\"; \n    m_sign = \"+\"; \n    m_wait = true; \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n    internal class CalcEngine \n    { \n        // Formats the input into a valid double format \n        private static string FormatInput( \n            string str) \n        { \n            // Format the input to something convertable  \n            // by Convert.toDouble \n\n            // Prepend a Zero  \n            // if the string begins with a \".\" \n            if (str.IndexOf(\".\") == 0)  \n            { \n                str = \"0\" + str; \n            } \n\n            // Appened a Zero  \n            // if the string ends with a \".\" \n            if (str.IndexOf(\".\") ==  \n                str.Length - 1)  \n            { \n                str = str + \"0\"; \n            } \n\n            // If negative is turned on  \n            // and there's no \"-\"  \n            // in the current string \n            // then \"-\" is prepended \n            if (m_sign.Equals(\"-\") &&  \n                str != \"0.0\" &&  \n                str.IndexOf(\"-\") == -1)  \n            { \n                str = \"-\" + str; \n            } \n\n            return str; \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n    internal class CalcEngine \n    { \n        // Solve the currently stored expression \n        public static bool Solve() \n        { \n            bool canSolve = true; \n\n            // The rest of code can be found  \n            // in the downloaded source code \n\n            return canSolve; \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorImperative \n{ \n    internal class CalcEngine \n    { \n        // Handles decimal square roots,  \n        // decimal buttons, percents, inverse, delete,  \n        // and sign switching \n        public static bool FunctionButton( \n            string str) \n        { \n            bool success = false; \n            switch (str) \n            { \n               // The rest of code can be found  \n               // in the downloaded source code \n            } \n            return success; \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public class Calc \n    { \n        public string m_input { get; set; } \n        public string m_sign { get; set; } \n        public string m_operator { get; set; } \n        public string m_lastNum { get; set; } \n        public string m_lastInput { get; set; } \n        public bool m_wait { get; set; } \n        public bool m_decimal { get; set; } \n        public bool m_lastHitEquals { get; set; } \n\n        public bool m_solve { get; set; } \n        public string m_answer { get; set; } \n        public bool m_funcSuccess { get; set; } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static Calc AppendNum( \n            this Calc calc, \n            double numValue) \n        {             \n           // The rest of code can be found  \n           // in the downloaded source code \n        } \n\n        public static Calc AppendNumWhenRound( \n            this Calc calc, \n            double numValue) \n        { \n           // The rest of code can be found  \n           // in the downloaded source code \n        } \n\n        // The rest of code can be found  \n        // in the downloaded source code  \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcPropertiesExtension \n    { \n        public static Calc Input( \n            this Calc calc, \n            string input) \n        { \n            calc.m_input = \n                input; \n            return calc; \n        } \n\n        public static Calc LastNum( \n            this Calc calc, \n            string lastNum) \n        { \n            calc.m_lastNum = \n                lastNum; \n            return calc; \n        } \n\n        // The rest of code can be found  \n        // in the downloaded source code \n\n        public static Calc ModifyCalcFuncSuccess( \n            this Calc calc, \n            bool val) \n        { \n            calc.m_funcSuccess = val; \n            return calc; \n        } \n\n        public static Calc ModifyCalcFuncSuccessBasedOn( \n            this Calc calc, \n            Func<bool> predicate) \n        { \n            return predicate() ? \n                calc.ModifyCalcFuncSuccess(true) : \n                calc.ModifyCalcFuncSuccess(false); \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static Calc Clear( \n            this Calc calc) \n        { \n            return calc \n                .ModifyCalcSign(\"+\") \n                .ModifyCalcInput(\".\") \n                .ModifyCalcDecimal(false); \n        } \n\n        public static Calc ClearAll( \n            this Calc calc) \n        { \n            return calc \n                .Clear() \n                .ModifyCalcLastNum(null) \n                .ModifyCalcLastInput(null) \n                .ModifyCalcOperator(null) \n                .ModifyCalcWait(false) \n                .ModifyCalcLastHitEquals(false); \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static Calc AppendNum( \n            this Calc calc, \n            double numValue) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        public static Calc AppendNumWhenRound( \n            this Calc calc, \n            double numValue) \n        { \n           // The rest of code can be found  \n           // in the downloaded source code \n        } \n\n        // The rest of code can be found  \n        // in the downloaded source code  \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static Calc PrepareOperation( \n            this Calc calc, \n            string strOperator) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        public static Calc PrepareOperationAdd( \n            this Calc calc) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        public static Calc  \n            PrepareOperationAddLastNumNull( \n                this Calc calc) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        // The rest of code can be found  \n        // in the downloaded source code \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static String FormatInput( \n            this Calc calc,  \n            String n) \n        { \n            return n \n                .ModifyStringWhen( \n                    () => n.IndexOf(\".\") == 0, \n                    () => n = \"0\" + n) \n                .ModifyStringWhen( \n                    () => n.IndexOf(\".\") == n.Length - 1, \n                    () => n = n + \"0\") \n                .ModifyStringWhen( \n                    () => calc.m_sign.Equals(\"-\") && \n                        n != \"0.0\" && \n                        n.IndexOf(\"-\") == -1, \n                    () => n = \"-\" + n); \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n  public static class StringMethodsExtension \n  { \n    public static string ModifyStringWhen( \n      this string @this, \n      Func<bool> predicate, \n      Func<string> modifier) \n    { \n      return predicate() \n      ? modifier() \n      : @this; \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n  public static class CalcMethodsExtension \n  { \n    public static Calc Solve( \n      this Calc calc) \n    { \n      return calc.CleanUp() \n      .Answer() \n      .UpdateAnswerToCalc(); \n    } \n  } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcSolveMethodsExtension \n    { \n        public static Calc Answer( \n            this Calc calc) \n        { \n            calc.m_answer = calc.m_operator.Match() \n                .With(o => o == \"+\",  \n                    calc.m_lastNum.SolveAdd( \n                        calc.m_lastInput)) \n                .With(o => o == \"-\",  \n                    calc.m_lastNum.SolveSubtract( \n                        calc.m_lastInput)) \n                .With(o => o == \"*\",  \n                    calc.m_lastNum.SolveMultiply( \n                        calc.m_lastInput)) \n                .With(o => o == \"/\",  \n                    !calc.FormatInput( \n                        calc.m_lastInput).Equals( \n                            \"0.0\") ?  \n                        calc.m_lastNum.SolveDivide( \n                            calc.m_lastInput) :  \n                        \"\") \n                .Else(\"\") \n                .Do(); \n\n            calc.m_solve = calc.m_answer.Match() \n                .With(o => o.Equals(\"\"), false) \n                .Else(true) \n                .Do(); \n\n            return calc; \n        } \n\n        public static Calc CleanUp( \n            this Calc calc) \n        { \n            return calc \n                .ModifyCalcInputWhen( \n                    () => calc.m_input.Equals(\"\"), \n                    \"0\") \n                .ModifyCalcLastNumWhen( \n                    () => calc.m_lastNum == null || \n                        calc.m_lastNum.Equals(\"\"), \n                    \"0,0\") \n                .ModifyCalcLastInputWhen( \n                    () => !calc.m_wait, \n                    \"\" + calc.FormatInput( \n                        calc.m_input)); \n        } \n\n        public static Calc UpdateAnswerToCalc( \n            this Calc calc) \n        { \n            calc.m_lastNum = calc.m_answer; \n            calc.m_input = calc.m_answer; \n            calc.m_sign = \"+\"; \n            calc.m_decimal = false; \n            calc.m_lastHitEquals = true; \n            calc.m_wait = true; \n\n            calc.m_solve = true; \n            return calc; \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class StringMethodsExtension \n    { \n        public static string SolveAdd( \n            this string @string,  \n            string str) \n        { \n            return Convert.ToString( \n                Convert.ToDouble(@string) + \n                Convert.ToDouble(str)); \n        } \n\n        public static string SolveSubtract( \n            this string @string, \n            string str) \n        { \n            return Convert.ToString( \n                Convert.ToDouble(@string) - \n                Convert.ToDouble(str)); \n        } \n\n        public static string SolveMultiply( \n            this string @string, \n            string str) \n        { \n            return Convert.ToString( \n                Convert.ToDouble(@string) * \n                Convert.ToDouble(str)); \n        } \n\n        public static string SolveDivide( \n            this string @string, \n            string str) \n        { \n            return Convert.ToString( \n                Convert.ToDouble(@string) / \n                Convert.ToDouble(str)); \n        } \n    } \n} \n\n```", "```cs\nnamespace CalculatorFunctional \n{ \n    public static class CalcMethodsExtension \n    { \n        public static Calc PrepareOperation( \n            this Calc calc, \n            string strOperator) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        public static Calc PrepareOperationAdd( \n            this Calc calc) \n        { \n            // The rest of code can be found  \n            // in the downloaded source code \n        } \n\n        // The rest of code can be found  \n        // in the downloaded source code \n    } \n} \n\n```"]