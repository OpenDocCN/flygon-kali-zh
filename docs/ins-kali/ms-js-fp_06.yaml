- en: Producing Functions - Higher-Order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成函数 - 高阶函数
- en: 'In [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we worked with some predefined higher-order functions and were
    able to see how their usage let us write declarative code, gaining in understandability
    as well as in compactness. In this new chapter, we are going to go further in
    the direction of higher-order functions, and we are going to develop our own.
    We can roughly classify the kinds of functions that we are going into three groups:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中，*声明式编程 - 更好的风格*，我们使用了一些预定义的高阶函数，并且能够看到它们的使用方式让我们编写了声明式的代码，不仅在可理解性上有所提升，而且在紧凑性上也有所提升。在这一新章节中，我们将进一步探讨高阶函数的方向，并且我们将开发我们自己的高阶函数。我们可以将我们要进入的函数类型大致分类为三组：
- en: '**Wrapped functions**, that keep their original functionality, adding some
    kind of new feature. In this group, we can consider *logging* (adding log production
    capacity to any function), *timing* (producing time and performance data for a
    given function), and *memoization* (that caches results to avoid future re-work).'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装函数**，保持其原始功能，添加某种新功能。在这一组中，我们可以考虑*日志记录*（为任何函数添加日志记录功能）、*计时*（为给定函数生成时间和性能数据）和*记忆化*（缓存结果以避免未来的重新计算）。'
- en: '**Altered functions**, that differ in some key point with their original versions.
    Here we can include the `once()` function (we wrote it in [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*) that changes the original function
    to run only once, functions such as `not()` or `invert()` that alter what the
    function would return, and arity-related conversions that produce a new function
    with a fixed number of parameters.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改函数**，在某些关键点上与它们的原始版本不同。在这里，我们可以包括`once()`函数（我们在[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)中编写过，*函数式思维
    - 第一个示例*），它改变了原始函数只运行一次，像`not()`或`invert()`这样改变函数返回值的函数，以及产生具有固定参数数量的新函数的arity相关转换。'
- en: '**Other productions**, that provide for new operations, turn functions into
    promises, provide enhanced search functions, or allow decoupling a method from
    objects, so we can use them in other contexts as if they were common functions.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他产物**，提供新的操作，将函数转换为promises，提供增强的搜索功能，或允许将方法与对象解耦，以便我们可以在其他上下文中使用它们，就像它们是普通函数一样。'
- en: Wrapping functions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装函数
- en: In this section, let's consider some higher-order functions that provide a *wrapper*
    around other function, to enhance it in some way, but without altering its original
    objective. In terms of d*esign patterns* (which we'll be revisiting in [Chapter
    11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml), *Implementing Design Patterns
    - The Functional Way*), we could also speak of *decorators*. This pattern is based
    on the concept of adding some behavior to an object (in our case, a function)
    without affecting other objects. The term *decorator* is also popular because
    of its usage in frameworks such as Angular, or (in an experimental mode) for general
    programming in JS.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们考虑一些提供对其他函数进行*包装*以某种方式增强其功能，但不改变其原始目的的高阶函数。在*设计模式*方面（我们将在[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)中重新讨论），我们也可以谈论*装饰器*。这种模式基于向对象（在我们的情况下是函数）添加一些行为而不影响其他对象的概念。装饰器这个术语也很受欢迎，因为它在Angular等框架中的使用，或者（在实验模式下）用于JS的一般编程。
- en: Decorators are being considered for general adoption in JS, but are currently
    (August 2017) at Stage 2, *Draft* level, and it may be a while until they get
    to Stage 3 (*Candidate*) and finally Stage 4 (*Finished*, meaning officially adopted).
    You can read more about decorators for JS at [https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)
    and about the JS adoption process itself, called TC39, in [https://tc39.github.io/process-document/](https://tc39.github.io/process-document/).
    See the *Questions* section in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器正在考虑在JS中进行一般采用，但目前（2017年8月）处于2阶段，*草案*级别，可能要等一段时间才能进入3阶段（*候选*）和最终进入4阶段（*完成*，意味着正式采用）。你可以在[https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)了解更多关于JS装饰器的信息，以及JS采用过程本身，称为TC39，在[https://tc39.github.io/process-document/](https://tc39.github.io/process-document/)。在[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)，*实现设计模式
    - 函数式方法*的*问题*部分中查看更多信息。
- en: 'As for the term *wrapper*, it''s more important and pervasive that you might
    have thought; in fact, JavaScript uses it widely. Where? You already know that
    object properties and methods are accessed through dot notation. However, you
    also know that you can write code such as `myString.length` or `22.9.toPrecision(5)`
    -- where are those properties and methods coming from, given that neither strings
    nor numbers are objects? JavaScript actually creates a *wrapper object* around
    your primitive value. This object inherits all the methods appropriate to the
    wrapped value. As soon as the needed evaluation has been done, JavaScript throws
    away the just-created wrapper. We cannot do anything about these transient wrappers,
    but there is a concept we will come back to: a wrapper allows methods to be called
    on things that are not of the appropriate type -- and that''s an interesting idea;
    see [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better
    Containers - Functional Data Types*, for more applications of that!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 至于*包装器*这个术语，它比你想象的更重要和普遍；事实上，JavaScript广泛使用它。在哪里？你已经知道对象属性和方法是通过点表示法访问的。然而，你也知道你可以编写诸如`myString.length`或`22.9.toPrecision(5)`的代码--这些属性和方法是从哪里来的，因为字符串和数字都不是对象？JavaScript实际上在你的原始值周围创建了一个*包装对象*。这个对象继承了适用于包装值的所有方法。一旦需要进行评估，JavaScript就会丢弃刚刚创建的包装器。我们无法对这些瞬时包装器做任何事情，但有一个概念我们将会回来：包装器允许在不适当类型的东西上调用方法--这是一个有趣的想法；参见[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)，*构建更好的容器
    - 函数式数据类型*，了解更多应用。
- en: Logging
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: 'Let''s start with a common problem. When debugging code, you usually need to
    add some kind of logging information, to see if a function was called, with what
    arguments, and what it returned, and so on. (Yes, of course, you can simply use
    a debugger and set breakpoints, but bear with me for this example!) Working normally,
    that means that you''ll have to modify the code of the function itself, both at
    entry and on exit. You''ll have to code such as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个常见的问题开始。在调试代码时，通常需要添加某种日志信息，以查看函数是否被调用，使用了什么参数，返回了什么，等等。（是的，当然，您可以简单地使用调试器并设置断点，但请在这个例子中忍耐一下！）正常工作意味着您将不得不修改函数本身的代码，无论是在进入还是退出时。您将不得不编写如下的代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'to something like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到这样的程度：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the function can return at several places, you'll have to modify all the
    `return` statements, to log the values that are to be returned. Of course, if
    you are just calculating the return expression on the fly, you'll need an auxiliar
    variable to capture that value.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数可以在多个地方返回，您将不得不修改所有的`return`语句，以记录要返回的值。当然，如果您只是在动态计算返回表达式，您将需要一个辅助变量来捕获该值。
- en: Logging in a functional way
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以一种功能性的方式记录
- en: Doing this is not difficult but modifying code is always dangerous and prone
    to "accidents". So, let's put our FP hats on, and think of a new way of doing
    this. We have a function that performs some kind of work and we want to know the
    arguments it receives and the value it returns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做并不困难，但修改代码总是危险的，容易发生“意外”。因此，让我们戴上我们的FP帽子，想出一种新的方法来做这件事。我们有一个执行某种工作的函数，我们想知道它接收到的参数和它返回的值。
- en: 'We can write a higher-order function that will have a single parameter, the
    original function, and return a new function that will do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个高阶函数，它将有一个参数，即原始函数，并返回一个新的函数，该函数将执行以下操作：
- en: Log the received arguments.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录接收到的参数。
- en: Call the original function, catching its returned value.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用原始函数，捕获其返回的值。
- en: Log that value; and finally.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录该值；最后。
- en: Return to the caller.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回给调用者。
- en: 'A possible solution would be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The function returned by `addLogging()` behaves as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由`addLogging()`返回的函数的行为如下：
- en: The first `console.log()` line shows the original function's name and its list
    of arguments
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`console.log()`行显示了原始函数的名称及其参数列表
- en: Then, the original function `fn()` is called, and the returned value is stored
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后调用原始函数`fn()`，并存储返回的值
- en: The second `console.log()` line shows the function name (again) and its returned
    value
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`console.log()`行显示函数名称（再次）及其返回值
- en: Finally, the value that `fn()` calculated, was returned
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`fn()`计算的值被返回
- en: If you were doing this for a Node.js application, you would probably opt for
    a better way of logging, by using libraries such as Winston, Morgan, or Bunyan
    -- but our focus is in showing how to wrap the original function, and the needed
    changes for using those libraries would be small.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为Node.js应用程序执行此操作，您可能会选择更好的日志记录方式，比如使用Winston、Morgan或Bunyan等库--但我们的重点是展示如何包装原始函数，使用这些库所需的更改将很小。
- en: For an example, we can use it with an upcoming functions -- which are written,
    I agree, in an overtly complicated way, just to have an appropriate example!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将其与即将到来的函数一起使用--我同意，以一种过于复杂的方式编写，只是为了有一个合适的例子！
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result of executing the last line would be the production of the following
    lines of logging:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最后一行的结果将产生以下日志行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All the changes we had to do in our code were the reassignments of `subtract()`
    and `changeSign()`, which essentially replaced them everywhere with their new
    log-producing wrapped versions. Any call to those two functions will produce this
    output.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中所做的所有更改都是重新分配`subtract()`和`changeSign()`，这实质上替换了它们的新的生成日志的包装版本。对这两个函数的任何调用都将产生此输出。
- en: We'll see a possible error because of not reassigning the wrapped logging function
    in the *Memoizing* in the following section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会看到一个可能的错误，因为在下一节的*Memoizing*中没有重新分配包装的日志函数。
- en: Taking exceptions into account
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑异常情况
- en: 'Let''s enhance our logging function a bit, by considering a needed adjustment.
    What happens to your log if the function throws an error? Fortunately, that''s
    easy to solve. We just have to add some code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微增强我们的日志函数，考虑到需要的调整。如果函数抛出错误，您的日志会发生什么？幸运的是，这很容易解决。我们只需要添加一些代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Other changes would be up to you -- adding date and time data, enhancing the
    way parameters are listed, and so on. However, our implementation still has an
    important defect; let's make it better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其他更改将由您决定--添加日期和时间数据，增强参数列表的方式等。然而，我们的实现仍然存在一个重要的缺陷；让我们改进一下。
- en: Working in a more pure way
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以更纯粹的方式工作
- en: 'When we wrote the `addLogging()` preceding function, we laid by the roadside
    some precepts we saw in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, because we included an impure element (`console.log()`)
    right in our code. With this, not only did we lose flexibility (would you be able
    to select an alternate way of logging?) but we also complicated our testing. We
    could, certainly, manage to test it by spying on the `console.log()` method, but
    that isn''t very clean: we depend on knowing the internals of the function we
    want to test, instead of doing a purely black box test:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写了`addLogging()`前面的函数时，我们放弃了[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中看到的一些原则，*行为得体
    - 纯函数*，因为我们在代码中包含了一个不纯的元素（`console.log()`）。这样做，我们不仅失去了灵活性（您能够选择替代的日志方式吗？），而且还使我们的测试变得更加复杂。当然，我们可以通过监听`console.log()`方法来测试它，但这并不是很干净：我们依赖于了解我们想要测试的函数的内部，而不是进行纯粹的黑盒测试：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this test shows that `addLogging()` behaves as expected, so this is
    a solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试表明`addLogging()`的行为符合预期，所以这是一个解决方案。
- en: 'Even so, being able to test our function in this way doesn''t solve the lack
    of flexibility we mentioned. We should pay attention to what we wrote in section
    *Injecting impure functions*: the logging function should be passed as an argument
    to the wrapper function, so we can change it if we need to:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样，以这种方式测试我们的函数并不能解决我们提到的灵活性不足。我们应该注意我们在*注入不纯函数*部分写的内容：日志函数应该作为参数传递给包装函数，这样我们就可以在需要时更改它：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we don''t do anything, the logging wrapper will obviously produce the same
    results as in the previous section. However, we could provide a different logger
    -- for example, with Node.js, we could use *winston* and the results would vary
    accordingly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们什么都不做，日志包装器显然会产生与前一节相同的结果。然而，我们可以提供一个不同的记录器——例如，在Node.js中，我们可以使用*winston*，结果会相应地有所不同：
- en: See [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)
    for more on the *winston* logging tool.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*winston*日志工具的更多信息，请参见[https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have followed our own earlier advice, we can take advantage of
    stubs. The code for testing is practically the same as before but we are using
    a stub, `dummy.logger()`, with no provided functionality or side effects, so it''s
    safer all around. True: in this case, the real function that was being invoked
    originally, `console.log()`, could do no harm, but that''s not always the case,
    so using a stub is recommended:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经遵循了我们之前的建议，我们可以利用存根。测试代码几乎与以前相同，但我们使用了一个没有提供功能或副作用的存根`dummy.logger()`，所以在各方面都更安全。确实：在这种情况下，最初被调用的真实函数`console.log()`不会造成任何伤害，但并非总是如此，因此建议使用存根：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When applying FP techniques, always keep in mind that if you are somehow complicating
    your own job --for example, making it difficult to test any of your functions--
    then you must be doing something wrong. In our case, the mere fact that the output
    of `addLogging()` was an impure function should have raised an alarm. Of course,
    given the simplicity of the code, in this particular case, you might decide that
    it's not worth a fix, that you can do without testing, and that you don't need
    to be able to change the way logging is produced. However, long experience in
    software development suggests that sooner or later you'll come to regret that
    sort of decision, so try to go with the cleaner solution instead.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用FP技术时，一定要记住，如果你在某种程度上使自己的工作复杂化——例如，使测试任何一个函数变得困难——那么你一定是在做错事。在我们的案例中，`addLogging()`的输出是一个不纯的函数，这一事实本应引起警惕。当然，鉴于代码的简单性，在这种特殊情况下，你可能会决定不值得修复，你可以不测试，你也不需要能够更改日志生成的方式。然而，长期的软件开发经验表明，迟早你会后悔这样的决定，所以尽量选择更清洁的解决方案。
- en: Timing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Another possible application for wrapped functions is to record and log, in
    a fully transparent way, the timing of each function invocation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包装函数的另一个可能的应用是以完全透明的方式记录和记录每个函数调用的时间。
- en: 'If you plan to optimize your code, remember the rules: *Don''t do it*, then
    *Don''t do it yet*, and finally *Don''t do it without measuring*. It has been
    often been mentioned that much bad code arises from early attempts at optimization,
    so don''t start by trying to write optimal code, don''t try to optimize until
    you recognize the need for it, and don''t do it haphazardly, without trying to
    determine the reasons for the slowdown by measuring all parts of your application.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划优化你的代码，请记住以下规则：*不要这样做*，然后*还不要这样做*，最后*不要在没有测量的情况下这样做*。经常提到，很多糟糕的代码都是由早期的优化尝试产生的，所以不要试图写出最佳的代码，不要试图优化，直到你意识到需要优化，不要随意地进行优化，而是通过测量应用程序的所有部分来确定减速的原因。
- en: 'Somehow, along the lines of the preceding example, we can write an `addTiming()`
    function that, given any function, will produce a wrapped version that will write
    out timing data on the console but will otherwise work in the same exact way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子的基础上，我们可以编写一个`addTiming()`函数，给定任何函数，它将生成一个包装版本，该版本将在控制台上写出时间数据，但在其他方面的工作方式完全相同：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, along the lines of the enhancement we applied in the previous section
    to the logging function, we are providing separate logger and time access functions.
    Writing tests for our `addTiming()` function should prove easy, given that we
    can inject both impure functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们在前一节对日志函数应用的增强相一致，我们提供了单独的记录器和时间访问函数。编写我们的`addTiming()`函数的测试应该很容易，因为我们可以注入两个不纯函数。
- en: Using `performance.now()` provides the highest accuracy. If you don't need such
    precision as provided by that function (and it's arguable that it is overkill),
    you could simply substitute `Date.now()`. For more on these alternatives, see
    [https://developer.mozilla.org/en-US/docs/Web/API/Performance/now](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)
    and [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now).
    You could also consider using `console.time()` and `console.timeEnd()`; see [https://developer.mozilla.org/en-US/docs/Web/API/Console/time](https://developer.mozilla.org/en-US/docs/Web/API/Console/time).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`performance.now()`提供了最高的精度。如果你不需要这个函数提供的精度（它可能是过度的），你可以简单地用`Date.now()`替代。有关这些替代方案的更多信息，请参见[https://developer.mozilla.org/en-US/docs/Web/API/Performance/now](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)和[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now)。你也可以考虑使用`console.time()`和`console.timeEnd()`；请参见[https://developer.mozilla.org/en-US/docs/Web/API/Console/time](https://developer.mozilla.org/en-US/docs/Web/API/Console/time)。
- en: 'Just to be able to fully try out the logging functionality, I modified the
    `subtract()` function, so it would throw an error if you attempted to subtract
    zero. You could also list the input parameters, if desired, for more information:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够充分尝试日志功能，我修改了`subtract()`函数，这样如果你尝试减去零，它会抛出一个错误。如果需要，你也可以列出输入参数，以获取更多信息：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code is quite similar to the previous `addLogging()` function, and that's
    reasonable - in both cases, we are adding some code before the actual function
    call, and then some new code after the function returns. You might even consider
    writing a *higher*-higher-order function, that would receive three functions,
    and would produce a higher-order function as output (such as `addLogging()` or
    `addTiming()`) that would call the first function at the beginning, and then the
    second function if the wrapped function returned a value, or the third function
    if an error had been thrown! What about it?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的`addLogging()`函数非常相似，这是合理的--在这两种情况下，我们都在实际函数调用之前添加了一些代码，然后在函数返回后添加了一些新代码。您甚至可以考虑编写一个*更高级*的高阶函数，它将接收三个函数，并且会产生一个高阶函数作为输出（例如`addLogging()`或`addTiming()`），该函数将在开始时调用第一个函数，然后在包装函数返回值时调用第二个函数，或者在抛出错误时调用第三个函数！怎么样？
- en: Memoizing
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: 'Back in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*, we considered the case of the Fibonacci function and
    saw how we could transform it, by hand, into a much more efficient version by
    means of *memoization*: caching calculated values, to avoid recalculations. For
    simplicity, let''s now only consider functions with a single, non-structured parameter,
    and leave for later functions with more complex parameters (objects, arrays) or
    more than one parameter for later.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中，*行为良好-纯函数*，我们考虑了斐波那契函数的情况，并看到了如何通过手工将其转换为更高效的版本，通过*记忆化*：缓存计算的值，以避免重新计算。为简单起见，现在让我们只考虑具有单个非结构化参数的函数，并留待以后处理具有更复杂参数（对象、数组）或多个参数的函数。
- en: 'The kind of values we can handle with ease are JS''s primitive values: data
    that isn''t objects and has no methods. JS has six of these: `boolean`, `null`,
    `number`, `string`, `symbol`, and `undefined`. It''s likely we would only see
    the first four as actual arguments. See more in [https://developer.mozilla.org/en-US/docs/Glossary/Primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松处理的值的类型是JS的原始值：不是对象且没有方法的数据。JS有六种原始值：`boolean`、`null`、`number`、`string`、`symbol`和`undefined`。很可能我们只会看到前四个作为实际参数。在[https://developer.mozilla.org/en-US/docs/Glossary/Primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)中了解更多。
- en: Simple memoization
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的记忆化
- en: 'We will work with the Fibonacci function we mentioned, which is a simple case:
    it receives a single numeric parameter. The function, as we saw it, was the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们提到的斐波那契函数，这是一个简单的情况：它接收一个数字参数。我们看到的函数如下：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The solution we did there was general in concept, but particularly in its implementation:
    we had to directly modify the code of the function in order to take advantage
    of said memoization. Now we should look into a way of doing it automatically,
    in the same fashion as with other wrapped functions. The solution would be a `memoize()`
    function that wraps any other function, to apply memoization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里做的解决方案在概念上是通用的，但在实现上特别是：我们必须直接修改函数的代码，以便利用所述的记忆化。现在我们应该研究一种自动执行相同方式的方法，就像对其他包装函数一样。解决方案将是一个`memoize()`函数，它包装任何其他函数，以应用记忆化：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How does this work? The returned function, for any given argument, first checks
    whether the argument was already received; that is, whether it can be found as
    a key in the cache object. If so, there's no need for calculation, and the cached
    value is returned. Otherwise, we calculate the missing value and store it in the
    cache. (We are using a closure to hide the cache from external access.) We are
    assuming here that the memoized function receives only one argument (`x`) and
    that it is a primitive value, which can then be directly used as a key value for
    the cache object; we'll consider other cases later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？对于任何给定的参数，返回的函数首先检查参数是否已经接收到；也就是说，它是否可以在缓存对象中找到。如果是这样，就不需要计算，直接返回缓存的值。否则，我们计算缺失的值并将其存储在缓存中。（我们使用闭包来隐藏缓存，防止外部访问。）我们在这里假设记忆化函数只接收一个参数（`x`），并且它是一个原始值，然后可以直接用作缓存对象的键值；我们以后会考虑其他情况。
- en: 'Is this working? We''ll have to time it -- and we happen to have a useful `addTiming()`
    function for that! First, we take some timings for the original `fib()` function.
    We want to time the complete calculation and not each individual recursive call,
    so we write an auxiliar `testFib()` function and that''s the one we''ll time.
    We should repeat the timing operations and do an average but, since we just want
    to confirm that memoizing works, we''ll tolerate differences:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效吗？我们需要计时--我们碰巧有一个有用的`addTiming()`函数来做这个！首先，我们对原始的`fib()`函数进行一些计时。我们想要计时完整的计算过程，而不是每个递归调用，所以我们编写了一个辅助的`testFib()`函数，这是我们将计时的函数。我们应该重复计时操作并取平均值，但是，由于我们只是想确认记忆化是否有效，我们将容忍差异：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Your times may vary, of course, but the results seem logical: the exponential
    growth we mentioned in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, appears to be present, and times grow quickly.
    Now, let''s memoize `fib()`, and we should get shorter times -- or shouldn''t
    we?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您的时间可能会有所不同，但结果似乎是合乎逻辑的：我们在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中提到的指数增长似乎是存在的，时间增长迅速。现在，让我们对`fib()`进行记忆化，我们应该得到更短的时间--或者不应该吗？
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Something's wrong! The times should have gone down--but they are just about
    the same. This is because of a common error, which I've even seen in some articles
    and web pages. We are timing `memofib()` -- but nobody calls that function, except
    for timing, and that only happens once! Internally, all recursive calls are to
    `fib()`, which isn't memoized. If we called `testMemoFib(45)` again, *that* call
    would be cached, and it would return almost immediately, but that optimization
    doesn't apply to the internal `fib()` calls. This is the reason, also, why the
    calls for `testMemoFib(40)` and `testMemoFib(35)` weren't optimized -- when we
    did the calculation for `testMemoFib(45)`, that was the only value that got cached.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 出了些问题！时间应该下降了——但它们几乎一样。这是因为一个常见的错误，我甚至在一些文章和网页中看到过。我们正在计时`memofib()`——但除了计时之外，没有人调用那个函数，而且那只会发生一次！在内部，所有的递归调用都是`fib()`，它没有被记忆化。如果我们再次调用`testMemoFib(45)`，*那个*调用会被缓存，它会几乎立即返回，但这种优化不适用于内部的`fib()`调用。这也是为什么`testMemoFib(40)`和`testMemoFib(35)`的调用没有被优化的原因——当我们计算`testMemoFib(45)`时，那是唯一被缓存的值。
- en: 'The correct solution is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方案如下：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, when calculating `fib(45)`, in fact, all the intermediate Fibonacci values
    (from `fib(0)` to `fib(45)` itself) are stored, so the forthcoming calls have
    practically no work to do.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当计算`fib(45)`时，实际上所有中间的斐波那契值（从`fib(0)`到`fib(45)`本身）都被存储了，所以即将到来的调用几乎没有什么工作要做。
- en: More complex memoization
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的记忆化
- en: 'What can we do if we have to work with a function that receives two or more
    arguments, or that can receive arrays or objects as arguments? Of course, like
    in the problem that we saw in [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, about having a function do its job
    only once, we could simply ignore the question: if the function to be memoized
    is unary, we do the memoization thing; otherwise, if the function has a different
    arity, we just don''t do anything!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须处理接收两个或更多参数的函数，或者可以接收数组或对象作为参数的函数，我们该怎么办？当然，就像我们在[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)中看到的问题一样，*函数式思维
    - 第一个例子*，关于让函数只执行一次，我们可以简单地忽略这个问题：如果要进行记忆化的函数是一元的，我们就进行记忆化；否则，如果函数的arity不同，我们就什么都不做！
- en: 'The number of parameters of a function is called the *arity* of the function,
    or its *valence*. You may speak in three different ways: you can say a function
    has arity 1, 2, 3, and so on., or you can say that a function is unary, binary,
    ternary, and so on, or you can also say it''s monadic, dyadic, triadic, and so
    on: take your pick!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数个数称为函数的*arity*，或者它的*valence*。你可以用三种不同的方式来说：你可以说一个函数的arity是1、2、3等，或者你可以说一个函数是一元的、二元的、三元的等，或者你也可以说它是单元的、二元的、三元的等：随你挑！
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Working more seriously, if we want to be able to memoize any function, we must
    find a way to generate cache keys. To do this, we have to find a way to convert
    any kind of argument, into a string. We cannot directly use a non-primitive as
    a cache key. We could attempt to convert the value to a string with something
    like `strX = String(x)` but we''ll have problems. With arrays, it seems it could
    work, but see these three cases:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更认真地工作，如果我们想要能够记忆化任何函数，我们必须找到一种生成缓存键的方法。为此，我们必须找到一种将任何类型的参数转换为字符串的方法。我们不能直接使用非原始值作为缓存键。我们可以尝试将值转换为字符串，比如`strX
    = String(x)`，但会遇到问题。对于数组，似乎可以工作，但看看这三种情况：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The three cases produce the same result. If we were only considering a single
    array argument, we'd probably be able to make do, but when different arrays produce
    the same key, that's a problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种情况产生相同的结果。如果我们只考虑单个数组参数，我们可能能够应付，但当不同的数组产生相同的键时，那就是个问题。
- en: 'Things become worse if we have to receive objects as arguments, because the
    `String()` representation of any object is, invariably, `"[object Object]"`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须接收对象作为参数，情况会变得更糟，因为任何对象的`String()`表示都是`"[object Object]"`：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The simplest solution is to use `JSON.stringify()` to convert whatever arguments
    we have received into a useful, distinct, and string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是使用`JSON.stringify()`将我们收到的任何参数转换为有用的、不同的字符串：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For performance, our logic should be as follows: if the function that we are
    memoizing receives a single argument, that is a primitive value, use that argument
    directly as a cache key; in other cases, use the result of `JSON.stringify()`
    as applied to the array of arguments. Our enhanced memoizing higher-order function
    could be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能，我们的逻辑应该是这样的：如果我们要进行记忆化的函数接收一个单一的原始值作为参数，直接使用该参数作为缓存键；在其他情况下，使用`JSON.stringify()`应用于参数数组的结果作为缓存键。我们增强的记忆化高阶函数可以如下：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In terms of universality, this is the safest version. If you are sure about
    the type of parameters in the function you are going to process, it''s arguable
    that our first version was faster. And, on the other hand, if you want to have
    easier to understand code, even at the cost of some wasted CPU cycles, you could
    go with a simpler version:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就普遍性而言，这是最安全的版本。如果你确定要处理的函数的参数类型，可以说我们的第一个版本更快。另一方面，如果你想要更容易理解的代码，即使牺牲一些CPU周期，你可以选择一个更简单的版本：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you want to know about the development of a top-performance memoizing function,
    read Caio Gondim's *How I wrote the world's fastest JavaScript memoization library*
    article, available online at [https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解一个性能最佳的记忆化函数的开发情况，可以阅读Caio Gondim的文章*How I wrote the world's fastest JavaScript
    memoization library*，在线可供阅读[https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/)。
- en: Memoization testing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化测试
- en: 'Testing the memoization higher-order function poses an interesting problem
    -- just how would you go about it? The first idea would be to look into the cache
    -- but that''s private and not visible. Of course, we could change `memoize()`
    to use a global cache, or to somehow allow external access to the cache, but doing
    that sort of internal exam is frowned upon: you should try to do your tests based
    on external properties only.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试记忆化高阶函数提出了一个有趣的问题--你会怎么做？第一个想法是查看缓存--但那是私有的，不可见的。当然，我们可以改变`memoize()`来使用全局缓存，或者以某种方式允许外部访问缓存，但这种内部检查是不受欢迎的：你应该尝试仅基于外部属性进行测试。
- en: 'Accepting that we should omit trying to examine the cache, we could go for
    a time control: calling a function such as `fib()`, for a large value of n, should
    take quite longer if the function were not memoized. This is certainly possible,
    but it''s also prone to possible failures: something external to your tests could
    run at just the wrong time and it could be possible that your memoized run would
    take longer than the original one. OK, it''s possible, but not probable -- but
    your test isn''t fully reliable.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接受我们应该省略尝试检查缓存，我们可以进行时间控制：调用一个函数，比如`fib()`，对于一个很大的n值，如果函数没有进行记忆化，应该需要更长的时间。这当然是可能的，但也容易出现可能的失败：你的测试之外的某些东西可能会在恰好的时候运行，可能你的记忆化运行时间会比原始运行时间更长。好吧，这是可能的，但不太可能--但你的测试并不完全可靠。
- en: 'Let''s go then for a more direct analysis of the number of actual calls to
    the memoized function. Working with a non-memoized, original, `fib()`, we could
    first test whether the function works normally and check how many calls it makes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们更直接地分析记忆化函数的实际调用次数。使用非记忆化的原始`fib()`，我们可以首先测试函数是否正常工作，并检查它调用了多少次：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The fact that `fib(6)` equals 8 is easy to verify, but where do you get that
    the function is called 25 times? For the answer, let''s revisit the diagram we
    saw earlier in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib(6)`等于8这一事实很容易验证，但你怎么知道函数被调用了25次？为了回答这个问题，让我们重新看一下之前在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中看到的图表，*行为得体-纯函数*：'
- en: '![](assets/0a11cde8-aa6d-4f15-ac1d-007e56138d1c.png)Figure 6.1\. All the recursive
    calls needed for calculating fib(6).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1。计算fib(6)所需的所有递归调用。
- en: 'Each node is a call; just counting, we get that in order to calculate `fib(6)`,
    25 calls are actually made to `fib()`. Now, let''s turn to the memoized version
    of the function. Testing that it still produces the same results is easy:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都是一个调用；仅仅计数，我们得到为了计算`fib(6)`，实际上有25次对`fib()`的调用。现在，让我们转向函数的记忆版本。测试它是否仍然产生相同的结果很容易：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But why is it called 11 times for calculating `fib(6)`, and then three times
    more after calculating `fib(5)`, `fib(4)`, and `fib(3)`? To answer the first part
    of the question, let''s analyze the figure we saw earlier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么在计算`fib(6)`时被调用了11次，然后在计算`fib(5)`，`fib(4)`和`fib(3)`之后又被调用了三次？为了回答问题的第一部分，让我们分析一下之前看到的图：
- en: 'First, we call `fib(6)`, which calls `fib(4)` and `fib(5)`: three calls'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们调用`fib(6)`，它调用了`fib(4)`和`fib(5)`：三次调用
- en: When calculating `fib(4)`, `fib(2)` and `fib(3)` are called; the count is up
    to five
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算`fib(4)`时，调用了`fib(2)`和`fib(3)`；计数增加到了五
- en: When calculating `fib(5)`, `fib(3)` and `fib(4)` are called; the count climbs
    to 11
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算`fib(5)`时，调用了`fib(3)`和`fib(4)`；计数上升到11
- en: Finally, `fib(6)` is calculated and cached
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，计算并缓存了`fib(6)`
- en: '`fib(3)` and `fib(4)` are both cached, so no more calls are done'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(3)`和`fib(4)`都被缓存了，所以不再进行调用'
- en: '`fib(5)` is calculated and cached'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(5)`被计算并缓存'
- en: When calculating `fib(2)`, `fib(0)` and `fib(1)` are called; now we have seven
    calls
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算`fib(2)`时，调用了`fib(0)`和`fib(1)`；现在我们有了七次调用
- en: When calculating `fib(3)`, `fib(1)` and `fib(2)` are called; the count is up
    to nine
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算`fib(3)`时，调用了`fib(1)`和`fib(2)`；计数增加到了九
- en: '`fib(4)` is calculated and cached'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(4)`被计算并缓存'
- en: '`fib(1)` and `fib(2)` are both already cached, so no further calls are made'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(1)`和`fib(2)`都已经被缓存了，所以不会再进行进一步的调用'
- en: '`fib(3)` is calculated and cached'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(3)`被计算并缓存'
- en: When calculating `fib(0)` and `fib(1)`, no extra calls are made, and both are
    cached
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算`fib(0)`和`fib(1)`时，不会进行额外的调用，两者都被缓存了
- en: '`fib(2)` is calculated and cached'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(2)`被计算并缓存'
- en: 'Whew! So the count of calls for `fib(6)` is 11 -- and now, given that all the
    values of `fib(n)` have been cached, for n from 0 to 6, it''s easy to see why
    calculating `fib(5)`, `fib(4)`, and `fib(3)` only adds three calls: all the other
    required values are already cached.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！所以`fib(6)`的调用次数是11--现在，鉴于所有`fib(n)`的值都已经被缓存，对于n从0到6，很容易看出计算`fib(5)`，`fib(4)`和`fib(3)`只会增加三次调用：所有其他所需的值都已经被缓存。
- en: Altering functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变函数
- en: In the previous section, we considered some ways of wrapping functions, so they
    would maintain their original functionality, though enhanced in some ways. Now
    we'll turn to actually modifying what the functions do, so the new results will
    actually differ from the original function's ones.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们考虑了一些包装函数的方法，使它们保持其原始功能，尽管在某些方面得到了增强。现在我们将转而实际修改函数的功能，使新的结果实际上与原始函数的结果不同。
- en: Doing things once, revisited
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新做一次事情
- en: 'Back in Chapter 2, *Thinking Functionally - A First Example*, we went through
    an example of developing an FP-style solution for a simple problem: fixing things
    so a given function would work only once:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第2章，*思考功能性-第一个例子*，我们通过一个简单的问题的FP风格解决方案的例子：修复一个给定函数只能工作一次的问题：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a perfectly fine solution, and we have nothing to object to. We can,
    however, think of a variation. We could observe that the given function gets called
    once, but its return value gets lost. That''s easy to fix, however; all we require
    is adding a `return` statement. However, that wouldn''t be enough; what would
    the function return if called more times? We can take a page out of the memoizing
    solution and store the function''s return value for future calls:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全合理的解决方案，我们没有任何异议。然而，我们可以考虑一种变体。我们可以观察到给定的函数被调用一次，但其返回值被丢失了。然而，这很容易解决；我们只需要添加一个`return`语句。然而，这还不够；如果调用更多次，函数会返回什么呢？我们可以借鉴记忆化解决方案，并为将来的调用存储函数的返回值：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You could also think of making the function work only once, but for each set
    of arguments... but you wouldn''t have to do any work for that: `memoize()` would
    be enough!'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以考虑使函数仅对每组参数起作用一次...但是你不必为此做任何工作：`memoize()`就足够了！
- en: 'Back in the mentioned [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, we considered a possible alternative
    to `once()`: another higher-order function that took two functions as parameters
    and allowed the first function to be called only once, calling the second function
    from that point on. Adding a `return` statement as earlier, it would have been
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回到提到的[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)，*函数式思维 - 第一个例子*，我们考虑了`once()`的一个可能替代品：另一个高阶函数，它以两个函数作为参数，并且只允许调用第一个函数一次，从那时起调用第二个函数。添加一个`return`语句，它将如下所示：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can rewrite this if we remember that functions are first-order objects.
    Instead of using a flag to remember which function to call, we can use a variable
    (`toCall`) to directly store whichever function needs to be called. Logically,
    that variable will be initialized to the first function, but will then change
    to the second one:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得函数是一级对象，我们可以重写这个过程。我们可以使用一个变量（`toCall`）直接存储需要调用的函数，而不是使用标志来记住要调用哪个函数。从逻辑上讲，该变量将被初始化为第一个函数，但随后将更改为第二个函数：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The very same example we saw before would still work:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的完全相同的例子仍然可以工作：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In terms of performance, the difference may be negligible. The reason for showing
    this further variation is just to keep in mind that by storing functions, you
    can often produce results in a simpler way. Using flags to store state is a common
    technique, used everywhere in procedural programming. However, here we manage
    to skip that usage, and yet produce the same result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，差异可能微乎其微。展示这种进一步变化的原因只是为了记住，通过存储函数，你通常可以以更简单的方式产生结果。在过程式编程中，使用标志存储状态是一种常见的技术，随处可见。然而，在这里，我们设法跳过了这种用法，但却产生了相同的结果。
- en: Logically negating a function
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑否定一个函数
- en: Let's consider the `.filter()` method from [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*. Given a predicate, we can filter
    the array to only include those elements for which the predicate is true. But
    how would you do a reverse filter and *exclude* the elements for which the predicate
    is true?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下来自[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的`.filter()`方法，*声明式编程
    - 更好的风格*。给定一个谓词，我们可以过滤数组，只包括谓词为真的元素。但是如何进行反向过滤并*排除*谓词为真的元素呢？
- en: 'The first solution should be pretty obvious: rework the predicate, so it will
    return the opposite of whatever it originally returned. In the previously mentioned
    chapters, we saw this example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案应该是相当明显的：重新设计谓词，使其返回与原始返回值相反的值。在前面提到的章节中，我们看到了这个例子：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, we could just write it the other way round, in either of these two equivalent
    fashions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以以另一种方式写出它，以这两种等效方式之一：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s perfectly fine, but we could also have had something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可以的，但我们也可以有类似以下的东西：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, rewriting the original function isn''t possible. However, working
    in a functional way, we can just write a higher-order function that will take
    any predicate, evaluate it, and then negate its result. A possible implementation
    would be quite simple, thanks to ES8''s syntax:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重写原始函数是不可能的。然而，在函数式编程中，我们可以编写一个高阶函数，它将接受任何谓词，评估它，然后否定其结果。由于ES8的语法，可能的实现会非常简单：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Working in this way, we could have rewritten the preceding filter as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作，我们可以将前面的过滤重写为以下形式：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is an additional solution we might want to try out -- instead of reversing
    the condition (as we did), we could write a new filtering method (possibly `filterNot()`?)
    that would work in the opposite way to `filter()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要尝试的另一个解决方案是--而不是颠倒条件（如我们所做的），我们可以编写一个新的过滤方法（可能是`filterNot()`？），它将以与`filter()`相反的方式工作：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This solution doesn't fully match `.filter()`, since you cannot use it as a
    method, but we could either add it to `Array.prototype`, or apply some methods
    that we'll be seeing in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*. It's more interesting, though,
    to note that we used the negated function, so `not()` is actually necessary for
    both solutions to the reverse filtering problem. In the upcoming Demethodizing
    section, we will see that we have yet another solution since we will be able to
    decouple methods such as `.filter()` from the objects they apply to, changing
    them into common functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案与`.filter()`并不完全匹配，因为你不能将其用作方法，但我们可以将其添加到`Array.prototype`中，或者应用一些我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中看到的方法，*连接函数
    - 管道和组合*。然而，更有趣的是，我们使用了否定的函数，因此`not()`对于反向过滤问题的两种解决方案都是必要的。在即将到来的去方法化部分中，我们将看到另一个解决方案，因为我们将能够将诸如`.filter()`之类的方法与它们适用的对象分离开来，将它们变成普通函数。
- en: 'As for negating the function *versus* using a new `filterNot()`, even though
    both possibilities are equally valid, I think using `not()` is more clear; if
    you already understand how filtering works, then you can practically read it aloud
    and it will be understandable: we want those that don''t have a negative balance,
    right?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 至于否定函数*与*使用新的`filterNot()`，尽管两种可能性同样有效，但我认为使用`not()`更清晰；如果你已经理解了过滤的工作原理，那么你几乎可以大声朗读它，它就会被理解：我们想要那些没有负余额的，对吧？
- en: Inverting results
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转结果
- en: 'In the same vein as the preceding filtering problem, let''s now revisit the
    sorting problem from the *Injection - sorting* it out section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*. We wanted to sort an array with
    some specific method, and we used `.sort()`, providing it with a comparison function
    that basically pointed out which of two strings should go first. To refresh your
    memory, given two strings, the function should do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的过滤问题类似，现在让我们重新讨论[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)中的*注入-排序*部分中的排序问题，*从函数开始-核心概念*。我们想要使用特定的方法对数组进行排序，并且我们使用了`.sort()`，提供了一个比较函数，基本上指出了哪个字符串应该先进行排序。为了提醒你，给定两个字符串，函数应该执行以下操作：
- en: Return a negative number, it the first string should precede the second one
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个字符串应该在第二个字符串之前，则返回一个负数
- en: Return zero if both strings are the same
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个字符串相同，则返回零
- en: Return a positive number, if the first string should follow the second one
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个正数，如果第一个字符串应该跟在第二个字符串后面
- en: Let's go back to the code we saw earlier for sorting in Spanish. We had to write
    a special comparison function, so sorting would take into account the special
    character order rules from Spanish, such as including letter *ñ* between *n* and
    *o*, and more.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前在西班牙语排序中看到的代码。我们必须编写一个特殊的比较函数，以便排序能够考虑西班牙语的特殊字符顺序规则，比如在*n*和*o*之间包括字母*ñ*，等等。
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are facing a similar problem: how can we manage to sort in a *descending*
    order? Given what we just saw in the previous section, two alternatives should
    immediately come to mind:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临着类似的问题：我们如何能够以*降序*的方式进行排序？根据我们在前一节中看到的内容，应该立即想到两种替代方案：
- en: Write a function that will invert the result from the comparing function. This
    will invert the result of all decisions as to which string should precede, and
    the final result will be an array sorted in exactly the opposite way.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，它将反转比较函数的结果。这将反转所有关于哪个字符串应该在前面的决定，最终结果将是一个完全相反排序的数组。
- en: Write a `sortDescending()` function or method, that does its work in the opposite
    fashion to `sort()`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`sortDescending()`函数或方法，以与`sort()`相反的方式进行工作。
- en: 'Let''s write an `invert()` function that will take change the result of a comparison.
    The code itself is quite similar to that of preceding `not()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`invert()`函数，它将改变比较的结果。代码本身与前面的`not()`非常相似：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Given this higher-order function, we can now sort in descending order by just
    providing a suitably inverted comparison function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个高阶函数，我们现在可以通过提供一个适当反转的比较函数来进行降序排序：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as expected: when we `invert()` the comparison function, the
    results are in the opposite order. By the way, writing unit tests would be quite
    easy, given that we already have some test cases with their expected results,
    wouldn''t it?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与预期相符：当我们`invert()`比较函数时，结果是相反的顺序。顺便说一句，编写单元测试将非常容易，因为我们已经有了一些测试用例和它们的预期结果，不是吗？
- en: Arity changing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变参数数量
- en: 'Back in the *Parsing numbers s*ection *tacitly* of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, we saw that using `parseInt()` with
    `.reduce()` would produce problems, because of the unexpected arity of that function,
    which took more than one argument:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中*隐式地*解析数字的部分，我们看到使用`parseInt()`与`.reduce()`会产生问题，因为该函数的参数数量是意外的，它需要多于一个参数：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have more than one way to solve this. In the mentioned chapter, we went
    with an arrow function, that is a simple solution, with the added advantage of
    being clear to understand. In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*, we will see yet another,
    based on partial application. But, here, let''s go with a higher-order function.
    What we need, is a function that will take another function as a parameter, and
    turn it into a unary function. Using JS''s spread operator and an arrow function,
    that''s easy to manage:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种解决方法。在提到的章节中，我们选择了箭头函数，这是一个简单的解决方案，而且具有清晰易懂的优势。在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中，*转换函数-柯里化和部分应用*，我们将看到另一种方法，基于部分应用。但是，在这里，让我们使用一个高阶函数。我们需要的是一个函数，它将另一个函数作为参数，并将其转换为一元函数。使用JS的展开运算符和箭头函数，这很容易管理：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using this function, our number parsing problem goes away:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们的数字解析问题就解决了：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It goes without saying that it would be equally simple to define further `binary()`,
    `ternary()`, and so on functions that would turn any function into an equivalent,
    restricted-arity, version.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，同样简单地定义进一步的`binary()`、`ternary()`等函数，可以将任何函数转换为等效的、限定数量参数的版本。
- en: You may think there aren't many cases in which you would want to apply this
    kind of solution, but in fact, there are many more than you would expect. Going
    through all of JavaScript's functions and methods, you can easily produce a list
    starting with `.apply()`, `.assign()`, `.bind()`, `.concat()`, `.copyWithin()`...
    and many more! If you wanted to use any of those in a tacit way, you would probably
    need to fix its arity, so it would work with a fixed, non-variable, number of
    parameters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为没有多少情况需要应用这种解决方案，但事实上，情况比你想象的要多得多。通过查看所有JavaScript的函数和方法，你可以轻松地列出一个以`.apply()`、`.assign()`、`.bind()`、`.concat()`、`.copyWithin()`...等等开头的列表！如果你想以一种心照不宣的方式使用其中任何一个，你可能需要修复它的参数数量，这样它就可以使用固定的、非可变的参数数量。
- en: If you want a nice list of JavaScript functions and methods, check out the pages
    at [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions)
    and at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index).
    As for tacit (or point freestyle) programming, we'll be coming back to it in [Chapter
    8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions - Pipelining
    and Composition*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个漂亮的JavaScript函数和方法列表，请查看[https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions)和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index)上的页面。至于暗示（或点自由风格）编程，我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中回到它，*连接函数
    - 管道和组合*。
- en: Other higher-order functions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他高阶函数
- en: Let's end this chapter by considering other sundry functions that provide results
    such as new finders, decoupling method from objects, and more.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章结束时考虑其他杂项函数，提供诸如新查找器、将方法与对象解耦等结果。
- en: Turning operations into functions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将操作转换为函数
- en: 'We have already seen several cases in which we needed to write a function just
    to add or multiply a pair of numbers. For example, in the *Summing an array* section
    of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we had to write code equivalent to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种情况，我们需要编写一个函数来添加或乘以一对数字。例如，在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的*求和数组*部分，*声明式编程
    - 更好的风格*，我们不得不编写等效于以下代码的代码：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the same chapter, in the section *Working with ranges*, to calculate a factorial,
    we then needed this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章节中，在*使用范围*部分，为了计算阶乘，我们需要这样：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It would have been easier if we could just turn a binary operator into a function
    that calculates the same result. The preceding two examples could have been written
    more succinctly, shown as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将二元运算符转换为计算相同结果的函数，那将会更容易。前面的两个例子可以更简洁地写成如下所示：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implementing operations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施操作
- en: 'How would we write this `binaryOp()` function? There are at least two ways
    of doing so: a safe but long one and a riskier and shorter alternative. The first
    would require listing each possible operator:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写这个`binaryOp()`函数？至少有两种方法：一种安全但冗长，一种更冒险但更短的替代方法。第一种方法需要列出每个可能的运算符：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This solution is perfectly fine but requires too much work. The second is more
    dangerous, but shorter. Please consider this just as an example, for learning
    purposes; using `eval()` isn't recommended for security reasons!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案完全没问题，但需要太多的工作。第二个更危险，但更短。请将其仅视为一个示例，用于学习目的；出于安全原因，不建议使用`eval()`！
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you follow this trail of thought, you may also define an `unaryOp()` function,
    even though there are fewer applications for it. (I leave this implementation
    to you; it's quite similar to what we already wrote.) In the upcoming [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*, we will see an alternative way of creating this unary
    function by using partial application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这种思路，你也可以定义一个`unaryOp()`函数，尽管它的应用更少。 （我把这个实现留给你；它与我们已经写的内容非常相似。）在即将到来的[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中，*转换函数
    - 柯里化和部分应用*，我们将看到创建这个一元函数的另一种方法，即使用部分应用。
- en: A handier implementation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更方便的实现
- en: 'Let''s get ahead of ourselves. Doing FP doesn''t mean always getting down to
    the very basic, simplest possible functions. For example, in the *Converting to
    free point style* section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, we will need a function to
    check if a number is negative, and we''ll consider using `binaryOp2()` to write
    it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们超前一步。进行FP并不意味着总是要回到非常基本、最简单的函数。例如，在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)的*转换为自由点风格*部分，*连接函数
    - 管道和组合*，我们将需要一个函数来检查一个数字是否为负数，并考虑使用`binaryOp2()`来编写它：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Never mind about the `curry()` function now (we''ll get to it soon in [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*) but the idea is that it fixes the first argument to
    zero, so our function will check, for a given number *n*, whether *0>n*. The point
    here is that the function we just wrote isn''t quite clear. We could do better
    if we defined a binary operation function that also let us specify one of its
    parameters, the left one or the right one, in addition to the operator to be used:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心`curry()`函数（我们很快会在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中讨论它，*转换函数
    - 柯里化和部分应用*），但其思想是将第一个参数固定为零，因此我们的函数将检查给定数字*n*是否*0>n*。这里的重点是，我们刚刚编写的函数并不是很清晰。如果我们定义一个二元操作函数，还可以让我们指定其参数之一，左边的参数或右边的参数，以及要使用的运算符，我们可以做得更好：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, you could have gone back to the `new Function()` style of code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以回到`new Function()`风格的代码：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With these new functions, we could simply write either of the following --
    though I think the second is clearer: I''d rather test whether a number is less
    than zero, rather than whether zero is greater than the number:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新函数，我们可以简单地写出以下任一代码--尽管我认为第二个更清晰：我宁愿测试一个数字是否小于零，而不是零是否大于该数字：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What is the point of this? Don't strive for some kind of *basic simplicity*
    or *going down to basics* code. We can transform an operator into a function,
    true -- but if you can do better, and simplify your coding, by also allowing to
    specify one of the two parameters for the operation, just do it! The idea of FP
    is helping write better code, and creating artificial limitations won't help anybody.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么意义？不要追求某种*基本简单*或*回归基础*的代码。我们可以将运算符转换为函数，没错--但如果你能做得更好，并通过允许指定操作的两个参数之一来简化编码，那就去做吧！FP的理念是帮助编写更好的代码，而创造人为限制对任何人都没有好处。
- en: 'Of course, for a simple function such as checking whether a number is negative,
    I would never want to complicate things with currying or binary operators or point
    freestyle or anything else, and I''d just write the following with no further
    ado:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于一个简单的函数，比如检查一个数字是否为负数，我绝对不想用柯里化、二元运算符或点自由风格或其他任何东西来复杂化事情，我只会毫不犹豫地写出以下内容：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Turning functions into promises
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数转换为promises
- en: 'In Node, most asynchronous functions require a callback such as `(err,data)=>{...}`:
    if `err` is `null`, the function was successful, and `data` is its result, and
    if `err` has some value, the function failed, and `err` gives the cause. (See
    [https://nodejs.org/api/errors.html#errors_node_js_style_callbacks](https://nodejs.org/api/errors.html#errors_node_js_style_callbacks)
    for more on this.)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中，大多数异步函数需要一个回调，比如`(err,data)=>{...}`：如果`err`是`null`，函数成功，`data`是其结果，如果`err`有一些值，函数失败，`err`给出了原因。（有关更多信息，请参见[https://nodejs.org/api/errors.html#errors_node_js_style_callbacks](https://nodejs.org/api/errors.html#errors_node_js_style_callbacks)。）
- en: However, you might prefer to work with promises instead. So, we can think of
    writing a higher-order function that will transform a function that requires a
    callback into a promise that lets you use `.then()` and `.catch()` methods. (In
    [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better Containers
    - Functional Data Types*, we will see that promises are actually monads, so this
    transformation is interesting in yet another way.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能更喜欢使用promises。因此，我们可以考虑编写一个高阶函数，将需要回调的函数转换为一个promise，让您使用`.then()`和`.catch()`方法。（在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中，*构建更好的容器-功能数据类型*，我们将看到promises实际上是monads，因此这种转换在另一个方面也很有趣。）
- en: 'How can we manage this? The transformation is rather simple. Given a function,
    we produce a new one: this will return a promise that, upon calling the original
    function with some parameters, will either `reject()` or `resolve()` the promise
    appropriately:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何管理这个？转换相当简单。给定一个函数，我们生成一个新的函数：这将返回一个promise，当使用一些参数调用原始函数时，将适当地`reject()`或`resolve()`promise：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With this function, instead of writing code like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，我们可以这样写代码：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Instead, you can go with promises:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用promises：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now you would be able to use `fspromise()` instead of the original method. We
    had to bind `fs.readFile`, as we mentioned in the *An unnecessary mistake* section
    of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用`fspromise()`而不是原始方法。我们必须绑定`fs.readFile`，正如我们在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*一个不必要的错误*部分中提到的那样，*从函数开始-核心概念*。
- en: Getting a property from an object
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从对象中获取属性
- en: 'There is a simple, but often used, function that we could also produce. Extracting
    an attribute from an object is a commonly required operation. For example, in
    [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we had to get latitudes and longitudes to be able to calculate
    an average:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单但经常使用的函数，我们也可以生成。从对象中提取属性是一个常见的操作。例如，在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中，*以声明方式编程-更好的风格*，我们需要获取纬度和经度以便计算平均值：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We had another example when we saw how to filter an array; in our example,
    we wanted to get the IDs for all accounts with a negative balance and, after filtering
    out all other accounts, we still needed to extract the ID field:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到如何过滤数组时，我们有另一个例子；在我们的例子中，我们想要获取所有余额为负的帐户的ID，并在过滤掉所有其他帐户后，我们仍然需要提取ID字段：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We could have joined those two lines, and produced the desired result with a
    one-liner, but that's not relevant here. In fact, unless the `delinquent` intermediate
    result was needed for some reason, most FP programmers would go for the one-line
    solution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将这两行合并，并用一行代码产生所需的结果，但这里并不重要。事实上，除非`delinquent`中间结果出于某种原因是必需的，大多数FP程序员都会选择一行解决方案。
- en: 'What do we need? We need a higher-order function that will receive the name
    of an attribute, and produce as its result a new function that will be able to
    extract said attribute from an object. Using ES8 syntax, this function is easy
    to write:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要什么？我们需要一个高阶函数，它将接收一个属性的名称，并产生一个新的函数作为其结果，这个函数将能够从对象中提取所述属性。使用ES8语法，这个函数很容易编写：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the *Getters and Setters* section of [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*, we'll write an even more general version of
    this function, able to "go deep" into an object, to get any attribute of it, no
    matter its location within the object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)的*获取器和设置器*部分，*确保纯度-不可变性*，我们将编写这个函数的更通用版本，能够“深入”到对象中，获取对象的任何属性，无论其在对象中的位置如何。
- en: 'With this function, the coordinates extraction could have been written as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个函数，坐标提取可以这样写：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For variety, we could have used an auxiliary variable to get the delinquent
    ID's.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，我们可以使用辅助变量来获取拖欠的ID。
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Be sure to fully understand what's going on here. The result of the `getField()`
    call is a function, which will be used in further expressions. The `map()` method
    requires a mapping function and that's what `getField()` produces.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要完全理解这里发生了什么。`getField()`调用的结果是一个函数，将在进一步的表达式中使用。`map()`方法需要一个映射函数，这就是`getField()`产生的东西。
- en: Demethodizing - turning methods into functions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去方法化-将方法转换为函数
- en: Methods such as `.filter()` or `.map()` are only available for arrays -- but
    in fact, you could want to apply them to, say, a `NodeList` or a `String`, and
    you'd be out of luck. Also, we are focusing on strings, so having to use these
    functions as methods is not exactly what we had in mind. Finally, whenever we
    create a new function (such as `none()`, which we saw in the *Checking Negatives*
    section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*), it cannot be applied in the same way as its
    peers (`.some()` and `.every()`, in this case) unless you do some prototype trickery
    -- which is rightly frowned upon, and not recommended at all... but do see the
    *Extending current data types* section of [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, where we will make `.map()`
    available for most basic types!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter()`或`.map()`等方法仅适用于数组--但实际上，你可能希望将它们应用于`NodeList`或`String`，但你可能会碰壁。此外，我们正在关注字符串，因此必须将这些函数用作方法并不是我们想要的。最后，每当我们创建一个新函数（比如`none()`，我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)
    *以更好的方式编程 - 声明式编程* 的*检查否定*部分中看到的），它不能像它的同行（在这种情况下是`.some()`和`.every()`）那样应用，除非你做一些原型的把戏--这是被严厉谴责的，也完全不推荐...但是请看[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)
    *构建更好的容器 - 函数数据类型* 的*扩展当前数据类型*部分，我们将使`.map()`适用于大多数基本类型！'
- en: So... what can we do? We can apply the old saying *If the mountain won't come
    to Muhammad, then Muhammad must go to the mountain* and, instead of worrying about
    not being able to create new methods, we will turn the existing methods into functions.
    We can do that, if we convert each method into a function that will receive, as
    its first parameter, the object it will work on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么...我们能做什么呢？我们可以应用古话*如果山不来，穆罕默德就去山*，而不是担心无法创建新的方法，我们将现有的方法转换为函数。如果我们将每个方法转换为一个函数，该函数将作为其第一个参数接收它将要操作的对象。
- en: Decoupling methods from objects can help you, because once you achieve this
    separation, everything turns out to be a function, and your code will be simpler.
    (Remember what we wrote preceding, in the *Logically negating a function*, regarding
    a possible `filterNot()` function in comparison to the `.filter()` method?) A
    decoupled method works in a fashion somewhat similar to what are called *generic*
    functions in other languages since they can be applied to diverse data types.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦方法和对象可以帮助你，因为一旦你实现了这种分离，一切都变成了一个函数，你的代码会更简单。（还记得我们在*逻辑否定一个函数*中写的内容吗，关于可能的`filterNot()`函数与`.filter()`方法的比较？）解耦的方法在某种程度上类似于其他语言中所谓的*通用*函数，因为它们可以应用于不同的数据类型。
- en: There are three distinct, but similar, ways to implement this in ES8\. The first
    argument in the list will correspond to the object; the other arguments, to the
    actual ones for the called method;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES8中，有三种不同但相似的实现方式。列表中的第一个参数将对应于对象；其他参数将对应于被调用方法的实际参数。
- en: See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for explanations on `apply()`, `call()`, and `bind()`. By the way, back in [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, we saw the equivalence between `.apply()` and `.call()` when you used
    the spread operator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)以了解`apply()`、`call()`和`bind()`的解释。顺便说一句，在[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)
    *成为函数 - 几个问题* 中，我们看到了在使用展开运算符时`.apply()`和`.call()`之间的等价性。
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There''s yet another way of doing this: `demethodize = Function.prototype.bind.bind(Function.prototype.call)`.
    If you want to understand how this works, read Leland Richardson''s *Clever way
    to* demethodize *Native JS Methods*, at [http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法：`demethodize = Function.prototype.bind.bind(Function.prototype.call)`。如果你想了解这是如何工作的，请阅读Leland
    Richardson的*Clever way to* demethodize *Native JS Methods*，网址为[http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods)。
- en: 'Let''s see some applications for those! Starting with a simple example, we
    can use `.map()` to loop over a string, without first converting it into an array
    of characters. Say you wanted to separate a string into individual letters and
    turn them into upper case:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些应用！从一个简单的例子开始，我们可以使用`.map()`来循环遍历一个字符串，而不必先将其转换为字符数组。假设你想将一个字符串分隔成单个字母并将它们转换为大写：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, if we demethodize both `.map()` and `.toUpperCase()`, we can simply
    write the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们解除了`.map()`和`.toUpperCase()`，我们可以简单地写成以下形式：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Yes, for this particular case, we could have first turned the string into uppercase,
    and then split it into separate letters, as in `name.toUpperCase().split("")`
    -- but it wouldn't have been such a nice example, with two usages of demethodizing
    no less, would it?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，对于这种特殊情况，我们可以先将字符串转换为大写，然后将其拆分为单独的字母，如`name.toUpperCase().split("")` -- 但这不会是一个很好的例子，毕竟有两个解除方法的用法，对吧？
- en: 'In a similar way, we could convert an array of decimal amounts into properly
    formatted strings, with thousands of separators and decimal points:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以将一个十进制金额数组转换为格式正确的字符串，带有千位分隔符和小数点：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, given the preceding map function, this would have also worked:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，给定前面的map函数，这也可以工作：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The idea of demethodizing a method to turn it into a function will prove to
    be quite useful in diverse situations. We have already seen some examples where
    we could have applied it and there will be more such cases in the rest of the
    book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法解除为函数的想法在不同的情况下将会非常有用。我们已经看到了一些例子，我们可以应用它，并且在本书的其余部分还会有更多这样的情况。
- en: Finding the optimum
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到最佳解决方案
- en: 'Let''s end this section by creating an extension of the `.find()` method. Suppose
    we want to find the optimum value --let''s suppose it''s the maximum-- of an array
    of numbers:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建`.find()`方法的扩展来结束本节。假设我们想要找到数组中的最优值--假设它是最大值--：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, is this sufficiently general? There are at least a pair of problems with
    this approach. First, are you sure that the optimum of a set will always be the
    maximum? If you were considering several mortgages, the one with *lowest* interest
    rate could be the best, couldn't it? Assuming that we would always want the *maximum*
    of a set is too constrictive.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是否足够通用？这种方法至少存在一对问题。首先，你确定集合的最优值总是最大值吗？如果你考虑了几种抵押贷款，那么利率最低的那个可能是最好的，不是吗？假设我们总是想要集合的*最大值*太过于局限了。
- en: 'You could do a roundabout trick: if you change the signs of all the numbers
    in an array, find its maximum, and change its sign, then you actually get the
    minimum of the array. In our case, `-findOptimum(myArray.map((x) => -x))` would
    produce 4 -- but it''s not easily understandable code.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以绕个弯：如果你改变数组中所有数字的符号，找到它的最大值，然后改变它的符号，那么你实际上得到了数组的最小值。在我们的例子中，`-findOptimum(myArray.map((x)
    => -x))`将产生4--但这不是容易理解的代码。
- en: 'Second, this way of finding the maximum depends on each option having a numeric
    value. But how would you find the optimum, if such a value didn''t exist? The
    usual way depends on comparing elements with each another and picking the one
    that comes on top of the comparison: compare the first element with the second
    and keep the best of those two; then compare that value with the third element
    and keep the best; and keep at it until you have finished going through all the
    elements.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，找到最大值的这种方式取决于每个选项都有一个数值。但如果这样的值不存在，你该如何找到最优值？通常的方法依赖于将元素相互比较，并选择在比较中排在前面的元素：将第一个元素与第二个元素进行比较，并保留其中较好的那个；然后将该值与第三个元素进行比较，并保留最好的；依此类推，直到你完成了所有元素的遍历。
- en: The way to solve this problem with more generality is to assume the existence
    of a `comparator()` function, that takes two elements as arguments, and returns
    the best of those. If you could associate a numeric value to each element, then
    the comparator function could simply compare those values. In other cases, it
    could do whatever logic is needed in order to decide what element comes out on
    top.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以更一般的方式解决这个问题的方法是假设存在一个`comparator()`函数，它以两个元素作为参数，并返回最好的那个。如果你能为每个元素关联一个数值，那么比较函数可以简单地比较这些值。在其他情况下，它可以根据需要执行任何逻辑，以便决定哪个元素排在前面。
- en: 'Let''s try to create an appropriate higher-order function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个合适的高阶函数：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With this, we can easily replicate maximum- and minimum-finding functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以轻松地复制最大值和最小值查找函数。
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s go one better, and compare non-numeric values. Let''s imagine a superheroes
    card game: each card represents a hero, with several numeric attributes, such
    as Strength, Powers, and Tech. When two heroes fight each other, the one with
    more categories with higher values than the other is the winner. Let''s implement
    a comparator for this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更上一层楼，比较非数值值。假设有一款超级英雄卡牌游戏：每张卡代表一个英雄，具有几个数值属性，如力量、能力和科技。当两个英雄互相对抗时，具有更多类别的英雄，其数值高于另一个英雄，将成为赢家。让我们为此实现一个比较器：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we can apply this to our "tournament" of heroes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这应用到我们的英雄“比赛”中：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When you rank elements according to one-to-one comparisons, unexpected results
    may be produced. For instance, with our superheroes comparison rules, you could
    find three heroes such that the first beats the second, the second beat the third,
    but the third beats the first! In mathematical terms, this means that the comparison
    function is not transitive and you don't have a *total ordering* for the set.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你根据一对一比较对元素进行排名时，可能会产生意想不到的结果。例如，根据我们的超级英雄比较规则，你可能会找到三个英雄，第一个击败第二个，第二个击败第三个，但第三个击败第一个！在数学术语中，这意味着比较函数不是传递的，你没有集合的*完全排序*。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 6.1\. **A border case**. What happens with our `getField()` function if we apply
    it to a null object? What should its behavior be? If necessary, modify the function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 6.1\. **一个边界情况**。如果我们将`getField()`函数应用于一个空对象，会发生什么？它应该是什么行为？如果需要，修改该函数。
- en: 6.2\. **How many?** How many calls would be needed to calculate `fib(50)` without
    memoizing? For example, to calculate `fib(0)` or `fib(1)`, one call is enough
    with no further recursion needed, and for `fib(6)` we saw that 25 calls were required.
    Can you find a formula to do this calculation?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2\. **多少次？** 要计算`fib(50)`需要多少次调用而不使用记忆化？例如，计算`fib(0)`或`fib(1)`，只需要一次调用，不需要进一步递归，而对于`fib(6)`，我们看到需要25次调用。你能找到一个公式来做这个计算吗？
- en: 6.3\. **A randomizing balancer**. Write a higher-order function `randomizer(fn1,
    fn2, ...)` that will receive a variable number of functions as arguments, and
    return a new function that will, on each call, randomly call one of `fn1`, `fn2`,
    and so on. You could possibly use this to balance calls to different services
    on a server if each function was able to do an Ajax call. For bonus points, ensure
    that no function will be called twice in a row.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 6.3\. **一个随机平衡器**。编写一个高阶函数`randomizer(fn1, fn2, ...)`，它将接收可变数量的函数作为参数，并返回一个新的函数，该函数在每次调用时将随机调用`fn1`、`fn2`等。如果每个函数都能执行Ajax调用，你可能会用到这个函数来平衡对服务器上不同服务的调用。为了加分，确保连续两次不会调用同一个函数。
- en: 6.4\. **Just say no!** In this chapter, we wrote a `not()` function that worked
    with boolean functions and a `negate()` function that worked with numerical ones.
    Can you go one better and just write a single `opposite()` function that will
    behave as `not()` or `negate()` as needed?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 6.4\. **只说不！** 在本章中，我们编写了一个与布尔函数一起工作的`not()`函数和一个与数值函数一起工作的`negate()`函数。你能更上一层楼，只编写一个`opposite()`函数，根据需要表现为`not()`或`negate()`吗？
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how to write higher-order functions of our own,
    which can either wrap another function to provide some new feature, alter a function's
    objective so it will do something else, or even totally new features, such as
    decoupling methods from objects or creating better finders.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到如何编写我们自己的高阶函数，它可以包装另一个函数以提供一些新功能，改变函数的目标以便做其他事情，甚至是全新的功能，比如将方法与对象解耦或创建更好的查找器。
- en: In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions
    - Currying and Partial Application*, we'll still keep working with higher-order
    functions, and we'll see how to produce specialized versions of existing functions,
    with predefined arguments, by currying and partial application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中，*函数转换-柯里化和部分应用*，我们将继续使用高阶函数，并且我们将看到如何通过柯里化和部分应用来生成现有函数的专门版本，带有预定义的参数。
