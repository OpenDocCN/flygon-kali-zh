- en: Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Kotlin takes design patterns pretty seriously. Previously, we've seen how the
    usage of the Singleton pattern was simplified by object declarations, and how
    usage of the Observator pattern was trivialized thanks to higher order functions
    and functional type. Also, Kotlin simplified the usage of most functional patterns,
    thanks to lambda expressions and functional types. In this chapter, we will see
    how usage of Delegation and Decorator patterns were simplified thanks to class
    delegation. We will also see a feature, which is pretty new in the programming
    world--property delegation--and how it is used to make Kotlin properties much
    more powerful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin非常重视设计模式。之前，我们已经看到了单例模式的使用是如何通过对象声明简化的，以及观察者模式的使用是如何通过高阶函数和函数类型变得微不足道的。此外，Kotlin通过lambda表达式和函数类型简化了大多数函数模式的使用。在本章中，我们将看到委托和装饰器模式的使用是如何通过类委托简化的。我们还将看到一个在编程世界中非常新的特性——属性委托——以及它是如何用来使Kotlin属性更加强大的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Delegation pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托模式
- en: Class delegation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类委托
- en: Decorator pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Property delegation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性委托
- en: Property delegates from the standard library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中的属性委托
- en: Creation of a custom property delegate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义属性委托
- en: Class delegation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类委托
- en: 'Kotlin has a feature called **class delegation** . It is a really inconspicuous
    feature that has many practical applications. It is worth to notice, that it is
    strongly connected with two design patterns: Delegation Pattern and Decorator
    Pattern. We will discuss those patterns in more detail in upcoming sections. Delegation
    and Decorator pattern are known for many years, but in Java their implementation
    required a lot of boilerplate code. Kotlin is one of the first languages that
    provided native support for those patterns reducing boilerplate code to minimum.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有一个名为**类委托**的特性。这是一个非常不起眼的特性，但有许多实际应用。值得注意的是，它与两种设计模式——委托模式和装饰器模式——密切相关。我们将在接下来的章节中更详细地讨论这些模式。委托和装饰器模式已经为人所知多年，但在Java中，它们的实现需要大量样板代码。Kotlin是第一批为这些模式提供本地支持并将样板代码减少到最低程度的语言之一。
- en: Delegation pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托模式
- en: In object-oriented programming, Delegation pattern is a design pattern, which
    is an alternative to inheritance. Delegation means that the object handles a request
    by delegating it to another object (delegate), instead of extending the class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，委托模式是一种设计模式，它是继承的一种替代方法。委托意味着对象通过将请求委托给另一个对象（委托）来处理请求，而不是扩展类。
- en: 'To support the polymorphic behavior known from Java, both objects should implement
    the same interface that holds all delegated methods and properties. A simple example
    of the delegation pattern is the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持从Java中所知的多态行为，两个对象都应该实现相同的接口，该接口包含所有委托的方法和属性。委托模式的一个简单示例如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we are talking about class delegation, there needs to be an interface that
    defines what methods are delegated.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们谈论类委托时，需要有一个定义了委托方法的接口。
- en: Object that we are delegating to (delegate).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要委托的对象（委托）。
- en: All methods inside the `WitcherPlayer` class should call corresponding methods
    on the delegate object (`player` ).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WitcherPlayer`类中的所有方法都应该调用委托对象（`player`）上的相应方法。'
- en: 'This is called delegation because the `WitcherPlayer` class is delegating methods
    defined in the `Player` interface to an instance of type `RpgGamePlayer` (`player`
    ). Similar result could be reached by using inheritance instead of delegation.
    It would look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为委托，因为`WitcherPlayer`类将`Player`接口中定义的方法委托给了`RpgGamePlayer`类型的实例（`player`）。使用继承而不是委托也可以达到类似的结果。它看起来如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At first glance, these two approaches might look similar, but delegation and
    inheritance have a lot of differences. On one hand, inheritance is much more popular
    and more common in use. It is often used in Java, and is connected to multiple
    OOP patterns. On the other hand, there are sources that strongly stand behind
    delegation. For example, the influential book *Design Patterns* , by the *Gang
    of Four* , contains the principle: *favor object composition over class inheritance*
    . Also, the popular book *Effective Java* , includes the rule: *favor composition
    over inheritance* (Item 6). Both of them strongly support the delegation pattern.
    Here are some basic arguments that stand behind the usage of the delegation pattern
    instead of inheritance:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这两种方法可能看起来相似，但委托和继承有很多不同之处。一方面，继承更受欢迎，使用更为普遍。它经常在Java中使用，并与多种面向对象模式相关联。另一方面，有一些来源强烈支持委托。例如，影响深远的《设计模式》一书，由四人组合编写，包含了这样的原则：*更倾向于对象组合而不是类继承*。此外，流行的《Effective
    Java》一书中包含了这样的规则：*更倾向于组合而不是继承*（第6条）。它们都强烈支持委托模式。以下是一些支持使用委托模式而不是继承的基本论点：
- en: Often classes are not designed for inheritance. When we override methods, we
    are not aware of underlying assumptions about class internal behavior (when methods
    are called, how those calls affect the objects, states, and so on). For example,
    when we override method, we might not be aware that it is used by other methods,
    so overridden methods may be called unexpectedly by a super class. Even if we
    check when the method is called, this behavior could change in a new version of
    the class (for example, if we extend class from an external library) and thus
    break our subclass' behavior. A very small amount of classes are properly designed
    and documented for inheritance, but nearly all nonabstract classes are designed
    for usage (this includes delegation).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常类并不是为了继承而设计的。当我们重写方法时，我们并不知道关于类内部行为的基本假设（方法何时被调用，这些调用如何影响对象、状态等）。例如，当我们重写方法时，我们可能不知道它被其他方法使用，因此重写的方法可能会被超类意外调用。即使我们检查方法何时被调用，这种行为也可能在类的新版本中发生变化（例如，如果我们从外部库扩展类），从而破坏我们子类的行为。非常少量的类被正确设计和记录为继承，但几乎所有非抽象类都是为使用而设计的（这包括委托）。
- en: In Java, it is possible to delegate a class to multiple classes, but inherit
    only from one.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，可以将一个类委托给多个类，但只能继承一个。
- en: By interface, we are specifying which methods and properties we want to delegate.
    This is compatible with the *interface segregation* principle (from SOLID)--we
    shouldn't expose unnecessary methods to the client.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口，我们指定要委托的方法和属性。这与*接口隔离*原则（来自SOLID原则）兼容--我们不应该向客户端公开不必要的方法。
- en: Some classes are final, so we can only delegate to them. In fact, all classes
    that are not designed for inheritance should be final. Kotlin designers were aware
    of it, and they made all classes in Kotlin to be final by default.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些类是final的，所以我们只能委托给它们。事实上，所有不设计用于继承的类都应该是final的。Kotlin的设计者意识到了这一点，并且默认情况下将Kotlin中的所有类都设为final。
- en: Making a class final and providing proper interface is good practice for public
    libraries. We can change the implementation of a class without worrying that it
    will affect library users (as long as the behavior will be the same from an interface
    point of view). It makes them impossible to inherit from, but they are still great
    candidates to delegate to.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类设为final并提供适当的接口是公共库的良好实践。我们可以更改类的实现而不必担心会影响库的用户（只要从接口的角度来看行为是相同的）。它们不可继承，但仍然是很好的委托候选者。
- en: 'More information on how classes should be designed to support inheritance and
    when delegation should be used can be found in the book *Effective Java* , in
    *Item 16: Favor composition over inheritance* .'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '有关如何设计支持继承的类以及何时应使用委托的更多信息可以在书籍*Effective Java*中找到，在*Item 16: Favor composition
    over inheritance*中找到。'
- en: 'Of course, there are also disadvantages of using delegation instead of inheritance.
    Here are the main problems:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用委托而不是继承也有缺点。以下是主要问题：
- en: We need to create interfaces that specify which methods should be delegated
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建指定应该委托哪些方法的接口
- en: We don't have access to protected methods and properties
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法访问受保护的方法和属性
- en: 'In Java, there was one more strong argument for using inheritance: it was much
    easier to implement. Even while comparing code from our `WitcherPlayer` example,
    we can see that delegation needed a lot of extra code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，使用继承还有一个更有力的论据：它要容易得多。即使比较我们`WitcherPlayer`示例中的代码，我们也可以看到委托需要大量额外的代码：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is especially problematic when we are dealing with interfaces with multiple
    methods. Fortunately, modern languages value the usage of the Delegation pattern,
    and many of them have native class delegation support. There is strong support
    for the Delegation pattern in Swift and Groovy, and there is also support through
    other mechanisms in Ruby, Python, JavaScript, and Smalltalk. Kotlin also strongly
    supports class delegation, and makes usage of this pattern really simple, and
    using nearly zero-boilerplate code. The `WitcherPlayer` class from the example
    could be implemented in this way in Kotlin:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理具有多个方法的接口时，这是特别棘手的。幸运的是，现代语言重视委托模式的使用，并且许多语言都具有本地类委托支持。Swift和Groovy对委托模式有很强的支持，Ruby、Python、JavaScript和Smalltalk也通过其他机制支持。Kotlin也强烈支持类委托，并且使用这种模式非常简单，几乎不需要样板代码。例如，示例中的`WitcherPlayer`类可以在Kotlin中以这种方式实现：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the `by` keyword, we are informing the compiler to delegate all methods
    defined in the `Player` interface from `WitcherPlayer` to `RpgGamePlayer` . An
    instance of `RpgGamePlayer` is created during the `WitcherPlayer` construction.
    In simpler words: `WitcherPlayer` is delegating methods defined in the `Player`
    interface to a new `RpgGamePlayer` object.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`by`关键字，我们通知编译器将`WitcherPlayer`中定义的`Player`接口的所有方法委托给`RpgGamePlayer`。在`WitcherPlayer`构造期间创建了一个`RpgGamePlayer`的实例。简单来说：`WitcherPlayer`将在`Player`接口中定义的方法委托给一个新的`RpgGamePlayer`对象。
- en: What is really happening here is that during compilation, the Kotlin compiler
    is generating not implemented methods from `Player` in `WitcherPlayer` and filling
    them with calls to an `RpgGamePlayer` instance (the same way as that we implemented
    them in the first example). The big improvement is that we don't need to implement
    those methods ourselves. Also note that if a signature of a delegated method changes,
    then we don't need to change all objects that are delegated to it, so the class
    is easier to maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正发生的是，在编译期间，Kotlin编译器从`Player`在`WitcherPlayer`中生成了未实现的方法，并用对`RpgGamePlayer`实例的调用填充它们（就像我们在第一个示例中实现的那样）。最大的改进是我们不需要自己实现这些方法。还要注意的是，如果委托方法的签名发生变化，那么我们不需要更改所有委托给它的对象，因此类更容易维护。
- en: 'There is another way to create and hold an instance of the delegate. It can
    be provided by a constructor, like in this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种创建和保存委托实例的方法。它可以由构造函数提供，就像这个例子中一样：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also delegate to a property defined in the constructor:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以委托给构造函数中定义的属性：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can delegate to any property accessible during class declaration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以委托给在类声明期间可访问的任何属性：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition, one object can have multiple different delegates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个对象可以有多个不同的委托：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `WitcherPlayer` class is delegating the `Player` interface to a new `RpgGamePlayer`
    object, `GameMaker` to a new `WitcherCreator` object, and also includes the function
    `fulfillYourDestiny` that is using functions from both delegates. Note that both
    `WitcherPlayer` and `WitcherCreator` are not tagged as open, and without this,
    they cannot be extended. They can be delegated, though.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WitcherPlayer`类将`Player`接口委托给一个新的`RpgGamePlayer`对象，`GameMaker`委托给一个新的`WitcherCreator`对象，并且还包括`fulfillYourDestiny`函数，该函数使用了来自两个委托的函数。请注意，`WitcherPlayer`和`WitcherCreator`都没有标记为open，没有这个标记，它们就不能被扩展。但它们可以被委托。'
- en: 'With such language support, the Delegation pattern is much more attractive
    than inheritance. While this pattern has both advantages and disadvantages, it
    is good to know when it should be used. The main cases where delegates should
    be used are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的语言支持，委托模式比继承更有吸引力。虽然这种模式既有优点又有缺点，但知道何时应该使用它是很好的。应该使用委托的主要情况如下：
- en: When your subclass violates the *Liskov substitution principle* ; for example,
    when we are dealing with situations where inheritance was implemented only to
    reuse code of the superclass, but it is not really acting like it.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的子类违反了*里氏替换原则*；例如，当我们处理继承仅用于重用超类代码的情况，但它实际上并不像那样工作。
- en: When the subclass uses only a portion of the methods of the superclass. In this
    case, it is only a matter of time before someone calls a superclass method that
    they were not supposed to call. Using delegation, we reuse only methods we choose
    (defined in the interface).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子类只使用超类的部分方法时。在这种情况下，只是时间问题，直到有人调用了他们本不应该调用的超类方法。使用委托，我们只重用我们选择的方法（在接口中定义）。
- en: 'When we cannot or we should not inherit, because:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不能或者不应该继承时，因为：
- en: The class is final
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是final的
- en: It is not accessible and used from behind interface
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不可访问，也不可从接口后面使用
- en: It is just not designed for inheritance
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只是不适合继承
- en: Note that while classes in Kotlin are final by default, most of them will be
    left final. If those classes are placed in a library then most likely we won't
    be able to change or open the class. Delegation will be the only option, to make
    class with different behavior.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然Kotlin中的类默认是final的，但大多数类都将保持final。如果这些类放在库中，那么我们很可能无法更改或打开这个类。委托将是唯一的选择，以创建具有不同行为的类。
- en: The Liskov substitution principle is a concept in OOP stating that all subclasses
    should act like their superclasses. In easier words, If unit tests are passing
    for some class, they should be passing for its subclasses too. This principle
    has been popularized by Robert C. Martin, who placed it in his set of most important
    OOP rules and described it in the popular book *Clean Code* .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 里氏替换原则是面向对象编程中的一个概念，它规定所有子类应该像它们的超类一样工作。简单来说，如果某个类的单元测试通过，那么它的子类也应该通过。这个原则由Robert
    C. Martin推广，他将其列为最重要的面向对象编程规则之一，并在流行的书籍*Clean Code*中描述了它。
- en: The book *Effective Java* states that "*inheritance is appropriate only in circumstances
    where a subclass really is a subtype of the superclass* ." In other words, class
    `B` should extend a class only if an *is-a* relationship exists between the two
    classes. If you are tempted to have class `B` extend class `A` , ask yourself
    *Is every B really an A?* In the next part, the book suggests that in every other
    case there should be composition used (which most common implementation is delegation).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 《Effective Java》一书指出：“只有在子类真正是超类的子类型的情况下才适合使用继承。”换句话说，只有当类`B`扩展类`A`时，两个类之间存在*is-a*关系。如果你想让类`B`扩展类`A`，问问自己“每个B都是一个A吗？”在接下来的部分，该书建议在其他所有情况下应该使用组合（最常见的实现是委托）。
- en: It is also worth note that Cocoa (the UI framework from Apple for building software
    programs to run on iOS) very often use delegates instead of inheritance. This
    pattern is becoming more and more popular, and in Kotlin it is highly supported.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Cocoa（苹果的UI框架，用于构建在iOS上运行的软件程序）很常用委托而不是继承。这种模式变得越来越流行，在Kotlin中得到了很好的支持。
- en: Decorator pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'Another common case where the Kotlin class delegation is really useful is when
    we are implementing a Decorator pattern. A Decorator pattern (also known as Wrapper
    pattern) is a design pattern that makes it possible to add a behavior to an existing
    class without using inheritance. In contrast to extensions where we can add a
    new behavior without modifying an object, we are creating a concrete object with
    a different behavior. A Decorator pattern uses Delegation, but in a very specific
    way--delegate is provided from outside of the class. The classic structure is
    presented in the following UML diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是，当我们实现装饰器模式时，Kotlin类委托非常有用。装饰器模式（也称为包装器模式）是一种设计模式，它使得可以在不使用继承的情况下向现有类添加行为。与扩展不同，我们可以在不修改对象的情况下添加新行为，装饰器模式使用委托，但是以一种非常特定的方式--委托是从类的外部提供的。经典结构如下UML图所示：
- en: '![](img/Image00052.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00052.jpg)'
- en: 'UML diagram of classic implementation of the Decorator pattern. Source: [http://upload.wikimedia.org](http://upload.wikimedia.org)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的经典实现的UML图。来源：[http://upload.wikimedia.org](http://upload.wikimedia.org)
- en: The Decorator contains the objects that it is decorating while it is implementing
    the same interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器包含它装饰的对象，同时实现相同的接口。
- en: 'The most popular example of decorator usage from the Java world is `InputStream`
    . There are different kinds of types that are extending `InputStream` , and a
    lot of decorators that can be used to add functionalities to them. This decorator
    can be used to add buffering, get content of a zipped file, or convert file content
    to a Java object. Let''s look at the example where multiple decorators are used
    to read a zipped Java object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Java世界的装饰器使用最广泛的例子是`InputStream`。有不同类型的类型扩展了`InputStream`，还有很多装饰器可以用来为它们添加功能。这个装饰器可以用来添加缓冲，获取压缩文件的内容，或者将文件内容转换为Java对象。让我们看一个使用多个装饰器来读取一个压缩的Java对象的例子：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a simple stream for reading a file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于读取文件的简单流。
- en: Make a new stream that contains buffering.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含缓冲的新流。
- en: Make a new stream that contains functionality of the reading compressed data
    in the GZIP file format.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含读取GZIP文件格式中压缩数据功能的新流。
- en: Make a new stream that adds functionality that deserializes primitive data and
    objects previously written using an `ObjectOutputStream` .
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的流，添加反序列化原始数据和之前使用`ObjectOutputStream`写入的对象的功能。
- en: Stream is used in the `readObject` method of `ObjectInputStream` , but all objects
    in this example are implementing `InputStream` (what makes it possible to pack
    it this way) and can be read by the methods specified by this interface.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流在`ObjectInputStream`的`readObject`方法中使用，但是这个例子中的所有对象都实现了`InputStream`（这使得可以以这种方式打包它），并且可以通过这个接口指定的方法来读取。
- en: Note that this pattern is also similar to inheritance, but we can decide what
    decorators we want to use and in what order. This is much more flexible and gives
    more possibilities during usage. Some people argue that `InputStream` usage would
    be better if designers would make one big class with all designed functionalities,
    and then use methods to turn some of them on or off. This approach would violate
    the *single-responsibility principle* and lead to much more complicated and much
    less expandable code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种模式也类似于继承，但我们可以决定我们想要使用哪些装饰器以及以什么顺序。这样更加灵活，并在使用过程中提供更多可能性。一些人认为，如果设计者能够制作一个具有所有设计功能的大类，然后使用方法来打开或关闭其中的一些功能，那么`InputStream`的使用会更好。这种方法将违反*单一责任原则*，并导致更加复杂和不太可扩展的代码。
- en: 'While the Decorator pattern is considered one of the best in practical use,
    it is rarely used in Java projects. This is because the implementation is not
    simple. Interfaces often contain multiple methods and creating a delegation to
    them in each decorator generates lots of boilerplate code. There is a different
    situation in Kotlin--we''ve already seen that in Kotlin class delegation is actually
    trivial. Let''s look at some classic examples of practical class delegation usage
    in the Decorator pattern. Let''s suppose that we want to add the first position
    as the *zero* element to several different `ListAdapters` . This extra position
    has some special properties. We couldn''t implement this using inheritance because
    these `ListAdapters` for different lists are of different types (which is the
    standard situation). In this case, we can either change the behaviors of each
    class (DRY rule) or we can create a decorator. Here is the short code of this
    decorator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管装饰器模式被认为是实际应用中最好的模式之一，但在Java项目中很少被使用。这是因为实现并不简单。接口通常包含多个方法，在每个装饰器中创建对它们的委托会生成大量样板代码。在Kotlin中情况不同--我们已经看到在Kotlin中类委托实际上是微不足道的。让我们看一些在装饰器模式中实际类委托使用的经典例子。假设我们想要将第一个位置作为*零*元素添加到几个不同的`ListAdapters`中。这个额外的位置有一些特殊的属性。我们无法使用继承来实现这一点，因为这些不同列表的`ListAdapters`是不同类型的（这是标准情况）。在这种情况下，我们可以改变每个类的行为（DRY规则），或者我们可以创建一个装饰器。这是这个装饰器的简短代码：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We used an inflator extension property of `Context` here, which is often included
    in Kotlin Android projects and should be known from [Chapter 7](text00171.html)
    , *Extension Functions and Properties* :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`Context`的扩展属性`inflator`，这在Kotlin Android项目中经常包含，并且应该从[第7章](text00171.html)
    *扩展函数和属性*中了解：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ZeroElementListDecorator` class defined this way always adds a first element
    with static view. Here we can see a simple example of its use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的`ZeroElementListDecorator`类总是添加一个具有静态视图的第一个元素。在这里我们可以看到它的简单使用示例：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In `ZeroElementListDecorator` it might look complicated that we needed to override
    four methods, but in fact, there are eight more of them and we didn't have to
    override them, thanks to Kotlin's class delegation. We can see that Kotlin class
    delegation is making the implementation of the Decorator pattern much easier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ZeroElementListDecorator`中，我们可能会觉得需要重写四个方法很复杂，但实际上还有八个方法，我们不需要重写它们，这要归功于Kotlin的类委托。我们可以看到Kotlin类委托使得装饰器模式的实现变得更加容易。
- en: The Decorator pattern is really simple to implement and is pretty intuitive.
    It can be used in lots of different cases to extend a class with extra functionality.
    It is really safe and often referred as a good practice. These examples are just
    some of the possibilities provided by class delegation. I am sure that the reader
    will find more use cases with presented patterns and use class delegation to make
    the project more clean, safe, and concise.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式实际上非常简单实现，而且非常直观。它可以在许多不同的情况下用来扩展类的额外功能。它非常安全，通常被称为一种良好的实践。这些例子只是类委托提供的可能性之一。我相信读者会发现更多使用这些模式的用例，并使用类委托使项目更加清晰、安全和简洁。
- en: Property delegation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性委托
- en: Kotlin allows not only class delegation, but also property delegation. In this
    section, we are going to find out what delegated properties are, review property
    delegates from Kotlin standard library, and learn how to create and use custom
    property delegates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin不仅允许类委托，还允许属性委托。在本节中，我们将找出委托属性是什么，审查Kotlin标准库中的属性委托，并学习如何创建和使用自定义属性委托。
- en: What are delegated properties?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是委托属性？
- en: 'Let''s start with explanation of what property delegates are. Here is an example
    of the use of property delegation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解释什么是属性委托开始。这里是属性委托的使用示例：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are delegating `user` property to an instance of `UserDelegate` (which is
    created by the constructor).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`user`属性委托给`UserDelegate`的一个实例（由构造函数创建）。
- en: Property delegation is similar to class delegation. We delegate to an object
    using the same keyword (`by` ). Each call to a property (`set` /`get` ) will be
    delegated to another object (`UserDelegate` ). This way we can reuse the same
    behavior for multiple properties, for example, setting a property value only when
    some criteria are met, or adding log entry when a property is accessed/updated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 属性委托类似于类委托。我们使用相同的关键字（`by`）将属性委托给一个对象。对属性（`set`/`get`）的每次调用都将被委托给另一个对象（`UserDelegate`）。这样我们可以为多个属性重用相同的行为，例如，仅当满足某些条件时设置属性值，或者在访问/更新属性时添加日志条目。
- en: 'We know that a property doesn''t really need a backing field. It might be defined
    just by getter (read-only) or a getter/setter (read-write). Under the hood, property
    delegates are just translated to corresponding method calls (`setValue` /`getValue`
    ). The preceding example will be compiled to such code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道属性实际上不需要后备字段。它可以只由getter（只读）或getter/setter（读/写）定义。在幕后，属性委托只是被转换为相应的方法调用（`setValue`/`getValue`）。上面的例子将被编译为这样的代码：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The example is showing that by using the `by` keyword, we are delegating the
    setter and getter calls to delegate. That is why any object that has the `getValue`
    and `setValue` functions with correct parameters (it will be described later)
    can be used as a delegate (for read-only properties `getValue` is enough, because
    only the getter is needed). It is important that all that class needs to be able
    to serve as a property delegate is to have these two methods. No interface is
    needed. Here is an example implementation of `UserDelegate` :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例显示，通过使用`by`关键字，我们将setter和getter调用委托给委托。这就是为什么任何具有正确参数的`getValue`和`setValue`函数的对象（稍后将描述）都可以用作委托（对于只读属性，只需要`getValue`，因为只需要getter）。重要的是，作为属性委托的所有类需要具有这两种方法。不需要接口。以下是`UserDelegate`的示例实现：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `setValue` and `getValue` methods are used to set and get value of a property
    (property setter call is delegated to a `setValue` method, and property getter
    is delegating value to the `getValue` method). Both functions need to be marked
    with the `operator` keyword. They have some special set of parameters that determine
    where and to which property the delegate can serve. If a property is read-only,
    then an object only needs to have a `getValue` method to be able to serve as its
    delegate:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue`和`getValue`方法用于设置和获取属性的值（属性设置器调用被委托给`setValue`方法，属性获取器将值委托给`getValue`方法）。这两个函数都需要标记为`operator`关键字。它们有一些特殊的参数集，用于确定委托可以服务的位置和属性。如果属性是只读的，那么对象只需要具有`getValue`方法就能够作为其委托：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The type returned by the `getValue` method and the type of property that the
    user defined in the `setValue` method determines type of delegated property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue`方法返回的类型和用户在`setValue`方法中定义的属性的类型决定了委托属性的类型。'
- en: 'Type of the first parameter of both the `getValue` and `setValue` functions
    (`thisRef` ) is contains the reference to context in which a delegate is used.
    It can be used to restrict types that delegate can be used for. For example, we
    can define delegate that might be used only inside an `Activity` class in the
    following way:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`getValue`和`setValue`函数的第一个参数（`thisRef`）的类型包含了委托使用的上下文的引用。它可以用于限制委托可以使用的类型。例如，我们可以以以下方式定义只能在`Activity`类内部使用的委托：'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we've seen, there will be a reference to `this` provided in all contexts
    where it is available. Only inside extension function or on extension property
    there is null placed instead. Reference to `this` is used to get some data from
    context. If we would type it to `Activity` , then we would be able to use this
    delegate only inside `Activity` (in any context where `this` is of the type `Activity`
    ).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，所有上下文中都会提供对`this`的引用。只有在扩展函数或扩展属性中才会放置null。对`this`的引用用于从上下文中获取一些数据。如果我们将其类型定义为`Activity`，那么我们只能在`Activity`内部（`this`的类型为`Activity`的任何上下文）中使用此委托。
- en: Also, if we want to force the delegate to be used only on the top-level, we
    can then specify the first parameter (`thisRef` ) type to `Nothing?` , because
    the only possible value of this type is `null` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要强制委托只能在顶层使用，我们可以将第一个参数（`thisRef`）的类型指定为`Nothing?`，因为这种类型的唯一可能值是`null`。
- en: Another parameter in these methods is `property` . It contains a reference to
    a delegated property, which contains its metadata (property name, type, and so
    on).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的另一个参数是`property`。它包含对委托属性的引用，其中包含其元数据（属性名称、类型等）。
- en: 'Property delegation can be used for properties defined in any context (top-level
    properties, member properties, local variables, and so on):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 属性委托可用于任何上下文中定义的属性（顶级属性、成员属性、局部变量等）：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Top-level property with delegate
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用委托的顶级属性
- en: Local variable (inside top-level function) with delegate
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用委托的局部变量（在顶级函数内部）
- en: Member property with delegate
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用委托的成员属性
- en: Local variable (inside method) with delegate
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用委托的局部变量（在方法内部）
- en: In the next few sections, we will describe delegates from the Kotlin standard
    library. They are important not only because they are often useful, but also because
    they are good examples of how property delegation can be used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将描述Kotlin标准库中的委托。它们不仅因为它们经常有用而重要，而且因为它们是如何使用属性委托的好例子。
- en: Predefined delegates
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预定义的委托
- en: The Kotlin standard library contains some property delegates that are very handy.
    Let's discuss how they can be used in real-life projects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库包含一些非常方便的属性委托。让我们讨论它们如何在实际项目中使用。
- en: The lazy function
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`lazy`函数'
- en: 'Sometimes we need to initialize an object, but we want to make sure that the
    object will be initialized only once, when it is used for the first time. In Java,
    we could solve this problem in the following way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要初始化一个对象，但我们希望确保对象只在第一次使用时初始化一次。在Java中，我们可以通过以下方式解决这个问题：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This construction is a popular pattern in Java development. Kotlin allows us
    to solve this problem in a much simpler way by providing the `lazy` delegate.
    It is the most commonly used delegate. It works only with read-only properties
    (`val` ) and its usage is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造在Java开发中很常见。Kotlin允许我们通过提供`lazy`委托来以更简单的方式解决这个问题。它是最常用的委托。它只适用于只读属性（`val`），用法如下：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `lazy` function in the standard library function that is providing delegate:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中提供委托的`lazy`函数：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Formally, in this example object of `SynchronizedLazyImpl` , it is used as a
    property delegate. Although, most often it is called **lazy delegate** from its
    corresponding function name. The same way other delegates are named from the names
    of the functions that are providing them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`SynchronizedLazyImpl` 的对象被正式地用作属性委托。尽管通常它被称为**惰性委托**，来自于相应的函数名。其他委托也是从提供它们的函数的名称命名的。
- en: 'The lazy delegate also has a thread safety mechanism. By default, delegates
    are fully thread safe, but we can change this behavior to make this function more
    efficient in situations where we know that there never will be more than one thread
    using it at the same time. To fully turn off thread-safety mechanisms we need
    to place the `enum` type value `LazyThreadSafetyMode.NONE` as a first argument
    of the `lazy` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性委托还具有线程安全机制。默认情况下，委托是完全线程安全的，但我们可以改变这种行为，使这个函数在我们知道永远不会有多个线程同时使用它的情况下更有效。要完全关闭线程安全机制，我们需要将`enum`类型值`LazyThreadSafetyMode.NONE`作为`lazy`函数的第一个参数。
- en: '`val someProperty by lazy(LazyThreadSafetyMode.NONE) { SomeType() }`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`val someProperty by lazy(LazyThreadSafetyMode.NONE) { SomeType() }`'
- en: 'Thanks to the lazy delegate, the initialization of the property is delayed
    until the value is needed. Usage of the lazy delegate provides several benefits:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于惰性委托，属性的初始化被延迟直到需要值。使用惰性委托提供了几个好处：
- en: Faster class initialization leading to faster application startup time, because
    value initialization is delayed until they are used for the first time
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的类初始化导致更快的应用程序启动时间，因为值的初始化被延迟到第一次使用它们时
- en: Some values may never be used for certain flow, so they will never be initialized--we
    are saving resources (memory, processor time, battery)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些值可能永远不会在某些流程中使用，因此它们永远不会被初始化——我们在节省资源（内存、处理器时间、电池）。
- en: 'Another benefit is that some objects need to be created later, after their
    class instance is created. For example, in `Activity` we cannot access the resources
    before layout is set using the `setContentView` method, which is typically called
    inside the `onCreate` method. I will present it in this example. Let''s look at
    the Java class with view reference elements filled in the classic Java way:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是有些对象需要在它们的类实例创建后才能创建。例如，在`Activity`中，我们不能在使用`setContentView`方法设置布局之前访问资源，这个方法通常在`onCreate`方法中调用。我将在这个例子中展示它。让我们看一下使用经典Java方式填充视图引用元素的Java类：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we translate it into Kotlin, one-to-one, it will look as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其翻译成Kotlin，一对一，它将如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the lazy delegate, we can implement this behavior in a simpler way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用惰性委托，我们可以以更简单的方式实现这种行为：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The benefits of this approach are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处如下：
- en: The property is declared and initialized in a single place, so the code is more
    concise.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性在一个地方声明和初始化，所以代码更简洁。
- en: The properties are non-nullable instead of nullable. This prevents lots of useless
    nullability checks.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是非空的，而不是可空的。这可以避免大量无用的空值检查。
- en: The properties are read only so thanks to that we have all benefits like threads
    synchronization or smart casts.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是只读的，因此我们可以获得所有的好处，比如线程同步或智能转换。
- en: The lambda passed to the lazy delegate (containing `findViewById` ) will be
    executed only when the property is accessed for the first time.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给惰性委托的lambda（包含`findViewById`）只有在第一次访问属性时才会执行。
- en: Values will be taken later than during class creation. This will speed-up the
    startup. If we won't use some of these views, their values won't be taken at all
    (`findViewById` is not really an efficient operation when the view is complex).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值将在类创建后被获取。这将加快启动速度。如果我们不使用其中一些视图，它们的值根本不会被获取（当视图复杂时，`findViewById`并不是一种高效的操作）。
- en: Not used property will be marked by the compiler. In Java implementation it
    won't, because value set would be noticed by the compiler as usage.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的属性将被编译器标记。在Java实现中不会，因为编译器会注意到设置的值作为使用。
- en: 'We can improve the preceding implementation by extracting the common behavior
    and converting it into an extension function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提取共同的行为并将其转换为扩展函数来改进前面的实现：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can define the view bindings in simpler and more concise code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用更简洁的代码定义视图绑定：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We don't need to set type provided to the `bindView` function because it is
    inferred from property type.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要为`bindView`函数提供的类型设置类型，因为它是从属性类型中推断出来的。
- en: Now we have a single delegate that calls `findViewById` under the hood, when
    we access a particular view for the first time. This is a very concise solution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个单一的委托，在我们第一次访问特定视图时会在后台调用`findViewById`。这是一个非常简洁的解决方案。
- en: There is another way of dealing with this problem. The current popular one is
    the *Kotlin Android Extension* plugin, which generates auto-binding to views in
    `Activities` and `Fragments` . We will discuss the practical applications in [Chapter
    9](text00222.html) , *Making your Marvel Gallery Application* .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种处理这个问题的方法。目前流行的是*Kotlin Android Extension*插件，它会在`Activities`和`Fragments`中自动生成视图的自动绑定。我们将在[第9章](text00222.html)中讨论实际应用，*制作你的Marvel画廊应用*。
- en: Even with such support, there are still benefits from staying with bindings.
    One is explicit knowledge of what elements of view we are using, and another is
    the separation between the name of element ID and name of a variable in which
    we hold this element. Also compilation time is faster.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这样的支持，仍然有保持绑定的好处。一个是明确知道我们正在使用的视图元素，另一个是元素ID的名称和我们保存该元素的变量的名称之间的分离。此外，编译时间更快。
- en: 'The same mechanism can be applied to solve other Android related problems.
    For example, when we pass an argument to `Activity` . The standard Java implementation
    looks as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的机制可以应用于解决其他与Android相关的问题。例如，当我们向`Activity`传递参数时。标准的Java实现如下：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could write the same implementation in Kotlin, but we can also retrieve
    parameter values (`getString` /`getParcerable` ) together with the variable declaration.
    To do this, we need the following extension functions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Kotlin中编写相同的实现，但也可以在变量声明时检索参数值（`getString` / `getParcerable` ）。为此，我们需要以下扩展函数：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we can get extra parameters by using `extra` and `extraString` delegates:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过使用 `extra` 和 `extraString` 委托来获取额外的参数：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are defining properties which values should be retrieved from `Activity`
    arguments using corresponding keys.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在定义应该从 `Activity` 参数中检索值的属性，使用相应的键。
- en: Here we access properties from arguments within the `onCreate` method. When
    we ask for property (use getter), the lazy delegate will get its value from extras
    and store it for later usage.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中，我们从参数中访问属性。当我们请求属性（使用getter）时，延迟委托将从额外中获取其值，并将其存储以供以后使用。
- en: To make a static method to start activity, we need to use a companion object.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个启动活动的静态方法，我们需要使用伴生对象。
- en: '`SettingsActivity::class.java` is the analogue of Java class reference `SettingsActivity.class`
    .'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SettingsActivity::class.java` 是Java类引用 `SettingsActivity.class` 的类似物。'
- en: We are using methods defined in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* .
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用[第7章](text00171.html)中定义的方法，*扩展函数和属性*。
- en: 'We can also make functions to retrieve other types that can be held by **Bundle**
    (for example, `Long` , `Serializable` ). This is a pretty nice alternative to
    the argument injection libraries such as `ActivityStarter` , when we want to keep
    a really fast compilation time. We can use similar functions to bind strings,
    colors, services, repositories, and other parts of model and logic:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写函数来检索其他可以由 **Bundle** 持有的类型（例如 `Long` 、`Serializable` ）。这是一个非常好的替代方案，可以避免使用诸如
    `ActivityStarter` 等参数注入库，从而保持非常快的编译时间。我们可以使用类似的函数来绑定字符串、颜色、服务、存储库和模型和逻辑的其他部分：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `Activity` , everything that is heavy or depends on arguments should be
    declared using lazy delegate (or provided asynchronously). Also we should define
    as lazy all the elements that depend on elements that need to be initialized lazily.
    For example, `presenter` definition, which depends on the `doctor` property:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Activity` 中，所有繁重的或依赖于参数的内容都应该使用延迟委托（或异步提供）。同时，所有依赖于需要延迟初始化的元素的元素也应该定义为延迟。例如，依赖于
    `doctor` 属性的 `presenter` 的定义：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Otherwise, the attempt to construct a `MainPresenter` object will take place
    during class creation when we cannot yet read values from the intent and it wouldn't
    be able to fill the `doctor` property, and the application would crash.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，尝试构造 `MainPresenter` 对象将在类创建时进行，此时我们还不能从意图中读取值，也无法填充 `doctor` 属性，应用程序将崩溃。
- en: I think that these examples are enough to convince us that the lazy delegate
    is really useful in Android projects. It is also a good property delegate to start
    with, as it is simple and elegant.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这些示例足以让我们相信，延迟委托在Android项目中非常有用。它也是一个很好的属性委托入门，因为它简单而优雅。
- en: The notNull function
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: notNull 函数
- en: 'The `notNull` delegate is the simplest standard library delegate, and that
    is why it will be presented first. The usage is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`notNull` 委托是最简单的标准库委托，这就是为什么它将首先被介绍。使用方法如下：'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Functions that provide most standard library delegates (including the `notNull`
    function) are defined in `object` delegates. To use them, we need to either refer
    to this object (`Delegates.notNull()` ) or import it (`import kotlin.properties.Delegates.notNull`
    ). We will assume in examples that this `object` is imported so we will omit reference
    to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提供大多数标准库委托（包括 `notNull` 函数）的函数是在 `object` 委托中定义的。要使用它们，我们需要引用这个对象（`Delegates.notNull()`
    ），或者导入它（`import kotlin.properties.Delegates.notNull` ）。在示例中，我们将假设这个 `object` 已经被导入，因此我们将省略对它的引用。
- en: 'The `notNull` delegate allows us to define a variable as non-nullable, that
    is initialized at a later time and not during the object construction time. We
    can define variable to be non-nullable without providing a default value. The
    `notNull` function is an alternative to `lateinit` :'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`notNull` 委托允许我们将变量定义为非空，即在稍后初始化而不是在对象构造时初始化。我们可以定义变量为非空而不提供默认值。`notNull` 函数是
    `lateinit` 的一种替代方式：'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `notNull` delegate provides nearly the same effect as `lateinit` (only the
    error message is different). In the case of trying to use this property before
    setting the value first, it will throw an `IllegalStateException` and it will
    terminate an Android application. Therefore, it should be used only when we know
    that a value will be set before the first attempt of usage.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`notNull` 委托提供了几乎与 `lateinit` 相同的效果（只是错误消息不同）。在尝试在设置值之前使用此属性时，它将抛出 `IllegalStateException`
    并终止Android应用程序。因此，只有在我们知道值将在第一次尝试使用之前设置时，才应该使用它。'
- en: The difference between `lateinit` and the `notNull` delegate is pretty simple.
    `lateinit` is faster than `notNull` delegate so it should be used instead of `notNull`
    delegate as often as possible. But it has restrictions, `lateinit` cannot be used
    for primitives or for top-level properties, so in this case, `notNull` is used
    instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`lateinit` 和 `notNull` 委托之间的区别非常简单。`lateinit` 比 `notNull` 委托更快，因此应尽可能使用 `lateinit`
    委托。但它有限制，`lateinit` 不能用于原始类型或顶级属性，因此在这种情况下，应使用 `notNull` 代替。'
- en: 'Let''s look at the `notNull` delegate implementation. Here is the `notNull`
    function implementation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `notNull` 委托的实现。以下是 `notNull` 函数的实现：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, `notNull` is actually a function returning an object that is
    an instance of our actual delegate hidden behind a `ReadWriteProperty` interface.
    Let''s look at an actual delegate definition:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`notNull` 实际上是一个返回对象的函数，该对象是我们实际委托的实例，隐藏在 `ReadWriteProperty` 接口后面。让我们来看一个实际的委托定义：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Class is private. It is possible because it is provided by function `notNull`
    , which is returning it as `ReadWriteProperty<Any?, T>` , which is public interface.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类是私有的。这是可能的，因为它是由函数 `notNull` 提供的，该函数将其作为 `ReadWriteProperty<Any?, T>` 返回，而该接口是公共的。
- en: Here we see how a return value is provided. If it is null during usage, then
    value was not set and the method will throw an error. Otherwise, it is returning
    the value.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里展示了如何提供返回值。如果在使用过程中为null，则表示未设置值，方法将抛出错误。否则，它会返回该值。
- en: 'This delegate should be pretty simple to understand. The `setValue` function
    sets the value to a nullable field and `getValue` returns this field if it is
    not null, and throws an exception if it is. Here is an example of this error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个委托应该很容易理解。`setValue`函数将值设置为可空字段，`getValue`如果不为null则返回该字段，如果为null则抛出异常。以下是此错误的示例：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a really simple example of delegated properties usage, but also a good
    introduction to how property delegates works. Delegated properties are very powerful
    constructs that have multiple applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于委托属性使用的非常简单的例子，也是对属性委托工作原理的良好介绍。委托属性是非常强大的构造，具有多种应用。
- en: The observable delegate
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察委托
- en: 'An observable is the most useful standard library delegate for mutable properties.
    Every time a value is set (`setValue` method is called), the lambda function from
    the declaration is invoked. A simple example of observable delegate is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察是可变属性最有用的标准库委托。每次设置一个值（调用`setValue`方法）时，都会调用声明中的lambda函数。可观察委托的一个简单示例如下：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The arguments of lambda function are as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda函数的参数如下：
- en: '`property` : Reference to the delegated property. Here it is reference to name.
    This is the same as property from `setValue` and `getValue` , which was described.
    It is of the `KProperty` type. In this case (and in most cases) we can put the
    underscore ("`_` " sign) instead when it is not used.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property`：委托属性的引用。这里是对name的引用。这与`setValue`和`getValue`中描述的属性相同。它是`KProperty`类型。在这种情况下（以及大多数情况下），当未使用时可以使用下划线（“`_`”符号）代替。'
- en: '`oldValue` : The previous value of the `property` (before the change).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oldValue`：更改前的`property`的先前值。'
- en: '`newValue` : The new value of the `property` (after the change).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newValue`：更改后的`property`的新值。'
- en: The lambda function will be invoked each time a new value is set to the property.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次将新值设置到属性时都会调用lambda函数。
- en: When we set the new value, then the value is updated, but at the same time lambda
    method declared in delegate is called.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们设置新值时，该值会更新，但同时也会调用委托中声明的lambda方法。
- en: Note that lambda is invoked each time setter is used and it doesn't matter if
    a new value is equal to previous.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，每次使用setter时都会调用lambda，并且不管新值是否等于先前的值都没有关系。
- en: 'It is particularly important to remember that lambda is called each time a
    new value is set, and not when an object''s inner state is changed. For example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的是要记住，每次设置新值时都会调用lambda，而不是在对象的内部状态更改时。例如：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Does not print anything, because we don't change the property (the setter is
    not used). We only change the property defined inside the list, but not the object
    itself.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不打印任何内容，因为我们没有更改属性（未使用setter）。我们只更改了列表内部定义的属性，而不是对象本身。
- en: Here we change the value of list, so the lambda function from observable delegate
    is called and text is printed.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们改变了列表的值，因此会调用可观察委托中的lambda函数并打印文本。
- en: 'Observable delegate is very useful for immutable types, as opposed to mutable
    ones. Fortunately, all basic types in Kotlin are immutable by default (`List`
    , `Map` , `Set` , `Int` , `String` ). Let''s look at a practical Android example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察委托对于不可变类型非常有用，与可变类型相反。幸运的是，Kotlin中的所有基本类型默认都是不可变的（`List`，`Map`，`Set`，`Int`，`String`）。让我们看一个实际的Android示例：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every time we change the list, the view is updated. Note that while `List` is
    immutable, we need to use setter when we want to apply any changes, so we can
    be sure that after this operation the list will be updated. It is much easier
    than remembering to call the `updateListView` method every time the list changes.
    This pattern can be used widely in the project to declare properties that are
    editing views. It changes the way the update view mechanism can work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改列表时，视图都会更新。请注意，虽然`List`是不可变的，但是当我们想要应用任何更改时，我们需要使用setter，以便确保在此操作之后列表将被更新。这比记住每次列表更改时都调用`updateListView`方法要容易得多。这种模式可以广泛用于项目中声明编辑视图的属性。它改变了更新视图机制的工作方式。
- en: 'Another problem that can be solved using an observable delegate is that in
    `ListAdapters` there was always a problem that `notifyDataSetChanged` had to be
    called each time elements on the list were changed. In Java, the classic solution
    was to encapsulate this list, and call `notifyDataSetChanged` in each function
    that is modifying it. In Kotlin, we can simplify this using an observable property
    delegate:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可观察委托可以解决的另一个问题是，在`ListAdapters`中，列表中的元素每次更改时都必须调用`notifyDataSetChanged`。在Java中，经典解决方案是封装此列表，并在修改它的每个函数中调用`notifyDataSetChanged`。在Kotlin中，我们可以使用可观察属性委托来简化这个过程：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that here list is immutable, so there is no way to change its elements
    without using `notifyDataSetChanged` .
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，这里的列表是不可变的，因此没有办法在不使用`notifyDataSetChanged`的情况下更改其元素。
- en: The observable delegate is used to define behavior that should happen on the
    property value change. It is most frequently used when we have operations that
    should be done every time we change a property, or when we want to bind a property
    value with a view or some other values. But inside the function we cannot decide
    if a new value will be set or not. For this, the `vetoable` delegate is used instead.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察委托用于定义在属性值更改时应发生的行为。当我们有应该在每次更改属性时执行的操作，或者当我们想要将属性值与视图或其他值绑定时，它最常用。但在函数内部，我们无法决定是否设置新值。为此，可以使用`vetoable`委托。
- en: The vetoable delegate
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可否决的委托
- en: 'The `vetoable` function is a standard library property delegate that works
    similar as an observable delegate, but with two main differences:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`vetoable`函数是一个标准库属性委托，其工作方式类似于可观察委托，但有两个主要区别：'
- en: The lambda from an argument is called before a new value is set
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置新值之前，会先调用参数中的lambda
- en: It allows the lambda function from a declaration to decide if a new value should
    be accepted or rejected
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许声明中的lambda函数决定是否接受或拒绝新值
- en: 'For example, if we have an assumption that the list must always contain larger
    number of items than the old one, then we will define the following `vetoable`
    delegate:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们假设列表必须始终包含比旧列表更多的项目，则我们将定义以下`vetoable`委托：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If a new list will not contain a larger number of items than the old one, then
    the value will not change. So we can treat `vetoable` like `observable` , which
    is also deciding if the value should be changed or not. Let''s suppose that we
    want to have a list bounded to view, but it needs to have three elements at least.
    We don''t allow any change that will make it possible to have fewer elements.
    The implementation would look as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新列表不包含比旧列表更多的项目，则值将不会更改。因此，我们可以将`vetoable`视为`observable`，它也决定是否应更改值。假设我们想要将列表绑定到视图，但它至少需要有三个元素。我们不允许进行任何可能导致其具有更少元素的更改。实现如下：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If a new list size is smaller than 3, then we do not accept it, and return `false`
    from lambda. This `false` value returned by return statement with label (that
    is used to the return from the lambda expression) is the information that the
    new value shouldn't be accepted.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新列表的大小小于3，则我们不接受它，并从lambda返回`false`。通过标签返回的`false`值（用于从lambda表达式返回）是新值不应被接受的信息。
- en: This lambda function needs to return a value. This value is taken either from
    `return` with a label or by the last line of the lambda body. Here value `true`
    informs that a new value should be accepted.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此lambda函数需要返回一个值。此值可以从带有标签的`return`中获取，也可以从lambda主体的最后一行获取。这里的值`true`表示应接受新值。
- en: 'Here is a simple example of its usage:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其用法的一个简单示例：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We could also make it unchangeable because of some other reasons, for example,
    we might still be loading the data. Also, the vetoable property delegate can be
    used in validators. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些其他原因，我们还可以使其不可改变，例如，我们可能仍在加载数据。此外，可否决的属性委托可以用于验证器。例如：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This property can be changed only to a value that is correct according to the
    predicate `isValid(new)` .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性只能更改为符合谓词`isValid(new)`的值。
- en: Property delegation to Map type
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性委托给Map类型
- en: 'The standard library contains extensions for `Map` and `MutableMap` with the
    `String` key type that provides the `getValue` and `setValue` functions. Thanks
    to them, `map` can also be used as a property delegate:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含了对具有`String`键类型的`Map`和`MutableMap`的扩展，提供了`getValue`和`setValue`函数。由于它们，`map`也可以用作属性委托：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Map key type needs to be `String` , while value type is not restricted. It is
    often `Any` or `Any?`
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射键类型需要是`String`，而值类型没有限制。通常是`Any`或`Any?`
- en: Creating `Map` that contains all the values
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含所有值的`Map`
- en: Provide a `map` to an object.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为对象提供一个`map`。
- en: 'This can be useful when we are keeping data in `Map` , and also for following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`Map`中保存数据时，这可能很有用，也适用于以下情况：
- en: When we want to simplify the access to these values
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要简化对这些值的访问时
- en: When we define a structure that is telling us what kind of keys we should expect
    in this map
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们定义一个结构，告诉我们应该在此映射中期望哪种键
- en: When we ask for a property that is delegated to `Map` , its value will be taken
    from this map value for a key equal to the property name
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们要求委托给`Map`的属性时，其值将从此映射值中获取，键等于属性名称
- en: 'How is it implemented? Here is the simplified code from the standard library:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何实现的？这是标准库中的简化代码：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`V` is a type of value on the list'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`V` 是列表上的一种值'
- en: '`thisRef` is of type `Any?` , so `Map` can be used as property delegate in
    any context'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`thisRef`的类型是`Any?`，因此`Map`可以在任何上下文中用作属性委托。'
- en: '`V1` is return type. This is often inferred from property, but it must be subtype
    of type `V`'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`V1`是返回类型。这通常是从属性推断出来的，但它必须是类型`V`的子类型'
- en: Name of the property is used as `key` on `map.`
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的名称用作`map`上的`key`。
- en: 'Keep in mind that this is just an extension function. All that an object needs
    to be a delegate is to contain the `getValue` method (and `setValue` , for read-write
    properties). We can even create a delegate from an object of an anonymous class
    using the `object` declaration:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个扩展函数。对象要成为委托所需的一切就是包含`getValue`方法（对于读写属性还需要`setValue`）。我们甚至可以使用`object`声明从匿名类的对象创建委托：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Object is not implementing any interface. It just contains the `getValue` method
    with proper signature. And it is enough to make it work as a read-only property
    delegate.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象没有实现任何接口。它只包含具有正确签名的`getValue`方法。这足以使其作为只读属性委托工作。
- en: Note that in `map` there needs to be an entry with such a name when we are asking
    for value of property, otherwise an error will be thrown (making the property
    nullable does not change it).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在请求属性的值时，`map`中需要有一个具有这样名称的条目，否则将抛出错误（使属性可为空不会改变它）。
- en: Delegating fields to map can be useful, for example, when we have an object
    from an API with dynamic fields. We would like to treat the provided data as an
    object to have easier access to its fields, but we also need to keep it as a map
    to be able to list all the fields given by an API (even ones that we were not
    expecting).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段委托给map可能很有用，例如，当我们从API中获得一个具有动态字段的对象时。我们希望将提供的数据视为对象，以便更轻松地访问其字段，但我们还需要将其保留为映射，以便能够列出API提供的所有字段（甚至是我们没有预期的字段）。
- en: 'In the previous example, we used `Map` , which is immutable; therefore, the
    object properties were read-only (`val` ). If we want to make an object that can
    be changed, then we should use `MutableMap` , and then the properties can be defined
    as mutable (`var` ). Here is an example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了不可变的`Map`；因此，对象属性是只读的（`val`）。如果我们想要创建一个可以更改的对象，那么我们应该使用`MutableMap`，然后可以将属性定义为可变的（`var`）。这是一个例子：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Property value can be changed just by changing the value of the `map`
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性值可以通过更改`map`的值来更改
- en: Property value can be also changed like in any other property. What is really
    happening there is that value change is delegated to `setValue` , which is changing
    `map` .
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性值也可以像其他属性一样更改。真正发生的是值的更改被委托给`setValue`，它正在更改`map`。
- en: 'While properties here are mutable, the `setValue` function must also be provided.
    It is implemented as an extension function for `MutableMap` . Here is the simplified
    code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的属性是可变的，但`setValue`函数也必须提供。它被实现为`MutableMap`的扩展函数。以下是简化的代码：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note how even so simple functions can allow such innovative way of using the
    common objects. This shows what possibilities property delegates are giving.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使是如此简单的函数也可以允许使用常见对象的创新方式。这显示了属性委托所提供的可能性。
- en: Kotlin allows us to define custom delegates. Right now, we can find many libraries
    that provides new property delegates that can be used for different purposes in
    Android. There are various ways in which property delegation can be used in Android.
    In the next section, we will see some examples of custom property delegates, and
    we will take a look at cases where this feature can be really helpful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许我们定义自定义委托。现在，我们可以找到许多库，提供了可以用于Android中不同目的的新属性委托。在Android中可以使用属性委托的各种方式。在下一节中，我们将看到一些自定义属性委托的例子，并且我们将看看这个功能在哪些情况下真的很有帮助。
- en: Custom delegates
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义委托
- en: 'All previous delegates came from the standard library, but we can easily implement
    our own property delegates. We''ve seen that in order to allow a class to be a
    delegate, we need to provide the `getValue` and `setValue` functions. They must
    have a concrete signature, but there is no need to extend a class or implement
    the interface. To use object as a delegate, we don''t even need to change its
    internal implementation, because we can define `getValue` and `setValue` as extension
    functions. However, when we are creating custom classes to be a delegates, then
    interface may be useful:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的所有委托都来自标准库，但我们可以轻松实现自己的属性委托。我们已经看到，为了允许一个类成为委托，我们需要提供`getValue`和`setValue`函数。它们必须具有具体的签名，但无需扩展类或实现接口。要将对象用作委托，我们甚至不需要更改其内部实现，因为我们可以将`getValue`和`setValue`定义为扩展函数。但是，当我们创建自定义类以成为委托时，接口可能会有用：
- en: It would define functions structure, so we can generate proper methods in Android
    Studio.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将定义函数结构，这样我们就可以在Android Studio中生成适当的方法。
- en: If we are creating libraries, then we might want to make delegates classes to
    be private or internal to prevent inappropriate usage of them. We've seen this
    situation in the `notNull` section, where the class `NotNullVar` was private and
    served as a `ReadWriteProperty<Any?, T>` which is an interface.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在创建库，那么我们可能希望将委托类设置为私有或内部，以防止不当使用。我们在`notNull`部分看到了这种情况，其中类`NotNullVar`是私有的，并且作为`ReadWriteProperty<Any?,
    T>`的接口。
- en: 'Interfaces that provide full functionality to allow some class to be delegate
    are `ReadOnlyProperty` (for read-only properties) and `ReadWriteProperty` (for
    read-write properties). These interfaces are really useful, so let''s look at
    their definitions:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提供完整功能以允许某个类成为委托的接口是`ReadOnlyProperty`（用于只读属性）和`ReadWriteProperty`（用于读写属性）。这些接口非常有用，让我们看看它们的定义：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The values of parameters were already explained, but let''s look at them again:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的值已经解释过了，但让我们再看一遍：
- en: '`thisRef` : A reference to an object where the delegate is used. Its type defines
    the context in which the delegate can be used.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisRef`：委托使用的对象的引用。其类型定义了委托可以使用的上下文。'
- en: '`property` : A reference that contains data about a delegated property. It
    contains all information about this property, such as its name or type.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property`：包含有关委托属性的数据的引用。它包含有关此属性的所有信息，例如其名称或类型。'
- en: '`value` : A new value to set.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：要设置的新值。'
- en: 'The parameters `thisRef` and `property` are not used in the following delegates:
    Lazy, Observable and Vetoable. `Map` , `MutableMap` , and `notNull` use property
    to obtain the name of the property for the key. But these parameters can be used
    in different cases.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`thisRef`和`property`参数在以下委托中未使用：Lazy、Observable和Vetoable。`Map`、`MutableMap`和`notNull`使用属性来获取键的属性名称。但是这些参数可以在不同的情况下使用。'
- en: 'Let''s look at some small, but useful, examples of custom property delegates.
    We''ve seen the lazy property delegate for read-only properties; however, sometimes
    we need a lazy property that is mutable. If it would be asked for the value before
    initialization, then it should fill its value from the initializer and return
    it. In other cases it should act like a normal mutable property:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些小而有用的自定义属性委托的例子。我们已经看到了用于只读属性的延迟属性委托；然而，有时我们需要一个可变的延迟属性。如果在初始化之前要求值，那么它应该从初始化程序中填充其值并返回它。在其他情况下，它应该像普通的可变属性一样工作：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The delegate is hidden behind the interface and served by a function, and as
    such allows us to change the implementation of `MutableLazy` without worrying
    if it will affect the code that is using it.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托被隐藏在接口后面，并由一个函数提供，因此允许我们更改`MutableLazy`的实现，而不必担心它会影响使用它的代码。
- en: We are implementing `ReadWriteProperty` . It is optional, but really useful
    because it is imposing the correct structure of a read-write property. Its first
    type is `Any?` meaning that we are allowed to use this property delegate in any
    context, including top-level. Its second type is generic. Note that there is no
    restrictions on this type, so it might be nullable too.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在实现`ReadWriteProperty`。这是可选的，但非常有用，因为它强制了读写属性的正确结构。它的第一个类型是`Any?`，意味着我们可以在任何上下文中使用这个属性委托，包括顶层。它的第二个类型是泛型。请注意，对这种类型没有限制，因此它也可能是可空的。
- en: The value of the property is stored in the `value` property, and its existence
    is stored in an initialized property. We need to do it this way because we want
    to allow `T` to be a nullable type. Then `null` in the value could mean either
    that it was not yet initialized or that it is just equal to `null` .
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的值存储在`value`属性中，其存在性存储在一个初始化的属性中。我们需要这样做是因为我们希望允许`T`是可空类型。然后值中的`null`可能意味着它尚未初始化，或者它只是等于`null`。
- en: We don't need to use the `operator` modifier, because it is already used in
    interface.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要使用`operator`修饰符，因为它已经在接口中使用了。
- en: If `getValue` is called before any value is set, then the value is filled using
    initializer.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在设置任何值之前调用`getValue`，则该值将使用初始化程序填充。
- en: We need to cast the value to `T` because it might be not-null, and we initialized
    value as nullable with null as an initial value.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将值转换为`T`，因为它可能不为空，并且我们将值初始化为可空，初始值为null。
- en: 'This property delegate might be useful in different use-cases in Android development;
    for example, when a default value of a property is stored in a file, and we need
    to read it (which is a heavy operation):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种属性委托在Android开发中的不同用例中可能会很有用；例如，当属性的默认值存储在文件中，我们需要读取它（这是一个繁重的操作）：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This way, if a user sets a custom value of this property before its usage,
    we won''t have to calculate it ourselves. Second custom property delegate will
    allow us to define property getter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果用户在使用之前设置了此属性的自定义值，我们就不必自己计算它。第二个自定义属性委托将允许我们定义属性的getter：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before Kotlin 1.1 defined it, we always had to define the type of property.
    To avoid it, we can define the following extension function to functional type
    (therefore, also the lambda expression):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin 1.1之前，我们总是需要定义属性的类型。为了避免这种情况，我们可以定义以下扩展函数到函数类型（因此也是lambda表达式）：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we can define the properties with similar behavior this way:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样定义具有类似行为的属性：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This way is not preferred because of its decreased efficiency, but it is a
    nice example of possibilities that delegated properties provides us. Such a small
    extension function is making functional type to be property delegate. This is,
    the simplified code in Kotlin after compilation (note that the extension function
    is marked as inline, so its calls were replaced with its body):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式不被推荐，因为它的效率降低，但它是委托属性提供给我们的可能性的一个很好的例子。这样一个小的扩展函数将函数类型转换为属性委托。这是在Kotlin编译后的简化代码（请注意，扩展函数被标记为内联，因此它的调用被替换为它的主体）：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the next section, we are going to see some custom delegates created for real
    projects. They will be presented together with the problems that they solve.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到为真实项目创建的一些自定义委托。它们将与它们解决的问题一起呈现。
- en: View binging
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图绑定
- en: 'When we are using **Model-View-Presenter** (**MVP** ) in the project, then
    we need to make all the changes in View by Presenter. Thus, we are forced to create
    multiple functions on the view, such as:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目中使用**Model-View-Presenter**（**MVP**）时，我们需要通过Presenter在View中进行所有更改。因此，我们被迫在视图上创建多个函数，例如：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also have to define the functions in the following `interface` :'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在以下`interface`中定义函数：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We may simplify the preceding code and reduce the need for setter/getter methods
    by using property binding. We can bind the property to view element. This is the
    result we would like to achieve:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用属性绑定，我们可以简化前面的代码并减少对setter/getter方法的需求。我们可以将属性绑定到视图元素。这是我们想要实现的结果：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And `interface` :'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 和`interface`：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding example is more concise and easier to maintain. Note that we
    provide element ID by argument. A simple class that will give us the expected
    results is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子更简洁，更易于维护。请注意，我们通过参数提供元素ID。一个简单的类将给我们带来预期的结果，如下所示：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We could create a similar binding for different view properties and different
    contexts (`Fragment` , `Service` ). Another really useful tool is binding to visibility,
    which is binding a logical property (with the type `Boolean` ) to the visibility
    of a `view` element:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为不同的视图属性和不同的上下文（`Fragment`，`Service`）创建类似的绑定。另一个非常有用的工具是绑定到可见性，它将逻辑属性（类型为`Boolean`）绑定到`view`元素的可见性：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These implementations provide possibilities that would be really hard to achieve
    in Java. Similar bindings might be created for other `View` elements to make using
    MVP shorter and simpler. The snippets that were just presented are only simple
    examples, but better implementations can be found in the library `KotlinAndroidViewBindings`
    ([https://github.com/MarcinMoskala/KotlinAndroidViewBindings](https://github.com/MarcinMoskala/KotlinAndroidViewBindings)
    ).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现提供了在Java中很难实现的可能性。类似的绑定可以用于其他`View`元素，以使MVP的使用更简洁和简单。刚刚呈现的片段只是简单的例子，但更好的实现可以在库`KotlinAndroidViewBindings`中找到（[https://github.com/MarcinMoskala/KotlinAndroidViewBindings](https://github.com/MarcinMoskala/KotlinAndroidViewBindings)）。
- en: Preference binding
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首选绑定
- en: 'To show more complex examples, we will present the attempt to help with the
    `SharedPreferences` usage. There are better Kotlin approaches for this problem,
    but this attempt is nice to analyze, and it is a reasonable example of we use
    property delegate on extension property. As a result, we want to be able to treat
    values saved in `SharedPreferences` as if they were properties of a `SharedPreferences`
    object. Here is example usage:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示更复杂的例子，我们将尝试帮助使用`SharedPreferences`。对于这个问题，有更好的Kotlin方法，但这个尝试很好分析，并且是我们在扩展属性上使用属性委托的一个合理例子。因此，我们希望能够将保存在`SharedPreferences`中的值视为`SharedPreferences`对象的属性。以下是示例用法：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can achieve it if we make the following extension property definitions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义以下扩展属性定义，我们就可以实现它：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The property of type Boolean. When a property is non-nullable, than default
    values have to be provided in the first argument of function.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔类型的属性。当属性是非空时，必须在函数的第一个参数中提供默认值。
- en: The property can have custom key provided. It is useful in real-life projects,
    where we must have control over this key (for example, to not change it unintentionally
    during property rename).
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性可以提供自定义键。这在实际项目中非常有用，因为我们必须控制这个键（例如，不要在属性重命名时无意中更改它）。
- en: 'Let''s analyze how it works by deep investigation of the not-null property.
    First, let''s look at the provider functions. Note that the type of the property
    is determining the way the value is taken from `SharedPreferences` (because there
    are different functions, such as `getString` , `getInt` , and so on). To obtain
    it, we need this class type to be provided as the `reified` type of the `inline`
    function, or through the parameter. This is what a delegate provider function
    looks like:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过深入研究非空属性的工作原理来分析它是如何工作的。首先，让我们看看提供函数。请注意，属性的类型决定了从 `SharedPreferences`
    中获取值的方式（因为有不同的函数，比如 `getString`、`getInt` 等）。为了获取它，我们需要将这个类类型作为 `inline` 函数的 `reified`
    类型提供，或者通过参数提供。这就是委托提供函数的样子：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both functions are returning object behind interface `ReadWriteProperty<SharedPreferences,
    T>` . Note that context here is set to `SharedPreferences` , so it can be used
    only there or in `SharedPreferences` extensions. This function is defined because
    the type parameter cannot be redefined and we need to provide type as a normal
    parameter.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个函数都返回接口 `ReadWriteProperty<SharedPreferences, T>` 后面的对象。请注意，这里的上下文设置为 `SharedPreferences`，因此只能在那里或在
    `SharedPreferences` 扩展中使用。定义这个函数是因为类型参数不能重新定义，我们需要将类型作为普通参数提供。
- en: Note that the `bindToPreferenceField` function cannot be private or internal,
    because inline functions can use only functions with the same or less restricted
    modifiers.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`bindToPreferenceField` 函数不能是私有的或内部的，因为内联函数只能使用相同或更少限制的函数。
- en: 'Finally, let''s see the `PreferenceFieldDelegate` class, which is our delegate:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 `PreferenceFieldDelegate` 类，它是我们的委托：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we know how the `thisRef` parameter is used. It is of the type `SharedPreferences`
    , and we can use it to get and set all the values. Here are definitions of the
    functions used to get and save values depending on property type:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `thisRef` 参数的用法。它的类型是 `SharedPreferences`，我们可以使用它来获取和设置所有的值。以下是用于根据属性类型获取和保存值的函数的定义：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also need `toJson` and `fromJson` defined:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义 `toJson` 和 `fromJson`：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'With such definitions we can define additional extension properties to `SharedPreferences`
    :'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的定义，我们可以为 `SharedPreferences` 定义额外的扩展属性：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As we''ve already seen in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* , there is no such thing in Java as a field that we might add
    to a class. Under the hood, the extension property is compiled to getter and setter
    functions, and they are delegating calls to a created delegate:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第7章](text00171.html) *扩展函数和属性* 中已经看到的，Java 中没有我们可以添加到类中的字段。在底层，扩展属性被编译为
    getter 和 setter 函数，并且它们将调用委托创建。
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Also remember that extension functions are, in fact, just static functions
    with an extension on the first parameter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，扩展函数实际上只是带有第一个参数扩展的静态函数：
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Presented examples should be enough to understand how property delegates are
    working and how they can be used. Property delegates are used intensively in Kotlin
    open source libraries. They are used to make fast and simple Dependency Injection
    (for example, Kodein, Injekt, TornadoFX), binding to views, `SharedPreferences`
    or other elements (attempts already shown includes `PreferenceHolder` , and `KotlinAndroidViewBindings`
    ), to define property keys on configuration definition (for example, Konfig),
    or even to define a database column structure (for example, Kwery). Still there
    is a big field of usages that are waiting to be discovered.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍的例子应该足以理解属性委托的工作原理以及它们的用法。属性委托在 Kotlin 开源库中被广泛使用。它们被用于快速简单的依赖注入（例如 Kodein、Injekt、TornadoFX）、绑定到视图、`SharedPreferences`
    或其他元素（已经包括 `PreferenceHolder` 和 `KotlinAndroidViewBindings`）、在配置定义中定义属性键（例如 Konfig），甚至用于定义数据库列结构（例如
    Kwery）。还有许多用法等待被发现。
- en: Providing a delegate
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供委托
- en: Since Kotlin 1.1, there is an operator, `provideDelegate` , that is used to
    provide delegate during class initialization. The main motivation behind `provideDelegate`
    was that it allows to provide customized delegate depending on traits of property
    (name, type, annotations, and so on).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kotlin 1.1 开始，有一个名为 `provideDelegate` 的操作符，用于在类初始化期间提供委托。`provideDelegate`
    的主要动机是它允许根据属性的特性（名称、类型、注解等）提供自定义委托。
- en: 'The `provideDelegate` operator returns delegate, and all types that have this
    operator do not need to be delegates themselves in order to be used as a delegate.
    Here is an example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`provideDelegate` 操作符返回委托，所有具有此操作符的类型不需要自己是委托就可以作为委托使用。以下是一个例子：'
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this example, `A` is used as a delegate, while it implements neither `getvalue`
    nor `setvalue` function. This is possible, because it defines a `provideDelegate`
    operator, which returns the delegate that will be used instead of `A` . Property
    delegation is compiled into the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`A` 被用作委托，虽然它既不实现 `getvalue` 也不实现 `setvalue` 函数。这是可能的，因为它定义了一个 `provideDelegate`
    操作符，它返回将用于代替 `A` 的委托。属性委托被编译为以下代码：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Practical example can be found in Kotlin supporting part of library `ActivityStarter`
    ([https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)
    ). Activity arguments are defined using annotations, but we can use property delegation
    to simplify usage from Kotlin and allow properties definition as possibly read-only
    and not `lateinit` :'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 支持的库 `ActivityStarter` 的一部分中可以找到实际的例子（[https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)）。活动参数是使用注解定义的，但我们可以使用属性委托来简化从
    Kotlin 使用，并允许属性定义为可能是只读的而不是 `lateinit`。
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'But there are some requirements:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有一些要求：
- en: When `argExtra` is used, property getter have to be annotated
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `argExtra` 时，属性的 getter 必须被注解
- en: We need to specify default value if argument is optional and type is not nullable.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是可选的，并且类型不可为空，我们需要指定默认值。
- en: 'To check this requirements, we need reference to property to get getter annotation.
    We cannot have such reference in the `argExtra` function, but we can implement
    them inside `provideDevegate` :'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这些要求，我们需要引用属性以获取 getter 注释。我们不能在 `argExtra` 函数中拥有这样的引用，但我们可以在 `provideDevegate`
    中实现它们：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Such delegate is throwing appropriate error when condition is not fulfilled:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件不满足时，这种委托会抛出适当的错误：
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`@get:Arg(optional = true) val a: A by ArgValueDelegateProvider()` throws error
    during initialization: `Arguments that are optional and have not-nullable type
    must have default value specified` .'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`@get:Arg(optional = true) val a: A by ArgValueDelegateProvider()` 在初始化期间抛出错误：`必须指定可选且非空类型的参数的默认值`。'
- en: This way unacceptable argument definitions are throwing appropriate errors during
    object initialization instead of breaking application in unexpected situations.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式在对象初始化期间，不接受不可接受的参数定义，而是抛出适当的错误，而不是在意外情况下破坏应用程序。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described class delegate, property delegates, and how they
    can be used to remove redundancy in code. We defined a delegate as an object to
    which calls from other object or property are delegated to. We learned design
    patterns that class delegation is strongly connected to Delegate pattern and Decorator
    pattern.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了类委托、属性委托，以及它们如何用于消除代码中的冗余。我们将委托定义为其他对象或属性调用的对象。我们学习了与类委托密切相关的委托模式和装饰器模式的设计模式。
- en: 'Delegation pattern is mentioned as an alternative to inheritance, and Decorator
    pattern is a way to add functionality to different kinds of classes that are implementing
    the same interface. We''ve seen how property delegation works, and Kotlin standard
    library property delegates: `notNull` , `lazy` , `observable` , `vetoable` , and
    the usage of `Map` as a delegate. We learned how they work and when they should
    be used. We''ve also seen how to make a custom property delegate, together with
    examples of real-life usage.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式被提及为继承的一种替代方案，装饰器模式是一种向实现相同接口的不同类添加功能的方式。我们已经看到了属性委托的工作原理，以及 Kotlin 标准库的属性委托：`notNull`，`lazy`，`observable`，`vetoable`，以及使用
    `Map` 作为委托的用法。我们学习了它们的工作原理以及何时应该使用它们。我们还看到了如何制作自定义属性委托，以及实际用例示例。
- en: Knowledge about different features and their usage is not enough--there is also
    a need to understand how they can be used together to build great applications.
    In the next chapter, we will write a demo application and explain how the various
    Kotlin features described throughout this book can be combined together.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对不同特性及其用法的了解是不够的，还需要理解它们如何结合在一起构建出色的应用程序。在下一章中，我们将编写一个演示应用程序，并解释本书中描述的各种 Kotlin
    特性如何结合在一起。
