["```ts\nnpm install mongoose @types/mongoose --save-dev\n```", "```ts\npublic Connect(): void {\n  mongoose.connect(this.url, {useNewUrlParser: true}, (e:unknown) => {\n    if (e) {\n      console.log(`Unable to connect ` + e);\n    } else {\n      console.log(`Connected to the database`);\n    }\n  });\n}\n```", "```ts\nexport interface ITodoSchema extends mongoose.Document {\n  Id: string,\n  Title: string,\n  Description: string,\n  DueDate: Date,\n  CreationDate: Date,\n  Completed: boolean,\n}\n```", "```ts\nexport const TodoSchema = new Schema({\n  Id: String,\n  Title: String,\n  Description: String,\n  DueDate: Date,\n  CreationDate: Date,\n  Completed: Boolean,\n});\n```", "```ts\nexport const TodoModel = mongoose.model<ITodoSchema>('todo', TodoSchema, 'todoitems', false);\n```", "```ts\nexport abstract class DataAccessBase<T extends mongoose.Document> {\n  private model: Model;\n  constructor(model: Model) {\n    this.model = model;\n  }\n}\n```", "```ts\nexport class TodoDataAccess extends DataAccessBase<ITodoSchema> {\n  constructor() {\n    super(TodoModel);\n  }\n}\n```", "```ts\nGetAll(): Promise<T[]> {\n  return new Promise<T[]>((callback, error) => {\n    this.model.find((err: unknown, result: T[]) => {\n      if (err) {\n        error(err);\n      }\n      if (result) {\n       callback(result);\n      }\n    });\n });\n}\n```", "```ts\nAdd(item: T): Promise<boolean> {\n  return new Promise<boolean>((callback, error) => {\n    this.model.create(item, (err: unknown, result: T) => {\n      if (err) {\n        error(err);\n      }\n      callback(!result);\n    });\n  });\n}\n```", "```ts\nGet(id: string): Promise<T> {\n  return new Promise<T>((callback, error) =>{\n    this.model.find({'Id': id}, (err: unknown, result: T) => {\n      if (err) {\n        error(err);\n      }\n      callback(result);\n    });\n  });\n}\n```", "```ts\nRemove(id: string): Promise<void> {\n  return new Promise<void>((callback, error) => {\n    this.model.deleteOne({'Id': id}, (err: unknown) => {\n      if (err) {\n        error(err);\n      }\n      callback();\n    });\n  });\n}\nUpdate(id: string, item: T): Promise<boolean> {\n  return new Promise<boolean>((callback, error) => {\n    this.model.updateOne({'Id': id}, item, (err: unknown)=>{\n      if (err) {\n        error(err);\n      }\n      callback(true);\n    });\n  })\n}\n```", "```ts\nexport class Prefill {\n  private constructor() {}\n}\n```", "```ts\nprivate static prefill: Prefill;\npublic static get Instance(): Prefill {\n  return this.prefill || (this.prefill = new this());\n}\n```", "```ts\nprivate items: TodoItems[] = new Array<TodoItem>();\npublic async Populate(): Promise<void> {\n  try\n  {\n    const schema = await this.dataAccess.GetAll();\n    this.items = new Array<TodoItem>();\n    schema.forEach(item => {\n      const todoItem: TodoItem = new TodoItem();\n      todoItem.Id = item.Id;\n      todoItem.Completed = item.Completed;\n      todoItem.CreationDate = item.CreationDate;\n      todoItem.DueDate = item.DueDate;\n      todoItem.Description = item.Description;\n      todoItem.Title = item.Title;\n      this.items.push(todoItem);\n    });\n  } catch(error) {\n    console.log(`Unfortunately, we couldn't retrieve all records ${error}`);\n  }\n}\n```", "```ts\nget Items(): TodoItem[] {\n  return this.items;\n}\n```", "```ts\nimport {\n  graphql,\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLString\n} from 'graphql';\n\nvar schema = new GraphQLSchema({\n  query: new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n      hello: {\n        type: GraphQLString,\n        resolve() {\n          return 'world';\n        }\n      }\n    }\n  })\n});\n```", "```ts\nnpm install type-graphql @types/graphql reflect-metadata --save\n```", "```ts\n{\n  \"compileOnSave\": false,\n  \"compilerOptions\": {\n    \"target\": \"es2016\", \n    \"module\": \"commonjs\",\n    \"lib\": [\"es2016\", \"esnext.asynciterable\", \"dom\"],\n    \"outDir\": \"./dist\",\n    \"noImplicitAny\": true,\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n  }\n}\n```", "```ts\nexport class TodoItem {\n}\n```", "```ts\n@ObjectType({description: \"A single to do\"})\nexport class TodoItem {\n}\n```", "```ts\n@Field(type=>ID)\nId: string=\"\";\n```", "```ts\n@Field({ nullable: true, description: \"The description of the item.\" })\nDescription?: string;\n@Field({ nullable: true, description: \"The due date for the item\" })\nDueDate?: Date;\n@Field({ nullable: true, description: \"The date the item was created\" })\nCreationDate: Date;\n```", "```ts\n@Field()\nTitle: string;\n@Field(type => Int)\nDaysCreated: number;\n@Field()\nCompleted: boolean;\n```", "```ts\n@ObjectType({ description: \"A single to do\" })\nexport class TodoItem {\n  constructor() {\n    this.Completed = false;\n  }\n  @Field(type=>ID)\n  Id: string = \"\";\n  @Field()\n  Title: string;\n  @Field({ nullable: true, description: \"The description of the item.\" })\n  Description?: string;\n  @Field({ nullable: true, description: \"The due date for the item\" })\n  DueDate?: Date;\n  @Field({ nullable: true, description: \"The date the item was created\" })\n  CreationDate: Date;\n  @Field(type => Int)\n  DaysCreated: number;\n  @Field()\n  Completed: boolean;\n}\n```", "```ts\n@InputType()\nexport class TodoItemInput implements Partial<TodoItem> {\n  @Field()\n  Id: string;\n  @Field({description: \"The item title\"})\n  Title: string = \"\";\n  @Field({ nullable: true, description: \"The item description\" })\n  Description?: string = \"\";\n  @Field({ nullable: true, description: \"The item due date\" })\n  DueDate?: Date;\n  @Field()\n  CreationDate: Date;\n  @Field()\n  Completed: boolean = false;\n}\n```", "```ts\n@Resolver(()=>TodoItem)\nexport class TodoItemResolver implements ResolverInterface<TodoItem>{\n}\n```", "```ts\nprivate readonly milliSecondsPerDay = 1000 * 60 * 60 * 24;\n@FieldResolver()\nDaysCreated(@Root() TodoItem: TodoItem): number {\n  const value = this.GetDateDifference(...[new Date(), TodoItem.CreationDate]);\n  if (value === 0) {\n    return 0;\n  }\n  return Math.round(value / this.milliSecondsPerDay);\n}\nprivate GetDateDifference(...args: [Date, Date]): number {\n  return Math.round(args[0].valueOf() - args[1].valueOf());\n}\n```", "```ts\n@Query(() => [TodoItem], { description: \"Get all the TodoItems\" })\nasync TodoItems(): Promise<TodoItem[]> {\n  return await Prefill.Instance.Items;\n}\n```", "```ts\n@Query(() => [TodoItem], { description: \"Get items past their due date\" })\nasync OverdueTodoItems(): Promise<TodoItem[]> {\n  const localCollection = new Array<TodoItem>();\n  const testDate = new Date();\n  await Prefill.Instance.Items.forEach(x => {\n    if (x.DueDate < testDate && !x.Completed) {\n      localCollection.push(x);\n    }\n  });\n  return localCollection;\n}\n```", "```ts\n@Mutation(() => TodoItem)\nasync Add(@Arg(\"TodoItem\") todoItemInput: TodoItemInput): Promise<TodoItem> {\n}\n```", "```ts\nprivate CreateTodoSchema<T extends TodoItem | TodoItemInput>(todoItem: T): ITodoSchema {\n  return <ITodoSchema>{\n    Id: todoItem.Id,\n    CreationDate: todoItem.CreationDate,\n    DueDate: todoItem.DueDate,\n    Description: todoItem.Description,\n    Title: todoItem.Title,\n    Completed: false\n  };\n}\n```", "```ts\n@Mutation(() => TodoItem)\nasync Add(@Arg(\"TodoItem\") todoItemInput: TodoItemInput): Promise<TodoItem> {\n  const todoItem = <TodoItem> {\n    Id : todoItemInput.Id,\n    CreationDate : todoItemInput.CreationDate,\n    DueDate : todoItemInput.DueDate,\n    Description : todoItemInput.Description,\n    Title : todoItemInput.Title,\n    Completed : todoItemInput.Completed\n  };\n  todoItem.Completed = false;\n  await Prefill.Instance.Items.push(todoItem);\n  await this.dataAccess.Add(this.CreateTodoSchema(todoItem));\n  return todoItem;\n}\n```", "```ts\n@Mutation(() => Boolean!)\nasync Update(@Arg(\"TodoItem\") todoItemInput: TodoItemInput): Promise<boolean> {\n  const item: TodoItem = await Prefill.Instance.Items.find(x => x.Id === todoItemInput.Id);\n  if (!item) return false;\n  item.Title = todoItemInput.Title;\n  item.Description = todoItemInput.Description;\n  item.DueDate = todoItemInput.DueDate;\n  this.dataAccess.Update(item.Id, this.CreateTodoSchema(item));\n  return true;\n}\n```", "```ts\n@Mutation(() => Boolean!)\nasync Remove(@Arg(\"Id\") id: string): Promise<boolean> {\n  const index = Prefill.Instance.Items.findIndex(x => x.Id === id);\n  if (index < 0) {\n    return false;\n  }\n  Prefill.Instance.Items.splice(index, 1);\n  await this.dataAccess.Remove(id);\n  return true;\n}\n```", "```ts\n@Mutation(() => Boolean!)\nasync Complete(@Arg(\"Id\") id: string) : Promise<boolean> {\n  const item: TodoItem = await Prefill.Instance.Items.find(x => x.Id === id);\n  if (!item) return false;\n  item.Completed = true;\n  await this.dataAccess.Update(item.Id, this.CreateTodoSchema(item));\n  return true;\n}\n```", "```ts\nnpm install apollo-server apollo-server-express --save\n```", "```ts\nexport class MyApp {\n  constructor(private mongo: Mongo = new Mongo()) { }\n}\n```", "```ts\npublic async Start(): Promise<void> {\n  this.mongo.Connect();\n\n  await Prefill.Instance.Populate();\n\n  const server = new ApolloServer({ schema, playground: true });\n  await server.listen(3000);\n}\n```", "```ts\nconst schema: GraphQLSchema = await buildSchema({\n  resolvers: [TodoItemResolver],\n  validate: false,\n  emitSchemaFile: path.resolve(__dirname, 'apolloschema.gql')\n});\n```", "```ts\nquery {\n  TodoItems {\n    Id\n    Title\n    Description\n    Completed\n    DaysCreated\n  }\n}\n```", "```ts\nng new Chapter05 --style scss --prefix atp --routing true\n```", "```ts\nng add @angular/material @angular/cdk @angular/animation @angular/flex-layout\n```", "```ts\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    BrowserAnimationsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```", "```ts\nHttpClientModule,\nHttpLinkModule,\nBrowserAnimationsModule,\nMatToolbarModule,\nMatButtonModule,\nMatSidenavModule,\nMatIconModule,\nMatListModule,\nFlexLayoutModule,\nHttpClientModule,\nMatInputModule,\nMatCardModule,\nMatNativeDateModule,\nMatDatepickerModule,\n```", "```ts\nng add apollo-client\n```", "```ts\nconstructor(httpLink: HttpLink, apollo: Apollo) {\n}\n```", "```ts\napollo.create({\n  link: httpLink.create({ uri: 'http://localhost:3000' }),\n  cache: new InMemoryCache(),\n  defaultOptions: {\n    watchQuery: {\n      // To get the data on each get, set the fetchPolicy\n      fetchPolicy: 'network-only'\n    }\n  }\n});\n```", "```ts\nng g c components/AddTask\nng g c components/Alltasks\nng g c components/OverdueTasks\n```", "```ts\nconst routes: Routes = [\n];\n```", "```ts\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```", "```ts\n{\n  path: 'all',\n  component: AlltasksComponent\n},\n```", "```ts\n{\n  path: '',\n  redirectTo: 'all',\n  pathMatch: 'full'\n},\n```", "```ts\n{\n  path: 'add',\n  component: AddTaskComponent\n},\n{\n  path: 'overdue',\n  component: OverduetasksComponent\n}\n```", "```ts\n<mat-toolbar color=\"primary\">\n  <mat-nav-list><a mat-list-item routerLink=\"all\">All tasks</a></mat-nav-list>\n  <mat-nav-list><a mat-list-item routerLink=\"overdue\">Overdue tasks</a></mat-nav-list>\n  <mat-nav-list><a mat-list-item routerLink=\"add\">Add task</a></mat-nav-list>\n</mat-toolbar> \n<div>\n  <router-outlet></router-outlet>\n</div>\n```", "```ts\nEarliestDate: Date;\nngOnInit() {\n this.EarliestDate = new Date();\n}\n```", "```ts\nTitle: string;\nDescription?: string;\nDueDate: Date;\n```", "```ts\nconstructor(private apollo: Apollo) { }\n```", "```ts\nAdd(): void {\n}\n```", "```ts\nconst todo: ITodoItemInput = new TodoItemInput();\ntodo.Completed = false;\ntodo.Id = Guid.create.toString();\ntodo.CreationDate = new Date();\ntodo.Title = this.Title;\ntodo.Description = this.Description;\ntodo.DueDate = this.DueDate;\n```", "```ts\nnpm install --save guid-typescript\n```", "```ts\nthis.apollo.mutate({\n ... logic goes here\n})\n```", "```ts\nthis.apollo.mutate({\n  mutation: gql`\n    mutation Add($input: TodoItemInput!) {\n      Add(TodoItem: $input) {\n        Title\n      }\n    }\n  `, variables: {\n    input: todo\n  }\n}).subscribe();\n```", "```ts backtick\u00a0because this lets us spread our input over multiple lines.\n\nThe `mutate` method is triggered from the call to `subscribe`. If we fail to supply this, our mutation will not run. As a convenience, I also added a `Reset` method so that we can clear values away from the UI when the user finishes. I did this so that the user would be able to immediately enter new values:\n\n```", "```ts\n\nThat is the logic inside our component taken care of. What we need to do now is add the HTML that will be displayed in the component. Before we add any elements to our component, we want to display the card that will contain our display. This will be centered vertically and horizontally in the display. This is not something that comes naturally to Material, so we have to supply our own local styling. We have a couple of other styles that we are going to set as well, to fix the size of the text area and the width of the card, and to set how we display form fields to make sure each one appears on its own line.\n\nInitially, we will set up a style to center the card. The card will be displayed inside a `div`\u00a0tag, so we will apply the styling to the\u00a0`div`\u00a0tag, which will center the card inside it:\n\n```", "```ts\n\nNow, we can style the Material card and form fields:\n\n```", "```ts\n\nFinally, we are going to set the height of the `textarea`\u00a0tag that the user will use to enter their description to 100 pixels:\n\n```", "```ts\n\nGetting back to our display, we are going to set up the container for our card so that it is centered:\n\n```", "```ts\n\nWe have reached a point where we want to start leveraging the power of Angular to control the validation of the user input. In order to start treating user input as though it's all related, we are going to put the input parts of our display inside an HTML form:\n\n```", "```ts\n\nWe need to break this form statement down a bit. We will start by working out what `#f=\"ngForm\"` actually does. This statement assigns the\u00a0`ngForm` component\u00a0to a variable called `f`. When we use `ngForm`, we are referring to the component inside\u00a0`FormsModule` (make sure that it's registered inside the `app.module` imports section). The reason that we do this is because this assignment means that we have access to properties of the component itself. The use of `ngForm` means that we are working with the top-level form group so that we can do things such as track whether or not the form is valid.\n\nWe can see this inside\u00a0`ngSubmit`, where we are subscribing to the event that tells us that the user has triggered the form submission, which results in the validation being checked; when the data is valid, this results in triggering the `Add` method. With this in place, we don't have to directly call `Add` when the Save button is clicked because the submit event will take care of this for us.\n\nThere is a short-circuit logic in play with `ngSubmit`. In other words, if the form is not valid, then we won't call the `Add` method.\n\nWe are now ready to add the card itself. This lives entirely inside our form. The title section is placed inside a `mat-card-title` section and our buttons are situated inside the `mat-card-actions` section, which aligns the buttons at the bottom of the card. As we just covered, we aren't supplying a click event handler to our Save button because the form submission\u00a0will take care of this:\n\n```", "```ts\n\nWe are ready to start adding the fields so that we can tie them back to the fields in our underlying model. We will start with the title as the description field largely follows this format as well. We will add the field and its related validation display in first, and then we will break down what is happening:\n\n```", "```ts\n\nThe first part of our input element is largely self-explanatory. We created it as a text field and used\u00a0`matInput` to hook the standard input so that it can be used inside\u00a0`mat-form-field`. With this, we can set the placeholder text to something appropriate.\n\nI opted to use `[(ngModel)]` instead of `[ngModel]` because of the way binding works. With `[ngModel]`, we get one-way binding so that it changes flow from the underlying property through to the UI element that displays it. Since we are going to be allowing the input to change the values, we need a form of binding that allows us to send information back from the template to the component. In this case, we are sending the value back to the `Title` property in the element.\n\nThe `name` property must be set. If it is not set, Angular throws internal warnings and our binding will not work properly. What we do here is set the name and then use `#` with the value set in the name to tie it to\u00a0`ngModel`. So, if we had `name=\"wibbly\"`, we would have `#wibbly=\"ngModel\"` as well.\n\nSince this field is required, we simply need to supply the `required` attribute, and our form validation will start working here.\n\nNow that we have the input element hooked up to validation, we need some way of displaying any errors. This is where the next `div` statement comes in. The opening `div` statement basically reads as *if the title is invalid (because it is required and has not been set, for instance), and it has either had a value changed in it or we have touched the field by setting focus to it at some point, then we need to display internal content using the alert and alert-danger attributes*.\n\nAs our validation failure might just be one of several different failures, we need to tell the user what the problem actually was. The inner `div` statement displays the appropriate text because it is scoped to a particular error. So, when we see `title.errors.required`, our template will display the You must add a title*.* text when no value has been entered.\n\nWe aren't going to look at the description field because it largely follows the same format. I would recommend looking at the Git code to see how that is formatted.\n\nWe still have to add the `DueDate` field to our component. We are going to use the Angular date picker module to add this. Effectively, the date picker is made up of three parts.\n\nWe have an input field that the user can type directly into. This input field is going to have a `min` property set on it that binds the earliest date the user can select to the `EarliestDate` field we created in the code behind the component. Just like we did in the title field, we will set this field to required so that it will be validated by Angular, and we will apply `#datepicker=\"ngModel\"` so that we can associate the `ngModel` component with this input field by setting the name with it:\n\n```", "```ts\n\nThe way that we associate the input field is by using `[matDatepicker]=\"picker\"`. As part of our form field, we have added a `mat-datepicker` component. We use `#picker` to name this component `picker`, which ties back to the `matDatepicker` binding\u00a0in our input field:\n\n```", "```ts\n\nThe final part that we need to add is the toggle that the user can press to show the calendar part on the page. This is added using\u00a0`mat-datepicker-toggle`. We tell it what date picker we are applying the calendar to by using `[for]=\"picker\"`:\n\n```", "```ts\n\nRight now, our form field looks like this:\n\n```", "```ts\n\nAll that we are missing now is the validation. Since we have already defined that the earliest date we can choose is today, we don't need to add any validation to that. We have no maximum date to worry about, so all we need to do is check that the user has chosen a date:\n\n```", "```ts\n\nSo, we have reached the point where we can add tasks to our todo list and they will be saved to the database, but that isn't much use to us if we can't actually view them. We are now going to turn our attention to the `AllTasksComponent` and `OverdueTasksComponent` components.\n\nOur `AllTasksComponent` and `OverdueTasksComponent` components are going to display the same information. All that differs between the two is the GQL call that is made. Because they have the same display, we are going to add a new component that will display the todo information. `AllTasksComponent` and `OverdueTasksComponent` will both use this component:\n\n```", "```ts\n\nJust like in our add task component,\u00a0`TodoCardComponent` is going to start off with an `EarliestDate` field and the Apollo client being imported:\n\n```", "```ts\n\nWe have reached the point where we need to consider what this component is actually going to be doing. It will receive a single\u00a0`ITodoItem` as input from either `AllTasksComponent` or `OverdueTasksComponent`, so we will need a means for the containing component to be able to pass this information in. We will also need a means to notify the containing component of when the todo item has been deleted so that it can be removed from the tasks being displayed (we will just do this on the client side rather than triggering a requery via GraphQL). Our UI will add a Save button when the user is editing the record, so we are going to need some way to track that the user is in the edit section.\n\nWith those requirements for the component, we can add in the necessary code to support this. First, we are going to address the ability to pass in a value to our component as an input parameter. In other words, we are going to add a field that can be seen and has values set on it by using data binding by the containers. Fortunately, Angular makes this a very simple task. By marking a field with `@Input`, we expose it for data binding:\n\n```", "```ts\n\nThat takes care of the input, but how do we let the container know when something has happened? When we delete a task, we want to raise an event as output from our component. Again, Angular makes this simple by using `@Output` to expose something; in this case, we are going to expose\u00a0`EventEmitter`. When we expose this to our containers, they can subscribe to the event and react when we emit the event. When we create\u00a0`EventEmitter`,\u00a0we are going to create it to pass the `Id`\u00a0of our task back, so we need `EventEmitter` to be a string event:\n\n```", "```ts\n\nWith this code in place, we can update our `AllTasksComponent` and `OverdueTasksComponent` templates that will hook up to our component:\n\n```", "```ts\n\nBefore we finish adding the logic to\u00a0`TodoCardComponent`, let's get back to\u00a0`AllTasksComponent` and `OverdueTasksComponent`. Internally, these are both very similar, so we will concentrate on the logic in `OverdueTasksComponent`.\n\nIt shouldn't come as a shock now that these components will accept an Apollo client in the constructor. As we saw from\u00a0`ngFor` previously, our component will also expose an array of `ITodoItem` called `todos`, which will be populated by our query:\n\n```", "```ts\n\nYou may notice, from looking at the code in the repository, that we have not added this code into our component. Instead, we are using a base class called `SubscriptionBase` that provides us with a `Subscribe` method and a resubscribe event.\n\nOur `Subscribe` method is generic accepts either\u00a0`OverdueTodoItemQuery` or\u00a0`TodoItemQuery` as the type, along with a `gql` query, and returns an observable that we can subscribe to in order to pull out the underlying data. The reason we have added the base class goes back to the fact that\u00a0`AllTasksComponent` and `OverdueTasksComponent` are just about identical, so it makes sense to reuse as much code as possible. The name that is sometimes given to this philosophy is **Don't Repeat Yourself** (**DRY**):\n\n```", "```ts\n\nAll this method does is create a query using\u00a0`gql` and set\u00a0`fetch-policy` to `no-cache`\u00a0to force the query to read from the network rather than relying on the cache set in\u00a0`app-module`. This is just another way of controlling whether or not we read from the in-memory cache:\n\n```", "```ts\n\nWe extend from a choice of two interfaces because they both expose the same items but with different names. So, `OverdueTodoItemQuery` exposes `OverdueTodoItems` and `TodoItemQuery` exposes `TodoItems`. The reason that we have to do this, rather than using just one interface, is because the field must match the name of the query. This is because Apollo client uses this to automatically map results back.\n\nThe `resubscribe` method is called after the user clicks the delete button in the interface (we will get to building up the UI template shortly). We saw that our `resubscribe` method was wired up to the event and that it would receive the event as a string, which would contain the `Id` of the task we want to delete. Again, all we are going to do to delete the record is find the one with the matching `Id`, and then splice the todos list to remove it:\n\n```", "```ts\n\nGoing back to\u00a0`OverdueTasksComponent`, all we need to do is call `subscribe`, passing in our `gql`\u00a0query and subscribing to the return data. When the data comes back, we are going to populate our todos array, which will be displayed in the UI:\n\n```", "```ts\n\nA note on our subscription\u2014as we are creating a new list of items to display, we need to clear `this.todos` before we start pushing the whole list back into it.\n\nWith `AllTasksComponent` and `OverdueTasksComponent` complete, we can turn our attention back to `TodoCardComponent`. Before we finish off adding the component logic, we really need to take a look at the way the template is created. A large part of the logic is similar to the add task UI logic, so we aren't going to worry about how to hook up to a form or add a validation. The things I want to concentrate on here relate to the fact that the task component will display differently when the user is in edit mode, as opposed to a read-only or label-based version. Let's start by looking at the title. When the task is in read-only mode, we are just going to display the title in\u00a0`span`, like this:\n\n```", "```ts\n\nWhen we are editing the task, we want to show input elements and validation, as follows:\n\n```", "```ts\n\nWe do this by using a neat trick of Angular. Behind the scenes, we are maintaining an `InEdit` flag. When that is false, we want to display the span. If it is true, we want to display a template in its place that contains our input logic. To do this, we start off by wrapping our span inside a `div` tag. This has an `ngIf` statement\u00a0that is bound to\u00a0`InEdit`. The `ngIf` statement contains an `else` clause that picks up the template with the matching name and displays this in its place:\n\n```", "```ts\n\nOther fields are displayed in a similar way. There is one more point of interest in the way we display the read-only fields.\u00a0`DueDate` needs to be formatted in order to be displayed as a meaningful date rather than as the raw date/time that is saved in the database. We use\u00a0`|` to pipe\u00a0`DueDate` into a special date formatter that controls how the date is displayed. For instance, March 21, 2018 would be displayed as `Due: Mar 21st, 2019` using the following date pipe:\n\n```", "```ts\n\nPlease take the time to review the rest of `todo-card.component.html`. Swapping templates is heavily done, so it is a good way to review how to make the same UI serve two purposes.\n\nIn the component itself, we have three operations left to look at. The first one that we will cover is the `Delete` method, which is triggered when the user presses the delete button on the component. This is a simple method that calls the `Remove` mutation, passing the `Id` across to be removed. When the item has been removed from the server, we call `emit` on our `deleted` event. This event passes the `Id` back to the containing component, which results in this item being removed from the UI:\n\n```", "```ts\n\nThe `Complete` method is just as simple. When the user clicks the `Complete` link, we call the `Complete` query, which passes across the current `Id` as the matching variable. As we could be in edit mode at this point, we call `this.Edit(false)` to switch back to read-only mode:\n\n```", "```ts\n\nThe `Save` method is very similar to the `Add` method in the add task\u00a0component. Again, we need to switch back from edit mode when this mutation finishes:\n\n```"]