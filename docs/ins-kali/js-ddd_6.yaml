- en: Chapter 6. Context Map – The Big Picture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。上下文地图-整体情况
- en: The dungeon manager application, for now, only contains the functionality to
    manage prisoner transportation, but as our application grows, the need to organize
    the code increases as well. The number of developers able to concurrently work
    on a piece of software is limited. Jeff Bezos (founder and CEO of Amazon.com)
    once stated that the size of a team should be no more than that can be fed by
    two pizzas ([http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200](http://www.wsj.com/news/articles/SB10001424052970203914304576627102996831200)).
    The idea is that any team larger than this will have trouble with communication
    as the number of connections within this team grows very quickly. As we add more
    people, the amount of communication needed to keep everybody up to date grows
    as well, and sooner or later the team will be slowed down by its constant need
    for meetings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢管理应用程序目前只包含管理囚犯运输的功能，但随着我们应用程序的增长，组织代码的需求也在增加。能够同时在一款软件上工作的开发人员数量有限。亚马逊创始人兼首席执行官杰夫·贝索斯曾经说过，一个团队的规模不应该超过两个披萨所能满足的人数。这个想法是，任何比这更大的团队在沟通方面都会遇到麻烦，因为团队内部的联系数量会迅速增长。随着我们增加更多的人，保持每个人都了解最新情况所需的沟通量也会增加，团队迟早会因为不断需要开会而变慢。
- en: 'This fact causes somewhat of a dilemma because, as we described earlier, the
    perfect application would be one where everybody would know everything about how
    the development happened and how the decisions around the changes were made. This
    leaves us with very few options: we can either decide to not grow the team, building
    the application but opting for a slower development cycle that can be handled
    by this team alone (along with a smaller feature-set on the application as a whole),
    or alternatively we can try to make multiple teams work on the same application.
    Both strategies have been successful as far as business goes. Staying small and
    growing naturally, while most likely not resulting in hockey-stick growth can
    result in a well run and successful company as the likes of Basecamp Inc. and
    other independent software developers have proved. On the other hand, this does
    not work for applications that are inherently complex and aim for a much broader
    scope, so the likes of Amazon and Netflix, for example, started growing their
    teams around the idea of creating a larger application comprising of smaller parts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实造成了一种困境，因为正如我们之前所描述的，完美的应用程序应该是每个人都了解开发过程以及围绕变化做出决策的应用程序。这给我们留下了很少的选择：我们可以决定不扩大团队，构建应用程序，但选择一个更慢的开发周期，这个团队可以独立处理（以及整个应用程序上的较小功能集），或者我们可以尝试让多个团队共同开发同一个应用程序。这两种策略在商业上都取得了成功。保持小规模并自然增长，虽然可能不会导致爆发式增长，但可以导致一个运行良好且成功的公司，就像Basecamp
    Inc.和其他独立软件开发者所证明的那样。另一方面，这对于固有复杂性并且目标范围更广的应用程序来说是行不通的，因此亚马逊和Netflix等公司开始围绕创建由较小部分组成的更大应用程序的理念来扩大他们的团队。
- en: 'Assuming that we opt for the idea of domain-driven design, we more likely have
    an application that is part of the inherently complex realm, so the following
    chapter will introduce some common ways to handle this scenario. One important
    point not to miss when designing an application like this is that we should always
    strive to reduce complexity as far as possible. You will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择领域驱动设计的理念，我们更有可能拥有一个属于固有复杂领域的应用程序，因此接下来的章节将介绍处理这种情况的一些常见方法。在设计这样的应用程序时不容忽视的一个重要点是，我们应该始终努力尽可能减少复杂性。你将学到：
- en: How to organize a growing application technically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在技术上组织不断增长的应用程序
- en: How to test the integration of applications in a system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试系统中应用程序的集成
- en: How to organize expanding contexts in the application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织应用程序中不断扩展的上下文
- en: Don't fear the monolith
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要害怕单体应用
- en: In recent times, there has been a strong move toward breaking applications apart
    and designing them as a set of services communicating via messages. This is a
    well-established concept for large-scale applications; the problem is finding
    the correct time to break the application apart and also deciding whether breaking
    it apart is the right thing to do. When we break an application into multiple
    services, we increase the complexity at this point since we now have to deal with
    handling communication problems crossing multiple services. We have to consider
    the resilience of the services, and the dependencies each service has, to provide
    its features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 近来，人们开始更加倾向于将应用程序拆分并设计成一组通过消息进行通信的服务。这对于大规模应用程序来说是一个成熟的概念；问题在于找到正确的时间来拆分应用程序，以及决定是否拆分是正确的做法。当我们将一个应用程序拆分成多个服务时，这一点会增加复杂性，因为现在我们必须处理跨多个服务的通信问题。我们必须考虑服务的弹性以及每个服务提供其功能所需的依赖关系。
- en: On the other hand, when we break an application apart at a late stage, problems
    arise when extracting logic from the application. There is no reason why a monolith
    application can't be well-factored and remain easy to maintain for a long time.
    Breaking up an application will always cause problems, and staying with a well-factored
    application for a long time works. The problem is that a large codebase with a
    lot of developers working on it is more likely to deteriorate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们在后期拆分应用程序时，从应用程序中提取逻辑会出现问题。没有理由一个单体应用程序不能被很好地因素化，并且在很长一段时间内保持易于维护。拆分应用程序总会带来问题，而长期保持一个良好因素化的应用程序是可行的。问题在于，一个代码库庞大且有很多开发人员在上面工作的情况更容易恶化。
- en: How can we avoid such problems? The best way is to design the application in
    a way that breaks it up as simply as possible but keeps the problem of communication
    between sub-systems out of the picture for as long as possible. This is what a
    strong domain model excels at; the domain will allow us to have strong separation
    from the underlying frameworks, but also makes it clear where to break apart the
    application when we have to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免这样的问题？最好的方法是以尽可能简单的方式设计应用程序，但尽可能长时间地避免子系统之间的通信问题。这正是强大的领域模型擅长的；领域将使我们能够与底层框架强烈分离，但也清楚地指出了在必须分解应用程序时应该如何分解。
- en: In the domain model, we already established areas that can be separated out
    later because we designed them as separate parts. A good example is the prisoner
    transport, which is hidden behind an interface that can later be extracted. There
    can be a team working on just the prisoner transport feature, and as long as there
    is no change to the public interface exposed, their work can be done without worrying
    about other changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，我们已经确定了可以稍后分离的区域，因为我们将它们设计为单独的部分。一个很好的例子是囚犯运输，它被隐藏在一个接口后面，以后可以被提取出来。可以有一个团队专门负责囚犯运输功能，只要公共接口没有改变，他们的工作就可以进行，而不必担心其他改变。
- en: Going a step further, it does not matter where the actual logic is executed,
    from a purely logical perspective. The prisoner transfer might just be a façade
    that calls into a separate backend, or it might be run in a process. This is what
    a well-factored application is all about—it provides an interface sub-domain functionality
    and exposes it in an abstract enough way to make the underlying system easy to
    change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，从纯逻辑角度来看，实际逻辑执行的位置并不重要。囚犯转移可能只是一个调用单独后端的幌子，或者可能在一个进程中运行。这就是一个良好分解的应用程序的全部意义——它提供了一个接口子域功能，并以足够抽象的方式暴露出来，使底层系统易于更改。
- en: We only want to separate out a service if it is necessary, and if there is a
    clear benefit in doing so, reducing the complexity of deployment or development
    dependencies so the development of the process can be scaled, at best, along with
    a team to take care of the service moving forward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在必要的情况下，如果分离出一个服务，并且这样做有明显的好处，减少部署或开发依赖的复杂性，使流程的开发能够尽可能地扩展，最好是有一个团队来负责服务的进一步发展。
- en: Service-oriented architecture and microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构和微服务
- en: In the extreme form, a **service-oriented architecture** (**SOA**) ends in microservices;
    a concept where each service is only responsible for a very limited feature set,
    therefore with very few reasons to change and is easy to maintain. In terms of
    domain-driven design, this means that a service is established for each bounded
    context inside the application. The context can eventually be broken down to mean
    that each aggregate is managed by separate services. The service managing the
    aggregate can ensure the inner consistency, and the interface as a service means
    that the access points are very clearly defined. Most of the problems are shifted
    to the communication layer, which has to deal with the resilience. This can be
    a big challenge to the communication layer in the application, and also for the
    services themselves that now have to deal with more failure modes due to the communication
    failing between the dependents. Microservices have been used in some scenarios
    with great success, but the overall concept is still young and needs to prove
    itself in a wider range of use cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在极端情况下，**面向服务的架构**（**SOA**）最终会变成微服务；每个服务只负责非常有限的功能集，因此很少有改变的理由，易于维护。在领域驱动设计方面，这意味着为应用程序中的每个有界上下文建立一个服务。上下文最终可以被分解为每个聚合由单独的服务管理。管理聚合的服务可以确保内部一致性，服务作为接口意味着访问点非常清晰地定义。大部分问题都转移到了通信层，必须处理弹性。这可能是应用程序中通信层的一个重大挑战，也是服务本身的挑战，因为它们现在必须处理更多的故障模式，由于依赖方之间的通信失败。微服务在某些场景中取得了巨大成功，但整体概念仍然年轻，需要在更广泛的用例中证明自己。
- en: The micro-service architecture is more or less an extension of the actor model,
    only if the move to making the actors self-sufficient services is an extension
    to this. This increases the communication overhead for better isolation; in domain-driven
    design, this could mean constructing services around entities, as they are the
    managers around the life cycle of parts of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构或多或少是演员模型的延伸，只有当将演员变成自给自足的服务时，才是对此的延伸。这增加了更好隔离的通信开销；在领域驱动设计中，这可能意味着围绕实体构建服务，因为它们是应用程序部分生命周期的管理者。
- en: Overall, whatever architecture ends up being the one of choice, it is useful
    to think about how to prepare the application for being broken up later. Carefully
    crafting a flexible domain model and leveraging bounded contexts is the key to
    evolving application design in such a way. Even in the case where the application
    is never actually broken into pieces, having a clear separation makes each part
    easier to work with and the combined application less error-prone because of better
    understandable, and therefore simpler to modify, components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，无论最终选择哪种架构，都有必要考虑如何准备应用程序以便以后可以分解。精心打造灵活的领域模型并利用有界上下文是以这种方式发展应用程序设计的关键。即使应用程序从未真正分解成部分，有清晰的分离也使每个部分更容易处理，并且由于更易理解，因此更容易修改，组件组合应用程序更少出错。
- en: A key point there is to have the core domain well identified and it is best
    to have it isolated to evolve it from other pieces of the system. Not every piece
    of the software is always going to be well designed, but having a core domain
    and its sub-domains isolated and defined makes the application as a whole ready
    to evolve, as those are the core pieces of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于要很好地确定核心领域，并最好将其与系统的其他部分隔离开来进行演化。并不是软件的每一部分都会被很好地设计，但是将核心领域及其子域隔离和定义好，使得整个应用程序都准备好进行演化，因为它们是应用程序的核心部分。
- en: Keeping it all in your head
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些记在脑中
- en: Every time we open our editor of choice to work on code, there is a bit of overhead
    to know where to start and what section we actually need to modify. Understanding
    where to start a modification to move toward a certain goal is often the difference
    between an application that is a joy to work on and one nobody likes to touch.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们打开我们选择的编辑器来编写代码时，都需要一些开销来知道从哪里开始以及我们实际需要修改哪个部分。了解从哪里开始修改以朝着特定目标前进，通常是一个应用程序能否愉快地工作的关键区别，而不是一个没有人愿意碰的应用程序。
- en: When we start working on a piece of code, there is a maximum amount of context
    we can keep in our head any a given time. Even though it is not possible to give
    exact constraints, it is easy to notice when a certain part of the code exceeds
    this limit. It is often the point where refactoring gets harder, the test starts
    to become brittle, and unit tests seem to lose their value as their passing no
    longer ensures the functionality of the system. In the open source world, this
    is often a breaking point for a project and it is very visible due to its open
    nature. Either a library or application at this point proves valuable enough if
    people invest their time into really understanding the inner workings and continue
    to work towards making progress toward a more modular design, or the development
    stops. Enterprise applications suffer from the same fate, except that people are
    much more hesitant to give up on a project that provides a source of income or
    another important business aspect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理一段代码时，我们在任何给定时间内能够在脑海中保留的上下文量是有限的。尽管不可能给出确切的限制，但当代码的某个部分超出了这个限制时很容易注意到。这通常是重构变得更加困难的时候，测试开始变得脆弱，单元测试似乎失去了其价值，因为它们的通过不再确保系统功能。在开源世界中，这通常是项目的一个破坏点，并且由于其开放性质，这一点非常明显。在这一点上，一个库或应用程序如果能够让人们投入时间真正理解内部工作并继续朝着更模块化的设计取得进展，那么它就变得非常有价值，或者开发就会停止。企业应用程序也遭受同样的命运，只是人们更加不愿意放弃提供收入来源或其他重要业务方面的项目。
- en: When projects become complicated, often people fear any modifications and nobody
    really understands what is going on anymore. When the pain and the uncertainty
    starts to grow, it is important to recognize this and start to separate the contexts
    of the application to keep its size manageable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目变得复杂时，人们经常害怕进行任何修改，而且没有人真正理解发生了什么。当痛苦和不确定性开始增长时，重要的是要认识到这一点，并开始分离应用程序的上下文，以保持其规模可管理。
- en: Recognizing the contexts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别上下文
- en: 'As we have drawn out the application, we have been recognizing certain parts
    of the application and the way they communicate with each other. We can use this
    knowledge now to make sure we have an idea of what the context of the application
    could look like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制应用程序时，我们已经认识到应用程序的某些部分以及它们之间的通信方式。我们现在可以利用这些知识来确保我们对应用程序的上下文有一个概念：
- en: '![Recognizing the contexts](graphics/B03704_06_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![识别上下文](graphics/B03704_06_01.jpg)'
- en: In [Chapter 1](ch01.html "Chapter 1. A Typical JavaScript Project"), *A Typical
    JavaScript Project*, we had about six contexts in the realm with which we were
    dealing. With the understanding gained from recent chapters, this has changed
    a bit, but the basics are there. Those contexts are identified as the communication
    between them happens by exchanging messages and not by modifying the internal
    state. In a case where we are building an API, we can't rely on the fact that
    we are in a situation where the internal state can be modified, nor should there
    be a way to reach inside a context and modify its internals, as this is a very
    deep coupling between contexts that would obviate the usefulness of contexts in
    general.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。典型的JavaScript项目")中，*典型的JavaScript项目*，我们处理了领域中大约有六个上下文。通过最近章节所获得的理解，这有些变化，但基本原理仍在。这些上下文被确定为它们之间的通信是通过交换消息而不是修改内部状态来进行的。在构建API的情况下，我们不能依赖于我们处于可以修改内部状态的情况，也不应该有一种方法可以进入上下文并修改其内部，因为这是上下文之间非常紧密的耦合，这将使上下文的有用性变得不明显。
- en: Messages are the key foundation of an easy-to-model API; if we think in messages,
    it is easy to image breaking apart the application and the messages no longer
    being sent locally, but over a network. Of course, breaking up an application
    is still not easy because suddenly there is a lot more complexity to deal with,
    but having the ability to deal with the messaging is a big part of the complexity
    out of the way already.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是易于建模API的关键基础；如果我们以消息为思考方式，很容易想象拆分应用程序和消息不再在本地发送，而是通过网络发送。当然，拆分应用程序仍然不容易，因为突然之间需要处理更多的复杂性，但有能力处理消息传递是摆脱复杂性的一大部分。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The functional programming language **Erlang** takes this concept as far as
    possible. Erlang makes it easy to split applications apart into so-called processes,
    which are only able to communicate via messages being sent. This allows Erlang
    to relocate the processes to different machines and abstract away a whole slew
    of problems of multiprocessor machines, or multimachine systems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言** Erlang**将这个概念发挥到了极致。Erlang使得将应用程序拆分成所谓的进程变得容易，这些进程只能通过发送消息进行通信。这使得Erlang能够将进程重新定位到不同的机器上，并抽象出多处理器机器或多机系统的一系列问题。
- en: Having a well-defined API allows us to make refactoring changes inside the context
    without breaking the applications on the outside. The contexts become roles in
    our system that we can regard as black boxes, and we can model other parts with
    the knowledge they encapsulate abstracted out. Inside a context, an application
    is a coherent whole, and represents its data in an abstracted way to the outside.
    When we expose domains and sub-domains as interfaces, we generate the building
    blocks to a malleable system. When they need to share data, there is a clear way
    to do it, and the goal should always be to share underlying data and expose different
    views on this data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有明确定义的API使我们能够在不破坏外部应用程序的情况下对上下文内部进行重构更改。上下文成为我们系统中可以视为黑匣子的角色，并且我们可以使用它们封装的知识来建模其他部分。在上下文内部，应用程序是一个连贯的整体，并且以一种抽象的方式向外部表示其数据。当我们将域和子域公开为接口时，我们生成了一个可塑性系统的构建块。当它们需要共享数据时，有一种明确的方法可以做到这一点，目标应该始终是共享底层数据并在这些数据上公开不同的视图。
- en: Testing in contexts
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在上下文中测试
- en: As we identify the contexts we can regard as black boxes, we should start using
    this knowledge in our tests as well. We have already seen how mocking allows us
    to separate us based on different roles, and a context in this way is a perfect
    candidate for a role to mock during our unit testing. As we break our application
    into contexts, we can, of course, also start with different styles of testing
    in different contexts, making the development process evolve as our understanding
    and the application changes. When we do this, we need to keep in mind that the
    application as a whole needs to continue running, so the integration of the application
    needs to be tested as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确定可以视为黑匣子的上下文时，我们也应该在测试中使用这些知识。我们已经看到模拟允许我们根据不同的角色进行分离，而上下文在这种方式上是进行单元测试时的一个完美候选。当我们将应用程序分解为上下文时，当然也可以在不同的上下文中开始使用不同的测试风格，使开发过程随着我们的理解和应用程序的变化而发展。在这样做时，我们需要记住整个应用程序需要继续运行，因此还需要测试应用程序的集成。
- en: Integration across boundaries
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨边界的集成
- en: 'At the boundaries of contexts, there are multiple things we need to test from
    the view of the context developer:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文的边界处，从上下文开发者的角度，有多个需要测试的事情：
- en: Our side of the context needs to adhere to its contract, which means the API.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们这一方的上下文需要遵守其合同，也就是API。
- en: The integration of the two contexts needs to work, so cross-boundary tests need
    to be in place.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个上下文的集成需要正常工作，因此需要进行跨边界测试。
- en: 'For the first point, we can think of our tests as the consumers of the API.
    When we think about our messaging API for example, we want to have a test confirming
    that our API does what it promises. This is best served by an outside-in test
    covering the contract on the side of the context. Have a fictive `Notifier` that
    works as follows, as we previously used the notifier sending a message via the
    `message` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一点，我们可以将我们的测试视为API的使用者。例如，当我们考虑我们的消息API时，我们希望有一个测试来确认我们的API是否实现了它承诺的功能。这最好通过一个外部测试来覆盖上下文一侧的合同。假设有一个虚构的`Notifier`，它的工作方式如下，就像我们之前使用通知器通过`message`函数发送消息一样：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to test whether the backend is called in the correct way when the notifier
    is called with the public API:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用通知器时，我们需要测试后端是否以正确的方式被调用：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would not be an extensive test but the basic assertion is that the backend
    we are using, which the notifier abstracts us from, is called. To make this more
    valuable, we would also need to assert the correct way of calling, as well as
    the calling of the dependencies further down.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会是一个详尽的测试，但基本的断言是我们使用的后端是否被调用了。为了使其更有价值，我们还需要断言正确的调用方式，以及进一步调用依赖项。
- en: 'The second point requires an integration test to be set up to cover the interaction
    between the two or more contexts without the involvement of mocks or stubs. This
    of course means that the test will most likely be more complicated than a test
    allowing mocks and stubs to tightly control the environment, and therefore it
    is often limited to quite a simple test, to ensure that a basic interaction works.
    An integration test should not go into too much detail in this case, as this might
    ossify the API more than intended. The following code tests the integration of
    the prisoner transfer system in the system as a whole, using the different required
    subsystems like the dungeon as integration points:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要建立一个集成测试，以覆盖两个或更多上下文之间的交互，而不涉及模拟或存根。当然，这意味着测试很可能会比允许使用模拟和存根来严格控制环境的测试更复杂，因此通常限于相当简单的测试，以确保基本交互正常工作。在这种情况下，集成测试不应该过于详细，因为这可能比预期的更加僵化API。以下代码测试了系统中囚犯转移系统的集成，使用了地牢等不同的子系统作为集成点：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code shows how much more involved an end-to-end test ensuring
    a prisoner transfer can be. Due to this complexity, it only makes sense to test
    simple interactions as otherwise the end-to-end tests quickly become hard to maintain
    with small changes, and they should only cover the interactions on a higher level.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了确保囚犯转移的端到端测试可以涉及多么复杂。由于这种复杂性，只有测试简单交互才有意义，否则端到端测试很快就会随着小的变化而变得难以维护，并且它们应该只覆盖更高级别的交互。
- en: The goal of end-to-end or, integration tests across the boundaries of the system,
    is to ensure that the basic interactions work. The goal of unit tests is that
    the module in itself behaves as we want it to. This leaves a level open, which
    becomes obvious when running a service in production.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端或系统边界的集成测试的目标是确保基本交互正常工作。单元测试的目标是模块本身的行为符合我们的期望。这留下了一个开放的层次，在生产环境中运行服务时会变得明显。
- en: TDD and testing in production
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD和生产测试
- en: Test-driven development allows us to design a system that is easy to change
    and evolve; on the contrary, it does not ensure a perfect function of course.
    We first write a "broken" test, a test where the underlying functionality is still
    missing, and then write the code to satisfy it. We don't write tests to be perfectly
    safe from production bugs, because we can never anticipate all the possible complications
    that may arise. We write the tests to allow our system to be flexible and also
    to allow it to be ready for production in the sense that we can introspect its
    behavior and have the contexts reasonably well isolated to deal with failure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发使我们能够设计一个易于更改和发展的系统；相反，它并不能确保完美的功能。我们首先编写一个“有问题”的测试，一个测试，其中基本功能仍然缺失，然后编写代码来满足它。我们不会编写测试以完全避免生产错误，因为我们永远无法预料到可能出现的所有可能的复杂情况。我们编写测试是为了使我们的系统灵活，并且使其准备好投入生产，以便我们可以审视其行为，并且上下文相对独立，以处理故障。
- en: When moving code to production, we are exercising the system in a new way, and
    for this we need to be ready to monitor and introspect. This kind of introspection
    and monitoring also allows easy tests due to the injection of logging modules
    and others that allow simpler assertions of integration tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移至生产环境时，我们以一种新的方式来运行系统，为此我们需要准备好进行监视和审视。这种审视和监视也允许由于注入日志模块和其他模块而进行简单的集成测试断言。
- en: We have now seen how a system of contexts can help us create a more stable and
    easier to maintain system. In the following section, we are focusing on how to
    actually maintain the context within the application to fight the leaking of abstractions
    and leaking context across, and how this relates to different ways of organizing
    the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了上下文系统如何帮助我们创建一个更稳定、更易于维护的系统。在接下来的部分中，我们将重点关注如何在应用程序中实际维护上下文，以抵制抽象泄漏和上下文泄漏，并且这与组织应用程序的不同方式有关。
- en: The different ways to manage contexts
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理上下文的不同方式
- en: So far, the main purpose of the context in our application has been to separate
    different modules and make the complexity of the whole application more manageable
    by abstracting out APIs. The other important benefits of separate contexts are
    the fact that we can start to explore different ways of managing application development
    in those decoupled parts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用程序中上下文的主要目的是通过抽象API来分离不同的模块，并使整个应用程序的复杂性更易管理。分离上下文的另一个重要好处是，我们可以开始探索在这些解耦部分中管理应用程序开发的不同方式。
- en: The way applications are developed evolves as the industry around software evolves
    at a rapid pace. Development principles that were state of the art just a couple
    years ago are being frowned upon now and developers want to move to new ways of
    making them more productive while promising bug-free, easier to manage applications.
    Of course, switching out the development principles is not free, and more often
    than not new ways don't necessarily match the way complete organizations can,
    or want, to work. By separating out the contexts of the application, we can start
    exploring those new ways alongside the well-established ones and keep the team
    evolving and developing alongside the applications they maintain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的开发方式随着软件周围的行业快速发展而发展。几年前还是最先进的开发原则现在受到了指责，开发人员希望转向新的方式，使其更具生产力，同时承诺无错误，更易管理的应用程序。当然，更换开发原则并不是免费的，而且往往新的方式并不一定与完整组织的工作方式相匹配。通过分离应用程序的上下文，我们可以开始探索这些新的方式，同时保持团队与他们维护的应用程序一起发展和进步。
- en: The first step towards manageable contexts is drawing a map of their relationships
    and starting to make a clear separation, using the language we established. With
    this map, we can start to think of ways to divide the application and break it
    into different ways to enable maximum productivity within the team.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 管理上下文的第一步是绘制它们之间的关系地图，并开始清晰地分离，使用我们建立的语言。有了这张地图，我们可以开始考虑如何划分应用程序，并将其分解为不同的方式，以便在团队内实现最大的生产力。
- en: Drawing a context map
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制上下文地图
- en: 'The prisoner transport application that we have been following throughout the
    book so far involves multiple contexts. Each context can be abstracted by a clear
    API, and aggregates multiple collaborators to make the prisoner transport, as
    a whole, work. We can follow these collaborators in the integration test we have
    seen before, and draw out their relationship on a map for everybody on the project
    to keep in mind. The following diagram shows an outline of the different contexts
    involved in the prisoner transport, including their role:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在跟踪的囚犯运输应用程序涉及多个上下文。每个上下文都可以通过清晰的API进行抽象，并聚合多个合作者，以使囚犯运输作为一个整体运行。我们可以在之前看到的集成测试中跟踪这些合作者，并在项目中为每个人绘制出它们的关系地图。以下图表显示了囚犯运输中涉及的不同上下文的概述，包括它们的角色：
- en: '![Drawing a context map](graphics/B03704_06_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![绘制上下文地图](graphics/B03704_06_02.jpg)'
- en: 'The map, for now, involves four main contexts as we saw in the previous integration
    test:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，地图涉及四个主要上下文，正如我们在前面的集成测试中看到的：
- en: Prisoner management
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 囚犯管理
- en: The dungeons
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 地牢'
- en: The messaging system
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息系统
- en: The transports
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 运输'
- en: Each context is responsible for providing the collaborators needed to make an
    actual transport between the dungeons happen, and provided the API stays consistent,
    it can be replaced with a different implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个上下文负责提供所需的合作者，以使地牢之间的实际传输发生，并且只要API保持一致，就可以用不同的实现替换它。
- en: Investigation into the context shows differences that are going to increase
    as the application evolves, which means different strategies are needed to manage
    the contexts. There is the dungeon as the main entry point to the application,
    which manages most of the raw resources. The dungeon is going to be like the sun
    in the dungeon management solar system. It provides access to the resources, which
    can then be used to accomplish different tasks. Due to this, the dungeon is a
    shared core of the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对上下文的调查显示了随着应用程序的发展而增加的差异，这意味着需要不同的策略来管理上下文。地牢作为应用程序的主要入口点，管理大部分原始资源。地牢将成为地牢管理太阳系中的太阳。它提供对资源的访问，然后可以用来完成不同的任务。因此，地牢是应用程序的共享核心。
- en: On the other hand, there are different sub-domains that use the resources provided
    by the dungeon that gather around. The messaging system, for example, provides
    infrastructure to different systems, in a largely decoupled way to augment tasks
    as they are done by other systems. The prisoner transfer we have seen is one of
    the sub-domains tying those other sub-domains together. We use resources provided
    by the dungeon to build a prisoner transfer, and we use the decoupled messaging
    functionality to augment the transfer task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有不同的子域使用地牢提供的资源聚集在一起。例如，消息系统以一种大部分解耦的方式为不同的系统提供基础设施，以增强它们完成的任务。我们所看到的囚犯转移就是将这些其他子域联系在一起的一个子域。我们使用地牢提供的资源来构建囚犯转移，并使用解耦的消息功能来增强转移任务。
- en: Those three systems show how we have different contexts working together and
    providing resources to accomplish the tasks the system is to build. As we build
    them, we need to think about how those sub-domains should be related. Depending
    on the different types of subsystem that are being built, different forms of context
    relationships are useful and best support the development. One thing to keep in
    mind, so as long as the application is simple enough, is that most of those will
    add more overhead to the development than they add flexibility, as sharing aspects
    of the application will, by definition, become more complicated than it has been
    before.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个系统展示了我们如何让不同的上下文共同工作，并提供资源来完成系统要构建的任务。在构建它们时，我们需要考虑这些子域应该如何相关。根据正在构建的不同类型的子系统，不同形式的上下文关系是有用的，并且最好支持开发。需要记住的一件事是，只要应用程序足够简单，大多数情况下，这些都会给开发增加更多的开销，而不是增加灵活性，因为应用程序的共享方面将会变得比以前更复杂。
- en: The monolithic architecture
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体架构
- en: When starting out with development, the team developing the application is most
    likely small and the context of the application is in itself not large yet. At
    this stage, it most likely does not make sense to break out the contexts of the
    application domain, as those are still flexible and have not evolved enough to
    warrant a separate team to take care of them. Also, APIs at this stage are not
    stable enough to implement a solid abstraction, no matter how much planning has
    gone into the details beforehand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发时，开发应用程序的团队很可能很小，应用程序的上下文本身还不是很大。在这个阶段，将应用程序域的上下文分离出来可能没有意义，因为它们仍然是灵活的，还没有发展到需要一个单独的团队来管理它们的程度。此外，在这个阶段，API还不够稳定，无论事先进行了多少规划，都无法实现一个坚实的抽象。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Martin Fowler has been talking about this as well and he recommends a strategy
    of building a monolith first and breaking it up as needed. You can find more on
    this on his blog at [http://martinfowler.com/bliki/MonolithFirst.html](http://martinfowler.com/bliki/MonolithFirst.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler也在谈论这个问题，并建议首先构建一个单体，然后根据需要将其拆分。您可以在他的博客上找到更多信息[http://martinfowler.com/bliki/MonolithFirst.html](http://martinfowler.com/bliki/MonolithFirst.html)。
- en: At this stage, application development will progress best using a monolithic
    architecture that provides shared access to the models. This does not mean, of
    course, that everything should be one big pile of code, but especially in a monolith
    it is easy to break out objects as everybody has access to them anyway. This will
    make it easier to break apart the application afterwards as borders tend to evolve
    during development.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，应用程序开发将最好使用提供对模型的共享访问的单体架构。当然，这并不意味着一切都应该是一大堆代码，但特别是在单体中，很容易将对象拆分出来，因为每个人都可以访问它们。这将使以后拆分应用程序变得更容易，因为边界在开发过程中往往会发展。
- en: 'This is also the way we have been developing the application so far; even though
    we recognize that there are contexts, those contexts don''t necessarily mean separation
    into different applications or domains, but for now they are a map in the developer''s
    mind to guide the location of the code as well as the flow of interactions. Taking
    a look at the prisoner transport, it can look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们迄今为止开发应用程序的方式；即使我们认识到存在上下文，这些上下文不一定意味着分离成不同的应用程序或领域，但目前它们是开发者头脑中的地图，用于指导代码的位置和交互的流程。看看囚犯转移，它可能看起来像这样：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Right now, the code accesses each part of the application directly. Even though
    the communication is wrapped into an object that controls the flow, the prisoner
    transfer has a lot of interaction happening, which will need to be accessed over
    the network if the application is broken apart. This kind of organization is typical
    for a monolithic application and will change when it is broken into different
    pieces, but the overall contexts will remain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码直接访问应用程序的每个部分。即使通信被包装成控制流的对象，囚犯转移中发生了大量的交互，如果应用程序被拆分，这些交互将需要通过网络访问。这种组织形式对于单体应用程序是典型的，当它被分解成不同的部分时会发生变化，但整体上下文将保持不变。
- en: A shared kernel
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内核
- en: We have already seen that the dungeon is like the sun in our orc dungeon management
    universe, so it only makes sense to share its functionality across the applications
    that interact with it in some way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，地牢就像我们的兽人地牢管理宇宙中的太阳，因此将其功能跨应用程序共享是有意义的。
- en: This kind of development is a **shared kernel**. The dungeon itself provides
    functionality that will need to be replicated in many different places unless
    it is shared in some way, and since the functionality is such a crucial part,
    it does not go well with a slow interface that is part of a supply chain, for
    example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发方式是一种**共享内核**。地牢本身提供的功能需要在许多不同的地方进行复制，除非以某种方式进行共享，而且由于功能是如此关键的一部分，它与供应链的慢接口并不相容，例如。
- en: 'The dungeon provides many useful interfaces for the different parts that use
    it, so the functionality needs to be developed in tandem with the consumers. Going
    back to the prisoner transport, the code will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 地牢为使用它的不同部分提供了许多有用的接口，因此功能需要与使用者一起开发。回到囚犯运输，代码将如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we used a common pattern, which uses an `init` method
    to encapsulate some logic needed to initialize the dungeon. This is often useful
    to make the creation easy to use from the outside, and instead of handling it
    in a complex constructor, we move it out to a separate factory method. The advantage
    is that the return of a simple method is easier to handle than using a complex
    constructor, as a failing constructor might end in a half-initialized object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个常见的模式，它使用`init`方法来封装一些初始化地牢所需的逻辑。这通常对于使外部创建变得容易很有用，而不是在复杂的构造函数中处理它，我们将其移到一个单独的工厂方法中。优点是，简单方法的返回值比使用复杂构造函数更容易处理，因为失败的构造函数可能会导致一个半初始化的对象。
- en: The important point in this is that the dungeon now supports a specific endpoint
    to provide the resources needed for the transfer to happen. This would most likely
    lock the given resources and initialize a transaction for them so they don't get
    reused without their reuse being possible in the physical world.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要一点是，地牢现在支持一个特定的端点，以提供转移所需的资源。这很可能会锁定给定的资源并为其初始化一个事务，以便它们在物理世界中不会被重复使用。
- en: 'Due to our shared kernel nature, this change can happen in the prisoner transfer
    and the dungeon part of the application in tandem. The shared kernel is, of course,
    not without problems, as it creates strong coupling between the parts. It is always
    useful to keep this in mind and think twice about whether pieces are really needed
    in the shared kernel or whether they belong in another part of the application.
    Shared data does not mean there is a reason to share code. The view of what a
    prisoner transfer is can be different throughout the application: while the transfer
    itself might care more about details, the messaging service sharing the data of
    the transfer to create a message to send cares only about the target and the source,
    as well as the prisoners involved in the transfer. So sharing code between the
    two contexts would confuse each domain with unnecessary and unrelated knowledge.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的共享内核特性，这种变化可以同时发生在囚犯转移和应用程序的地牢部分。共享内核当然并非没有问题，因为它在部分之间创建了强耦合。牢记这一点并仔细考虑，是否真的需要在共享内核中使用这些部分，或者它们是否属于应用程序的另一部分，这总是有用的。共享数据并不意味着有理由共享代码。对于应用程序中囚犯转移的视图可能会有所不同：虽然转移本身可能更关心细节，但消息服务共享转移数据以创建要发送的消息只关心目标和来源，以及参与转移的囚犯。因此，在两个上下文之间共享代码会使每个领域混淆不必要和无关的知识。
- en: The architecture of a shared context like this means that the teams working
    inside the shared context must work closely together, and that this part of the
    application has to be vigorously refactored and reviewed so it does not get out
    of hand. It is a straight evolution of the monolith, so to speak, but it takes
    the application a step further towards being split into multiple ones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的共享上下文架构意味着在共享上下文内工作的团队必须紧密合作，这部分应用程序必须进行大力重构和审查，以免失控。可以说，这是单体架构的直接演变，但它使应用程序更进一步地分割成多个部分。
- en: For many applications, splitting out some basic elements with a lot of churn
    is enough, and the application can evolve much more quickly using a shared kernel
    where the development team coordinates. This of course forces the team to trust
    each others decisions in general and the communication overhead between the engineers
    can grow with the shared kernel, evolving at this point, the application has solidified
    to a stage where teams can take over the responsibilities for application parts,
    rolling them in their own.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序来说，将一些基本元素分离出来并进行大量变更就足够了，应用程序可以通过共享内核更快地演进，开发团队进行协调。当然，这迫使团队在一般情况下信任彼此的决定，并且工程师之间的沟通开销可能会随着共享内核的演变而增加，此时应用程序已经稳定到一个阶段，团队可以接管应用程序部分的责任，并将其整合到自己的部分中。
- en: The APIs
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: Building distinct applications requires a set of APIs that can be relied upon.
    With APIs like this, it is possible to extract certain sub-domains from the main
    domain and application, which can start to evolve completely separately to the
    main application as long as they continue to conform to the same API as before.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建不同的应用程序需要一组可靠的API。有了这样的API，可以从主域和应用程序中提取某些子域，这些子域可以开始完全独立于主应用程序演进，只要它们继续遵守之前的相同API。
- en: It is important to identify a sub-domain first to allow it to have a clean API
    layer to build upon. Looking at the context map will show the interactions of
    the sub-domains, and those interactions are what an API model should be based
    on. Starting out by building in a more monolithic way and breaking out pieces
    as they are solidified in their sub-domain will lead towards this naturally.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要识别一个子域，以便为其提供一个清晰的API层来构建。查看上下文映射将显示子域的交互，而这些交互是API模型应该基于的。首先以更单片式的方式构建，然后在其子域中巩固时分解出部分，将自然地朝着这个方向发展。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Conforming to the same API as before is often only regarded as taking the same
    input and producing the same output, there is more to it so to provide a drop-in
    replacement. New applications need to provide similar guarantees towards response
    time and other service levels, such as data persistence for example. A drop-in
    replacement is easier said than done in most cases, but evolving an application
    toward better service levels is often easier in isolation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前相同的API一致通常只被视为接受相同的输入并产生相同的输出，但实际上还有更多内容，以便提供一个可替换的组件。新应用程序需要提供类似的保证，以确保响应时间和其他服务水平，例如数据持久性。在大多数情况下，实现一个可替换的组件并不像表面上那么容易，但将应用程序发展到更好的服务水平通常在孤立环境中更容易。
- en: As we develop the application, we are now free to branch off while staying true
    to the mission of the application. We are providing a service to other applications
    who need to conform to our way of doing things but only up to the call of the
    application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发应用程序，我们现在可以自由地分支出去，同时保持对应用程序使命的忠诚。我们为其他需要遵循我们做事方式的应用程序提供服务，但仅限于应用程序的调用。
- en: The customer and the supplier
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顾客和供应商
- en: An application that provides a service is a supplier of a certain service. We
    can think of the messaging system as such a service. It provides other applications
    with an entry point to send messages across certain end points. Those end points
    need to provide the necessary calls if they want to receive messages while the
    messaging system takes care of the delivery of the message. An application using
    the messaging system needs to call into the system in a certain way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提供服务的应用程序是某种服务的供应商。我们可以将消息系统视为这样的服务。它为其他应用程序提供了一个发送消息到特定端点的入口点。如果它们想要接收消息，这些端点需要提供必要的调用，而消息系统则负责传递消息。使用消息系统的应用程序需要以某种方式调用系统。
- en: Such a way of interaction is very abstract, and a good application like this
    does not provide many endpoints but very high-level entry points to the system
    in general to make the use as easy as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种互动方式非常抽象，而且像这样的一个好应用程序并不提供很多端点，而是提供了非常高级的入口点，以便尽可能地使使用变得容易。
- en: Developing a client
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发客户端
- en: 'Using an internal application like this can be done in multiple ways. The interface
    can be very simple, for example, a very basic call over HTTP like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用内部应用程序可以有多种方式。接口可以非常简单，例如，像这样通过HTTP进行非常基本的调用：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A call like this does not need a separate client for most languages as it is
    very easy to interact with and will be bundled in to the customer application
    in whatever way is deemed best.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的调用对大多数语言来说并不需要单独的客户端，因为它非常容易进行交互，并且将被捆绑到客户应用程序中，以任何被认为最佳的方式。
- en: Not every application can provide such an easy interface of course, so at this
    stage there is the need to provide a client, which at best is shared between the
    different customers of the application, to not duplicate work. This can be provided
    either by the developing application in the case of complex clients or can be
    initiated by one of the customer applications and then shared in the same style
    as a shared kernel. While in most bigger systems it seems that the client is more
    often than not provided by the application development team, this is not necessarily
    the best way as they are not always aware of the intricacies that using their
    application involves, and therefore invite wrapping clients for each consumer
    to evolve alongside the internal client.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个应用程序都能提供如此简单的接口，因此在这个阶段需要提供一个客户端，最好是在应用程序的不同客户之间共享，以避免重复工作。这可以由开发应用程序提供，例如在复杂客户端的情况下，也可以由其中一个客户应用程序发起，然后以与共享内核相同的方式共享。在大多数更大的系统中，客户端往往是由应用程序开发团队提供的，但这并不一定是最好的方式，因为他们并不总是了解使用他们应用程序的复杂性，因此邀请每个消费者的封装客户端与内部客户端一起发展可能更好。
- en: The conformist
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 墨守成规
- en: The split of an application into an API supplier and consumer is a very distinct
    split and, even with the provided clients, it means that the application now consists
    of multiple parts that are no longer developed as a unit. This kind of split is
    often suggested to increase the speed of development as the team can be smaller
    and there is no longer such a strong communication needed. However, this comes
    at a price when the two separate applications need to work together to provide
    new features.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分割为API供应商和消费者是一个非常明显的分割，即使有提供的客户端，这意味着应用程序现在由多个部分组成，不再作为一个单元进行开发。这种分割通常被认为可以增加开发速度，因为团队可以更小，不再需要如此强烈的沟通。然而，当两个独立的应用程序需要共同提供新功能时，这是需要付出代价的。
- en: When we need to communicate across borders, it is expensive, not only in terms
    of networking and method call speed, but in terms of team communication overall.
    The teams providing different parts of the application are not set up to work
    with each other and the time it takes to set this structure up is an overhead
    we have to pay for every time a feature is developed in collaboration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要跨界通信时，这是昂贵的，不仅在网络和方法调用速度方面，而且在整体团队沟通方面也是如此。提供应用程序不同部分的团队并不是为了相互合作而设立的，建立这种结构所需的时间是我们每次开发合作功能时都要付出的额外开销。
- en: '|   | *Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations…* |  
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| | *设计系统的组织...受限于产生与这些组织沟通结构相同的设计...* | |'
- en: '|   | --*M. Conway* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| | --*M. 康威* |'
- en: This kind of development is kind of the inverse effect of *Conway's law*, because
    as organizations will produce systems constrained by their structure, forcing
    different structures will inadvertently slow down the team as it is not fit to
    develop such an application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种发展是康威定律的一种反向效应，因为组织将会产生受其结构限制的系统，强制使用不同的结构将无意中减慢团队的速度，因为它不适合开发这样的应用程序。
- en: 'When confronted with an increasing application, we need to make a choice: we
    can either decide to break up the application or deal with the result of growing
    pains. Dealing with the pains of a legacy application and just conforming to the
    development route it took can be a good choice depending on where the overall
    system is supposed to go. If, for example, the application is in maintenance mode
    for some time and it is unlikely that it will gain features any time soon, deciding
    to just continue on this route, even if the model is not perfect and the code
    base seems legacy, might well be the best choice.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对一个不断增长的应用程序时，我们需要做出选择：我们可以决定拆分应用程序，或者处理增长痛苦的结果。处理遗留应用程序的痛苦，并且只是顺应其发展路线，根据整体系统的预期走向，这可能是一个不错的选择。例如，如果应用程序在一段时间内处于维护模式，并且不太可能很快增加功能，决定继续这条路线，即使模型不完美，代码库看起来遗留，可能是最好的选择。
- en: Being a conformist is the unpopular choice, but it follows the suit of "never
    do a rewrite" and, after all, it is more rewarding to work on an application that
    is actually useful than on one that might be nicely engineered but does not provide
    value and is therefore neglected sooner or later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 成为顺从者是不受欢迎的选择，但它遵循“永远不要重写”的规则，毕竟，开发一个实际有用的应用程序比开发一个可能工程精良但没有价值并因此迟早被忽视的应用程序更有意义。
- en: The anticorruption layer
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反腐层
- en: There is a certain point in the application's life where just adding more features
    and conforming to the already present design is not productive anymore. At this
    stage, it makes sense to split from the main application and start to break out
    of the cycle of ever increasing complexity in the software. At this stage, it
    is a good idea to reform the domain language as well and see where the legacy
    codebase fits into the model, as this allows you to create solid abstractions
    and design a nice API on top of it. This kind of development provides a façade
    over the code, and by this, we mean providing a layer to shield the application
    from old terms and problems that might leak in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中，有一个特定的阶段，只是添加更多功能并顺应已有设计不再具有生产力。在这个阶段，从主应用程序中分离出来并开始摆脱软件中不断增加的复杂性很有意义。在这个阶段，重新构建领域语言也是一个好主意，并且看看遗留代码库如何适应模型，因为这可以让您创建坚实的抽象，并在其上设计一个良好的API。这种开发提供了对代码的外观，我们指的是提供一个层来保护应用程序免受可能泄漏进来的旧术语和问题的影响。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The anticorruption layer is a very important pattern when it comes to improving
    applications that are already in production. Isolating a new feature makes it
    easier not only to test , but also can increase reliability and ease the introduction
    of new patterns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 反腐层是在改进已经投入生产的应用程序时非常重要的模式。隔离新功能不仅更容易测试，还可以增加可靠性，并且可以更容易地引入新模式。
- en: Isolating the methodologies
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离方法论
- en: As we build a layer like this, we are all about isolating us from the underlying
    technology; this of course means that we should also isolate ourselves from the
    ways of building software present below, and we can start using all the new ways
    developed since the original application was started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这样的层时，我们完全隔离自己不受底层技术的影响；当然，这意味着我们也应该隔离自己不受下面的软件构建方式的影响，并且可以开始使用自原应用程序开始以来开发的所有新方式。
- en: This has one very bad side-effect, which is that the old application instantly
    becomes the legacy not many people want to work on anymore and much blame might
    be thrown toward it. Make sure such a strong split is necessary for this reason.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个非常不好的副作用，即旧应用程序立即成为不多人愿意再去工作的遗留应用程序，而且可能会受到很多责备。确保出于这个原因有必要进行如此强烈的分割。
- en: An anticorruption layer might also make sense in the case where an outside application
    is integrated into the system, for example, credit card processing by an outside
    banking system. External dependencies are best served when isolated from the core
    application, and be it just for the fact that the external API can change and
    adjusting all callers is most likely more complicated then adjusting the internal
    abstraction. This is exactly what an anticorruption layer is good at, so soon
    your internal dependencies are best treated like external ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 反腐层在集成外部应用程序进入系统的情况下也可能是有意义的，例如，外部银行系统的信用卡处理。最好将外部依赖项与核心应用程序隔离开来，即使只是因为外部API可能会发生变化，调整所有调用者很可能比调整内部抽象更复杂。这正是反腐层擅长的，因此很快你的内部依赖项最好像外部依赖项一样处理。
- en: Separate ways
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分道扬镳
- en: Similar to an anticorruption layer, in a more separate way, tries to solve the
    problem of an application growing apart in the domain. As we develop a common
    language across the system and are breaking the application apart, the language
    will become more refined for some models and the models will increase in complexity
    in certain applications, but not necessarily in others. This can lead to problems
    where a shared core is used because this core needs to incorporate the maximum
    complexity required by each sub-domain and therefore continues to grow while we
    would rather keep it small.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于反腐层，以更分离的方式，试图解决应用程序在域中分离的问题。当我们在系统中开发一个共同的语言并将应用程序拆分时，语言将变得更加精细，某些模型的复杂性将增加在某些应用程序中，但不一定在其他应用程序中。这可能会导致问题，因为共享的核心被使用，因为这个核心需要合并每个子域所需的最大复杂性，因此在我们宁愿保持它小的同时继续增长。
- en: The problem is deciding when a certain application needs to be split at the
    domain model level because the increased complexity for one part does not enhance
    another parts' usability anymore. In our application, the likely candidate is
    the dungeon model that is shared across the other applications. We want to keep
    it as small as possible, but parts of the application will have different demands
    on it. The messaging subsystem will have to focus on the delivery of messages
    to the dungeon and increase the complexity of this part, while the system to handle
    prisoner transport prerequisites will care about other resource management parts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于何时决定某个应用程序需要在域模型层面进行拆分，因为对于一个部分的增加复杂性不再增强另一个部分的可用性。在我们的应用程序中，可能的候选者是共享在其他应用程序中的地牢模型。我们希望尽可能地保持它小，但应用程序的部分将对它有不同的需求。消息子系统将需要专注于将消息传递给地牢并增加这部分的复杂性，而处理囚犯运输前提条件的系统将关心其他资源管理部分。
- en: Unrelated applications
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无关的应用程序
- en: With different applications having such different requirements towards the core
    domain, it can make sense not share the model but build a specific one for the
    applications that need it, sharing only a datastore or some other means to share
    the state. The goal is to reduce dependencies and this can mean only sharing what
    actually needs to be shared, even if the names might suggest otherwise. When sharing
    a data store, it is important to keep in mind that only the sub-domain that owns
    the data should be able to modify it, while all others should be using an API
    to access the data, or only have read-only access. It comes down to whether the
    overhead of an API is sustainable, or whether direct integration is needed for
    performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的应用程序对核心域有如此不同的要求，因此不共享模型而为需要它的应用程序构建一个特定的模型是有意义的，只共享数据存储或其他一些共享状态的手段。目标是减少依赖关系，这可能意味着只共享实际需要共享的内容，即使名称可能暗示相反。在共享数据存储时，重要的是要记住，只有拥有数据的子域应该能够修改它，而其他所有子域应该使用API来访问数据，或者只有只读访问权限。这取决于API的开销是否可持续，或者是否需要直接集成以提高性能。
- en: When applications start using models in different ways and the only reason they
    share a model is the fact that the model is named the same, we can start to look
    for more specific names that are fit for purpose, and at some point we can even
    get rid of the primary model completely. In our dungeon example, the case may
    be that, over time, the dungeon itself gets reduced to only being the entry point
    of the application, acting as a router to the managing sub-domain applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开始以不同的方式使用模型，而它们共享模型的唯一原因是模型的名称相同时，我们可以开始寻找更适合目的的更具体的名称，甚至在某个时候完全摆脱主要模型。在我们的地牢示例中，情况可能是，随着时间的推移，地牢本身只能被减少到只作为应用程序的入口点，充当管理子域应用程序的路由器。
- en: Moving more functionality outside the initially shared context of the application
    into other contexts means that we reduce the surface of our shared sub-domain,
    and that we misidentified the role of this domain in the beginning. This is nothing
    bad since every application should be built to evolve, and as contexts become
    more clear, this can in turn clarify the sub-domain borders that were previously
    unclear.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将更多功能移出应用程序最初共享的上下文，意味着我们减少了共享子域的表面，并且最初误解了这个域的角色。这并不是坏事，因为每个应用程序都应该被建立为进化，随着上下文变得更加清晰，这反过来可以澄清先前不清晰的子域边界。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't get too attached to your understanding of the borders of domains and sub-domains.
    As gaining experience from business experts can improve your understanding of
    a sub-domain, so can the refining of a bounded context in turn influence the domain.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于执着于你对域和子域边界的理解。从业务专家那里获得经验可以改善你对子域的理解，因此有界上下文的精炼反过来会影响域。
- en: An open protocol
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个开放的协议
- en: The last step in making applications truly independent is publishing them as
    an open protocol. The point is to make the core functionality of the application
    accessible openly from the outside as a published standard. This is very seldom
    the case as it requires a lot of maintenance and setup initially. The best candidates
    for an open protocol are special communication layers used to communicate with
    the application to allow external clients.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序真正独立的最后一步是将它们发布为开放协议。关键是使应用程序的核心功能从外部公开访问，作为一个公开的标准。这很少是情况，因为它需要大量的维护和初始设置。开放协议的最佳候选者是用于与应用程序通信的特殊通信层，以允许外部客户端。
- en: The API of an application can be considered an open protocol when it invites
    in external users, and maybe even external clients. In our dungeon applications
    we might, at some point, want to make the messaging subsystem an open protocol
    to allow other dungeons to plug in via their own local applications, and therefore
    establishing the standard in the Dungeon Management™.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序邀请外部用户，甚至可能是外部客户端时，应用程序的API可以被视为一个开放协议。在我们的地牢应用程序中，我们可能希望将消息子系统在某个时候变成一个开放协议，以允许其他地牢通过它们自己的本地应用程序插入，并因此在Dungeon
    Management™中建立标准。
- en: As this stage, when thinking about the Open Protocols, what we need to focus
    on is the fact of how we can share knowledge of the protocol in an effective way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，当考虑到开放协议时，我们需要关注的是如何有效地分享协议的知识。
- en: Sharing knowledge
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享知识
- en: We split the application apart into multiple sub-applications of the sub-domains,
    we do this to increase the size of the team and enable better cooperation between
    them. This also means that the team needs to find a way to share the information
    about the application and their usage with new developers as well as with developers
    tapping into the sub-domain to accomplish a certain goal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序拆分为多个子域的子应用程序，我们这样做是为了增加团队的规模，并促进它们之间更好的合作。这也意味着团队需要找到一种方式来与新开发人员分享关于应用程序及其使用的信息，以及与进入子域以实现特定目标的开发人员分享信息。
- en: The domain language is an important part of our design and we invested some
    time into building it throughout the development so far. We can draw on this and
    make this language available for other developers. The language, as we have seen
    it, slightly adjusts for each module and is a working document that needs to be
    kept up to date, and that means we need to find a way to keep it published.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 领域语言是我们设计的重要部分，我们已经花了一些时间来构建它。我们可以利用这一点，使这种语言对其他开发人员可用。正如我们所看到的，每个模块的语言都略有调整，是一个需要保持更新的工作文档，这意味着我们需要找到一种方式来保持其发布。
- en: The publishing language
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布语言
- en: The language we have been developing is an ever-evolving document, and as such
    we have to think about how to share the knowledge embedded in it. Again let's
    first define what we would do in a perfect world and see how we can approximate
    this situation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在开发的语言是一个不断发展的文档，因此我们必须考虑如何分享其中蕴含的知识。让我们首先定义在一个完美的世界里我们会做什么，然后看看我们如何可以接近这种情况。
- en: In a perfect world, the team that started out developing the application would
    stay together for the whole lifetime of the application and continue to grow,
    but the core developers would always be there. A team like this would have the
    major advantage of the terminology and the assumptions of the project being shared
    by the team as they have been following the application through its life, and
    new developers would join and learn from the core team by osmosis, so to speak.
    They would slowly adapt to the team and follow the rules, breaking them if necessary,
    and if agreed upon via the consensus of the team.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界里，开始开发应用程序的团队会一直保持在一起，直到应用程序的整个生命周期，并继续成长，但核心开发人员会一直在那里。这样的团队会有一个重大优势，即项目的术语和假设被团队共享，因为他们一直在应用程序的整个生命周期中跟踪，并且新的开发人员会加入并通过渗透学习核心团队。他们会慢慢适应团队并遵循规则，必要时打破规则，如果团队一致同意的话。
- en: We don't live in a perfect world though, and teams are likely to have some churn
    where core developers leave for whatever reason and are replaced with new faces.
    When this happens, there is the risk that the core principles of the application
    can could be lost, that the language around the project does not follow the original
    rules more, and many other bad things. Luckily, compared to olden times, we don't
    have to rely on word of mouth but can document our findings for others to find.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不生活在一个完美的世界，团队可能会有一些变动，核心开发人员因某种原因离开，并被新面孔取代。当这种情况发生时，应用程序的核心原则可能会丢失，围绕项目的语言可能不再遵循最初的规则，以及许多其他不好的事情。幸运的是，与古代相比，我们不必依赖口口相传，而是可以为他人记录我们的发现。
- en: Creating the documentation
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文档
- en: Documentation is often not the favorite part of software development, but this
    comes from the fact that a lot of documentation is not useful in many projects.
    When we create documentation, the important thing is to not state the obvious
    but to actually document the problems and ideas arising during development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文档通常不是软件开发中最受欢迎的部分，但这是因为许多项目中的文档并不实用。当我们创建文档时，重要的是不要陈述显而易见的事实，而是实际上记录在开发过程中出现的问题和想法。
- en: Often, the documentation found on projects is the outline of the methods, what
    parameters they take in, and what they return. This is a good start but not not
    the end of all documentation necessary. When different people are using the project
    they need to understand the intention behind it to use the API properly. When
    we create an application and decide on what kind of features we want and how they
    work, this is important to document. So far in this book, we have been focusing
    a lot on how to think about application development and also how to make sure
    it is in an understandable form for others to follow. All this is documentation
    that needs to be kept around. We want to be sure that the next person can follow
    the thinking that went into the development, knows what the terms mean, and how
    they relate to each other.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目中找到的文档是方法的概要，它们接受什么参数，以及它们返回什么。这是一个很好的开始，但并不是所有必要的文档的结束。当不同的人使用项目时，他们需要理解其背后的意图以正确使用API。当我们创建一个应用程序并决定我们想要什么样的功能以及它们如何工作时，这是重要的文档。到目前为止，在这本书中，我们一直在专注于如何思考应用程序开发，以及如何确保它以一种可理解的形式供他人遵循。所有这些都是需要保留的文档。我们希望确保下一个人能够理解开发过程中的思维，知道术语的含义以及它们之间的关系。
- en: A good way to start is to keep a central document where this kind of information
    lives close to the application and is accessible to everybody interested. Making
    the document as short as possible and having a way to see it evolve along with
    the project is key, so having some kind of versioning is a very useful feature.
    Going back in time in source code is very common to find out how a certain piece
    of code has changed, and being able to relate the right piece of documentation
    to it is very helpful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开始是保持一个中心文档，其中包含这种信息，靠近应用程序并且对所有感兴趣的人都可访问。使文档尽可能简短，并且有一种方式可以随着项目的发展而看到它的演变是关键的，因此具有某种版本控制是一个非常有用的功能。回溯源代码中的时间是非常常见的，以找出某段代码是如何改变的，能够将正确的文档与之相关联是非常有帮助的。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keeping a simple text file as the README for the project is a good place to
    start. This README can live inside the application repository, making the relationship
    between documentation and application a very strong one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个简单的文本文件作为项目的README是一个很好的开始。这个README可以存在于应用程序存储库中，使文档和应用程序之间的关系非常紧密。
- en: 'In the following we see this by the example of the canned fake API server,
    available at [https://github.com/sideshowcoder/canned](https://github.com/sideshowcoder/canned):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们通过一个罐头假API服务器的示例来看这一点，可在[https://github.com/sideshowcoder/canned](https://github.com/sideshowcoder/canned)找到：
- en: '![Creating the documentation](graphics/B03704_06_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建文档](graphics/B03704_06_03.jpg)'
- en: 'The important points for documentation are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的重要点是：
- en: The goal of the project in a short statement
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目目标的简短陈述
- en: The design ideas followed throughout the project to guide new developers
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贯穿整个项目的设计理念，以指导新开发人员。
- en: Example usages of features
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能的示例用法
- en: Implementation notes for very important pieces of code
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常重要的代码实现说明
- en: The change history of major changes
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要变更的更改历史
- en: The setup instructions
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置说明
- en: Updating the documentation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新文档
- en: Keeping the documentation close to the application has some essential advantages;
    it is just way too easy to neglect some document off in a wiki somewhere that
    needs special permissions to access, while looking at something every day when
    working on a project will more likely be kept up-to-date.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档保持在应用程序附近具有一些重要的优势；在某个需要特殊权限访问的wiki中忽视一些文档太容易了，而在项目上工作时每天查看某些东西更可能保持最新。
- en: Documentation is a living and breathing piece of the overall project and it
    therefore needs to be part of the project itself. Especially in the modern, open
    source inspired development world, the idea that everybody should be able to contribute
    to a project quickly is ingrained in the developer culture and this is a good
    thing. Code speaks louder than a thousand architecture specs, so to speak, and
    therefore limiting the documentation to the core design ideas while letting the
    code explain the specific implementation makes the documentation more useful in
    the long run and keeps developers engaged in the updating process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是整个项目的一个活生生的部分，因此它需要成为项目本身的一部分。特别是在现代、开源激发的开发世界中，每个人都应该能够快速地为项目做出贡献的想法已经根植于开发者文化中，这是一件好事。代码比千言万语的架构规范更有说服力，因此将文档限制在核心设计理念，同时让代码解释具体实现，使文档在长期内更有用，并保持开发人员参与更新过程。
- en: Tests are not the only documentation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试不是唯一的文档
- en: 'One side note about tests: often TDD is stated as having the benefit of providing
    tests as part of the documentation, as they are the examples on how to use the
    code after all. This is often an excuse to not bother to write up any examples
    outside this and also to not document the overall design since reading the tests
    states the design.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试的一个侧面说明：通常TDD被认为具有提供测试作为文档的好处，因为它们毕竟是如何使用代码的示例。这经常成为不费力地在外部编写任何示例和不记录整体设计的借口，因为阅读测试可以说明设计。
- en: The problem with this approach is that for the tests, all methods are equally
    important. It is very hard to convey an auxiliary decision made because it did
    not seem to have an impact at this moment from a core design idea of the project.
    This makes refactoring hard and is prone to side-track the project and maintain
    features that were never intended to be any in the beginning. For a developer
    coming into a project, the documentation should specify what the core functionality
    is, and if he or she finds a use for some obscure function outside this core,
    this is great and a good place for reading the tests, but there is a way to distinguish
    a feature that has support from the main application versus an auxiliary one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于对于测试来说，所有方法都同等重要。很难传达一个辅助决策，因为它似乎在这一刻没有影响，从项目的核心设计理念来看，这使得重构变得困难，并且容易使项目偏离轨道并维护从未打算在一开始就有的功能。对于加入项目的开发人员，文档应该指定核心功能是什么，如果他或她发现核心之外的某个晦涩函数有用，这很好，也是阅读测试的好地方，但有一种方法可以区分主应用程序支持的功能与辅助功能。
- en: One approach to try to make this more interactive is README-driven development,
    where we write the README first and make the examples executable, trying to make
    our code pass the examples we specified as the first layer of tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使这更加互动的一种方法是README驱动开发，我们首先编写README并使示例可执行，试图使我们的代码通过我们指定的示例作为第一层测试。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can read more on README-driven development at Tom Preston-Werner's blog,
    [http://tom.preston-werner.com/2010/08/23/readme-driven-development.html](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Tom Preston-Werner的博客上阅读更多关于README驱动开发的内容，[http://tom.preston-werner.com/2010/08/23/readme-driven-development.html](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html)。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on the interaction between different subprojects
    forming sub-domains and collaborating with each other by different means. This
    collaboration can take many forms and depending on the context and the state of
    the application as a whole, some can be more valuable then others.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点关注了不同子项目形成子域并通过不同方式相互合作的互动。这种合作可以采取许多形式，取决于应用程序整体的上下文和状态，有些形式可能比其他形式更有价值。
- en: The right choice for collaboration is always up for debate, of course, and it
    is very possible to change the mode as the project evolves. An important point
    I would like to get across is that those collaboration ideas are not set in stone;
    it is a sliding scale and every team should decide what works best for them and
    what keeps the actual complexity in the application and the team work low.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，合作的正确选择总是值得讨论的，并且随着项目的发展很可能会改变模式。我想要传达的一个重要观点是，这些合作理念并不是一成不变的；它是一个可变的尺度，每个团队都应该决定什么对他们最有效，以及如何保持应用程序和团队工作的实际复杂性低。
- en: In the last part, the chapter focused on the important things when creating
    documentation for a project and how we can make it useful while not diving into
    the realm of creating elaborate specifications that nobody ever touches or even
    understands as soon as they leave the hands of the architect who created them
    in the first place.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，本章重点关注了在为项目创建文档时的重要事项，以及我们如何使其在不深入创建精心制定的规范的情况下变得有用，因为一旦离开最初创建它们的架构师的手，很少有人会接触或理解它们。
- en: In the next chapter, we are going to explore how other development methods fit
    into domain-driven design, how a good object-oriented structure can support the
    design in general, and how domain-driven design is influenced by many other techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨其他开发方法如何适应领域驱动设计，良好的面向对象结构如何支持总体设计，以及领域驱动设计如何受到许多其他技术的影响。
