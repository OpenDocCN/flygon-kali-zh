- en: '*Chapter 7*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第7章*：'
- en: Big O Analysis of Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的大O分析
- en: This chapter covers the most popular metric for analyzing the efficiency and
    scalability of algorithms—Big O notation—in the context of a technical interview.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖分析算法效率和可扩展性的最流行的度量标准——大O符号——在技术面试的背景下。
- en: There are plenty of articles dedicated to this topic. Some of them are purely
    mathematical (academic), while others try to explain it with a more friendly approach.
    The pure mathematical approach is quite hard to digest and not very useful during
    an interview, so we will go for a more friendly approach that will be much more
    familiar to interviewers and developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多文章专门讨论这个话题。其中一些是纯数学的（学术性的），而其他一些则试图以更友好的方式解释它。纯数学的方法很难理解，在面试中也不太有用，所以我们将采用更友好的方法，这将更加熟悉于面试官和开发人员。
- en: Even so, this is not an easy mission because besides being the most popular
    metric for measuring the efficiency and scalability of algorithms, Big O notation
    can often also be the thing that you've never been motivated enough to learn about,
    despite knowing that it's going to show up in every single interview. From juniors
    to senior warriors, Big O notation is probably the biggest Achilles heel for everyone.
    However, let's make an effort to turn this Achilles heel into a strong point for
    our interviews.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，这并不是一项容易的任务，因为除了是衡量算法效率和可扩展性的最流行的度量标准外，大O符号通常也是你从未有动力学习的东西，尽管你知道它会出现在每一次面试中。从初级到高级的战士，大O符号可能是每个人最大的软肋。然而，让我们努力将这个软肋变成我们面试的一个强项。
- en: 'We will quickly go over Big O notation and highlight the things that matter
    the most. Next, we''ll jump into examples that have been carefully crafted to
    cover a wide range of problems, and so by the end of this chapter, you''ll be
    able to determine and express Big O for almost any given snippet of code. Our
    agenda includes the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速介绍大O符号，并强调最重要的事情。接下来，我们将深入研究精心设计的示例，涵盖各种问题，因此在本章结束时，你将能够确定并表达几乎任何给定代码的大O。我们的议程包括以下内容：
- en: Analogy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类比
- en: Big O complexity time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O复杂度时间
- en: The best case, worst case, and expected case
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳情况、最坏情况和预期情况
- en: Big O examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O示例
- en: So, let's start our Big O journey!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始我们的大O之旅！
- en: Analogy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类比
- en: Imagine a scenario where you've found one of your favorite movies on the internet.
    You can order it or download it. Since you want to see it as soon as possible,
    which is the best way to proceed? If you order it, then it will take a day to
    arrive. If you download it, then it will take half a day to download. So, it is
    faster to download it. That's the way to go!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情景，你在互联网上找到了自己喜欢的电影之一。你可以订购或下载它。由于你想尽快看到它，最好的方法是什么？如果你订购，那么需要一天才能送到。如果你下载，那么需要半天的时间。所以，下载更快。这就是要走的路！
- en: But wait! Just when you get ready to download it, you spot the *Lord of the
    Rings Master Collection* at a great price, and so you think about downloading
    it as well. Only this time, the download will take 2 days. However, if you place
    an order, then it will still only take a single day. So, placing an order is faster!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！就在你准备下载时，你发现了*指环王大师收藏*，价格很优惠，所以你也考虑下载它。只是这一次，下载需要2天的时间。然而，如果你下订单，仍然只需要一天。所以，下订单更快！
- en: Now, we can conclude that no matters how many items we order, the shipping time
    remains constant. We call this O(1). This is a constant runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以得出结论，无论我们订购多少物品，运输时间都保持不变。我们称之为O(1)。这是一个恒定的运行时间。
- en: Moreover, we conclude that the download time is directly proportional to the
    file sizes. We call this O(n). This is an asymptotic runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们得出结论，下载时间与文件大小成正比。我们称之为O(n)。这是一种渐近运行时间。
- en: From day-to-day observations, we can also conclude that online ordering scales
    better than online downloading.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从日常观察中，我们还可以得出结论，网上订购比网上下载更具扩展性。
- en: '**This is exactly what Big O time means: an asymptotic runtime measurement
    or an asymptotic function.**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**这正是大O时间的含义：渐近运行时间测量或渐近函数。**'
- en: As an asymptotic measurement, we are talking about Big O complexity time (this
    can be complexity space as well).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种渐近测量，我们谈论的是大O复杂度时间（这也可以是复杂度空间）。
- en: Big O complexity time
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O复杂度时间
- en: 'The following diagram reveals that, at some moment in time, O(n) surpasses
    O(1). So, until O(n) surpasses O(1), we can say that O(n) performs better than
    O(1):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示，在某个时间点，O(n)超过了O(1)。因此，在O(n)超过O(1)之前，我们可以说O(n)的性能优于O(1)：
- en: '![Figure 7.1 – The asymptotic runtime (Big O time)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 渐近运行时间（大O时间）'
- en: '](img/Figure_7.1_B15403.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B15403.jpg)'
- en: Figure 7.1 – The asymptotic runtime (Big O time)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 渐近运行时间（大O时间）
- en: Besides the O(1)—constant time—and O(n)—linear time runtimes—we have many other
    runtimes, such as O(log n), O(n log n)—logarithmic time—O(n2)—quadratic time,
    O(2n)— exponential time, and O(n!)—factorial time. These are the most common runtimes,
    but many more also exist.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了O(1)——常数时间——和O(n)——线性时间运行时间——我们还有许多其他运行时间，比如O(log n)、O(n log n)——对数时间——O(n2)——二次时间，O(2n)——指数时间，以及O(n!)——阶乘时间。这些是最常见的运行时间，但还有许多其他存在。
- en: 'The following diagram represents the Big O complexity chart:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表了大O复杂度图表：
- en: '![Figure 7.2 – Big O complexity chart'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 大O复杂度图表'
- en: '](img/Figure_7.2_B15403.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B15403.jpg)'
- en: Figure 7.2 – Big O complexity chart
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 大O复杂度图表
- en: As you can see, not all O times perform the same. O(n!), O(2n), and O(n2) are
    considered **horrible** and we should strive to write algorithms that perform
    outside this area. O(n log n) is better than O(n!) but is still **bad**. O(n)
    is considered **fair**, while O(log n) and O(1) are **good**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，并非所有的O时间表现都相同。O(n!)、O(2n)和O(n2)被认为是**可怕的**，我们应该努力编写超出这个范围的算法。O(n log
    n)比O(n!)更好，但仍然**糟糕**。O(n)被认为是**公平的**，而O(log n)和O(1)被认为是**好的**。
- en: Sometimes, we need multiple variables to express the runtime performance. For
    example, the time for mowing the grass on a soccer field can be expressed as O(*wl*),
    where *w* is the width of the soccer field and *l* is the length of the soccer
    field. Or, if you have to mow *p* soccer fields, then you can express it as O(*wlp*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要多个变量来表示运行时性能。例如，修剪足球场草坪的时间可以表示为O（wl），其中w是足球场的宽度，l是足球场的长度。或者，如果你必须修剪p个足球场，那么你可以表示为O（wlp）。
- en: However, it is not all about time. We care about space as well. For example,
    building an array of *n* elements needs O(n) space. Building a matrix of *n* x
    *n* elements needs O(n2) space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不全是关于时间。我们也关心空间。例如，构建一个包含*n*个元素的数组需要O（n）的空间。构建一个*n* x *n*元素的矩阵需要O（n2）的空间。
- en: The best case, worst case, and expected case
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳情况、最坏情况和预期情况
- en: If we simplify things, then we can think of the efficiency of our algorithms
    in terms of *best case, worst case,* and *expected case*. The best case is when
    the input of our algorithms meets some extraordinary conditions that allow it
    to perform the best. The worst case is at the other extreme, where the input is
    in an unfavorable shape that makes our algorithm reveal its worst performances.
    Commonly, however, these amazing or terrible situations won't happen. So, we introduce
    the expected performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简化事情，我们可以考虑算法的效率，以*最佳情况*、*最坏情况*和*预期情况*来衡量。最佳情况是当我们的算法的输入满足一些特殊条件，使其表现最佳。最坏情况是在另一个极端，输入处于不利的状态，使我们的算法表现最差。然而，通常这些惊人或可怕的情况不会发生。因此，我们引入了预期性能。
- en: Most of the time, we care about the worst and expected cases, which, in the
    case of most algorithms, are usually the same. The best case is an idealistic
    performance, and so it remains idealistic. Mainly, for almost any algorithm, we
    can find a special input that will lead to the O(1) best-case performance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们关心最坏和预期情况，对于大多数算法来说，它们通常是相同的。最佳情况是理想的性能，因此它仍然是理想的。主要是，对于几乎任何算法，我们都可以找到一个特殊的输入，导致O（1）的最佳情况性能。
- en: For more details about Big O, I strongly recommended you read the Big O cheat
    sheet ([https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Big O的更多细节，我强烈建议您阅读Big O速查表（[https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)）。
- en: Now, let's tackle a bunch of examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来解决一堆例子。
- en: Big O examples
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O的例子
- en: We will try to determine Big O for different snippets of code exactly as you
    will see at interviews, and we will go through several relevant lessons that need
    to be learned. In other words, let's adopt a *learning-by-example* approach.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试确定不同代码片段的Big O，就像你在面试中看到的那样，我们将经历需要学习的几个相关课程。换句话说，让我们采用*以例子学习*的方法。
- en: 'The first six examples will highlight the fundamental rules of Big O, listed
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前六个例子将突出Big O的基本规则，列举如下：
- en: Drop constants
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去掉常数
- en: Drop non-dominant terms
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去掉非主导项
- en: Different input means different variables
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的输入意味着不同的变量
- en: Different steps are summed or multiplied
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的步骤被求和或相乘
- en: Let us begin with trying out the examples.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始尝试一些例子。
- en: Example 1 – O(1)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例1 - O（1）
- en: 'Consider the following three snippets of code and compute Big O for each of
    them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个代码片段并计算它们的Big O：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since this code returns a constant, Big O is O(1). Regardless of what the rest
    of the code does, this line of code will execute at a constant rate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码返回一个常数，Big O是O（1）。无论代码的其余部分做什么，这行代码都会以恒定的速度执行：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Accessing an array by index is accomplished with O(1). Regardless of how many
    elements are in the array, getting an element from a specific index is a constant
    operation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引访问数组是以O（1）完成的。无论数组中有多少元素，从特定索引获取元素都是一个恒定的操作：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Queue#peek()` method retrieves but does not remove, the head (first element)
    of this queue. It doesn't matter how many elements follows the head, the time
    to retrieve the head via the `peek()` method is O(1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue#peek()`方法检索但不删除队列的头（第一个元素）。不管头部后面有多少元素，通过`peek()`方法检索头部的时间都是O（1）。'
- en: So, all three snippets in the preceding code block have the O(1) complexity
    time. Similarly, inserting and removing from a queue, pushing and popping from
    a stack, inserting a node in a linked list, and retrieving the left/right child
    of a node of a tree stored in an array are also cases of O(1) time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面代码块中的所有三个代码片段都具有O（1）的复杂度时间。同样，从队列中插入和删除，从栈中推送和弹出，插入链表中的节点，以及从数组中检索节点的左/右子节点也是O（1）时间的情况。
- en: Example 2 – O(n), linear time algorithms
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例2 - O（n），线性时间算法
- en: 'Consider the following snippet of code and compute Big O:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段并计算Big O：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to determine the Big O value for this snippet of code, we have to
    answer the following question: *how many times does this* `for` *loop iterate?*
    The answer is `a.length` times. We cannot say exactly how much time this means,
    but we can say that the time will grow linearly with the size of the given array
    (which represents the input). So, this snippet of code will have an O(`a.length`)
    time and is known as linear time. It is denoted as O(n).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定这段代码的Big O值，我们必须回答以下问题：*这个* `for` *循环迭代了多少次？*答案是`a.length`次。我们无法准确地说这意味着多少时间，但我们可以说随着给定数组的大小（表示输入），时间会线性增长。因此，这段代码将具有O（`a.length`）时间，被称为线性时间。它表示为O（n）。
- en: Example 3 – O(n), dropping the constants
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例3 - O（n），去掉常数
- en: 'Consider the following snippet of code and compute Big O:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段并计算Big O：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even if we added more instructions to the loop, we would still have the same
    runtime as in *Example 2*. The runtime will still be linear in the size of its
    input, `a.length`. As in *Example 2* we had a single line of code in a loop, while
    here we have four lines of code in a loop, you might expect Big O to be O(n +
    4) or something like that. However, this kind of reasoning is not precise or accurate—it's
    just wrong! Big O here is still O(n).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在循环中添加了更多的指令，我们仍然会像*例2*中一样具有相同的运行时间。运行时间仍然会随着其输入`a.length`的大小呈线性增长。就像*例2*中我们在循环中有一行代码，而在这里我们在循环中有四行代码，你可能期望大O是O(n
    + 4)或类似的。然而，这种推理不准确或准确 - 它是错误的！这里的大O仍然是O(n)。
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Keep in mind that Big O doesn't depend on the number of code lines. It depends
    on the runtime rate of increase, which is not modified by constant-time operations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大O不取决于代码行数。它取决于运行时间的增长率，这不会被常数时间操作修改。
- en: 'Just to reinforce this scenario, let''s consider the following two snippets
    of code, which compute the minimum and maximum of the given array, `a`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强这种情况，让我们考虑以下两个代码片段，它们计算给定数组`a`的最小值和最大值：
- en: '![7.3 – Code Comparison'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.3 - 代码比较'
- en: '](img/Figure_7.3_B15403.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B15403.jpg)'
- en: 7.3 – Code Comparison
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3 - 代码比较
- en: Now, which one of these two code snippets runs faster?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这两个代码片段中哪一个运行得更快？
- en: The first code snippet uses a single loop, but it has two `if` statements, while
    the second code snippet uses two loops, but it has one `if` statement per loop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码片段使用了一个循环，但有两个`if`语句，而第二个代码片段使用了两个循环，但每个循环中有一个`if`语句。
- en: Thinking like this opens the door to insanity! Counting the statements can continue
    at a deeper level. For example, we can continue to count the statements (operations)
    at the compiler level, or we might want to take into consideration the compiler
    optimizations. Well, that's not what Big O is about!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的思考方式会让人发疯！计算语句可以继续深入。例如，我们可以继续在编译器级别计算语句（操作），或者我们可能想要考虑编译器优化。嗯，这不是大O的意义所在！
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Big O is not about counting the code statements. Its goal is to express the
    runtime growth for input sizes and express how the runtime scales. In short, Big
    O just describes the runtime rate of increase.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大O不是关于计算代码语句的。它的目标是表达输入大小的运行时间增长，并表达运行时间的规模。简而言之，大O只是描述运行时间的增长率。
- en: Moreover, don't fall into the trap of thinking that because the first snippet
    has one loop, Big O is O(n), while in the case of the second snippet, because
    it has two loops, Big O is O(2n). Simply remove 2 from 2*n* since 2 is a constant!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要陷入这样的陷阱，认为因为第一个片段有一个循环，所以大O是O(n)，而在第二个片段的情况下，因为它有两个循环，所以大O是O(2n)。只需去掉2*n*中的2，因为2是一个常数！
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As a rule of thumb, when you express Big O, drop the constants in runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经验法则，当你表达大O时，去掉运行时间中的常数。
- en: So, both of the preceding snippets have a Big O value of O(n).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面两个代码片段都有一个大O值为O(n)。
- en: Example 4 – dropping the non-dominant terms
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例4 - 去掉非主导项
- en: 'Consider the following snippet of code and compute Big O (`a` is an array):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段并计算大O（`a`是一个数组）：
- en: '![7.4 – Code snippet executed in O(n)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.4 - 在O(n)中执行的代码片段'
- en: '](img/Figure_7.4_B15403.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B15403.jpg)'
- en: 7.4 – Code snippet executed in O(n)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4 - 在O(n)中执行的代码片段
- en: 'The first `for` loop is executed in O(n), while the second `for` loop is executed
    in O(n2). So, we may think that the answer to this problem is O(n) + O(n2) = O(n
    + n2). But this is not true! The rate of increase is given by *n*2, while *n*
    is a non-dominant term. If the size of the array is increased, then *n*2 affects
    the rate of increase much more than *n*, and so *n* is not relevant. Consider
    a few more examples:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环的执行时间是O(n)，而第二个`for`循环的执行时间是O(n2)。所以，我们可能会认为这个问题的答案是O(n) + O(n2) =
    O(n + n2)。但这是不正确的！增长率由*n*2给出，而*n*是一个非主导项。如果数组的大小增加，那么*n*2对增长率的影响要比*n*大得多，所以*n*不相关。考虑一些更多的例子：
- en: O(2n + 2n) -> drop constants and non-dominant terms -> O(2n).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(2n + 2n) -> 去掉常数和非主导项 -> O(2n)。
- en: O(n + log n) -> drop non-dominant terms -> O(n).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(n + log n) -> 去掉非主导项 -> O(n)。
- en: O(3*n2 + n + 2*n) -> drop constants and non-dominant terms -> O(n2).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(3*n2 + n + 2*n) -> 去掉常数和非主导项 -> O(n2)。
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As a rule of thumb, when you express Big O, drop the non-dominant terms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经验法则，当你表达大O时，去掉非主导项。
- en: Next, let's focus on two examples that are a common source of confusion for
    candidates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于两个常让候选人感到困惑的例子。
- en: Example 5 – different input means different variables
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例5 - 不同的输入意味着不同的变量
- en: Consider the following two snippets of code (`a` and `b` are arrays). How many
    variables should be used to express Big O?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个代码片段（`a`和`b`是数组）。应该使用多少变量来表达大O？
- en: '![7.5 – Code snippets 1 and 2'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.5 - 代码片段1和2'
- en: '](img/Figure_7.5_B15403.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B15403.jpg)'
- en: 7.5 – Code snippets 1 and 2
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5 - 代码片段1和2
- en: In the first snippet, we have two `for` loops that loop the same array, `a`
    (we have the same input for both loops), and so Big O can be expressed as O(n),
    where *n* refers to `a`. In the second code snippet, we also have two `for` loops,
    but they loop different arrays (we have two inputs, `a` and `b`). This time, Big
    O is not O(n)! What does *n* refer to – `a` or `b`? Let's say that *n* refers
    to `a`. If we increase the size of `b`, then O(n) doesn't reflect the runtime
    rate of increase. Therefore, Big O is the sum of these two runtimes (the runtime
    of `a` plus the runtime of `b`). This means that Big O must refer to both runtimes.
    For this, we can use two variables that refer to `a` and to `b`. So, Big O is
    expressed as O(a + b). This time, if we increase the size of `a` and/or `b`, then
    O(a + b) captures the runtime rate increase.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个片段中，我们有两个`for`循环，循环同一个数组`a`（我们对两个循环都有相同的输入），所以大O可以表示为O(n)，其中*n*指的是`a`。在第二个代码片段中，我们也有两个`for`循环，但它们循环不同的数组（我们有两个输入，`a`和`b`）。这次，大O不是O(n)！*n*指的是`a`还是`b`？假设*n*指的是`a`。如果我们增加`b`的大小，那么O(n)就不能反映运行时间的增长率。因此，大O是这两个运行时间的总和（`a`的运行时间加上`b`的运行时间）。这意味着大O必须指代这两个运行时间。为此，我们可以使用两个变量分别指代`a`和`b`。因此，大O表示为O(a
    + b)。这次，如果我们增加`a`和/或`b`的大小，那么O(a + b)就能捕捉到运行时间的增长率。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a rule of thumb, different inputs mean different variables.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，不同的输入意味着不同的变量。
- en: Next, let's see what happens when we add and multiply the algorithm steps.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在添加和乘以算法步骤时会发生什么。
- en: Example 6 – different steps are summed or multiplied
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例6 - 不同步骤是求和还是乘积
- en: Consider the following two snippets of code (`a` and `b` are arrays). How do
    you express Big O for each of these snippets?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个代码片段（`a`和`b`是数组）。如何为这两个片段中的每一个表达大O？
- en: '![7.6 – Code snippet a and b'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.6 - 代码片段a和b'
- en: '](img/Figure_7.6_B15403.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B15403.jpg)'
- en: 7.6 – Code snippet a and b
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6 - 代码片段a和b
- en: We already know from the previous example that, in the case of the first snippet,
    Big O is O(a + b). We sum up the runtimes since their work is not interweaved
    as in the case of the second snippet. So, in the second snippet, we cannot sum
    up the runtimes since, for each case of `a[i]`, the code loops the `b` array,
    and so Big O is O(a * b).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从前面的例子中知道，在第一个片段的情况下，大O是O(a + b)。我们对运行时间求和，因为它们的工作不像第二个片段那样交织在一起。所以，在第二个片段中，我们不能对运行时间求和，因为对于每个`a[i]`的情况，代码都会循环`b`数组，所以大O是O(a
    * b)。
- en: Think twice before deciding between summing and multiplying the runtimes. This
    is a common mistake made in interviews. Also, it is quite common to not notice
    that there is more than one input (here, there are two) and to mistakenly express
    Big O using a single variable. That would be wrong! Always pay attention to how
    many inputs are present. For each input that affects the runtime rate of increase,
    you should have a separate variable (see *Example 5*).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定对运行时间求和还是乘积之前三思。这是面试中常见的错误。而且，很常见的是没有注意到有多个输入（这里有两个），并错误地使用单个变量表示大O。那是错误的！一定要注意有多少个输入。对于每个影响运行时间增长率的输入，你应该有一个单独的变量（参见*示例5*）。
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'As a rule of thumb, different steps can be summed or multiplied. The runtimes
    should be summed or multiplied based on the following two statements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，不同的步骤可以求和或相乘。根据以下两个陈述，运行时间应该求和或相乘：
- en: If you describe your algorithm as **it foos and when it's done, it buzzes**,
    then sum the runtimes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你描述你的算法为**它foos，当它完成时，它就buzzes**，那么就对运行时间求和。
- en: If you describe your algorithm as **for each time it foos, it buzzes**, then
    multiply the runtimes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你描述你的算法为**每次它foos，它就buzzes**，那么就乘以运行时间。
- en: Now, let's discuss *log n* runtimes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论*log n*的运行时间。
- en: Example 7 – log n runtimes
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例7 - 对数n运行时间
- en: Write a snippet of pseudo-code that has Big O as O(log n).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个大O为O(log n)的伪代码片段。
- en: 'In order to understand the O(log n) runtimes, let''s start with the Binary
    Search algorithm. The Binary Search algorithm details and implementation is available
    in [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340), *Sorting and
    Searching*. This algorithm describes the steps for looking for element `x` in
    an array, `a`. Consider a sorted array, `a`, of 16 elements, such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解O(log n)的运行时间，让我们从二分搜索算法开始。二分搜索算法的详细信息和实现在[*第14章*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)，*排序和搜索*中可用。这个算法描述了在数组`a`中查找元素`x`的步骤。考虑一个有16个元素的有序数组`a`，如下所示：
- en: '![Figure 7.7 – Ordered array of 16 elements'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 16个元素的有序数组'
- en: '](img/Figure_7.7_B15403.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B15403.jpg)'
- en: Figure 7.7 – Ordered array of 16 elements
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 16个元素的有序数组
- en: 'First, we compare `x` with the midpoint of the array, `p`. If they are equal,
    then we return the corresponding array index as the final result. If `x > p`,
    then we search on the right side of the array. If `x < p`, then we search on the
    left side of the array. The following is a graphical representation of the binary
    search algorithm for finding the number 17:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`x`与数组`p`的中点进行比较。如果它们相等，那么我们将返回相应的数组索引作为最终结果。如果`x > p`，那么我们在数组的右侧搜索。如果`x
    < p`，那么我们在数组的左侧搜索。以下是用于查找数字17的二分搜索算法的图形表示：
- en: '![Figure 7.8 – The binary search algorithm'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 二分搜索算法'
- en: '](img/Figure_7.8_B15403.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B15403.jpg)'
- en: Figure 7.8 – The binary search algorithm
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 二分搜索算法
- en: 'Notice that we start with 16 elements and end with 1\. After the first step,
    we are down to 16/2 = 8 elements. At the second step, we are down to 8/2 = 4 elements.
    At the third step, we are down to 4/2 = 2 elements. Then, at the last step, we
    find the searched number, 17\. If we translate this algorithm into pseudo-code,
    then we obtain something as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从16个元素开始，最后剩下1个。第一步之后，我们剩下16/2 = 8个元素。第二步，我们剩下8/2 = 4个元素。第三步，我们剩下4/2 =
    2个元素。然后，在最后一步，我们找到了搜索的数字17。如果我们将这个算法转换成伪代码，那么我们得到如下内容：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's express Big O for this pseudo-code. We can observe that the algorithm
    consists of a continuous half-life of the array until only one element remains.
    So, the total runtime is dependent on how many steps we need in order to find
    a certain number in the array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个伪代码表示大O。我们可以观察到，该算法由数组的连续半衰期组成，直到只剩下一个元素。因此，总运行时间取决于我们需要多少步才能在数组中找到某个数字。
- en: 'In our example, we had four steps (we halved the array 4 times) that can be
    expressed as following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有四步（我们将数组减半了4次），可以表示为以下形式：
- en: '![Figure 7.9 – General case expression'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 - 一般情况表达'
- en: '](img/01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/01.jpg)'
- en: 'Or, if we condense it then we get:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们压缩它，我们得到：
- en: '![](img/7.09_-_02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7.09_-_02.jpg)'
- en: 'One step further, and we can express it for general case as (*n* is the size
    of the array, *k* is the number of steps to reach the solution):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们可以将其表示为一般情况（*n*是数组的大小，*k*是达到解决方案所需的步数）：
- en: '![](img/7.09_-_03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7.09_-_03.jpg)'
- en: 'But, 2k = n is exactly what logarithm means - *A quantity representing the
    power to which a fixed number (the base) must be raised to produce a given number*.
    So, we can write the follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，2k = n正是对数的意思 - *表示必须提高一个固定数字（底数）的幂以产生给定数字的数量*。因此，我们可以写成如下形式：
- en: '![](img/7.09_-_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7.09_-_04.jpg)'
- en: In our case, 2k = *n* means 24 = 16, which is log216 = 4.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，2k = *n*意味着24 = 16，即log216 = 4。
- en: So, Big O for the Binary Search algorithm is O(log n). However, where is the
    logarithm base? The short answer is that the logarithm base is not needed for
    expressing Big O because logs of different bases are only different by a constant
    factor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，二分搜索算法的大O是O(log n)。然而，对数的底在哪里？简短的答案是，对数的底不需要用于表示大O，因为不同底数的对数只相差一个常数因子。
- en: Important note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As a rule of thumb, when you have to express Big O for an algorithm that halves
    its input at each step/iteration, there are big chances of it being a case of
    O(log n).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，当你必须为一个在每一步/迭代中将其输入减半的算法表示大O时，它很有可能是O(log n)的情况。
- en: Next, let's talk about evaluating Big O for recursive runtimes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈递归运行时间的大O评估。
- en: Example 8 – recursive runtimes
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8 - 递归运行时间
- en: What is Big O for the following snippet of code?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段的大O是多少？
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On our first impression, we may express Big O as O(n2). Most likely, we will
    reach this result because we are misled by the two calls of the `fibonacci()`
    method from `return`. However, let''s give value to *k* and quickly sketch the
    runtime. For example, if we call `fibonacci(7)` and we represent the recursive
    calls as a tree, then we obtain the following diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一印象中，我们可能将大O表示为O(n2)。很可能，我们会得出这个结果，因为我们被`return`中`fibonacci()`方法的两次调用所误导。然而，让我们给*k*赋值并快速勾画运行时。例如，如果我们调用`fibonacci(7)`并将递归调用表示为一棵树，那么我们会得到以下图表：
- en: '![Figure 7.9 – Tree of calls'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 - 调用树'
- en: '](img/Figure_7.10_B15403.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B15403.jpg)'
- en: Figure 7.9 – Tree of calls
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 调用树
- en: We almost immediately notice that the depth of this tree is equal to 7, and
    so the depth of the general tree is equal to *k*. Moreover, with the exception
    of the terminal levels, each node has two children, and so almost every level
    has twice the number of calls as the one above it.This means that we can express
    Big O as O(branches depth). In our case, this is O(2k), denoted O(2n).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎立即注意到这棵树的深度等于7，因此一般树的深度等于*k*。此外，除了终端级别外，每个节点都有两个子节点，因此几乎每个级别的调用数量都是上面一个级别的两倍。这意味着我们可以将大O表示为O(分支深度)。在我们的情况下，这是O(2k)，表示为O(2n)。
- en: In an interview, just saying O(2n) should be an acceptable answer. If we want
    to be more accurate, then we should take into account the terminal levels, especially
    the last level (or the bottom of the call stack), which can sometimes contain
    a single call. This means that we don't always have two branches. A more accurate
    answer would be O(1.6n). Mentioning that the real value is less than 2 should
    be enough for any interviewer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，只说O(2n)应该是可以接受的答案。如果我们想更准确，那么我们应该考虑终端级别，特别是最后一级（或调用堆栈的底部），有时可能只包含一个调用。这意味着我们并不总是有两个分支。更准确的答案应该是O(1.6n)。提到实际值小于2应该足够让任何面试官满意。
- en: If we want to express Big O in terms of space complexity, then we obtain O(n).
    Do not be fooled by the fact that the runtime complexity is O(2n). At any moment,
    we cannot have more than *k* numbers. If we look in the preceding tree, we can
    only see numbers from 1 to 7.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以空间复杂度的术语来表示大O，那么我们得到O(n)。不要被运行时复杂度为O(2n)所迷惑。在任何时刻，我们不能有超过*k*个数字。如果我们看看前面的树，我们只能看到从1到7的数字。
- en: Example 9 – in-order traversal of a binary tree
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例9 - 二叉树的中序遍历
- en: Consider a given perfect binary search tree. If you need a quick remainder of
    binary trees then consider the *Nutshell* section of [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,*
    *Trees and Graphs*.What is Big O for the following snippet of code?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个给定的完美二叉搜索树。如果你需要快速回顾二叉树，那么请考虑[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,*
    *树和图*的*概要*部分。以下是代码片段的大O是多少？
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A perfect binary search tree is a binary search tree whose internal nodes have
    exactly two children and all the leaf nodes are on the same level or depth. In
    the following diagram, we have a typical perfect binary search tree (again, visualizing
    the runtime input is very useful):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的二叉搜索树是一棵二叉搜索树，其内部节点恰好有两个子节点，所有叶节点都在同一级别或深度上。在下面的图表中，我们有一棵典型的完美二叉搜索树（再次，可视化运行时输入非常有用）：
- en: '![Figure 7.10 – Height-balanced binary search tree'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 - 高度平衡的二叉搜索树'
- en: '](img/Figure_7.11_B15403.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B15403.jpg)'
- en: Figure 7.10 – Height-balanced binary search tree
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - 高度平衡的二叉搜索树
- en: 'We know from experience (more precisely, from the previous example) that when
    we face a recursive problem with branches, we can have an O(branches depth) case.
    In our case, we have two branches (each node has two children), and so we have
    O(2 depth). Having an exponential time looks weird, but let''s see what the relationship
    between the number of nodes and the depth is. In the preceding diagram, we have
    15 nodes and the depth is 4\. If we had 7 nodes, then the depth would be 3, and
    if we had 31 nodes, then the depth would be 5\. Now, if we don''t already know
    from the theory that the depth of a perfect binary tree is logarithmic, then maybe
    we can observe the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从经验中知道（更确切地说，从前面的例子中知道），当我们面对一个具有分支的递归问题时，我们可能会有一个O(分支深度)的情况。在我们的情况下，我们有两个分支（每个节点有两个子节点），因此我们有O(2深度)。指数时间看起来很奇怪，但让我们看看节点数量和深度之间的关系。在前面的图表中，我们有15个节点，深度为4。如果我们有7个节点，那么深度将是3，如果我们有31个节点，那么深度将是5。现在，如果我们不知道理论上完美二叉树的深度是对数的，那么也许我们可以观察以下内容：
- en: For 15 nodes, we have a depth of 4; therefore, we have 24 = 16, equivalent to
    log216 = 4.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于15个节点，我们有4层深度；因此，我们有24 = 16，相当于log216 = 4。
- en: For 7 nodes, we have a depth of 3; therefore, we have 23 = 8, equivalent to
    log28 = 3.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于7个节点，我们有3层深度；因此，我们有23 = 8，相当于log28 = 3。
- en: For 31 nodes, we have a depth of 5; therefore, we have 25 = 32, equivalent to
    log232 = 5.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于31个节点，我们有5层深度；因此，我们有25 = 32，相当于log232 = 5。
- en: 'Based on the preceding observations, we can conclude that we can express Big
    O as O(2log n) since the depth is roughly *log n*. So, we can write the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的观察，我们可以得出结论，我们可以将大O表示为O(2log n)，因为深度大约是*log n*。因此，我们可以写成以下形式：
- en: '![Figure 7.11 – Big O expression'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – 大O表达式'
- en: '](img/7-3.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7-3.jpg)'
- en: Figure 7.11 – Big O expression
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 大O表达式
- en: So, Big O in this case is O(n). We could reach the same conclusion if we recognized
    that this code is in fact the In-Order traversal of a binary tree, and in this
    traversal (exactly as in case of Pre-Order and Post-Order traversals), each node
    is visited a single time. Moreover, for each traversed node, there is a constant
    amount of work, and so Big O is O(n).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，大O是O(n)。如果我们意识到这段代码实际上是二叉树的中序遍历，我们也可以得出相同的结论，在这种遍历中（正如前序遍历和后序遍历一样），每个节点只被访问一次。此外，对于每个遍历的节点，有一个恒定的工作量，因此大O是O(n)。
- en: Example 10 – n may vary
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例10 – n可能变化
- en: What is Big O for the following snippet of code?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少？
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From *Example 8*, we already know that the Big O value of the `fibonacci()`
    method is O(2n). `printFibonacci()` calls `fibonacci()` *n* times, so it is very
    tempting to express the total Big O value as O(n)*O(2n) = O(n2n). However, is
    this true or have we rushed to give an apparently easy answer?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从*示例8*中，我们已经知道`fibonacci()`方法的大O值为O(2n)。`printFibonacci()`调用`fibonacci()`*n*次，因此很容易将总的大O值表示为O(n)*O(2n)
    = O(n2n)。然而，这是真的吗，还是我们匆忙给出了一个表面上容易的答案？
- en: 'Well, the trick here is that *n* varies. For example, let''s visualize the
    runtime:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里的诀窍是*n*是变化的。例如，让我们来可视化运行时间：
- en: '![](img/Figure_7.11.1_B15403.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.11.1_B15403.jpg)'
- en: We cannot say that we execute the same code *n* times, so this is O(2n).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能说我们执行相同的代码*n*次，因此这是O(2n)。
- en: Example 11 – memoization
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例11 – 记忆化
- en: What is Big O for the following snippet of code?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少？
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code computes the Fibonacci number via recursion. However, this code uses
    a technique known as *Memoization*. Mainly, the idea is to cache the return value
    and use it to reduce recursive calls. We already know from *Example 8* that Big
    O of the `fibonacci()` method is O(2n). Since *Memoization* should reduce recursive
    calls (it introduces an optimization), we can guess that Big O of this code should
    do better than O(2n). However, this is just an intuition, so let''s visualize
    the runtime for *k* = 7:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过递归计算斐波那契数。然而，这段代码使用了一种称为*记忆化*的技术。主要思想是缓存返回值并使用它来减少递归调用。我们已经从*示例8*中知道`fibonacci()`方法的大O是O(2n)。由于*记忆化*应该减少递归调用（它引入了一种优化），我们可以猜测这段代码的大O应该比O(2n)好。然而，这只是一种直觉，所以让我们来可视化*k*
    = 7的运行时间：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each `fibonacci(k)` method is computed from the cached `fibonacci(k-1)` and
    `fibonacci(k-2)` methods. Fetching the computed values from the cache and summing
    them is a constant time work. Since we do this work *k* times, this means that
    Big O can be expressed as O(n).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`fibonacci(k)`方法都是从缓存的`fibonacci(k-1)`和`fibonacci(k-2)`方法计算出来的。从缓存中获取计算出的值并对它们求和是一个恒定的工作量。由于我们这样做了*k*次，这意味着大O可以表示为O(n)。
- en: Besides *Memoization*, we can use another approach, known as *Tabulation*. More
    details are available in [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161),
    *Recursion and Dynamic Programming*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*记忆化*，我们还可以使用另一种方法，称为*表格法*。更多细节请参阅[*第8章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)，*递归和动态规划*。
- en: Example 12 – looping half of the matrix
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12 – 循环矩阵的一半
- en: What is Big O for the following two snippets of code (`a` is an array)?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个代码片段（`a`是一个数组）的大O是多少？
- en: '![7.12 – Code snippets for Big O'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.12 – 大O的代码片段'
- en: '](img/Figure_7.12_B15403.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B15403.jpg)'
- en: 7.12 – Code snippets for Big O
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 7.12 – 大O的代码片段
- en: These snippets of code are almost identical, except that in the first snippet,
    `j` starts from `0`, while in the second snippet, it starts from `i+1`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段几乎是相同的，只是在第一个片段中，`j`从`0`开始，而在第二个片段中，它从`i+1`开始。
- en: 'We can easily give value to the array size and visualize the runtime of these
    two snippets of code. For example, let''s consider that the array size is 5\.
    The left-hand matrix is the runtime of the first snippet of code, while the right-hand
    matrix corresponds to the runtime of the second snippet of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地给出数组大小的值，并可视化这两个代码片段的运行时间。例如，让我们假设数组大小为5。左侧矩阵是第一个代码片段的运行时间，而右侧矩阵对应于第二个代码片段的运行时间：
- en: '![Figure 7.13 – Visualizing the runtime'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 – 可视化运行时间'
- en: '](img/Figure_7.14_B15403.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B15403.jpg)'
- en: Figure 7.13 – Visualizing the runtime
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 可视化运行时间
- en: 'The matrix corresponding to the first snippet of code reveals an *n*n* size,
    while the matrix corresponding to the second snippet of code roughly reveals an
    *n*n*/2 size. So, we can write the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一段代码对应的矩阵显示了一个*n*n*大小，而与第二段代码对应的矩阵大致显示了一个*n*n*/2大小。因此，我们可以写成以下形式：
- en: 'Snippet 1 runtime is: ![](img/Snippets_01.png).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码段1的运行时间是：![](img/Snippets_01.png)。
- en: 'Snippet 2 runtime is: ![](img/Snippets_02.png) since we eliminate constants.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码段2的运行时间是：![](img/Snippets_02.png) 因为我们消除了常数。
- en: So, both snippets of code have O(n2).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这两段代码的时间复杂度都是O(n2)。
- en: 'Alternatively, you can think of it like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样想：
- en: For the first snippet, the inner loop doesn't work and it is run *n* times by
    the outer loop, and so *n*n = n*2, results in O(n2).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个代码段，内部循环不做任何工作，外部循环运行了*n*次，所以*n*n = n*2，结果是O(n2)。
- en: For the second snippet, the inner loop does roughly *n*/2 work and it is run
    *n* times by the outer loop, so *n*n*/2 = *n*2/2 = *n*2 * 1/2, which results in
    (after removing the constants) O(n2).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二段代码，内部循环大致做了*n*/2的工作，并且外部循环运行了*n*次，所以*n*n*/2 = *n*2/2 = *n*2 * 1/2，去除常数后得到O(n2)。
- en: Example 13 – identifying O(1) loops
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例13 - 识别O(1)循环
- en: What is Big O for the following snippet of code (`a` is an array)?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段的大O是多少（`a`是一个数组）？
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we ignore the third loop (the `q` loop), then we already know that Big O
    is O(n2). So, how does the third loop influence the total Big O value? The third
    loop iterates from 0 to 1 million, independent of the array size, and so Big O
    for this loop is O(1), which is a constant. Since the third loop doesn''t depend
    on how the input size varies, we can write it as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略第三个循环（`q`循环），那么我们已经知道大O是O(n2)。那么第三个循环如何影响总的大O值呢？第三个循环独立于数组大小，迭代从0到100万，因此这个循环的大O是O(1)，是一个常数。由于第三个循环不依赖于输入大小的变化，我们可以写成以下形式：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, it is clear that Big O for this example is O(n2).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显这个例子的大O是O(n2)。
- en: Example 14 – looping half of the array
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例14 - 循环数组的一半
- en: What is Big O for the following snippet of code (`a` is an array)?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段的大O是多少（`a`是一个数组）？
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Confusion here can be caused by the fact that this snippet loops only half of
    the array. Don't make the common mistake of expressing Big O as O(n/2). Remember
    that constants should be removed, and so Big O is O(n). Iterating only half of
    the array doesn't impact the Big O time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会引起混淆，因为这段代码只循环了数组的一半。不要犯将大O表达为O(n/2)的常见错误。记住常数应该被去除，所以大O是O(n)。只迭代数组的一半不会影响大O时间。
- en: Example 15 – reducing Big O expressions
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例15 - 减少大O表达式
- en: Which of the following can be expressed as O(n)?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个可以表示为O(n)？
- en: O(n + p)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(n + p)
- en: O(n + log n)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(n + log n)
- en: The answer is that O(n + log n) can be reduced to O(n) because *log* *n* is
    a non-dominant term and it can be removed. On the other hand, O(n + p) cannot
    be reduced to O(n) because we don't know anything about *p*. Until we establish
    what *p* is and what the relationship between *n* and *p* is, we have to keep
    both of them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是O(n + log n)可以简化为O(n)，因为*log* *n*是一个非主导项，可以被去除。另一方面，O(n + p)不能简化为O(n)，因为我们不知道*p*的情况。在我们确定*p*是什么以及*n*和*p*之间的关系之前，我们必须保留它们两个。
- en: Example 16 – looping with O(log n)
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例16 - 具有O(log n)的循环
- en: What is Big O for the following snippet of code (`a` is an array)?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段的大O是多少（`a`是一个数组）？
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's just focus on the outer loop. Based on the experiences from the previous
    examples, we can quickly express Big O as O(n).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只关注外部循环。根据之前示例的经验，我们可以迅速将大O表达为O(n)。
- en: 'How about the inner loop? We can notice that `j` starts from the array length
    and, at each iteration, it is halved. Remember the important note from *Example
    7* that say: *When you have to express Big O for an algorithm that halves its
    input at each step, there are big chances to be in a O(log n) case*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环呢？我们可以注意到`j`从数组长度开始，并且在每次迭代时减半。记住*示例7*中的重要说明：*当你必须为每一步减半的算法表达大O时，很可能是O(log
    n)的情况*。
- en: Important note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Whenever you think that there are big chances of it being a case of O(log n),
    it is advised that you use test numbers that are powers of the divisor. If the
    input is divided by 2 (it is halved), then use numbers that are a power of 2 (for
    example, 23 = 8, 24 = 16, 25 = 32, and so on). If the input is divided by 3, then
    use numbers that are a power of 3 (for example, 32 = 9, 33 = 27, and so on). This
    way, it is easy to count the number of divisions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你认为这很可能是O(log n)的情况时，建议使用除数的幂的测试数字。如果输入被除以2（被减半），那么使用除数的幂的数字（例如，23 = 8，24
    = 16，25 = 32等）。如果输入被除以3，那么使用除数的幂的数字（例如，32 = 9，33 = 27等）。这样，很容易计算除法的次数。
- en: 'So, let''s give value to `a.length` and visualize the runtime. Let''s say that
    `a.length` is 16\. This means that `j` will take the 12, 8, 4, 2, and 1 values.
    We have divided `j` by 2 exactly four times, so we have the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们给`a.length`赋值并可视化运行时间。假设`a.length`是16。这意味着`j`将取12、8、4、2和1的值。我们已经将`j`除以2四次，所以有以下结果：
- en: '![Figure 7.14 – Loop with O (log n)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14 - 具有O(log n)的循环'
- en: '](img/Figure_7.15_Loop_with_O_(log_n).jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_Loop_with_O_(log_n).jpg)'
- en: Figure 7.14 – Loop with O (log n)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 - 具有O(log n)的循环
- en: So, Big O for the inner loop is O(log n). To compute the total Big O, we consider
    that the outer loop is executed *n* times, and within that loop, another loop
    is executed *log* *n* times. So, the total Big O result is O(n)* O (log n) = O(n
    log n).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内部循环的大O是O(log n)。为了计算总的大O，我们考虑外部循环执行了*n*次，在这个循环内，另一个循环执行了*log* *n*次。因此，总的大O结果是O(n)*
    O (log n) = O(n log n)。
- en: As a tip, a lot of sorting algorithms (for example, Merge Sort and Heap Sort)
    have the O(n log n) runtime. Moreover, a lot of O(n log n) algorithms are recursive.
    Generally speaking, algorithms that are classified under the **Divide and Conquer**
    (**D&C**) category of algorithms are O(n log n). Hopefully, keeping these tips
    in mind will be very handy in interviews.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，许多排序算法（例如，归并排序和堆排序）具有O(n log n)的运行时间。 此外，许多O(n log n)算法是递归的。 一般来说，属于**分而治之**（**D&C**）类别的算法是O(n
    log n)。 希望记住这些提示在面试中会非常有用。
- en: Example 17 – string comparison
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例17 – 字符串比较
- en: 'What is Big O for the following snippet of code? (note that `a` is an array,
    and be sure to carefully read the comments):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少？（注意`a`是一个数组，请仔细阅读注释）：
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`sortArrayOfString()` receives an array of `String` and performs two major
    actions. It sorts each string from this array and the array itself. Both sorts
    are accomplished via algorithms whose runtime is expressed as O(n log n).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortArrayOfString()`接收一个`String`数组并执行两个主要操作。 它对该数组中的每个字符串和数组本身进行排序。 这两种排序都是通过运行时表达为O(n
    log n)的算法完成的。'
- en: 'Now, let''s focus on the `for` loop and see the wrong answer that is commonly
    given by candidates. We already know that sorting a single string gives us O(n
    log n). Doing this for each string means O(n) * (n log n) = O(n*n log n) = O(n2
    log n). Next, we sort the array itself, which is also given as O(n log n). Putting
    all of the results together, the total Big O value is O(n2 log n) + O(n log n)
    = O(n2 log n + n log n), which is O(n2 log n) since *n* *log* *n* is a non-dominant
    term. However, is this correct? The short answer is no! But why not?! There are
    two major mistakes that we''ve done: we''ve used *n* to represent two things (the
    size of the array and the length of the string) and we assumed that comparing
    `String` requires a constant time as is the case for fixed-width integers.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`for`循环，并看看候选人通常给出的错误答案。 我们已经知道对单个字符串进行排序会给我们带来O(n log n)。 对每个字符串进行这样的操作意味着O(n)
    * (n log n) = O(n*n log n) = O(n2 log n)。 接下来，我们对数组本身进行排序，这也表示为O(n log n)。 将所有结果放在一起，总的大O值是O(n2
    log n) + O(n log n) = O(n2 log n + n log n)，这是O(n2 log n)，因为*n* *log* *n*是一个非主导项。
    但是，这是正确的吗？ 简短的答案是否定的！ 但为什么不是呢？ 我们犯了两个主要错误：我们使用*n*来表示两个东西（数组的大小和字符串的长度），并且我们假设比较`String`需要一个常数时间，就像对于固定宽度的整数一样。
- en: 'Let''s detail the first problem. So, sorting a single string gives us O(n log
    n), where *n* represents the length of that string. We sort `a.length` strings,
    so *n* now represents the size of the array. This is where the confusion comes
    from, because when we say that the `for` loop is O(n2 log n), to which *n* are
    we referring to? Since we are working with two variables, we need to denote them
    differently. For example, we can consider the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明第一个问题。 因此，对单个字符串进行排序会给我们带来O(n log n)，其中*n*代表该字符串的长度。 我们对`a.length`个字符串进行排序，所以*n*现在代表数组的大小。
    这就是混淆的原因，因为当我们说`for`循环是O(n2 log n)时，我们指的是哪个*n*？ 由于我们正在处理两个变量，我们需要以不同的方式表示它们。 例如，我们可以考虑以下内容：
- en: '*s*: The length of the longest `String`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*s*：最长`String`的长度。'
- en: '*p*: The size of the array of `String`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p*：`String`数组的大小。'
- en: In these terms, sorting a single string is O(s log s), and doing this *p* times
    results in O(p)*O(s log s) = O(p*s log s).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用这些术语来说，对单个字符串进行排序是O(s log s)，这样做*p*次的结果是O(p)*O(s log s) = O(p*s log s)。
- en: Now, let's tackle the second problem. In our new terms, sorting the array is
    O(p log p) – I've just replaced *n* with *p*. However, does the comparison of
    `String` require a constant time as is the case of fixed-width integers? The answer
    is no! String sorting changes O(p log p) because the `String` comparison itself
    has a variable cost. The length of `String` varies, and so the comparison time
    varies as well. So, in our case, each `String` comparison takes O(s), and since
    we have O(p log p) comparisons, it results that sorting the array of strings is
    O(s) * O(p log p) = O(s*p log p).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解决第二个问题。 用我们的新术语来说，对数组进行排序是O(p log p) – 我刚刚用*p*替换了*n*。 但是，`String`的比较是否需要像固定宽度整数一样的常数时间呢？
    答案是否定的！ `String`排序改变了O(p log p)，因为`String`比较本身具有可变成本。 `String`的长度是变化的，因此比较时间也是变化的。
    因此，在我们的情况下，每个`String`比较都需要O(s)，由于我们有O(p log p)次比较，结果是对字符串数组进行排序是O(s) * O(p log
    p) = O(s*p log p)。
- en: Finally, we have to add O(p*s log s) to O(s*p log p) = O(s*p(log s + log p)).
    Done!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将O(p*s log s)加到O(s*p log p)上= O(s*p(log s + log p))。 完成！
- en: Example 18 – factorial Big O
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例18 – 阶乘的大O
- en: What is Big O for the following snippet of code?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少？
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is obvious that this snippet of code is a recursive implementation of computing
    factorials. Don't do the common mistake of thinking that Big O is O(n!). This
    is not true! Always analyze the code carefully without prior assumption.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这段代码是计算阶乘的递归实现。 不要犯认为大O是O(n!)的常见错误。 这是不正确的！ 要仔细分析代码，不要提前假设。
- en: The recursive process traverses the sequence *n*–1, *n*–2, ... 1 times; therefore,
    this is O(n).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 递归过程遍历序列*n*–1，*n*–2，... 1次；因此，这是O(n)。
- en: Example 19 – using n notation with caution
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例19 – 谨慎使用n符号
- en: What is Big O for the following two snippets of code?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个代码片段的大O是多少？
- en: '![7.15 – Code snippets'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![7.15 – 代码片段'
- en: '](img/Figure_7.15_B15403.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B15403.jpg)'
- en: 7.15 – Code snippets
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 7.15 – 代码片段
- en: The first snippet (on the left-side hand) does constant work for `y` times.
    The `x` input doesn't affect the runtime rate of increase, and so Big O can be
    expressed as O(y). Pay attention to the fact that we don't say O(n) since *n*
    can be confused with `x` as well.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的第一个代码片段对`y`次进行了常量工作。 `x`输入不会影响运行时间的增长速度，因此大O可以表示为O(y)。 请注意，我们不说O(n)，因为*n*也可能与`x`混淆。
- en: The second snippet (on the right-side hand) recursively traverses `y`-1, `y`-2,
    ..., 0\. Each `y` input is traversed a single time, so Big O can be expressed
    as O(y). Again, the `x` input doesn't affect the runtime rate of increase. Moreover,
    we avoid saying O(n) since there is more than one input and O(n) will create confusion.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段（在右侧）递归遍历`y`-1、`y`-2、...、0。每个`y`输入只遍历一次，因此大O可以表示为O（y）。再次强调，`x`输入不会影响运行时间的增长率。此外，我们避免说O（n），因为有多个输入，O（n）会引起混淆。
- en: Example 20 – the sum and count
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例20 - 总和和计数
- en: What is Big O for the following snippet of code (`x` and `y` are positive)?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少（`x`和`y`为正数）？
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's give values to `x` and `y` and watch the `count` variable, which counts
    the number of iterations. Consider that `x`=10 and `y`=2\. For this scenario,
    `count` will be 5 (10/2 = 5). Following the same logic, we have `x`=14, `y`=4,
    `count`=3 (14/4 = 3.5), or `x`=22, `y`=3, or `count`=7 (22/3 = 7.3). We can notice
    that in the worst-case scenario, `count` is `x`/`y`, and so Big O can be expressed
    as O(x/y).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给`x`和`y`赋值，并观察`count`变量，该变量计算迭代次数。考虑`x`=10和`y`=2。对于这种情况，`count`将为5（10/2 =
    5）。按照相同的逻辑，我们有`x`=14，`y`=4，`count`=3（14/4 = 3.5），或`x`=22，`y`=3，或`count`=7（22/3
    = 7.3）。我们可以注意到，在最坏的情况下，`count`是`x`/`y`，因此大O可以表示为O（x/y）。
- en: Example 21 – the number of iteration counts in Big O
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例21 - 大O中的迭代计数
- en: The following snippet of code tries to guess the square root of a number. What
    is Big O?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段尝试猜测一个数字的平方根。大O是多少？
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's consider that the number (`n`) is a perfect square root, such as 144,
    and we already know that sqrt(144) = 12\. Since the `guess` variable starts from
    1 and stops at `guess*guess <= n` with step 1, it is quite simple to compute that
    `guess` will take the values 1, 2, 3, ... , 12\. When `guess` is 12, we have 12*12
    = 144, and the loop stops. So, we had 12 iterations, which is exactly sqrt(144).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设数字（`n`）是一个完全平方根，例如144，我们已经知道sqrt（144）= 12。由于`guess`变量从1开始，并在`guess*guess
    <= n`时停止，步长为1，因此很容易计算出`guess`将取值1、2、3、...，12。当`guess`为12时，我们有12*12 = 144，循环停止。因此，我们有12次迭代，这恰好是sqrt（144）。
- en: We follow the same logic for a non-perfect square root. Let's consider that
    `n` is 15\. This time, `guess` will take the 1, 2, and 3 values. When `guess`=4,
    we have 4*4 > 15 and the loop stops. The returned value is -1\. So, we had 3 iterations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对非完全平方根采用相同的逻辑。假设`n`是15。这次，`guess`将取1、2和3的值。当`guess`=4时，我们有4*4 > 15，循环停止。返回值为-1。因此，我们有3次迭代。
- en: In conclusion, we have sqrt(`n`) iterations, so Big O can be expressed as O(sqrt(n)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们有sqrt（`n`）次迭代，因此大O可以表示为O（sqrt（n））。
- en: Example 22 – digits
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例22 - 数字
- en: The following snippet of code sum up the digits of an integer. What is Big O?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段总结了整数的数字。大O是多少？
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At each iteration, `n` is divided by 10\. This way, the code isolates a digit
    in the right-side of the number (for example, 56643/10 = 5664.3). To traverse
    all the digits, the `while` loop needs a number of iterations equal to the number
    of digits (for example, for 56,643 it needs 5 iterations to isolate 3, 4, 6, 6,
    and 5).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，`n`被10除。这样，代码会将数字的右侧孤立出来（例如，56643/10 = 5664.3）。为了遍历所有数字，`while`循环需要的迭代次数等于数字的位数（例如，对于56,643，它需要5次迭代来孤立3、4、6、6和5）。
- en: 'However, a number with 5 digits can be up to 105 = 100,000, which means 99,999
    iterations. Generally speaking, this means a number (`n`) with *d* digits can
    be up to 10d. So, we can say the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个有5位数字的数字可以达到105 = 100,000，这意味着99,999次迭代。一般来说，这意味着一个具有*d*位数的数字（`n`）可以达到10d。因此，我们可以说以下内容：
- en: '![Figure 7.16 – Digits relationship'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16 - 数字关系'
- en: '](img/7-2.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/7-2.jpg)'
- en: Figure 7.16 – Digits relationship
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 - 数字关系
- en: Example 23 – sorting
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例23 - 排序
- en: What is Big O for the following snippet of code?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的大O是多少？
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In *Example 16*, we said that a lot of sorting algorithms (including Merge Sort)
    have a runtime of O(n log n). This means that `mergesort(y)` has a runtime of
    O(y log y).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例16*中，我们说很多排序算法（包括归并排序）的运行时间为O（n log n）。这意味着`mergesort(y)`的运行时间为O（y log y）。
- en: In *E**xample 7*, we said that the Binary Search algorithm has a runtime of
    O(log n). This means that `binarySearch(y, i)` has a runtime of O(log y). In the
    worst-case scenario, the `for` loop will iterate the whole `x` array, and so the
    binary search algorithm will be executed `x.length` times. The `for` loop will
    have a runtime of O(x log y).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在*E**xample 7*中，我们说二分搜索算法的运行时间为O（log n）。这意味着`binarySearch(y, i)`的运行时间为O（log
    y）。在最坏的情况下，`for`循环将遍历整个`x`数组，因此二分搜索算法将被执行`x.length`次。`for`循环的运行时间为O（x log y）。
- en: So, the total Big O value can be expressed as O(y log y) + O(x log y) = O(y
    log y + x log y).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的大O值可以表示为O（y log y）+ O（x log y）= O（y log y + x log y）。
- en: Done! This was the last example presented here. Next, let's try to extract several
    key hints that can help you in interviews to determine and express Big O.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！这是这里介绍的最后一个示例。接下来，让我们尝试提取几个关键提示，这些提示可以帮助你在面试中确定和表达大O。
- en: Key hints to look for in an interview
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面试中要寻找的关键提示
- en: During an interview, time and stress are serious factors that can affect concentration.
    Having the capacity to identify templates, recognize certain cases, guess the
    correct answer, and so on gives you a major advantage. As we stated in [*Chapter
    5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072), *How to Approach a Coding
    Challenge,* in *figure 5.2*, building an example (or a use case) is the second
    step to tackling a coding challenge. Even if the code is given by the interviewer,
    building an example is still quite useful for determining Big O.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，时间和压力是可以影响集中力的严重因素。具有识别模板、识别特定情况、猜测正确答案等能力会给你带来重大优势。正如我们在[*第5章*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)中所述，*如何应对编码挑战*，在*图5.2*中，构建示例（或用例）是应对编码挑战的第二步。即使面试官提供了代码，构建示例对于确定大O仍然非常有用。
- en: As you probably noticed, in almost every non-trivial example that we covered,
    we preferred to visualize the runtime for one or several concrete cases. That
    way, you can really understand the details of the code, identify the inputs, determine
    the static (constant) and dynamic (variable) parts of the code, and get a general
    view of how the code works.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在我们涵盖的几乎每个非平凡示例中，我们更喜欢为一个或多个具体案例可视化运行时间。这样，您可以真正理解代码的细节，识别输入，确定代码的静态（常数）和动态（变量）部分，并对代码的工作方式有一个总体了解。
- en: 'The following is a non-exhaustive list of key hints that can help you in an
    interview:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键提示的非尽事项清单，可以帮助您在面试中：
- en: '`x`, `y`, and `w`, and do some computations, such as `x-y` and `y*w`). In some
    cases, to create confusion, it adds repetitive statement as well (for example,
    the computations are done in `for(int i=0; i<10; i++)`). So, it is very important
    to settle right from the start whether the inputs of the algorithm affect its
    runtime or not.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`，`y`和`w`，并进行一些计算，比如`x-y`和`y*w`）。在某些情况下，为了制造混淆，它还会添加重复的语句（例如，计算是在`for(int
    i=0; i<10; i++)`中完成的）。因此，从一开始就确定算法的输入是否影响其运行时间非常重要。'
- en: '`for(int i=0; i<a.length; i++)`, where `a` is an array). Typically, these structures
    have a runtime of O(n). In some cases, to create confusion, the repetitive structure
    adds a condition that validates a `break` statement. Remember that Big O is about
    the worst-case scenario, so you should evaluate the runtime keeping in mind that
    the condition that validates the `break` statement may never happen and Big O
    is still O(n).'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for(int i=0; i<a.length; i++)`，其中`a`是一个数组）。通常，这些结构的运行时间为O(n)。在某些情况下，为了制造混淆，重复的结构会添加一个验证`break`语句的条件。请记住，大O是关于最坏情况的，因此您应该评估运行时间时要牢记验证`break`语句的条件可能永远不会发生，而大O仍然是O(n)。'
- en: '**If, at each iteration, the algorithm halves the input data, then O(log n)
    may be involved in the total Big O value**: As you saw in *Example 7*, the Binary
    Search algorithm is a famous case of O(log n). Typically, you can identify similar
    cases by trying to visualize the runtime.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果在每次迭代中，算法将输入数据减半，则总体大O值可能涉及O(log n)**：正如您在*示例7*中看到的，二分查找算法是O(log n)的著名案例。通常，您可以通过尝试可视化运行时间来识别类似的情况。'
- en: '**A recursive problem of having branches is a good signal that O(branches**
    depth**) might be part of the total Big O value**: The most common case where
    O(2depth) is encountered is in snippets of code that manipulate binary trees.
    Pay attention to how you determine the *depth* as well. As you saw in *Example
    9*, the *depth* can influence the final result. In that case, O(2log n) was reduced
    to O(n).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有分支的递归问题是O(分支**深度**)可能是总体大O值的一个很好的信号**：O(2^深度)遇到的最常见情况是在操纵二叉树的代码片段中。还要注意如何确定*深度*。正如您在*示例9*中看到的，*深度*可以影响最终结果。在那种情况下，O(2log
    n)被降低为O(n)。'
- en: '**Recursive algorithms that use Memoization or Tabulation are good candidates
    for having O(n) as their total Big O value**: Typically, recursive algorithms
    expose exponential runtimes (for example, O(2n)) but optimizations such as *Memoization*
    and *Tabulation* may reduce the runtime to O(n).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用记忆化或表格法的递归算法是具有O(n)作为其总体大O值的良好候选**：通常，递归算法暴露出指数运行时间（例如，O(2^n)），但是优化，如*记忆化*和*表格法*可以将运行时间降低到O(n)。'
- en: '**Sort algorithms commonly introduce O(n log n) in the total Big O value**:
    Keep in mind that a lot of sorting algorithms (for example, Heap Sort, Merge Sort,
    and so on) have a runtime of O(n log n).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序算法通常在总体大O值中引入O(n log n)**：请记住，许多排序算法（例如，堆排序，归并排序等）的运行时间为O(n log n)。'
- en: I hope these hints help you as we have covered some very tried and tested examples.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些提示能帮助您，因为我们已经涵盖了一些经过充分验证的例子。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered one of the most predominant topics in an interview,
    Big O. Sometimes, you'll have to determine Big O for a given code, while other
    times, you'll have to determine it for your own code. In other words, there is
    little chance of bypassing Big O in an interview. No matter how hard you train,
    Big O always remains a hard topic that can put even the best developers in trouble.
    Fortunately, the cases covered here are the most popular in interviews and they
    represent perfect templates for a lot of derived problems.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了面试中最主要的话题之一，即大O。有时，您将不得不确定给定代码的大O，而其他时候，您将不得不确定自己的代码的大O。换句话说，在面试中几乎没有绕过大O的机会。无论您如何努力训练，大O始终是一个难题，即使是最优秀的开发人员也可能遇到困难。幸运的是，这里涵盖的情况是面试中最受欢迎的，并且它们代表了许多派生问题的完美模板。
- en: 'In the next chapter, we will tackle other favored topics in interviews: recursion
    and Dynamic Programming.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决面试中其他受欢迎的话题：递归和动态规划。
