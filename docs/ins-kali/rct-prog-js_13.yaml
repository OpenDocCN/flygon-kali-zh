- en: Appendix A. A Node.js Kick start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. Node.js Kick start
- en: In web development, it is desirable to have a backend server of some sort. The
    list of servers and languages available is extensive. But one server that has
    generated an extraordinary level of excitement is Node.js, which lets you use
    the same JavaScript for frontend and backend development, and allows truly interesting
    possibilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，有一个后端服务器是可取的。可用的服务器和语言列表很长。但一个引起了极大兴奋的服务器是Node.js，它让你可以在前端和后端开发中使用相同的JavaScript，并且提供了真正有趣的可能性。
- en: The purpose of this book is to introduce Facebook's frontend user interface
    framework, called ReactJS. The purpose of this appendix is to provide just enough
    of a backend to run an authenticated server, and while there are many good choices,
    Node.js works without an appendix asking you to deal with a new language. The
    basic work done in this appendix covers territory comparable to what you might
    approach with another server and backend language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的是介绍Facebook的前端用户界面框架ReactJS。本附录的目的是提供足够的后端内容来运行一个经过身份验证的服务器，虽然有许多不错的选择，但Node.js可以在不需要处理新语言的情况下工作。本附录中所做的基本工作涵盖了与其他服务器和后端语言可能涉及的领域相当的范围。
- en: 'In this appendix, we will be covering these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将涵盖以下主题：
- en: How Node.js takes a cue from INTERCAL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js如何从INTERCAL中汲取灵感
- en: How Node.js, like JavaScript, has minefields
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js，就像JavaScript一样，存在着许多隐患
- en: Porting the Pragmatometer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植Pragmatometer
- en: But let's first look at Node.js and INTERCAL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先让我们看看Node.js和INTERCAL。
- en: Node.js and INTERCAL
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js和INTERCAL
- en: '**INTERCAL**, properly named **The Compiler Language With No Pronounceable
    Acronym**, was first announced by Princeton students Don Woods and Jim Lyon in
    1972\. The archetypal example of a language designed to satirize various trends
    and fashions in programming languages, it is perhaps better known as the archetypal
    example of a language intended, not to be easy to work with, but to be deliberately
    and unnecessarily hard to use. Its *Hello, world!* code contains full, repetitive-stress-injury-inducing
    16 lines; its legendary ROT-13 encryptor/decryptor (a straightforward one-liner
    for Perl or Unix shell commands) has been described on `alt.folklore.computers`
    as "four pages of completely undecipherable code." INTERCAL was originally published
    on punch cards in EBCDIC, a character encoding that has been called an encryption
    standard.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: INTERCAL，正式名称为“没有可发音首字母缩写的编译语言”，是由普林斯顿大学的Don Woods和Jim Lyon于1972年首次宣布。作为一个旨在讽刺各种编程语言的趋势和时尚的语言的原型示例，它可能更为人所知的是一个旨在不易使用，而故意和不必要地难以使用的语言的原型示例。它的“Hello,
    world!”代码包含了完整的、重复性压力伤害的16行；它传奇般的ROT-13加密/解密器（对于Perl或Unix shell命令来说是一个简单的一行代码）在“alt.folklore.computers”上被描述为“四页完全无法理解的代码”。INTERCAL最初是以EBCDIC的穿孔卡形式发布的，这是一种被称为加密标准的字符编码。
- en: One trend that was satirized was Edgser Dikjstra's "Go to statement considered
    harmful," a work that was beyond being merely seminal, arguably being the single
    most important article in the history of computer science. Wags have said, for
    instance, that a programmer is someone who is offended on being told, "Go to hell!"
    not by the "hell" but by `Go to`. One INTERCAL variant (C-INTERCAL) took the premise
    that `Go to` statements are indeed rightly considered harmful, and they wanted
    to go as far away from `Go to` statements as possible—much farther than wimpy
    IF-THEN-ELSE statements and `while` loops. They offered a much more radical departure
    from the `Go to` statement than IF-THEN-ELSE and `while` loops—the `come from`
    statement. While the `Go to` statement says, "If the execution reaches this point
    of the code, go to that area of the code," the `come from` antonym says, "If the
    execution reaches that other area of the code, switch over and pick up things
    at this point of the code."
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被讽刺的趋势是Edgser Dikjstra的“Go to语句被认为是有害的”，这项工作不仅仅是开创性的，可以说是计算机科学史上最重要的文章。有人说，程序员是一个被告知“去地狱！”而不是被“地狱”所冒犯的人，而是被“去”所冒犯的人。一个INTERCAL变种（C-INTERCAL）认为“Go
    to”语句确实是有害的，他们想尽可能远离“Go to”语句——比IF-THEN-ELSE语句和while循环要远得多。他们提供了一个比IF-THEN-ELSE和while循环更激进的离开“Go
    to”语句的方法——“come from”语句。而“Go to”语句是说，“如果执行到达代码的这一点，就去到代码的那个区域”，“come from”反义词是说，“如果执行到达代码的那个区域，切换过去并在代码的这一点继续进行”。
- en: 'The suggestion that might be made is as follows: the genius of Node.js, for
    which we are providing a kick start in this chapter, is that it bends over backward
    to have flow control based on `come from` statements, or something very similar
    to them. Now, Node.js is also a server programmable in JavaScript, which is nothing
    to sneeze at, but it has completely eclipsed all other servers programmable in
    JavaScript. Its genius stems, not from JavaScript alone, but from a development
    environment that works best when you can solve problems in terms of `come from`
    as a primary tool for flow control. The usual preferred term is asynchronous callback
    function, rather than `come from`, but you will work best with Node.js when you
    realize that Node.js is interesting as a live example of `come from` programming
    being performant by default, and outperforming its competitors by an order of
    magnitude.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可能提出的建议是：Node.js的天才之处，在本章中我们提供了一个快速入门，是它竭尽全力基于“come from”语句或类似的东西进行流程控制。现在，Node.js也是一个可用JavaScript编程的服务器，这一点也不可小觑，但它已经完全超越了所有其他可用JavaScript编程的服务器。它的天才不仅来自JavaScript，还来自一个在你能够用“come
    from”作为流程控制的主要工具来解决问题时效果最佳的开发环境。通常更喜欢的术语是异步回调函数，而不是“come from”，但当你意识到Node.js作为一个“come
    from”编程的活生生的例子默认情况下是高性能的，并且在性能上超越了竞争对手一个数量级时，你会发现Node.js的工作效果最佳。
- en: Someone who has formative C experience and comes to Perl might well be told,
    "You're not really thinking of Perl unless you're thinking of hashes," or an old-line
    Java programmer might be told, "You're not really thinking of JavaScript unless
    you're thinking of closures." In like fashion, someone coming from any other mainstream
    web server at all might be told, "You're not really thinking of Node.js unless
    you're thinking of `come from`-style asynchronous callback functions."
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有C语言经验的人来到Perl可能会被告知，“除非你考虑到哈希表，否则你并没有真正考虑Perl”，或者一个老派的Java程序员可能会被告知，“除非你考虑到闭包，否则你并没有真正考虑JavaScript”。同样地，来自任何其他主流网络服务器的人可能会被告知，“除非你考虑到`come
    from`风格的异步回调函数，否则你并没有真正考虑Node.js”。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Anonymous functions have been glorious since they appeared in Lisp, and they're
    a great feature in JavaScript. But when dealing with Node.js callbacks, consider
    using non-nested named functions as an alternative to deeply nesting layers of
    anonymous inner functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自匿名函数出现以来，它们在Lisp中就很出色，在JavaScript中也是一个很棒的特性。但在处理Node.js回调时，考虑使用非嵌套的命名函数作为匿名内部函数的替代。
- en: 'Technically speaking, using asynchronous callback functions in Node.js is strictly
    optional. However, it may be strongly suggested that unless you are using a learning
    tool for Node.js—such as the excellent "Learn You the Node.js For Much Win!" (a
    title that clearly alludes to *Learn You a Haskell For Great Good* as an excellent
    predecessor), the Node.js learning tool being the one promoted at [http://nodeschool.io](http://nodeschool.io)—you
    should remember Knuth''s two rules:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在Node.js中使用异步回调函数是可选的。然而，强烈建议除非你正在使用一个Node.js的学习工具，比如优秀的“学习Node.js为了大胜利！”（这个标题显然是对*Learn
    You a Haskell For Great Good*的一个优秀前辈的致敬），Node.js的学习工具是在[http://nodeschool.io](http://nodeschool.io)上推广的那个，你应该记住Knuth的两条规则：
- en: '**Rule 1 (for all programmers)**: Don''t optimize'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1（适用于所有程序员）**：不要优化'
- en: '**Rule 2 (for advanced programmers only)**: Optimize later'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2（仅适用于高级程序员）**：稍后再优化'
- en: 'In the context of Node.js, this becomes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js的上下文中，这变成了：
- en: '**Rule 1 (for all Node.js hackers)**: Don''t use synchronous methods where
    an asynchronous approach would work'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1（适用于所有Node.js黑客）**：不要使用同步方法，而应该使用异步方法'
- en: '**Rule 2 (for advanced Node.js hackers only)**: Add any synchronous functionality
    later'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2（仅适用于高级Node.js黑客）**：稍后再添加任何同步功能。'
- en: 'For an example of code implemented synchronously, the way a non-Node.js person
    would likely see, we can read and print a file such as `/etc/passwd` (on Windows,
    a different full path would be appropriate; you can create and save one with Notepad
    or your favorite editor):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个同步实现的代码示例，一个非Node.js的人可能会看到的方式，我们可以读取并打印一个文件，比如`/etc/passwd`（在Windows上，应该使用不同的完整路径；你可以用记事本或你喜欢的编辑器创建并保存一个）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implemented with the `come from` asynchronous callback functionality:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`come from`异步回调功能实现：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The question of whether `console.log()` is blocking or not does not concern
    us here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log()`是否阻塞与否并不关心我们。'
- en: 'This is a slightly more sophisticated *Hello, world!* program for node, or
    perhaps a program just after *Hello, world!* which, in Node.js, is simply as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微复杂一点的Node.js的*Hello, world!*程序，或者可能是*Hello, world!*之后的程序，它在Node.js中就是这样的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's comment on the asynchronous example in detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细评论一下异步示例。
- en: 'The standard way of importing a package is to call `require()`, and save the
    result in the variable you want to use to access the package. The `fs` package
    is one of the few packages that come automatically with Node.js, but Node.js comes
    packed with a whole universe of packages available through **Node Package Manager**
    (**npm**), a package manager that may appear familiar to people who use Linux
    package managers. With npm, you can search for, for example, Express.js, which
    will be covered briefly in this chapter. Express.js is popular among the Node.js
    community, works well with Node.js, and is a bit like Rails for Ruby or Django
    for Python. A search for Express.js can be like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包的标准方法是调用`require()`，并将结果保存在你想要用来访问包的变量中。`fs`包是少数几个自带Node.js的包之一，但Node.js还附带了通过**Node
    Package Manager**（**npm**）获得的整个包宇宙，这是一个对于使用Linux包管理器的人来说可能很熟悉的包管理器。使用npm，你可以搜索例如Express.js这样的包，这将在本章中简要介绍。Express.js在Node.js社区中很受欢迎，与Node.js配合良好，有点像Ruby的Rails或Python的Django。搜索Express.js可以像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you''ve identified which package name you want (or you think you want),
    you can install it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了你想要的包名（或者你认为你想要的），你就可以安装它：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, the `fs.readFile()` function call is what sets up the
    `come from` behavior. Like other asynchronous calls, it has two required arguments:
    a basic argument (possibly an array) that is given to `fs.readFile()`, and a callback
    function. What happens when this is called—instead of blocking for an expensive
    amount of time while the file is being read—is that the program registers a request
    to read a file with the specified parameters, and then the single Node.js leaves
    it where it is, and attends to other requests. This is very important. Instead
    of blocking and doing nothing while it waits, the program services other needs,
    and after the file operation comes back with the file result (having been busy
    in the meantime tucking in other requests), and then `come from` wherever it is
    and services the callback function provided. It is very hard to accidentally get
    properly used Node.js to block, except with something that burns the CPU, and
    with the current CPU speeds, it is rare for an innocuous request to block the
    CPU so much to be a problem (interested parties can use Node.js to mine bitcoins
    via tools such as those provided at [http://bitcoinjs.org/](http://bitcoinjs.org/),
    but presumably few people worried about their Node.js server being as performant
    as possible will have it mine bitcoin on the side). There is a cluster module
    intended to take advantage of multiple cores where Node.js, by default, runs in
    one single-threaded process on one core. But if you have any doubt about whether
    your use case is extreme enough to need something like cluster to perform Node''s
    performant-by-default structure, you probably don''t need cluster yet.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，fs.readFile()函数调用是设置come from行为的。像其他异步调用一样，它有两个必需的参数：一个基本参数（可能是一个数组），它被传递给fs.readFile()，以及一个回调函数。当调用这个函数时，程序不会阻塞，而是注册一个读取文件的请求，并使用指定的参数，然后Node.js将其留在原地，并处理其他请求。这是非常重要的。程序在等待时不会阻塞和无所事事，而是服务其他需求，文件操作完成后，程序会回到come
    from的位置，并执行提供的回调函数。很难让正确使用的Node.js阻塞，除非使用会占用CPU的东西，而当前的CPU速度很少会因为一个无害的请求而阻塞CPU（有兴趣的人可以使用Node.js通过[http://bitcoinjs.org/](http://bitcoinjs.org/)等工具挖掘比特币，但可能很少有人担心他们的Node.js服务器的性能问题，会让它在一边挖矿）。有一个集群模块旨在利用多个核心，Node.js默认情况下在一个单线程进程上运行在一个核心上。但是，如果你对你的用例是否足够极端需要像集群这样的东西来执行Node的默认性能结构有任何疑问，你可能还不需要集群。
- en: The way Node works (without using cluster, at least) has the additional advantage
    of avoiding concurrency issues, because it is single-threaded and de facto not
    concurrent. This is a very good thing. Concurrency is a slippery, treacherous
    thing to deal with. There are highly proficient programmers who work well with
    concurrency, but overall, concurrency should be considered harmful—a sort of Pandora's
    Box that perennially confuses most normal programmers. There may be a reason to
    consider purely functional languages using immutable data to be a separate case
    as far as concurrency goes, but here we will stick to saying that it is good that
    Node.js can, by default, handle an enormous number of requests without requiring
    the developer to cope with slippery concurrency difficulties.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node的工作方式（至少不使用集群）还有一个额外的优势，即避免并发问题，因为它是单线程的，事实上不是并发的。这是一件非常好的事情。并发是一个棘手、危险的问题。有高度熟练的程序员擅长处理并发，但总的来说，并发应该被视为有害的一种东西，一种经常让大多数普通程序员感到困惑的潘多拉魔盒。也许有理由认为使用不可变数据的纯函数语言在并发方面是一个单独的情况，但在这里我们将坚持认为Node.js默认情况下可以处理大量请求，而不需要开发人员应对棘手的并发问题是件好事。
- en: The second argument given to `fs.readFile()` is optional, and `fs.readFile()`
    allowing it is a little unusual. Normal asynchronous calls look like identifier(data,
    callback). In this case, the second, optional argument is worth a closer look.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 给fs.readFile()的第二个参数是可选的，fs.readFile()允许它是有点不寻常的。正常的异步调用看起来像identifier(data,
    callback)。在这种情况下，第二个可选参数值得更仔细地研究。
- en: The argument is what encoding to use to make a string from an array of bytes,
    and the argument given is the normal default encoding, `'utf-8'`, although there
    is a slight temptation here to fall back, in this case on `'ascii'`. This is particularly
    because Unix `/etc/passwd` files precede `UTF-[anything]` by decades. But we will
    be good netizens and use `'utf-8'`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数是用来从字节数组中创建字符串的编码，给定的参数是正常的默认编码，'utf-8'，尽管在这种情况下有一点诱惑，可以回退到'ascii'。这是因为Unix的/etc/passwd文件比UTF-[anything]早几十年。但我们将成为良好的网民并使用'utf-8'。
- en: The behavior would probably be similar, in our case, between using UTF-8 and
    ASCII encoding. The output will, in fact, be identical if `/etc/passwd` is like
    many `/etc/passwd` files over the years in containing ASCII characters alone and
    possibly supporting ASCII characters alone. But either of them will be a different
    beast by not specifying some encoding. Without further changes, the callback will
    be given in bytes rather than any JavaScript string in the ordinary sense. And
    here, we have a hint of something big about Node.js.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，使用UTF-8和ASCII编码的行为可能是相似的。实际上，如果/etc/passwd文件像多年来许多/etc/passwd文件一样只包含ASCII字符，可能仅支持ASCII字符，输出将是相同的。但是，如果不指定某种编码，它们中的任何一个都将是一个不同的东西。没有进一步的更改，回调将以字节而不是普通意义上的JavaScript字符串给出。在这里，我们可以看到Node.js的一些重要特点。
- en: There has been an arms race for the fastest JavaScript engine among browsers,
    and Node.js took a release of Google Chrome's V8 engine (forks of Node.js may
    use something newer), and extended it in certain ways, so that it would be able
    to function as a general-purpose runtime environment, including being well-adapted
    to serving as a web server. This included adding several extensions that don't
    exist in client-side web browser JavaScript. The ability to handle sockets as
    a server was one example, and this, along with I/O, was brilliantly developed
    along an asynchronous model, as discussed earlier.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，有一个最快的JavaScript引擎之间的竞争，Node.js采用了Google Chrome的V8引擎的一个版本（Node.js的分支可能使用更新的版本），并在某些方面进行了扩展，以便能够作为通用的运行时环境，包括作为Web服务器。这包括添加了一些在客户端Web浏览器JavaScript中不存在的扩展。处理套接字作为服务器就是一个例子，这个功能以及I/O都是以前讨论过的异步模型的杰出发展。
- en: 'Another gap has to do with binary data. The standard browser JavaScript, at
    the time of writing this book, doesn''t really provide a direct way to deal with
    binary data. While there may be obvious work of handling binary data behind the
    scenes in the following code, there is no clear way to say "I want 128 (octet)
    bytes of alternating 1s and 0s, starting with a 1":'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个差距与二进制数据有关。在撰写本书时，标准浏览器JavaScript实际上并没有直接处理二进制数据的方法。虽然在下面的代码中可能有处理二进制数据的明显工作，但没有明确的方法来表示“我想要128（八位）字节的交替1和0，以1开头”：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Node.js extends V8's capabilities to handle proper binary data, and tried and
    true JSON is complemented with the new and binary-friendly BSON. The handling
    of binary data is low-level, possibly too low-level for its C-like character.
    For example, a productivity boost and decrease in frustration comes when a C programmer
    switches completely from using `malloc()` ("memory allocate") to using `calloc()`
    ("cleared memory allocate"). The `malloc()` function allocates a raw block of
    memory with whatever detritus was left over from the memory's previous occupant,
    leading to strange and wickedly magical effects if you fail to properly initialize
    any portion of the memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js扩展了V8的功能以处理适当的二进制数据，并且经过试验和验证的JSON与新的二进制友好的BSON相辅相成。处理二进制数据是低级的，可能对于其类似C的特性来说太低级了。例如，当C程序员完全从使用`malloc()`（“内存分配”）切换到使用`calloc()`（“清除内存分配”）时，就会提高生产力并减少挫败感。`malloc()`函数分配了一个原始的内存块，其中包含了来自内存先前占用者的任何残留物，如果你没有正确初始化内存的任何部分，就会导致奇怪和神奇的效果。
- en: The `calloc()` function allocates a raw block of memory and clobbers any previous
    content with zeroes. Remember Pete Hunt's words, "I'd rather be predictable than
    right?" Stopping ever using `malloc()` directly again in favor of `calloc()` is
    a major way in which C programmers can opt to be predictable rather than right.
    However, out of misguided optimization concerns (it is a fraction of a second
    faster not to wipe the allocated byte memory), Node.js offers the equivalent of
    a C `malloc()` only, without any furnished `calloc()` equivalent, as far as I
    can tell. Fortunately, Node.js JavaScript (or C, for that matter) is so powerful
    that it is a straightforward exercise to port the `calloc()` functionality. Just
    make a wrapper that handles everything that the Node.js byte allocation handles,
    follows up by making all bits zeroes, and use this wrapper exclusively when you
    allocate bytes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`calloc()`函数分配了一个原始的内存块，并用零覆盖了任何先前的内容。记住Pete Hunt的话，“我宁愿是可预测的，也不愿意是正确的？”停止直接使用`malloc()`而转而使用`calloc()`是C程序员可以选择可预测而不是正确的主要方式。然而，出于错误的优化考虑（不擦除分配的字节内存会快上几分之一秒），Node.js只提供了C
    `malloc()`的等价物，没有提供任何`calloc()`的等价物，据我所知。幸运的是，Node.js的JavaScript（或者说C）是如此强大，以至于很容易移植`calloc()`功能。只需制作一个处理Node.js字节分配处理的包装器，然后使所有位都为零，并且在分配字节时专门使用这个包装器。'
- en: 'Returning to the immediately highlighted code, in Node.js thinking at least,
    reading from a file or from the network does not return a string. It returns binary
    bytes. Now those bytes may be easily convertible via a given encoding, and if
    you furnish the encoding you want, `fs.readFile()` will give you a proper string,
    not just bytes. But let''s look at some code similar to what we had earlier. Node.js,
    like many good environments, offers a **Read-Eval-Print-Loop** (**REPL**) to try
    things out (invoking the node executable without any following arguments will
    activate the REPL). From the REPL:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回到刚刚突出显示的代码，在Node.js的思维中，从文件或网络中读取的不是字符串，而是二进制字节。现在这些字节可能很容易通过给定的编码进行转换，如果你提供了想要的编码，`fs.readFile()`将给你一个合适的字符串，而不仅仅是字节。但让我们看一下与之前类似的一些代码。Node.js，像许多良好的环境一样，提供了一个**读取-求值-打印-循环**（**REPL**）来尝试一些东西（调用node可执行文件而不跟随任何参数将激活REPL）。从REPL：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The various bytes in the file are represented in hexadecimal code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的各个字节用十六进制代码表示。
- en: 'Returning to our last code sample, the `function(err, data)` callback signature
    is the normal callback signature for the programming contract. The callback should
    be eventually called, and perhaps called very quickly. This should be done with
    either a "truthy" `err`, in which case the callback should optionally take steps
    to respond to any information contained in the error feedback, and non-optionally
    return without going further, or a null err, in which case the function''s precondition
    is met and the callback should take whatever action is appropriate to receive
    the data that was requested. The preceding code illustrates the pattern: check
    for null `err`, optionally act on it by logging diagnostics, and print the file
    contents if err is null.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们上一个代码示例，`function(err, data)`回调签名是编程合同的正常回调签名。回调应该最终被调用，可能非常快地被调用。这应该通过一个“真值”`err`来完成，如果是这种情况，回调应该选择性地采取步骤来响应错误反馈中包含的任何信息，并且在不进一步进行的情况下无条件返回，或者一个空的err，在这种情况下，函数的前提条件得到满足，回调应该采取适当的行动来接收所请求的数据。前面的代码说明了这种模式：检查空的`err`，选择性地通过记录诊断信息对其进行操作，并且如果err为空，则打印文件内容。
- en: Warning – Node.js and its ecosystem are hot, and hot enough to burn you badly!
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警告 - Node.js及其生态系统很热，热得足以严重伤害你！
- en: 'When I was a teacher''s assistant, one of the nonobvious suggestions I was
    told was not to tell a student that something was "easy." The reason was somewhat
    obvious in retrospect: if you tell people that something is easy, someone who
    doesn''t see a solution may end up feeling (even more) stupid, because not only
    do they not get how to solve the problem, but also the problem that they are too
    stupid to understand is an easy one!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我是一名助教时，有一个不那么明显的建议是不要告诉学生某件事“很容易”。事后想来原因有些明显：如果你告诉别人某件事很容易，那么那些看不到解决方案的人可能会感到（更加）愚蠢，因为他们不仅不知道如何解决问题，而且他们无法理解的问题是一个很容易的问题！
- en: There are gotchas that don't just annoy people coming from Python/Django, which
    immediately reloads the source if you change anything. With Node.js, the default
    behavior is that if you make one change, the old version continues to be active
    until the end of time or until you manually stop and restart the server. This
    inappropriate behavior doesn't just annoy Pythonistas; it also irritates native
    Node.js users who provide various workarounds. The StackOverflow question "Auto-reload
    of files in Node.js" has, at the time of this writing, over 200 upvotes and 19
    answers; an edit directs the user to a nanny script, node-supervisor, with homepage
    at [http://tinyurl.com/reactjs-node-supervisor](http://tinyurl.com/reactjs-node-supervisor).
    This problem affords new users with great opportunity to feel stupid because they
    thought they had fixed the problem, but the old, buggy behavior is completely
    unchanged. And it is easy to forget to bounce the server; I have done so multiple
    times. And the message I would like to give is, "No, you're not stupid because
    this behavior of Node.js bit your back; it's just that the designers of Node.js
    saw no reason to provide appropriate behavior here. Do try to cope with it, perhaps
    taking a little help from node-supervisor or another solution, but please don't
    walk away feeling that you're stupid. You're not the one with the problem; the
    problem is in Node.js's default behavior."
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题不仅令从Python/Django转过来的人感到恼火，Python/Django会在更改任何内容后立即重新加载源代码。而在Node.js中，默认行为是，如果你做了一次更改，旧版本将一直保持活动状态，直到永远或者直到你手动停止并重新启动服务器。这种不恰当的行为不仅令Python程序员感到恼火，也令原生的Node.js用户感到恼火，他们提供了各种解决方法。在StackOverflow上的问题“Node.js中的文件自动重新加载”在我写这篇文章时，已经有超过200个赞和19个答案；一次编辑将用户引导到一个看护脚本，node-supervisor，主页在[http://tinyurl.com/reactjs-node-supervisor](http://tinyurl.com/reactjs-node-supervisor)。这个问题为新用户提供了一个很好的机会，让他们感到愚蠢，因为他们以为已经解决了问题，但旧的错误行为完全没有改变。而且很容易忘记重启服务器；我已经多次这样做了。我想传达的信息是，“不，你不是因为Node.js的这种行为而感到愚蠢；只是Node.js的设计者没有理由在这里提供适当的行为。尽量应对它，也许可以从node-supervisor或其他解决方案中得到一点帮助，但请不要走开时觉得自己很蠢。你不是有问题的人；问题在于Node.js的默认行为。”
- en: 'This section, after some debate, was left in, precisely because I don''t want
    to give an impression of "It''s easy." I cut my hands repeatedly while getting
    things to work, and I don''t want to smooth over difficulties and set you up to
    believe this: getting Node.js and its ecosystem to function well is a straightforward
    matter, and if it''s not straightforward for you too, you don''t know what you''re
    doing. If you don''t run into obnoxious difficulties while using Node.js, that''s
    wonderful. If you do, I would hope that you don''t walk away feeling, "I''m stupid.
    There must be something wrong with me." You''re not stupid if you experience nasty
    surprises dealing with Node.js. It''s not you! It''s Node.js and its ecosystem!'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分经过一些辩论后被保留了下来，正是因为我不想给人留下“这很容易”的印象。在让事情正常运转的过程中，我反复割伤了手，我不想掩盖困难，也不想让你相信：让Node.js及其生态系统正常运行是一件简单的事情，如果对你来说不简单，那就是你不知道自己在做什么。如果你在使用Node.js时没有遇到令人讨厌的困难，那太好了。如果你遇到了，我希望你不要走开时感到“我很蠢。一定是我有问题。”如果你在处理Node.js时遇到了令人讨厌的意外，你并不蠢。不是你的问题！是Node.js及其生态系统的问题！
- en: Next, we will explore a sample project, a remote equivalent of the quick and
    dirty localStorage-based persistence, which was covered in [Chapter 11](ch11.html
    "Chapter 11. Demonstrating Functional Reactive Programming in JavaScript with
    a Live Example Part IV – Adding a Scratchpad and Putting It All Together"), *Demonstrative
    Functional Reactive Programming in JavaScript with a Live Example Part IV – Adding
    a Scratchpad and Putting It All Together*. That was a success, but it was way
    too hard with way too many trip-ups along the way. I have, at times, compared
    Python and JavaScript; but it may be worth a moment to look at why JavaScript's
    Node.js is really nasty compared to Python's Django.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个示例项目，一个远程等效的快速而简单的基于localStorage的持久性，这在[第11章](ch11.html "第11章。用实例演示JavaScript中的函数式响应式编程
    - 添加一个草稿本并把所有内容放在一起")中有所涉及，*用实例演示JavaScript中的函数式响应式编程 - 添加一个草稿本并把所有内容放在一起*。那是一个成功，但在过程中遇到了太多的困难。我有时会比较Python和JavaScript；但也许值得花点时间看看为什么JavaScript的Node.js与Python的Django相比确实很讨厌。
- en: 'My first experience with Django, after years of experience, was a feeling that
    it was a brilliant power tool that, for some strange reason, had accidentally
    not been enshrined in Python''s standard library. Now, in fact, there is excellent
    reason for this, and one that need criticize neither Python nor Django: as Python''s
    Benevolent Dictator for Life observed, you put something into the standard library
    when it is "dead," not when it is still growing. Django is still growing and it''s
    still getting better. Therefore, Django does not belong in the standard library
    for Python no matter how good it is.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我对Django的第一次体验，经过多年的经验后，感觉它是一个很棒的强大工具，但出于某种奇怪的原因，它不小心没有被纳入Python的标准库。事实上，这是有充分理由的，既不需要批评Python也不需要批评Django：正如Python的终身独裁者所观察到的那样，当某样东西“死”了，而不是当它仍在成长时，你才把它放入标准库。Django仍在成长，它仍在变得更好。因此，无论它有多好，Django都不属于Python的标准库。
- en: 'There is, for many contexts, a principle of least astonishment, and once you
    start to know Python well, it does not give you unpleasant surprises too often.
    Django does come with some surprises, such as its templating system, which at
    the time of ASP and JSP was a striking proposition. (Now it has had its 15 minutes
    of fame, and even Python/Django developers start off by replacing the templating
    system with something more powerful. It was entirely the right choice for ReactJS
    to essentially do the opposite.) But paradoxically, both Django and ReactJS offered
    templating that reflected a genius from Mars technique, as defined in The New
    Hacker''s Dictionary:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情境中，有一个最少惊讶原则，一旦你开始熟悉Python，它就不会经常给你带来不愉快的惊喜。Django确实会带来一些惊喜，比如它的模板系统，在ASP和JSP时代是一个引人注目的提议。（现在它已经过了它的15分钟的荣耀，即使是Python/Django开发人员也开始用更强大的东西替换模板系统。ReactJS基本上做了相反的选择是完全正确的。）但矛盾的是，Django和ReactJS都提供了反映了火星技术的模板，如《新黑客词典》中定义的：
- en: '*[TMRC] A visionary quality which enables one to ignore the standard approach
    and come up with a totally unexpected new algorithm. An attack on a problem from
    an offbeat angle that no one has ever thought of before, but in retrospect makes
    perfect sense. Compare grok, zen.*'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*[TMRC]一种具有远见卓识的品质，使人能够忽略标准方法，提出完全意想不到的新算法。从一个离奇的角度攻击问题，以前没有人想到过，但事后看来是完全合理的。比较grok，zen。'
- en: Working with Node.js doesn't feel anything like working with Python, or even
    like working with ReactJS. It is more frustrating, is more difficult, and has
    more things that don't make sense.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js的感觉与使用Python甚至与使用ReactJS完全不同。它更令人沮丧，更困难，而且有更多不合理的事情。
- en: 'Here is one example: at the time of the initial research, I intended to use
    passport.js to offload the dirty work of authentication. I originally meant to
    use Facebook authentication, but the instructions involved creating something
    on the Facebook developer site, and taking down information from the Facebook
    application. And even after exploring the Facebook developer site and asking,
    "passport.js says to get XYZ information from my application on the Facebook developer
    site," I completely failed to obtain any timely answer.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：在最初的研究时，我打算使用passport.js来卸载身份验证的脏活。我最初打算使用Facebook身份验证，但说明涉及在Facebook开发者网站上创建一些东西，并从Facebook应用程序中获取信息。即使在探索Facebook开发者网站并询问后，“passport.js说要从Facebook开发者网站上的我的应用程序获取XYZ信息”，我完全没有得到及时的答复。
- en: Scaling back my ambitions, I decided to use the most basic proper authentication
    from passport.js—username and password—until I learned that what was provided
    as username and password support was almost entirely useless.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小我的野心，我决定使用passport.js最基本的适当身份验证——用户名和密码——直到我发现提供的用户名和密码支持几乎完全没有用。
- en: 'The reason it is useless is that just as **Create, Read, Update, Destroy**
    (**CRUD**) offers an enumeration of basic responsibilities—bases that need to
    be covered in any serious and complete tool for handling data and records (whether
    it is an SQL database, any stripe of a NoSQL database, pickled data saved in a
    programming environment, an editor, or an e-mail client)—there is a basic set
    of bases that need to be covered in mainstream account management, whether username/password
    or any newer and gentler alternative to making users keep track of yet another
    login and password. While individual sites may opt out of certain functionality,
    repeated and basic functionality that provide the CRUD of account management includes
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它无用的原因是，正如**创建，读取，更新，销毁**（CRUD）提供了基本责任的列举——任何处理数据和记录的严肃和完整工具都需要涵盖的基础（无论是SQL数据库，任何一种NoSQL数据库，保存在编程环境中的pickled数据，编辑器或电子邮件客户端）——在主流帐户管理中有一组基本的基础需要涵盖，无论是用户名/密码还是任何新的更温和的让用户跟踪另一个登录和密码的替代方案。虽然个别网站可能选择退出某些功能，但提供帐户管理的CRUD的重复和基本功能包括以下内容：
- en: Allowing users to create new accounts
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户创建新帐户
- en: Allowing users to log in with an existing account
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户使用现有帐户登录
- en: Replacing a lost password without an unencrypted password being e-mailed to
    the user
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换丢失的密码，而不会将未加密的密码通过电子邮件发送给用户
- en: Possibly an extended set of features for a site's administrative members, such
    as account moderation (if desired), locking and unlocking accounts, and account
    deletion
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是网站管理成员的一组扩展功能，如帐户管理（如果需要），锁定和解锁帐户，以及帐户删除。
- en: The only one of these bases covered by passport.js's functionality is logging
    in with an already existing account, created by some means that I have not been
    able to ascertain, and being successfully or unsuccessfully authenticated. Perhaps
    the only thing more pathologically incomplete in terms of a CRUD was offered in
    the April 1 issue of Byte magazine some decades ago, when someone advertised an
    exceptionally good deal on write-only memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: passport.js功能中唯一涵盖的基础是使用已经存在的帐户登录，由我无法确定的某种方式创建，并成功或不成功地进行身份验证。也许在CRUD方面唯一更加病态不完整的事情是几十年前在Byte杂志的4月1日问题中提供的，当时有人宣传了一个非常划算的只读存储器。
- en: 'Now we might note in passing that supporting 100 percent of CRUD is not, strictly
    speaking, the only possible approach. Years ago, **Write Once, Read Many** (**WORM**)
    disk drives spent some time in the limelight. While there is possibly no modern
    laptop that has shipped with a genuine WORM drive, ClojureScript includes an extraordinary
    amount of effort to offer WORM data. WORM, in this context, means that data is
    designed to exclude Updating (although you can make modified copies easily enough),
    and Deletion is reserved to garbage collection: out of full CRUD support, ClojureScript''s
    WORM data only allows unimpaired Creation and Reading of data. ClojureScript reflects
    a carefully thought-out decision to offer WORM data in a context where full CRUD
    support would have been considerably easier. This decision now deserves obvious
    respect.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可能会注意到，支持100％的CRUD并不是唯一可能的方法。多年前，“写一次，读多次”（WORM）磁盘驱动器曾经引起了一些关注。虽然可能没有现代笔记本电脑配备真正的WORM驱动器，但ClojureScript包括了大量的工作来提供WORM数据。在这种情况下，WORM意味着数据被设计为排除更新（尽管您可以很容易地制作修改后的副本），并且删除被保留到垃圾回收：在完全支持CRUD的情况下，ClojureScript的WORM数据只允许无损地创建和读取数据。ClojureScript反映了一个经过深思熟虑的决定，在这种情况下提供WORM数据会更容易实现完全的CRUD支持。这个决定现在值得明显的尊重。
- en: Now, the lack of an equivalent of full CRUD support is not the end of the world
    for authentication, as at least one other group has approached "authentication
    CRUD" more appropriately. Stormpath advertises offerings for Node, Python, Java,
    and REST. One of their developers rewrote my code for authentication for me to
    use their system. While this may just be being nice to an author who might cover
    their product, Stormpath inclusion isn't even a proper integration challenge;
    it's really simple. Now it should be stated for the record that Stormpath is not
    open source, but a SaaS with freemium pricing. The full-featured, free, and "no
    credit card required" developer tier has a quota of 100,000 API calls per month,
    and they estimate user logins as using about three API calls. They definitely
    have a profit motive, but if you have enough traffic for you to need a paid tier
    of service, you shouldn't care about the trifle you have to pay them. The system
    gives an overall impression of being a bit young, with people working out the
    remaining kinks, but it has happened that someone told them politely about something
    that was immature, and the problem was resolved quickly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于身份验证来说，缺乏等同于完全CRUD支持并不是世界末日，因为至少还有另一组人更适当地处理了“身份验证CRUD”。Stormpath为Node、Python、Java和REST提供了广告服务。他们的一名开发人员为我重写了身份验证的代码，以便我使用他们的系统。虽然这可能只是对可能涵盖他们产品的作者的友好表示，但Stormpath的包含甚至不是一个适当的集成挑战；它真的很简单。现在应该声明一下，Stormpath不是开源的，而是一个带有免费定价的SaaS。全功能、免费且“无需信用卡”的开发者层每月有10万次API调用的配额，他们估计用户登录大约使用三个API调用。他们肯定有盈利动机，但如果您的流量足够大，需要付费服务层，您不应该在乎您必须支付给他们的小事。该系统给人的整体印象有点年轻，人们正在解决剩下的问题，但确实有人礼貌地告诉他们有些不成熟的地方，问题很快就解决了。
- en: Another basic difficulty surrounds databases. There's a good case to be made
    that MongoDB is important, and together with the "access MongoDB from Node.js"
    package of mongoose, it is worth the learning curve. In preparation for this chapter,
    top-of-search tutorials proved to explain how to create a Schema and save something
    in it, but left guesswork as to how to usefully approach a database where all
    the necessary schemas already exist. Subsequent work turned up an existing Stack
    Overflow solution that appeared to cover database CRUD with a database with already
    existing schemas and databases. I may have come within an inch of pay dirt before
    giving up, but I intended to use mongoose/MongoDB for its database work almost
    from the beginning, and I have not yet attained proficiency.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本困难围绕着数据库。可以说MongoDB很重要，再加上mongoose的“从Node.js访问MongoDB”包，值得学习曲线。在准备本章时，搜索排名靠前的教程证明了如何创建模式并保存其中的内容，但对如何有用地处理已经存在的所有必要模式的数据库留下了猜测。随后的工作发现了一个现有的Stack
    Overflow解决方案，似乎涵盖了具有已经存在的模式和数据库的数据库CRUD。在放弃之前，我可能已经接近成功，但我打算从一开始就使用mongoose/MongoDB进行数据库工作，但我还没有达到熟练程度。
- en: Another database that seemed like a perfect fit, and may yet be redeemable,
    is a server-side implementation of the HTML5 key-value store. This approach has
    the cardinal advantage of an API that most good frontend developers understand
    well enough. For that matter, it's also an API that most not-so-good frontend
    developers understand well enough. But with the `node-localstorage` package, while
    `dictionary-syntax` access is not offered (you would want to use `localStorage.setItem(key,
    value)` or `localStorage.getItem(key)`, but not `localStorage[key])`, the full
    localStorage semantics is implemented, including a default 5 MB quota. Why? Do
    server-side JavaScript developers need to be protected from themselves?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个看起来非常合适的数据库，而且可能还有挽回的余地，是HTML5键值存储的服务器端实现。这种方法的主要优势是大多数优秀的前端开发人员都足够了解的API。而且，这也是大多数不那么优秀的前端开发人员都足够了解的API。但是使用`node-localstorage`包时，虽然不提供`dictionary-syntax`访问（您可能想使用`localStorage.setItem(key,
    value)`或`localStorage.getItem(key)`，但不是`localStorage[key]`），但实现了完整的localStorage语义，包括默认的5MB配额。为什么？服务器端JavaScript开发人员需要保护自己吗？
- en: For client-side database capabilities, a 5 MB quota per website is really a
    generous and useful amount of breathing space to let developers work with it.
    You could set a much lower quota and still offer developers an immeasurable improvement
    over limping along with cookie management. A 5 MB limit doesn't lend itself very
    quickly to big data client-side processing, but there is a really generous allowance
    that resourceful developers can use to do a lot. On the other hand, 5 MB is not
    a particularly large portion of most disks purchased any time recently. This means
    that if you and a website disagree about what the reasonable use of disk space
    is, or if a site is simply hoggish, it does not really cost you much and you are
    in no danger of a swamped hard drive, unless your hard drive was already too full.
    We may be better off if the balance were a little less, or a little more, but
    overall it's a decent solution for addressing the intrinsic tension with respect
    to a client-side context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端数据库功能来说，每个网站的5MB配额确实是一个慷慨而有用的呼吸空间，让开发者可以更好地使用它。你可以设置一个更低的配额，仍然可以为开发者提供比使用cookie管理更好的改进。5MB的限制并不适合快速进行大数据客户端处理，但对于有资源的开发者来说，这是一个非常慷慨的允许，可以做很多事情。另一方面，5MB对于最近购买的大多数磁盘来说并不是一个特别大的部分。这意味着如果你和一个网站对于磁盘空间的合理使用意见不一致，或者一个网站只是贪婪，这并不会让你花费太多，你也不会有硬盘被淹没的危险，除非你的硬盘已经太满了。也许我们最好的平衡是更少一点，或者更多一点，但总的来说，这是一个相当不错的解决方案，可以解决客户端环境中的内在紧张关系。
- en: However, it might gently be pointed out that when you are the one writing code
    for your server, you don't need any additional protection from making your database
    more than a tolerable 5 MB in size. Most developers will neither need nor want
    tools acting like nannies and protecting them from storing more than 5 MB of server-side
    data. Also, this 5 MB quota, which is a golden balancing act on the client side,
    is rather a bit silly on a Node.js server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能要温和地指出，当你自己为服务器编写代码时，你不需要额外的保护来使你的数据库超过5MB的容量。大多数开发者既不需要也不希望工具像保姆一样保护他们免于存储超过5MB的服务器端数据。此外，这个5MB的配额，在客户端是一个黄金的平衡，但在Node.js服务器上却有点傻。
- en: Moreover, for a database for multiple users—such as is covered in this appendix—it
    might be pointed out, slightly painfully, that it's not 5 MB per user account,
    unless you create a separate database for list on each account. It is 5 MB shared
    between all user accounts together. This could get painful if you go viral!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于多用户的数据库，可能会有点痛苦地指出，这不是每个用户账户5MB，除非你为每个账户创建一个单独的数据库列表。这是5MB在所有用户账户之间共享。如果你爆发了，这可能会很痛苦！
- en: 'The documentation states that the quota is customizable, but an e-mail a week
    ago to the developer asking how to change the quota is unanswered, as was a Stack
    Overflow question asking the same thing. The only answer I have been able to find
    is in the GitHub CoffeeScript source, where it is listed as an optional second
    integer argument to a constructor. This is easy enough, and you can specify a
    quota equal to the disk or partition size. But besides porting a feature that
    does not make sense, the tool''s author has also completely failed to follow a
    very standard convention of interpreting 0 as "unlimited" for a variable or function
    wherein an integer is to specify the maximum limit for the concerned resource
    use. The best thing to do with this disfeature is probably to specify that the
    quota is infinity:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文档说明配额是可定制的，但一周前给开发者的电子邮件询问如何更改配额没有得到回复，同样的问题也在Stack Overflow上提问了，也没有得到答复。我唯一找到的答案是在GitHub的CoffeeScript源代码中，它被列为构造函数的可选第二个整数参数。这很容易，你可以指定一个与磁盘或分区大小相等的配额。但除了移植一个没有意义的功能之外，工具的作者还完全没有遵循一个非常标准的约定，即将0解释为“无限制”，用整数来指定相关资源使用的最大限制。对于这个缺陷，最好的做法可能是指定配额为无限大：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A similar amateur roughness kept cropping up in elements that surfaced in my
    research. Express.js is of a higher level than Node.js, but in terms of ways of
    shooting yourself in the foot, Node.js is closer to offering C's way than any
    other technology I have used recently. C is for those who prefer to load their
    own rounds before shooting themselves in the foot.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的研究中，这种类似业余的粗糙性不断出现。Express.js比Node.js更高级，但就自毁的方式而言，Node.js更接近于提供C的方式，而不是我最近使用的任何其他技术。C是为那些更喜欢在开枪前装载自己的子弹的人准备的。
- en: A sample project – a server for our Pragmatometer
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例项目 - 为我们的Pragmatometer提供服务器
- en: Let's work toward a simple project. We will create a generic server backend
    that can serve a modification of the Pragmatometer project covered in the last
    chapters of this book, which handled persistence by saving and restoring from
    a few JSON strings locally in HTML5 localStorage. We will work on a server that
    can provide static content, like what has already been developed, provide an API
    to save or restore a string and an identifying key, and handle basic authentication
    and account management. The client-side programming should be barely more interesting
    than it was before, essentially by swapping saving to localStorage to saving to
    our remote Node.js server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们朝着一个简单的项目努力。我们将创建一个通用的服务器后端，可以为本书最后几章中涉及的Pragmatometer项目提供修改，该项目通过在HTML5的本地存储中保存和恢复几个JSON字符串来处理持久性。我们将致力于开发一个可以提供静态内容的服务器，提供一个API来保存或恢复一个字符串和一个标识键，并处理基本的身份验证和账户管理。客户端编程应该比以前更有趣，基本上是通过将保存到本地存储更换为保存到我们的远程Node.js服务器。
- en: We will work with several technologies. The most attention will be given to
    working within Express.js compared to, for instance, Stormpath. Stormpath appears
    not to have taken credit for inventing something fundamentally new, original,
    or stunning, or for a breakthrough in an authentication mechanism. They might
    perhaps take credit for solving a well-known problem in such a way that a large
    chunk of busy work will be taken off your plate. Adding Stormpath is small and
    unobtrusive. Most users will not use it as a platform to build some great work
    on top of. Consequently, we will give significant attention to Express.js (and
    getting our client to talk to Express.js), which is a platform to work with. On
    the framework's site, Express.js is promoted as a "fast, unopinionated web framework
    for Node.js." They pretty much deliver what they boast of.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用多种技术。最关注的将是在Express.js中工作，与例如Stormpath相比。Stormpath似乎没有因发明基本新的、原创的或令人惊叹的东西，或者因身份验证机制的突破而获得赞誉。他们可能会因以一种使大量繁重工作减轻你的负担的方式解决了一个众所周知的问题而获得赞誉。添加Stormpath是小而不显眼的。大多数用户不会将其用作构建一些伟大工作的平台。因此，我们将重点关注Express.js（以及让我们的客户端与Express.js通信），这是一个可以使用的平台。在框架的网站上，Express.js被宣传为“Node.js的快速、不受限制的Web框架”。他们基本上实现了他们吹嘘的东西。
- en: We will need to build a server, but also alter the client side for the Pragmatometer
    project in chapter 8 to chapter 11 There are `save()` and `restore()` functions,
    and they will be altered and expanded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一个服务器，但也需要修改第8章到第11章中Pragmatometer项目的客户端。有`save()`和`restore()`函数，它们将被修改和扩展。
- en: Install Express.js via `npm install express`. Then create an express project
    using `express [the directory name for your project]`. You will have a framework
    fleshed out. You can add packages to the `package.json` file, and run `npm install`
    to populate your local copy. There will be a public or static directory that you
    can make available, and `routes/index.js` handles routing in a way that people
    who know other frameworks may feel like home.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`npm install express`安装Express.js。然后使用`express [项目的目录名]`创建一个express项目。你将会有一个完整的框架。你可以向`package.json`文件添加包，并运行`npm
    install`来填充你的本地副本。将会有一个公共或静态目录可以使用，并且`routes/index.js`以其他框架熟悉的方式处理路由。
- en: Client-side preparations
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端准备工作
- en: Everything that was under the `js/` directory in chapter 8 to chapter 11 is
    moved to `public/javascripts`. The full details of the changes will be posted
    on the website. Here, we adapt the `save()` and `restore()` functions from being
    (client-side) localStorage-specific to retaining localStorage for a slight perceived
    speed boost, but restore from and save to a remote server. In this case, the server
    is a Node.js server built with Express.js, but it could essentially be any server
    serving the same, simple, and implicit API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章到第11章中`js/`目录下的所有内容都移动到`public/javascripts`。更改的完整细节将发布在网站上。在这里，我们将`save()`和`restore()`函数从（客户端）特定于localStorage的功能改为保留localStorage以获得轻微的感知速度提升，但从远程服务器恢复和保存。在这种情况下，服务器是使用Express.js构建的Node.js服务器，但基本上可以是任何提供相同、简单和隐式API的服务器。
- en: 'Ordinarily, with ReactJS, an object''s state is set within a `setInitialState()`
    call. Theoretically, we can preserve the relevant semantics by loading with the
    synchronous equivalent of an Ajax call, but it''s also possible to populate a
    stub and then make available a callback that will really set things in motion.
    The function used to populate an object''s state upon successful return from an
    Ajax call is `populate_state()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用ReactJS，对象的状态是在`setInitialState()`调用中设置的。理论上，我们可以通过加载同步等效的Ajax调用来保留相关的语义，但也可以填充一个存根，然后提供一个真正启动事情的回调。用于在从Ajax调用成功返回时填充对象状态的函数是`populate_state()`。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `restore()` function is slightly complex, but that''s because it is written
    to build perceived layers of responsiveness. It makes an Ajax call, setting a
    state as initialized and marking `state.initialized` as `false`. It also restores
    from JSON (if anything has been saved). Its check of whether localStorage is available,
    and graceful degradation if it isn''t, is probably historical, as ReactJS is only
    claimed to work with browsers (IE8 and higher) that offer localStorage. Nonetheless,
    it provides an example of how we might go about graceful degradation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`restore()`函数略微复杂，因为它被编写成构建感知层的响应。它进行了一个Ajax调用，设置一个状态为初始化，并将`state.initialized`标记为`false`。它还从JSON中恢复（如果有保存的内容）。它检查localStorage是否可用，并且如果不可用，则优雅地降级，这可能是历史性的，因为ReactJS只声称与提供localStorage的浏览器（IE8及更高版本）一起工作。尽管如此，它提供了一个我们如何进行优雅降级的例子。'
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As a limitation of scope, neither the implementation of the `restore()` function
    in the preceding code, nor the `save()` function in the following code address
    resilience in the face of a failed Ajax call (or calls). One way of addressing
    this concern is to check for failure and keep retrying, with exponentially increasing
    delays between retries to be a good netizen and not add persistent heavy traffic
    to the network. This pattern is followed (roughly) at a high level by Gmail and
    at a low level baked into TCP/IP. For our implementation, anything that a failed
    Ajax call might not have conveyed should be available afresh in the key-value
    store, unless there has been a subsequent update, in which case both changes will
    usually be saved.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为范围的限制，前面代码中`restore()`函数的实现，以及后面代码中的`save()`函数都没有处理在失败的Ajax调用（或调用）中的弹性。解决这个问题的一种方法是检查失败并保持重试，随着重试之间的延迟呈指数增长，以成为一个良好的网络公民，不会给网络增加持久的重负载。这种模式在高层次上大致上被Gmail遵循，在TCP/IP中也被内置。对于我们的实现，任何一个失败的Ajax调用可能没有传达的内容应该在键值存储中重新可用，除非有后续更新，这种情况下通常会保存两个更改。
- en: 'The `save()` function is slightly simpler, but it represents the other side
    of a coin: make an Ajax call to save/restore, and save to and restore from localStorage
    as an approximation before it is available:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`函数稍微简单一些，但它代表了另一面：进行Ajax调用以保存/恢复，并在可用之前将其保存到和从localStorage中恢复：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While we are pulling stuff from localStorage, we try to prevent the user from
    being able to enter data. This is because under unpredictable race conditions,
    this data gets clobbered when data from Ajax calls comes back. In other words,
    the user is blocked from adding any input until data is restored from Ajax (even
    if a value has already been restored from localStorage). This means, in particular,
    that submit buttons are disabled, and for now, the only application for which
    the callback function is given to `restore()` is for enabling submit buttons that
    have been disabled. For the calendar, the `render()` method has a disabled **Submit**
    button (you can be more purist and disable all the input fields, but disabling
    the **Submit** button is enough to prevent user data from being clobbered by race
    conditions):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从localStorage中拉取东西时，我们试图阻止用户能够输入数据。这是因为在不可预测的竞争条件下，当来自Ajax调用的数据返回时，这些数据会被覆盖。换句话说，用户被阻止添加任何输入，直到从Ajax中恢复数据（即使值已经从localStorage中恢复）。这意味着，特别是提交按钮被禁用，目前，给`restore()`的回调函数的唯一应用是启用已被禁用的提交按钮。对于日历，`render()`方法有一个禁用的**提交**按钮（您可以更加纯粹并禁用所有输入字段，但禁用**提交**按钮足以防止用户数据被竞争条件覆盖）：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Calendar''s `getInitialState` function only arranges for a bare stub of
    data to be synchronously put in place. The Ajax call, upon returning, gives it
    a more appropriate value and re-enables the disabled save button, as race conditions
    are no longer a concern here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 日历的`getInitialState`函数只安排了一个简单的数据存根，以同步方式放置。Ajax调用返回后，它会给出一个更合适的值，并重新启用禁用的保存按钮，因为这里不再关注竞争条件：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a few more details on the client side, but they are not particularly
    difficult. For instance, we add a Logout link (positioned with CSS to be at the
    top right), and the JavaScript behavior (without calling the usual `preventDefault()`
    method, because we do not want to prevent the default behavior) of erasing account
    data from the key-value store:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端还有一些细节，但它们并不特别困难。例如，我们添加一个注销链接（使用CSS定位到右上角），并且JavaScript行为（不调用通常的`preventDefault()`方法，因为我们不想阻止默认行为）擦除键值存储中的帐户数据：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The server side
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端
- en: 'When we need packages, we should add them to our `package.json` file. One way
    of doing this is backwards. Perform npm install XYZ and then add a line to the
    `package.json` file under "dependencies," specifying "XYZ": "~1.2.3" and recording
    the version number for the installation. The dependencies presently included are
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要包时，我们应该将它们添加到我们的`package.json`文件中。一种做法是反向进行。执行npm install XYZ，然后在“dependencies”下的`package.json`文件中添加一行，指定“XYZ”:“~1.2.3”，并记录安装的版本号。目前包括的依赖关系如下：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create an account at [https://stormpath.com/](https://stormpath.com/), probably
    a free developer account (unless you know you need more), and specify the various
    details in `app.js`. This setup uses HTML-like EJS over Markdown-like Jade for
    views:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[https://stormpath.com/](https://stormpath.com/)创建一个帐户，可能是一个免费的开发者帐户（除非您知道您需要更多），并在`app.js`中指定各种细节。此设置使用类似HTML的EJS而不是类似Markdown的Jade进行视图：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All but one of the items marked `[Deleted]` are things that you get from your
    setup on Stormpath. Some people have advised trying to be clever in making your
    own secret key; Don''t! Under Mac, Unix, Linux, or Cygwin (Cygwin is freely available
    from [http://cygwin.org](http://cygwin.org) and runs under Windows), pull up Command
    Prompt and type the following line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`[Deleted]`的项目中除了一个都是从Stormpath的设置中获取的。有些人建议在制作自己的秘钥时要聪明一些；不要这样做！在Mac、Unix、Linux或Cygwin（Cygwin可以从[http://cygwin.org](http://cygwin.org)免费获取，并在Windows下运行）下，打开命令提示符并输入以下命令：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will get you a kilobyte of cryptographically strong and random data that
    is encoded to be copy and paste friendly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一千字节的加密强大和随机数据，该数据已编码为易于复制和粘贴。
- en: 'Here''s a note on hygiene: the recommended practice is to be very careful with
    your secret key and, in particular, not to include it in version control. Instead,
    put it into a dot-file directory under your home directory with permissions that
    don''t let anyone else do anything with it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于卫生的注意事项：建议的做法是非常小心地处理您的秘钥，特别是不要将其包含在版本控制中。而是将其放入主目录下的点文件目录中，并设置权限，不让其他人对其进行任何操作。
- en: 'Probably, the one file with the heaviest work in it is `routes/index.js`. We
    pull in several dependencies, including a body parser that will be able to get
    data out of Ajax saves that POST JSON in the body of the request:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，工作量最大的文件之一是`routes/index.js`。我们引入了几个依赖项，包括一个body解析器，它将能够从Ajax保存中获取数据，该数据以POST
    JSON的形式在请求的主体中：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We include localStorage , specifying Infinity as our quota, and then provide
    a sanitizer for characters in keys. This specific sanitizer leaves alphanumeric
    characters intact, which with the rest of the application is sufficient to ensure
    that it doesn''t make key collisions. It also ensures that the characters are
    on a whitelist that excludes colons. This allows us to create keys with names
    similar to `username:component-name`, perform a string split on colons, and always
    get the username in the zeroth slot and a component name in the first slot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括localStorage，指定无限制作为我们的配额，然后为键中的字符提供一个清理器。这个特定的清理器保留字母数字字符，这对于应用程序的其余部分足以确保它不会产生键冲突。它还确保字符在排除冒号的白名单上。这使我们能够创建类似`username:component-name`的键，对冒号进行字符串分割，并始终在零号位置获取用户名和在第一个位置获取组件名称：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The router works in a way that should seem familiar to users who''ve seen routers
    in almost any context before. Although route and non-route functions will be mixed,
    the router is created and connected to the first two routes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器的工作方式应该对以前在几乎任何上下文中看到过路由器的用户来说是熟悉的。虽然路由和非路由函数将被混合使用，但路由器是创建并连接到前两个路由的：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The included `stormpath.loginRequired`, once Stormpath is included, is really
    all that you need to get a view to be login protected. We go ahead to define two
    non-view functions: the functions used to `save()` and `restore()` a key for a
    particular user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含了Stormpath，包含的`stormpath.loginRequired`就是你需要的一切，以便让视图受到登录保护。我们继续定义两个非视图函数：用于`save()`和`restore()`特定用户的键的函数：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We add the routes that will service the POST Ajax requests. If we want to add
    support for GET or other verbs, we can call `router.get()` and the like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了用于处理POST Ajax请求的路由。如果我们想要添加对GET或其他动词的支持，我们可以调用`router.get()`等方法：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then there is a boilerplate line that we keep intact:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有一行样板代码我们保持不变：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also use Express.js''s hierarchy for static data; the revised `index.ejs`
    pulls from a place different from our earlier js/:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用Express.js的层次结构来存储静态数据；修改后的`index.ejs`从与之前的js/不同的位置获取数据：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And that's it! We provide full details in the electronic resource packet. Now
    we have provided a server-side key-value store with account management.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们在电子资源包中提供了详细信息。现在我们已经提供了一个带有账户管理的服务器端键值存储。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When this appendix was being contemplated, one of the questions I considered
    was "JavaScript plus Node.js or Python plus Django?" The focus of this book is
    on a frontend with ReactJS, and the focus on the backend was just to have enough
    to support the frontend. I naturally thought that Python is so easy, even to newcomers,
    and Django also is so easy (again, even to newcomers) that even with the introduction
    of a new language, a basic key-value store with authentication should be an easy
    appendix to read and to write. However, the author thought then that I would go
    the high road of JavaScript plus Node.js, the combination everybody wants in on,
    and I have been paying for his decision not to provide a Python-plus-Django appendix
    ever since.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这个附录时，我考虑过的一个问题是“JavaScript加上Node.js还是Python加上Django？”本书的重点是ReactJS前端，后端的重点只是为了提供足够的支持前端。我自然地认为Python是如此简单，即使对新手来说也是如此，Django也是如此简单（同样，即使对新手来说也是如此），即使引入一种新语言，基本的带有认证的键值存储应该是一个容易阅读和编写的附录。然而，作者当时认为我会选择JavaScript加上Node.js这条高路，这是每个人都想要的组合，自那时起，我一直在为他的决定付出代价，因为他没有提供Python加上Django的附录。
- en: The code provided in a bundle is, of course, freely offered for any mileage
    you can pull from it that won't violate Packt Publishing's licensing. But the
    basic task of implementing a key-value store with account management is perhaps
    of the level of an undergraduate's homework assignment. It does not, in any sense,
    demonstrate the peaks of wonder offered by any server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑提供的代码当然是免费提供的，你可以从中获取任何不违反Packt Publishing许可的里程。但是，实现带有账户管理的键值存储的基本任务可能是本科生的家庭作业水平。从任何方面来看，它都不能展示出服务器所提供的惊人功能。
- en: Now, Node.js really does offer peaks of wonder. These, however, were not explored
    here because the goal was to provide just enough "Node.js plus Express.js" to
    create a server-based adaptation of the Pragmatometer project covered in chapters
    8 to 11\. Moreover, given the degree of enthusiasm and the sheer work hours on
    all projects, it may be warranted in a year, 2 years, or 3 years to sharply temper
    any remarks about an immature ecosystem made at the time of writing this book.
    After 5 years, it may really make sense to say, "The 2015 Node.js ecosystem had
    several minefields. The 2020 Node.js ecosystem has multiple paradises."
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Node.js确实提供了令人惊叹的功能。然而，这些功能在这里没有被探索，因为目标是提供足够的“Node.js加上Express.js”来创建一个基于服务器的Pragmatometer项目的适应版本，该项目在第8到11章中进行了介绍。此外，鉴于对所有项目的热情和大量工作时间，可能有必要在撰写本书时对关于不成熟生态系统的任何评论进行严格的限制，可能需要1年、2年或3年的时间。5年后，可能真的有必要说，“2015年的Node.js生态系统存在一些隐患。2020年的Node.js生态系统有多个乐园。”
- en: But to publish, as passport.js did, to have a simple animation between `passport.authenticate('twitter')`,
    `passport.authenticate('google')`, `passport.authenticate('facebook')`, and so
    on slide by with a quite seductive apparent ease, and then have the user searching
    and asking at length for a passport.js way to handle username-password authentication
    that allowed users to create a new account, doesn't happen. This is extremely
    inappropriate, and it is inappropriate in a way that happened more than once in
    the Node.js ecosystem. The transition between finding a Node.js tool with a slick
    website that seems to offer exactly what you need, and activating "Hello, world!"
    levels of functionality meets perhaps 50 percent success. It represents a gulf
    bigger than I anything have seen in the entire history of the Web.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，像passport.js一样发布，通过`passport.authenticate('twitter')`、`passport.authenticate('google')`、`passport.authenticate('facebook')`等方式简单地实现动画效果，然后让用户长时间搜索和询问如何处理用户名密码认证以允许用户创建新账户，这是不会发生的。这是极其不合适的，而且在Node.js生态系统中发生了不止一次。在找到一个看起来提供了你需要的功能的Node.js工具的网站和激活“Hello,
    world!”级别的功能之间的过渡，成功率也许只有50%。这代表了一个比我在整个Web历史上见过的任何事情都更大的鸿沟。
- en: I can see people thinking, not exactly that I am brilliant because of how I
    made the to-do list with multiple statuses available for each item, but that I
    was practical, and overall the book significantly reduced the amount of legwork
    involved in the readers' getting up to speed with ReactJS. However, I would be
    mystified if people told me that I was brilliant, because I thought of making
    an authenticated key-value store, as covered in this appendix. The achievement
    is not at all because I managed to get some technology to work as an authenticated
    key-value store—which is a task on par with undergraduate homework—but because
    it was accomplished in an environment that exists in continuity with INTERCAL.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以看到人们会认为，不是因为我设计了一个带有多种状态的待办事项清单，而觉得我很聪明，而是因为我很实际，总的来说，这本书大大减少了读者在学习ReactJS时所需的工作量。然而，如果有人告诉我我很聪明，因为我想到了制作一个经过身份验证的键值存储，我会感到困惑，因为这在附录中有所涉及。这个成就并不是因为我设法让某些技术作为一个经过身份验证的键值存储工作——这与本科作业相当——而是因为它是在与INTERCAL连续存在的环境中完成的。
- en: 'People have needlessly shot themselves in the foot by constantly using JavaScript
    as a whole, and crucial to JavaScript being made a respectable language was Douglas
    Crockford saying, in essence:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 人们不断地将自己置于困境中，因为他们不断地将JavaScript作为一个整体来使用，而JavaScript能够成为一门受人尊敬的语言，关键在于道格拉斯·克罗克福德的一句话，本质上是这样说的：
- en: '*"JavaScript as a language has some really good parts and some really bad parts.
    Here are the good parts. Just forget that anything else is there."*'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “JavaScript作为一种语言有一些非常好的部分和一些非常糟糕的部分。这里是好的部分。只要忘记其他的东西存在。”
- en: 'Perhaps the hot Node.js ecosystem will grow its own "Douglas Crockford," who
    will say:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 也许炙手可热的Node.js生态系统将会培养出自己的“道格拉斯·克罗克福德”，他会说：
- en: The Node.js ecosystem is a coding Wild West, but there are some real gems to
    be found. Here's a road map. Here are the areas to avoid at almost any cost. And
    here are the areas with some of the richest pay dirt to be found in any language
    or environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js生态系统就像编码的西部荒野，但也有一些真正的宝藏。这是一张路线图。这些是几乎可以不惜任何代价避免的领域。这些领域是任何语言或环境中可以找到一些最丰富的矿藏的地方。
- en: Perhaps someone else can take these words as a challenge, follow Crockford's
    lead, and write *The Good Parts* and/or *The Better Parts* for Node.js and its
    ecosystem. I'd buy a copy!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也许其他人可以把这些话当作一个挑战，跟随克罗克福德的脚步，为Node.js及其生态系统编写《好的部分》和/或《更好的部分》。我会买一本！
