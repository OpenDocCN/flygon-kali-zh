- en: Chapter 9. Let's Get Our Hands Dirty
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。让我们动手吧
- en: In this chapter, we will look at building a TypeScript single-page web application
    from the ground up. We will start with a discussion on what the site should look
    like, how we want our page transitions to flow, and then move on to expore the
    capabilities of the Bootstrap framework, and discuss a pure HTML version of our
    site. Our focus will then switch to the data structures that we will need for
    our application, and what Backbone models and colllections we need to represent
    this data. Along the way, we will write a set of unit and integration tests for
    these models and collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头开始构建一个TypeScript单页Web应用程序。我们将从讨论网站应该是什么样子开始，我们希望我们的页面转换如何流动，然后转向探索Bootstrap框架的功能，并讨论我们网站的纯HTML版本。我们的重点将转向我们应用程序所需的数据结构，以及我们需要用来表示这些数据的Backbone模型和集合。在此过程中，我们将为这些模型和集合编写一组单元和集成测试。
- en: Once we have data to work with, we will then use the **Marionette** framework
    to build views in order to render our application to the DOM. We will then show
    how to break up our pure HTML version of the site into smaller portions of HTML
    snippets, and then integrate these snippets with our Marionette views. Finally,
    we will tie the application together using events, and explore the **State** and
    **Mediator** Design Pattern to help us manage complex page transitions and DOM
    elements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了要处理的数据，我们将使用**Marionette**框架来构建视图，以将我们的应用程序呈现到DOM中。然后，我们将展示如何将我们网站的纯HTML版本分解为HTML片段的较小部分，然后将这些片段与我们的Marionette视图集成。最后，我们将使用事件将应用程序联系在一起，并探讨**State**和**Mediator**设计模式，以帮助我们管理复杂的页面转换和DOM元素。
- en: Marionette
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marionette
- en: Marionette is an extension of the Backbone library, and introduces a number
    of enhancements to the framework, in order to reduce boilerplate Backbone code,
    and make working with DOM elements and HTML fragments easier. Marionette also
    introduces the concept of layouts and regions to help with managing logical portions
    of HTML within a large web page. A Marionette layout is a type of controller that
    manages several regions, and a Marionette region is an object that manages a particular
    HTML portion of our page. As an example, we could have a region for the header
    panel, one for a side-bar panel, and another for a footer area. This allows us
    to break up our application into logical areas, and then tie them together through
    messaging.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette是Backbone库的扩展，引入了一些增强功能，以减少样板Backbone代码，并使处理DOM元素和HTML片段更容易。Marionette还引入了布局和区域的概念，以帮助管理大型网页中的逻辑部分。Marionette布局是一种管理多个区域的控制器，而Marionette区域是管理我们页面上特定HTML部分的对象。例如，我们可以为标题面板设置一个区域，为侧边栏面板设置一个区域，为页脚区域设置另一个区域。这使我们能够将应用程序分解为逻辑区域，然后通过消息将它们联系在一起。
- en: Bootstrap
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap
- en: We will also be using Bootstrap to help with our page layout. Bootstrap is a
    popular mobile-first framework for rendering HTML elements across a number of
    different platforms. Bootstrap styling and customization is a topic big enough
    for its own book, so we won't be exploring the ins and outs of the various Bootstrap
    options. If you are keen on learning more, then be sure to read the excellent
    book by David Cochran and Ian Whitley called *Boostrap Site Blueprints*, *Packt
    Publishing* ([https://www.packtpub.com/web-development/bootstrap-site-blueprints](https://www.packtpub.com/web-development/bootstrap-site-blueprints)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Bootstrap来帮助我们进行页面布局。Bootstrap是一个流行的移动优先框架，用于在许多不同平台上呈现HTML元素。Bootstrap的样式和定制是一个足够大的主题，需要一本专门的书来探讨，所以我们不会探讨各种Bootstrap选项的细节。如果你有兴趣了解更多，请务必阅读David
    Cochran和Ian Whitley的优秀著作*Boostrap Site Blueprints*，*Packt Publishing* ([https://www.packtpub.com/web-development/bootstrap-site-blueprints](https://www.packtpub.com/web-development/bootstrap-site-blueprints))。
- en: Board Sales
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Board Sales
- en: Our application will be a rather simple one, called Board Sales, and will list
    a range of windsurfing boards on the main page, using a summary view, or board
    list view. Clicking on any one of these boards will transition the page to show
    detailed information on the selected board. On the left-hand side of the screen,
    there will be a simple panel to allow the user to filter the main board list via
    manufacturer, or board type.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将是一个相当简单的应用，名为Board Sales，将在主页上列出一系列风浪板，使用摘要视图或板列表视图。单击其中任何一个板将使页面转换为显示所选板的详细信息。在屏幕的左侧，将有一个简单的面板，允许用户通过制造商或板类型来过滤主板列表。
- en: Modern windsurfing boards come in a range of sizes, and are measured by volume.
    Smaller volume boards are generally used for wave sailing, and larger volume boards
    are used for racing, or slalom. Those in-between can be categorized as freestyle
    boards, and are used for performing acrobatic tricks on flat water. Another important
    element of any board is the range of sails that the board is designed for. In
    very strong winds, smaller sails are used to allow the windsurfer to control the
    power generated by the wind, and in lighter winds, larger sails are used to generate
    more power. Our summary view will include a quick reference to the volume measurements
    for each board, and our detail view will show all the various board measurements
    and a compatible list of sail ranges.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的风浪板有各种尺寸，并且是按体积来衡量的。较小体积的板通常用于波浪帆船，而较大体积的板用于比赛或障碍赛。介于两者之间的板可以归类为自由式板，用于在平静水域上进行杂技表演。任何板的另一个重要元素是板设计的帆范围。在非常强风下，使用较小的帆来允许风帆手控制风力产生的动力，在较轻的风中，使用较大的帆来产生更多的动力。我们的摘要视图将包括对每个板的体积测量的快速参考，我们的详细视图将显示所有各种板的测量和兼容的帆范围列表。
- en: Page layout
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面布局
- en: 'With this application, we will use the power of JavaScript to provide a left-to-right
    panel-style page layout. We will use some Bootstrap transitions to slide panels
    in from the left, or from the right, in order to provide the user with a slightly
    different browsing experience. Let''s take a look at what this will look like
    conceptually:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个应用程序，我们将利用JavaScript的强大功能来提供从左到右的面板式页面布局。我们将使用一些Bootstrap过渡效果，从左侧或右侧滑入面板，以提供用户稍微不同的浏览体验。让我们来看看这在概念上是什么样子：
- en: '![Page layout](img/9665OS_09_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![页面布局](img/9665OS_09_01.jpg)'
- en: A conceptual view of page transitions for Board Sales
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Board Sales的页面转换的概念视图
- en: The **viewing panel** will be our main page, with a **header panel**, a **board
    listing panel**, and a **footer panel**. Hidden from view on the left-hand side
    will be the **filter panel**, with a button on the top-left of the main panel
    to show or hide this filter panel. The filter panel will slide in from the left
    when needed, and slide back to the left when hidden. Similarly, the **board detail**
    **panel** will slide in from the right when a board is clicked, and will slide
    back to the right when the back button is clicked, revealing the board listing
    panel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**查看面板**将是我们的主页面，有一个**头部面板**，一个**板块列表面板**和一个**页脚面板**。左侧隐藏的是**过滤面板**，主面板的左上方有一个按钮，用于显示或隐藏此过滤面板。需要时，过滤面板将从左侧滑入，隐藏时将滑回左侧。同样，**板块详细**
    **面板**将在点击板块时从右侧滑入，点击返回按钮时将滑回右侧，显示板块列表面板。'
- en: When the site is viewed on a desktop device, the filter panel on the left will
    be shown by default, but when the site is viewed on a tablet device—with a smaller
    screen—then the filter panel will be hidden by default, in order to save on screen
    real estate.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当在桌面设备上查看网站时，左侧的过滤面板将默认显示，但当在平板设备上查看网站时，由于屏幕较小，过滤面板将默认隐藏，以节省屏幕空间。
- en: Installing Bootstrap
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Bootstrap
- en: Bootstrap is a collection of CSS styles and JavaScript functions that aid in
    building responsive websites rather simply and easily. The responsive nature of
    Boostrap means that pages will resize elements automatically, to allow rendering
    on the smaller screen sizes of mobile phones, as well as larger screens used on
    tablets and desktops. By using Bootstrap, we gain the additional benefit of being
    able to target mobile users and desktop users with very little change to our HTML
    or CSS style sheets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是一组CSS样式和JavaScript函数，可帮助简单轻松地构建响应式网站。Bootstrap的响应性意味着页面将自动调整元素大小，以便在手机的较小屏幕尺寸上呈现，以及在平板电脑和台式机上使用的较大屏幕上呈现。通过使用Bootstrap，我们获得了额外的好处，可以以非常少的改动来针对移动用户和桌面用户。
- en: 'Bootstrap can be installed with a NuGet package, along with the corresponding
    TypeScript definitions as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap可以通过NuGet包安装，以及相应的TypeScript定义如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once Bootstrap has been installed, we can start building a sample web page that
    is purely written in HTML using Bootstrap. Building a demo page in this way helps
    us to figure out what Bootstrap elements we will use, and allows us to modify
    our CSS styles and structure our HTML correctly, before we start to build our
    application. This is where the Brackets editor really comes into its own. By using
    the live preview functionality of the editor, we can edit our HTML and CSS in
    one IDE, and have instant visual feedback in the preview pane. Working on sample
    HTML in this way is both a rewarding and fun experience, not to mention a massive
    time-saver.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Bootstrap后，我们可以开始构建一个纯粹使用Bootstrap编写的示例网页。以这种方式构建演示页面有助于我们确定要使用的Bootstrap元素，并允许我们在开始构建应用程序之前修改我们的CSS样式和正确构造我们的HTML。这就是Brackets编辑器真正发挥作用的地方。通过使用编辑器的实时预览功能，我们可以在一个IDE中编辑我们的HTML和CSS，并在预览窗格中获得即时的视觉反馈。以这种方式在示例HTML上工作既有益又有趣，更不用说节省了大量时间。
- en: Using Bootstrap
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bootstrap
- en: 'Our page will use a couple of Bootstrap elements for the main page regions,
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面将使用一些Bootstrap元素来定义主页面区域，如下：
- en: A **Navbar** component to render the header panel.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**导航栏**组件来渲染头部面板。
- en: A **Footer** component to render the footer panel.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**页脚**组件来渲染页脚面板。
- en: A **Carousel** component to slide from the board list view to the board detail
    view.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**轮播**组件，用于从板块列表视图滑动到板块详细视图。
- en: An **Accordion** component to render the filtering options in the left-hand
    side panel.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**手风琴**组件来渲染左侧面板中的过滤选项。
- en: '**Row** and **Column** components to control the HTML layout of boards in our
    board list view, as well as in the board detail view.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行**和**列**组件来控制我们板块列表视图中的板块的HTML布局，以及板块详细视图中的布局。'
- en: Table CSS elements to render tables.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表格CSS元素来渲染表格。
- en: In this chapter, we will not go into detail about how to build HTML pages with
    Bootstrap. We will instead start with a working version that you can find in the
    sample code under the directory /`tscode/tests/brackets/TestBootstrap.html`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会详细介绍如何使用Bootstrap构建HTML页面。相反，我们将从一个可在目录/`tscode/tests/brackets/TestBootstrap.html`下的示例代码中找到的工作版本开始。
- en: 'Our Bootstrap elements are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Bootstrap元素如下：
- en: '![Using Bootstrap](img/9665OS_09_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap](img/9665OS_09_02.jpg)'
- en: At the top of our page is the navbar element, which has been given a `navbar-inverse`
    style to render it with a black background. The **carousel panel 1** element is
    the first carousel panel, and contains the left-hand side filter panel, as well
    as the board list and the **show / hide panel** button. The **filter** options
    on the left-hand side panel use the Bootstrap accordion component. Finally, our
    footer is styled to be a "sticky footer", meaning that it will always show on
    the page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们页面的顶部是导航栏元素，它被赋予了`navbar-inverse`样式，以黑色背景呈现。**轮播面板1**元素是第一个轮播面板，包含左侧的过滤面板，以及板块列表和**显示/隐藏面板**按钮。左侧面板上的**过滤**选项使用了Bootstrap手风琴组件。最后，我们的页脚被设计成“粘性页脚”，意味着它将始终显示在页面上。
- en: When we click on any one of the boards in the board list, our carousel component
    will slide the carousel panel over to the left, and slide in the board detail
    view from the right.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击板列表中的任何一个板时，我们的轮播组件将把轮播面板向左滑动，并从右侧滑入板详细视图。
- en: 'Our board detail panel is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的面板详细信息如下：
- en: '![Using Bootstrap](img/9665OS_09_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bootstrap](img/9665OS_09_03.jpg)'
- en: Again, we have the standard header and footer regions, but this time, we are
    viewing **carousel panel 2**. This panel has a back button on the top left-hand
    side, and shows the detailed information on the selected board.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有标准的页眉和页脚区域，但这次我们正在查看**轮播面板2**。该面板在左上角有一个返回按钮，并显示所选板的详细信息。
- en: You will notice when you run this test page, that there are four links in the
    footer region named **next**, **prev**, **show**, and **hide**. These buttons
    are used to test the cycling of the carousel panels, and the show / hide functionality
    for the left hand-side panel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此测试页面时，您会注意到页脚区域有四个链接，分别命名为**next**、**prev**、**show**和**hide**。这些按钮用于测试轮播面板的循环和左侧面板的显示/隐藏功能。
- en: Bootstrap is ideal for building quick mock-ups of a working version of the site.
    This version can easily be taken to customers, or to project meetings for demo
    purposes. Showing a customer a demo mockup of a site will give you invaluable
    feedback on the overall site's flow and design. Ideally, this sort of work should
    be done by a senior web designer, or someone with equal skill set—who specializes
    in CSS styling.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap非常适合快速构建站点的工作版本的模拟。这个版本可以轻松地展示给客户，或者用于项目会议的演示目的。向客户展示站点的演示模型将为您提供有关整个站点流程和设计的宝贵反馈。理想情况下，这样的工作应该由一位资深的网页设计师或者具有相同技能的人来完成，他们专门负责CSS样式。
- en: We will be reusing and reworking this HTML later on when we start to build Marionette
    views. It is a good idea, however, to keep these demo HTML pages within your project,
    so that you can test their look and feel on different browsers and devices, all
    the while tweaking your HTML layout and CSS styles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建Marionette视图时，我们将稍后重用和重新设计这个HTML。然而，将这些演示HTML页面保留在项目中是一个好主意，这样您就可以在不同的浏览器和设备上测试它们的外观和感觉，同时调整您的HTML布局和CSS样式。
- en: Data structure
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'In a real-world application, data for websites would be stored and retrieved
    from a database of some sort. To use the data within a JavaScript web page, these
    data structures would be serialized to JSON format. Marionette uses standard Backbone
    models and collections for loading and serializing data structures. For the purpose
    of this sample application, our data structure will look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，网站的数据将存储在某种数据库中，并从中检索。为了在JavaScript网页中使用数据，这些数据结构将被序列化为JSON格式。Marionette使用标准的Backbone模型和集合来加载和序列化数据结构。对于这个示例应用程序，我们的数据结构将如下所示：
- en: '![Data structure](img/9665OS_09_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![数据结构](img/9665OS_09_04.jpg)'
- en: Class diagram of ManufacturerCollection and related Backbone models
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManufacturerCollection`和相关的Backbone模型的类图'
- en: 'The source of our data is the `ManufacturerCollection`, which will have a `url`
    property to load data from our site. This `ManufacturerCollection` holds a collection
    of `ManufacturerModels`, that are available via the `models` property. The `ManufacturerCollection`
    also implements two interfaces: `IManufacturerCollection` and `IFilterProvider`.
    We will discuss these two interfaces later on.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据源是`ManufacturerCollection`，它将有一个`url`属性来从我们的网站加载数据。这个`ManufacturerCollection`持有一个`ManufacturerModels`集合，可以通过`models`属性获得。`ManufacturerCollection`还实现了两个接口：`IManufacturerCollection`和`IFilterProvider`。我们稍后会讨论这两个接口。
- en: The properties of the `ManufacturerModel` will be used to render a single manufacturer's
    name and logo to the DOM. Each `ManufacturerModel` also has an array named `boards`,
    which holds an array of `BoardModels`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManufacturerModel`的属性将用于将单个制造商的名称和徽标呈现到DOM中。每个`ManufacturerModel`还有一个名为`boards`的数组，其中包含一个`BoardModels`数组。'
- en: Each `BoardModel` has properties that are necessary for rendering, as well as
    an array named `board_types`, which holds an array of `BoardType` classes. A `BoardType`
    is a simple string, and will hold a value of either "Wave", "Freestyle", or "Slalom".
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`BoardModel`都有必要用于呈现的属性，以及一个名为`board_types`的数组，其中包含一组`BoardType`类。`BoardType`是一个简单的字符串，将包含"Wave"、"Freestyle"或"Slalom"中的一个值。
- en: Each `BoardModel` will also have an array of `sizes`, holding a `BoardSize`
    class, containing detailed information on the available sizes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`BoardModel`还将有一个`sizes`数组，其中包含一个`BoardSize`类，其中包含有关可用尺寸的详细信息。
- en: 'As an example, the JSON data structure that is used to serialize the preceding
    object structure, would be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于序列化前述对象结构的JSON数据结构将如下所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our sample application, a full JSON dataset can be found at `/tscode/tests/boards.json`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，完整的JSON数据集可以在`/tscode/tests/boards.json`找到。
- en: Data interfaces
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据接口
- en: 'In order to use this JSON data structure within TypeScript, we will need to
    define a set of interfaces to describe the above data structure, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在TypeScript中使用这个JSON数据结构，我们需要定义一组接口来描述上述数据结构，如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These interfaces simply match the model properties in the previous diagram,
    and we can then build the corresponding `Backbone.Model` classes that implement
    these interfaces. Note that for brevity, we have not listed each individual property
    of each model here, so be sure to refer to the accompanying source code for a
    full listing. Our Backbone models are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口简单地匹配了前面图表中的模型属性，然后我们可以构建相应的实现这些接口的`Backbone.Model`类。请注意，为了简洁起见，我们没有在这里列出每个模型的每个属性，因此请务必参考附带的源代码以获取完整列表。我们的Backbone模型如下：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each class extends `Backbone.Model`, and implements one of the interfaces that
    we have defined earlier. There is not much to these classes, except for defining
    a `get` and `set` method for each property, and using the correct property type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都扩展了`Backbone.Model`，并实现了我们之前定义的接口之一。这些类没有太多内容，除了为每个属性定义`get`和`set`方法，并使用正确的属性类型。
- en: 'At this stage, our models are in place, and we can write a few unit tests,
    just to make sure that we can create our models correctly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的模型已经就位，我们可以编写一些单元测试，以确保我们可以正确地创建我们的模型：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We start with a simple test that creates a `BoardType` model, and then test
    that the `board_type` property has been set correctly. Similarly, we can create
    a test for the `BoardSize` model:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的测试开始，创建一个`BoardType`模型，然后测试`board_type`属性是否已正确设置。同样，我们可以为`BoardSize`模型创建一个测试：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This test is also just creating an instance of the `BoardSize` model, but it
    is using the `beforeAll` Jasmine method. For brevity, we are only showing one
    test, which checks the `volume` property, but in a real-world application we would
    test each of the `BoardSize` properties. Finally, we can write a test of the `BoardModel`
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试也只是创建了一个`BoardSize`模型的实例，但它使用了`beforeAll` Jasmine方法。为简洁起见，我们只展示了一个测试，检查`volume`属性，但在实际应用中，我们会测试每个`BoardSize`属性。最后，我们可以编写一个`BoardModel`的测试如下：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, we are creating a `BoardModel` instance in our `beforeAll` function,
    and then testing that the properties are set correctly. Note the tests near the
    bottom of this code snippet: we are checking whether the `sizes` property and
    `board_types` properties have been built correctly, and that they are in fact
    arrays that can be referenced with `[]` array notation.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在我们的`beforeAll`函数中创建了一个`BoardModel`实例，然后测试属性是否设置正确。注意代码片段底部附近的测试：我们正在检查`sizes`属性和`board_types`属性是否已正确构建，并且它们实际上是可以用`[]`数组表示法引用的数组。
- en: In the accompanying source code, you will find further tests for these models,
    as well as tests for the `ManufacturerModel`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在附带的源代码中，您将找到这些模型的进一步测试，以及对`ManufacturerModel`的测试。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how each model is constructed with a simple cut-and-paste of sections of
    the original JSON sample. When Backbone models are hydrated through RESTful services,
    these services are simply returning JSON—and our tests are, therefore, matching
    what Backbone itself would be doing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个模型是如何通过简单地剪切和粘贴原始JSON样本的部分来构建的。当Backbone模型通过RESTful服务进行填充时，这些服务只是简单地返回JSON，因此我们的测试与Backbone本身的操作是匹配的。
- en: Integration tests
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: At this stage, you may wonder why we are writing these sort of tests, as they
    might seem trivial, and are just checking whether certain properties have been
    constructed correctly. In real-world applications, models change quite frequently,
    especially in the beginning stages of a project. It is quite common to have one
    developer, or a portion of the team, who are responsible for the backend databases
    and server-side code that deliver JSON to the frontend. Another another team may
    be responsible for working on the frontend JavaScript code. By writing tests like
    these, you are clearly defining what your data structures should look like, and
    what properties you are expecting in your models. If a change is made server side
    that modifies a data structure, your team will be able to quickly identify where
    the cause of the problem lies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会想为什么我们要编写这些测试，因为它们可能看起来微不足道，只是检查某些属性是否已正确构建。在实际应用中，模型经常会发生变化，特别是在项目的初期阶段。通常会有一个开发人员或团队的一部分负责后端数据库和向前端提供JSON的服务器端代码。另一个团队可能负责前端JavaScript代码的开发。通过编写这样的测试，您清楚地定义了数据结构应该是什么样子，以及您的模型中期望的属性是什么。如果服务器端进行了修改数据结构的更改，您的团队将能够快速确定问题的原因所在。
- en: Another reason to write property-based tests is that Backbone, Marionette, and
    just about any other JavaScript library will use these property names to render
    HTML to the frontend. If you have a template that is expecting a property called
    `manufacturer_logo`, and you change this property name to `logo_image`, then your
    rendering code will break. These errors are quite often difficult to track down
    at runtime. Following the Test Driven Development mantra of "fail early, and fail
    loudly", our model property tests will quickly highlight these potential errors,
    should they occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编写基于属性的测试的另一个原因是，Backbone、Marionette和几乎任何其他JavaScript库都将使用这些属性名称来将HTML呈现到前端。如果您的模板期望一个名为`manufacturer_logo`的属性，而您将此属性名称更改为`logo_image`，那么您的渲染代码将会出错。这些错误通常很难在运行时跟踪。遵循“尽早失败，失败得响亮”的测试驱动开发原则，我们的模型属性测试将快速突出显示这些潜在错误，如果发生的话。
- en: Once a series of property-based tests are in place, we can now focus on an integration
    test that will actually call the server-side code. This will ensure that our RESTful
    services are working correctly, and that the JSON data structure that our site
    is generating matches the JSON data structure that our Backbone models expect.
    Again, if two separate teams are responsible for client-side and server-side code,
    this sort of integration test will ensure that the data exchange is consistent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一系列基于属性的测试就位，我们现在可以专注于一个集成测试，实际上会调用服务器端代码。这将确保我们的RESTful服务正常工作，并且我们网站生成的JSON数据结构与我们的Backbone模型期望的JSON数据结构匹配。同样，如果两个独立的团队负责客户端和服务器端代码，这种集成测试将确保数据交换是一致的。
- en: 'We will be loading our data for this application through a `Backbone.Collection`
    class, and this collection will need to load multiple manufacturers. To this end,
    we can now build a `ManufacturerCollection` class as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过`Backbone.Collection`类加载此应用程序的数据，并且此集合将需要加载多个制造商。为此，我们现在可以构建一个`ManufacturerCollection`类，如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a very simple `Backbone.Collection` class, which just sets the `model`
    property to our `ManufacturerModel`, and the `url` property to `/tscode/boards.json`.
    As our sample application does not have a backend database or REST services, so
    we will just load our JSON from disk at this stage. Note that even though we are
    using a static JSON file in this test, Backbone will still issue an HTTP request
    back to our server in order to load this file, meaning that any test of this `ManufacturerCollection`
    is, in fact, an integration test. We can now write some integration tests to ensure
    that this model can be loaded correctly from the `url` property, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的`Backbone.Collection`类，它只是将`model`属性设置为我们的`ManufacturerModel`，将`url`属性设置为`/tscode/boards.json`。由于我们的示例应用程序没有后端数据库或REST服务，因此我们将在此阶段仅从磁盘加载我们的JSON。请注意，即使在此测试中我们使用静态JSON文件，Backbone仍将向服务器发出HTTP请求以加载此文件，这意味着对`ManufacturerCollection`的任何测试实际上都是集成测试。现在我们可以编写一些集成测试，以确保该模型可以从`url`属性正确加载，如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are again using the Jasmine `beforeAll` syntax to set up our `ManufacturerCollection`
    instance, and then calling `fetch({ async: false })` to wait for the collection
    to be loaded. We then have two tests, one to check that we are loading three manufacturers
    into our collection, and another to check the `Manufacturer` model at index `2`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '我们再次使用Jasmine的`beforeAll`语法来设置我们的`ManufacturerCollection`实例，然后调用`fetch({ async:
    false })`来等待集合加载。然后我们有两个测试，一个是检查我们是否将三个制造商加载到我们的集合中，另一个是检查索引为`2`的`Manufacturer`模型。'
- en: Traversing a collection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'Now that we have a full `ManufacturerCollection` loaded, we can turn our attention
    to processing the data that it contains. We will need to search this collection
    to find two things: a list of manufacturers, and a list of board types. These
    two lists will be used by our filtering panel on the left-hand side panel. In
    a real-world application, these two lists may be provided by server-side code,
    returning simple JSON data structures to represent these two lists. In our sample
    application, however, we will show how to traverse the main manufacturer Backbone
    collection that we have already loaded. The filtering data structure is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了完整的`ManufacturerCollection`，我们可以将注意力转向处理它包含的数据。我们需要搜索此集合以找到两件事：制造商列表和板类型列表。这两个列表将被用于左侧面板上的过滤面板。在现实世界的应用程序中，这两个列表可能由服务器端代码提供，返回简单的JSON数据结构来表示这两个列表。然而，在我们的示例应用程序中，我们将展示如何遍历我们已经加载的主制造商Backbone集合。过滤数据结构如下：
- en: '![Traversing a collection](img/9665OS_09_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![遍历集合](img/9665OS_09_05.jpg)'
- en: FilterCollection class diagram with related Backbone models
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相关Backbone模型的FilterCollection类图
- en: 'Rather than listing the full implementation of Backbone models shown in the
    preceding diagram, we will take a look at the TypeScript interfaces instead. Our
    interfaces for these filtering models are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面图表中显示的Backbone模型的完整实现不同，我们将查看TypeScript接口。我们的这些过滤模型的接口如下：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start with a `FilterType` enum, which we will use to define each of the types
    of filters we have available. We can filter our board list by either manufacturer
    name, board type, or clear all filters by using the `None` filter type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`FilterType`枚举开始，我们将使用它来定义我们可用的每种类型的过滤器。我们可以通过制造商名称、板类型或使用`None`过滤器类型清除所有过滤器来过滤我们的板列表。
- en: The `IFilterValue` interface simply holds a string value that will be used for
    filtering. When we are filtering by board type, this string value would be one
    of "Wave", "Freestyle", or "Slalom", and when we are filtering by manufacturer,
    this string value will be the name of the manufacturer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFilterValue`接口简单地保存一个用于过滤的字符串值。当我们按板类型进行过滤时，此字符串值将是“Wave”、“Freestyle”或“Slalom”之一，当我们按制造商进行过滤时，此字符串值将是制造商的名称。'
- en: The `IFilterModel` interface will hold the `FilterType`, a name for the filter,
    and array of `filterValues`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFilterModel`接口将保存`FilterType`，过滤器的名称和`filterValues`数组。'
- en: 'We will create a Backbone model for each of these interfaces, meaning that
    we will end up with two Backbone models, named `FilterValue` (which implements
    the `IFilterValue` interface), and `FilterModel` (which implements the `IFilterModel`
    interface). To house a collection of `FilterModel` instances, we will also create
    a Backbone collection named `FilterCollection`. This collection has a single method
    named `buildFilterCollection`, which will use an `IFilterProvider` interface to
    build its internal array of `FilterModels`. This `IFilterProvider` interface is
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这些接口创建一个Backbone模型，这意味着我们最终将拥有两个Backbone模型，名为`FilterValue`（实现`IFilterValue`接口）和`FilterModel`（实现`IFilterModel`接口）。为了容纳`FilterModel`实例的集合，我们还将创建一个名为`FilterCollection`的Backbone集合。此集合有一个名为`buildFilterCollection`的方法，它将使用`IFilterProvider`接口来构建其内部的`FilterModels`数组。此`IFilterProvider`接口如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our `IFilterProvider` interface has two functions. The `findManufacturerNames`
    function will return a list of manufacturer names (and their associated logos),
    and the `findBoardTypes` function will return a list of strings of all board types.
    This information is all that is needed to build up our `FilterCollection` internal
    data structures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`IFilterProvider`接口有两个函数。`findManufacturerNames`函数将返回制造商名称列表（及其关联的标志），`findBoardTypes`函数将返回所有板类型的字符串列表。这些信息是构建我们的`FilterCollection`内部数据结构所需的全部信息。
- en: All of the values needed to populate this `FilterCollection` will come from
    data that is already contained within our `ManufacturerCollection`. The `ManufacturerCollection`
    will, therefore, need to implement this `IFilterProvider` interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用于填充此`FilterCollection`所需的所有值将来自已包含在我们的`ManufacturerCollection`中的数据。因此，`ManufacturerCollection`将需要实现此`IFilterProvider`接口。
- en: Finding manufacturer names
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找制造商名称
- en: 'Let''s continue working within our test suite to flesh out the functionality
    of the `findManufacturerNames` function that the `ManufacturerCollection` will
    need to implement, as part of the `IFilterProvider` interface. This function returns
    an array of type `IManufacturerName`, which is defined as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在我们的测试套件中工作，以充实`ManufacturerCollection`需要实现的`IFilterProvider`接口的`findManufacturerNames`函数的功能。这个函数返回一个`IManufacturerName`类型的数组，定义如下：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now build a test using this interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个接口构建一个测试：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This test is reusing the `manufacturers` variable that we set up in our previous
    test suite. It then calls the `findManufacturerNames` function, and expects the
    results to be an array of three manufacturer names, i.e. `"JP Australia"`, `"RRD",`
    and `"Starboard"`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试重用了我们在之前的测试套件中设置的`manufacturers`变量。然后调用`findManufacturerNames`函数，并期望结果是一个包含三个制造商名称的数组，即"JP
    Australia"，"RRD"和"Starboard"。
- en: 'Now, we can update the actual `ManufacturerCollection` class, in order to provide
    an implementation of the `findManufacturerNames` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新实际的`ManufacturerCollection`类，以提供`findManufacturerNames`函数的实现：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, we are using the Underscore utility function named `map` to
    loop through our collection. Each Backbone collection class has an internal array
    named `models`. The `map` function will loop through this `models` property, and
    call the anonymous function for each item in the collection, passing the current
    model into our anonymous function via the `iterator` argument. Our code then builds
    a JSON object with the required properties of the `IManufacturer` interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用Underscore实用函数`map`来循环遍历我们的集合。每个Backbone集合类都有一个名为`models`的内部数组。`map`函数将循环遍历这个`models`属性，并为集合中的每个项目调用匿名函数，通过`iterator`参数将当前模型传递给我们的匿名函数。然后我们的代码构建了一个具有`IManufacturer`接口所需属性的JSON对象。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The TypeScript compiler will generate errors if the returned object does not
    conform to the `IManufacturer` name interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的对象不符合`IManufacturer`名称接口，TypeScript编译器将生成错误。
- en: Finding board types
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找板类型
- en: 'We can now focus on the second function of the `IFilterProvider` interface,
    named `findBoardTypes` that the `ManufacturerCollection` will need to implement.
    Here is the unit test:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以专注于`IFilterProvider`接口的第二个函数，名为`findBoardTypes`，`ManufacturerCollection`需要实现。这是一个单元测试：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This test calls the `findBoardTypes` function, which will return an array of
    strings. We are expecting the returned array to contain three strings: `"Wave"`,
    `"Freestyle"`, and `"Slalom"`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试调用`findBoardTypes`函数，它将返回一个字符串数组。我们期望返回的数组包含三个字符串："Wave"，"Freestyle"和"Slalom"。
- en: 'The corresponding function in our `ManufacturerCollection` class is then implemented
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`ManufacturerCollection`类中对应的函数实现如下：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The implementation of the `findBoardTypes` function starts by creating a new
    string array named `boardTypes`, which will hold our results. We then use the
    Underscore `each` function to loop through each manufacturer. The Underscore `each`
    function is similar to the `map` function, and will iterate through each item
    in our collection. We then loop through each board in the manufacturer's arsenal,
    and through each board type listed per board. Finally, we are testing to see whether
    the board type collection contains an item already, using the underscore `_.contains`
    function. If it does not already have the board type in the array, we push the
    `board_type` string into our `boardTypes` array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`findBoardTypes`函数的实现从创建一个名为`boardTypes`的新字符串数组开始，它将保存我们的结果。然后我们使用Underscore的`each`函数来循环遍历每个制造商。Underscore的`each`函数类似于`map`函数，将迭代我们集合中的每个项目。然后我们循环遍历制造商的所有板，以及每个板上列出的每种板类型。最后，我们测试看看板类型集合是否已经包含一个项目，使用underscore的`_.contains`函数。如果数组中还没有板类型，我们将`board_type`字符串推入我们的`boardTypes`数组中。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Underscore library has numerous utility functions available for searching,
    manipulating, and modifying arrays and collections—so be sure to consult the documentation
    to find suitable functions for use in your code. These functions are not limited
    to Backbone collections only, and can be used on any type of array.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore库有许多实用函数可用于搜索、操作和修改数组和集合，因此请务必查阅文档，找到适合在您的代码中使用的合适函数。这些函数不仅限于Backbone集合，可以用于任何类型的数组。
- en: This completes our work on the `IFilterProvider` interface, and its implementation
    within the `ManufacturerCollection` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`IFilterProvider`接口的工作，以及它在`ManufacturerCollection`类中的实现。
- en: Filtering a Collection
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合过滤
- en: 'When a user clicks on a filter option on the left-hand side panel, we will
    need to apply the selected filter to the data contained within our manufacturer
    collection. In order to do this, we will need to implement two functions, named
    `filterByManufacturer`, and `filterByBoardType` within the `ManufacturerCollection`
    class. Let''s start with a test to filter our collection by manufacturer name:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在左侧面板上点击过滤选项时，我们需要将所选的过滤器应用到制造商集合中包含的数据。为了做到这一点，我们需要在`ManufacturerCollection`类中实现两个函数，名为`filterByManufacturer`和`filterByBoardType`。让我们从一个测试开始，通过制造商名称来过滤我们的集合：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This test calls the `filterByManufacturer` function, expecting only a single
    manufacturer to be returned. With this test in place, we can create the real `filterByManufacturer`
    function on the `ManufacturerCollection` as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试调用`filterByManufacturer`函数，期望只返回一个制造商。有了这个测试，我们可以在`ManufacturerCollection`上创建真正的`filterByManufacturer`函数，如下所示：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are using the Underscore function named `filter` to apply a filter
    to our collection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Underscore函数`filter`来对我们的集合应用过滤器。
- en: 'The second filtering function is by board type, and is a little more complicated.
    We will need to loop through each manufacturer in our collection, then through
    each board, and then through each board type. If we find a match for the board
    type, we will flag this board to be included in the result set. Before we tackle
    the `filterByBoardType` function, let''s write a test:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个筛选函数是按板子类型筛选，稍微复杂一些。我们需要循环遍历我们的集合中的每个制造商，然后循环遍历每个板子，然后循环遍历每个板子类型。如果我们找到了板子类型的匹配，我们将标记这个板子包含在结果集中。在我们着手编写`filterByBoardType`函数之前，让我们写一个测试：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our test calls the `filterByBoardType` function, using the string `"Slalom"`
    as a filter. Remember that this function will return a collection of `ManufacturerModel`
    objects at the top level, with the `boards` array within each of these objects
    filtered by board type. Our test then loops through each manufacturer, and each
    board in the result set, and then uses the Underscore function called `some` to
    test whether the `board_types` array has the correct board type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试调用`filterByBoardType`函数，使用字符串`"Slalom"`作为筛选条件。请记住，这个函数将返回一个`ManufacturerModel`对象的集合，顶层的每个对象中的`boards`数组都经过板子类型的筛选。我们的测试然后循环遍历每个制造商，以及结果集中的每个板子，然后使用Underscore函数`some`来测试`board_types`数组是否有正确的板子类型。
- en: 'Our code to implement this function on the `ManufacturerCollection` is also
    a little tricky, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ManufacturerCollection`上实现这个函数的代码也有点棘手，如下所示：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our `ManufacturerCollection` class instance holds the entire collection that
    was loaded via the JSON file from the site. In order to keep this data for repeated
    filters, we will need to construct a new `ManufacturerModel` array to return from
    this function – so that we do not to modify the underlying "global" data. Once
    we have constructed this new array, we can then loop through each manufacturer.
    If we find a board matching the required filter, we will set a flag named `hasBoardType`
    to true, to indicate that this manufacturer must be added to our filtered array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ManufacturerCollection`类实例保存了通过网站上的JSON文件加载的整个集合。为了保留这些数据以进行重复筛选，我们需要构造一个新的`ManufacturerModel`数组来从这个函数中返回——这样我们就不需要修改基础的“全局”数据。一旦我们构造了这个新数组，我们就可以循环遍历每个制造商。如果我们找到与所需筛选匹配的板子，我们将设置一个名为`hasBoardType`的标志为true，以指示这个制造商必须添加到我们的筛选数组中。
- en: Each manufacturer in this filtered array will also need to list only the board
    types that match our filter criteria, so we will need another array—called `boardMatches`—to
    hold these matching boards. Our code will then loop through each board, and check
    whether it has the required `board_type`. If so, we will add it to the `boardMatches`
    array and set the `hasBoardType` flag to `true`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个经过筛选的数组中，每个制造商还需要列出与我们的筛选条件匹配的板子类型，因此我们需要另一个数组——称为`boardMatches`——来保存这些匹配的板子。然后我们的代码将循环遍历每个板子，并检查它是否具有所需的`board_type`。如果是，我们将把它添加到`boardMatches`数组中，并将`hasBoardType`标志设置为`true`。
- en: Once we have looped through each board for a manufacturer, we can check the
    `hasBoardType` flag. If our manufacturer has this board type, we will construct
    a new `ManufacturerModel`, and then set the `boards` property on this model to
    our in-memory array of the matching boards.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们循环遍历了每个制造商的板子，我们就可以检查`hasBoardType`标志。如果我们的制造商有这种板子类型，我们将构造一个新的`ManufacturerModel`，然后将这个模型的`boards`属性设置为我们内存中匹配的板子的数组。
- en: Our work with the underlying Backbone collections and models is now complete.
    We have also written a set of unit and integration tests to ensure that we can
    load our collection from the site, build our filtering lists from this collection,
    and then apply a particular filter to this data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对底层的Backbone集合和模型的工作现在已经完成。我们还编写了一组单元测试和集成测试，以确保我们可以从网站加载我们的集合，从这个集合构建我们的筛选列表，然后对这些数据应用特定的筛选。
- en: Marionette application, regions and layouts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marionette应用程序、区域和布局
- en: 'We can now focus our attention on building the application itself. In Marionette,
    this is achieved by creating a class that derives from `Marionette.Application`,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把注意力集中在构建应用程序本身上。在Marionette中，这是通过创建一个从`Marionette.Application`派生的类来实现的，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have defined a class named `BoardSalesApp` that derives from the `Marionette.Application`
    class, and will serve as the starting point for our application. Our constructor
    function is fairly simple, and creates a new instance of the `PageViewLayout`
    class, which we will discuss shortly. The only other function in our application
    is the `onStart` function, which renders our `PageViewLayout` to the screen. This
    `onStart` function will be triggered by Marionette when the application starts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`BoardSalesApp`的类，它派生自`Marionette.Application`类，并将作为我们应用程序的起点。我们的构造函数非常简单，它创建了`PageViewLayout`类的一个新实例，我们将很快讨论。我们应用程序中的唯一其他函数是`onStart`函数，它将我们的`PageViewLayout`呈现到屏幕上。当应用程序启动时，Marionette将触发这个`onStart`函数。
- en: 'Our `PageLayoutView` class is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PageLayoutView`类如下：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This class extends from `Marionette.LayoutView`, and does two important things.
    Firstly, it sets a number of properties on the `options` object, and then calls
    the base class constructor via the `super` function, passing in this `options`
    object. One of the properties of this `options` object is named `el`, and contains
    the name of the DOM element that this view will render into. In this code snippet,
    this `el` property is set to the DOM element `'#page_wrapper'`. Without this `el`
    property set, we will just get a blank screen when we try to render the viewto
    the DOM.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展自`Marionette.LayoutView`，并做了两件重要的事情。首先，在`options`对象上设置了一些属性，然后通过`super`函数调用了基类的构造函数，传入了这个`options`对象。这个`options`对象的一个属性名为`el`，包含了这个视图将呈现到的DOM元素的名称。在这段代码中，这个`el`属性被设置为DOM元素`'#page_wrapper'`。如果不设置这个`el`属性，当我们尝试将视图呈现到DOM时，我们将得到一个空白屏幕。
- en: The second important step in our constructor is to load a snippet from the `SnippetService`.
    This snippet is then used to set the `template` property on the `options` object.
    Marionette, similar to Backbone, loads a template, and then combines the underlying
    model properties with the view template, in order to generate the HTML that will
    be rendered to the DOM.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构造函数中的第二个重要步骤是从`SnippetService`加载一个片段。然后使用这个片段来设置`options`对象上的`template`属性。与Backbone类似，Marionette加载模板，然后将底层模型属性与视图模板结合起来，以生成将呈现到DOM中的HTML。
- en: At this stage, in order to run our `BoardSalesApp`, and have it render the `PageViewLayout`
    to the DOM, we will need two things. The first is a DOM element in our `index.html`
    page with an `id="page_wrapper"`, to match our `options.el` property, and the
    second is our `PAGE_VIEW_LAYOUT_SNIPPET`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，为了运行我们的`BoardSalesApp`，并让它将`PageViewLayout`呈现到DOM中，我们需要两样东西。第一是在我们的`index.html`页面中有一个`id="page_wrapper"`的DOM元素，以匹配我们的`options.el`属性，第二是我们的`PAGE_VIEW_LAYOUT_SNIPPET`。
- en: 'Our `index.html` page is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index.html`页面如下：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This page includes the `bootstrap.css` and `app.css` style sheets, as well as
    a call to Require, with the `data-main` attribute set to a Require config file
    named `/tscode/app/AppConfig`. The body of the `index.html` page just includes
    the DOM element with `id="page_wrapper"`, and a footer. This is a very stripped-down
    version of the demo HTML page that we built earlier.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面包括`bootstrap.css`和`app.css`样式表，以及一个带有`data-main`属性设置为名为`/tscode/app/AppConfig`的Require配置文件的Require调用。`index.html`页面的主体只包括带有`id="page_wrapper"`的DOM元素和页脚。这是我们之前构建的演示HTML页面的一个非常简化的版本。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have also included a script named `head-1.0.3.js`, which can be installed
    via the NuGet package `HeadJS`. This script interrogates our browser to find out
    whether it is running on a mobile or desktop device, what browser we are using,
    and even what the current screen size is. We will use the output of `head.js`
    later in our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一个名为`head-1.0.3.js`的脚本，可以通过NuGet包`HeadJS`安装。这个脚本会查询我们的浏览器，以找出它是在移动设备还是桌面设备上运行，我们正在使用什么浏览器，甚至当前屏幕尺寸是多少。我们将在应用程序中稍后使用`head.js`的输出。
- en: 'We will now need to create an HTML snippet for the `PageViewLayout`. This file
    is called `PageViewLayout.html`, and resides in the `/tscode/app/views` directory,
    so it can be easily found when we are working with the `PageViewLayout.ts` file.
    Take a look at the sample code for a full listing of this HTML file, which includes
    the following relevant sections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为`PageViewLayout`创建一个HTML片段。这个文件叫做`PageViewLayout.html`，位于`/tscode/app/views`目录中，因此在处理`PageViewLayout.ts`文件时可以很容易找到。查看完整的HTML文件清单的示例代码，其中包括以下相关部分：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `PageViewSnippet.html` file contains the major elements of our page. We
    have the `main_panel_div` that serves as the middle panel of our application,
    with a `carousel-inner` div that contains our two carousel panel divs, named `carousel_panel_1`
    and `carousel_panel_2`. Within these carousel panels, we will be rendering the
    filter panel, board list panel and board detail panel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PageViewSnippet.html`文件包含了我们页面的主要元素。我们有一个`main_panel_div`作为应用程序的中间面板，其中包含了我们的两个轮播面板div，名为`carousel_panel_1`和`carousel_panel_2`。在这些轮播面板中，我们将呈现过滤面板、板块列表面板和板块详细信息面板。
- en: 'We now need to put together our `AppConfig.ts` file that Require will load,
    and set up the `SnippetService` to load the `PageViewLayout.html` snippet. In
    the interests of brevity, we have not listed the full `require.config` here, and
    have excluded the `paths` and `shims` section. We will just focus on the call
    to Require as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要组合我们的`AppConfig.ts`文件，Require将加载，并设置`SnippetService`来加载`PageViewLayout.html`片段。为了简洁起见，我们没有在这里列出完整的`require.config`，并且已经排除了`paths`和`shims`部分。我们将专注于对Require的调用如下：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we included the `BoardSalesApp`, `tinyioc`, and `snippetservice`, as well
    as our `PageViewLayout.html` snippet in the call to require. We then set up the
    `SnippetService`, store the `pageViewLayoutSnippet` against the correct key, and
    register the `SnippetService` with our service locator. To start our Marionette
    application, we create a new instance of the `BoardSalesApp`, and call `start`.
    Once the `start` method is called, our `BoardSalesApp.onStart` method will be
    fired by Marionette, which will then render the `PageViewLayout` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包括了`BoardSalesApp`、`tinyioc`和`snippetservice`，以及我们的`PageViewLayout.html`片段在require的调用中。然后我们设置了`SnippetService`，将`pageViewLayoutSnippet`存储在正确的键下，并将`SnippetService`注册到我们的服务定位器中。为了启动我们的Marionette应用程序，我们创建了`BoardSalesApp`的一个新实例，并调用`start`。一旦调用了`start`方法，Marionette将触发我们的`BoardSalesApp.onStart`方法，然后渲染`PageViewLayout`类。
- en: Loading the main collection
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载主要集合
- en: 'In this application, we will be loading our `ManufacturerCollection` only once,
    and then reusing this "global" collection for filtering purposes. Let''s now update
    our `BoardSalesApp` to include this "global" collection, and load it on application
    startup. Again, refer to the sample code for a full listing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将只加载我们的`ManufacturerCollection`一次，然后重复使用这个“全局”集合进行过滤。现在让我们更新我们的`BoardSalesApp`，以包括这个“全局”集合，并在应用程序启动时加载它。再次参考完整清单的示例代码：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have updated our `BoardSalesApp` to store an instance of the `ManufacturerCollection`
    class in the private variable named `_manufCollection`. Our `onStart` function
    has been updated to instantiate this collection, after the call to `viewLayout.render`.
    Note the next call to `TypeScriptTinyIoC`. We are registering `this._manufCollection`
    as a service that will implement the `IIManufacturerCollection` named interface.
    We then call the Backbone `fetch` function on the collection, with a `success`
    and `error` callback. Both the `success` callback and `error` callback simply
    raise an event.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了我们的`BoardSalesApp`，在私有变量`_manufCollection`中存储了`ManufacturerCollection`类的一个实例。我们的`onStart`函数已经更新，以在调用`viewLayout.render`之后实例化这个集合。注意下一个对`TypeScriptTinyIoC`的调用。我们正在注册`this._manufCollection`作为一个将实现`IIManufacturerCollection`命名接口的服务。然后我们在集合上调用Backbone的`fetch`函数，带有`success`和`error`回调。`success`回调和`error`回调都只是触发一个事件。
- en: 'By registering our instance of the `ManufacturerCollection` class against the
    named interface `IIManufacturerCollection`, any of our classes that need access
    to the main collection can simply request the instance of this class from our
    service locator. These named interfaces are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的`ManufacturerCollection`类的实例注册到命名接口`IIManufacturerCollection`，我们的任何需要访问主要集合的类都可以简单地从我们的服务定位器中请求此类的实例。这些命名接口如下：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will also need to modify our `ManufacturerCollection` class to implement
    the `IManufacturerCollection` interface as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`ManufacturerCollection`类以实现`IManufacturerCollection`接口，如下所示：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s now have a look at the events that will be fired from our `success`
    and `error` callbacks. In the `success` function callback, we are raising an event
    of type `INotifyEvent`. Note that we are just listing the interface definitions
    here—for the corresponding `IInterfaceChecker` classes and event classes, please
    refer to the accompanying source code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下将从我们的`success`和`error`回调中触发的事件。在`success`函数回调中，我们正在引发`INotifyEvent`类型的事件。请注意，我们在这里只列出接口定义—有关相应的`IInterfaceChecker`类和事件类，请参考附带的源代码：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have defined an `EventType` enum to hold an event type, and then defined
    an `INotifyEvent` interface that just holds a property named `eventType`. We have
    also defined the corresponsing `INotifyEvent_Handler` interface that any handler
    will need to implement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`EventType`枚举来保存事件类型，然后定义了一个`INotifyEvent`接口，它只包含一个名为`eventType`的属性。我们还定义了相应的`INotifyEvent_Handler`接口，任何处理程序都需要实现。
- en: 'Our error event will use inheritance to derive from these interfaces as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误事件将使用继承从这些接口派生如下：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we are are deriving the `IErrorEvent` interface from `INotifyEvent`, thereby
    reusing the `EventType` enum and properties from the base interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`INotifyEvent`派生`IErrorEvent`接口，从而重用基接口的`EventType`枚举和属性。
- en: 'We can now respond to these events in our `PageViewLayout` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的`PageViewLayout`类中响应这些事件：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have implemented the `INotifyEvent_Handler` interface, and registered with
    `TypeScriptTinyIoC` for the `IINotifyEvent`. Our `handle_NotifyEvent` class will
    check that the event type is a `ManufacturerDataLoaded` event, and then create
    an instance of the `ManufacturerCollectionView` class and render it to the DOM.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`INotifyEvent_Handler`接口，并在`TypeScriptTinyIoC`中为`IINotifyEvent`注册了。我们的`handle_NotifyEvent`类将检查事件类型是否为`ManufacturerDataLoaded`事件，然后创建`ManufacturerCollectionView`类的实例并将其渲染到DOM中。
- en: Marionette views
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marionette视图
- en: 'Marionette provides a number of different view classes for us to use, based
    on what type of object we need to render to the DOM. Any class that needs to render
    a `Backbone.Collection` can use a `CollectionView`, and any class that needs to
    render a single item in this collection can use an `ItemView`. Marionette also
    provides a hybrid of these two views called a `CompositeView`. If we take a look
    at our demo application, we will be able to break up our screen into a number
    of logical views, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette提供了许多不同的视图类供我们使用，根据我们需要渲染到DOM的对象类型。任何需要渲染`Backbone.Collection`的类都可以使用`CollectionView`，任何需要渲染此集合中的单个项目的类都可以使用`ItemView`。Marionette还提供了这两种视图的混合称为`CompositeView`。如果我们看一下我们的演示应用程序，我们将能够将我们的屏幕分解为许多逻辑视图，如下所示：
- en: '![Marionette views](img/9665OS_09_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Marionette views](img/9665OS_09_06.jpg)'
- en: Board list view with Marionette view overlay
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 带有Marionette视图覆盖的板列表视图
- en: 'The identification of what views we need to build are pretty closely related
    to the data structure that we have in place for our Backbone collections and models.
    This relationship is clearly seen when we superimpose the preceding views on top
    of our class diagram for our `ManufacturerCollection`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的视图的确定与我们为Backbone集合和模型设置的数据结构密切相关。当我们将前面的视图叠加在我们的`ManufacturerCollection`类的类图上时，这种关系显而易见：
- en: '![Marionette views](img/9665OS_09_07.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Marionette views](img/9665OS_09_07.jpg)'
- en: Model class diagram with corresponding Marionette Views
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相应Marionette视图的模型类图
- en: The ManufacturerCollectionView class
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ManufacturerCollectionView类
- en: We start with a `ManufacturerCollectionView`, which is a view that renders the
    whole `ManufacturerCollection`. We will also need a `ManufacturerView` to render
    a particular `ManufacturerModel`, and then a `BoardView` to render each board
    in a manufacturer's arsenal. Each board has an internal array of `BoardSize` objects,
    so we will create a `BoardSizeView` to render these items.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ManufacturerCollectionView`开始，这是一个渲染整个`ManufacturerCollection`的视图。我们还需要一个`ManufacturerView`来渲染特定的`ManufacturerModel`，然后是一个`BoardView`来渲染制造商武器库中的每个板。每个板都有一个内部的`BoardSize`对象数组，因此我们将创建一个`BoardSizeView`来渲染这些项目。
- en: 'Lets start building these views, starting with the `ManufacturerCollectionView`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建这些视图，从`ManufacturerCollectionView`开始：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class extends from `Marionette.CollectionView`, and specifies our `ManufacturerModel`
    as the generic type for the class. Our `constructor` sets the `el` property of
    the `options` object to be `"#manufacturer_collection"`. As we saw with our `PageLayoutView`,
    Marionette will use this property to render the entire collection into the DOM.
    We have also set a `className` property in our `options`. Marionette will use
    the `className` property to append a `class="…"` attribute to the outer DOM element.
    This will apply the CSS styles of `row` and `board_row` to the `manufacturer_collection`
    element in the rendered HTML. Once we have constructed our `options` correctly,
    we call `super(options)` to pass these options to the base class constructor.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展自`Marionette.CollectionView`，并将我们的`ManufacturerModel`指定为类的泛型类型。我们的`constructor`将`el`属性设置为`"＃manufacturer_collection"`的`options`对象。正如我们在`PageLayoutView`中看到的，Marionette将使用此属性将整个集合渲染到DOM中。我们还在我们的`options`中设置了一个`className`属性。Marionette将使用`className`属性将`class="…"`属性附加到外部DOM元素。这将在渲染的HTML中将`CSS`样式应用于`manufacturer_collection`元素的`row`和`board_row`。一旦我们正确构造了我们的`options`，我们调用`super(options)`将这些选项传递给基类构造函数。
- en: The `childView` property of a `CollectionView` instructs Marionette to create
    an instance of the class we specify for each element that it finds in the collection.
    We have set this `childView` property to be `ManfuacturerView`, so Marionette
    will construct a new `ManufacturerView` for each element in the collection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionView`的`childView`属性指示Marionette为集合中找到的每个元素创建我们指定的类的实例。我们将这个`childView`属性设置为`ManfuacturerView`，因此Marionette将为集合中的每个元素构造一个新的`ManufacturerView`。'
- en: Finally, in our constructor, we are using our service locator pattern to look
    up an instance of our `ManufacturerCollection` service, and then we set the internal
    `this.collection` property to the returned object. Once we have defined a `childView`
    class name, and set the `this.collection` property, Marionette will automatically
    create instances of our child views, and render them to the DOM.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的构造函数中，我们使用我们的服务定位器模式查找`ManufacturerCollection`服务的一个实例，然后将内部的`this.collection`属性设置为返回的对象。一旦我们定义了`childView`类名，并设置了`this.collection`属性，Marionette将自动创建我们的子视图的实例，并将它们呈现到DOM中。
- en: Note that we don't need an HTML template or snippet for a `CollectionView`.
    This is because we are deferring the rendering of an individual item to the `childView`
    classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`CollectionView`，我们不需要HTML模板或片段。这是因为我们将单个项目的渲染推迟到`childView`类。
- en: The ManufacturerView class
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ManufacturerView类
- en: 'Our `childView` class, `ManufacturerView`, is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`childView`类`ManufacturerView`如下：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this instance, we are deriving our view from `Marionette.CompositeView`,
    and using a standard `Backbone.Model` for the generic type. Because we have multiple
    manufacturers in our board list view, we don't really need to render anything
    specific for each manufacturer. Therefore, our template is a simple `<div></div>`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们从`Marionette.CompositeView`派生我们的视图，并使用标准的`Backbone.Model`作为通用类型。因为我们的板列表视图中有多个制造商，我们实际上不需要为每个制造商渲染任何特定的内容。因此，我们的模板是一个简单的`<div></div>`。
- en: The important part of this view is to set up a new `Backbone.Collection` for
    our `boards` array, and then set a `childView` class to render each `board` in
    the collection. Our `childView` property is set to `BoardView`, and we are also
    setting a `childViewOptions` property that will be sent through to each `BoardView`
    instance. Remember that each `BoardView` shows the manufacturer logo, but this
    logo image is held at the manufacturer level. Therefore, we need to pass this
    information down to each `BoardView` that is created. Marionette allows us to
    use the `childViewOptions` property to pass any extra properties down to the child
    view. Here, we have defined a `parentIcon` property as part of this `childViewOptions`
    object, in to order pass down the manufacturer logo to each instance of a child
    `BoardView` class. This `parentIcon` property will then be available to the child
    view via the `options` parameter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的重要部分是为我们的`boards`数组设置一个新的`Backbone.Collection`，然后设置一个`childView`类来渲染集合中的每个`board`。我们的`childView`属性设置为`BoardView`，我们还设置了一个`childViewOptions`属性，将通过它传递给每个`BoardView`实例。请记住，每个`BoardView`显示制造商的标志，但这个标志图像是在制造商级别保存的。因此，我们需要将这些信息传递给每个创建的`BoardView`。Marionette允许我们使用`childViewOptions`属性将任何额外的属性传递给子视图。在这里，我们在`childViewOptions`对象中定义了一个`parentIcon`属性，以便将制造商的标志传递给每个子`BoardView`类的实例。然后，这个`parentIcon`属性将通过`options`参数对子视图可用。
- en: The BoardView class
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BoardView类
- en: 'Our `BoardView` class is also a `CompositeView` as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BoardView`类也是一个`CompositeView`，如下所示：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This `BoardView` constructor does a couple of things. Firstly, it retrieves
    the snippet named `BOARD_VIEW_SNIPPET` to use as its own `template`. It then sets
    an internal model property named `parentIcon` to store the `parentIcon` property
    that was passed in via the `options` parameter from the parent view. We then create
    a new `Backbone.Collection` for the `sizes` array, and set the `childView` property
    to `BoardSizeView`. The `childViewContainer` property tells Marionette that there
    is a `<tbody></tbody>` HTML div within our snippet that it should use to render
    any `childView` into. Finally, we retrieve another snippet named `BOARD_SIZE_MINI_VIEW_SNIPPET`,
    and pass this snippet through to the `childView` as a `template` property.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`BoardView`构造函数做了几件事。首先，它检索名为`BOARD_VIEW_SNIPPET`的片段，用作自己的`template`。然后，它设置一个内部模型属性`parentIcon`，用于存储通过父视图的`options`参数传递的`parentIcon`属性。然后，我们为`sizes`数组创建一个新的`Backbone.Collection`，并将`childView`属性设置为`BoardSizeView`。`childViewContainer`属性告诉Marionette在我们的片段中有一个`<tbody></tbody>`的HTML
    div，它应该用来渲染任何`childView`。最后，我们检索另一个名为`BOARD_SIZE_MINI_VIEW_SNIPPET`的片段，并将这个片段作为`template`属性传递给`childView`。
- en: Instead of each `BoardSizeView` class resolving its own HTML snippet, we have
    moved control of which snippet to use up in the class hierarchy, to the parent
    of the `BoardSizeView`. This allows us to reuse the `BoardSizeView` class within
    this summary view, as well as in the `BoardDetailView`, which we will discuss
    later. As the internal data models are identical for the summary size view and
    the detail size view, all that will need to change is our HTML template. We therefore
    pass this template down into the `BoardSizeView` using the `childViewOption` properties,
    as we have seen previously.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardSizeView`类不是解析自己的HTML片段，而是将控制权移动到类层次结构的父类`BoardSizeView`的父类。这使我们能够在摘要视图中重用`BoardSizeView`类，以及在稍后将讨论的`BoardDetailView`中重用。由于摘要大小视图和详细大小视图的内部数据模型是相同的，唯一需要改变的是我们的HTML模板。因此，我们使用`childViewOption`属性将此模板传递到`BoardSizeView`中，就像我们之前看到的那样。'
- en: The BoardSizeView class
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BoardSizeView类
- en: 'Our `BoardSizeView` class could not be simpler, and is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BoardSizeView`类非常简单，如下所示：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This class is simply an `ItemView`, which is using the `BoardSize` model as
    the generic type. We don't have any custom code within this class, but we are
    simply using it as a named `childView` in our preceding `BoardView` class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是一个`ItemView`，它使用`BoardSize`模型作为通用类型。在这个类中我们没有任何自定义代码，而是简单地将它作为前面的`BoardView`类中的一个命名的`childView`。
- en: 'Let''s take a look now at the HTML snippets that we will need for each of these
    views. First up is our `BoardViewSnippet.html`. Again, you can find the full snippet
    in the accompanying source code. The general structure of the `BoardViewSnippet.html`
    is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们将需要为每个视图准备的HTML片段。首先是我们的“BoardViewSnippet.html”。同样，您可以在附带的源代码中找到完整的片段。“BoardViewSnippet.html”的一般结构如下：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this snippet, we have included the `<%= name %>`, `<%= description %>`, `<%=
    parentIcon %>` and `<%= image %>` syntax as placeholders for our model properties.
    Near the bottom of the snippet, we have created a table with an empty `<tbody></tbody>`
    tag. This tag corresponds to the `childViewContainer` property that we used in
    our `BoardView` class, and Marionette will render each `BoardSizeView` item into
    this `<tbody>` tag.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们包含了“<%= name %>”、“<%= description %>”、“<%= parentIcon %>”和“<%= image
    %>”语法作为我们模型属性的占位符。在片段的底部附近，我们创建了一个带有空的“<tbody></tbody>”标记的表。这个标记对应于我们在“BoardView”类中使用的“childViewContainer”属性，Marionette将每个“BoardSizeView”项目呈现到这个“<tbody>”标记中。
- en: 'Our `BoardSizeMiniViewSnippet.html` is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“BoardSizeMiniViewSnippet.html”如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we are only interested in the `<%= volume %>` property of the `BoardSize`
    model. With these view classes and two snippets in place, our board list view
    is complete. All we need to do is to load these snippets up in our `require.config`
    block, and store the appropriate snippets on our `SnippetService` instance:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只对“BoardSize”模型的“<%= volume %>”属性感兴趣。有了这些视图类和两个片段，我们的板列表视图就完成了。我们需要做的就是在我们的“require.config”块中加载这些片段，并将适当的片段存储在我们的“SnippetService”实例上：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Filtering using the IFilterProvider interface
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用IFilterProvider接口进行过滤
- en: When we put together the `ManufacturerCollection` class, we wrote two functions
    to query the data structure, and return a list of manufacturers and board types.
    These two functions were called `findManufacturerNames` and `findBoardTypes` respectively.
    Our new `FilterCollection` class will need to call these methods to retrieve the
    filter values from our "global" dataset.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们组合“ManufacturerCollection”类时，我们编写了两个函数来查询数据结构，并返回制造商和板类型的列表。这两个函数分别称为“findManufacturerNames”和“findBoardTypes”。我们的新“FilterCollection”类将需要调用这些方法来从我们的“全局”数据集中检索过滤器值。
- en: 'We could implement this functionality in two ways. One way would be to get
    a reference to the global `ManufacturerCollection` instance via the `IIManufacturerCollection`
    named interface. This option, however, would mean that the code for the `FilterCollection`
    would need to understand the code for the `ManufacturerCollection`. A better way
    of implementing this functionality would be to get a reference to an `IFilterProvider`
    interface. This interface would then just expose the two methods that we need
    to build our list of filters. Let''s take this second approach, and define a named
    interface as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式实现这个功能。一种方式是通过“IIManufacturerCollection”命名接口获取对全局“ManufacturerCollection”实例的引用。然而，这个选项意味着“FilterCollection”的代码需要理解“ManufacturerCollection”的代码。实现这个功能的更好方式是获取对“IFilterProvider”接口的引用。然后，这个接口将只公开我们构建过滤器列表所需的两个方法。让我们采用这种第二种方法，并定义一个命名接口，如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then simply modify the existing `ManufacturerCollection` to implement
    this interface (which it already does):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以简单地修改现有的“ManufacturerCollection”以实现这个接口（它已经这样做了）：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now register the `ManufacturerCollection` with `TypeScriptTinyIoC` against
    the `IIFilterProvider` named interface in our `BoardSalesApp.onStart` method,
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的“BoardSalesApp.onStart”方法中使用“TypeScriptTinyIoC”注册“ManufacturerCollection”到“IIFilterProvider”命名接口，如下所示：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our `ManufacturerCollection` is now registered to provide both the `IIManfacturerCollection`
    named interface, as well as the `IIFilterProvider` named interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经注册了我们的“ManufacturerCollection”来提供名为“IIManfacturerCollection”的接口，以及名为“IIFilterProvider”的接口。
- en: The FilterCollection class
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FilterCollection类
- en: 'Our `FilterCollection` can then resolve the `IIFilterProvider` interface in
    its constructor, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的“FilterCollection”可以在其构造函数中解析“IIFilterProvider”接口，如下所示：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we are storing the class that is returned by the call to `TypeScriptTinyIoC`
    in a private variable named `_filterProvider`. By defining these interfaces for
    a `FilterProvider`, we can now unit test our `FilterCollection` with a mock `FilterProvider`
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将调用“TypeScriptTinyIoC”返回的类存储在名为“_filterProvider”的私有变量中。通过为“FilterProvider”定义这些接口，我们现在可以使用模拟“FilterProvider”对我们的“FilterCollection”进行单元测试，如下所示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the setup for our tests, we are creating a `MockFilterProvider` that implements
    our `IFilterProvider` interface, and we have registered it for the purposes of
    our tests. By using a mock provider, we also know exactly what data to expect
    within our tests. Our actual tests will be as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试设置中，我们创建了一个实现我们的“IFilterProvider”接口的“MockFilterProvider”，并为我们的测试目的注册了它。通过使用模拟提供程序，我们还知道在我们的测试中可以期望什么数据。我们的实际测试将如下所示：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These tests start by creating an instance of the `FilterCollectionClass`, and
    then call the `buildFilterCollection` function. We then test that the collection
    has a `FilterType.Manufacturer` at index `0`, along with expected values. With
    these failing tests in place, we can flesh out the `buildFilterCollection` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试从创建“FilterCollectionClass”的实例开始，然后调用“buildFilterCollection”函数。然后我们测试集合在索引“0”处是否有“FilterType.Manufacturer”，以及预期值。有了这些失败的测试，我们可以完善“buildFilterCollection”函数：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our `buildFilterCollection` function is creating three instances of a `FilterModel`.
    The first instance, named `manufFilter` has its `filterType` set to `FilterType.Manufacturer`,
    and uses the `_filterProvider.findManufacterNames` function to build up the values
    for this `FilterModel`. The `manufFilter` instance is then added to the internal
    `collection` via the call `this.push(manufFilter)`. The second and third `FilterModel`
    instances have their `filterType` set to `FilterType.BoardType` and `FilterType.None`
    respectively.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`buildFilterCollection`函数正在创建三个`FilterModel`的实例。第一个实例名为`manufFilter`，其`filterType`设置为`FilterType.Manufacturer`，并使用`_filterProvider.findManufacterNames`函数来构建此`FilterModel`的值。然后通过调用`this.push(manufFilter)`将`manufFilter`实例添加到内部`collection`中。第二个和第三个`FilterModel`实例的`filterType`分别设置为`FilterType.BoardType`和`FilterType.None`。
- en: Filtering views
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤视图
- en: 'Again, the relationship between the Marionette views that we need to implement,
    and the underlying Backbone collections and models that we have, is easy to visualize
    when we superimpose the views on top of our Backbone models as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将视图叠加在我们的Backbone模型上时，我们需要实现的Marionette视图之间的关系很容易可视化如下：
- en: '![Filtering views](img/9665OS_09_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![过滤视图](img/9665OS_09_09.jpg)'
- en: Filtering class diagram showing related Marionette views
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 显示相关Marionette视图的过滤类图
- en: The first view, named `FilterCollectionView`, will be derived from `CollectionView`,
    and will be tied to our top-level `FilterCollection`. The second view, named `FilterModelView`
    will be a `CompositeView`, and will render each `FilterType` to its own accordion
    header. The third and final view will be an `ItemView` for each of the filter
    options, and is named FilterItemView.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视图名为`FilterCollectionView`，将从`CollectionView`派生，并将与我们的顶级`FilterCollection`绑定。第二个视图名为`FilterModelView`，将是一个`CompositeView`，并将每个`FilterType`呈现到其自己的手风琴标题中。第三个和最后一个视图将是每个过滤选项的`ItemView`，名为FilterItemView。
- en: Building these Marionette views is a very similar process to what we have done
    with the previous manufacturer and board views. For this reason, we will not go
    into detail here on the implementation of each view. Be sure to refer to the sample
    code included with this chapter for full listings of these views and their relevant
    HTML snippets.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这些Marionette视图的过程与我们之前对制造商和板视图所做的工作非常相似。因此，我们不会在这里详细介绍每个视图的实现。请务必参考本章附带的示例代码，以获取这些视图及其相关HTML片段的完整列表。
- en: Now that we have our filters rendering on the left-hand side panel, we will
    need to be able to respond to a click event on the `FilterItemView`, and trigger
    the actual filtering code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在左侧面板上呈现了我们的过滤器，我们需要能够响应`FilterItemView`上的点击事件，并触发实际的过滤代码。
- en: DOM events in Marionette
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marionette中的DOM事件
- en: 'Marionette provides a simple syntax for trapping DOM events. Any view has an
    internal property named `events`, which will bind DOM events to our Marionette
    views. Our `FilterItemView`, then, can be updated to respond to DOM events as
    follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette提供了一个简单的语法来捕获DOM事件。任何视图都有一个名为`events`的内部属性，它将把DOM事件绑定到我们的Marionette视图上。然后，我们的`FilterItemView`可以更新以响应DOM事件，如下所示：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have added an `events` property to our `options` object, and registered a
    handler function for the `click` DOM event. Whenever someone clicks on a `FilterItemView`,
    Marionette will invoke the `filterClicked` function. We have also added a call
    to `_.bindAll` for this event, to ensure that the `this` variable is scoped to
    the class instance whenever the `filterClicked` function is called.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向我们的`options`对象添加了一个`events`属性，并为`click` DOM事件注册了一个处理程序函数。每当有人点击`FilterItemView`时，Marionette将调用`filterClicked`函数。我们还为此事件添加了一个`_.bindAll`调用，以确保在调用`filterClicked`函数时，`this`变量被限定为类实例。
- en: Remember that each instance of this `FilterItemView` has a corresponding `FilterValue`
    model available to it via the internal `model` property. So, within our `filterClicked`
    function, we are simply raising a new `FilterEvent`, using properties from the
    internal `model` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个`FilterItemView`的实例都可以通过内部的`model`属性获得相应的`FilterValue`模型。因此，在我们的`filterClicked`函数中，我们只是使用内部`model`变量的属性来引发一个新的`FilterEvent`。
- en: 'Our event definition interfaces are as follows—again, please refer to the sample
    code for the matching `IInterfaceChecker` definitions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件定义接口如下 - 再次，请参考匹配的`IInterfaceChecker`定义的示例代码：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now register handlers for these filter events elsewhere in our code.
    The logical place to put this event handler is on the `PageViewLayout` itself,
    as this class is responsible for rendering the board list. We will define our
    `handle_FilterEvent` function on the `PageViewLayout` as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在代码的其他地方注册这些过滤器事件的处理程序。将此事件处理程序放在`PageViewLayout`本身上是一个合乎逻辑的地方，因为这个类负责呈现板列表。我们将在`PageViewLayout`上定义我们的`handle_FilterEvent`函数如下：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function starts by obtaining a reference to our "global" registered `ManufacturerCollection`.
    We then define a variable named `filteredCollection` to hold our filtered version
    of the main `ManufacturerCollection`. Based on the `FilterType` within the event
    itself, we call either `filterByBoardType`, or `filterByManufacturer`. If the
    event type is `FilterType.None`, we simply set the `filteredCollection` to the
    `mainCollection`, effectively clearing all filters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能首先通过获取对我们“全局”注册的`ManufacturerCollection`的引用来开始。然后，我们定义一个名为`filteredCollection`的变量来保存我们对主`ManufacturerCollection`进行过滤的版本。根据事件本身的`FilterType`，我们调用`filterByBoardType`或`filterByManufacturer`。如果事件类型是`FilterType.None`，我们只需将`filteredCollection`设置为`mainCollection`，有效地清除所有过滤器。
- en: The last part of this function sets the internal `collection` property of our
    main view (`this._manufacturerView`) to the resultant `filteredCollection`, and
    then calls `render`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的最后部分将我们主视图（`this._manufacturerView`）的内部`collection`属性设置为结果`filteredCollection`，然后调用`render`。
- en: Our application is now responding to a click event on the `FilterItemView`,
    raising an event, and re-rendering the `ManufacturerView`, in order to apply the
    selected filter to our data for rendering.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在正在响应`FilterItemView`上的点击事件，触发一个事件，并重新渲染`ManufacturerView`，以便将所选的过滤器应用于我们的数据进行渲染。
- en: Triggering a Detail view event
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发详细视图事件
- en: We have another click event, however, that we need to respond to. When a user
    clicks on a particular board, we need to fire an event that will slide the panels
    over, and show the board detail view.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要响应另一个点击事件。当用户点击特定的面板时，我们需要触发一个事件，将面板滑动过去，并显示详细的面板视图。
- en: 'Before we move onto the board detail view and how it is rendered, let''s first
    hook up a click event on the `BoardView` class. To do so, we just need to specify
    a click event handler on the `options.events` parameters on the `BoardView` class,
    similar to our previous click event handler. We will also need to create an `onClicked`
    function, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论详细视图以及如何渲染它之前，让我们首先在`BoardView`类上挂接一个点击事件。为此，我们只需要在`BoardView`类的`options.events`参数上指定一个点击事件处理程序，类似于我们之前的点击事件处理程序。我们还需要创建一个`onClicked`函数，如下所示：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The changes to this class are fairly minimal, we just set the `events` property
    on our `options` correctly, issue a call to `_.bindAll`, as we did in our `FilterItem`
    code, and then write an `onClicked` function. This `onClicked` function issues
    a call to `flip` as we saw in [Chapter 7](ch07.html "Chapter 7. Modularization"),
    *Modularization*, and then raises a new `BoardSelectedEvent`. Our `BoardSelectedEvent`
    interface and handler interfaces are as follows—again, please refer to the sample
    code for the matching `IInterfaceChecker` definitions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个类的更改非常小，我们只需正确设置`options`上的`events`属性，发出对`_.bindAll`的调用，就像我们在`FilterItem`代码中所做的那样，然后编写一个`onClicked`函数。这个`onClicked`函数发出一个调用`flip`，就像我们在[第7章](ch07.html
    "第7章。模块化")中看到的那样，*模块化*，然后触发一个新的`BoardSelectedEvent`。我们的`BoardSelectedEvent`接口和处理程序接口如下-再次，请参考示例代码以获取匹配的`IInterfaceChecker`定义：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `BoardSelectedEvent` simply contains the entire `BoardModel` itself, in
    the `selectedBoard` property. With these event interfaces and clases in place,
    we can now register for a `BoardSelectedEvent` anywhere in our code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardSelectedEvent`只是包含整个`BoardModel`本身，在`selectedBoard`属性中。有了这些事件接口和类，我们现在可以在代码的任何地方注册`BoardSelectedEvent`。'
- en: Rendering the BoardDetailView
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染BoardDetailView
- en: 'In this application, the logical place for handling this `BoardSelectedEvent`
    would be in the `PageViewLayout`, as it is responsible for cycling the carousel
    panels, and rendering the `BoardDetailView`. Let''s update this class as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，处理`BoardSelectedEvent`的逻辑位置应该是在`PageViewLayout`中，因为它负责循环轮播面板，并渲染`BoardDetailView`。让我们按照以下方式更新这个类：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we have upated our `PageViewLayout` class to implement the `IBoardSelectedEvent_Hander`
    interface, and registered it with `TypeScriptTinyIoC`. We are responding to the
    `BoardSelectedEvent` by creating a new `BoardDetailView` class, using the full
    `BoardModel` included in the event, and then calling `render`. Our `BoardDetailView`
    class is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经更新了我们的`PageViewLayout`类以实现`IBoardSelectedEvent_Hander`接口，并将其注册到`TypeScriptTinyIoC`。我们通过创建一个新的`BoardDetailView`类来响应`BoardSelectedEvent`，使用事件中包含的完整`BoardModel`，然后调用`render`。我们的`BoardDetailView`类如下：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `BoardDetailView` class is very similar to our `BoardView`, but it uses
    the `"#board_detail_view"` element for the `options.el` property—which is our
    corresponding DOM element. Our snippet has the `BOARD_DETAIL_VIEW_SNIPPET` key.
    We then create a `Backbone.Collection` out of the `sizes` property, and set the
    `childView` to the `BoardSize` view class template, in the same way that we did
    earlier for the `BoardView`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardDetailView`类与我们的`BoardView`非常相似，但它使用`"＃board_detail_view"`元素作为`options.el`属性，这是我们对应的DOM元素。我们的片段具有`BOARD_DETAIL_VIEW_SNIPPET`键。然后我们从`sizes`属性创建一个`Backbone.Collection`，并将`childView`设置为`BoardSize`视图类模板，就像我们之前为`BoardView`所做的那样。'
- en: Our `childViewContainer`, however, now targets the `<tbody></tbody>` tag to
    render children into. We are also passing the template from the `BOARD_SIZE_VIEW_SNIPPET`
    to the child `BoardSize` view, and setting the `tagName` to `'tr'`. Remember how
    we moved the configuration of the child `BoardSize` views up one level in our
    `BoardView`? Well, we are doing the same thing here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`childViewContainer`现在将目标定位到`<tbody></tbody>`标签以渲染子元素。我们还将模板从`BOARD_SIZE_VIEW_SNIPPET`传递给子`BoardSize`视图，并将`tagName`设置为`'tr'`。还记得我们如何将子`BoardSize`视图的配置移到`BoardView`中吗？嗯，我们在这里做同样的事情。
- en: Please refer to the sample code for a full listing of the `BoardDetailViewSnippet.html`,
    and the `BoardSizeViewSnippet.html`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`BoardDetailViewSnippet.html`和`BoardSizeViewSnippet.html`的完整清单，请参考示例代码。
- en: The State Design Pattern
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: Our last task for this application is to control the various screen elements
    as users interact with our application. As a user navigates the application, we
    need to move from carousel panel 1 to carousel panel 2, and update screen elements,
    such as showing and hiding the left-hand side filter panel. In a large web application,
    there may be many screen elements, many different transitions, and things such
    as pop ups or masks that say **"loading…"** while our application fetches data
    from backend services. Keeping track of all of these elements becomes a difficult
    and time-consuming task, often leaving large swathes of if-else or switch statements
    in many different areas of our code, leading to a lot of direct DOM manipulation
    spaghetti.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个应用程序的最后一个任务是在用户与我们的应用程序交互时控制各种屏幕元素。当用户导航应用程序时，我们需要从轮播面板1移动到轮播面板2，并更新屏幕元素，例如显示和隐藏左侧的过滤面板。在大型Web应用程序中，可能会有许多屏幕元素，许多不同的过渡效果，以及诸如弹出窗口或遮罩等内容，显示**“加载中…”**，而我们的应用程序从后端服务获取数据。跟踪所有这些元素变得困难且耗时，通常会在代码的许多不同区域留下大量的if-else或switch语句，导致大量直接的DOM操作混乱。
- en: The State Design Pattern is a design pattern that can simplify our application
    code, so that code that manipulates these various DOM elements can reside in one
    place. The State Design Pattern defines a set of states that the application could
    be in, and provides an easy mechanism to transition between these states, control
    visual screen elements, and handle animations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式是一种可以简化我们应用程序代码的设计模式，这样可以将操作这些不同DOM元素的代码放在一个地方。状态设计模式定义了应用程序可能处于的一组状态，并提供了一种简单的机制来在这些状态之间进行转换，控制视觉屏幕元素，并处理动画。
- en: Problem space
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题空间
- en: 'As an example of what we are trying to achieve, consider the following business
    rules:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们试图实现的一个例子，考虑以下业务规则：
- en: When a user first logs into the BoardSales application on a desktop, the left-hand
    filter panel should be visible.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户首次登录到桌面上的BoardSales应用程序时，左侧的筛选面板应该可见。
- en: If the user is using a mobile device, the left-hand filter panel should not
    be visible when a user first logs in. This is done to save on screen real estate.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户使用移动设备，当用户首次登录时，左侧的筛选面板不应该可见。这样做是为了节省屏幕空间。
- en: If the filter panel is visible, then the expand icon should switch to a left-hand
    arrow (<) to allow the user to hide it.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果筛选面板可见，则展开图标应该切换为左箭头（<），以允许用户隐藏它。
- en: If the filter panel is not visible, then the expand icon should be a right-hand
    arrow (>) to allow the user to show it.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果筛选面板不可见，则展开图标应该是右箭头（>），以允许用户显示它。
- en: If a user expands the filter panel, and then switches to a board detail view
    and back again, then the filter panel should remain expanded.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户展开了筛选面板，然后切换到看板详细视图，然后再切回来，那么筛选面板应该保持展开状态。
- en: If a user hides the filter panel, and then switches to a board detail view and
    back again, then the filter panel should remain hidden.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户隐藏了筛选面板，然后切换到看板详细视图，然后再切回来，那么筛选面板应该保持隐藏状态。
- en: 'On top of these business rules, we have an outstanding bug that has been reported
    for users on a Firefox browser (you can test this behavior using the demo HTML
    page):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些业务规则之外，我们还有一个已经报告给使用Firefox浏览器的用户的未解决bug（您可以使用演示HTML页面测试此行为）：
- en: When clicking on a board in the board list view, with the filter panel open,
    the carousel panel does not behave correctly. The carousel first cycles across
    to the board detail view, and then closes the filter panel. This transition is
    inconsistent with other browsers, where the filter panel is cycled along with
    the board list at the same time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在看板列表视图中点击一个看板时，如果筛选面板是打开的，轮播面板就不会正确地行为。轮播首先跨越到看板详细视图，然后关闭筛选面板。这种转换与其他浏览器不一致，在其他浏览器中，筛选面板与看板列表同时循环。
- en: 'This bug therefore adds another business requirement to our list:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个bug给我们的清单增加了另一个业务需求：
- en: For users on a Firefox browser, please hide the filter panel first, before cycling
    the carousel to the board detail view.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用Firefox浏览器的用户，请在循环轮播到看板详细视图之前先隐藏筛选面板。
- en: The State Design Pattern uses a set of very similar classes, each representing
    a particular application state. Each of these state classes are derived from the
    same base class. When we want our application to change to a different state,
    we simply switch to the object that represents the state that we are interested
    in.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式使用一组非常相似的类，每个类代表特定的应用程序状态。这些状态类都是从同一个基类派生的。当我们希望应用程序切换到不同的状态时，我们只需切换到表示我们感兴趣的状态的对象。
- en: For example, our application really has only three states. We have a state where
    the board list and filter panels are both visible. We have another state where
    only the board list is visible, and our third state is where the board detail
    panel is visible. Depending on which state we are in, we should be either on `carousel_panel_1`,
    or on `carousel_panel_2`. Also, the icon that is used in conjunction with the
    filter panel needs to swich from a left-hand chevron `<` to a right-hand chevron
    `>`, depending on the application state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的应用实际上只有三种状态。我们有一个状态，其中看板列表和筛选面板都是可见的。我们有另一个状态，只有看板列表是可见的，我们的第三个状态是看板详细面板可见。根据我们所处的状态，我们应该在`carousel_panel_1`上，或者在`carousel_panel_2`上。此外，与筛选面板一起使用的图标需要根据应用程序状态从左手的尖角`<`切换到右手的尖角`>`。
- en: The State Design Pattern also has the concept of a Mediator class, which will
    keep track of the current state, and contain the logic of how to switch between
    each of these states.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设计模式还有一个中介者类的概念，它将跟踪当前状态，并包含如何在这些状态之间切换的逻辑。
- en: State class diagram
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态类图
- en: 'Consider the following class diagram for the State and Mediator Design Pattern:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下状态和中介者设计模式的类图：
- en: '![State class diagram](img/9665OS_09_10.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![状态类图](img/9665OS_09_10.jpg)'
- en: State and Mediator pattern class diagram
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和中介者模式类图
- en: 'We start with an enum named `StateType` that lists our three application states,
    and second enum named `PanelType` to indicate which carousel panel each of these
    states are on. We then define an interface named `IState` that each of these states
    must implement. To hold properties common to each state, we have also defined
    a base `State` class, from which all states will derive. Our implementation of
    these enums, the `IState` interface, and the base `State` class as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`StateType`的枚举开始，列出了我们的三种应用程序状态，第二个名为`PanelType`的枚举用于指示每个状态所在的轮播面板。然后，我们定义了一个名为`IState`的接口，每个状态都必须实现该接口。为了保存每个状态的公共属性，我们还定义了一个名为`State`的基类，所有状态都将从中派生。我们的实现如下所示：这些枚举，`IState`接口和基类`State`。
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our `StateType` enum has defined each state that we will be using. Our application,
    therefore, is either in `BoardListOnly` state, `BoardListWithFilter` state, or
    `BoardDetail` state. Our second enum, named `PanelType`, is used to indicate which
    of the carousel panels we are currently on, either the `Initial` panel (carousel_panel_1),
    or the `Secondary` panel (carousel_panel_2).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“StateType”枚举已经定义了我们将使用的每个状态。因此，我们的应用程序可能处于“BoardListOnly”状态、“BoardListWithFilter”状态或“BoardDetail”状态。我们的第二个枚举，名为“PanelType”，用于指示我们当前位于哪个旋转木马面板，即“Initial”面板（carousel_panel_1）或“Secondary”面板（carousel_panel_2）。
- en: We then define an `IState` interface that all state objects must implement.
    This interface allows us to query each state, and determine four important pieces
    of information. The `getPanelType` function tells us what panel we should be currently
    viewing, and the `getStateType` function returns the `StateType` enum value. The
    `getShowFilterClass` function will return a string that is used to apply a CSS
    class to the show / hide filter button, and the `isFilterPanelVisible` function
    returns a boolean to indicate whether or not the filter panel is visible.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个“IState”接口，所有状态对象都必须实现。此接口允许我们查询每个状态，并确定四个重要信息。 “getPanelType”函数告诉我们我们当前应该查看哪个面板，“getStateType”函数返回“StateType”枚举值。
    “getShowFilterClass”函数将返回一个字符串，用于将CSS类应用于显示/隐藏过滤按钮，“isFilterPanelVisible”函数返回一个布尔值，指示过滤面板是否可见。
- en: Each state needs a reference to the `Mediator` class, so we have created a base
    `State` class with a `constructor` function, from which each of our State objects
    can be derived from.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态都需要引用“中介者”类，因此我们创建了一个带有“constructor”函数的基本“State”类，从中可以派生出我们的每个State对象。
- en: Concrete State classes
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具体状态类
- en: 'Let''s now create concrete classes for each of these states. The first state
    that our application can be in, is when we are viewing the board list, and the
    filter panel is hidden:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为每个状态创建具体类。我们的应用程序可能处于的第一个状态是，当我们查看看板列表时，过滤面板是隐藏的：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our `BoardListOnlyState` class extends the `State` class that we defined earlier,
    and implements the `IState` interface. In this `BoardListOnly` state, we should
    be on the `Initial` carousel panel, the class to be used for the show / hide filter
    panel button should be a `glyphicon-chevron-right` [ `>` ], and the left-hand
    side filter panel should NOT be visible.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“BoardListOnlyState”类扩展了我们之前定义的“State”类，并实现了“IState”接口。在这种“BoardListOnly”状态下，我们应该在“Initial”旋转木马面板上，用于显示/隐藏过滤面板按钮的类应该是“glyphicon-chevron-right”
    [ `>` ]，左侧的过滤面板不应该可见。
- en: 'The next state that our application could be in, is when the board list is
    showing, and we also have the filter panel visible:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可能处于的下一个状态是，当看板列表显示时，我们还可以看到过滤面板：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `BoardListWithFilterPanel` state, our carousel panel is again the `Initial`
    panel, but our class for the show / hide filter panel button is now a `glyphicon-chevron-left`
    (`<`). Our filter panel is also visible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在“BoardListWithFilterPanel”状态下，我们的旋转木马面板再次是“Initial”面板，但我们用于显示/隐藏过滤面板按钮的类现在是“glyphicon-chevron-left”（<）。我们的过滤面板也是可见的。
- en: 'The last state we need to define for our application, is when we have cycled
    over to `carousel_panel_2`, and are viewing the board detail screen:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的应用程序定义的最后一个状态是，当我们循环到“carousel_panel_2”并查看看板详细信息屏幕时：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `DetailPanel` state, we are on the `Secondary` carousel panel, we do
    not need a class for the show / hide filter panel button (as the panel has moved
    off the screen), and the filter panel itself is NOT visible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在“DetailPanel”状态下，我们位于“Secondary”旋转木马面板上，我们不需要一个用于显示/隐藏过滤面板按钮的类（因为面板已经移出屏幕），过滤面板本身也不可见。
- en: Note that in the sample application source code, you will find a series of unit
    tests that will test each of these properties. For the purposes of brevity, we
    will not list them here.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在示例应用程序源代码中，您将找到一系列单元测试，测试每个属性。出于简洁起见，我们在这里不列出它们。
- en: The Mediator class
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介者类
- en: In object-oriented patterns, a Mediator is used to encapsulate the logic of
    how a set of objects interacts. In our case, we have a set of states that define
    what visual elements should be shown. There is also a need to define how these
    various elements transition according to the movement between these states.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的模式中，中介者用于封装一组对象交互的逻辑。在我们的情况下，我们有一组状态，定义了应该显示哪些视觉元素。还需要定义这些不同元素如何根据这些状态之间的移动进行过渡。
- en: 'We will, therefore, define a `Mediator` class to encapsulate all of this transition
    logic, and co-ordinate the changes to our visual elements, based on movements
    between states. In order for our `Mediator` class to interact with the UI, we
    will define a set of four functions that must be implemented by any class using
    this `Mediator`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将定义一个“中介者”类来封装所有这些过渡逻辑，并根据状态之间的移动协调对我们的视觉元素的更改。为了使我们的“中介者”类与UI交互，我们将定义一组四个函数，任何使用此“中介者”的类都必须实现：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Our `IMediatorFunctions` interface has four functions. The `showLeftPanel` function
    will show our filter panel. The `hideLeftPanel` function will hide the filter
    panel. The `cyclePanels` function will be invoked with either a `'prev'` string,
    or a `'next'` string to cycle the carousel panel from `carousel_panel_1` to `carousel_panel_2`.
    The `showFilterButtonChangeClass` will be invoked with two arguments—a `fromClass`
    string that is a CSS class, and a `toClass` string that is another CSS class.
    This function will just remove the `fromClass` CSS class from the DOM element,
    and then add the `toClass` CSS class to the DOM element. In this way, we can change
    the icon used for our show / hide filter button from a chevron-right (`>`) to
    a chevron-left (`<`).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`IMediatorFunctions`接口有四个函数。`showLeftPanel`函数将显示我们的过滤面板。`hideLeftPanel`函数将隐藏过滤面板。`cyclePanels`函数将以`'prev'`字符串或`'next'`字符串调用，以将轮播面板从`carousel_panel_1`循环到`carousel_panel_2`。`showFilterButtonChangeClass`将以两个参数调用——一个是CSS类的`fromClass`字符串，另一个是另一个CSS类的`toClass`字符串。这个函数将从DOM元素中删除`fromClass`
    CSS类，然后将`toClass` CSS类添加到DOM元素中。通过这种方式，我们可以将用于显示/隐藏过滤按钮的图标从chevron-right（`>`）更改为chevron-left（`<`）。
- en: 'We can now look at the internal logic of the `Mediator` class itself, starting
    with a set of private variables and the constructor:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看一下`Mediator`类本身的内部逻辑，从一组私有变量和构造函数开始：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `Mediator` class has a number of private variables. The `_currentState`
    variable is used to hold an instance of one of our `State` classes, and represents
    the current state of the UI. This `_currentState` variable can hold any one of
    our three states. The `_currentMainPanelState` variable again holds one of our
    `State` classes, but represents the current state of the main panel. This `_currentMainPanelState`
    will only hold either a `BoardListOnlyState`, or a `BoardListWithFilterPanelState`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Mediator`类有许多私有变量。`_currentState`变量用于保存我们`State`类之一的实例，并表示UI的当前状态。这个`_currentState`变量可以保存我们三个状态中的任何一个。`_currentMainPanelState`变量再次保存我们的`State`类之一，但表示主面板的当前状态。这个`_currentMainPanelState`只会保存`BoardListOnlyState`或`BoardListWithFilterPanelState`中的一个。
- en: The `_pageViewLayout` variable will hold an instance of the class that implements
    our `IMediatorFunctions` interface, and we will apply state changes to the UI
    through this variable. For those of you familiar with the MVP pattern, the `Mediator`
    class is acting as a Presenter, and the `_pageViewLayout` variable is acting as
    the View.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`_pageViewLayout`变量将保存实现我们的`IMediatorFunctions`接口的类的实例，我们将通过这个变量对UI应用状态变化。对于熟悉MVP模式的人来说，`Mediator`类充当Presenter，`_pageViewLayout`变量充当View。'
- en: The `_isMobile` variable just holds a boolean value indicating whether or not
    we are on a mobile device. We will set this variable a little later.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`_isMobile`变量只是保存一个布尔值，指示我们是否在移动设备上。我们稍后会设置这个变量。'
- en: We then have three private variables that will hold instances of our three states—
    `BoardListOnlyState`, `DetailPanelState`, and `BoardListWithFilterPanelState`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有三个私有变量，它们将保存我们三个状态的实例——`BoardListOnlyState`、`DetailPanelState`和`BoardListWithFilterPanelState`。
- en: Our constructor simply sets up these private variables, and then instantiates
    an instance of each of our state classes, assigning them to the correct internal
    variable.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数简单地设置了这些私有变量，然后实例化了我们每个状态类的一个实例，并将它们分配给正确的内部变量。
- en: Note the code near the bottom of the constructor. This is the implementation
    of one of our business rules. If the application is being viewed on a mobile device,
    then the filter panel should NOT be visible by default. We are, therefore, setting
    the value of the `_currentState` variable to one of the initial states, based
    on our `isMobile` flag. To round out our constructor function, we also set the
    initial value of the `_currentMainPanelState` variable to the `_currentState`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意构造函数底部附近的代码。这是我们一个业务规则的实现。如果应用程序在移动设备上查看，则过滤面板默认情况下不应可见。因此，我们将`_currentState`变量的值设置为初始状态之一，基于我们的`isMobile`标志。为了完成构造函数功能，我们还将`_currentMainPanelState`变量的初始值设置为`_currentState`。
- en: 'Our next `Mediator` function, `getNextState`, simply returns one of our private
    `State` variables, using a `StateType` enum as input:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个`Mediator`函数`getNextState`只是使用`StateType`枚举作为输入返回我们的私有`State`变量之一：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is essentially a mini factory method, and will return the correct internal
    `State` object, based on the value of the `StateType` argument.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是一个迷你工厂方法，将根据`StateType`参数的值返回正确的内部`State`对象。
- en: Moving to a new State
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转移到新状态
- en: 'The main body of logic that controls how the UI needs to be updated, based
    on the movement between states, is implemented in the `moveToState` function,
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 控制UI如何根据状态之间的移动更新的主要逻辑体现在`moveToState`函数中，如下所示：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This function will be called whenever we want to move from one state to another.
    The first thing this function does, is to set up two variables: `previousState`
    and `nextState`. The `previousState` variable is actually our current state object,
    and the `nextState` variable is a `State` object for the state that we are moving
    to.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在我们想要从一个状态转换到另一个状态时调用。这个函数做的第一件事是设置两个变量：`previousState`和`nextState`。`previousState`变量实际上是我们当前的状态对象，而`nextState`变量是我们要转移到的状态的`State`对象。
- en: We can now compare the `previousState` variable with the `nextState` variable
    and make some decisions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以比较`previousState`变量和`nextState`变量并做出一些决定。
- en: 'The logic for our first if statement goes something like this: if we are moving
    from an `Initial` panel type to a `Secondary` panel, then call the relevant functions
    on the UI to hide the left panel, and initiate a carousel cycle to `''next''`.
    This logic will fix the Firefox bug that we were notified of earlier.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个if语句的逻辑大致如下：如果我们从“Initial”面板类型移动到“Secondary”面板，则调用UI上的相关函数隐藏左侧面板，并启动轮播循环到“next”。这个逻辑将修复我们之前收到的Firefox错误。
- en: 'The logic for our second if statement is the opposite of the first one: if
    we are moving from a `Secondary` panel to an `Initial` panel, then initiate a
    carousel cycle with `''prev''`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第二个if语句的逻辑与第一个相反：如果我们从`Secondary`面板移动到`Initial`面板，那么就用`'prev'`来启动轮播循环。
- en: The next step in our logic applies the class for the show / hide filter button
    to the UI, by calling the `showFilterButtonChangeClass` function on the UI, passing
    in the CSS class name from the `previousState`, and the CSS class name from the
    `nextState` as arguments. Remember that this will remove the CSS class from `previousState`,
    and then add the CSS class from `nextState` to the show / hide filter button CSS.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逻辑的下一步是通过在UI上调用`showFilterButtonChangeClass`函数，将显示/隐藏过滤按钮的类应用到UI上，传入来自`previousState`的CSS类名和来自`nextState`的CSS类名作为参数。请记住，这将从`previousState`中移除CSS类，然后将`nextState`中的CSS类添加到显示/隐藏过滤按钮的CSS中。
- en: Our next logical step checks whether the filter panel should be shown or hidden,
    and calls the corresponding function on our `_pageViewLayout`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个逻辑步骤是检查过滤面板是否应该显示或隐藏，并在我们的`_pageViewLayout`上调用相应的函数。
- en: As we are now done with our state change logic, and can set the value of the
    `_currentState` variable to now hold our `nextState`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经完成了状态更改逻辑，并且可以将`_currentState`变量的值设置为持有我们的`nextState`。
- en: The last piece of logic just checks to see whether we are currently in `BoardListOnly`
    or `BoardListWithFilter` state, and if so, stores the current state in the `_currentMainPanelState`
    variable. This logic will form part of the business rules that we have been given,
    to ensure that when we switch from our main panel to our detail panel and back
    again, the status of the filter panel is maintained correctly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分逻辑只是检查我们当前是否处于`BoardListOnly`或`BoardListWithFilter`状态，如果是的话，将当前状态存储在`_currentMainPanelState`变量中。这个逻辑将成为我们已经给出的业务规则的一部分，以确保当我们从主面板切换到详细面板，然后再切换回来时，过滤面板的状态被正确地维护。
- en: 'We have two more functions in our `Mediator` class to discuss, which are as
    follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Mediator`类中还有两个要讨论的函数，如下所示：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first function, called `showHideFilterButtonClicked` is actually the function
    that will need to be called when we click on the show / hide filter button in
    our application. Depending on whether the filter panel is open or closed, the
    behavior of this button will be slightly different. The only object that knows
    what to do, depending on what state the application is in, is the `Mediator` class
    itself. So, we are deferring the decision-making on what to do when the button
    is clicked, to the `Mediator` class.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数叫做`showHideFilterButtonClicked`，实际上是当我们在应用程序中点击显示/隐藏过滤按钮时需要调用的函数。根据过滤面板是打开还是关闭，此按钮的行为会略有不同。唯一知道根据应用程序的状态该做什么的对象是`Mediator`类本身。因此，我们将决定当按钮被点击时该做什么的决策推迟到`Mediator`类。
- en: The implementation of the `showHideFilterButtonClicked` function just checks
    what our current state is, and then calls a `moveToState` with the correct `nextState`
    as the parameter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`showHideFilterButtonClicked`函数的实现只是检查我们当前的状态是什么，然后调用一个带有正确`nextState`作为参数的`moveToState`。'
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you are building a large-scale application, there may be many different
    buttons or screen elements that change slightly depending on what state your application
    is in. Deferring the decision-making logic to a Mediator class provides a simple
    and elegant way of managing all of your screen elements. This business logic is
    captured in one place, and can also be tested thoroughly. Be sure to check the
    sample code for a full suite of tests surrounding the Mediator class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建大型应用程序时，可能会有许多不同的按钮或屏幕元素，这些元素会根据应用程序的状态稍有不同。将决策逻辑推迟到中介者类提供了一种简单而优雅的方式来管理所有屏幕元素。这个业务逻辑被捕获在一个地方，并且也可以得到充分的测试。一定要检查中介者类周围的完整测试套件的示例代码。
- en: Our final function, `getCurrentMainPanelState`, simply returns the last known
    state of our main panel, and will be used to implement the business logic for
    remembering whether the filter panel is open or closed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个函数`getCurrentMainPanelState`只是返回我们主面板的最后已知状态，并将用于实现业务逻辑，以记住过滤面板是打开还是关闭。
- en: Implementing the IMediatorFunctions interface
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现IMediatorFunctions接口
- en: 'When the `Mediator` class needs to trigger changes to the UI, it calls functions
    on the `IMediatorFunctions` interface, as we have seen previously. Our application,
    therefore, must implement this `IMediatorFunctions` interface somewhere. As the
    `PageViewLayout` class holds references to each of the UI elements we need to
    change, the logical place to implement this interface is on the `PageViewLayout`
    class itself, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Mediator`类需要触发对UI的更改时，它会调用`IMediatorFunctions`接口上的函数，就像我们之前看到的那样。因此，我们的应用程序必须在某个地方实现这个`IMediatorFunctions`接口。由于`PageViewLayout`类持有我们需要更改的每个UI元素的引用，因此实现这个接口的逻辑地方是在`PageViewLayout`类本身，如下所示：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We have updated our `PageViewLayout` class to implement all of the functions
    in the `IMediatorFunctions` interface. We have also included a private variable
    named `_mediator` to hold an instance of the `Mediator` class, and set this up
    in our constructor.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了我们的`PageViewLayout`类，以实现`IMediatorFunctions`接口中的所有函数。我们还包括了一个名为`_mediator`的私有变量，用于保存`Mediator`类的一个实例，并在我们的构造函数中设置这个实例。
- en: As with our other views that need to respond to click events, we have set up
    an `options.events` object to tie a DOM `click` event on the `#show_filter_button`
    DOM element (which is our show / hide button), to the `showHideFilterButtonClicked`
    function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他需要响应点击事件的视图一样，我们设置了一个`options.events`对象，将DOM上的`click`事件与`#show_filter_button`
    DOM元素（我们的显示/隐藏按钮）绑定到`showHideFilterButtonClicked`函数上。
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using jQuery to check whether the main HTML element in our page has a
    class named `mobile`. This class will be set by the `head.js` utility script that
    we included in our `index.html` page at the beginning of this chapter. In this
    way, we are able to determine whether our application is being used on a mobile
    or desktop device.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用jQuery来检查我们页面中的主HTML元素是否有一个名为`mobile`的类。这个类将由我们在本章开头包含在`index.html`页面中的`head.js`实用程序脚本设置。通过这种方式，我们能够确定我们的应用程序是在移动设备上还是在桌面设备上使用。
- en: The `showLeftPanel` and `hideLeftPanel` functions just include the jQuery snippets
    to apply or remove the relevant classes, in order to slide the filter panel in
    or out.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`showLeftPanel`和`hideLeftPanel`函数只是包含了jQuery片段，以应用或移除相关的类，以便滑动筛选面板进入或退出。'
- en: The `cyclePanels` function calls our Bootstrap carousel function with either
    a `'next'` or `'prev'` parameter, as we did in our demo HTML page.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclePanels`函数调用我们的Bootstrap轮播函数，带有`''next''`或`''prev''`参数，就像我们在演示HTML页面中所做的那样。'
- en: The `showFilterButtonChangeClass` simply removes the `fromClass` CSS style from
    our `show_filter_button` DOM element, and then adds the new `toClass` CSS style.
    Removing and adding these CSS classes will switch the button displayed from a
    left chevron (`<`) to a right chevron (`>`), or vica versa.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`showFilterButtonChangeClass`只是从我们的`show_filter_button` DOM元素中移除`fromClass`
    CSS样式，然后添加新的`toClass` CSS样式。移除和添加这些CSS类将切换按钮的显示，从左切换到右（`<`到`>`），或者反之。'
- en: When a user clicks on the `#show_filter_button` DOM element, our `showHideFilterButtonClicked`
    method will be invoked. As discussed earlier, we are forwarding this call to the
    `Mediator` instance, so that the `Mediator` logic can make the decision as to
    what to do when the button is clicked.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`#show_filter_button` DOM元素时，我们的`showHideFilterButtonClicked`方法将被调用。正如之前讨论的，我们正在将这个调用转发到`Mediator`实例，以便`Mediator`逻辑可以决定当按钮被点击时该做什么。
- en: Triggering State changes
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发状态变化
- en: To finish off our State and Mediator Design Pattern, we will now just need to
    call the `Mediator` functions in the right places, in order to trigger the logic
    to move to a different state.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的状态和中介者设计模式，我们现在只需要在正确的位置调用`Mediator`函数，以触发逻辑移动到不同的状态。
- en: 'The first place we call the `moveToState` function is in our `handle_NotifyEvent`,
    when our `ManufacturerDataLoaded` event is triggered. This event only ever occurs
    once in our application, and that is after the `ManufacturerCollection` has been
    successfully loaded. We already have an event handler for this in our `PageViewLayout`
    class, so let''s update this function as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次调用`moveToState`函数的地方是在我们的`handle_NotifyEvent`中，当我们的`ManufacturerDataLoaded`事件被触发时。这个事件在我们的应用程序中只会发生一次，那就是在`ManufacturerCollection`成功加载之后。我们已经在我们的`PageViewLayout`类中有一个事件处理程序，所以让我们更新这个函数如下：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Our first `if` statement checks for the `ManufacturerDataLoaded` event type,
    and then creates a new `ManufacturerCollectionView` and calls its `render` function,
    as we have seen previously. We then call the `moveToState` function, passing in
    the Mediator's `currentMainPanelState` as an argument. Remember how we set the
    initial main panel state in the Mediator's constructor, based on whether or not
    the browser was on a mobile device? This call to `moveToState` will use that initial
    state as a parameter, essentially starting the application in the correct state.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`if`语句检查`ManufacturerDataLoaded`事件类型，然后创建一个新的`ManufacturerCollectionView`并调用它的`render`函数，就像我们之前看到的那样。然后我们调用`moveToState`函数，传入中介者的`currentMainPanelState`作为参数。还记得我们如何在中介者的构造函数中根据浏览器是否在移动设备上设置了初始主面板状态吗？这次对`moveToState`的调用将使用该初始状态作为参数，从而在正确的状态下启动应用程序。
- en: Our second `if` statement will trigger a `moveToState` when the user is in the
    `BoardDetail` screen, and clicks on the back button on the header panel. This
    logic again uses the `currentMainPanelState` to restore our board list to the
    correct state, according to our business rules.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个`if`语句将在用户在`BoardDetail`屏幕上，并在标题面板上点击返回按钮时触发`moveToState`。这个逻辑再次使用`currentMainPanelState`根据我们的业务规则将我们的板块列表恢复到正确的状态。
- en: 'The other function within the `PageLayoutView` that will trigger a call to
    `moveToState`, is our handler for a `BoardSelectedEvent`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageLayoutView`中的另一个函数将触发对`moveToState`的调用，是我们对`BoardSelectedEvent`的处理程序：'
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Whenever a user clicks on a board in the board list, a `BoardSelectedEvent`
    is triggered, and we render the `BoardDetailView`. This `BoardDetailView`, however,
    is on the second carousel panel, so we will need to move to the `BoardDetail`
    state as part of this event handler.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户在板块列表中点击一个板块时，都会触发一个`BoardSelectedEvent`，然后我们渲染`BoardDetailView`。然而，这个`BoardDetailView`位于第二个轮播面板上，所以我们需要在这个事件处理程序中移动到`BoardDetail`状态。
- en: 'Lastly, we will need to trigger the `moveToState` function when the user is
    in a `BoardDetailView`, and clicks on the back button. To implement this, we will
    need to raise a `NotifyEvent`, with the `eventType` set to `BoardDetailBackClicked`,
    from our `BoardDetailView`, as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户在`BoardDetailView`中，并点击返回按钮时，我们需要触发`moveToState`函数。为了实现这一点，我们需要从我们的`BoardDetailView`中触发一个`NotifyEvent`，并将`eventType`设置为`BoardDetailBackClicked`，如下所示：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, we have tied the `onPrev` function to the DOM `click` event on the `#prev_button`
    element. Once a click is triggered, we simply need to raise a new `NotifyEvent`,
    with the `eventType` set to `BoardDetailBackClicked`, in order to trigger a `moveToState`
    function call.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`onPrev`函数绑定到`#prev_button`元素上的DOM`click`事件。一旦触发了点击，我们只需要触发一个新的`NotifyEvent`，并将`eventType`设置为`BoardDetailBackClicked`，以触发`moveToState`函数调用。
- en: With our State and Mediator Design Pattern classes in place, our sample application
    is now complete.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的状态和中介者设计模式类，我们的示例应用现在已经完成。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a full TypeScript single-page application from the
    ground up. We started with an initial idea of how the application would be designed,
    and how we wanted the pages to transition. We then built a pure HTML demo page
    using out-of-the-box Bootstrap elements, and sprinkled a little JavaScript magic
    to create a full demo page. We applied various styles to the HTML, previewed it
    in Brackets, and tweaked the look and feel until we were happy.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从头开始构建了一个完整的TypeScript单页应用程序。我们从应用程序设计的初始想法开始，以及我们希望页面如何过渡。然后，我们使用现成的Bootstrap元素构建了一个纯HTML演示页面，并添加了一些JavaScript魔法来创建一个完整的演示页面。我们对HTML应用了各种样式，在Brackets中预览，并调整外观，直到满意为止。
- en: Our next major step was to understand, and work with, the data structures that
    we would need within our application. We wrote Jasmine unit tests and integration
    tests to solidify our Backbone models and collections, and wrote the filtering
    functions that we needed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的主要步骤是理解并处理我们应用程序中需要的数据结构。我们编写了Jasmine单元测试和集成测试来巩固我们的Backbone模型和集合，并编写了我们需要的过滤函数。
- en: We then built up a set of Marionette views, and split up our demo HTML into
    snippets for each of these views to use. We tied the views to our collections
    and models, and used interfaces to work with data providers. Our application then
    started to come together by working with real server-side data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们建立了一组Marionette视图，并将我们的演示HTML拆分成每个视图使用的片段。我们将视图与我们的集合和模型联系起来，并使用接口与数据提供程序一起工作。我们的应用程序随后开始通过使用真实的服务器端数据来完善。
- en: Finally, we discussed page transition strategies, and implemented a State and
    Mediator Design Pattern to implement our required business logic.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了页面过渡策略，并实现了状态和中介者设计模式来实现我们所需的业务逻辑。
- en: Hopefully, you have enjoyed the journey of building an application from the
    ground up—from concept to visualization, and then through implementation and testing.
    We have finally arrived at an industrial strength, enterprise ready, TypeScript
    single-page Marionette application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢从头开始构建应用程序的旅程——从概念到可视化，然后通过实施和测试。我们最终到达了一个工业强度、企业就绪的TypeScript单页Marionette应用程序。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
