["```cs\npublic class TreeNode<T> \n{ \n    public T Data { get; set; } \n    public TreeNode<T> Parent { get; set; } \n    public List<TreeNode<T>> Children { get; set; } \n\n    public int GetHeight() \n    { \n        int height = 1; \n        TreeNode<T> current = this; \n        while (current.Parent != null) \n        { \n            height++; \n            current = current.Parent; \n        } \n        return height; \n    } \n} \n```", "```cs\npublic class Tree<T> \n{ \n    public TreeNode<T> Root { get; set; } \n} \n```", "```cs\nTree<int> tree = new Tree<int>(); \ntree.Root = new TreeNode<int>() { Data = 100 }; \ntree.Root.Children = new List<TreeNode<int>> \n{ \n    new TreeNode<int>() { Data = 50, Parent = tree.Root }, \n    new TreeNode<int>() { Data = 1, Parent = tree.Root }, \n    new TreeNode<int>() { Data = 150, Parent = tree.Root } \n}; \ntree.Root.Children[2].Children = new List<TreeNode<int>>() \n{ \n    new TreeNode<int>()  \n        { Data = 30, Parent = tree.Root.Children[2] } \n}; \n```", "```cs\npublic class Person \n{ \n    public int Id { get; set; } \n    public string Name { get; set; } \n    public string Role { get; set; } \n\n    public Person() { } \n\n    public Person(int id, string name, string role) \n    { \n        Id = id; \n        Name = name; \n        Role = role; \n    } \n} \n```", "```cs\nTree<Person> company = new Tree<Person>(); \ncompany.Root = new TreeNode<Person>() \n{ \n    Data = new Person(100, \"Marcin Jamro\", \"CEO\"), \n    Parent = null \n}; \ncompany.Root.Children = new List<TreeNode<Person>>() \n{ \n    new TreeNode<Person>() \n    { \n        Data = new Person(1, \"John Smith\", \"Head of Development\"), \n        Parent = company.Root \n    }, \n    new TreeNode<Person>() \n    { \n        Data = new Person(50, \"Mary Fox\", \"Head of Research\"), \n        Parent = company.Root \n    }, \n    new TreeNode<Person>() \n    { \n        Data = new Person(150, \"Lily Smith\", \"Head of Sales\"), \n        Parent = company.Root \n    } \n}; \ncompany.Root.Children[2].Children = new List<TreeNode<Person>>() \n{ \n    new TreeNode<Person>() \n    {\n        Data = new Person(30, \"Anthony Black\", \"Sales Specialist\"),\n        Parent = company.Root.Children[2]\n    } \n}; \n```", "```cs\npublic class TreeNode<T> \n{ \n    public T Data { get; set; } \n    public TreeNode<T> Parent { get; set; } \n    public List<TreeNode<T>> Children { get; set; } \n\n    public int GetHeight() \n    { \n        int height = 1; \n        TreeNode<T> current = this; \n        while (current.Parent != null) \n        { \n            height++; \n            current = current.Parent; \n        } \n        return height; \n    } \n} \n```", "```cs\npublic class BinaryTreeNode<T> : TreeNode<T> \n{ \n    public BinaryTreeNode() => Children =  \n        new List<TreeNode<T>>() { null, null }; \n\n    public BinaryTreeNode<T> Left \n    { \n        get { return (BinaryTreeNode<T>)Children[0]; } \n        set { Children[0] = value; } \n    } \n\n    public BinaryTreeNode<T> Right \n    { \n        get { return (BinaryTreeNode<T>)Children[1]; } \n        set { Children[1] = value; } \n    } \n} \n```", "```cs\npublic class BinaryTree<T> \n{ \n    public BinaryTreeNode<T> Root { get; set; } \n    public int Count { get; set; } \n} \n```", "```cs\nprivate void TraversePreOrder(BinaryTreeNode<T> node,  \n    List<BinaryTreeNode<T>> result) \n{ \n    if (node != null) \n    { \n        result.Add(node); \n        TraversePreOrder(node.Left, result); \n        TraversePreOrder(node.Right, result); \n    } \n} \n```", "```cs\nprivate void TraverseInOrder(BinaryTreeNode<T> node,  \n    List<BinaryTreeNode<T>> result) \n{ \n    if (node != null) \n    { \n        TraverseInOrder(node.Left, result); \n        result.Add(node); \n        TraverseInOrder(node.Right, result); \n    } \n} \n```", "```cs\nprivate void TraversePostOrder(BinaryTreeNode<T> node,  \n    List<BinaryTreeNode<T>> result) \n{ \n    if (node != null) \n    { \n        TraversePostOrder(node.Left, result); \n        TraversePostOrder(node.Right, result); \n        result.Add(node); \n    } \n} \n```", "```cs\npublic List<BinaryTreeNode<T>> Traverse(TraversalEnum mode) \n{ \n    List<BinaryTreeNode<T>> nodes = new List<BinaryTreeNode<T>>(); \n    switch (mode) \n    { \n        case TraversalEnum.PREORDER: \n            TraversePreOrder(Root, nodes); \n            break; \n        case TraversalEnum.INORDER: \n            TraverseInOrder(Root, nodes); \n            break; \n        case TraversalEnum.POSTORDER: \n            TraversePostOrder(Root, nodes); \n            break; \n    } \n    return nodes; \n} \n```", "```cs\npublic enum TraversalEnum \n{ \n    PREORDER, \n    INORDER, \n    POSTORDER \n} \n```", "```cs\npublic int GetHeight() \n{ \n    int height = 0; \n    foreach (BinaryTreeNode<T> node  \n        in Traverse(TraversalEnum.PREORDER)) \n    { \n        height = Math.Max(height, node.GetHeight()); \n    } \n    return height; \n} \n```", "```cs\npublic class QuizItem \n{ \n    public string Text { get; set; } \n    public QuizItem(string text) => Text = text; \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n    BinaryTree<QuizItem> tree = GetTree(); \n    BinaryTreeNode<QuizItem> node = tree.Root; \n    while (node != null) \n    { \n        if (node.Left != null || node.Right != null) \n        { \n            Console.Write(node.Data.Text); \n            switch (Console.ReadKey(true).Key) \n            { \n                case ConsoleKey.Y: \n                    WriteAnswer(\" Yes\"); \n                    node = node.Left; \n                    break; \n                case ConsoleKey.N: \n                    WriteAnswer(\" No\"); \n                    node = node.Right; \n                    break; \n            } \n        } \n        else \n        { \n            WriteAnswer(node.Data.Text); \n            node = null; \n        } \n    } \n} \n```", "```cs\nprivate static BinaryTree<QuizItem> GetTree() \n{ \n    BinaryTree<QuizItem> tree = new BinaryTree<QuizItem>(); \n    tree.Root = new BinaryTreeNode<QuizItem>() \n    { \n        Data = new QuizItem(\"Do you have experience in developing  \n            applications?\"), \n        Children = new List<TreeNode<QuizItem>>() \n        { \n            new BinaryTreeNode<QuizItem>() \n            { \n                Data = new QuizItem(\"Have you worked as a  \n                    developer for more than 5 years?\"), \n                Children = new List<TreeNode<QuizItem>>() \n                { \n                    new BinaryTreeNode<QuizItem>() \n                    { \n                        Data = new QuizItem(\"Apply as a senior  \n                            developer!\") \n                    }, \n                    new BinaryTreeNode<QuizItem>() \n                    { \n                        Data = new QuizItem(\"Apply as a middle  \n                            developer!\") \n                    } \n                } \n            }, \n            new BinaryTreeNode<QuizItem>() \n            { \n                Data = new QuizItem(\"Have you completed  \n                    the university?\"), \n                Children = new List<TreeNode<QuizItem>>() \n                { \n                    new BinaryTreeNode<QuizItem>() \n                    { \n                        Data = new QuizItem(\"Apply for a junior  \n                            developer!\") \n                    }, \n                    new BinaryTreeNode<QuizItem>() \n                    { \n                        Data = new QuizItem(\"Will you find some  \n                            time during the semester?\"), \n                        Children = new List<TreeNode<QuizItem>>() \n                        { \n                            new BinaryTreeNode<QuizItem>() \n                            { \n                                Data = new QuizItem(\"Apply for our  \n                                   long-time internship program!\") \n                            }, \n                            new BinaryTreeNode<QuizItem>() \n                            { \n                                Data = new QuizItem(\"Apply for  \n                                   summer internship program!\") \n                            } \n                        } \n                    } \n                } \n            } \n        } \n    }; \n    tree.Count = 9; \n    return tree; \n} \n```", "```cs\nprivate static void WriteAnswer(string text) \n{ \n    Console.ForegroundColor = ConsoleColor.White; \n    Console.WriteLine(text); \n    Console.ForegroundColor = ConsoleColor.Gray; \n} \n```", "```cs\npublic class BinaryTreeNode<T> : TreeNode<T> \n{ \n    public BinaryTreeNode() => Children =  \n        new List<TreeNode<T>>() { null, null }; \n\n    public BinaryTreeNode<T> Parent { get; set; } \n\n    public BinaryTreeNode<T> Left \n    { \n        get { return (BinaryTreeNode<T>)Children[0]; } \n        set { Children[0] = value; } \n    } \n\n    public BinaryTreeNode<T> Right \n    { \n        get { return (BinaryTreeNode<T>)Children[1]; } \n        set { Children[1] = value; } \n    } \n\n    public int GetHeight() \n    { \n        int height = 1; \n        BinaryTreeNode<T> current = this; \n        while (current.Parent != null) \n        { \n            height++; \n            current = current.Parent; \n        } \n        return height; \n    } \n} \n```", "```cs\npublic class TreeNode<T> \n{ \n    public T Data { get; set; } \n    public List<TreeNode<T>> Children { get; set; } \n} \n```", "```cs\npublic class BinarySearchTree<T> : BinaryTree<T>  \n    where T : IComparable \n{ \n} \n```", "```cs\npublic bool Contains(T data) \n{ \n    BinaryTreeNode<T> node = Root; \n    while (node != null) \n    { \n        int result = data.CompareTo(node.Data); \n        if (result == 0) \n        { \n            return true; \n        } \n        else if (result < 0) \n        { \n            node = node.Left; \n        } \n        else \n        { \n            node = node.Right; \n        } \n    } \n    return false; \n} \n```", "```cs\npublic void Add(T data) \n{ \n    BinaryTreeNode<T> parent = GetParentForNewNode(data); \n    BinaryTreeNode<T> node = new BinaryTreeNode<T>()  \n        { Data = data, Parent = parent }; \n\n    if (parent == null) \n    { \n        Root = node; \n    } \n    else if (data.CompareTo(parent.Data) < 0) \n    { \n        parent.Left = node; \n    } \n    else \n    { \n        parent.Right = node; \n    } \n\n    Count++; \n} \n```", "```cs\nprivate BinaryTreeNode<T> GetParentForNewNode(T data) \n{ \n    BinaryTreeNode<T> current = Root; \n    BinaryTreeNode<T> parent = null; \n    while (current != null) \n    { \n        parent = current; \n        int result = data.CompareTo(current.Data); \n        if (result == 0) \n        { \n            throw new ArgumentException( \n                $\"The node {data} already exists.\"); \n        } \n        else if (result < 0) \n        { \n            current = current.Left; \n        } \n        else \n        { \n            current = current.Right; \n        } \n    } \n\n    return parent; \n} \n```", "```cs\npublic void Remove(T data) \n{ \n    Remove(Root, data); \n} \n```", "```cs\nprivate void Remove(BinaryTreeNode<T> node, T data) \n{ \n    if (node == null)\n    {\n        throw new ArgumentException(\n            $\"The node {data} does not exist.\");\n    }\n    else if (data.CompareTo(node.Data) < 0) \n    { \n        Remove(node.Left, data); \n    } \n    else if (data.CompareTo(node.Data) > 0) \n    { \n        Remove(node.Right, data); \n    } \n    else \n    { \n        if (node.Left == null && node.Right == null) \n        { \n            ReplaceInParent(node, null); \n            Count--; \n        } \n        else if (node.Right == null) \n        { \n            ReplaceInParent(node, node.Left); \n            Count--; \n        } \n        else if (node.Left == null) \n        { \n            ReplaceInParent(node, node.Right); \n            Count--; \n        } \n        else \n        { \n            BinaryTreeNode<T> successor =  \n                FindMinimumInSubtree(node.Right); \n            node.Data = successor.Data; \n            Remove(successor, successor.Data); \n        } \n    } \n} \n```", "```cs\nReplaceInParent(node, node.Left); \nCount--; \n```", "```cs\nBinaryTreeNode<T> successor = FindMinimumInSubtree(node.Right); \nnode.Data = successor.Data; \nRemove(successor, successor.Data); \n```", "```cs\nprivate void ReplaceInParent(BinaryTreeNode<T> node,  \n    BinaryTreeNode<T> newNode) \n{ \n    if (node.Parent != null) \n    { \n        if (node.Parent.Left == node) \n        { \n            node.Parent.Left = newNode; \n        } \n        else \n        { \n            node.Parent.Right = newNode; \n        } \n    } \n    else \n    { \n        Root = newNode; \n    } \n\n    if (newNode != null) \n    { \n        newNode.Parent = node.Parent; \n    } \n} \n```", "```cs\nprivate BinaryTreeNode<T> FindMinimumInSubtree( \n    BinaryTreeNode<T> node) \n{ \n    while (node.Left != null) \n    { \n        node = node.Left; \n    } \n    return node; \n} \n```", "```cs\nclass Program \n{ \n    private const int COLUMN_WIDTH = 5; \n\n    public static void Main(string[] args) \n    { \n        Console.OutputEncoding = Encoding.UTF8; \n\n        BinarySearchTree<int> tree = new BinarySearchTree<int>(); \n        tree.Root = new BinaryTreeNode<int>() { Data = 100 }; \n        tree.Root.Left = new BinaryTreeNode<int>()  \n            { Data = 50, Parent = tree.Root }; \n        tree.Root.Right = new BinaryTreeNode<int>()  \n            { Data = 150, Parent = tree.Root }; \n        tree.Count = 3; \n        VisualizeTree(tree, \"The BST with three nodes  \n            (50, 100, 150):\"); \n\n        tree.Add(75); \n        tree.Add(125); \n        VisualizeTree(tree, \"The BST after adding two nodes  \n            (75, 125):\"); (...) \n\n        tree.Remove(25); \n        VisualizeTree(tree,  \n            \"The BST after removing the node 25:\"); (...) \n\n        Console.Write(\"Pre-order traversal:\\t\"); \n        Console.Write(string.Join(\", \", tree.Traverse( \n            TraversalEnum.PREORDER).Select(n => n.Data))); \n        Console.Write(\"\\nIn-order traversal:\\t\"); \n        Console.Write(string.Join(\", \", tree.Traverse( \n            TraversalEnum.INORDER).Select(n => n.Data))); \n        Console.Write(\"\\nPost-order traversal:\\t\"); \n        Console.Write(string.Join(\", \", tree.Traverse( \n            TraversalEnum.POSTORDER).Select(n => n.Data))); \n    } \n```", "```cs\nBinarySearchTree<int> tree = new BinarySearchTree<int>(); \ntree.Root = new BinaryTreeNode<int>() { Data = 100 }; \ntree.Root.Left = new BinaryTreeNode<int>()  \n    { Data = 50, Parent = tree.Root }; \ntree.Root.Right = new BinaryTreeNode<int>()  \n    { Data = 150, Parent = tree.Root }; \ntree.Count = 3; \n```", "```cs\ntree.Add(125); \nVisualizeTree(tree, \"The BST after adding two nodes (75, 125):\"); \n```", "```cs\ntree.Remove(25); \nVisualizeTree(tree, \"The BST after removing the node 25:\"); \n```", "```cs\nConsole.WriteLine(\"Pre-order traversal:\\t\"); \nConsole.Write(string.Join(\", \",  \n    tree.Traverse(TraversalEnum.PREORDER).Select(n => n.Data))); \n```", "```cs\nprivate static void VisualizeTree( \n    BinarySearchTree<int> tree, string caption) \n{ \n    char[][] console = InitializeVisualization( \n        tree, out int width); \n    VisualizeNode(tree.Root, 0, width / 2, console, width); \n    Console.WriteLine(caption); \n    foreach (char[] row in console) \n    { \n        Console.WriteLine(row); \n    } \n} \n```", "```cs\nprivate static char[][] InitializeVisualization( \n    BinarySearchTree<int> tree, out int width) \n{ \n    int height = tree.GetHeight(); \n    width = (int)Math.Pow(2, height) - 1; \n    char[][] console = new char[height * 2][]; \n    for (int i = 0; i < height * 2; i++) \n    { \n        console[i] = new char[COLUMN_WIDTH * width]; \n    } \n    return console; \n}\n```", "```cs\n                                        100\n                    \u250c-------------------+-------------------\u2510\n                    50                                      150\n          \u250c---------+---------\u2510                  \u250c---------+---------\u2510\n          25                  75                  125                 175\n                               +----\u2510        \u250c----+----\u2510\n                                   90        110       135\n\n```", "```cs\nprivate static void VisualizeNode(BinaryTreeNode<int> node, \n    int row, int column, char[][] console, int width) \n{ \n    if (node != null) \n    { \n        char[] chars = node.Data.ToString().ToCharArray(); \n        int margin = (COLUMN_WIDTH - chars.Length) / 2; \n        for (int i = 0; i < chars.Length; i++) \n        { \n            console[row][COLUMN_WIDTH * column + i + margin]  \n                = chars[i]; \n        } \n\n        int columnDelta = (width + 1) /  \n            (int)Math.Pow(2, node.GetHeight() + 1); \n        VisualizeNode(node.Left, row + 2, column - columnDelta,  \n            console, width); \n        VisualizeNode(node.Right, row + 2, column + columnDelta,  \n            console, width); \n        DrawLineLeft(node, row, column, console, columnDelta); \n        DrawLineRight(node, row, column, console, columnDelta); \n    } \n} \n```", "```cs\nprivate static void DrawLineLeft(BinaryTreeNode<int> node,  \n    int row, int column, char[][] console, int columnDelta) \n{ \n    if (node.Left != null) \n    { \n        int startColumnIndex =  \n            COLUMN_WIDTH * (column - columnDelta) + 2; \n        int endColumnIndex = COLUMN_WIDTH * column + 2; \n        for (int x = startColumnIndex + 1;  \n            x < endColumnIndex; x++) \n        { \n            console[row + 1][x] = '-'; \n        } \n        console[row + 1][startColumnIndex] = '\\u250c'; \n        console[row + 1][endColumnIndex] = '+'; \n    } \n} \n```", "```cs\nprivate static void DrawLineRight(BinaryTreeNode<int> node, \n    int row, int column, char[][] console, int columnDelta) \n{ \n    if (node.Right != null) \n    { \n        int startColumnIndex = COLUMN_WIDTH * column + 2; \n        int endColumnIndex =  \n            COLUMN_WIDTH * (column + columnDelta) + 2; \n        for (int x = startColumnIndex + 1;  \n            x < endColumnIndex; x++) \n        { \n            console[row + 1][x] = '-'; \n        } \n        console[row + 1][startColumnIndex] = '+'; \n        console[row + 1][endColumnIndex] = '\\u2510'; \n    } \n} \n```", "```cs\n    The BST with three nodes (50, 100, 150):\n          100\n     \u250c----+----\u2510\n     50        150 \n```", "```cs\n    The BST after adding two nodes (75, 125):\n                    100\n          \u250c---------+---------\u2510\n          50                  150\n           +----\u2510        \u250c----+\n               75        125\n```", "```cs\n    The BST after adding five nodes (25, 175, 90, 110, 135):\n                                        100\n                    \u250c-------------------+-------------------\u2510\n                    50                                      150\n          \u250c---------+---------\u2510                  \u250c---------+---------\u2510\n          25                  75                  125                 175\n                               +----\u2510        \u250c----+----\u2510\n                                   90        110       135  \n```", "```cs\n    The BST after removing the node 25:\n                                        100\n                    \u250c-------------------+-------------------\u2510\n                    50                                      150\n                    +---------\u2510                   \u250c---------+---------\u2510\n                              75                  125                 175\n                              +----\u2510         \u250c----+----\u2510\n                                   90        110       135 \n```", "```cs\n    The BST after removing the node 50:\n                                        100\n                    \u250c-------------------+-------------------\u2510\n                    75                                      150\n                    +----\u2510                        \u250c---------+---------\u2510\n                         90                       125                 175\n                                             \u250c----+----\u2510\n                                             110       135  \n```", "```cs\n    The BST after removing the node 100:\n                                        110\n                     \u250c-------------------+-------------------\u2510\n                    75                                      150\n                    +---------\u2510                   \u250c---------+---------\u2510\n                              90                  125                 175\n                                                  +----\u2510\n                                                       135\n```", "```cs\n    Pre-order traversal:    110, 75, 90, 150, 125, 135, 175\n    In-order traversal:     75, 90, 110, 125, 135, 150, 175\n    Post-order traversal:   90, 75, 135, 125, 175, 150, 110\n```", "```cs\nAvlTree<int> tree = new AvlTree<int>(); \nfor (int i = 1; i < 10; i++) \n{ \n    tree.Add(i); \n} \n\nConsole.WriteLine(\"In-order: \"  \n    + string.Join(\", \", tree.GetInorderEnumerator())); \nConsole.WriteLine(\"Post-order: \"  \n    + string.Join(\", \", tree.GetPostorderEnumerator())); \nConsole.WriteLine(\"Breadth-first: \"  \n    + string.Join(\", \", tree.GetBreadthFirstEnumerator())); \n\nAvlTreeNode<int> node = tree.FindNode(8); \nConsole.WriteLine($\"Children of node {node.Value} (height =  \n    {node.Height}): {node.Left.Value} and {node.Right.Value}.\"); \n```", "```cs\n    In-order: 1, 2, 3, 4, 5, 6, 7, 8, 9\n    Post-order: 1, 3, 2, 5, 7, 9, 8, 6, 4\n    Breadth-first: 4, 2, 6, 1, 3, 5, 8, 7, 9\n```", "```cs\n    Children of node 8 (height = 2): 7 and 9.\n```", "```cs\nRedBlackTreeList<int> tree = new RedBlackTreeList<int>(); \nfor (int i = 1; i <= 10; i++) \n{ \n    tree.Add(i); \n} \n```", "```cs\ntree.Remove(9); \n```", "```cs\nbool contains = tree.ContainsKey(5); \nConsole.WriteLine( \n    \"Does value exist? \" + (contains ? \"yes\" : \"no\")); \n```", "```cs\nuint count = tree.Count; \ntree.Greatest(out int greatest); \ntree.Least(out int least); \nConsole.WriteLine( \n    $\"{count} elements in the range {least}-{greatest}\"); \n```", "```cs\nConsole.WriteLine( \n    \"Values: \" + string.Join(\", \", tree.GetEnumerable())); \n```", "```cs\nConsole.Write(\"Values: \"); \nforeach (EntryList<int> node in tree) \n{ \n    Console.Write(node + \" \"); \n} \n```", "```cs\n    Does value exist? yes\n    9 elements in the range 1-10\n    Values: 1, 2, 3, 4, 5, 6, 7, 8, 10\n    Values: 1 2 3 4 5 6 7 8 10\n\n```", "```cs\nMultiHeap<int> heap = HeapFactory.NewBinaryHeap<int>(); \n```", "```cs\nList<int> unsorted = new List<int>() { 50, 33, 78, -23, 90, 41 }; \nMultiHeap<int> heap = HeapFactory.NewBinaryHeap<int>(); \nunsorted.ForEach(i => heap.Add(i)); \nConsole.WriteLine(\"Unsorted: \" + string.Join(\", \", unsorted)); \n\nList<int> sorted = new List<int>(heap.Count); \nwhile (heap.Count > 0) \n{ \n    sorted.Add(heap.RemoveMin()); \n} \nConsole.WriteLine(\"Sorted: \" + string.Join(\", \", sorted)); \n```", "```cs\n    Unsorted: 50, 33, 78, -23, 90, 41\n    Sorted: -23, 33, 41, 50, 78, 90\n\n```", "```cs\nMultiHeap<int> heap = HeapFactory.NewBinomialHeap<int>(); \n```", "```cs\nMultiHeap<int> heap = HeapFactory.NewFibonacciHeap<int>(); \n```"]