- en: Chapter 8. Application Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 应用模式
- en: Thus far we have spent a great deal of time examining patterns that are used
    to solve local problems, that is; problems that span only a handful of classes
    and not the whole application. These patterns have been narrow in scope. They
    frequently only relate to two or three classes and might be used but a single
    time in any given application. As you can imagine there are also larger scale
    patterns that are applicable to the application as a whole. You might think of
    "toolbar" as a general pattern that is used in many places in an application.
    What's more, it is a pattern that is used in a great number of applications to
    give them a similar look and feel. Patterns can help guide how the whole application
    is assembled.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了大量时间研究用于解决局部问题的模式，也就是说，仅涉及少数类而不是整个应用程序的问题。这些模式的范围很窄。它们通常只涉及两三个类，并且在任何给定的应用程序中可能只使用一次。你可以想象一下，也有适用于整个应用程序的更大规模的模式。你可以把“工具栏”看作是一个通用模式，它在应用程序的许多地方使用。而且，它是在许多应用程序中使用的模式，以赋予它们相似的外观和感觉。模式可以指导整个应用程序的组装方式。
- en: In this chapter we're going to look at a family of patterns which I've taken
    to calling the MV* family. This family includes MVC, MVVM, MVP, and even PAC.
    Just like their names, the patterns themselves are pretty similar. The chapter
    will cover each of these patterns and show how, or if, we can apply them to JavaScript.
    We'll also pay special attention to how the patterns differ from one another.
    By the end of the chapter you should be able to thrill guests at a cocktail party
    with an explanation of the nuances of MVP versus MVC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下一个我称之为MV*家族的模式。这个家族包括MVC、MVVM、MVP，甚至PAC。就像它们的名字一样，这些模式本身非常相似。本章将涵盖这些模式，并展示如何，或者是否可以将它们应用到JavaScript中。我们还将特别关注这些模式之间的区别。在本章结束时，你应该能够在鸡尾酒会上以MVP与MVC的微妙差异为话题，让客人们感到兴奋。
- en: 'The topics covered will be as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖的主题将如下：
- en: History of Model View patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model View模式的历史
- en: Model View Controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model View Controller
- en: Model View Presenter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model View Presenter
- en: Model View ViewModel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model View ViewModel
- en: First, some history
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先，一些历史
- en: 'Separating concerns inside an application is a very important idea. We live
    in a complex and ever-changing world. This means that not only is it nearly impossible
    to formulate a computer program which works in exactly the way users want, but
    that what users want is an ever-shifting maze. Couple this with the fact that
    an ideal program for user A is totally different from an ideal program for user
    B and we''re guaranteed to end up in a mess. Our applications need to change as
    frequently as we change our socks: at least once a year.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内部分离关注点是一个非常重要的想法。我们生活在一个复杂且不断变化的世界。这意味着不仅几乎不可能制定一个完全符合用户需求的计算机程序，而且用户的需求也是一个不断变化的迷宫。再加上一个事实，即用户A的理想程序与用户B的理想程序完全不同，我们肯定会陷入混乱。我们的应用程序需要像我们换袜子一样频繁地更改：至少每年一次。
- en: Layering an application and maintaining modularity reduces the impact of a change.
    The less each layer knows about the other layers the better. Maintaining simple
    interfaces between the layers reduces the chances that a change to one layer will
    percolate to another layer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分层应用程序和维护模块化减少了变更的影响。每个层对其他层了解得越少越好。保持层之间的简单接口减少了一个层的变更对另一个层的影响的机会。
- en: If you've ever taken a close look at a high quality piece of nylon (from a hot
    air balloon, parachute, or expensive jacket) you may have noticed that that the
    fabric seems to form tiny squares. This is because, every few millimeters, a thick
    reinforcing thread is added to the weave to form a crosshatch pattern. If the
    fabric is ripped, then the rip will be stopped or at least slowed by the reinforcement.
    This limits the damage to a small area and prevents it from spreading.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经仔细观察过高质量的尼龙制品（如热气球、降落伞或昂贵的夹克），你可能会注意到这种织物似乎形成了微小的方块。这是因为每隔几毫米，都会添加一根粗的加强线来形成交叉网格图案。如果织物被撕裂，那么这种加强线将会停止或至少减缓撕裂。这限制了损坏的范围，并防止其扩散。
- en: 'Layers and modules in an application are exactly the same: they limit the spread
    of damage from a change.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的层和模块与限制变更的传播是完全相同的。
- en: In the early chapters of this module, we talked a bit about the seminal language,
    Smalltalk. It was the language which made classes famous. Like many of these patterns,
    the original MV* pattern, **Model View Controller** (**MVC**), was used long before
    it was ever identified. Although difficult to prove it seems that MVC was originally
    suggested in the late 1970s by Trygve Reenskaug, a Norwegian computer scientist,
    during a visit to the legendary Xerox PARC. Through the 1980s the pattern became
    heavily used in Smalltalk applications. However, it was not until 1988 that the
    pattern was more formally documented in an article entitled, *A Cookbook for Using
    the Model-View-Controller User Interface Paradigm* by Glenn E. Krasner and Stephen
    T. Pope.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块的前几章中，我们谈到了开创性的语言Smalltalk。它是使类著名的语言。就像许多这些模式一样，最初的MV*模式**Model View Controller**（MVC）在被识别之前很久就已经被使用了。尽管很难证明，但MVC最初是在20世纪70年代末由挪威计算机科学家Trygve
    Reenskaug在访问传奇般的施乐帕克时提出的。在20世纪80年代，这种模式在Smalltalk应用程序中得到了广泛使用。然而，直到1988年，这种模式才在一篇名为《使用模型-视图-控制器用户界面范例的烹饪书》的文章中得到了更正式的记录，作者是Glenn
    E. Krasner和Stephen T. Pope。
- en: Model View Controller
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型 视图 控制器
- en: 'MVC is a pattern that is useful for creating rich, interactive user interfaces:
    just the sort of interfaces which are becoming more and more popular on the web.
    The astute amongst you will have already figured out that the pattern is made
    up of three major components: model, view, and controller. You can see how information
    flows between the components in this illustration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种用于创建丰富、交互式用户界面的模式：正是这种界面越来越受欢迎。聪明的你们可能已经发现，这种模式由三个主要组件组成：模型、视图和控制器。你可以看到这个插图中组件之间的信息流动：
- en: '![Model View Controller](img/00069.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Model View Controller](img/00069.jpeg)'
- en: The preceding diagram shows the relationship between the three components in
    MVC.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了MVC中三个组件之间的关系。
- en: The model contains the state of the program. In many applications this model
    is contained in some form, in a database. The model may be rehydrated from a persistent
    store such as the database or it can be transient. Ideally the model is the only
    mutable part of the pattern. Neither the view nor the controller has any state
    associated with them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型包含程序的状态。在许多应用程序中，该模型以某种形式包含在数据库中。该模型可以从持久存储（如数据库）中重新生成，也可以是瞬态的。理想情况下，模型是模式中唯一可变的部分。视图和控制器都不与任何状态相关联。
- en: 'For a simple login screen the model might look like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的登录屏幕，模型可能如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll notice that not only do we have fields for the inputs shown to the user
    but also for the state of the login. This would not be apparent to the user but
    it is still part of the application state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们不仅为用户显示的输入字段有字段，还有登录状态的字段。这对用户来说可能不明显，但它仍然是应用程序状态的一部分。
- en: The model is usually modeled as a simple container for information. Typically,
    there are no real functions in the model. It simply contains data fields and may
    also contain validation. In some implementations of the MVC pattern the model
    also contains meta-data about the fields such as validation rules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通常被建模为信息的简单容器。通常，模型中没有真正的功能。它只包含数据字段，也可能包含验证。在MVC模式的一些实现中，模型还包含有关字段的元数据，如验证规则。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Naked Object pattern is a deviation from the typical MVC pattern. It augments
    the model with extensive business information as well as hits about the display
    and editing of data. It even contains methods for persisting the model to storage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 裸对象模式是典型MVC模式的偏离。它通过大量的业务信息以及有关数据显示和编辑的提示来增强模型。甚至包含将模型持久化到存储的方法。
- en: The views in the Naked Object pattern are generated from these models automatically.
    The controller is also automatically generated by examining the model. This centralizes
    the logic for displaying and manipulating application states and saves the developer
    from having to write their own views and controllers. So while the view and controller
    still exist, they are not actual objects but are dynamically created from the
    model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 裸对象模式中的视图是自动生成的。控制器也是通过检查模型自动生成的。这将逻辑集中在显示和操作应用程序状态上，并使开发人员无需编写自己的视图和控制器。因此，虽然视图和控制器仍然存在，但它们不是实际的对象，而是从模型动态创建的。
- en: Several systems have been successfully deployed using this pattern. Some criticism
    has emerged around the ability to generate an attractive user interface from just
    the models as well as how to properly coordinate multiple views.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 已成功部署了几个系统使用了这种模式。一些批评出现在能否仅从模型生成吸引人的用户界面以及如何正确协调多个视图方面。
- en: In a foreword to the PhD thesis, *presenting Naked Objects* by Reenskaug, he
    suggests that the naked objects pattern is actually closer to his original vision
    for MVC than most of the derivations of MVC in the wild.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reenskaug的博士论文《呈现裸对象》的前言中，他建议裸对象模式实际上比野外MVC的大多数派生更接近他最初对MVC的愿景。
- en: Updates to the model are communicated to the view whenever the state changes.
    This is typically done through the use of an observer pattern. The model does
    not typically know about either the controller or the view. The first is simply
    the thing telling it to change and the second is only updated through the observer
    pattern so the model doesn't have direct knowledge of it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的更新在状态改变时会通知视图。这通常是通过观察者模式来实现的。模型通常不知道控制器或视图。第一个只是告诉它要改变的东西，第二个只通过观察者模式更新，所以模型没有直接的了解。
- en: 'The view does pretty much what you would expect: communicate the model state
    to a target. I hesitate to suggest that the view must be a visual or graphical
    representation of the model as frequently the view is being communicated to another
    computer and may be in the form of XML, JSON, or some other data format. In most
    cases, especially those related to JavaScript, the view will be a graphical object.
    In a web context this will typically be HTML which is rendered by the browser.
    JavaScript is also gaining popularity on phones and on the desktop, so the view
    could also be a screen on a phone or on the desktop.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 视图基本上做你所期望的事情：将模型状态传达给目标。我不敢说视图必须是模型的视觉或图形表示，因为视图经常被传达到另一台计算机，并且可能是XML、JSON或其他数据格式。在大多数情况下，特别是与JavaScript相关的情况，视图将是一个图形对象。在Web环境中，这通常是由浏览器呈现的HTML。JavaScript在手机和桌面上也越来越受欢迎，因此视图也可以是手机或桌面上的屏幕。
- en: 'The view for the model presented in the preceding paragraph might look like
    the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面段落中呈现的模型的视图可能如下图所示：
- en: '![Model View Controller](img/00070.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Model View Controller](img/00070.jpeg)'
- en: In cases, where the observer pattern is not used, then the view may poll the
    model at some interval looking for changes. In this case the view may have to
    keep a representation of the state itself or at least a version number. It is
    important that the view not unilaterally update this state without passing the
    updates to the controller, otherwise the model and the copy in the view will get
    out of sync.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有使用观察者模式的情况下，视图可能会定期轮询模型以寻找更改。在这种情况下，视图可能必须保持状态的表示，或者至少一个版本号。重要的是，视图不要单方面更新此状态，而不将更新传递给控制器，否则模型和视图中的副本将不同步。
- en: 'Finally, the state of the model is updated by the controller. The controller
    usually contains all the logic and business rules for updating fields on the model.
    A simple controller for our login page might look like the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模型的状态由控制器更新。控制器通常包含更新模型字段的所有逻辑和业务规则。我们登录页面的简单控制器可能如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The controller knows about the existence of the model and is typically aware
    of the view's existence as well. It coordinates the two of them. A controller
    may be responsible for initializing more than one view. For instance, a single
    controller may provide a list view of all the instances of a model as well as
    a view that simply provides details. In many systems a controller will have create,
    read, update, and delete (CRUD) operations on it that work over a model. The controller
    is responsible for choosing the correct view and for wiring up the communication
    between the model and the view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器知道模型的存在，并且通常也知道视图的存在。它协调它们两者。一个控制器可能负责初始化多个视图。例如，一个单一的控制器可以提供模型的所有实例的列表视图，以及一个简单提供细节的视图。在许多系统中，控制器将对模型进行创建、读取、更新和删除（CRUD）操作。控制器负责选择正确的视图，并在模型和视图之间建立通信。
- en: 'When there is a need for a change to the application then the location of the
    code should be immediately apparent. For example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要进行更改时，代码的位置应该立即显而易见。例如：
- en: '| Change | Location |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 更改 | 位置 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Elements don''t appear well spaced on the screen, change spacing. | View
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: 屏幕上的元素间距不够，改变间距。| 视图 |
- en: '| No users are able to log in due to a logical error in password validation.
    | Controller |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 由于密码验证中的逻辑错误，没有用户能够登录。 | 控制器 |'
- en: '| New field to be added. | All layers |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 需要添加新字段。 | 所有层 |'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**Presentation-Abstraction-Control** (**PAC**) is another pattern that makes
    use of a triad of components. In this case its goal is to describe a hierarchy
    of encapsulated triples that more closely match how we think of the world. The
    control, similar to an MVC controller, passes interactions up in the hierarchy
    of encapsulated components allowing for information to flow between components.
    The abstraction is similar to a model but may represent only a few fields that
    are important for that specific PAC instead of the entire model. Finally, the
    presentation is effectively the same as a view.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Presentation-Abstraction-Control**（**PAC**）是另一种利用三个组件的模式。在这种情况下，它的目标是描述一组封装的三元组的层次结构，更接近我们对世界的思考方式。控制，类似于MVC控制器，将交互传递到封装组件的层次结构中，允许信息在组件之间流动。抽象类似于模型，但可能只代表对于特定PAC而言重要的一些字段，而不是整个模型。最后，演示实际上与视图相同。'
- en: The hierarchical nature of PAC allows for parallel processing of the components,
    meaning that it can be a powerful tool in today's multiprocessor systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PAC的分层性质允许组件的并行处理，这意味着它可以成为当今多处理器系统中的强大工具。
- en: 'You might notice that the last one there requires a change in all layers of
    the application. These multiple locations for responsibility are something that
    the Naked Objects pattern attempts to address by dynamically creating views and
    controllers. The MVC pattern splits code into locations by dividing the code by
    its role in user interaction. This means that a single data field lives in all
    the layers as is shown in this picture:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到最后一个需要在应用程序的所有层中进行更改。这种多重责任的位置是裸对象模式试图通过动态创建视图和控制器来解决的问题。MVC模式通过根据用户交互的角色将代码分割成位置。这意味着单个数据字段存在于所有层中，如图所示：
- en: '![Model View Controller](img/00071.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图控制器](img/00071.jpeg)'
- en: Some might call this a cross-cutting concern but really it doesn't span a sufficient
    amount of the application to be called such. Data access and logging are cross-cutting
    concerns as they are pervasive and difficult to centralize. This pervasion of
    a field through the different layers is really not a major problem. However, if
    it is bugging you then you might be an ideal candidate for using the Naked Objects
    pattern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会称之为横切关注点，但实际上它并没有跨越足够的应用范围。数据访问和日志记录是横切关注点，因为它们是普遍存在的，难以集中。这种领域在不同层之间的普遍性并不是一个主要问题。但是，如果这让你感到困扰，那么你可能是使用裸对象模式的理想候选人。
- en: Let's step into building some code to represent a MVC in JavaScript.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建一些用JavaScript表示MVC的代码。
- en: MVC code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC代码
- en: Let's start with a simple scenario for which we can apply MVC. Unfortunately,
    Westeros has very few computers, likely due to the lack of electricity. Thus applying
    application structuring patterns using Westeros as an example is difficult. Sadly
    we'll have to take a step back and talk about an application which controls Westeros.
    Let's assume it to be a web application and implement the entirety of MVC on the
    client side.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的场景开始，我们可以应用MVC。不幸的是，维斯特洛几乎没有计算机，可能是由于缺乏电力。因此，使用维斯特洛作为示例来应用应用程序结构模式是困难的。遗憾的是，我们将不得不退一步，谈论一个控制维斯特洛的应用程序。让我们假设它是一个Web应用程序，并在客户端实现整个MVC。
- en: It is possible to implement MVC by splitting the model, view and controller
    between client and server. Typically, the controller would sit on the server and
    provide an API which is known by the view. The model serves as a communication
    method both to the view which resides on the web browser and to the data store,
    likely a database of some form. It is also common that the controller be split
    between the server and the client in cases where some additional control is required
    on the client.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在客户端和服务器之间分割模型、视图和控制器来实现MVC。通常，控制器会位于服务器上，并提供视图所知的API。模型作为通信方法，既可以到驻留在Web浏览器上的视图，也可以到数据存储，可能是某种形式的数据库。在某些需要在客户端上进行额外控制的情况下，控制器也可以在服务器和客户端之间分割。
- en: 'In our example we would like to create a screen that controls the properties
    of a castle. Fortunately, you''re lucky that this is not a book on designing user
    interfaces with HTML as I would certainly fail. We''ll stick to a picture in place
    of the HTML:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想创建一个控制城堡属性的屏幕。幸运的是，你很幸运，因为这不是一本关于使用HTML设计用户界面的书，我肯定会失败。我们将用图片代替HTML：
- en: '![MVC code](img/00072.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![MVC代码](img/00072.jpeg)'
- en: 'For the most part, the view simply provides a set of controls and data for
    the end user. In this example the view will need to know how to call the save
    function on the controller. Let''s set that up:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，视图只是为最终用户提供一组控件和数据。在这个例子中，视图需要知道如何调用控制器上的保存函数。让我们来设置一下：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You'll notice that the constructor for this view contains both a reference to
    the document and to the controller. The document contains both HTML and styling,
    provided by CSS. We can get away with not passing in a reference to the document
    but injecting the document in this fashion allows for easier testability. We'll
    look at testability more in a later chapter. It also permits reusing the view
    multiple times on a single page without worrying about the two instances conflicting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到此视图的构造函数包含对文档和控制器的引用。文档包含HTML和由CSS提供的样式。我们可以不传入文档的引用，但以这种方式注入文档可以更容易进行测试。我们将在后面的章节中更多地讨论可测试性。它还允许在单个页面上多次重用视图，而不必担心两个实例之间的冲突。
- en: 'The constructor also contains a reference to the model which is used to add
    data to fields on the page as needed. Finally, the constructor also references
    a collection of errors. This allows for validation errors from the controller
    to be passed back to the view to be handled. We have set the validation result
    to be a wrapped collection that looks something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还包含对模型的引用，用于根据需要向页面上的字段添加数据。最后，构造函数还引用了一组错误。这允许将控制器的验证错误传递回视图进行处理。我们已经将验证结果设置为一个包装集合，看起来像下面这样：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only functionality here is that the button's `onclick` method is bound to
    calling save on the controller. Instead of passing in a large number of parameters
    to the `saveCastle` function on the controller, we build a lightweight object
    and pass that in. This makes the code more readable, especially in cases where
    some of the parameters are optional. No real work is done in the view and all
    the input goes directly to the controller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的功能是将按钮的`onclick`方法绑定到调用控制器上的保存。与在控制器的`saveCastle`函数中传递大量参数不同，我们构建一个轻量级对象并将其传递进去。这使得代码更易读，特别是在一些参数是可选的情况下。视图中没有真正的工作，所有输入直接传递给控制器。
- en: 'The controller contains the real functionality of the application:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器包含应用程序的真正功能：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The controller here does a number of things. The first thing is that it has
    a `setView` function which instructs the browser to set the given view as the
    current one. This is likely done through the use of a template. The mechanics
    of how that works are not important to the pattern so I'll leave that up to your
    imagination.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在这里做了很多事情。首先，它有一个`setView`函数，指示浏览器将给定的视图设置为当前视图。这可能是通过使用模板来完成的。这些工作的机制对于模式来说并不重要，所以我会留给你的想象力。
- en: Next, the controller implements a `validate` method. This method checks to make
    sure that the model is valid. Some validation may be performed on the client,
    such as testing the format of a postal code, but other validation requires a server
    trip. If a username must be unique then there is no reasonable way to test that
    on the client without communicating with the server. In some cases, the validation
    functionality may exist on the model rather than in the controller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，控制器实现了一个`validate`方法。此方法检查模型是否有效。一些验证可能在客户端执行，例如测试邮政编码的格式，但其他验证需要与服务器通信。如果用户名必须是唯一的，那么在不与服务器通信的情况下，无法合理地在客户端进行测试。在某些情况下，验证功能可能存在于模型中，而不是控制器中。
- en: Methods for setting up various different views are also found in the controller.
    In this case we have a bit of a workflow with a view for creating a castle then
    views for both success and failure. The failure case just returns the same view
    with a collection of validation errors attached to it. The success case returns
    a whole new view.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中还包含设置各种不同视图的方法。在这种情况下，我们有一个创建城堡的视图，然后是成功和失败的视图。失败情况只是返回相同的视图，并附加了一系列验证错误。成功情况返回一个全新的视图。
- en: The logic to save the model to some sort of persistent storage is also located
    in the controller. Again the implementation of this is less important than to
    see that the logic for communicating with the storage system is located in the
    controller.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型保存到某种持久存储的逻辑也位于控制器中。再次强调，与其看到与存储系统通信的逻辑相比，实现这一点并不重要。
- en: 'The final letter in MVC is the model. In this case, it is a very light weight
    one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MVC中的最后一个字母是模型。在这种情况下，它是一个非常轻量级的模型：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, all it does is keep track of the variables that make up the
    state of the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它只是跟踪构成应用程序状态的变量。
- en: Concerns are well separated in this pattern allowing for changes to be made
    with relative ease.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，关注点得到了很好的分离，从而可以相对容易地进行更改。
- en: Model View Presenter
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型视图Presenter
- en: The **Model View** **Presenter** (**MVP**) pattern is very similar to MVC. It
    is a fairly well known pattern in the Microsoft world and is generally used to
    structure WPF and Silverlight applications. It can be used in pure JavaScript
    as well. The key difference comes down to how the different parts of the system
    interact and where their responsibility ends.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图** **Presenter**（**MVP**）模式与MVC非常相似。这是微软世界中非常知名的模式，通常用于构建WPF和Silverlight应用程序。它也可以在纯JavaScript中使用。关键区别在于系统的不同部分如何交互以及它们的责任范围。'
- en: 'The first difference is that, with the presenter, there is a one to one mapping
    between presenter and view. This means that the logic that existed in the controller
    in the MVC pattern, which selected the correct view to render, doesn''t exist.
    Or rather it exists at a higher level outside the concern of the pattern. The
    selection of the correct presenter may be handled by a routing tool. Such a router
    will examine the parameters and provide the best choice for the presenter. The
    flow of information in the MVP pattern can be seen here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是，在呈现者中，呈现者和视图之间存在一对一的映射。这意味着在MVC模式中控制器中存在的逻辑，即选择正确的视图进行渲染的逻辑，不存在。或者说它存在于模式之外的更高级别。正确的呈现者的选择可能由路由工具处理。这样的路由器将检查参数并为呈现者提供最佳选择。MVP模式中的信息流可以在这里看到：
- en: '![Model View Presenter](img/00073.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图呈现者](img/00073.jpeg)'
- en: The presenter is aware of both the view and the model but the view is unaware
    of the model and the model unaware of the view. All communication is passed through
    the presenter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现者既知道视图又知道模型，但视图不知道模型，模型也不知道视图。所有通信都通过呈现者传递。
- en: The presenter pattern is often characterized by a great deal of two-way dispatch.
    A click will fire in the presenter and then the presenter will update the model
    with the change and then the view. The preceding diagram suggests that the input
    first passes through the view. In a passive version of the MVP pattern, the view
    has little to no interaction with the messages as they are passed onto the presenter.
    However, there is also a variation called active MVP that allows the view to contain
    some additional logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现者模式通常以大量的双向分派为特征。点击将在呈现者中触发，然后呈现者将更新模型和视图。前面的图表表明输入首先通过视图传递。在MVP模式的被动版本中，视图与消息几乎没有交互，因为它们被传递到呈现者。然而，还有一种称为主动MVP的变体，允许视图包含一些额外的逻辑。
- en: This active version of MVP can be more useful for web situations. It permits
    adding validation and other simple logic to the view. This reduces the number
    of requests that need to pass from the client back to the web server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种主动版本的MVP对Web情况更有用。它允许向视图添加验证和其他简单逻辑。这减少了需要从客户端传递回Web服务器的请求数量。
- en: Let's update our existing code sample to use MVP instead of MVC.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们现有的代码示例，使用MVP而不是MVC。
- en: MVP code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP代码
- en: 'Let''s start again with the view:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次从视图开始：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see the constructor for the view no longer takes a reference to the
    model. This is because the view in MVP doesn't have any idea about what model
    is being used. That information is abstracted away by the presenter. The reference
    to presenter remains in the constructor to allow sending messages back to the
    presenter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，视图的构造函数不再接受对模型的引用。这是因为MVP中的视图对使用的模型一无所知。这些信息被呈现者抽象掉了。对呈现者的引用仍然保留在构造函数中，以便向呈现者发送消息。
- en: Without the model there is an increase in the number of public setter and getter
    methods. These setters allow the presenter to make updates to the state of the
    view. The getters provide an abstraction over how the view stores the state and
    gives the presenter a way to get the information. The `saveCastle` function no
    longer passes any values to the presenter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有模型的情况下，公共setter和getter方法的数量增加。这些setter允许呈现者更新视图的状态。getter提供了视图如何存储状态的抽象，并为呈现者提供了获取信息的方法。`saveCastle`函数不再向呈现者传递任何值。
- en: 'The presenter''s code looks like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现者的代码如下所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that the view is now referenced in a persistent fashion in the presenter.
    The `saveCastle` method calls into the view to get its values. However, the presenter
    does make sure to use the public methods of the view instead of referencing the
    document directly. The `saveCastle` method updates the model. If there are validation
    errors, then it will call back into the view to update the `IsValid` flag. This
    is an example of the double dispatch I mentioned earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，视图现在以持久的方式在呈现者中被引用。`saveCastle`方法调用视图获取其值。然而，呈现者确保使用视图的公共方法而不是直接引用文档。`saveCastle`方法更新模型。如果存在验证错误，它将回调到视图更新`IsValid`标志。这是我之前提到的双重分派的一个例子。
- en: Finally, the model remains unchanged from before. We've kept the validation
    logic in the presenter. At which level the validation is done, model or presenter,
    matters less than being consistent in where the validation is done through your
    application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模型与以前一样保持不变。我们将验证逻辑保留在呈现者中。在哪个级别进行验证，模型还是呈现者，不如在整个应用程序中一致地进行验证重要。
- en: The MVP pattern is again a fairly useful pattern for building user interfaces.
    The larger separation between the view and the model creates a stricter API allowing
    for better adaptation to change. However, this comes at the expense of more code.
    With more code comes more opportunity for bugs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式再次是构建用户界面的一个非常有用的模式。视图和模型之间的较大分离创建了一个更严格的API，允许更好地适应变化。然而，这是以更多的代码为代价的。更多的代码意味着更多的bug的机会。
- en: Model View ViewModel
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型视图视图模型
- en: 'The final pattern we''ll look at in this chapter is the Model View ViewModel
    pattern, more commonly known as MVVM. By now this sort of pattern should be getting
    quite familiar. Again you can see the flow of information between components in
    this illustration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的最后一个模式是模型视图视图模型模式，更常被称为MVVM。到现在为止，这种模式应该已经相当熟悉了。同样，你可以在这个插图中看到组件之间的信息流：
- en: '![Model View ViewModel](img/00074.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图视图模型](img/00074.jpeg)'
- en: You can see here that many of the same constructs have returned but that the
    communication between them is somewhat different.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到许多相同的构造已经返回，但它们之间的通信有些不同。
- en: In this variation, what has previously been the controller and presenter is
    now the view model. Just like with MVC and MVP, the majority of the logic is held
    within the central component, in this case the view model. The model itself is
    actually very simple in MVVM. Typically, it acts as an envelope that just holds
    data. Validation is done within the view model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种变化中，以前的控制器和展示者现在是视图模型。就像MVC和MVP一样，大部分逻辑都保存在中央组件中，这里是视图模型。MVVM中的模型本身实际上非常简单。通常，它充当一个仅保存数据的信封。验证是在视图模型中完成的。
- en: Just like with MVP, the view is totally unaware of the existence of the model.
    The difference is that, with MVP, the view was aware that it was talking to some
    intermediate class. It called methods rather than simply setting values. In MVVM
    the view believes that the view model is its view. Instead of calling operations
    like `saveCastle` and passing in data or waiting for data to be requested, the
    view updates fields on the view model as they change. In effect, the fields on
    the view are bound to the view model. The view model may proxy these values through
    to the model or wait until a commit-like operation like save is called to pass
    the data along.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像MVP一样，视图完全不知道模型的存在。不同之处在于，在MVP中，视图知道它正在与某个中间类交谈。它调用方法而不是简单地设置值。在MVVM中，视图认为视图模型就是它的视图。它不是调用像`saveCastle`这样的操作，并传递数据或等待数据被请求，而是在视图模型上更新字段随着它们的更改。实际上，视图上的字段与视图模型绑定。视图模型可以通过模型代理这些值，或者等到调用保存等操作时将数据传递出去。
- en: Equally, changes to the view model should be reflected at once in the view.
    A single view may have a number of view models. Each of these view models may
    push updates to the view or have changes pushed to it via the view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对视图模型的更改应立即在视图中反映出来。单个视图可能有多个视图模型。这些视图模型中的每一个都可以向视图推送更新，或者通过视图向其推送更改。
- en: Let's take a look at a really rudimentary implementation of this and then we'll
    discuss how to make it better.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个真正基本的实现，然后我们将讨论如何改进它。
- en: MVVM code
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM代码
- en: 'The naïve view implementation is, frankly, a huge mess:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的视图实现，坦率地说，是一团糟：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is highly repetitive and each property must be proxied back to `ViewModel`.
    I''ve truncated most of this code but it adds up to a good 70 lines. The code
    inside the view model is equally terrible:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高度重复的，每个属性都必须被代理回`ViewModel`。我截断了大部分代码，但它总共有70行。视图模型内部的代码同样糟糕：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One look at this code should send you running for the hills. It is set up in
    a way that will encourage copy and paste programming: a fantastic way to introduce
    errors into a code base. I sure hope there is a better way to transfer changes
    between the model and the view.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看一眼这段代码应该会让你四处奔跑。它的设置方式会鼓励复制和粘贴编程：这是引入代码错误的绝佳方式。我真希望有一种更好的方法来在模型和视图之间传输更改。
- en: A better way to transfer changes between the model and the view
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模型和视图之间传输更改的更好方法
- en: It may not have escaped your notice that there are a number of MVVM-style frameworks
    for JavaScript in the wild. Obviously they would not have been readily adopted
    if they followed the approach that we described in the preceding section. Instead
    they follow one of two different approaches.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有许多MVVM风格的JavaScript框架。显然，如果它们遵循我们在前一节中描述的方法，它们就不会被广泛采用。相反，它们遵循两种不同的方法之一。
- en: The first approach is known as dirty checking. In this approach, after every
    interaction with the view model we loop over all of its properties looking for
    changes. When changes are found, the related value in the view is updated with
    the new value. For changes to values in the view change, actions are attached
    to all the controls. These then trigger updates to the view model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法被称为脏检查。在这种方法中，每次与视图模型交互后，我们都会遍历其所有属性，寻找更改。当发现更改时，视图中的相关值将被更新为新值。对于视图中值的更改，操作将附加到所有控件上。然后触发更新到视图模型。
- en: 'This approach can be slow for large models as it is expensive to iterate over
    all the properties of a large model. The number of things which can cause a model
    to change is high and there is no real way to tell if a distant field in a model
    has been changed by changing another without going and validating it. On the upside,
    dirty checking allows you to use plain old JavaScript objects. There is no need
    to write your code any differently than before. The same is not true of the other
    approach: container objects.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型模型来说，这种方法可能会很慢，因为迭代大型模型的所有属性是昂贵的。可以导致模型更改的事情很多，没有真正的方法可以告诉远程模型中的一个字段是否已经通过更改另一个字段而被更改，而不是去验证它。好处是，脏检查允许您使用普通的JavaScript对象。无需像以前那样编写代码。另一种方法不是这样的：容器对象。
- en: With a container object a special interface is provided to wrap existing objects
    so that changes to the object may be directly observed. Basically this is an application
    of the observer pattern but applied dynamically so the underlying object has no
    idea it is being observed. The spy pattern, perhaps?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器对象，提供了一个特殊的接口来包装现有对象，以便直接观察对象的更改。基本上，这是观察者模式的应用，但是动态应用，因此基础对象不知道它正在被观察。间谍模式，也许？
- en: 'An example might be helpful here. Let us say that we have the model object
    we''ve been using up until now:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里举个例子可能会有所帮助。假设我们一直在使用的模型对象是这样的：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, instead of `model.name` being a simple string, we would wrap some function
    around it. In the case of the Knockout library this would look like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`model.name`不再是一个简单的字符串，我们会在其周围包装一些函数。在Knockout库的情况下，它看起来像下面这样：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the highlighted code, the various properties of the model are being wrapped
    with an observable. This means that they must now be accessed differently:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在突出显示的代码中，模型的各种属性被包装为可观察的。这意味着它们现在必须以不同的方式被访问：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This approach obviously adds some friction to your code and makes changing frameworks
    quite involved.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显然会给你的代码增加一些摩擦，并使更改框架变得相当复杂。
- en: Current MVVM frameworks are split on their approach to container objects versus
    dirty checking. AngularJS uses dirty checking while Backbone, Ember, and Knockout
    all make use of container objects. There is currently no clear winner.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的MVVM框架在对待容器对象与脏检查方面存在分歧。AngularJS使用脏检查，而Backbone、Ember和Knockout都使用容器对象。目前还没有明显的赢家。
- en: Observing view changes
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察视图更改
- en: Fortunately, the pervasiveness of MV* patterns on the web and the difficulties
    with observing model changes has not gone unnoticed. You might be expecting me
    to say that this will be solved in ECMAScript-2015 as is my normal approach. Weirdly,
    the solution to all of this, `Object.observe`, is a feature under discussion for
    ECMAScript-2016\. However, at the time of writing, at least one major browser
    already supports it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Web上MV*模式的普及以及观察模型更改的困难并没有被忽视。你可能期待我会说这将在ECMAScript-2015中解决，这是我的正常做法。奇怪的是，所有这些问题的解决方案，`Object.observe`，是ECMAScript-2016讨论中的一个功能。然而，在撰写本文时，至少有一个主要浏览器已经支持它。
- en: 'It can be used like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像下面这样使用：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having this simple interface to monitor changes to objects removes much of the
    logic provided by large MV* frameworks. It will be easier to roll your own functionality
    for MV* and there may, in fact, be no need to use external frameworks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这样一个简单的接口来监视对象的更改，可以消除大型MV*框架提供的大部分逻辑。为MV*编写自己的功能将更容易，实际上可能没有必要使用外部框架。
- en: Tips and tricks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技巧
- en: The different layers of the various MV* patterns need not all be on the browser,
    nor do they all need to be written in JavaScript. Many popular frameworks allow
    for maintaining a model on the server and communicating with it using JSON.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 各种MV*模式的不同层次不一定都在浏览器上，也不一定都需要用JavaScript编写。许多流行的框架允许在服务器上维护模型，并使用JSON进行通信。
- en: '`Object.observe` may not be available on all browsers yet, but there are polyfills
    that can be used to create a similar interface. The performance is not as good
    as the native implementation, but it is still usable.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.observe`可能尚未在所有浏览器上可用，但有一些polyfills可以用来创建类似的接口。性能不如原生实现好，但仍然可用。'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Separating concerns to a number of layers ensures that changes to the application
    are isolated like a ripstop. The various MV* patterns allow for separating the
    concerns in a graphical application. The differences between the various patterns
    come down to how the responsibilities are separated and how information is communicated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将关注点分离到多个层次可以确保应用程序的更改像防撕裂一样被隔离。各种MV*模式允许在图形应用程序中分离关注点。各种模式之间的差异在于责任如何分离以及信息如何通信。
- en: In the next chapter we'll look at a number of patterns and techniques to improve
    the experience of developing and deploying JavaScript to the Web.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些模式和技术，以改善开发和部署JavaScript到Web的体验。
