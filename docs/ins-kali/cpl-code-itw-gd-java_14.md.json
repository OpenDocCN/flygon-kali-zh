["```java\nprivate final class Node {\n\u00a0\u00a0private int data;\n\u00a0\u00a0private Node next;\n}\n```", "```java\nprivate final class Node {\n\u00a0\u00a0private int data;\n\u00a0\u00a0private Node next;\n\u00a0\u00a0private Node prev;\n}\n```", "```java\nprivate final class MyEntry<K, V> {\n\u00a0\u00a0private final K key;\n\u00a0\u00a0private V value;\n\u00a0\u00a0public MyEntry(K key, V value) {\n\u00a0\u00a0\u00a0\u00a0this.key = key;\n\u00a0\u00a0\u00a0\u00a0this.value = value;\n\u00a0\u00a0}\n\u00a0\u00a0// getters and setters omitted for brevity\n}\n```", "```java\nprivate static final int DEFAULT_CAPACITY = 16;\nprivate MyEntry<K, V>[] entries \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= new MyEntry[DEFAULT_CAPACITY];\n```", "```java\nprivate int size;\npublic void put(K key, V value) {\n\u00a0\u00a0boolean success = true;\n\u00a0\u00a0for (int i = 0; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0if (entries[i].getKey().equals(key)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0entries[i].setValue(value);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0success = false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0if (success) {\n\u00a0\u00a0\u00a0\u00a0checkCapacity();\n\u00a0\u00a0\u00a0\u00a0entries[size++] = new MyEntry<>(key, value);\n\u00a0\u00a0}\n}\n```", "```java\nprivate void checkCapacity() {\n\u00a0\u00a0if (size == entries.length) {\n\u00a0\u00a0\u00a0\u00a0int newSize = entries.length * 2;\n\u00a0\u00a0\u00a0\u00a0entries = Arrays.copyOf(entries, newSize);\n\u00a0\u00a0}\n}\n```", "```java\npublic V get(K key) {\n\u00a0\u00a0for (int i = 0; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0if (entries[i] != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (entries[i].getKey().equals(key)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return entries[i].getValue();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return null;\n}\n```", "```java\npublic void remove(K key) {\n\u00a0\u00a0for (int i = 0; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0if (entries[i].getKey().equals(key)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0entries[i] = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0condenseArray(i);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\nprivate void condenseArray(int start) {\n\u00a0\u00a0int i;\n\u00a0\u00a0for (i = start; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0entries[i] = entries[i + 1];\n\u00a0\u00a0}\n\u00a0\u00a0entries[i] = null; // don't forget this line\n}\n```", "```java\npublic Set<K> keySet() {\n\u00a0\u00a0Set<K> set = new HashSet<>();\n\u00a0\u00a0for (int i = 0; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0set.add(entries[i].getKey());\n\u00a0\u00a0}\n\u00a0\u00a0return set;\n}\n```", "```java\npublic Collection<V> values() {\n\u00a0\u00a0List<V> list = new ArrayList<>();\n\u00a0\u00a0for (int i = 0; i < size; i++) {\n\u00a0\u00a0\u00a0\u00a0list.add(entries[i].getValue());\n\u00a0\u00a0}\n\u00a0\u00a0return list;\n}\n```", "```java\nchar[] nuts = {'$', '%', '&', 'x', '@'};\nchar[] bolts = {'%', '@', 'x', '$', '&'};\n```", "```java\npublic static void match(char[] nuts, char[] bolts) {\n\u00a0\u00a0// in this map, each nut is a key and \n\u00a0\u00a0// its position is as value\n\u00a0\u00a0Map<Character, Integer> map = new HashMap<>();\n\u00a0\u00a0for (int i = 0; i < nuts.length; i++) {\n\u00a0\u00a0\u00a0\u00a0map.put(nuts[i], i);\n\u00a0\u00a0}\n\u00a0\u00a0//for each bolt, search a nut\n\u00a0\u00a0for (int i = 0; i < bolts.length; i++) {\n\u00a0\u00a0\u00a0\u00a0char bolt = bolts[i];\n\u00a0\u00a0\u00a0\u00a0if (map.containsKey(bolt)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nuts[i] = bolts[i];\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"Bolt \" + bolt + \" has no nut\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0System.out.println(\"Matches between nuts and bolts: \");\n\u00a0\u00a0System.out.println(\"Nuts: \" + Arrays.toString(nuts));\n\u00a0\u00a0System.out.println(\"Bolts: \" +Arrays.toString(bolts));\n}\n```", "```java\n// 'size' is the linked list size\npublic void removeDuplicates() {\n\u00a0\u00a0Set<Integer> dataSet = new HashSet<>();\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0Node prevNode = null;\n\u00a0\u00a0while (currentNode != null) {\n\u00a0\u00a0\u00a0\u00a0if (dataSet.contains(currentNode.data)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prevNode.next = currentNode.next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (currentNode == tail) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = prevNode;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dataSet.add(currentNode.data);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prevNode = currentNode;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.next;\n\u00a0\u00a0}\n}\n```", "```java\npublic void removeDuplicates() {\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0while (currentNode != null) {\n\u00a0\u00a0\u00a0\u00a0Node runnerNode = currentNode;\n\u00a0\u00a0\u00a0\u00a0while (runnerNode.next != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (runnerNode.next.data == currentNode.data) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (runnerNode.next == tail) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = runnerNode;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0runnerNode.next = runnerNode.next.next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size--;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0runnerNode = runnerNode.next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.next;\n\u00a0\u00a0}\n}\n```", "```java\npublic void rearrange(int n) {\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0head = currentNode;\n\u00a0\u00a0tail = currentNode;\n\u00a0\u00a0while (currentNode != null) {\n\u00a0\u00a0\u00a0\u00a0Node nextNode = currentNode.next;\n\u00a0\u00a0\u00a0\u00a0if (currentNode.data < n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// insert node at the head\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode.next = head;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head = currentNode;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// insert node at the tail\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail.next = currentNode;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = currentNode;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0currentNode = nextNode;\n\u00a0\u00a0}\n\u00a0\u00a0tail.next = null;\n}\n```", "```java\npublic int nthToLastIterative(int n) {\n\u00a0\u00a0// both runners are set to the start\n\u00a0\u00a0Node firstRunner = head;\n\u00a0\u00a0Node secondRunner = head;\n\u00a0\u00a0// runner1 goes in the nth position\n\u00a0\u00a0for (int i = 0; i < n; i++) {\n\u00a0\u00a0\u00a0\u00a0if (firstRunner == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw new IllegalArgumentException(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"The given n index is out of bounds\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0firstRunner = firstRunner.next;\n\u00a0\u00a0}\n\u00a0\u00a0// runner2 run as long as runner1 is not null\n\u00a0\u00a0// basically, when runner1 cannot run further (is null), \n\u00a0\u00a0// runner2 will be placed on the nth to last node\n\u00a0\u00a0while (firstRunner != null) {\n\u00a0\u00a0\u00a0\u00a0firstRunner = firstRunner.next;\n\u00a0\u00a0\u00a0\u00a0secondRunner = secondRunner.next;\n\u00a0\u00a0}\n\u00a0\u00a0return secondRunner.data;\n}\n```", "```java\npublic void findLoopStartNode() {\n\u00a0\u00a0Node slowRunner = head;\n\u00a0\u00a0Node fastRunner = head;\n\u00a0\u00a0// fastRunner meets slowRunner\n\u00a0\u00a0while (fastRunner != null && fastRunner.next != null) {\n\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0\u00a0\u00a0fastRunner = fastRunner.next.next;\n\u00a0\u00a0\u00a0\u00a0if (slowRunner == fastRunner) { // they met\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.println(\"\\nThe meet point is at \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the node with value: \" + slowRunner);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// if no meeting point was found then there is no loop\n\u00a0\u00a0if (fastRunner == null || fastRunner.next == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// the slowRunner moves to the head of the linked list\n\u00a0\u00a0// the fastRunner remains at the meeting point\n\u00a0\u00a0// they move simultaneously node-by-node and \n\u00a0\u00a0// they should meet at the loop start\n\u00a0\u00a0slowRunner = head;\n\u00a0\u00a0while (slowRunner != fastRunner) {\n\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0\u00a0\u00a0fastRunner = fastRunner.next;\n\u00a0\u00a0}\n\u00a0\u00a0// both pointers points to the start of the loop\n\u00a0\u00a0System.out.println(\"\\nLoop start detected at \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the node with value: \" + fastRunner);\n}\n```", "```java\npublic boolean isPalindrome() {\n\u00a0\u00a0Node fastRunner = head;\n\u00a0\u00a0Node slowRunner = head;\n\u00a0\u00a0Stack<Integer> firstHalf = new Stack<>();\n\u00a0\u00a0// the first half of the linked list is added into the stack\n\u00a0\u00a0while (fastRunner != null && fastRunner.next != null) {\n\u00a0\u00a0\u00a0\u00a0firstHalf.push(slowRunner.data);\n\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0\u00a0\u00a0fastRunner = fastRunner.next.next;\n\u00a0\u00a0}\n\u00a0\u00a0// for odd number of elements we to skip the middle node\n\u00a0\u00a0if (fastRunner != null) {\n\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0}\n\u00a0\u00a0// pop from the stack and compare with the node by node of \n\u00a0\u00a0// the second half of the linked list\n\u00a0\u00a0while (slowRunner != null) {\n\u00a0\u00a0\u00a0\u00a0int top = firstHalf.pop();\n\u00a0\u00a0\u00a0\u00a0// a mismatch means that the list is not a palindrome\n\u00a0\u00a0\u00a0\u00a0if (top != slowRunner.data) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0}\n\u00a0\u00a0return true;\n}\n```", "```java\nprivate Node sum(Node node1, Node node2, int carry) {\n\u00a0\u00a0if (node1 == null && node2 == null && carry == 0) {\n\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0}\n\u00a0\u00a0Node resultNode = new Node();\n\u00a0\u00a0int value = carry;\n\u00a0\u00a0if (node1 != null) {\n\u00a0\u00a0\u00a0\u00a0value += node1.data;\n\u00a0\u00a0}\n\u00a0\u00a0if (node2 != null) {\n\u00a0\u00a0\u00a0\u00a0value += node2.data;\n\u00a0\u00a0}\n\u00a0\u00a0resultNode.data = value % 10;\n\u00a0\u00a0if (node1 != null || node2 != null) {\n\u00a0\u00a0\u00a0\u00a0Node more = sum(node1 == null\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? null : node1.next, node2 == null\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? null : node2.next, value >= 10 ? 1 : 0);\n\u00a0\u00a0\u00a0\u00a0resultNode.next = more;\n\u00a0\u00a0}\n\u00a0\u00a0return resultNode;\n}\n```", "```java\npublic int intersection() {\n\u00a0\u00a0// this is the head of first list\n\u00a0\u00a0Node currentNode1 = {head_of_first_list};\n\u00a0\u00a0// this is the head of the second list\n\u00a0\u00a0Node currentNode2 = {head_of_second_list};\n\u00a0\u00a0// compute the size of both linked lists\n\u00a0\u00a0// linkedListSize() is just a helper method\n\u00a0\u00a0int s1 = linkedListSize(currentNode1);\n\u00a0\u00a0int s2 = linkedListSize(currentNode2);\n\u00a0\u00a0// the first linked list is longer than the second one\n\u00a0\u00a0if (s1 > s2) {\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < (s1 - s2); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode1 = currentNode1.next;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0// the second linked list is longer than the first one\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < (s2 - s1); i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode2 = currentNode2.next;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// iterate both lists until the end or the intersection node\n\u00a0\u00a0while (currentNode1 != null && currentNode2 != null) {\n\u00a0\u00a0\u00a0\u00a0// we compare references not values!\n\u00a0\u00a0\u00a0\u00a0if (currentNode1 == currentNode2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return currentNode1.data;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0currentNode1 = currentNode1.next;\n\u00a0\u00a0\u00a0\u00a0currentNode2 = currentNode2.next;\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```", "```java\npublic void swap() {\n\u00a0\u00a0if (head == null || head.next == null) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0Node prevPair = null;\n\u00a0\u00a0// consider two nodes at a time and swap their links\n\u00a0\u00a0while (currentNode != null && currentNode.next != null) {\n\u00a0\u00a0\u00a0\u00a0Node node1 = currentNode;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// first node\n\u00a0\u00a0\u00a0\u00a0Node node2 = currentNode.next;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// second node\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Node node3 = currentNode.next.next; // third node\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// swap node1 node2\n\u00a0\u00a0\u00a0\u00a0Node auxNode = node1;\n\u00a0\u00a0\u00a0\u00a0node1 = node2;\n\u00a0\u00a0\u00a0\u00a0node2 = auxNode;\n\u00a0\u00a0\u00a0\u00a0// repair the links broken by swapping\n\u00a0\u00a0\u00a0\u00a0node1.next = node2;\n\u00a0\u00a0\u00a0\u00a0node2.next = node3;\n\u00a0\u00a0\u00a0\u00a0// if we are at the first swap we set the head\n\u00a0\u00a0\u00a0\u00a0if (prevPair == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head = node1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we link the previous pair to this pair\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0prevPair.next = node1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// there are no more nodes, therefore set the tail\n\u00a0\u00a0\u00a0\u00a0if (currentNode.next == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = currentNode;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// prepare the prevNode of the current pair\n\u00a0\u00a0\u00a0\u00a0prevPair = node2;\n\u00a0\u00a0\u00a0\u00a0// advance to the next pair\n\u00a0\u00a0\u00a0\u00a0currentNode = node3;\n\u00a0\u00a0}\n}\n```", "```java\nNode auxNode = list1.next; // auxNode = node with value 7\nlist1.next = list2;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// list1.next = node with value 5\nlist2 = auxNode;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// list2 = node with value 7\n```", "```java\npublic void merge(SinglyLinkedList sll) {\n\u00a0\u00a0// these are the two lists\n\u00a0\u00a0Node list1 = head;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the merged linked list \n\u00a0\u00a0Node list2 = sll.head;\u00a0\u00a0// from this list we add nodes at \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// appropriate place in list1\n\u00a0\u00a0// compare heads and swap them if it is necessary\n\u00a0\u00a0if (list1.data < list2.data) {\n\u00a0\u00a0\u00a0\u00a0head = list1;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0head = list2;\n\u00a0\u00a0\u00a0\u00a0list2 = list1;\n\u00a0\u00a0\u00a0\u00a0list1 = head;\n\u00a0\u00a0}\n\u00a0\u00a0// compare the nodes from list1 with the nodes from list2\n\u00a0\u00a0while (list1.next != null) {\n\u00a0\u00a0\u00a0\u00a0if (list1.next.data > list2.data) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node auxNode = list1.next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list1.next = list2;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list2 = auxNode;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// advance to the last node in the merged linked list\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0list1 = list1.next;\n\u00a0\u00a0}\n\u00a0\u00a0// add the remaining list2\n\u00a0\u00a0if (list1.next == null) {\n\u00a0\u00a0\u00a0\u00a0list1.next = list2;\n\u00a0\u00a0}\n}\n```", "```java\npublic void removeRedundantPath() {\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0while (currentNode.next != null \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& currentNode.next.next != null) {\n\u00a0\u00a0\u00a0\u00a0Node middleNode = currentNode.next.next;\n\u00a0\u00a0\u00a0\u00a0// check for a vertical triplet (triplet with same column)\n\u00a0\u00a0\u00a0\u00a0if (currentNode.c == currentNode.next.c\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& currentNode.c == middleNode.c) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// delete the middle node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode.next = middleNode;\n\u00a0\u00a0\u00a0\u00a0} // check for a horizontal triplet \n\u00a0\u00a0\u00a0\u00a0else if (currentNode.r == currentNode.next.r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& currentNode.r == middleNode.r) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// delete the middle node\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode.next = middleNode;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.next;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic void moveLastToFront() {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0// step 1\n\u00a0\u00a0while (currentNode.next.next != null) {\n\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.next;\n\u00a0\u00a0}\n\u00a0\u00a0// step 2\n\u00a0\u00a0Node nextNode = currentNode.next;\n\u00a0\u00a0// step 3\n\u00a0\u00a0currentNode.next = null;\n\u00a0\u00a0// step 4\n\u00a0\u00a0nextNode.next = head;\n\u00a0\u00a0head = nextNode;\n}\n```", "```java\npublic void moveLastToFront() {\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0// step 1\n\u00a0\u00a0while (currentNode.next.next != null) {\n\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.next;\n\u00a0\u00a0}\n\u00a0\u00a0// step 2\n\u00a0\u00a0currentNode.next.next = head;\n\u00a0\u00a0// step 3\n\u00a0\u00a0head = currentNode.next;\n\u00a0\u00a0// step 4\n currentNode.next = null;\n}\n```", "```java\npublic void reverseInKGroups(int k) {\n\u00a0\u00a0if (head != null) {\n\u00a0\u00a0\u00a0\u00a0head = reverseInKGroups(head, k);\n\u00a0\u00a0}\n}\nprivate Node reverseInKGroups(Node head, int k) {\n\u00a0\u00a0Node current = head;\n\u00a0\u00a0Node next = null;\n\u00a0\u00a0Node prev = null;\n\u00a0\u00a0int counter = 0;\n\u00a0\u00a0// reverse first 'k' nodes of linked list\n\u00a0\u00a0while (current != null && counter < k) {\n\u00a0\u00a0\u00a0\u00a0next = current.next;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0current.next = prev;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0prev = current;\n\u00a0\u00a0\u00a0\u00a0current = next;\n\u00a0\u00a0\u00a0\u00a0counter++;\n\u00a0\u00a0}\n\u00a0\u00a0// 'next' points to (k+1)th node\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0if (next != null) {\n\u00a0\u00a0\u00a0\u00a0head.next = reverseInKGroups(next, k);\n\u00a0\u00a0}\n\u00a0\u00a0// 'prev' is now the head of the input list \n\u00a0\u00a0return prev;\n}\n```", "```java\npublic void reverse() {\n\u00a0\u00a0Node currentNode = head;\n\u00a0\u00a0Node prevNode = null;\n\u00a0\u00a0while (currentNode != null) {\n\u00a0\u00a0\u00a0\u00a0// swap next and prev pointers of the current node\n\u00a0\u00a0\u00a0\u00a0Node prev = currentNode.prev;\n\u00a0\u00a0\u00a0\u00a0currentNode.prev = currentNode.next;\n\u00a0\u00a0\u00a0\u00a0currentNode.next = prev;\n\u00a0\u00a0\u00a0\u00a0// update the previous node before moving to the next node\n\u00a0\u00a0\u00a0\u00a0prevNode = currentNode;\n\u00a0\u00a0\u00a0\u00a0// move to the next node in the doubly linked list\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0currentNode = currentNode.prev;\n\u00a0\u00a0}\n\u00a0\u00a0// update the head to point to the last node\n\u00a0\u00a0if (prevNode != null) {\n\u00a0\u00a0\u00a0\u00a0head = prevNode;\n\u00a0\u00a0}\n}\n```", "```java\npublic final class LRUCache {\n\u00a0\u00a0private final class Node {\n\u00a0\u00a0\u00a0\u00a0private int key;\n\u00a0\u00a0\u00a0\u00a0private int value;\n\u00a0\u00a0\u00a0\u00a0private Node next;\n\u00a0\u00a0\u00a0\u00a0private Node prev;\n\u00a0\u00a0}\n\u00a0\u00a0private final Map<Integer, Node> hashmap;\n\u00a0\u00a0private Node head;\n\u00a0\u00a0private Node tail;\n\u00a0\u00a0// 5 is the maximum size of the cache\n\u00a0\u00a0private static final int LRU_SIZE = 5;\n\u00a0\u00a0public LRUCache() {\n\u00a0\u00a0\u00a0\u00a0hashmap = new HashMap<>();\n\u00a0\u00a0}\n\u00a0\u00a0public int getEntry(int key) {\n\u00a0\u00a0\u00a0\u00a0Node node = hashmap.get(key);\n\u00a0\u00a0\u00a0\u00a0// if the key already exist then update its usage in cache\n\u00a0\u00a0\u00a0\u00a0if (node != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0removeNode(node);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addNode(node);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node.value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// by convention, data not found is marked as -1\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0public void putEntry(int key, int value) {\n\u00a0\u00a0\u00a0\u00a0Node node = hashmap.get(key);\n\u00a0\u00a0\u00a0\u00a0// if the key already exist then update \n\u00a0\u00a0\u00a0\u00a0// the value and move it to top of the cache\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (node != null) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.value = value;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0removeNode(node);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addNode(node);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// this is new key\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node newNode = new Node();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode.prev = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode.next = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode.value = value;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0newNode.key = key;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if we reached the maximum size of the cache then \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we have to remove the\u00a0\u00a0Least Recently Used\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hashmap.size() >= LRU_SIZE) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hashmap.remove(tail.key);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0removeNode(tail);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addNode(newNode);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addNode(newNode);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hashmap.put(key, newNode);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// helper method to add a node to the top of the cache\n\u00a0\u00a0private void addNode(Node node) {\n\u00a0\u00a0\u00a0\u00a0node.next = head;\n\u00a0\u00a0\u00a0\u00a0node.prev = null;\n\u00a0\u00a0\u00a0\u00a0if (head != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head.prev = node;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0head = node;\n\u00a0\u00a0\u00a0\u00a0if (tail == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = head;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// helper method to remove a node from the cache\n\u00a0\u00a0private void removeNode(Node node) {\n\u00a0\u00a0\u00a0\u00a0if (node.prev != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.prev.next = node.next;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0head = node.next;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (node.next != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.next.prev = node.prev;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tail = node.prev;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\u00a0\u00a0\u00a0\n}\n```"]