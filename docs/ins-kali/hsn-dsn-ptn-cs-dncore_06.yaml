- en: Implementing Design Patterns - Basics Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施设计模式 - 基础知识第2部分
- en: In the previous chapter, we introduced FlixOne and the initial development of
    a new inventory management application. Several patterns were used by the development
    team, ranging from patterns designed to limit the scope of a deliverable such
    as a **Minimum Viable Product** (**MVP**) to patterns to assist in the development
    of the project such as **Test Driven Development** (**TDD**). Several patterns
    from the **Gang of Four** (**GoF**) were also applied as a solution to leverage
    how others have solved similar problems in the past so that we don't repeat common
    mistakes. Single responsibility principle, Open–closed principle, Liskov substitution
    principle, Interface Segregation principle, and Dependency inversion principle
    (SOLID principles) were applied to ensure we are creating a stable code base that
    will help in the management and future development of our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了FlixOne以及新库存管理应用程序的初始开发。开发团队使用了多种模式，从旨在限制交付范围的模式（如**最小可行产品**（**MVP**））到辅助项目开发的模式（如**测试驱动开发**（**TDD**））。还应用了**四人帮**（**GoF**）的几种模式，作为解决方案，以利用他人过去解决类似问题的经验，以免重复常见错误。应用了单一责任原则、开闭原则、里氏替换原则、接口隔离原则和依赖反转原则（SOLID原则），以确保我们正在创建一个稳定的代码库，将有助于管理和未来开发我们的应用程序。
- en: This chapter will continue to explain the building of the FlixOne inventory
    management application by incorporating more patterns. More of the GoF patterns
    will be used, including the singleton and factory patterns. A singleton pattern
    will be used to illustrate the repository pattern that is used to maintain the
    FlixOne collection of books. The factory pattern will further the understanding
    of the **Dependency Injection** (**DI**). Finally, we will use the .NET Core framework
    to facilitate an **Inversion of Control** (**IoC**) container that will be used
    to complete the initial inventory management console application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续解释通过合并更多模式来构建FlixOne库存管理应用程序。将使用更多的GoF模式，包括单例模式和工厂模式。将使用单例模式来说明用于维护FlixOne图书收藏的存储库模式。工厂模式将进一步理解**依赖注入**（**DI**）。最后，我们将使用.NET
    Core框架来促进**控制反转**（**IoC**）容器，该容器将用于完成初始库存管理控制台应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The singleton pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The factory pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Features of .NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core的特性
- en: Console application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以解释这些概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）
- en: .NET Core
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用Express Edition）
- en: Installing Visual Studio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or later. You
    can use your preferred IDE. To do this, follow these instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio或更高版本。您可以使用您喜欢的集成开发环境。要做到这一点，请按照以下说明进行操作：
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for the installation of Visual Studio; in this chapter, we are using Visual Studio
    for Windows.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明进行操作。安装Visual Studio有多个版本可供选择；在本章中，我们使用的是Windows版的Visual Studio。
- en: Setting up .NET Core
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core的设置
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，则需要按照以下说明进行操作：
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'Follow the installation instructions for the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照相关库的安装说明进行操作：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code that is shown
    in this chapter might not be complete, so it is recommended that you retrieve
    the source code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到。本章中显示的源代码可能不完整，因此建议您检索源代码以运行示例（[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4)）。
- en: The singleton pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is another GoF design pattern that is used to restrict
    the instantiation of a class to one object. It is used in situations where actions
    within a system need to be coordinated or access to data needs to be limited.
    For example, if access to a file needs to be restricted within an application
    to a single writer, then a singleton could be used to prevent multiple objects
    from trying to write to the file at the same time. In our scenario, we are going
    to use a singleton to maintain the collection of books and their inventory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是另一个GoF设计模式，用于限制类的实例化为一个对象。它用于需要协调系统内的操作或限制对数据的访问的情况。例如，如果需要在应用程序内将对文件的访问限制为单个写入者，则可以使用单例模式防止多个对象同时尝试向文件写入。在我们的场景中，我们将使用单例模式来维护书籍及其库存的集合。
- en: The value of the singleton pattern is more apparent when it is illustrated using
    examples. This section will start with a basic class and then go on to identify
    the different issues that the singleton pattern addresses. These issues will be
    identified, and the class will be updated and then verified by unit tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的价值在使用示例时更加明显。本节将从一个基本类开始，然后继续识别单例模式所解决的不同问题。这些问题将被识别出来，然后通过单元测试进行更新和验证。
- en: The singleton pattern should only be used when necessary as it can introduce
    a potential bottleneck for the application. Sometimes, the pattern is viewed as
    an anti-pattern as it introduces global state. With global state, unknown dependencies
    within an application are introduced and it then becomes unclear as to how many
    types might depend on the information. Additionally, many frameworks and repositories
    already limit access when required, so introducing an additional mechanism might
    limit the performance unnecessarily.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式应仅在必要时使用，因为它可能为应用程序引入潜在的瓶颈。有时，该模式被视为反模式，因为它引入了全局状态。全局状态会引入应用程序中的未知依赖关系，因此不清楚有多少类型可能依赖于该信息。此外，许多框架和存储库已经在需要时限制了访问，因此引入额外的机制可能会不必要地限制性能。
- en: .NET Core provides support for a number of the patterns discussed. In the next
    chapter, we will take advantage of the `ServiceCollection`class's support for
    both the factory method and the singleton pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core支持许多讨论的模式。在下一章中，我们将利用`ServiceCollection`类对工厂方法和单例模式的支持。
- en: In our scenario, the singleton pattern will be used to hold an in-memory repository
    containing a collection of books. The singleton will prevent the collection of
    books from being updated by more than one thread at a time. This will require
    us to *lock* a section of the code to prevent unpredictable updates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，单例模式将用于保存包含书籍集合的内存存储库。单例将防止多个线程同时更新书籍集合。这将要求我们*锁定*代码的一部分，以防止不可预测的更新。
- en: 'The complexity of introducing a singleton into an application can be subtle;
    so, to gain a solid understanding of the pattern, we will cover the following
    topics:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将单例引入应用程序的复杂性可能是微妙的；因此，为了对该模式有一个坚实的理解，我们将涵盖以下主题：
- en: .Net Framework's handling of processes and threads
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .Net Framework对进程和线程的处理
- en: The repository pattern
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库模式
- en: Race conditions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件
- en: Unit testing to identify race conditions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试以识别竞争条件
- en: Processes and threads
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程
- en: To understand the singleton pattern, we need to provide a little context. In
    the .Net Framework, an application will be composed of lightweight, managed subprocesses
    called application domains that can comprise one or more managed threads. For
    the purpose of understanding the singleton pattern, let's define this as a multithreaded
    application that contains one or more threads running simultaneously. Technically,
    the threads are actually not running simultaneously, but this is achieved by dividing
    the available processor time between the threads, so that each thread will execute
    for a small amount of time and then the thread will suspend activity, allowing
    for another thread to execute.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解单例模式，我们需要提供一些背景。在.Net Framework中，一个应用程序将由称为应用程序域的轻量级托管子进程组成，这些子进程可以包含一个或多个托管线程。为了理解单例模式，让我们将其定义为包含一个或多个同时运行的线程的多线程应用程序。从技术上讲，这些线程实际上并不是同时运行的，而是通过在线程之间分配可用处理器时间来实现的，因此每个线程将执行一小段时间，然后该线程将暂停活动，从而允许另一个线程执行。
- en: Going back to the singleton pattern, in a multithreaded application, special
    care needs to be taken to ensure that access to the singleton is limited so that
    only one thread enters specific areas of logic at a time. Because of this synchronization
    of threads, it is possible for one thread to retrieve a value and update it, and,
    before it can be stored, another thread also updates the value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单例模式，在多线程应用程序中，需要特别注意确保对单例的访问受限，以便只有一个线程同时进入特定逻辑区域。由于线程的同步，一个线程可以检索值并更新它，然后在存储之前，另一个线程也更新该值。
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可能访问相同的共享数据并以不可预测的结果进行更新，这可能被称为**竞争条件**。
- en: 'To avoid data being updated incorrectly, some restriction is required to prevent
    more than one thread from executing the same block of logic at the same time.
    There are several mechanisms supported in the .Net Framework and, in the singleton
    pattern, the `lock` keyword is used. In the following code, the `lock` keyword
    is illustrated to show that only one thread at a time can execute the highlighted
    code while all other threads will be blocked:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据被错误更新，需要一些限制，以防止多个线程同时执行相同的逻辑块。在.Net Framework中支持几种机制，在单例模式中，使用`lock`关键字。在下面的代码中，演示了`lock`关键字，以表明一次只有一个线程可以执行突出显示的代码，而所有其他线程将被阻塞：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The lock is a simple way of restricting access to a section of code and can
    be applied to both object instances, as our previous example shows, and to the
    sections of code marked as static.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 锁是限制代码段访问的简单方法，可以应用于对象实例，就像我们之前的例子所示的那样，也可以应用于标记为静态的代码段。
- en: The repository pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库模式
- en: The singleton pattern that is introduced to the project is applied to a class
    being used to maintain the inventory's collection of books. The singleton will
    prevent access from multiple threads being handled incorrectly, and, another pattern,
    the repository pattern, will be used to create a facade over the data that is
    being managed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 引入到项目中的单例模式应用于用于维护库存书籍集合的类。单例将防止多个线程访问被错误处理，另一个模式存储库模式将用于创建一个外观，用于管理的数据。
- en: The repository pattern provides an abstraction over a repository to provide
    a layer between the business logic of an application and the underlying data.
    This provides several advantages. By having a clean separation, our business logic
    can be maintained and unit tested independently of the underlying data. Often,
    the same repository pattern class can be reused by multiple business objects.
    An example of this could be `GetInventoryCommand`, `AddInventoryCommand`, and
    `UpdateInventoryCommand` objects; all of these objects use the same repository
    class. This allows us to test the logic in these commands in isolation from the
    repository. Another advantage of the pattern is that it enables centralized data-related
    policies to be more easily implemented, such as caching.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式提供了一个存储库的抽象，以在应用程序的业务逻辑和底层数据之间提供一层。这提供了几个优势。通过进行清晰的分离，我们的业务逻辑可以独立于底层数据进行维护和单元测试。通常，相同的存储库模式类可以被多个业务对象重用。一个例子是`GetInventoryCommand`、`AddInventoryCommand`和`UpdateInventoryCommand`对象；所有这些对象都使用相同的存储库类。这使我们能够在不受存储库影响的情况下测试这些命令中的逻辑。该模式的另一个优势是，它使得更容易实现集中的数据相关策略，比如缓存。
- en: 'To begin, let''s consider the following interface that describes the methods
    that the repository will implement; it contains a method for retrieving the books,
    adding a book, and updating the quantity of the book:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑以下描述存储库将实现的方法的接口；它包含了检索书籍、添加书籍和更新书籍数量的方法：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The initial version of the repository is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库的初始版本如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this chapter, the book collection is being maintained in the form of an in-memory
    cache, and, in later chapters, this will be moved to a repository providing persistent
    data. Of course, this implementation is not ideal, as, once the application ends,
    all the data will be lost. However, it serves to illustrate the singleton pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，书籍集合以内存缓存的形式进行维护，而在后续章节中，这将被移动到提供持久数据的存储库中。当然，这种实现并不理想，因为一旦应用程序结束，所有数据都将丢失。但是，它用来说明单例模式。
- en: Unit tests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To illustrate the issues that the singleton pattern addresses, let''s start
    with a simple unit test that adds 30 books to the repository, updates the quantity
    of the different books, and then verifies the result. The following code shows
    the overall unit test, and we will explain each step individually:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明单例模式解决的问题，让我们从一个简单的单元测试开始，向存储库添加30本书，更新不同书籍的数量，然后验证结果。以下代码显示了整体单元测试，我们将逐个解释每个步骤：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add 30 books, the `context` instance is used to add books from `Book_1`to `Book_30`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加30本书，使用`context`实例从`Book_1`到`Book_30`添加书籍：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next section updates the book quantity by adding the numbers from `1` to `10`
    to the quantity of each book:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分通过将数字`1`到`10`添加到每本书的数量来更新书籍数量：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, in the next section, we will subtract the numbers from `1` to `10` from
    the quantity of each book:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一部分，我们将从每本书的数量中减去数字`1`到`10`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we have added and removed the same quantity for each book, the last part
    of our test will verify that the ending quantity is `0`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为每本书添加和移除了相同的数量，所以我们测试的最后部分将验证最终数量是否为`0`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running the test, we can see that the test passes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，我们可以看到测试通过了：
- en: '![](img/9597d7f3-ef49-419f-b295-077228d9471e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9597d7f3-ef49-419f-b295-077228d9471e.png)'
- en: So, when the test is run in a single process, the repository works as desired.
    However, what if the update requests are performed in separate threads? In order
    to test this, the unit test will be refactored to perform calls to the `InventoryContext` class
    in separate threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当测试在单个进程中运行时，存储库将按预期工作。但是，如果更新请求在单独的线程中执行会怎样呢？为了测试这一点，单元测试将被重构为在单独的线程中对`InventoryContext`类进行调用。
- en: 'The addition of the books is moved to a method that performs adding a book
    as a task (that is, in its own thread):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的添加被移动到一个执行添加书籍的方法中（即在自己的线程中）：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, the update quantity step is moved into another method with a
    similar approach:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更新数量步骤被移动到另一个具有类似方法的方法中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The unit test is then updated to call the new methods. It is worth noting that
    the unit test will wait until all books are added before updating the quantity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新单元测试以调用新方法。值得注意的是，单元测试将等待所有书籍添加完成后再更新数量。
- en: 'The `add thirty books` section now looks as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`添加三十本书`部分现在如下所示：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, the update quantity is changed to call both the `Add` and `subtract` method
    in the tasks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，更新数量被更改为在任务中调用`Add`和`subtract`方法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the refactor, the unit test no longer successfully completes, and, when
    the unit test runs now, an error is reported indicating that the book was not
    found in the collection. This will be reported as `"The given key was not present
    in the dictionary."`. This is because each time the context is instantiated, a
    new books collection is created. The first step is to restrict the creation of
    the context. This is done by changing the access of the constructor so that the
    class can no longer be instantiated directly. Instead, a new public `static` property
    that only supports a `get` operation is added. This property will return an underlying `static`instance
    of the `InventoryContext` class and, if the instance is missing, will create it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后，单元测试不再成功完成，当单元测试现在运行时，会报告错误，指示在集合中找不到书籍。这将报告为“字典中未找到给定的键”。这是因为每次实例化上下文时，都会创建一个新的书籍集合。第一步是限制上下文的创建。这是通过更改构造函数的访问权限来完成的，以便该类不再可以直接实例化。相反，添加一个新的公共`static`属性，只支持`get`操作。该属性将返回`InventoryContext`类的底层`static`实例，并且如果实例丢失，将创建它：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is still not enough to fix the broken unit test, but this is due to a
    different reason. To identify the issue, the unit test is run in debug mode with
    a breakpoint set in the `UpdateQuantity` method. The first time this is run, we
    can see that 28 books have been created and loaded in the book collection, as
    shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不足以修复损坏的单元测试，但这是由于不同的原因。为了确定问题，单元测试在调试模式下运行，并在`UpdateQuantity`方法中设置断点。第一次运行时，我们可以看到已经创建了28本书并加载到书籍集合中，如下面的截图所示：
- en: '![](img/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png)'
- en: 'At this point in the unit test, we would expect 30 books; however, before we
    start investigating, let''s run the unit test a second time. This time, we get
    an **Object reference not set to an instance of an object** error when we try
    to access the books collection for adding a new book, as shown in the following
    screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试的这一点上，我们期望有30本书；然而，在我们开始调查之前，让我们再次运行单元测试。这一次，当我们尝试访问书籍集合以添加新书时，我们遇到了一个“对象引用未设置为对象的实例”错误，如下面的截图所示：
- en: '![](img/268b58d4-cbbe-4b12-9b77-df3b31df45db.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/268b58d4-cbbe-4b12-9b77-df3b31df45db.png)'
- en: 'Moreover, when the unit test is run a third time, the **Object reference not
    set to an instance of an object** error is not encountered, but there are only
    27 books in our collection, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当单元测试第三次运行时，不再遇到“对象引用未设置为对象的实例”错误，但我们的集合中只有27本书，如下面的截图所示：
- en: '![](img/46a4b8bc-48e9-4586-b1af-c64784920993.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46a4b8bc-48e9-4586-b1af-c64784920993.png)'
- en: 'This type of unpredictable behavior is typical of race conditions and indicates
    that the shared resource, that is, the `InventoryContext` singleton, is being
    handled by multiple threads without synchronizing the access. The construction
    of the static object still allows more than one instance of the `InventoryContext` singleton
    to be created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不可预测的行为是竞争条件的典型特征，并且表明共享资源，即`InventoryContext`单例，正在被多个线程处理而没有同步访问。静态对象的构造仍然允许创建多个`InventoryContext`单例的实例：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The race condition is where multiple threads evaluate the `if` statement as
    true and they all try to construct the `_context` object. All will succeed, but
    they will overwrite the previously constructed value by doing so. Of course, this
    is inefficient, especially when the constructor is a costly operation, but the
    issue discovered with the unit test is that the `_context` object is actually
    constructed by a thread after another thread or threads have updated the books
    collection. That is why the books collection, `_books`, has a different number
    of elements between runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是多个线程评估`if`语句为真，并且它们都尝试构造`_context`对象。所有线程都会成功，但它们会通过这样做覆盖先前构造的值。当然，这是低效的，特别是当构造函数是昂贵的操作时，但单元测试发现的问题是`_context`对象实际上是由一个线程在另一个线程或多个线程更新书籍集合之后构造的。这就是为什么书籍集合`_books`在运行之间具有不同数量的元素。
- en: 'To prevent this issue, the pattern uses a lock around the constructor as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，该模式在构造函数周围使用锁定，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unfortunately, the unit tests still fail. This is because although one thread
    at a time can enter the lock, all blocked instances will still enter the lock
    once the blocking thread has completed. The pattern handles this situation by
    having an additional check inside the lock in case the construction has already
    been completed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，单元测试仍然失败。这是因为虽然一次只有一个线程可以进入锁定，但所有被阻塞的实例仍然会在阻塞线程完成后进入锁定。该模式通过在锁定内部进行额外检查来处理这种情况，以防构造已经完成：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding lock is essential as it prevents the static `InventoryContext`
    object from getting instantiated multiple times. Unfortunately, our test still
    does not consistently pass; with each change, the unit test becomes closer to
    passing. Some unit test runs will complete without error but, occasionally, the
    test completes with a failed result, as indicated in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的锁定是必不可少的，因为它防止静态的`InventoryContext`对象被多次实例化。不幸的是，我们的测试仍然没有始终通过；随着每次更改，单元测试越来越接近通过。一些单元测试运行将在没有错误的情况下完成，但偶尔，测试将以失败的结果完成，如下面的截图所示：
- en: '![](img/8cf03f40-50e7-4459-8209-60388b3b9a71.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf03f40-50e7-4459-8209-60388b3b9a71.png)'
- en: 'Our instantiation of the static repository is now thread safe, but our access
    to the books collection is not. One thing to note is that the `Dictionary` class
    being used is not thread-safe. Fortunately, there are thread-safe collections
    available as part of the .Net Framework. These classes ensure that **adds and
    removals** from the collection are written for a multithreaded process. Note that
    only adds and removals are thread safe as this will become important a little
    bit later. The updated constructor is shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态存储库实例现在是线程安全的，但我们对书籍集合的访问不是。需要注意的一点是，所使用的`Dictionary`类不是线程安全的。幸运的是，.Net
    Framework中有线程安全的集合可用。这些类确保了对集合的**添加和删除**是为多线程进程编写的。需要注意的是，只有添加和删除是线程安全的，因为这将在稍后变得重要。更新后的构造函数如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Microsoft recommends using the thread-safe collections in `System.Collections.Concurrent`
    over the corresponding collections in `System.Collections`, unless the application
    is targeting .Net Framework 1.1 or earlier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议在目标为.Net Framework 1.1或更早版本的应用程序中，使用`System.Collections.Concurrent`中的线程安全集合，而不是`System.Collections`中对应的集合。
- en: After running the unit test again, introducing a `ConcurrentDictionary` class
    is still not enough to prevent incorrectly maintaining the books. The unit test
    is still failing. The concurrent dictionary protects from multiple threads being
    added and removed unpredictably, but does not offer any protection on the items
    in the collection themselves. This means that updates to the objects in the collection
    are not thread safe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行单元测试后，引入`ConcurrentDictionary`类仍然不足以防止书籍的错误维护。单元测试仍然失败。并发字典可以防止多个线程不可预测地添加和删除，但对集合中的项目本身没有任何保护。这意味着对集合中的对象的更新不是线程安全的。
- en: Let's take a closer look at race conditions in a multithreaded environment to
    understand why this is the case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下多线程环境中的竞争条件，以了解为什么会出现这种情况。
- en: A race condition illustration
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争条件示例
- en: 'The following sequence of diagrams visualize what is happening conceptually
    between two threads: **ThreadA** and **ThreadB**. The first diagram shows both
    threads without any values from the collection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列图表描述了两个线程**ThreadA**和**ThreadB**之间概念上发生的情况。第一个图表显示了两个线程都没有从集合中获取任何值：
- en: '![](img/fe27049f-ade1-485f-a255-bcd56290bbc6.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe27049f-ade1-485f-a255-bcd56290bbc6.png)'
- en: 'The following diagram shows that both threads read from the collection of the
    book with the name of `Chester`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两个线程都从名称为`Chester`的书籍集合中读取：
- en: '![](img/b2b80704-df53-4c39-b3c5-e7176a6c2467.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2b80704-df53-4c39-b3c5-e7176a6c2467.png)'
- en: 'The following diagram shows that **ThreadA** updates the book by increasing
    the quantity by `4`, while **ThreadB** updates the book by increasing the quantity
    by `3`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了**ThreadA**通过增加`4`来更新书籍的数量，而**ThreadB**通过增加`3`来更新书籍的数量：
- en: '![](img/b5a8650f-1f3d-4414-9109-f15046958d42.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a8650f-1f3d-4414-9109-f15046958d42.png)'
- en: 'Then, when the updated book is persisted back to the collection, we have an
    unknown quantity as the result, as shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当更新后的书籍被持久化回集合时，我们得到了一个未知数量的结果，如下图所示：
- en: '![](img/f4a99992-46d0-4eb7-a464-d82126476461.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4a99992-46d0-4eb7-a464-d82126476461.png)'
- en: 'To avoid this race condition, we need to block other threads while an update
    operation is taking place. In `InventoryContext`, blocking other threads takes
    the form of a lock around the update of the book quantity:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种竞争条件，我们需要在更新操作进行时阻止其他线程。在`InventoryContext`中，阻止其他线程的方法是在更新书籍数量时进行锁定：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The unit test now completes without error, as the additional locks prevent unpredictable
    race conditions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试现在可以顺利完成，因为额外的锁定防止了不可预测的竞争条件。
- en: The `InventoryContext` class is still not complete as it has been completed
    just enough to illustrate the singleton and repository patterns. In later chapters,
    the `InventoryContext` class will be adapted to use Entity Framework, an **Object
    Relational Mapping** (**ORM**) framework. At this point, the `InventoryContext` class
    will be improved to support additional functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryContext`类仍然不完整，因为它只是完成了足够的部分来说明单例和存储库模式。在后面的章节中，`InventoryContext`类将被改进以使用Entity
    Framework，这是一个**对象关系映射**（**ORM**）框架。此时，`InventoryContext`类将被改进以支持额外的功能。'
- en: AddInventoryCommand
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddInventoryCommand
- en: 'With our repository available, the three `InventoryCommand` classes can be
    completed. The first, `AddInventoryCommand`, is shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的存储库后，三个`InventoryCommand`类可以完成。首先是`AddInventoryCommand`，如下所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing to note is that the repository, `IInventoryContext`, is injected
    in the constructor along with the `IUserInterface` interface described in the
    previous chapter. The command also requires a single parameter, `name`*, *to be
    supplied. This is retrieved in the `GetParameters` method that implements the
    `IParameterisedCommand` interface, which was also covered in the previous chapter.
    The command is then run in the `InternalCommand` method, which simply executes
    the `AddBook` method on the repository and returns a bool indicating whether the
    command has executed successfully.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，存储库`IInventoryContext`在构造函数中与前一章描述的`IUserInterface`接口一起被注入。命令还需要提供一个参数，即`name`*，*这在实现了前一章中也涵盖的`IParameterisedCommand`接口的`GetParameters`方法中被检索。然后在`InternalCommand`方法中运行命令，该方法简单地在存储库上执行`AddBook`方法，并返回一个指示命令是否成功执行的布尔值。
- en: TestInventoryContext
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestInventoryContext
- en: Similar to `TestUserInterface` used in the previous chapter, the `TestInventoryContext` class
    will be used to mock the behavior of our repository by implementing the `IInventoryContext`
    interface. This class will support the three methods of the interface, as well
    as supporting two additional methods for retrieving the books that have been added
    to the collection during the unit test and for retrieving the books that have
    been updated during the unit test.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章中使用的`TestUserInterface`类类似，`TestInventoryContext`类将用于模拟我们的存储库的行为，实现`IInventoryContext`接口。该类将支持接口的三种方法，以及支持在单元测试期间添加到集合中的两种附加方法和更新的书籍。
- en: 'To support the `TestInventoryContext` class, two collections will be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`TestInventoryContext`类，将使用两个集合：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first is used to store the starting collection of the books, while the
    second is used to store the final collection of the books. The constructor is
    shown in the following code; note how the dictionaries are copies of each other:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于存储书籍的起始集合，而第二个用于存储书籍的最终集合。构造函数如下所示；请注意字典是彼此的副本：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `IInventoryContext` methods are written to update and return just one of
    the collections, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInventoryContext`方法被编写为更新和返回集合中的一本书，如下所示：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the end of the unit test, the two remaining methods can be used to determine
    the difference between the starting and ending collections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试结束时，可以使用剩余的两种方法来确定起始和结束集合之间的差异：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is some confusion in the software industry around the differences between
    mocks, stubs, fakes, and other terms used to identify and/or categorize types
    or services used in testing that are not suitable for production but are necessary
    for the unit test. These dependencies may have functionality that is different,
    missing, and/or the same as their *real* counterparts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业中，关于模拟、存根、伪造和其他用于识别和/或分类测试中使用的类型或服务的差异存在一些混淆，这些类型或服务不适用于生产，但对于单元测试是必要的。这些依赖项可能具有与其*真实*对应项不同、缺失和/或相同的功能。
- en: For example, the `TestUserInterface` class could be referred to as a mock as
    it provides some expectation (for example, assert statements) of the unit test
    while the `TestInventoryContext` class would be a fake, as it provides a working
    implementation. In this book, we will not follow these classifications too strictly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`TestUserInterface`类可以被称为模拟，因为它提供了对单元测试的一些期望（例如，断言语句），而`TestInventoryContext`类将是伪造的，因为它提供了一个工作实现。在本书中，我们不会严格遵循这些分类。
- en: AddInventoryCommandTest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddInventoryCommandTest
- en: '`AddInventoryCommandTest` was updated by the team to verify the `AddInventoryCommand`
    functionality. This test will verify the adding of a single book to an existing
    inventory. The first part of the test is to define what is expected of the interface,
    which is only a single prompt to receive the new book name (remember that the
    `TestUserInterface` class takes three parameters: expected input, expected messages,
    and expected warnings):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 团队已经更新了`AddInventoryCommandTest`来验证`AddInventoryCommand`的功能。此测试将验证向现有库存中添加一本书。测试的第一部分是定义接口的预期，这只是一个单独的提示，用于接收新书名（请记住`TestUserInterface`类需要三个参数：预期输入、预期消息和预期警告）：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `TestInventoryContext` class will be initialized with a single book simulating
    an existing book collection:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestInventoryContext`类将初始化为模拟现有书籍集合中的一本书：'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code snippet shows the creation of `AddInventoryCommand`, the
    running of the command, and the assert statements used to validate that the command
    ran successfully:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`AddInventoryCommand`的创建、命令的运行以及用于验证命令成功运行的断言语句：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the command is run, the result is verified to have run without error and
    that the command is not a terminating command. The rest of the `Assert` statements
    validate the expectation that only one book was added with the expected name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 命令运行后，将验证结果是否无错误运行，并且命令不是终止命令。`Assert`语句的其余部分验证了预期只添加了一本带有预期名称的书。
- en: UpdateQuantityCommand
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UpdateQuantityCommand
- en: '`UpdateQuantityCommand` is very similar to `AddInventoryCommand` and its source
    is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommand`与`AddInventoryCommand`非常相似，其源代码如下：'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Like `AddInventoryCommand`, the `UpdateInventoryCommand` command is a non-terminating
    command with parameters. Therefore, it extends the `NonTerminatingCommand` base
    class and implements the `IParameterisedCommand` interface. Similarly, the dependencies
    for `IUserInterface` and `IInventoryContext` are injected in the constructor:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AddInventoryCommand`一样，`UpdateInventoryCommand`命令是一个带参数的非终止命令。因此，它扩展了`NonTerminatingCommand`基类，并实现了`IParameterisedCommand`接口。同样，`IUserInterface`和`IInventoryContext`的依赖项在构造函数中注入：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `UpdateQuantityCommand` class does have an additional parameter, *quantity*,
    which is determined as part of the `GetParameters` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommand`类确实具有一个额外的参数*quantity*，该参数是作为`GetParameters`方法的一部分确定的。'
- en: 'Finally, the quantity of a book is updated via the repository''s `UpdateQuantity`
    method in the `InternalCommand` override method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过存储库的`InternalCommand`重写方法，更新书的数量：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that the `UpdateQuantityCommand` class has been defined, the following section
    will add a unit test to validate the command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`UpdateQuantityCommand`类已经定义，接下来的部分将添加一个单元测试来验证该命令。
- en: UpdateQuantityCommandTest
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UpdateQuantityCommandTest
- en: '`UpdateQuantityCommandTest` contains a test to validate a scenario where a
    book is updated in an existing collection. The creation of the expected interface
    and existing collection are shown in the following code (note that the test involves
    adding `6` to the quantity of an existing book):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommandTest`包含一个测试，用于验证在现有集合中更新书籍的情景。预期接口和现有集合的创建如下代码所示（请注意，测试涉及将`6`添加到现有书的数量）：'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code block shows the running of the command and the initial validation
    of the successful run of the non-terminating command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块显示了命令的运行以及非终止命令成功运行的初始验证：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The expectation of the test is that no new books would be added and that the
    existing book''s quantity of 7 will be increased by 6, resulting in a new quantity
    of 13:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的期望是不会添加新书籍，并且现有书籍的数量为 7，将增加 6，结果为新数量为 13：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the `UpdateQuantityCommand` class added, the ability to retrieve the inventory
    will be added in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `UpdateQuantityCommand` 类后，将在下一节中添加检索库存的能力。
- en: GetInventoryCommand
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetInventoryCommand
- en: 'The `GetInventoryCommand` command differs from the previous two commands because
    it does not require any parameters. It does use the `IUserInterface` dependency
    and the `IInventoryContext` dependency to write the content of the collection.
    This is shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryCommand` 命令与前两个命令不同，因为它不需要任何参数。它使用 `IUserInterface` 依赖项和 `IInventoryContext`
    依赖项来写入集合的内容。如下所示：'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the `GetInventoryCommand` command implemented, the next step is to add
    a new test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了 `GetInventoryCommand` 命令后，下一步是添加一个新的测试。
- en: GetInventoryCommandTest
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetInventoryCommandTest
- en: '`GetInventoryCommandTest` covers a scenario when the `GetInventoryCommand` command
    is used to retrieve the collection of books. The test will define the expected
    messages (remember that the first parameter is for the parameters, the second
    parameter is for messages, and the third parameter is for warnings) that will
    occur when testing the user interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryCommandTest` 涵盖了当使用 `GetInventoryCommand` 命令检索书籍集合时的场景。测试将定义预期的消息（记住，第一个参数是用于参数，第二个参数是用于消息，第三个参数是用于警告），这些消息将在测试用户界面时发生：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These messages will correspond to the mock repository, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息将对应于模拟存储库，如下所示：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The unit test runs the command with the mock dependencies. It verifies that
    the command executed without error and that the command is not a terminating command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试使用模拟依赖项运行命令。它验证命令是否无错误执行，并且命令不是终止命令：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The expected messages are validating in `TestUserInterface` and, hence, the
    only thing that remains for the unit test to do is to make sure that no books
    were mysteriously added or updated by the command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的消息在 `TestUserInterface` 中进行验证，因此单元测试剩下的唯一任务就是确保命令没有神秘地添加或更新书籍：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that suitable unit tests for the `GetInventoryCommand` class have been added,
    we'll introduce the factory pattern in order to manage the creation of specific
    commands.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经添加了适合 `GetInventoryCommand` 类的单元测试，我们将引入工厂模式来管理特定命令的创建。
- en: The factory pattern
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The next pattern applied by the team is the GoF factory pattern. The pattern
    introduces a **creator** whose responsibility is the instantiation of implementations
    of a specific type. Its purpose is to encapsulate the complexity around constructing
    types. The factory pattern allows for more flexibility as the application changes,
    by limiting the amount of required change compared to whether the construction
    was in the calling class. This is because the complexity of the construction is
    in one location, instead of distributed in multiple locations across the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 团队应用的下一个模式是 GoF 工厂模式。该模式引入了一个**创建者**，其责任是实例化特定类型的实现。它的目的是封装围绕构造类型的复杂性。工厂模式允许更灵活地应对应用程序的变化，通过限制所需更改的数量，而不是在调用类中进行构造。这是因为构造的复杂性在一个位置，而不是分布在应用程序的多个位置。
- en: In the FlixOne example, `InventoryCommandFactory` implements the pattern and
    shields the details of constructing each of the different `InventoryCommand` instances.
    In this scenario, the input received from the console application will be used
    to determine the concrete implementation of `InventoryCommand` to return. It is
    important to note that the return type is the `InventoryCommand` abstract class, thus
    shielding the calling class from the details of the concrete class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FlixOne 示例中，`InventoryCommandFactory` 实现了该模式，并屏蔽了构造每个不同的 `InventoryCommand`
    实例的细节。在这种情况下，从控制台应用程序接收到的输入将用于确定要返回的 `InventoryCommand` 的具体实现。重要的是要注意返回类型是 `InventoryCommand`
    抽象类，因此屏蔽了调用类对具体类的细节。
- en: '`InventoryCommandFactory` is shown in the following code block. But, for now,
    focus on the `GetCommand` method as this implements the factory pattern:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 在下面的代码块中显示。但是，现在专注于 `GetCommand` 方法，因为它实现了工厂模式：'
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`GetCommand` uses a given string to determine the specific implementation of `InventoryCommand` to
    return:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommand` 使用给定的字符串来确定要返回的 `InventoryCommand` 的特定实现：'
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All commands require `IUserInterface` to be supplied, but some also require
    access to the repository. These will be supplied with the singleton instance of
    `IInventoryContext`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都需要提供 `IUserInterface`，但有些还需要访问存储库。这些将使用 `IInventoryContext` 的单例实例提供。
- en: The factory pattern is often used with an Interface as the return type. It is
    illustrated here as the `InventoryCommand` base class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式通常与接口一起使用作为返回类型。在这里，它被说明为 `InventoryCommand` 基类。
- en: Unit tests
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: At first glance, the idea of building unit tests for such a simple class seemed
    like a waste of the team's time. Two important issues were uncovered by constructing
    the unit tests that might have gone undetected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，为这样一个简单的类构建单元测试似乎是团队时间的浪费。通过构建单元测试，发现了两个重要问题，这些问题可能会被忽略。
- en: Issue one – UnknownCommand
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题一 - UnknownCommand
- en: 'The first issue was what to do when a command is received that does not match
    any of the defined `InventoryCommand` inputs. After reviewing the requirements,
    the team noticed they missed this requirement, as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是当接收到一个不匹配任何已定义的 `InventoryCommand` 输入的命令时该怎么办。在审查要求后，团队注意到他们错过了这个要求，如下面的截图所示：
- en: '![](img/2609a169-37d7-4a74-8aac-65d25b8c1a77.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2609a169-37d7-4a74-8aac-65d25b8c1a77.png)'
- en: 'The team decided to introduce a new `InventoryCommand` class, `UnknownCommand`,
    to handle this situation. The `UnknownCommand` class should print a warning message
    to the console (via the `IUserInterface` `WriteWarning` method), should not cause
    the application to end, and should return false to indicate that the command was
    not run successfully. The implementation details are shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 团队决定引入一个新的`InventoryCommand`类，`UnknownCommand`，来处理这种情况。 `UnknownCommand`类应该通过`IUserInterface`的`WriteWarning`方法向控制台打印警告消息，不应导致应用程序结束，并且应返回false以指示命令未成功运行。
    实现细节如下所示：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The unit test created for `UnknownCommand` will test for the warning message
    as well as the two Boolean values returned by the `InternalCommand` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为`UnknownCommand`创建的单元测试将测试警告消息以及`InternalCommand`方法返回的两个布尔值：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`UnknownCommandTests` covers the commands that require testing. Next, tests
    around `InventoryCommandFactory` will be implemented.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnknownCommandTests`覆盖了需要测试的命令。 接下来，将实现围绕`InventoryCommandFactory`的测试。'
- en: InventoryCommandFactoryTests
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommandFactoryTests
- en: '`InventoryCommandFactoryTests` contains unit tests related to `InventoryCommandFactory`.
    Because each test will have a similar pattern of constructing `InventoryCommandFactory`
    and its `IUserInterface` dependency and then running the `GetCommand` method,
    a shared method is created that will run when the test initializes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactoryTests`包含与`InventoryCommandFactory`相关的单元测试。 因为每个测试都将具有类似的模式，即构造`InventoryCommandFactory`及其`IUserInterface`依赖项，然后运行`GetCommand`方法，因此创建了一个共享方法，该方法将在测试初始化时运行：'
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Initialize` method constructs a stubbed `IUserInterface` and sets the
    `Factory` property. The individual unit tests then take a simple form of validating
    that the object returned is the correct type. First, an instance of the `QuitCommand` class should
    be returned when the user enters `"q"` or `"quit"`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize`方法构造了一个存根`IUserInterface`并设置了`Factory`属性。 然后，各个单元测试采用简单的形式，验证返回的对象是否是正确的类型。
    首先，当用户输入`"q"`或`"quit"`时，应返回`QuitCommand`类的实例，如下所示：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `QuitCommand_Successful` test method validates that when the `InventoryCommandFactory`
    method, `GetCommand`, is run, the object returned is a specific instance of the `QuitCommand` type.
    `HelpCommand` is only available when `"?"` is submitted:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuitCommand_Successful`测试方法验证了当运行`InventoryCommandFactory`方法`GetCommand`时，返回的对象是`QuitCommand`类型的特定实例。
    当提交`"?"`时，`HelpCommand`才可用：'
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The team did add a test for `UnknownCommand` that validated how `InventoryCommand`
    would respond when given a value not matching an existing command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 团队确实添加了一个针对`UnknownCommand`的测试，验证了当给出与现有命令不匹配的值时，`InventoryCommand`将如何响应：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the test methods in place, we can now cover a scenario where a command
    is given that does not match a known command in the application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有了测试方法，现在我们可以涵盖一种情况，即在应用程序中给出一个不匹配已知命令的命令。
- en: Issue two – case-insensitive text commands
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题二 - 不区分大小写的文本命令
- en: 'The second issue was uncovered when the requirements were reviewed again, stating
    that the commands should not be case-sensitive:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是在再次审查要求时发现的，即命令不应区分大小写：
- en: '![](img/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png)'
- en: 'With the test for `UpdateInventoryCommand`, `InventoryCommandFactory` was found
    to be case-sensitive using the following test:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`UpdateInventoryCommand`的测试，发现`InventoryCommandFactory`在以下测试中是区分大小写的：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Fortunately, this test was easy to solve by applying a `ToLower()` method to
    the input before determining the command, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过在确定命令之前对输入应用`ToLower()`方法，这个测试很容易解决，如下所示：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This scenario highlights both the value of the `Factory` method and the value
    of leveraging unit tests to help validate requirements during development and
    not relying on user testing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况突出了`Factory`方法的价值以及利用单元测试来帮助验证开发过程中的需求的价值，而不是依赖用户测试。
- en: Features in .NET Core
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的功能
- en: '[Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns – Basics Part 1,* and the first part of this chapter have illustrated
    the GoF patterns without using any frameworks. It is worth covering this as, sometimes,
    a framework is not available for a specific pattern or applicable in a particular
    scenario. Additionally, it is important to understand what functionality the framework
    is providing in order to know when a pattern should be used. The rest of this
    chapter will look at a couple of features that .NET Core provides that support
    some of the patterns we have covered so far.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式 - 基础部分1*，以及本章的第一部分已经演示了GoF模式，而没有使用任何框架。
    有必要覆盖这一点，因为有时针对特定模式可能没有可用的框架，或者在特定场景中不适用。 此外，了解框架提供的功能是很重要的，以便知道何时应该使用某种模式。 本章的其余部分将介绍.NET
    Core提供的一些功能，支持我们迄今为止已经涵盖的一些模式。'
- en: IServiceCollection
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IServiceCollection
- en: .NET Core was designed with **Dependency Injection** (**DI**) built-in to the
    framework. Typically, the start of a .NET Core application contains the set up
    of the DI for an application that primarily contains the creation of a collection
    of services. The framework uses these services to supply the dependencies when
    the application requires them. The services provide the foundation of a robust
    **Inversion of Control** (**IoC**) framework and are arguably one of the coolest
    features of .NET Core. This section will complete the console application and
    demonstrate how .NET Core supports building a sophisticated IoC framework based
    on the `IServiceCollection` interface.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core设计时内置了**依赖注入**（**DI**）。 通常，.NET Core应用程序的启动包含为应用程序设置DI的过程，主要包括创建服务集合。
    框架在应用程序需要时使用这些服务来提供依赖项。 这些服务为强大的**控制反转**（**IoC**）框架奠定了基础，并且可以说是.NET Core最酷的功能之一。
    本节将完成控制台应用程序，并演示.NET Core如何基于`IServiceCollection`接口支持构建复杂的IoC框架。
- en: 'The `IServiceCollection` interface is used to define the services available
    to the container that implements `IServiceProvider` interface. The services themselves
    are types that will be injected at runtime when required by the application. For
    example, `ConsoleUserInterface` interface, which was defined previously, will
    be a service injected at runtime. This is shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection`接口用于定义容器中可用的服务，该容器实现了`IServiceProvider`接口。这些服务本身是在应用程序需要时在运行时注入的类型。例如，之前定义的`ConsoleUserInterface`接口将在运行时作为服务注入。这在下面的代码中显示：'
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, `ConsoleUserInterface` interface is being added as a
    service that implements the `IUserInterface` interface. If the DI is providing
    another type that requires a `IUserInterface` interface dependency, then `ConsoleUserInterface`
    interface will be used. For example, `InventoryCommandFactory` is also added to
    the services, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`ConsoleUserInterface`接口被添加为实现`IUserInterface`接口的服务。如果DI提供了另一种需要`IUserInterface`接口依赖的类型，那么将使用`ConsoleUserInterface`接口。例如，`InventoryCommandFactory`也被添加到服务中，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`InventoryCommandFactory` has a constructor that requires an implementation
    of the `IUserInterface` interface:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory`有一个需要`IUserInterface`接口实现的构造函数：'
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Later, an instance of `InventoryCommandFactory` is requested, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，请求一个`InventoryCommandFactory`的实例，如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, an instance of `IUserInterface` (in this application it is the registered `ConsoleUserInterface`)
    is instantiated and supplied to the constructor of `InventoryCommandFactory`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`IUserInterface`的一个实例（在这个应用程序中是注册的`ConsoleUserInterface`）被实例化并提供给`InventoryCommandFactory`的构造函数。
- en: There are different types of service *lifetimes *that can be specified when
    registering a service. A lifetime governs how the types will be instantiated and
    include Transient, Scoped, and Singleton. Transient means the service is created
    each time it is requested. Scope will be covered later when we look at website-related
    patterns and in particular where services are created per web request. Singleton
    behaves like the singleton pattern we covered earlier, and will also be covered
    later in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册服务时可以指定不同类型的服务*生命周期*。生命周期规定了类型将如何实例化，包括瞬态、作用域和单例。瞬态意味着每次请求时都会创建服务。作用域将在后面讨论，特别是在查看与网站相关的模式时，服务是按照网页请求创建的。单例的行为类似于我们之前讨论的单例模式，并且将在本章后面进行讨论。
- en: CatalogService
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CatalogService
- en: 'The `CatalogService` interface represents the console application the team
    is building and is described as having a single `Run` method, as shown in the
    `ICatalogService` interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`CatalogService`接口代表团队正在构建的控制台应用程序，并被描述为具有一个`Run`方法，如`ICatalogService`接口中所示：'
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The service has two dependencies, `IUserInterface` and `IInventoryCommandFactory`,
    and they will be injected into the constructor and stored as local variables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务有两个依赖项，`IUserInterface`和`IInventoryCommandFactory`，它们将被注入到构造函数中并存储为局部变量：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Run` method is based on the earlier design by the team shown in [Chapter
    3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design Patterns
    – Basics Part 1.* It prints a greeting and then loops until the quit inventory command
    is entered by the user. Each loop will perform the command and, if the command
    is not successful, it will print a help message:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run`方法基于团队在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中展示的早期设计。它打印一个问候语，然后循环，直到用户输入退出库存命令为止。每次循环都会执行命令，如果命令不成功，它将打印一个帮助消息：'
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now that we have the `CatalogService` interface ready, the next step will be
    to put everything together. The next section will do this using .NET Core.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`CatalogService`接口，下一步将是把所有东西放在一起。下一节将使用.NET Core来完成这一点。
- en: IServiceProvider
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IServiceProvider
- en: 'With `CatalogService` defined, the team is finally able to put everything together
    in .NET Core. The start of all applications, that is, EXE programs, is the `Main`
    method, and .NET Core is no exception. The program is shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`CatalogService`定义，团队最终能够在.NET Core中将所有东西放在一起。所有应用程序的开始，即EXE程序，都是`Main`方法，.NET
    Core也不例外。程序如下所示：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `ConfigureServices` method, different types are added to the IoC container
    including `ConsoleUserInterface`, `CatalogService`, and `InventoryCommandFactory` classes.
    The `ConsoleUserInterface` and `InventoryCommandFactory` class will be injected
    as required and the `CatalogService` class will be explicitly retrieved from the
    `IServiceProvider` interface built from the `ServiceCollection` object containing
    the added types. The program *runs* until the `CatalogService` `Run` method completes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConfigureServices`方法中，不同类型被添加到IoC容器中，包括`ConsoleUserInterface`、`CatalogService`和`InventoryCommandFactory`类。`ConsoleUserInterface`和`InventoryCommandFactory`类将根据需要注入，而`CatalogService`类将从`ServiceCollection`对象中包含的添加类型构建的`IServiceProvider`接口中显式检索出来。程序将一直运行，直到`CatalogService`的`Run`方法完成。
- en: In [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml), *Implementing Design
    Patterns - .NET Core*, the singleton pattern will be revisited to use the .NET
    Core built-in capabilities by using the `IServiceCollection`, `AddSingleton` method
    to control the `InventoryContext` instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml)中，*实现设计模式-.NET Core*，将重新讨论单例模式，使用.NET
    Core内置的能力，通过使用`IServiceCollection`的`AddSingleton`方法来控制`InventoryContext`实例。
- en: Console application
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台应用程序
- en: 'The console application, when running from the command line, is simple, but
    it is a foundation of well-designed code adhering to the SOLID principles discussed
    in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns – Basics Part 1*. When run, the application provides a simple greeting
    and displays a help message, including the command''s supports and examples:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序在命令行中运行时很简单，但它是一个遵循SOLID原则的良好设计代码的基础，这些原则在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中讨论过，*实现设计模式-基础部分1*。运行时，应用程序提供一个简单的问候，并显示一个帮助消息，包括命令的支持和示例：
- en: '![](img/2b227f12-9b64-4501-9190-7385cf1f6d34.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b227f12-9b64-4501-9190-7385cf1f6d34.png)'
- en: 'The application then loops through the commands until a quit command is received.
    The following screenshot illustrates its functionality:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用程序循环执行命令，直到收到退出命令。以下屏幕截图说明了其功能：
- en: '![](img/23375dec-001c-4064-9278-19da5d745827.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23375dec-001c-4064-9278-19da5d745827.png)'
- en: This was not the most impressive of console applications, but it served to illustrated
    many principles and patterns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是最令人印象深刻的控制台应用程序，但它用来说明了许多原则和模式。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Similar to [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns – Basics Part 1, *this chapter continued the description of building
    an inventory management console application for FlixOne, in order to show practical
    examples of using **Object-Oriented Programming** (**OOP**) design patterns. In
    this chapter,the GoF's singleton and factory patterns were the focus. These two
    patterns have a particularly important role to play in .NET Core applications
    and will be used often in the following chapters. An introduction to using the
    built-in framework to provide an IoC container was also covered in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)类似，*实现设计模式-基础部分1*，本章继续描述了为FlixOne构建库存管理控制台应用程序，以展示使用面向对象编程（OOP）设计模式的实际示例。在本章中，GoF的单例模式和工厂模式是重点。这两种模式在.NET
    Core应用程序中起着特别重要的作用，并将在接下来的章节中经常使用。本章还介绍了使用内置框架提供IoC容器的方法。
- en: This chapter finished with a working inventory management console application
    based on the requirements determined in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns – Basics Part 1*. These requirements were the basis
    of the unit tests created in both chapters and were used to illustrate TDD. The
    team has a higher level of confidence that the application will pass the **User
    Acceptance Testing** (**UAT**) by having a suite of tests that verify the features
    required for this phase of development.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以一个符合[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml) *实现设计模式-基础部分1*中确定的要求的工作库存管理控制台应用程序结束。这些要求是两章中创建的单元测试的基础，并用于说明TDD。通过拥有一套验证本开发阶段所需功能的测试，团队对应用程序能够通过用户验收测试（UAT）有更高的信心。
- en: In the next chapter, we will continue with the description of building the inventory
    management application. The focus will move from basic OOP patterns to using the
    .NET Core framework to implement different patterns. For example, the singleton
    pattern introduced in this chapter will be refactored to use the capability of
    `IServiceCollection` to create a singleton, and we will also take a closer look
    at its DI capabilities. Additionally, the application will be extended to support
    logging using a variety of logging providers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续描述构建库存管理应用程序。重点将从基本的面向对象编程模式转移到使用.NET Core框架来实现不同的模式。例如，本章介绍的单例模式将被重构以利用`IServiceCollection`的能力来创建单例，我们还将更仔细地研究其依赖注入能力。此外，该应用程序将扩展以支持使用各种日志提供程序进行日志记录。
- en: Questions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: Provide an example why using a singleton **would not** be a good mechanism for
    limiting access to a shared resource.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个例子，说明为什么使用单例模式不是限制访问共享资源的好机制。
- en: Is the following statement true? Why or why not? `ConcurrentDictionary` prevents
    items in the collection from being updated by more than one thread at a time.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下陈述是否正确？为什么？`ConcurrentDictionary`可以防止集合中的项目被多个线程同时更新。
- en: What is a race condition and why should it be avoided?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞态条件，为什么应该避免？
- en: How does the factory pattern help to simplify code?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式如何帮助简化代码？
- en: Do .NET Core applications require third-party IoC containers?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core应用程序需要第三方IoC容器吗？
