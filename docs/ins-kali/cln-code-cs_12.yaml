- en: Using Tools to Improve Code Quality
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具来提高代码质量
- en: As a programmer, enhancing code quality is one of your chief concerns. Improving
    the quality of your code demands the utilization of various tools. Tools designed
    to improve your code and also speed up development include **code metrics**, **quick
    actions**, the **JetBrains dotTrace** profiler, **JetBrains ReSharper**, and **Telerik
    JustDecompile**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，提高代码质量是您的主要关注点之一。提高代码质量需要利用各种工具。旨在改进代码并加快开发速度的工具包括代码度量衡、快速操作、JetBrains
    dotTrace分析器、JetBrains ReSharper和Telerik JustDecompile。
- en: 'This is the main thing that we''ll be doing in this chapter, with the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的主要内容，包括以下主题：
- en: Defining good-quality code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义高质量的代码
- en: Performing code cleanup and calculating code metrics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码清理和计算代码度量衡
- en: Performing code analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行代码分析
- en: Using quick actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速操作
- en: Using the JetBrains dotTrace profiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JetBrains dotTrace分析器
- en: Using JetBrains ReSharper
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JetBrains ReSharper
- en: Using Telerik JustDecompile
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Telerik JustDecompile
- en: 'By the end of this chapter, you will have gained the following skills:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将掌握以下技能：
- en: Using code metrics to measure software complexity and maintainability
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码度量衡来衡量软件复杂性和可维护性
- en: Using quick actions to make changes using a single command
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速操作进行更改
- en: Profiling your code and analyzing bottlenecks with JetBrains dotTrace
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JetBrains dotTrace对代码进行分析和瓶颈分析
- en: Refactoring code using JetBrains ReSharper
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JetBrains ReSharper重构代码
- en: Decompiling code and generating a solution using Telerik JustDecompile
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Telerik JustDecompile对代码进行反编译和生成解决方案
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this book: [https://github.com/PacktPublishing/Clean-Code-in-C-](https://github.com/PacktPublishing/Clean-Code-in-C-)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的源代码：[https://github.com/PacktPublishing/Clean-Code-in-C-](https://github.com/PacktPublishing/Clean-Code-in-C-)
- en: Visual Studio 2019 Community Edition or higher: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019社区版或更高版本：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
- en: Telerik JustDecompile: [https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Telerik JustDecompile：[https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx)
- en: JetBrains ReSharper Ultimate: [https://www.jetbrains.com/resharper/download/#section=resharper-installer](https://www.jetbrains.com/resharper/download/#section=resharper-installer)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains ReSharper Ultimate：[https://www.jetbrains.com/resharper/download/#section=resharper-installer](https://www.jetbrains.com/resharper/download/#section=resharper-installer)
- en: Defining good-quality code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义高质量的代码
- en: Good code quality is an essential software property. Financial loss, wasted
    time and effort, and even death can result from poor-quality code. High-standard
    code will have the qualities of **Performance, Availability, Security, Scalability,
    Maintainability, Accessibility, Deployability, and Extensibility** (**PASSMADE**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码质量是一种重要的软件属性。低质量的代码可能导致财务损失、时间和精力浪费，甚至死亡。高标准的代码将具有性能、可用性、安全性、可扩展性、可维护性、可访问性、可部署性和可扩展性（PASSMADE）的特质。
- en: Performant code is small, only does what it needs to do, and is very fast. Performant
    code will not grind a system to a halt. Things that grind a system to a halt are
    file **input/output** (**I/O**) operations, memory usage, and **central processing
    unit** (**CPU**) usage. Low-performing code is a candidate for refactoring.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能的代码体积小，只做必要的事情，并且非常快。高性能的代码不会导致系统崩溃。导致系统崩溃的因素包括文件输入/输出（I/O）操作、内存使用和中央处理单元（CPU）使用。性能低下的代码适合重构。
- en: Availability refers to the software being continually available at the required
    level of performance. Availability is the ratio between the **time the software
    is functional** (**tsf**) to the **total time it is expected to function** (**ttef**)—for
    example, tsf=700; ttef =744\. 700 / 744 = 0.9409 = 94.09% availability.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性指的是软件在所需性能水平上持续可用。可用性是软件功能时间（tsf）与预期功能总时间（ttef）之比，例如，tsf=700；ttef=744。700
    / 744 = 0.9409 = 94.09%的可用性。
- en: Secure code is the code that properly validates input to protect against invalid
    data formats, an invalid range data, and malicious attacks and that fully authenticates
    and authorizes its users. Secure code is also code that is fault-tolerant. For
    example, if you are halfway through transferring money from one account to another
    and the system crashes, the operation should ensure the data remains intact, with
    no money taken from the account in question.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的代码是指正确验证输入以防止无效数据格式、无效范围数据和恶意攻击，并完全验证和授权其用户的代码。安全的代码也是容错的代码。例如，如果正在从一个账户转账到另一个账户，系统崩溃了，操作应确保数据保持完整，不会从相关账户中取走任何钱。
- en: Scalable code is code that can safely handle exponential growth in the number
    of users using the system without the system grinding to a halt. So, whether the
    software handles one request per hour or a million requests per hour, there is
    no degradation in the performance of the code and no downtime due to excessive
    load.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的代码是指能够安全处理系统用户数量呈指数增长，而不会导致系统崩溃的代码。因此，无论软件每小时处理一个请求还是一百万个请求，代码的性能都不会下降，也不会因过载而导致停机。
- en: Maintainability refers to how easy it is to fix bugs and add new functionality.
    Maintainable code should be well organized and easy to read. There should be low
    coupling and high cohesion so that the code can be easily maintained and extended.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性指的是修复错误和添加新功能的难易程度。可维护的代码应该组织良好，易于阅读。应该低耦合，高内聚，以便代码可以轻松维护和扩展。
- en: Accessible code is code that people with limited abilities find easy to modify
    and use according to their needs. Examples include user interfaces with high contrast,
    a narrator for dyslexic and blind people, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问的代码是指残障人士可以轻松修改和根据自己的需求使用的代码。例如，具有高对比度的用户界面，为诵读困难和盲人提供的叙述者等。
- en: Deployability focuses on the users of the software—will the users be standalone,
    remote access, or local network users? Whatever type the user is, the software
    should be very easy to deploy without any issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可部署性关注软件的用户——用户是独立的、远程访问的还是本地网络用户？无论用户类型如何，软件都应该非常容易部署，没有任何问题。
- en: Extensibility refers to how easy it is to extend an application by adding new
    features to it. Spaghetti code and highly coupled code with low cohesion make
    this very difficult and error-prone. Such code can be very hard to read and maintain
    and is not easy to extend. Therefore, extensible code is code that is easy to
    read, easy to maintain, and—thus—easy to add new features to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性指的是通过向应用程序添加新功能来扩展应用程序的容易程度。意大利面代码和高度耦合的代码与低内聚度使这变得非常困难且容易出错。这样的代码很难阅读和维护，也不容易扩展。因此，可扩展的代码是易于阅读、易于维护的代码，因此也易于添加新功能。
- en: From the PASSMADE requirements of good-quality code, you can easily infer the
    kinds of problems that could arise from failing to meet these requirements. Failure
    to meet these requirements would lead to poor-performing code that becomes frustrating
    and unusable. Clients would be annoyed by increased downtime. Hackers would be
    able to exploit vulnerabilities in code that is not secure. The software would
    degrade exponentially as more users are added to the system. Code would be hard
    to fix or extend, and in some cases impossible to fix or extend. Users with limited
    abilities would not be able to modify the software around their limitations, and
    deployment would be a configuration nightmare.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从优质代码的PASSMADE要求中，您可以轻松推断出未能满足这些要求可能导致的问题。未能满足这些要求将导致性能不佳的代码变得令人沮丧和无法使用。客户会因增加的停机时间而感到恼火。黑客可以利用不安全的代码中的漏洞。随着更多用户加入系统，软件会呈指数级下降。代码将难以修复或扩展，在某些情况下甚至无法修复或扩展。能力有限的用户将无法修改其限制周围的软件，并且部署将成为配置噩梦。
- en: Code metrics to the rescue. Code metrics enable developers to measure code complexity
    and maintainability and thus help us to identify code that is a candidate for
    refactoring.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码度量来拯救。代码度量使开发人员能够衡量代码复杂性和可维护性，从而帮助我们识别需要重构的代码。
- en: With Quick Actions, you can use a single command to refactor C# code, such as
    extracting code out into its own method. JetBrains dotTrace allows you to profile
    your code and find performance bottlenecks. Further, JetBrains ReSharper is a
    Visual Studio productivity extension that enables you to analyze code quality
    and detect code smells, enforce coding standards, and refactor code. And Telerik
    JustDecompile helps you to decompile existing code for troubleshooting, and to
    create **Intermediate Language** (**IL**), C#, and VB.NET projects from. This
    is particularly useful if you no longer have the source code and need to maintain
    or extend the compiled code. You can even generate debug symbols for the compiled
    code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速操作，您可以使用单个命令重构C#代码，例如将代码提取到自己的方法中。JetBrains dotTrace允许您分析代码并找到性能瓶颈。此外，JetBrains
    ReSharper是Visual Studio的生产力扩展，使您能够分析代码质量、检测代码异味、强制执行编码标准并重构代码。而Telerik JustDecompile则帮助您反编译现有代码进行故障排除，并从中创建中间语言（IL）、C#和VB.NET项目。如果您不再拥有源代码并且需要维护或扩展已编译的代码，这将非常有用。您甚至可以为编译后的代码生成调试符号。
- en: Let's take a deeper look at the tools mentioned, starting with code metrics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下提到的工具，首先是代码度量。
- en: Performing code cleanup and calculating code metrics
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行代码清理和计算代码度量
- en: Before we look at how to gather code metrics, we first need to know what they
    are and why they are useful to us. **Code metrics** are mainly concerned with
    software complexity and maintainability. They help us to see how we can improve
    the maintainability of our source code and reduce source code complexity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看如何收集代码度量之前，我们首先需要知道它们是什么，以及它们对我们有何用处。代码度量主要涉及软件复杂性和可维护性。它们帮助我们看到如何改进源代码的可维护性并减少源代码的复杂性。
- en: 'The code metrics that Visual Studio 2019 calculates for you consist of the
    following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2019为您计算的代码度量包括以下内容：
- en: '**Maintainability index**: Code maintainability is an essential component of **Application
    Lifecycle Management** (**ALM**). Until software reaches its end of life, it must
    be maintained. The harder the code base is to maintain, the shorter the lifespan
    of the source code before a complete replacement is required. Writing new software
    to replace an ailing system is far more work and is more expensive when compared
    to maintaining an existing system. The measurement for code maintainability is
    known as the maintainability index. This value is an integer value between 0 and
    100\. Here are the maintainability index ratings, their colors, and their meanings:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性指数：代码可维护性是“应用生命周期管理”（ALM）的重要组成部分。在软件达到寿命终点之前，必须对其进行维护。代码基础越难以维护，源代码在完全替换之前的寿命就越短。与维护现有系统相比，编写新软件以替换不健康的系统需要更多的工作，也更昂贵。代码可维护性的度量称为可维护性指数。该值是0到100之间的整数值。以下是可维护性指数的评级、颜色和含义：
- en: Any value from *20 and above* has a *green* rating for good maintainability.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20及以上的任何值都具有良好可维护性的绿色评级。
- en: Moderately maintainable code is *between 10 and 19*, with a *yellow* rating.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性一般的代码在10到19之间，评级为黄色。
- en: Anything *below 10* has a rating of *red*, meaning that it is hard to maintain.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何低于10的值都具有红色评级，意味着它很难维护。
- en: '**Cyclomatic complexity**: Code complexity, also known as cyclomatic complexity,
    refers to the various code paths through the software. The more paths there are,
    the more complex the software is. And the more complex the software is, the harder
    it is to test and maintain. Complex code can lead to more error-prone software
    releases and can make it hard to maintain and extend the software. Hence, it is
    advisable that code complexity should be kept to a minimum.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度：代码复杂度，也称为圈复杂度，指的是软件中的各种代码路径。路径越多，软件就越复杂。软件越复杂，测试和维护就越困难。复杂的代码可能导致更容易出错的软件发布，并且可能使软件的维护和扩展变得困难。因此，建议将代码复杂度保持在最低限度。
- en: '**Depth of Inheritance**: The Depth of Inheritance and class coupling metrics
    are affected by the popular programming paradigm called **Object-Oriented Programming** (**OOP**).
    With OOP, classes are able to inherit from other classes. A class that is inherited
    from is known as a base class. Classes that inherit from a base class are known
    as subclasses. The metric for the number of classes that inherit from each other
    is known as the Depth of Inheritance.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承深度：继承深度和类耦合度受到了一种流行的编程范式的影响，称为面向对象编程（OOP）。在OOP中，类能够从其他类继承。被继承的类称为基类。从基类继承的类称为子类。每个类相互继承的数量度量被称为继承深度。
- en: The deeper the level of inheritance, the more chance you have of errors in derived
    classes if something is changed in one of the base classes. The ideal Depth of
    Inheritance is 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次越深，如果基类中的某些内容发生变化，派生类中出现错误的可能性就越大。理想的继承深度是1。
- en: '**Class coupling**: OOP allows class coupling. Class coupling arises when a
    class is directly referenced by a parameter, a local variable, a return type,
    a method call, a generic or template instantiation, base classes, interface implementations,
    fields defined on extra types, and an attribute decoration.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类耦合：面向对象编程允许类耦合。当一个类被参数、局部变量、返回类型、方法调用、泛型或模板实例化、基类、接口实现、在额外类型上定义的字段和属性装饰直接引用时，就会产生类耦合。
- en: The class coupling code metric determines the level of coupling between classes.
    To make code easier to maintain and extend, class coupling should be kept to an
    absolute minimum. In OOP, one way to achieve this is to use interface-based programming.
    This way, you avoid directly accessing a class. The benefit of this method of
    programming is that you can swap classes in and out, as long as they implement
    the same interface. Poor-quality code has high coupling and low cohesion, but
    good-quality code has low coupling and high cohesion.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类耦合代码度量确定了类之间的耦合程度。为了使代码更易于维护和扩展，类耦合应该尽量减少。在面向对象编程中，实现这一点的一种方法是使用基于接口的编程。这样，您可以避免直接访问类。这种编程方法的好处是，只要它们实现相同的接口，您就可以随意替换类。质量低劣的代码具有高耦合和低内聚，而高质量的代码具有低耦合和高内聚。
- en: Ideally, software should be highly cohesive with low coupling, because it makes
    programs easier to test, maintain, and extend.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，软件应该具有高内聚性和低耦合性，因为这样可以使程序更容易测试、维护和扩展。
- en: '**Lines of source code**: The complete count of the lines of your source code,
    including blank lines, is measured by the lines of source code metric.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码行数：源代码的完整行数，包括空行，由源代码行数度量。
- en: '**Lines of executable code**: The measure of operations in executable code
    is measured by the lines of executable code metric.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行代码行数：可执行代码中的操作数量由可执行代码行数度量。
- en: 'Now that you have a heads-up on what code metrics are and which measurements
    are available in Visual Studio 2019 version 16.4 onward, it''s time to see them
    in action, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了代码度量是什么，以及Visual Studio 2019版本16.4及更高版本中提供了哪些度量，现在是时候看到它们的实际效果了：
- en: Open any project you like within Visual Studio.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开任何您喜欢的项目。
- en: Right-click on the project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目。
- en: 'Select Analyze and Code Cleanup | **Run** Code Cleanup (Profile 1), as illustrated
    in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择分析和代码清理|运行代码清理（Profile 1），如下截图所示：
- en: '![](img/3084d347-1840-4623-b317-93e84e4a3333.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3084d347-1840-4623-b317-93e84e4a3333.png)'
- en: Now, select Calculate Code Metrics.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择计算代码度量。
- en: 'You should see the Code Metrics Results window appear, as shown in the following
    screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到代码度量结果窗口出现，如下截图所示：
- en: '![](img/0072829c-42dd-4d15-bdb7-62df99180ec1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0072829c-42dd-4d15-bdb7-62df99180ec1.png)'
- en: As you can see from the screenshot, all our classes, interfaces, and methods
    are marked with a *green* indicator. This means that the selected project is one
    that is maintainable. If any of these lines were marked yellow or red, then you
    would need to address them and refactor them to make them green. Well, we've covered
    code metrics, and so, naturally, we move on to cover code analysis.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，我们所有的类、接口和方法都标有绿色指示器。这意味着所选的项目是可维护的。如果其中任何一行标记为黄色或红色，那么您需要解决它们并重构它们以使其变为绿色。好了，我们已经介绍了代码度量，因此自然而然地，我们继续介绍代码分析。
- en: Performing code analysis
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行代码分析
- en: To help developers identify potential problems with their source code, Microsoft
    provides the Code Analysis tool as part of Visual Studio. Code Analysis performs
    a static source code analysis. The tool will identify design flaws, issues with
    globalization, security problems, issues with performance, and interoperability
    problems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发人员识别其源代码的潜在问题，微软提供了Visual Studio的代码分析工具。代码分析执行静态源代码分析。该工具将识别设计缺陷、全球化问题、安全问题、性能问题和互操作性问题。
- en: 'Open the book solution, and select the CH11_AddressingCrossCuttingConcerns
    project. Then, from the Project menu, select Project | CH11_AddressingCrossCuttingConcerns | Properties
    from the menu. On the properties page for the project, select Code Analysis, as
    illustrated in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 打开书中的解决方案，并选择CH11_AddressingCrossCuttingConcerns项目。然后，从项目菜单中选择项目|CH11_AddressingCrossCuttingConcerns
    |属性。在项目的属性页面上，选择代码分析，如下截图所示：
- en: '![](img/845a8cb0-51c3-4c8c-86aa-227357896190.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/845a8cb0-51c3-4c8c-86aa-227357896190.png)'
- en: 'As shown in the preceding screenshot, if you see that the recommended analyzer
    package is not installed, click on Install to install it. Once installed, the
    version number will be displayed in the installed version box. For me, it is version
    2.9.6\. By default, the active rules are Microsoft Managed Recommended Rules.
    The location of this ruleset, as shown in the description, is C:\Program Files
    (x86)\Microsoft Visual Studio\2019\Professional\Team Tools\Static Analysis Tools\Rule
    Sets\MinimumRecommendedRules.ruleset. Open the file. It will open as a Visual
    Studio tool window, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的截图所示，如果您发现推荐的分析器包未安装，请单击“安装”进行安装。安装后，版本号将显示在已安装版本框中。对我来说，它是版本2.9.6。默认情况下，活动规则是Microsoft托管推荐规则。如描述中所示，此规则集的位置是C:\Program
    Files (x86)\Microsoft Visual Studio\2019\Professional\Team Tools\Static Analysis
    Tools\Rule Sets\MinimumRecommendedRules.ruleset。打开文件。它将作为Visual Studio工具窗口打开，如下所示：
- en: '![](img/6e77dab0-0c68-4f3b-9cb3-e2c4c151e744.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e77dab0-0c68-4f3b-9cb3-e2c4c151e744.png)'
- en: As you can see in the preceding screenshot, you can select and deselect rules.
    When you close the window, you will be prompted to save any changes. To run a
    code analysis, go to Analyze and Code Cleanup | Code Analysis. In order to view
    the results, you will need the Error List window to be open. You can open it from
    the View menu.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的截图所示，您可以选择和取消选择规则。关闭窗口时，将提示您保存任何更改。要运行代码分析，转到分析和代码清理|代码分析。要查看结果，需要打开错误列表窗口。您可以从“视图”菜单中打开它。
- en: 'Once you have run the code analysis, you will see a list of errors, warnings,
    and messages. You can address each and every one of them to improve the overall
    quality of your software. A sample of these can be seen in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了代码分析，您将看到错误、警告和消息的列表。您可以处理每一个，以提高软件的整体质量。以下截图显示了其中一些示例：
- en: '![](img/ce41fac1-0f57-4161-bdce-80454882fa47.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce41fac1-0f57-4161-bdce-80454882fa47.png)'
- en: From the preceding screenshot, you can see that the `CH10_AddressingCrossCuttingConcerns`
    project has *32 warnings and 13 messages*. If we were to work on the warnings
    and messages, we would get them down to 0 messages and 0 warnings. So, now that
    you have seen how to use code metrics to see how maintainable your software is
    and you've analyzed it to see what improvements you can make, it's now time to
    look at quick actions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中，您可以看到`CH10_AddressingCrossCuttingConcerns`项目有*32个警告和13个消息*。如果我们处理这些警告和消息，就可以将它们减少到0个消息和0个警告。因此，现在您已经知道如何使用代码度量来查看软件的可维护性，并对其进行分析以了解您可以做出哪些改进，现在是时候看看快速操作了。
- en: Using quick actions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用快速操作
- en: Another handy tool that I like to use is the Quick Action tool. Appearing as
    a screwdriver ![](img/879fde26-23f4-46ce-a945-b990c87ea7b2.png), a lightbulb ![](img/e1db92fb-dc9b-4b31-8ab6-869d769ee72d.png),
    or an error light bulb ![](img/006b25b8-4e48-4dbb-9c13-708d087aa336.png) on a
    line of code, quick actions enable you to use a single command that will generate
    code, refactor code, suppress warnings, perform code fixes, and add `using` statements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我喜欢使用的方便工具是快速操作工具。在代码行上显示为螺丝刀![](img/879fde26-23f4-46ce-a945-b990c87ea7b2.png)，灯泡![](img/e1db92fb-dc9b-4b31-8ab6-869d769ee72d.png)，或错误灯泡![](img/006b25b8-4e48-4dbb-9c13-708d087aa336.png)，快速操作使您能够使用单个命令生成代码，重构代码，抑制警告，执行代码修复，并添加`using`语句。
- en: 'Since the `CH10_AddressingCrossCuttingConcerns` project had 32 warnings and
    13 messages, we can use this project to see the quick actions in action. Have
    a look at the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CH10_AddressingCrossCuttingConcerns`项目有32个警告和13个消息，我们可以使用该项目来查看快速操作的效果。看看下面的截图：
- en: '![](img/edbf7964-0014-4776-bd6c-5f535045eb67.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edbf7964-0014-4776-bd6c-5f535045eb67.png)'
- en: 'Looking at the preceding screenshot, we see the lightbulb on line 10\. If we
    click on the lightbulb, the following menu pops up:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看看上面的截图，我们看到第10行的灯泡。如果我们点击灯泡，将弹出以下菜单：
- en: '![](img/022c0406-d6cc-41eb-abaf-27bd8f8fe633.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/022c0406-d6cc-41eb-abaf-27bd8f8fe633.png)'
- en: If we click on Add readonly modifier, the `readonly` access modifier is placed
    after the private access modifier. Have a go yourself at using quick actions to
    modify the code. It is fairly straightforward once you get the hang of it. Once
    you have had a play around with quick actions, move on to look at the JetBrains
    dotTrace profiling tool.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击“添加readonly修饰符”，`readonly`访问修饰符将放置在私有访问修饰符之后。尝试使用快速操作修改代码。一旦掌握了，这是相当简单的。一旦您尝试了快速操作，就可以继续查看JetBrains
    dotTrace分析工具。
- en: Using the JetBrains dotTrace profiler
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JetBrains dotTrace分析工具
- en: The JetBrains dotTrace profiler is a part of JetBrains ReSharper Ultimate license.
    Since we will be looking at both tools, I recommend that you download and install
    JetBrains ReSharper Ultimate before we continue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains dotTrace分析工具是JetBrains ReSharper Ultimate许可的一部分。因为我们将同时查看这两个工具，我建议您在继续之前下载并安装JetBrains
    ReSharper Ultimate。
- en: JetBrains does have a trial version available if you don't already own a copy.
    There are versions available for Windows, macOS, and Linux.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有拥有副本，JetBrains确实有试用版本可用。Windows、macOS和Linux都有可用的版本。
- en: The JetBrains dotTrace profiling tool works with Mono, .NET Framework, and .NET
    Core. All application types are supported by the profiler, and you can use the
    profiler to analyze and track down performance issues with your code base. The
    profiler will help you to get to the bottom of such problems that cause 100% CPU
    usage, 100% of the disk I/O, maxing out the memory or running into overflow exception,
    and many other issues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains dotTrace分析工具适用于Mono、.NET Framework和.NET Core。分析工具支持所有应用程序类型，您可以使用分析工具分析和跟踪代码库的性能问题。分析工具将帮助您解决导致CPU使用率达到100%、磁盘I/O达到100%、内存达到最大或遇到溢出异常等问题。
- en: Many applications perform **HyperText Transfer Protocol** (**HTTP**) requests.
    The profiler will analyze how the application is processing these requests, and
    it will also do the same with **Structured Query Language** (**SQL**) queries
    on a database. Static methods and unit tests can be profiled, and you can view
    the results from within Visual Studio. There is also a standalone version that
    you can use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序执行超文本传输协议（HTTP）请求。性能分析器将分析应用程序如何处理这些请求，并对数据库上的结构化查询语言（SQL）查询进行相同的分析。还可以对静态方法和单元测试进行性能分析，并可以在Visual
    Studio中查看结果。还有一个独立版本供您使用。
- en: There are four basic profiling options—Sampling, Tracing, Line-by-Line, and
    Timeline. The first time you start looking at the performance of an application,
    you may decide to use Sampling, which provides an accurate measurement of call
    time. Tracing and Line-by-Line offer more detailed profiling, but they do add
    more overhead (memory and CPU usage) to the program being profiled. Timeline is
    similar to sampling and collects application events over time. Between them, there
    is no problem that can't be tracked down and resolved.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种基本的性能分析选项——Sampling、Tracing、Line-by-Line和Timeline。第一次开始查看应用程序的性能时，您可能决定使用Sampling，它提供了准确的调用时间测量。Tracing和Line-by-Line提供了更详细的性能分析，但会给被分析的程序增加更多开销（内存和CPU使用）。Timeline类似于Sampling，并会随时间收集应用程序事件。在它们之间，没有无法追踪和解决的问题。
- en: Advanced profiling options include real-time performance counters, thread time,
    real-time CPU instructions, and thread cycle time. The real-time performance counters
    measure the time between method entry and exit. Thread time measures the thread
    running time. Based on the CPU register, the real-time CPU instructions provide
    an accurate time of method entry and exit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 高级性能分析选项包括实时性能计数器、线程时间、实时CPU指令和线程周期时间。实时性能计数器测量方法进入和退出之间的时间。线程时间测量线程运行时间。基于CPU寄存器，实时CPU指令提供了方法进入和退出的准确时间。
- en: The profiler can attach to running .NET Framework 4.0 (or later) or .NET Core
    3.0 (or later) applications and processes, profile local applications, and profile
    remote applications. These include standalone applications; .NET Core applications; **Internet
    Information Services** (**IIS**)-hosted web applications; IIS Express-hosted applications;
    .NET Windows Services, **Windows Communication Foundation** (**WCF**) services; Windows
    Store and **Universal Windows Platform** (**UWP**) applications; any .NET processes
    (started after you run the profiling session); desktop or console applications
    based on Mono; and Unity editor or standalone Unity applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器可以附加到正在运行的.NET Framework 4.0（或更高版本）或.NET Core 3.0（或更高版本）应用程序和进程，对本地应用程序和远程应用程序进行性能分析。这些包括独立应用程序；.NET
    Core应用程序；Internet信息服务（IIS）托管的Web应用程序；IIS Express托管的应用程序；.NET Windows服务；Windows通信基础（WCF）服务；Windows商店和通用Windows平台（UWP）应用程序；任何.NET进程（在运行性能分析会话后启动）；基于Mono的桌面或控制台应用程序；以及Unity编辑器或独立的Unity应用程序。
- en: 'To access the profiler in Visual Studio 2019 from the menu, select Extensions
    | ReSharper | Profile | Show Performance Profiler. In the following screenshot,
    you can see that nothing has been profiled yet. Also, the currently selected project
    to be profiled is set to Basic CH3, and the profiling type is set to Timeline.
    We will profile CH3 using Sampling to profile our project by expanding the Timeline
    drop-down functionality and selecting Sampling, as illustrated in the following
    screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio 2019中从菜单中访问性能分析器，请选择Extensions | ReSharper | Profile | Show
    Performance Profiler。在下面的截图中，您可以看到尚未进行性能分析。当前选择要进行性能分析的项目设置为Basic CH3，并且性能分析类型设置为Timeline。我们将使用Sampling对CH3进行性能分析，通过展开时间轴下拉功能并选择Sampling，如下面的截图所示：
- en: '![](img/8647fbeb-0249-480f-b79c-7d4c03df2f1d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8647fbeb-0249-480f-b79c-7d4c03df2f1d.png)'
- en: 'If you want to sample a different project, just expand the Project drop-down list
    and select the project that you want to profile. The project will be built, and
    the profiler started. Your project will then run and be shut down. The results
    will then be displayed in the dotTrace profiling application, as shown in the
    following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要对不同的项目进行采样，请展开项目下拉列表并选择要进行性能分析的项目。项目将被构建，并启动性能分析器。然后您的项目将运行并关闭。结果将显示在dotTrace性能分析应用程序中，如下面的截图所示：
- en: '![](img/38f49eb2-a59e-4ae7-a6cb-90c767ffd1e4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38f49eb2-a59e-4ae7-a6cb-90c767ffd1e4.png)'
- en: From the preceding screenshot, you can see that the first of four threads are
    being shown. This is the thread for our program. The other threads are for the
    supporting processes that enable our program to run along with the finalizer thread
    that is responsible for exiting the program and cleaning up system resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中，您可以看到四个线程中的第一个线程。这是我们程序的线程。其他线程是支持进程的线程，这些支持进程使我们的程序能够运行，还有负责退出程序并清理系统资源的finalizer线程。
- en: 'The All Calls menu items down the left-hand side comprise the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的所有调用菜单项包括以下内容：
- en: Thread Tree
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程树
- en: Call Tree
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用树
- en: Plain List
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通列表
- en: Hot Spots
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热点
- en: 'The current option selected the Thread Tree. Let''s have a look at the expanded
    Call Tree in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选项选择了线程树。让我们来看看下面截图中展开的调用树：
- en: '![](img/97e6fb4a-a0e3-435d-a26d-d78c0396b512.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97e6fb4a-a0e3-435d-a26d-d78c0396b512.png)'
- en: The profiler shows you the complete Call Tree for your code, and that includes
    system code as well as your own code. You can see the percentage of time spent
    on making the call. This allows you to identify any long-running methods and address
    them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器为您的代码显示完整的调用树，包括系统代码和您自己的代码。您可以看到调用所花费的时间百分比。这使您能够识别任何运行时间较长的方法并加以解决。
- en: 'Now, we''ll look at the Plain List. As you can see with the Plain List view
    in the screenshot that follows, we can group it according to the following criteria:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看普通列表。如下面截图中的普通列表视图所示，我们可以根据以下标准对其进行分组：
- en: None
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: Class
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Namespace
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Assembly
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集
- en: 'You can see the preceding criteria in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下面的屏幕截图中看到前面的标准：
- en: '![](img/5cb7c40f-d8ac-4ced-9ae4-e0ddb8135d41.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cb7c40f-d8ac-4ced-9ae4-e0ddb8135d41.png)'
- en: 'When you click on an item in the list, you get to view the source code for
    the class where the method resides. This is useful, as you can see the code where
    the problem lies and what needs to be done. The last sampling profile screen we''ll
    look at is the Hot Spots view, illustrated in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击列表中的项目时，您可以查看包含该方法的类的源代码。这很有用，因为您可以看到问题所在的代码以及需要做什么。我们将看到的最后一个采样配置文件屏幕是热点视图，如下面的屏幕截图所示：
- en: '![](img/e71a1ce2-79bd-485e-aedd-b7e3686de601.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e71a1ce2-79bd-485e-aedd-b7e3686de601.png)'
- en: 'The profiler is showing that the Main Thread, which is our code''s starting
    point, only takes 4.59% of the processing time. If you click on the root, 18%
    of the code is our user code, and 72% of the code is system code, as shown in
    the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器显示，主线程（我们代码的起点）只占用了4.59%的处理时间。如果您点击根，我们的用户代码占了18%的代码，系统代码占了72%的代码，如下面的屏幕截图所示：
- en: '![](img/bba028e6-5545-492f-9e35-34bf7eb90b1a.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bba028e6-5545-492f-9e35-34bf7eb90b1a.png)'
- en: We have only touched the surface with this profiling tool. There is more to
    it, and I encourage you to try it out for yourself. The main purpose of this chapter
    is to introduce you to the tools that are available to you.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是用这个性能分析工具触及到了表面。还有更多内容，我鼓励您自己尝试一下。本章的主要目的是向您介绍可用的工具。
- en: For further information on how to use JetBrains dotTrace, I refer you to their
    online learning materials, at [https://www.jetbrains.com/profiler/documentation/documentation.html](https://www.jetbrains.com/profiler/documentation/documentation.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用JetBrains dotTrace的更多信息，我建议您参考他们的在线学习材料，网址为[https://www.jetbrains.com/profiler/documentation/documentation.html](https://www.jetbrains.com/profiler/documentation/documentation.html)。
- en: Next up, we look at JetBrains ReSharper.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看JetBrains ReSharper。
- en: Using JetBrains ReSharper
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JetBrains ReSharper
- en: 'In this section, we look at how JetBrains ReSharper can help you improve your
    code. ReSharper is quite an extensive tool, and just as with the profiler, which
    is a part of the Ultimate edition of ReSharper, we will only be touching the surface,
    but you will hopefully come to an appreciation of what the tool is and what it
    can do for you to improve your Visual Studio coding experience. Here are a few
    benefits of using ReSharper:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看JetBrains ReSharper如何帮助您改进您的代码。 ReSharper是一个非常广泛的工具，就像性能分析器一样，它是ReSharper的旗舰版的一部分，我们只会触及到表面，但您希望能够欣赏到这个工具是什么，以及它如何帮助您改进您的Visual
    Studio编码体验。以下是使用ReSharper的一些好处：
- en: With ReSharper, you can perform an analysis of your code quality.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ReSharper，您可以对代码质量进行分析。
- en: It will provide options to improve your code, remove code smells, and fix coding
    problems.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将提供改进代码、消除代码异味和修复编码问题的选项。
- en: With the navigation system, you are able to completely traverse your solution
    and jump to any item of interest. You have many different helpers that include
    extended IntelliSense, code reorganization, and more.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导航系统，您可以完全遍历您的解决方案并跳转到任何感兴趣的项目。您有许多不同的辅助工具，包括扩展的智能感知、代码重组等。
- en: Refactoring benefits from ReSharper's offerings that can be localized or solution-wide.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReSharper的重构功能可以是局部的，也可以是整个解决方案的。
- en: You can also generate source code using ReSharper, such as base class and superclasses,
    and inline methods.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用ReSharper生成源代码，例如基类和超类，以及内联方法。
- en: Here, code can be cleaned up in keeping with your company's coding policies
    to get rid of unused imports and other unused code.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，可以根据公司的编码政策清理代码，以消除未使用的导入和其他未使用的代码。
- en: 'You can visit the ReSharper menu from the Visual Studio 2019 Extensions menu.
    When in the code editor, right-clicking the mouse on a piece of code will bring
    up a context menu with the appropriate menu items. The ReSharper menu item in
    the context menu is Refactor This..., as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Visual Studio 2019扩展菜单中访问ReSharper菜单。在代码编辑器中，右键单击代码片段将显示上下文菜单，其中包含适当的菜单项。上下文菜单中的ReSharper菜单项是Refactor
    This...，如下面的屏幕截图所示：
- en: '![](img/62d9b26f-b6e6-45f3-8575-106fddc2b60e.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62d9b26f-b6e6-45f3-8575-106fddc2b60e.png)'
- en: 'Now, from the Visual Studio 2019 menu, run Extensions | ReSharper | Inspect
    | Code Issues in Solution. ReSharper will process the solution and then display
    the Inspection Results window, as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从Visual Studio 2019菜单中运行扩展 | ReSharper | 检查 | 解决方案中的代码问题。 ReSharper将处理解决方案，然后显示检查结果窗口，如下面的屏幕截图所示：
- en: '![](img/884a6f64-3229-4167-9489-7634b96632d4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/884a6f64-3229-4167-9489-7634b96632d4.png)'
- en: As you can see in the preceding screenshot, ReSharper found 527 issues with
    our code—436 of which are being displayed. These problems include common practices
    and code improvements, compiler warnings, constraint violations, language usage
    opportunities, potential code quality issues, redundancies in code, redundancies
    in symbol declarations, spelling issues, and syntax style.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，ReSharper发现了我们代码中的527个问题，其中436个正在显示。这些问题包括常见做法和代码改进、编译器警告、约束违规、语言使用机会、潜在的代码质量问题、代码冗余、符号声明冗余、拼写问题和语法风格。
- en: 'If we expand Compiler Warnings, we see that there are three problems, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开编译器警告，我们会看到有三个问题，如下所示：
- en: The `_name` field is never assigned.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_name`字段从未被赋值。'
- en: The `nre` local variable is never used.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nre`本地变量从未被使用。'
- en: This `async` method lacks `await` operators and will run synchronously. Use
    the `await` operator to await non-blocking **Application Programming Interface**
    (**API**) calls, or `await TaskEx.Run(...)` to do CPU-bound work on a background
    thread.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个`async`方法缺少`await`操作符，将以同步方式运行。使用`await`操作符等待非阻塞的**应用程序编程接口**（**API**）调用，或者使用`await
    TaskEx.Run(...)`在后台线程上执行CPU绑定的工作。
- en: 'These problems are variable declarations that don''t get assigned or used,
    and an `async` method lacking an `await` operator that will run synchronously.
    If you click on the first warning, it will take you to the line of code that is
    never assigned. Looking at the class, you can see that the string is declared
    and used, but it is never assigned. Since we check if the string contains `string.Empty`,
    we can assign that value to the declaration. Hence, the updated line will be as
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是声明的变量没有被赋值或使用，以及一个缺少`await`运算符的`async`方法将以同步方式运行。如果单击第一个警告，它将带您到从未分配的代码行。查看类，您会发现字符串已声明并使用，但从未分配。由于我们检查字符串是否包含`string.Empty`，我们可以将该值分配给声明。因此，更新后的行将如下所示：
- en: '[PRE0]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since the `_name` variable still highlights, we can hover over it and see what
    the problem is. The Quick Action informs us that the `_name` variable can be marked
    read-only. Let''s add the `readonly` modifier. So, the line now becomes this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_name`变量仍然突出显示，我们可以将鼠标悬停在上面，看看问题是什么。快速操作通知我们，`_name`变量可以标记为只读。让我们添加`readonly`修饰符。所以，现在这行变成了这样：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we click on the refresh ![](img/39fdfd96-ae8b-4036-a5f8-76f71c793546.png) button,
    we will find that the number of issues found is now 526\. Yet, we fixed two problems.
    So, should the number be 525? Well, no. The second problem that we fixed was not
    a problem picked up by ReSharper, but an improvement picked up by Visual Studio
    Quick Actions. So, ReSharper is showing the correct number of issues it has detected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单击刷新按钮![](img/39fdfd96-ae8b-4036-a5f8-76f71c793546.png)，我们将发现发现的问题数量现在是526。然而，我们解决了两个问题。所以，问题数量应该是525吗？好吧，不是。我们解决的第二个问题不是ReSharper检测到的问题，而是Visual
    Studio快速操作检测到的改进。因此，ReSharper显示了它检测到的正确问题数量。
- en: 'Let''s have a look at the potential code quality issue for the `LooseCouplingB`
    class. ReSharper reports a possible `System.NullReferenceException` within this
    method. Let''s look at the code first, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`LooseCouplingB`类的潜在代码质量问题。ReSharper报告了这个方法内可能的`System.NullReferenceException`。让我们先看看代码，如下所示：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And sure enough, we do have `System.NullReferenceException` staring us in the
    face. We''ll look at the `LooseCouplingA` class, to confirm which members should
    be set to `null`. Also, the member to be set is `_name`, as illustrated in the
    following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们面对着`System.NullReferenceException`。我们将查看`LooseCouplingA`类，以确认应将哪些成员设置为`null`。另外，要设置的成员是`_name`，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, `_name` is being checked for empty. And so, really, the code should
    be setting `_name` to `string.Empty`. So, our fixed constructor in `LooseCouplingB` becomes
    the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`_name`正在被检查是否为空。所以，实际上，代码应该将`_name`设置为`string.Empty`。因此，我们在`LooseCouplingB`中修复的构造函数如下：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if we refresh the Inspection Results window, our list of issues has gone
    down by five, because apart from correctly assigning the `Name` property, we made
    use of the language usage opportunity to simplify our instantiation and initialization,
    which was detected by ReSharper. Have a play around with the tool and eliminate
    the problems found in the Inspection Results window.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们刷新Inspection Results窗口，我们的问题列表将减少五个，因为除了正确分配`Name`属性之外，我们利用了语言使用机会来简化我们的实例化和初始化，这是由ReSharper检测到的。玩一下这个工具，消除检查结果窗口中发现的问题。
- en: 'ReSharper can also generate *dependency diagrams*. To generate a dependency
    diagram for our solution, select Extensions | ReSharper | Architecture | Show
    Project Dependency Diagram. This will display the project dependency diagram for
    our solution. The black container box called `CH06` is the namespace, and the
    gray/blue boxes prefixed with `CH06_` are projects, as illustrated in the following
    screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ReSharper还可以生成*依赖关系图*。要为我们的解决方案生成依赖关系图，请选择Extensions | ReSharper | Architecture
    | Show Project Dependency Diagram。这将显示我们解决方案的项目依赖关系图。称为`CH06`的黑色容器框是命名空间，以`CH06_`为前缀的灰色/蓝色框是项目，如下面的屏幕截图所示：
- en: '![](img/4dcecdbe-cc72-4c4b-b6ca-aeb80473c813.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dcecdbe-cc72-4c4b-b6ca-aeb80473c813.png)'
- en: As you can see from the project dependency diagram in the `CH06` namespace,
    there is a project dependency between `CH06_SpecFlow` and `CH06_SpecFlow.Implementation`.
    Similarly, you can also generate type dependency diagrams using ReSharper. Select
    Extensions | ReSharper | Architecture | Type Dependencies Diagram.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从`CH06`命名空间的项目依赖关系图中可以看出，`CH06_SpecFlow`和`CH06_SpecFlow.Implementation`之间存在项目依赖关系。同样，您还可以使用ReSharper生成类型依赖关系图。选择Extensions
    | ReSharper | Architecture | Type Dependencies Diagram。
- en: 'If we generate the diagram for `ConcreteClass` in the `CH10_AddressingCrossCuttingConcerns`
    project, then the diagram will be generated, but only the `ConcreteComponent`
    class will be initially displayed. Right-click the `ConcreteComponent` box on
    the diagram and select Add All Referenced Types. You will see the addition of
    the `ExceptionAttribute` class and the `IComponent` interface. Right-click on
    the `ExceptionAttribute` class and select Add All Referenced Types, and you end
    up with the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`CH10_AddressingCrossCuttingConcerns`项目中的`ConcreteClass`生成图表，那么图表将被生成，但只有`ConcreteComponent`类将被最初显示。右键单击图表上的`ConcreteComponent`框，然后选择Add
    All Referenced Types。您将看到`ExceptionAttribute`类和`IComponent`接口的添加。右键单击`ExceptionAttribute`类，然后选择Add
    All Referenced Types，您将得到以下结果：
- en: '![](img/ea8e50b2-0ab3-4b5c-8110-b7ed7648b6ee.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea8e50b2-0ab3-4b5c-8110-b7ed7648b6ee.png)'
- en: 'What''s really wonderful about this tool is that you can order the diagram
    elements by namespace. This can be really useful for massive solutions with multiple
    large projects and deep-nested namespaces. Though it''s good that we can right-click
    on code and go to the item declaration, you can''t beat visually seeing the lay
    of the land in terms of the project that you are working on, and that is why this
    tool can be really useful. Here is an example of a typed dependencies diagram
    organized by namespaces:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具真正美妙的地方在于你可以按命名空间对图表元素进行排序。对于有多个大型项目和深度嵌套命名空间的庞大解决方案来说，这真的非常有用。虽然我们可以右键单击代码并转到项目声明，但是以可视化的方式看到你正在工作的项目的情况是无可替代的，这就是为什么这个工具非常有用。以下是一个按命名空间组织的类型依赖关系图的示例：
- en: '![](img/99ae67ae-8f3b-437b-9112-a5cf9be0fae3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ae67ae-8f3b-437b-9112-a5cf9be0fae3.png)'
- en: Many a time, I could have really used a diagram such as this in my day-to-day
    work. This diagram is technical documentation that will help developers find their
    way around a complex solution. They will be able to see which namespaces are available
    and how everything is interlinked. This will empower developers with the correct
    knowledge as to where new classes, enums, and interfaces should be placed when
    performing new development, but also, they will know where to find objects if
    they are performing maintenance. This diagram is also good for finding duplicate
    namespaces, interfaces, and object names.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中，我真的经常需要这样的图表。这个图表是技术文档，将帮助开发人员了解复杂解决方案。他们将能够看到哪些命名空间是可用的，以及一切是如何相互关联的。这将使开发人员具备正确的知识，知道在进行新开发时应该把新类、枚举和接口放在哪里，但也知道在进行维护时应该在哪里找到对象。这个图表也很适合查找重复的命名空间、接口和对象名称。
- en: 'Let''s now look at coverage. Proceed as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看覆盖率。操作如下：
- en: Select Extensions | ReSharper | Cover | Cover Application.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择扩展 | ReSharper | 覆盖 | 覆盖应用程序。
- en: The Coverage Configuration dialog will be displayed, and the default selected
    option will be Standalone.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖配置对话框将被显示，并且默认选择的选项将是独立运行。
- en: Select your executable.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的可执行文件。
- en: You can select a .NET app from the `bin` folder.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从`bin`文件夹中选择一个.NET应用程序。
- en: 'The following screenshot shows the Coverage Configuration dialog:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了覆盖配置对话框：
- en: '![](img/3ad944a8-2edf-4546-8a32-e657aa46605f.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ad944a8-2edf-4546-8a32-e657aa46605f.png)'
- en: 'Click the Run button to start the application and collect profiling data. ReSharper
    will display the following dialog:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行按钮启动应用程序并收集分析数据。ReSharper将显示以下对话框：
- en: '![](img/351aa848-072c-4355-8d75-fb92db9e3815.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/351aa848-072c-4355-8d75-fb92db9e3815.png)'
- en: 'The application will then run. As the application is running, the coverage
    profiler will be collecting data. Our selected executable is a console application
    that displays the following data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将会运行。当应用程序运行时，覆盖分析器将会收集数据。我们选择的可执行文件是一个控制台应用程序，显示如下数据：
- en: '![](img/34e40597-803e-4918-bb75-59127613b600.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34e40597-803e-4918-bb75-59127613b600.png)'
- en: 'Click the console window, and then press any key to exit. The coverage dialog
    will disappear, and storage will then be initialized. Finally, the Coverage Results
    Browser window will be displayed, as shown here:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击控制台窗口，然后按任意键退出。覆盖对话框将消失，然后存储将被初始化。最后，覆盖结果浏览器窗口将显示，如下所示：
- en: '![](img/d6678fcf-fbbc-47b2-872c-d69eec9cdf46.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6678fcf-fbbc-47b2-872c-d69eec9cdf46.png)'
- en: This window contains really useful information. It provides a visual indicator
    of code that was not called, marked in red. The code that was executed is marked
    in green. Using this information, you can see if the code is dead code that can
    be removed, or was not executed due to the path taken through the system but is
    still required, or was commented out for testing purposes, or was simply not called
    because the developer forgot to add the call in the correct place or a condition
    check was wrong.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口包含了非常有用的信息。它提供了代码未被调用的视觉指示，用红色标记。执行的代码用绿色标记。使用这些信息，你可以看到代码是否是可以删除的死代码，或者由于系统路径而未被执行但仍然需要，或者由于测试目的而被注释掉，或者仅仅是因为开发人员忘记在正确的位置添加调用或者条件检查错误而未被调用。
- en: 'To go to the item of interest, you just have to double-click on the item, and
    then you will be taken to the specific code you are interested in. Our `Program`
    class only covers 33% of the code. So, let''s double-click `Program`, and see
    what''s the matter. The resulting output is shown in the following code block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要转到感兴趣的项目，你只需要双击该项目，然后你将被带到你感兴趣的具体代码。我们的`Program`类只覆盖了33%的代码。所以，让我们双击`Program`，看看问题出在哪里。结果输出如下代码块所示：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from the code, the reason why some of our code was not covered
    is because calls to the code were commented out for testing purposes. We can leave
    the code as it is (which we will do in this case). However, you can also remove
    the dead code or reinstate the code by removing the comments. Now, you know why
    the code is not being covered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们的一些代码之所以没有被覆盖是因为调用代码的地方被注释掉了，用于测试目的。我们可以保留代码不变（在这种情况下我们会这样做）。然而，你也可以通过去掉注释来删除死代码或者恢复代码。现在，你知道代码为什么没有被覆盖了。
- en: Well, now that you've been introduced to ReSharper and had a look at tools to
    assist you in writing good, clean C# code, it is time to look at our next tool,
    called Telerik JustDecompile.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你已经了解了ReSharper并且看了一下辅助你编写良好、干净的C#代码的工具，是时候看看我们的下一个工具了，叫做Telerik JustDecompile。
- en: Using Telerik JustDecompile
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Telerik JustDecompile
- en: I have used Telerik JustDecompile on a number of occasions, for things such as
    tracking down bugs in third-party libraries, recovering essential project source
    code that has been lost, checking the strength of assembly obfuscation, and for
    learning purposes. It is a tool that I highly recommend, as over the years it
    has proven its worth many times.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾多次使用Telerik JustDecompile，比如追踪第三方库中的bug，恢复丢失的项目源代码，检查程序集混淆的强度，以及学习目的。这是一个我强烈推荐的工具，多年来它已经证明了它的价值很多次。
- en: The decompilation engine is open source and you can obtain the source code from [https://github.com/telerik/justdecompileengine](https://github.com/telerik/justdecompileengine),
    so you are free to contribute to the project and write your own extensions for
    it. You can download Windows Installer from the Telerik website, at [https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx).
    All source code is fully navigable. The decompiler is available as a standalone
    application or as a Visual Studio extension. You create VB.NET or C# projects
    from assemblies that you decompile, and you extract and save resources from the
    decompiled assemblies.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译引擎是开源的，你可以从[https://github.com/telerik/justdecompileengine](https://github.com/telerik/justdecompileengine)获取源代码，因此你可以自由地为项目做出贡献并为其编写自己的扩展。你可以从Telerik网站下载Windows安装程序，网址是[https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx)。所有源代码都可以完全导航。反编译器可作为独立应用程序或Visual
    Studio扩展使用。你可以从反编译的程序集创建VB.NET或C#项目，并提取和保存反编译的程序集中的资源。
- en: Download and install Telerik JustDecompile. We will then go through the decompilation
    process, and generate a C# project from an assembly. You may be prompted to install
    other tools during the installation process, but you can deselect the other offerings
    from Telerik.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装Telerik JustDecompile。然后我们将进行反编译过程，并从程序集生成一个C#项目。在安装过程中可能会提示你安装其他工具，但你可以取消选择Telerik提供的其他产品。
- en: 'Run the Telerik JustDecompile standalone application. Find a .NET assembly
    and then drag it into the left pane of Telerik JustDecompile. It will decompile
    the code and display the code tree on the left. If you select an item on the left,
    the code is shown on the right, as you can see in the screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Telerik JustDecompile独立应用程序。找到一个.NET程序集，然后将其拖入Telerik JustDecompile的左窗格中。它将对代码进行反编译，并在左侧显示代码树。如果你在左侧选择一个项目，右侧将显示代码，就像屏幕截图中所示的那样：
- en: '![](img/a3aff607-0a76-4f69-a3c5-4aa285e08091.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3aff607-0a76-4f69-a3c5-4aa285e08091.png)'
- en: 'As you can see, the decompilation process is fast and it does a pretty good
    job of decompiling our assembly. The decompilation is not perfect, but in most
    cases, it does the job. Proceed as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，反编译过程非常快速，并且在大多数情况下，它都能很好地完成反编译工作。按照以下步骤进行：
- en: In the dropdown to the right of the Plugins menu item, select C#.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“插件”菜单项右侧的下拉菜单中，选择C#。
- en: Then, click on Tools | Create Project.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“工具”|“创建项目”。
- en: You will sometimes be prompted to select the .NET version to target; other times,
    not.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时会提示你选择要针对的.NET版本；有时则不会。
- en: Then, you will be asked where to save the project.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将被要求保存项目的位置。
- en: The project will then be written to that location.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目将会被写入该位置。
- en: You can then open the project in Visual Studio and work on it. Should you encounter
    any problems, Telerik logs the issues in your code and provides an email. You
    can always email them with any issues you encounter. They are good at responding
    to and fixing problems.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在Visual Studio中打开项目并对其进行操作。如果遇到任何问题，Telerik会在你的代码中记录问题并提供电子邮件。你可以随时通过电子邮件联系他们。他们擅长回应和解决问题。
- en: Well, we have completed our look at the tools in this chapter, so now, let's
    look at what we have learned in summary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经完成了本章中工具的介绍，现在，让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have seen how code metrics provide several measurements
    of code quality, and how easy it is to generate them. Code metrics include the
    number of lines—including blank lines—versus the number of executable lines of
    code, the cyclomatic complexity, the level of cohesion and coupling, and how maintainable
    your code is. The refactoring color codes are green for good, yellow for ideally
    needs refactoring, and red for definitely needs refactoring.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到代码度量提供了代码质量的几个衡量标准，以及生成这些衡量标准有多么容易。代码度量包括行数（包括空行）与可执行代码行数的比例，圈复杂度，内聚性和耦合性水平，以及代码的可维护性。重构的颜色代码是绿色表示良好，黄色表示理想情况下需要重构，红色表示绝对需要重构。
- en: You then saw how easy it is to provide a static code analysis of projects and
    view the results. Viewing and modifying rulesets that govern what gets analyzed
    and what doesn't get analyzed was also covered. Then, you experienced quick actions
    and saw how we can perform bug fixes, add using statements, and refactor code
    with a single command.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你看到了提供项目的静态代码分析以及查看结果有多么容易。还涵盖了查看和修改规则集，规定了哪些内容会被分析，哪些不会被分析。然后，你体验了快速操作，并看到了如何通过单个命令进行错误修复，添加using语句，并重构代码。
- en: We then used the JetBrains dotTrace profiler to measure our application's performance,
    track down bottlenecks, and identify hungry methods that take up the most processing
    time. The next tool we looked at was JetBrains ReSharper, which enables us to
    inspect code for various problems and potential improvements. We identified a
    couple of them and made the necessary changes, and saw how easy it was to improve
    the code with this tool. Then, we looked at creating architectural diagrams for
    dependencies and type dependencies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用JetBrains dotTrace性能分析工具来测量我们应用程序的性能，找出瓶颈，并识别占用大部分处理时间的方法。接下来我们看了JetBrains
    ReSharper，它使我们能够检查代码中的各种问题和潜在改进。我们确定了一些问题并进行了必要的更改，看到了使用这个工具改进代码有多么容易。然后，我们看了如何创建依赖关系和类型依赖的架构图。
- en: Finally, we looked at Telerik JustDecompile, a very useful tool that can be
    used to decompile assemblies and generate projects in either C# or VB.NET from
    them. This can be very useful when bugs are encountered or the program needs to
    be expanded, but you no longer have access to the existing source code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了Telerik JustDecompile，这是一个非常有用的工具，可以用来反编译程序集并从中生成C#或VB.NET项目。当遇到错误或需要扩展程序，但无法访问现有源代码时，这将非常有用。
- en: In the chapters that follow, we will mainly be looking at code, and how we can
    refactor it. But for now, test your knowledge with the following questions and
    further your reading with the links provided in the *Further reading* section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将主要关注代码，以及我们如何重构它。但现在，用以下问题测试你的知识，并通过“进一步阅读”部分提供的链接进一步阅读。
- en: Questions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are code metrics, and why should we use them?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码度量是什么，为什么我们应该使用它们？
- en: Name six code metric measurements.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举六个代码度量测量。
- en: What is code analysis, and why is it useful?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是代码分析，为什么它有用？
- en: What are quick actions?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是快速操作？
- en: What is JetBrains dotTrace used for?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JetBrains dotTrace用于什么？
- en: What is JetBrains ReSharper used for?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JetBrains ReSharper用于什么？
- en: Why use Telerik JustDecompile to decompile assemblies?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用Telerik JustDecompile来反编译程序集？
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Official Microsoft documentation on code metrics: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方微软文档关于代码度量：[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)
- en: 'Official Microsoft documentation on Quick Actions: [https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方微软文档关于快速操作：[https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019)
- en: JetBrains dotTrace profiler: [https://www.jetbrains.com/profiler/](https://www.jetbrains.com/profiler/)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains dotTrace性能分析器：[https://www.jetbrains.com/profiler/](https://www.jetbrains.com/profiler/)
