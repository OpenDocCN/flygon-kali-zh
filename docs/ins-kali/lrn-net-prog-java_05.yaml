- en: Chapter 5. Peer-to-Peer Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。点对点网络
- en: A **peer-to-peer** (**P2P**) computer network refers to an architecture whose
    nodes frequently serve as both a server and as a client. The primary objective
    of P2P systems is to eliminate the need for separate servers to manage the system.
    The configuration of the P2P network will change dynamically with nodes joining
    and leaving the network in an unpredictable manner. The nodes may differ in terms
    of factors, such as processing speed, bandwidth support, and storage capabilities.
    The term peer implies a level of equality between the nodes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**点对点**（**P2P**）计算机网络指的是一种架构，其节点经常充当服务器和客户端。P2P系统的主要目标是消除需要单独的服务器来管理系统的需求。P2P网络的配置将随着节点以不可预测的方式加入和离开网络而动态变化。节点可能在处理速度、带宽支持和存储能力等因素上有所不同。对等方这个术语意味着节点之间的平等性。'
- en: There are various definitions and interpretations of a P2P network. They can
    be characterized as a decentralized, constantly changing, and self-regulated architecture.
    Servers tend to provide services, while clients request them. A P2P node usually
    does both. A pure P2P network will not have nodes designated as a client or server.
    In reality, these networks are rare. Most P2P networks rely on a central facility,
    such as a DNS server, for support.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对P2P网络有各种定义和解释。它们可以被描述为分散的、不断变化的、自我调节的架构。服务器倾向于提供服务，而客户端请求服务。P2P节点通常两者兼而有之。纯P2P网络不会有被指定为客户端或服务器的节点。实际上，这些网络很少见。大多数P2P网络依赖于中央设施，如DNS服务器，提供支持。
- en: Certain networks may be a hybrid between the client/server architecture and
    a more pure P2P architecture where there is never a specific node acting as a
    "master" server. For example, a file sharing P2P may use the nodes of the network
    to download the files, while a server may provide additional supporting information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 某些网络可能是客户端/服务器架构和更纯粹的P2P架构之间的混合体，在这种情况下，从不会有特定的节点充当“主”服务器。例如，文件共享P2P可能使用网络的节点来下载文件，而服务器可能提供额外的支持信息。
- en: 'P2P can be classified in several ways. We will use a couple of common classification
    categories that are useful in understanding the nature of P2P networks. One classification
    is based on how **indexing**, the process of finding a node, is performed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: P2P可以以多种方式分类。我们将使用一些常见的分类类别，有助于理解P2P网络的性质。一个分类是基于**索引**的执行过程，即找到一个节点的过程：
- en: '**Centralized**: This is when a central server keeps track of where the data
    is located among peers'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式**：这是指一个中央服务器跟踪对等方之间数据位置的过程'
- en: '**Local**: This is when each peer keeps track of its own data'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：这是指每个对等方跟踪自己的数据的情况'
- en: '**Distributed**: This is when the data references are maintained by multiple
    peers'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式**：这是指数据引用由多个对等方维护的情况'
- en: Hybrid P2P networks use a centralized indexing scheme. Pure P2P networks use
    local or distributed indexes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 混合P2P网络使用集中式索引方案。纯P2P网络使用本地或分布式索引。
- en: Algorithms are used to determine the location of information in a system. The
    system is decentralized with no overriding server executing the algorithm. The
    algorithm supports a self-organizing system that dynamically reconfigures itself
    as nodes are added and removed. In addition, these systems will ideally balance
    the load and resources as the network membership changes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 算法用于确定系统中信息的位置。系统是分散的，没有执行算法的主服务器。该算法支持一个自组织的系统，随着节点的加入和移除而动态重新配置自身。此外，这些系统理想情况下会在网络成员变化时平衡负载和资源。
- en: 'In this chapter, we will cover:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The P2P concepts and terminology
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P2P的概念和术语
- en: Java support for P2P networks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java对P2P网络的支持
- en: The nature of distributed hash tables
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式哈希表的性质
- en: How FreePastry supports P2P applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreePastry如何支持P2P应用程序
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: P2P applications provide a flexible alternative to the traditional client/server
    architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: P2P应用程序提供了传统客户端/服务器架构的灵活替代方案。
- en: P2P functions/characteristics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P2P功能/特征
- en: 'One way of understanding a P2P network is to examine its characteristics. These
    include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理解P2P网络的一种方式是审视其特征。这些特征包括以下内容：
- en: 'Nodes that contribute resources to the system, including:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向系统提供资源的节点，包括：
- en: Data storage
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储
- en: Computational resources
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算资源
- en: They provide support for a set of services
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供一系列服务的支持
- en: They are very scalable and fault tolerant
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常可扩展和容错
- en: They support load balancing of resources
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持资源的负载平衡
- en: They may support limited anonymity
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能支持有限的匿名性
- en: The nature of P2P systems is that a user may not be able to access a specific
    node to use a service or resources. As nodes join and leave a system randomly,
    a specific node may not be available. The algorithm will determine how the system
    responds to requests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: P2P系统的性质是用户可能无法访问特定节点以使用服务或资源。随着节点随机加入和离开系统，特定节点可能不可用。算法将决定系统如何响应请求。
- en: 'The basics functions of a P2P system include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: P2P系统的基本功能包括：
- en: Enrollment of peers in a network
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等方在网络中的注册
- en: Peer discovery—the process of determining which peer has the information of
    interest
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等方发现-确定哪个对等方拥有感兴趣的信息的过程
- en: Sending messages between peers
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等方之间的消息传递
- en: Not all peers perform all of these functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有对等方都执行所有这些功能。
- en: The resources of a P2P system are identified using a **Globally Unique Identifier**
    (**GUID**) that is usually generated using a secure hashing function, which we
    will examine in DHT components. The GUID is not intended to be human readable.
    It is a randomly generated value providing little opportunity for conflicts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: P2P系统的资源使用**全局唯一标识符**（**GUID**）进行标识，通常使用安全哈希函数生成，我们将在DHT组件中进行讨论。GUID不打算供人类阅读。它是一个随机生成的值，几乎没有冲突的机会。
- en: The nodes of a P2P are organized using **routing** **overlay**s. It is a type
    of **middleware** that routes requests to the appropriate node. The overlay refers
    to a network that is on top of the physical network as identified by resources
    using IP addresses. We can envision a network as composed on a series of IP-based
    nodes. However, an overlay is a subset of these nodes usually focusing on a single
    task.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: P2P的节点使用**路由** **覆盖**进行组织。这是一种将请求路由到适当节点的**中间件**类型。覆盖指的是位于物理网络之上的网络，由IP地址标识资源。我们可以将网络构想为由一系列基于IP的节点组成。然而，覆盖是这些节点的一个子集，通常专注于单一任务。
- en: The routing overlay will take into consideration factors, such as the number
    of nodes between a user and a resource, and the bandwidth of the connection, to
    determine which node should fulfill a request. Frequently, a resource may be duplicated
    or even split across multiple nodes. A routing overlay will attempt to provide
    the optimal path to a resource.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 路由覆盖将考虑因素，例如用户和资源之间的节点数量，以及连接的带宽，以确定哪个节点应该满足请求。资源经常会被复制或甚至分布在多个节点之间。路由覆盖将尝试提供到资源的最佳路径。
- en: As nodes join and leave a system, the routing overlay needs to account for these
    changes. When a node joins a system, it may be asked to take on some responsibilities.
    When a node leaves, other parts of the system may need to pick up some of the
    departing nodes responsibilities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着节点加入和离开系统，路由覆盖需要考虑这些变化。当一个节点加入系统时，可能会被要求承担一些责任。当一个节点离开时，系统的其他部分可能需要承担一些离开节点的责任。
- en: In this chapter, we will explain various concepts, which are often embedded
    as part of a system. We will briefly overview different P2P application, which
    will be followed by a discussion of Java support for this architecture. The use
    of distributed hash tables is demonstrated, and an in-depth examination of FreePastry
    is presented, which will provide insight into how many of the P2P frameworks work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释通常作为系统一部分嵌入的各种概念。我们将简要概述不同的P2P应用程序，然后讨论Java对这种架构的支持。我们演示了分布式哈希表的使用，并深入研究了FreePastry，这将使我们了解许多P2P框架的工作原理。
- en: When applicable, we will illustrate how some of these concepts can be implemented
    manually. While these implementations are not needed to use the system, they will
    provide a more in-depth understanding of these underlying concepts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的情况下，我们将说明如何手动实现一些这些概念。虽然不需要使用这些实现来使用系统，但它们将提供对这些基本概念的更深入的理解。
- en: Applications-based P2P networks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于应用程序的P2P网络
- en: 'There are many applications that are based on a P2P network. They can be used
    for the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于P2P网络的应用程序。它们可以用于以下用途：
- en: '**Content distribution**: This is file sharing (files, music, videos, images)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容分发**：这是文件共享（文件、音乐、视频、图像）'
- en: '**Distributed computing**: This is when a problem is divided into smaller tasks
    and executed in a parallel fashion'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式计算**：这是将问题分解为较小任务并以并行方式执行的情况'
- en: '**Collaboration**: This is when users work together to solve a common problem'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collaboration**：这是用户共同解决共同问题时的情况'
- en: '**Platforms**: These are systems on which P2P applications are built, such
    as JXTA, and Pastry'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**：这些是构建P2P应用程序的系统，如JXTA和Pastry'
- en: Distributed computing leverages the power of larger numbers of smaller computers
    to perform a task. The problems amenable to this approach require that they be
    broken down into smaller units and then executed concurrently on multiple machines.
    The results of these smaller tasks then need to be combined to produce a final
    result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算利用更多数量的较小计算机的能力来执行任务。这种方法适用的问题需要被分解成较小的单元，然后并行在多台机器上执行。然后需要将这些较小任务的结果组合起来产生最终结果。
- en: 'P2P networks support a number of applications, such as the following ones:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络支持许多应用程序，例如以下应用程序：
- en: '**Skype**: This is a video-conferencing application'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Skype**：这是一个视频会议应用程序'
- en: '**Freecast**: This is peer-to-peer streaming audio program'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Freecast**：这是一个点对点的流媒体音频程序'
- en: '**BitTorrent**: This is a popular peer-to-peer file sharing system'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BitTorrent**：这是一个流行的点对点文件共享系统'
- en: '**Tor**: This program shields users'' identities'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tor**：这个程序可以保护用户的身份'
- en: '**Haihaisoft**: This is used for distribution of prerecorded TV programs'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Haihaisoft**：用于分发预先录制的电视节目'
- en: '**WoW**: This uses a P2P for game updates'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WoW**：这使用P2P进行游戏更新'
- en: '**YaCy**: This is a search engine and web crawler'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YaCy**：这是一个搜索引擎和网络爬虫'
- en: '**Octoshape**: This supports live TV'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Octoshape**：支持实时电视'
- en: A good overview of P2P applications is found at [http://p2peducation.pbworks.com/w/page/8897427/FrontPage](http://p2peducation.pbworks.com/w/page/8897427/FrontPage).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://p2peducation.pbworks.com/w/page/8897427/FrontPage](http://p2peducation.pbworks.com/w/page/8897427/FrontPage)上可以找到对P2P应用程序的很好概述。
- en: Java support for P2P applications
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对P2P应用程序的支持
- en: Java support beyond the low-level socket support that was detailed in earlier
    chapters consists of various frameworks. These range from well-known frameworks,
    such as JXTA, to small limited-capability protocols. These frameworks provide
    the basis for more specialized applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持超出了在早期章节中详细介绍的低级套接字支持，包括各种框架。这些框架从众所周知的框架（如JXTA）到小型的功能有限的协议都有。这些框架为更专业的应用程序提供了基础。
- en: 'The following table lists several of these frameworks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了几个这些框架：
- en: '| P2P framework | URL |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| P2P framework | URL |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
- en: '| JXTA | [https://jxta.kenai.com/](https://jxta.kenai.com/) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| JXTA | [https://jxta.kenai.com/](https://jxta.kenai.com/) |'
- en: '| Hive2Hive | [https://github.com/Hive2Hive/Hive2Hive](https://github.com/Hive2Hive/Hive2Hive)
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Hive2Hive | [https://github.com/Hive2Hive/Hive2Hive](https://github.com/Hive2Hive/Hive2Hive)
    |'
- en: '| jnmp2p | [https://code.google.com/p/jnmp2p/](https://code.google.com/p/jnmp2p/)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| jnmp2p | [https://code.google.com/p/jnmp2p/](https://code.google.com/p/jnmp2p/)
    |'
- en: '| FlexGP | [http://flexgp.github.io/flexgp/javalibrary.html](http://flexgp.github.io/flexgp/javalibrary.html)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| FlexGP | [http://flexgp.github.io/flexgp/javalibrary.html](http://flexgp.github.io/flexgp/javalibrary.html)
    |'
- en: '| JMaay | [http://sourceforge.net/projects/jmaay/](http://sourceforge.net/projects/jmaay/)
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| JMaay | [http://sourceforge.net/projects/jmaay/](http://sourceforge.net/projects/jmaay/)
    |'
- en: '| P2P-MPI | [http://grid.u-strasbg.fr/p2pmpi/](http://grid.u-strasbg.fr/p2pmpi/)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| P2P-MPI | [http://grid.u-strasbg.fr/p2pmpi/](http://grid.u-strasbg.fr/p2pmpi/)
    |'
- en: '| Pastry | [http://www.freepastry.org/](http://www.freepastry.org/) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Pastry | [http://www.freepastry.org/](http://www.freepastry.org/) |'
- en: These frameworks use an algorithm to route messages between peers. Hash tables
    frequently form the basis of these frameworks, as discussed next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架使用算法在对等方之间路由消息。哈希表经常构成这些框架的基础，如下所讨论的。
- en: Distributed hash tables
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式哈希表
- en: A **Distributed Hash Table** (**DHT**) uses a key/value pair to locate resources
    in a network. This mapping function is spread across peers making it distributed.
    This architecture allows P2P networks to scale easily to a large number of nodes
    and to handle peers joining and leaving a network randomly. A DHT is the basis
    to support core P2P services. Many applications use DHT, including BitTorrent,
    Freenet, and YaCy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式哈希表**（**DHT**）使用键/值对在网络中定位资源。这个映射函数分布在对等方之间，使其分布式。这种架构使得P2P网络可以轻松扩展到大量节点，并且可以处理对等方随机加入和离开网络。DHT是支持核心P2P服务的基础。许多应用使用DHT，包括BitTorrent、Freenet和YaCy。'
- en: The following figure illustrates mapping a key to a value. The key is frequently
    a string containing the identity of a resource, such as the name of a book; and
    the value is a number generated to represent the resource. The number can be used
    to locate the resource in a network and can correspond to the identifier of a
    node.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了将键映射到值。键通常是包含资源标识的字符串，比如书名；值是用来表示资源的数字。这个数字可以用来在网络中定位资源，并且可以对应于节点的标识符。
- en: '![Distributed hash tables](img/B04915_05_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![分布式哈希表](img/B04915_05_01.jpg)'
- en: 'P2P networks have been in use for a while. The evolution of these networks
    is reflected in how resources are mapped as typified by Napster, Gnutella, and
    Freenet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: P2P网络已经使用了一段时间。这些网络的演变反映在资源如何被映射，如Napster、Gnutella和Freenet所体现的那样。
- en: Napster ([https://en.wikipedia.org/wiki/Napster](https://en.wikipedia.org/wiki/Napster))
    was the first large-scale P2P content delivery system. It uses a server to keep
    track of the nodes in the network. The nodes held the actual data. When a client
    needs this data, the server will look up the current set of nodes that holds the
    data, and this node's location will be sent back to the client. The client will
    then contact the node holding the data. This made it easy for attacks to be launched
    against it and, eventually, led to its demise through lawsuits.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Napster ([https://en.wikipedia.org/wiki/Napster](https://en.wikipedia.org/wiki/Napster))是第一个大规模P2P内容传送系统。它使用服务器来跟踪网络中的节点。节点保存实际数据。当客户端需要这些数据时，服务器将查找保存数据的当前节点集，并将该节点的位置发送回客户端。然后客户端将联系保存数据的节点。这使得它容易受到攻击，并最终通过诉讼导致了它的消亡。
- en: Gnutella ([https://web.archive.org/web/20080525005017](https://web.archive.org/web/20080525005017),
    [http://www.gnutella.com/](http://www.gnutella.com/)) does not use a central server
    but broadcasts to every node in a network. This resulted in the network being
    flooded with messages, and the approach was modified in later versions.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gnutella ([https://web.archive.org/web/20080525005017](https://web.archive.org/web/20080525005017),
    [http://www.gnutella.com/](http://www.gnutella.com/))不使用中央服务器，而是向网络中的每个节点广播。这导致网络被消息淹没，并且这种方法在后来的版本中被修改。
- en: 'Freenet ([https://freenetproject.org/](https://freenetproject.org/)) uses a
    heuristic key-based routing scheme and focuses on censorship and anonymity issues.
    However, DHS uses a more structured key-based routing approach resulting in the
    following:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Freenet ([https://freenetproject.org/](https://freenetproject.org/))使用启发式基于键的路由方案，专注于审查和匿名问题。然而，DHS使用更结构化的基于键的路由方法，导致以下结果：
- en: Decentralization
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化
- en: Fault tolerance
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错性
- en: Scalability
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Efficiency
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: However, DHT does not support exact-match search. If this type of search is
    needed, then it has to be added.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DHT不支持精确匹配搜索。如果需要这种类型的搜索，就必须添加。
- en: DHT components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DHT组件
- en: A **keyspace** is a set of 160-bit strings (keys) that is used to identify an
    element. **Keyspace partitioning** is the process of splitting the keyspace among
    the nodes of the network. An overlay network connects the nodes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**键空间**是一组用于标识元素的160位字符串（键）。**键空间分区**是将键空间分割成网络节点的过程。覆盖网络连接节点。'
- en: A commonly used hashing algorithm is **Secure Hash Algorithm** (**SHA-1**) ([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1)).
    SHA-1 was designed by the NSA and generates a 160-bit hash value known as a message
    digest. Most P2Ps do not require the developer to explicitly perform the hashing
    function. However, it is instructive to see how it is done. The following is an
    example of using Java to create a digest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的哈希算法是**安全哈希算法**（**SHA-1**）([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1))。SHA-1是由NSA设计的，生成一个称为消息摘要的160位哈希值。大多数P2P不需要开发人员显式执行哈希函数。但是，了解如何执行是有益的。以下是使用Java创建摘要的示例。
- en: 'The `MessageDigest` class''s `getInstance` method accepts a string specifying
    the algorithm to use and returns a `MessageDigest` instance. Its `update` method
    requires an array of bytes containing the key to hash. In this example, a string
    is used. The `digest` method returns an array of bytes holding the hash value.
    The byte array is then displayed as a hexadecimal number:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDigest`类的`getInstance`方法接受一个指定要使用的算法的字符串，并返回一个`MessageDigest`实例。它的`update`方法需要一个包含要哈希的键的字节数组。在这个例子中，使用了一个字符串。`digest`方法返回一个包含哈希值的字节数组。然后将字节数组显示为十六进制数：'
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Executing this sequence will produce the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个序列将产生以下输出：
- en: '**Hex format : 434d902b6098ac050e4ed79b83ad93155b161d72**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**十六进制格式：434d902b6098ac050e4ed79b83ad93155b161d72**'
- en: 'To store data, such as a file, we can use the filename to create a key. A put
    type function is then used to store the data:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储数据，比如文件，我们可以使用文件名创建一个键。然后使用put类型函数来存储数据：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To retrieve the data corresponding to a key, a get type function is used:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索与密钥对应的数据，使用get类型函数：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every node in an overlay either contains the data that is represented by the
    key, or it is a node closer to the node containing the data. The routing algorithm
    determines the next node to visit on the way to the node containing the data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖中的每个节点都包含由密钥表示的数据，或者它是更接近包含数据的节点的节点。路由算法确定了前往包含数据的节点的下一个节点。
- en: DHT implementations
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DHT实现
- en: 'There are several Java implementations of DHTs, as listed in the following
    table:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种Java实现的DHT，如下表所示：
- en: '| Implementation | URL |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 实现 | URL |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| openkad | [https://code.google.com/p/openkad/](https://code.google.com/p/openkad/)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| openkad | [https://code.google.com/p/openkad/](https://code.google.com/p/openkad/)
    |'
- en: '| Open Chord | [http://open-chord.sourceforge.net/](http://open-chord.sourceforge.net/)
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Open Chord | [http://open-chord.sourceforge.net/](http://open-chord.sourceforge.net/)
    |'
- en: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| TomP2P | [http://tomp2p.net/](http://tomp2p.net/) |'
- en: '| JDHT | [http://dks.sics.se/jdht/](http://dks.sics.se/jdht/) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| JDHT | [http://dks.sics.se/jdht/](http://dks.sics.se/jdht/) |'
- en: We will use the **Java Distributed Hash Table** (**JDHT**) to illustrate the
    use of a DHT.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Java分布式哈希表**（**JDHT**）来说明DHT的使用。
- en: Using JDHT
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JDHT
- en: 'In order to use JDHT, you will need the JAR files that are listed in the following
    table. The `dks.jar` file is the main jar file used. However, the other two JAR
    files are used by JDHT. Alternate sources for the `dks.jar` file is listed as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用JDHT，您需要以下表中列出的JAR文件。`dks.jar`文件是主要的jar文件。但是，JDHT还使用其他两个JAR文件。`dks.jar`文件的备用来源如下所示：
- en: '| JAR | Site |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| JAR | 网站 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dks.jar` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `dks.jar` |'
- en: '[http://dks.sics.se/jdht/](http://dks.sics.se/jdht/)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://dks.sics.se/jdht/](http://dks.sics.se/jdht/)'
- en: '[https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2](https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2](https://www.ac.upc.edu/projects/cms/browser/cms/trunk/lib/dks.jar?rev=2)'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `xercesImpl.jar` | [http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm](http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm)
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `xercesImpl.jar` | [http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm](http://www.java2s.com/Code/Jar/x/DownloadxercesImpljar.htm)
    |'
- en: '| Apache log4j 1.2.17 | [https://logging.apache.org/log4j/1.2/download.html](https://logging.apache.org/log4j/1.2/download.html)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Apache log4j 1.2.17 | [https://logging.apache.org/log4j/1.2/download.html](https://logging.apache.org/log4j/1.2/download.html)
    |'
- en: 'The following example has been adapted from the one on the website. First,
    we create a `JDHT` instance. JDHT uses port `4440` as its default. With this instance,
    we can then use its `put` method to add a key/value pair to the table:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例已经改编自网站上的示例。首先，我们创建一个`JDHT`实例。JDHT使用端口`4440`作为其默认端口。有了这个实例，我们可以使用它的`put`方法将键/值对添加到表中：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order for a client to connect with this instance, we need to get a reference
    to this node. This is achieved as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端能够连接到此实例，我们需要获取对此节点的引用。如下所示实现：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code will keep the program running until the user terminates
    it. The `close` method is then used to close the table:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将使程序保持运行，直到用户终止它。然后使用`close`方法关闭表：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the program is executed, you will get an output similar to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，您将获得类似以下的输出：
- en: '**dksref://192.168.1.9:4440/0/2179157225/0/1952355557247862269**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**dksref://192.168.1.9:4440/0/2179157225/0/1952355557247862269**'
- en: '**Press Enter to terminate application:**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**按Enter键终止应用程序：**'
- en: 'The client application is described as follows. A new JDHT instance is created
    using a different port. The second argument is the reference to the first application.
    You will need to copy the reference and paste it into the client. A different
    reference will be generated each time the first application is executed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序描述如下。使用不同的端口创建一个新的JDHT实例。第二个参数是对第一个应用程序的引用。您需要复制引用并将其粘贴到客户端中。每次执行第一个应用程序时，都会生成一个不同的引用：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we use the `get` method to retrieve the value associated with the key.
    The value is then displayed and the application is closed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`get`方法检索与密钥关联的值。然后显示该值并关闭应用程序：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '**http://docs.oracle.com/javase/8/docs/api/**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**http://docs.oracle.com/javase/8/docs/api/**'
- en: This simple demonstration illustrates the basics of a distributed hash table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的演示说明了分布式哈希表的基础知识。
- en: Using FreePastry
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FreePastry
- en: Pastry ([http://www.freepastry.org/](http://www.freepastry.org/)) is a P2P routing
    overlay system. FreePastry ([http://www.freepastry.org/FreePastry/](http://www.freepastry.org/FreePastry/))
    is an open source implementation of Pastry and is simple enough for us to use
    to illustrate many of the features of a P2P system. Pastry will route messages
    with a network of *n* nodes in *O(log n)* steps. That is, given a network of nodes,
    it requires, at most, log base 2 of *n* steps to reach the node. This is an efficient
    routing approach. However, while it may only require traversing three nodes to
    get to a resource, it may require a considerable number of IP hops to get to it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Pastry（[http://www.freepastry.org/](http://www.freepastry.org/)）是一个P2P路由覆盖系统。FreePastry（[http://www.freepastry.org/FreePastry/](http://www.freepastry.org/FreePastry/)）是Pastry的开源实现，足够简单，可以用来说明P2P系统的许多特性。Pastry将在*O(log
    n)*步骤中路由具有*n*节点网络的消息。也就是说，给定一个节点网络，最多需要*log2 n*步骤才能到达该节点。这是一种高效的路由方法。但是，虽然只需要遍历三个节点就可以获得资源，但可能需要大量的IP跳数才能到达它。
- en: Pastry uses the concept of **leaf sets** in the routing process. Each node has
    a leaf set. A leaf set is a collection of GUIDS and IP addresses of nodes that
    are numerically closest to this node. The nodes are logically arranged in a circle,
    as shown next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Pastry在路由过程中使用**叶集**的概念。每个节点都有一个叶集。叶集是此节点数字上最接近的节点的GUIDS和IP地址的集合。节点在逻辑上排列成一个圆圈，如下所示。
- en: 'In the following figure, each dot represents a node with an identifier. The
    addresses used here range from `0` to `FFFFFF`. The real addresses range from
    `0` to `2128`. If a message representing a request originates at address `9341A2`
    and needs to be sent to address `E24C12`, then based on the numerical address
    the overlay router may route the messages through the intermediate nodes, as depicted
    by the arrows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，每个点代表一个带有标识符的节点。这里使用的地址范围从`0`到`FFFFFF`。真实地址范围从`0`到`2128`。如果代表请求的消息起源于地址`9341A2`并且需要发送到地址`E24C12`，那么基于数字地址，覆盖路由器可能通过中间节点路由消息，如箭头所示：
- en: '![Using FreePastry](img/B04915_05_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用FreePastry](img/B04915_05_02.jpg)'
- en: 'Other applications have been built on top of FreePastry, including:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用程序已构建在FreePastry之上，包括：
- en: '**SCRIBE**: This is a group communication and event notification system supporting
    the publisher/subscriber paradigm'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCRIBE**：这是一个支持发布者/订阅者范式的组通信和事件通知系统'
- en: '**PAST**: This is an archival storage utility system'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PAST**：这是一个存档存储实用程序系统'
- en: '**SplitStream**: This program supports content streaming and distribution'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SplitStream**：该程序支持内容流和分发'
- en: '**Pastiche**: This is backup system'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pastiche**：这是备份系统'
- en: Each of these applications uses an API to support their use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都使用API来支持它们的使用。
- en: The FreePastry demonstration
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreePastry演示
- en: 'To demonstrate how FreePastry supports a P2P application, we will create an
    application based on the FreePastry tutorials found at [https://trac.freepastry.org/wiki/FreePastryTutorial](https://trac.freepastry.org/wiki/FreePastryTutorial).
    In this demonstration, we will create two nodes and demonstrate how they can send
    and receive messages. The demonstration uses three classes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示FreePastry如何支持P2P应用程序，我们将创建一个基于[https://trac.freepastry.org/wiki/FreePastryTutorial](https://trac.freepastry.org/wiki/FreePastryTutorial)中找到的FreePastry教程的应用程序。在这个演示中，我们将创建两个节点，并演示它们如何发送和接收消息。演示使用三个类：
- en: '`FreePastryExample`: This is used to bootstrap the network'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreePastryExample`：这用于引导网络'
- en: '`FreePastryApplication`: This executes the functionality of the node'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreePastryApplication`：这执行节点的功能'
- en: '`PastryMessage`: This is the message that is sent between nodes'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PastryMessage`：这是在节点之间发送的消息'
- en: Let's start with the bootstrap application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从引导应用程序开始。
- en: Understanding the FreePastryExample class
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解FreePastryExample类
- en: 'There are several components used with FreePastry applications. These include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个组件与FreePastry应用程序一起使用。这些包括：
- en: '**Environment**: This class represents the application''s environment'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：这个类代表应用程序的环境'
- en: '**Bind port**: This represents the local port that the application will bind
    to'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定端口**：这代表应用程序将绑定到的本地端口'
- en: '**Boot port**: This is the boot port that is used for the node''s `InetAddress`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导端口**：这是用于节点的`InetAddress`的引导端口'
- en: '**Boot address**: This is the IP address of the boot node'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导地址**：这是引导节点的IP地址'
- en: 'The `FreePastryExample` class is defined next. It contains a main method and
    a constructor:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来定义`FreePastryExample`类。它包含一个主方法和一个构造函数：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will start with the `main` method. An instance of the `Environment` class
    is created first. This class holds the parameter settings for the node. Next,
    the NAT search policy is set to never, which allows us to use the program in a
    local LAN without difficulty:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`main`方法开始。首先创建`Environment`类的实例。这个类保存节点的参数设置。接下来，将NAT搜索策略设置为从不，这样我们就可以在本地LAN中使用程序而不会有困难：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The ports and `InetSocketAddress` instance are initialized. We will set both
    ports to the same number at this time. We used the IP address `192.168.1.14` to
    instantiate the `InetAddress` object. You will need to use the address of your
    machine instead. This is a local LAN address. Do not use `127.0.0.1` as it will
    not work properly. The `InetAddress` object along with the `bootPort` value are
    used to create the `InetSocketAddress` instance. All of this is placed in a try
    block to handle exceptions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 端口和`InetSocketAddress`实例被初始化。我们将此时两个端口设置为相同的数字。我们使用IP地址`192.168.1.14`来实例化`InetAddress`对象。您需要使用您的机器的地址。这是一个本地LAN地址。不要使用`127.0.0.1`，因为它将无法正常工作。`InetAddress`对象以及`bootPort`值用于创建`InetSocketAddress`实例。所有这些都放在try块中来处理异常：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last task is to create an instance of the `FreePastryExample` class by
    calling the constructor:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个任务是通过调用构造函数创建`FreePastryExample`类的实例：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The constructor will create and launch the node's application. To accomplish
    this, we need to create a `PastryNode` instance and attach the application to
    it. To create the node, we will use a factory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将创建并启动节点的应用程序。为了实现这一点，我们需要创建一个`PastryNode`实例，并将应用程序附加到它上面。为了创建节点，我们将使用一个工厂。
- en: 'Every node needs a unique ID. The `RandomNodeIdFactory` class generates an
    ID based on the current environment. Using this object with the bind port and
    the environment, an instance of the `SocketPastryNodeFactory` is created. With
    this factory the `newNode` method is invoked to create our `PastryNode` instance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都需要一个唯一的ID。`RandomNodeIdFactory`类根据当前环境生成ID。使用此对象与绑定端口和环境，创建`SocketPastryNodeFactory`的实例。使用此工厂调用`newNode`方法来创建我们的`PastryNode`实例：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, an instance of the `FreePastryApplication` class is created, and the
    node is started using the `boot` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`FreePastryApplication`类的实例，并使用`boot`方法启动节点：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The node''s ID is then displayed as shown in the next code sequence. As there
    will be multiple nodes in the network, we pause for 10 seconds to allow the other
    nodes to start. We used the FreePastry timer to effect this delay. A random node
    ID is created, and the application''s `routeMessage` message is called to send
    a message to that node:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后显示节点的ID，如下一个代码序列所示。由于网络中会有多个节点，我们暂停10秒钟，以便其他节点启动。我们使用FreePastry计时器来实现这种延迟。创建一个随机节点ID，并调用应用程序的`routeMessage`消息将消息发送到该节点：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before we execute the program, we need to develop the application class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序之前，我们需要开发应用程序类。
- en: Understanding the FreePastryApplication class
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解FreePastryApplication类
- en: 'The `FreePastryApplication` class implements the `Application` interface and
    implements the functionality of the node. The constructor creates and registers
    an `Endpoint` instance and initializes a message. The `Endpoint` instance is used
    by the node to send messages. The class and constructor are shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`FreePastryApplication`类实现了`Application`接口，并实现了节点的功能。构造函数创建并注册了一个`Endpoint`实例，并初始化了一个消息。节点使用`Endpoint`实例来发送消息。以下是类和构造函数的示例：'
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may get a "Leaking this in constructor" warning when this code is compiled.
    This is caused by a reference to the constructor's object being passed as an argument
    to the `buildEndpoint` method using the `this` keyword. This is a potentially
    bad practice because the object may have not been fully constructed when it was
    passed. Another thread may try to do something with the object before it is ready.
    It is not as much of a problem if it is passed to a package-private method that
    performs common initialization. In this situation, it is not likely to cause problems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码被编译时，您可能会收到“在构造函数中泄漏this”的警告。这是由于使用`this`关键字将构造函数的对象引用作为参数传递给`buildEndpoint`方法。这是一个潜在的不良实践，因为在传递时对象可能尚未完全构造。另一个线程可能会在对象准备好之前尝试对其进行操作。如果它被传递给执行常见初始化的包私有方法，那么这不会是太大的问题。在这种情况下，它不太可能引起问题。
- en: 'The `Application` interface requires that three methods be implemented:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`接口要求实现三种方法：'
- en: '`deliver`: This is called when a message is received'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deliver`：当接收到消息时调用'
- en: '`forward`: This is used to forward a message'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward`：用于转发消息'
- en: '`update`: This informs the application that a node has joined or left a set
    of local nodes'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：通知应用程序一个节点已加入或离开了一组本地节点'
- en: We are only interested in the `deliver` method for this application. In addition,
    we will add the `getCurrentTime` and `routeMessage` methods to the application.
    We will use the `getCurrentTime` methods to show the time that our messages are
    sent and arrive. The `routeMessage` method will send a message to another node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对这个应用程序中的`deliver`方法感兴趣。此外，我们将添加`getCurrentTime`和`routeMessage`方法到应用程序中。我们将使用`getCurrentTime`方法来显示我们发送和接收消息的时间。`routeMessage`方法将向另一个节点发送消息。
- en: 'The `getCurrentTime` method is as follows. It uses the `EndPoint` object to
    access the node''s environment and then the time:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCurrentTime`方法如下。它使用`EndPoint`对象来访问节点的环境，然后获取时间：'
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `routeMessage` method is passed the identifier of the destination node.
    The message text is constructed adding the end point and time information. A `PastryMessage`
    instance is created using the end-point identifier and the message text. The `route`
    method is then called to send this message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`routeMessage`方法传递了目标节点的标识符。消息文本是通过添加端点和时间信息来构造的。使用端点标识符和消息文本创建了一个`PastryMessage`实例。然后调用`route`方法来发送这条消息：'
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When a message is received by a node, the `deliver` method is invoked. The
    implementation of this method is as follows. The end point identifier, the message,
    and the time of arrival are displayed. This will help us understand how messages
    are sent and received:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点接收到消息时，将调用`deliver`方法。该方法的实现如下。显示了端点标识符、消息和到达时间。这将帮助我们理解消息是如何发送和接收的：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `PastryMessage` class implements the `Message` interface, as shown next.
    The constructor accepts the destination, source, and message:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`PastryMessage`类实现了`Message`接口，如下所示。构造函数接受目标、源和消息：'
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Message` interface possesses a single `getPriority` method that needs
    to be overridden. Here, we return a low priority so that it does not interfere
    with underlying P2P maintenance traffic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`接口拥有一个需要被重写的`getPriority`方法。在这里，我们返回一个低优先级，以便它不会干扰底层的P2P维护流量：'
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `toString` method is overridden to provide a more detailed description
    of the message:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法被重写以提供消息的更详细描述：'
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we are ready to execute the example. Execute the `FreePastryExample` class.
    The initial output will consist of the following output. The abbreviated node
    identifier is displayed, which in this case is `<0xB36864..>`. The identifier
    that you get will be different:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备执行示例。执行`FreePastryExample`类。初始输出将包括以下输出。显示了缩写的节点标识符，本例中为`<0xB36864..>`。您得到的标识符将会不同：
- en: '**InetAddress: /192.168.1.14 Node <0xB36864..> created**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/192.168.1.14 节点<0xB36864..>已创建**'
- en: 'After this, a pause a message is sent and subsequently received by the current
    node. This message was created in the `FreePastryExample` class using the code
    repeated here for your convenience:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，发送一个暂停消息，随后当前节点接收到该消息。这条消息是在`FreePastryExample`类中创建的，以下是重复的代码以供您参考：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A random identifier was used because we do not have a specific node to send
    the message to. When the message is sent, the following output is generated. The
    random identifier for this run is `<0x83C7CD..>`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了一个随机标识符，因为我们没有特定的节点来发送消息。当消息被发送时，将生成以下输出。本次运行的随机标识符是`<0x83C7CD..>`：
- en: '**Message Sent**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息已发送**'
- en: '**Current Node: <0xB36864..>**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前节点：<0xB36864..>**'
- en: '**Destination: <0x83C7CD..>**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标：<0x83C7CD..>**'
- en: '**Time: 1441844742906**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间：1441844742906**'
- en: '**Message Received**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息已接收**'
- en: '**Current Node: <0xB36864..>**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前节点：<0xB36864..>**'
- en: '**Message: From: <0xB36864..> To: <0x83C7CD..> [Hello there! from Instance:
    Instance ID Sent at: [1441844732905]]**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息：从：<0xB36864..> 到：<0x83C7CD..> [你好！来自实例：实例ID 发送于：[1441844732905]]**'
- en: '**Time: 1441844742915**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间：1441844742915**'
- en: The time between the sending and receiving of the message is minimal. If a larger
    set of nodes comprised the P2P network, more significant delays would show up.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收消息之间的时间是最短的。如果P2P网络由更大的节点集合组成，将会出现更显著的延迟。
- en: 'In the previous output, the node addresses were truncated. We can use the `toStringFull`
    method, as shown here, to get the full address:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的输出中，节点地址被截断了。我们可以使用`toStringFull`方法，如下所示，来获取完整的地址：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will produce output similar to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '**Node B36864DE0C4F9E9C1572CBCC095D585EA943B1B4 created**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点B36864DE0C4F9E9C1572CBCC095D585EA943B1B4已创建**'
- en: We did not provide a specific address for our messages. Instead, we randomly
    generated addresses. This application demonstrated the basic elements of a FreePastry
    application. Additional layers are used to facilitate communication between nodes,
    such as the publisher/provider paradigm support by Scribe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为消息提供特定的地址。相反，我们随机生成了地址。这个应用程序演示了FreePastry应用程序的基本元素。其他层用于促进节点之间的通信，比如Scribe支持的发布者/提供者范式。
- en: We can start a second node using the same program, but we will need to use a
    different bind port to avoid binding conflicts. The message sent by either node
    will not necessarily be received by the other node. This is the result of the
    routes generated by FreePastry.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的程序启动第二个节点，但我们需要使用不同的绑定端口以避免绑定冲突。任一节点发送的消息不一定会被另一个节点接收。这是FreePastry生成的路由的结果。
- en: Sending a message to a specific node
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向特定节点发送消息
- en: To send a message directly to a node, we need its identifier. To get a remote
    node's identifier, we need to use a leaf set. This collection is not strictly
    a set because for small networks, such as the one we are using, the same node
    may appear twice.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接向节点发送消息，我们需要其标识符。要获取远程节点的标识符，我们需要使用叶集。这个集合不严格地是一个集合，因为对于小型网络（比如我们正在使用的网络），同一个节点可能会出现两次。
- en: The `LeafSet` class represents this collection and has a `get` method that will
    return a `NodeHandle` instance for each node. We can send messages to nodes if
    we have this node handle.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeafSet`类代表这个集合，并且有一个`get`方法，将为每个节点返回一个`NodeHandle`实例。如果我们有这个节点句柄，我们可以向节点发送消息。'
- en: 'To demonstrate this approach, add the following method to the `FreePastryApplication`
    class. This is similar to the `routeMessage` method, but it uses a node handle
    as an argument of the `route` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种方法，将以下方法添加到`FreePastryApplication`类中。这类似于`routeMessage`方法，但它使用节点句柄作为`route`方法的参数：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following sequences of code to the end of the `FreePastryExample` constructor.
    Optionally, comment out the previous code that uses the `routeMessage` method.
    First, we pause for 10 seconds to allow other nodes to join the network:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码序列添加到`FreePastryExample`构造函数的末尾。可选择注释掉使用`routeMessage`方法的先前代码。首先，我们暂停10秒，以便其他节点加入网络：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we create an instance of the `LeafSet` class. The `getUniqueSet` method
    returns the leaf set, which excludes the current node. A for-each statement will
    then use the `routeMessageDirect` variable to send the message to the nodes of
    the collection:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`LeafSet`类的一个实例。`getUniqueSet`方法返回叶集，不包括当前节点。然后，for-each语句将使用`routeMessageDirect`变量将消息发送到集合的节点：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the `FreePastryExample` class using a bind port of `9001`. Then, change
    the bind port to `9002` and start the class a second time. After several seconds,
    you will see an output similar to the following one. The first set of output corresponds
    to the first instance of the application, while the second set corresponds to
    the second instance. Each instance will send one message to the other instance.
    Note the time stamps that are used when the messages are sent and received:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定端口`9001`启动`FreePastryExample`类。然后，将绑定端口更改为`9002`，并再次启动该类。几秒钟后，您将看到类似以下输出。第一组输出对应应用程序的第一个实例，而第二组对应第二个实例。每个实例将向另一个实例发送一条消息。请注意消息发送和接收时使用的时间戳：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is a lot more to FreePastry than we were able to illustrate here. However,
    the examples provide a feel for the nature of P2P application development. Other
    P2P frameworks work in a similar manner.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: FreePastry还有很多内容，我们无法在这里详细说明。然而，这些示例提供了P2P应用程序开发性质的感觉。其他P2P框架以类似的方式工作。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the nature and use of P2P networks. This architecture
    treats all nodes as equals avoiding the use of a central server. Nodes are mapped
    using an overlay network, which effectively creates a subnetwork of nodes in an
    IP address space. These nodes will vary in their capabilities and will join and
    leave the network in a random manner.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了P2P网络的性质和用途。这种架构将所有节点视为平等，避免使用中央服务器。节点使用覆盖网络进行映射，有效地在IP地址空间中创建了一个节点的子网络。这些节点的能力各不相同，会以随机的方式加入和离开网络。
- en: We saw how a distributed hash table supports identifying and locating nodes
    in a network. A routing algorithm uses this table to fulfill requests by sending
    messages between nodes. We demonstrated the Java Distributed Hashing Table to
    illustrate the used of DHTs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了分布式哈希表如何支持在网络中识别和定位节点。路由算法使用这个表来通过节点之间的消息传递来满足请求。我们演示了Java分布式哈希表来说明DHT的使用。
- en: There are several open source Java based P2P frameworks available. We used FreePastry
    to demonstrate how P2P networks work. Specifically, we showed you how nodes join
    a network and how messages are sent between nodes. This provided a better understanding
    of how these frameworks function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个基于Java的开源P2P框架可用。我们使用FreePastry来演示P2P网络的工作原理。具体来说，我们向您展示了节点如何加入网络以及消息如何在节点之间发送。这提供了对这些框架如何运作的更好理解。
- en: In the next chapter, we will examine the nature of the UDP protocol and how
    it supports multicasting.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨UDP协议的性质以及它如何支持多播。
